{"files":[{"patch":"@@ -1440,1 +1440,1 @@\n-    if (TemplateAssertionPredicateExpressionNode::valid_opcode(n)) {\n+    if (TemplateAssertionPredicateExpressionNode::is_maybe_in_expression(n)) {\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1640,1 +1640,19 @@\n-  void push( Node *b ) { map(_cnt++,b); }\n+\n+  void push(Node* n) { map(_cnt++, n); }\n+\n+  void push_non_null_cfg_inputs_of(const Node* node) {\n+    for (uint i = 1; i < node->req(); i++) {\n+      Node* input = node->in(i);\n+      if (input != nullptr) {\n+        push(input);\n+      }\n+    }\n+  }\n+\n+  void push_outputs_of(const Node* node) {\n+    for (DUIterator_Fast imax, i = node->fast_outs(imax); i < imax; i++) {\n+      Node* output = node->fast_out(i);\n+      push(output);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-  DataNodesOnPathsToTargets data_nodes_on_path_to_targets(TemplateAssertionPredicateExpressionNode::valid_opcode,\n+  DataNodesOnPathsToTargets data_nodes_on_path_to_targets(TemplateAssertionPredicateExpressionNode::is_maybe_in_expression,\n@@ -337,2 +337,2 @@\n-bool TemplateAssertionPredicateExpressionNode::find_opaque_loop_nodes(Node* node) {\n-  if (valid_opcode(node)) {\n+bool TemplateAssertionPredicateExpressionNode::is_in_expression(Node* node) {\n+  if (is_maybe_in_expression(node)) {\n@@ -346,2 +346,2 @@\n-      } else if (valid_opcode(next)) {\n-        push_non_null_inputs(list, next);\n+      } else if (is_maybe_in_expression(next)) {\n+        list.push_non_null_cfg_inputs_of(next);\n@@ -354,9 +354,0 @@\n-void TemplateAssertionPredicateExpressionNode::push_non_null_inputs(Unique_Node_List& list, const Node* node) {\n-  for (uint i = 1; i < node->req(); i++) {\n-    Node* input = node->in(i);\n-    if (input != nullptr) {\n-      list.push(input);\n-    }\n-  }\n-}\n-\n@@ -366,7 +357,0 @@\n-\n-void TemplateAssertionPredicateExpressionNode::push_outputs(Unique_Node_List& list, const Node* node) {\n-  for (DUIterator_Fast imax, i = node->fast_outs(imax); i < imax; i++) {\n-    Node* out = node->fast_out(i);\n-    list.push(out);\n-  }\n-}\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":5,"deletions":21,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -302,1 +302,1 @@\n-    assert(is_valid(node), \"must be valid\");\n+    assert(is_in_expression(node), \"must be valid\");\n@@ -307,2 +307,0 @@\n-  static bool find_opaque_loop_nodes(Node* node);\n-  static void push_non_null_inputs(Unique_Node_List& list, const Node* node);\n@@ -310,1 +308,0 @@\n-  static void push_outputs(Unique_Node_List& list, const Node* node);\n@@ -314,3 +311,1 @@\n-  static bool is_valid(Node* node) {\n-    return find_opaque_loop_nodes(node);\n-  }\n+  static bool is_in_expression(Node* node);\n@@ -320,1 +315,1 @@\n-  static bool valid_opcode(const Node* node) {\n+  static bool is_maybe_in_expression(const Node* node) {\n@@ -343,2 +338,2 @@\n-  template <class ApplyToTemplateFunction>\n-  void for_each_template_assertion_predicate(ApplyToTemplateFunction apply_to_template_function) {\n+  template <class Callback>\n+  void for_each_template_assertion_predicate(Callback callback) {\n@@ -352,1 +347,1 @@\n-        apply_to_template_function(next->as_If());\n+        callback(next->as_If());\n@@ -356,1 +351,1 @@\n-        push_outputs(list, next);\n+        list.push_outputs_of(next);\n@@ -359,0 +354,6 @@\n+\n+    \/\/ Each node inside a Template Assertion Predicate Expression is in between a Template Assertion Predicate and\n+    \/\/ its OpaqueLoop* nodes (or an OpaqueLoop* node itself). The OpaqueLoop* nodes do not common up. Therefore, each\n+    \/\/ Template Assertion Predicate Expression node belongs to a single expression - except for OpaqueLoopInitNodes.\n+    \/\/ An OpaqueLoopInitNode is shared between the init and last value Template Assertion Predicate at creation.\n+    \/\/ Later, when cloning the expressions, they are no longer shared.\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -418,1 +418,1 @@\n-  if (!TemplateAssertionPredicateExpressionNode::is_valid(node)) {\n+  if (!TemplateAssertionPredicateExpressionNode::is_in_expression(node)) {\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}