{"files":[{"patch":"@@ -1397,34 +1397,0 @@\n-\/\/ Is 'n' a node that can be found on the input chain of a Template Assertion Predicate bool (i.e. between a Template\n-\/\/ Assertion Predicate If node and the OpaqueLoop* nodes)?\n-static bool is_part_of_template_assertion_predicate_bool(Node* n) {\n-  int op = n->Opcode();\n-  return (n->is_Bool() ||\n-          n->is_Cmp() ||\n-          op == Op_AndL ||\n-          op == Op_OrL ||\n-          op == Op_RShiftL ||\n-          op == Op_LShiftL ||\n-          op == Op_LShiftI ||\n-          op == Op_AddL ||\n-          op == Op_AddI ||\n-          op == Op_MulL ||\n-          op == Op_MulI ||\n-          op == Op_SubL ||\n-          op == Op_SubI ||\n-          op == Op_ConvI2L ||\n-          op == Op_CastII);\n-}\n-\n-bool PhaseIdealLoop::subgraph_has_opaque(Node* n) {\n-  if (n->Opcode() == Op_OpaqueLoopInit || n->Opcode() == Op_OpaqueLoopStride) {\n-    return true;\n-  }\n-  if (!is_part_of_template_assertion_predicate_bool(n)) {\n-    return false;\n-  }\n-  uint init;\n-  uint stride;\n-  count_opaque_loop_nodes(n, init, stride);\n-  return init != 0 || stride != 0;\n-}\n-\n@@ -1474,5 +1440,11 @@\n-    if (is_part_of_template_assertion_predicate_bool(n)) {\n-      for (uint j = 1; j < n->req(); j++) {\n-        Node* m = n->in(j);\n-        if (m != nullptr) {\n-          wq.push(m);\n+    if (TemplateAssertionPredicateExpressionNode::is_maybe_in_expression(n)) {\n+      if (n->is_OpaqueLoopInit()) {\n+        init++;\n+      } else if (n->is_OpaqueLoopStride()) {\n+        stride++;\n+      } else {\n+        for (uint j = 1; j < n->req(); j++) {\n+          Node* m = n->in(j);\n+          if (m != nullptr) {\n+            wq.push(m);\n+          }\n@@ -1481,6 +1453,0 @@\n-      continue;\n-    }\n-    if (n->Opcode() == Op_OpaqueLoopInit) {\n-      init++;\n-    } else if (n->Opcode() == Op_OpaqueLoopStride) {\n-      stride++;\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":11,"deletions":45,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -952,1 +952,0 @@\n-  static bool subgraph_has_opaque(Node* n);\n@@ -1757,6 +1756,0 @@\n-  bool clone_cmp_down(Node* n, const Node* blk1, const Node* blk2);\n-\n-  void clone_loadklass_nodes_at_cmp_index(const Node* n, Node* cmp, int i);\n-\n-  bool clone_cmp_loadklass_down(Node* n, const Node* blk1, const Node* blk2);\n-\n@@ -1765,0 +1758,4 @@\n+  bool clone_cmp_loadklass_down(Node* n, const Node* blk1, const Node* blk2);\n+  void clone_loadklass_nodes_at_cmp_index(const Node* n, Node* cmp, int i);\n+  bool clone_cmp_down(Node* n, const Node* blk1, const Node* blk2);\n+  void clone_template_assertion_predicate_expression_down(Node* node);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1640,1 +1640,19 @@\n-  void push( Node *b ) { map(_cnt++,b); }\n+\n+  void push(Node* n) { map(_cnt++, n); }\n+\n+  void push_non_null_cfg_inputs_of(const Node* node) {\n+    for (uint i = 1; i < node->req(); i++) {\n+      Node* input = node->in(i);\n+      if (input != nullptr) {\n+        push(input);\n+      }\n+    }\n+  }\n+\n+  void push_outputs_of(const Node* node) {\n+    for (DUIterator_Fast imax, i = node->fast_outs(imax); i < imax; i++) {\n+      Node* output = node->fast_out(i);\n+      push(output);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-  DataNodesOnPathsToTargets data_nodes_on_path_to_targets(TemplateAssertionPredicateExpression::maybe_contains,\n+  DataNodesOnPathsToTargets data_nodes_on_path_to_targets(TemplateAssertionPredicateExpressionNode::is_maybe_in_expression,\n@@ -335,0 +335,22 @@\n+\n+\/\/ Check if this node belongs a Template Assertion Predicate Expression (including OpaqueLoop* nodes).\n+bool TemplateAssertionPredicateExpressionNode::is_in_expression(Node* node) {\n+  if (is_maybe_in_expression(node)) {\n+    ResourceMark rm;\n+    Unique_Node_List list;\n+    list.push(node);\n+    for (uint i = 0; i < list.size(); i++) {\n+      Node* next = list.at(i);\n+      if (next->is_OpaqueLoopInit() || next->is_OpaqueLoopStride()) {\n+        return true;\n+      } else if (is_maybe_in_expression(next)) {\n+        list.push_non_null_cfg_inputs_of(next);\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool TemplateAssertionPredicateExpressionNode::is_template_assertion_predicate(Node* node) {\n+  return node->is_If() && node->in(1)->is_Opaque4();\n+}\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -286,8 +286,35 @@\n-  \/\/ Is 'n' a node that could be part of a Template Assertion Predicate Expression (i.e. could be found on the input\n-  \/\/ chain of a Template Assertion Predicate Opaque4Node up to and including the OpaqueLoop* nodes)?\n-  static bool maybe_contains(const Node* n) {\n-    const int opcode = n->Opcode();\n-    return (opcode == Op_OpaqueLoopInit ||\n-            opcode == Op_OpaqueLoopStride ||\n-            n->is_Bool() ||\n-            n->is_Cmp() ||\n+  Opaque4Node* clone(Node* new_ctrl, PhaseIdealLoop* phase);\n+  Opaque4Node* clone_and_replace_init(Node* new_init, Node* new_ctrl,PhaseIdealLoop* phase);\n+  Opaque4Node* clone_and_replace_init_and_stride(Node* new_init, Node* new_stride, Node* new_ctrl, PhaseIdealLoop* phase);\n+};\n+\n+\/\/ Class to represent a node being part of a Template Assertion Predicate Expression.\n+\/\/\n+\/\/ The expression itself can belong to no, one, or two Template Assertion Predicates:\n+\/\/ - None: This node is already dead (i.e. we replaced the Bool condition of the Template Assertion Predicate).\n+\/\/ - Two: A OpaqueLoopInitNode could be part of two Template Assertion Predicates.\n+\/\/ - One: In all other cases.\n+class TemplateAssertionPredicateExpressionNode : public StackObj {\n+  Node* const _node;\n+\n+ public:\n+  explicit TemplateAssertionPredicateExpressionNode(Node* node) : _node(node) {\n+    assert(is_in_expression(node), \"must be valid\");\n+  }\n+  NONCOPYABLE(TemplateAssertionPredicateExpressionNode);\n+\n+ private:\n+  static bool is_template_assertion_predicate(Node* node);\n+\n+ public:\n+  \/\/ Check whether the provided node is part of a Template Assertion Predicate Expression or not.\n+  static bool is_in_expression(Node* node);\n+\n+  \/\/ Check if the opcode of node could be found in a Template Assertion Predicate Expression.\n+  \/\/ This also provides a fast check whether a node is unrelated.\n+  static bool is_maybe_in_expression(const Node* node) {\n+    const int opcode = node->Opcode();\n+    return (node->is_OpaqueLoopInit() ||\n+            node->is_OpaqueLoopStride() ||\n+            node->is_Bool() ||\n+            node->is_Cmp() ||\n@@ -309,3 +336,27 @@\n-  Opaque4Node* clone(Node* new_ctrl, PhaseIdealLoop* phase);\n-  Opaque4Node* clone_and_replace_init(Node* new_init, Node* new_ctrl,PhaseIdealLoop* phase);\n-  Opaque4Node* clone_and_replace_init_and_stride(Node* new_init, Node* new_stride, Node* new_ctrl, PhaseIdealLoop* phase);\n+  \/\/ Apply the given function to all Template Assertion Predicates (if any) to which this Template Assertion Predicate\n+  \/\/ Expression Node belongs to.\n+  template <class Callback>\n+  void for_each_template_assertion_predicate(Callback callback) {\n+    ResourceMark rm;\n+    Unique_Node_List list;\n+    list.push(_node);\n+    DEBUG_ONLY(int template_counter = 0;)\n+    for (uint i = 0; i < list.size(); i++) {\n+      Node* next = list.at(i);\n+      if (is_template_assertion_predicate(next)) {\n+        callback(next->as_If());\n+        DEBUG_ONLY(template_counter++;)\n+      } else {\n+        assert(!next->is_CFG(), \"no CFG expected in Template Assertion Predicate Expression\");\n+        list.push_outputs_of(next);\n+      }\n+    }\n+\n+    \/\/ Each node inside a Template Assertion Predicate Expression is in between a Template Assertion Predicate and\n+    \/\/ its OpaqueLoop* nodes (or an OpaqueLoop* node itself). The OpaqueLoop* nodes do not common up. Therefore, each\n+    \/\/ Template Assertion Predicate Expression node belongs to a single expression - except for OpaqueLoopInitNodes.\n+    \/\/ An OpaqueLoopInitNode is shared between the init and last value Template Assertion Predicate at creation.\n+    \/\/ Later, when cloning the expressions, they are no longer shared.\n+    assert(template_counter <= 2, \"a node cannot be part of more than two templates\");\n+    assert(template_counter <= 1 || _node->is_OpaqueLoopInit(), \"only OpaqueLoopInit nodes can be part of two templates\");\n+  }\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":62,"deletions":11,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -98,19 +98,1 @@\n-  if (subgraph_has_opaque(n)) {\n-    Unique_Node_List wq;\n-    wq.push(n);\n-    for (uint i = 0; i < wq.size(); i++) {\n-      Node* m = wq.at(i);\n-      if (m->is_If()) {\n-        assert(assertion_predicate_has_loop_opaque_node(m->as_If()), \"opaque node not reachable from if?\");\n-        TemplateAssertionPredicateExpression template_assertion_predicate_expression(m->in(1)->as_Opaque4());\n-        Opaque4Node* cloned_opaque4_node = template_assertion_predicate_expression.clone(m->in(0), this);\n-        _igvn.replace_input_of(m, 1, cloned_opaque4_node);\n-      } else {\n-        assert(!m->is_CFG(), \"not CFG expected\");\n-        for (DUIterator_Fast jmax, j = m->fast_outs(jmax); j < jmax; j++) {\n-          Node* u = m->fast_out(j);\n-          wq.push(u);\n-        }\n-      }\n-    }\n-  }\n+  clone_template_assertion_predicate_expression_down(n);\n@@ -430,0 +412,21 @@\n+\/\/ 'n' could be a node belonging to a Template Assertion Predicate Expression (i.e. any node between a Template\n+\/\/ Assertion Predicate and its OpaqueLoop* nodes (included)). We cannot simply split this node up since this would\n+\/\/ create a phi node inside the Template Assertion Predicate Expression - making it unrecognizable as such. Therefore,\n+\/\/ we completely clone the entire Template Assertion Predicate Expression \"down\". This ensures that we have an\n+\/\/ untouched copy that is still recognized by the Template Assertion Predicate matching code.\n+void PhaseIdealLoop::clone_template_assertion_predicate_expression_down(Node* node) {\n+  if (!TemplateAssertionPredicateExpressionNode::is_in_expression(node)) {\n+    return;\n+  }\n+\n+  TemplateAssertionPredicateExpressionNode template_assertion_predicate_expression_node(node);\n+  auto clone_expression = [&](IfNode* template_assertion_predicate) {\n+    Opaque4Node* opaque4_node = template_assertion_predicate->in(1)->as_Opaque4();\n+    TemplateAssertionPredicateExpression template_assertion_predicate_expression(opaque4_node);\n+    Node* new_ctrl = template_assertion_predicate->in(0);\n+    Opaque4Node* cloned_opaque4_node = template_assertion_predicate_expression.clone(new_ctrl, this);\n+    igvn().replace_input_of(template_assertion_predicate, 1, cloned_opaque4_node);\n+  };\n+  template_assertion_predicate_expression_node.for_each_template_assertion_predicate(clone_expression);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":22,"deletions":19,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8330004\n+ * @summary Sanity test to exercise code to clone a Template Assertion Predicate down in Split If.\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xcomp -XX:LoopMaxUnroll=0\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestSplitIfCloningDown::*\n+ *                   compiler.predicates.assertion.TestSplitIfCloningDown\n+ *\/\n+\n+\/*\n+ * @test id=no-flags\n+ * @bug 8330004\n+ * @summary Sanity test to exercise code to clone a Template Assertion Predicate down in Split If.\n+ * @run main compiler.predicates.assertion.TestSplitIfCloningDown\n+ *\/\n+\n+package compiler.predicates.assertion;\n+\n+public class TestSplitIfCloningDown {\n+    static int[] iArr = new int[100];\n+    static boolean flag;\n+    static int iFld;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10000; i++) {\n+            testPhiIntoNonOpaqueLoopExpressionNode();\n+            testPhiIntoOpaqueLoopExpressionNode();\n+        }\n+    }\n+\n+\n+    static void testPhiIntoNonOpaqueLoopExpressionNode() {\n+        int zero = 34;\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            zero = 0;\n+        }\n+\n+\n+        for (int t = 0; t < 100; t++) { \/\/ Use outer loop such that OpaqueLoop* will get an earlier ctrl.\n+            iArr = new int[1000];\n+\n+            \/\/ Replaced by CMove which is an input into Template Assertion Predicate Expression which\n+            \/\/ is not an OpaqueLoop* node. Split If will create a phi and tries to split a Template\n+            \/\/ Assertion Predicate Expression node -> Need to clone template down.\n+            int a;\n+            if (flag) {\n+                a = 4;\n+            } else {\n+                a = 3;\n+            }\n+\n+            for (int i = 0; i < 100; i++) {\n+                iArr[i+a] = 34; \/\/ Hoisted with Hoisted Check Predicate and Template Assertion Predicate\n+                if (i * zero < iFld) { \/\/ Unswitched after Split If to check further template cloning.\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test above but this time the phi inputs into an OpaqueLoop* node and not a node in between.\n+    static void testPhiIntoOpaqueLoopExpressionNode() {\n+        int zero = 34;\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            zero = 0;\n+        }\n+\n+        iArr = new int[1000];\n+\n+        \/\/ Replaced by CMove which is an input into Template Assertion Predicate Expression which\n+        \/\/ is not an OpaqueLoop* node. Split If will create a phi and tries to split a Template\n+        \/\/ Assertion Predicate Expression node -> Need to clone template down.\n+        int a;\n+        if (flag) {\n+            a = 4;\n+        } else {\n+            a = 3;\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            iArr[i+a] = 34; \/\/ Hoisted with Hoisted Check Predicate and Template Assertion Predicate\n+            if (i * zero < iFld) { \/\/ Unswitched after Split If to check further template cloning.\n+                return;\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/assertion\/TestSplitIfCloningDown.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"}]}