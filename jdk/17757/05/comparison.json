{"files":[{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/circularStringBuffer.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+\n+\/\/ LogDecorator::None applies to 'constant initialization' because of its constexpr constructor.\n+const LogDecorations& CircularStringBuffer::None = LogDecorations(\n+    LogLevel::Warning, LogTagSetMapping<LogTag::__NO_TAG>::tagset(), LogDecorators::None);\n+\n+const char* allocation_failure_msg = \"Failed to allocate async logging buffer\";\n+\n+#ifdef LINUX\n+CircularMapping::CircularMapping(size_t size)\n+  : size(size) {\n+  assert(is_aligned(size, os::vm_page_size()), \"must be\");\n+  file = tmpfile();\n+  if (file == nullptr) {\n+    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, \"%s\", allocation_failure_msg);\n+  }\n+  const int fd = fileno(file);\n+  if (fd == -1) {\n+    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, \"%s\", allocation_failure_msg);\n+  }\n+  int ret = ftruncate(fd, size);\n+  if (ret != 0) {\n+    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, \"%s\", allocation_failure_msg);\n+  }\n+  buffer = (char*)mmap(nullptr, size * 2, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+  if (buffer == MAP_FAILED) {\n+    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, \"%s\", allocation_failure_msg);\n+  }\n+  void* mmap_ret = mmap(buffer, size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED, fd, 0);\n+  if (mmap_ret == MAP_FAILED) {\n+    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, \"%s\", allocation_failure_msg);\n+  }\n+  mmap_ret = mmap(buffer + size, size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED, fd, 0);\n+  if (mmap_ret == MAP_FAILED) {\n+    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, \"%s\", allocation_failure_msg);\n+  }\n+\n+  \/\/ Success, notify NMT.\n+  MemTracker::record_virtual_memory_reserve(buffer, size, CURRENT_PC, mtLogging);\n+  MemTracker::record_virtual_memory_commit(buffer, size, CURRENT_PC);\n+}\n+#else\n+CircularMapping::CircularMapping(size_t size)\n+  : buffer(nullptr),\n+    size(size) {\n+  buffer = os::reserve_memory(size, false, mtLogging);\n+  if (buffer == nullptr) {\n+    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, \"%s\", allocation_failure_msg);\n+  }\n+  bool ret = os::commit_memory(buffer, size, false);\n+  if (!ret) {\n+    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, \"%s\", allocation_failure_msg);\n+  }\n+}\n+#endif \/\/ LINUX\n+\n+\n+CircularStringBuffer::CircularStringBuffer(StatisticsMap& map, PlatformMonitor& stats_lock, size_t size, bool should_stall)\n+  : _should_stall(should_stall),\n+    _stats(map),\n+    _stats_lock(stats_lock),\n+    circular_mapping(size),\n+    _tail(0),\n+    _head(0) {}\n+\n+size_t CircularStringBuffer::allocated_bytes() {\n+  size_t h = Atomic::load(&_head);\n+  size_t t = Atomic::load(&_tail);\n+  if (h <= t) {\n+    return t - h;\n+  } else {\n+    return circular_mapping.size - (h - t);\n+  }\n+}\n+size_t CircularStringBuffer::available_bytes() {\n+  return circular_mapping.size - allocated_bytes();\n+}\n+\n+size_t CircularStringBuffer::calculate_bytes_needed(size_t sz) {\n+  return align_up(sz, alignof(Message));\n+}\n+\n+\/\/ Size including NUL byte\n+void CircularStringBuffer::enqueue_locked(const char* str, size_t size, LogFileStreamOutput* output,\n+                                   const LogDecorations decorations) {\n+  const size_t required_memory = calculate_bytes_needed(size);\n+\n+#ifdef ASSERT\n+  size_t unused = this->available_bytes();\n+  \/\/ We need space for an additional Message in case of a flush token\n+  assert(!(output == nullptr) || unused >= sizeof(Message), \"invariant\");\n+#endif\n+\n+  auto not_enough_memory = [&]() {\n+    return this->available_bytes() < (required_memory + sizeof(Message)*(output == nullptr ? 1 : 2));\n+  };\n+\n+  if (not_enough_memory()) {\n+    if (_should_stall) {\n+      Thread* thread = Thread::current_or_null();\n+      if (thread != nullptr && thread->is_Java_thread()) {\n+        ThreadBlockInVM tbivm(JavaThread::cast(thread));\n+        ConsumerLocker cl(this);\n+        while (not_enough_memory()) {\n+          _consumer_lock.wait(0);\n+        }\n+      } else {\n+        ConsumerLocker cl(this);\n+        while (not_enough_memory()) {\n+          _consumer_lock.wait(0);\n+        }\n+      }\n+    } else {\n+      _stats_lock.lock();\n+      bool p_created;\n+      uint32_t* counter = _stats.put_if_absent(output, 0, &p_created);\n+      *counter = *counter + 1;\n+      _stats_lock.unlock();\n+      return;\n+    }\n+  }\n+  \/\/ Load the tail.\n+  size_t t = _tail;\n+  \/\/ Write the Message\n+  Message msg{required_memory, output, decorations};\n+  circular_mapping.write_bytes(t, (char*)&msg, sizeof(Message));\n+  \/\/ Move t forward\n+  t = (t +  sizeof(Message)) % circular_mapping.size;\n+  \/\/ Write the string\n+  circular_mapping.write_bytes(t, str, size);\n+  \/\/ Finally move the tail, making the message available for consumers.\n+  Atomic::store(&_tail, (t + required_memory) % circular_mapping.size);\n+  \/\/ We're done, notify a potentially awaiting consumer.\n+  _consumer_lock.notify();\n+  return;\n+}\n+\n+void CircularStringBuffer::enqueue(const char* msg, size_t size, LogFileStreamOutput* output,\n+                                   const LogDecorations decorations) {\n+  ProducerLocker pl(this);\n+  enqueue_locked(msg, size, output, decorations);\n+}\n+\n+void CircularStringBuffer::enqueue(LogFileStreamOutput& output, LogMessageBuffer::Iterator msg_iterator) {\n+  ProducerLocker pl(this);\n+  for (; !msg_iterator.is_at_end(); msg_iterator++) {\n+    const char* str = msg_iterator.message();\n+    size_t len = strlen(str);\n+    enqueue_locked(str, len+1, &output, msg_iterator.decorations());\n+  }\n+}\n+\n+CircularStringBuffer::DequeueResult CircularStringBuffer::dequeue(Message* out_msg, char* out, size_t out_size) {\n+  ConsumerLocker cl(this);\n+\n+  size_t h = _head;\n+  size_t t = _tail;\n+  \/\/ Check if there's something to read\n+  if (h == t) {\n+    return NoMessage;\n+  }\n+\n+  \/\/ Read the message\n+  circular_mapping.read_bytes(h, (char*)out_msg, sizeof(Message));\n+  const size_t str_size = out_msg->size;\n+  if (str_size > out_size) {\n+    \/\/ Not enough space\n+    return TooSmall;\n+  }\n+  \/\/ Move h forward\n+  h = (h + sizeof(Message)) % circular_mapping.size;\n+\n+  \/\/ Now read the string\n+  circular_mapping.read_bytes(h, out, str_size);\n+  \/\/ Done, move the head forward\n+  Atomic::store(&_head, (h + out_msg->size) % circular_mapping.size);\n+  \/\/ Notify a producer that more memory is available\n+  _consumer_lock.notify();\n+  \/\/ Release the lock\n+  return OK;\n+}\n+\n+void CircularStringBuffer::flush() {\n+  enqueue(\"\", 0, nullptr, CircularStringBuffer::None);\n+  _consumer_lock.notify();\n+  _flush_sem.wait();\n+}\n+\n+void CircularStringBuffer::signal_flush() {\n+  _flush_sem.signal();\n+}\n+\n+bool CircularStringBuffer::maybe_has_message() {\n+  size_t h = Atomic::load(&_head);\n+  size_t t = Atomic::load(&_tail);\n+  return !(h == t);\n+}\n+\n+void CircularStringBuffer::await_message() {\n+  while (true) {\n+    ConsumerLocker cl(this);\n+    while (_head == _tail) {\n+      _consumer_lock.wait(0 \/* no timeout *\/);\n+    }\n+    break;\n+  }\n+}\n","filename":"src\/hotspot\/share\/logging\/circularStringBuffer.cpp","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_LOGGING_CIRCULARSTRINGBUFFER_HPP\n+#define SHARE_LOGGING_CIRCULARSTRINGBUFFER_HPP\n+#include \"logging\/logFileStreamOutput.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/semaphore.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+#include <string.h>\n+#ifdef LINUX\n+#include <sys\/mman.h>\n+#endif\n+\n+\/\/ The CircularMapping is a struct that provides\n+\/\/ an interface for writing and reading bytes in a circular buffer\n+\/\/ correctly. This indirection is necessary because there are two\n+\/\/ underlying implementations: Linux, and all others.\n+#ifdef LINUX\n+\/\/ Implements a circular buffer by using the virtual memory mapping facilities of the OS.\n+\/\/ Specifically, it reserves virtual memory with twice the size of the requested buffer.\n+\/\/ The latter half of this buffer is then mapped back to the start of the first buffer.\n+\/\/ This allows for write_bytes and read_bytes to consist of a single memcpy, as the\n+\/\/ wrap-around is dealt with by the virtual memory system.\n+struct CircularMapping {\n+  FILE* file;\n+  char* buffer;\n+  size_t size;\n+\n+  CircularMapping()\n+  : file(nullptr), buffer(nullptr), size(0) {\n+  };\n+\n+  CircularMapping(size_t size);\n+  ~CircularMapping() {\n+    ::munmap(buffer, size * 2);\n+    ::fclose(file);\n+  }\n+\n+  void write_bytes(size_t at, const char* bytes, size_t size) {\n+    ::memcpy(&buffer[at], bytes, size);\n+  }\n+\n+  void read_bytes(size_t at, char* out, size_t size) {\n+    ::memcpy(out, &buffer[at], size);\n+  }\n+};\n+#else\n+\/\/ On other platforms we resort to a double memcpy.\n+struct CircularMapping {\n+  char* buffer;\n+  size_t size;\n+  CircularMapping()\n+  : buffer(nullptr), size(0) {\n+  };\n+  CircularMapping(size_t size);\n+\n+  void write_bytes(size_t at, const char* bytes, size_t size) {\n+    const size_t part1_size = MIN2(size, this->size - at);\n+    const size_t part2_size = size - part1_size;\n+\n+    ::memcpy(&buffer[at], bytes, part1_size);\n+    ::memcpy(buffer, &bytes[part1_size], part2_size);\n+  }\n+\n+  void read_bytes(size_t at, char* out, size_t size) {\n+    const size_t part1_size = MIN2(size, this->size - at);\n+    const size_t part2_size = size - part1_size;\n+\n+    ::memcpy(out, &buffer[at], part1_size);\n+    ::memcpy(&out[part1_size], buffer, part2_size);\n+  }\n+\n+  ~CircularMapping() {\n+    os::release_memory(buffer, size);\n+  }\n+};\n+#endif\n+\n+class CircularStringBuffer {\n+  friend class AsyncLogTest;\n+\n+public:\n+    \/\/ account for dropped messages\n+  using StatisticsMap = ResourceHashtable<LogFileStreamOutput*, uint32_t, 17, \/*table_size*\/\n+                                        AnyObj::C_HEAP, mtLogging>;\n+private:\n+  static const LogDecorations& None;\n+  const bool _should_stall; \/\/ Should a producer stall until a consumer has made room for its message?\n+\n+  \/\/ Need to perform accounting of statistics under a separate lock.\n+  StatisticsMap& _stats;\n+  PlatformMonitor& _stats_lock;\n+\n+  \/\/ Can't use a Monitor here as we need a low-level API that can be used without Thread::current().\n+  \/\/ The consumer lock's condition variable is used for communicating when messages are produced and consumed.\n+  PlatformMonitor _consumer_lock;\n+  PlatformMonitor _producer_lock;\n+  Semaphore _flush_sem;\n+\n+  struct ConsumerLocker : public StackObj {\n+    CircularStringBuffer* buf;\n+    ConsumerLocker(CircularStringBuffer* buf) : buf(buf) {\n+      buf->_consumer_lock.lock();\n+    }\n+    ~ConsumerLocker() {\n+      buf->_consumer_lock.unlock();\n+    }\n+  };\n+  struct ProducerLocker : public StackObj {\n+    CircularStringBuffer* buf;\n+    ProducerLocker(CircularStringBuffer* buf) : buf(buf) {\n+      buf->_producer_lock.lock();\n+    }\n+    ~ProducerLocker() {\n+      buf->_producer_lock.unlock();\n+    }\n+  };\n+  \/\/ Opaque circular mapping of our buffer.\n+  CircularMapping circular_mapping;\n+\n+  \/\/ Shared memory:\n+  \/\/ Consumer reads tail, writes to head.\n+  \/\/ Producer reads head, writes to tail.\n+  volatile size_t _tail; \/\/ Where new writes happen\n+  volatile size_t _head; \/\/ Where new reads happen\n+\n+  size_t allocated_bytes();\n+  size_t available_bytes();\n+  \/\/ How many bytes are needed to store a message of size sz?\n+  size_t calculate_bytes_needed(size_t sz);\n+\n+public:\n+  \/\/ Messsage is the header of a log line and contains its associated decorations and output.\n+  \/\/ It is directly followed by the c-str of the log line. The log line is padded at the end\n+  \/\/ to ensure correct alignment for the Message. A Message is considered to be a flush token\n+  \/\/ when its output is null.\n+  \/\/\n+  \/\/ Example layout:\n+  \/\/ ---------------------------------------------\n+  \/\/ |_output|_decorations|\"a log line\", |pad| <- Message aligned.\n+  \/\/ |_output|_decorations|\"yet another\",|pad|\n+  \/\/ ...\n+  \/\/ |nullptr|_decorations|\"\",|pad| <- flush token\n+  \/\/ |<- _pos\n+  \/\/ ---------------------------------------------\n+  struct Message {\n+    size_t size; \/\/ Size of string following the Message envelope\n+    LogFileStreamOutput* const output;\n+    const LogDecorations decorations;\n+    Message(size_t size, LogFileStreamOutput* output, const LogDecorations decorations)\n+    : size(size), output(output), decorations(decorations) {\n+    }\n+\n+    Message()\n+    : size(0), output(nullptr), decorations(None) {\n+    }\n+\n+    bool is_token() {\n+      return output == nullptr;\n+    }\n+  };\n+\n+private:\n+  void enqueue_locked(const char* msg, size_t size, LogFileStreamOutput* output, const LogDecorations decorations);\n+\n+public:\n+  NONCOPYABLE(CircularStringBuffer);\n+  CircularStringBuffer(StatisticsMap& stats, PlatformMonitor& stats_lock, size_t size, bool should_stall = false);\n+\n+  void enqueue(const char* msg, size_t size, LogFileStreamOutput* output,\n+               const LogDecorations decorations);\n+  void enqueue(LogFileStreamOutput& output, LogMessageBuffer::Iterator msg_iterator);\n+\n+  enum DequeueResult {\n+    NoMessage, \/\/ There was no message in the buffer\n+    TooSmall,  \/\/ The provided out buffer is too small\n+    OK         \/\/ A message was found and copied over to the out buffer and out_message.\n+  };\n+  DequeueResult dequeue(Message* out_message, char* out, size_t out_size);\n+\n+  \/\/ Await flushing, blocks until signal_flush() is called by the flusher.\n+  void flush();\n+  void signal_flush();\n+\n+  bool maybe_has_message();\n+  void await_message();\n+};\n+\n+#endif \/\/ SHARE_LOGGING_CIRCULARSTRINGBUFFER_HPP\n","filename":"src\/hotspot\/share\/logging\/circularStringBuffer.hpp","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,53 +35,0 @@\n-class AsyncLogWriter::AsyncLogLocker : public StackObj {\n- public:\n-  AsyncLogLocker() {\n-    assert(_instance != nullptr, \"AsyncLogWriter::_lock is unavailable\");\n-    _instance->_lock.lock();\n-  }\n-\n-  ~AsyncLogLocker() {\n-    _instance->_lock.unlock();\n-  }\n-};\n-\n-\/\/ LogDecorator::None applies to 'constant initialization' because of its constexpr constructor.\n-const LogDecorations& AsyncLogWriter::None = LogDecorations(LogLevel::Warning, LogTagSetMapping<LogTag::__NO_TAG>::tagset(),\n-                                      LogDecorators::None);\n-\n-bool AsyncLogWriter::Buffer::push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg) {\n-  const size_t len = strlen(msg);\n-  const size_t sz = Message::calc_size(len);\n-  const bool is_token = output == nullptr;\n-  \/\/ Always leave headroom for the flush token. Pushing a token must succeed.\n-  const size_t headroom = (!is_token) ? Message::calc_size(0) : 0;\n-\n-  if (_pos + sz <= (_capacity - headroom)) {\n-    new(_buf + _pos) Message(output, decorations, msg, len);\n-    _pos += sz;\n-    return true;\n-  }\n-\n-  return false;\n-}\n-\n-void AsyncLogWriter::Buffer::push_flush_token() {\n-  bool result = push_back(nullptr, AsyncLogWriter::None, \"\");\n-  assert(result, \"fail to enqueue the flush token.\");\n-}\n-\n-void AsyncLogWriter::enqueue_locked(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg) {\n-  \/\/ To save space and streamline execution, we just ignore null message.\n-  \/\/ client should use \"\" instead.\n-  assert(msg != nullptr, \"enqueuing a null message!\");\n-\n-  if (!_buffer->push_back(output, decorations, msg)) {\n-    bool p_created;\n-    uint32_t* counter = _stats.put_if_absent(output, 0, &p_created);\n-    *counter = *counter + 1;\n-    return;\n-  }\n-\n-  _data_available = true;\n-  _lock.notify();\n-}\n-\n@@ -89,2 +36,2 @@\n-  AsyncLogLocker locker;\n-  enqueue_locked(&output, decorations, msg);\n+  size_t size = strlen(msg);\n+  _circular_buffer.enqueue(msg, size+1, &output, decorations);\n@@ -96,5 +43,1 @@\n-  AsyncLogLocker locker;\n-\n-  for (; !msg_iterator.is_at_end(); msg_iterator++) {\n-    enqueue_locked(&output, msg_iterator.decorations(), msg_iterator.message());\n-  }\n+  _circular_buffer.enqueue(output, msg_iterator);\n@@ -103,4 +46,6 @@\n-AsyncLogWriter::AsyncLogWriter()\n-  : _flush_sem(0), _lock(), _data_available(false),\n-    _initialized(false),\n-    _stats() {\n+AsyncLogWriter::AsyncLogWriter(bool should_stall)\n+:\n+  _stats_lock(),\n+  _stats(),\n+  _circular_buffer(_stats, _stats_lock, align_up(AsyncLogBufferSize, os::vm_page_size()), should_stall),\n+  _initialized(false) {\n@@ -108,4 +53,1 @@\n-  size_t size = AsyncLogBufferSize \/ 2;\n-  _buffer = new Buffer(size);\n-  _buffer_staging = new Buffer(size);\n-  log_info(logging)(\"AsyncLogBuffer estimates memory use: \" SIZE_FORMAT \" bytes\", size * 2);\n+  log_info(logging)(\"AsyncLogBuffer estimates memory use: \" SIZE_FORMAT \" bytes\", align_up(AsyncLogBufferSize, os::vm_page_size()));\n@@ -119,1 +61,2 @@\n-void AsyncLogWriter::write(AsyncLogMap<AnyObj::RESOURCE_AREA>& snapshot) {\n+bool AsyncLogWriter::write(AsyncLogMap<AnyObj::RESOURCE_AREA>& snapshot,\n+                           char* write_buffer, size_t write_buffer_size) {\n@@ -121,3 +64,9 @@\n-  auto it = _buffer_staging->iterator();\n-  while (it.hasNext()) {\n-    const Message* e = it.next();\n+  CircularStringBuffer::Message msg;\n+  while (_circular_buffer.maybe_has_message()) {\n+    using DequeueResult = CircularStringBuffer::DequeueResult;\n+    DequeueResult result = _circular_buffer.dequeue(&msg, write_buffer, write_buffer_size);\n+    assert(result != DequeueResult::NoMessage, \"Race detected but there is only one reading thread\");\n+    if (result == DequeueResult::TooSmall) {\n+      \/\/ Need a larger buffer\n+      return false;\n+    }\n@@ -125,2 +74,2 @@\n-    if (!e->is_token()){\n-      e->output()->write_blocking(e->decorations(), e->message());\n+    if (!msg.is_token()) {\n+      msg.output->write_blocking(msg.decorations, write_buffer);\n@@ -147,1 +96,1 @@\n-    _flush_sem.signal(req);\n+    _circular_buffer.signal_flush();\n@@ -149,0 +98,1 @@\n+  return true;\n@@ -152,0 +102,4 @@\n+  \/\/ 16KiB ought to be enough.\n+  size_t write_buffer_size = 16 * 1024;\n+  char* write_buffer = NEW_C_HEAP_ARRAY(char, write_buffer_size, mtLogging);\n+\n@@ -155,0 +109,3 @@\n+    _circular_buffer.await_message();\n+\n+    \/\/ move counters to snapshot and reset them.\n@@ -156,12 +113,2 @@\n-      AsyncLogLocker locker;\n-\n-      while (!_data_available) {\n-        _lock.wait(0\/* no timeout *\/);\n-      }\n-      \/\/ Only doing a swap and statistics under the lock to\n-      \/\/ guarantee that I\/O jobs don't block logsites.\n-      _buffer_staging->reset();\n-      swap(_buffer, _buffer_staging);\n-\n-      \/\/ move counters to snapshot and reset them.\n-      _stats.iterate([&] (LogFileStreamOutput* output, uint32_t& counter) {\n+      _stats_lock.lock();\n+      _stats.iterate([&](LogFileStreamOutput* output, uint32_t& counter) {\n@@ -175,1 +122,8 @@\n-      _data_available = false;\n+      _stats_lock.unlock();\n+    }\n+    bool success = write(snapshot, write_buffer, write_buffer_size);\n+    if (!success) {\n+      \/\/ Buffer was too small, double it.\n+      FREE_C_HEAP_ARRAY(char, write_buffer);\n+      write_buffer_size *= 2;\n+      write_buffer = NEW_C_HEAP_ARRAY(char, write_buffer_size, mtLogging);\n@@ -177,1 +131,0 @@\n-    write(snapshot);\n@@ -188,1 +141,1 @@\n-  AsyncLogWriter* self = new AsyncLogWriter();\n+  AsyncLogWriter* self = new AsyncLogWriter(LogConfiguration::async_mode() == LogConfiguration::AsyncMode::Stall);\n@@ -214,33 +167,1 @@\n-    {\n-      AsyncLogLocker locker;\n-      \/\/ Push directly in-case we are at logical max capacity, as this must not get dropped.\n-      _instance->_buffer->push_flush_token();\n-      _instance->_data_available = true;\n-      _instance->_lock.notify();\n-    }\n-\n-    _instance->_flush_sem.wait();\n-  }\n-}\n-\n-AsyncLogWriter::BufferUpdater::BufferUpdater(size_t newsize) {\n-  AsyncLogLocker locker;\n-  auto p = AsyncLogWriter::_instance;\n-\n-  _buf1 = p->_buffer;\n-  _buf2 = p->_buffer_staging;\n-  p->_buffer = new Buffer(newsize);\n-  p->_buffer_staging = new Buffer(newsize);\n-}\n-\n-AsyncLogWriter::BufferUpdater::~BufferUpdater() {\n-  AsyncLogWriter::flush();\n-  auto p = AsyncLogWriter::_instance;\n-\n-  {\n-    AsyncLogLocker locker;\n-\n-    delete p->_buffer;\n-    delete p->_buffer_staging;\n-    p->_buffer = _buf1;\n-    p->_buffer_staging = _buf2;\n+    _instance->_circular_buffer.flush();\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":45,"deletions":124,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"logging\/circularStringBuffer.hpp\"\n@@ -65,4 +66,3 @@\n-  template <AnyObj::allocation_type ALLOC_TYPE>\n-  using AsyncLogMap = ResourceHashtable<LogFileStreamOutput*,\n-                          uint32_t, 17, \/*table_size*\/\n-                          ALLOC_TYPE, mtLogging>;\n+  template<AnyObj::allocation_type ALLOC_TYPE>\n+  using AsyncLogMap = ResourceHashtable<LogFileStreamOutput*, uint32_t, 17, \/*table_size*\/\n+                                        ALLOC_TYPE, mtLogging>;\n@@ -70,91 +70,0 @@\n-  \/\/ Messsage is the envelope of a log line and its associative data.\n-  \/\/ Its length is variable because of the zero-terminated c-str. It is only valid when we create it using placement new\n-  \/\/ within a buffer.\n-  \/\/\n-  \/\/ Example layout:\n-  \/\/ ---------------------------------------------\n-  \/\/ |_output|_decorations|\"a log line\", |pad| <- Message aligned.\n-  \/\/ |_output|_decorations|\"yet another\",|pad|\n-  \/\/ ...\n-  \/\/ |nullptr|_decorations|\"\",|pad| <- flush token\n-  \/\/ |<- _pos\n-  \/\/ ---------------------------------------------\n-  class Message {\n-    NONCOPYABLE(Message);\n-    ~Message() = delete;\n-    LogFileStreamOutput* const _output;\n-    const LogDecorations _decorations;\n-   public:\n-    \/\/ msglen excludes NUL-byte\n-    Message(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg, const size_t msglen)\n-      : _output(output), _decorations(decorations) {\n-      assert(msg != nullptr, \"c-str message can not be null!\");\n-      memcpy(reinterpret_cast<char* >(this+1), msg, msglen + 1);\n-    }\n-\n-    \/\/ Calculate the size for a prospective Message object depending on its message length including the trailing zero\n-    static constexpr size_t calc_size(size_t message_len) {\n-      return align_up(sizeof(Message) + message_len + 1, alignof(Message));\n-    }\n-\n-    size_t size() const {\n-      return calc_size(strlen(message()));\n-    }\n-\n-    inline bool is_token() const { return _output == nullptr; }\n-    LogFileStreamOutput* output() const { return _output; }\n-    const LogDecorations& decorations() const { return _decorations; }\n-    const char* message() const { return reinterpret_cast<const char *>(this+1); }\n-  };\n-\n-  class Buffer : public CHeapObj<mtLogging> {\n-    char* _buf;\n-    size_t _pos;\n-    const size_t _capacity;\n-\n-   public:\n-    Buffer(size_t capacity) :  _pos(0), _capacity(capacity) {\n-      _buf = NEW_C_HEAP_ARRAY(char, capacity, mtLogging);\n-      \/\/ Ensure _pos is Message-aligned\n-      _pos = align_up(_buf, alignof(Message)) - _buf;\n-      assert(capacity >= Message::calc_size(0), \"capcity must be great a token size\");\n-    }\n-\n-    ~Buffer() {\n-      FREE_C_HEAP_ARRAY(char, _buf);\n-    }\n-\n-    void push_flush_token();\n-    bool push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg);\n-\n-    void reset() {\n-      \/\/ Ensure _pos is Message-aligned\n-      _pos = align_up(_buf, alignof(Message)) - _buf;\n-    }\n-\n-    class Iterator {\n-      const Buffer& _buf;\n-      size_t _curr;\n-\n-    public:\n-      Iterator(const Buffer& buffer): _buf(buffer), _curr(0) {}\n-\n-      bool hasNext() const {\n-        return _curr < _buf._pos;\n-      }\n-\n-      const Message* next() {\n-        assert(hasNext(), \"sanity check\");\n-        auto msg = reinterpret_cast<Message*>(_buf._buf + _curr);\n-        _curr = MIN2(_curr + msg->size(), _buf._pos);\n-        return msg;\n-      }\n-    };\n-\n-    Iterator iterator() const {\n-      return Iterator(*this);\n-    }\n-  };\n-\n-  static AsyncLogWriter* _instance;\n-  Semaphore _flush_sem;\n@@ -162,3 +71,1 @@\n-  PlatformMonitor _lock;\n-  bool _data_available;\n-  volatile bool _initialized;\n+  PlatformMonitor _stats_lock;\n@@ -167,3 +74,1 @@\n-  \/\/ ping-pong buffers\n-  Buffer* _buffer;\n-  Buffer* _buffer_staging;\n+  CircularStringBuffer _circular_buffer;\n@@ -171,1 +76,2 @@\n-  static const LogDecorations& None;\n+  static AsyncLogWriter* _instance;\n+  volatile bool _initialized;\n@@ -173,1 +79,1 @@\n-  AsyncLogWriter();\n+  AsyncLogWriter(bool should_stall);\n@@ -175,1 +81,1 @@\n-  void write(AsyncLogMap<AnyObj::RESOURCE_AREA>& snapshot);\n+  bool write(AsyncLogMap<AnyObj::RESOURCE_AREA>& snapshot, char* write_buffer, size_t write_buffer_size);\n@@ -188,10 +94,0 @@\n-  \/\/ for testing-only\n-  class BufferUpdater {\n-    Buffer* _buf1;\n-    Buffer* _buf2;\n-\n-   public:\n-    BufferUpdater(size_t newsize);\n-    ~BufferUpdater();\n-  };\n-\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":11,"deletions":115,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -640,1 +640,1 @@\n-  out->print_cr(\" -Xlog:async\");\n+  out->print_cr(\" -Xlog:async[:[mode]]\");\n@@ -644,0 +644,4 @@\n+  out->print_cr(\" A mode, either 'drop' or 'stall', may be provided. If 'drop' is provided then\"\n+                \" messages will be dropped if there is no room in the intermediate buffer,\"\n+                \" if 'stall' is provided then the log operation will wait for room to be made by the output thread.\"\n+                \" The default mode is 'drop'.\");\n@@ -719,1 +723,1 @@\n-bool LogConfiguration::_async_mode = false;\n+LogConfiguration::AsyncMode LogConfiguration::_async_mode = AsyncMode::Off;\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -65,1 +65,7 @@\n-  static bool                       _async_mode;\n+\n+ public:\n+  enum class AsyncMode {\n+    Off, Drop, Stall\n+  };\n+ private:\n+  static AsyncMode _async_mode;\n@@ -132,3 +138,4 @@\n-  static bool is_async_mode() { return _async_mode; }\n-  static void set_async_mode(bool value) {\n-    _async_mode = value;\n+  static AsyncMode async_mode() { return _async_mode; }\n+  static bool is_async_mode() { return _async_mode != AsyncMode::Off; }\n+  static void set_async_mode(AsyncMode mode) {\n+    _async_mode = mode;\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.hpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2597,2 +2597,1 @@\n-      } else if (strcmp(tail, \":async\") == 0) {\n-        LogConfiguration::set_async_mode(true);\n+      } else if (strncmp(tail, \":async\", strlen(\":async\")) == 0) {\n@@ -2600,0 +2599,12 @@\n+        const char* async_tail = tail + strlen(\":async\");\n+        if (strcmp(async_tail, \":stall\") == 0) {\n+          LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Stall);\n+        } else if (strcmp(async_tail, \":drop\") == 0) {\n+          LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Drop);\n+        } else if (*async_tail == '\\0') {\n+          \/\/ Default is to drop.\n+          LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Drop);\n+        } else {\n+          \/\/ User provided unknown async option\n+          ret = false;\n+        }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"logTestFixture.hpp\"\n+#include \"logTestUtils.inline.hpp\"\n@@ -31,2 +33,0 @@\n-#include \"logTestFixture.hpp\"\n-#include \"logTestUtils.inline.hpp\"\n@@ -36,1 +36,4 @@\n- public:\n+public:\n+  \/\/ msg is 128 bytes.\n+  const char* large_message = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                              \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n@@ -38,1 +41,1 @@\n-    if(!LogConfiguration::is_async_mode()) {\n+    if (!LogConfiguration::is_async_mode()) {\n@@ -42,14 +45,0 @@\n-\n-  void test_asynclog_ls() {\n-    LogStream ls(Log(logging)::info());\n-    outputStream* os = &ls;\n-    os->print_cr(\"LogStreamWithAsyncLogImpl\");\n-    os->print_cr(\"LogStreamWithAsyncLogImpl secondline\");\n-\n-    \/\/multi-lines\n-    os->print(\"logStream msg1-\");\n-    os->print(\"msg2-\");\n-    os->print(\"msg3\\n\");\n-    os->print_cr(\"logStream newline\");\n-  }\n-\n@@ -59,1 +48,1 @@\n-LOG_LEVEL_LIST\n+    LOG_LEVEL_LIST\n@@ -72,3 +61,0 @@\n-  \/\/ Caveat: BufferUpdater is not MT-safe. We use it only for testing.\n-  \/\/ We would observe missing loglines if we interleaved buffers.\n-  \/\/ Emit all logs between constructor and destructor of BufferUpdater.\n@@ -76,4 +62,1 @@\n-    const size_t sz = 2000;\n-\n-    \/\/ shrink async buffer.\n-    AsyncLogWriter::BufferUpdater saver(1024);\n+    \/\/ Write more messages than available in buffer.\n@@ -81,0 +64,1 @@\n+    const size_t msg_number = AsyncLogBufferSize \/ strlen(large_message);\n@@ -82,4 +66,3 @@\n-\n-    \/\/ write more messages than its capacity in burst\n-    for (size_t i = 0; i < sz; ++i) {\n-      lm.debug(\"a lot of log...\");\n+    \/\/ + 5 to go past the buffer size, forcing it to drop the message.\n+    for (size_t i = 0; i < (msg_number + 5); i++) {\n+      lm.debug(\"%s\", large_message);\n@@ -90,0 +73,12 @@\n+  void test_asynclog_ls() {\n+    LogStream ls(Log(logging)::info());\n+    outputStream* os = &ls;\n+    os->print_cr(\"LogStreamWithAsyncLogImpl\");\n+    os->print_cr(\"LogStreamWithAsyncLogImpl secondline\");\n+\n+    \/\/multi-lines\n+    os->print(\"logStream msg1-\");\n+    os->print(\"msg2-\");\n+    os->print(\"msg3\\n\");\n+    os->print_cr(\"logStream newline\");\n+  }\n@@ -102,1 +97,2 @@\n-};\n+  template<typename F>\n+  void test_stdout_or_stderr(const char* mode, F get_captured_string) {\n@@ -104,2 +100,3 @@\n-TEST_VM_F(AsyncLogTest, asynclog) {\n-  set_log_config(TestLogFileName, \"logging=debug\");\n+    if (!set_log_config(mode, \"logging=debug\")) {\n+      return;\n+    }\n@@ -107,3 +104,7 @@\n-  test_asynclog_ls();\n-  test_asynclog_raw();\n-  AsyncLogWriter::flush();\n+    bool async = AsyncLogWriter::instance() != nullptr;\n+    if (async) {\n+      test_asynclog_drop_messages();\n+      AsyncLogWriter::flush();\n+    } else {\n+      test_asynclog_ls();\n+    }\n@@ -111,3 +112,4 @@\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"LogStreamWithAsyncLogImpl\"));\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream msg1-msg2-msg3\"));\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream newline\"));\n+    fflush(nullptr);\n+    if (!write_to_file(get_captured_string())) {\n+      return;\n+    }\n@@ -115,5 +117,3 @@\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Debug\"));\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Info\"));\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Warning\"));\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Error\"));\n-  EXPECT_FALSE(file_contains_substring(TestLogFileName, \"1Trace\")); \/\/ trace message is masked out\n+    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"LogStreamWithAsyncLogImpl\"));\n+    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream msg1-msg2-msg3\"));\n+    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream newline\"));\n@@ -121,4 +121,29 @@\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"AsyncLogTarget.print = 1\"));\n-  EXPECT_FALSE(file_contains_substring(TestLogFileName, \"log_trace-test\")); \/\/ trace message is masked out\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"log_debug-test\"));\n-}\n+    if (async) {\n+      EXPECT_TRUE(\n+          file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n+    }\n+  }\n+  void test_room_for_flush() {\n+    PlatformMonitor lock; \/\/ For statistics\n+    CircularStringBuffer::StatisticsMap map;\n+    CircularStringBuffer cb(map, lock, os::vm_page_size());\n+    const size_t count = (cb.circular_mapping.size \/ (strlen(large_message)+1 + sizeof(CircularStringBuffer::Message))) - 1;\n+    stringStream ss;\n+    ss.print(\"file=%s\", TestLogFileName);\n+    LogFileOutput out(ss.freeze());\n+    for (size_t i = 0; i < count; i++) {\n+      cb.enqueue_locked(large_message, strlen(large_message), &out, CircularStringBuffer::None);\n+    }\n+    unsigned int* missing = map.get(&out);\n+    EXPECT_TRUE(missing == nullptr);\n+    cb.enqueue_locked(large_message, strlen(large_message), &out, CircularStringBuffer::None);\n+    cb.enqueue_locked(large_message, strlen(large_message), &out, CircularStringBuffer::None);\n+    missing = map.get(&out);\n+    EXPECT_TRUE(missing !=nullptr && *missing > 0);\n+    size_t old_tail = cb._tail;\n+    cb.enqueue_locked(nullptr, 0, nullptr, CircularStringBuffer::None);\n+    EXPECT_TRUE(cb._tail != old_tail);\n+    unsigned int* new_missing = map.get(&out);\n+    EXPECT_TRUE(new_missing != nullptr && *missing == *new_missing);\n+  }\n+};\n@@ -147,1 +172,0 @@\n-  LogMessageBuffer buffer;\n@@ -160,44 +184,2 @@\n-TEST_VM_F(AsyncLogTest, logBuffer) {\n-  const auto Default = LogDecorations(LogLevel::Warning, LogTagSetMapping<LogTag::__NO_TAG>::tagset(),\n-                                      LogDecorators());\n-  size_t len = strlen(TestLogFileName) + strlen(LogFileOutput::Prefix) + 1;\n-  char* name = NEW_C_HEAP_ARRAY(char, len, mtLogging);\n-  snprintf(name, len, \"%s%s\", LogFileOutput::Prefix, TestLogFileName);\n-\n-  LogFileStreamOutput* output = new LogFileOutput(name);\n-  output->initialize(nullptr, nullptr);\n-  auto buffer = new AsyncLogWriter::Buffer(1024);\n-\n-  int line = 0;\n-  int written;\n-  uintptr_t addr;\n-  const uintptr_t mask = (uintptr_t)(sizeof(void*) - 1);\n-  bool res;\n-\n-  res = buffer->push_back(output, Default, \"a log line\");\n-  EXPECT_TRUE(res) << \"first message should succeed.\";\n-  line++;\n-  res = buffer->push_back(output, Default, \"yet another\");\n-  EXPECT_TRUE(res) << \"second message should succeed.\";\n-  line++;\n-\n-  auto it = buffer->iterator();\n-  EXPECT_TRUE(it.hasNext());\n-  const AsyncLogWriter::Message* e = it.next();\n-  addr = reinterpret_cast<uintptr_t>(e);\n-  EXPECT_EQ(0, (int)(addr & (sizeof(void*)-1))); \/\/ returned vaue aligns on sizeof(pointer)\n-  EXPECT_EQ(output, e->output());\n-  EXPECT_EQ(0, memcmp(&Default, &e->decorations(), sizeof(LogDecorations)));\n-  EXPECT_STREQ(\"a log line\", e->message());\n-  written = e->output()->write_blocking(e->decorations(), e->message());\n-  EXPECT_GT(written, 0);\n-\n-  EXPECT_TRUE(it.hasNext());\n-  e = it.next();\n-  addr = reinterpret_cast<uintptr_t>(e);\n-  EXPECT_EQ(0, (int)(addr & (sizeof(void*)-1)));\n-  EXPECT_EQ(output, e->output());\n-  EXPECT_EQ(0, memcmp(&Default, &e->decorations(), sizeof(LogDecorations)));\n-  EXPECT_STREQ(\"yet another\", e->message());\n-  written = e->output()->write_blocking(e->decorations(), e->message());\n-  EXPECT_GT(written, 0);\n+TEST_VM_F(AsyncLogTest, asynclog) {\n+  set_log_config(TestLogFileName, \"logging=debug\");\n@@ -205,3 +187,3 @@\n-  while (buffer->push_back(output, Default, \"0123456789abcdef\")) {\n-    line++;\n-  }\n+  test_asynclog_ls();\n+  test_asynclog_raw();\n+  AsyncLogWriter::flush();\n@@ -209,12 +191,3 @@\n-  EXPECT_GT(line, 2);\n-  while (it.hasNext()) {\n-    e = it.next();\n-    addr = reinterpret_cast<uintptr_t>(e);\n-    EXPECT_EQ(0, (int)(addr & (sizeof(void*)-1)));\n-    EXPECT_EQ(output, e->output());\n-    EXPECT_STREQ(\"0123456789abcdef\", e->message());\n-    written = e->output()->write_blocking(e->decorations(), e->message());\n-    EXPECT_GT(written, 0);\n-    line--;\n-  }\n-  EXPECT_EQ(line, 2);\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"LogStreamWithAsyncLogImpl\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream msg1-msg2-msg3\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream newline\"));\n@@ -222,8 +195,5 @@\n-  \/\/ last one, flush token. expect to succeed even buffer has been full.\n-  buffer->push_flush_token();\n-  EXPECT_TRUE(it.hasNext());\n-  e = it.next();\n-  EXPECT_EQ(e->output(), nullptr);\n-  EXPECT_TRUE(e->is_token());\n-  EXPECT_STREQ(\"\", e->message());\n-  EXPECT_FALSE(it.hasNext());\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Debug\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Info\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Warning\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Error\"));\n+  EXPECT_FALSE(file_contains_substring(TestLogFileName, \"1Trace\")); \/\/ trace message is masked out\n@@ -231,3 +201,5 @@\n-  \/\/ reset buffer\n-  buffer->reset();\n-  EXPECT_FALSE(buffer->iterator().hasNext());\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"AsyncLogTarget.print = 1\"));\n+  EXPECT_FALSE(\n+      file_contains_substring(TestLogFileName, \"log_trace-test\")); \/\/ trace message is masked out\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"log_debug-test\"));\n+}\n@@ -235,2 +207,4 @@\n-  delete output; \/\/ close file\n-  FREE_C_HEAP_ARRAY(char, name);\n+TEST_VM_F(AsyncLogTest, stdoutOutput) {\n+  testing::internal::CaptureStdout();\n+  test_stdout_or_stderr(\"stdout\", testing::internal::GetCapturedStdout);\n+}\n@@ -238,6 +212,3 @@\n-  const char* strs[4];\n-  strs[0] = \"a log line\";\n-  strs[1] = \"yet another\";\n-  strs[2] = \"0123456789abcdef\";\n-  strs[3] = nullptr; \/\/ sentinel!\n-  EXPECT_TRUE(file_contains_substrings_in_order(TestLogFileName, strs));\n+TEST_VM_F(AsyncLogTest, stderrOutput) {\n+  testing::internal::CaptureStderr();\n+  test_stdout_or_stderr(\"stderr\", testing::internal::GetCapturedStderr);\n@@ -250,1 +221,0 @@\n-\n@@ -256,56 +226,2 @@\n-TEST_VM_F(AsyncLogTest, stdoutOutput) {\n-  testing::internal::CaptureStdout();\n-\n-  if (!set_log_config(\"stdout\", \"logging=debug\")) {\n-    return;\n-  }\n-\n-  bool async = AsyncLogWriter::instance() != nullptr;\n-  if (async) {\n-    test_asynclog_drop_messages();\n-    AsyncLogWriter::flush();\n-  } else {\n-    test_asynclog_ls();\n-  }\n-\n-  fflush(nullptr);\n-  if (!write_to_file(testing::internal::GetCapturedStdout())) {\n-    return;\n-  }\n-\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"LogStreamWithAsyncLogImpl\"));\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream msg1-msg2-msg3\"));\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream newline\"));\n-\n-  if (async) {\n-    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n-  }\n-}\n-\n-TEST_VM_F(AsyncLogTest, stderrOutput) {\n-  testing::internal::CaptureStderr();\n-\n-  if (!set_log_config(\"stderr\", \"logging=debug\")) {\n-    return;\n-  }\n-\n-  bool async = AsyncLogWriter::instance() != nullptr;\n-  if (async) {\n-    test_asynclog_drop_messages();\n-    AsyncLogWriter::flush();\n-  } else {\n-    test_asynclog_ls();\n-  }\n-\n-  fflush(nullptr);\n-  if (!write_to_file(testing::internal::GetCapturedStderr())) {\n-    return;\n-  }\n-\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"LogStreamWithAsyncLogImpl\"));\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream msg1-msg2-msg3\"));\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream newline\"));\n-\n-  if (async) {\n-    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n-  }\n+TEST_F(AsyncLogTest, CircularStringBufferAlwaysRoomForFlush) {\n+  test_room_for_flush();\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":100,"deletions":184,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"logging\/circularStringBuffer.hpp\"\n+#include \"threadHelper.inline.hpp\"\n","filename":"test\/hotspot\/gtest\/logging\/test_logDecorations.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}