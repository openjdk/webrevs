{"files":[{"patch":"@@ -895,1 +895,37 @@\n-  return os::Posix::realpath(filename, outbuf, outbuflen);\n+\n+  if (filename == nullptr || outbuf == nullptr || outbuflen < 1) {\n+    assert(false, \"os::realpath: invalid arguments.\");\n+    errno = EINVAL;\n+    return nullptr;\n+  }\n+\n+  char* result = nullptr;\n+\n+  \/\/ This assumes platform realpath() is implemented according to POSIX.1-2008.\n+  \/\/ POSIX.1-2008 allows to specify null for the output buffer, in which case\n+  \/\/ output buffer is dynamically allocated and must be ::free()'d by the caller.\n+  ALLOW_C_FUNCTION(::realpath, char* p = ::realpath(filename, nullptr);)\n+  if (p != nullptr) {\n+    if (strlen(p) < outbuflen) {\n+      strcpy(outbuf, p);\n+      result = outbuf;\n+    } else {\n+      errno = ENAMETOOLONG;\n+    }\n+    ALLOW_C_FUNCTION(::free, ::free(p);) \/\/ *not* os::free\n+  } else {\n+    \/\/ Fallback for platforms struggling with modern Posix standards (AIX 5.3, 6.1). If realpath\n+    \/\/ returns EINVAL, this may indicate that realpath is not POSIX.1-2008 compatible and\n+    \/\/ that it complains about the null we handed down as user buffer.\n+    \/\/ In this case, use the user provided buffer but at least check whether realpath caused\n+    \/\/ a memory overwrite.\n+    if (errno == EINVAL) {\n+      outbuf[outbuflen - 1] = '\\0';\n+      ALLOW_C_FUNCTION(::realpath, p = ::realpath(filename, outbuf);)\n+      if (p != nullptr) {\n+        guarantee(outbuf[outbuflen - 1] == '\\0', \"realpath buffer overwrite detected.\");\n+        result = p;\n+      }\n+    }\n+  }\n+  return result;\n@@ -1031,41 +1067,0 @@\n-char* os::Posix::realpath(const char* filename, char* outbuf, size_t outbuflen) {\n-\n-  if (filename == nullptr || outbuf == nullptr || outbuflen < 1) {\n-    assert(false, \"os::Posix::realpath: invalid arguments.\");\n-    errno = EINVAL;\n-    return nullptr;\n-  }\n-\n-  char* result = nullptr;\n-\n-  \/\/ This assumes platform realpath() is implemented according to POSIX.1-2008.\n-  \/\/ POSIX.1-2008 allows to specify null for the output buffer, in which case\n-  \/\/ output buffer is dynamically allocated and must be ::free()'d by the caller.\n-  ALLOW_C_FUNCTION(::realpath, char* p = ::realpath(filename, nullptr);)\n-  if (p != nullptr) {\n-    if (strlen(p) < outbuflen) {\n-      strcpy(outbuf, p);\n-      result = outbuf;\n-    } else {\n-      errno = ENAMETOOLONG;\n-    }\n-    ALLOW_C_FUNCTION(::free, ::free(p);) \/\/ *not* os::free\n-  } else {\n-    \/\/ Fallback for platforms struggling with modern Posix standards (AIX 5.3, 6.1). If realpath\n-    \/\/ returns EINVAL, this may indicate that realpath is not POSIX.1-2008 compatible and\n-    \/\/ that it complains about the null we handed down as user buffer.\n-    \/\/ In this case, use the user provided buffer but at least check whether realpath caused\n-    \/\/ a memory overwrite.\n-    if (errno == EINVAL) {\n-      outbuf[outbuflen - 1] = '\\0';\n-      ALLOW_C_FUNCTION(::realpath, p = ::realpath(filename, outbuf);)\n-      if (p != nullptr) {\n-        guarantee(outbuf[outbuflen - 1] == '\\0', \"realpath buffer overwrite detected.\");\n-        result = p;\n-      }\n-    }\n-  }\n-  return result;\n-\n-}\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":37,"deletions":42,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -64,2 +64,0 @@\n-  static char* realpath(const char* filename, char* outbuf, size_t outbuflen);\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5319,4 +5319,0 @@\n-  return os::win32::realpath(filename, outbuf, outbuflen);\n-}\n-\n-char* os::win32::realpath(const char* filename, char* outbuf, size_t outbuflen) {\n@@ -5331,21 +5327,3 @@\n-  ALLOW_C_FUNCTION(::_fullpath, char* p = ::_fullpath(nullptr, filename, 0);)\n-  if (p != nullptr) {\n-    if (strlen(p) < outbuflen) {\n-      strcpy(outbuf, p);\n-      result = outbuf;\n-    } else {\n-      errno = ENAMETOOLONG;\n-    }\n-    ALLOW_C_FUNCTION(::free, ::free(p);) \/\/ *not* os::free\n-  } else {\n-    \/\/ there was a error\n-    \/\/ In this case, use the user provided buffer but at least check whether _fullpath caused\n-    \/\/ a memory overwrite.\n-    if (errno == EINVAL) {\n-      outbuf[outbuflen - 1] = '\\0';\n-      ALLOW_C_FUNCTION(::_fullpath, p = ::_fullpath(outbuf, filename, outbuflen - 1);)\n-      if (p != nullptr) {\n-        guarantee(outbuf[outbuflen - 1] == '\\0', \"_fullpath buffer overwrite detected.\");\n-        result = p;\n-      }\n-    }\n+  ALLOW_C_FUNCTION(::_fullpath, result = ::_fullpath(outbuf, filename, outbuflen);)\n+  if (result == nullptr) {\n+    errno = ENAMETOOLONG;\n@@ -5354,1 +5332,0 @@\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":3,"deletions":26,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -62,2 +62,0 @@\n-  static char* realpath(const char* filename, char* outbuf, size_t outbuflen);\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}