{"files":[{"patch":"@@ -27,0 +27,1 @@\n+#include \"cppstdlib\/new.hpp\"\n@@ -521,2 +522,2 @@\n-  _top_at_mark_starts(NEW_C_HEAP_ARRAY(HeapWord*, _g1h->max_num_regions(), mtGC)),\n-  _top_at_rebuild_starts(NEW_C_HEAP_ARRAY(HeapWord*, _g1h->max_num_regions(), mtGC)),\n+  _top_at_mark_starts(NEW_C_HEAP_ARRAY(Atomic<HeapWord*>, _g1h->max_num_regions(), mtGC)),\n+  _top_at_rebuild_starts(NEW_C_HEAP_ARRAY(Atomic<HeapWord*>, _g1h->max_num_regions(), mtGC)),\n@@ -560,0 +561,6 @@\n+  for (uint i = 0; i < _g1h->max_num_regions(); i++) {\n+    ::new (&_region_mark_stats[i]) G1RegionMarkStats{};\n+    ::new (&_top_at_mark_starts[i]) Atomic<HeapWord*>{};\n+    ::new (&_top_at_rebuild_starts[i]) Atomic<HeapWord*>{};\n+  }\n+\n@@ -568,1 +575,1 @@\n-  _has_aborted = false;\n+  _has_aborted.store_relaxed(false);\n@@ -580,1 +587,1 @@\n-    _top_at_rebuild_starts[i] = nullptr;\n+    _top_at_rebuild_starts[i].store_relaxed(nullptr);\n@@ -592,1 +599,1 @@\n-  _top_at_rebuild_starts[region_idx] = nullptr;\n+  _top_at_rebuild_starts[region_idx].store_relaxed(nullptr);\n@@ -628,1 +635,1 @@\n-  _finger = _heap.start();\n+  _finger.store_relaxed(_heap.start());\n@@ -650,1 +657,1 @@\n-  _concurrent = concurrent;\n+  _concurrent.store_relaxed(concurrent);\n@@ -657,1 +664,1 @@\n-           p2i(_finger), p2i(_heap.end()));\n+           p2i(finger()), p2i(_heap.end()));\n@@ -688,2 +695,2 @@\n-  FREE_C_HEAP_ARRAY(HeapWord*, _top_at_mark_starts);\n-  FREE_C_HEAP_ARRAY(HeapWord*, _top_at_rebuild_starts);\n+  FREE_C_HEAP_ARRAY(Atomic<HeapWord*>, _top_at_mark_starts);\n+  FREE_C_HEAP_ARRAY(Atomic<HeapWord*>, _top_at_rebuild_starts);\n@@ -1154,1 +1161,1 @@\n-  return AtomicAccess::load(&_completed_mark_cycles);\n+  return _completed_mark_cycles.load_relaxed();\n@@ -1163,1 +1170,1 @@\n-    AtomicAccess::inc(&_completed_mark_cycles, memory_order_relaxed);\n+    _completed_mark_cycles.add_then_fetch(1u, memory_order_relaxed);\n@@ -1177,1 +1184,1 @@\n-  _restart_for_overflow = false;\n+  _restart_for_overflow.store_relaxed(false);\n@@ -1346,1 +1353,1 @@\n-    _restart_for_overflow = true;\n+    _restart_for_overflow.store_relaxed(true);\n@@ -1775,2 +1782,2 @@\n-  \/\/ \"checkpoint\" the finger\n-  HeapWord* finger = _finger;\n+  \/\/ \"Checkpoint\" the finger.\n+  HeapWord* local_finger = finger();\n@@ -1778,2 +1785,2 @@\n-  while (finger < _heap.end()) {\n-    assert(_g1h->is_in_reserved(finger), \"invariant\");\n+  while (local_finger < _heap.end()) {\n+    assert(_g1h->is_in_reserved(local_finger), \"invariant\");\n@@ -1781,1 +1788,1 @@\n-    G1HeapRegion* curr_region = _g1h->heap_region_containing_or_null(finger);\n+    G1HeapRegion* curr_region = _g1h->heap_region_containing_or_null(local_finger);\n@@ -1786,1 +1793,1 @@\n-    HeapWord* end = curr_region != nullptr ? curr_region->end() : finger + G1HeapRegion::GrainWords;\n+    HeapWord* end = curr_region != nullptr ? curr_region->end() : local_finger + G1HeapRegion::GrainWords;\n@@ -1789,3 +1796,3 @@\n-    HeapWord* res = AtomicAccess::cmpxchg(&_finger, finger, end);\n-    if (res == finger && curr_region != nullptr) {\n-      \/\/ we succeeded\n+    HeapWord* res = _finger.compare_exchange(local_finger, end);\n+    if (res == local_finger && curr_region != nullptr) {\n+      \/\/ We succeeded.\n@@ -1796,3 +1803,3 @@\n-      \/\/ notice that _finger == end cannot be guaranteed here since,\n-      \/\/ someone else might have moved the finger even further\n-      assert(_finger >= end, \"the finger should have moved forward\");\n+      \/\/ Notice that _finger == end cannot be guaranteed here since,\n+      \/\/ someone else might have moved the finger even further.\n+      assert(finger() >= end, \"The finger should have moved forward\");\n@@ -1804,1 +1811,1 @@\n-               \"the region limit should be at bottom\");\n+               \"The region limit should be at bottom\");\n@@ -1810,3 +1817,4 @@\n-      assert(_finger > finger, \"the finger should have moved forward\");\n-      \/\/ read it again\n-      finger = _finger;\n+      \/\/ Read the finger again.\n+      HeapWord* next_finger = finger();\n+      assert(next_finger > local_finger, \"The finger should have moved forward \" PTR_FORMAT \" \" PTR_FORMAT, p2i(local_finger), p2i(next_finger));\n+      local_finger = next_finger;\n@@ -1951,1 +1959,1 @@\n-  _has_aborted = true;\n+  _has_aborted.store_relaxed(true);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":39,"deletions":31,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -371,1 +371,1 @@\n-  HeapWord* volatile      _finger;            \/\/ The global finger, region aligned,\n+  Atomic<HeapWord*>       _finger;            \/\/ The global finger, region aligned,\n@@ -398,1 +398,1 @@\n-  volatile uint           _completed_mark_cycles;\n+  Atomic<uint>            _completed_mark_cycles;\n@@ -402,1 +402,1 @@\n-  volatile bool           _has_overflown;\n+  Atomic<bool>            _has_overflown;\n@@ -404,1 +404,1 @@\n-  volatile bool           _concurrent;\n+  Atomic<bool>            _concurrent;\n@@ -406,1 +406,1 @@\n-  volatile bool           _has_aborted;\n+  Atomic<bool>            _has_aborted;\n@@ -410,1 +410,1 @@\n-  volatile bool           _restart_for_overflow;\n+  Atomic<bool>            _restart_for_overflow;\n@@ -464,2 +464,2 @@\n-  HeapWord*           finger()       { return _finger;   }\n-  bool                concurrent()   { return _concurrent; }\n+  HeapWord*           finger()       { return _finger.load_relaxed();   }\n+  bool                concurrent()   { return _concurrent.load_relaxed(); }\n@@ -490,1 +490,1 @@\n-  bool out_of_regions() { return _finger >= _heap.end(); }\n+  bool out_of_regions() { return finger() >= _heap.end(); }\n@@ -502,4 +502,4 @@\n-  bool has_overflown()           { return _has_overflown; }\n-  void set_has_overflown()       { _has_overflown = true; }\n-  void clear_has_overflown()     { _has_overflown = false; }\n-  bool restart_for_overflow()    { return _restart_for_overflow; }\n+  bool has_overflown()           { return _has_overflown.load_relaxed(); }\n+  void set_has_overflown()       { _has_overflown.store_relaxed(true); }\n+  void clear_has_overflown()     { _has_overflown.store_relaxed(false); }\n+  bool restart_for_overflow()    { return _restart_for_overflow.load_relaxed(); }\n@@ -519,1 +519,1 @@\n-  HeapWord* volatile* _top_at_mark_starts;\n+  Atomic<HeapWord*>* _top_at_mark_starts;\n@@ -524,1 +524,1 @@\n-  HeapWord* volatile* _top_at_rebuild_starts;\n+  Atomic<HeapWord*>* _top_at_rebuild_starts;\n@@ -679,1 +679,1 @@\n-  bool has_aborted()      { return _has_aborted; }\n+  bool has_aborted() { return _has_aborted.load_relaxed(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-  _top_at_mark_starts[region] = r->top();\n+  _top_at_mark_starts[region].store_relaxed(r->top());\n@@ -201,1 +201,1 @@\n-  _top_at_mark_starts[r->hrm_index()] = r->bottom();\n+  _top_at_mark_starts[r->hrm_index()].store_relaxed(r->bottom());\n@@ -210,1 +210,1 @@\n-  return _top_at_mark_starts[region];\n+  return _top_at_mark_starts[region].load_relaxed();\n@@ -220,1 +220,1 @@\n-  return _top_at_rebuild_starts[r->hrm_index()];\n+  return _top_at_rebuild_starts[r->hrm_index()].load_relaxed();\n@@ -228,1 +228,1 @@\n-  assert(_top_at_rebuild_starts[region] == nullptr,\n+  assert(top_at_rebuild_start(r) == nullptr,\n@@ -230,2 +230,2 @@\n-         region, p2i(_top_at_rebuild_starts[region]));\n-  _top_at_rebuild_starts[region] = r->top();\n+         region, p2i(top_at_rebuild_start(r)));\n+  _top_at_rebuild_starts[region].store_relaxed(r->top());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"}]}