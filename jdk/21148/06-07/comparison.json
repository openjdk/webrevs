{"files":[{"patch":"@@ -2066,0 +2066,2 @@\n+      } else {\n+        CHECK_BAILOUT();\n@@ -2135,0 +2137,2 @@\n+  } else {\n+    CHECK_BAILOUT();\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1207,0 +1207,7 @@\n+    if (_failure_reason.get() == reason) {\n+      \/\/ Already set to same storage, so we cannot free the\n+      \/\/ memory with clear() below.  This is expected for C1,\n+      \/\/ which uses the ciEnv to store the failure reason.\n+      return;\n+    }\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -570,1 +570,1 @@\n-    assert(false, \"no progress\");\n+    assert(C->failing_internal(), \"no progress\");\n@@ -1016,0 +1016,3 @@\n+\n+  if (C->failing()) return nullptr;\n+\n@@ -1147,0 +1150,1 @@\n+          if (C->failing()) return nullptr;\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1203,0 +1203,1 @@\n+    if (phase->C->failing()) return nullptr;\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -799,5 +799,9 @@\n-      if (strcmp(failure_reason(), ciEnv::old_method_reason()) != 0) {\n-        stringStream ss;\n-        ss.print(\"method parse failed: %s\", failure_reason());\n-        record_method_not_compilable(ss.as_string() DEBUG_ONLY(COMMA true));\n-      }\n+      \/\/ Some failure reasons should not prevent retry\n+#ifdef ASSERT\n+      if (failure_is_artificial()) return;\n+#endif\n+      if (strcmp(failure_reason(), ciEnv::old_method_reason()) == 0) return;\n+      \/\/ Everything else marks the root method as not-compilable\n+      stringStream ss;\n+      ss.print(\"method parse failed: %s\", failure_reason());\n+      record_method_not_compilable(ss.as_string() DEBUG_ONLY(COMMA true));\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+        if (failing()) return nullptr;\n@@ -238,0 +239,1 @@\n+            if (failing()) return nullptr;\n@@ -276,1 +278,1 @@\n-            }\n+            } else if (failing()) return nullptr;\n@@ -315,0 +317,2 @@\n+    if (failing()) return nullptr;\n+\n@@ -340,2 +344,3 @@\n-        if (cha_monomorphic_target != nullptr &&\n-            cha_monomorphic_target->holder() != env()->Object_klass()) { \/\/ subtype check against Object is useless\n+        if (cha_monomorphic_target == nullptr) {\n+          if (failing()) return nullptr;\n+        } else if (cha_monomorphic_target->holder() != env()->Object_klass()) { \/\/ subtype check against Object is useless\n@@ -348,0 +353,2 @@\n+          if (failing()) return nullptr;\n+\n@@ -644,0 +651,2 @@\n+  if (failing()) return;\n+\n@@ -690,0 +699,1 @@\n+    if (failing()) return;\n@@ -1201,1 +1211,1 @@\n-    }\n+    } else if (failing()) return nullptr;\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1030,0 +1030,1 @@\n+      if (failing()) return;\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1048,0 +1048,1 @@\n+      if (C->failing()) return;\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}