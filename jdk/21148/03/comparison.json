{"files":[{"patch":"@@ -2124,1 +2124,1 @@\n-    assert(!target->can_be_statically_bound() || target->equals(cha_monomorphic_target), \"\");\n+    assert(!target->can_be_statically_bound() || target == cha_monomorphic_target, \"\");\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -685,1 +685,3 @@\n-  ciMethod* root_m = resolve_invoke(caller, actual_recv, check_access, true \/* allow_abstract *\/);\n+  VM_ENTRY_MARK;\n+\n+  ciMethod* root_m = resolve_invoke_helper(caller, actual_recv, check_access, true \/* allow_abstract *\/, thread);\n@@ -691,0 +693,5 @@\n+  \/\/ Redefinition support.\n+  if (this->is_old() || root_m->is_old()) {\n+    return nullptr;\n+  }\n+\n@@ -716,2 +723,0 @@\n-  VM_ENTRY_MARK;\n-\n@@ -745,0 +750,6 @@\n+\n+  \/\/ Redefinition support.\n+  if (this->is_old() || root_m->is_old() || target->is_old()) {\n+    return nullptr;\n+  }\n+\n@@ -785,17 +796,1 @@\n-\/\/ ciMethod::equals\n-\/\/\n-\/\/ Returns true if the methods are the same, taking redefined methods\n-\/\/ into account.\n-bool ciMethod::equals(const ciMethod* m) const {\n-  if (this == m) return true;\n-  VM_ENTRY_MARK;\n-  Method* m1 = this->get_Method();\n-  Method* m2 = m->get_Method();\n-  if (m1->is_old()) m1 = m1->get_new_method();\n-  if (m2->is_old()) m2 = m2->get_new_method();\n-  return m1 == m2;\n-}\n-\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciMethod::resolve_invoke\n+\/\/ ciMethod::resolve_invoke_helper\n@@ -805,1 +800,1 @@\n-ciMethod* ciMethod::resolve_invoke(ciKlass* caller, ciKlass* exact_receiver, bool check_access, bool allow_abstract) {\n+ciMethod* ciMethod::resolve_invoke_helper(ciKlass* caller, ciKlass* exact_receiver, bool check_access, bool allow_abstract, CompilerThread* thread) {\n@@ -807,1 +802,1 @@\n-  VM_ENTRY_MARK;\n+  ASSERT_IN_VM;\n@@ -848,0 +843,10 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciMethod::resolve_invoke\n+\/\/\n+\/\/ Given a known receiver klass, find the target for the call.\n+\/\/ Return null if the call has no target or the target is abstract.\n+ciMethod* ciMethod::resolve_invoke(ciKlass* caller, ciKlass* exact_receiver, bool check_access, bool allow_abstract) {\n+  VM_ENTRY_MARK;\n+  return resolve_invoke_helper(caller, exact_receiver, check_access, allow_abstract, thread);\n+}\n+\n@@ -1499,0 +1504,7 @@\n+\/\/ ciMethod::is_old\n+\/\/\n+\/\/ Return true for redefined methods\n+bool ciMethod::is_old() const {\n+  ASSERT_IN_VM;\n+  return get_Method()->is_old();\n+}\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":34,"deletions":22,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -301,0 +301,1 @@\n+  ciMethod* resolve_invoke_helper(ciKlass* caller, ciKlass* exact_receiver, bool check_access, bool allow_abstract, CompilerThread* thread);\n@@ -364,0 +365,1 @@\n+  bool is_old() const;\n@@ -369,2 +371,0 @@\n-  bool equals(const ciMethod* m) const;\n-\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}