{"files":[{"patch":"@@ -297,4 +297,1 @@\n-     *    the following rechecks even if the CAS is not attempted.  To\n-     *    more easily distinguish among kinds of CAS failures, we use\n-     *    the compareAndExchange version, and usually handle null\n-     *    returns (indicating contention) separately from others.\n+     *    the following rechecks even if the CAS is not attempted.\n@@ -566,3 +563,1 @@\n-     *    aren't needed. We filter out some of these cases by exiting\n-     *    retry loops in signalWork if the task responsible for the\n-     *    signal has already been taken.\n+     *    aren't needed.\n@@ -575,13 +570,3 @@\n-     *   wastage. All remedies are intrinsically heuristic. We use a\n-     *   strategy that works well in most cases: We track \"sources\"\n-     *   (queue ids) of non-empty (usually polled) queues while\n-     *   scanning. These are maintained in the \"source\" field of\n-     *   WorkQueues for use in method helpJoin and elsewhere (see\n-     *   below). We also maintain them as arguments\/results of\n-     *   top-level polls (argument \"window\" in method scan, with setup\n-     *   in method runWorker) as an encoded sliding window of current\n-     *   and previous two sources (or INVALID_ID if none), and stop\n-     *   signalling when all were from the same source. These\n-     *   mechanisms may result in transiently too few workers, but\n-     *   once workers poll from a new source, they rapidly reactivate\n-     *   others.\n+     *   wastage. We reduce impact by deactivating workers when\n+     *   queues don't have accessible tasks, but reactivating and\n+     *   rescanning if other tasks remain.\n@@ -601,19 +586,19 @@\n-     * suffice. Scans do not otherwise explicitly take into account\n-     * core affinities, loads, cache localities, etc, However, they do\n-     * exploit temporal locality (which usually approximates these) by\n-     * preferring to re-poll from the same queue (either in method\n-     * tryPoll() or scan) after a successful poll before trying others\n-     * (see method topLevelExec), which also reduces bookkeeping,\n-     * cache traffic, and scanning overhead. But it also reduces\n-     * fairness, which is partially counteracted by giving up on\n-     * contention.\n-     *\n-     * Deactivation. When method scan indicates that no tasks are\n-     * found by a worker, it tries to deactivate (in awaitWork),\n-     * giving up (and rescanning) on ctl contention. To avoid missed\n-     * signals during deactivation, the method rescans and reactivates\n-     * if there may have been a missed signal during deactivation,\n-     * filtering out most cases in which this is unnecessary. Because\n-     * idle workers are often not yet blocked (parked), we use the\n-     * WorkQueue parking field to advertise that a waiter actually\n-     * needs unparking upon signal.\n+     * suffice. Each queue's polling attempt uses a bounded retry\n+     * (MAX_SCAN_RETRIES) to avoid becoming stuck when other\n+     * scanners\/pollers stall.  Scans do not otherwise explicitly take\n+     * into account core affinities, loads, cache localities, etc,\n+     * However, they do exploit temporal locality (which usually\n+     * approximates these) by preferring to re-poll from the same\n+     * queue after a successful poll before trying others, which also\n+     * reduces bookkeeping, cache traffic, and scanning overhead. But\n+     * it also reduces fairness, which is partially counteracted by\n+     * giving up on contention.\n+     *\n+     * Deactivation. When method scan indicates (twice) that no tasks\n+     * are found by a worker, it tries to deactivate()), giving up\n+     * (and rescanning) on ctl contention. To avoid missed signals\n+     * during deactivation, the method rescans and reactivates if\n+     * there may have been a missed signal during\n+     * deactivation. Because idle workers are often not yet blocked\n+     * (parked), we use a WorkQueue field to advertise that a waiter\n+     * actually needs unparking upon signal.\n@@ -631,18 +616,18 @@\n-     * others including tryCompensate. Method quiescent() is\n-     * used in all of these contexts. It provides checks that all\n-     * workers are idle and there are no submissions that they could\n-     * poll if they were not idle, retrying on inconsistent reads of\n-     * queues and using the runState seqLock to retry on queue array\n-     * updates.  (It also reports quiescence if the pool is\n-     * terminating.) A true report means only that there was a moment\n-     * at which quiescence held.  False negatives are inevitable (for\n-     * example when queues indices lag updates, as described above),\n-     * which is accommodated when (tentatively) idle by scanning for\n-     * work etc, and then re-invoking. This includes cases in which\n-     * the final unparked thread (in awaitWork) uses quiescent()\n-     * to check for tasks that could have been added during a race\n-     * window that would not be accompanied by a signal, in which case\n-     * re-activating itself (or any other worker) to rescan. Method\n-     * helpQuiesce acts similarly but cannot rely on ctl counts to\n-     * determine that all workers are inactive because the caller and\n-     * any others executing helpQuiesce are not included in counts.\n+     * others including tryCompensate. Method quiescent() is used in\n+     * all of these contexts. It provides checks that all workers are\n+     * idle and there are no submissions that they could poll if they\n+     * were not idle, retrying on inconsistent reads of queues and\n+     * using the runState seqLock to retry on queue array updates.\n+     * (It also reports quiescence if the pool is terminating.) A true\n+     * report means only that there was a moment at which quiescence\n+     * held.  False negatives are inevitable (for example when queues\n+     * indices lag updates, as described above), which is accommodated\n+     * when (tentatively) idle by scanning for work etc, and then\n+     * re-invoking. This includes cases in which the final unparked\n+     * thread (in deactivate()) uses quiescent() to check for tasks\n+     * that could have been added during a race window that would not\n+     * be accompanied by a signal, in which case re-activating itself\n+     * (or any other worker) to rescan. Method helpQuiesce acts\n+     * similarly but cannot rely on ctl counts to determine that all\n+     * workers are inactive because the caller and any others\n+     * executing helpQuiesce are not included in counts.\n@@ -671,3 +656,3 @@\n-     * to the first timeout of a fully populated pool. Subsequent (or\n-     * other) cases use delays such that, if still quiescent, all will\n-     * be released before one additional keepAlive unit elapses.\n+     * to the first timeout of a quiescent pool. Subsequent cases use\n+     * minimal delays such that, if still quiescent, all will be\n+     * released soon therafter.\n@@ -889,1 +874,3 @@\n-     * less-contended applications. For class WorkQueue, an\n+     * less-contended applications. To help arrange this, some\n+     * non-reference fields are declared as \"long\" even when ints or\n+     * shorts would suffice.  For class WorkQueue, an\n@@ -892,0 +879,3 @@\n+     * other management.  For class WorkQueue, an embedded padded\n+     * region segregates fields (all decalred as \"int\") most heavily\n+     * updated by owners from those most commonly read by stealers or\n@@ -900,4 +890,5 @@\n-     * be fairly small.  (Maintenance note: any changes in fields,\n-     * queues, or their uses, or JVM layout policies, must be\n-     * accompanied by re-evaluation of these placement and sizing\n-     * decisions.)\n+     * be just large enough to avoid resizing in most tree-structured\n+     * tasks, although resizing is common in some other cases.\n+     * (Maintenance note: any changes in fields, queues, or their\n+     * uses, or JVM layout policies, must be accompanied by\n+     * re-evaluation of these placement and sizing decisions.)\n@@ -957,18 +948,0 @@\n-     * Revision notes\n-     * ==============\n-     *\n-     * The main sources of differences from previous version are:\n-     *\n-     * * New abstract class ForkJoinTask.InterruptibleTask ensures\n-     *   handling of tasks submitted under the ExecutorService\n-     *   API are consistent with specs.\n-     * * Method quiescent() replaces previous quiescence-related\n-     *   checks, relying on versioning and sequence locking instead\n-     *   of ReentrantLock.\n-     * * Termination processing now ensures that internal data\n-     *   structures are maintained consistently enough while stopping\n-     *   to interrupt all workers and cancel all tasks. It also uses a\n-     *   CountDownLatch instead of a Condition for termination because\n-     *   of lock change.\n-     * * Many other changes to avoid performance regressions due\n-     *   to the above.\n@@ -986,1 +959,2 @@\n-     * Undershoot tolerance for idle timeouts\n+     * Undershoot tolerance for idle timeouts, also serving as the\n+     * minimum allowed timeout value.\n@@ -1004,1 +978,1 @@\n-    static final int INITIAL_QUEUE_CAPACITY = 1 << 6;\n+    static final int INITIAL_QUEUE_CAPACITY = 1 << 7;\n@@ -1017,4 +991,4 @@\n-    static final int STOP             = 1 <<  0;   \/\/ terminating\n-    static final int SHUTDOWN         = 1 <<  1;   \/\/ terminate when quiescent\n-    static final int TERMINATED       = 1 <<  2;   \/\/ only set if STOP also set\n-    static final int RS_LOCK          = 1 <<  3;   \/\/ lowest seqlock bit\n+    static final long STOP            = 1L <<  0;   \/\/ terminating\n+    static final long SHUTDOWN        = 1L <<  1;   \/\/ terminate when quiescent\n+    static final long TERMINATED      = 1L <<  2;   \/\/ only set if STOP also set\n+    static final long RS_LOCK         = 1L <<  3;   \/\/ lowest seqlock bit\n@@ -1032,7 +1006,0 @@\n-    \/\/ source history window packing used in scan() and runWorker()\n-    static final long RESCAN          = 1L << 63; \/\/ must be negative\n-    static final long HMASK           = ((((long)SMASK) << 32) |\n-                                         (((long)SMASK) << 16)); \/\/ history bits\n-    static final long NO_HISTORY      = ((((long)INVALID_ID) << 32) | \/\/ no 3rd\n-                                         (((long)INVALID_ID) << 16)); \/\/ no 2nd\n-\n@@ -1040,1 +1007,2 @@\n-    static final int DEREGISTERED     = 1 << 31;  \/\/ worker terminating\n+    static final int PARKING          = 1 << 31;  \/\/ parked in awaitWork\n+    static final int DROPPED          = 1 << 16;  \/\/ removed from ctl counts\n@@ -1043,0 +1011,1 @@\n+    static final int MAX_SCAN_RETRIES = 8;        \/\/ limit stalls in scan()\n@@ -1220,1 +1189,1 @@\n-        volatile int source;       \/\/ source queue id (or DEREGISTERED)\n+        volatile int source;       \/\/ source queue id (or DROPPED or PARKING)\n@@ -1223,2 +1192,0 @@\n-        @jdk.internal.vm.annotation.Contended(\"w\")\n-        volatile int parking;      \/\/ nonzero if parked in awaitWork\n@@ -1231,1 +1198,0 @@\n-        private static final long SOURCE;\n@@ -1240,3 +1206,0 @@\n-        final void forgetSource() {\n-            U.putIntOpaque(this, SOURCE, 0);\n-        }\n@@ -1264,1 +1227,1 @@\n-            top = base = 1;\n+            top = base = INITIAL_QUEUE_CAPACITY >>> 2; \/\/ offset\n@@ -1294,3 +1257,12 @@\n-            int s = top, b = base, cap, m, p, room, newCap; ForkJoinTask<?>[] a;\n-            if ((a = array) == null || (cap = a.length) <= 0 ||\n-                (room = (m = cap - 1) - (s - b)) < 0) { \/\/ could not resize\n+            int s = top, b = base, m, cap, room; ForkJoinTask<?>[] a;\n+            if ((a = array) != null && (cap = a.length) > 0) { \/\/ else disabled\n+                if ((room = (m = cap - 1) - (s - b)) >= 0) {\n+                    top = s + 1;\n+                    long pos = slotOffset(m & s);\n+                    if (!internal)\n+                        U.putReference(a, pos, task);       \/\/ inside lock\n+                    else\n+                        U.getAndSetReference(a, pos, task); \/\/ fully fenced\n+                    if (room == 0)                          \/\/ resize\n+                        growArray(a, cap, s);\n+                }\n@@ -1299,1 +1271,4 @@\n-                throw new RejectedExecutionException(\"Queue capacity exceeded\");\n+                if (room < 0)\n+                    throw new RejectedExecutionException(\"Queue capacity exceeded\");\n+                else if ((room == 0 || a[m & (s - 1)] == null) && pool != null)\n+                    pool.signalWork();\n@@ -1301,7 +1276,11 @@\n-            top = s + 1;\n-            long pos = slotOffset(p = m & s);\n-            if (!internal)\n-                U.putReference(a, pos, task);         \/\/ inside lock\n-            else\n-                U.getAndSetReference(a, pos, task);   \/\/ fully fenced\n-            if (room == 0 && (newCap = cap << 1) > 0) {\n+        }\n+\n+        \/**\n+         * Resizes the queue array unless out of memory.\n+         * @param a old array\n+         * @param cap old array capacity\n+         * @param s current top\n+         *\/\n+        private void growArray(ForkJoinTask<?>[] a, int cap, int s) {\n+            int newCap;\n+            if (a != null && a.length == cap && (newCap = cap << 1) > 0) {\n@@ -1309,1 +1288,1 @@\n-                try {                                 \/\/ resize for next time\n+                try {\n@@ -1314,1 +1293,1 @@\n-                    int newMask = newCap - 1;         \/\/ poll old, push to new\n+                    int mask = cap - 1, newMask = newCap - 1;\n@@ -1316,1 +1295,1 @@\n-                        ForkJoinTask<?> u;\n+                        ForkJoinTask<?> u;            \/\/ poll old, push to new\n@@ -1318,1 +1297,1 @@\n-                                 a, slotOffset(k & m), null)) == null)\n+                                 a, slotOffset(k & mask), null)) == null)\n@@ -1322,1 +1301,1 @@\n-                    updateArray(newArray);            \/\/ fully fenced\n+                    updateArray(newArray);           \/\/ fully fenced\n@@ -1324,1 +1303,0 @@\n-                a = null;                             \/\/ always signal\n@@ -1326,4 +1304,0 @@\n-            if (!internal)\n-                unlockPhase();\n-            if ((a == null || a[m & (s - 1)] == null) && pool != null)\n-                pool.signalWork(a, p);\n@@ -1341,2 +1315,2 @@\n-            if (a != null && (cap = a.length) > 0) {\n-                for (int m = cap - 1, s, nb; p - b > 0; ) {\n+            if (p - b > 0 && a != null && (cap = a.length) > 0) {\n+                for (int m = cap - 1, s, nb;;) {\n@@ -1358,0 +1332,2 @@\n+                    if (p - b <= 0)\n+                        break;\n@@ -1416,2 +1392,0 @@\n-         *\n-         * @param pool if nonnull, pool to signal if more tasks exist\n@@ -1419,15 +1393,23 @@\n-        final ForkJoinTask<?> poll(ForkJoinPool pool) {\n-            for (;;) {\n-                ForkJoinTask<?>[] a = array;\n-                int b = base, cap, k;\n-                if (a == null || (cap = a.length) <= 0)\n-                    break;\n-                ForkJoinTask<?> t = a[k = b & (cap - 1)];\n-                U.loadFence();\n-                if (base == b) {\n-                    Object o;\n-                    int nb = b + 1, nk = nb & (cap - 1);\n-                    if (t == null)\n-                        o = a[k];\n-                    else if (t == (o = U.compareAndExchangeReference(\n-                                       a, slotOffset(k), t, null))) {\n+        final ForkJoinTask<?> poll() {\n+            if ((phase & (IDLE | 1)) == 0 || top - base > 0) {\n+                for (boolean stalled = false;;) {\n+                    int cap, b, k, nb; ForkJoinTask<?>[] a;\n+                    if ((a = array) == null || (cap = a.length) <= 0)\n+                        break;\n+                    long kp = slotOffset(k = (cap - 1) & (b = base));\n+                    int nk = (nb = b + 1) & (cap - 1); \/\/ next slot\n+                    int sk = (b + 2) & (cap - 1);      \/\/ 2nd slot ahead\n+                    ForkJoinTask<?> t = a[k];\n+                    U.loadFence();\n+                    if (base != b)\n+                        ;                              \/\/ inconsistent\n+                    else if (t == null) {\n+                        if (a[sk] == null && a[nk] == null && a[k] == null &&\n+                            top - b <= 0)\n+                            break;                     \/\/ empty\n+                        if (stalled)\n+                            Thread.onSpinWait();\n+                        stalled = true;\n+                        U.loadFence();                 \/\/ reread\n+                    }\n+                    else if (U.compareAndSetReference(a, kp, t, null)) {\n@@ -1435,2 +1417,0 @@\n-                        if (a[nk] != null && pool != null)\n-                            pool.signalWork(a, nk); \/\/ propagate\n@@ -1439,3 +1419,0 @@\n-                    if (o == null && a[nk] == null && array == a &&\n-                        (phase & (IDLE | 1)) != 0 && top - base <= 0)\n-                        break;                    \/\/ empty\n@@ -1447,0 +1424,2 @@\n+        \/\/ specialized execution methods\n+\n@@ -1448,3 +1427,2 @@\n-         * Tries to poll next task in FIFO order, failing without\n-         * retries on contention or stalls. Used only by topLevelExec\n-         * to repoll from the queue obtained from pool.scan.\n+         * Runs the given task, as well as remaining local tasks, plus\n+         * those from src queue that can be taken without interference.\n@@ -1452,16 +1430,15 @@\n-        private ForkJoinTask<?> tryPoll() {\n-            ForkJoinTask<?>[] a; int cap;\n-            if ((a = array) != null && (cap = a.length) > 0) {\n-                for (int b = base, k;;) {  \/\/ loop only if inconsistent\n-                    ForkJoinTask<?> t = a[k = b & (cap - 1)];\n-                    U.loadFence();\n-                    if (b == (b = base)) {\n-                        Object o;\n-                        if (t == null)\n-                            o = a[k];\n-                        else if (t == (o = U.compareAndExchangeReference(\n-                                           a, slotOffset(k), t, null))) {\n-                            updateBase(b + 1);\n-                            return t;\n-                        }\n-                        if (o == null)\n+        final void topLevelExec(ForkJoinTask<?> task, WorkQueue src,\n+                                int srcBase, int cfg) {\n+            if (task != null && src != null) {\n+                int fifo = cfg & FIFO, nstolen = 1;\n+                for (;;) {\n+                    task.doExec();\n+                    if ((task = nextLocalTask(fifo)) == null) {\n+                        int k, cap; ForkJoinTask<?>[] a;\n+                        if (src.base != srcBase ||\n+                            (a = src.array) == null || (cap = a.length) <= 0 ||\n+                            (task = a[k = srcBase & (cap - 1)]) == null)\n+                            break;\n+                        U.loadFence();\n+                        if (src.base != srcBase || !U.compareAndSetReference(\n+                                a, slotOffset(k), task, null))\n@@ -1469,0 +1446,2 @@\n+                        src.updateBase(++srcBase);\n+                        ++nstolen;\n@@ -1471,0 +1450,3 @@\n+                nsteals += nstolen;\n+                if ((cfg & CLEAR_TLS) != 0)\n+                    ThreadLocalRandom.eraseThreadLocals(Thread.currentThread());\n@@ -1472,24 +1454,0 @@\n-            return null;\n-        }\n-\n-        \/\/ specialized execution methods\n-\n-        \/**\n-         * Runs the given (stolen) task if nonnull, as well as\n-         * remaining local tasks and\/or others available from the\n-         * given queue, if any.\n-         *\/\n-        final void topLevelExec(ForkJoinTask<?> task, WorkQueue src, int srcId) {\n-            int cfg = config, fifo = cfg & FIFO, nstolen = nsteals + 1;\n-            if ((srcId & 1) != 0) \/\/ don't record external sources\n-                source = srcId;\n-            if ((cfg & CLEAR_TLS) != 0)\n-                ThreadLocalRandom.eraseThreadLocals(Thread.currentThread());\n-            while (task != null) {\n-                task.doExec();\n-                if ((task = nextLocalTask(fifo)) == null && src != null &&\n-                    (task = src.tryPoll()) != null)\n-                    ++nstolen;\n-            }\n-            nsteals = nstolen;\n-            forgetSource();\n@@ -1637,1 +1595,0 @@\n-            SOURCE = U.objectFieldOffset(klass, \"source\");\n@@ -1678,0 +1635,1 @@\n+    volatile long runState;              \/\/ versioned, lockable\n@@ -1682,1 +1640,0 @@\n-    volatile int runState;               \/\/ versioned, lockable\n@@ -1726,2 +1683,2 @@\n-    private int getAndBitwiseOrRunState(int v) { \/\/ for status bits\n-        return U.getAndBitwiseOrInt(this, RUNSTATE, v);\n+    private long getAndBitwiseOrRunState(long v) { \/\/ for status bits\n+        return U.getAndBitwiseOrLong(this, RUNSTATE, v);\n@@ -1729,2 +1686,2 @@\n-    private boolean casRunState(int c, int v) {\n-        return U.compareAndSetInt(this, RUNSTATE, c, v);\n+    private boolean casRunState(long c, long v) {\n+        return U.compareAndSetLong(this, RUNSTATE, c, v);\n@@ -1733,1 +1690,1 @@\n-        U.getAndAddInt(this, RUNSTATE, RS_LOCK);\n+        U.getAndAddLong(this, RUNSTATE, RS_LOCK);\n@@ -1735,3 +1692,3 @@\n-    private int lockRunState() {                \/\/ lock and return current state\n-        int s, u;                               \/\/ locked when RS_LOCK set\n-        if (((s = runState) & RS_LOCK) == 0 && casRunState(s, u = s + RS_LOCK))\n+    private long lockRunState() {                \/\/ lock and return current state\n+        long s, u;                               \/\/ locked when RS_LOCK set\n+        if (((s = runState) & RS_LOCK) == 0L && casRunState(s, u = s + RS_LOCK))\n@@ -1742,3 +1699,4 @@\n-    private int spinLockRunState() {            \/\/ spin\/sleep\n-        for (int waits = 0, s, u;;) {\n-            if (((s = runState) & RS_LOCK) == 0) {\n+    private long spinLockRunState() {            \/\/ spin\/sleep\n+        for (int waits = 0;;) {\n+            long s, u;\n+            if (((s = runState) & RS_LOCK) == 0L) {\n@@ -1762,1 +1720,1 @@\n-        return p != null && (p.runState & STOP) != 0;\n+        return p != null && (p.runState & STOP) != 0L;\n@@ -1780,1 +1738,1 @@\n-            if ((runState & STOP) == 0 &&  \/\/ avoid construction if terminating\n+            if ((runState & STOP) == 0L &&  \/\/ avoid construction if terminating\n@@ -1818,1 +1776,1 @@\n-            int stop = lockRunState() & STOP;\n+            long stop = lockRunState() & STOP;\n@@ -1821,1 +1779,1 @@\n-                if (stop == 0 && (qs = queues) != null && (n = qs.length) > 0) {\n+                if (stop == 0L && (qs = queues) != null && (n = qs.length) > 0) {\n@@ -1864,0 +1822,2 @@\n+        if ((runState & STOP) != 0L)       \/\/ ensure released\n+            releaseAll();\n@@ -1869,3 +1829,3 @@\n-            if ((src = w.source) != DEREGISTERED) { \/\/ else trimmed on timeout\n-                w.source = DEREGISTERED;\n-                if (phase != 0) {         \/\/ else failed to start\n+            if ((src = w.source) != DROPPED) {\n+                w.source = DROPPED;        \/\/ else already dropped\n+                if (phase != 0) {          \/\/ else failed to start\n@@ -1873,2 +1833,9 @@\n-                    if ((phase & IDLE) != 0)\n-                        reactivate(w);    \/\/ pool stopped before released\n+                    if (w.top - w.base > 0) {\n+                        ForkJoinTask<?> t; \/\/ cancel remaining tasks\n+                        while ((t = w.nextLocalTask()) != null) {\n+                            try {\n+                                t.cancel(false);\n+                            } catch (Throwable ignore) {\n+                            }\n+                        }\n+                    }\n@@ -1878,2 +1845,2 @@\n-        long c = ctl;\n-        if (src != DEREGISTERED)          \/\/ decrement counts\n+        if (src != DROPPED) {             \/\/ decrement counts\n+            long c = ctl;\n@@ -1884,9 +1851,0 @@\n-        else if ((int)c != 0)\n-            replaceable = true;           \/\/ signal below to cascade timeouts\n-        if (w != null) {                  \/\/ cancel remaining tasks\n-            for (ForkJoinTask<?> t; (t = w.nextLocalTask()) != null; ) {\n-                try {\n-                    t.cancel(false);\n-                } catch (Throwable ignore) {\n-                }\n-            }\n@@ -1897,3 +1855,4 @@\n-            int stop = lockRunState() & STOP;\n-            if (stop == 0 && (qs = queues) != null && (n = qs.length) > 0 &&\n-                qs[i = phase & SMASK & (n - 1)] == w) {\n+            if ((lockRunState() & STOP) != 0L)\n+                replaceable = false;\n+            else if ((qs = queues) != null && (n = qs.length) > 0 &&\n+                     qs[i = phase & SMASK & (n - 1)] == w) {\n@@ -1904,0 +1863,2 @@\n+            if (replaceable)\n+                signalWork();\n@@ -1905,2 +1866,0 @@\n-        if ((runState & STOP) == 0 && replaceable)\n-            signalWork(null, 0); \/\/ may replace unless trimmed or uninitialized\n@@ -1912,5 +1871,1 @@\n-     * Releases an idle worker, or creates one if not enough exist,\n-     * returning on contention if a signal task is already taken.\n-     *\n-     * @param a if nonnull, a task array holding task signalled\n-     * @param k index of task in array\n+     * Releases an idle worker, or creates one if not enough exist.\n@@ -1918,1 +1873,1 @@\n-    final void signalWork(ForkJoinTask<?>[] a, int k) {\n+    final void signalWork() {\n@@ -1924,1 +1879,5 @@\n-            if (qs == null || qs.length <= i)\n+            if ((short)(c >>> RC_SHIFT) >= pc)\n+                break;\n+            if (qs == null)\n+                break;\n+            if (qs.length <= i)\n@@ -1932,1 +1891,1 @@\n-            else if ((short)(c >>> RC_SHIFT) >= pc || (v = w) == null)\n+            else if ((v = w) == null)\n@@ -1936,1 +1895,1 @@\n-            if (c == (c = compareAndExchangeCtl(c, nc | ac))) {\n+            if (c == (c = ctl) && c == (c = compareAndExchangeCtl(c, nc | ac))) {\n@@ -1941,1 +1900,1 @@\n-                    if (v.parking != 0)\n+                    if (v.source < 0)\n@@ -1946,1 +1905,1 @@\n-            if (a != null && k >= 0 && k < a.length && a[k] == null)\n+            if ((runState & STOP) != 0L)\n@@ -1952,3 +1911,3 @@\n-     * Reactivates the given worker, and possibly others if not top of\n-     * ctl stack. Called only during shutdown to ensure release on\n-     * termination.\n+     * Releases all waiting workers. Called only during shutdown.\n+     *\n+     * @return current ctl\n@@ -1956,2 +1915,3 @@\n-    private void reactivate(WorkQueue w) {\n-        for (long c = ctl;;) {\n+    private long releaseAll() {\n+        long c = ctl;\n+        for (;;) {\n@@ -1959,3 +1919,2 @@\n-            if ((qs = queues) == null || (sp = (int)c) == 0 ||\n-                qs.length <= (i = sp & SMASK) || (v = qs[i]) == null ||\n-                (v != w && w != null && (w.phase & IDLE) == 0))\n+            if ((sp = (int)c) == 0 || (qs = queues) == null ||\n+                qs.length <= (i = sp & SMASK) || (v = qs[i]) == null)\n@@ -1967,3 +1926,1 @@\n-                if (v == w)\n-                    break;\n-                if (v.parking != 0)\n+                if (v.source < 0)\n@@ -1973,0 +1930,1 @@\n+        return c;\n@@ -1977,3 +1935,3 @@\n-     * @return true if terminating or all workers are inactive and\n-     * submission queues are empty and unlocked; if so, setting STOP\n-     * if shutdown is enabled\n+     * @return positive if stopping, nonnegative if terminating or all\n+     * workers are inactive and submission queues are empty and\n+     * unlocked; if so, setting STOP if shutdown is enabled\n@@ -1981,1 +1939,1 @@\n-    private boolean quiescent() {\n+    private int quiescent() {\n@@ -1985,1 +1943,1 @@\n-            for (int e, prevRunState = 0; ; prevRunState = e) {\n+            for (long e, prevRunState = 0L; ; prevRunState = e) {\n@@ -1987,2 +1945,2 @@\n-                if (((e = runState) & STOP) != 0)\n-                    return true;                          \/\/ terminating\n+                if (((e = runState) & STOP) != 0L)\n+                    return 1;                             \/\/ terminating\n@@ -1990,1 +1948,1 @@\n-                    return false;                         \/\/ at least one active\n+                    return -1;                            \/\/ at least one active\n@@ -1993,1 +1951,1 @@\n-                    WorkQueue[] qs = queues; WorkQueue q;\n+                    WorkQueue[] qs = queues;\n@@ -1996,0 +1954,1 @@\n+                        WorkQueue q;\n@@ -2001,2 +1960,2 @@\n-                                    signalWork(null, 0);  \/\/ ensure live\n-                                return false;\n+                                    signalWork();\n+                                return -1;\n@@ -2009,5 +1968,3 @@\n-                    return true;\n-                else if (compareAndSetCtl(c, c) && casRunState(e, e | STOP)) {\n-                    interruptAll();                       \/\/ confirmed\n-                    return true;                          \/\/ enable termination\n-                }\n+                    return 0;\n+                else if (compareAndSetCtl(c, c) && casRunState(e, e | STOP))\n+                    return 1;                             \/\/ enable termination\n@@ -2027,4 +1984,3 @@\n-        if (w != null) {\n-            int phase = w.phase, r = w.stackPred; \/\/ seed from registerWorker\n-            long window = (long)((r >>> 16) & SMASK) | NO_HISTORY;\n-            do {\n+        if (w != null) {              \/\/ use seed from registerWorker\n+            int phase = w.phase, r = w.stackPred, cfg = w.config;\n+            for (boolean recheck = false;;) {\n@@ -2032,3 +1988,11 @@\n-            } while ((runState & STOP) == 0 &&\n-                     (((window = scan(w, window, r)) < 0L ||\n-                       ((phase = awaitWork(w, phase)) & IDLE) == 0)));\n+                if ((runState & STOP) != 0L)\n+                    break;\n+                else if (scan(w, r, cfg))\n+                    recheck = false;\n+                else if (!recheck)   \/\/ rescan before deactivating\n+                    recheck = true;\n+                else if (((phase = deactivate(w, r, phase)) & IDLE) == 0)\n+                    recheck = false;\n+                else\n+                    break;\n+            }\n@@ -2040,2 +2004,2 @@\n-     * each queue starting at initial index with random stride,\n-     * returning next scan window and retry indicator.\n+     * each queue starting at random index with random stride,\n+     * returning retry indicator.\n@@ -2044,1 +2008,0 @@\n-     * @param window up to three queue indices\n@@ -2046,1 +2009,2 @@\n-     * @return the next window to use, with RESCAN set for rescan\n+     * @param cfg config bits\n+     * @return true if there are still unscanned queues\n@@ -2048,1 +2012,1 @@\n-    private long scan(WorkQueue w, long window, int r) {\n+    private boolean scan(WorkQueue w, int r, int cfg) {\n@@ -2050,27 +2014,8 @@\n-        int n = (qs == null) ? 0 : qs.length, step = (r << 1) | 1;\n-        long next = window & ~RESCAN;\n-        outer: for (int i = (short)window, l = n; l > 0; --l, i += step) {\n-            int j, cap; WorkQueue q; ForkJoinTask<?>[] a;\n-            if ((q = qs[j = i & SMASK & (n - 1)]) != null &&\n-                (a = q.array) != null && (cap = a.length) > 0) {\n-                for (int b = q.base;;) {\n-                    int nb = b + 1, nk = nb & (cap - 1), k;\n-                    ForkJoinTask<?> t = a[k = b & (cap - 1)];\n-                    U.loadFence();                \/\/ re-read b and t\n-                    if (b == (b = q.base)) {      \/\/ else inconsistent; retry\n-                        Object o;\n-                        if (t == null)\n-                            o = a[k];\n-                        else if (t == (o = U.compareAndExchangeReference(\n-                                           a, slotOffset(k), t, null))) {\n-                            q.updateBase(nb);\n-                            next = RESCAN | ((window << 16) & HMASK) | j;\n-                            if (window != next && a[nk] != null)\n-                                signalWork(a, nk); \/\/ limit propagation\n-                            if (w != null)        \/\/ always true\n-                                w.topLevelExec(t, q, j);\n-                            break outer;\n-                        }\n-                        if (o == null) {\n-                            if (next >= 0L && a[nk] != null)\n-                                next |= RESCAN;\n+        if (w != null && qs != null) {\n+            int n = qs.length, step = (r >>> 16) | 1;\n+            for (int i = r, l = n; l > 0; --l, i += step) {\n+                int j; WorkQueue q;\n+                if ((q = qs[j = i & (n - 1)]) != null) {\n+                    for (int retries = MAX_SCAN_RETRIES, b = q.base;;) {\n+                        int cap, k, nb; ForkJoinTask<?>[] a;\n+                        if ((a = q.array) == null || (cap = a.length) <= 0)\n@@ -2078,0 +2023,20 @@\n+                        long kp = slotOffset(k = (cap - 1) & b);\n+                        int nk = (nb = b + 1) & (cap - 1); \/\/ next slot\n+                        int sk = (b + 2) & (cap - 1);      \/\/ 2nd slot ahead\n+                        ForkJoinTask<?> t = a[k];\n+                        U.loadFence();\n+                        if (b == (b = q.base)) {          \/\/ else inconsistent\n+                            if (t != null) {\n+                                if (U.compareAndSetReference(a, kp, t, null)) {\n+                                    q.base = nb;\n+                                    w.source = j;         \/\/ volatile write\n+                                    if (a[nk] != null)\n+                                        signalWork();     \/\/ propagate signal\n+                                    w.topLevelExec(t, q, nb, cfg);\n+                                    return true;\n+                                }\n+                                b = q.base;\n+                            }\n+                            else if (a[sk] == null && a[nk] == null &&\n+                                     a[k] == null)\n+                                break;                    \/\/ probably empty\n@@ -2079,0 +2044,2 @@\n+                        if (b != nb && --retries == 0)\n+                            return true;                  \/\/ stalled; move\n@@ -2083,1 +2050,1 @@\n-        return next;\n+        return false;\n@@ -2087,1 +2054,1 @@\n-     * Tries to inactivate, and if successful, awaits signal or termination.\n+     * Deactivates and if necessary awaits signal or termination.\n@@ -2089,1 +2056,2 @@\n-     * @param w the worker (may be null if already terminated)\n+     * @param w the worker\n+     * @param r random seed\n@@ -2093,7 +2061,6 @@\n-    private int awaitWork(WorkQueue w, int phase) {\n-        boolean quiet;                           \/\/ true if possibly quiescent\n-        int active = phase + (IDLE << 1), p = phase | IDLE, e;\n-        if (w != null) {\n-            w.phase = p;                         \/\/ deactivate\n-            long np = active & LMASK, pc = ctl;  \/\/ try to enqueue\n-            long qc = np | ((pc - RC_UNIT) & UMASK);\n+    private int deactivate(WorkQueue w, int r, int phase) {\n+        int p = phase | IDLE;\n+        if (w != null) {                         \/\/ currently always true\n+            w.phase = p;\n+            int active = phase + (IDLE << 1), ac;\n+            long pc = ctl, qc = (active & LMASK) | ((pc - RC_UNIT) & UMASK);\n@@ -2101,31 +2068,20 @@\n-            if (pc != (pc = compareAndExchangeCtl(pc, qc))) {\n-                qc = np | ((pc - RC_UNIT) & UMASK);\n-                w.stackPred = (int)pc;           \/\/ retry once\n-                if (pc != (pc = compareAndExchangeCtl(pc, qc)))\n-                    p = w.phase = phase;         \/\/ back out\n-            }\n-            if (p != phase && ((e = runState) & STOP) == 0 &&\n-                (!(quiet = (qc & RC_MASK) <= 0L) || (e & SHUTDOWN) == 0 ||\n-                 !(quiet = quiescent()) || (runState & STOP) == 0)) {\n-                long deadline = 0L;              \/\/ not terminating\n-                if (quiet) {                     \/\/ use timeout if trimmable\n-                    int nt = (short)(qc >>> TC_SHIFT);\n-                    long delay = keepAlive;      \/\/ scale if not at target\n-                    if (nt != (nt = Math.max(nt, parallelism)) && nt > 0)\n-                        delay = Math.max(TIMEOUT_SLOP, delay \/ nt);\n-                    if ((deadline = delay + System.currentTimeMillis()) == 0L)\n-                        deadline = 1L;           \/\/ avoid zero\n-                }\n-                boolean release = quiet;\n-                WorkQueue[] qs = queues;         \/\/ recheck queues\n-                int n = (qs == null) ? 0 : qs.length;\n-                for (int l = -n, j = active; l < n; ++l, ++j) {\n-                    WorkQueue q; ForkJoinTask<?>[] a; int cap;\n-                    if ((p = w.phase) == active) \/\/ interleave signal checks\n-                        break;\n-                    if ((q = qs[j & (n - 1)]) != null &&\n-                        (a = q.array) != null && (cap = a.length) > 0 &&\n-                        a[q.base & (cap - 1)] != null) {\n-                        if (release && qc == ctl && compareAndSetCtl(qc, pc)) {\n-                            p = w.phase = active;\n-                            break;               \/\/ possible missed signal\n+            if ((runState & STOP) != 0L || !compareAndSetCtl(pc, qc))\n+                p = w.phase = phase;             \/\/ back out\n+            else if ((ac = (short)(qc >>> RC_SHIFT)) > 0 ||\n+                     quiescent() <= 0) {         \/\/ check quiescent termination\n+                WorkQueue[] qs;\n+                int spins = ac + ((short)(qc >>> TC_SHIFT) << 1) + SPIN_WAITS;\n+                while (((p = w.phase) & IDLE) != 0 && --spins != 0)\n+                    Thread.onSpinWait();         \/\/ reduce flailing\n+                if ((p & IDLE) != 0 && (qs = queues) != null) {\n+                    int n = qs.length, step = (r >>> 16) | 1;\n+                    for (int i = r, l = n; l > 0; --l, i += step) {\n+                        WorkQueue q;             \/\/ check for missed signals\n+                        if ((q = qs[i & (n - 1)]) != null &&\n+                            q.top - q.base > 0) {\n+                            if (((p = w.phase) & IDLE) == 0)\n+                                break;\n+                            if (ctl == qc && compareAndSetCtl(qc, pc)) {\n+                                p = w.phase = active;\n+                                break;           \/\/ self-signal\n+                            }\n@@ -2133,1 +2089,0 @@\n-                        release = true;          \/\/ track multiple or reencounter\n@@ -2135,1 +2090,2 @@\n-                    Thread.onSpinWait();         \/\/ reduce memory traffic\n+                    if ((p & IDLE) != 0)         \/\/ block\n+                        p = awaitWork(w, qc);\n@@ -2137,8 +2093,32 @@\n-                if (p != active) {               \/\/ emulate LockSupport.park\n-                    LockSupport.setCurrentBlocker(this);\n-                    w.parking = 1;\n-                    for (;;) {\n-                        if ((runState & STOP) != 0 || (p = w.phase) == active)\n-                            break;\n-                        U.park(deadline != 0L, deadline);\n-                        if ((p = w.phase) == active || (runState & STOP) != 0)\n+            }\n+        }\n+        return p;\n+    }\n+\n+    \/**\n+     * Awaits signal or termination.\n+     *\n+     * @param w the worker\n+     * @param queuedCtl queued ctl value\n+     * @return current phase, with IDLE set if worker should exit\n+     *\/\n+    private int awaitWork(WorkQueue w, long queuedCtl) {\n+        int p = IDLE;\n+        boolean trimmable = false;\n+        long deadline = 0L;                     \/\/ timeout if trimmable\n+        if (w != null) {\n+            if ((queuedCtl & RC_MASK) <= 0L) {\n+                long ka = (w.source == INVALID_ID) ? TIMEOUT_SLOP : keepAlive;\n+                long d = ka + System.currentTimeMillis();\n+                if (trimmable = (ctl == queuedCtl))\n+                    deadline = d;               \/\/ minimal keepAlive if cascading\n+            }\n+            if (((p = w.phase) & IDLE) != 0) {  \/\/ emulate LockSupport.park\n+                LockSupport.setCurrentBlocker(this);\n+                w.source = PARKING;             \/\/ enable unpark\n+                while ((runState & STOP) == 0L && ((p = w.phase) & IDLE) != 0) {\n+                    int trim;\n+                    if (!Thread.interrupted())\n+                        U.park(trimmable, deadline);\n+                    if (trimmable) {\n+                        if ((trim = tryTrim(w, queuedCtl, deadline)) > 0)\n@@ -2146,12 +2126,3 @@\n-                        Thread.interrupted();    \/\/ clear for next park\n-                        if (deadline != 0L && TIMEOUT_SLOP >\n-                            deadline - System.currentTimeMillis()) {\n-                            long sp = w.stackPred & LMASK, c = ctl;\n-                            long nc = sp | (UMASK & (c - TC_UNIT));\n-                            if (((int)c & SMASK) == (active & SMASK) &&\n-                                compareAndSetCtl(c, nc)) {\n-                                w.source = DEREGISTERED;\n-                                w.phase = active;\n-                                break;           \/\/ trimmed on timeout\n-                            }\n-                            deadline = 0L;       \/\/ no longer trimmable\n+                        else if (trim < 0) {\n+                            trimmable = false;\n+                            deadline = 0L;\n@@ -2160,2 +2131,0 @@\n-                    w.parking = 0;\n-                    LockSupport.setCurrentBlocker(null);\n@@ -2163,0 +2132,2 @@\n+                w.source = 0;\n+                LockSupport.setCurrentBlocker(null);\n@@ -2168,0 +2139,31 @@\n+    \/**\n+     * Tries to remove and deregister worker after timeout, and release\n+     * another to do the same.\n+     * @return > 0: trimmed, < 0 : not trimmable, else 0\n+     *\/\n+    private int tryTrim(WorkQueue w, long queuedCtl, long deadline) {\n+        long c, nc; int stat, p, vp, i; WorkQueue[] vs; WorkQueue v;\n+        if ((c = ctl) != queuedCtl || w == null || ((p = w.phase) & IDLE) == 0)\n+            stat = -1;\n+        else if (deadline - System.currentTimeMillis() >= TIMEOUT_SLOP)\n+            stat = 0;                       \/\/ spurious wakeup\n+        else if (!compareAndSetCtl(\n+                     c, nc = (w.stackPred & LMASK) | (UMASK & (c - TC_UNIT))))\n+            stat = -1;                      \/\/ lost race to signaller\n+        else {\n+            stat = 1;\n+            w.source = DROPPED;\n+            w.phase = p + IDLE;\n+            if ((vp = (int)nc) != 0 && (vs = queues) != null &&\n+                vs.length > (i = vp & SMASK) && (v = vs[i]) != null &&\n+                compareAndSetCtl(           \/\/ try to wake up next waiter\n+                    nc, ((UMASK & (nc + RC_UNIT)) |\n+                         (nc & TC_MASK) | (v.stackPred & LMASK)))) {\n+                v.source = INVALID_ID;      \/\/ enable cascaded timeouts\n+                v.phase = vp;\n+                U.unpark(v.owner);\n+            }\n+        }\n+        return stat;\n+    }\n+\n@@ -2176,1 +2178,1 @@\n-        if ((runState & STOP) == 0) {\n+        if ((runState & STOP) == 0L) {\n@@ -2185,1 +2187,1 @@\n-                        (t = q.poll(this)) != null)\n+                        (t = q.poll()) != null)\n@@ -2220,1 +2222,1 @@\n-                if (v.parking != 0)\n+                if (v.source < 0)\n@@ -2231,1 +2233,1 @@\n-            if ((runState & STOP) != 0)                 \/\/ terminating\n+            if ((runState & STOP) != 0L)                \/\/ terminating\n@@ -2264,1 +2266,0 @@\n-\n@@ -2276,1 +2277,1 @@\n-                    if ((runState & STOP) != 0)\n+                    if ((runState & STOP) != 0L)\n@@ -2357,1 +2358,1 @@\n-                    if ((runState & STOP) != 0)\n+                    if ((runState & STOP) != 0L)\n@@ -2435,2 +2436,2 @@\n-        for (int e = runState;;) {\n-            if ((e & STOP) != 0)\n+        for (long e = runState;;) {\n+            if ((e & STOP) != 0L)\n@@ -2489,1 +2490,1 @@\n-                rescan || (e & RS_LOCK) != 0)\n+                rescan || (e & RS_LOCK) != 0L)\n@@ -2521,1 +2522,1 @@\n-        if (!quiescent()) {\n+        if (quiescent() < 0) {\n@@ -2532,1 +2533,1 @@\n-                else if (quiescent())\n+                else if (quiescent() >= 0)\n@@ -2603,2 +2604,2 @@\n-                int stop = lockRunState() & STOP;\n-                if (stop == 0 && queues == qs && qs[i] == null)\n+                long stop = lockRunState() & STOP;\n+                if (stop == 0L && queues == qs && qs[i] == null)\n@@ -2609,1 +2610,1 @@\n-                if (stop != 0)\n+                if (stop != 0L)\n@@ -2614,1 +2615,1 @@\n-            else if ((runState & SHUTDOWN) != 0) {\n+            else if ((runState & SHUTDOWN) != 0L) {\n@@ -2756,16 +2757,10 @@\n-    private int tryTerminate(boolean now, boolean enable) {\n-        int e = runState;\n-        if ((e & STOP) == 0) {\n-            if (now) {\n-                int s = lockRunState();\n-                runState = e = (s + RS_LOCK) | STOP | SHUTDOWN;\n-                if ((s & STOP) == 0)\n-                    interruptAll();\n-            }\n-            else {\n-                int isShutdown = (e & SHUTDOWN);\n-                if (isShutdown == 0 && enable)\n-                    getAndBitwiseOrRunState(isShutdown = SHUTDOWN);\n-                if (isShutdown != 0)\n-                    quiescent();                 \/\/ may trigger STOP\n-                e = runState;\n+    private long tryTerminate(boolean now, boolean enable) {\n+        long e = runState, isShutdown;\n+        if ((e & STOP) == 0L) {\n+            if (now)\n+                runState = e = (lockRunState() + RS_LOCK) | STOP | SHUTDOWN;\n+            else if ((isShutdown = (e & SHUTDOWN)) != 0 || enable) {\n+                if (isShutdown == 0)\n+                    getAndBitwiseOrRunState(SHUTDOWN);\n+                if (quiescent() > 0)\n+                    e = runState;\n@@ -2773,0 +2768,2 @@\n+            if ((e & STOP) != 0L && (releaseAll() & RC_MASK) > 0L && now)\n+                interruptAll();\n@@ -2775,10 +2772,14 @@\n-            int r = (int)Thread.currentThread().threadId(); \/\/ stagger traversals\n-            WorkQueue[] qs = queues;\n-            int n = (qs == null) ? 0 : qs.length;\n-            for (int l = n; l > 0; --l, ++r) {\n-                int j = r & SMASK & (n - 1); WorkQueue q; ForkJoinTask<?> t;\n-                while ((q = qs[j]) != null && q.source != DEREGISTERED &&\n-                       (t = q.poll(null)) != null) {\n-                    try {\n-                        t.cancel(false);\n-                    } catch (Throwable ignore) {\n+            if ((ctl & RC_MASK) > 0L) {          \/\/ unless all inactive\n+                int r = (int)Thread.currentThread().threadId();\n+                WorkQueue[] qs = queues;         \/\/ stagger traversals\n+                int n = (qs == null) ? 0 : qs.length;\n+                for (int l = n; l > 0; --l, ++r) {\n+                    WorkQueue q; ForkJoinTask<?> t;\n+                    if ((q = qs[r & (n - 1)]) != null &&\n+                        q.source != DROPPED) {\n+                        while ((t = q.poll()) != null) {\n+                            try {\n+                                t.cancel(false);\n+                            } catch (Throwable ignore) {\n+                            }\n+                        }\n@@ -2788,2 +2789,3 @@\n-            if (((e = runState) & TERMINATED) == 0 && ctl == 0L) {\n-                if ((getAndBitwiseOrRunState(TERMINATED) & TERMINATED) == 0) {\n+            if (((e = runState) & TERMINATED) == 0L && ctl == 0L) {\n+                e |= TERMINATED;\n+                if ((getAndBitwiseOrRunState(TERMINATED) & TERMINATED) == 0L) {\n@@ -2796,1 +2798,0 @@\n-                e = runState;\n@@ -2812,1 +2813,1 @@\n-                q.source != DEREGISTERED) {\n+                q.source != DROPPED) {\n@@ -3472,1 +3473,1 @@\n-        if ((runState & TERMINATED) == 0 && (qs = queues) != null) {\n+        if ((runState & TERMINATED) == 0L && (qs = queues) != null) {\n@@ -3504,1 +3505,1 @@\n-        return quiescent();\n+        return quiescent() >= 0;\n@@ -3544,1 +3545,1 @@\n-        if ((runState & TERMINATED) == 0 && (qs = queues) != null) {\n+        if ((runState & TERMINATED) == 0L && (qs = queues) != null) {\n@@ -3563,1 +3564,1 @@\n-        if ((runState & TERMINATED) == 0 && (qs = queues) != null) {\n+        if ((runState & TERMINATED) == 0L && (qs = queues) != null) {\n@@ -3580,1 +3581,1 @@\n-        if ((runState & STOP) == 0 && (qs = queues) != null) {\n+        if ((runState & STOP) == 0L && (qs = queues) != null) {\n@@ -3635,1 +3636,1 @@\n-        int e = runState;\n+        long e = runState;\n@@ -3661,3 +3662,3 @@\n-        String level = ((e & TERMINATED) != 0 ? \"Terminated\" :\n-                        (e & STOP)       != 0 ? \"Terminating\" :\n-                        (e & SHUTDOWN)   != 0 ? \"Shutting down\" :\n+        String level = ((e & TERMINATED) != 0L ? \"Terminated\" :\n+                        (e & STOP)       != 0L ? \"Terminating\" :\n+                        (e & SHUTDOWN)   != 0L ? \"Shutting down\" :\n@@ -3754,1 +3755,1 @@\n-        return (runState & SHUTDOWN) != 0;\n+        return (runState & SHUTDOWN) != 0L;\n@@ -3782,1 +3783,1 @@\n-                 (runState & TERMINATED) != 0)\n+                 (runState & TERMINATED) != 0L)\n@@ -3971,1 +3972,1 @@\n-            if ((runState & STOP) != 0)\n+            if ((runState & STOP) != 0L)\n@@ -3991,0 +3992,1 @@\n+     * @return value to use in endCompensatedBlock\n@@ -4000,0 +4002,1 @@\n+     * @param post value from beginCompensatedBlock\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":434,"deletions":431,"binary":false,"changes":865,"status":"modified"}]}