{"files":[{"patch":"@@ -344,1 +344,1 @@\n-     * The poll operations in q.poll(), scan(), helpJoin(), and\n+     * The poll operations in q.poll(), runWorker(), helpJoin(), and\n@@ -548,1 +548,1 @@\n-     *    external producer, each worker taking its first (since the last\n+     *    producer, each worker taking its first (since the last\n@@ -577,1 +577,1 @@\n-     * Scanning. Method scan performs top-level scanning for (and\n+     * Scanning. Method runWorker performs top-level scanning for (and\n@@ -586,19 +586,18 @@\n-     * suffice. Each queue's polling attempt uses a bounded retry\n-     * (MAX_SCAN_RETRIES) to avoid becoming stuck when other\n-     * scanners\/pollers stall.  Scans do not otherwise explicitly take\n-     * into account core affinities, loads, cache localities, etc,\n-     * However, they do exploit temporal locality (which usually\n-     * approximates these) by preferring to re-poll from the same\n-     * queue after a successful poll before trying others, which also\n-     * reduces bookkeeping, cache traffic, and scanning overhead. But\n-     * it also reduces fairness, which is partially counteracted by\n-     * giving up on contention.\n-     *\n-     * Deactivation. When method scan indicates (twice) that no tasks\n-     * are found by a worker, it tries to deactivate()), giving up\n-     * (and rescanning) on \"ctl\" contention. To avoid missed signals\n-     * during deactivation, the method rescans and reactivates if\n-     * there may have been a missed signal during\n-     * deactivation. Because idle workers are often not yet blocked\n-     * (parked), we use a WorkQueue field to advertise that a waiter\n-     * actually needs unparking upon signal.\n+     * suffice. Each queue's polling attempt o avoid becoming stuck\n+     * when other scanners\/pollers stall.  Scans do not otherwise\n+     * explicitly take into account core affinities, loads, cache\n+     * localities, etc, However, they do exploit temporal locality\n+     * (which usually approximates these) by preferring to re-poll\n+     * from the same queue after a successful poll before trying\n+     * others, which also reduces bookkeeping, cache traffic, and\n+     * scanning overhead. But it also reduces fairness, which is\n+     * partially counteracted by giving up on detected interference in\n+     * async mode.\n+     *\n+     * Deactivation. When no tasks are found by a worker in runWorker,\n+     * it tries to deactivate()), giving up (and rescanning) on \"ctl\"\n+     * contention. To avoid missed signals during deactivation, the\n+     * method rescans and reactivates if there may have been a missed\n+     * signal during deactivation.  Because idle workers are often not\n+     * yet blocked (parked), we use a WorkQueue field to advertise\n+     * that a waiter actually needs unparking upon signal.\n@@ -992,1 +991,0 @@\n-    \/\/        INITIAL_QUEUE_CAPACITY << 2;\n@@ -1025,1 +1023,0 @@\n-    static final int MAX_SCAN_RETRIES = 8;        \/\/ limit stalls in scan()\n@@ -1242,1 +1239,0 @@\n-            \/\/            top = base = 1;\n@@ -1287,2 +1283,1 @@\n-                else if ((room == 0 || room == m || a[m & (s - 1)] == null) &&\n-                         pool != null)\n+                else if (room > 0 && a[m & (s - 1)] == null && pool != null)\n@@ -1426,3 +1421,5 @@\n-                    else if (a[sk] == null && a[nk] == null &&\n-                             a[k] == null && top - b <= 0)\n-                        break;                     \/\/ empty\n+                    else if (a[sk] == null && a[nk] == null && a[k] == null) {\n+                        if (top - b <= 0)\n+                            break;                 \/\/ empty\n+                        Thread.onSpinWait();       \/\/ stalled\n+                    }\n@@ -1430,2 +1427,0 @@\n-                if (b != nb)                       \/\/ stalled\n-                    Thread.onSpinWait();\n@@ -1439,2 +1434,1 @@\n-         * Runs the given task, as well as remaining local tasks, plus\n-         * those from src queue that can be taken without interference.\n+         * Runs the given task, as well as remaining local tasks.\n@@ -1442,24 +1436,5 @@\n-        final void topLevelExec(ForkJoinTask<?> task, WorkQueue src,\n-                                int srcBase, int cfg) {\n-            if (task != null && src != null) {  \/\/ always true\n-                int fifo = cfg & FIFO, nstolen = 1;\n-                for (;;) {\n-                    task.doExec();\n-                    if ((task = nextLocalTask(fifo)) == null) {\n-                        int k, b, cap; ForkJoinTask<?>[] a;\n-                        if ((a = src.array) == null || (cap = a.length) <= 0 ||\n-                            \/\/ check interference on initial exec\n-                            ((b = src.base) != srcBase && nstolen == 1) ||\n-                            (task = a[k = (cap - 1) & b]) == null)\n-                            break;\n-                        U.loadFence();\n-                        if (src.base != b || !U.compareAndSetReference(\n-                                a, slotOffset(k), task, null))\n-                            break;\n-                        src.updateBase(b + 1);\n-                        ++nstolen;\n-                    }\n-                }\n-                nsteals += nstolen;\n-                if ((cfg & CLEAR_TLS) != 0)\n-                    ThreadLocalRandom.eraseThreadLocals(Thread.currentThread());\n+        final void topLevelExec(ForkJoinTask<?> task, int cfg) {\n+            int fifo = cfg & FIFO;\n+            while (task != null) {\n+                task.doExec();\n+                task = nextLocalTask(fifo);\n@@ -1467,0 +1442,2 @@\n+            if ((cfg & CLEAR_TLS) != 0)\n+                ThreadLocalRandom.eraseThreadLocals(Thread.currentThread());\n@@ -1907,1 +1884,1 @@\n-            if (c == (c = ctl) && c == (c = compareAndExchangeCtl(c, nc | ac))) {\n+            if (c == (c = compareAndExchangeCtl(c, nc | ac))) {\n@@ -1917,2 +1894,0 @@\n-            if ((runState & STOP) != 0L)\n-                break;\n@@ -1970,3 +1945,1 @@\n-                            if ((p & IDLE) == 0 || s - b > 0) {\n-                                if ((i & 1) == 0 && compareAndSetCtl(c, c))\n-                                    signalWork();\n+                            if ((p & IDLE) == 0 || s - b > 0)\n@@ -1974,1 +1947,0 @@\n-                            }\n@@ -1996,3 +1968,6 @@\n-        if (w != null) {              \/\/ use seed from registerWorker\n-            int phase = w.phase, r = w.stackPred, cfg = w.config;\n-            for (boolean recheck = false;;) {\n+        if (w != null) {\n+            WorkQueue[] qs;\n+            int phase = w.phase, r = w.stackPred; \/\/ seed from registerWorker\n+            int cfg = w.config, src = -1, ntaken = 0;\n+            for (boolean working = false;;) {     \/\/ true if ran since activated\n+                boolean taken = false;\n@@ -2000,9 +1975,1 @@\n-                if ((runState & STOP) != 0L)\n-                    break;\n-                else if (scan(w, r, cfg))\n-                    recheck = false;\n-                else if (!recheck)   \/\/ rescan before deactivating\n-                    recheck = true;\n-                else if (((phase = deactivate(w, r, phase)) & IDLE) == 0)\n-                    recheck = false;\n-                else\n+                if ((runState & STOP) != 0L || (qs = queues) == null)\n@@ -2010,37 +1977,29 @@\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Scans for and if found executes top-level tasks: Tries to poll\n-     * each queue starting at random index with random stride,\n-     * returning retry indicator.\n-     *\n-     * @param w caller's WorkQueue\n-     * @param r random seed\n-     * @param cfg config bits\n-     * @return true if there are still unscanned queues\n-     *\/\n-    private boolean scan(WorkQueue w, int r, int cfg) {\n-        WorkQueue[] qs = queues;\n-        if (w != null && qs != null) {\n-            int n = qs.length, step = (r >>> 16) | 1;\n-            for (int i = r, l = n; l > 0; --l, i += step) {\n-                int j, cap; WorkQueue q; ForkJoinTask<?>[] a;\n-                if ((q = qs[j = i & (n - 1)]) != null &&\n-                    (a = q.array) != null && (cap = a.length) > 0) {\n-                    for (int retries = MAX_SCAN_RETRIES, b = q.base, k, nb;;) {\n-                        long kp = slotOffset(k = (cap - 1) & b);\n-                        int nk = (nb = b + 1) & (cap - 1); \/\/ next slot\n-                        int sk = (b + 2) & (cap - 1);      \/\/ 2nd slot ahead\n-                        ForkJoinTask<?> t = a[k];\n-                        U.loadFence();\n-                        if (b == (b = q.base)) {           \/\/ else inconsistent\n-                            if (t != null) {\n-                                if (U.compareAndSetReference(a, kp, t, null)) {\n-                                    q.base = nb;\n-                                    w.source = j;          \/\/ volatile write\n-                                    if (a[nk] != null && (j & 1) == 0)\n-                                        signalWork();      \/\/ propagate signal\n-                                    w.topLevelExec(t, q, nb, cfg);\n-                                    return true;\n+                int n = qs.length, i = r, step = (r >>> 16) | 1;\n+                for (int l = n; l > 0; --l, i += step) {  \/\/ scan queues\n+                    int j; WorkQueue q;\n+                    if ((q = qs[j = i & (n - 1)]) != null) {\n+                        for (int b = q.base;;) {\n+                            int cap, k, nb; ForkJoinTask<?>[] a;\n+                            if ((a = q.array) == null || (cap = a.length) <= 0)\n+                                break;\n+                            long kp = slotOffset(k = (cap - 1) & b);\n+                            int nk = (nb = b + 1) & (cap - 1); \/\/ next slot\n+                            int sk = (b + 2) & (cap - 1); \/\/ 2nd slot ahead\n+                            ForkJoinTask<?> t = a[k];\n+                            U.loadFence();\n+                            if (b != (b = q.base))\n+                                ;                         \/\/ inconsistent\n+                            else if (t == null) {\n+                                if (a[sk] == null && a[nk] == null &&\n+                                    a[k] == null &&       \/\/ screen size check\n+                                    ((taken & !working) || q.top - b <= 0))\n+                                    break;\n+                            }\n+                            else if (U.compareAndSetReference(a, kp, t, null)) {\n+                                q.base = nb;\n+                                w.nsteals = ++ntaken;\n+                                w.source = j;             \/\/ volatile write\n+                                if (!taken) {\n+                                    taken = true;\n+                                    if (!working && a[nk] != null)\n+                                        signalWork();     \/\/ propagate signal\n@@ -2048,0 +2007,1 @@\n+                                w.topLevelExec(t, cfg);\n@@ -2049,0 +2009,2 @@\n+                                if (src != (src = j) && b != nb)\n+                                    break;                \/\/ reduce interference\n@@ -2050,6 +2012,2 @@\n-                            else if (a[sk] == null && a[nk] == null &&\n-                                     a[k] == null) {\n-                                if (q.array != a)          \/\/ resized; restart\n-                                    return true;\n-                                break;                     \/\/ probably empty\n-                            }\n+                            else if (taken & !working)    \/\/ new contention\n+                                break;\n@@ -2057,2 +2015,2 @@\n-                        if (b != nb && --retries == 0)\n-                            return true;                   \/\/ stalled; move\n+                        if (taken)                       \/\/ restart scan\n+                            break;\n@@ -2061,0 +2019,3 @@\n+                if (!(working = taken) &&\n+                    ((phase = deactivate(w, r, phase)) & IDLE) != 0)\n+                    break;\n@@ -2063,1 +2024,0 @@\n-        return false;\n@@ -2075,2 +2035,2 @@\n-        int p = phase | IDLE;\n-        if (w != null) {                         \/\/ currently always true\n+        int p = phase | IDLE, active = phase + (IDLE << 1);\n+        if (w != null) {                         \/\/ always true\n@@ -2078,7 +2038,13 @@\n-            int active = phase + (IDLE << 1), ac;\n-            long pc = ctl, qc = (active & LMASK) | ((pc - RC_UNIT) & UMASK);\n-            w.stackPred = (int)pc;               \/\/ set ctl stack link\n-            if ((runState & STOP) != 0L || !compareAndSetCtl(pc, qc))\n-                p = w.phase = phase;             \/\/ back out\n-            else if ((ac = (short)(qc >>> RC_SHIFT)) > 0 ||\n-                     quiescent() <= 0) {         \/\/ check quiescent termination\n+            long pc = ctl, qc;\n+            for (;;) {                           \/\/ try to enqueue\n+                w.stackPred = (int)pc;           \/\/ set ctl stack link\n+                qc = (active & LMASK) | ((pc - RC_UNIT) & UMASK);\n+                if (pc == (pc = compareAndExchangeCtl(pc, qc)))\n+                    break;\n+                if ((pc & RC_MASK) >= (qc & RC_MASK)) {\n+                    p = w.phase = phase;         \/\/ back out on possible signal\n+                    break;\n+                }\n+            }\n+            if (p != phase &&                    \/\/ check quiescent termination\n+                ((runState & SHUTDOWN) == 0 || quiescent() <= 0)) {\n@@ -2086,2 +2052,2 @@\n-                int spins = ac + ((short)(qc >>> TC_SHIFT) << 1) + SPIN_WAITS;\n-                while (((p = w.phase) & IDLE) != 0 && --spins >= 0)\n+                int spins = ((short)(qc >>> TC_SHIFT) << 1) + SPIN_WAITS + 1;\n+                while (((p = w.phase) & IDLE) != 0 && --spins > 0)\n@@ -2095,2 +2061,0 @@\n-                            if (((p = w.phase) & IDLE) == 0)\n-                                break;\n@@ -2101,0 +2065,2 @@\n+                            if (((p = w.phase) & IDLE) == 0)\n+                                break;\n@@ -2103,2 +2069,2 @@\n-                    if ((p & IDLE) != 0)         \/\/ block\n-                        p = awaitWork(w, qc);\n+                    if ((p & IDLE) != 0)\n+                        p = awaitWork(w, qc);    \/\/ block\n@@ -2120,3 +2086,3 @@\n-        boolean trimmable = false;\n-        long deadline = 0L;                     \/\/ timeout if trimmable\n-        if (w != null) {\n+        if (w != null && ((p = w.phase) & IDLE) != 0) {\n+            boolean trimmable = false;          \/\/ possibly drop if quiescent\n+            long deadline = 0L;                 \/\/ timeout if trimmable\n@@ -2129,5 +2095,6 @@\n-            if (((p = w.phase) & IDLE) != 0) {  \/\/ emulate LockSupport.park\n-                LockSupport.setCurrentBlocker(this);\n-                w.source = PARKING;             \/\/ enable unpark\n-                while ((runState & STOP) == 0L && ((p = w.phase) & IDLE) != 0) {\n-                    int trim;\n+            LockSupport.setCurrentBlocker(this);\n+            w.source = PARKING;                 \/\/ enable unpark\n+            if (((p = w.phase) & IDLE) != 0) {\n+                for (int trim;;) {\n+                    if ((runState & STOP) != 0L)\n+                        break;\n@@ -2136,0 +2103,2 @@\n+                    if (((p = w.phase) & IDLE) == 0)\n+                        break;\n@@ -2139,1 +2108,1 @@\n-                        else if (trim < 0) {\n+                        if (trim < 0) {\n@@ -2145,2 +2114,0 @@\n-                w.source = 0;\n-                LockSupport.setCurrentBlocker(null);\n@@ -2148,0 +2115,2 @@\n+            w.source = 0;\n+            LockSupport.setCurrentBlocker(null);\n@@ -2160,1 +2129,1 @@\n-            stat = -1;\n+            stat = -1;                      \/\/ no longer ctl top\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":119,"deletions":150,"binary":false,"changes":269,"status":"modified"}]}