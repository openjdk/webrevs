{"files":[{"patch":"@@ -552,5 +552,6 @@\n-     *    activation. Emptiness must be conservatively approximated,\n-     *    sometimes resulting in unnecessary signals.  Also, to reduce\n-     *    resource usages in some cases, at the expense of slower\n-     *    startup in others, activation of an idle thread is preferred\n-     *    over creating a new one, here and elsewhere.\n+     *    activation. Emptiness must be conservatively approximated\n+     *    (by checking if there is apparently at most one existing\n+     *    task) which may result in unnecessary signals.  Also, to\n+     *    reduce resource usages in some cases, at the expense of\n+     *    slower startup in others, activation of an idle thread is\n+     *    preferred over creating a new one, here and elsewhere.\n@@ -1225,1 +1226,0 @@\n-        private static final long SOURCE;\n@@ -1237,3 +1237,0 @@\n-        final void updateSource(int v) {\n-            U.getAndSetInt(this, SOURCE, v);\n-        }\n@@ -1303,1 +1300,3 @@\n-                else if ((room == 0 || a[m & (s - 2)] == null) && pool != null)\n+                else if ((room == 0 ||\n+                          a[m & (s - 2)] == null) && \/\/ at most one existing task\n+                         pool != null)\n@@ -1605,1 +1604,0 @@\n-            SOURCE = U.objectFieldOffset(klass, \"source\");\n@@ -1966,3 +1964,1 @@\n-                            if ((p & IDLE) == 0 || s - b > 0) {\n-                                if ((i & 1) == 0 && compareAndSetCtl(c, c))\n-                                    signalWork();        \/\/ ensure live\n+                            if ((p & IDLE) == 0 || s - b > 0)\n@@ -1970,1 +1966,0 @@\n-                            }\n@@ -1995,1 +1990,1 @@\n-            rescan: for (;;) {\n+            rescan: for (boolean scanned = false;;) {\n@@ -2001,1 +1996,1 @@\n-                for (int l = -n; l < n; ++l, i += step) {  \/\/ scan queues (twice)\n+                for (int l = n; l > 0; --l, i += step) {  \/\/ scan queues\n@@ -2005,1 +2000,1 @@\n-                        for (int b = q.base;;) {\n+                        for (int pb = -1, b = q.base;;) {\n@@ -2028,1 +2023,2 @@\n-                                Thread.onSpinWait();\n+                                if (pb == (pb = b))       \/\/ base unchanged\n+                                    Thread.onSpinWait();\n@@ -2035,1 +2031,1 @@\n-                                w.updateSource(j);        \/\/ fully fenced\n+                                w.source = j;             \/\/ volatile write\n@@ -2045,1 +2041,5 @@\n-                if (((phase = deactivate(w, r, phase)) & IDLE) != 0)\n+                if (!scanned)\n+                    scanned = true;                   \/\/ rescan before deactivate\n+                else if (((phase = deactivate(w, r, phase)) & IDLE) == 0)\n+                    scanned = false;\n+                else\n@@ -2060,1 +2060,1 @@\n-        int p = phase | IDLE, active = phase + (IDLE << 1);\n+        int p = phase | IDLE, activePhase = phase + (IDLE << 1);\n@@ -2066,1 +2066,1 @@\n-                qc = (active & LMASK) | ((pc - RC_UNIT) & UMASK);\n+                qc = (activePhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n@@ -2075,1 +2075,1 @@\n-                ((qc & RC_MASK) > 0L || quiescent() <= 0)) {\n+                ((runState & SHUTDOWN) == 0L || quiescent() <= 0)) {\n@@ -2078,1 +2078,1 @@\n-                while ((p = w.phase) != active && --spins > 0)\n+                while ((p = w.phase) != activePhase && --spins > 0)\n@@ -2080,1 +2080,1 @@\n-                if (p != active && (qs = queues) != null) {\n+                if (p != activePhase && (qs = queues) != null) {\n@@ -2087,1 +2087,1 @@\n-                                p = w.phase = active;\n+                                p = w.phase = activePhase;\n@@ -2090,1 +2090,1 @@\n-                            if ((p = w.phase) == active)\n+                            if ((p = w.phase) == activePhase)\n@@ -2094,1 +2094,1 @@\n-                    if (p != active) {\n+                    if (p != activePhase) {\n@@ -2098,1 +2098,1 @@\n-                        if ((p = w.phase) != active)\n+                        if ((p = w.phase) != activePhase)\n@@ -2111,0 +2111,1 @@\n+     * @param p current phase (known to be idle)\n@@ -2116,1 +2117,1 @@\n-            int active = p + IDLE;\n+            int activePhase = p + IDLE;\n@@ -2121,1 +2122,1 @@\n-            while ((p = w.phase) != active) {\n+            while ((p = w.phase) != activePhase) {\n@@ -2148,2 +2149,2 @@\n-        long c, nc; int stat, nextPhase, vp, i; WorkQueue[] vs; WorkQueue v;\n-        if ((nextPhase = phase + IDLE) != (int)(c = ctl) || w == null)\n+        long c, nc; int stat, activePhase, vp, i; WorkQueue[] vs; WorkQueue v;\n+        if ((activePhase = phase + IDLE) != (int)(c = ctl) || w == null)\n@@ -2159,1 +2160,1 @@\n-            w.phase = nextPhase;\n+            w.phase = activePhase;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":36,"deletions":35,"binary":false,"changes":71,"status":"modified"}]}