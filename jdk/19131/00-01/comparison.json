{"files":[{"patch":"@@ -548,1 +548,1 @@\n-     *    producer, each worker taking its first (since the last\n+     *    external producer, each worker taking its first (since the last\n@@ -554,1 +554,1 @@\n-     *    logarithmic full activation time\n+     *    logarithmic full activation time.\n@@ -599,1 +599,1 @@\n-     * (and rescanning) on ctl contention. To avoid missed signals\n+     * (and rescanning) on \"ctl\" contention. To avoid missed signals\n@@ -658,1 +658,3 @@\n-     * released soon therafter.\n+     * released soon therafter. This is checked by setting the\n+     * \"source\" field of signallee to an invalid value, that will\n+     * remain invalid only if it did not process any tasks.\n@@ -701,1 +703,3 @@\n-     * they are ignored, and 0 is an OK default.) The scan in method\n+     * they are ignored, and 0 is an OK default. However, the source\n+     * field is set anyway, or eventually to DROPPED, to ensure\n+     * volatile memory synchronization effects.) The scan in method\n@@ -880,1 +884,1 @@\n-     * region segregates fields (all decalred as \"int\") most heavily\n+     * region segregates fields (all declared as \"int\") most heavily\n@@ -882,13 +886,16 @@\n-     * other management.  Initial sizing and resizing of WorkQueue\n-     * arrays is an even more delicate tradeoff because the best\n-     * strategy systematically varies across garbage collectors. Small\n-     * arrays are better for locality and reduce GC scan time, but\n-     * large arrays reduce both direct false-sharing and indirect\n-     * cases due to GC bookkeeping (cardmarks etc), and reduce the\n-     * number of resizes, which are not especially fast because they\n-     * require atomic transfers.  Currently, arrays are initialized to\n-     * be just large enough to avoid resizing in most tree-structured\n-     * tasks, although resizing is common in some other cases.\n-     * (Maintenance note: any changes in fields, queues, or their\n-     * uses, or JVM layout policies, must be accompanied by\n-     * re-evaluation of these placement and sizing decisions.)\n+     * other management.\n+     *\n+     * Initial sizing and resizing of WorkQueue arrays is an even more\n+     * delicate tradeoff because the best strategy systematically\n+     * varies across garbage collectors. Small arrays are better for\n+     * locality and reduce GC scan time, but large arrays reduce both\n+     * direct false-sharing and indirect cases due to GC bookkeeping\n+     * (cardmarks etc), and reduce the number of resizes, which are\n+     * not especially fast because they require atomic transfers.\n+     * Currently, arrays for workers are initialized to be just large\n+     * enough to avoid resizing in most tree-structured tasks, but\n+     * larger for external queues where both false-sharing problems\n+     * and the need for resizing are more common..  (Maintenance note:\n+     * any changes in fields, queues, or their uses, or JVM layout\n+     * policies, must be accompanied by re-evaluation of these\n+     * placement and sizing decisions.)\n@@ -975,2 +982,2 @@\n-     * Initial capacity of work-stealing queue array.  Must be a power\n-     * of two, at least 2. See above.\n+     * Initial capacity of work-stealing queue array for workers.\n+     * Must be a power of two, at least 2. See above.\n@@ -978,1 +985,8 @@\n-    static final int INITIAL_QUEUE_CAPACITY = 1 << 7;\n+    static final int INITIAL_QUEUE_CAPACITY = 1 << 6;\n+\n+    \/**\n+     * Initial capacity of work-stealing queue array for external queues.\n+     * Must be a power of two, at least 2. See above.\n+     *\/\n+    static final int INITIAL_EXTERNAL_QUEUE_CAPACITY = 1 << 9;\n+    \/\/        INITIAL_QUEUE_CAPACITY << 2;\n@@ -1224,5 +1238,3 @@\n-            if (clearThreadLocals)\n-                cfg |= CLEAR_TLS;\n-            this.config = cfg;\n-            top = base = INITIAL_QUEUE_CAPACITY >>> 2; \/\/ offset\n-            this.phase = id;\n+            array = new ForkJoinTask<?>[owner == null ?\n+                                        INITIAL_EXTERNAL_QUEUE_CAPACITY :\n+                                        INITIAL_QUEUE_CAPACITY];\n@@ -1230,0 +1242,2 @@\n+            \/\/            top = base = 1;\n+            this.config = (clearThreadLocals) ? cfg | CLEAR_TLS : cfg;\n@@ -1273,1 +1287,2 @@\n-                else if ((room == 0 || a[m & (s - 1)] == null) && pool != null)\n+                else if ((room == 0 || room == m || a[m & (s - 1)] == null) &&\n+                         pool != null)\n@@ -1285,2 +1300,2 @@\n-            int newCap;\n-            if (a != null && a.length == cap && (newCap = cap << 1) > 0) {\n+            int newCap = cap << 1;\n+            if (a != null && a.length == cap && cap > 0 && newCap > 0) {\n@@ -1394,24 +1409,16 @@\n-            if ((phase & (IDLE | 1)) == 0 || top - base > 0) {\n-                for (boolean stalled = false;;) {\n-                    int cap, b, k, nb; ForkJoinTask<?>[] a;\n-                    if ((a = array) == null || (cap = a.length) <= 0)\n-                        break;\n-                    long kp = slotOffset(k = (cap - 1) & (b = base));\n-                    int nk = (nb = b + 1) & (cap - 1); \/\/ next slot\n-                    int sk = (b + 2) & (cap - 1);      \/\/ 2nd slot ahead\n-                    ForkJoinTask<?> t = a[k];\n-                    U.loadFence();\n-                    if (base != b)\n-                        ;                              \/\/ inconsistent\n-                    else if (t == null) {\n-                        if (a[sk] == null && a[nk] == null && a[k] == null &&\n-                            top - b <= 0)\n-                            break;                     \/\/ empty\n-                        if (stalled)\n-                            Thread.onSpinWait();\n-                        stalled = true;\n-                        U.loadFence();                 \/\/ reread\n-                    }\n-                    else if (U.compareAndSetReference(a, kp, t, null)) {\n-                        updateBase(nb);\n-                        return t;\n+            for (int b = base;;) {\n+                int cap, k, nb; ForkJoinTask<?>[] a;\n+                if ((a = array) == null || (cap = a.length) <= 0)\n+                    break;\n+                long kp = slotOffset(k = (cap - 1) & b);\n+                int nk = (nb = b + 1) & (cap - 1); \/\/ next slot\n+                int sk = (b + 2) & (cap - 1);      \/\/ 2nd slot ahead\n+                ForkJoinTask<?> t = a[k];\n+                U.loadFence();\n+                if (b == (b = base)) {             \/\/ else inconsistent\n+                    if (t != null) {\n+                        if (U.compareAndSetReference(a, kp, t, null)) {\n+                            updateBase(nb);\n+                            return t;\n+                        }\n+                        b = base;\n@@ -1419,0 +1426,3 @@\n+                    else if (a[sk] == null && a[nk] == null &&\n+                             a[k] == null && top - b <= 0)\n+                        break;                     \/\/ empty\n@@ -1420,0 +1430,2 @@\n+                if (b != nb)                       \/\/ stalled\n+                    Thread.onSpinWait();\n@@ -1432,1 +1444,1 @@\n-            if (task != null && src != null) {\n+            if (task != null && src != null) {  \/\/ always true\n@@ -1437,4 +1449,5 @@\n-                        int k, cap; ForkJoinTask<?>[] a;\n-                        if (src.base != srcBase ||\n-                            (a = src.array) == null || (cap = a.length) <= 0 ||\n-                            (task = a[k = srcBase & (cap - 1)]) == null)\n+                        int k, b, cap; ForkJoinTask<?>[] a;\n+                        if ((a = src.array) == null || (cap = a.length) <= 0 ||\n+                            \/\/ check interference on initial exec\n+                            ((b = src.base) != srcBase && nstolen == 1) ||\n+                            (task = a[k = (cap - 1) & b]) == null)\n@@ -1443,1 +1456,1 @@\n-                        if (src.base != srcBase || !U.compareAndSetReference(\n+                        if (src.base != b || !U.compareAndSetReference(\n@@ -1446,1 +1459,1 @@\n-                        src.updateBase(++srcBase);\n+                        src.updateBase(b + 1);\n@@ -1771,1 +1784,0 @@\n-            w.array = new ForkJoinTask<?>[INITIAL_QUEUE_CAPACITY];\n@@ -2017,6 +2029,4 @@\n-                int j; WorkQueue q;\n-                if ((q = qs[j = i & (n - 1)]) != null) {\n-                    for (int retries = MAX_SCAN_RETRIES, b = q.base;;) {\n-                        int cap, k, nb; ForkJoinTask<?>[] a;\n-                        if ((a = q.array) == null || (cap = a.length) <= 0)\n-                            break;\n+                int j, cap; WorkQueue q; ForkJoinTask<?>[] a;\n+                if ((q = qs[j = i & (n - 1)]) != null &&\n+                    (a = q.array) != null && (cap = a.length) > 0) {\n+                    for (int retries = MAX_SCAN_RETRIES, b = q.base, k, nb;;) {\n@@ -2028,1 +2038,1 @@\n-                        if (b == (b = q.base)) {          \/\/ else inconsistent\n+                        if (b == (b = q.base)) {           \/\/ else inconsistent\n@@ -2032,3 +2042,3 @@\n-                                    w.source = j;         \/\/ volatile write\n-                                    if (a[nk] != null)\n-                                        signalWork();     \/\/ propagate signal\n+                                    w.source = j;          \/\/ volatile write\n+                                    if (a[nk] != null && (j & 1) == 0)\n+                                        signalWork();      \/\/ propagate signal\n@@ -2041,2 +2051,5 @@\n-                                     a[k] == null)\n-                                break;                    \/\/ probably empty\n+                                     a[k] == null) {\n+                                if (q.array != a)          \/\/ resized; restart\n+                                    return true;\n+                                break;                     \/\/ probably empty\n+                            }\n@@ -2045,1 +2058,1 @@\n-                            return true;                  \/\/ stalled; move\n+                            return true;                   \/\/ stalled; move\n@@ -2074,1 +2087,1 @@\n-                while (((p = w.phase) & IDLE) != 0 && --spins != 0)\n+                while (((p = w.phase) & IDLE) != 0 && --spins >= 0)\n@@ -2101,1 +2114,1 @@\n-     * @param w the worker\n+     * @param w the work queue\n@@ -2596,1 +2609,1 @@\n-            int n, i, id; WorkQueue[] qs; WorkQueue q;\n+            int n, i, id; WorkQueue[] qs; WorkQueue q, w = null;\n@@ -2602,2 +2615,3 @@\n-                WorkQueue w = new WorkQueue(null, id, 0, false);\n-                w.array = new ForkJoinTask<?>[INITIAL_QUEUE_CAPACITY];\n+                if (w == null)\n+                    w = new WorkQueue(null, id, 0, false);\n+                w.phase = id;\n@@ -2605,2 +2619,4 @@\n-                if (stop == 0L && queues == qs && qs[i] == null)\n-                    q = qs[i] = w;                   \/\/ else discard; retry\n+                if (stop == 0L && queues == qs && qs[i] == null) {\n+                    q = qs[i] = w;                   \/\/ else retry\n+                    w = null;\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":98,"deletions":82,"binary":false,"changes":180,"status":"modified"}]}