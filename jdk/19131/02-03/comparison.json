{"files":[{"patch":"@@ -203,6 +203,18 @@\n-     * then to randomized FIFO steals of tasks in other queues.  This\n-     * framework began as vehicle for supporting tree-structured\n-     * parallelism using work-stealing.  Over time, its scalability\n-     * advantages led to extensions and changes to better support more\n-     * diverse usage contexts.  Here's a brief history of major\n-     * revisions, each also with other minor features and changes.\n+     * then to randomized FIFO steals of tasks in other queues.\n+     *\n+     * This framework began as vehicle for supporting structured\n+     * parallelism using work-stealing, designed to work best when\n+     * tasks are dag-structured (wrt completion dependencies), nested\n+     * (generated using recursion or completions), of reasonable\n+     * granularity, independent (wrt memory and resources) and where\n+     * callers participate in task execution. These are properties\n+     * that anyone aiming for efficient parallel multicore execution\n+     * should design for.  Over time, the scalability advantages of\n+     * this framework led to extensions to better support more diverse\n+     * usage contexts, amounting to weakenings or violations of each\n+     * of these properties. Accommodating them may compromise\n+     * performance, but mechanics discussed below include tradeoffs\n+     * attempting to arrange that no single performance issue dominates.\n+     *\n+     * Here's a brief history of major revisions, each also with other\n+     * minor features and changes.\n@@ -586,1 +598,1 @@\n-     * suffice. Each queue's polling attempt o avoid becoming stuck\n+     * suffice. Each queue's polling attempts to avoid becoming stuck\n@@ -594,2 +606,1 @@\n-     * partially counteracted by giving up on detected interference in\n-     * async mode.\n+     * partially counteracted by giving up on detected interference.\n@@ -1969,4 +1980,4 @@\n-            WorkQueue[] qs;\n-            int phase = w.phase, r = w.stackPred; \/\/ seed from registerWorker\n-            int cfg = w.config, src = -1, ntaken = 0;\n-            for (boolean working = false;;) {     \/\/ true if ran since activated\n+            int phase = w.phase, r = w.stackPred;     \/\/ seed from registerWorker\n+            int cfg = w.config, src = -1, nsteals = 0;\n+            rescan: for (boolean working = false;;) { \/\/ set if ran since active\n+                WorkQueue[] qs;\n@@ -1984,1 +1995,1 @@\n-                                break;\n+                                continue rescan;\n@@ -1992,1 +2003,1 @@\n-                            else if (t == null) {\n+                            else if (t == null) {         \/\/ possibly empty\n@@ -1994,3 +2005,11 @@\n-                                    a[k] == null &&       \/\/ screen size check\n-                                    ((taken & !working) || q.top - b <= 0))\n-                                    break;\n+                                    a[k] == null) {       \/\/ screen\n+                                    if (q.top - b > 0) {  \/\/ stalled\n+                                        if (!taken)       \/\/ move unless taking\n+                                            continue rescan;\n+                                        Thread.onSpinWait();\n+                                    }\n+                                    else if (taken)\n+                                        continue rescan;  \/\/ depleted; restart\n+                                    else\n+                                        break;            \/\/ empty\n+                                }\n@@ -1998,1 +2017,3 @@\n-                            else if (U.compareAndSetReference(a, kp, t, null)) {\n+                            else if (!U.compareAndSetReference(a, kp, t, null))\n+                                b = q.base;               \/\/ contended\n+                            else {\n@@ -2000,1 +2021,1 @@\n-                                w.nsteals = ++ntaken;\n+                                w.nsteals = ++nsteals;\n@@ -2002,5 +2023,3 @@\n-                                if (!taken) {\n-                                    taken = true;\n-                                    if (!working && a[nk] != null)\n-                                        signalWork();     \/\/ propagate signal\n-                                }\n+                                if (working != (working = taken = true) &&\n+                                    a[nk] != null)\n+                                    signalWork();         \/\/ propagate signal\n@@ -2008,3 +2027,2 @@\n-                                b = q.base;\n-                                if (src != (src = j) && b != nb)\n-                                    break;                \/\/ reduce interference\n+                                if ((b = q.base) != nb && src != (src = j))\n+                                    continue rescan;      \/\/ reduce interference\n@@ -2012,2 +2030,0 @@\n-                            else if (taken & !working)    \/\/ new contention\n-                                break;\n@@ -2015,2 +2031,0 @@\n-                        if (taken)                       \/\/ restart scan\n-                            break;\n@@ -2019,2 +2033,1 @@\n-                if (!(working = taken) &&\n-                    ((phase = deactivate(w, r, phase)) & IDLE) != 0)\n+                if (((phase = deactivate(w, r, phase)) & IDLE) != 0)\n@@ -2022,0 +2035,1 @@\n+                working = false;                          \/\/ reactivated\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":48,"deletions":34,"binary":false,"changes":82,"status":"modified"}]}