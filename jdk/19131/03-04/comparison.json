{"files":[{"patch":"@@ -502,1 +502,1 @@\n-     * enqueuing in ctl (see method runWorker).  This \"queue\" is a\n+     * enqueuing in ctl (see method deactivate).  This \"queue\" is a\n@@ -516,8 +516,7 @@\n-     * thread first invokes registerWorker, where it constructs a\n-     * WorkQueue and is assigned an index in the queues array\n-     * (expanding the array if necessary).  Upon any exception across\n-     * these steps, or null return from factory, deregisterWorker\n-     * adjusts counts and records accordingly.  If a null return, the\n-     * pool continues running with fewer than the target number\n-     * workers. If exceptional, the exception is propagated, generally\n-     * to some external caller.\n+     * thread first invokes registerWorker, where it is assigned an\n+     * index in the queues array (expanding the array if necessary).\n+     * Upon any exception across these steps, or null return from\n+     * factory, deregisterWorker adjusts counts and records\n+     * accordingly.  If a null return, the pool continues running with\n+     * fewer than the target number workers. If exceptional, the\n+     * exception is propagated, generally to some external caller.\n@@ -559,1 +558,2 @@\n-     *  * If instead, tasks come in serially from only a single\n+     *  * At the other extreme, if \"flat\" tasks (those that do not in\n+     *    turn generate others) come in serially from only a single\n@@ -570,5 +570,7 @@\n-     *    opportunities to over-signal.  Note that in either of these\n-     *    contexts, signals may be (and often are) unnecessary because\n-     *    active workers continue scanning after running tasks without\n-     *    the need to be signalled (which is one reason work stealing\n-     *    is often faster than alternatives), so additional workers\n+     *    opportunities to over-signal. (Failure to distinguish these\n+     *    cases in terms of submission methods was arguably an early\n+     *    design mistake.)  Note that in either of these contexts,\n+     *    signals may be (and often are) unnecessary because active\n+     *    workers continue scanning after running tasks without the\n+     *    need to be signalled (which is one reason work stealing is\n+     *    often faster than alternatives), so additional workers\n@@ -606,1 +608,3 @@\n-     * partially counteracted by giving up on detected interference.\n+     * partially counteracted by giving up on detected interference\n+     * (which also reduces contention when too many workers try to\n+     * take small tasks from the same queue).\n@@ -1030,1 +1034,0 @@\n-    static final int PARKING          = 1 << 31;  \/\/ parked in awaitWork\n@@ -1211,1 +1214,1 @@\n-        volatile int source;       \/\/ source queue id (or DROPPED or PARKING)\n+        volatile int source;       \/\/ source queue id (or DROPPED)\n@@ -1214,0 +1217,2 @@\n+        @jdk.internal.vm.annotation.Contended(\"w\")\n+        volatile int parking;      \/\/ nonzero if parked in awaitWork\n@@ -1900,1 +1905,1 @@\n-                    if (v.source < 0)\n+                    if (v.parking != 0)\n@@ -1924,1 +1929,1 @@\n-                if (v.source < 0)\n+                if (v.parking != 0)\n@@ -1987,1 +1992,1 @@\n-                    break;\n+                    return;\n@@ -2034,1 +2039,1 @@\n-                    break;\n+                    return;\n@@ -2083,2 +2088,7 @@\n-                    if ((p & IDLE) != 0)\n-                        p = awaitWork(w, qc);    \/\/ block\n+                    if ((p & IDLE) != 0) {\n+                        long delay = (((qc & RC_MASK) > 0L) ? 0L :\n+                                      (w.source != INVALID_ID) ? keepAlive :\n+                                      TIMEOUT_SLOP); \/\/ minimal delay if cascade\n+                        if (((p = w.phase) & IDLE) != 0)\n+                            p = awaitWork(w, delay); \/\/ block, drop, or exit\n+                    }\n@@ -2095,1 +2105,1 @@\n-     * @param queuedCtl queued ctl value\n+     * @param delay if nonzero keepAlive before trimming if quiescent\n@@ -2098,1 +2108,1 @@\n-    private int awaitWork(WorkQueue w, long queuedCtl) {\n+    private int awaitWork(WorkQueue w, long delay) {\n@@ -2100,9 +2110,1 @@\n-        if (w != null && ((p = w.phase) & IDLE) != 0) {\n-            boolean trimmable = false;          \/\/ possibly drop if quiescent\n-            long deadline = 0L;                 \/\/ timeout if trimmable\n-            if ((queuedCtl & RC_MASK) <= 0L) {\n-                long ka = (w.source == INVALID_ID) ? TIMEOUT_SLOP : keepAlive;\n-                long d = ka + System.currentTimeMillis();\n-                if (trimmable = (ctl == queuedCtl))\n-                    deadline = d;               \/\/ minimal keepAlive if cascading\n-            }\n+        if (w != null) {\n@@ -2110,8 +2112,10 @@\n-            w.source = PARKING;                 \/\/ enable unpark\n-            if (((p = w.phase) & IDLE) != 0) {\n-                for (int trim;;) {\n-                    if ((runState & STOP) != 0L)\n-                        break;\n-                    if (!Thread.interrupted())\n-                        U.park(trimmable, deadline);\n-                    if (((p = w.phase) & IDLE) == 0)\n+            long deadline = (delay == 0L ? 0L :\n+                             delay + System.currentTimeMillis());\n+            w.parking = 1;                 \/\/ enable unpark\n+            while (((p = w.phase) & IDLE) != 0) {\n+                boolean trimmable = false; int trim;\n+                Thread.interrupted();      \/\/ clear status\n+                if ((runState & STOP) != 0L)\n+                    break;\n+                if (deadline != 0L) {\n+                    if ((trim = tryTrim(w, p, deadline)) > 0)\n@@ -2119,8 +2123,4 @@\n-                    if (trimmable) {\n-                        if ((trim = tryTrim(w, queuedCtl, deadline)) > 0)\n-                            break;\n-                        if (trim < 0) {\n-                            trimmable = false;\n-                            deadline = 0L;\n-                        }\n-                    }\n+                    else if (trim < 0)\n+                        deadline = 0L;\n+                    else\n+                        trimmable = true;\n@@ -2128,0 +2128,1 @@\n+                U.park(trimmable, deadline);\n@@ -2129,1 +2130,1 @@\n-            w.source = 0;\n+            w.parking = 0;\n@@ -2140,3 +2141,3 @@\n-    private int tryTrim(WorkQueue w, long queuedCtl, long deadline) {\n-        long c, nc; int stat, p, vp, i; WorkQueue[] vs; WorkQueue v;\n-        if ((c = ctl) != queuedCtl || w == null || ((p = w.phase) & IDLE) == 0)\n+    private int tryTrim(WorkQueue w, int phase, long deadline) {\n+        long c, nc; int stat, nextPhase, vp, i; WorkQueue[] vs; WorkQueue v;\n+        if ((nextPhase = phase + IDLE) != (int)(c = ctl) || w == null)\n@@ -2152,1 +2153,1 @@\n-            w.phase = p + IDLE;\n+            w.phase = nextPhase;\n@@ -2218,1 +2219,1 @@\n-                if (v.source < 0)\n+                if (v.parking != 0)\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":58,"deletions":57,"binary":false,"changes":115,"status":"modified"}]}