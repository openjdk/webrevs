{"files":[{"patch":"@@ -203,6 +203,18 @@\n-     * then to randomized FIFO steals of tasks in other queues.  This\n-     * framework began as vehicle for supporting tree-structured\n-     * parallelism using work-stealing.  Over time, its scalability\n-     * advantages led to extensions and changes to better support more\n-     * diverse usage contexts.  Here's a brief history of major\n-     * revisions, each also with other minor features and changes.\n+     * then to randomized FIFO steals of tasks in other queues.\n+     *\n+     * This framework began as vehicle for supporting structured\n+     * parallelism using work-stealing, designed to work best when\n+     * tasks are dag-structured (wrt completion dependencies), nested\n+     * (generated using recursion or completions), of reasonable\n+     * granularity, independent (wrt memory and resources) and where\n+     * callers participate in task execution. These are properties\n+     * that anyone aiming for efficient parallel multicore execution\n+     * should design for.  Over time, the scalability advantages of\n+     * this framework led to extensions to better support more diverse\n+     * usage contexts, amounting to weakenings or violations of each\n+     * of these properties. Accommodating them may compromise\n+     * performance, but mechanics discussed below include tradeoffs\n+     * attempting to arrange that no single performance issue dominates.\n+     *\n+     * Here's a brief history of major revisions, each also with other\n+     * minor features and changes.\n@@ -297,4 +309,1 @@\n-     *    the following rechecks even if the CAS is not attempted.  To\n-     *    more easily distinguish among kinds of CAS failures, we use\n-     *    the compareAndExchange version, and usually handle null\n-     *    returns (indicating contention) separately from others.\n+     *    the following rechecks even if the CAS is not attempted.\n@@ -347,1 +356,1 @@\n-     * The poll operations in q.poll(), scan(), helpJoin(), and\n+     * The poll operations in q.poll(), runWorker(), helpJoin(), and\n@@ -557,1 +566,1 @@\n-     *    logarithmic full activation time\n+     *    logarithmic full activation time.\n@@ -566,3 +575,1 @@\n-     *    aren't needed. We filter out some of these cases by exiting\n-     *    retry loops in signalWork if the task responsible for the\n-     *    signal has already been taken.\n+     *    aren't needed.\n@@ -575,13 +582,3 @@\n-     *   wastage. All remedies are intrinsically heuristic. We use a\n-     *   strategy that works well in most cases: We track \"sources\"\n-     *   (queue ids) of non-empty (usually polled) queues while\n-     *   scanning. These are maintained in the \"source\" field of\n-     *   WorkQueues for use in method helpJoin and elsewhere (see\n-     *   below). We also maintain them as arguments\/results of\n-     *   top-level polls (argument \"window\" in method scan, with setup\n-     *   in method runWorker) as an encoded sliding window of current\n-     *   and previous two sources (or INVALID_ID if none), and stop\n-     *   signalling when all were from the same source. These\n-     *   mechanisms may result in transiently too few workers, but\n-     *   once workers poll from a new source, they rapidly reactivate\n-     *   others.\n+     *   wastage. We reduce impact by deactivating workers when\n+     *   queues don't have accessible tasks, but reactivating and\n+     *   rescanning if other tasks remain.\n@@ -592,1 +589,1 @@\n-     * Scanning. Method scan performs top-level scanning for (and\n+     * Scanning. Method runWorker performs top-level scanning for (and\n@@ -601,19 +598,17 @@\n-     * suffice. Scans do not otherwise explicitly take into account\n-     * core affinities, loads, cache localities, etc, However, they do\n-     * exploit temporal locality (which usually approximates these) by\n-     * preferring to re-poll from the same queue (either in method\n-     * tryPoll() or scan) after a successful poll before trying others\n-     * (see method topLevelExec), which also reduces bookkeeping,\n-     * cache traffic, and scanning overhead. But it also reduces\n-     * fairness, which is partially counteracted by giving up on\n-     * contention.\n-     *\n-     * Deactivation. When method scan indicates that no tasks are\n-     * found by a worker, it tries to deactivate (in awaitWork),\n-     * giving up (and rescanning) on ctl contention. To avoid missed\n-     * signals during deactivation, the method rescans and reactivates\n-     * if there may have been a missed signal during deactivation,\n-     * filtering out most cases in which this is unnecessary. Because\n-     * idle workers are often not yet blocked (parked), we use the\n-     * WorkQueue parking field to advertise that a waiter actually\n-     * needs unparking upon signal.\n+     * suffice. Each queue's polling attempts to avoid becoming stuck\n+     * when other scanners\/pollers stall.  Scans do not otherwise\n+     * explicitly take into account core affinities, loads, cache\n+     * localities, etc, However, they do exploit temporal locality\n+     * (which usually approximates these) by preferring to re-poll\n+     * from the same queue after a successful poll before trying\n+     * others, which also reduces bookkeeping, cache traffic, and\n+     * scanning overhead. But it also reduces fairness, which is\n+     * partially counteracted by giving up on detected interference.\n+     *\n+     * Deactivation. When no tasks are found by a worker in runWorker,\n+     * it tries to deactivate()), giving up (and rescanning) on \"ctl\"\n+     * contention. To avoid missed signals during deactivation, the\n+     * method rescans and reactivates if there may have been a missed\n+     * signal during deactivation.  Because idle workers are often not\n+     * yet blocked (parked), we use a WorkQueue field to advertise\n+     * that a waiter actually needs unparking upon signal.\n@@ -631,18 +626,18 @@\n-     * others including tryCompensate. Method quiescent() is\n-     * used in all of these contexts. It provides checks that all\n-     * workers are idle and there are no submissions that they could\n-     * poll if they were not idle, retrying on inconsistent reads of\n-     * queues and using the runState seqLock to retry on queue array\n-     * updates.  (It also reports quiescence if the pool is\n-     * terminating.) A true report means only that there was a moment\n-     * at which quiescence held.  False negatives are inevitable (for\n-     * example when queues indices lag updates, as described above),\n-     * which is accommodated when (tentatively) idle by scanning for\n-     * work etc, and then re-invoking. This includes cases in which\n-     * the final unparked thread (in awaitWork) uses quiescent()\n-     * to check for tasks that could have been added during a race\n-     * window that would not be accompanied by a signal, in which case\n-     * re-activating itself (or any other worker) to rescan. Method\n-     * helpQuiesce acts similarly but cannot rely on ctl counts to\n-     * determine that all workers are inactive because the caller and\n-     * any others executing helpQuiesce are not included in counts.\n+     * others including tryCompensate. Method quiescent() is used in\n+     * all of these contexts. It provides checks that all workers are\n+     * idle and there are no submissions that they could poll if they\n+     * were not idle, retrying on inconsistent reads of queues and\n+     * using the runState seqLock to retry on queue array updates.\n+     * (It also reports quiescence if the pool is terminating.) A true\n+     * report means only that there was a moment at which quiescence\n+     * held.  False negatives are inevitable (for example when queues\n+     * indices lag updates, as described above), which is accommodated\n+     * when (tentatively) idle by scanning for work etc, and then\n+     * re-invoking. This includes cases in which the final unparked\n+     * thread (in deactivate()) uses quiescent() to check for tasks\n+     * that could have been added during a race window that would not\n+     * be accompanied by a signal, in which case re-activating itself\n+     * (or any other worker) to rescan. Method helpQuiesce acts\n+     * similarly but cannot rely on ctl counts to determine that all\n+     * workers are inactive because the caller and any others\n+     * executing helpQuiesce are not included in counts.\n@@ -671,3 +666,5 @@\n-     * to the first timeout of a fully populated pool. Subsequent (or\n-     * other) cases use delays such that, if still quiescent, all will\n-     * be released before one additional keepAlive unit elapses.\n+     * to the first timeout of a quiescent pool. Subsequent cases use\n+     * minimal delays such that, if still quiescent, all will be\n+     * released soon therafter. This is checked by setting the\n+     * \"source\" field of signallee to an invalid value, that will\n+     * remain invalid only if it did not process any tasks.\n@@ -716,1 +713,3 @@\n-     * they are ignored, and 0 is an OK default.) The scan in method\n+     * they are ignored, and 0 is an OK default. However, the source\n+     * field is set anyway, or eventually to DROPPED, to ensure\n+     * volatile memory synchronization effects.) The scan in method\n@@ -889,1 +888,3 @@\n-     * less-contended applications. For class WorkQueue, an\n+     * less-contended applications. To help arrange this, some\n+     * non-reference fields are declared as \"long\" even when ints or\n+     * shorts would suffice.  For class WorkQueue, an\n@@ -892,12 +893,19 @@\n-     * other management.  Initial sizing and resizing of WorkQueue\n-     * arrays is an even more delicate tradeoff because the best\n-     * strategy systematically varies across garbage collectors. Small\n-     * arrays are better for locality and reduce GC scan time, but\n-     * large arrays reduce both direct false-sharing and indirect\n-     * cases due to GC bookkeeping (cardmarks etc), and reduce the\n-     * number of resizes, which are not especially fast because they\n-     * require atomic transfers.  Currently, arrays are initialized to\n-     * be fairly small.  (Maintenance note: any changes in fields,\n-     * queues, or their uses, or JVM layout policies, must be\n-     * accompanied by re-evaluation of these placement and sizing\n-     * decisions.)\n+     * other management.  For class WorkQueue, an embedded padded\n+     * region segregates fields (all declared as \"int\") most heavily\n+     * updated by owners from those most commonly read by stealers or\n+     * other management.\n+     *\n+     * Initial sizing and resizing of WorkQueue arrays is an even more\n+     * delicate tradeoff because the best strategy systematically\n+     * varies across garbage collectors. Small arrays are better for\n+     * locality and reduce GC scan time, but large arrays reduce both\n+     * direct false-sharing and indirect cases due to GC bookkeeping\n+     * (cardmarks etc), and reduce the number of resizes, which are\n+     * not especially fast because they require atomic transfers.\n+     * Currently, arrays for workers are initialized to be just large\n+     * enough to avoid resizing in most tree-structured tasks, but\n+     * larger for external queues where both false-sharing problems\n+     * and the need for resizing are more common..  (Maintenance note:\n+     * any changes in fields, queues, or their uses, or JVM layout\n+     * policies, must be accompanied by re-evaluation of these\n+     * placement and sizing decisions.)\n@@ -957,18 +965,0 @@\n-     * Revision notes\n-     * ==============\n-     *\n-     * The main sources of differences from previous version are:\n-     *\n-     * * New abstract class ForkJoinTask.InterruptibleTask ensures\n-     *   handling of tasks submitted under the ExecutorService\n-     *   API are consistent with specs.\n-     * * Method quiescent() replaces previous quiescence-related\n-     *   checks, relying on versioning and sequence locking instead\n-     *   of ReentrantLock.\n-     * * Termination processing now ensures that internal data\n-     *   structures are maintained consistently enough while stopping\n-     *   to interrupt all workers and cancel all tasks. It also uses a\n-     *   CountDownLatch instead of a Condition for termination because\n-     *   of lock change.\n-     * * Many other changes to avoid performance regressions due\n-     *   to the above.\n@@ -986,1 +976,2 @@\n-     * Undershoot tolerance for idle timeouts\n+     * Undershoot tolerance for idle timeouts, also serving as the\n+     * minimum allowed timeout value.\n@@ -1001,2 +992,2 @@\n-     * Initial capacity of work-stealing queue array.  Must be a power\n-     * of two, at least 2. See above.\n+     * Initial capacity of work-stealing queue array for workers.\n+     * Must be a power of two, at least 2. See above.\n@@ -1006,0 +997,6 @@\n+    \/**\n+     * Initial capacity of work-stealing queue array for external queues.\n+     * Must be a power of two, at least 2. See above.\n+     *\/\n+    static final int INITIAL_EXTERNAL_QUEUE_CAPACITY = 1 << 9;\n+\n@@ -1017,4 +1014,4 @@\n-    static final int STOP             = 1 <<  0;   \/\/ terminating\n-    static final int SHUTDOWN         = 1 <<  1;   \/\/ terminate when quiescent\n-    static final int TERMINATED       = 1 <<  2;   \/\/ only set if STOP also set\n-    static final int RS_LOCK          = 1 <<  3;   \/\/ lowest seqlock bit\n+    static final long STOP            = 1L <<  0;   \/\/ terminating\n+    static final long SHUTDOWN        = 1L <<  1;   \/\/ terminate when quiescent\n+    static final long TERMINATED      = 1L <<  2;   \/\/ only set if STOP also set\n+    static final long RS_LOCK         = 1L <<  3;   \/\/ lowest seqlock bit\n@@ -1032,7 +1029,0 @@\n-    \/\/ source history window packing used in scan() and runWorker()\n-    static final long RESCAN          = 1L << 63; \/\/ must be negative\n-    static final long HMASK           = ((((long)SMASK) << 32) |\n-                                         (((long)SMASK) << 16)); \/\/ history bits\n-    static final long NO_HISTORY      = ((((long)INVALID_ID) << 32) | \/\/ no 3rd\n-                                         (((long)INVALID_ID) << 16)); \/\/ no 2nd\n-\n@@ -1040,1 +1030,2 @@\n-    static final int DEREGISTERED     = 1 << 31;  \/\/ worker terminating\n+    static final int PARKING          = 1 << 31;  \/\/ parked in awaitWork\n+    static final int DROPPED          = 1 << 16;  \/\/ removed from ctl counts\n@@ -1220,1 +1211,1 @@\n-        volatile int source;       \/\/ source queue id (or DEREGISTERED)\n+        volatile int source;       \/\/ source queue id (or DROPPED or PARKING)\n@@ -1223,2 +1214,0 @@\n-        @jdk.internal.vm.annotation.Contended(\"w\")\n-        volatile int parking;      \/\/ nonzero if parked in awaitWork\n@@ -1231,1 +1220,0 @@\n-        private static final long SOURCE;\n@@ -1240,3 +1228,0 @@\n-        final void forgetSource() {\n-            U.putIntOpaque(this, SOURCE, 0);\n-        }\n@@ -1261,5 +1246,3 @@\n-            if (clearThreadLocals)\n-                cfg |= CLEAR_TLS;\n-            this.config = cfg;\n-            top = base = 1;\n-            this.phase = id;\n+            array = new ForkJoinTask<?>[owner == null ?\n+                                        INITIAL_EXTERNAL_QUEUE_CAPACITY :\n+                                        INITIAL_QUEUE_CAPACITY];\n@@ -1267,0 +1250,1 @@\n+            this.config = (clearThreadLocals) ? cfg | CLEAR_TLS : cfg;\n@@ -1294,3 +1278,12 @@\n-            int s = top, b = base, cap, m, p, room, newCap; ForkJoinTask<?>[] a;\n-            if ((a = array) == null || (cap = a.length) <= 0 ||\n-                (room = (m = cap - 1) - (s - b)) < 0) { \/\/ could not resize\n+            int s = top, b = base, m, cap, room; ForkJoinTask<?>[] a;\n+            if ((a = array) != null && (cap = a.length) > 0) { \/\/ else disabled\n+                if ((room = (m = cap - 1) - (s - b)) >= 0) {\n+                    top = s + 1;\n+                    long pos = slotOffset(m & s);\n+                    if (!internal)\n+                        U.putReference(a, pos, task);       \/\/ inside lock\n+                    else\n+                        U.getAndSetReference(a, pos, task); \/\/ fully fenced\n+                    if (room == 0)                          \/\/ resize\n+                        growArray(a, cap, s);\n+                }\n@@ -1299,1 +1292,4 @@\n-                throw new RejectedExecutionException(\"Queue capacity exceeded\");\n+                if (room < 0)\n+                    throw new RejectedExecutionException(\"Queue capacity exceeded\");\n+                else if (room > 0 && a[m & (s - 1)] == null && pool != null)\n+                    pool.signalWork();\n@@ -1301,7 +1297,11 @@\n-            top = s + 1;\n-            long pos = slotOffset(p = m & s);\n-            if (!internal)\n-                U.putReference(a, pos, task);         \/\/ inside lock\n-            else\n-                U.getAndSetReference(a, pos, task);   \/\/ fully fenced\n-            if (room == 0 && (newCap = cap << 1) > 0) {\n+        }\n+\n+        \/**\n+         * Resizes the queue array unless out of memory.\n+         * @param a old array\n+         * @param cap old array capacity\n+         * @param s current top\n+         *\/\n+        private void growArray(ForkJoinTask<?>[] a, int cap, int s) {\n+            int newCap = cap << 1;\n+            if (a != null && a.length == cap && cap > 0 && newCap > 0) {\n@@ -1309,1 +1309,1 @@\n-                try {                                 \/\/ resize for next time\n+                try {\n@@ -1314,1 +1314,1 @@\n-                    int newMask = newCap - 1;         \/\/ poll old, push to new\n+                    int mask = cap - 1, newMask = newCap - 1;\n@@ -1316,1 +1316,1 @@\n-                        ForkJoinTask<?> u;\n+                        ForkJoinTask<?> u;            \/\/ poll old, push to new\n@@ -1318,1 +1318,1 @@\n-                                 a, slotOffset(k & m), null)) == null)\n+                                 a, slotOffset(k & mask), null)) == null)\n@@ -1322,1 +1322,1 @@\n-                    updateArray(newArray);            \/\/ fully fenced\n+                    updateArray(newArray);           \/\/ fully fenced\n@@ -1324,1 +1324,0 @@\n-                a = null;                             \/\/ always signal\n@@ -1326,4 +1325,0 @@\n-            if (!internal)\n-                unlockPhase();\n-            if ((a == null || a[m & (s - 1)] == null) && pool != null)\n-                pool.signalWork(a, p);\n@@ -1341,2 +1336,2 @@\n-            if (a != null && (cap = a.length) > 0) {\n-                for (int m = cap - 1, s, nb; p - b > 0; ) {\n+            if (p - b > 0 && a != null && (cap = a.length) > 0) {\n+                for (int m = cap - 1, s, nb;;) {\n@@ -1358,0 +1353,2 @@\n+                    if (p - b <= 0)\n+                        break;\n@@ -1416,2 +1413,0 @@\n-         *\n-         * @param pool if nonnull, pool to signal if more tasks exist\n@@ -1419,5 +1414,4 @@\n-        final ForkJoinTask<?> poll(ForkJoinPool pool) {\n-            for (;;) {\n-                ForkJoinTask<?>[] a = array;\n-                int b = base, cap, k;\n-                if (a == null || (cap = a.length) <= 0)\n+        final ForkJoinTask<?> poll() {\n+            for (int b = base;;) {\n+                int cap, k, nb; ForkJoinTask<?>[] a;\n+                if ((a = array) == null || (cap = a.length) <= 0)\n@@ -1425,1 +1419,4 @@\n-                ForkJoinTask<?> t = a[k = b & (cap - 1)];\n+                long kp = slotOffset(k = (cap - 1) & b);\n+                int nk = (nb = b + 1) & (cap - 1); \/\/ next slot\n+                int sk = (b + 2) & (cap - 1);      \/\/ 2nd slot ahead\n+                ForkJoinTask<?> t = a[k];\n@@ -1427,38 +1424,4 @@\n-                if (base == b) {\n-                    Object o;\n-                    int nb = b + 1, nk = nb & (cap - 1);\n-                    if (t == null)\n-                        o = a[k];\n-                    else if (t == (o = U.compareAndExchangeReference(\n-                                       a, slotOffset(k), t, null))) {\n-                        updateBase(nb);\n-                        if (a[nk] != null && pool != null)\n-                            pool.signalWork(a, nk); \/\/ propagate\n-                        return t;\n-                    }\n-                    if (o == null && a[nk] == null && array == a &&\n-                        (phase & (IDLE | 1)) != 0 && top - base <= 0)\n-                        break;                    \/\/ empty\n-                }\n-            }\n-            return null;\n-        }\n-\n-        \/**\n-         * Tries to poll next task in FIFO order, failing without\n-         * retries on contention or stalls. Used only by topLevelExec\n-         * to repoll from the queue obtained from pool.scan.\n-         *\/\n-        private ForkJoinTask<?> tryPoll() {\n-            ForkJoinTask<?>[] a; int cap;\n-            if ((a = array) != null && (cap = a.length) > 0) {\n-                for (int b = base, k;;) {  \/\/ loop only if inconsistent\n-                    ForkJoinTask<?> t = a[k = b & (cap - 1)];\n-                    U.loadFence();\n-                    if (b == (b = base)) {\n-                        Object o;\n-                        if (t == null)\n-                            o = a[k];\n-                        else if (t == (o = U.compareAndExchangeReference(\n-                                           a, slotOffset(k), t, null))) {\n-                            updateBase(b + 1);\n+                if (b == (b = base)) {             \/\/ else inconsistent\n+                    if (t != null) {\n+                        if (U.compareAndSetReference(a, kp, t, null)) {\n+                            updateBase(nb);\n@@ -1467,2 +1430,6 @@\n-                        if (o == null)\n-                            break;\n+                        b = base;\n+                    }\n+                    else if (a[sk] == null && a[nk] == null && a[k] == null) {\n+                        if (top - b <= 0)\n+                            break;                 \/\/ empty\n+                        Thread.onSpinWait();       \/\/ stalled\n@@ -1478,3 +1445,1 @@\n-         * Runs the given (stolen) task if nonnull, as well as\n-         * remaining local tasks and\/or others available from the\n-         * given queue, if any.\n+         * Runs the given task, as well as remaining local tasks.\n@@ -1482,6 +1447,2 @@\n-        final void topLevelExec(ForkJoinTask<?> task, WorkQueue src, int srcId) {\n-            int cfg = config, fifo = cfg & FIFO, nstolen = nsteals + 1;\n-            if ((srcId & 1) != 0) \/\/ don't record external sources\n-                source = srcId;\n-            if ((cfg & CLEAR_TLS) != 0)\n-                ThreadLocalRandom.eraseThreadLocals(Thread.currentThread());\n+        final void topLevelExec(ForkJoinTask<?> task, int cfg) {\n+            int fifo = cfg & FIFO;\n@@ -1490,3 +1451,1 @@\n-                if ((task = nextLocalTask(fifo)) == null && src != null &&\n-                    (task = src.tryPoll()) != null)\n-                    ++nstolen;\n+                task = nextLocalTask(fifo);\n@@ -1494,2 +1453,2 @@\n-            nsteals = nstolen;\n-            forgetSource();\n+            if ((cfg & CLEAR_TLS) != 0)\n+                ThreadLocalRandom.eraseThreadLocals(Thread.currentThread());\n@@ -1637,1 +1596,0 @@\n-            SOURCE = U.objectFieldOffset(klass, \"source\");\n@@ -1678,0 +1636,1 @@\n+    volatile long runState;              \/\/ versioned, lockable\n@@ -1682,1 +1641,0 @@\n-    volatile int runState;               \/\/ versioned, lockable\n@@ -1726,2 +1684,2 @@\n-    private int getAndBitwiseOrRunState(int v) { \/\/ for status bits\n-        return U.getAndBitwiseOrInt(this, RUNSTATE, v);\n+    private long getAndBitwiseOrRunState(long v) { \/\/ for status bits\n+        return U.getAndBitwiseOrLong(this, RUNSTATE, v);\n@@ -1729,2 +1687,2 @@\n-    private boolean casRunState(int c, int v) {\n-        return U.compareAndSetInt(this, RUNSTATE, c, v);\n+    private boolean casRunState(long c, long v) {\n+        return U.compareAndSetLong(this, RUNSTATE, c, v);\n@@ -1733,1 +1691,1 @@\n-        U.getAndAddInt(this, RUNSTATE, RS_LOCK);\n+        U.getAndAddLong(this, RUNSTATE, RS_LOCK);\n@@ -1735,3 +1693,3 @@\n-    private int lockRunState() {                \/\/ lock and return current state\n-        int s, u;                               \/\/ locked when RS_LOCK set\n-        if (((s = runState) & RS_LOCK) == 0 && casRunState(s, u = s + RS_LOCK))\n+    private long lockRunState() {                \/\/ lock and return current state\n+        long s, u;                               \/\/ locked when RS_LOCK set\n+        if (((s = runState) & RS_LOCK) == 0L && casRunState(s, u = s + RS_LOCK))\n@@ -1742,3 +1700,4 @@\n-    private int spinLockRunState() {            \/\/ spin\/sleep\n-        for (int waits = 0, s, u;;) {\n-            if (((s = runState) & RS_LOCK) == 0) {\n+    private long spinLockRunState() {            \/\/ spin\/sleep\n+        for (int waits = 0;;) {\n+            long s, u;\n+            if (((s = runState) & RS_LOCK) == 0L) {\n@@ -1762,1 +1721,1 @@\n-        return p != null && (p.runState & STOP) != 0;\n+        return p != null && (p.runState & STOP) != 0L;\n@@ -1780,1 +1739,1 @@\n-            if ((runState & STOP) == 0 &&  \/\/ avoid construction if terminating\n+            if ((runState & STOP) == 0L &&  \/\/ avoid construction if terminating\n@@ -1813,1 +1772,0 @@\n-            w.array = new ForkJoinTask<?>[INITIAL_QUEUE_CAPACITY];\n@@ -1818,1 +1776,1 @@\n-            int stop = lockRunState() & STOP;\n+            long stop = lockRunState() & STOP;\n@@ -1821,1 +1779,1 @@\n-                if (stop == 0 && (qs = queues) != null && (n = qs.length) > 0) {\n+                if (stop == 0L && (qs = queues) != null && (n = qs.length) > 0) {\n@@ -1864,0 +1822,2 @@\n+        if ((runState & STOP) != 0L)       \/\/ ensure released\n+            releaseAll();\n@@ -1869,3 +1829,3 @@\n-            if ((src = w.source) != DEREGISTERED) { \/\/ else trimmed on timeout\n-                w.source = DEREGISTERED;\n-                if (phase != 0) {         \/\/ else failed to start\n+            if ((src = w.source) != DROPPED) {\n+                w.source = DROPPED;        \/\/ else already dropped\n+                if (phase != 0) {          \/\/ else failed to start\n@@ -1873,2 +1833,9 @@\n-                    if ((phase & IDLE) != 0)\n-                        reactivate(w);    \/\/ pool stopped before released\n+                    if (w.top - w.base > 0) {\n+                        ForkJoinTask<?> t; \/\/ cancel remaining tasks\n+                        while ((t = w.nextLocalTask()) != null) {\n+                            try {\n+                                t.cancel(false);\n+                            } catch (Throwable ignore) {\n+                            }\n+                        }\n+                    }\n@@ -1878,2 +1845,2 @@\n-        long c = ctl;\n-        if (src != DEREGISTERED)          \/\/ decrement counts\n+        if (src != DROPPED) {             \/\/ decrement counts\n+            long c = ctl;\n@@ -1884,9 +1851,0 @@\n-        else if ((int)c != 0)\n-            replaceable = true;           \/\/ signal below to cascade timeouts\n-        if (w != null) {                  \/\/ cancel remaining tasks\n-            for (ForkJoinTask<?> t; (t = w.nextLocalTask()) != null; ) {\n-                try {\n-                    t.cancel(false);\n-                } catch (Throwable ignore) {\n-                }\n-            }\n@@ -1897,3 +1855,4 @@\n-            int stop = lockRunState() & STOP;\n-            if (stop == 0 && (qs = queues) != null && (n = qs.length) > 0 &&\n-                qs[i = phase & SMASK & (n - 1)] == w) {\n+            if ((lockRunState() & STOP) != 0L)\n+                replaceable = false;\n+            else if ((qs = queues) != null && (n = qs.length) > 0 &&\n+                     qs[i = phase & SMASK & (n - 1)] == w) {\n@@ -1904,0 +1863,2 @@\n+            if (replaceable)\n+                signalWork();\n@@ -1905,2 +1866,0 @@\n-        if ((runState & STOP) == 0 && replaceable)\n-            signalWork(null, 0); \/\/ may replace unless trimmed or uninitialized\n@@ -1912,5 +1871,1 @@\n-     * Releases an idle worker, or creates one if not enough exist,\n-     * returning on contention if a signal task is already taken.\n-     *\n-     * @param a if nonnull, a task array holding task signalled\n-     * @param k index of task in array\n+     * Releases an idle worker, or creates one if not enough exist.\n@@ -1918,1 +1873,1 @@\n-    final void signalWork(ForkJoinTask<?>[] a, int k) {\n+    final void signalWork() {\n@@ -1924,1 +1879,5 @@\n-            if (qs == null || qs.length <= i)\n+            if ((short)(c >>> RC_SHIFT) >= pc)\n+                break;\n+            if (qs == null)\n+                break;\n+            if (qs.length <= i)\n@@ -1932,1 +1891,1 @@\n-            else if ((short)(c >>> RC_SHIFT) >= pc || (v = w) == null)\n+            else if ((v = w) == null)\n@@ -1941,1 +1900,1 @@\n-                    if (v.parking != 0)\n+                    if (v.source < 0)\n@@ -1946,2 +1905,0 @@\n-            if (a != null && k >= 0 && k < a.length && a[k] == null)\n-                break;\n@@ -1952,3 +1909,3 @@\n-     * Reactivates the given worker, and possibly others if not top of\n-     * ctl stack. Called only during shutdown to ensure release on\n-     * termination.\n+     * Releases all waiting workers. Called only during shutdown.\n+     *\n+     * @return current ctl\n@@ -1956,2 +1913,3 @@\n-    private void reactivate(WorkQueue w) {\n-        for (long c = ctl;;) {\n+    private long releaseAll() {\n+        long c = ctl;\n+        for (;;) {\n@@ -1959,3 +1917,2 @@\n-            if ((qs = queues) == null || (sp = (int)c) == 0 ||\n-                qs.length <= (i = sp & SMASK) || (v = qs[i]) == null ||\n-                (v != w && w != null && (w.phase & IDLE) == 0))\n+            if ((sp = (int)c) == 0 || (qs = queues) == null ||\n+                qs.length <= (i = sp & SMASK) || (v = qs[i]) == null)\n@@ -1967,3 +1924,1 @@\n-                if (v == w)\n-                    break;\n-                if (v.parking != 0)\n+                if (v.source < 0)\n@@ -1973,0 +1928,1 @@\n+        return c;\n@@ -1977,3 +1933,3 @@\n-     * @return true if terminating or all workers are inactive and\n-     * submission queues are empty and unlocked; if so, setting STOP\n-     * if shutdown is enabled\n+     * @return positive if stopping, nonnegative if terminating or all\n+     * workers are inactive and submission queues are empty and\n+     * unlocked; if so, setting STOP if shutdown is enabled\n@@ -1981,1 +1937,1 @@\n-    private boolean quiescent() {\n+    private int quiescent() {\n@@ -1985,1 +1941,1 @@\n-            for (int e, prevRunState = 0; ; prevRunState = e) {\n+            for (long e, prevRunState = 0L; ; prevRunState = e) {\n@@ -1987,2 +1943,2 @@\n-                if (((e = runState) & STOP) != 0)\n-                    return true;                          \/\/ terminating\n+                if (((e = runState) & STOP) != 0L)\n+                    return 1;                             \/\/ terminating\n@@ -1990,1 +1946,1 @@\n-                    return false;                         \/\/ at least one active\n+                    return -1;                            \/\/ at least one active\n@@ -1993,1 +1949,1 @@\n-                    WorkQueue[] qs = queues; WorkQueue q;\n+                    WorkQueue[] qs = queues;\n@@ -1996,0 +1952,1 @@\n+                        WorkQueue q;\n@@ -1999,5 +1956,2 @@\n-                            if ((p & IDLE) == 0 || s - b > 0) {\n-                                if ((i & 1) == 0 && compareAndSetCtl(c, c))\n-                                    signalWork(null, 0);  \/\/ ensure live\n-                                return false;\n-                            }\n+                            if ((p & IDLE) == 0 || s - b > 0)\n+                                return -1;\n@@ -2009,5 +1963,3 @@\n-                    return true;\n-                else if (compareAndSetCtl(c, c) && casRunState(e, e | STOP)) {\n-                    interruptAll();                       \/\/ confirmed\n-                    return true;                          \/\/ enable termination\n-                }\n+                    return 0;\n+                else if (compareAndSetCtl(c, c) && casRunState(e, e | STOP))\n+                    return 1;                             \/\/ enable termination\n@@ -2028,3 +1980,5 @@\n-            int phase = w.phase, r = w.stackPred; \/\/ seed from registerWorker\n-            long window = (long)((r >>> 16) & SMASK) | NO_HISTORY;\n-            do {\n+            int phase = w.phase, r = w.stackPred;     \/\/ seed from registerWorker\n+            int cfg = w.config, src = -1, nsteals = 0;\n+            rescan: for (boolean working = false;;) { \/\/ set if ran since active\n+                WorkQueue[] qs;\n+                boolean taken = false;\n@@ -2032,3 +1986,51 @@\n-            } while ((runState & STOP) == 0 &&\n-                     (((window = scan(w, window, r)) < 0L ||\n-                       ((phase = awaitWork(w, phase)) & IDLE) == 0)));\n+                if ((runState & STOP) != 0L || (qs = queues) == null)\n+                    break;\n+                int n = qs.length, i = r, step = (r >>> 16) | 1;\n+                for (int l = n; l > 0; --l, i += step) {  \/\/ scan queues\n+                    int j; WorkQueue q;\n+                    if ((q = qs[j = i & (n - 1)]) != null) {\n+                        for (int b = q.base;;) {\n+                            int cap, k, nb; ForkJoinTask<?>[] a;\n+                            if ((a = q.array) == null || (cap = a.length) <= 0)\n+                                continue rescan;\n+                            long kp = slotOffset(k = (cap - 1) & b);\n+                            int nk = (nb = b + 1) & (cap - 1); \/\/ next slot\n+                            int sk = (b + 2) & (cap - 1); \/\/ 2nd slot ahead\n+                            ForkJoinTask<?> t = a[k];\n+                            U.loadFence();\n+                            if (b != (b = q.base))\n+                                ;                         \/\/ inconsistent\n+                            else if (t == null) {         \/\/ possibly empty\n+                                if (a[sk] == null && a[nk] == null &&\n+                                    a[k] == null) {       \/\/ screen\n+                                    if (q.top - b > 0) {  \/\/ stalled\n+                                        if (!taken)       \/\/ move unless taking\n+                                            continue rescan;\n+                                        Thread.onSpinWait();\n+                                    }\n+                                    else if (taken)\n+                                        continue rescan;  \/\/ depleted; restart\n+                                    else\n+                                        break;            \/\/ empty\n+                                }\n+                            }\n+                            else if (!U.compareAndSetReference(a, kp, t, null))\n+                                b = q.base;               \/\/ contended\n+                            else {\n+                                q.base = nb;\n+                                w.nsteals = ++nsteals;\n+                                w.source = j;             \/\/ volatile write\n+                                if (working != (working = taken = true) &&\n+                                    a[nk] != null)\n+                                    signalWork();         \/\/ propagate signal\n+                                w.topLevelExec(t, cfg);\n+                                if ((b = q.base) != nb && src != (src = j))\n+                                    continue rescan;      \/\/ reduce interference\n+                            }\n+                        }\n+                    }\n+                }\n+                if (((phase = deactivate(w, r, phase)) & IDLE) != 0)\n+                    break;\n+                working = false;                          \/\/ reactivated\n+            }\n@@ -2039,3 +2041,1 @@\n-     * Scans for and if found executes top-level tasks: Tries to poll\n-     * each queue starting at initial index with random stride,\n-     * returning next scan window and retry indicator.\n+     * Deactivates and if necessary awaits signal or termination.\n@@ -2043,2 +2043,1 @@\n-     * @param w caller's WorkQueue\n-     * @param window up to three queue indices\n+     * @param w the worker\n@@ -2046,1 +2045,2 @@\n-     * @return the next window to use, with RESCAN set for rescan\n+     * @param phase current phase\n+     * @return current phase, with IDLE set if worker should exit\n@@ -2048,30 +2048,33 @@\n-    private long scan(WorkQueue w, long window, int r) {\n-        WorkQueue[] qs = queues;\n-        int n = (qs == null) ? 0 : qs.length, step = (r << 1) | 1;\n-        long next = window & ~RESCAN;\n-        outer: for (int i = (short)window, l = n; l > 0; --l, i += step) {\n-            int j, cap; WorkQueue q; ForkJoinTask<?>[] a;\n-            if ((q = qs[j = i & SMASK & (n - 1)]) != null &&\n-                (a = q.array) != null && (cap = a.length) > 0) {\n-                for (int b = q.base;;) {\n-                    int nb = b + 1, nk = nb & (cap - 1), k;\n-                    ForkJoinTask<?> t = a[k = b & (cap - 1)];\n-                    U.loadFence();                \/\/ re-read b and t\n-                    if (b == (b = q.base)) {      \/\/ else inconsistent; retry\n-                        Object o;\n-                        if (t == null)\n-                            o = a[k];\n-                        else if (t == (o = U.compareAndExchangeReference(\n-                                           a, slotOffset(k), t, null))) {\n-                            q.updateBase(nb);\n-                            next = RESCAN | ((window << 16) & HMASK) | j;\n-                            if (window != next && a[nk] != null)\n-                                signalWork(a, nk); \/\/ limit propagation\n-                            if (w != null)        \/\/ always true\n-                                w.topLevelExec(t, q, j);\n-                            break outer;\n-                        }\n-                        if (o == null) {\n-                            if (next >= 0L && a[nk] != null)\n-                                next |= RESCAN;\n-                            break;\n+    private int deactivate(WorkQueue w, int r, int phase) {\n+        int p = phase | IDLE, active = phase + (IDLE << 1);\n+        if (w != null) {                         \/\/ always true\n+            w.phase = p;\n+            long pc = ctl, qc;\n+            for (;;) {                           \/\/ try to enqueue\n+                w.stackPred = (int)pc;           \/\/ set ctl stack link\n+                qc = (active & LMASK) | ((pc - RC_UNIT) & UMASK);\n+                if (pc == (pc = compareAndExchangeCtl(pc, qc)))\n+                    break;\n+                if ((pc & RC_MASK) >= (qc & RC_MASK)) {\n+                    p = w.phase = phase;         \/\/ back out on possible signal\n+                    break;\n+                }\n+            }\n+            if (p != phase &&                    \/\/ check quiescent termination\n+                ((runState & SHUTDOWN) == 0 || quiescent() <= 0)) {\n+                WorkQueue[] qs;\n+                int spins = ((short)(qc >>> TC_SHIFT) << 1) + SPIN_WAITS + 1;\n+                while (((p = w.phase) & IDLE) != 0 && --spins > 0)\n+                    Thread.onSpinWait();         \/\/ reduce flailing\n+                if ((p & IDLE) != 0 && (qs = queues) != null) {\n+                    int n = qs.length, step = (r >>> 16) | 1;\n+                    for (int i = r, l = n; l > 0; --l, i += step) {\n+                        WorkQueue q;             \/\/ check for missed signals\n+                        if ((q = qs[i & (n - 1)]) != null &&\n+                            q.top - q.base > 0) {\n+                            if (ctl == qc && compareAndSetCtl(qc, pc)) {\n+                                p = w.phase = active;\n+                                break;           \/\/ self-signal\n+                            }\n+                            if (((p = w.phase) & IDLE) == 0)\n+                                break;\n@@ -2080,0 +2083,2 @@\n+                    if ((p & IDLE) != 0)\n+                        p = awaitWork(w, qc);    \/\/ block\n@@ -2083,1 +2088,1 @@\n-        return next;\n+        return p;\n@@ -2087,1 +2092,1 @@\n-     * Tries to inactivate, and if successful, awaits signal or termination.\n+     * Awaits signal or termination.\n@@ -2089,2 +2094,2 @@\n-     * @param w the worker (may be null if already terminated)\n-     * @param phase current phase\n+     * @param w the work queue\n+     * @param queuedCtl queued ctl value\n@@ -2093,13 +2098,10 @@\n-    private int awaitWork(WorkQueue w, int phase) {\n-        boolean quiet;                           \/\/ true if possibly quiescent\n-        int active = phase + (IDLE << 1), p = phase | IDLE, e;\n-        if (w != null) {\n-            w.phase = p;                         \/\/ deactivate\n-            long np = active & LMASK, pc = ctl;  \/\/ try to enqueue\n-            long qc = np | ((pc - RC_UNIT) & UMASK);\n-            w.stackPred = (int)pc;               \/\/ set ctl stack link\n-            if (pc != (pc = compareAndExchangeCtl(pc, qc))) {\n-                qc = np | ((pc - RC_UNIT) & UMASK);\n-                w.stackPred = (int)pc;           \/\/ retry once\n-                if (pc != (pc = compareAndExchangeCtl(pc, qc)))\n-                    p = w.phase = phase;         \/\/ back out\n+    private int awaitWork(WorkQueue w, long queuedCtl) {\n+        int p = IDLE;\n+        if (w != null && ((p = w.phase) & IDLE) != 0) {\n+            boolean trimmable = false;          \/\/ possibly drop if quiescent\n+            long deadline = 0L;                 \/\/ timeout if trimmable\n+            if ((queuedCtl & RC_MASK) <= 0L) {\n+                long ka = (w.source == INVALID_ID) ? TIMEOUT_SLOP : keepAlive;\n+                long d = ka + System.currentTimeMillis();\n+                if (trimmable = (ctl == queuedCtl))\n+                    deadline = d;               \/\/ minimal keepAlive if cascading\n@@ -2107,18 +2109,5 @@\n-            if (p != phase && ((e = runState) & STOP) == 0 &&\n-                (!(quiet = (qc & RC_MASK) <= 0L) || (e & SHUTDOWN) == 0 ||\n-                 !(quiet = quiescent()) || (runState & STOP) == 0)) {\n-                long deadline = 0L;              \/\/ not terminating\n-                if (quiet) {                     \/\/ use timeout if trimmable\n-                    int nt = (short)(qc >>> TC_SHIFT);\n-                    long delay = keepAlive;      \/\/ scale if not at target\n-                    if (nt != (nt = Math.max(nt, parallelism)) && nt > 0)\n-                        delay = Math.max(TIMEOUT_SLOP, delay \/ nt);\n-                    if ((deadline = delay + System.currentTimeMillis()) == 0L)\n-                        deadline = 1L;           \/\/ avoid zero\n-                }\n-                boolean release = quiet;\n-                WorkQueue[] qs = queues;         \/\/ recheck queues\n-                int n = (qs == null) ? 0 : qs.length;\n-                for (int l = -n, j = active; l < n; ++l, ++j) {\n-                    WorkQueue q; ForkJoinTask<?>[] a; int cap;\n-                    if ((p = w.phase) == active) \/\/ interleave signal checks\n+            LockSupport.setCurrentBlocker(this);\n+            w.source = PARKING;                 \/\/ enable unpark\n+            if (((p = w.phase) & IDLE) != 0) {\n+                for (int trim;;) {\n+                    if ((runState & STOP) != 0L)\n@@ -2126,19 +2115,6 @@\n-                    if ((q = qs[j & (n - 1)]) != null &&\n-                        (a = q.array) != null && (cap = a.length) > 0 &&\n-                        a[q.base & (cap - 1)] != null) {\n-                        if (release && qc == ctl && compareAndSetCtl(qc, pc)) {\n-                            p = w.phase = active;\n-                            break;               \/\/ possible missed signal\n-                        }\n-                        release = true;          \/\/ track multiple or reencounter\n-                    }\n-                    Thread.onSpinWait();         \/\/ reduce memory traffic\n-                }\n-                if (p != active) {               \/\/ emulate LockSupport.park\n-                    LockSupport.setCurrentBlocker(this);\n-                    w.parking = 1;\n-                    for (;;) {\n-                        if ((runState & STOP) != 0 || (p = w.phase) == active)\n-                            break;\n-                        U.park(deadline != 0L, deadline);\n-                        if ((p = w.phase) == active || (runState & STOP) != 0)\n+                    if (!Thread.interrupted())\n+                        U.park(trimmable, deadline);\n+                    if (((p = w.phase) & IDLE) == 0)\n+                        break;\n+                    if (trimmable) {\n+                        if ((trim = tryTrim(w, queuedCtl, deadline)) > 0)\n@@ -2146,12 +2122,3 @@\n-                        Thread.interrupted();    \/\/ clear for next park\n-                        if (deadline != 0L && TIMEOUT_SLOP >\n-                            deadline - System.currentTimeMillis()) {\n-                            long sp = w.stackPred & LMASK, c = ctl;\n-                            long nc = sp | (UMASK & (c - TC_UNIT));\n-                            if (((int)c & SMASK) == (active & SMASK) &&\n-                                compareAndSetCtl(c, nc)) {\n-                                w.source = DEREGISTERED;\n-                                w.phase = active;\n-                                break;           \/\/ trimmed on timeout\n-                            }\n-                            deadline = 0L;       \/\/ no longer trimmable\n+                        if (trim < 0) {\n+                            trimmable = false;\n+                            deadline = 0L;\n@@ -2160,2 +2127,0 @@\n-                    w.parking = 0;\n-                    LockSupport.setCurrentBlocker(null);\n@@ -2164,0 +2129,2 @@\n+            w.source = 0;\n+            LockSupport.setCurrentBlocker(null);\n@@ -2168,0 +2135,31 @@\n+    \/**\n+     * Tries to remove and deregister worker after timeout, and release\n+     * another to do the same.\n+     * @return > 0: trimmed, < 0 : not trimmable, else 0\n+     *\/\n+    private int tryTrim(WorkQueue w, long queuedCtl, long deadline) {\n+        long c, nc; int stat, p, vp, i; WorkQueue[] vs; WorkQueue v;\n+        if ((c = ctl) != queuedCtl || w == null || ((p = w.phase) & IDLE) == 0)\n+            stat = -1;                      \/\/ no longer ctl top\n+        else if (deadline - System.currentTimeMillis() >= TIMEOUT_SLOP)\n+            stat = 0;                       \/\/ spurious wakeup\n+        else if (!compareAndSetCtl(\n+                     c, nc = (w.stackPred & LMASK) | (UMASK & (c - TC_UNIT))))\n+            stat = -1;                      \/\/ lost race to signaller\n+        else {\n+            stat = 1;\n+            w.source = DROPPED;\n+            w.phase = p + IDLE;\n+            if ((vp = (int)nc) != 0 && (vs = queues) != null &&\n+                vs.length > (i = vp & SMASK) && (v = vs[i]) != null &&\n+                compareAndSetCtl(           \/\/ try to wake up next waiter\n+                    nc, ((UMASK & (nc + RC_UNIT)) |\n+                         (nc & TC_MASK) | (v.stackPred & LMASK)))) {\n+                v.source = INVALID_ID;      \/\/ enable cascaded timeouts\n+                v.phase = vp;\n+                U.unpark(v.owner);\n+            }\n+        }\n+        return stat;\n+    }\n+\n@@ -2176,1 +2174,1 @@\n-        if ((runState & STOP) == 0) {\n+        if ((runState & STOP) == 0L) {\n@@ -2185,1 +2183,1 @@\n-                        (t = q.poll(this)) != null)\n+                        (t = q.poll()) != null)\n@@ -2220,1 +2218,1 @@\n-                if (v.parking != 0)\n+                if (v.source < 0)\n@@ -2231,1 +2229,1 @@\n-            if ((runState & STOP) != 0)                 \/\/ terminating\n+            if ((runState & STOP) != 0L)                \/\/ terminating\n@@ -2264,1 +2262,0 @@\n-\n@@ -2276,1 +2273,1 @@\n-                    if ((runState & STOP) != 0)\n+                    if ((runState & STOP) != 0L)\n@@ -2357,1 +2354,1 @@\n-                    if ((runState & STOP) != 0)\n+                    if ((runState & STOP) != 0L)\n@@ -2435,2 +2432,2 @@\n-        for (int e = runState;;) {\n-            if ((e & STOP) != 0)\n+        for (long e = runState;;) {\n+            if ((e & STOP) != 0L)\n@@ -2489,1 +2486,1 @@\n-                rescan || (e & RS_LOCK) != 0)\n+                rescan || (e & RS_LOCK) != 0L)\n@@ -2521,1 +2518,1 @@\n-        if (!quiescent()) {\n+        if (quiescent() < 0) {\n@@ -2532,1 +2529,1 @@\n-                else if (quiescent())\n+                else if (quiescent() >= 0)\n@@ -2595,1 +2592,1 @@\n-            int n, i, id; WorkQueue[] qs; WorkQueue q;\n+            int n, i, id; WorkQueue[] qs; WorkQueue q, w = null;\n@@ -2601,5 +2598,8 @@\n-                WorkQueue w = new WorkQueue(null, id, 0, false);\n-                w.array = new ForkJoinTask<?>[INITIAL_QUEUE_CAPACITY];\n-                int stop = lockRunState() & STOP;\n-                if (stop == 0 && queues == qs && qs[i] == null)\n-                    q = qs[i] = w;                   \/\/ else discard; retry\n+                if (w == null)\n+                    w = new WorkQueue(null, id, 0, false);\n+                w.phase = id;\n+                long stop = lockRunState() & STOP;\n+                if (stop == 0L && queues == qs && qs[i] == null) {\n+                    q = qs[i] = w;                   \/\/ else retry\n+                    w = null;\n+                }\n@@ -2609,1 +2609,1 @@\n-                if (stop != 0)\n+                if (stop != 0L)\n@@ -2614,1 +2614,1 @@\n-            else if ((runState & SHUTDOWN) != 0) {\n+            else if ((runState & SHUTDOWN) != 0L) {\n@@ -2756,16 +2756,10 @@\n-    private int tryTerminate(boolean now, boolean enable) {\n-        int e = runState;\n-        if ((e & STOP) == 0) {\n-            if (now) {\n-                int s = lockRunState();\n-                runState = e = (s + RS_LOCK) | STOP | SHUTDOWN;\n-                if ((s & STOP) == 0)\n-                    interruptAll();\n-            }\n-            else {\n-                int isShutdown = (e & SHUTDOWN);\n-                if (isShutdown == 0 && enable)\n-                    getAndBitwiseOrRunState(isShutdown = SHUTDOWN);\n-                if (isShutdown != 0)\n-                    quiescent();                 \/\/ may trigger STOP\n-                e = runState;\n+    private long tryTerminate(boolean now, boolean enable) {\n+        long e = runState, isShutdown;\n+        if ((e & STOP) == 0L) {\n+            if (now)\n+                runState = e = (lockRunState() + RS_LOCK) | STOP | SHUTDOWN;\n+            else if ((isShutdown = (e & SHUTDOWN)) != 0 || enable) {\n+                if (isShutdown == 0)\n+                    getAndBitwiseOrRunState(SHUTDOWN);\n+                if (quiescent() > 0)\n+                    e = runState;\n@@ -2773,0 +2767,2 @@\n+            if ((e & STOP) != 0L && (releaseAll() & RC_MASK) > 0L && now)\n+                interruptAll();\n@@ -2775,10 +2771,14 @@\n-            int r = (int)Thread.currentThread().threadId(); \/\/ stagger traversals\n-            WorkQueue[] qs = queues;\n-            int n = (qs == null) ? 0 : qs.length;\n-            for (int l = n; l > 0; --l, ++r) {\n-                int j = r & SMASK & (n - 1); WorkQueue q; ForkJoinTask<?> t;\n-                while ((q = qs[j]) != null && q.source != DEREGISTERED &&\n-                       (t = q.poll(null)) != null) {\n-                    try {\n-                        t.cancel(false);\n-                    } catch (Throwable ignore) {\n+            if ((ctl & RC_MASK) > 0L) {          \/\/ unless all inactive\n+                int r = (int)Thread.currentThread().threadId();\n+                WorkQueue[] qs = queues;         \/\/ stagger traversals\n+                int n = (qs == null) ? 0 : qs.length;\n+                for (int l = n; l > 0; --l, ++r) {\n+                    WorkQueue q; ForkJoinTask<?> t;\n+                    if ((q = qs[r & (n - 1)]) != null &&\n+                        q.source != DROPPED) {\n+                        while ((t = q.poll()) != null) {\n+                            try {\n+                                t.cancel(false);\n+                            } catch (Throwable ignore) {\n+                            }\n+                        }\n@@ -2788,2 +2788,3 @@\n-            if (((e = runState) & TERMINATED) == 0 && ctl == 0L) {\n-                if ((getAndBitwiseOrRunState(TERMINATED) & TERMINATED) == 0) {\n+            if (((e = runState) & TERMINATED) == 0L && ctl == 0L) {\n+                e |= TERMINATED;\n+                if ((getAndBitwiseOrRunState(TERMINATED) & TERMINATED) == 0L) {\n@@ -2796,1 +2797,0 @@\n-                e = runState;\n@@ -2812,1 +2812,1 @@\n-                q.source != DEREGISTERED) {\n+                q.source != DROPPED) {\n@@ -3472,1 +3472,1 @@\n-        if ((runState & TERMINATED) == 0 && (qs = queues) != null) {\n+        if ((runState & TERMINATED) == 0L && (qs = queues) != null) {\n@@ -3504,1 +3504,1 @@\n-        return quiescent();\n+        return quiescent() >= 0;\n@@ -3544,1 +3544,1 @@\n-        if ((runState & TERMINATED) == 0 && (qs = queues) != null) {\n+        if ((runState & TERMINATED) == 0L && (qs = queues) != null) {\n@@ -3563,1 +3563,1 @@\n-        if ((runState & TERMINATED) == 0 && (qs = queues) != null) {\n+        if ((runState & TERMINATED) == 0L && (qs = queues) != null) {\n@@ -3580,1 +3580,1 @@\n-        if ((runState & STOP) == 0 && (qs = queues) != null) {\n+        if ((runState & STOP) == 0L && (qs = queues) != null) {\n@@ -3635,1 +3635,1 @@\n-        int e = runState;\n+        long e = runState;\n@@ -3661,3 +3661,3 @@\n-        String level = ((e & TERMINATED) != 0 ? \"Terminated\" :\n-                        (e & STOP)       != 0 ? \"Terminating\" :\n-                        (e & SHUTDOWN)   != 0 ? \"Shutting down\" :\n+        String level = ((e & TERMINATED) != 0L ? \"Terminated\" :\n+                        (e & STOP)       != 0L ? \"Terminating\" :\n+                        (e & SHUTDOWN)   != 0L ? \"Shutting down\" :\n@@ -3754,1 +3754,1 @@\n-        return (runState & SHUTDOWN) != 0;\n+        return (runState & SHUTDOWN) != 0L;\n@@ -3782,1 +3782,1 @@\n-                 (runState & TERMINATED) != 0)\n+                 (runState & TERMINATED) != 0L)\n@@ -3971,1 +3971,1 @@\n-            if ((runState & STOP) != 0)\n+            if ((runState & STOP) != 0L)\n@@ -3991,0 +3991,1 @@\n+     * @return value to use in endCompensatedBlock\n@@ -4000,0 +4001,1 @@\n+     * @param post value from beginCompensatedBlock\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":467,"deletions":465,"binary":false,"changes":932,"status":"modified"}]}