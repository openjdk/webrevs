{"files":[{"patch":"@@ -277,0 +277,1 @@\n+macro(NarrowMemProj)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -866,1 +866,1 @@\n-void ConnectionGraph::reduce_phi_on_castpp_field_load(Node* curr_castpp, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist) {\n+void ConnectionGraph::reduce_phi_on_castpp_field_load(Node* curr_castpp, GrowableArray<Node*> &alloc_worklist) {\n@@ -1282,1 +1282,1 @@\n-void ConnectionGraph::reduce_phi(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist) {\n+void ConnectionGraph::reduce_phi(PhiNode* ophi, GrowableArray<Node*> &alloc_worklist) {\n@@ -1309,1 +1309,1 @@\n-    reduce_phi_on_castpp_field_load(castpps.at(i), alloc_worklist, memnode_worklist);\n+    reduce_phi_on_castpp_field_load(castpps.at(i), alloc_worklist);\n@@ -4155,0 +4155,5 @@\n+        } else if (C->get_alias_index(result->adr_type()) != alias_idx) {\n+          assert(C->get_general_index(alias_idx) == C->get_alias_index(result->adr_type()), \"should be projection for the same field\/array element\");\n+          result = get_map(result->_idx);\n+          assert(result != nullptr, \"new projection should have been allocated\");\n+          break;\n@@ -4451,0 +4456,16 @@\n+        \/\/ Add a new NarrowMem projection for each existing NarrowMem projection with new adr type\n+        InitializeNode* init = alloc->as_Allocate()->initialization();\n+        assert(init != nullptr, \"can't find Initialization node for this Allocate node\");\n+        auto process_narrow_proj = [&](NarrowMemProjNode* proj) {\n+          const TypePtr* adr_type = proj->adr_type();\n+          const TypePtr* new_adr_type = tinst->add_offset(adr_type->offset());\n+          if (adr_type != new_adr_type && !init->already_has_narrow_mem_proj_with_adr_type(new_adr_type)) {\n+            DEBUG_ONLY( uint alias_idx = _compile->get_alias_index(new_adr_type); )\n+            assert(_compile->get_general_index(alias_idx) == _compile->get_alias_index(adr_type), \"new adr type should be narrowed down from existing adr type\");\n+            NarrowMemProjNode* new_proj = new NarrowMemProjNode(init, new_adr_type);\n+            igvn->set_type(new_proj, new_proj->bottom_type());\n+            record_for_optimizer(new_proj);\n+            set_map(proj, new_proj); \/\/ record it so ConnectionGraph::find_inst_mem() can find it\n+          }\n+        };\n+        init->for_each_narrow_mem_proj_with_new_uses(process_narrow_proj);\n@@ -4522,1 +4543,1 @@\n-        reduce_phi(n->as_Phi(), alloc_worklist, memnode_worklist);\n+        reduce_phi(n->as_Phi(), alloc_worklist);\n@@ -4714,5 +4735,7 @@\n-    } else if (n->is_MemBar()) { \/\/ Initialize, MemBar nodes\n-      \/\/ we don't need to do anything, but the users must be pushed\n-      n = n->as_MemBar()->proj_out_or_null(TypeFunc::Memory);\n-      if (n == nullptr) {\n-        continue;\n+    } else if (n->is_MemBar()) { \/\/ MemBar nodes\n+      if (!n->is_Initialize()) { \/\/ memory projections for Initialize pushed below (so we get to all their uses)\n+        \/\/ we don't need to do anything, but the users must be pushed\n+        n = n->as_MemBar()->proj_out_or_null(TypeFunc::Memory);\n+        if (n == nullptr) {\n+          continue;\n+        }\n@@ -4735,0 +4758,2 @@\n+    } else if (n->is_Proj()) {\n+      assert(n->in(0)->is_Initialize(), \"we only push memory projections for Initialize\");\n@@ -4778,0 +4803,5 @@\n+      } else if (use->is_Proj()) {\n+        assert(n->is_Initialize(), \"We only push projections of Initialize\");\n+        if (use->as_Proj()->_con == TypeFunc::Memory) { \/\/ Ignore precedent edge\n+          memnode_worklist.append_if_missing(use);\n+        }\n@@ -4829,1 +4859,1 @@\n-        const Type *at = igvn->type(mem->in(MemNode::Address));\n+        const Type* at = igvn->type(mem->in(MemNode::Address));\n@@ -4949,1 +4979,1 @@\n-             n->is_AddP() || n->is_Phi(), \"unknown node used for set_map()\");\n+             n->is_AddP() || n->is_Phi() || n->is_NarrowMemProj(), \"unknown node used for set_map()\");\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":41,"deletions":11,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -566,1 +566,1 @@\n-                        \/\/ ChecCastPP    - allocation that this is a cast of\n+                        \/\/ CheckCastPP   - allocation that this is a cast of\n@@ -568,0 +568,2 @@\n+                        \/\/ NarrowMem     - newly created projection (type includes instance_id) from projection created\n+                        \/\/                 before EA\n@@ -612,1 +614,1 @@\n-  void reduce_phi_on_castpp_field_load(Node* castpp, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist);\n+  void reduce_phi_on_castpp_field_load(Node* castpp, GrowableArray<Node*> &alloc_worklist);\n@@ -616,1 +618,1 @@\n-  void reduce_phi(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist);\n+  void reduce_phi(PhiNode* ophi, GrowableArray<Node*> &alloc_worklist);\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3644,4 +3644,7 @@\n-    \/\/ Add an edge in the MergeMem for the header fields so an access\n-    \/\/ to one of those has correct memory state\n-    set_memory(minit_out, C->get_alias_index(oop_type->add_offset(oopDesc::mark_offset_in_bytes())));\n-    set_memory(minit_out, C->get_alias_index(oop_type->add_offset(oopDesc::klass_offset_in_bytes())));\n+    int mark_idx = C->get_alias_index(oop_type->add_offset(oopDesc::mark_offset_in_bytes()));\n+    \/\/ Add an edge in the MergeMem for the header fields so an access to one of those has correct memory state.\n+    \/\/ Use one NarrowMemProjNode per slice to properly record the adr type of each slice. The Initialize node will have\n+    \/\/ multiple projections as a result.\n+    set_memory(_gvn.transform(new NarrowMemProjNode(init, C->get_adr_type(mark_idx))), mark_idx);\n+    int klass_idx = C->get_alias_index(oop_type->add_offset(oopDesc::klass_offset_in_bytes()));\n+    set_memory(_gvn.transform(new NarrowMemProjNode(init, C->get_adr_type(klass_idx))), klass_idx);\n@@ -3651,1 +3654,1 @@\n-      hook_memory_on_init(*this, elemidx, minit_in, minit_out);\n+      hook_memory_on_init(*this, elemidx, minit_in, _gvn.transform(new NarrowMemProjNode(init, C->get_adr_type(elemidx))));\n@@ -3660,1 +3663,1 @@\n-        hook_memory_on_init(*this, fieldidx, minit_in, minit_out);\n+        hook_memory_on_init(*this, fieldidx, minit_in, _gvn.transform(new NarrowMemProjNode(init, C->get_adr_type(fieldidx))));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -592,1 +592,1 @@\n-      MemNode::dump_adr_type(node, node->adr_type(), &s2);\n+      MemNode::dump_adr_type(node->adr_type(), &s2);\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5547,1 +5547,1 @@\n-    C->gvn_replace_by(init->proj_out(TypeFunc::Memory), alloc_mem);\n+    init->replace_mem_projs_by(alloc_mem, C);\n@@ -5598,2 +5598,14 @@\n-    set_memory(init->proj_out_or_null(TypeFunc::Memory), Compile::AliasIdxRaw);\n-    set_memory(init->proj_out_or_null(TypeFunc::Memory), elemidx);\n+    \/\/ Need to properly move every memory projection for the Initialize\n+#ifdef ASSERT\n+    int mark_idx = C->get_alias_index(ary_type->add_offset(oopDesc::mark_offset_in_bytes()));\n+    int klass_idx = C->get_alias_index(ary_type->add_offset(oopDesc::klass_offset_in_bytes()));\n+#endif\n+    auto move_proj = [&](ProjNode* proj) {\n+      int alias_idx = C->get_alias_index(proj->adr_type());\n+      assert(alias_idx == Compile::AliasIdxRaw ||\n+             alias_idx == elemidx ||\n+             alias_idx == mark_idx ||\n+             alias_idx == klass_idx, \"should be raw memory or array element type\");\n+      set_memory(proj, alias_idx);\n+    };\n+    init->for_each_proj(move_proj, TypeFunc::Memory);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4034,1 +4034,3 @@\n-  call->init_req(TypeFunc::FramePtr,  C->start()->proj_out_or_null(TypeFunc::FramePtr));\n+  Node* frame = new ParmNode(C->start(), TypeFunc::FramePtr);\n+  _igvn.register_new_node_with_optimizer(frame);\n+  call->init_req(TypeFunc::FramePtr,  frame);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2681,2 +2681,3 @@\n-          Node* cle_out = cle->proj_out_or_null(false);\n-          if (use == cle_out) {\n+          \/\/ is use the projection that exits the loop from the CountedLoopEndNode?\n+          if (use->in(0) == cle) {\n+            IfFalseNode* cle_out = use->as_IfFalse();\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -999,1 +999,0 @@\n-        assert(init->outcnt() <= 2, \"only a control and memory projection expected\");\n@@ -1009,3 +1008,1 @@\n-        Node *mem_proj = init->proj_out_or_null(TypeFunc::Memory);\n-        if (mem_proj != nullptr) {\n-          Node *mem = init->in(TypeFunc::Memory);\n+        Node* mem = init->in(TypeFunc::Memory);\n@@ -1013,0 +1010,1 @@\n+        if (init->number_of_projs(TypeFunc::Memory) > 0) {\n@@ -1014,1 +1012,1 @@\n-            assert(mem->in(TypeFunc::Memory) == _callprojs.fallthrough_memproj, \"allocation memory projection\");\n+            assert(mem->as_MergeMem()->memory_at(Compile::AliasIdxRaw) == _callprojs.fallthrough_memproj, \"allocation memory projection\");\n@@ -1018,2 +1016,0 @@\n-#endif\n-          _igvn.replace_node(mem_proj, mem);\n@@ -1021,0 +1017,3 @@\n+#endif\n+        init->replace_mem_projs_by(mem, &_igvn);\n+        assert(init->outcnt() == 0, \"should only have had a control and some memory projections, and we removed them\");\n@@ -1607,1 +1606,10 @@\n-      MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);\n+      \/\/ What we want is to prevent the compiler and the CPU from re-ordering the stores that initialize this object\n+      \/\/ with subsequent stores to any slice. As a consequence, this MemBar should capture the entire memory state at\n+      \/\/ this point in the IR and produce a new memory state that should cover all slices. However, the Initialize node\n+      \/\/ only captures\/produces a partial memory state making it complicated to insert such a MemBar. Because\n+      \/\/ re-ordering by the compiler can't happen by construction (a later Store that publishes the just allocated\n+      \/\/ object reference is indirectly control dependent on the Initialize node), preventing reordering by the CPU is\n+      \/\/ sufficient. For that a MemBar on the raw memory slice is good enough.\n+      \/\/ If init is null, this allocation does have an InitializeNode but this logic can't locate it (see comment in\n+      \/\/ PhaseMacroExpand::initialize_object()).\n+      MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxRaw);\n@@ -1623,1 +1631,0 @@\n-      Node* init_mem = init->proj_out_or_null(TypeFunc::Memory);\n@@ -1625,1 +1632,2 @@\n-      MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);\n+      \/\/ See comment above that explains why a raw memory MemBar is good enough.\n+      MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxRaw);\n@@ -1630,2 +1638,11 @@\n-      Node* mem = new ProjNode(init, TypeFunc::Memory);\n-      transform_later(mem);\n+      Node* old_raw_mem_proj = nullptr;\n+      auto find_raw_mem = [&](ProjNode* proj) {\n+        if (C->get_alias_index(proj->adr_type()) == Compile::AliasIdxRaw) {\n+          assert(old_raw_mem_proj == nullptr, \"only one expected\");\n+          old_raw_mem_proj = proj;\n+        }\n+      };\n+      init->for_each_proj(find_raw_mem, TypeFunc::Memory);\n+      assert(old_raw_mem_proj != nullptr, \"should have found raw mem Proj\");\n+      Node* raw_mem_proj = new ProjNode(init, TypeFunc::Memory);\n+      transform_later(raw_mem_proj);\n@@ -1635,1 +1652,1 @@\n-      mb->init_req(TypeFunc::Memory, mem);\n+      mb->init_req(TypeFunc::Memory, raw_mem_proj);\n@@ -1640,1 +1657,1 @@\n-      mem = new ProjNode(mb, TypeFunc::Memory);\n+      Node* mem = new ProjNode(mb, TypeFunc::Memory);\n@@ -1649,3 +1666,1 @@\n-      if (init_mem != nullptr) {\n-        _igvn.replace_node(init_mem, mem);\n-      }\n+      _igvn.replace_node(old_raw_mem_proj, mem);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":32,"deletions":17,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -154,0 +154,2 @@\n+    assert(!n->is_Initialize() || n->as_Initialize()->number_of_projs(TypeFunc::Memory) == 1,\n+           \"after matching, Initialize should have a single memory projection\");\n@@ -1032,1 +1034,1 @@\n-        Node* m;\n+        Node* m = nullptr;\n@@ -1047,3 +1049,15 @@\n-              \/\/ Convert to machine-dependent projection\n-              m = n->in(0)->as_Multi()->match( n->as_Proj(), this );\n-              NOT_PRODUCT(record_new2old(m, n);)\n+              if (n->in(0)->is_Initialize() && n->as_Proj()->_con == TypeFunc::Memory) {\n+                \/\/ Initialize may have multiple NarrowMem projections. They would all match to identical raw mem MachProjs.\n+                \/\/ We don't need multiple MachProjs. Create one if none already exist, otherwise use existing one.\n+                m = n->in(0)->as_Initialize()->mem_mach_proj();\n+                if (m == nullptr && has_new_node(n->in(0))) {\n+                  InitializeNode* new_init = new_node(n->in(0))->as_Initialize();\n+                  m = new_init->mem_mach_proj();\n+                }\n+                assert(m == nullptr || m->is_MachProj(), \"no mem projection yet or a MachProj created during matching\");\n+              }\n+              if (m == nullptr) {\n+                \/\/ Convert to machine-dependent projection\n+                m = n->in(0)->as_Multi()->match( n->as_Proj(), this );\n+                NOT_PRODUCT(record_new2old(m, n);)\n+              }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  dump_adr_type(this, _adr_type, st);\n+  dump_adr_type(_adr_type, st);\n@@ -111,1 +111,1 @@\n-void MemNode::dump_adr_type(const Node* mem, const TypePtr* adr_type, outputStream *st) {\n+void MemNode::dump_adr_type(const TypePtr* adr_type, outputStream* st) {\n@@ -4232,1 +4232,1 @@\n-  assert(outcnt() > 0 && outcnt() <= 2, \"Only one or two out edges allowed\");\n+  assert(outcnt() > 0 && (outcnt() <= 2 || Opcode() == Op_Initialize), \"Only one or two out edges allowed\");\n@@ -4240,3 +4240,0 @@\n-  if (proj_out_or_null(TypeFunc::Memory) != nullptr) {\n-    igvn->replace_node(proj_out(TypeFunc::Memory), in(TypeFunc::Memory));\n-  }\n@@ -4246,0 +4243,7 @@\n+  if (is_Initialize()) {\n+    as_Initialize()->replace_mem_projs_by(in(TypeFunc::Memory), igvn);\n+  } else {\n+    if (proj_out_or_null(TypeFunc::Memory) != nullptr) {\n+      igvn->replace_node(proj_out(TypeFunc::Memory), in(TypeFunc::Memory));\n+    }\n+  }\n@@ -5448,0 +5452,54 @@\n+void InitializeNode::replace_mem_projs_by(Node* mem, Compile* C) {\n+  auto replace_proj = [&](ProjNode* proj) {\n+    C->gvn_replace_by(proj, mem);\n+    return CONTINUE;\n+  };\n+  apply_to_projs(replace_proj, TypeFunc::Memory);\n+}\n+\n+void InitializeNode::replace_mem_projs_by(Node* mem, PhaseIterGVN* igvn) {\n+  DUIterator_Fast imax, i = fast_outs(imax);\n+  auto replace_proj = [&](ProjNode* proj) {\n+    igvn->replace_node(proj, mem);\n+    --i; --imax;\n+    return CONTINUE;\n+  };\n+  apply_to_projs(imax, i, replace_proj, TypeFunc::Memory);\n+}\n+\n+template <class Callback> NarrowMemProjNode* InitializeNode::apply_to_narrow_mem_projs(Callback callback) const {\n+  DUIterator_Fast imax, i = fast_outs(imax);\n+  return apply_to_narrow_mem_projs_any_iterator(UsesIteratorFast(imax, i, this), callback);\n+}\n+\n+\n+template<class Callback> NarrowMemProjNode* InitializeNode::apply_to_narrow_mem_projs(Callback callback, const TypePtr* adr_type) const {\n+  auto filter = [&](NarrowMemProjNode* proj) {\n+    if (proj->adr_type() == adr_type && callback(proj->as_NarrowMemProj()) == BREAK_AND_RETURN_CURRENT_PROJ) {\n+      return BREAK_AND_RETURN_CURRENT_PROJ;\n+    }\n+    return CONTINUE;\n+  };\n+  return apply_to_narrow_mem_projs(filter);\n+}\n+\n+bool InitializeNode::already_has_narrow_mem_proj_with_adr_type(const TypePtr* adr_type) const {\n+  auto find_proj = [](ProjNode* proj) {\n+    return BREAK_AND_RETURN_CURRENT_PROJ;\n+  };\n+  return apply_to_narrow_mem_projs(find_proj, adr_type) != nullptr;\n+}\n+\n+MachProjNode* InitializeNode::mem_mach_proj() const {\n+  auto find_proj = [](ProjNode* proj) {\n+    if (proj->is_MachProj()) {\n+      return BREAK_AND_RETURN_CURRENT_PROJ;\n+    }\n+    return CONTINUE;\n+  };\n+  ProjNode* proj = apply_to_projs(find_proj, TypeFunc::Memory);\n+  if (proj == nullptr) {\n+    return nullptr;\n+  }\n+  return proj->as_MachProj();\n+}\n@@ -5870,0 +5928,1 @@\n+           || n->is_NarrowMemProj()\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":65,"deletions":6,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-  static void dump_adr_type(const Node* mem, const TypePtr* adr_type, outputStream *st);\n+  static void dump_adr_type(const TypePtr* adr_type, outputStream* st);\n@@ -1374,1 +1374,14 @@\n- private:\n+  \/\/ An Initialize node has multiple memory projections. Helper methods used when the node is removed.\n+  \/\/ For use at parse time\n+  void replace_mem_projs_by(Node* mem, Compile* C);\n+  \/\/ For use with IGVN\n+  void replace_mem_projs_by(Node* mem, PhaseIterGVN* igvn);\n+\n+  \/\/ Does a NarrowMemProj with this adr_type and this node as input already exist?\n+  bool already_has_narrow_mem_proj_with_adr_type(const TypePtr* adr_type) const;\n+\n+  \/\/ Used during matching: find the MachProj memory projection if there's one. Expectation is that there should be at\n+  \/\/ most one.\n+  MachProjNode* mem_mach_proj() const;\n+\n+private:\n@@ -1391,0 +1404,40 @@\n+\n+  \/\/ Iterate with i over all NarrowMemProj uses calling callback\n+  template <class Callback, class Iterator> NarrowMemProjNode* apply_to_narrow_mem_projs_any_iterator(Iterator i, Callback callback) const {\n+    auto filter = [&](ProjNode* proj) {\n+      if (proj->is_NarrowMemProj() && callback(proj->as_NarrowMemProj()) == BREAK_AND_RETURN_CURRENT_PROJ) {\n+        return BREAK_AND_RETURN_CURRENT_PROJ;\n+      }\n+      return CONTINUE;\n+    };\n+    ProjNode* res = apply_to_projs_any_iterator(i, filter);\n+    if (res == nullptr) {\n+      return nullptr;\n+    }\n+    return res->as_NarrowMemProj();\n+  }\n+\n+  \/\/ Same but with default iterator\n+  template <class Callback> NarrowMemProjNode* apply_to_narrow_mem_projs(Callback callback) const;\n+  \/\/ Same but only for NarrowMem proj whose adr_type matches\n+  template <class Callback> NarrowMemProjNode* apply_to_narrow_mem_projs(Callback callback, const TypePtr* adr_type) const;\n+\n+  \/\/ Run callback on all NarrowMem proj uses using passed iterator\n+  template <class Callback> NarrowMemProjNode* apply_to_narrow_mem_projs(DUIterator& i, Callback callback) const {\n+    return apply_to_narrow_mem_projs_any_iterator<Callback, UsesIterator>(UsesIterator(i, this), callback);\n+  }\n+\n+  template <class Callback> NarrowMemProjNode* apply_to_narrow_mem_projs_with_new_uses(Callback callback) const {\n+    DUIterator i = outs();\n+    return apply_to_narrow_mem_projs_any_iterator<Callback, UsesIterator>(UsesIterator(i, this), callback);\n+  }\n+\n+public:\n+\n+  template <class Callback> void for_each_narrow_mem_proj_with_new_uses(Callback callback) const {\n+    auto callback_always_continue = [&](NarrowMemProjNode* proj) {\n+      callback(proj);\n+      return MultiNode::CONTINUE;\n+    };\n+    apply_to_narrow_mem_projs_with_new_uses(callback_always_continue);\n+  }\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":55,"deletions":2,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -48,14 +48,5 @@\n-  for( DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++ ) {\n-    Node *p = fast_out(i);\n-    if (p->is_Proj()) {\n-      ProjNode *proj = p->as_Proj();\n-      if (proj->_con == which_proj) {\n-        assert((Opcode() != Op_If && Opcode() != Op_RangeCheck) || proj->Opcode() == (which_proj ? Op_IfTrue : Op_IfFalse), \"bad if #2\");\n-        return proj;\n-      }\n-    } else {\n-      assert(p == this && this->is_Start(), \"else must be proj\");\n-      continue;\n-    }\n-  }\n-  return nullptr;\n+  assert(number_of_projs(which_proj) <= 1, \"only when there's a single projection\");\n+  ProjNode* proj = find_first(which_proj);\n+  assert(proj == nullptr || (Opcode() != Op_If && Opcode() != Op_RangeCheck) || proj->Opcode() == (which_proj ? Op_IfTrue : Op_IfFalse),\n+         \"incorrect projection node at If\/RangeCheck: IfTrue on false path or IfFalse on true path\");\n+  return proj;\n@@ -65,4 +56,8 @@\n-  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n-    ProjNode* proj = fast_out(i)->isa_Proj();\n-    if (proj != nullptr && (proj->_con == which_proj) && (proj->_is_io_use == is_io_use)) {\n-      return proj;\n+  assert(number_of_projs(which_proj, is_io_use) <= 1, \"only when there's a single projection\");\n+  return find_first(which_proj, is_io_use);\n+}\n+\n+template<class Callback> ProjNode* MultiNode::apply_to_projs(Callback callback, uint which_proj, bool is_io_use) const {\n+  auto filter = [&](ProjNode* proj) {\n+    if (proj->_is_io_use == is_io_use && callback(proj) == BREAK_AND_RETURN_CURRENT_PROJ) {\n+      return BREAK_AND_RETURN_CURRENT_PROJ;\n@@ -70,2 +65,35 @@\n-  }\n-  return nullptr;\n+    return CONTINUE;\n+  };\n+  return apply_to_projs(filter, which_proj);\n+}\n+\n+uint MultiNode::number_of_projs(uint which_proj) const {\n+  uint cnt = 0;\n+  auto count_projs = [&](ProjNode* proj) {\n+    cnt++;\n+  };\n+  for_each_proj(count_projs, which_proj);\n+  return cnt;\n+}\n+\n+uint MultiNode::number_of_projs(uint which_proj, bool is_io_use) const {\n+  uint cnt = 0;\n+  auto count_projs = [&](ProjNode* proj) {\n+    cnt++;\n+  };\n+  for_each_proj(count_projs, which_proj, is_io_use);\n+  return cnt;\n+}\n+\n+ProjNode* MultiNode::find_first(uint which_proj) const {\n+  auto find_proj = [&](ProjNode* proj) {\n+    return BREAK_AND_RETURN_CURRENT_PROJ;\n+  };\n+  return apply_to_projs(find_proj, which_proj);\n+}\n+\n+ProjNode* MultiNode::find_first(uint which_proj, bool is_io_use) const {\n+  auto find_proj = [](ProjNode* proj) {\n+    return BREAK_AND_RETURN_CURRENT_PROJ;\n+  };\n+  return apply_to_projs(find_proj, which_proj, is_io_use);\n","filename":"src\/hotspot\/share\/opto\/multnode.cpp","additions":48,"deletions":20,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -52,0 +52,109 @@\n+  uint number_of_projs(uint which_proj) const;\n+  uint number_of_projs(uint which_proj, bool is_io_use) const;\n+\n+protected:\n+\n+  \/\/ Provide single interface for DUIterator_Fast\/DUIterator for template method below\n+  class UsesIteratorFast {\n+    DUIterator_Fast& _imax;\n+    DUIterator_Fast& _i;\n+    const Node* _node;\n+\n+  public:\n+    bool cont() {\n+      return _i < _imax;\n+    }\n+    void next() {\n+      _i++;\n+    }\n+    Node* current() {\n+      return _node->fast_out(_i);\n+    }\n+    UsesIteratorFast(DUIterator_Fast& imax, DUIterator_Fast& i, const Node* node)\n+      : _imax(imax), _i(i), _node(node) {\n+    }\n+  };\n+\n+  class UsesIterator {\n+    DUIterator& _i;\n+    const Node* _node;\n+\n+  public:\n+    bool cont() {\n+      return _node->has_out(_i);\n+    }\n+    void next() {\n+      _i++;\n+    }\n+    Node* current() {\n+      return _node->out(_i);\n+    }\n+    UsesIterator(DUIterator& i, const Node* node)\n+      : _i(i), _node(node) {\n+    }\n+  };\n+\n+  \/\/ Iterate with i over all Proj uses calling callback\n+  template<class Callback, class Iterator> ProjNode* apply_to_projs_any_iterator(Iterator i, Callback callback) const {\n+    for (; i.cont(); i.next()) {\n+      Node* p = i.current();\n+      if (p->is_Proj()) {\n+        ProjNode* proj = p->as_Proj();\n+        ApplyToProjs result = callback(proj);\n+        if (result == BREAK_AND_RETURN_CURRENT_PROJ) {\n+          return proj;\n+        }\n+        assert(result == CONTINUE, \"should be either break or continue\");\n+      } else {\n+        assert(p == this && is_Start(), \"else must be proj\");\n+      }\n+    }\n+    return nullptr;\n+  }\n+public:\n+  enum ApplyToProjs {\n+    CONTINUE,\n+    BREAK_AND_RETURN_CURRENT_PROJ\n+  };\n+\n+  \/\/ Run callback on projections with iterator passed as argument\n+  template<class Callback> ProjNode* apply_to_projs(DUIterator_Fast& imax, DUIterator_Fast& i, Callback callback) const {\n+    return apply_to_projs_any_iterator<Callback, UsesIteratorFast>(UsesIteratorFast(imax, i, this), callback);\n+  }\n+\n+  \/\/ Same but with default iterator\n+  template<class Callback> ProjNode* apply_to_projs(Callback callback) const {\n+    DUIterator_Fast imax, i = fast_outs(imax);\n+    return apply_to_projs(imax, i, callback);\n+  }\n+\n+  \/\/ Same but only for Proj node whose _con matches which_proj\n+  template <class Callback> ProjNode* apply_to_projs(DUIterator_Fast& imax, DUIterator_Fast& i, Callback callback, uint which_proj) const;\n+\n+  \/\/ Same but with default iterator\n+  template<class Callback> ProjNode* apply_to_projs(Callback callback, uint which_proj) const {\n+    DUIterator_Fast imax, i = fast_outs(imax);\n+    return apply_to_projs(imax, i, callback, which_proj);\n+  }\n+\n+  \/\/ Same but for matching _con and _is_io_use\n+  template <class Callback> ProjNode* apply_to_projs(Callback callback, uint which_proj, bool is_io_use) const;\n+\n+  template<class Callback> void for_each_proj(Callback callback, uint which_proj) const {\n+    auto callback_always_continue = [&](ProjNode* proj) {\n+      callback(proj);\n+      return MultiNode::CONTINUE;\n+    };\n+    apply_to_projs(callback_always_continue, which_proj);\n+  }\n+\n+  template <class Callback> void for_each_proj(Callback callback, uint which_proj, bool is_io_use) const {\n+    auto callback_always_continue = [&](ProjNode* proj) {\n+      callback(proj);\n+      return MultiNode::CONTINUE;\n+    };\n+    apply_to_projs(callback_always_continue, which_proj, is_io_use);\n+  }\n+\n+  ProjNode* find_first(uint which_proj) const;\n+  ProjNode* find_first(uint which_proj, bool is_io_use) const;\n@@ -109,0 +218,38 @@\n+\/\/ A ProjNode variant that captures an adr_type(). Used as a projection of InitializeNode to have the right adr_type()\n+\/\/ for array elements\/fields.\n+class NarrowMemProjNode : public ProjNode {\n+private:\n+  const TypePtr* const _adr_type;\n+protected:\n+  virtual uint hash() const {\n+    return ProjNode::hash() + _adr_type->hash();\n+  }\n+  virtual bool cmp(const Node& n) const {\n+    return ProjNode::cmp(n) && ((NarrowMemProjNode&)n)._adr_type == _adr_type;\n+  }\n+  virtual uint size_of() const {\n+    return sizeof(*this);\n+  }\n+public:\n+  NarrowMemProjNode(Node* src, const TypePtr* adr_type)\n+    : ProjNode(src, TypeFunc::Memory), _adr_type(adr_type) {\n+    init_class_id(Class_NarrowMemProj);\n+  }\n+\n+  virtual const TypePtr* adr_type() const {\n+    return _adr_type;\n+  }\n+\n+  virtual int Opcode() const;\n+};\n+\n+template <class Callback> ProjNode* MultiNode::apply_to_projs(DUIterator_Fast& imax, DUIterator_Fast& i, Callback callback, uint which_proj) const {\n+  auto filter = [&](ProjNode* proj) {\n+    if (proj->_con == which_proj && callback(proj) == BREAK_AND_RETURN_CURRENT_PROJ) {\n+      return BREAK_AND_RETURN_CURRENT_PROJ;\n+    }\n+    return CONTINUE;\n+  };\n+  return apply_to_projs(imax, i, filter);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/multnode.hpp","additions":147,"deletions":0,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -2605,1 +2605,1 @@\n-    MemNode::dump_adr_type(this, adr_type(), st);\n+    MemNode::dump_adr_type(adr_type(), st);\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+class NarrowMemProjNode;\n@@ -767,0 +768,1 @@\n+      DEFINE_CLASS_ID(NarrowMemProj, Proj, 6)\n@@ -985,0 +987,1 @@\n+  DEFINE_CLASS_QUERY(NarrowMemProj)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2595,0 +2595,3 @@\n+  auto enqueue_init_mem_projs = [&](ProjNode* proj) {\n+    add_users_to_worklist0(proj, worklist);\n+  };\n@@ -2599,2 +2602,1 @@\n-      Node* imem = init->proj_out_or_null(TypeFunc::Memory);\n-      if (imem != nullptr) add_users_to_worklist0(imem, worklist);\n+      init->for_each_proj(enqueue_init_mem_projs, TypeFunc::Memory);\n@@ -2614,2 +2616,2 @@\n-    Node* imem = use->as_Initialize()->proj_out_or_null(TypeFunc::Memory);\n-    if (imem != nullptr) add_users_to_worklist0(imem, worklist);\n+    InitializeNode* init = use->as_Initialize();\n+    init->for_each_proj(enqueue_init_mem_projs, TypeFunc::Memory);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -383,1 +383,0 @@\n-  assert(init->outcnt() <= 2, \"only a control and memory projection expected\");\n@@ -389,5 +388,2 @@\n-  Node *mem_proj = init->proj_out_or_null(TypeFunc::Memory);\n-  if (mem_proj != nullptr) {\n-    Node *mem = init->in(TypeFunc::Memory);\n-    C->gvn_replace_by(mem_proj, mem);\n-  }\n+  Node* mem = init->in(TypeFunc::Memory);\n+  init->replace_mem_projs_by(mem, C);\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -678,1 +678,3 @@\n-        return hasName(n, \"Proj\") || hasName(n, \"MachProj\");\n+        return hasName(n, \"Proj\") ||\n+               hasName(n, \"MachProj\") ||\n+               hasName(n, \"NarrowMemProj\");\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/java\/com\/sun\/hotspot\/igv\/servercompiler\/ServerCompilerScheduler.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+combine(anyNode, matches(\"name\", \"NarrowMemProj\"), [\"N\"]);\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/condenseGraph.filter","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,3 +51,7 @@\n-    analyzer.shouldContain(\"++++ Eliminated: 26 Allocate\");\n-    analyzer.shouldContain(\"++++ Eliminated: 48 Allocate\");\n-    analyzer.shouldContain(\"++++ Eliminated: 78 Allocate\");\n+    analyzer.shouldMatch(\n+            \"(?s)\" + \/\/ Let .* also match line terminators.\n+            \"Eliminated: \\\\d+ Allocate\" +\n+            \".*\" +\n+            \"Eliminated: \\\\d+ Allocate\" +\n+            \".*\" +\n+            \"Eliminated: \\\\d+ Allocate\");\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestIterativeEA.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327963\n+ * @summary C2: fix construction of memory graph around Initialize node to prevent incorrect execution if allocation is removed\n+ * @run main\/othervm -XX:-BackgroundCompilation compiler.macronodes.TestEarlyEliminationOfAllocationWithoutUse\n+ * @run main\/othervm compiler.macronodes.TestEarlyEliminationOfAllocationWithoutUse\n+ *\/\n+\n+package compiler.macronodes;\n+import java.util.Arrays;\n+\n+public class TestEarlyEliminationOfAllocationWithoutUse {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        boolean[] allTrue = new boolean[3];\n+        Arrays.fill(allTrue, true);\n+        A a = new A();\n+        boolean[] allFalse = new boolean[3];\n+        for (int i = 0; i < 20_000; i++) {\n+            a.field1 = 0;\n+            test1(a, allTrue);\n+            test1(a, allFalse);\n+            if (a.field1 != 42) {\n+                throw new RuntimeException(\"Lost Store\");\n+            }\n+        }\n+    }\n+\n+    private static void test1(A otherA, boolean[] flags) {\n+        otherA.field1 = 42;\n+        \/\/ Fully unrolled before EA\n+        for (int i = 0; i < 3; i++) {\n+            A a = new A(); \/\/ removed right after EA\n+            if (flags[i]) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private static class A {\n+        int field1;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/macronodes\/TestEarlyEliminationOfAllocationWithoutUse.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,338 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327012 8327963\n+ * @summary Revealed issue where hook_memory_on_init links some array slice to the rawptr slice.\n+ *          Now that array slice depends on the rawslice. And then when the Initialize MemBar gets\n+ *          removed in expand_allocate_common, the rawslice sees that it has now no effect, looks\n+ *          through the MergeMem and sees the initial state. That way, also the linked array slice\n+ *          goes to the initial state, even if before the allocation there were stores on the array\n+ *          slice. This leads to a messed up memory graph, and missing stores in the generated code.\n+ *\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,compiler.macronodes.TestEliminationOfAllocationWithoutUse::test*\n+ *                   compiler.macronodes.TestEliminationOfAllocationWithoutUse\n+ * @run main\/othervm -Xcomp\n+ *                   -XX:CompileCommand=compileonly,compiler.macronodes.TestEliminationOfAllocationWithoutUse::test*\n+ *                   compiler.macronodes.TestEliminationOfAllocationWithoutUse\n+ *\/\n+\n+package compiler.macronodes;\n+\n+public class TestEliminationOfAllocationWithoutUse {\n+\n+    static public void main(String[] args) {\n+        int failures = 0;\n+        failures += run1();\n+        failures += run2();\n+        failures += run3();\n+        failures += run4();\n+        failures += run5();\n+        failures += run6();\n+        failures += run7();\n+        failures += run8();\n+        failures += run9();\n+        if (failures != 0) {\n+            throw new RuntimeException(\"Had test failures: \" + failures);\n+        }\n+    }\n+\n+    static public int run1() {\n+        int size = 10;\n+        double[] arr1 = new double[size];\n+        double[] arr2 = new double[size];\n+        test1(arr1, arr2);\n+\n+        double sum = 0;\n+        for (int i = 0; i < arr1.length; ++i) {\n+            sum += arr1[i] - arr2[i];\n+        }\n+\n+        if (sum != (double)(size)) {\n+            System.out.println(\"test1: wrong result: \" + sum + \" vs expected: \" + size);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ Simplified from JDK-8327012 regression test.\n+    public static void test1(double[] arr1, double[] arr2) {\n+        for(int i = 0; i < arr1.length; ++i) {\n+            \/\/ stores on double[] slice\n+            arr1[i] = (double)(i + 2);\n+            arr2[i] = (double)(i + 1);\n+            \/\/ Allocation without use: but Initialize MemBar tangles the rawptr and double[] slices\n+            double[] tmp = new double[100];\n+            \/\/ When the Initialize MemBar is removed, the rawptr slice sees that there is no effect\n+            \/\/ and takes the initial state. The double[] slice is hooked on to the rawptr slice, and\n+            \/\/ also thinks it has the initial state, ignoring the double[] stores above.\n+        }\n+    }\n+\n+    static public int run2() {\n+        int size = 10;\n+        double[] arr1 = new double[size];\n+        test2(arr1);\n+\n+        double sum = 0;\n+        for(int i = 0; i < arr1.length; ++i) {\n+            sum += arr1[i];\n+        }\n+\n+        if (sum != (double)(size)) {\n+            System.out.println(\"test2: wrong result: \" + sum + \" vs expected: \" + size);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ Simplified from test1\n+    public static void test2(double[] arr1) {\n+        for(int i = 0; i < arr1.length; ++i) {\n+            arr1[i] = 1;\n+            double[] tmp = new double[100];\n+        }\n+    }\n+\n+    static public int run3() {\n+        int size = 10;\n+        int[] arr1 = new int[size];\n+        test3(arr1);\n+\n+        int sum = 0;\n+        for(int i = 0; i < arr1.length; ++i) {\n+            sum += arr1[i];\n+        }\n+\n+        if (sum != size) {\n+            System.out.println(\"test3: wrong result: \" + sum + \" vs expected: \" + size);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ Modified from test2\n+    public static void test3(int[] arr1) {\n+        for(int i = 0; i < arr1.length; ++i) {\n+            arr1[i] = 1;\n+            int[] tmp = new int[100];\n+        }\n+    }\n+\n+    \/\/ From TestIncorrectResult.java in JDK-8324739\n+    static int test4(int l2) {\n+       int[] tmp = new int[20];\n+\n+       for (int j = 0; j < l2; ++j) {\n+           tmp[j] = 42;\n+           int[] unused_but_necessary = new int[400];\n+       }\n+\n+       return tmp[0];\n+    }\n+\n+    public static int run4() {\n+        for (int i = 0; i < 100; ++i) {\n+            long res = test4(20);\n+\n+            if (res != 42) {\n+                System.out.println(\"test4: wrong result: \" + res + \" vs expected: 42\");\n+                return 1;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ From JDK-8336701\n+    static class Test5 {\n+        int[] b = new int[400];\n+        static int[] staticArray = new int[400];\n+    }\n+\n+    static void test5() {\n+        long e;\n+        for (e = 1; e < 9; ++e) {\n+            Test5.staticArray[(int) e] -= e;\n+            synchronized (new Test5()) { }\n+        }\n+        for (int f = 0; f < 10000; ++f) ;\n+    }\n+\n+    static int run5() {\n+        new Test5();\n+        for (int i = 0; i < 1000; ++i) {\n+            test5();\n+        }\n+        if (Test5.staticArray[8] != -8000) {\n+            System.out.println(\"test5: wrong result: \" + Test5.staticArray[8] + \" vs expected: -8000\");\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ From JDK-8336293\n+    static class Test6 {\n+        static long c;\n+        static int a = 400;\n+        double[] b = new double[400];\n+    }\n+\n+    static void test6() {\n+        long d;\n+        double[] e = new double[Test6.a];\n+        for (int f = 0; f < e.length; f++)\n+            e[f] = 1.116242;\n+        d = 1;\n+        while (++d < 7)\n+            synchronized (new Test6()) { }\n+        long g = 0;\n+        for (int f = 0; f < e.length; f++)\n+            g += e[f];\n+        Test6.c += g;\n+    }\n+\n+    static int run6() {\n+        new Test6();\n+        for (int f = 0; f < 10000; ++f) {\n+            test6();\n+        }\n+        if (Test6.c != 4000000) {\n+            System.out.println(\"test6: wrong result: \" + Test6.c + \" vs expected: 4000000 \");\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ From JDK-8327868\n+    static class Test7 {\n+        static int a = 400;\n+        int[] b = new int[400];\n+        static int[] staticArray = new int[a];\n+    }\n+\n+    static int test7() {\n+        int l, d = 3;\n+        for (l = 2; 58 > l; l++) {\n+            for (int e = 2; e < 8; e += 2)\n+                for (int f = 1; f < e; f += 2)\n+                    synchronized (new Test7()) {\n+                    }\n+            do\n+                ; while (d < 2);\n+            int g = 0;\n+            do\n+                g++;\n+            while (g < 20000);\n+            Test7.staticArray[1] -= 3023399;\n+        }\n+        int h = 0;\n+        for (int i = 0; i < Test7.staticArray.length; i++)\n+            h += Test7.staticArray[i];\n+        return h;\n+    }\n+\n+    static int run7() {\n+        new Test7();\n+        int res = test7();\n+        if (res != -169310344) {\n+            System.out.println(\"test7: wrong result: \" + res + \" vs expected: -169310344\");\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ from JDK-8329984\n+    static class Test8 {\n+        static int a = 400;\n+        int[] e = new int[400];\n+    }\n+\n+    static int test8() {\n+        int i = 22738;\n+        int b;\n+        int h;\n+        int[] c = new int[Test8.a];\n+        for (b = 3; b < 273; b++) {\n+            h = 1;\n+            while (++h < 97) switch (b % 6 + 56) {\n+                case 56:\n+                    c[1] = i;\n+                case 57:\n+                    synchronized (new Test8()) {}\n+            }\n+        }\n+        int k = 0;\n+        for (int j = 0; j < c.length; j++) k += c[j];\n+        return k;\n+    }\n+\n+    public static int run8() {\n+        new Test8();\n+        for (int i = 0; i < 20; i++) {\n+            int res = test8();\n+            if (res != 22738) {\n+                System.out.println(\"test8: wrong result: \" + res + \" vs expected: 22738\");\n+                return 1;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ from JDK-8341009\n+   static class Test9 {\n+        static int a = 256;\n+        float[] b = new float[256];\n+        static long c;\n+    }\n+\n+  static void test9() {\n+    for (int f = 0; f < 10000; ++f) ;\n+    float[][] g = new float[Test9.a][Test9.a];\n+    for (int d = 7; d < 16; d++) {\n+      long e = 1;\n+      do {\n+        g[d][(int) e] = d;\n+        synchronized (new Test9()) {\n+        }\n+      } while (++e < 5);\n+    }\n+    for (int i = 0; i < Test9.a; ++i) {\n+      for (int j = 0; j < Test9.a ; ++j) {\n+          Test9.c += g[i][j];\n+      }\n+    }\n+  }\n+\n+  static int run9() {\n+    for (int j = 6; 116 > j; ++j) {\n+        test9();\n+    }\n+    if (Test9.c != 43560) {\n+        System.out.println(\"test9: wrong result: \" + Test9.c + \" vs expected: 43560\");\n+        return 1;\n+    }\n+    return 0;\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/macronodes\/TestEliminationOfAllocationWithoutUse.java","additions":338,"deletions":0,"binary":false,"changes":338,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327012 8327963\n+ * @summary Test that initializing store gets captured, i.e. moved before the InitializeNode\n+ *          and made into a raw-store.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.macronodes.TestInitializingStoreCapturing\n+ *\/\n+\n+package compiler.macronodes;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestInitializingStoreCapturing {\n+\n+    static class A {\n+        float value;\n+        A(float v) { value = v; }\n+    };\n+\n+    static public void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_F, \"= 0\"})\n+    static A testInitializeField() {\n+        return new A(4.2f);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_F, \"= 0\"})\n+    static float[] testInitializeArray() {\n+        return new float[] {4.2f};\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/macronodes\/TestInitializingStoreCapturing.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"}]}