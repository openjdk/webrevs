{"files":[{"patch":"@@ -4123,16 +4123,0 @@\n-    if (!is_instance && result->Opcode() == Op_NarrowMemProj) {\n-      \/\/ Memory for non known instance can safely skip over a known instance allocation (that memory state doesn't access\n-      \/\/ the result of an allocation for a known instance).\n-      assert(result->as_Proj()->_con == TypeFunc::Memory, \"a NarrowMemProj can only be a memory projection\");\n-      assert(toop != nullptr, \"\");\n-      Node* proj_in = result->in(0);\n-      if (proj_in->is_Initialize()) {\n-        AllocateNode* alloc = proj_in->as_Initialize()->allocation();\n-        assert(alloc->result_cast() == nullptr ||\n-               ((alloc->_is_scalar_replaceable) == igvn->type(alloc->result_cast())->is_oopptr()->is_known_instance()),\n-               \"only scalar replaceable allocations are known instance\");\n-        if (alloc != nullptr && alloc->_is_scalar_replaceable) {\n-          result = alloc->in(TypeFunc::Memory);\n-        }\n-      }\n-    }\n@@ -4159,0 +4143,5 @@\n+        } else if (C->get_alias_index(result->adr_type()) != alias_idx) {\n+          assert(C->get_general_index(alias_idx) == C->get_alias_index(result->adr_type()), \"should be projection for the same field\/array element\");\n+          result = get_map(result->_idx);\n+          assert(result != nullptr, \"new projection should have been allocated\");\n+          break;\n@@ -4455,1 +4444,1 @@\n-        \/\/ Update adr type captured by NarrowMem projections to new type\n+        \/\/ Add a new NarrowMem projection for each existing NarrowMem projection with new adr type\n@@ -4458,13 +4447,12 @@\n-        for (DUIterator_Fast imax, i = init->fast_outs(imax); i < imax; i++) {\n-          ProjNode* proj = init->fast_out(i)->as_Proj();\n-          if (proj->Opcode() == Op_NarrowMemProj) {\n-            const TypePtr* adr_type = proj->adr_type();\n-            const TypePtr* new_adr_type = tinst->add_offset(adr_type->offset());\n-            if (adr_type != new_adr_type) {\n-              DEBUG_ONLY( uint alias_idx = _compile->get_alias_index(new_adr_type); )\n-              assert(_compile->get_general_index(alias_idx) == _compile->get_alias_index(adr_type), \"new adr type should be narrowed down from existing adr type\");\n-              igvn->hash_delete(proj);\n-              ((NarrowMemProjNode*)proj)->set_adr_type(new_adr_type);\n-              igvn->hash_insert(proj);\n-              record_for_optimizer(proj);\n-            }\n+        DUIterator i = init->outs();\n+        auto process_narrow_proj = [tinst, init, this, igvn](NarrowMemProjNode* proj) {\n+          const TypePtr* adr_type = proj->adr_type();\n+          const TypePtr* new_adr_type = tinst->add_offset(adr_type->offset());\n+          bool already_has_narrow_mem_proj_with_adr_type = init->already_has_narrow_mem_proj_with_adr_type(new_adr_type);\n+          if (adr_type != new_adr_type && !already_has_narrow_mem_proj_with_adr_type) {\n+            DEBUG_ONLY( uint alias_idx = _compile->get_alias_index(new_adr_type); )\n+            assert(_compile->get_general_index(alias_idx) == _compile->get_alias_index(adr_type), \"new adr type should be narrowed down from existing adr type\");\n+            NarrowMemProjNode* new_proj = new NarrowMemProjNode(init, new_adr_type);\n+            igvn->set_type(new_proj, new_proj->bottom_type());\n+            record_for_optimizer(new_proj);\n+            set_map(proj, new_proj); \/\/ record it so ConnectionGraph::find_inst_mem() can find it\n@@ -4472,1 +4460,3 @@\n-        }\n+          return false;\n+        };\n+        init->apply_to_narrow_mem_projs(i, process_narrow_proj);\n@@ -4876,19 +4866,0 @@\n-      if (mem->Opcode() == Op_NarrowMemProj) {\n-        const TypePtr* at = mem->adr_type();\n-        uint alias_idx = (uint) _compile->get_alias_index(at->is_ptr());\n-        if (idx == i) {\n-          \/\/ projection for a non known allocation on a non known allocation slice: can't skip over the allocation\n-          if (cur == nullptr) {\n-            cur = mem;\n-          }\n-        } else {\n-          \/\/ projection for a known allocation on a non known allocation slice: skip over the allocation\n-          if (idx >= nmm->req() || nmm->is_empty_memory(nmm->in(idx))) {\n-            nmm->set_memory_at(idx, mem);\n-          }\n-          InitializeNode* init = mem->in(0)->as_Initialize();\n-          AllocateNode* alloc = init->allocation();\n-          assert(alloc != nullptr, \"can find Allocate node from the Initialize node\");\n-          mem = alloc->in(TypeFunc::Memory);\n-        }\n-      }\n@@ -4896,1 +4867,0 @@\n-      record_for_optimizer(nmm);\n@@ -5000,1 +4970,1 @@\n-             n->is_AddP() || n->is_Phi(), \"unknown node used for set_map()\");\n+             n->is_AddP() || n->is_Phi() || n->is_NarrowMemProj(), \"unknown node used for set_map()\");\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":22,"deletions":52,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -566,1 +566,1 @@\n-                        \/\/ ChecCastPP    - allocation that this is a cast of\n+                        \/\/ CheckCastPP   - allocation that this is a cast of\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3637,1 +3637,1 @@\n-    set_memory(_gvn.transform(new NarrowMemProjNode(init, TypeFunc::Memory, C->get_adr_type(mark_idx))), mark_idx);\n+    set_memory(_gvn.transform(new NarrowMemProjNode(init, C->get_adr_type(mark_idx))), mark_idx);\n@@ -3639,1 +3639,1 @@\n-    set_memory(_gvn.transform(new NarrowMemProjNode(init, TypeFunc::Memory, C->get_adr_type(klass_idx))), klass_idx);\n+    set_memory(_gvn.transform(new NarrowMemProjNode(init, C->get_adr_type(klass_idx))), klass_idx);\n@@ -3643,1 +3643,1 @@\n-      hook_memory_on_init(*this, elemidx, minit_in, _gvn.transform(new NarrowMemProjNode(init, TypeFunc::Memory, C->get_adr_type(elemidx))));\n+      hook_memory_on_init(*this, elemidx, minit_in, _gvn.transform(new NarrowMemProjNode(init, C->get_adr_type(elemidx))));\n@@ -3652,1 +3652,1 @@\n-        hook_memory_on_init(*this, fieldidx, minit_in, _gvn.transform(new NarrowMemProjNode(init, TypeFunc::Memory, C->get_adr_type(fieldidx))));\n+        hook_memory_on_init(*this, fieldidx, minit_in, _gvn.transform(new NarrowMemProjNode(init, C->get_adr_type(fieldidx))));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -5550,8 +5550,7 @@\n-    for (DUIterator_Fast imax, i = init->fast_outs(imax); i < imax; i++) {\n-      ProjNode* proj = init->fast_out(i)->as_Proj();\n-      if (proj->_con == TypeFunc::Memory) {\n-        int alias_idx = C->get_alias_index(proj->adr_type());\n-        assert(alias_idx == Compile::AliasIdxRaw || alias_idx == elemidx || alias_idx == mark_idx || alias_idx == klass_idx, \"should be raw memory or array element type\");\n-        set_memory(proj, alias_idx);\n-      }\n-    }\n+    auto move_proj = [=](ProjNode* proj) {\n+      int alias_idx = C->get_alias_index(proj->adr_type());\n+      assert(alias_idx == Compile::AliasIdxRaw || alias_idx == elemidx || alias_idx == mark_idx || alias_idx == klass_idx, \"should be raw memory or array element type\");\n+      set_memory(proj, alias_idx);\n+      return false;\n+    };\n+    init->apply_to_projs(move_proj, TypeFunc::Memory);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3900,1 +3900,3 @@\n-  call->init_req(TypeFunc::FramePtr,  C->start()->proj_out_or_null(TypeFunc::FramePtr));\n+  Node* frame = new ParmNode(C->start(), TypeFunc::FramePtr);\n+  _igvn.register_new_node_with_optimizer(frame);\n+  call->init_req(TypeFunc::FramePtr,  frame);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2680,2 +2680,3 @@\n-          Node* cle_out = cle->proj_out_or_null(false);\n-          if (use == cle_out) {\n+          \/\/ is use the projection that exits the loop from the CountedLoopEndNode?\n+          if (use->in(0) == cle) {\n+            IfFalseNode* cle_out = use->as_IfFalse();\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1021,2 +1021,1 @@\n-        Node* mem_proj = init->proj_out_or_null(TypeFunc::Memory);\n-        if (mem_proj != nullptr) {\n+        if (init->number_of_projs(TypeFunc::Memory) > 0) {\n@@ -1618,1 +1617,1 @@\n-      MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);\n+      MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxRaw);\n@@ -1634,1 +1633,0 @@\n-      Node* init_mem = init->proj_out_or_null(TypeFunc::Memory);\n@@ -1636,1 +1634,8 @@\n-      MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);\n+      \/\/ What we want is to prevent the compiler and the cpu from re-ordering the stores that initialize this object\n+      \/\/ with subsequent stores to any slice. As a consequence, this MemBar should capture the entire memory state at\n+      \/\/ this point in the IR and produce a new memory state that should cover all slices. However, the Initialize node\n+      \/\/ only captures\/produces a partial memory state making it complicated to insert such a MemBar. Because\n+      \/\/ re-ordering by the compiler can't happen by construction (a later Store that publishes the just allocated\n+      \/\/ object reference is indirectly control dependent on the Initialize node), preventing reordering by the cpu is\n+      \/\/ sufficient. For that a MemBar on the raw memory slice is good enough.\n+      MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxRaw);\n@@ -1641,2 +1646,12 @@\n-      Node* mem = new ProjNode(init, TypeFunc::Memory);\n-      transform_later(mem);\n+      Node* existing_raw_mem_proj = nullptr;\n+      auto find_raw_mem = [&, this](ProjNode* proj) {\n+        if (C->get_alias_index(proj->adr_type()) == Compile::AliasIdxRaw) {\n+          assert(existing_raw_mem_proj == nullptr, \"only one expected\");\n+          existing_raw_mem_proj = proj;\n+        }\n+        return false;\n+      };\n+      init->apply_to_projs(find_raw_mem, TypeFunc::Memory);\n+      Node* raw_mem_proj = new ProjNode(init, TypeFunc::Memory);\n+      transform_later(raw_mem_proj);\n+      assert(existing_raw_mem_proj != nullptr, \"\");\n@@ -1646,1 +1661,1 @@\n-      mb->init_req(TypeFunc::Memory, mem);\n+      mb->init_req(TypeFunc::Memory, raw_mem_proj);\n@@ -1651,1 +1666,1 @@\n-      mem = new ProjNode(mb, TypeFunc::Memory);\n+      Node* mem = new ProjNode(mb, TypeFunc::Memory);\n@@ -1660,3 +1675,1 @@\n-      if (init_mem != nullptr) {\n-        _igvn.replace_node(init_mem, mem);\n-      }\n+      _igvn.replace_node(existing_raw_mem_proj, mem);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":25,"deletions":12,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -5455,6 +5455,5 @@\n-  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n-    ProjNode* proj = fast_out(i)->as_Proj();\n-    if (proj->_con == TypeFunc::Memory) {\n-      C->gvn_replace_by(proj, mem);\n-    }\n-  }\n+  auto replace_proj = [C, mem](ProjNode* proj) {\n+    C->gvn_replace_by(proj, mem);\n+    return false;\n+  };\n+  apply_to_projs(replace_proj, TypeFunc::Memory);\n@@ -5464,5 +5463,19 @@\n-  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n-    ProjNode* proj = fast_out(i)->as_Proj();\n-    if (proj->_con == TypeFunc::Memory) {\n-      igvn->replace_node(proj, mem);\n-      --i; --imax;\n+  DUIterator_Fast imax, i = fast_outs(imax);\n+  auto replace_proj = [mem, igvn, &i, &imax](ProjNode* proj) {\n+    igvn->replace_node(proj, mem);\n+    --i; --imax;\n+    return false;\n+  };\n+  apply_to_projs(imax, i, replace_proj, TypeFunc::Memory);\n+}\n+\n+template <class Callback> ProjNode* InitializeNode::apply_to_narrow_mem_projs(Callback callback) const {\n+  DUIterator_Fast imax, i = fast_outs(imax);\n+  return apply_to_narrow_mem_projs_any_iterator(UsesIteratorFast(imax, i, this), callback);\n+}\n+\n+\n+template<class Callback> ProjNode* InitializeNode::apply_to_narrow_mem_projs(Callback callback, const TypePtr* adr_type) const {\n+  auto filter = [callback, adr_type](NarrowMemProjNode* proj) {\n+    if (proj->adr_type() == adr_type && callback(proj->as_NarrowMemProj())) {\n+      return true;\n@@ -5470,1 +5483,10 @@\n-  }\n+    return false;\n+  };\n+  return apply_to_narrow_mem_projs(filter);\n+}\n+\n+bool InitializeNode::already_has_narrow_mem_proj_with_adr_type(const TypePtr* adr_type) const {\n+  auto find_proj = [](ProjNode* proj) {\n+    return true;\n+  };\n+  return apply_to_narrow_mem_projs(find_proj, adr_type) != nullptr;\n@@ -5894,1 +5916,1 @@\n-           || n->Opcode() == Op_NarrowMemProj\n+           || n->is_NarrowMemProj()\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":35,"deletions":13,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1365,1 +1365,2 @@\n-  \/\/ An Initialize node has multiple memory projection. Helper methods used when the node is removed.\n+  \/\/ An Initialize node has multiple memory projections. Helper methods used when the node is removed.\n+  \/\/ For use at parse time\n@@ -1367,1 +1368,9 @@\n-  void replace_mem_projs_by(Node* mem, PhaseIterGVN* ivn);\n+  \/\/ For use with IGVN\n+  void replace_mem_projs_by(Node* mem, PhaseIterGVN* igvn);\n+\n+  \/\/ Does a NarrowMemProj with this adr_type and this node as input already exist?\n+  bool already_has_narrow_mem_proj_with_adr_type(const TypePtr* adr_type) const;\n+  \/\/ Run callback on all NarrowMem proj uses using passed iterator\n+  template <class Callback> ProjNode* apply_to_narrow_mem_projs(DUIterator& i, Callback callback) const {\n+    return apply_to_narrow_mem_projs_any_iterator<Callback, UsesIterator>(UsesIterator(i, this), callback);\n+  }\n@@ -1369,1 +1378,1 @@\n- private:\n+private:\n@@ -1386,0 +1395,16 @@\n+\n+  \/\/ Iterate with i over all NarrowMemProj uses calling callback\n+  template <class Callback, class Iterator> ProjNode* apply_to_narrow_mem_projs_any_iterator(Iterator i, Callback callback) const {\n+    auto filter = [callback](ProjNode* proj) {\n+      if (proj->is_NarrowMemProj() && callback(proj->as_NarrowMemProj())) {\n+        return true;\n+      }\n+      return false;\n+    };\n+    return apply_to_projs_any_iterator(i, filter);\n+  }\n+\n+  \/\/ Same but with default iterator\n+  template <class Callback> ProjNode* apply_to_narrow_mem_projs(Callback callback) const;\n+  \/\/ Same but only for NarrowMem proj whose adr_type matches\n+  template <class Callback> ProjNode* apply_to_narrow_mem_projs(Callback callback, const TypePtr* adr_type) const;\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -48,14 +48,7 @@\n-  for( DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++ ) {\n-    Node *p = fast_out(i);\n-    if (p->is_Proj()) {\n-      ProjNode *proj = p->as_Proj();\n-      if (proj->_con == which_proj) {\n-        assert((Opcode() != Op_If && Opcode() != Op_RangeCheck) || proj->Opcode() == (which_proj ? Op_IfTrue : Op_IfFalse), \"bad if #2\");\n-        return proj;\n-      }\n-    } else {\n-      assert(p == this && this->is_Start(), \"else must be proj\");\n-      continue;\n-    }\n-  }\n-  return nullptr;\n+  assert(number_of_projs(which_proj) <= 1, \"only when there's a single projection\");\n+  auto find_proj = [which_proj, this](ProjNode* proj) {\n+    assert((Opcode() != Op_If && Opcode() != Op_RangeCheck) || proj->Opcode() == (which_proj ? Op_IfTrue : Op_IfFalse),\n+           \"bad if #2\");\n+    return true;\n+  };\n+  return apply_to_projs(find_proj, which_proj);\n@@ -65,4 +58,11 @@\n-  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n-    ProjNode* proj = fast_out(i)->isa_Proj();\n-    if (proj != nullptr && (proj->_con == which_proj) && (proj->_is_io_use == is_io_use)) {\n-      return proj;\n+  assert(number_of_projs(which_proj, is_io_use) <= 1, \"only when there's a single projection\");\n+  auto find_proj = [](ProjNode* proj) {\n+    return true;\n+  };\n+  return apply_to_projs(find_proj, which_proj, is_io_use);\n+}\n+\n+template<class Callback> ProjNode* MultiNode::apply_to_projs(Callback callback, uint which_proj, bool is_io_use) const {\n+  auto filter = [is_io_use,callback](ProjNode* proj) {\n+    if (proj->_is_io_use == is_io_use && callback(proj)) {\n+      return true;\n@@ -70,2 +70,23 @@\n-  }\n-  return nullptr;\n+    return false;\n+  };\n+  return apply_to_projs(filter, which_proj);\n+}\n+\n+uint MultiNode::number_of_projs(uint which_proj) const {\n+  uint cnt = 0;\n+  auto count_projs = [&cnt](ProjNode* proj) {\n+    cnt++;\n+    return false;\n+  };\n+  apply_to_projs(count_projs, which_proj);\n+  return cnt;\n+}\n+\n+uint MultiNode::number_of_projs(uint which_proj, bool is_io_use) const {\n+  uint cnt = 0;\n+  auto count_projs = [&cnt](ProjNode* proj) {\n+    cnt++;\n+    return false;\n+  };\n+  apply_to_projs(count_projs, which_proj, is_io_use);\n+  return cnt;\n@@ -229,0 +250,24 @@\n+\n+#ifndef PRODUCT\n+void NarrowMemProjNode::dump_adr_type(outputStream* st) const {\n+  st->print(\" @\"); _adr_type->dump_on(st);\n+  Compile* C = Compile::current();\n+  Compile::AliasType* atp = C->alias_type(_adr_type);\n+  ciField* field = atp->field();\n+  if (field) {\n+    st->print(\", name=\");\n+    field->print_name_on(st);\n+  }\n+  st->print(\", idx=%d;\", atp->index());\n+}\n+\n+void NarrowMemProjNode::dump_spec(outputStream *st) const {\n+  ProjNode::dump_spec(st);\n+  dump_adr_type(st);\n+}\n+\n+void NarrowMemProjNode::dump_compact_spec(outputStream *st) const {\n+  ProjNode::dump_compact_spec(st);\n+  dump_adr_type(st);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/multnode.cpp","additions":65,"deletions":20,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -52,0 +52,83 @@\n+  uint number_of_projs(uint which_proj) const;\n+  uint number_of_projs(uint which_proj, bool is_io_use) const;\n+\n+  \/\/ Run callback on all Proj projection from this node\n+  template<class Callback> ProjNode* apply_to_projs(Callback callback) const {\n+    DUIterator_Fast imax, i = fast_outs(imax);\n+    return apply_to_projs(imax, i, callback);\n+  }\n+\n+  \/\/ Same but with provided iterators\n+  template<class Callback> ProjNode* apply_to_projs(DUIterator_Fast& imax, DUIterator_Fast& i, Callback callback) const {\n+    return apply_to_projs_any_iterator<Callback, UsesIteratorFast>(UsesIteratorFast(imax, i, this), callback);\n+  }\n+\n+  \/\/ Same but only for Proj node whose _con matches which_proj\n+  template <class Callback> ProjNode* apply_to_projs(DUIterator_Fast& imax, DUIterator_Fast& i, Callback callback, uint which_proj) const;\n+\n+  \/\/ Same but with default iterators\n+  template<class Callback> ProjNode* apply_to_projs(Callback callback, uint which_proj) const {\n+    DUIterator_Fast imax, i = fast_outs(imax);\n+    return apply_to_projs(imax, i, callback, which_proj);\n+  }\n+\n+  \/\/ Same but for matching _con and _is_io_use\n+  template <class Callback> ProjNode* apply_to_projs(Callback callback, uint which_proj, bool is_io_use) const;\n+\n+protected:\n+\n+  \/\/ Provide single interface for DUIterator_Fast\/DUIterator for template method below\n+  class UsesIteratorFast {\n+    DUIterator_Fast& _imax;\n+    DUIterator_Fast& _i;\n+    const Node* _node;\n+\n+  public:\n+    bool cont() {\n+      return _i < _imax;\n+    }\n+    void next() {\n+      _i++;\n+    }\n+    Node* current() {\n+      return _node->fast_out(_i);;\n+    }\n+    UsesIteratorFast(DUIterator_Fast& imax, DUIterator_Fast& i, const Node* node)\n+      : _imax(imax), _i(i), _node(node) {\n+    }\n+  };\n+\n+  class UsesIterator {\n+    DUIterator& _i;\n+    const Node* _node;\n+\n+  public:\n+    bool cont() {\n+      return _node->has_out(_i);\n+    }\n+    void next() {\n+      _i++;\n+    }\n+    Node* current() {\n+      return _node->out(_i);;\n+    }\n+    UsesIterator(DUIterator& i, const Node* node)\n+      : _i(i), _node(node) {\n+    }\n+  };\n+\n+  \/\/ Iterate with i over all Proj uses calling callback\n+  template<class Callback, class Iterator> ProjNode* apply_to_projs_any_iterator(Iterator i, Callback callback) const {\n+    for (; i.cont(); i.next()) {\n+      Node* p = i.current();\n+      if (p->is_Proj()) {\n+        ProjNode* proj = p->as_Proj();\n+        if (callback(proj)) {\n+          return proj;\n+        }\n+      } else {\n+        assert(p == this && is_Start(), \"else must be proj\");\n+      }\n+    }\n+    return nullptr;\n+  }\n@@ -112,1 +195,1 @@\n-  const TypePtr* _adr_type;\n+  const TypePtr* const _adr_type;\n@@ -124,2 +207,3 @@\n-  NarrowMemProjNode(Node* src, uint con, const TypePtr* adr_type)\n-    : ProjNode(src, con), _adr_type(adr_type) {\n+  NarrowMemProjNode(Node* src, const TypePtr* adr_type)\n+    : ProjNode(src, TypeFunc::Memory), _adr_type(adr_type) {\n+    init_class_id(Class_NarrowMemProj);\n@@ -131,3 +215,1 @@\n-  void set_adr_type(const TypePtr* adr_type) {\n-    _adr_type = adr_type;\n-  }\n+\n@@ -135,0 +217,6 @@\n+\n+#ifndef PRODUCT\n+  void dump_adr_type(outputStream* st) const;\n+  virtual void dump_spec(outputStream *st) const;\n+  virtual void dump_compact_spec(outputStream *st) const;\n+#endif\n@@ -137,0 +225,10 @@\n+template <class Callback> ProjNode* MultiNode::apply_to_projs(DUIterator_Fast& imax, DUIterator_Fast& i, Callback callback, uint which_proj) const {\n+  auto filter = [which_proj, callback](ProjNode* proj) {\n+    if (proj->_con == which_proj && callback(proj)) {\n+      return true;\n+    }\n+    return false;\n+  };\n+  return apply_to_projs(imax, i, filter);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/multnode.hpp","additions":104,"deletions":6,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+class NarrowMemProjNode;\n@@ -765,0 +766,1 @@\n+      DEFINE_CLASS_ID(NarrowMemProj, Proj, 6)\n@@ -982,0 +984,1 @@\n+  DEFINE_CLASS_QUERY(NarrowMemProj)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1658,2 +1658,5 @@\n-      Node* imem = init->proj_out_or_null(TypeFunc::Memory);\n-      if (imem != nullptr) add_users_to_worklist0(imem, worklist);\n+      auto enqueue = [&worklist](ProjNode* proj) {\n+        add_users_to_worklist0(proj, worklist);\n+        return false;\n+      };\n+      init->apply_to_projs(enqueue, TypeFunc::Memory);\n@@ -1673,2 +1676,6 @@\n-    Node* imem = use->as_Initialize()->proj_out_or_null(TypeFunc::Memory);\n-    if (imem != nullptr) add_users_to_worklist0(imem, worklist);\n+    InitializeNode* init = use->as_Initialize();\n+    auto enqueue = [&worklist](ProjNode* proj) {\n+      add_users_to_worklist0(proj, worklist);\n+      return false;\n+    };\n+    init->apply_to_projs(enqueue, TypeFunc::Memory);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"}]}