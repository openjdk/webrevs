{"files":[{"patch":"@@ -866,1 +866,1 @@\n-void ConnectionGraph::reduce_phi_on_castpp_field_load(Node* curr_castpp, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist) {\n+void ConnectionGraph::reduce_phi_on_castpp_field_load(Node* curr_castpp, GrowableArray<Node*> &alloc_worklist) {\n@@ -1282,1 +1282,1 @@\n-void ConnectionGraph::reduce_phi(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist) {\n+void ConnectionGraph::reduce_phi(PhiNode* ophi, GrowableArray<Node*> &alloc_worklist) {\n@@ -1310,1 +1310,1 @@\n-    reduce_phi_on_castpp_field_load(castpps.at(i), alloc_worklist, memnode_worklist);\n+    reduce_phi_on_castpp_field_load(castpps.at(i), alloc_worklist);\n@@ -4451,1 +4451,1 @@\n-        auto process_narrow_proj = [tinst, init, this, igvn](NarrowMemProjNode* proj) {\n+        auto process_narrow_proj = [&](NarrowMemProjNode* proj) {\n@@ -4463,1 +4463,1 @@\n-          return false;\n+          return MultiNode::CONTINUE;\n@@ -4537,1 +4537,1 @@\n-        reduce_phi(n->as_Phi(), alloc_worklist, memnode_worklist);\n+        reduce_phi(n->as_Phi(), alloc_worklist);\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -612,1 +612,1 @@\n-  void reduce_phi_on_castpp_field_load(Node* castpp, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist);\n+  void reduce_phi_on_castpp_field_load(Node* castpp, GrowableArray<Node*> &alloc_worklist);\n@@ -616,1 +616,1 @@\n-  void reduce_phi(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist);\n+  void reduce_phi(PhiNode* ophi, GrowableArray<Node*> &alloc_worklist);\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5572,1 +5572,1 @@\n-    auto move_proj = [=](ProjNode* proj) {\n+    auto move_proj = [&](ProjNode* proj) {\n@@ -5579,1 +5579,1 @@\n-      return false;\n+      return MultiNode::CONTINUE;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1030,1 +1030,1 @@\n-        assert(init->outcnt() == 0, \"only a control and some memory projections expected\");\n+        assert(init->outcnt() == 0, \"should only have had a control and some memory projections, and we removed them\");\n@@ -1307,0 +1307,15 @@\n+  InitializeNode* init = alloc->initialization();\n+  if (init != nullptr) {\n+    \/\/ Remove NarrowMemProjs and only keep a single Proj: NarrowMemProjs are only useful as long as the Allocate node\n+    \/\/ exists and can be removed.\n+    \/\/ To make this logic straightforward, create a new Proj. ProjNode constructor needs a proper input.\n+    Node* new_mem_proj = new ProjNode(init, TypeFunc::Memory);\n+    \/\/ clear input so new Proj is not one of the uses of init\n+    new_mem_proj->set_req(0, nullptr);\n+    \/\/ replace uses (the existing Proj and all NarrowMemProj) with the new Proj\n+    init->replace_mem_projs_by(new_mem_proj, &_igvn);\n+    \/\/ make Proj a use of the Initialize node again\n+    new_mem_proj->set_req(0, init);\n+    transform_later(new_mem_proj);\n+  }\n+\n@@ -1647,1 +1662,1 @@\n-      auto find_raw_mem = [&, this](ProjNode* proj) {\n+      auto find_raw_mem = [&](ProjNode* proj) {\n@@ -1652,1 +1667,1 @@\n-        return false;\n+        return MultiNode::CONTINUE;\n@@ -1655,0 +1670,1 @@\n+      assert(existing_raw_mem_proj != nullptr, \"should have found raw mem Proj\");\n@@ -1657,1 +1673,0 @@\n-      assert(existing_raw_mem_proj != nullptr, \"\");\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -5455,1 +5455,1 @@\n-  auto replace_proj = [C, mem](ProjNode* proj) {\n+  auto replace_proj = [&](ProjNode* proj) {\n@@ -5457,1 +5457,1 @@\n-    return false;\n+    return CONTINUE;\n@@ -5464,1 +5464,1 @@\n-  auto replace_proj = [mem, igvn, &i, &imax](ProjNode* proj) {\n+  auto replace_proj = [&](ProjNode* proj) {\n@@ -5467,1 +5467,1 @@\n-    return false;\n+    return CONTINUE;\n@@ -5479,1 +5479,1 @@\n-  auto filter = [callback, adr_type](NarrowMemProjNode* proj) {\n+  auto filter = [&](NarrowMemProjNode* proj) {\n@@ -5481,1 +5481,1 @@\n-      return true;\n+      return BREAK_AND_RETURN_CURRENT_PROJ;\n@@ -5483,1 +5483,1 @@\n-    return false;\n+    return CONTINUE;\n@@ -5490,1 +5490,1 @@\n-    return true;\n+    return BREAK_AND_RETURN_CURRENT_PROJ;\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1407,1 +1407,1 @@\n-    auto filter = [callback](ProjNode* proj) {\n+    auto filter = [&](ProjNode* proj) {\n@@ -1409,1 +1409,1 @@\n-        return true;\n+        return BREAK_AND_RETURN_CURRENT_PROJ;\n@@ -1411,1 +1411,1 @@\n-      return false;\n+      return CONTINUE;\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  auto find_proj = [which_proj, this](ProjNode* proj) {\n+  auto find_proj = [&](ProjNode* proj) {\n@@ -51,2 +51,2 @@\n-           \"bad if #2\");\n-    return true;\n+           \"incorrect projection node at If\/RangeCheck: IfTrue on false path or IfFalse on true path\");\n+    return BREAK_AND_RETURN_CURRENT_PROJ;\n@@ -60,1 +60,1 @@\n-    return true;\n+    return BREAK_AND_RETURN_CURRENT_PROJ;\n@@ -66,1 +66,1 @@\n-  auto filter = [is_io_use,callback](ProjNode* proj) {\n+  auto filter = [&](ProjNode* proj) {\n@@ -68,1 +68,1 @@\n-      return true;\n+      return BREAK_AND_RETURN_CURRENT_PROJ;\n@@ -70,1 +70,1 @@\n-    return false;\n+    return CONTINUE;\n@@ -77,1 +77,1 @@\n-  auto count_projs = [&cnt](ProjNode* proj) {\n+  auto count_projs = [&](ProjNode* proj) {\n@@ -79,1 +79,1 @@\n-    return false;\n+    return CONTINUE;\n@@ -87,1 +87,1 @@\n-  auto count_projs = [&cnt](ProjNode* proj) {\n+  auto count_projs = [&](ProjNode* proj) {\n@@ -89,1 +89,1 @@\n-    return false;\n+    return CONTINUE;\n@@ -257,1 +257,1 @@\n-  if (field) {\n+  if (field != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/multnode.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -55,1 +55,6 @@\n-  \/\/ Run callback on all Proj projection from this node\n+  enum ApplyToProjs {\n+    CONTINUE,\n+    BREAK_AND_RETURN_CURRENT_PROJ\n+  };\n+\n+  \/\/ Run callback on projections from this node as long as callback returns CONTINUE\n@@ -126,1 +131,2 @@\n-        if (callback(proj)) {\n+        ApplyToProjs result = callback(proj);\n+        if (result == BREAK_AND_RETURN_CURRENT_PROJ) {\n@@ -129,0 +135,1 @@\n+        assert(result == CONTINUE, \"should be either break or continue\");\n@@ -226,1 +233,1 @@\n-  auto filter = [which_proj, callback](ProjNode* proj) {\n+  auto filter = [&](ProjNode* proj) {\n@@ -228,1 +235,1 @@\n-      return true;\n+      return BREAK_AND_RETURN_CURRENT_PROJ;\n@@ -230,1 +237,1 @@\n-    return false;\n+    return CONTINUE;\n","filename":"src\/hotspot\/share\/opto\/multnode.hpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1674,1 +1674,1 @@\n-      auto enqueue = [&worklist](ProjNode* proj) {\n+      auto enqueue = [&](ProjNode* proj) {\n@@ -1676,1 +1676,1 @@\n-        return false;\n+        return MultiNode::CONTINUE;\n@@ -1693,1 +1693,1 @@\n-    auto enqueue = [&worklist](ProjNode* proj) {\n+    auto enqueue = [&](ProjNode* proj) {\n@@ -1695,1 +1695,1 @@\n-      return false;\n+      return MultiNode::CONTINUE;\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/macronodes\/TestEliminationOfAllocationWithoutUse.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/macronodes\/TestInitializingStoreCapturing.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}