{"files":[{"patch":"@@ -276,0 +276,1 @@\n+macro(NarrowMemProj)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4150,0 +4150,5 @@\n+        } else if (C->get_alias_index(result->adr_type()) != alias_idx) {\n+          assert(C->get_general_index(alias_idx) == C->get_alias_index(result->adr_type()), \"should be projection for the same field\/array element\");\n+          result = get_map(result->_idx);\n+          assert(result != nullptr, \"new projection should have been allocated\");\n+          break;\n@@ -4446,0 +4451,19 @@\n+        \/\/ Add a new NarrowMem projection for each existing NarrowMem projection with new adr type\n+        InitializeNode* init = alloc->as_Allocate()->initialization();\n+        assert(init != nullptr, \"can't find Initialization node for this Allocate node\");\n+        DUIterator i = init->outs();\n+        auto process_narrow_proj = [tinst, init, this, igvn](NarrowMemProjNode* proj) {\n+          const TypePtr* adr_type = proj->adr_type();\n+          const TypePtr* new_adr_type = tinst->add_offset(adr_type->offset());\n+          bool already_has_narrow_mem_proj_with_adr_type = init->already_has_narrow_mem_proj_with_adr_type(new_adr_type);\n+          if (adr_type != new_adr_type && !already_has_narrow_mem_proj_with_adr_type) {\n+            DEBUG_ONLY( uint alias_idx = _compile->get_alias_index(new_adr_type); )\n+            assert(_compile->get_general_index(alias_idx) == _compile->get_alias_index(adr_type), \"new adr type should be narrowed down from existing adr type\");\n+            NarrowMemProjNode* new_proj = new NarrowMemProjNode(init, new_adr_type);\n+            igvn->set_type(new_proj, new_proj->bottom_type());\n+            record_for_optimizer(new_proj);\n+            set_map(proj, new_proj); \/\/ record it so ConnectionGraph::find_inst_mem() can find it\n+          }\n+          return false;\n+        };\n+        init->apply_to_narrow_mem_projs(i, process_narrow_proj);\n@@ -4709,5 +4733,7 @@\n-    } else if (n->is_MemBar()) { \/\/ Initialize, MemBar nodes\n-      \/\/ we don't need to do anything, but the users must be pushed\n-      n = n->as_MemBar()->proj_out_or_null(TypeFunc::Memory);\n-      if (n == nullptr) {\n-        continue;\n+    } else if (n->is_MemBar()) { \/\/ MemBar nodes\n+      if (!n->is_Initialize()) { \/\/ memory projections for Initialize pushed below (so we get to all their uses)\n+        \/\/ we don't need to do anything, but the users must be pushed\n+        n = n->as_MemBar()->proj_out_or_null(TypeFunc::Memory);\n+        if (n == nullptr) {\n+          continue;\n+        }\n@@ -4730,0 +4756,2 @@\n+    } else if (n->is_Proj()) {\n+      assert(n->in(0)->is_Initialize(), \"we only push memory projections for Initialize\");\n@@ -4773,0 +4801,5 @@\n+      } else if (use->is_Proj()) {\n+        assert(n->is_Initialize(), \"We only push projections of Initialize\");\n+        if (use->as_Proj()->_con == TypeFunc::Memory) { \/\/ Ignore precedent edge\n+          memnode_worklist.append_if_missing(use);\n+        }\n@@ -4824,1 +4857,1 @@\n-        const Type *at = igvn->type(mem->in(MemNode::Address));\n+        const Type* at = igvn->type(mem->in(MemNode::Address));\n@@ -4944,1 +4977,1 @@\n-             n->is_AddP() || n->is_Phi(), \"unknown node used for set_map()\");\n+             n->is_AddP() || n->is_Phi() || n->is_NarrowMemProj(), \"unknown node used for set_map()\");\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":40,"deletions":7,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -566,1 +566,1 @@\n-                        \/\/ ChecCastPP    - allocation that this is a cast of\n+                        \/\/ CheckCastPP   - allocation that this is a cast of\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3633,4 +3633,7 @@\n-    \/\/ Add an edge in the MergeMem for the header fields so an access\n-    \/\/ to one of those has correct memory state\n-    set_memory(minit_out, C->get_alias_index(oop_type->add_offset(oopDesc::mark_offset_in_bytes())));\n-    set_memory(minit_out, C->get_alias_index(oop_type->add_offset(oopDesc::klass_offset_in_bytes())));\n+    int mark_idx = C->get_alias_index(oop_type->add_offset(oopDesc::mark_offset_in_bytes()));\n+    \/\/ Add an edge in the MergeMem for the header fields so an access to one of those has correct memory state\n+    \/\/ Use one NarrowMemProjNode per slice to properly record the adr type of each slice. The Initialize node will have\n+    \/\/ multiple projection as a result.\n+    set_memory(_gvn.transform(new NarrowMemProjNode(init, C->get_adr_type(mark_idx))), mark_idx);\n+    int klass_idx = C->get_alias_index(oop_type->add_offset(oopDesc::klass_offset_in_bytes()));\n+    set_memory(_gvn.transform(new NarrowMemProjNode(init, C->get_adr_type(klass_idx))), klass_idx);\n@@ -3640,1 +3643,1 @@\n-      hook_memory_on_init(*this, elemidx, minit_in, minit_out);\n+      hook_memory_on_init(*this, elemidx, minit_in, _gvn.transform(new NarrowMemProjNode(init, C->get_adr_type(elemidx))));\n@@ -3649,1 +3652,1 @@\n-        hook_memory_on_init(*this, fieldidx, minit_in, minit_out);\n+        hook_memory_on_init(*this, fieldidx, minit_in, _gvn.transform(new NarrowMemProjNode(init, C->get_adr_type(fieldidx))));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -5512,1 +5512,1 @@\n-    C->gvn_replace_by(init->proj_out(TypeFunc::Memory), alloc_mem);\n+    init->replace_mem_projs_by(alloc_mem, C);\n@@ -5563,2 +5563,15 @@\n-    set_memory(init->proj_out_or_null(TypeFunc::Memory), Compile::AliasIdxRaw);\n-    set_memory(init->proj_out_or_null(TypeFunc::Memory), elemidx);\n+    \/\/ Need to properly move every memory projection for the Initialize\n+#ifdef ASSERT\n+    int mark_idx = C->get_alias_index(ary_type->add_offset(oopDesc::mark_offset_in_bytes()));\n+    int klass_idx = C->get_alias_index(ary_type->add_offset(oopDesc::klass_offset_in_bytes()));\n+#endif\n+    auto move_proj = [=](ProjNode* proj) {\n+      int alias_idx = C->get_alias_index(proj->adr_type());\n+      assert(alias_idx == Compile::AliasIdxRaw ||\n+             alias_idx == elemidx ||\n+             alias_idx == mark_idx ||\n+             alias_idx == klass_idx, \"should be raw memory or array element type\");\n+      set_memory(proj, alias_idx);\n+      return false;\n+    };\n+    init->apply_to_projs(move_proj, TypeFunc::Memory);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -3941,1 +3941,3 @@\n-  call->init_req(TypeFunc::FramePtr,  C->start()->proj_out_or_null(TypeFunc::FramePtr));\n+  Node* frame = new ParmNode(C->start(), TypeFunc::FramePtr);\n+  _igvn.register_new_node_with_optimizer(frame);\n+  call->init_req(TypeFunc::FramePtr,  frame);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2657,2 +2657,3 @@\n-          Node* cle_out = cle->proj_out_or_null(false);\n-          if (use == cle_out) {\n+          \/\/ is use the projection that exits the loop from the CountedLoopEndNode?\n+          if (use->in(0) == cle) {\n+            IfFalseNode* cle_out = use->as_IfFalse();\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1010,1 +1010,0 @@\n-        assert(init->outcnt() <= 2, \"only a control and memory projection expected\");\n@@ -1020,3 +1019,1 @@\n-        Node *mem_proj = init->proj_out_or_null(TypeFunc::Memory);\n-        if (mem_proj != nullptr) {\n-          Node *mem = init->in(TypeFunc::Memory);\n+        Node* mem = init->in(TypeFunc::Memory);\n@@ -1024,0 +1021,1 @@\n+        if (init->number_of_projs(TypeFunc::Memory) > 0) {\n@@ -1025,1 +1023,1 @@\n-            assert(mem->in(TypeFunc::Memory) == _callprojs.fallthrough_memproj, \"allocation memory projection\");\n+            assert(mem->as_MergeMem()->memory_at(Compile::AliasIdxRaw) == _callprojs.fallthrough_memproj, \"allocation memory projection\");\n@@ -1029,2 +1027,0 @@\n-#endif\n-          _igvn.replace_node(mem_proj, mem);\n@@ -1032,0 +1028,3 @@\n+#endif\n+        init->replace_mem_projs_by(mem, &_igvn);\n+        assert(init->outcnt() == 0, \"only a control and some memory projections expected\");\n@@ -1618,1 +1617,1 @@\n-      MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);\n+      MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxRaw);\n@@ -1634,1 +1633,0 @@\n-      Node* init_mem = init->proj_out_or_null(TypeFunc::Memory);\n@@ -1636,1 +1634,8 @@\n-      MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);\n+      \/\/ What we want is to prevent the compiler and the cpu from re-ordering the stores that initialize this object\n+      \/\/ with subsequent stores to any slice. As a consequence, this MemBar should capture the entire memory state at\n+      \/\/ this point in the IR and produce a new memory state that should cover all slices. However, the Initialize node\n+      \/\/ only captures\/produces a partial memory state making it complicated to insert such a MemBar. Because\n+      \/\/ re-ordering by the compiler can't happen by construction (a later Store that publishes the just allocated\n+      \/\/ object reference is indirectly control dependent on the Initialize node), preventing reordering by the cpu is\n+      \/\/ sufficient. For that a MemBar on the raw memory slice is good enough.\n+      MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxRaw);\n@@ -1641,2 +1646,12 @@\n-      Node* mem = new ProjNode(init, TypeFunc::Memory);\n-      transform_later(mem);\n+      Node* existing_raw_mem_proj = nullptr;\n+      auto find_raw_mem = [&, this](ProjNode* proj) {\n+        if (C->get_alias_index(proj->adr_type()) == Compile::AliasIdxRaw) {\n+          assert(existing_raw_mem_proj == nullptr, \"only one expected\");\n+          existing_raw_mem_proj = proj;\n+        }\n+        return false;\n+      };\n+      init->apply_to_projs(find_raw_mem, TypeFunc::Memory);\n+      Node* raw_mem_proj = new ProjNode(init, TypeFunc::Memory);\n+      transform_later(raw_mem_proj);\n+      assert(existing_raw_mem_proj != nullptr, \"\");\n@@ -1646,1 +1661,1 @@\n-      mb->init_req(TypeFunc::Memory, mem);\n+      mb->init_req(TypeFunc::Memory, raw_mem_proj);\n@@ -1651,1 +1666,1 @@\n-      mem = new ProjNode(mb, TypeFunc::Memory);\n+      Node* mem = new ProjNode(mb, TypeFunc::Memory);\n@@ -1660,3 +1675,1 @@\n-      if (init_mem != nullptr) {\n-        _igvn.replace_node(init_mem, mem);\n-      }\n+      _igvn.replace_node(existing_raw_mem_proj, mem);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":30,"deletions":17,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -4234,4 +4234,1 @@\n-  if (outcnt() != 2) {\n-    assert(Opcode() == Op_Initialize, \"Only seen when there are no use of init memory\");\n-    assert(outcnt() == 1, \"Only control then\");\n-  }\n+  assert(outcnt() == 2 || Opcode() == Op_Initialize, \"Only seen when there are no or multiple uses of init memory\");\n@@ -4245,3 +4242,0 @@\n-  if (proj_out_or_null(TypeFunc::Memory) != nullptr) {\n-    igvn->replace_node(proj_out(TypeFunc::Memory), in(TypeFunc::Memory));\n-  }\n@@ -4251,0 +4245,7 @@\n+  if (is_Initialize()) {\n+    as_Initialize()->replace_mem_projs_by(in(TypeFunc::Memory), igvn);\n+  } else {\n+    if (proj_out_or_null(TypeFunc::Memory) != nullptr) {\n+      igvn->replace_node(proj_out(TypeFunc::Memory), in(TypeFunc::Memory));\n+    }\n+  }\n@@ -5453,0 +5454,40 @@\n+void InitializeNode::replace_mem_projs_by(Node* mem, Compile* C) {\n+  auto replace_proj = [C, mem](ProjNode* proj) {\n+    C->gvn_replace_by(proj, mem);\n+    return false;\n+  };\n+  apply_to_projs(replace_proj, TypeFunc::Memory);\n+}\n+\n+void InitializeNode::replace_mem_projs_by(Node* mem, PhaseIterGVN* igvn) {\n+  DUIterator_Fast imax, i = fast_outs(imax);\n+  auto replace_proj = [mem, igvn, &i, &imax](ProjNode* proj) {\n+    igvn->replace_node(proj, mem);\n+    --i; --imax;\n+    return false;\n+  };\n+  apply_to_projs(imax, i, replace_proj, TypeFunc::Memory);\n+}\n+\n+template <class Callback> ProjNode* InitializeNode::apply_to_narrow_mem_projs(Callback callback) const {\n+  DUIterator_Fast imax, i = fast_outs(imax);\n+  return apply_to_narrow_mem_projs_any_iterator(UsesIteratorFast(imax, i, this), callback);\n+}\n+\n+\n+template<class Callback> ProjNode* InitializeNode::apply_to_narrow_mem_projs(Callback callback, const TypePtr* adr_type) const {\n+  auto filter = [callback, adr_type](NarrowMemProjNode* proj) {\n+    if (proj->adr_type() == adr_type && callback(proj->as_NarrowMemProj())) {\n+      return true;\n+    }\n+    return false;\n+  };\n+  return apply_to_narrow_mem_projs(filter);\n+}\n+\n+bool InitializeNode::already_has_narrow_mem_proj_with_adr_type(const TypePtr* adr_type) const {\n+  auto find_proj = [](ProjNode* proj) {\n+    return true;\n+  };\n+  return apply_to_narrow_mem_projs(find_proj, adr_type) != nullptr;\n+}\n@@ -5875,0 +5916,1 @@\n+           || n->is_NarrowMemProj()\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":49,"deletions":7,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1374,1 +1374,14 @@\n- private:\n+  \/\/ An Initialize node has multiple memory projections. Helper methods used when the node is removed.\n+  \/\/ For use at parse time\n+  void replace_mem_projs_by(Node* mem, Compile* C);\n+  \/\/ For use with IGVN\n+  void replace_mem_projs_by(Node* mem, PhaseIterGVN* igvn);\n+\n+  \/\/ Does a NarrowMemProj with this adr_type and this node as input already exist?\n+  bool already_has_narrow_mem_proj_with_adr_type(const TypePtr* adr_type) const;\n+  \/\/ Run callback on all NarrowMem proj uses using passed iterator\n+  template <class Callback> ProjNode* apply_to_narrow_mem_projs(DUIterator& i, Callback callback) const {\n+    return apply_to_narrow_mem_projs_any_iterator<Callback, UsesIterator>(UsesIterator(i, this), callback);\n+  }\n+\n+private:\n@@ -1391,0 +1404,16 @@\n+\n+  \/\/ Iterate with i over all NarrowMemProj uses calling callback\n+  template <class Callback, class Iterator> ProjNode* apply_to_narrow_mem_projs_any_iterator(Iterator i, Callback callback) const {\n+    auto filter = [callback](ProjNode* proj) {\n+      if (proj->is_NarrowMemProj() && callback(proj->as_NarrowMemProj())) {\n+        return true;\n+      }\n+      return false;\n+    };\n+    return apply_to_projs_any_iterator(i, filter);\n+  }\n+\n+  \/\/ Same but with default iterator\n+  template <class Callback> ProjNode* apply_to_narrow_mem_projs(Callback callback) const;\n+  \/\/ Same but only for NarrowMem proj whose adr_type matches\n+  template <class Callback> ProjNode* apply_to_narrow_mem_projs(Callback callback, const TypePtr* adr_type) const;\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -48,14 +48,7 @@\n-  for( DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++ ) {\n-    Node *p = fast_out(i);\n-    if (p->is_Proj()) {\n-      ProjNode *proj = p->as_Proj();\n-      if (proj->_con == which_proj) {\n-        assert((Opcode() != Op_If && Opcode() != Op_RangeCheck) || proj->Opcode() == (which_proj ? Op_IfTrue : Op_IfFalse), \"bad if #2\");\n-        return proj;\n-      }\n-    } else {\n-      assert(p == this && this->is_Start(), \"else must be proj\");\n-      continue;\n-    }\n-  }\n-  return nullptr;\n+  assert(number_of_projs(which_proj) <= 1, \"only when there's a single projection\");\n+  auto find_proj = [which_proj, this](ProjNode* proj) {\n+    assert((Opcode() != Op_If && Opcode() != Op_RangeCheck) || proj->Opcode() == (which_proj ? Op_IfTrue : Op_IfFalse),\n+           \"bad if #2\");\n+    return true;\n+  };\n+  return apply_to_projs(find_proj, which_proj);\n@@ -65,4 +58,11 @@\n-  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n-    ProjNode* proj = fast_out(i)->isa_Proj();\n-    if (proj != nullptr && (proj->_con == which_proj) && (proj->_is_io_use == is_io_use)) {\n-      return proj;\n+  assert(number_of_projs(which_proj, is_io_use) <= 1, \"only when there's a single projection\");\n+  auto find_proj = [](ProjNode* proj) {\n+    return true;\n+  };\n+  return apply_to_projs(find_proj, which_proj, is_io_use);\n+}\n+\n+template<class Callback> ProjNode* MultiNode::apply_to_projs(Callback callback, uint which_proj, bool is_io_use) const {\n+  auto filter = [is_io_use,callback](ProjNode* proj) {\n+    if (proj->_is_io_use == is_io_use && callback(proj)) {\n+      return true;\n@@ -70,2 +70,23 @@\n-  }\n-  return nullptr;\n+    return false;\n+  };\n+  return apply_to_projs(filter, which_proj);\n+}\n+\n+uint MultiNode::number_of_projs(uint which_proj) const {\n+  uint cnt = 0;\n+  auto count_projs = [&cnt](ProjNode* proj) {\n+    cnt++;\n+    return false;\n+  };\n+  apply_to_projs(count_projs, which_proj);\n+  return cnt;\n+}\n+\n+uint MultiNode::number_of_projs(uint which_proj, bool is_io_use) const {\n+  uint cnt = 0;\n+  auto count_projs = [&cnt](ProjNode* proj) {\n+    cnt++;\n+    return false;\n+  };\n+  apply_to_projs(count_projs, which_proj, is_io_use);\n+  return cnt;\n@@ -229,0 +250,24 @@\n+\n+#ifndef PRODUCT\n+void NarrowMemProjNode::dump_adr_type(outputStream* st) const {\n+  st->print(\" @\"); _adr_type->dump_on(st);\n+  Compile* C = Compile::current();\n+  Compile::AliasType* atp = C->alias_type(_adr_type);\n+  ciField* field = atp->field();\n+  if (field) {\n+    st->print(\", name=\");\n+    field->print_name_on(st);\n+  }\n+  st->print(\", idx=%d;\", atp->index());\n+}\n+\n+void NarrowMemProjNode::dump_spec(outputStream *st) const {\n+  ProjNode::dump_spec(st);\n+  dump_adr_type(st);\n+}\n+\n+void NarrowMemProjNode::dump_compact_spec(outputStream *st) const {\n+  ProjNode::dump_compact_spec(st);\n+  dump_adr_type(st);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/multnode.cpp","additions":65,"deletions":20,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -52,0 +52,83 @@\n+  uint number_of_projs(uint which_proj) const;\n+  uint number_of_projs(uint which_proj, bool is_io_use) const;\n+\n+  \/\/ Run callback on all Proj projection from this node\n+  template<class Callback> ProjNode* apply_to_projs(Callback callback) const {\n+    DUIterator_Fast imax, i = fast_outs(imax);\n+    return apply_to_projs(imax, i, callback);\n+  }\n+\n+  \/\/ Same but with provided iterators\n+  template<class Callback> ProjNode* apply_to_projs(DUIterator_Fast& imax, DUIterator_Fast& i, Callback callback) const {\n+    return apply_to_projs_any_iterator<Callback, UsesIteratorFast>(UsesIteratorFast(imax, i, this), callback);\n+  }\n+\n+  \/\/ Same but only for Proj node whose _con matches which_proj\n+  template <class Callback> ProjNode* apply_to_projs(DUIterator_Fast& imax, DUIterator_Fast& i, Callback callback, uint which_proj) const;\n+\n+  \/\/ Same but with default iterators\n+  template<class Callback> ProjNode* apply_to_projs(Callback callback, uint which_proj) const {\n+    DUIterator_Fast imax, i = fast_outs(imax);\n+    return apply_to_projs(imax, i, callback, which_proj);\n+  }\n+\n+  \/\/ Same but for matching _con and _is_io_use\n+  template <class Callback> ProjNode* apply_to_projs(Callback callback, uint which_proj, bool is_io_use) const;\n+\n+protected:\n+\n+  \/\/ Provide single interface for DUIterator_Fast\/DUIterator for template method below\n+  class UsesIteratorFast {\n+    DUIterator_Fast& _imax;\n+    DUIterator_Fast& _i;\n+    const Node* _node;\n+\n+  public:\n+    bool cont() {\n+      return _i < _imax;\n+    }\n+    void next() {\n+      _i++;\n+    }\n+    Node* current() {\n+      return _node->fast_out(_i);;\n+    }\n+    UsesIteratorFast(DUIterator_Fast& imax, DUIterator_Fast& i, const Node* node)\n+      : _imax(imax), _i(i), _node(node) {\n+    }\n+  };\n+\n+  class UsesIterator {\n+    DUIterator& _i;\n+    const Node* _node;\n+\n+  public:\n+    bool cont() {\n+      return _node->has_out(_i);\n+    }\n+    void next() {\n+      _i++;\n+    }\n+    Node* current() {\n+      return _node->out(_i);;\n+    }\n+    UsesIterator(DUIterator& i, const Node* node)\n+      : _i(i), _node(node) {\n+    }\n+  };\n+\n+  \/\/ Iterate with i over all Proj uses calling callback\n+  template<class Callback, class Iterator> ProjNode* apply_to_projs_any_iterator(Iterator i, Callback callback) const {\n+    for (; i.cont(); i.next()) {\n+      Node* p = i.current();\n+      if (p->is_Proj()) {\n+        ProjNode* proj = p->as_Proj();\n+        if (callback(proj)) {\n+          return proj;\n+        }\n+      } else {\n+        assert(p == this && is_Start(), \"else must be proj\");\n+      }\n+    }\n+    return nullptr;\n+  }\n@@ -108,0 +191,44 @@\n+\/\/ A ProjNode variant that captures an adr_type(). Used as a projection of InitializeNode to have the right adr_type()\n+\/\/ for array elements\/fields.\n+class NarrowMemProjNode : public ProjNode {\n+private:\n+  const TypePtr* const _adr_type;\n+protected:\n+  virtual uint hash() const {\n+    return ProjNode::hash() + _adr_type->hash();\n+  }\n+  virtual bool cmp(const Node& n) const {\n+    return ProjNode::cmp(n) && ((NarrowMemProjNode&)n)._adr_type == _adr_type;\n+  }\n+  virtual uint size_of() const {\n+    return sizeof(*this);\n+  }\n+public:\n+  NarrowMemProjNode(Node* src, const TypePtr* adr_type)\n+    : ProjNode(src, TypeFunc::Memory), _adr_type(adr_type) {\n+    init_class_id(Class_NarrowMemProj);\n+  }\n+\n+  virtual const TypePtr* adr_type() const {\n+    return _adr_type;\n+  }\n+\n+  virtual int Opcode() const;\n+\n+#ifndef PRODUCT\n+  void dump_adr_type(outputStream* st) const;\n+  virtual void dump_spec(outputStream *st) const;\n+  virtual void dump_compact_spec(outputStream *st) const;\n+#endif\n+};\n+\n+template <class Callback> ProjNode* MultiNode::apply_to_projs(DUIterator_Fast& imax, DUIterator_Fast& i, Callback callback, uint which_proj) const {\n+  auto filter = [which_proj, callback](ProjNode* proj) {\n+    if (proj->_con == which_proj && callback(proj)) {\n+      return true;\n+    }\n+    return false;\n+  };\n+  return apply_to_projs(imax, i, filter);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/multnode.hpp","additions":127,"deletions":0,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+class NarrowMemProjNode;\n@@ -765,0 +766,1 @@\n+      DEFINE_CLASS_ID(NarrowMemProj, Proj, 6)\n@@ -982,0 +984,1 @@\n+  DEFINE_CLASS_QUERY(NarrowMemProj)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1674,2 +1674,5 @@\n-      Node* imem = init->proj_out_or_null(TypeFunc::Memory);\n-      if (imem != nullptr) add_users_to_worklist0(imem, worklist);\n+      auto enqueue = [&worklist](ProjNode* proj) {\n+        add_users_to_worklist0(proj, worklist);\n+        return false;\n+      };\n+      init->apply_to_projs(enqueue, TypeFunc::Memory);\n@@ -1689,2 +1692,6 @@\n-    Node* imem = use->as_Initialize()->proj_out_or_null(TypeFunc::Memory);\n-    if (imem != nullptr) add_users_to_worklist0(imem, worklist);\n+    InitializeNode* init = use->as_Initialize();\n+    auto enqueue = [&worklist](ProjNode* proj) {\n+      add_users_to_worklist0(proj, worklist);\n+      return false;\n+    };\n+    init->apply_to_projs(enqueue, TypeFunc::Memory);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -356,1 +356,0 @@\n-  assert(init->outcnt() <= 2, \"only a control and memory projection expected\");\n@@ -362,5 +361,2 @@\n-  Node *mem_proj = init->proj_out_or_null(TypeFunc::Memory);\n-  if (mem_proj != nullptr) {\n-    Node *mem = init->in(TypeFunc::Memory);\n-    C->gvn_replace_by(mem_proj, mem);\n-  }\n+  Node* mem = init->in(TypeFunc::Memory);\n+  init->replace_mem_projs_by(mem, C);\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-    analyzer.shouldContain(\"++++ Eliminated: 48 Allocate\");\n-    analyzer.shouldContain(\"++++ Eliminated: 78 Allocate\");\n+    analyzer.shouldContain(\"++++ Eliminated: 51 Allocate\");\n+    analyzer.shouldContain(\"++++ Eliminated: 84 Allocate\");\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestIterativeEA.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327963\n+ * @summary C2: fix construction of memory graph around Initialize node to prevent incorrect execution if allocation is removed\n+ * @run main\/othervm -XX:-BackgroundCompilation TestEarlyEliminationOfAllocationWithoutUse\n+ * @run main\/othervm TestEarlyEliminationOfAllocationWithoutUse\n+ *\/\n+\n+import java.util.Arrays;\n+\n+public class TestEarlyEliminationOfAllocationWithoutUse {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        boolean[] allTrue = new boolean[3];\n+        Arrays.fill(allTrue, true);\n+        A a = new A();\n+        boolean[] allFalse = new boolean[3];\n+        for (int i = 0; i < 20_000; i++) {\n+            a.field1 = 0;\n+            test1(a, allTrue);\n+            test1(a, allFalse);\n+            if (a.field1 != 42) {\n+                throw new RuntimeException(\"Lost Store\");\n+            }\n+        }\n+    }\n+\n+    private static void test1(A otherA, boolean[] flags) {\n+        otherA.field1 = 42;\n+        \/\/ Fully unrolled before EA\n+        for (int i = 0; i < 3; i++) {\n+            A a = new A(); \/\/ removed right after EA\n+            if (flags[i]) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private static class A {\n+        int field1;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/macronodes\/TestEarlyEliminationOfAllocationWithoutUse.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,338 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327012 8327963\n+ * @summary Revealed issue where hook_memory_on_init links some array slice to the rawptr slice.\n+ *          Now that array slice depends on the rawslice. And then when the Initialize MemBar gets\n+ *          removed in expand_allocate_common, the rawslice sees that it has now no effect, looks\n+ *          through the MergeMem and sees the initial stae. That way, also the linked array slice\n+ *          goes to the initial state, even if before the allocation there were stores on the array\n+ *          slice. This leads to a messed up memory graph, and missing stores in the generated code.\n+ *\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,compiler.macronodes.TestEliminationOfAllocationWithoutUse::test*\n+ *                   compiler.macronodes.TestEliminationOfAllocationWithoutUse\n+ * @run main\/othervm -Xcomp\n+ *                   -XX:CompileCommand=compileonly,compiler.macronodes.TestEliminationOfAllocationWithoutUse::test*\n+ *                   compiler.macronodes.TestEliminationOfAllocationWithoutUse\n+ *\/\n+\n+package compiler.macronodes;\n+\n+public class TestEliminationOfAllocationWithoutUse {\n+\n+    static public void main(String[] args) {\n+        int failures = 0;\n+        failures += run1();\n+        failures += run2();\n+        failures += run3();\n+        failures += run4();\n+        failures += run5();\n+        failures += run6();\n+        failures += run7();\n+        failures += run8();\n+        failures += run9();\n+        if (failures != 0) {\n+            throw new RuntimeException(\"Had test failures: \" + failures);\n+        }\n+    }\n+\n+    static public int run1() {\n+        int size = 10;\n+        double[] arr1 = new double[size];\n+        double[] arr2 = new double[size];\n+        test1(arr1, arr2);\n+\n+        double sum = 0;\n+        for (int i = 0; i < arr1.length; ++i) {\n+            sum += arr1[i] - arr2[i];\n+        }\n+\n+        if (sum != (double)(size)) {\n+            System.out.println(\"test1: wrong result: \" + sum + \" vs expected: \" + size);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ Simplified from JDK-8327012 regression test.\n+    public static void test1(double[] arr1, double[] arr2) {\n+        for(int i = 0; i < arr1.length; ++i) {\n+            \/\/ stores on double[] slice\n+            arr1[i] = (double)(i + 2);\n+            arr2[i] = (double)(i + 1);\n+            \/\/ Allocation without use: but Initialize MemBar tangles the rawptr and double[] slices\n+            double[] tmp = new double[100];\n+            \/\/ When the Initialize MemBar is removed, the rawptr slice sees that there is no effect\n+            \/\/ and takes the initial state. The double[] slice is hooked on to the rawptr slice, and\n+            \/\/ also thinks it has the initial state, ignoring the double[] stores above.\n+        }\n+    }\n+\n+    static public int run2() {\n+        int size = 10;\n+        double[] arr1 = new double[size];\n+        test2(arr1);\n+\n+        double sum = 0;\n+        for(int i = 0; i < arr1.length; ++i) {\n+            sum += arr1[i];\n+        }\n+\n+        if (sum != (double)(size)) {\n+            System.out.println(\"test2: wrong result: \" + sum + \" vs expected: \" + size);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ Simplified from test1\n+    public static void test2(double[] arr1) {\n+        for(int i = 0; i < arr1.length; ++i) {\n+            arr1[i] = 1;\n+            double[] tmp = new double[100];\n+        }\n+    }\n+\n+    static public int run3() {\n+        int size = 10;\n+        int[] arr1 = new int[size];\n+        test3(arr1);\n+\n+        int sum = 0;\n+        for(int i = 0; i < arr1.length; ++i) {\n+            sum += arr1[i];\n+        }\n+\n+        if (sum != size) {\n+            System.out.println(\"test3: wrong result: \" + sum + \" vs expected: \" + size);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ Modified from test2\n+    public static void test3(int[] arr1) {\n+        for(int i = 0; i < arr1.length; ++i) {\n+            arr1[i] = 1;\n+            int[] tmp = new int[100];\n+        }\n+    }\n+\n+    \/\/ From TestIncorrectResult.java in JDK-8324739\n+    static int test4(int l2) {\n+       int[] tmp = new int[20];\n+\n+       for (int j = 0; j < l2; ++j) {\n+           tmp[j] = 42;\n+           int[] unused_but_necessary = new int[400];\n+       }\n+\n+       return tmp[0];\n+    }\n+\n+    public static int run4() {\n+        for (int i = 0; i < 100; ++i) {\n+            long res = test4(20);\n+\n+            if (res != 42) {\n+                System.out.println(\"test4: wrong result: \" + res + \" vs expected: 42\");\n+                return 1;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ From JDK-8336701\n+    static class Test5 {\n+        int[] b = new int[400];\n+        static int[] staticArray = new int[400];\n+    }\n+\n+    static void test5() {\n+        long e;\n+        for (e = 1; e < 9; ++e) {\n+            Test5.staticArray[(int) e] -= e;\n+            synchronized (new Test5()) { }\n+        }\n+        for (int f = 0; f < 10000; ++f) ;\n+    }\n+\n+    static int run5() {\n+        new Test5();\n+        for (int i = 0; i < 1000; ++i) {\n+            test5();\n+        }\n+        if (Test5.staticArray[8] != -8000) {\n+            System.out.println(\"test5: wrong result: \" + Test5.staticArray[8] + \" vs expected: -8000\");\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ From JDK-8336293\n+    static class Test6 {\n+        static long c;\n+        static int a = 400;\n+        double[] b = new double[400];\n+    }\n+\n+    static void test6() {\n+        long d;\n+        double[] e = new double[Test6.a];\n+        for (int f = 0; f < e.length; f++)\n+            e[f] = 1.116242;\n+        d = 1;\n+        while (++d < 7)\n+            synchronized (new Test6()) { }\n+        long g = 0;\n+        for (int f = 0; f < e.length; f++)\n+            g += e[f];\n+        Test6.c += g;\n+    }\n+\n+    static int run6() {\n+        new Test6();\n+        for (int f = 0; f < 10000; ++f) {\n+            test6();\n+        }\n+        if (Test6.c != 4000000) {\n+            System.out.println(\"test6: wrong result: \" + Test6.c + \" vs expected: 4000000 \");\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ From JDK-8327868\n+    static class Test7 {\n+        static int a = 400;\n+        int[] b = new int[400];\n+        static int[] staticArray = new int[a];\n+    }\n+\n+    static int test7() {\n+        int l, d = 3;\n+        for (l = 2; 58 > l; l++) {\n+            for (int e = 2; e < 8; e += 2)\n+                for (int f = 1; f < e; f += 2)\n+                    synchronized (new Test7()) {\n+                    }\n+            do\n+                ; while (d < 2);\n+            int g = 0;\n+            do\n+                g++;\n+            while (g < 20000);\n+            Test7.staticArray[1] -= 3023399;\n+        }\n+        int h = 0;\n+        for (int i = 0; i < Test7.staticArray.length; i++)\n+            h += Test7.staticArray[i];\n+        return h;\n+    }\n+\n+    static int run7() {\n+        new Test7();\n+        int res = test7();\n+        if (res != -169310344) {\n+            System.out.println(\"test7: wrong result: \" + res + \" vs expected: -169310344\");\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ from JDK-8329984\n+    static class Test8 {\n+        static int a = 400;\n+        int[] e = new int[400];\n+    }\n+\n+    static int test8() {\n+        int i = 22738;\n+        int b;\n+        int h;\n+        int[] c = new int[Test8.a];\n+        for (b = 3; b < 273; b++) {\n+            h = 1;\n+            while (++h < 97) switch (b % 6 + 56) {\n+                case 56:\n+                    c[1] = i;\n+                case 57:\n+                    synchronized (new Test8()) {}\n+            }\n+        }\n+        int k = 0;\n+        for (int j = 0; j < c.length; j++) k += c[j];\n+        return k;\n+    }\n+\n+    public static int run8() {\n+        new Test8();\n+        for (int i = 0; i < 20; i++) {\n+            int res = test8();\n+            if (res != 22738) {\n+                System.out.println(\"test8: wrong result: \" + res + \" vs expected: 22738\");\n+                return 1;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ from JDK-8341009\n+   static class Test9 {\n+        static int a = 256;\n+        float[] b = new float[256];\n+        static long c;\n+    }\n+\n+  static void test9() {\n+    for (int f = 0; f < 10000; ++f) ;\n+    float[][] g = new float[Test9.a][Test9.a];\n+    for (int d = 7; d < 16; d++) {\n+      long e = 1;\n+      do {\n+        g[d][(int) e] = d;\n+        synchronized (new Test9()) {\n+        }\n+      } while (++e < 5);\n+    }\n+    for (int i = 0; i < Test9.a; ++i) {\n+      for (int j = 0; j < Test9.a ; ++j) {\n+          Test9.c += g[i][j];\n+      }\n+    }\n+  }\n+\n+  static int run9() {\n+    for (int j = 6; 116 > j; ++j) {\n+        test9();\n+    }\n+    if (Test9.c != 43560) {\n+        System.out.println(\"test9: wrong result: \" + Test9.c + \" vs expected: 43560\");\n+        return 1;\n+    }\n+    return 0;\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/macronodes\/TestEliminationOfAllocationWithoutUse.java","additions":338,"deletions":0,"binary":false,"changes":338,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327012 8327963\n+ * @summary Test that initializing store gets captured, i.e. moved before the InitializeNode\n+ *          and made into a raw-store.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.macronodes.TestInitializingStoreCapturing\n+ *\/\n+\n+package compiler.macronodes;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestInitializingStoreCapturing {\n+\n+    static class A {\n+        float value;\n+        A(float v) { value = v; }\n+    };\n+\n+    static public void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_F, \"= 0\"})\n+    static A testInitializeField() {\n+        return new A(4.2f);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_F, \"= 0\"})\n+    static float[] testInitializeArray() {\n+        return new float[] {4.2f};\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/macronodes\/TestInitializingStoreCapturing.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"}]}