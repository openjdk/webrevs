{"files":[{"patch":"@@ -276,0 +276,1 @@\n+macro(NarrowMemProj)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4123,0 +4123,16 @@\n+    if (!is_instance && result->Opcode() == Op_NarrowMemProj) {\n+      \/\/ Memory for non known instance can safely skip over a known instance allocation (that memory state doesn't access\n+      \/\/ the result of an allocation for a known instance).\n+      assert(result->as_Proj()->_con == TypeFunc::Memory, \"a NarrowMemProj can only be a memory projection\");\n+      assert(toop != nullptr, \"\");\n+      Node* proj_in = result->in(0);\n+      if (proj_in->is_Initialize()) {\n+        AllocateNode* alloc = proj_in->as_Initialize()->allocation();\n+        assert(alloc->result_cast() == nullptr ||\n+               ((alloc->_is_scalar_replaceable) == igvn->type(alloc->result_cast())->is_oopptr()->is_known_instance()),\n+               \"only scalar replaceable allocations are known instance\");\n+        if (alloc != nullptr && alloc->_is_scalar_replaceable) {\n+          result = alloc->in(TypeFunc::Memory);\n+        }\n+      }\n+    }\n@@ -4439,0 +4455,18 @@\n+        \/\/ Update adr type captured by NarrowMem projections to new type\n+        InitializeNode* init = alloc->as_Allocate()->initialization();\n+        assert(init != nullptr, \"can't find Initialization node for this Allocate node\");\n+        for (DUIterator_Fast imax, i = init->fast_outs(imax); i < imax; i++) {\n+          ProjNode* proj = init->fast_out(i)->as_Proj();\n+          if (proj->Opcode() == Op_NarrowMemProj) {\n+            const TypePtr* adr_type = proj->adr_type();\n+            const TypePtr* new_adr_type = tinst->add_offset(adr_type->offset());\n+            if (adr_type != new_adr_type) {\n+              uint alias_ix = _compile->get_alias_index(new_adr_type);\n+              assert(_compile->get_general_index(alias_ix) == _compile->get_alias_index(adr_type), \"new adr type should be narrowed down from existing adr type\");\n+              igvn->hash_delete(proj);\n+              ((NarrowMemProjNode*)proj)->set_adr_type(new_adr_type);\n+              igvn->hash_insert(proj);\n+              record_for_optimizer(proj);\n+            }\n+          }\n+        }\n@@ -4702,5 +4736,7 @@\n-    } else if (n->is_MemBar()) { \/\/ Initialize, MemBar nodes\n-      \/\/ we don't need to do anything, but the users must be pushed\n-      n = n->as_MemBar()->proj_out_or_null(TypeFunc::Memory);\n-      if (n == nullptr) {\n-        continue;\n+    } else if (n->is_MemBar()) { \/\/ MemBar nodes\n+      if (!n->is_Initialize()) { \/\/ memory projections for Initialize pushed below (so we get to all their uses)\n+        \/\/ we don't need to do anything, but the users must be pushed\n+        n = n->as_MemBar()->proj_out_or_null(TypeFunc::Memory);\n+        if (n == nullptr) {\n+          continue;\n+        }\n@@ -4723,0 +4759,2 @@\n+    } else if (n->is_Proj()) {\n+      assert(n->in(0)->is_Initialize(), \"we only push memory projections for Initialize\");\n@@ -4766,0 +4804,5 @@\n+      } else if (use->is_Proj()) {\n+        assert(n->is_Initialize(), \"We only push projections of Initialize\");\n+        if (use->as_Proj()->_con == TypeFunc::Memory) { \/\/ Ignore precedent edge\n+          memnode_worklist.append_if_missing(use);\n+        }\n@@ -4817,1 +4860,1 @@\n-        const Type *at = igvn->type(mem->in(MemNode::Address));\n+        const Type* at = igvn->type(mem->in(MemNode::Address));\n@@ -4833,0 +4876,19 @@\n+      if (mem->Opcode() == Op_NarrowMemProj) {\n+        const TypePtr* at = mem->adr_type();\n+        uint idx = (uint) _compile->get_alias_index(at->is_ptr());\n+        if (idx == i) {\n+          \/\/ projection for a non known allocation on a non known allocation slice: can't skip over the allocation\n+          if (cur == nullptr) {\n+            cur = mem;\n+          }\n+        } else {\n+          \/\/ projection for a known allocation on a non known allocation slice: skip over the allocation\n+          if (idx >= nmm->req() || nmm->is_empty_memory(nmm->in(idx))) {\n+            nmm->set_memory_at(idx, mem);\n+          }\n+          InitializeNode* init = mem->in(0)->as_Initialize();\n+          AllocateNode* alloc = init->allocation();\n+          assert(alloc != nullptr, \"can find Allocate node from the Initialize node\");\n+          mem = alloc->in(TypeFunc::Memory);\n+        }\n+      }\n@@ -4834,0 +4896,1 @@\n+      record_for_optimizer(nmm);\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":69,"deletions":6,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -3633,4 +3633,7 @@\n-    \/\/ Add an edge in the MergeMem for the header fields so an access\n-    \/\/ to one of those has correct memory state\n-    set_memory(minit_out, C->get_alias_index(oop_type->add_offset(oopDesc::mark_offset_in_bytes())));\n-    set_memory(minit_out, C->get_alias_index(oop_type->add_offset(oopDesc::klass_offset_in_bytes())));\n+    int mark_idx = C->get_alias_index(oop_type->add_offset(oopDesc::mark_offset_in_bytes()));\n+    \/\/ Add an edge in the MergeMem for the header fields so an access to one of those has correct memory state\n+    \/\/ Use one NarrowMemProjNode per slice to properly record the adr type of each slice. The Initialize node will have\n+    \/\/ multiple projection as a result.\n+    set_memory(_gvn.transform(new NarrowMemProjNode(init, TypeFunc::Memory, C->get_adr_type(mark_idx))), mark_idx);\n+    int klass_idx = C->get_alias_index(oop_type->add_offset(oopDesc::klass_offset_in_bytes()));\n+    set_memory(_gvn.transform(new NarrowMemProjNode(init, TypeFunc::Memory, C->get_adr_type(klass_idx))), klass_idx);\n@@ -3640,1 +3643,1 @@\n-      hook_memory_on_init(*this, elemidx, minit_in, minit_out);\n+      hook_memory_on_init(*this, elemidx, minit_in, _gvn.transform(new NarrowMemProjNode(init, TypeFunc::Memory, C->get_adr_type(elemidx))));\n@@ -3649,1 +3652,1 @@\n-        hook_memory_on_init(*this, fieldidx, minit_in, minit_out);\n+        hook_memory_on_init(*this, fieldidx, minit_in, _gvn.transform(new NarrowMemProjNode(init, TypeFunc::Memory, C->get_adr_type(fieldidx))));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -5494,1 +5494,1 @@\n-    C->gvn_replace_by(init->proj_out(TypeFunc::Memory), alloc_mem);\n+    init->replace_mem_projs_by(alloc_mem, C);\n@@ -5545,2 +5545,13 @@\n-    set_memory(init->proj_out_or_null(TypeFunc::Memory), Compile::AliasIdxRaw);\n-    set_memory(init->proj_out_or_null(TypeFunc::Memory), elemidx);\n+    \/\/ Need to properly move every memory projection for the Initialize\n+#ifdef ASSERT\n+    int mark_idx = C->get_alias_index(ary_type->add_offset(oopDesc::mark_offset_in_bytes()));\n+    int klass_idx = C->get_alias_index(ary_type->add_offset(oopDesc::klass_offset_in_bytes()));\n+#endif\n+    for (DUIterator_Fast imax, i = init->fast_outs(imax); i < imax; i++) {\n+      ProjNode* proj = init->fast_out(i)->as_Proj();\n+      if (proj->_con == TypeFunc::Memory) {\n+        int alias_idx = C->get_alias_index(proj->adr_type());\n+        assert(alias_idx == Compile::AliasIdxRaw || alias_idx == elemidx || alias_idx == mark_idx || alias_idx == klass_idx, \"should be raw memory or array element type\");\n+        set_memory(proj, alias_idx);\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1010,1 +1010,0 @@\n-        assert(init->outcnt() <= 2, \"only a control and memory projection expected\");\n@@ -1020,3 +1019,1 @@\n-        Node *mem_proj = init->proj_out_or_null(TypeFunc::Memory);\n-        if (mem_proj != nullptr) {\n-          Node *mem = init->in(TypeFunc::Memory);\n+        Node* mem = init->in(TypeFunc::Memory);\n@@ -1024,0 +1021,2 @@\n+        Node* mem_proj = init->proj_out_or_null(TypeFunc::Memory);\n+        if (mem_proj != nullptr) {\n@@ -1025,1 +1024,1 @@\n-            assert(mem->in(TypeFunc::Memory) == _callprojs.fallthrough_memproj, \"allocation memory projection\");\n+            assert(mem->as_MergeMem()->memory_at(Compile::AliasIdxRaw) == _callprojs.fallthrough_memproj, \"allocation memory projection\");\n@@ -1029,2 +1028,0 @@\n-#endif\n-          _igvn.replace_node(mem_proj, mem);\n@@ -1032,0 +1029,3 @@\n+#endif\n+        init->replace_mem_projs_by(mem, &_igvn);\n+        assert(init->outcnt() == 0, \"only a control and some memory projections expected\");\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -4234,4 +4234,1 @@\n-  if (outcnt() != 2) {\n-    assert(Opcode() == Op_Initialize, \"Only seen when there are no use of init memory\");\n-    assert(outcnt() == 1, \"Only control then\");\n-  }\n+  assert(outcnt() == 2 || Opcode() == Op_Initialize, \"Only seen when there are no or multiple uses of init memory\");\n@@ -4245,3 +4242,0 @@\n-  if (proj_out_or_null(TypeFunc::Memory) != nullptr) {\n-    igvn->replace_node(proj_out(TypeFunc::Memory), in(TypeFunc::Memory));\n-  }\n@@ -4251,0 +4245,7 @@\n+  if (is_Initialize()) {\n+    as_Initialize()->replace_mem_projs_by(in(TypeFunc::Memory), igvn);\n+  } else {\n+    if (proj_out_or_null(TypeFunc::Memory) != nullptr) {\n+      igvn->replace_node(proj_out(TypeFunc::Memory), in(TypeFunc::Memory));\n+    }\n+  }\n@@ -5453,0 +5454,18 @@\n+void InitializeNode::replace_mem_projs_by(Node* mem, Compile* C) {\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    ProjNode* proj = fast_out(i)->as_Proj();\n+    if (proj->_con == TypeFunc::Memory) {\n+      C->gvn_replace_by(proj, mem);\n+    }\n+  }\n+}\n+\n+void InitializeNode::replace_mem_projs_by(Node* mem, PhaseIterGVN* igvn) {\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    ProjNode* proj = fast_out(i)->as_Proj();\n+    if (proj->_con == TypeFunc::Memory) {\n+      igvn->replace_node(proj, mem);\n+      --i; --imax;\n+    }\n+  }\n+}\n@@ -5875,0 +5894,1 @@\n+           || n->Opcode() == Op_NarrowMemProj\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1365,0 +1365,4 @@\n+  \/\/ An Initialize node has multiple memory projection. Helper methods used when the node is removed.\n+  void replace_mem_projs_by(Node* mem, Compile* C);\n+  void replace_mem_projs_by(Node* mem, PhaseIterGVN* ivn);\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -108,0 +108,29 @@\n+\/\/ A ProjNode variant that captures an adr_type(). Used as a projection of InitializeNode to have the right adr_type()\n+\/\/ for array elements\/fields.\n+class NarrowMemProjNode : public ProjNode {\n+private:\n+  const TypePtr* _adr_type;\n+protected:\n+  virtual uint hash() const {\n+    return ProjNode::hash() + _adr_type->hash();\n+  }\n+  virtual bool cmp(const Node& n) const {\n+    return ProjNode::cmp(n) && ((NarrowMemProjNode&)n)._adr_type == _adr_type;\n+  }\n+  virtual uint size_of() const {\n+    return sizeof(*this);\n+  }\n+public:\n+  NarrowMemProjNode(Node* src, uint con, const TypePtr* adr_type)\n+    : ProjNode(src, con), _adr_type(adr_type) {\n+  }\n+\n+  virtual const TypePtr* adr_type() const {\n+    return _adr_type;\n+  }\n+  void set_adr_type(const TypePtr* adr_type) {\n+    _adr_type = adr_type;\n+  }\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/multnode.hpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -356,1 +356,0 @@\n-  assert(init->outcnt() <= 2, \"only a control and memory projection expected\");\n@@ -362,5 +361,2 @@\n-  Node *mem_proj = init->proj_out_or_null(TypeFunc::Memory);\n-  if (mem_proj != nullptr) {\n-    Node *mem = init->in(TypeFunc::Memory);\n-    C->gvn_replace_by(mem_proj, mem);\n-  }\n+  Node* mem = init->in(TypeFunc::Memory);\n+  init->replace_mem_projs_by(mem, C);\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-    analyzer.shouldContain(\"++++ Eliminated: 48 Allocate\");\n-    analyzer.shouldContain(\"++++ Eliminated: 78 Allocate\");\n+    analyzer.shouldContain(\"++++ Eliminated: 51 Allocate\");\n+    analyzer.shouldContain(\"++++ Eliminated: 84 Allocate\");\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestIterativeEA.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,338 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327012 8327963\n+ * @summary Revealed issue where hook_memory_on_init links some array slice to the rawptr slice.\n+ *          Now that array slice depends on the rawslice. And then when the Initialize MemBar gets\n+ *          removed in expand_allocate_common, the rawslice sees that it has now no effect, looks\n+ *          through the MergeMem and sees the initial stae. That way, also the linked array slice\n+ *          goes to the initial state, even if before the allocation there were stores on the array\n+ *          slice. This leads to a messed up memory graph, and missing stores in the generated code.\n+ *\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,compiler.macronodes.TestEliminationOfAllocationWithoutUse::test*\n+ *                   compiler.macronodes.TestEliminationOfAllocationWithoutUse\n+ * @run main\/othervm -Xcomp\n+ *                   -XX:CompileCommand=compileonly,compiler.macronodes.TestEliminationOfAllocationWithoutUse::test*\n+ *                   compiler.macronodes.TestEliminationOfAllocationWithoutUse\n+ *\/\n+\n+package compiler.macronodes;\n+\n+public class TestEliminationOfAllocationWithoutUse {\n+\n+    static public void main(String[] args) {\n+        int failures = 0;\n+        failures += run1();\n+        failures += run2();\n+        failures += run3();\n+        failures += run4();\n+        failures += run5();\n+        failures += run6();\n+        failures += run7();\n+        failures += run8();\n+        failures += run9();\n+        if (failures != 0) {\n+            throw new RuntimeException(\"Had test failures: \" + failures);\n+        }\n+    }\n+\n+    static public int run1() {\n+        int size = 10;\n+        double[] arr1 = new double[size];\n+        double[] arr2 = new double[size];\n+        test1(arr1, arr2);\n+\n+        double sum = 0;\n+        for (int i = 0; i < arr1.length; ++i) {\n+            sum += arr1[i] - arr2[i];\n+        }\n+\n+        if (sum != (double)(size)) {\n+            System.out.println(\"test1: wrong result: \" + sum + \" vs expected: \" + size);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ Simplified from JDK-8327012 regression test.\n+    public static void test1(double[] arr1, double[] arr2) {\n+        for(int i = 0; i < arr1.length; ++i) {\n+            \/\/ stores on double[] slice\n+            arr1[i] = (double)(i + 2);\n+            arr2[i] = (double)(i + 1);\n+            \/\/ Allocation without use: but Initialize MemBar tangles the rawptr and double[] slices\n+            double[] tmp = new double[100];\n+            \/\/ When the Initialize MemBar is removed, the rawptr slice sees that there is no effect\n+            \/\/ and takes the initial state. The double[] slice is hooked on to the rawptr slice, and\n+            \/\/ also thinks it has the initial state, ignoring the double[] stores above.\n+        }\n+    }\n+\n+    static public int run2() {\n+        int size = 10;\n+        double[] arr1 = new double[size];\n+        test2(arr1);\n+\n+        double sum = 0;\n+        for(int i = 0; i < arr1.length; ++i) {\n+            sum += arr1[i];\n+        }\n+\n+        if (sum != (double)(size)) {\n+            System.out.println(\"test2: wrong result: \" + sum + \" vs expected: \" + size);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ Simplified from test1\n+    public static void test2(double[] arr1) {\n+        for(int i = 0; i < arr1.length; ++i) {\n+            arr1[i] = 1;\n+            double[] tmp = new double[100];\n+        }\n+    }\n+\n+    static public int run3() {\n+        int size = 10;\n+        int[] arr1 = new int[size];\n+        test3(arr1);\n+\n+        int sum = 0;\n+        for(int i = 0; i < arr1.length; ++i) {\n+            sum += arr1[i];\n+        }\n+\n+        if (sum != size) {\n+            System.out.println(\"test3: wrong result: \" + sum + \" vs expected: \" + size);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ Modified from test2\n+    public static void test3(int[] arr1) {\n+        for(int i = 0; i < arr1.length; ++i) {\n+            arr1[i] = 1;\n+            int[] tmp = new int[100];\n+        }\n+    }\n+\n+    \/\/ From TestIncorrectResult.java in JDK-8324739\n+    static int test4(int l2) {\n+       int[] tmp = new int[20];\n+\n+       for (int j = 0; j < l2; ++j) {\n+           tmp[j] = 42;\n+           int[] unused_but_necessary = new int[400];\n+       }\n+\n+       return tmp[0];\n+    }\n+\n+    public static int run4() {\n+        for (int i = 0; i < 100; ++i) {\n+            long res = test4(20);\n+\n+            if (res != 42) {\n+                System.out.println(\"test4: wrong result: \" + res + \" vs expected: 42\");\n+                return 1;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ From JDK-8336701\n+    static class Test5 {\n+        int[] b = new int[400];\n+        static int[] staticArray = new int[400];\n+    }\n+\n+    static void test5() {\n+        long e;\n+        for (e = 1; e < 9; ++e) {\n+            Test5.staticArray[(int) e] -= e;\n+            synchronized (new Test5()) { }\n+        }\n+        for (int f = 0; f < 10000; ++f) ;\n+    }\n+\n+    static int run5() {\n+        new Test5();\n+        for (int i = 0; i < 1000; ++i) {\n+            test5();\n+        }\n+        if (Test5.staticArray[8] != -8000) {\n+            System.out.println(\"test5: wrong result: \" + Test5.staticArray[8] + \" vs expected: -8000\");\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ From JDK-8336293\n+    static class Test6 {\n+        static long c;\n+        static int a = 400;\n+        double[] b = new double[400];\n+    }\n+\n+    static void test6() {\n+        long d;\n+        double[] e = new double[Test6.a];\n+        for (int f = 0; f < e.length; f++)\n+            e[f] = 1.116242;\n+        d = 1;\n+        while (++d < 7)\n+            synchronized (new Test6()) { }\n+        long g = 0;\n+        for (int f = 0; f < e.length; f++)\n+            g += e[f];\n+        Test6.c += g;\n+    }\n+\n+    static int run6() {\n+        new Test6();\n+        for (int f = 0; f < 10000; ++f) {\n+            test6();\n+        }\n+        if (Test6.c != 4000000) {\n+            System.out.println(\"test6: wrong result: \" + Test6.c + \" vs expected: 4000000 \");\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ From JDK-8327868\n+    static class Test7 {\n+        static int a = 400;\n+        int[] b = new int[400];\n+        static int[] staticArray = new int[a];\n+    }\n+\n+    static int test7() {\n+        int l, d = 3;\n+        for (l = 2; 58 > l; l++) {\n+            for (int e = 2; e < 8; e += 2)\n+                for (int f = 1; f < e; f += 2)\n+                    synchronized (new Test7()) {\n+                    }\n+            do\n+                ; while (d < 2);\n+            int g = 0;\n+            do\n+                g++;\n+            while (g < 20000);\n+            Test7.staticArray[1] -= 3023399;\n+        }\n+        int h = 0;\n+        for (int i = 0; i < Test7.staticArray.length; i++)\n+            h += Test7.staticArray[i];\n+        return h;\n+    }\n+\n+    static int run7() {\n+        new Test7();\n+        int res = test7();\n+        if (res != -169310344) {\n+            System.out.println(\"test7: wrong result: \" + res + \" vs expected: -169310344\");\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ from JDK-8329984\n+    static class Test8 {\n+        static int a = 400;\n+        int[] e = new int[400];\n+    }\n+\n+    static int test8() {\n+        int i = 22738;\n+        int b;\n+        int h;\n+        int[] c = new int[Test8.a];\n+        for (b = 3; b < 273; b++) {\n+            h = 1;\n+            while (++h < 97) switch (b % 6 + 56) {\n+                case 56:\n+                    c[1] = i;\n+                case 57:\n+                    synchronized (new Test8()) {}\n+            }\n+        }\n+        int k = 0;\n+        for (int j = 0; j < c.length; j++) k += c[j];\n+        return k;\n+    }\n+\n+    public static int run8() {\n+        new Test8();\n+        for (int i = 0; i < 20; i++) {\n+            int res = test8();\n+            if (res != 22738) {\n+                System.out.println(\"test8: wrong result: \" + res + \" vs expected: 22738\");\n+                return 1;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ from JDK-8341009\n+   static class Test9 {\n+        static int a = 256;\n+        float[] b = new float[256];\n+        static long c;\n+    }\n+\n+  static void test9() {\n+    for (int f = 0; f < 10000; ++f) ;\n+    float[][] g = new float[Test9.a][Test9.a];\n+    for (int d = 7; d < 16; d++) {\n+      long e = 1;\n+      do {\n+        g[d][(int) e] = d;\n+        synchronized (new Test9()) {\n+        }\n+      } while (++e < 5);\n+    }\n+    for (int i = 0; i < Test9.a; ++i) {\n+      for (int j = 0; j < Test9.a ; ++j) {\n+          Test9.c += g[i][j];\n+      }\n+    }\n+  }\n+\n+  static int run9() {\n+    for (int j = 6; 116 > j; ++j) {\n+        test9();\n+    }\n+    if (Test9.c != 43560) {\n+        System.out.println(\"test9: wrong result: \" + Test9.c + \" vs expected: 43560\");\n+        return 1;\n+    }\n+    return 0;\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/macronodes\/TestEliminationOfAllocationWithoutUse.java","additions":338,"deletions":0,"binary":false,"changes":338,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327012 8327963\n+ * @summary Test that initializing store gets captured, i.e. moved before the InitializeNode\n+ *          and made into a raw-store.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.macronodes.TestInitializingStoreCapturing\n+ *\/\n+\n+package compiler.macronodes;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestInitializingStoreCapturing {\n+\n+    static class A {\n+        float value;\n+        A(float v) { value = v; }\n+    };\n+\n+    static public void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_F, \"= 0\"})\n+    static A testInitializeField() {\n+        return new A(4.2f);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_F, \"= 0\"})\n+    static float[] testInitializeArray() {\n+        return new float[] {4.2f};\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/macronodes\/TestInitializingStoreCapturing.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"}]}