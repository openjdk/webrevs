{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -410,3 +410,0 @@\n-  \/\/ To call this, one must have the MultiArray_lock held, but the _klasses list still has lock free reads.\n-  assert_locked_or_safepoint(MultiArray_lock);\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -861,0 +861,1 @@\n+  assert(!THREAD->owns_locks(), \"allocating metaspace while holding mutex\");\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,4 +133,2 @@\n-    ResourceMark rm(THREAD);\n-    {\n-      \/\/ Ensure atomic creation of higher dimensions\n-      MutexLocker mu(THREAD, MultiArray_lock);\n+    \/\/ Ensure atomic creation of higher dimensions\n+    RecursiveLocker rl(MultiArray_lock, THREAD);\n@@ -138,5 +136,3 @@\n-      \/\/ Check if another thread beat us\n-      if (higher_dimension() == nullptr) {\n-\n-        \/\/ Create multi-dim klass object and link them together\n-        ObjArrayKlass* ak =\n+    if (higher_dimension() == nullptr) {\n+      \/\/ Create multi-dim klass object and link them together\n+      ObjArrayKlass* ak =\n@@ -144,5 +140,3 @@\n-        ak->set_lower_dimension(this);\n-        \/\/ use 'release' to pair with lock-free load\n-        release_set_higher_dimension(ak);\n-        assert(ak->is_objArray_klass(), \"incorrect initialization of ObjArrayKlass\");\n-      }\n+      \/\/ use 'release' to pair with lock-free load\n+      release_set_higher_dimension(ak);\n+      assert(ak->lower_dimension() == this, \"lower dimension mismatch\");\n@@ -152,1 +146,2 @@\n-  ObjArrayKlass *ak = higher_dimension();\n+  ObjArrayKlass* ak = higher_dimension();\n+  assert(ak != nullptr, \"should be set\");\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1548,12 +1548,9 @@\n-    ResourceMark rm(THREAD);\n-    JavaThread *jt = THREAD;\n-    {\n-      \/\/ Atomic creation of array_klasses\n-      MutexLocker ma(THREAD, MultiArray_lock);\n-\n-      \/\/ Check if update has already taken place\n-      if (array_klasses() == nullptr) {\n-        ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);\n-        \/\/ use 'release' to pair with lock-free load\n-        release_set_array_klasses(k);\n-      }\n+\n+    \/\/ Recursively lock array allocation\n+    RecursiveLocker rl(MultiArray_lock, THREAD);\n+\n+    \/\/ Check if another thread created the array klass while we were waiting for the lock.\n+    if (array_klasses() == nullptr) {\n+      ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);\n+      \/\/ use 'release' to pair with lock-free load\n+      release_set_array_klasses(k);\n@@ -1562,0 +1559,1 @@\n+\n@@ -1563,2 +1561,3 @@\n-  ObjArrayKlass* oak = array_klasses();\n-  return oak->array_klass(n, THREAD);\n+  ObjArrayKlass* ak = array_klasses();\n+  assert(ak != nullptr, \"should be set\");\n+  return ak->array_klass(n, THREAD);\n@@ -2765,1 +2764,1 @@\n-    MutexLocker ml(MultiArray_lock);\n+    RecursiveLocker rl(MultiArray_lock, THREAD);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,1 @@\n+    assert(MultiArray_lock->holds_lock(THREAD), \"must hold lock after bootstrapping\");\n@@ -66,2 +67,0 @@\n-      super_klass = element_super->array_klass_or_null();\n-      bool supers_exist = super_klass != nullptr;\n@@ -69,1 +68,2 @@\n-      \/\/ We need an array type for each.\n+      \/\/ We need an array type for each before creating this array type.\n+      super_klass = element_super->array_klass(CHECK_NULL);\n@@ -71,1 +71,1 @@\n-      for( int i = element_supers->length()-1; i >= 0; i-- ) {\n+      for (int i = element_supers->length() - 1; i >= 0; i--) {\n@@ -73,19 +73,1 @@\n-        if (elem_super->array_klass_or_null() == nullptr) {\n-          supers_exist = false;\n-          break;\n-        }\n-      }\n-      if (!supers_exist) {\n-        \/\/ Oops.  Not allocated yet.  Back out, allocate it, and retry.\n-        Klass* ek = nullptr;\n-        {\n-          MutexUnlocker mu(MultiArray_lock);\n-          super_klass = element_super->array_klass(CHECK_NULL);\n-          for( int i = element_supers->length()-1; i >= 0; i-- ) {\n-            Klass* elem_super = element_supers->at(i);\n-            elem_super->array_klass(CHECK_NULL);\n-          }\n-          \/\/ Now retry from the beginning\n-          ek = element_klass->array_klass(n, CHECK_NULL);\n-        }  \/\/ re-lock\n-        return ObjArrayKlass::cast(ek);\n+        elem_super->array_klass(CHECK_NULL);\n@@ -93,0 +75,1 @@\n+      \/\/ Fall through because inheritance is acyclic and we hold the global recursive lock to allocate all the arrays.\n@@ -153,0 +136,4 @@\n+  if (element_klass->is_array_klass()) {\n+    set_lower_dimension(ArrayKlass::cast(element_klass));\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":11,"deletions":24,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -3149,3 +3149,0 @@\n-  if (MultiArray_lock->owner() == thread) {\n-    return false;\n-  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,4 +105,0 @@\n-    \/\/ To get a consistent list of classes we need MultiArray_lock to ensure\n-    \/\/ array classes aren't created.\n-    MutexLocker ma(MultiArray_lock);\n-\n@@ -125,2 +121,3 @@\n-    \/\/ array classes aren't created during this walk.\n-    MutexLocker ma(MultiArray_lock);\n+    \/\/ array classes aren't created by another thread during this walk. This walks through the\n+    \/\/ InstanceKlass::_array_klasses links.\n+    RecursiveLocker ma(MultiArray_lock, Thread::current());\n","filename":"src\/hotspot\/share\/prims\/jvmtiGetLoadedClasses.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include \"runtime\/semaphore.inline.hpp\"\n@@ -525,0 +526,30 @@\n+\n+\n+RecursiveMutex::RecursiveMutex() : _sem(1), _owner(nullptr), _recursions(0) {}\n+\n+void RecursiveMutex::lock(Thread* current) {\n+  assert(current == Thread::current(), \"must be current thread\");\n+  if (current == _owner) {\n+    _recursions++;\n+  } else {\n+    \/\/ can be called by jvmti by VMThread.\n+    if (current->is_Java_thread()) {\n+      _sem.wait_with_safepoint_check(JavaThread::cast(current));\n+    } else {\n+      _sem.wait();\n+    }\n+    _recursions++;\n+    assert(_recursions == 1, \"should be\");\n+    _owner = current;\n+  }\n+}\n+\n+void RecursiveMutex::unlock(Thread* current) {\n+  assert(current == Thread::current(), \"must be current thread\");\n+  assert(current == _owner, \"must be owner\");\n+  _recursions--;\n+  if (_recursions == 0) {\n+    _owner = nullptr;\n+    _sem.signal();\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/semaphore.hpp\"\n@@ -244,0 +245,20 @@\n+\/\/ RecursiveMutex is a minimal implementation, and has no safety and rank checks that Mutex has.\n+\/\/ There are also no checks that the recursive lock is not held when going to Java or to JNI, like\n+\/\/ other JVM mutexes have.  This should be used only for cases where the alternatives with all the\n+\/\/ nice safety features don't work.\n+\/\/ Waiting on the RecursiveMutex partipates in the safepoint protocol if the current thread is a Java thread,\n+\/\/ (ie. waiting sets JavaThread to blocked)\n+class RecursiveMutex : public CHeapObj<mtThread> {\n+  Semaphore  _sem;\n+  Thread*    _owner;\n+  int        _recursions;\n+\n+  NONCOPYABLE(RecursiveMutex);\n+ public:\n+  RecursiveMutex();\n+  void lock(Thread* current);\n+  void unlock(Thread* current);\n+  \/\/ For use in asserts\n+  bool holds_lock(Thread* current) { return _owner == current; }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,0 @@\n-Mutex*   MultiArray_lock              = nullptr;\n@@ -159,0 +158,2 @@\n+\/\/ Only one RecursiveMutex\n+RecursiveMutex* MultiArray_lock       = nullptr;\n@@ -272,1 +273,0 @@\n-  MUTEX_DEFN(MultiArray_lock                 , PaddedMutex  , safepoint);\n@@ -286,0 +286,1 @@\n+  MUTEX_DEFN(ClassLoaderDataGraph_lock       , PaddedMutex  , safepoint);\n@@ -337,1 +338,0 @@\n-  MUTEX_DEFL(ClassLoaderDataGraph_lock      , PaddedMutex  , MultiArray_lock);\n@@ -360,0 +360,3 @@\n+\n+  \/\/ Allocate RecursiveMutex\n+  MultiArray_lock = new RecursiveMutex();\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,0 @@\n-extern Mutex*   MultiArray_lock;                 \/\/ a lock used to guard allocation of multi-dim arrays\n@@ -335,0 +334,17 @@\n+\/\/ Instance of a RecursiveLock that may be held through Java heap allocation, which may include calls to Java,\n+\/\/ and JNI event notification for resource exhaustion for metaspace or heap.\n+extern RecursiveMutex* MultiArray_lock;\n+\n+\/\/ RAII locker for a RecursiveMutex.  See comments in mutex.hpp for more information.\n+class RecursiveLocker {\n+  RecursiveMutex* _lock;\n+  Thread*         _thread;\n+ public:\n+  RecursiveLocker(RecursiveMutex* lock, Thread* current) : _lock(lock), _thread(current) {\n+    _lock->lock(_thread);\n+  }\n+  ~RecursiveLocker() {\n+    _lock->unlock(_thread);\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"}]}