{"files":[{"patch":"@@ -90,1 +90,1 @@\n-    public record ClassHierarchyInfo(ClassDesc thisClass, boolean isInterface, ClassDesc superClass) {\n+    record ClassHierarchyInfo(ClassDesc thisClass, boolean isInterface, ClassDesc superClass) {\n@@ -100,1 +100,1 @@\n-    public static ClassHierarchyResolver ofCached(Function<ClassDesc, InputStream> classStreamResolver) {\n+    static ClassHierarchyResolver ofCached(Function<ClassDesc, InputStream> classStreamResolver) {\n@@ -112,1 +112,1 @@\n-    public static ClassHierarchyResolver of(Collection<ClassDesc> interfaces,\n+    static ClassHierarchyResolver of(Collection<ClassDesc> interfaces,\n@@ -139,2 +139,3 @@\n-     * the Reflection API with a {@linkplain MethodHandles.Lookup Lookup}. The classes\n-     * resolved must be accessible to this given lookup.\n+     * the Reflection API with a {@linkplain MethodHandles.Lookup Lookup}. If the class\n+     * resolved is inaccessible to the given lookup, it throws {@link\n+     * IllegalArgumentException} instead of returning {@code null}.\n@@ -151,0 +152,2 @@\n+                } catch (IllegalAccessException ex) {\n+                    throw new IllegalArgumentException(ex);\n@@ -152,1 +155,0 @@\n-                    \/\/ Should we handle IllegalAccessException differently?\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassHierarchyResolver.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import java.util.stream.Stream;\n+\n@@ -110,1 +112,1 @@\n-                .flatMap(ce -> ce instanceof MethodMethod mm ? mm.elementStream() : Stream.empty())\n+                .flatMap(ce -> ce instanceof MethodModel mm ? mm.elementStream() : Stream.empty())\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/snippet-files\/PackageSnippets.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -113,0 +113,7 @@\n+    @Test\n+    void testLookupResolver_IllegalAccess() throws Exception {\n+        \/\/ A lookup from this test class, cannot access nested classes in HashMap\n+        var lookup = MethodHandles.lookup();\n+        assertThrows(IllegalArgumentException.class, () -> transformAndVerify(ClassHierarchyResolver.of(lookup)));\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/ClassHierarchyInfoTest.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}