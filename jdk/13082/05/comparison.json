{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -30,0 +31,1 @@\n+import java.util.HashMap;\n@@ -31,0 +33,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -32,0 +35,2 @@\n+import java.util.function.Supplier;\n+\n@@ -49,2 +54,3 @@\n-            = new ClassHierarchyImpl.CachedClassHierarchyResolver(\n-            new Function<ClassDesc, InputStream>() {\n+            = ofCached(ofParsing(ClassLoader.getSystemClassLoader())\n+                    .orElse(ofReflection(ClassLoader.getSystemClassLoader())),\n+            new Supplier<Map<ClassDesc, ClassHierarchyInfo>>() {\n@@ -52,2 +58,2 @@\n-                public InputStream apply(ClassDesc classDesc) {\n-                    return ClassLoader.getSystemResourceAsStream(Util.toInternalName(classDesc) + \".class\");\n+                public Map<ClassDesc, ClassHierarchyInfo> get() {\n+                    return new ConcurrentHashMap<>();\n@@ -89,1 +95,1 @@\n-    public record ClassHierarchyInfo(ClassDesc thisClass, boolean isInterface, ClassDesc superClass) {\n+    record ClassHierarchyInfo(ClassDesc thisClass, boolean isInterface, ClassDesc superClass) {\n@@ -93,2 +99,40 @@\n-     * Returns a {@linkplain  ClassHierarchyResolver} that extracts class hierarchy\n-     * information from classfiles located by a mapping function\n+     * Returns a ClassHierarchyResolver that caches class hierarchy information from another\n+     * resolver. The returned resolver will not update if delegate resolver returns differently.\n+     * The returned resolver is not thread-safe.\n+     * {@snippet file=\"PackageSnippets.java\" region=\"lookup-class-hierarchy-resolver\"}\n+     *\n+     * @param delegate the resolver to pull information from\n+     * @return the ClassHierarchyResolver\n+     *\/\n+    static ClassHierarchyResolver ofCached(ClassHierarchyResolver delegate) {\n+        class Factory implements Supplier<Map<ClassDesc, ClassHierarchyInfo>> {\n+            static final Factory INSTANCE = new Factory();\n+\n+            @Override\n+            public Map<ClassDesc, ClassHierarchyInfo> get() {\n+                return new HashMap<>();\n+            }\n+        }\n+        return ofCached(delegate, Factory.INSTANCE);\n+    }\n+\n+    \/**\n+     * Returns a ClassHierarchyResolver that caches class hierarchy information from another\n+     * resolver. The returned resolver will not update if delegate resolver returns differently.\n+     * The thread safety of the returned resolver depends on the thread safety of the map\n+     * returned by the {@code cacheFactory}.\n+     *\n+     * @param delegate the resolver to pull information from\n+     * @param cacheFactory the factory for the cache\n+     * @return the ClassHierarchyResolver\n+     *\/\n+    static ClassHierarchyResolver ofCached(ClassHierarchyResolver delegate,\n+                                           Supplier<Map<ClassDesc, ClassHierarchyInfo>> cacheFactory) {\n+        return new ClassHierarchyImpl.CachedClassHierarchyResolver(delegate, cacheFactory.get());\n+    }\n+\n+    \/**\n+     * Returns a {@linkplain ClassHierarchyResolver} that extracts class hierarchy\n+     * information from classfiles located by a mapping function. The mapping function\n+     * should return null if it cannot provide a mapping for a classfile. Any IOException\n+     * from the provided input stream is rethrown as an UncheckedIOException.\n@@ -99,2 +143,18 @@\n-    public static ClassHierarchyResolver ofCached(Function<ClassDesc, InputStream> classStreamResolver) {\n-        return new ClassHierarchyImpl.CachedClassHierarchyResolver(classStreamResolver);\n+    static ClassHierarchyResolver ofParsing(Function<ClassDesc, InputStream> classStreamResolver) {\n+        return new ClassHierarchyImpl.ParsingClassHierarchyResolver(classStreamResolver);\n+    }\n+\n+    \/**\n+     * Returns a {@linkplain ClassHierarchyResolver} that extracts class hierarchy\n+     * information from classfiles located by a class loader.\n+     *\n+     * @param loader the class loader, to find class files\n+     * @return the {@linkplain ClassHierarchyResolver}\n+     *\/\n+    static ClassHierarchyResolver ofParsing(ClassLoader loader) {\n+        return ofParsing(new Function<ClassDesc, InputStream>() {\n+            @Override\n+            public InputStream apply(ClassDesc classDesc) {\n+                return loader.getResourceAsStream(Util.toInternalName(classDesc) + \".class\");\n+            }\n+        });\n@@ -111,1 +171,1 @@\n-    public static ClassHierarchyResolver of(Collection<ClassDesc> interfaces,\n+    static ClassHierarchyResolver of(Collection<ClassDesc> interfaces,\n@@ -115,0 +175,44 @@\n+\n+    \/**\n+     * Returns a ClassHierarchyResolver that extracts class hierarchy information via\n+     * the Reflection API with a {@linkplain ClassLoader}.\n+     *\n+     * @param loader the class loader\n+     * @return the class hierarchy resolver\n+     *\/\n+    static ClassHierarchyResolver ofReflection(ClassLoader loader) {\n+        return new ClassHierarchyImpl.ReflectionClassHierarchyResolver() {\n+            @Override\n+            protected Class<?> resolve(ClassDesc cd) {\n+                try {\n+                    return Class.forName(Util.toBinaryName(cd.descriptorString()), false, loader);\n+                } catch (ClassNotFoundException ex) {\n+                    return null;\n+                }\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Returns a ClassHierarchyResolver that extracts class hierarchy information via\n+     * the Reflection API with a {@linkplain MethodHandles.Lookup Lookup}. If the class\n+     * resolved is inaccessible to the given lookup, it throws {@link\n+     * IllegalArgumentException} instead of returning {@code null}.\n+     *\n+     * @param lookup the lookup, must be able to access classes to resolve\n+     * @return the class hierarchy resolver\n+     *\/\n+    static ClassHierarchyResolver ofReflection(MethodHandles.Lookup lookup) {\n+        return new ClassHierarchyImpl.ReflectionClassHierarchyResolver() {\n+            @Override\n+            protected Class<?> resolve(ClassDesc cd) {\n+                try {\n+                    return (Class<?>) cd.resolveConstantDesc(lookup);\n+                } catch (IllegalAccessException ex) {\n+                    throw new IllegalArgumentException(ex);\n+                } catch (ReflectiveOperationException ex) {\n+                    return null;\n+                }\n+            }\n+        };\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassHierarchyResolver.java","additions":115,"deletions":11,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -29,0 +30,1 @@\n+import java.io.UncheckedIOException;\n@@ -32,1 +34,0 @@\n-import java.util.Collections;\n@@ -39,0 +40,2 @@\n+import static jdk.internal.classfile.Classfile.*;\n+\n@@ -104,2 +107,1 @@\n-\n-        \/\/this instance should never appear in the cache nor leak out\n+        \/\/this instance should leak out, appears only in cache in order to utilize Map.computeIfAbsent\n@@ -109,0 +111,22 @@\n+        private final ClassHierarchyResolver delegate;\n+        private final Map<ClassDesc, ClassHierarchyInfo> resolvedCache;\n+\n+        public CachedClassHierarchyResolver(ClassHierarchyResolver delegate, Map<ClassDesc, ClassHierarchyInfo> resolvedCache) {\n+            this.delegate = delegate;\n+            this.resolvedCache = resolvedCache;\n+        }\n+\n+        @Override\n+        public ClassHierarchyInfo getClassInfo(ClassDesc classDesc) {\n+            var ret = resolvedCache.computeIfAbsent(classDesc, new Function<ClassDesc, ClassHierarchyInfo>() {\n+                @Override\n+                public ClassHierarchyInfo apply(ClassDesc classDesc) {\n+                    var ret = delegate.getClassInfo(classDesc);\n+                    return ret == null ? NOPE : ret;\n+                }\n+            });\n+            return ret == NOPE ? null : ret;\n+        }\n+    }\n+\n+    public static final class ParsingClassHierarchyResolver implements ClassHierarchyResolver {\n@@ -110,1 +134,0 @@\n-        private final Map<ClassDesc, ClassHierarchyResolver.ClassHierarchyInfo> resolvedCache;\n@@ -112,1 +135,1 @@\n-        public CachedClassHierarchyResolver(Function<ClassDesc, InputStream> classStreamProvider) {\n+        public ParsingClassHierarchyResolver(Function<ClassDesc, InputStream> classStreamProvider) {\n@@ -114,1 +137,0 @@\n-            this.resolvedCache = Collections.synchronizedMap(new HashMap<>());\n@@ -123,32 +145,19 @@\n-            \/\/using NOPE to distinguish between null value and non-existent record in the cache\n-            \/\/this code is on JDK bootstrap critical path, so cannot use lambdas here\n-            var res = resolvedCache.getOrDefault(classDesc, NOPE);\n-            if (res == NOPE) {\n-                res = null;\n-                var ci = streamProvider.apply(classDesc);\n-                if (ci != null) {\n-                    try (var in = new DataInputStream(new BufferedInputStream(ci))) {\n-                        in.skipBytes(8);\n-                        int cpLength = in.readUnsignedShort();\n-                        String[] cpStrings = new String[cpLength];\n-                        int[] cpClasses = new int[cpLength];\n-                        for (int i=1; i<cpLength; i++) {\n-                            switch (in.readUnsignedByte()) {\n-                                case 1 -> cpStrings[i] = in.readUTF();\n-                                case 7 -> cpClasses[i] = in.readUnsignedShort();\n-                                case 8, 16, 19, 20 -> in.skipBytes(2);\n-                                case 15 -> in.skipBytes(3);\n-                                case 3, 4, 9, 10, 11, 12, 17, 18 -> in.skipBytes(4);\n-                                case 5, 6 -> {in.skipBytes(8); i++;}\n-                            }\n-                        }\n-                        boolean isInterface = (in.readUnsignedShort() & 0x0200) != 0;\n-                        in.skipBytes(2);\n-                        int superIndex = in.readUnsignedShort();\n-                        var superClass = superIndex > 0 ? ClassDesc.ofInternalName(cpStrings[cpClasses[superIndex]]) : null;\n-                        res = new ClassHierarchyInfo(classDesc, isInterface, superClass);\n-                        int interfCount = in.readUnsignedShort();\n-                        for (int i=0; i<interfCount; i++) {\n-                            \/\/all listed interfaces are cached without resolution\n-                            var intDesc = ClassDesc.ofInternalName(cpStrings[cpClasses[in.readUnsignedShort()]]);\n-                            resolvedCache.put(intDesc, new ClassHierarchyResolver.ClassHierarchyInfo(intDesc, true, null));\n+            var ci = streamProvider.apply(classDesc);\n+            if (ci == null) return null;\n+            try (var in = new DataInputStream(new BufferedInputStream(ci))) {\n+                in.skipBytes(8);\n+                int cpLength = in.readUnsignedShort();\n+                String[] cpStrings = new String[cpLength];\n+                int[] cpClasses = new int[cpLength];\n+                for (int i = 1; i < cpLength; i++) {\n+                    int tag;\n+                    switch (tag = in.readUnsignedByte()) {\n+                        case TAG_UTF8 -> cpStrings[i] = in.readUTF();\n+                        case TAG_CLASS -> cpClasses[i] = in.readUnsignedShort();\n+                        case TAG_STRING, TAG_METHODTYPE, TAG_MODULE, TAG_PACKAGE -> in.skipBytes(2);\n+                        case TAG_METHODHANDLE -> in.skipBytes(3);\n+                        case TAG_INTEGER, TAG_FLOAT, TAG_FIELDREF, TAG_METHODREF, TAG_INTERFACEMETHODREF,\n+                                TAG_NAMEANDTYPE, TAG_CONSTANTDYNAMIC, TAG_INVOKEDYNAMIC -> in.skipBytes(4);\n+                        case TAG_LONG, TAG_DOUBLE -> {\n+                            in.skipBytes(8);\n+                            i++;\n@@ -156,2 +165,1 @@\n-                    } catch (Exception ignore) {\n-                        \/\/ignore\n+                        default -> throw new IllegalStateException(\"Bad tag (\" + tag + \") at index (\" + i + \")\");\n@@ -160,2 +168,7 @@\n-                \/\/null ClassHierarchyInfo value is also cached to avoid repeated resolution attempts\n-                resolvedCache.put(classDesc, res);\n+                boolean isInterface = (in.readUnsignedShort() & ACC_INTERFACE) != 0;\n+                in.skipBytes(2);\n+                int superIndex = in.readUnsignedShort();\n+                var superClass = superIndex > 0 ? ClassDesc.ofInternalName(cpStrings[cpClasses[superIndex]]) : null;\n+                return new ClassHierarchyInfo(classDesc, isInterface, superClass);\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n@@ -163,1 +176,0 @@\n-            return res;\n@@ -188,0 +200,18 @@\n+\n+    public abstract static class ReflectionClassHierarchyResolver implements ClassHierarchyResolver {\n+\n+        @Override\n+        public ClassHierarchyInfo getClassInfo(ClassDesc cd) {\n+            if (!cd.isClassOrInterface())\n+                return null;\n+            var cl = resolve(cd);\n+            if (cl == null) {\n+                return null;\n+            }\n+            var sup = cl.getSuperclass();\n+            return new ClassHierarchyInfo(cd, cl.isInterface(),\n+                    sup == null ? null : ClassDesc.of(sup.getName()));\n+        }\n+\n+        protected abstract Class<?> resolve(ClassDesc cd);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl.java","additions":74,"deletions":44,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,3 +117,20 @@\n-    public static String toClassString(String desc) {\n-        \/\/TODO: this doesn't look right L ... ;\n-        return desc.replace('\/', '.');\n+    \/**\n+     * Convert a descriptor of classes or interfaces or arrays, or an internal\n+     * name of a class or interface, into a fully qualified binary name, that can\n+     * be resolved by {@link Class#forName(String) Class::forName}. Primitive type\n+     * descriptors should never be passed into this method.\n+     *\n+     * @param descOrInternalName a descriptor or internal name\n+     * @return the fully qualified binary name\n+     *\/\n+    public static String toBinaryName(String descOrInternalName) {\n+        if (descOrInternalName.startsWith(\"L\")) {\n+            \/\/ descriptors of classes or interfaces\n+            if (descOrInternalName.length() <= 2 || !descOrInternalName.endsWith(\";\")) {\n+                throw new IllegalArgumentException(descOrInternalName);\n+            }\n+            return descOrInternalName.substring(1, descOrInternalName.length() - 1).replace('\/', '.');\n+        } else {\n+            \/\/ arrays, classes or interfaces' internal names\n+            return descOrInternalName.replace('\/', '.');\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -36,0 +37,2 @@\n+import java.util.stream.Stream;\n+\n@@ -37,0 +40,1 @@\n+import jdk.internal.classfile.ClassHierarchyResolver;\n@@ -110,1 +114,1 @@\n-                .flatMap(ce -> ce instanceof MethodMethod mm ? mm.elementStream() : Stream.empty())\n+                .flatMap(ce -> ce instanceof MethodModel mm ? mm.elementStream() : Stream.empty())\n@@ -306,0 +310,7 @@\n+\n+    void resolverExample() {\n+        \/\/ @start region=\"lookup-class-hierarchy-resolver\"\n+        MethodHandles.Lookup lookup = MethodHandles.lookup(); \/\/ @replace regex=\"MethodHandles\\.lookup\\(\\)\" replacement=\"...\"\n+        ClassHierarchyResolver resolver = ClassHierarchyResolver.ofCached(ClassHierarchyResolver.ofReflection(lookup));\n+        \/\/ @end\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/snippet-files\/PackageSnippets.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,12 @@\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.impl\n+ *          java.base\/jdk.internal.classfile.impl.verifier\n+ *          java.base\/jdk.internal.classfile.java.lang.constant\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.util\n+ *          java.base\/java.util:open\n+ * @comment Opens java.util so HashMap bytecode generation can access its nested\n+ *          classes with a proper Lookup object\n@@ -34,0 +46,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -38,0 +51,1 @@\n+import java.util.HashMap;\n@@ -68,1 +82,1 @@\n-    void testBreakDefaulClassHierarchy() throws Exception {\n+    void testBreakDefaultClassHierarchy() throws Exception {\n@@ -79,1 +93,1 @@\n-        transformAndVerify(ClassHierarchyResolver.ofCached(classDesc -> {\n+        transformAndVerify(ClassHierarchyResolver.ofParsing(classDesc -> {\n@@ -88,0 +102,24 @@\n+    @Test\n+    void testClassLoaderParsingResolver() throws Exception {\n+        transformAndVerify(ClassHierarchyResolver.ofParsing(ClassLoader.getSystemClassLoader()));\n+    }\n+\n+    @Test\n+    void testClassLoaderReflectionResolver() throws Exception {\n+        transformAndVerify(ClassHierarchyResolver.ofReflection(ClassLoader.getSystemClassLoader()));\n+    }\n+\n+    @Test\n+    void testLookupResolver() throws Exception {\n+        \/\/ A lookup must be able to access all the classes involved in the class file generation\n+        var privilegedLookup = MethodHandles.privateLookupIn(HashMap.class, MethodHandles.lookup());\n+        transformAndVerify(ClassHierarchyResolver.ofReflection(privilegedLookup));\n+    }\n+\n+    @Test\n+    void testLookupResolver_IllegalAccess() throws Exception {\n+        \/\/ A lookup from this test class, cannot access nested classes in HashMap\n+        var lookup = MethodHandles.lookup();\n+        assertThrows(IllegalArgumentException.class, () -> transformAndVerify(ClassHierarchyResolver.ofReflection(lookup)));\n+    }\n+\n@@ -89,0 +127,5 @@\n+        transformAndVerifySingle(res);\n+        transformAndVerifySingle(ClassHierarchyResolver.ofCached(res));\n+    }\n+\n+    void transformAndVerifySingle(ClassHierarchyResolver res) throws Exception {\n@@ -106,1 +149,6 @@\n-        if (!errors.isEmpty()) throw errors.iterator().next();\n+        if (!errors.isEmpty()) {\n+            var itr = errors.iterator();\n+            var thrown = itr.next();\n+            itr.forEachRemaining(thrown::addSuppressed);\n+            throw thrown;\n+        }\n","filename":"test\/jdk\/jdk\/classfile\/ClassHierarchyInfoTest.java","additions":52,"deletions":4,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -40,0 +42,19 @@\n+    @ParameterizedTest\n+    @ValueSource(classes = {\n+            Long.class,\n+            Object.class,\n+            Util.class,\n+            Test.class,\n+            int[][].class,\n+            Object[].class,\n+    })\n+    void testDescToBinaryName(Class<?> type) throws ReflectiveOperationException {\n+        if (!type.isArray()) {\n+            \/\/ Test internal name\n+            var internal = type.getName().replace('.', '\/');\n+            assertEquals(type, Class.forName(Util.toBinaryName(internal)));\n+        }\n+        \/\/ Test descriptor\n+        assertEquals(type, Class.forName(Util.toBinaryName(type.descriptorString())));\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/UtilTest.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"}]}