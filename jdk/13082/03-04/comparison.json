{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.util.HashMap;\n@@ -32,0 +33,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -33,0 +35,2 @@\n+import java.util.function.Supplier;\n+\n@@ -50,2 +54,3 @@\n-            = new ClassHierarchyImpl.CachedClassHierarchyResolver(\n-            new Function<ClassDesc, InputStream>() {\n+            = ofCached(ofParsing(ClassLoader.getSystemClassLoader())\n+                    .orElse(ofReflection(ClassLoader.getSystemClassLoader())),\n+            new Supplier<Map<ClassDesc, ClassHierarchyInfo>>() {\n@@ -53,2 +58,2 @@\n-                public InputStream apply(ClassDesc classDesc) {\n-                    return ClassLoader.getSystemResourceAsStream(Util.toInternalName(classDesc) + \".class\");\n+                public Map<ClassDesc, ClassHierarchyInfo> get() {\n+                    return new ConcurrentHashMap<>();\n@@ -56,1 +61,1 @@\n-            }).orElse(of(ClassLoader.getSystemClassLoader()));\n+            });\n@@ -94,2 +99,40 @@\n-     * Returns a {@linkplain  ClassHierarchyResolver} that extracts class hierarchy\n-     * information from classfiles located by a mapping function\n+     * Returns a ClassHierarchyResolver that caches class hierarchy information from another\n+     * resolver. The returned resolver will not update if delegate resolver returns differently.\n+     * The returned resolver is not thread-safe.\n+     * {@snippet file=\"PackageSnippets.java\" region=\"lookup-class-hierarchy-resolver\"}\n+     *\n+     * @param delegate the resolver to pull information from\n+     * @return the ClassHierarchyResolver\n+     *\/\n+    static ClassHierarchyResolver ofCached(ClassHierarchyResolver delegate) {\n+        class Factory implements Supplier<Map<ClassDesc, ClassHierarchyInfo>> {\n+            static final Factory INSTANCE = new Factory();\n+\n+            @Override\n+            public Map<ClassDesc, ClassHierarchyInfo> get() {\n+                return new HashMap<>();\n+            }\n+        }\n+        return ofCached(delegate, Factory.INSTANCE);\n+    }\n+\n+    \/**\n+     * Returns a ClassHierarchyResolver that caches class hierarchy information from another\n+     * resolver. The returned resolver will not update if delegate resolver returns differently.\n+     * The thread safety of the returned resolver depends on the thread safety of the map\n+     * returned by the {@code cacheFactory}.\n+     *\n+     * @param delegate the resolver to pull information from\n+     * @param cacheFactory the factory for the cache\n+     * @return the ClassHierarchyResolver\n+     *\/\n+    static ClassHierarchyResolver ofCached(ClassHierarchyResolver delegate,\n+                                           Supplier<Map<ClassDesc, ClassHierarchyInfo>> cacheFactory) {\n+        return new ClassHierarchyImpl.CachedClassHierarchyResolver(delegate, cacheFactory.get());\n+    }\n+\n+    \/**\n+     * Returns a {@linkplain ClassHierarchyResolver} that extracts class hierarchy\n+     * information from classfiles located by a mapping function. The mapping function\n+     * should return null if it cannot provide a mapping for a classfile. Any IOException\n+     * from the provided input stream is rethrown as an UncheckedIOException.\n@@ -100,2 +143,18 @@\n-    static ClassHierarchyResolver ofCached(Function<ClassDesc, InputStream> classStreamResolver) {\n-        return new ClassHierarchyImpl.CachedClassHierarchyResolver(classStreamResolver);\n+    static ClassHierarchyResolver ofParsing(Function<ClassDesc, InputStream> classStreamResolver) {\n+        return new ClassHierarchyImpl.ParsingClassHierarchyResolver(classStreamResolver);\n+    }\n+\n+    \/**\n+     * Returns a {@linkplain ClassHierarchyResolver} that extracts class hierarchy\n+     * information from classfiles located by a class loader.\n+     *\n+     * @param loader the class loader, to find class files\n+     * @return the {@linkplain ClassHierarchyResolver}\n+     *\/\n+    static ClassHierarchyResolver ofParsing(ClassLoader loader) {\n+        return ofParsing(new Function<ClassDesc, InputStream>() {\n+            @Override\n+            public InputStream apply(ClassDesc classDesc) {\n+                return loader.getResourceAsStream(Util.toInternalName(classDesc) + \".class\");\n+            }\n+        });\n@@ -124,1 +183,1 @@\n-    static ClassHierarchyResolver of(ClassLoader loader) {\n+    static ClassHierarchyResolver ofReflection(ClassLoader loader) {\n@@ -146,1 +205,1 @@\n-    static ClassHierarchyResolver of(MethodHandles.Lookup lookup) {\n+    static ClassHierarchyResolver ofReflection(MethodHandles.Lookup lookup) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassHierarchyResolver.java","additions":70,"deletions":11,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -29,0 +30,1 @@\n+import java.io.UncheckedIOException;\n@@ -32,1 +34,0 @@\n-import java.util.Collections;\n@@ -35,1 +36,0 @@\n-import java.util.Optional;\n@@ -40,0 +40,2 @@\n+import static jdk.internal.classfile.Classfile.*;\n+\n@@ -105,2 +107,1 @@\n-\n-        \/\/this instance should never appear in the cache nor leak out\n+        \/\/this instance should leak out, appears only in cache in order to utilize Map.computeIfAbsent\n@@ -110,0 +111,22 @@\n+        private final ClassHierarchyResolver delegate;\n+        private final Map<ClassDesc, ClassHierarchyInfo> resolvedCache;\n+\n+        public CachedClassHierarchyResolver(ClassHierarchyResolver delegate, Map<ClassDesc, ClassHierarchyInfo> resolvedCache) {\n+            this.delegate = delegate;\n+            this.resolvedCache = resolvedCache;\n+        }\n+\n+        @Override\n+        public ClassHierarchyInfo getClassInfo(ClassDesc classDesc) {\n+            var ret = resolvedCache.computeIfAbsent(classDesc, new Function<ClassDesc, ClassHierarchyInfo>() {\n+                @Override\n+                public ClassHierarchyInfo apply(ClassDesc classDesc) {\n+                    var ret = delegate.getClassInfo(classDesc);\n+                    return ret == null ? NOPE : ret;\n+                }\n+            });\n+            return ret == NOPE ? null : ret;\n+        }\n+    }\n+\n+    public static final class ParsingClassHierarchyResolver implements ClassHierarchyResolver {\n@@ -111,1 +134,0 @@\n-        private final Map<ClassDesc, ClassHierarchyResolver.ClassHierarchyInfo> resolvedCache;\n@@ -113,1 +135,1 @@\n-        public CachedClassHierarchyResolver(Function<ClassDesc, InputStream> classStreamProvider) {\n+        public ParsingClassHierarchyResolver(Function<ClassDesc, InputStream> classStreamProvider) {\n@@ -115,1 +137,0 @@\n-            this.resolvedCache = Collections.synchronizedMap(new HashMap<>());\n@@ -124,32 +145,19 @@\n-            \/\/using NOPE to distinguish between null value and non-existent record in the cache\n-            \/\/this code is on JDK bootstrap critical path, so cannot use lambdas here\n-            var res = resolvedCache.getOrDefault(classDesc, NOPE);\n-            if (res == NOPE) {\n-                res = null;\n-                var ci = streamProvider.apply(classDesc);\n-                if (ci != null) {\n-                    try (var in = new DataInputStream(new BufferedInputStream(ci))) {\n-                        in.skipBytes(8);\n-                        int cpLength = in.readUnsignedShort();\n-                        String[] cpStrings = new String[cpLength];\n-                        int[] cpClasses = new int[cpLength];\n-                        for (int i=1; i<cpLength; i++) {\n-                            switch (in.readUnsignedByte()) {\n-                                case 1 -> cpStrings[i] = in.readUTF();\n-                                case 7 -> cpClasses[i] = in.readUnsignedShort();\n-                                case 8, 16, 19, 20 -> in.skipBytes(2);\n-                                case 15 -> in.skipBytes(3);\n-                                case 3, 4, 9, 10, 11, 12, 17, 18 -> in.skipBytes(4);\n-                                case 5, 6 -> {in.skipBytes(8); i++;}\n-                            }\n-                        }\n-                        boolean isInterface = (in.readUnsignedShort() & 0x0200) != 0;\n-                        in.skipBytes(2);\n-                        int superIndex = in.readUnsignedShort();\n-                        var superClass = superIndex > 0 ? ClassDesc.ofInternalName(cpStrings[cpClasses[superIndex]]) : null;\n-                        res = new ClassHierarchyInfo(classDesc, isInterface, superClass);\n-                        int interfCount = in.readUnsignedShort();\n-                        for (int i=0; i<interfCount; i++) {\n-                            \/\/all listed interfaces are cached without resolution\n-                            var intDesc = ClassDesc.ofInternalName(cpStrings[cpClasses[in.readUnsignedShort()]]);\n-                            resolvedCache.put(intDesc, new ClassHierarchyResolver.ClassHierarchyInfo(intDesc, true, null));\n+            var ci = streamProvider.apply(classDesc);\n+            if (ci == null) return null;\n+            try (var in = new DataInputStream(new BufferedInputStream(ci))) {\n+                in.skipBytes(8);\n+                int cpLength = in.readUnsignedShort();\n+                String[] cpStrings = new String[cpLength];\n+                int[] cpClasses = new int[cpLength];\n+                for (int i = 1; i < cpLength; i++) {\n+                    int tag;\n+                    switch (tag = in.readUnsignedByte()) {\n+                        case TAG_UTF8 -> cpStrings[i] = in.readUTF();\n+                        case TAG_CLASS -> cpClasses[i] = in.readUnsignedShort();\n+                        case TAG_STRING, TAG_METHODTYPE, TAG_MODULE, TAG_PACKAGE -> in.skipBytes(2);\n+                        case TAG_METHODHANDLE -> in.skipBytes(3);\n+                        case TAG_INTEGER, TAG_FLOAT, TAG_FIELDREF, TAG_METHODREF, TAG_INTERFACEMETHODREF,\n+                                TAG_NAMEANDTYPE, TAG_CONSTANTDYNAMIC, TAG_INVOKEDYNAMIC -> in.skipBytes(4);\n+                        case TAG_LONG, TAG_DOUBLE -> {\n+                            in.skipBytes(8);\n+                            i++;\n@@ -157,2 +165,1 @@\n-                    } catch (Exception ignore) {\n-                        \/\/ignore\n+                        default -> throw new IllegalStateException(\"Bad tag (\" + tag + \") at index (\" + i + \")\");\n@@ -161,2 +168,7 @@\n-                \/\/null ClassHierarchyInfo value is also cached to avoid repeated resolution attempts\n-                resolvedCache.put(classDesc, res);\n+                boolean isInterface = (in.readUnsignedShort() & ACC_INTERFACE) != 0;\n+                in.skipBytes(2);\n+                int superIndex = in.readUnsignedShort();\n+                var superClass = superIndex > 0 ? ClassDesc.ofInternalName(cpStrings[cpClasses[superIndex]]) : null;\n+                return new ClassHierarchyInfo(classDesc, isInterface, superClass);\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n@@ -164,1 +176,0 @@\n-            return res;\n@@ -191,1 +202,0 @@\n-        private final Map<ClassDesc, Optional<ClassHierarchyInfo>> cache = new HashMap<>();\n@@ -197,9 +207,7 @@\n-            return cache.computeIfAbsent(cd, desc -> {\n-                var cl = resolve(desc);\n-                if (cl == null) {\n-                    return Optional.empty();\n-                }\n-                var sup = cl.getSuperclass();\n-                return Optional.of(new ClassHierarchyInfo(desc, cl.isInterface(),\n-                        sup == null ? null : ClassDesc.of(sup.getName())));\n-            }).orElse(null);\n+            var cl = resolve(cd);\n+            if (cl == null) {\n+                return null;\n+            }\n+            var sup = cl.getSuperclass();\n+            return new ClassHierarchyInfo(cd, cl.isInterface(),\n+                    sup == null ? null : ClassDesc.of(sup.getName()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl.java","additions":62,"deletions":54,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -39,0 +40,1 @@\n+import jdk.internal.classfile.ClassHierarchyResolver;\n@@ -308,0 +310,7 @@\n+\n+    void resolverExample() {\n+        \/\/ @start region=\"lookup-class-hierarchy-resolver\"\n+        MethodHandles.Lookup lookup = MethodHandles.lookup(); \/\/ @replace regex=\"MethodHandles\\.lookup\\(\\)\" replacement=\"...\"\n+        ClassHierarchyResolver resolver = ClassHierarchyResolver.ofCached(ClassHierarchyResolver.ofReflection(lookup));\n+        \/\/ @end\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/snippet-files\/PackageSnippets.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-        transformAndVerify(ClassHierarchyResolver.ofCached(classDesc -> {\n+        transformAndVerify(ClassHierarchyResolver.ofParsing(classDesc -> {\n@@ -103,2 +103,7 @@\n-    void testClassLoaderResolver() throws Exception {\n-        transformAndVerify(ClassHierarchyResolver.of(ClassLoader.getSystemClassLoader()));\n+    void testClassLoaderParsingResolver() throws Exception {\n+        transformAndVerify(ClassHierarchyResolver.ofParsing(ClassLoader.getSystemClassLoader()));\n+    }\n+\n+    @Test\n+    void testClassLoaderReflectionResolver() throws Exception {\n+        transformAndVerify(ClassHierarchyResolver.ofReflection(ClassLoader.getSystemClassLoader()));\n@@ -111,1 +116,1 @@\n-        transformAndVerify(ClassHierarchyResolver.of(privilegedLookup));\n+        transformAndVerify(ClassHierarchyResolver.ofReflection(privilegedLookup));\n@@ -118,1 +123,1 @@\n-        assertThrows(IllegalArgumentException.class, () -> transformAndVerify(ClassHierarchyResolver.of(lookup)));\n+        assertThrows(IllegalArgumentException.class, () -> transformAndVerify(ClassHierarchyResolver.ofReflection(lookup)));\n","filename":"test\/jdk\/jdk\/classfile\/ClassHierarchyInfoTest.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"}]}