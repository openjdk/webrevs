{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -55,1 +56,1 @@\n-            });\n+            }).orElse(of(ClassLoader.getSystemClassLoader()));\n@@ -89,1 +90,1 @@\n-    public record ClassHierarchyInfo(ClassDesc thisClass, boolean isInterface, ClassDesc superClass) {\n+    record ClassHierarchyInfo(ClassDesc thisClass, boolean isInterface, ClassDesc superClass) {\n@@ -99,1 +100,1 @@\n-    public static ClassHierarchyResolver ofCached(Function<ClassDesc, InputStream> classStreamResolver) {\n+    static ClassHierarchyResolver ofCached(Function<ClassDesc, InputStream> classStreamResolver) {\n@@ -111,1 +112,1 @@\n-    public static ClassHierarchyResolver of(Collection<ClassDesc> interfaces,\n+    static ClassHierarchyResolver of(Collection<ClassDesc> interfaces,\n@@ -115,0 +116,44 @@\n+\n+    \/**\n+     * Returns a ClassHierarchyResolver that extracts class hierarchy information via\n+     * the Reflection API with a {@linkplain ClassLoader}.\n+     *\n+     * @param loader the class loader\n+     * @return the class hierarchy resolver\n+     *\/\n+    static ClassHierarchyResolver of(ClassLoader loader) {\n+        return new ClassHierarchyImpl.ReflectionClassHierarchyResolver() {\n+            @Override\n+            protected Class<?> resolve(ClassDesc cd) {\n+                try {\n+                    return Class.forName(Util.toBinaryName(cd.descriptorString()), false, loader);\n+                } catch (ClassNotFoundException ex) {\n+                    return null;\n+                }\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Returns a ClassHierarchyResolver that extracts class hierarchy information via\n+     * the Reflection API with a {@linkplain MethodHandles.Lookup Lookup}. If the class\n+     * resolved is inaccessible to the given lookup, it throws {@link\n+     * IllegalArgumentException} instead of returning {@code null}.\n+     *\n+     * @param lookup the lookup, must be able to access classes to resolve\n+     * @return the class hierarchy resolver\n+     *\/\n+    static ClassHierarchyResolver of(MethodHandles.Lookup lookup) {\n+        return new ClassHierarchyImpl.ReflectionClassHierarchyResolver() {\n+            @Override\n+            protected Class<?> resolve(ClassDesc cd) {\n+                try {\n+                    return (Class<?>) cd.resolveConstantDesc(lookup);\n+                } catch (IllegalAccessException ex) {\n+                    throw new IllegalArgumentException(ex);\n+                } catch (ReflectiveOperationException ex) {\n+                    return null;\n+                }\n+            }\n+        };\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassHierarchyResolver.java","additions":50,"deletions":5,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.util.Optional;\n@@ -188,0 +189,21 @@\n+\n+    public abstract static class ReflectionClassHierarchyResolver implements ClassHierarchyResolver {\n+        private final Map<ClassDesc, Optional<ClassHierarchyInfo>> cache = new HashMap<>();\n+\n+        @Override\n+        public ClassHierarchyInfo getClassInfo(ClassDesc cd) {\n+            if (!cd.isClassOrInterface())\n+                return null;\n+            return cache.computeIfAbsent(cd, desc -> {\n+                var cl = resolve(desc);\n+                if (cl == null) {\n+                    return Optional.empty();\n+                }\n+                var sup = cl.getSuperclass();\n+                return Optional.of(new ClassHierarchyInfo(desc, cl.isInterface(),\n+                        sup == null ? null : ClassDesc.of(sup.getName())));\n+            }).orElse(null);\n+        }\n+\n+        protected abstract Class<?> resolve(ClassDesc cd);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,3 +117,20 @@\n-    public static String toClassString(String desc) {\n-        \/\/TODO: this doesn't look right L ... ;\n-        return desc.replace('\/', '.');\n+    \/**\n+     * Convert a descriptor of classes or interfaces or arrays, or an internal\n+     * name of a class or interface, into a fully qualified binary name, that can\n+     * be resolved by {@link Class#forName(String) Class::forName}. Primitive type\n+     * descriptors should never be passed into this method.\n+     *\n+     * @param descOrInternalName a descriptor or internal name\n+     * @return the fully qualified binary name\n+     *\/\n+    public static String toBinaryName(String descOrInternalName) {\n+        if (descOrInternalName.startsWith(\"L\")) {\n+            \/\/ descriptors of classes or interfaces\n+            if (descOrInternalName.length() <= 2 || !descOrInternalName.endsWith(\";\")) {\n+                throw new IllegalArgumentException(descOrInternalName);\n+            }\n+            return descOrInternalName.substring(1, descOrInternalName.length() - 1).replace('\/', '.');\n+        } else {\n+            \/\/ arrays, classes or interfaces' internal names\n+            return descOrInternalName.replace('\/', '.');\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import java.util.stream.Stream;\n+\n@@ -110,1 +112,1 @@\n-                .flatMap(ce -> ce instanceof MethodMethod mm ? mm.elementStream() : Stream.empty())\n+                .flatMap(ce -> ce instanceof MethodModel mm ? mm.elementStream() : Stream.empty())\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/snippet-files\/PackageSnippets.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,12 @@\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.impl\n+ *          java.base\/jdk.internal.classfile.impl.verifier\n+ *          java.base\/jdk.internal.classfile.java.lang.constant\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.util\n+ *          java.base\/java.util:open\n+ * @comment Opens java.util so HashMap bytecode generation can access its nested\n+ *          classes with a proper Lookup object\n@@ -34,0 +46,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -38,0 +51,1 @@\n+import java.util.HashMap;\n@@ -68,1 +82,1 @@\n-    void testBreakDefaulClassHierarchy() throws Exception {\n+    void testBreakDefaultClassHierarchy() throws Exception {\n@@ -88,0 +102,19 @@\n+    @Test\n+    void testClassLoaderResolver() throws Exception {\n+        transformAndVerify(ClassHierarchyResolver.of(ClassLoader.getSystemClassLoader()));\n+    }\n+\n+    @Test\n+    void testLookupResolver() throws Exception {\n+        \/\/ A lookup must be able to access all the classes involved in the class file generation\n+        var privilegedLookup = MethodHandles.privateLookupIn(HashMap.class, MethodHandles.lookup());\n+        transformAndVerify(ClassHierarchyResolver.of(privilegedLookup));\n+    }\n+\n+    @Test\n+    void testLookupResolver_IllegalAccess() throws Exception {\n+        \/\/ A lookup from this test class, cannot access nested classes in HashMap\n+        var lookup = MethodHandles.lookup();\n+        assertThrows(IllegalArgumentException.class, () -> transformAndVerify(ClassHierarchyResolver.of(lookup)));\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/ClassHierarchyInfoTest.java","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -40,0 +42,19 @@\n+    @ParameterizedTest\n+    @ValueSource(classes = {\n+            Long.class,\n+            Object.class,\n+            Util.class,\n+            Test.class,\n+            int[][].class,\n+            Object[].class,\n+    })\n+    void testDescToBinaryName(Class<?> type) throws ReflectiveOperationException {\n+        if (!type.isArray()) {\n+            \/\/ Test internal name\n+            var internal = type.getName().replace('.', '\/');\n+            assertEquals(type, Class.forName(Util.toBinaryName(internal)));\n+        }\n+        \/\/ Test descriptor\n+        assertEquals(type, Class.forName(Util.toBinaryName(type.descriptorString())));\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/UtilTest.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"}]}