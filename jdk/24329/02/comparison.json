{"files":[{"patch":"@@ -54,0 +54,4 @@\n+#define DECLARE_EXTRA_CPU_FEATURE_NAME(id, name, bit) name,\n+const char* VM_Version::_extra_features_names[] = { EXTRA_CPU_FEATURE_FLAGS(DECLARE_EXTRA_CPU_FEATURE_NAME)};\n+#undef DECLARE_EXTRA_CPU_FEATURE_FLAG\n+\n@@ -141,1 +145,1 @@\n-    Label detect_486, cpu486, detect_586, std_cpuid1, std_cpuid4;\n+    Label detect_486, cpu486, detect_586, std_cpuid1, std_cpuid4, std_cpuid24;\n@@ -344,0 +348,11 @@\n+    \/\/\n+    \/\/ cpuid(0x24) Converged Vector ISA Main Leaf (EAX = 24H, ECX = 0).\n+    \/\/\n+    __ bind(std_cpuid24);\n+    __ movl(rax, 0x24);\n+    __ movl(rcx, 0);\n+    __ cpuid();\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid24_offset())));\n+    __ movl(Address(rsi, 0), rax);\n+    __ movl(Address(rsi, 4), rbx);\n+\n@@ -431,2 +446,1 @@\n-    __ cmpl(rax, 0x200000);\n-    __ jcc(Assembler::notEqual, vector_save_restore);\n+    __ jcc(Assembler::equal, vector_save_restore);\n@@ -436,2 +450,1 @@\n-    __ cmpl(rax, 0x80000);\n-    __ jcc(Assembler::notEqual, vector_save_restore);\n+    __ jcc(Assembler::equal, vector_save_restore);\n@@ -466,2 +479,1 @@\n-    __ cmpl(rcx, 0x18000000);\n-    __ jccb(Assembler::notEqual, done); \/\/ jump if AVX is not supported\n+    __ jccb(Assembler::equal, done); \/\/ jump if AVX is not supported\n@@ -471,2 +483,1 @@\n-    __ cmpl(rax, 0x6);\n-    __ jccb(Assembler::equal, start_simd_check); \/\/ return if AVX is not supported\n+    __ jccb(Assembler::notEqual, start_simd_check); \/\/ return if AVX is not supported\n@@ -491,0 +502,1 @@\n+      \/\/ OR check _cpuid_info.std_cpuid24_ebx.bits.avx10\n@@ -493,3 +505,6 @@\n-      __ andl(rax, Address(rsi, 4)); \/\/ xcr0 bits sse | ymm\n-      __ cmpl(rax, 0x10000);\n-      __ jccb(Assembler::notEqual, legacy_setup); \/\/ jump if EVEX is not supported\n+      __ andl(rax, Address(rsi, 4));\n+      __ lea(rsi, Address(rbp, in_bytes(VM_Version::sefsl1_cpuid7_offset())));\n+      __ movl(rbx, 0x80000);\n+      __ andl(rbx, Address(rsi, 4));\n+      __ orl(rax, rbx);\n+      __ jccb(Assembler::equal, legacy_setup); \/\/ jump if EVEX is not supported\n@@ -501,2 +516,1 @@\n-      __ cmpl(rax, 0xE0);\n-      __ jccb(Assembler::notEqual, legacy_setup); \/\/ jump if EVEX is not supported\n+      __ jccb(Assembler::equal, legacy_setup); \/\/ jump if EVEX is not supported\n@@ -580,2 +594,1 @@\n-      __ cmpl(rax, 0x10000);\n-      __ jcc(Assembler::notEqual, legacy_save_restore);\n+      __ jcc(Assembler::equal, legacy_save_restore);\n@@ -587,2 +600,1 @@\n-      __ cmpl(rax, 0xE0);\n-      __ jcc(Assembler::notEqual, legacy_save_restore);\n+      __ jcc(Assembler::equal, legacy_save_restore);\n@@ -882,0 +894,1 @@\n+    _extra_features = _cpuid_info.extra_feature_flags(); \/\/ These can be changed by VM settings\n@@ -895,0 +908,1 @@\n+\n@@ -1021,0 +1035,2 @@\n+    _features &= ~CPU_AVX512ER;\n+    _features &= ~CPU_AVX512PF;\n@@ -1032,0 +1048,2 @@\n+    _features &= ~CPU_AVX10_1;\n+    _features &= ~EXTRA_CPU_AVX10_2;\n@@ -1092,1 +1110,1 @@\n-  char buf[1024];\n+  char buf[2048] = {'\\0'};\n@@ -1099,1 +1117,3 @@\n-  insert_features_names(buf + res, sizeof(buf) - res, _features_names);\n+  insert_features_names(_features, buf + res, sizeof(buf) - res, _features_names);\n+  res = (int)strlen(buf);\n+  insert_features_names(_extra_features, buf + res, sizeof(buf) - res, _extra_features_names);\n@@ -2965,0 +2985,15 @@\n+uint64_t VM_Version::CpuidInfo::extra_feature_flags() const {\n+  uint64_t result = 0;\n+  if (is_intel()) {\n+    if (sefsl1_cpuid7_edx.bits.avx10 != 0 &&\n+        std_cpuid24_ebx.bits.avx10_vlen_512 !=0 &&\n+        std_cpuid24_ebx.bits.avx10_converged_isa_version >= 2 &&\n+        xem_xcr0_eax.bits.opmask != 0 &&\n+        xem_xcr0_eax.bits.zmm512 != 0 &&\n+        xem_xcr0_eax.bits.zmm32 != 0) {\n+      result |= EXTRA_CPU_AVX10_2;\n+    }\n+  }\n+  return result;\n+}\n+\n@@ -3057,0 +3092,26 @@\n+    if (is_intel()) {\n+      if (sefsl1_cpuid7_edx.bits.avx10 != 0 &&\n+          std_cpuid24_ebx.bits.avx10_vlen_512 !=0 &&\n+          std_cpuid24_ebx.bits.avx10_converged_isa_version >= 1 &&\n+          xem_xcr0_eax.bits.opmask != 0 &&\n+          xem_xcr0_eax.bits.zmm512 != 0 &&\n+          xem_xcr0_eax.bits.zmm32 != 0) {\n+        result |= CPU_AVX10_1;\n+        result |= CPU_AVX_IFMA;\n+        result |= CPU_AVX512F;\n+        result |= CPU_AVX512CD;\n+        result |= CPU_AVX512DQ;\n+        result |= CPU_AVX512_IFMA;\n+        result |= CPU_AVX512PF;\n+        result |= CPU_AVX512ER;\n+        result |= CPU_AVX512BW;\n+        result |= CPU_AVX512VL;\n+        result |= CPU_AVX512_VPOPCNTDQ;\n+        result |= CPU_AVX512_VPCLMULQDQ;\n+        result |= CPU_AVX512_VAES;\n+        result |= CPU_AVX512_VNNI;\n+        result |= CPU_AVX512_BITALG;\n+        result |= CPU_AVX512_VBMI;\n+        result |= CPU_AVX512_VBMI2;\n+      }\n+    }\n@@ -3058,0 +3119,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":82,"deletions":20,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -298,1 +298,3 @@\n-      uint32_t       : 21,\n+      uint32_t       : 19,\n+              avx10  : 1,\n+                     : 1,\n@@ -304,0 +306,18 @@\n+  union StdCpuid24MainLeafEax {\n+    uint32_t value;\n+    struct {\n+      uint32_t  sub_leaves_cnt  : 31;\n+    } bits;\n+  };\n+\n+  union StdCpuid24MainLeafEbx {\n+    uint32_t value;\n+    struct {\n+      uint32_t  avx10_converged_isa_version  : 8,\n+                                             : 8,\n+                                             : 2,\n+                avx10_vlen_512               : 1,\n+                                             : 13;\n+    } bits;\n+  };\n+\n@@ -345,1 +365,1 @@\n-   * src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.amd64\/src\/jdk\/vm\/ci\/amd64\/AMD64.java\n+   * src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java\n@@ -423,1 +443,2 @@\n-    decl(AVX512_FP16,       \"avx512_fp16\",       62) \/* AVX512 FP16 ISA support*\/\n+    decl(AVX512_FP16,       \"avx512_fp16\",       62) \/* AVX512 FP16 ISA support*\/ \\\n+    decl(AVX10_1,           \"avx10_1\",           63) \/* AVX10 512 bit vector ISA Version 1 support*\/\n@@ -430,0 +451,14 @@\n+  \/*\n+   * Update following files when declaring new flags:\n+   * test\/lib-test\/jdk\/test\/whitebox\/CPUInfoTest.java\n+   * src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java\n+   *\/\n+  enum Extra_Feature_Flag : uint64_t {\n+#define EXTRA_CPU_FEATURE_FLAGS(decl) \\\n+    decl(AVX10_2,           \"avx10_2\",           0) \/* AVX10 512 bit vector ISA Version 2 support*\/\n+\n+#define DECLARE_EXTRA_CPU_FEATURE_FLAG(id, name, bit) EXTRA_CPU_##id = (1ULL << bit),\n+    EXTRA_CPU_FEATURE_FLAGS(DECLARE_EXTRA_CPU_FEATURE_FLAG)\n+#undef DECLARE_EXTRA_CPU_FEATURE_FLAG\n+  };\n+\n@@ -431,0 +466,1 @@\n+  static const char* _extra_features_names[];\n@@ -495,0 +531,5 @@\n+    \/\/ cpuid function 24 converged vector ISA main leaf\n+    \/\/ eax = 24, ecx = 0\n+    StdCpuid24MainLeafEax std_cpuid24_eax;\n+    StdCpuid24MainLeafEbx std_cpuid24_ebx;\n+\n@@ -569,0 +610,1 @@\n+    uint64_t extra_feature_flags() const;\n@@ -614,0 +656,1 @@\n+  static ByteSize std_cpuid24_offset() { return byte_offset_of(CpuidInfo, std_cpuid24_eax); }\n@@ -649,1 +692,1 @@\n-  static void set_evex_cpuFeatures() { _features |= (CPU_AVX512F | CPU_SSE | CPU_SSE2 | CPU_VZEROUPPER ); }\n+  static void set_evex_cpuFeatures() { _features |= (CPU_AVX10_1 | EXTRA_CPU_AVX10_2 | CPU_AVX512F | CPU_SSE | CPU_SSE2 | CPU_VZEROUPPER ); }\n@@ -771,0 +814,6 @@\n+  \/\/ IntelÂ® AVX10 introduces a versioned approach for enumeration that is monotonically increasing, inclusive,\n+  \/\/ and supporting all vector lengths. Feature set supported by an AVX10 vector ISA version is also supported\n+  \/\/ by all the versions above it.\n+  static bool supports_avx10_1()      { return (_features & CPU_AVX10_1) != 0;}\n+  static bool supports_avx10_2()      { return (_extra_features & EXTRA_CPU_AVX10_2) != 0;}\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":53,"deletions":4,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -150,0 +150,1 @@\n+  static_field(Abstract_VM_Version,            _extra_features,                        uint64_t)                                     \\\n@@ -979,1 +980,4 @@\n-#define VM_LONG_CPU_FEATURE_CONSTANTS CPU_FEATURE_FLAGS(DECLARE_LONG_CPU_FEATURE_CONSTANT)\n+#define DECLARE_LONG_EXTRA_CPU_FEATURE_CONSTANT(id, name, bit) GENERATE_VM_LONG_CONSTANT_ENTRY(VM_Version::EXTRA_CPU_##id)\n+#define VM_LONG_CPU_FEATURE_CONSTANTS \\\n+   CPU_FEATURE_FLAGS(DECLARE_LONG_CPU_FEATURE_CONSTANT) \\\n+   EXTRA_CPU_FEATURE_FLAGS(DECLARE_LONG_EXTRA_CPU_FEATURE_CONSTANT)\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+uint64_t Abstract_VM_Version::_extra_features = 0;\n@@ -323,2 +324,1 @@\n-void Abstract_VM_Version::insert_features_names(char* buf, size_t buflen, const char* features_names[]) {\n-  uint64_t features = _features;\n+void Abstract_VM_Version::insert_features_names(uint64_t features, char* buf, size_t buflen, const char* features_names[]) {\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,0 +59,3 @@\n+  \/\/ Extra CPU feature flags used when all 64 bits of _features are exhausted for\n+  \/\/ on a given target, currently only used for x86_64, can be affected by VM settings.\n+  static uint64_t _extra_features;\n@@ -130,0 +133,1 @@\n+  static uint64_t extra_features()     { return _extra_features; }\n@@ -131,1 +135,2 @@\n-  static void insert_features_names(char* buf, size_t buflen, const char* features_names[]);\n+\n+  static void insert_features_names(uint64_t features, char* buf, size_t buflen, const char* features_names[]);\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -261,0 +261,2 @@\n+        AVX10_1,\n+        AVX10_2\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+                    long extra_features,\n@@ -77,0 +78,11 @@\n+            if (key.startsWith(\"VM_Version::EXTRA_CPU_\")) {\n+                String name = key.substring(\"VM_Version::EXTRA_CPU_\".length());\n+                try {\n+                    CPUFeatureType feature = Enum.valueOf(enumType, renaming.getOrDefault(name, name));\n+                    if ((extra_features & bitMask) != 0) {\n+                        outFeatures.add(feature);\n+                    }\n+                } catch (IllegalArgumentException iae) {\n+                    missing.add(name);\n+                }\n+            }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIBackendFactory.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, emptyMap());\n+        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, 0L, emptyMap());\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/aarch64\/AArch64HotSpotJVMCIBackendFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,2 @@\n-        EnumSet<CPUFeature> features = HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, renaming);\n+        EnumSet<CPUFeature> features = HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures,\n+                                                                                  config.vmVersionExtraFeatures, renaming);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/amd64\/AMD64HotSpotJVMCIBackendFactory.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    final long vmVersionExtraFeatures = getFieldValue(\"Abstract_VM_Version::_extra_features\", Long.class, \"uint64_t\");\n@@ -91,0 +92,2 @@\n+    final long avx10_1 = getConstant(\"VM_Version::CPU_AVX10_1\", Long.class);\n+    final long avx10_2 = getConstant(\"VM_Version::EXTRA_CPU_AVX10_2\", Long.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/amd64\/AMD64HotSpotVMConfig.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, emptyMap());\n+        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, 0L, emptyMap());\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotJVMCIBackendFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-                    \"apx_f\"\n+                    \"apx_f\", \"avx10_1\", \"avx10_2\"\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/CPUInfoTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}