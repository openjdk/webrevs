{"files":[{"patch":"@@ -705,0 +705,2 @@\n+void VM_Version::pre_initialize() {}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+  static void pre_initialize();\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  static void pre_initialize();\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -356,0 +356,2 @@\n+void VM_Version::pre_initialize() {}\n+\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm_32.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+void VM_Version::pre_initialize() {}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+  static void pre_initialize();\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+void VM_Version::pre_initialize() {}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -308,0 +308,1 @@\n+  static void pre_initialize();\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -91,0 +91,2 @@\n+void VM_Version::pre_initialize() {}\n+\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -414,0 +414,1 @@\n+  static void pre_initialize();\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,4 +54,0 @@\n-#define DECLARE_EXTRA_CPU_FEATURE_NAME(id, name, bit) name,\n-const char* VM_Version::_extra_features_names[] = { EXTRA_CPU_FEATURE_FLAGS(DECLARE_EXTRA_CPU_FEATURE_NAME)};\n-#undef DECLARE_EXTRA_CPU_FEATURE_FLAG\n-\n@@ -91,1 +87,1 @@\n-  assert ((!Universe::is_fully_initialized() || (_features & CPU_FLUSH) != 0), \"clflush should be available\");\n+  assert ((!Universe::is_fully_initialized() || SUPPORTS_CPU_FEATURE(CPU_FLUSH)), \"clflush should be available\");\n@@ -878,1 +874,0 @@\n-  _features = 0;\n@@ -893,3 +888,2 @@\n-    _features = _cpuid_info.feature_flags(); \/\/ These can be changed by VM settings\n-    _extra_features = _cpuid_info.extra_feature_flags(); \/\/ These can be changed by VM settings\n-    _cpu_features = _features;   \/\/ Preserve features\n+    _cpuid_info.feature_flags(); \/\/ These can be changed by VM settings\n+    memcpy(_dynamic_cpu_features_vector, _dynamic_features_vector, sizeof(uint64_t) * _dynamic_features_vector_size);   \/\/ Preserve features\n@@ -951,2 +945,2 @@\n-    _features &= ~CPU_SSE4_1;\n-    _features &= ~CPU_SSE4_2;\n+    CLEAR_CPU_FEATURE(CPU_SSE4_1);\n+    CLEAR_CPU_FEATURE(CPU_SSE4_2);\n@@ -956,3 +950,3 @@\n-    _features &= ~CPU_SSE3;\n-    _features &= ~CPU_SSSE3;\n-    _features &= ~CPU_SSE4A;\n+    CLEAR_CPU_FEATURE(CPU_SSE3);\n+    CLEAR_CPU_FEATURE(CPU_SSSE3);\n+    CLEAR_CPU_FEATURE(CPU_SSE4A);\n@@ -962,1 +956,1 @@\n-    _features &= ~CPU_SSE2;\n+    CLEAR_CPU_FEATURE(CPU_SSE2);\n@@ -965,1 +959,1 @@\n-    _features &= ~CPU_SSE;\n+    CLEAR_CPU_FEATURE(CPU_SSE);\n@@ -1031,19 +1025,19 @@\n-    _features &= ~CPU_AVX512F;\n-    _features &= ~CPU_AVX512DQ;\n-    _features &= ~CPU_AVX512CD;\n-    _features &= ~CPU_AVX512BW;\n-    _features &= ~CPU_AVX512ER;\n-    _features &= ~CPU_AVX512PF;\n-    _features &= ~CPU_AVX512VL;\n-    _features &= ~CPU_AVX512_VPOPCNTDQ;\n-    _features &= ~CPU_AVX512_VPCLMULQDQ;\n-    _features &= ~CPU_AVX512_VAES;\n-    _features &= ~CPU_AVX512_VNNI;\n-    _features &= ~CPU_AVX512_VBMI;\n-    _features &= ~CPU_AVX512_VBMI2;\n-    _features &= ~CPU_AVX512_BITALG;\n-    _features &= ~CPU_AVX512_IFMA;\n-    _features &= ~CPU_APX_F;\n-    _features &= ~CPU_AVX512_FP16;\n-    _features &= ~CPU_AVX10_1;\n-    _features &= ~EXTRA_CPU_AVX10_2;\n+    CLEAR_CPU_FEATURE(CPU_AVX512F);\n+    CLEAR_CPU_FEATURE(CPU_AVX512DQ);\n+    CLEAR_CPU_FEATURE(CPU_AVX512CD);\n+    CLEAR_CPU_FEATURE(CPU_AVX512BW);\n+    CLEAR_CPU_FEATURE(CPU_AVX512ER);\n+    CLEAR_CPU_FEATURE(CPU_AVX512PF);\n+    CLEAR_CPU_FEATURE(CPU_AVX512VL);\n+    CLEAR_CPU_FEATURE(CPU_AVX512_VPOPCNTDQ);\n+    CLEAR_CPU_FEATURE(CPU_AVX512_VPCLMULQDQ);\n+    CLEAR_CPU_FEATURE(CPU_AVX512_VAES);\n+    CLEAR_CPU_FEATURE(CPU_AVX512_VNNI);\n+    CLEAR_CPU_FEATURE(CPU_AVX512_VBMI);\n+    CLEAR_CPU_FEATURE(CPU_AVX512_VBMI2);\n+    CLEAR_CPU_FEATURE(CPU_AVX512_BITALG);\n+    CLEAR_CPU_FEATURE(CPU_AVX512_IFMA);\n+    CLEAR_CPU_FEATURE(CPU_APX_F);\n+    CLEAR_CPU_FEATURE(CPU_AVX512_FP16);\n+    CLEAR_CPU_FEATURE(CPU_AVX10_1);\n+    CLEAR_CPU_FEATURE(CPU_AVX10_2);\n@@ -1062,1 +1056,1 @@\n-    _features &= ~CPU_APX_F;\n+    CLEAR_CPU_FEATURE(CPU_APX_F);\n@@ -1066,2 +1060,2 @@\n-    _features &= ~CPU_AVX2;\n-    _features &= ~CPU_AVX_IFMA;\n+    CLEAR_CPU_FEATURE(CPU_AVX2);\n+    CLEAR_CPU_FEATURE(CPU_AVX_IFMA);\n@@ -1071,4 +1065,4 @@\n-    _features &= ~CPU_AVX;\n-    _features &= ~CPU_VZEROUPPER;\n-    _features &= ~CPU_F16C;\n-    _features &= ~CPU_SHA512;\n+    CLEAR_CPU_FEATURE(CPU_AVX);\n+    CLEAR_CPU_FEATURE(CPU_VZEROUPPER);\n+    CLEAR_CPU_FEATURE(CPU_F16C);\n+    CLEAR_CPU_FEATURE(CPU_SHA512);\n@@ -1079,1 +1073,1 @@\n-    _features &= ~CPU_HT;\n+    CLEAR_CPU_FEATURE(CPU_HT);\n@@ -1084,17 +1078,17 @@\n-      _features &= ~CPU_VZEROUPPER;\n-      _features &= ~CPU_AVX512BW;\n-      _features &= ~CPU_AVX512VL;\n-      _features &= ~CPU_AVX512DQ;\n-      _features &= ~CPU_AVX512_VNNI;\n-      _features &= ~CPU_AVX512_VAES;\n-      _features &= ~CPU_AVX512_VPOPCNTDQ;\n-      _features &= ~CPU_AVX512_VPCLMULQDQ;\n-      _features &= ~CPU_AVX512_VBMI;\n-      _features &= ~CPU_AVX512_VBMI2;\n-      _features &= ~CPU_CLWB;\n-      _features &= ~CPU_FLUSHOPT;\n-      _features &= ~CPU_GFNI;\n-      _features &= ~CPU_AVX512_BITALG;\n-      _features &= ~CPU_AVX512_IFMA;\n-      _features &= ~CPU_AVX_IFMA;\n-      _features &= ~CPU_AVX512_FP16;\n+      CLEAR_CPU_FEATURE(CPU_VZEROUPPER);\n+      CLEAR_CPU_FEATURE(CPU_AVX512BW);\n+      CLEAR_CPU_FEATURE(CPU_AVX512VL);\n+      CLEAR_CPU_FEATURE(CPU_AVX512DQ);\n+      CLEAR_CPU_FEATURE(CPU_AVX512_VNNI);\n+      CLEAR_CPU_FEATURE(CPU_AVX512_VAES);\n+      CLEAR_CPU_FEATURE(CPU_AVX512_VPOPCNTDQ);\n+      CLEAR_CPU_FEATURE(CPU_AVX512_VPCLMULQDQ);\n+      CLEAR_CPU_FEATURE(CPU_AVX512_VBMI);\n+      CLEAR_CPU_FEATURE(CPU_AVX512_VBMI2);\n+      CLEAR_CPU_FEATURE(CPU_CLWB);\n+      CLEAR_CPU_FEATURE(CPU_FLUSHOPT);\n+      CLEAR_CPU_FEATURE(CPU_GFNI);\n+      CLEAR_CPU_FEATURE(CPU_AVX512_BITALG);\n+      CLEAR_CPU_FEATURE(CPU_AVX512_IFMA);\n+      CLEAR_CPU_FEATURE(CPU_AVX_IFMA);\n+      CLEAR_CPU_FEATURE(CPU_AVX512_FP16);\n@@ -1111,1 +1105,1 @@\n-  int res = jio_snprintf(\n+  size_t res = jio_snprintf(\n@@ -1117,3 +1111,4 @@\n-  insert_features_names(_features, buf + res, sizeof(buf) - res, _features_names);\n-  res = (int)strlen(buf);\n-  insert_features_names(_extra_features, buf + res, sizeof(buf) - res, _extra_features_names);\n+  for (uint64_t i = 0; i < _dynamic_features_vector_size; i++) {\n+    insert_features_names(_dynamic_features_vector[i], buf + res, sizeof(buf) - res, _features_names, 64 * i);\n+    res = strlen(buf);\n+  }\n@@ -2202,0 +2197,9 @@\n+void VM_Version::pre_initialize() {\n+  _dynamic_features_element_shift_count = 6;\n+  _dynamic_features_vector_size =  (MAX_CPU_FEATURES >> _dynamic_features_element_shift_count) + 1;\n+  _dynamic_features_vector = NEW_C_HEAP_ARRAY(uint64_t, _dynamic_features_vector_size, mtInternal);\n+  _dynamic_cpu_features_vector = NEW_C_HEAP_ARRAY(uint64_t, _dynamic_features_vector_size, mtInternal);\n+  memset(_dynamic_features_vector, 0, sizeof(uint64_t) * _dynamic_features_vector_size);\n+  memset(_dynamic_cpu_features_vector, 0, sizeof(uint64_t) * _dynamic_features_vector_size);\n+}\n+\n@@ -2982,17 +2986,1 @@\n-uint64_t VM_Version::CpuidInfo::extra_feature_flags() const {\n-  uint64_t result = 0;\n-  if (is_intel()) {\n-    if (sefsl1_cpuid7_edx.bits.avx10 != 0 &&\n-        std_cpuid24_ebx.bits.avx10_vlen_512 !=0 &&\n-        std_cpuid24_ebx.bits.avx10_converged_isa_version >= 2 &&\n-        xem_xcr0_eax.bits.opmask != 0 &&\n-        xem_xcr0_eax.bits.zmm512 != 0 &&\n-        xem_xcr0_eax.bits.zmm32 != 0) {\n-      result |= EXTRA_CPU_AVX10_2;\n-    }\n-  }\n-  return result;\n-}\n-\n-uint64_t VM_Version::CpuidInfo::feature_flags() const {\n-  uint64_t result = 0;\n+void VM_Version::CpuidInfo::feature_flags() const {\n@@ -3000,1 +2988,1 @@\n-    result |= CPU_CX8;\n+    SET_CPU_FEATURE(CPU_CX8);\n@@ -3002,1 +2990,1 @@\n-    result |= CPU_CMOV;\n+    SET_CPU_FEATURE(CPU_CMOV);\n@@ -3004,1 +2992,1 @@\n-    result |= CPU_FLUSH;\n+    SET_CPU_FEATURE(CPU_FLUSH);\n@@ -3009,1 +2997,1 @@\n-  assert ((result & CPU_FLUSH) != 0, \"clflush should be available\");\n+  assert (SUPPORTS_CPU_FEATURE(CPU_FLUSH), \"clflush should be available\");\n@@ -3013,1 +3001,1 @@\n-    result |= CPU_FXSR;\n+    SET_CPU_FEATURE(CPU_FXSR);\n@@ -3016,1 +3004,1 @@\n-    result |= CPU_HT;\n+    SET_CPU_FEATURE(CPU_HT);\n@@ -3019,1 +3007,1 @@\n-    result |= CPU_MMX;\n+    SET_CPU_FEATURE(CPU_MMX);\n@@ -3021,1 +3009,1 @@\n-    result |= CPU_SSE;\n+    SET_CPU_FEATURE(CPU_SSE);\n@@ -3023,1 +3011,1 @@\n-    result |= CPU_SSE2;\n+    SET_CPU_FEATURE(CPU_SSE2);\n@@ -3025,1 +3013,1 @@\n-    result |= CPU_SSE3;\n+    SET_CPU_FEATURE(CPU_SSE3);\n@@ -3027,1 +3015,1 @@\n-    result |= CPU_SSSE3;\n+    SET_CPU_FEATURE(CPU_SSSE3);\n@@ -3029,1 +3017,1 @@\n-    result |= CPU_SSE4_1;\n+    SET_CPU_FEATURE(CPU_SSE4_1);\n@@ -3031,1 +3019,1 @@\n-    result |= CPU_SSE4_2;\n+    SET_CPU_FEATURE(CPU_SSE4_2);\n@@ -3033,1 +3021,1 @@\n-    result |= CPU_POPCNT;\n+    SET_CPU_FEATURE(CPU_POPCNT);\n@@ -3036,1 +3024,1 @@\n-    result |= CPU_APX_F;\n+    SET_CPU_FEATURE(CPU_APX_F);\n@@ -3042,2 +3030,2 @@\n-    result |= CPU_AVX;\n-    result |= CPU_VZEROUPPER;\n+    SET_CPU_FEATURE(CPU_AVX);\n+    SET_CPU_FEATURE(CPU_VZEROUPPER);\n@@ -3045,1 +3033,1 @@\n-      result |= CPU_SHA512;\n+      SET_CPU_FEATURE(CPU_SHA512);\n@@ -3047,1 +3035,1 @@\n-      result |= CPU_F16C;\n+      SET_CPU_FEATURE(CPU_F16C);\n@@ -3049,1 +3037,1 @@\n-      result |= CPU_AVX2;\n+      SET_CPU_FEATURE(CPU_AVX2);\n@@ -3051,1 +3039,1 @@\n-        result |= CPU_AVX_IFMA;\n+        SET_CPU_FEATURE(CPU_AVX_IFMA);\n@@ -3054,1 +3042,1 @@\n-        result |= CPU_GFNI;\n+        SET_CPU_FEATURE(CPU_GFNI);\n@@ -3059,1 +3047,1 @@\n-      result |= CPU_AVX512F;\n+      SET_CPU_FEATURE(CPU_AVX512F);\n@@ -3061,1 +3049,1 @@\n-        result |= CPU_AVX512CD;\n+        SET_CPU_FEATURE(CPU_AVX512CD);\n@@ -3063,1 +3051,1 @@\n-        result |= CPU_AVX512DQ;\n+        SET_CPU_FEATURE(CPU_AVX512DQ);\n@@ -3065,1 +3053,1 @@\n-        result |= CPU_AVX512_IFMA;\n+        SET_CPU_FEATURE(CPU_AVX512_IFMA);\n@@ -3067,1 +3055,1 @@\n-        result |= CPU_AVX512PF;\n+        SET_CPU_FEATURE(CPU_AVX512PF);\n@@ -3069,1 +3057,1 @@\n-        result |= CPU_AVX512ER;\n+        SET_CPU_FEATURE(CPU_AVX512ER);\n@@ -3071,1 +3059,1 @@\n-        result |= CPU_AVX512BW;\n+        SET_CPU_FEATURE(CPU_AVX512BW);\n@@ -3073,1 +3061,1 @@\n-        result |= CPU_AVX512VL;\n+        SET_CPU_FEATURE(CPU_AVX512VL);\n@@ -3075,1 +3063,1 @@\n-        result |= CPU_AVX512_VPOPCNTDQ;\n+        SET_CPU_FEATURE(CPU_AVX512_VPOPCNTDQ);\n@@ -3077,1 +3065,1 @@\n-        result |= CPU_AVX512_VPCLMULQDQ;\n+        SET_CPU_FEATURE(CPU_AVX512_VPCLMULQDQ);\n@@ -3079,1 +3067,1 @@\n-        result |= CPU_AVX512_VAES;\n+        SET_CPU_FEATURE(CPU_AVX512_VAES);\n@@ -3081,1 +3069,1 @@\n-        result |= CPU_AVX512_VNNI;\n+        SET_CPU_FEATURE(CPU_AVX512_VNNI);\n@@ -3083,1 +3071,1 @@\n-        result |= CPU_AVX512_BITALG;\n+        SET_CPU_FEATURE(CPU_AVX512_BITALG);\n@@ -3085,1 +3073,1 @@\n-        result |= CPU_AVX512_VBMI;\n+        SET_CPU_FEATURE(CPU_AVX512_VBMI);\n@@ -3087,1 +3075,1 @@\n-        result |= CPU_AVX512_VBMI2;\n+        SET_CPU_FEATURE(CPU_AVX512_VBMI2);\n@@ -3096,17 +3084,18 @@\n-        result |= CPU_AVX10_1;\n-        result |= CPU_AVX_IFMA;\n-        result |= CPU_AVX512F;\n-        result |= CPU_AVX512CD;\n-        result |= CPU_AVX512DQ;\n-        result |= CPU_AVX512_IFMA;\n-        result |= CPU_AVX512PF;\n-        result |= CPU_AVX512ER;\n-        result |= CPU_AVX512BW;\n-        result |= CPU_AVX512VL;\n-        result |= CPU_AVX512_VPOPCNTDQ;\n-        result |= CPU_AVX512_VPCLMULQDQ;\n-        result |= CPU_AVX512_VAES;\n-        result |= CPU_AVX512_VNNI;\n-        result |= CPU_AVX512_BITALG;\n-        result |= CPU_AVX512_VBMI;\n-        result |= CPU_AVX512_VBMI2;\n+        SET_CPU_FEATURE(CPU_AVX10_1);\n+        SET_CPU_FEATURE(CPU_AVX512F);\n+        SET_CPU_FEATURE(CPU_AVX512CD);\n+        SET_CPU_FEATURE(CPU_AVX512DQ);\n+        SET_CPU_FEATURE(CPU_AVX512PF);\n+        SET_CPU_FEATURE(CPU_AVX512ER);\n+        SET_CPU_FEATURE(CPU_AVX512BW);\n+        SET_CPU_FEATURE(CPU_AVX512VL);\n+        SET_CPU_FEATURE(CPU_AVX512_VPOPCNTDQ);\n+        SET_CPU_FEATURE(CPU_AVX512_VPCLMULQDQ);\n+        SET_CPU_FEATURE(CPU_AVX512_VAES);\n+        SET_CPU_FEATURE(CPU_AVX512_VNNI);\n+        SET_CPU_FEATURE(CPU_AVX512_BITALG);\n+        SET_CPU_FEATURE(CPU_AVX512_VBMI);\n+        SET_CPU_FEATURE(CPU_AVX512_VBMI2);\n+        if (std_cpuid24_ebx.bits.avx10_converged_isa_version >= 2) {\n+          SET_CPU_FEATURE(CPU_AVX10_2);\n+        }\n@@ -3118,1 +3107,1 @@\n-    result |= CPU_HV;\n+    SET_CPU_FEATURE(CPU_HV);\n@@ -3120,1 +3109,1 @@\n-    result |= CPU_BMI1;\n+    SET_CPU_FEATURE(CPU_BMI1);\n@@ -3122,1 +3111,1 @@\n-    result |= CPU_TSC;\n+    SET_CPU_FEATURE(CPU_TSC);\n@@ -3124,1 +3113,1 @@\n-    result |= CPU_TSCINV_BIT;\n+    SET_CPU_FEATURE(CPU_TSCINV_BIT);\n@@ -3126,1 +3115,1 @@\n-    result |= CPU_AES;\n+    SET_CPU_FEATURE(CPU_AES);\n@@ -3128,1 +3117,1 @@\n-    result |= CPU_LZCNT;\n+    SET_CPU_FEATURE(CPU_LZCNT);\n@@ -3130,1 +3119,1 @@\n-    result |= CPU_3DNOW_PREFETCH;\n+    SET_CPU_FEATURE(CPU_3DNOW_PREFETCH);\n@@ -3132,1 +3121,1 @@\n-    result |= CPU_ERMS;\n+    SET_CPU_FEATURE(CPU_ERMS);\n@@ -3134,1 +3123,1 @@\n-    result |= CPU_FSRM;\n+    SET_CPU_FEATURE(CPU_FSRM);\n@@ -3136,1 +3125,1 @@\n-    result |= CPU_CLMUL;\n+    SET_CPU_FEATURE(CPU_CLMUL);\n@@ -3138,1 +3127,1 @@\n-    result |= CPU_RTM;\n+    SET_CPU_FEATURE(CPU_RTM);\n@@ -3140,1 +3129,1 @@\n-     result |= CPU_ADX;\n+     SET_CPU_FEATURE(CPU_ADX);\n@@ -3142,1 +3131,1 @@\n-    result |= CPU_BMI2;\n+    SET_CPU_FEATURE(CPU_BMI2);\n@@ -3144,1 +3133,1 @@\n-    result |= CPU_SHA;\n+    SET_CPU_FEATURE(CPU_SHA);\n@@ -3146,1 +3135,1 @@\n-    result |= CPU_FMA;\n+    SET_CPU_FEATURE(CPU_FMA);\n@@ -3148,1 +3137,1 @@\n-    result |= CPU_FLUSHOPT;\n+    SET_CPU_FEATURE(CPU_FLUSHOPT);\n@@ -3150,1 +3139,1 @@\n-    result |= CPU_CLWB;\n+    SET_CPU_FEATURE(CPU_CLWB);\n@@ -3152,1 +3141,1 @@\n-    result |= CPU_RDTSCP;\n+    SET_CPU_FEATURE(CPU_RDTSCP);\n@@ -3154,1 +3143,1 @@\n-    result |= CPU_RDPID;\n+    SET_CPU_FEATURE(CPU_RDPID);\n@@ -3160,1 +3149,1 @@\n-      result |= CPU_3DNOW_PREFETCH;\n+      SET_CPU_FEATURE(CPU_3DNOW_PREFETCH);\n@@ -3162,1 +3151,1 @@\n-      result |= CPU_SSE4A;\n+      SET_CPU_FEATURE(CPU_SSE4A);\n@@ -3168,1 +3157,1 @@\n-      result |= CPU_SERIALIZE;\n+      SET_CPU_FEATURE(CPU_SERIALIZE);\n@@ -3170,1 +3159,1 @@\n-      result |= CPU_AVX512_FP16;\n+      SET_CPU_FEATURE(CPU_AVX512_FP16);\n@@ -3177,2 +3166,2 @@\n-    assert((result & CPU_CLWB) == 0, \"Check if it is supported?\");\n-    result &= ~CPU_CLWB;\n+    assert(SUPPORTS_CPU_FEATURE(CPU_CLWB), \"Check if it is supported?\");\n+    CLEAR_CPU_FEATURE(CPU_CLWB);\n@@ -3183,1 +3172,1 @@\n-    result |= CPU_PKU;\n+    SET_CPU_FEATURE(CPU_PKU);\n@@ -3186,1 +3175,1 @@\n-    result |= CPU_OSPKE;\n+    SET_CPU_FEATURE(CPU_OSPKE);\n@@ -3191,1 +3180,1 @@\n-    result |= CPU_CET_SS;\n+    SET_CPU_FEATURE(CPU_CET_SS);\n@@ -3194,1 +3183,1 @@\n-    result |= CPU_CET_IBT;\n+    SET_CPU_FEATURE(CPU_CET_IBT);\n@@ -3201,1 +3190,1 @@\n-    result |= CPU_TSCINV;\n+    SET_CPU_FEATURE(CPU_TSCINV);\n@@ -3203,2 +3192,0 @@\n-\n-  return result;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":154,"deletions":167,"binary":false,"changes":321,"status":"modified"},{"patch":"@@ -367,1 +367,1 @@\n-  enum Feature_Flag : uint64_t {\n+  enum Feature_Flag : uint32_t {\n@@ -444,1 +444,2 @@\n-    decl(AVX10_1,           \"avx10_1\",           63) \/* AVX10 512 bit vector ISA Version 1 support*\/\n+    decl(AVX10_1,           \"avx10_1\",           63) \/* AVX10 512 bit vector ISA Version 1 support*\/ \\\n+    decl(AVX10_2,           \"avx10_2\",           64) \/* AVX10 512 bit vector ISA Version 2 support*\/\n@@ -446,1 +447,1 @@\n-#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (1ULL << bit),\n+#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (bit),\n@@ -451,13 +452,1 @@\n-  \/*\n-   * Update following files when declaring new flags:\n-   * test\/lib-test\/jdk\/test\/whitebox\/CPUInfoTest.java\n-   * src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java\n-   *\/\n-  enum Extra_Feature_Flag : uint64_t {\n-#define EXTRA_CPU_FEATURE_FLAGS(decl) \\\n-    decl(AVX10_2,           \"avx10_2\",           0) \/* AVX10 512 bit vector ISA Version 2 support*\/\n-\n-#define DECLARE_EXTRA_CPU_FEATURE_FLAG(id, name, bit) EXTRA_CPU_##id = (1ULL << bit),\n-    EXTRA_CPU_FEATURE_FLAGS(DECLARE_EXTRA_CPU_FEATURE_FLAG)\n-#undef DECLARE_EXTRA_CPU_FEATURE_FLAG\n-  };\n+#define MAX_CPU_FEATURES 64\n@@ -466,1 +455,0 @@\n-  static const char* _extra_features_names[];\n@@ -609,2 +597,1 @@\n-    uint64_t feature_flags() const;\n-    uint64_t extra_feature_flags() const;\n+    void feature_flags() const;\n@@ -690,5 +677,21 @@\n-  static void clean_cpuFeatures()   { _features = 0; }\n-  static void set_avx_cpuFeatures() { _features |= (CPU_SSE | CPU_SSE2 | CPU_AVX | CPU_VZEROUPPER ); }\n-  static void set_evex_cpuFeatures() { _features |= (CPU_AVX10_1 | EXTRA_CPU_AVX10_2 | CPU_AVX512F | CPU_SSE | CPU_SSE2 | CPU_VZEROUPPER ); }\n-  static void set_apx_cpuFeatures() { _features |= CPU_APX_F; }\n-  static void set_bmi_cpuFeatures() { _features |= (CPU_BMI1 | CPU_BMI2 | CPU_LZCNT | CPU_POPCNT); }\n+  static void clean_cpuFeatures()   { memset(_dynamic_features_vector, 0, sizeof(uint64_t) * _dynamic_features_vector_size); }\n+  static void set_avx_cpuFeatures() {\n+    SET_CPU_FEATURE(CPU_SSE);\n+    SET_CPU_FEATURE(CPU_SSE2);\n+    SET_CPU_FEATURE(CPU_AVX);\n+    SET_CPU_FEATURE(CPU_VZEROUPPER);\n+  }\n+  static void set_evex_cpuFeatures() {\n+    SET_CPU_FEATURE(CPU_AVX10_1);\n+    SET_CPU_FEATURE(CPU_AVX512F);\n+    SET_CPU_FEATURE(CPU_SSE);\n+    SET_CPU_FEATURE(CPU_SSE2);\n+    SET_CPU_FEATURE(CPU_VZEROUPPER);\n+  }\n+  static void set_apx_cpuFeatures() { SET_CPU_FEATURE(CPU_APX_F); }\n+  static void set_bmi_cpuFeatures() {\n+    SET_CPU_FEATURE(CPU_BMI1);\n+    SET_CPU_FEATURE(CPU_BMI2);\n+    SET_CPU_FEATURE(CPU_LZCNT);\n+    SET_CPU_FEATURE(CPU_POPCNT);\n+  }\n@@ -697,0 +700,1 @@\n+  static void pre_initialize();\n@@ -749,34 +753,34 @@\n-  static bool supports_cpuid()        { return _features  != 0; }\n-  static bool supports_cmov()         { return (_features & CPU_CMOV) != 0; }\n-  static bool supports_fxsr()         { return (_features & CPU_FXSR) != 0; }\n-  static bool supports_ht()           { return (_features & CPU_HT) != 0; }\n-  static bool supports_mmx()          { return (_features & CPU_MMX) != 0; }\n-  static bool supports_sse()          { return (_features & CPU_SSE) != 0; }\n-  static bool supports_sse2()         { return (_features & CPU_SSE2) != 0; }\n-  static bool supports_sse3()         { return (_features & CPU_SSE3) != 0; }\n-  static bool supports_ssse3()        { return (_features & CPU_SSSE3)!= 0; }\n-  static bool supports_sse4_1()       { return (_features & CPU_SSE4_1) != 0; }\n-  static bool supports_sse4_2()       { return (_features & CPU_SSE4_2) != 0; }\n-  static bool supports_popcnt()       { return (_features & CPU_POPCNT) != 0; }\n-  static bool supports_avx()          { return (_features & CPU_AVX) != 0; }\n-  static bool supports_avx2()         { return (_features & CPU_AVX2) != 0; }\n-  static bool supports_tsc()          { return (_features & CPU_TSC) != 0; }\n-  static bool supports_rdtscp()       { return (_features & CPU_RDTSCP) != 0; }\n-  static bool supports_rdpid()        { return (_features & CPU_RDPID) != 0; }\n-  static bool supports_aes()          { return (_features & CPU_AES) != 0; }\n-  static bool supports_erms()         { return (_features & CPU_ERMS) != 0; }\n-  static bool supports_fsrm()         { return (_features & CPU_FSRM) != 0; }\n-  static bool supports_clmul()        { return (_features & CPU_CLMUL) != 0; }\n-  static bool supports_rtm()          { return (_features & CPU_RTM) != 0; }\n-  static bool supports_bmi1()         { return (_features & CPU_BMI1) != 0; }\n-  static bool supports_bmi2()         { return (_features & CPU_BMI2) != 0; }\n-  static bool supports_adx()          { return (_features & CPU_ADX) != 0; }\n-  static bool supports_evex()         { return (_features & CPU_AVX512F) != 0; }\n-  static bool supports_avx512dq()     { return (_features & CPU_AVX512DQ) != 0; }\n-  static bool supports_avx512ifma()   { return (_features & CPU_AVX512_IFMA) != 0; }\n-  static bool supports_avxifma()      { return (_features & CPU_AVX_IFMA) != 0; }\n-  static bool supports_avx512pf()     { return (_features & CPU_AVX512PF) != 0; }\n-  static bool supports_avx512er()     { return (_features & CPU_AVX512ER) != 0; }\n-  static bool supports_avx512cd()     { return (_features & CPU_AVX512CD) != 0; }\n-  static bool supports_avx512bw()     { return (_features & CPU_AVX512BW) != 0; }\n-  static bool supports_avx512vl()     { return (_features & CPU_AVX512VL) != 0; }\n+  static bool supports_cpuid()        { return _dynamic_features_vector  != nullptr; }\n+  static bool supports_cmov()         { return SUPPORTS_CPU_FEATURE(CPU_CMOV); }\n+  static bool supports_fxsr()         { return SUPPORTS_CPU_FEATURE(CPU_FXSR); }\n+  static bool supports_ht()           { return SUPPORTS_CPU_FEATURE(CPU_HT); }\n+  static bool supports_mmx()          { return SUPPORTS_CPU_FEATURE(CPU_MMX); }\n+  static bool supports_sse()          { return SUPPORTS_CPU_FEATURE(CPU_SSE); }\n+  static bool supports_sse2()         { return SUPPORTS_CPU_FEATURE(CPU_SSE2); }\n+  static bool supports_sse3()         { return SUPPORTS_CPU_FEATURE(CPU_SSE3); }\n+  static bool supports_ssse3()        { return SUPPORTS_CPU_FEATURE(CPU_SSSE3); }\n+  static bool supports_sse4_1()       { return SUPPORTS_CPU_FEATURE(CPU_SSE4_1); }\n+  static bool supports_sse4_2()       { return SUPPORTS_CPU_FEATURE(CPU_SSE4_2); }\n+  static bool supports_popcnt()       { return SUPPORTS_CPU_FEATURE(CPU_POPCNT); }\n+  static bool supports_avx()          { return SUPPORTS_CPU_FEATURE(CPU_AVX); }\n+  static bool supports_avx2()         { return SUPPORTS_CPU_FEATURE(CPU_AVX2); }\n+  static bool supports_tsc()          { return SUPPORTS_CPU_FEATURE(CPU_TSC); }\n+  static bool supports_rdtscp()       { return SUPPORTS_CPU_FEATURE(CPU_RDTSCP); }\n+  static bool supports_rdpid()        { return SUPPORTS_CPU_FEATURE(CPU_RDPID); }\n+  static bool supports_aes()          { return SUPPORTS_CPU_FEATURE(CPU_AES); }\n+  static bool supports_erms()         { return SUPPORTS_CPU_FEATURE(CPU_ERMS); }\n+  static bool supports_fsrm()         { return SUPPORTS_CPU_FEATURE(CPU_FSRM); }\n+  static bool supports_clmul()        { return SUPPORTS_CPU_FEATURE(CPU_CLMUL); }\n+  static bool supports_rtm()          { return SUPPORTS_CPU_FEATURE(CPU_RTM); }\n+  static bool supports_bmi1()         { return SUPPORTS_CPU_FEATURE(CPU_BMI1); }\n+  static bool supports_bmi2()         { return SUPPORTS_CPU_FEATURE(CPU_BMI2); }\n+  static bool supports_adx()          { return SUPPORTS_CPU_FEATURE(CPU_ADX); }\n+  static bool supports_evex()         { return SUPPORTS_CPU_FEATURE(CPU_AVX512F); }\n+  static bool supports_avx512dq()     { return SUPPORTS_CPU_FEATURE(CPU_AVX512DQ); }\n+  static bool supports_avx512ifma()   { return SUPPORTS_CPU_FEATURE(CPU_AVX512_IFMA); }\n+  static bool supports_avxifma()      { return SUPPORTS_CPU_FEATURE(CPU_AVX_IFMA); }\n+  static bool supports_avx512pf()     { return SUPPORTS_CPU_FEATURE(CPU_AVX512PF); }\n+  static bool supports_avx512er()     { return SUPPORTS_CPU_FEATURE(CPU_AVX512ER); }\n+  static bool supports_avx512cd()     { return SUPPORTS_CPU_FEATURE(CPU_AVX512CD); }\n+  static bool supports_avx512bw()     { return SUPPORTS_CPU_FEATURE(CPU_AVX512BW); }\n+  static bool supports_avx512vl()     { return SUPPORTS_CPU_FEATURE(CPU_AVX512VL); }\n@@ -791,1 +795,1 @@\n-  static bool supports_apx_f()        { return (_features & CPU_APX_F) != 0; }\n+  static bool supports_apx_f()        { return SUPPORTS_CPU_FEATURE(CPU_APX_F); }\n@@ -793,20 +797,20 @@\n-  static bool supports_sha()          { return (_features & CPU_SHA) != 0; }\n-  static bool supports_fma()          { return (_features & CPU_FMA) != 0 && supports_avx(); }\n-  static bool supports_vzeroupper()   { return (_features & CPU_VZEROUPPER) != 0; }\n-  static bool supports_avx512_vpopcntdq()  { return (_features & CPU_AVX512_VPOPCNTDQ) != 0; }\n-  static bool supports_avx512_vpclmulqdq() { return (_features & CPU_AVX512_VPCLMULQDQ) != 0; }\n-  static bool supports_avx512_vaes()  { return (_features & CPU_AVX512_VAES) != 0; }\n-  static bool supports_gfni()         { return (_features & CPU_GFNI) != 0; }\n-  static bool supports_avx512_vnni()  { return (_features & CPU_AVX512_VNNI) != 0; }\n-  static bool supports_avx512_bitalg()  { return (_features & CPU_AVX512_BITALG) != 0; }\n-  static bool supports_avx512_vbmi()  { return (_features & CPU_AVX512_VBMI) != 0; }\n-  static bool supports_avx512_vbmi2() { return (_features & CPU_AVX512_VBMI2) != 0; }\n-  static bool supports_avx512_fp16()  { return (_features & CPU_AVX512_FP16) != 0; }\n-  static bool supports_hv()           { return (_features & CPU_HV) != 0; }\n-  static bool supports_serialize()    { return (_features & CPU_SERIALIZE) != 0; }\n-  static bool supports_f16c()         { return (_features & CPU_F16C) != 0; }\n-  static bool supports_pku()          { return (_features & CPU_PKU) != 0; }\n-  static bool supports_ospke()        { return (_features & CPU_OSPKE) != 0; }\n-  static bool supports_cet_ss()       { return (_features & CPU_CET_SS) != 0; }\n-  static bool supports_cet_ibt()      { return (_features & CPU_CET_IBT) != 0; }\n-  static bool supports_sha512()       { return (_features & CPU_SHA512) != 0; }\n+  static bool supports_sha()          { return SUPPORTS_CPU_FEATURE(CPU_SHA); }\n+  static bool supports_fma()          { return SUPPORTS_CPU_FEATURE(CPU_FMA) && supports_avx(); }\n+  static bool supports_vzeroupper()   { return SUPPORTS_CPU_FEATURE(CPU_VZEROUPPER); }\n+  static bool supports_avx512_vpopcntdq()  { return SUPPORTS_CPU_FEATURE(CPU_AVX512_VPOPCNTDQ); }\n+  static bool supports_avx512_vpclmulqdq() { return SUPPORTS_CPU_FEATURE(CPU_AVX512_VPCLMULQDQ); }\n+  static bool supports_avx512_vaes()  { return SUPPORTS_CPU_FEATURE(CPU_AVX512_VAES); }\n+  static bool supports_gfni()         { return SUPPORTS_CPU_FEATURE(CPU_GFNI); }\n+  static bool supports_avx512_vnni()  { return SUPPORTS_CPU_FEATURE(CPU_AVX512_VNNI); }\n+  static bool supports_avx512_bitalg()  { return SUPPORTS_CPU_FEATURE(CPU_AVX512_BITALG); }\n+  static bool supports_avx512_vbmi()  { return SUPPORTS_CPU_FEATURE(CPU_AVX512_VBMI); }\n+  static bool supports_avx512_vbmi2() { return SUPPORTS_CPU_FEATURE(CPU_AVX512_VBMI2); }\n+  static bool supports_avx512_fp16()  { return SUPPORTS_CPU_FEATURE(CPU_AVX512_FP16); }\n+  static bool supports_hv()           { return SUPPORTS_CPU_FEATURE(CPU_HV); }\n+  static bool supports_serialize()    { return SUPPORTS_CPU_FEATURE(CPU_SERIALIZE); }\n+  static bool supports_f16c()         { return SUPPORTS_CPU_FEATURE(CPU_F16C); }\n+  static bool supports_pku()          { return SUPPORTS_CPU_FEATURE(CPU_PKU); }\n+  static bool supports_ospke()        { return SUPPORTS_CPU_FEATURE(CPU_OSPKE); }\n+  static bool supports_cet_ss()       { return SUPPORTS_CPU_FEATURE(CPU_CET_SS); }\n+  static bool supports_cet_ibt()      { return SUPPORTS_CPU_FEATURE(CPU_CET_IBT); }\n+  static bool supports_sha512()       { return SUPPORTS_CPU_FEATURE(CPU_SHA512); }\n@@ -817,2 +821,2 @@\n-  static bool supports_avx10_1()      { return (_features & CPU_AVX10_1) != 0;}\n-  static bool supports_avx10_2()      { return (_extra_features & EXTRA_CPU_AVX10_2) != 0;}\n+  static bool supports_avx10_1()      { return SUPPORTS_CPU_FEATURE(CPU_AVX10_1);}\n+  static bool supports_avx10_2()      { return SUPPORTS_CPU_FEATURE(CPU_AVX10_2);}\n@@ -823,1 +827,1 @@\n-  static bool cpu_supports_evex()     { return (_cpu_features & CPU_AVX512F) != 0; }\n+  static bool cpu_supports_evex()     { return SUPPORTS_CPU_FEATURE_AUX(CPU_AVX512F); }\n@@ -861,3 +865,3 @@\n-  static bool supports_3dnow_prefetch()    { return (_features & CPU_3DNOW_PREFETCH) != 0; }\n-  static bool supports_lzcnt()    { return (_features & CPU_LZCNT) != 0; }\n-  static bool supports_sse4a()    { return (_features & CPU_SSE4A) != 0; }\n+  static bool supports_3dnow_prefetch()    { return SUPPORTS_CPU_FEATURE(CPU_3DNOW_PREFETCH); }\n+  static bool supports_lzcnt()    { return SUPPORTS_CPU_FEATURE(CPU_LZCNT); }\n+  static bool supports_sse4a()    { return SUPPORTS_CPU_FEATURE(CPU_SSE4A); }\n@@ -870,1 +874,1 @@\n-    return (_features & CPU_TSCINV_BIT) != 0;\n+    return SUPPORTS_CPU_FEATURE(CPU_TSCINV_BIT);\n@@ -873,1 +877,1 @@\n-    return (_features & CPU_TSCINV) != 0;\n+    return SUPPORTS_CPU_FEATURE(CPU_TSCINV);\n@@ -934,1 +938,1 @@\n-  static bool supports_clflush() { return  ((_features & CPU_FLUSH) != 0); }\n+  static bool supports_clflush() { return  (SUPPORTS_CPU_FEATURE(CPU_FLUSH)); }\n@@ -938,2 +942,2 @@\n-  static bool supports_clflushopt() { return ((_features & CPU_FLUSHOPT) != 0); }\n-  static bool supports_clwb() { return ((_features & CPU_CLWB) != 0); }\n+  static bool supports_clflushopt() { return (SUPPORTS_CPU_FEATURE(CPU_FLUSHOPT)); }\n+  static bool supports_clwb() { return (SUPPORTS_CPU_FEATURE(CPU_CLWB)); }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":94,"deletions":90,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+void VM_Version::pre_initialize() {}\n+\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+  static void pre_initialize();\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-  JVMTI_ONLY(static_field(CompilerToVM::Data,  _should_notify_object_alloc,            int*))                                         \\\n+  JVMTI_ONLY(static_field(CompilerToVM::Data,  _should_notify_object_alloc,            int*))                                        \\\n@@ -150,1 +150,3 @@\n-  static_field(Abstract_VM_Version,            _extra_features,                        uint64_t)                                     \\\n+  static_field(Abstract_VM_Version,            _dynamic_features_vector,               uint64_t*)                                    \\\n+  static_field(Abstract_VM_Version,            _dynamic_features_vector_size,          uint64_t)                                     \\\n+  static_field(Abstract_VM_Version,            _dynamic_features_element_shift_count,  uint64_t)                                     \\\n@@ -987,1 +989,0 @@\n-#define DECLARE_LONG_EXTRA_CPU_FEATURE_CONSTANT(id, name, bit) GENERATE_VM_LONG_CONSTANT_ENTRY(VM_Version::EXTRA_CPU_##id)\n@@ -989,2 +990,1 @@\n-   CPU_FEATURE_FLAGS(DECLARE_LONG_CPU_FEATURE_CONSTANT) \\\n-   EXTRA_CPU_FEATURE_FLAGS(DECLARE_LONG_EXTRA_CPU_FEATURE_CONSTANT)\n+   CPU_FEATURE_FLAGS(DECLARE_LONG_CPU_FEATURE_CONSTANT)\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-uint64_t Abstract_VM_Version::_extra_features = 0;\n@@ -40,0 +39,5 @@\n+uint64_t* Abstract_VM_Version::_dynamic_features_vector = nullptr;\n+uint64_t Abstract_VM_Version::_dynamic_features_vector_size = 0;\n+uint64_t Abstract_VM_Version::_dynamic_features_element_shift_count = 0;\n+uint64_t* Abstract_VM_Version::_dynamic_cpu_features_vector = nullptr;\n+\n@@ -328,3 +332,2 @@\n-void Abstract_VM_Version::insert_features_names(uint64_t features, char* buf, size_t buflen, const char* features_names[]) {\n-  uint features_names_index = 0;\n-\n+void Abstract_VM_Version::insert_features_names(uint64_t features, char* buf, size_t buflen, const char* features_names[],\n+                                                uint features_names_index) {\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -59,3 +59,1 @@\n-  \/\/ Extra CPU feature flags used when all 64 bits of _features are exhausted for\n-  \/\/ on a given target, currently only used for x86_64, can be affected by VM settings.\n-  static uint64_t _extra_features;\n+\n@@ -67,0 +65,7 @@\n+  \/\/ Dynamically sized feature flags currently only used by x86 backend,\n+  \/\/ can be affected by VM settings.\n+  static uint64_t* _dynamic_features_vector;\n+  static uint64_t _dynamic_features_vector_size;\n+  static uint64_t _dynamic_features_element_shift_count;\n+  static uint64_t* _dynamic_cpu_features_vector;\n+\n@@ -132,2 +137,54 @@\n-  static uint64_t features()           { return _features; }\n-  static uint64_t extra_features()     { return _extra_features; }\n+  static uint64_t features() {\n+    return _features;\n+  }\n+\n+  static void set_dynamic_feature(uint32_t feature) {\n+    uint32_t index = feature >> _dynamic_features_element_shift_count;\n+    uint32_t index_mask = (1 << _dynamic_features_element_shift_count) - 1;\n+    assert(index < _dynamic_features_vector_size, \"Features array index out of bounds\");\n+    _dynamic_features_vector[index] |= (1ULL << (feature & index_mask));\n+  }\n+\n+  static void clear_dynamic_feature(uint32_t feature) {\n+    uint32_t index = feature >> _dynamic_features_element_shift_count;\n+    uint32_t index_mask = (1 << _dynamic_features_element_shift_count) - 1;\n+    assert(index < _dynamic_features_vector_size, \"Features array index out of bounds\");\n+    _dynamic_features_vector[index] &= ~(1ULL << (feature & index_mask));\n+  }\n+\n+  static bool supports_dynamic_feature(uint32_t feature) {\n+    uint32_t index = feature >> _dynamic_features_element_shift_count;\n+    uint32_t index_mask = (1 << _dynamic_features_element_shift_count) - 1;\n+    assert(index < _dynamic_features_vector_size, \"Features array index out of bounds\");\n+    return (_dynamic_features_vector[index] & (1ULL << (feature & index_mask))) != 0;\n+  }\n+\n+  static void set_cpu_feature_aux(uint32_t feature) {\n+    uint32_t index = feature >> _dynamic_features_element_shift_count;\n+    uint32_t index_mask = (1 << _dynamic_features_element_shift_count) - 1;\n+    assert(index < _dynamic_features_vector_size, \"Features array index out of bounds\");\n+    _dynamic_cpu_features_vector[index] |= (1ULL << (feature & index_mask));\n+  }\n+\n+  static bool supports_cpu_feature_aux(uint32_t feature) {\n+    uint32_t index = feature >> _dynamic_features_element_shift_count;\n+    uint32_t index_mask = (1 << _dynamic_features_element_shift_count) - 1;\n+    assert(index < _dynamic_features_vector_size, \"Features array index out of bounds\");\n+    return (_dynamic_cpu_features_vector[index] & (1ULL << (feature & index_mask))) != 0;\n+  }\n+\n+#define SET_CPU_FEATURE(feature) \\\n+  Abstract_VM_Version::set_dynamic_feature(feature)\n+\n+#define CLEAR_CPU_FEATURE(feature) \\\n+  Abstract_VM_Version::clear_dynamic_feature(feature)\n+\n+#define SUPPORTS_CPU_FEATURE(feature) \\\n+  Abstract_VM_Version::supports_dynamic_feature(feature)\n+\n+#define SET_CPU_FEATURE_AUX(feature) \\\n+  Abstract_VM_Version::set_cpu_feature_aux(feature)\n+\n+#define SUPPORTS_CPU_FEATURE_AUX(feature) \\\n+  Abstract_VM_Version::supports_cpu_feature_aux(feature)\n+\n@@ -136,1 +193,1 @@\n-  static void insert_features_names(uint64_t features, char* buf, size_t buflen, const char* features_names[]);\n+  static void insert_features_names(uint64_t features, char* buf, size_t buflen, const char* features_names[], uint features_names_index = 0);\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":63,"deletions":6,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+void VM_Version_pre_init();\n@@ -126,0 +127,1 @@\n+  VM_Version_pre_init();          \/\/ allocate feature flags arrays\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -705,0 +705,3 @@\n+     static_field(Abstract_VM_Version,         _dynamic_features_vector,                      uint64_t*)                             \\\n+     static_field(Abstract_VM_Version,         _dynamic_features_vector_size,                 uint64_t)                              \\\n+     static_field(Abstract_VM_Version,         _dynamic_features_element_shift_count,         uint64_t)                              \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,4 @@\n+void VM_Version_pre_init() {\n+  VM_Version::pre_initialize();\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/vm_version.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;\n@@ -60,1 +61,0 @@\n-                    long extra_features,\n@@ -78,2 +78,36 @@\n-            if (key.startsWith(\"VM_Version::EXTRA_CPU_\")) {\n-                String name = key.substring(\"VM_Version::EXTRA_CPU_\".length());\n+        }\n+        if (!missing.isEmpty()) {\n+            throw new JVMCIError(\"Missing CPU feature constants: %s\", missing);\n+        }\n+        return outFeatures;\n+    }\n+\n+    \/**\n+     * Converts a dynamically sized CPU features vector into enum constants.\n+     *\n+     * @param <CPUFeatureType> CPU feature enum type\n+     * @param enumType the class of {@code CPUFeatureType}\n+     * @param constants VM constants. Each entry whose key starts with {@code \"VM_Version::CPU_\"}\n+     *            specifies a CPU feature and its value is a mask for a bit in {@code features}\n+     * @param dynamic_features_vector_pointer pointer to dyanmic feature vector specifying CPU features\n+     * @param dynamic_features_vector_size dyanmic feature array size\n+     * @param dynamic_features_element_shift_count log of dyanmic feature vector element size in bits\n+     * @param renaming maps from VM feature names to enum constant names where the two differ\n+     * @throws IllegalArgumentException if any VM CPU feature constant cannot be converted to an\n+     *             enum value\n+     * @return the set of converted values\n+     *\/\n+    static <CPUFeatureType extends Enum<CPUFeatureType>> EnumSet<CPUFeatureType> convertDynamicFeaturesVector(\n+                    Class<CPUFeatureType> enumType,\n+                    Map<String, Long> constants,\n+                    long dynamic_features_vector_pointer,\n+                    long dynamic_features_vector_size,\n+                    long dynamic_features_element_shift_count,\n+                    Map<String, String> renaming) {\n+        EnumSet<CPUFeatureType> outFeatures = EnumSet.noneOf(enumType);\n+        List<String> missing = new ArrayList<>();\n+        for (Entry<String, Long> e : constants.entrySet()) {\n+            String key = e.getKey();\n+            long bitIndex = e.getValue();\n+            if (key.startsWith(\"VM_Version::CPU_\")) {\n+                String name = key.substring(\"VM_Version::CPU_\".length());\n@@ -82,1 +116,12 @@\n-                    if ((extra_features & bitMask) != 0) {\n+                    long dynamic_features_vector_index = bitIndex >>> dynamic_features_element_shift_count;\n+                    assert dynamic_features_vector_index < dynamic_features_vector_size;\n+\n+                    long  dynamic_features_element_bitsize = (1L << dynamic_features_element_shift_count);\n+                    assert (dynamic_features_element_bitsize & (dynamic_features_element_bitsize - 1)) == 0;\n+\n+                    long  dynamic_features_element_size = dynamic_features_element_bitsize \/ Byte.SIZE;\n+                    long features = UNSAFE.getLong(dynamic_features_vector_pointer +\n+                                                   dynamic_features_vector_index * dynamic_features_element_size);\n+\n+                    long effective_bitMask = 1L << (bitIndex & (dynamic_features_element_bitsize - 1));\n+                    if ((features & effective_bitMask) != 0) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIBackendFactory.java","additions":49,"deletions":4,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, 0L, emptyMap());\n+        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, emptyMap());\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/aarch64\/AArch64HotSpotJVMCIBackendFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,2 +53,5 @@\n-        EnumSet<CPUFeature> features = HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures,\n-                                                                                  config.vmVersionExtraFeatures, renaming);\n+        EnumSet<CPUFeature> features = HotSpotJVMCIBackendFactory.convertDynamicFeaturesVector(CPUFeature.class, constants,\n+                                                                                               config.vmVersionFeaturesVector,\n+                                                                                               config.vmVersionFeaturesVectorSize,\n+                                                                                               config.vmVersionFeaturesElemShiftCnt,\n+                                                                                               renaming);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/amd64\/AMD64HotSpotJVMCIBackendFactory.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,2 +49,3 @@\n-    final long vmVersionFeatures = getFieldValue(\"Abstract_VM_Version::_features\", Long.class, \"uint64_t\");\n-    final long vmVersionExtraFeatures = getFieldValue(\"Abstract_VM_Version::_extra_features\", Long.class, \"uint64_t\");\n+    final long vmVersionFeaturesVector = getFieldAddress(\"Abstract_VM_Version::_dynamic_features_vector\", \"uint64_t*\");\n+    final long vmVersionFeaturesVectorSize = getFieldValue(\"Abstract_VM_Version::_dynamic_features_vector_size\", Long.class, \"uint64_t\");\n+    final long vmVersionFeaturesElemShiftCnt = getFieldValue(\"Abstract_VM_Version::_dynamic_features_element_shift_count\", Long.class, \"uint64_t\");\n@@ -93,1 +94,1 @@\n-    final long avx10_2 = getConstant(\"VM_Version::EXTRA_CPU_AVX10_2\", Long.class);\n+    final long avx10_2 = getConstant(\"VM_Version::CPU_AVX10_2\", Long.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/amd64\/AMD64HotSpotVMConfig.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, 0L, emptyMap());\n+        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, emptyMap());\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotJVMCIBackendFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-                           17179869184L);\n+                           34L);\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbLongConstant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}