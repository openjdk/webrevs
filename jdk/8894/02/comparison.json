{"files":[{"patch":"@@ -4148,8 +4148,14 @@\n-        ciMethod* target = type->as_ObjectType()->constant_value()->as_method_handle()->get_vmtarget();\n-        \/\/ We don't do CHA here so only inline static and statically bindable methods.\n-        if (target->is_static() || target->can_be_statically_bound()) {\n-          if (ciMethod::is_consistent_info(callee, target)) {\n-            Bytecodes::Code bc = target->is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokevirtual;\n-            ignore_return = ignore_return || (callee->return_type()->is_void() && !target->return_type()->is_void());\n-            if (try_inline(target, \/*holder_known*\/ !callee->is_static(), ignore_return, bc)) {\n-              return true;\n+        ciObject* mh = type->as_ObjectType()->constant_value();\n+        if (mh->is_method_handle()) {\n+          ciMethod* target = mh->as_method_handle()->get_vmtarget();\n+\n+          \/\/ We don't do CHA here so only inline static and statically bindable methods.\n+          if (target->is_static() || target->can_be_statically_bound()) {\n+            if (ciMethod::is_consistent_info(callee, target)) {\n+              Bytecodes::Code bc = target->is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokevirtual;\n+              ignore_return = ignore_return || (callee->return_type()->is_void() && !target->return_type()->is_void());\n+              if (try_inline(target, \/*holder_known*\/ !callee->is_static(), ignore_return, bc)) {\n+                return true;\n+              }\n+            } else {\n+              print_inlining(target, \"signatures mismatch\", \/*success*\/ false);\n@@ -4158,1 +4164,2 @@\n-            print_inlining(target, \"signatures mismatch\", \/*success*\/ false);\n+            assert(false, \"no inlining through MH::invokeBasic\"); \/\/ missing optimization opportunity due to suboptimal LF shape\n+            print_inlining(target, \"not static or statically bindable\", \/*success*\/ false);\n@@ -4161,1 +4168,2 @@\n-          print_inlining(target, \"not static or statically bindable\", \/*success*\/ false);\n+          assert(mh->is_null_object(), \"not a null\");\n+          print_inlining(callee, \"receiver is always null\", \/*success*\/ false);\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1021,5 +1021,20 @@\n-        const TypeOopPtr* oop_ptr = receiver->bottom_type()->is_oopptr();\n-        ciMethod* target = oop_ptr->const_oop()->as_method_handle()->get_vmtarget();\n-        const int vtable_index = Method::invalid_vtable_index;\n-\n-        if (!ciMethod::is_consistent_info(callee, target)) {\n+        const TypeOopPtr* recv_toop = receiver->bottom_type()->isa_oopptr();\n+        if (recv_toop != NULL) {\n+          ciMethod* target = recv_toop->const_oop()->as_method_handle()->get_vmtarget();\n+          const int vtable_index = Method::invalid_vtable_index;\n+\n+          if (!ciMethod::is_consistent_info(callee, target)) {\n+            print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n+                                   \"signatures mismatch\");\n+            return NULL;\n+          }\n+\n+          CallGenerator *cg = C->call_generator(target, vtable_index,\n+                                                false \/* call_does_dispatch *\/,\n+                                                jvms,\n+                                                allow_inline,\n+                                                PROB_ALWAYS);\n+          return cg;\n+        } else {\n+          assert(receiver->bottom_type() == TypePtr::NULL_PTR, \"not a null: %s\",\n+                 Type::str(receiver->bottom_type()));\n@@ -1027,2 +1042,1 @@\n-                                 \"signatures mismatch\");\n-          return NULL;\n+                                 \"receiver is always null\");\n@@ -1030,7 +1044,0 @@\n-\n-        CallGenerator* cg = C->call_generator(target, vtable_index,\n-                                              false \/* call_does_dispatch *\/,\n-                                              jvms,\n-                                              allow_inline,\n-                                              PROB_ALWAYS);\n-        return cg;\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8287223\n+ * @library \/test\/lib \/ patches\n+ *\n+ * @build java.base\/java.lang.invoke.MethodHandleHelper\n+ * @run main\/bootclasspath\/othervm -Xbatch -XX:CompileCommand=compileonly,*::test -XX:-TieredCompilation                         compiler.jsr292.NullConstantMHReceiver\n+ * @run main\/bootclasspath\/othervm -Xbatch -XX:CompileCommand=compileonly,*::test -XX:+TieredCompilation -XX:TieredStopAtLevel=1 compiler.jsr292.NullConstantMHReceiver\n+ *\/\n+\n+package compiler.jsr292;\n+\n+import java.lang.invoke.MethodHandleHelper;\n+\n+public class NullConstantMHReceiver {\n+    static void test() throws Throwable {\n+        MethodHandleHelper.invokeBasicL(null);\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        for (int i = 0; i < 15000; i++) {\n+            try {\n+                test();\n+            } catch (NullPointerException e) {\n+                \/\/ expected\n+                continue;\n+            }\n+            throw new AssertionError(\"NPE wasn't thrown\");\n+        }\n+        System.out.println(\"TEST PASSED\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/NullConstantMHReceiver.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"}]}