{"files":[{"patch":"@@ -682,3 +682,5 @@\n-          \"=XY, with Y: verify Def-Use modifications during IGVN\"           \\\n-          \"          X: verify that type(n) == n->Value() after IGVN\"       \\\n-          \"X and Y in 0=off; 1=on\")                                         \\\n+          \"=DCBA, with A: verify Def-Use modifications during IGVN\"         \\\n+          \"            B: verify that type(n) == n->Value() after IGVN\"     \\\n+          \"            C: verify Node::Ideal did not miss opportunities\"    \\\n+          \"            D: verify Node::Identity did not miss opportunities\" \\\n+          \"A, B, C, and D in 0=off; 1=on\")                                  \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1075,1 +1075,5 @@\n-  if (is_verify_Value()) {\n+  assert(_worklist.size() == 0, \"igvn worklist must be empty before verify\");\n+\n+  if (is_verify_Value() ||\n+      is_verify_Ideal() ||\n+      is_verify_Identity()) {\n@@ -1083,1 +1087,4 @@\n-      failure |= verify_node_value(n);\n+      if (is_verify_Value())    { failure |= verify_Value_for(n); }\n+      if (is_verify_Ideal())    { failure |= verify_Ideal_for(n, false); }\n+      if (is_verify_Ideal())    { failure |= verify_Ideal_for(n, true); }\n+      if (is_verify_Identity()) { failure |= verify_Identity_for(n); }\n@@ -1100,0 +1107,21 @@\n+\n+  verify_empty_worklist(nullptr);\n+}\n+\n+void PhaseIterGVN::verify_empty_worklist(Node* node) {\n+  \/\/ Verify that the igvn worklist is empty. If no optimization happened, then\n+  \/\/ nothing needs to be on the worklist.\n+  if (_worklist.size() == 0) { return; }\n+\n+  stringStream ss; \/\/ Print as a block without tty lock.\n+  for (uint j = 0; j < _worklist.size(); j++) {\n+    Node* n = _worklist.at(j);\n+    ss.print(\"igvn.worklist[%d] \", j);\n+    n->dump(\"\\n\", false, &ss);\n+  }\n+  if (_worklist.size() != 0 && node != nullptr) {\n+    ss.print_cr(\"Previously optimized:\");\n+    node->dump(\"\\n\", false, &ss);\n+  }\n+  tty->print_cr(\"%s\", ss.as_string());\n+  assert(false, \"igvn worklist must still be empty after verify\");\n@@ -1107,1 +1135,1 @@\n-bool PhaseIterGVN::verify_node_value(Node* n) {\n+bool PhaseIterGVN::verify_Value_for(Node* n) {\n@@ -1152,9 +1180,854 @@\n-  tty->cr();\n-  tty->print_cr(\"Missed Value optimization:\");\n-  n->dump_bfs(1, nullptr, \"\");\n-  tty->print_cr(\"Current type:\");\n-  told->dump_on(tty);\n-  tty->cr();\n-  tty->print_cr(\"Optimized type:\");\n-  tnew->dump_on(tty);\n-  tty->cr();\n+\n+  stringStream ss; \/\/ Print as a block without tty lock.\n+  ss.cr();\n+  ss.print_cr(\"Missed Value optimization:\");\n+  n->dump_bfs(1, nullptr, \"\", &ss);\n+  ss.print_cr(\"Current type:\");\n+  told->dump_on(&ss);\n+  ss.cr();\n+  ss.print_cr(\"Optimized type:\");\n+  tnew->dump_on(&ss);\n+  ss.cr();\n+  tty->print_cr(\"%s\", ss.as_string());\n+  return true;\n+}\n+\n+\/\/ Check that all Ideal optimizations that could be done were done.\n+\/\/ Returns true if it found missed optimization opportunities and\n+\/\/         false otherwise (no missed optimization, or skipped verification).\n+bool PhaseIterGVN::verify_Ideal_for(Node* n, bool can_reshape) {\n+  \/\/ First, we check a list of exceptions, where we skip verification,\n+  \/\/ because there are known cases where Ideal can optimize after IGVN.\n+  \/\/ Some may be expected and cannot be fixed, and others should be fixed.\n+  switch (n->Opcode()) {\n+    \/\/ RangeCheckNode::Ideal looks up the chain for about 999 nodes\n+    \/\/ see \"Range-Check scan limit\". So it is possible that something\n+    \/\/ optimized in that input subgraph, and the RangeCheck was not\n+    \/\/ added to the worklist because it would be too expensive to walk\n+    \/\/ down the graph for 1000 nodes and put all on the worklist.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xbatch --version\n+    case Op_RangeCheck:\n+      return false;\n+\n+    \/\/ IfNode::Ideal does:\n+    \/\/   Node* prev_dom = search_identical(dist, igvn);\n+    \/\/ which means we seach up the CFG, traversing at most up to a distance.\n+    \/\/ If anything happens rather far away from the If, we may not put the If\n+    \/\/ back on the worklist.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_If:\n+      return false;\n+\n+    \/\/ IfNode::simple_subsuming\n+    \/\/ Looks for dominating test that subsumes the current test.\n+    \/\/ Notification could be difficult because of larger distance.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   runtime\/exceptionMsgs\/ArrayIndexOutOfBoundsException\/ArrayIndexOutOfBoundsExceptionTest.java#id1\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_CountedLoopEnd:\n+      return false;\n+\n+    \/\/ LongCountedLoopEndNode::Ideal\n+    \/\/ Probably same issue as above.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/predicates\/assertion\/TestAssertionPredicates.java#NoLoopPredicationXbatch\n+    \/\/   -XX:StressLongCountedLoop=2000000 -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    case Op_LongCountedLoopEnd:\n+      return false;\n+\n+    \/\/ RegionNode::Ideal does \"Skip around the useless IF diamond\".\n+    \/\/   245  IfTrue  === 244\n+    \/\/   258  If  === 245 257\n+    \/\/   259  IfTrue  === 258  [[ 263 ]]\n+    \/\/   260  IfFalse  === 258  [[ 263 ]]\n+    \/\/   263  Region  === 263 260 259  [[ 263 268 ]]\n+    \/\/ to\n+    \/\/   245  IfTrue  === 244\n+    \/\/   263  Region  === 263 245 _  [[ 263 268 ]]\n+    \/\/\n+    \/\/ \"Useless\" means that there is no code in either branch of the If.\n+    \/\/ I found a case where this was not done yet during IGVN.\n+    \/\/ Why does the Region not get added to IGVN worklist when the If diamond becomes useles?\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_Region:\n+      return false;\n+\n+    \/\/ In AddNode::Ideal, we call \"commute\", which swaps the inputs so\n+    \/\/ that smaller idx are first. Tracking it back, it led me to\n+    \/\/ PhaseIdealLoop::remix_address_expressions which swapped the edges.\n+    \/\/\n+    \/\/ Example:\n+    \/\/   Before PhaseIdealLoop::remix_address_expressions\n+    \/\/     154  AddI  === _ 12 144\n+    \/\/   After PhaseIdealLoop::remix_address_expressions\n+    \/\/     154  AddI  === _ 144 12\n+    \/\/   After AddNode::Ideal\n+    \/\/     154  AddI  === _ 12 144\n+    \/\/\n+    \/\/ I suspect that the node should be added to the IGVN worklist after\n+    \/\/ PhaseIdealLoop::remix_address_expressions\n+    \/\/\n+    \/\/ This is the only case I looked at, there may be others. Found like this:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xbatch --version\n+    \/\/\n+    \/\/ The following hit the same logic in PhaseIdealLoop::remix_address_expressions.\n+    \/\/\n+    \/\/ Note: currently all of these fail also for other reasons, for example\n+    \/\/ because of \"commute\" doing the reordering with the phi below. Once\n+    \/\/ that is resolved, we can come back to this issue here.\n+    \/\/\n+    \/\/ case Op_AddD:\n+    \/\/ case Op_AddI:\n+    \/\/ case Op_AddL:\n+    \/\/ case Op_AddF:\n+    \/\/ case Op_MulI:\n+    \/\/ case Op_MulL:\n+    \/\/ case Op_MulF:\n+    \/\/ case Op_MulD:\n+    \/\/   if (n->in(1)->_idx > n->in(2)->_idx) {\n+    \/\/     \/\/ Expect \"commute\" to revert this case.\n+    \/\/     return false;\n+    \/\/   }\n+    \/\/   break; \/\/ keep verifying\n+\n+    \/\/ AddFNode::Ideal calls \"commute\", which can reorder the inputs for this:\n+    \/\/   Check for tight loop increments: Loop-phi of Add of loop-phi\n+    \/\/ It wants to take the phi into in(1):\n+    \/\/    471  Phi  === 435 38 390\n+    \/\/    390  AddF  === _ 471 391\n+    \/\/\n+    \/\/ Other Associative operators are also affected equally.\n+    \/\/\n+    \/\/ Investigate why this does not happen earlier during IGVN.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ReductionPerf.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_AddD:\n+    \/\/case Op_AddI: \/\/ Also affected for other reasons.\n+    \/\/case Op_AddL: \/\/ Also affected for other reasons.\n+    case Op_AddF:\n+    case Op_MulI:\n+    case Op_MulL:\n+    case Op_MulF:\n+    case Op_MulD:\n+    case Op_MinF:\n+    case Op_MinD:\n+    case Op_MaxF:\n+    case Op_MaxD:\n+    \/\/ XorINode::Ideal\n+    \/\/ Found with:\n+    \/\/   compiler\/intrinsics\/chacha\/TestChaCha20.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_XorI:\n+    case Op_XorL:\n+    \/\/ It seems we may have similar issues with the HF cases.\n+    \/\/ Found with aarch64:\n+    \/\/   compiler\/vectorization\/TestFloat16VectorOperations.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_AddHF:\n+    case Op_MulHF:\n+    case Op_MaxHF:\n+    case Op_MinHF:\n+      return false;\n+\n+    \/\/ In MulNode::Ideal the edges can be swapped to help value numbering:\n+    \/\/\n+    \/\/    \/\/ We are OK if right is a constant, or right is a load and\n+    \/\/    \/\/ left is a non-constant.\n+    \/\/    if( !(t2->singleton() ||\n+    \/\/          (in(2)->is_Load() && !(t1->singleton() || in(1)->is_Load())) ) ) {\n+    \/\/      if( t1->singleton() ||       \/\/ Left input is a constant?\n+    \/\/          \/\/ Otherwise, sort inputs (commutativity) to help value numbering.\n+    \/\/          (in(1)->_idx > in(2)->_idx) ) {\n+    \/\/        swap_edges(1, 2);\n+    \/\/\n+    \/\/ Why was this not done earlier during IGVN?\n+    \/\/\n+    \/\/ Found with:\n+    \/\/    test\/hotspot\/jtreg\/gc\/stress\/gcbasher\/TestGCBasherWithG1.java\n+    \/\/    -XX:VerifyIterativeGVN=1110\n+    case Op_AndI:\n+    \/\/ Same for AndL.\n+    \/\/ Found with:\n+    \/\/   compiler\/intrinsics\/bigInteger\/MontgomeryMultiplyTest.java\n+    \/\/    -XX:VerifyIterativeGVN=1110\n+    case Op_AndL:\n+      return false;\n+\n+    \/\/ SubLNode::Ideal does transform like:\n+    \/\/   Convert \"c1 - (y+c0)\" into \"(c1-c0) - y\"\n+    \/\/\n+    \/\/ In IGVN before verification:\n+    \/\/   8423  ConvI2L  === _ 3519  [[ 8424 ]]  #long:-2\n+    \/\/   8422  ConvI2L  === _ 8399  [[ 8424 ]]  #long:3..256:www\n+    \/\/   8424  AddL  === _ 8422 8423  [[ 8383 ]]  !orig=[8382]\n+    \/\/   8016  ConL  === 0  [[ 8383 ]]  #long:0\n+    \/\/   8383  SubL  === _ 8016 8424  [[ 8156 ]]  !orig=[8154]\n+    \/\/\n+    \/\/ And then in verification:\n+    \/\/   8338  ConL  === 0  [[ 8339 8424 ]]  #long:-2     <----- Was constant folded.\n+    \/\/   8422  ConvI2L  === _ 8399  [[ 8424 ]]  #long:3..256:www\n+    \/\/   8424  AddL  === _ 8422 8338  [[ 8383 ]]  !orig=[8382]\n+    \/\/   8016  ConL  === 0  [[ 8383 ]]  #long:0\n+    \/\/   8383  SubL  === _ 8016 8424  [[ 8156 ]]  !orig=[8154]\n+    \/\/\n+    \/\/ So the form changed from:\n+    \/\/   c1 - (y + [8423  ConvI2L])\n+    \/\/ to\n+    \/\/   c1 - (y + -2)\n+    \/\/ but the SubL was not added to the IGVN worklist. Investigate why.\n+    \/\/ There could be other issues too.\n+    \/\/\n+    \/\/ There seems to be a related AddL IGVN optimization that triggers\n+    \/\/ the same SubL optimization, so investigate that too.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_SubL:\n+      return false;\n+\n+    \/\/ SubINode::Ideal does\n+    \/\/ Convert \"x - (y+c0)\" into \"(x-y) - c0\" AND\n+    \/\/ Convert \"c1 - (y+c0)\" into \"(c1-c0) - y\"\n+    \/\/\n+    \/\/ Investigate why this does not yet happen during IGVN.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   test\/hotspot\/jtreg\/compiler\/c2\/IVTest.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_SubI:\n+      return false;\n+\n+    \/\/ AddNode::IdealIL does transform like:\n+    \/\/   Convert x + (con - y) into \"(x - y) + con\"\n+    \/\/\n+    \/\/ In IGVN before verification:\n+    \/\/   8382  ConvI2L\n+    \/\/   8381  ConvI2L  === _ 791  [[ 8383 ]]  #long:0\n+    \/\/   8383  SubL  === _ 8381 8382\n+    \/\/   8168  ConvI2L\n+    \/\/   8156  AddL  === _ 8168 8383  [[ 8158 ]]\n+    \/\/\n+    \/\/ And then in verification:\n+    \/\/   8424  AddL\n+    \/\/   8016  ConL  === 0  [[ 8383 ]]  #long:0  <--- Was constant folded.\n+    \/\/   8383  SubL  === _ 8016 8424\n+    \/\/   8168  ConvI2L\n+    \/\/   8156  AddL  === _ 8168 8383  [[ 8158 ]]\n+    \/\/\n+    \/\/ So the form changed from:\n+    \/\/   x + (ConvI2L(0) - [8382  ConvI2L])\n+    \/\/ to\n+    \/\/   x + (0 - [8424  AddL])\n+    \/\/ but the AddL was not added to the IGVN worklist. Investigate why.\n+    \/\/ There could be other issues too. For example with \"commute\", see above.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_AddL:\n+      return false;\n+\n+    \/\/ SubTypeCheckNode::Ideal calls SubTypeCheckNode::verify_helper, which does\n+    \/\/   Node* cmp = phase->transform(new CmpPNode(subklass, in(SuperKlass)));\n+    \/\/   record_for_cleanup(cmp, phase);\n+    \/\/ This has the effect that these new nodes end up on the IGVN worklist,\n+    \/\/ but if we now leave verification and IGVN itself, we have nodes on the\n+    \/\/ worklist, and that should not be (there are asserts against this).\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xbatch --version\n+    case Op_SubTypeCheck:\n+      return false;\n+\n+    \/\/ LoopLimitNode::Ideal when stride is constant power-of-2, we can do a lowering\n+    \/\/ to other nodes: Conv, Add, Sub, Mul, And ...\n+    \/\/\n+    \/\/  107  ConI  === 0  [[ ... ]]  #int:2\n+    \/\/   84  LoadRange  === _ 7 83\n+    \/\/   50  ConI  === 0  [[ ... ]]  #int:0\n+    \/\/  549  LoopLimit  === _ 50 84 107\n+    \/\/\n+    \/\/ I stepped backward, to see how the node was generated, and I found that it was\n+    \/\/ created in PhaseIdealLoop::exact_limit and not changed since. It is added to the\n+    \/\/ IGVN worklist. I quickly checked when it goes into LoopLimitNode::Ideal after\n+    \/\/ that, and it seems we want to skip lowering it until after loop-opts, but never\n+    \/\/ add call record_for_post_loop_opts_igvn. This would be an easy fix, but there\n+    \/\/ could be other issues too.\n+    \/\/\n+    \/\/ Fond with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_LoopLimit:\n+      return false;\n+\n+    \/\/ PhiNode::Ideal calls split_flow_path, which tries to do this:\n+    \/\/ \"This optimization tries to find two or more inputs of phi with the same constant\n+    \/\/ value. It then splits them into a separate Phi, and according Region.\"\n+    \/\/\n+    \/\/ Example:\n+    \/\/   130  DecodeN  === _ 129\n+    \/\/    50  ConP  === 0  [[ 18 91 99 18 ]]  #null\n+    \/\/    18  Phi  === 14 50 130 50  [[ 133 ]]  #java\/lang\/Object *  Oop:java\/lang\/Object *\n+    \/\/\n+    \/\/  turns into:\n+    \/\/\n+    \/\/    50  ConP  === 0  [[ 99 91 18 ]]  #null\n+    \/\/   130  DecodeN  === _ 129  [[ 18 ]]\n+    \/\/    18  Phi  === 14 130 50  [[ 133 ]]  #java\/lang\/Object *  Oop:java\/lang\/Object *\n+    \/\/\n+    \/\/ We would have to investigate why this optimization does not happen during IGVN.\n+    \/\/ There could also be other issues - I did not investigate further yet.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_Phi:\n+      return false;\n+\n+    \/\/ MemBarNode::Ideal does \"Eliminate volatile MemBars for scalar replaced objects\".\n+    \/\/ For examle \"The allocated object does not escape\".\n+    \/\/\n+    \/\/ It seems the difference to earlier calls to MemBarNode::Ideal, is that there\n+    \/\/ alloc->as_Allocate()->does_not_escape_thread() returned false, but in verification\n+    \/\/ it returned true. Why does the MemBarStoreStore not get added to the IGVN\n+    \/\/ worklist when this change happens?\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_MemBarStoreStore:\n+      return false;\n+\n+    \/\/ ConvI2LNode::Ideal converts\n+    \/\/   648  AddI  === _ 583 645  [[ 661 ]]\n+    \/\/   661  ConvI2L  === _ 648  [[ 664 ]]  #long:0..maxint-1:www\n+    \/\/ into\n+    \/\/   772  ConvI2L  === _ 645  [[ 773 ]]  #long:-120..maxint-61:www\n+    \/\/   771  ConvI2L  === _ 583  [[ 773 ]]  #long:60..120:www\n+    \/\/   773  AddL  === _ 771 772  [[ ]]\n+    \/\/\n+    \/\/ We have to investigate why this does not happen during IGVN in this case.\n+    \/\/ There could also be other issues - I did not investigate further yet.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    case Op_ConvI2L:\n+      return false;\n+\n+    \/\/ AddNode::IdealIL can do this transform (and similar other ones):\n+    \/\/   Convert \"a*b+a*c into a*(b+c)\n+    \/\/ The example had AddI(MulI(a, b), MulI(a, c)). Why did this not happen\n+    \/\/ during IGVN? There was a mutation for one of the MulI, and only\n+    \/\/ after that the pattern was as needed for the optimization. The MulI\n+    \/\/ was added to the IGVN worklist, but not the AddI. This probably\n+    \/\/ can be fixed by adding the correct pattern in add_users_of_use_to_worklist.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ReductionPerf.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_AddI:\n+      return false;\n+\n+    \/\/ ArrayCopyNode::Ideal\n+    \/\/    calls ArrayCopyNode::prepare_array_copy\n+    \/\/    calls Compile::conv_I2X_index        -> is called with sizetype = intcon(0), I think that\n+    \/\/                                            is not expected, and we create a range int:0..-1\n+    \/\/    calls Compile::constrained_convI2L   -> creates ConvI2L(intcon(1), int:0..-1)\n+    \/\/                                            note: the type is already empty!\n+    \/\/    calls PhaseIterGVN::transform\n+    \/\/    calls PhaseIterGVN::transform_old\n+    \/\/    calls PhaseIterGVN::subsume_node     -> subsume ConvI2L with TOP\n+    \/\/    calls Unique_Node_List::push         -> pushes TOP to worklist\n+    \/\/\n+    \/\/ Once we get back to ArrayCopyNode::prepare_array_copy, we get back TOP, and\n+    \/\/ return false. This means we eventually return nullptr from ArrayCopyNode::Ideal.\n+    \/\/\n+    \/\/ Question: is it ok to push anything to the worklist during ::Ideal, if we will\n+    \/\/           return nullptr, indicating nothing happened?\n+    \/\/           Is it smart to do transform in Compile::constrained_convI2L, and then\n+    \/\/           check for TOP in calls ArrayCopyNode::prepare_array_copy?\n+    \/\/           Should we just allow TOP to land on the worklist, as an exception?\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/arraycopy\/TestArrayCopyAsLoadsStores.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_ArrayCopy:\n+      return false;\n+\n+    \/\/ CastLLNode::Ideal\n+    \/\/    calls ConstraintCastNode::optimize_integer_cast -> pushes CastLL through SubL\n+    \/\/\n+    \/\/ Could be a notification issue, where updates inputs of CastLL do not notify\n+    \/\/ down through SubL to CastLL.\n+    \/\/\n+    \/\/ Found With:\n+    \/\/   compiler\/c2\/TestMergeStoresMemorySegment.java#byte-array\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_CastLL:\n+      return false;\n+\n+    \/\/ Similar case happens to CastII\n+    \/\/\n+    \/\/ Found With:\n+    \/\/   compiler\/c2\/TestScalarReplacementMaxLiveNodes.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_CastII:\n+      return false;\n+\n+    \/\/ MaxLNode::Ideal\n+    \/\/   calls AddNode::Ideal\n+    \/\/   calls commute -> decides to swap edges\n+    \/\/\n+    \/\/ Another notification issue, because we check inputs of inputs?\n+    \/\/ MaxL -> Phi -> Loop\n+    \/\/ MaxL -> Phi -> MaxL\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/c2\/irTests\/TestIfMinMax.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_MaxL:\n+    case Op_MinL:\n+      return false;\n+\n+    \/\/ OrINode::Ideal\n+    \/\/   calls AddNode::Ideal\n+    \/\/   calls commute -> left is Load, right not -> commute.\n+    \/\/\n+    \/\/ Not sure why notification does not work here, seems like\n+    \/\/ the depth is only 1, so it should work. Needs investigation.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/codegen\/TestCharVect2.java#id0\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_OrI:\n+    case Op_OrL:\n+      return false;\n+\n+    \/\/ Bool -> constant folded to 1.\n+    \/\/ Issue with notification?\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_Bool:\n+      return false;\n+\n+    \/\/ LShiftLNode::Ideal\n+    \/\/ Looks at pattern: \"(x + x) << c0\", converts it to \"x << (c0 + 1)\"\n+    \/\/ Probably a notification issue.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/conversions\/TestMoveConvI2LOrCastIIThruAddIs.java\n+    \/\/   -ea -esa -XX:CompileThreshold=100 -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    case Op_LShiftL:\n+      return false;\n+\n+    \/\/ LShiftINode::Ideal\n+    \/\/ pattern: ((x + con1) << con2) -> x << con2 + con1 << con2\n+    \/\/ Could be issue with notification of inputs of inputs\n+    \/\/\n+    \/\/ Side-note: should cases like these not be shared between\n+    \/\/            LShiftI and LShiftL?\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/escapeAnalysis\/Test6689060.java\n+    \/\/   -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110 -ea -esa -XX:CompileThreshold=100 -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    case Op_LShiftI:\n+      return false;\n+\n+    \/\/ AddPNode::Ideal seems to do set_req without removing lock first.\n+    \/\/ Found with various vector tests tier1-tier3.\n+    case Op_AddP:\n+      return false;\n+\n+    \/\/ StrIndexOfNode::Ideal\n+    \/\/ Found in tier1-3.\n+    case Op_StrIndexOf:\n+    case Op_StrIndexOfChar:\n+      return false;\n+\n+    \/\/ StrEqualsNode::Identity\n+    \/\/\n+    \/\/ Found (linux x64 only?) with:\n+    \/\/   serviceability\/sa\/ClhsdbThreadContext.java\n+    \/\/   -XX:+UnlockExperimentalVMOptions -XX:LockingMode=1 -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    case Op_StrEquals:\n+      return false;\n+\n+    \/\/ AryEqNode::Ideal\n+    \/\/ Not investigated. Reshapes itself and adds lots of nodes to the worklist.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/i2c_c2i\/Test.java\n+    \/\/   -XX:+UnlockDiagnosticVMOptions -XX:-TieredCompilation -XX:+StressUnstableIfTraps -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    case Op_AryEq:\n+      return false;\n+\n+    \/\/ MergeMemNode::Ideal\n+    \/\/ Found in tier1-3.\n+    case Op_MergeMem:\n+      return false;\n+\n+    \/\/ URShiftINode::Ideal\n+    \/\/ Found in tier1-3.\n+    case Op_URShiftI:\n+      return false;\n+\n+    \/\/ CMoveINode::Ideal\n+    \/\/ Found in tier1-3.\n+    case Op_CMoveI:\n+      return false;\n+\n+    \/\/ CmpPNode::Ideal calls isa_const_java_mirror\n+    \/\/ and generates new constant nodes, even if no progress is made.\n+    \/\/ We can probably rewrite this so that only types are generated.\n+    \/\/ It seems that object types are not hashed, we could investigate\n+    \/\/ if that is an option as well.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1110 -Xcomp --version\n+    case Op_CmpP:\n+      return false;\n+\n+    \/\/ MinINode::Ideal\n+    \/\/ Did not investigate, but there are some patterns that might\n+    \/\/ need more notification.\n+    case Op_MinI:\n+    case Op_MaxI: \/\/ preemptively removed it as well.\n+      return false;\n+  }\n+\n+  if (n->is_Load()) {\n+    \/\/ LoadNode::Ideal uses tries to find an earlier memory state, and\n+    \/\/ checks can_see_stored_value for it.\n+    \/\/\n+    \/\/ Investigate why this was not already done during IGVN.\n+    \/\/ A similar issue happens with Identity.\n+    \/\/\n+    \/\/ There seem to be other cases where loads go up some steps, like\n+    \/\/ LoadNode::Ideal going up 10x steps to find dominating load.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   test\/hotspot\/jtreg\/compiler\/arraycopy\/TestCloneAccess.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    return false;\n+  }\n+\n+  if (n->is_Store()) {\n+    \/\/ StoreNode::Ideal can do this:\n+    \/\/  \/\/ Capture an unaliased, unconditional, simple store into an initializer.\n+    \/\/  \/\/ Or, if it is independent of the allocation, hoist it above the allocation.\n+    \/\/ That replaces the Store with a MergeMem.\n+    \/\/\n+    \/\/ We have to investigate why this does not happen during IGVN in this case.\n+    \/\/ There could also be other issues - I did not investigate further yet.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=0100 -Xcomp --version\n+    return false;\n+  }\n+\n+  if (n->is_Vector()) {\n+    \/\/ VectorNode::Ideal swaps edges, but only for ops\n+    \/\/ that are deemed commutable. But swap_edges\n+    \/\/ requires the hash to be invariant when the edges\n+    \/\/ are swapped, which is not implemented for these\n+    \/\/ vector nodes. This seems not to create any trouble\n+    \/\/ usually, but we can also get graphs where in the\n+    \/\/ end the nodes are not all commuted, so there is\n+    \/\/ definitively an issue here.\n+    \/\/\n+    \/\/ Probably we have two options: kill the hash, or\n+    \/\/ properly make the hash commutation friendly.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/vectorapi\/TestMaskedMacroLogicVector.java\n+    \/\/   -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110 -XX:+UseParallelGC -XX:+UseNUMA\n+    return false;\n+  }\n+\n+  if (n->is_Region()) {\n+    \/\/ LoopNode::Ideal calls RegionNode::Ideal.\n+    \/\/ CountedLoopNode::Ideal calls RegionNode::Ideal too.\n+    \/\/ But I got an issue because RegionNode::optimize_trichotomy\n+    \/\/ then modifies another node, and pushes nodes to the worklist\n+    \/\/ Not sure if this is ok, modifying another node like that.\n+    \/\/ Maybe it is, then we need to look into what to do with\n+    \/\/ the nodes that are now on the worklist, maybe just clear\n+    \/\/ them out again. But maybe modifying other nodes like that\n+    \/\/ is also bad design. In the end, we return nullptr for\n+    \/\/ the current CountedLoop. But the extra nodes on the worklist\n+    \/\/ trip the asserts later on.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/eliminateAutobox\/TestShortBoxing.java\n+    \/\/   -ea -esa -XX:CompileThreshold=100 -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    return false;\n+  }\n+\n+  if (n->is_CallJava()) {\n+    \/\/ CallStaticJavaNode::Ideal\n+    \/\/ Led to a crash:\n+    \/\/   assert((is_CallStaticJava() && cg->is_mh_late_inline()) || (is_CallDynamicJava() && cg->is_virtual_late_inline())) failed: mismatch\n+    \/\/\n+    \/\/ Did not investigate yet, could be a bug.\n+    \/\/ Or maybe it does not expect to be called during verification.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   test\/jdk\/jdk\/incubator\/vector\/VectorRuns.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+\n+    \/\/ CallDynamicJavaNode::Ideal, and I think also for CallStaticJavaNode::Ideal\n+    \/\/  and possibly their subclasses.\n+    \/\/ During late inlining it can call CallJavaNode::register_for_late_inline\n+    \/\/ That means we do more rounds of late inlining, but might fail.\n+    \/\/ Then we do IGVN again, and register the node again for late inlining.\n+    \/\/ This creates an endless cycle. Everytime we try late inlining, we\n+    \/\/ are also creating more nodes, especially SafePoint and MergeMem.\n+    \/\/ These nodes are immediately rejected when the inlining fails in the\n+    \/\/ do_late_inline_check, but they still grow the memory, until we hit\n+    \/\/ the MemLimit and crash.\n+    \/\/ The assumption here seems that CallDynamicJavaNode::Ideal does not get\n+    \/\/ called repeatedly, and eventually we terminate. I fear this is not\n+    \/\/ a great assumption to make. We should investigate more.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/loopopts\/superword\/TestDependencyOffsets.java#vanilla-U\n+    \/\/   -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    return false;\n+  }\n+\n+  \/\/ The number of nodes shoud not increase.\n+  uint old_unique = C->unique();\n+\n+  Node* i = n->Ideal(this, can_reshape);\n+  \/\/ If there was no new Idealization, we are probably happy.\n+  if (i == nullptr) {\n+    if (old_unique < C->unique()) {\n+      stringStream ss; \/\/ Print as a block without tty lock.\n+      ss.cr();\n+      ss.print_cr(\"Ideal optimization did not make progress but created new unused nodes.\");\n+      ss.print_cr(\"  old_unique = %d, unique = %d\", old_unique, C->unique());\n+      n->dump_bfs(1, nullptr, \"\", &ss);\n+      tty->print_cr(\"%s\", ss.as_string());\n+      return true;\n+    }\n+\n+    verify_empty_worklist(n);\n+\n+    \/\/ Everything is good.\n+    return false;\n+  }\n+\n+  \/\/ We just saw a new Idealization which was not done during IGVN.\n+  stringStream ss; \/\/ Print as a block without tty lock.\n+  ss.cr();\n+  ss.print_cr(\"Missed Ideal optimization (can_reshape=%s):\", can_reshape ? \"true\": \"false\");\n+  if (i == n) {\n+    ss.print_cr(\"The node was reshaped by Ideal.\");\n+  } else {\n+    ss.print_cr(\"The node was replaced by Ideal.\");\n+    ss.print_cr(\"Old node:\");\n+    n->dump_bfs(1, nullptr, \"\", &ss);\n+  }\n+  ss.print_cr(\"The result after Ideal:\");\n+  i->dump_bfs(1, nullptr, \"\", &ss);\n+  tty->print_cr(\"%s\", ss.as_string());\n+  return true;\n+}\n+\n+\/\/ Check that all Identity optimizations that could be done were done.\n+\/\/ Returns true if it found missed optimization opportunities and\n+\/\/         false otherwise (no missed optimization, or skipped verification).\n+bool PhaseIterGVN::verify_Identity_for(Node* n) {\n+  \/\/ First, we check a list of exceptions, where we skip verification,\n+  \/\/ because there are known cases where Ideal can optimize after IGVN.\n+  \/\/ Some may be expected and cannot be fixed, and others should be fixed.\n+  switch (n->Opcode()) {\n+    \/\/ SafePointNode::Identity can remove SafePoints, but wants to wait until\n+    \/\/ after loopopts:\n+    \/\/   \/\/ Transforming long counted loops requires a safepoint node. Do not\n+    \/\/   \/\/ eliminate a safepoint until loop opts are over.\n+    \/\/   if (in(0)->is_Proj() && !phase->C->major_progress()) {\n+    \/\/\n+    \/\/ I think the check for major_progress does delay it until after loopopts\n+    \/\/ but it does not ensure that the node is on the IGVN worklist after\n+    \/\/ loopopts. I think we should try to instead check for\n+    \/\/ phase->C->post_loop_opts_phase() and call record_for_post_loop_opts_igvn.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1000 -Xcomp --version\n+    case Op_SafePoint:\n+      return false;\n+\n+    \/\/ MergeMemNode::Identity replaces the MergeMem with its base_memory if it\n+    \/\/ does not record any other memory splits.\n+    \/\/\n+    \/\/ I did not deeply investigate, but it looks like MergeMemNode::Identity\n+    \/\/ never got called during IGVN for this node, investigate why.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1000 -Xcomp --version\n+    case Op_MergeMem:\n+      return false;\n+\n+    \/\/ ConstraintCastNode::Identity finds casts that are the same, except that\n+    \/\/ the control is \"higher up\", i.e. dominates. The call goes via\n+    \/\/ ConstraintCastNode::dominating_cast to PhaseGVN::is_dominator_helper,\n+    \/\/ which traverses up to 100 idom steps. If anything gets optimized somewhere\n+    \/\/ away from the cast, but within 100 idom steps, the cast may not be\n+    \/\/ put on the IGVN worklist any more.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1000 -Xcomp --version\n+    case Op_CastPP:\n+    case Op_CastII:\n+    case Op_CastLL:\n+      return false;\n+\n+    \/\/ Same issue for CheckCastPP, uses ConstraintCastNode::Identity and\n+    \/\/ checks dominator, which may be changed, but too far up for notification\n+    \/\/ to work.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/c2\/irTests\/TestSkeletonPredicates.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_CheckCastPP:\n+      return false;\n+\n+    \/\/ In SubNode::Identity, we do:\n+    \/\/   Convert \"(X+Y) - Y\" into X and \"(X+Y) - X\" into Y\n+    \/\/ In the example, the AddI had an input replaced, the AddI is\n+    \/\/ added to the IGVN worklist, but the SubI is one link further\n+    \/\/ down and is not added. I checked add_users_of_use_to_worklist\n+    \/\/ where I would expect the SubI would be added, and I cannot\n+    \/\/ find the pattern, only this one:\n+    \/\/   If changed AddI\/SubI inputs, check CmpU for range check optimization.\n+    \/\/\n+    \/\/ Fix this \"notification\" issue and check if there are any other\n+    \/\/ issues.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1000 -Xcomp --version\n+    case Op_SubI:\n+    case Op_SubL:\n+      return false;\n+\n+    \/\/ PhiNode::Identity checks for patterns like:\n+    \/\/   r = (x != con) ? x : con;\n+    \/\/ that can be constant folded to \"x\".\n+    \/\/\n+    \/\/ Call goes through PhiNode::is_cmove_id and CMoveNode::is_cmove_id.\n+    \/\/ I suspect there was some earlier change to one of the inputs, but\n+    \/\/ not all relevant outputs were put on the IGVN worklist.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   test\/hotspot\/jtreg\/gc\/stress\/gcbasher\/TestGCBasherWithG1.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_Phi:\n+      return false;\n+\n+    \/\/ ConvI2LNode::Identity does\n+    \/\/ convert I2L(L2I(x)) => x\n+    \/\/\n+    \/\/ Investigate why this did not already happen during IGVN.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/loopopts\/superword\/TestDependencyOffsets.java#vanilla-A\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_ConvI2L:\n+      return false;\n+\n+    \/\/ MaxNode::find_identity_operation\n+    \/\/  Finds patterns like Max(A, Max(A, B)) -> Max(A, B)\n+    \/\/  This can be a 2-hop search, so maybe notification is not\n+    \/\/  good enough.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   compiler\/codegen\/TestBooleanVect.java\n+    \/\/   -XX:VerifyIterativeGVN=1110\n+    case Op_MaxL:\n+    case Op_MinL:\n+    case Op_MaxI:\n+    case Op_MinI:\n+    case Op_MaxF:\n+    case Op_MinF:\n+    case Op_MaxHF:\n+    case Op_MinHF:\n+    case Op_MaxD:\n+    case Op_MinD:\n+      return false;\n+\n+\n+    \/\/ AddINode::Identity\n+    \/\/ Converts (x-y)+y to x\n+    \/\/ Could be issue with notification\n+    \/\/\n+    \/\/ Turns out AddL does the same.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/  compiler\/c2\/Test6792161.java\n+    \/\/  -ea -esa -XX:CompileThreshold=100 -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    case Op_AddI:\n+    case Op_AddL:\n+      return false;\n+\n+    \/\/ AbsINode::Identity\n+    \/\/ Not investigated yet.\n+    case Op_AbsI:\n+      return false;\n+  }\n+\n+  if (n->is_Load()) {\n+    \/\/ LoadNode::Identity tries to look for an earlier store value via\n+    \/\/ can_see_stored_value. I found an example where this led to\n+    \/\/ an Allocation, where we could assume the value was still zero.\n+    \/\/ So the LoadN can be replaced with a zerocon.\n+    \/\/\n+    \/\/ Investigate why this was not already done during IGVN.\n+    \/\/ A similar issue happens with Ideal.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1000 -Xcomp --version\n+    return false;\n+  }\n+\n+  if (n->is_Store()) {\n+    \/\/ StoreNode::Identity\n+    \/\/ Not investigated, but found missing optimization for StoreI.\n+    \/\/ Looks like a StoreI is replaced with an InitializeNode.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   applications\/ctw\/modules\/java_base_2.java\n+    \/\/   -ea -esa -XX:CompileThreshold=100 -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation -Djava.awt.headless=true -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=1110\n+    return false;\n+  }\n+\n+  if (n->is_Vector()) {\n+    \/\/ Found with tier1-3. Not investigated yet.\n+    \/\/ The observed issue was with AndVNode::Identity\n+    return false;\n+  }\n+\n+  Node* i = n->Identity(this);\n+  \/\/ If we cannot find any other Identity, we are happy.\n+  if (i == n) {\n+    verify_empty_worklist(n);\n+    return false;\n+  }\n+\n+  \/\/ The verification just found a new Identity that was not found during IGVN.\n+  stringStream ss; \/\/ Print as a block without tty lock.\n+  ss.cr();\n+  ss.print_cr(\"Missed Identity optimization:\");\n+  ss.print_cr(\"Old node:\");\n+  n->dump_bfs(1, nullptr, \"\", &ss);\n+  ss.print_cr(\"New node:\");\n+  i->dump_bfs(1, nullptr, \"\", &ss);\n+  tty->print_cr(\"%s\", ss.as_string());\n@@ -1893,1 +2766,1 @@\n-\/\/ We have a list of exceptions, see comments in verify_node_value.\n+\/\/ We have a list of exceptions, see comments in verify_Value_for.\n@@ -1898,1 +2771,1 @@\n-    failure |= verify_node_value(n);\n+    failure |= verify_Value_for(n);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":887,"deletions":14,"binary":false,"changes":901,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -497,1 +497,4 @@\n-  bool verify_node_value(Node* n);\n+  bool verify_Value_for(Node* n);\n+  bool verify_Ideal_for(Node* n, bool can_reshape);\n+  bool verify_Identity_for(Node* n);\n+  void verify_empty_worklist(Node* n);\n@@ -596,0 +599,8 @@\n+  static bool is_verify_Ideal() {\n+    \/\/ '-XX:VerifyIterativeGVN=100'\n+    return ((VerifyIterativeGVN % 1000) \/ 100) == 1;\n+  }\n+  static bool is_verify_Identity() {\n+    \/\/ '-XX:VerifyIterativeGVN=1000'\n+    return ((VerifyIterativeGVN % 10000) \/ 1000) == 1;\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -302,0 +302,1 @@\n+  const int max_modes = 4;\n@@ -303,1 +304,1 @@\n-  for (int i = 0; i < 2; i++) {\n+  for (int i = 0; i < max_modes; i++) {\n@@ -315,1 +316,1 @@\n-                        \"for VerifyIterativeGVN: maximal 2 digits\\n\", original_value);\n+                        \"for VerifyIterativeGVN: maximal %d digits\\n\", original_value, max_modes);\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @summary Run with -Xcomp to test -XX:VerifyIterativeGVN=11 in debug builds.\n+ * @summary Run with -Xcomp to test -XX:VerifyIterativeGVN=1111 in debug builds.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\/timeout=300 -Xbatch -Xcomp -XX:VerifyIterativeGVN=11 compiler.c2.TestVerifyIterativeGVN\n+ * @run main\/othervm\/timeout=300 -Xcomp -XX:VerifyIterativeGVN=1111 compiler.c2.TestVerifyIterativeGVN\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestVerifyIterativeGVN.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}