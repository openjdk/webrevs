{"files":[{"patch":"@@ -27,0 +27,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -86,0 +87,31 @@\n+#if defined(TARGET_COMPILER_gcc) && !defined(_WIN64)\n+JRT_LEAF(jfloat, SharedRuntime::frem(jfloat x, jfloat y))\n+  jfloat retval;\n+  asm (\"\\\n+1:               \\n\\\n+fprem            \\n\\\n+fnstsw %%ax      \\n\\\n+test   $0x4,%%ah \\n\\\n+jne    1b        \\n\\\n+\"\n+    :\"=t\"(retval)\n+    :\"0\"(x), \"u\"(y)\n+    :\"cc\", \"ax\");\n+  return retval;\n+JRT_END\n+\n+JRT_LEAF(jdouble, SharedRuntime::drem(jdouble x, jdouble y))\n+  jdouble retval;\n+  asm (\"\\\n+1:               \\n\\\n+fprem            \\n\\\n+fnstsw %%ax      \\n\\\n+test   $0x4,%%ah \\n\\\n+jne    1b        \\n\\\n+\"\n+    :\"=t\"(retval)\n+    :\"0\"(x), \"u\"(y)\n+    :\"cc\", \"ax\");\n+  return retval;\n+JRT_END\n+#endif \/\/ TARGET_COMPILER_gcc && !_WIN64\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -231,0 +231,1 @@\n+#ifdef _WIN64\n@@ -235,0 +236,1 @@\n+#endif\n@@ -236,1 +238,2 @@\n-JRT_LEAF(jfloat, SharedRuntime::frem(jfloat  x, jfloat  y))\n+#if !defined(TARGET_COMPILER_gcc) || defined(_WIN64)\n+JRT_LEAF(jfloat, SharedRuntime::frem(jfloat x, jfloat y))\n@@ -254,1 +257,0 @@\n-\n@@ -270,0 +272,1 @@\n+#endif \/\/ !TARGET_COMPILER_gcc || _WIN64\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.floatingpoint;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Tests for float and double modulo.\n+ * Testcase is based on: https:\/\/github.com\/cirosantilli\/java-cheat\/blob\/c5ffd8ea19c5620ce752b6c98b2d3579be2bef98\/Nan.java\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class DremFrem {\n+\n+    private static final int DEFAULT_X_RANGE = 1 << 11;\n+    private static final int DEFAULT_Y_RANGE = 1 << 11;\n+    private static boolean regressionValue = false;\n+\n+    @Benchmark\n+    @OperationsPerInvocation(DEFAULT_X_RANGE * DEFAULT_Y_RANGE)\n+    public void calcFloatJava(Blackhole bh) {\n+        for (int i = 0; i < DEFAULT_X_RANGE; i++) {\n+            for (int j = DEFAULT_Y_RANGE; j > 0; j--) {\n+                float x = i;\n+                float y = j;\n+                boolean result = (13.0F * x * x * x) % y == 1.0F;\n+                regressionValue = regressionValue & result;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(DEFAULT_X_RANGE * DEFAULT_Y_RANGE)\n+    public void calcDoubleJava(Blackhole bh) {\n+        for (int i = 0; i < DEFAULT_X_RANGE; i++) {\n+            for (int j = DEFAULT_Y_RANGE; j > 0; j--) {\n+                double x = i;\n+                double y = j;\n+                boolean result = (13.0D * x * x * x) % y == 1.0D;\n+                regressionValue = regressionValue & result;\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"divzero\")\n+    public void cornercaseFloatJava_divzero(Blackhole bh) {\n+            assert Float.isNaN(10 \/ 0);\n+            assert Float.isNaN(10 \/ 0);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(DEFAULT_X_RANGE * DEFAULT_Y_RANGE)\n+    public void cornercaseFloatJava(Blackhole bh) {\n+        for (int i = 0; i < DEFAULT_X_RANGE * DEFAULT_Y_RANGE; i++) {\n+            \/\/ Generate some NaNs.\n+            float nan            = Float.NaN;\n+            float zero_div_zero  = 0.0f \/ 0.0f;\n+            float sqrt_negative  = (float)Math.sqrt(-1.0);\n+            float log_negative   = (float)Math.log(-1.0);\n+            float inf_minus_inf  = Float.POSITIVE_INFINITY - Float.POSITIVE_INFINITY;\n+            float inf_times_zero = Float.POSITIVE_INFINITY * 0.0f;\n+            float quiet_nan1     = Float.intBitsToFloat(0x7fc00001);\n+            float quiet_nan2     = Float.intBitsToFloat(0x7fc00002);\n+            float signaling_nan1 = Float.intBitsToFloat(0x7fa00001);\n+            float signaling_nan2 = Float.intBitsToFloat(0x7fa00002);\n+            float nan_minus      = -nan;\n+\n+            \/\/ Generate some infinities.\n+            float positive_inf   = Float.POSITIVE_INFINITY;\n+            float negative_inf   = Float.NEGATIVE_INFINITY;\n+            float one_div_zero   = 1.0f \/ 0.0f;\n+            float log_zero       = (float)Math.log(0.0);\n+\n+            \/\/ Double check that they are actually NaNs.\n+            assert  Float.isNaN(nan);\n+            assert  Float.isNaN(zero_div_zero);\n+            assert  Float.isNaN(sqrt_negative);\n+            assert  Float.isNaN(inf_minus_inf);\n+            assert  Float.isNaN(inf_times_zero);\n+            assert  Float.isNaN(quiet_nan1);\n+            assert  Float.isNaN(quiet_nan2);\n+            assert  Float.isNaN(signaling_nan1);\n+            assert  Float.isNaN(signaling_nan2);\n+            assert  Float.isNaN(nan_minus);\n+            assert  Float.isNaN(log_negative);\n+\n+            \/\/ Double check that they are infinities.\n+            assert  Float.isInfinite(positive_inf);\n+            assert  Float.isInfinite(negative_inf);\n+            assert !Float.isNaN(positive_inf);\n+            assert !Float.isNaN(negative_inf);\n+            assert one_div_zero == positive_inf;\n+            assert log_zero == negative_inf;\n+                \/\/ Double check infinities.\n+\n+            assert Float.isNaN(positive_inf \/ 10);\n+            assert Float.isNaN(negative_inf \/ 10);\n+            cornercaseFloatJava_divzero(bh);\n+            assert (+10 \/ positive_inf) == +10;\n+            assert (+10 \/ negative_inf) == +10;\n+            assert (-10 \/ positive_inf) == -10;\n+            assert (-10 \/ negative_inf) == -10;\n+\n+            \/\/ NaN comparisons always fail.\n+            \/\/ Therefore, all tests that we will do afterwards will be just isNaN.\n+            assert !(1.0f < nan);\n+            assert !(1.0f == nan);\n+            assert !(1.0f > nan);\n+            assert !(nan == nan);\n+\n+            \/\/ NaN propagate through most operations.\n+            assert Float.isNaN(nan + 1.0f);\n+            assert Float.isNaN(1.0f + nan);\n+            assert Float.isNaN(nan + nan);\n+            assert Float.isNaN(nan \/ 1.0f);\n+            assert Float.isNaN(1.0f \/ nan);\n+            assert Float.isNaN((float)Math.sqrt((double)nan));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"divzero\")\n+    public void cornercaseDoubleJava_divzero(Blackhole bh) {\n+            assert Double.isNaN(10 \/ 0);\n+            assert Double.isNaN(10 \/ 0);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(DEFAULT_X_RANGE * DEFAULT_Y_RANGE)\n+    public void cornercaseDoubleJava(Blackhole bh) {\n+        for (int i = 0; i < DEFAULT_X_RANGE * DEFAULT_Y_RANGE; i++) {\n+            \/\/ Generate some NaNs.\n+            double nan            = Double.NaN;\n+            double zero_div_zero  = 0.0f \/ 0.0f;\n+            double sqrt_negative  = (double)Math.sqrt(-1.0);\n+            double log_negative   = (double)Math.log(-1.0);\n+            double inf_minus_inf  = Double.POSITIVE_INFINITY - Double.POSITIVE_INFINITY;\n+            double inf_times_zero = Double.POSITIVE_INFINITY * 0.0f;\n+            double quiet_nan1     = Double.longBitsToDouble(0x7ffc000000000001L);\n+            double quiet_nan2     = Double.longBitsToDouble(0x7ffc000000000002L);\n+            double signaling_nan1 = Double.longBitsToDouble(0x7ffa000000000001L);\n+            double signaling_nan2 = Double.longBitsToDouble(0x7ffa000000000002L);\n+            double nan_minus      = -nan;\n+\n+            \/\/ Generate some infinities.\n+            double positive_inf   = Double.POSITIVE_INFINITY;\n+            double negative_inf   = Double.NEGATIVE_INFINITY;\n+            double one_div_zero   = 1.0d \/ 0.0f;\n+            double log_zero       = (double)Math.log(0.0);\n+\n+            \/\/ Double check that they are actually NaNs.\n+            assert  Double.isNaN(nan);\n+            assert  Double.isNaN(zero_div_zero);\n+            assert  Double.isNaN(sqrt_negative);\n+            assert  Double.isNaN(inf_minus_inf);\n+            assert  Double.isNaN(inf_times_zero);\n+            assert  Double.isNaN(quiet_nan1);\n+            assert  Double.isNaN(quiet_nan2);\n+            assert  Double.isNaN(signaling_nan1);\n+            assert  Double.isNaN(signaling_nan2);\n+            assert  Double.isNaN(nan_minus);\n+            assert  Double.isNaN(log_negative);\n+\n+            \/\/ Double check that they are infinities.\n+            assert  Double.isInfinite(positive_inf);\n+            assert  Double.isInfinite(negative_inf);\n+            assert !Double.isNaN(positive_inf);\n+            assert !Double.isNaN(negative_inf);\n+            assert one_div_zero == positive_inf;\n+            assert log_zero == negative_inf;\n+                \/\/ Double check infinities.\n+\n+            assert Double.isNaN(positive_inf \/ 10);\n+            assert Double.isNaN(negative_inf \/ 10);\n+            cornercaseDoubleJava_divzero(bh);\n+            assert (+10 \/ positive_inf) == +10;\n+            assert (+10 \/ negative_inf) == +10;\n+            assert (-10 \/ positive_inf) == -10;\n+            assert (-10 \/ negative_inf) == -10;\n+\n+            \/\/ NaN comparisons always fail.\n+            \/\/ Therefore, all tests that we will do afterwards will be just isNaN.\n+            assert !(1.0d < nan);\n+            assert !(1.0d == nan);\n+            assert !(1.0d > nan);\n+            assert !(nan == nan);\n+\n+            \/\/ NaN propagate through most operations.\n+            assert Double.isNaN(nan + 1.0d);\n+            assert Double.isNaN(1.0d + nan);\n+            assert Double.isNaN(nan + nan);\n+            assert Double.isNaN(nan \/ 1.0d);\n+            assert Double.isNaN(1.0d \/ nan);\n+            assert Double.isNaN((double)Math.sqrt((double)nan));\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/floatingpoint\/DremFrem.java","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"}]}