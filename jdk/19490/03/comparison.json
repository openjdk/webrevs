{"files":[{"patch":"@@ -37,0 +37,3 @@\n+#if INCLUDE_ZGC\n+#include \"gc\/z\/zBarrierSetAssembler.hpp\"\n+#endif\n@@ -167,1 +170,1 @@\n-void CodeInstaller::pd_relocate_poll(address pc, jint mark, JVMCI_TRAPS) {\n+bool CodeInstaller::pd_relocate(address pc, jint mark) {\n@@ -170,2 +173,2 @@\n-      JVMCI_ERROR(\"unimplemented\");\n-      break;\n+      \/\/ This is unhandled and will be reported by the caller\n+      return false;\n@@ -174,1 +177,1 @@\n-      break;\n+      return true;\n@@ -176,2 +179,2 @@\n-      JVMCI_ERROR(\"unimplemented\");\n-      break;\n+      \/\/ This is unhandled and will be reported by the caller\n+      return false;\n@@ -180,4 +183,14 @@\n-      break;\n-    default:\n-      JVMCI_ERROR(\"invalid mark value\");\n-      break;\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_LOAD_GOOD_BEFORE_TB_X:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatLoadGoodBeforeTbX);\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_MARK_BAD_BEFORE_MOV:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatMarkBadBeforeMov);\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_BEFORE_MOV:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatStoreGoodBeforeMov);\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_STORE_BAD_BEFORE_MOV:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatStoreBadBeforeMov);\n+      return true;\n+\n@@ -185,0 +198,1 @@\n+  return false;\n","filename":"src\/hotspot\/cpu\/aarch64\/jvmciCodeInstaller_aarch64.cpp","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-void CodeInstaller::pd_relocate_poll(address pc, jint mark, JVMCI_TRAPS) {\n+bool CodeInstaller::pd_relocate(address pc, jint mark) {\n@@ -110,0 +110,1 @@\n+  return false;\n","filename":"src\/hotspot\/cpu\/riscv\/jvmciCodeInstaller_riscv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+#if INCLUDE_ZGC\n+#include \"gc\/z\/zBarrierSetAssembler.hpp\"\n+#endif\n@@ -200,1 +203,1 @@\n-void CodeInstaller::pd_relocate_poll(address pc, jint mark, JVMCI_TRAPS) {\n+bool CodeInstaller::pd_relocate(address pc, jint mark) {\n@@ -209,1 +212,1 @@\n-      break;\n+      return true;\n@@ -214,1 +217,22 @@\n-      break;\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_LOAD_GOOD_BEFORE_SHL:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatLoadGoodBeforeShl);\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_LOAD_BAD_AFTER_TEST:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatLoadBadAfterTest);\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_MARK_BAD_AFTER_TEST:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatMarkBadAfterTest);\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_CMP:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatStoreGoodAfterCmp);\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_STORE_BAD_AFTER_TEST:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatStoreBadAfterTest);\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_OR:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatStoreGoodAfterOr);\n+      return true;\n+    case Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_MOV:\n+      _instructions->relocate(pc, barrier_Relocation::spec(), ZBarrierRelocationFormatStoreGoodAfterMov);\n+      return true;\n@@ -216,2 +240,1 @@\n-      JVMCI_ERROR(\"invalid mark value: %d\", mark);\n-      break;\n+      return false;\n","filename":"src\/hotspot\/cpu\/x86\/jvmciCodeInstaller_x86.cpp","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -3641,0 +3641,9 @@\n+        case relocInfo::entry_guard_type:      return \"entry_guard\";\n+        case relocInfo::post_call_nop_type:    return \"post_call_nop\";\n+        case relocInfo::barrier_type: {\n+          barrier_Relocation* const reloc = iter.barrier_reloc();\n+          stringStream st;\n+          st.print(\"barrier format=%d\", reloc->format());\n+          return st.as_string();\n+        }\n+\n@@ -3643,2 +3652,5 @@\n-        default:\n-          break;\n+        default: {\n+          stringStream st;\n+          st.print(\"unknown relocInfo=%d\", (int) iter.type());\n+          return st.as_string();\n+        }\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -154,0 +154,2 @@\n+  static void load_barrier_on_oop_array(volatile zpointer* p, size_t length);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -478,0 +478,6 @@\n+inline void ZBarrier::load_barrier_on_oop_array(volatile zpointer* p, size_t length) {\n+  for (volatile const zpointer* const end = p + length; p < end; p++) {\n+    load_barrier_on_oop_field(p);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -66,0 +66,4 @@\n+JRT_LEAF(void, ZBarrierSetRuntime::load_barrier_on_oop_array(oop* p, size_t length))\n+  ZBarrier::load_barrier_on_oop_array((zpointer*)p, length);\n+JRT_END\n+\n@@ -129,0 +133,4 @@\n+address ZBarrierSetRuntime::load_barrier_on_oop_array_addr() {\n+  return reinterpret_cast<address>(load_barrier_on_oop_array);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetRuntime.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  static void load_barrier_on_oop_array(oop* p, size_t length);\n@@ -57,0 +58,1 @@\n+  static address load_barrier_on_oop_array_addr();\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetRuntime.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1300,0 +1300,4 @@\n+  if (pd_relocate(pc, id)) {\n+    return;\n+  }\n+\n@@ -1333,6 +1337,0 @@\n-    case POLL_NEAR:\n-    case POLL_FAR:\n-    case POLL_RETURN_NEAR:\n-    case POLL_RETURN_FAR:\n-      pd_relocate_poll(pc, id, JVMCI_CHECK);\n-      break;\n@@ -1353,0 +1351,1 @@\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -179,0 +179,17 @@\n+\n+#ifdef X86\n+    Z_BARRIER_RELOCATION_FORMAT_LOAD_GOOD_BEFORE_SHL,\n+    Z_BARRIER_RELOCATION_FORMAT_LOAD_BAD_AFTER_TEST,\n+    Z_BARRIER_RELOCATION_FORMAT_MARK_BAD_AFTER_TEST,\n+    Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_CMP,\n+    Z_BARRIER_RELOCATION_FORMAT_STORE_BAD_AFTER_TEST,\n+    Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_OR,\n+    Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_MOV,\n+#endif\n+#ifdef AARCH64\n+    Z_BARRIER_RELOCATION_FORMAT_LOAD_GOOD_BEFORE_TB_X,\n+    Z_BARRIER_RELOCATION_FORMAT_MARK_BAD_BEFORE_MOV,\n+    Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_BEFORE_MOV,\n+    Z_BARRIER_RELOCATION_FORMAT_STORE_BAD_BEFORE_MOV,\n+#endif\n+\n@@ -315,1 +332,1 @@\n-  void pd_relocate_poll(address pc, jint mark, JVMCI_TRAPS);\n+  bool pd_relocate(address pc, jint mark);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1211,4 +1211,12 @@\n-  JVMCINMethodHandle nmethod_handle(THREAD);\n-  nmethod* nm = JVMCIENV->get_nmethod(nmethod_mirror, nmethod_handle);\n-  if (nm == nullptr || !nm->is_in_use()) {\n-    JVMCI_THROW_NULL(InvalidInstalledCodeException);\n+  methodHandle mh;\n+  {\n+    \/\/ Reduce the scope of JVMCINMethodHandle so that it isn't alive across the Java call.  Once the\n+    \/\/ nmethod has been validated and the method is fetched from the nmethod it's fine for the\n+    \/\/ nmethod to be reclaimed if necessary.\n+    JVMCINMethodHandle nmethod_handle(THREAD);\n+    nmethod* nm = JVMCIENV->get_nmethod(nmethod_mirror, nmethod_handle);\n+    if (nm == nullptr || !nm->is_in_use()) {\n+      JVMCI_THROW_NULL(InvalidInstalledCodeException);\n+    }\n+    methodHandle nmh(THREAD, nm->method());\n+    mh = nmh;\n@@ -1216,1 +1224,0 @@\n-  methodHandle mh(THREAD, nm->method());\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -71,0 +71,4 @@\n+    static address ZPointerVectorLoadBadMask_address;\n+    static address ZPointerVectorStoreBadMask_address;\n+    static address ZPointerVectorStoreGoodMask_address;\n+\n@@ -103,0 +107,1 @@\n+    static int sizeof_ZStoreBarrierEntry;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+#include \"gc\/z\/zBarrierSetRuntime.hpp\"\n+#include \"gc\/z\/zThreadLocalData.hpp\"\n@@ -83,0 +85,4 @@\n+address CompilerToVM::Data::ZPointerVectorLoadBadMask_address;\n+address CompilerToVM::Data::ZPointerVectorStoreBadMask_address;\n+address CompilerToVM::Data::ZPointerVectorStoreGoodMask_address;\n+\n@@ -120,0 +126,1 @@\n+int CompilerToVM::Data::sizeof_ZStoreBarrierEntry = sizeof(ZStoreBarrierEntry);\n@@ -160,9 +167,17 @@\n-    thread_address_bad_mask_offset = in_bytes(XThreadLocalData::address_bad_mask_offset());\n-    ZBarrierSetRuntime_load_barrier_on_oop_field_preloaded =                     XBarrierSetRuntime::load_barrier_on_oop_field_preloaded_addr();\n-    ZBarrierSetRuntime_load_barrier_on_weak_oop_field_preloaded =                XBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded_addr();\n-    ZBarrierSetRuntime_load_barrier_on_phantom_oop_field_preloaded =             XBarrierSetRuntime::load_barrier_on_phantom_oop_field_preloaded_addr();\n-    ZBarrierSetRuntime_weak_load_barrier_on_oop_field_preloaded =                XBarrierSetRuntime::weak_load_barrier_on_oop_field_preloaded_addr();\n-    ZBarrierSetRuntime_weak_load_barrier_on_weak_oop_field_preloaded =           XBarrierSetRuntime::weak_load_barrier_on_weak_oop_field_preloaded_addr();\n-    ZBarrierSetRuntime_weak_load_barrier_on_phantom_oop_field_preloaded =        XBarrierSetRuntime::weak_load_barrier_on_phantom_oop_field_preloaded_addr();\n-    ZBarrierSetRuntime_load_barrier_on_oop_array =                               XBarrierSetRuntime::load_barrier_on_oop_array_addr();\n-    ZBarrierSetRuntime_clone =                                                   XBarrierSetRuntime::clone_addr();\n+    if (ZGenerational) {\n+      ZPointerVectorLoadBadMask_address   = (address) &ZPointerVectorLoadBadMask;\n+      ZPointerVectorStoreBadMask_address  = (address) &ZPointerVectorStoreBadMask;\n+      ZPointerVectorStoreGoodMask_address = (address) &ZPointerVectorStoreGoodMask;\n+    } else {\n+      thread_address_bad_mask_offset = in_bytes(XThreadLocalData::address_bad_mask_offset());\n+      \/\/ Initialize the old names for compatibility.  The proper XBarrierSetRuntime names are\n+      \/\/ exported as addresses in vmStructs_jvmci.cpp as are the new ZBarrierSetRuntime names.\n+      ZBarrierSetRuntime_load_barrier_on_oop_field_preloaded              = XBarrierSetRuntime::load_barrier_on_oop_field_preloaded_addr();\n+      ZBarrierSetRuntime_load_barrier_on_weak_oop_field_preloaded         = XBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded_addr();\n+      ZBarrierSetRuntime_load_barrier_on_phantom_oop_field_preloaded      = XBarrierSetRuntime::load_barrier_on_phantom_oop_field_preloaded_addr();\n+      ZBarrierSetRuntime_weak_load_barrier_on_oop_field_preloaded         = XBarrierSetRuntime::weak_load_barrier_on_oop_field_preloaded_addr();\n+      ZBarrierSetRuntime_weak_load_barrier_on_weak_oop_field_preloaded    = XBarrierSetRuntime::weak_load_barrier_on_weak_oop_field_preloaded_addr();\n+      ZBarrierSetRuntime_weak_load_barrier_on_phantom_oop_field_preloaded = XBarrierSetRuntime::weak_load_barrier_on_phantom_oop_field_preloaded_addr();\n+      ZBarrierSetRuntime_load_barrier_on_oop_array                        = XBarrierSetRuntime::load_barrier_on_oop_array_addr();\n+      ZBarrierSetRuntime_clone                                            = XBarrierSetRuntime::clone_addr();\n+    }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -877,1 +877,1 @@\n-      guarantee(*oop_ptr != nullptr, \"unexpected cleared handle\");\n+      guarantee(NativeAccess<>::oop_load(oop_ptr) != nullptr, \"unexpected cleared handle\");\n@@ -892,1 +892,1 @@\n-  return handle != nullptr && *handle != nullptr;\n+  return handle != nullptr && NativeAccess<>::oop_load(handle) != nullptr;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-  return UseSerialGC || UseParallelGC || UseG1GC || (UseZGC && !ZGenerational);\n+  return UseSerialGC || UseParallelGC || UseG1GC || UseZGC || UseEpsilonGC;\n@@ -233,3 +233,1 @@\n-      log_warning(gc, jvmci)(\"Setting EnableJVMCI to false as selected GC does not support JVMCI: %s\", GCConfig::hs_err_name());\n-      FLAG_SET_DEFAULT(EnableJVMCI, false);\n-      FLAG_SET_DEFAULT(UseJVMCICompiler, false);\n+      fatal(\"JVMCI does not support the selected GC\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/g1\/g1BarrierSetRuntime.hpp\"\n@@ -49,0 +50,6 @@\n+#if INCLUDE_ZGC\n+#include \"gc\/x\/xBarrierSetRuntime.hpp\"\n+#include \"gc\/z\/zBarrierSetAssembler.hpp\"\n+#include \"gc\/z\/zBarrierSetRuntime.hpp\"\n+#include \"gc\/z\/zThreadLocalData.hpp\"\n+#endif\n@@ -69,0 +76,1 @@\n+  AARCH64_ONLY(static_field(CompilerToVM::Data, BarrierSetAssembler_patching_epoch_addr, address))                                   \\\n@@ -79,0 +87,4 @@\n+  static_field(CompilerToVM::Data,             ZPointerVectorLoadBadMask_address, address)                                           \\\n+  static_field(CompilerToVM::Data,             ZPointerVectorStoreBadMask_address, address)                                          \\\n+  static_field(CompilerToVM::Data,             ZPointerVectorStoreGoodMask_address, address)                                         \\\n+                                                                                                                                     \\\n@@ -112,0 +124,1 @@\n+  static_field(CompilerToVM::Data,             sizeof_ZStoreBarrierEntry,              int)                                          \\\n@@ -787,1 +800,6 @@\n-#define VM_ADDRESSES(declare_address, declare_preprocessor_address, declare_function) \\\n+\/\/ Helper macro to support ZGC pattern where the function itself isn't exported\n+#define DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, name) \\\n+  declare_function_with_value(name, name##_addr())\n+\n+\n+#define VM_ADDRESSES(declare_address, declare_preprocessor_address, declare_function, declare_function_with_value) \\\n@@ -804,0 +822,20 @@\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::load_barrier_on_oop_field_preloaded))                      \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded))                 \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::load_barrier_on_phantom_oop_field_preloaded))              \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::weak_load_barrier_on_oop_field_preloaded))                 \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::weak_load_barrier_on_weak_oop_field_preloaded))            \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::weak_load_barrier_on_phantom_oop_field_preloaded))         \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::load_barrier_on_oop_array))                                \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::clone))                                                    \\\n+                                                                                                                      \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded))                      \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded))                 \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::load_barrier_on_phantom_oop_field_preloaded))              \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded_store_good))           \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::no_keepalive_load_barrier_on_weak_oop_field_preloaded))    \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::no_keepalive_load_barrier_on_phantom_oop_field_preloaded)) \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::store_barrier_on_native_oop_field_without_healing))        \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::store_barrier_on_oop_field_with_healing))                  \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::store_barrier_on_oop_field_without_healing))               \\\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::load_barrier_on_oop_array))                                \\\n+                                                                          \\\n@@ -854,0 +892,26 @@\n+#if INCLUDE_ZGC\n+\n+#define VM_INT_CONSTANTS_JVMCI_ZGC(declare_constant, declare_constant_with_value, declare_preprocessor_constant)                           \\\n+  declare_constant_with_value(\"ZThreadLocalData::store_good_mask_offset\" , in_bytes(ZThreadLocalData::store_good_mask_offset()))           \\\n+  declare_constant_with_value(\"ZThreadLocalData::store_bad_mask_offset\" , in_bytes(ZThreadLocalData::store_bad_mask_offset()))             \\\n+  declare_constant_with_value(\"ZThreadLocalData::store_barrier_buffer_offset\" , in_bytes(ZThreadLocalData::store_barrier_buffer_offset())) \\\n+  declare_constant_with_value(\"ZStoreBarrierBuffer::current_offset\" , in_bytes(ZStoreBarrierBuffer::current_offset()))                     \\\n+  declare_constant_with_value(\"ZStoreBarrierBuffer::buffer_offset\" , in_bytes(ZStoreBarrierBuffer::buffer_offset()))                       \\\n+  declare_constant_with_value(\"ZStoreBarrierEntry::p_offset\" , in_bytes(ZStoreBarrierEntry::p_offset()))                                   \\\n+  declare_constant_with_value(\"ZStoreBarrierEntry::prev_offset\" , in_bytes(ZStoreBarrierEntry::prev_offset()))                             \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_LOAD_GOOD_BEFORE_SHL))                                            \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_LOAD_BAD_AFTER_TEST))                                             \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_MARK_BAD_AFTER_TEST))                                             \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_CMP))                                            \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_STORE_BAD_AFTER_TEST))                                            \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_OR))                                             \\\n+  AMD64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_AFTER_MOV))                                            \\\n+  AARCH64_ONLY(declare_constant(ZPointerLoadShift))                                                                                        \\\n+  AARCH64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_LOAD_GOOD_BEFORE_TB_X))                                         \\\n+  AARCH64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_MARK_BAD_BEFORE_MOV))                                           \\\n+  AARCH64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_STORE_GOOD_BEFORE_MOV))                                         \\\n+  AARCH64_ONLY(declare_constant(CodeInstaller::Z_BARRIER_RELOCATION_FORMAT_STORE_BAD_BEFORE_MOV))\n+\n+#endif \/\/ INCLUDE_ZGC\n+\n+\n@@ -856,1 +920,1 @@\n-#define VM_ADDRESSES_OS(declare_address, declare_preprocessor_address, declare_function) \\\n+#define VM_ADDRESSES_OS(declare_address, declare_preprocessor_address, declare_function, declare_function_with_value) \\\n@@ -864,1 +928,1 @@\n-#define VM_ADDRESSES_OS(declare_address, declare_preprocessor_address, declare_function) \\\n+#define VM_ADDRESSES_OS(declare_address, declare_preprocessor_address, declare_function, declare_function_with_value) \\\n@@ -915,1 +979,1 @@\n-#define VM_ADDRESSES_OS(declare_address, declare_preprocessor_address, declare_function)\n+#define VM_ADDRESSES_OS(declare_address, declare_preprocessor_address, declare_function, declare_function_with_value)\n@@ -922,0 +986,4 @@\n+#define GENERATE_VM_FUNCTION_WITH_VALUE_ENTRY(name, value) \\\n+  { QUOTE(name), CAST_FROM_FN_PTR(void*, value) },\n+\n+\n@@ -972,0 +1040,5 @@\n+#if INCLUDE_ZGC\n+  VM_INT_CONSTANTS_JVMCI_ZGC(GENERATE_VM_INT_CONSTANT_ENTRY,\n+                              GENERATE_VM_INT_CONSTANT_WITH_VALUE_ENTRY,\n+                              GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n+#endif\n@@ -997,1 +1070,2 @@\n-               GENERATE_VM_FUNCTION_ENTRY)\n+               GENERATE_VM_FUNCTION_ENTRY,\n+               GENERATE_VM_FUNCTION_WITH_VALUE_ENTRY)\n@@ -1000,1 +1074,2 @@\n-                  GENERATE_VM_FUNCTION_ENTRY)\n+                  GENERATE_VM_FUNCTION_ENTRY,\n+                  GENERATE_VM_FUNCTION_WITH_VALUE_ENTRY)\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":81,"deletions":6,"binary":false,"changes":87,"status":"modified"}]}