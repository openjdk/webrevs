{"files":[{"patch":"@@ -153,1 +153,7 @@\n-    return (is_integral_type(bt) ? Op_RotateLeftV : 0);\n+    switch (bt) {\n+    case T_INT:\n+    case T_LONG: return Op_RotateLeftV;\n+    default:     return 0; \/\/ RotateLeftV for byte, short values produces incorrect Java result.\n+                           \/\/ Because java code should convert a byte, short value into int value,\n+                           \/\/ and then do RotateI.\n+    }\n@@ -155,1 +161,7 @@\n-    return (is_integral_type(bt) ? Op_RotateRightV : 0);\n+    switch (bt) {\n+    case T_INT:\n+    case T_LONG: return Op_RotateRightV;\n+    default:     return 0; \/\/ RotateRightV for byte, short values produces incorrect Java result.\n+                           \/\/ Because java code should convert a byte, short value into int value,\n+                           \/\/ and then do RotateI.\n+    }\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Loongson Technology. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8286847\n+ * @summary Test vectorization of rotate byte and short\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:-TieredCompilation -XX:CompileCommand=compileonly,TestRotateByteAndShortVector::testRotate* -Xbatch TestRotateByteAndShortVector\n+ *\/\n+\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class TestRotateByteAndShortVector {\n+    private static final Random random = Utils.getRandomInstance();\n+    private static final int ARRLEN = 512;\n+    private static final int ITERS = 11000;\n+\n+    private static byte[] arrByte = new byte[ARRLEN];\n+    private static byte[] rolByte = new byte[ARRLEN];\n+    private static byte[] rorByte = new byte[ARRLEN];\n+    private static byte   resByte = 0;\n+\n+    private static short[] arrShort = new short[ARRLEN];\n+    private static short[] rolShort = new short[ARRLEN];\n+    private static short[] rorShort = new short[ARRLEN];\n+    private static short   resShort = 0;\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"warmup\");\n+        warmup();\n+\n+        System.out.println(\"Testing...\");\n+        runRotateLeftByteTest();\n+        runRotateRightByteTest();\n+        runRotateLeftShortTest();\n+        runRotateRightShortTest();\n+\n+        System.out.println(\"PASSED\");\n+    }\n+\n+    static void warmup() {\n+        random.nextBytes(arrByte);\n+        randomShorts();\n+        for (int i = 0; i < ITERS; i++) {\n+            testRotateLeftByte(rolByte, arrByte, i);\n+            testRotateRightByte(rorByte, arrByte, i);\n+            testRotateLeftShort(rolShort, arrShort, i);\n+            testRotateRightShort(rorShort, arrShort, i);\n+        }\n+    }\n+\n+    static void randomShorts() {\n+        for (int i = 0; i < ARRLEN; i++) {\n+            arrShort[i] = (short) random.nextInt();\n+        }\n+    }\n+\n+    static void runRotateLeftByteTest() {\n+        for (int shift = 0; shift < 64; shift++) {\n+            random.nextBytes(arrByte);\n+            testRotateLeftByte(rolByte, arrByte, shift);\n+            for (int i = 0; i < ARRLEN; i++) {\n+                resByte = (byte) ((arrByte[i] << shift) | (arrByte[i] >>> -shift));\n+                if (rolByte[i] != resByte) {\n+                    throw new RuntimeException(\"rol value = \" + arrByte[i] + \", shift = \" + shift + \", error: \" + \"expect \" + resByte + \" but result is \" + rolByte[i]);\n+                }\n+            }\n+        }\n+    }\n+\n+    static void runRotateRightByteTest() {\n+        for (int shift = 0; shift < 64; shift++) {\n+            random.nextBytes(arrByte);\n+            testRotateRightByte(rorByte, arrByte, shift);\n+            for (int i = 0; i < ARRLEN; i++) {\n+                resByte = (byte) ((arrByte[i] >>> shift) | (arrByte[i] << -shift));\n+                if (rorByte[i] != resByte) {\n+                    throw new RuntimeException(\"ror value = \" + arrByte[i] + \", shift = \" + shift + \", error: \" + \"expect \" + resByte + \" but result is \" + rorByte[i]);\n+                }\n+            }\n+        }\n+    }\n+\n+    static void runRotateLeftShortTest() {\n+        for (int shift = 0; shift < 64; shift++) {\n+            randomShorts();\n+            testRotateLeftShort(rolShort, arrShort, shift);\n+            for (int i = 0; i < ARRLEN; i++) {\n+                resShort = (short) ((arrShort[i] << shift) | (arrShort[i] >>> -shift));\n+                if (rolShort[i] != resShort) {\n+                    throw new RuntimeException(\"rol value = \" + arrShort[i] + \", shift = \" + shift + \", error: \" + \"expect \" + resShort + \" but result is \" + rolShort[i]);\n+                }\n+            }\n+        }\n+    }\n+\n+    static void runRotateRightShortTest() {\n+        for (int shift = 0; shift < 64; shift++) {\n+            randomShorts();\n+            testRotateRightShort(rorShort, arrShort, shift);\n+            for (int i = 0; i < ARRLEN; i++) {\n+                resShort = (short) ((arrShort[i] >>> shift) | (arrShort[i] << -shift));\n+                if (rorShort[i] != resShort) {\n+                    throw new RuntimeException(\"ror value = \" + arrShort[i] + \", shift = \" + shift + \", error: \" + \"expect \" + resShort + \" but result is \" + rorShort[i]);\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testRotateLeftByte(byte[] test, byte[] arr, int shift) {\n+        for (int i = 0; i < ARRLEN; i++) {\n+            test[i] = (byte) ((arr[i] << shift) | (arr[i] >>> -shift));\n+        }\n+    }\n+\n+    static void testRotateRightByte(byte[] test, byte[] arr, int shift) {\n+        for (int i = 0; i < ARRLEN; i++) {\n+            test[i] = (byte) ((arr[i] >>> shift) | (arr[i] << -shift));\n+        }\n+    }\n+\n+    static void testRotateLeftShort(short[] test, short[] arr, int shift) {\n+        for (int i = 0; i < ARRLEN; i++) {\n+            test[i] = (short) ((arr[i] << shift) | (arr[i] >>> -shift));\n+        }\n+    }\n+\n+    static void testRotateRightShort(short[] test, short[] arr, int shift) {\n+        for (int i = 0; i < ARRLEN; i++) {\n+            test[i] = (short) ((arr[i] >>> shift) | (arr[i] << -shift));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRotateByteAndShortVector.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"}]}