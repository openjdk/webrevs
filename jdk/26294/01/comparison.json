{"files":[{"patch":"@@ -370,1 +370,1 @@\n-  CompileTask* next = _first;\n+  CompileTask* current = _first;\n@@ -373,18 +373,3 @@\n-  while (next != nullptr) {\n-    CompileTask* current = next;\n-    next = current->next();\n-    bool found_waiter = false;\n-    {\n-      MutexLocker ct_lock(CompileTaskWait_lock);\n-      assert(current->waiting_for_completion_count() <= 1, \"more than one thread are waiting for task\");\n-      if (current->waiting_for_completion_count() > 0) {\n-        \/\/ If another thread waits for this task, we must wake them up\n-        \/\/ so they will stop waiting and free the task.\n-        CompileTaskWait_lock->notify_all();\n-        found_waiter = true;\n-      }\n-    }\n-    if (!found_waiter) {\n-      \/\/ If no one was waiting for this task, we need to delete it ourselves.\n-      \/\/ In this case, the task is also certainly unlocked, because, again, there is no waiter.\n-      \/\/ Otherwise, by convention, it's the waiters responsibility to delete the task.\n+  while (current != nullptr) {\n+    if (!current->is_blocking()) {\n+      \/\/ Non-blocking task. No one is waiting for it, delete it now.\n@@ -392,0 +377,4 @@\n+    } else {\n+      \/\/ Blocking task. By convention, it is the waiters responsibility\n+      \/\/ to delete the task. We cannot delete it here, because we do not\n+      \/\/ coordinate with waiters. We will notify the waiters later.\n@@ -393,0 +382,1 @@\n+    current = current->next();\n@@ -397,0 +387,8 @@\n+  \/\/ Wake up all blocking task waiters to deal with remaining blocking\n+  \/\/ tasks. This is not a performance sensitive path, so we do this\n+  \/\/ unconditionally to simplify coding\/testing.\n+  {\n+    MonitorLocker ml(Thread::current(), CompileTaskWait_lock);\n+    ml.notify_all();\n+  }\n+\n@@ -1723,1 +1721,0 @@\n-    MonitorLocker ml(thread, CompileTaskWait_lock);\n@@ -1725,1 +1722,2 @@\n-    task->inc_waiting_for_completion();\n+    \/\/ Wait until the task is complete or compilation is shut down.\n+    MonitorLocker ml(thread, CompileTaskWait_lock);\n@@ -1729,1 +1727,0 @@\n-    task->dec_waiting_for_completion();\n@@ -1732,5 +1729,10 @@\n-  if (free_task) {\n-    if (is_compilation_disabled_forever()) {\n-      delete task;\n-      return;\n-    }\n+  \/\/ It is harmless to check this status without the lock, because\n+  \/\/ completion is a stable property.\n+  if (!task->is_complete() && is_compilation_disabled_forever()) {\n+    \/\/ Task is not complete, and we are exiting for compilation shutdown.\n+    \/\/ The task can still be executed by some compiler thread, therefore\n+    \/\/ we cannot delete it. This will leave task allocated, which leaks it.\n+    \/\/ At this (degraded) point, it is less risky to abandon the task,\n+    \/\/ rather than attempting a more complicated deletion protocol.\n+    free_task = false;\n+  }\n@@ -1738,2 +1740,1 @@\n-    \/\/ It is harmless to check this status without the lock, because\n-    \/\/ completion is a stable property (until the task object is deleted).\n+  if (free_task) {\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":30,"deletions":29,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -384,1 +384,1 @@\n-    return _should_compile_new_jobs == shutdown_compilation;\n+    return Atomic::load(&_should_compile_new_jobs) == shutdown_compilation;\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,2 +59,0 @@\n-  _waiting_count = 0;\n-\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-  int                  _waiting_count;  \/\/ See waiting_for_completion_count()\n@@ -167,17 +166,0 @@\n-  \/\/ See how many threads are waiting for this task. Must have lock to read this.\n-  int waiting_for_completion_count() {\n-    assert(CompileTaskWait_lock->owned_by_self(), \"must have lock to use waiting_for_completion_count()\");\n-    return _waiting_count;\n-  }\n-  \/\/ Indicates that a thread is waiting for this task to complete. Must have lock to use this.\n-  void inc_waiting_for_completion() {\n-    assert(CompileTaskWait_lock->owned_by_self(), \"must have lock to use inc_waiting_for_completion()\");\n-    _waiting_count++;\n-  }\n-  \/\/ Indicates that a thread stopped waiting for this task to complete. Must have lock to use this.\n-  void dec_waiting_for_completion() {\n-    assert(CompileTaskWait_lock->owned_by_self(), \"must have lock to use dec_waiting_for_completion()\");\n-    assert(_waiting_count > 0, \"waiting count is not positive\");\n-    _waiting_count--;\n-  }\n-\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -85,2 +85,0 @@\n-compiler\/debug\/TestStressBailout.java 8361752 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}