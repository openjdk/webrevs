{"files":[{"patch":"@@ -387,1 +387,1 @@\n-  \/\/ Wake up all blocking task waiters to delete all remaining blocking\n+  \/\/ Wake up all blocking task waiters to deal with remaining blocking\n@@ -389,1 +389,1 @@\n-  \/\/ unconditionally to simplify coding.\n+  \/\/ unconditionally to simplify coding\/testing.\n@@ -1721,1 +1721,0 @@\n-    MonitorLocker ml(thread, CompileTaskWait_lock);\n@@ -1723,0 +1722,2 @@\n+    \/\/ Wait until the task is complete or compilation is shut down.\n+    MonitorLocker ml(thread, CompileTaskWait_lock);\n@@ -1728,5 +1729,10 @@\n-  if (free_task) {\n-    if (is_compilation_disabled_forever()) {\n-      delete task;\n-      return;\n-    }\n+  \/\/ It is harmless to check this status without the lock, because\n+  \/\/ completion is a stable property.\n+  if (!task->is_complete() && is_compilation_disabled_forever()) {\n+    \/\/ Task is not complete, and we are exiting for compilation shutdown.\n+    \/\/ The task can still be executed by some compiler thread, therefore\n+    \/\/ we cannot delete it. This will leave task allocated, which leaks it.\n+    \/\/ At this (degraded) point, it is less risky to abandon the task,\n+    \/\/ rather than attempting a more complicated deletion protocol.\n+    free_task = false;\n+  }\n@@ -1734,2 +1740,1 @@\n-    \/\/ It is harmless to check this status without the lock, because\n-    \/\/ completion is a stable property (until the task object is deleted).\n+  if (free_task) {\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -384,1 +384,1 @@\n-    return _should_compile_new_jobs == shutdown_compilation;\n+    return Atomic::load(&_should_compile_new_jobs) == shutdown_compilation;\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}