{"files":[{"patch":"@@ -296,1 +296,3 @@\n-        } else if ((v.flags() & FINAL) != 0 &&\n+            return;\n+        }\n+        if ((v.flags() & FINAL) != 0 &&\n@@ -307,0 +309,12 @@\n+            return;\n+        }\n+\n+        \/\/ Illegal to assign an instance field inherited from a superclass in a constructor prologue\n+        if (env.info.ctorPrologue &&\n+                v.owner.kind == TYP &&\n+                types.isSubtype(env.enclClass.type, v.owner.type) &&\n+                v.owner != env.enclClass.sym &&\n+                (v.flags() & STATIC) == 0 &&\n+                (base == null ||\n+                  TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base))) {\n+            log.error(pos, Errors.CantRefBeforeCtorCalled(v));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1511,1 +1511,1 @@\n-                    if (env1.info.ctorPrologue && (sym.flags_field & SYNTHETIC) == 0)\n+                    if (env1.info.ctorPrologue && !isAllowedInPrologue(env1, (VarSymbol)sym))\n@@ -3778,1 +3778,1 @@\n-                    else if (env1.info.ctorPrologue)\n+                    else if (env1.info.ctorPrologue && sym.kind == VAR && !isAllowedInPrologue(env1, (VarSymbol)sym))\n@@ -3831,0 +3831,45 @@\n+    \/**\n+     * Determine if an instance field may appear in a constructor prologue.\n+     *\n+     * <p>\n+     * This is only allowed when:\n+     *  - The field is being assigned a value (i.e., written but not read)\n+     *  - The field is not inherited from a superclass\n+     *  - The assignment is not within a lambda, because that would require\n+     *    capturing 'this' which is not allowed prior to super().\n+     *\n+     * <p>\n+     * Note, this method doesn't catch all such scenarios, because this method\n+     * is invoked for symbol \"x\" only for \"x = 42\" but not for \"this.x = 42\".\n+     * To catch those cases, we rely on similar logic in Attr.checkAssignable().\n+     *\/\n+    private boolean isAllowedInPrologue(Env<AttrContext> env, VarSymbol v) {\n+\n+        \/\/ Check assumptions\n+        Assert.check(env.info.ctorPrologue);\n+        Assert.check((v.flags_field & STATIC) == 0);\n+\n+        \/\/ The symbol must appear in the LHS of an assignment statement\n+        if (!env.tree.hasTag(ASSIGN))\n+            return false;\n+\n+        \/\/ The assignment statement must not be within a lambda\n+        if (env.info.isLambda)\n+            return false;\n+\n+        \/\/ Get the symbol's qualifier, if any\n+        JCExpression lhs = TreeInfo.skipParens(((JCAssign)env.tree).lhs);\n+        JCExpression base = lhs.hasTag(SELECT) ? ((JCFieldAccess)lhs).selected : null;\n+\n+        \/\/ The symbol must not be an instance field inherited from a superclass\n+        if (v.owner.kind == TYP &&\n+                types.isSubtype(env.enclClass.type, v.owner.type) &&\n+                v.owner != env.enclClass.sym &&\n+                (base == null ||\n+                  TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base))) {\n+            return false;\n+        }\n+\n+        \/\/ OK\n+        return true;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":47,"deletions":2,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -777,1 +777,1 @@\n-        if (isExplicitThisReference(types, currentClassType, tree)) {\n+        if (TreeInfo.isExplicitThisReference(types, currentClassType, tree)) {\n@@ -1165,37 +1165,0 @@\n-    \/** Check if the given tree is an explicit reference to the 'this' instance of the\n-     *  class currently being compiled. This is true if tree is:\n-     *  - An unqualified 'this' identifier\n-     *  - A 'super' identifier qualified by a class name whose type is 'currentClass' or a supertype\n-     *  - A 'this' identifier qualified by a class name whose type is 'currentClass' or a supertype\n-     *    but also NOT an enclosing outer class of 'currentClass'.\n-     *\/\n-    private boolean isExplicitThisReference(Types types, Type.ClassType currentClass, JCTree tree) {\n-        switch (tree.getTag()) {\n-            case PARENS:\n-                return isExplicitThisReference(types, currentClass, TreeInfo.skipParens(tree));\n-            case IDENT:\n-            {\n-                JCIdent ident = (JCIdent)tree;\n-                Names names = ident.name.table.names;\n-                return ident.name == names._this;\n-            }\n-            case SELECT:\n-            {\n-                JCFieldAccess select = (JCFieldAccess)tree;\n-                Type selectedType = types.erasure(select.selected.type);\n-                if (!selectedType.hasTag(CLASS))\n-                    return false;\n-                ClassSymbol currentClassSym = (ClassSymbol)((Type.ClassType)types.erasure(currentClass)).tsym;\n-                ClassSymbol selectedClassSym = (ClassSymbol)((Type.ClassType)selectedType).tsym;\n-                Names names = select.name.table.names;\n-                return currentClassSym.isSubClass(selectedClassSym, types) &&\n-                        (select.name == names._super ||\n-                        (select.name == names._this &&\n-                            (currentClassSym == selectedClassSym ||\n-                            !currentClassSym.isEnclosedBy(selectedClassSym))));\n-            }\n-            default:\n-                return false;\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":1,"deletions":38,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -185,0 +185,35 @@\n+    \/** Check if the given tree is an explicit reference to the 'this' instance of the\n+     *  class currently being compiled. This is true if tree is:\n+     *  - An unqualified 'this' identifier\n+     *  - A 'super' identifier qualified by a class name whose type is 'currentClass' or a supertype\n+     *  - A 'this' identifier qualified by a class name whose type is 'currentClass' or a supertype\n+     *    but also NOT an enclosing outer class of 'currentClass'.\n+     *\/\n+    public static boolean isExplicitThisReference(Types types, Type.ClassType currentClass, JCTree tree) {\n+        switch (tree.getTag()) {\n+            case PARENS:\n+                return isExplicitThisReference(types, currentClass, skipParens(tree));\n+            case IDENT: {\n+                JCIdent ident = (JCIdent)tree;\n+                Names names = ident.name.table.names;\n+                return ident.name == names._this || ident.name == names._super;\n+            }\n+            case SELECT: {\n+                JCFieldAccess select = (JCFieldAccess)tree;\n+                Type selectedType = types.erasure(select.selected.type);\n+                if (!selectedType.hasTag(TypeTag.CLASS))\n+                    return false;\n+                Symbol.ClassSymbol currentClassSym = (Symbol.ClassSymbol)((Type.ClassType)types.erasure(currentClass)).tsym;\n+                Symbol.ClassSymbol selectedClassSym = (Symbol.ClassSymbol)((Type.ClassType)selectedType).tsym;\n+                Names names = select.name.table.names;\n+                return currentClassSym.isSubClass(selectedClassSym, types) &&\n+                        (select.name == names._super ||\n+                        (select.name == names._this &&\n+                            (currentClassSym == selectedClassSym ||\n+                            !currentClassSym.isEnclosedBy(selectedClassSym))));\n+            }\n+            default:\n+                return false;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8325805\n+ * @summary Permit non-superclass instance field assignments before this\/super in constructors\n+ * @compile\/fail\/ref=DA_DUConstructors.out -XDrawDiagnostics DA_DUConstructors.java\n+ * @enablePreview\n+ *\/\n+\n+public class DA_DUConstructors {\n+    \/\/ identity\n+    class C1 {\n+        final int x;\n+        final int y = x + 1;\n+        C1() {\n+            x = 12;\n+            super();\n+        }\n+    }\n+\n+    class C2 {\n+        final int x;\n+        C2() {\n+            this(x = 3); \/\/ error\n+        }\n+        C2(int i) {\n+            x = 4;\n+        }\n+    }\n+\n+    class C3 {\n+        C3(int i) {}\n+    }\n+    class C4 extends C3 {\n+        final int x;\n+        C4() {\n+            super(x = 3); \/\/ ok\n+        }\n+    }\n+\n+    class C5 {\n+        final int x;\n+        final int y = x + 1; \/\/ x is not DA\n+        C5() {\n+            x = 12; super();\n+        }\n+        C5(int i) {\n+            \/* no prologue *\/\n+            x = i;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/DA_DUConstructors.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+DA_DUConstructors.java:23:17: compiler.err.var.might.already.be.assigned: x\n+DA_DUConstructors.java:42:23: compiler.err.var.might.not.have.been.initialized: x\n+- compiler.note.preview.filename: DA_DUConstructors.java, DEFAULT\n+- compiler.note.preview.recompile\n+2 errors\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/DA_DUConstructors.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8325805\n+ * @summary Permit non-superclass instance field assignments before this\/super in constructors\n+ * @compile\/fail\/ref=EarlyAssignments.out -XDrawDiagnostics EarlyAssignments.java\n+ * @enablePreview\n+ *\/\n+public class EarlyAssignments {\n+\n+    public static class Inner1 {\n+        public int x;\n+\n+        public Inner1() {\n+            x = 123;                        \/\/ OK - \"x\" belongs to this class\n+            this.x = 123;                   \/\/ OK - \"x\" belongs to this class\n+            Inner1.this.x = 123;            \/\/ OK - \"x\" belongs to this class\n+            super();\n+        }\n+\n+        public Inner1(int y) {\n+            y = x;                          \/\/ FAIL - early 'this' reference\n+            y = this.x;                     \/\/ FAIL - early 'this' reference\n+            y = Inner1.this.x;              \/\/ FAIL - early 'this' reference\n+            super();\n+        }\n+\n+        public class Inner1a extends Inner1 {\n+            public int z;\n+            public Inner1a(byte value) {\n+                Inner1.this.x = value;      \/\/ OK - \"x\" belongs to outer class\n+                z = super.x;                \/\/ FAIL - \"x\" belongs to superclass\n+                z = x;                      \/\/ FAIL - \"x\" belongs to superclass\n+                this.z = x;                 \/\/ FAIL - \"x\" belongs to superclass\n+                Inner1a.this.z = x;         \/\/ FAIL - \"x\" belongs to superclass\n+                Object o1 = Inner1.this;    \/\/ OK - Inner1 is an outer class\n+                Object o2 = Inner1a.this;   \/\/ FAIL - Inner1a is this class\n+                super();\n+            }\n+            public Inner1a(short value) {\n+                x = value;                  \/\/ FAIL - \"x\" belongs to superclass\n+                super();\n+            }\n+            public Inner1a(char value) {\n+                this.x = value;             \/\/ FAIL - \"x\" belongs to superclass\n+                super();\n+            }\n+            public Inner1a(int value) {\n+                super.x = value;            \/\/ FAIL - \"x\" belongs to superclass\n+                super();\n+            }\n+        }\n+\n+        public class Inner1b {\n+            public Inner1b(int value) {\n+                Inner1.this.x = value;      \/\/ OK - \"x\" belongs to outer class\n+                super();\n+            }\n+        }\n+    }\n+\n+    public static class Inner2 extends Inner1 {\n+        int y;\n+        public Inner2(int value) {\n+            y = value;                      \/\/ OK  - \"y\" belongs to this class\n+            this.y = value;                 \/\/ OK  - \"y\" belongs to this class\n+            x = value;                      \/\/ FAIL - \"x\" belongs to superclass\n+            this.x = value;                 \/\/ FAIL - \"x\" belongs to superclass\n+            Object o1 = this;               \/\/ FAIL - can't acces 'this' yet\n+            Object o2 = Inner2.this;        \/\/ FAIL - can't acces 'this' yet\n+            super();\n+        }\n+    }\n+\n+    public static class Inner3 {\n+\n+        public int e;\n+\n+        public class Inner3a {\n+\n+            public static int x;\n+\n+            public Inner3a(int val) {\n+                x = val;                    \/\/ OK - \"x\" is a static field\n+                val = x;                    \/\/ OK - \"x\" is a static field\n+                e = val;                    \/\/ OK - \"e\" belongs to outer class\n+                val = e;                    \/\/ OK - \"e\" belongs to outer class\n+                Inner3.this.e = val;        \/\/ OK - \"e\" belongs to outer class\n+                super();\n+            }\n+        }\n+    }\n+\n+    public static class Inner4 {\n+        public int x;\n+\n+        public Inner4() {\n+            x = 0;                              \/\/ OK\n+            x = x + 1;                          \/\/ FAIL - illegal early access\n+            super();\n+        }\n+\n+        public Inner4(int a) {\n+            this.x = 0;                         \/\/ OK\n+            this.x = this.x + 1;                \/\/ FAIL - illegal early access\n+            super();\n+        }\n+\n+        public Inner4(char a) {\n+            Inner4.this.x = 0;                  \/\/ OK\n+            Inner4.this.x = Inner4.this.x + 1;  \/\/ FAIL - illegal early access\n+            super();\n+        }\n+    }\n+\n+    public static class Inner5 extends Inner4 {\n+        public int y;\n+\n+        public Inner5() {\n+            y = x + 1;                          \/\/ FAIL - illegal early access\n+            super();\n+        }\n+\n+        public Inner5(int a) {\n+            this.y = x + 1;                     \/\/ FAIL - illegal early access\n+            super();\n+        }\n+\n+        public Inner5(char a) {\n+            Inner5.this.y = x + 1;              \/\/ FAIL - illegal early access\n+            super();\n+        }\n+\n+        public Inner5(short a) {\n+            y = super.x + 1;                    \/\/ FAIL - illegal early access\n+            super();\n+        }\n+\n+        public Inner5(float a) {\n+            y = Inner5.this.x + 1;              \/\/ FAIL - illegal early access\n+            super();\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignments.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+EarlyAssignments.java:21:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:22:17: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:23:23: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:31:21: compiler.err.cant.ref.before.ctor.called: super\n+EarlyAssignments.java:32:21: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:33:26: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:34:34: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:36:36: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:40:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:44:21: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:48:22: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:66:13: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:67:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:68:25: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:69:31: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:98:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:104:22: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:110:35: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:119:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:124:22: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:129:29: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:134:17: compiler.err.cant.ref.before.ctor.called: super\n+EarlyAssignments.java:139:23: compiler.err.cant.ref.before.ctor.called: this\n+- compiler.note.preview.filename: EarlyAssignments.java, DEFAULT\n+- compiler.note.preview.recompile\n+23 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignments.out","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -94,1 +94,1 @@\n-        this.x = x.length;              \/\/ this should FAIL\n+        this.x++;                       \/\/ this should FAIL\n@@ -171,0 +171,28 @@\n+\n+    public static class Inner2 {\n+        int x;\n+    }\n+    public static class Inner3 extends Inner2 {\n+        int y;\n+        Inner3(byte z) {\n+            x = z;                      \/\/ this should FAIL\n+            super();\n+        }\n+        Inner3(short z) {\n+            this.x = z;                 \/\/ this should FAIL\n+            super();\n+        }\n+        Inner3(char z) {\n+            Inner3.this.x = z;          \/\/ this should FAIL\n+            super();\n+        }\n+        Inner3(int z) {\n+            super.x = z;                \/\/ this should FAIL\n+            super();\n+        }\n+    }\n+\n+    public SuperInitFails(double[][] x) {\n+        Runnable r = () -> this.x = 7;  \/\/ this should FAIL\n+        super();\n+    }\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -18,0 +18,5 @@\n+SuperInitFails.java:178:13: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:182:17: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:186:24: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:190:18: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:196:28: compiler.err.cant.ref.before.ctor.called: this\n@@ -29,1 +34,1 @@\n-26 errors\n+31 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.out","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -410,0 +410,22 @@\n+    \/\/ we allow 'this' reference prior to super() for field assignments only\n+    public static class Test20 {\n+        private int x;\n+        public Test20(short x) {\n+            x = x;\n+            super();\n+        }\n+        public Test20(int x) {\n+            this.x = x;\n+            super();\n+        }\n+        public Test20(char x) {\n+            Test20.this.x = x;\n+            super();\n+        }\n+        public Test20(byte y) {\n+            x = y;\n+            this((int)y);\n+            this.x++;\n+        }\n+    }\n+\n@@ -451,0 +473,1 @@\n+        new Test20(123);\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitGood.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"}]}