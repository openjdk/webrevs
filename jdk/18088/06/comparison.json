{"files":[{"patch":"@@ -296,1 +296,3 @@\n-        } else if ((v.flags() & FINAL) != 0 &&\n+            return;\n+        }\n+        if ((v.flags() & FINAL) != 0 &&\n@@ -307,0 +309,17 @@\n+            return;\n+        }\n+\n+        \/\/ Check instance field assignments that appear in constructor prologues\n+        if (rs.isEarlyReference(env, base, v)) {\n+\n+            \/\/ Field may not be inherited from a superclass\n+            if (v.owner != env.enclClass.sym) {\n+                log.error(pos, Errors.CantRefBeforeCtorCalled(v));\n+                return;\n+            }\n+\n+            \/\/ Field may not have an initializer\n+            if ((v.flags() & HASINIT) != 0) {\n+                log.error(pos, Errors.CantAssignInitializedBeforeCtorCalled(v));\n+                return;\n+            }\n@@ -2782,0 +2801,1 @@\n+                   (clazztype.tsym.flags_field & NOOUTERTHIS) == 0 &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1511,1 +1511,1 @@\n-                    if (env1.info.ctorPrologue && (sym.flags_field & SYNTHETIC) == 0)\n+                    if (env1.info.ctorPrologue && !isAllowedEarlyReference(env1, (VarSymbol)sym))\n@@ -3769,0 +3769,1 @@\n+        Assert.check(name == names._this || name == names._super);\n@@ -3778,1 +3779,1 @@\n-                    else if (env1.info.ctorPrologue)\n+                    else if (env1.info.ctorPrologue && !isAllowedEarlyReference(env1, (VarSymbol)sym))\n@@ -3831,0 +3832,64 @@\n+    \/**\n+     * Determine if an early instance field reference may appear in a constructor prologue.\n+     *\n+     * <p>\n+     * This is only allowed when:\n+     *  - The field is being assigned a value (i.e., written but not read)\n+     *  - The field is not inherited from a superclass\n+     *  - The assignment is not within a lambda, because that would require\n+     *    capturing 'this' which is not allowed prior to super().\n+     *\n+     * <p>\n+     * Note, this method doesn't catch all such scenarios, because this method\n+     * is invoked for symbol \"x\" only for \"x = 42\" but not for \"this.x = 42\".\n+     * We also don't verify that the field has no initializer, which is required.\n+     * To catch those cases, we rely on similar logic in Attr.checkAssignable().\n+     *\/\n+    private boolean isAllowedEarlyReference(Env<AttrContext> env, VarSymbol v) {\n+\n+        \/\/ Check assumptions\n+        Assert.check(env.info.ctorPrologue);\n+        Assert.check((v.flags_field & STATIC) == 0);\n+\n+        \/\/ The symbol must appear in the LHS of an assignment statement\n+        if (!(env.tree instanceof JCAssign assign))\n+            return false;\n+\n+        \/\/ The assignment statement must not be within a lambda\n+        if (env.info.isLambda)\n+            return false;\n+\n+        \/\/ Get the symbol's qualifier, if any\n+        JCExpression lhs = TreeInfo.skipParens(assign.lhs);\n+        JCExpression base = lhs instanceof JCFieldAccess select ? select.selected : null;\n+\n+        \/\/ If an early reference, the field must not be declared in a superclass\n+        if (isEarlyReference(env, base, v) && v.owner != env.enclClass.sym)\n+            return false;\n+\n+        \/\/ OK\n+        return true;\n+    }\n+\n+    \/**\n+     * Determine if the variable appearance constitutes an early reference to the current class.\n+     *\n+     * <p>\n+     * This means the variable is an instance field of the current class and it appears\n+     * in an early initialization context of it (i.e., one of its constructor prologues).\n+     *\n+     * <p>\n+     * Such a reference is only allowed for assignments to non-initialized fields that are\n+     * not inherited from a superclass, though that is not enforced by this method.\n+     *\n+     * @param env    The current environment\n+     * @param base   Variable qualifier, if any, otherwise null\n+     * @param v      The variable\n+     *\/\n+    public boolean isEarlyReference(Env<AttrContext> env, JCTree base, VarSymbol v) {\n+        return env.info.ctorPrologue &&\n+            (v.flags() & STATIC) == 0 &&\n+            v.owner.kind == TYP &&\n+            types.isSubtype(env.enclClass.type, v.owner.type) &&\n+            (base == null || TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base));\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":67,"deletions":2,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -402,0 +402,4 @@\n+# 0: symbol or name\n+compiler.err.cant.assign.initialized.before.ctor.called=\\\n+    cannot assign initialized field ''{0}'' before supertype constructor has been called\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8325805\n+ * @summary Permit non-superclass instance field assignments before this\/super in constructors\n+ * @compile\/fail\/ref=DA_DUConstructors.out -XDrawDiagnostics DA_DUConstructors.java\n+ * @enablePreview\n+ *\/\n+\n+public class DA_DUConstructors {\n+    \/\/ identity\n+    class C1 {\n+        final int x;\n+        final int y = x + 1;\n+        C1() {\n+            x = 12;\n+            super();\n+        }\n+    }\n+\n+    class C2 {\n+        final int x;\n+        C2() {\n+            this(x = 3); \/\/ error\n+        }\n+        C2(int i) {\n+            x = 4;\n+        }\n+    }\n+\n+    class C3 {\n+        C3(int i) {}\n+    }\n+    class C4 extends C3 {\n+        final int x;\n+        C4() {\n+            super(x = 3); \/\/ ok\n+        }\n+    }\n+\n+    class C5 {\n+        final int x;\n+        final int y = x + 1; \/\/ x is not DA\n+        C5() {\n+            x = 12; super();\n+        }\n+        C5(int i) {\n+            \/* no prologue *\/\n+            x = i;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/DA_DUConstructors.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+DA_DUConstructors.java:23:17: compiler.err.var.might.already.be.assigned: x\n+DA_DUConstructors.java:42:23: compiler.err.var.might.not.have.been.initialized: x\n+- compiler.note.preview.filename: DA_DUConstructors.java, DEFAULT\n+- compiler.note.preview.recompile\n+2 errors\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/DA_DUConstructors.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8325805\n+ * @summary Permit non-superclass instance field assignments before this\/super in constructors\n+ * @compile\/fail\/ref=EarlyAssignments.out -XDrawDiagnostics EarlyAssignments.java\n+ * @enablePreview\n+ *\/\n+public class EarlyAssignments {\n+\n+    public static class Inner1 {\n+        public int x;\n+\n+        public Inner1() {\n+            x = 123;                        \/\/ OK - \"x\" belongs to this class\n+            this.x = 123;                   \/\/ OK - \"x\" belongs to this class\n+            Inner1.this.x = 123;            \/\/ OK - \"x\" belongs to this class\n+            super();\n+        }\n+\n+        public Inner1(int y) {\n+            y = x;                          \/\/ FAIL - early 'this' reference\n+            y = this.x;                     \/\/ FAIL - early 'this' reference\n+            y = Inner1.this.x;              \/\/ FAIL - early 'this' reference\n+            super();\n+        }\n+\n+        public class Inner1a extends Inner1 {\n+            public int z;\n+            public Inner1a(byte value) {\n+                Inner1.this.x = value;      \/\/ OK - \"x\" belongs to outer class\n+                z = super.x;                \/\/ FAIL - \"x\" belongs to superclass\n+                z = x;                      \/\/ FAIL - \"x\" belongs to superclass\n+                this.z = x;                 \/\/ FAIL - \"x\" belongs to superclass\n+                Inner1a.this.z = x;         \/\/ FAIL - \"x\" belongs to superclass\n+                Object o1 = Inner1.this;    \/\/ OK - Inner1 is an outer class\n+                Object o2 = Inner1a.this;   \/\/ FAIL - Inner1a is this class\n+                super();\n+            }\n+            public Inner1a(short value) {\n+                x = value;                  \/\/ FAIL - \"x\" belongs to superclass\n+                super();\n+            }\n+            public Inner1a(char value) {\n+                this.x = value;             \/\/ FAIL - \"x\" belongs to superclass\n+                super();\n+            }\n+            public Inner1a(int value) {\n+                super.x = value;            \/\/ FAIL - \"x\" belongs to superclass\n+                super();\n+            }\n+        }\n+\n+        public class Inner1b {\n+            public Inner1b(int value) {\n+                Inner1.this.x = value;      \/\/ OK - \"x\" belongs to outer class\n+                super();\n+            }\n+        }\n+    }\n+\n+    public static class Inner2 extends Inner1 {\n+        int y;\n+        public Inner2(int value) {\n+            y = value;                      \/\/ OK  - \"y\" belongs to this class\n+            this.y = value;                 \/\/ OK  - \"y\" belongs to this class\n+            x = value;                      \/\/ FAIL - \"x\" belongs to superclass\n+            this.x = value;                 \/\/ FAIL - \"x\" belongs to superclass\n+            Object o1 = this;               \/\/ FAIL - can't acces 'this' yet\n+            Object o2 = Inner2.this;        \/\/ FAIL - can't acces 'this' yet\n+            super();\n+        }\n+    }\n+\n+    public static class Inner3 {\n+\n+        public int e;\n+\n+        public class Inner3a {\n+\n+            public static int x;\n+\n+            public Inner3a(int val) {\n+                x = val;                    \/\/ OK - \"x\" is a static field\n+                val = x;                    \/\/ OK - \"x\" is a static field\n+                e = val;                    \/\/ OK - \"e\" belongs to outer class\n+                val = e;                    \/\/ OK - \"e\" belongs to outer class\n+                Inner3.this.e = val;        \/\/ OK - \"e\" belongs to outer class\n+                super();\n+            }\n+        }\n+    }\n+\n+    public static class Inner4 {\n+        public int x;\n+\n+        public Inner4() {\n+            x = 0;                              \/\/ OK\n+            x = x + 1;                          \/\/ FAIL - illegal early access\n+            super();\n+        }\n+\n+        public Inner4(int a) {\n+            this.x = 0;                         \/\/ OK\n+            this.x = this.x + 1;                \/\/ FAIL - illegal early access\n+            super();\n+        }\n+\n+        public Inner4(char a) {\n+            Inner4.this.x = 0;                  \/\/ OK\n+            Inner4.this.x = Inner4.this.x + 1;  \/\/ FAIL - illegal early access\n+            super();\n+        }\n+    }\n+\n+    public static class Inner5 extends Inner4 {\n+        public int y;\n+\n+        public Inner5() {\n+            y = x + 1;                          \/\/ FAIL - illegal early access\n+            super();\n+        }\n+\n+        public Inner5(int a) {\n+            this.y = x + 1;                     \/\/ FAIL - illegal early access\n+            super();\n+        }\n+\n+        public Inner5(char a) {\n+            Inner5.this.y = x + 1;              \/\/ FAIL - illegal early access\n+            super();\n+        }\n+\n+        public Inner5(short a) {\n+            y = super.x + 1;                    \/\/ FAIL - illegal early access\n+            super();\n+        }\n+\n+        public Inner5(float a) {\n+            y = Inner5.this.x + 1;              \/\/ FAIL - illegal early access\n+            super();\n+        }\n+    }\n+\n+    public static class Inner6 {\n+        public int x = 1;\n+\n+        public Inner6() {\n+            x = 2;                              \/\/ FAIL - illegal early access\n+            super();\n+        }\n+    }\n+\n+    public static class Inner7 {\n+        public final int x = 1;\n+\n+        public Inner7() {\n+            x = 2;                              \/\/ FAIL - illegal early access\n+            super();\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignments.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+EarlyAssignments.java:21:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:22:17: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:23:23: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:31:21: compiler.err.cant.ref.before.ctor.called: super\n+EarlyAssignments.java:32:21: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:33:26: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:34:34: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:36:36: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:40:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:44:21: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:48:22: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:66:13: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:67:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:68:25: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:69:31: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:98:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:104:22: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:110:35: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:119:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:124:22: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:129:29: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:134:17: compiler.err.cant.ref.before.ctor.called: super\n+EarlyAssignments.java:139:23: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:148:13: compiler.err.cant.assign.initialized.before.ctor.called: x\n+EarlyAssignments.java:157:13: compiler.err.cant.assign.val.to.var: final, x\n+- compiler.note.preview.filename: EarlyAssignments.java, DEFAULT\n+- compiler.note.preview.recompile\n+25 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignments.out","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8325805\n+ * @summary Verify local class in early construction context has no outer instance\n+ * @compile\/fail\/ref=EarlyLocalClass.out -XDrawDiagnostics EarlyLocalClass.java\n+ * @enablePreview\n+ *\/\n+public class EarlyLocalClass {\n+    EarlyLocalClass() {\n+        class Local {\n+            void foo() {\n+                EarlyLocalClass.this.hashCode();    \/\/ this should FAIL\n+            }\n+        }\n+        new Local();                                \/\/ this is OK\n+        super();\n+        new Local();                                \/\/ this is OK\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalClass.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+EarlyLocalClass.java:12:32: compiler.err.no.encl.instance.of.type.in.scope: EarlyLocalClass\n+- compiler.note.preview.filename: EarlyLocalClass.java, DEFAULT\n+- compiler.note.preview.recompile\n+1 error\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalClass.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -94,1 +94,1 @@\n-        this.x = x.length;              \/\/ this should FAIL\n+        this.x++;                       \/\/ this should FAIL\n@@ -148,10 +148,0 @@\n-    public SuperInitFails(short[][] x) {\n-        class Foo {\n-            Foo() {\n-                SuperInitFails.this.hashCode();\n-            }\n-        };\n-        new Foo();                      \/\/ this should FAIL\n-        super();\n-    }\n-\n@@ -171,0 +161,28 @@\n+\n+    public static class Inner2 {\n+        int x;\n+    }\n+    public static class Inner3 extends Inner2 {\n+        int y;\n+        Inner3(byte z) {\n+            x = z;                      \/\/ this should FAIL\n+            super();\n+        }\n+        Inner3(short z) {\n+            this.x = z;                 \/\/ this should FAIL\n+            super();\n+        }\n+        Inner3(char z) {\n+            Inner3.this.x = z;          \/\/ this should FAIL\n+            super();\n+        }\n+        Inner3(int z) {\n+            super.x = z;                \/\/ this should FAIL\n+            super();\n+        }\n+    }\n+\n+    public SuperInitFails(double[][] x) {\n+        Runnable r = () -> this.x = 7;  \/\/ this should FAIL\n+        super();\n+    }\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.java","additions":29,"deletions":11,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -15,3 +15,7 @@\n-SuperInitFails.java:154:9: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:165:31: compiler.err.cant.ref.before.ctor.called: x\n-SuperInitFails.java:169:15: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:155:31: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:159:15: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:168:13: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:172:17: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:176:24: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:180:18: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:186:28: compiler.err.cant.ref.before.ctor.called: this\n@@ -26,1 +30,1 @@\n-SuperInitFails.java:160:18: compiler.err.ctor.calls.not.allowed.here\n+SuperInitFails.java:150:18: compiler.err.ctor.calls.not.allowed.here\n@@ -29,1 +33,1 @@\n-26 errors\n+30 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.out","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -410,0 +410,48 @@\n+    \/\/ we allow 'this' reference prior to super() for field assignments only\n+    public static class Test20 {\n+        private int x;\n+        public Test20(short x) {\n+            x = x;\n+            super();\n+        }\n+        public Test20(int x) {\n+            this.x = x;\n+            super();\n+        }\n+        public Test20(char x) {\n+            Test20.this.x = x;\n+            super();\n+        }\n+        public Test20(byte y) {\n+            x = y;\n+            this((int)y);\n+            this.x++;\n+        }\n+    }\n+\n+    \/\/ allow creating and using local and anonymous classes before super()\n+    \/\/ they will not have enclosing instances though\n+    public static class Test21 {\n+        public Test21(int x) {\n+            Runnable r = new Runnable() {\n+                public void run() {\n+                    this.hashCode();\n+                }\n+            };\n+            r.run();\n+            super();\n+            r.run();\n+        }\n+        public Test21(float x) {\n+            class Foo {\n+                public void bar() {\n+                    this.hashCode();\n+                }\n+            };\n+            new Foo().bar();\n+            super();\n+            new Foo().bar();\n+        }\n+    }\n+\n+\n@@ -451,0 +499,3 @@\n+        new Test20(123);\n+        new Test21((int)123);\n+        new Test21((float)123);\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitGood.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ key: compiler.err.cant.assign.initialized.before.ctor.called\n+ \/\/ options: --enable-preview  -source ${jdk.version}\n+\n+class CantAssignInitializedBeforeCtorCalled {\n+    int x = 1;\n+    CantAssignInitializedBeforeCtorCalled() {\n+        x = 2;\n+        super();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantAssignInitializedBeforeCtorCalled.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"}]}