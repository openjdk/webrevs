{"files":[{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/population_count.hpp\"\n@@ -119,0 +120,51 @@\n+\n+\/*\n+Lemma 1: For a given known bits information, _lo and _hi bounds of corresponding value\n+        range are computed using following formulas :-\n+        - _hi = ~ZEROS\n+        - _lo = ONES\n+Proof:-\n+  - KnownBits.ZEROS and KnownBits.ONES are inferred out of common prefix of value range\n+    delimiting bounds.\n+\n+  - Thus, ~ZEROS not only include set bits in the common prefix but optimistically assumes\n+    that all other bits not included in common prefix are also set, thereby implicitly covering\n+    the actual set bits at runtime.\n+\n+  - Consider following illustration which performs round trip translation\n+    of a value range via knowbits information e.g.\n+    A) Initial value range bounds to infer knownbits.\n+      _lo = 0b11000100\n+      _hi = 0b11000110\n+      _common_prefix      = 0b11000100\n+      _common_prefix_mask = 0b11111100\n+      _known_bits.ones    = _lo & _common_prefix_mask  = 0b11000100\n+      _known_bits.zeros   = ~_lo & _common_prefix_mask = 0b00111000\n+\n+    B) Now transform computed knownbits back to value range.\n+      _new_lo = _known_bits.ones  = 0b11000100\n+      _new_hi = ~known_bits.zeros = 0b11000111\n+\n+  - We now know that ~KnownBits.ZEROS >= UB >= LB >= KnownBits.ONES\n+  - Therefore, popcount(~ZEROS) is guaranteed to be greater than popcount(ONES).\n+  - Also, popcount(~ZEROS) >= Res.UB >= Res.LB >= popcount(ONES)\n+*\/\n+\n+const Type* PopCountINode::Value(PhaseGVN* phase) const {\n+  const Type* t = phase->type(in(1));\n+  if (t == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  KnownBits<juint> bits = t->isa_int()->_bits;\n+  return TypeInt::make(population_count(bits._ones), population_count(~bits._zeros), Type::WidenMax);\n+\n+}\n+\n+const Type* PopCountLNode::Value(PhaseGVN* phase) const {\n+  const Type* t = phase->type(in(1));\n+  if (t == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  KnownBits<julong> bits = t->isa_long()->_bits;\n+  return TypeInt::make(population_count(bits._ones), population_count(~bits._zeros), Type::WidenMax);\n+}\n","filename":"src\/hotspot\/share\/opto\/countbitsnode.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n@@ -91,0 +92,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/countbitsnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+\n+public class PopCountValueTransform {\n+\n+    public int lower_bound = 0;\n+\n+    public int upper_bound = 10000;\n+\n+    @Benchmark\n+    public int StockKernelInt() {\n+        int res = 0;\n+        for (int i = lower_bound; i < upper_bound; i++) {\n+            int constrained_i = Integer.min(1179, Integer.max(1169, i));\n+            res += constrained_i;\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int LogicFoldingKerenlInt() {\n+        int res = 0;\n+        for (int i = lower_bound; i < upper_bound; i++) {\n+            int constrained_i = Integer.min(1179, Integer.max(1169, i));\n+            if (Integer.bitCount(constrained_i) > 20 || Integer.bitCount(constrained_i) < 3) {\n+                throw new AssertionError(\"Uncommon trap\");\n+            }\n+            res += constrained_i;\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public long StockKernelLong() {\n+        long res = 0;\n+        for (int i = lower_bound; i < upper_bound; i++) {\n+            long constrained_i = Long.min(1179, Long.max(1169, i));\n+            res += constrained_i;\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public long LogicFoldingKerenLong() {\n+        long res = 0;\n+        for (int i = lower_bound; i < upper_bound; i++) {\n+            long constrained_i = Long.min(1179L, Long.max(1169L, i));\n+            if (Long.bitCount(constrained_i) > 20L || Long.bitCount(constrained_i) < 3L) {\n+                throw new AssertionError(\"Uncommon trap\");\n+            }\n+            res += constrained_i;\n+        }\n+        return res;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/PopCountValueTransform.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"}]}