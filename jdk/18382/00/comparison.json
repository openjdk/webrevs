{"files":[{"patch":"@@ -5045,0 +5045,266 @@\n+const static uint64_t right_16_bits = right_n_bits(16);\n+const static uint64_t right_8_bits = right_n_bits(8);\n+\n+  \/***\n+   *  int java.util.zip.Adler32.updateBytes(int adler, byte[] b, int off, int len)\n+   *\n+   *  Arguments:\n+   *\n+   *  Inputs:\n+   *   c_rarg0   - int   adler\n+   *   c_rarg1   - byte* buff (b + off)\n+   *   c_rarg2   - int   len\n+   *\n+   * Output:\n+   *   c_rarg0   - int adler result\n+   *\/\n+  address generate_updateBytesAdler32() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"updateBytesAdler32\");\n+    address start = __ pc();\n+\n+    Label L_simple_by1_loop, L_nmax, L_nmax_loop, L_by16, L_by16_loop, L_by1_loop, L_do_mod, L_combine, L_by1;\n+\n+    \/\/ Aliases\n+    Register adler  = c_rarg0;\n+    Register s1     = c_rarg0;\n+    Register s2     = c_rarg3;\n+    Register buff   = c_rarg1;\n+    Register len    = c_rarg2;\n+    Register nmax  = x29; \/\/ t4\n+    Register base  = x30; \/\/ t5\n+    Register count = x31; \/\/ t6\n+    Register temp0 = c_rarg4;\n+    Register temp1 = c_rarg5;\n+    Register temp2 = t2;\n+    Register temp3 = x28; \/\/ t3\n+\n+    \/\/ Max number of bytes we can process before having to take the mod\n+    \/\/ 0x15B0 is 5552 in decimal, the largest n such that 255n(n+1)\/2 + (n+1)(BASE-1) <= 2^32-1\n+    const uint64_t BASE = 0xfff1;\n+    const uint64_t NMAX = 0x15B0;\n+\n+    __ mv(temp3, right_16_bits);\n+\n+    __ mv(base, BASE);\n+    __ mv(nmax, NMAX);\n+\n+    \/\/ s1 is initialized to the lower 16 bits of adler\n+    \/\/ s2 is initialized to the upper 16 bits of adler\n+    __ srli(s2, adler, 16); \/\/ s2 = ((adler >> 16) & 0xffff)\n+    __ andr(s2, s2, temp3);\n+    __ andr(s1, adler, temp3); \/\/ s1 = (adler & 0xffff)\n+\n+    \/\/ The pipelined loop needs at least 16 elements for 1 iteration\n+    \/\/ It does check this, but it is more effective to skip to the cleanup loop\n+    __ mv(temp0, (u1)16);\n+    __ bgeu(len, temp0, L_nmax);\n+    __ beqz(len, L_combine);\n+\n+    __ bind(L_simple_by1_loop);\n+    __ lbu(temp0, Address(buff, 0));\n+    __ addi(buff, buff, 1);\n+    __ add(s1, s1, temp0);\n+    __ add(s2, s2, s1);\n+    __ sub(len, len, 1);\n+    __ bgtz(len, L_simple_by1_loop);\n+\n+    \/\/ s1 = s1 % BASE\n+    __ remuw(s1, s1, base);\n+\n+    \/\/ s2 = s2 % BASE\n+    __ remuw(s2, s2, base);\n+\n+    __ j(L_combine);\n+\n+    __ bind(L_nmax);\n+    __ sub(len, len, nmax);\n+    __ sub(count, nmax, 16);\n+    __ bltz(len, L_by16);\n+\n+    __ bind(L_nmax_loop);\n+\n+    __ ld(temp0, Address(buff, 0));\n+    __ ld(temp1, Address(buff, sizeof(jlong)));\n+    __ addi(buff, buff, 16);\n+\n+    __ andi(temp2, temp0, right_8_bits);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp0, 8);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp0, 16);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp0, 24);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp0, 32);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp0, 40);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp0, 48);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ add(s2, s2, s1);\n+    __ srli(temp2, temp0, 56);\n+    __ add(s1, s1, temp2);\n+    __ add(s2, s2, s1);\n+\n+    __ andi(temp2, temp1, right_8_bits);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp1, 8);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp1, 16);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp1, 24);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp1, 32);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp1, 40);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp1, 48);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ add(s2, s2, s1);\n+    __ srli(temp2, temp1, 56);\n+    __ add(s1, s1, temp2);\n+    __ add(s2, s2, s1);\n+\n+    __ sub(count, count, 16);\n+    __ bgez(count, L_nmax_loop);\n+\n+    \/\/ s1 = s1 % BASE\n+    __ remuw(s1, s1, base);\n+\n+    \/\/ s2 = s2 % BASE\n+    __ remuw(s2, s2, base);\n+\n+    __ sub(len, len, nmax);\n+    __ sub(count, nmax, 16);\n+    __ bgez(len, L_nmax_loop);\n+\n+    __ bind(L_by16);\n+    __ add(len, len, count);\n+    __ bltz(len, L_by1);\n+\n+    __ bind(L_by16_loop);\n+\n+    __ ld(temp0, Address(buff, 0));\n+    __ ld(temp1, Address(buff, sizeof(jlong)));\n+    __ addi(buff, buff, 16);\n+\n+    __ andi(temp2, temp0, right_8_bits);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp0, 8);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp0, 16);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp0, 24);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp0, 32);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp0, 40);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp0, 48);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ add(s2, s2, s1);\n+    __ srli(temp2, temp0, 56);\n+    __ add(s1, s1, temp2);\n+    __ add(s2, s2, s1);\n+\n+    __ andi(temp2, temp1, right_8_bits);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp1, 8);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp1, 16);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp1, 24);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp1, 32);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp1, 40);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ srli(temp2, temp1, 48);\n+    __ andi(temp2, temp2, right_8_bits);\n+    __ add(s2, s2, s1);\n+    __ add(s1, s1, temp2);\n+    __ add(s2, s2, s1);\n+    __ srli(temp2, temp1, 56);\n+    __ add(s1, s1, temp2);\n+    __ add(s2, s2, s1);\n+\n+    __ sub(len, len, 16);\n+    __ bgez(len, L_by16_loop);\n+\n+    __ bind(L_by1);\n+    __ add(len, len, 15);\n+    __ bltz(len, L_do_mod);\n+\n+    __ bind(L_by1_loop);\n+    __ lbu(temp0, Address(buff, 0));\n+    __ addi(buff, buff, 1);\n+    __ add(s1, temp0, s1);\n+    __ add(s2, s2, s1);\n+    __ sub(len, len, 1);\n+    __ bgez(len, L_by1_loop);\n+\n+    __ bind(L_do_mod);\n+    \/\/ s1 = s1 % BASE\n+    __ remuw(s1, s1, base);\n+\n+    \/\/ s2 = s2 % BASE\n+    __ remuw(s2, s2, base);\n+\n+    \/\/ Combine lower bits and higher bits\n+    \/\/ adler = s1 | (s2 << 16)\n+    __ bind(L_combine);\n+    __ slli(s2, s2, 16);\n+    __ orr(s1, s1, s2);\n+\n+    __ ret();\n+\n+    return start;\n+  }\n+\n@@ -5624,0 +5890,4 @@\n+    if (UseAdler32Intrinsics) {\n+      StubRoutines::_updateBytesAdler32 = generate_updateBytesAdler32();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":270,"deletions":0,"binary":false,"changes":270,"status":"modified"},{"patch":"@@ -162,0 +162,4 @@\n+  if (FLAG_IS_DEFAULT(UseAdler32Intrinsics)) {\n+    FLAG_SET_DEFAULT(UseAdler32Intrinsics, true);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}