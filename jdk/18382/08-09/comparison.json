{"files":[{"patch":"@@ -5112,0 +5112,54 @@\n+  void adler32_process_bytes_by32(Register buff, Register s1, Register s2, Register count,\n+    VectorRegister vtable, VectorRegister vzero, VectorRegister *vbytes, VectorRegister *vs1acc, VectorRegister *vs2acc, \n+    Register temp0, Register temp1, Register temp2, VectorRegister vtemp1, VectorRegister vtemp2) {\n+\n+    \/\/ Same algorithm as for 64 bytes, but shrinked to 32 bytes step:\n+    \/\/   s1_new = s1 + b1 + b2 + ... + b32\n+    \/\/   s2_new = s2 + (s1 + b1) + (s1 + b1 + b2) + ... + (s1 + b1 + b2 + ... + b32)\n+    \/\/          = s2 + s1 * 32 + (b1 * 32 + b2 * 31 + ... + b32 * 1)\n+    \/\/          = s2 + s1 * 32 + (b1, b2, ... b16) dot (32, 31, ... 1)\n+\n+    __ mv(count, 32);\n+    \/\/ Load data\n+    __ vsetvli(temp0, count, Assembler::e8, Assembler::m2);\n+    __ vle8_v(vbytes[0], buff);\n+    __ addi(buff, buff, 32);\n+\n+    \/\/ Reduction sum for s1_new\n+    \/\/ 0xFF * 32 = 0x1FE0, so:\n+    \/\/ 1. Need to do vector-widening reduction sum\n+    \/\/ 2. It is safe to perform sign-extension during vmv.x.s with 16-bits elements\n+    __ vwredsumu_vs(vs1acc[0], vbytes[0], vzero);\n+    \/\/ Multiplication for s2_new\n+    __ vwmulu_vv(vs2acc[0], vtable, vbytes[0]);\n+\n+    \/\/ s2 = s2 + s1 * 32\n+    __ slli(temp1, s1, 5);\n+    __ add(s2, s2, temp1);\n+\n+    \/\/ Summing up calculated results for s2_new\n+    __ vsetvli(temp0, count, Assembler::e16, Assembler::m2);\n+    \/\/ Upper bound for reduction sum:\n+    \/\/ 0xFF * (32 + 31 + ... + 2 + 1) = 0x20DF0 max for whole register group, so:\n+    \/\/ 1. Need to do vector-widening reduction sum\n+    \/\/ 2. It is safe to perform sign-extension during vmv.x.s with 32-bits elements\n+    __ vwredsumu_vs(vtemp1, vs2acc[0], vzero);\n+    if (MaxVectorSize == 16)\n+      \/\/ For small vector length, the rest of multiplied data\n+      \/\/ is in successor of vs2acc[i], so summing it up, too\n+      __ vwredsumu_vs(vtemp2, vs2acc[1], vzero);\n+\n+    \/\/ Extracting results for:\n+    \/\/ s1_new\n+    __ vmv_x_s(temp0, vs1acc[0]);\n+    __ add(s1, s1, temp0);\n+    \/\/ s2_new\n+    __ vsetvli(temp0, count, Assembler::e32, Assembler::m1);\n+    __ vmv_x_s(temp1, vtemp1);\n+    __ add(s2, s2, temp1);\n+    if (MaxVectorSize == 16) {\n+      __ vmv_x_s(temp2, vtemp2);\n+      __ add(s2, s2, temp2);\n+    }\n+  }\n+\n@@ -5222,0 +5276,1 @@\n+    VectorRegister vtable_32 = (MaxVectorSize == 16) ? v26 : v4;\n@@ -5239,0 +5294,8 @@\n+    if (MaxVectorSize > 16) {\n+      \/\/ Need to generate vtable_32 explicitly\n+      __ mv(temp1, 32);\n+      __ vsetvli(temp0, temp1, Assembler::e8, Assembler::m2);\n+      __ vid_v(vtemp1);\n+      __ vrsub_vx(vtable_32, vtemp1, temp1);\n+      \/\/ vtable_32 group now contains { 0x20, 0x1f, 0x1e, ..., 0x3, 0x2, 0x1 }\n+    }\n@@ -5242,0 +5305,1 @@\n+      __ mv(temp1, 16);\n@@ -5243,1 +5307,2 @@\n-      __ vrsub_vi(vtable_16, vtemp1, 16);\n+      __ vrsub_vx(vtable_16, vtemp1, temp1);\n+      \/\/ vtable_32 group now contains { 0x10, 0xf, 0xe, ..., 0x3, 0x2, 0x1 }\n@@ -5299,1 +5364,3 @@\n-    const int remainder = 3;\n+    adler32_process_bytes_by32(buff, s1, s2, step, vtable_32, vzero,\n+      vbytes, vs1acc, vs2acc, temp0, temp1, temp2, vtemp1, vtemp2);\n+    const int remainder = 1;\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":69,"deletions":2,"binary":false,"changes":71,"status":"modified"}]}