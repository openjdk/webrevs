{"files":[{"patch":"@@ -5045,3 +5045,2 @@\n-  void generate_updateBytesAdler32_accum(Register buff, Register temp0,\n-          VectorRegister vtemp1, VectorRegister vtemp2, VectorRegister vtemp3, VectorRegister vzero,\n-          VectorRegister vbytes, VectorRegister vs1acc, VectorRegister vs2acc, VectorRegister vtable) {\n+  void generate_updateBytesAdler32_accum(Register buff, VectorRegister vzero, VectorRegister vbytes,\n+    VectorRegister vs1acc, VectorRegister vs2acc, VectorRegister vtable) {\n@@ -5067,2 +5066,0 @@\n-    __ vsetivli(temp0, 16, Assembler::e8, Assembler::m1);\n-\n@@ -5076,2 +5073,20 @@\n-    \/\/ vs2acc = (b1 * 16) + (b2 * 15) + (b3 * 14) + ... + (b16 * 1)\n-    __ vwmulu_vv(vtemp1, vtable, vbytes); \/\/ vtemp2 now contains the second part of multiplication\n+    \/\/ vs2acc = { (b1 * 16), (b2 * 15), (b3 * 14), ..., (b8 * 9) }\n+    \/\/ vs2acc->successor() = { (b9 * 8), (b10 * 7), (b11 * 6), ..., (b16 * 1) }\n+    __ vwmulu_vv(vs2acc, vtable, vbytes); \/\/ vs2acc->successor() now contains the second part of multiplication\n+    \/\/ The only thing that remains is to sum up the remembered result\n+  }\n+\n+  void generate_updateBytesAdler32_unroll(Register buff, Register s1, Register s2, int unroll_factor,\n+    VectorRegister vtable, VectorRegister vbytes, VectorRegister vzero, VectorRegister *unroll_regs,\n+    Register temp0, Register temp1, Register temp2, VectorRegister vtemp1, VectorRegister vtemp2) {\n+\n+    assert(unroll_factor <= 8, \"Not enough vector registers in unroll_regs\");\n+    \/\/ Below is partial loop unrolling for updateBytesAdler32:\n+    \/\/ First, the unroll*16 bytes are processed, the results are in\n+    \/\/ v4, v5, v6, ..., v25, v26, v27\n+    \/\/ Second, the final summation for unrolled part of the loop should be performed\n+\n+    __ vsetivli(temp0, 16, Assembler::e8, Assembler::m1);\n+    for (int i = 0; i < unroll_factor; i++)\n+      generate_updateBytesAdler32_accum(buff, vzero, vbytes, unroll_regs[i], unroll_regs[i + 8], vtable);\n+    \/\/ Summing up\n@@ -5079,3 +5094,18 @@\n-    __ vadd_vv(vtemp3, vtemp1, vtemp2); \/\/ 0x14 * 0xFF * 2 = 0x27D8 -- max value per element,\n-                                        \/\/ so no need to do vector-widening operation\n-    __ vwredsumu_vs(vs2acc, vtemp3, vzero);\n+    for (int i = 0; i < unroll_factor; i++) {\n+      \/\/ s2 = s2 + s1 * 16\n+      __ slli(temp1, s1, 4);\n+      __ add(s2, s2, temp1);\n+\n+      \/\/ 0xFF * 0x10 = 0xFF0, 0xFF0 * 8 = 7F80, so:\n+      \/\/ 1. No need to do vector-widening reduction sum\n+      \/\/ 2. It is safe to perform sign-extension during vmv.x.s\n+      __ vredsum_vs(vtemp1, unroll_regs[i + 8], vzero);\n+      __ vredsum_vs(vtemp2, unroll_regs[i + 8]->successor(), vzero);\n+\n+      __ vmv_x_s(temp0, unroll_regs[i]);\n+      __ vmv_x_s(temp1, vtemp1);\n+      __ vmv_x_s(temp2, vtemp2);\n+      __ add(s1, s1, temp0);\n+      __ add(s2, s2, temp1);\n+      __ add(s2, s2, temp2);\n+    }\n@@ -5115,7 +5145,2 @@\n-    Register buf_end = c_rarg6;\n-    VectorRegister vbytes = v1;\n-    VectorRegister vtable = v3;\n-    VectorRegister vtemp1 = v4;\n-    VectorRegister vtemp2 = v5;\n-    VectorRegister vtemp3 = v30;\n-    VectorRegister vzero = v12;\n+    Register temp2 = c_rarg6;\n+    Register buf_end = c_rarg7;\n@@ -5123,0 +5148,3 @@\n+    VectorRegister vbytes = v1;\n+    VectorRegister vtable = v2;\n+    VectorRegister vzero = v3;\n@@ -5124,2 +5152,2 @@\n-      v13, v14, v15, v16, v17, v18, v19, v20,\n-      v21, v22, v23, v24, v25, v26, v27, v28,\n+      v4, v5, v6, v7, v8, v9, v10, v11,\n+      v12, v14, v16, v18, v20, v22, v24, v26\n@@ -5127,0 +5155,2 @@\n+    VectorRegister vtemp1 = v28;\n+    VectorRegister vtemp2 = v29;\n@@ -5133,0 +5163,3 @@\n+    \/\/ Unroll factor for L_nmax loop\n+    const int unroll = 8;\n+\n@@ -5138,1 +5171,1 @@\n-    __ li(temp0, 16);\n+    __ mv(temp0, 16);\n@@ -5148,5 +5181,0 @@\n-    \/\/ Zeroing all unroll registers\n-    for (int i = 0; i < 16; i++) {\n-      __ vmv_v_i(unroll_regs[i], 0);\n-    }\n-\n@@ -5182,1 +5210,0 @@\n-\n@@ -5200,16 +5227,2 @@\n-    for (int i = 0; i < 8; i++)\n-      generate_updateBytesAdler32_accum(buff, temp0, vtemp1, vtemp2, vtemp3, vzero, vbytes, unroll_regs[i], unroll_regs[i + 8], vtable);\n-\n-    \/\/ Summing up\n-    __ vsetivli(temp0, 2, Assembler::e64, Assembler::m1); \/\/ Set SEW to 64 to avoid sign-extension\n-                                                          \/\/ in the next instructions\n-    for (int i = 0; i < 8; i++) {\n-      \/\/ s2 = s2 + s1 * 16\n-      __ slli(temp1, s1, 4);\n-      __ add(s2, s2, temp1);\n-\n-      __ vmv_x_s(temp0, unroll_regs[i]);\n-      __ vmv_x_s(temp1, unroll_regs[i + 8]);\n-      __ add(s1, s1, temp0);\n-      __ add(s2, s2, temp1);\n-    }\n+    generate_updateBytesAdler32_unroll(buff, s1, s2, unroll, vtable, vbytes,\n+      vzero, unroll_regs, temp0, temp1, temp2, vtemp1, vtemp2);\n@@ -5218,17 +5231,4 @@\n-    \/\/ Do the calculations for remaining 48 bytes\n-    generate_updateBytesAdler32_accum(buff, temp0, vtemp1, vtemp2, vtemp3, vzero, vbytes, unroll_regs[0], unroll_regs[8], vtable);\n-    generate_updateBytesAdler32_accum(buff, temp0, vtemp1, vtemp2, vtemp3, vzero, vbytes, unroll_regs[1], unroll_regs[9], vtable);\n-    generate_updateBytesAdler32_accum(buff, temp0, vtemp1, vtemp2, vtemp3, vzero, vbytes, unroll_regs[2], unroll_regs[10], vtable);\n-    \/\/ Summing up\n-    __ vsetivli(temp0, 2, Assembler::e64, Assembler::m1); \/\/ Set SEW to 64 to avoid sign-extension\n-                                                          \/\/ in the next instructions\n-    for (int i = 0; i < 3; i++) {\n-      \/\/ s2 = s2 + s1 * 16\n-      __ slli(temp1, s1, 4);\n-      __ add(s2, s2, temp1);\n-\n-      __ vmv_x_s(temp0, unroll_regs[i]);\n-      __ vmv_x_s(temp1, unroll_regs[i + 8]);\n-      __ add(s1, s1, temp0);\n-      __ add(s2, s2, temp1);\n-    }\n+    const int remainder = ((NMAX \/ 16) % unroll);\n+    \/\/ Do the calculations for remaining 16*remainder bytes\n+    generate_updateBytesAdler32_unroll(buff, s1, s2, remainder, vtable, vbytes,\n+      vzero, unroll_regs, temp0, temp1, temp2, vtemp1, vtemp2);\n@@ -5238,1 +5238,0 @@\n-\n@@ -5251,11 +5250,2 @@\n-    generate_updateBytesAdler32_accum(buff, temp0, vtemp1, vtemp2, vtemp3, vzero, vbytes, unroll_regs[0], unroll_regs[8], vtable);\n-    \/\/ s1 = s1 + unroll_regs[0], s2 = s2 + unroll_regs[8]\n-    __ vsetivli(temp0, 2, Assembler::e64, Assembler::m1); \/\/ Set SEW to 64 to avoid sign-extension\n-                                                          \/\/ in the next instructions\n-    \/\/ s2 = s2 + s1 * 16\n-    __ slli(temp1, s1, 4);\n-    __ add(s2, s2, temp1);\n-    __ vmv_x_s(temp0, unroll_regs[0]);\n-    __ vmv_x_s(temp1, unroll_regs[8]);\n-    __ add(s1, s1, temp0);\n-    __ add(s2, s2, temp1);\n+    generate_updateBytesAdler32_unroll(buff, s1, s2, 1, vtable, vbytes,\n+      vzero, unroll_regs, temp0, temp1, temp2, vtemp1, vtemp2);\n@@ -5281,1 +5271,0 @@\n-\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":61,"deletions":72,"binary":false,"changes":133,"status":"modified"}]}