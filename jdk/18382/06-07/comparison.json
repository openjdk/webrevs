{"files":[{"patch":"@@ -5045,0 +5045,2 @@\n+static const uint64_t right_16_bits = right_n_bits(16);\n+\n@@ -5081,1 +5083,3 @@\n-    \/\/ 0xFF * 0x10 = 0xFF0, 0xFF0 * 8 = 7F80, 7F80 * 4 = 1FE00 max, so:\n+    \/\/ 0xFF   * 0x10 = 0xFF0   max per single vector element,\n+    \/\/ 0xFF0  * 0x10 = 0xFF00  max per vector,\n+    \/\/ 0xFF00 * 0x4  = 0x3FC00 max for the whole group, so:\n@@ -5085,1 +5089,4 @@\n-    __ vwredsumu_vs(vtemp2, vs2acc[2], vzero);\n+    if (MaxVectorSize == 16)\n+      \/\/ For small vector length, the rest of multiplied data\n+      \/\/ is in successor of vs2acc[i], so summing it up, too\n+      __ vwredsumu_vs(vtemp2, vs2acc[2], vzero);\n@@ -5095,2 +5102,4 @@\n-    __ vmv_x_s(temp2, vtemp2);\n-    __ add(s2, s2, temp2);\n+    if (MaxVectorSize == 16) {\n+      __ vmv_x_s(temp2, vtemp2);\n+      __ add(s2, s2, temp2);\n+    }\n@@ -5099,1 +5108,1 @@\n-  void adler32_process_bytes_by16(Register buff, Register s1, Register s2, Register count,\n+  void adler32_process_bytes_by16(Register buff, Register s1, Register s2, Register right_16_bits,\n@@ -5109,5 +5118,0 @@\n-    \/\/ Load data for unrolling steps all at once\n-    __ vsetvli(temp0, count, Assembler::e8, Assembler::m4);\n-    __ vle8_v(vbytes[0], buff);\n-    __ addi(buff, buff, LMUL*16);\n-\n@@ -5116,0 +5120,3 @@\n+      __ vle8_v(vbytes[i], buff);\n+      __ addi(buff, buff, 16);\n+\n@@ -5131,1 +5138,1 @@\n-    __ vsetivli(temp0, 8, Assembler::e16, Assembler::m1);\n+    __ vsetivli(temp0, (MaxVectorSize == 16) ? 8 : 16, Assembler::e16, Assembler::m1);\n@@ -5138,3 +5145,3 @@\n-      \/\/ 0xFF * 0x10 = 0xFF0, 0xFF0 * 8 = 7F80, so:\n-      \/\/ 1. No need to do vector-widening reduction sum\n-      \/\/ 2. It is safe to perform sign-extension during vmv.x.s with 16-bits elements\n+      \/\/ 0xFF  * 0x10 = 0xFF0  max per single vector element,\n+      \/\/ 0xFF0 + 0xFEF + ... + FE1 = 0xFE88 max sum for 16-byte step\n+      \/\/ No need to do vector-widening reduction sum\n@@ -5142,1 +5149,5 @@\n-      __ vredsum_vs(vtemp2, vs2acc[i]->successor(), vzero);\n+      if (MaxVectorSize == 16) {\n+        \/\/ For small vector length, the rest of multiplied data\n+        \/\/ is in successor of vs2acc[i], so summing it up, too\n+        __ vredsum_vs(vtemp2, vs2acc[i]->successor(), vzero);\n+      }\n@@ -5147,1 +5158,0 @@\n-      __ vmv_x_s(temp2, vtemp2);\n@@ -5149,0 +5159,8 @@\n+      if (MaxVectorSize == 16) {\n+        __ vmv_x_s(temp2, vtemp2);\n+        __ add(s2, s2, temp2);\n+      } else {\n+        \/\/ For MaxVectorSize > 16 multiplied data is in single register, so it is\n+        \/\/ not safe to perform sign-extension during vmv.x.s with 16-bits elements\n+        __ andr(temp1, temp1, right_16_bits);\n+      }\n@@ -5150,1 +5168,0 @@\n-      __ add(s2, s2, temp2);\n@@ -5172,1 +5189,2 @@\n-    Label L_simple_by1_loop, L_nmax, L_nmax_loop, L_nmax_loop_entry, L_by16, L_by16_loop, L_by1_loop, L_do_mod, L_combine, L_by1;\n+    Label L_simple_by1_loop, L_nmax, L_nmax_loop, L_nmax_loop_entry,\n+      L_by16, L_by16_loop, L_by16_loop_unroll, L_by1_loop, L_do_mod, L_combine, L_by1;\n@@ -5186,0 +5204,2 @@\n+    Register right_16_bits = c_rarg7;\n+    Register step = x28; \/\/ t3\n@@ -5198,1 +5218,1 @@\n-    VectorRegister vtable_16 = v27;\n+    VectorRegister vtable_16 = (MaxVectorSize == 16) ? v27 : v30;\n@@ -5216,1 +5236,0 @@\n-\n@@ -5218,0 +5237,10 @@\n+    if (MaxVectorSize > 16) {\n+      \/\/ Need to generate vtable_16 explicitly\n+      __ mv(temp1, 16);\n+      __ vsetvli(temp0, temp1, Assembler::e8, Assembler::m1);\n+\n+      \/\/ Generating accumulation coefficients for further calculations\n+      __ vid_v(vtemp1);\n+      __ vmv_v_x(vtable_16, temp1);\n+      __ vsub_vv(vtable_16, vtable_16, vtemp1);\n+    }\n@@ -5221,0 +5250,1 @@\n+    __ mv(right_16_bits, right_n_bits(16));\n@@ -5226,4 +5256,2 @@\n-      const uint64_t right_16_bits = right_n_bits(16);\n-      __ mv(temp0, right_16_bits);\n-      __ andr(s2, s2, temp0);\n-      __ andr(s1, adler, temp0); \/\/ s1 = (adler & 0xffff)\n+      __ andr(s2, s2, right_16_bits);\n+      __ andr(s1, adler, right_16_bits); \/\/ s1 = (adler & 0xffff)\n@@ -5260,0 +5288,1 @@\n+    __ mv(step, 64);\n@@ -5266,1 +5295,1 @@\n-    adler32_process_bytes_by64(buff, s1, s2, count, vtable_64, vzero,\n+    adler32_process_bytes_by64(buff, s1, s2, step, vtable_64, vzero,\n@@ -5273,2 +5302,1 @@\n-    __ mv(count, 16*remainder);\n-    adler32_process_bytes_by16(buff, s1, s2, count, vtable_16, vzero,\n+    adler32_process_bytes_by16(buff, s1, s2, right_16_bits, vtable_16, vzero,\n@@ -5289,0 +5317,9 @@\n+    \/\/ Trying to unroll\n+    __ mv(count, 64);\n+    __ blt(len, count, L_by16_loop);\n+\n+  __ bind(L_by16_loop_unroll);\n+    adler32_process_bytes_by64(buff, s1, s2, count, vtable_64, vzero,\n+      vbytes, vs1acc, vs2acc, temp0, temp1, temp2, vtemp1, vtemp2);\n+    __ sub(len, len, 64);\n+    __ bge(len, count, L_by16_loop_unroll);\n@@ -5290,0 +5327,1 @@\n+    __ blt(len, count, L_by1);\n@@ -5292,1 +5330,1 @@\n-    adler32_process_bytes_by16(buff, s1, s2, count, vtable_16, vzero,\n+    adler32_process_bytes_by16(buff, s1, s2, right_16_bits, vtable_16, vzero,\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":66,"deletions":28,"binary":false,"changes":94,"status":"modified"}]}