{"files":[{"patch":"@@ -594,0 +594,4 @@\n+    XVMINSP_OPCODE = (60u << OPCODE_SHIFT |  200u << 3),\n+    XVMINDP_OPCODE = (60u << OPCODE_SHIFT |  232u << 3),\n+    XVMAXSP_OPCODE = (60u << OPCODE_SHIFT |  192u << 3),\n+    XVMAXDP_OPCODE = (60u << OPCODE_SHIFT |  224u << 3),\n@@ -702,0 +706,1 @@\n+    VMAXSD_OPCODE  = (4u  << OPCODE_SHIFT |  450u     ),\n@@ -705,0 +710,1 @@\n+    VMAXUD_OPCODE  = (4u  << OPCODE_SHIFT |  194u     ),\n@@ -708,0 +714,1 @@\n+    VMINSD_OPCODE  = (4u  << OPCODE_SHIFT |  962u     ),\n@@ -711,0 +718,1 @@\n+    VMINUD_OPCODE  = (4u  << OPCODE_SHIFT |  706u     ),\n@@ -2307,0 +2315,1 @@\n+  inline void vmaxsd(   VectorRegister d, VectorRegister a, VectorRegister b);\n@@ -2310,0 +2319,1 @@\n+  inline void vmaxud(   VectorRegister d, VectorRegister a, VectorRegister b);\n@@ -2313,0 +2323,1 @@\n+  inline void vminsd(   VectorRegister d, VectorRegister a, VectorRegister b);\n@@ -2316,0 +2327,1 @@\n+  inline void vminud(   VectorRegister d, VectorRegister a, VectorRegister b);\n@@ -2440,0 +2452,6 @@\n+  \/\/ The following functions do not match exactly the Java.math semantics.\n+  inline void xvminsp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);\n+  inline void xvmindp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);\n+  inline void xvmaxsp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);\n+  inline void xvmaxdp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -919,0 +919,5 @@\n+inline void Assembler::xvminsp(VectorSRegister d, VectorSRegister a, VectorSRegister b) { emit_int32( XVMINSP_OPCODE | vsrt(d) | vsra(a) | vsrb(b)); }\n+inline void Assembler::xvmindp(VectorSRegister d, VectorSRegister a, VectorSRegister b) { emit_int32( XVMINDP_OPCODE | vsrt(d) | vsra(a) | vsrb(b)); }\n+inline void Assembler::xvmaxsp(VectorSRegister d, VectorSRegister a, VectorSRegister b) { emit_int32( XVMAXSP_OPCODE | vsrt(d) | vsra(a) | vsrb(b)); }\n+inline void Assembler::xvmaxdp(VectorSRegister d, VectorSRegister a, VectorSRegister b) { emit_int32( XVMAXDP_OPCODE | vsrt(d) | vsra(a) | vsrb(b)); }\n+\n@@ -1033,0 +1038,1 @@\n+inline void Assembler::vmaxsd(  VectorRegister d, VectorRegister a, VectorRegister b) { emit_int32( VMAXSD_OPCODE   | vrt(d) | vra(a) | vrb(b)); }\n@@ -1036,0 +1042,1 @@\n+inline void Assembler::vmaxud(  VectorRegister d, VectorRegister a, VectorRegister b) { emit_int32( VMAXUD_OPCODE   | vrt(d) | vra(a) | vrb(b)); }\n@@ -1039,0 +1046,1 @@\n+inline void Assembler::vminsd(  VectorRegister d, VectorRegister a, VectorRegister b) { emit_int32( VMINSD_OPCODE   | vrt(d) | vra(a) | vrb(b)); }\n@@ -1042,0 +1050,1 @@\n+inline void Assembler::vminud(  VectorRegister d, VectorRegister a, VectorRegister b) { emit_int32( VMINUD_OPCODE   | vrt(d) | vra(a) | vrb(b)); }\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -629,0 +629,57 @@\n+\n+void C2_MacroAssembler::reduceI(int opcode, Register dst, Register iSrc, VectorRegister vSrc,\n+                                VectorRegister vTmp1, VectorRegister vTmp2) {\n+\n+  auto fn_vec_op = [this](int opcode, const VectorRegister &dst, const VectorRegister &a, const VectorRegister &b) {\n+    switch(opcode) {\n+      case Op_AddReductionVI:\n+        vadduwm(dst, a, b); break;\n+      case Op_MulReductionVI:\n+        vmuluwm(dst, a , b); break;\n+      case Op_AndReductionV:\n+        vand(dst, a, b); break;\n+      case Op_OrReductionV:\n+        vor(dst, a, b); break;\n+      case Op_XorReductionV:\n+        vxor(dst, a, b); break;\n+      case Op_MinReductionV:\n+        vminsw(dst, a, b); break;\n+      case Op_MaxReductionV:\n+        vmaxsw(dst, a, b); break;\n+      default: assert(false, \"wrong opcode\");\n+    }\n+  };\n+\n+  auto fn_scalar_op = [this](int opcode, const Register &dst, const Register &src) {\n+    switch (opcode) {\n+      case Op_AddReductionVI:\n+        add(dst, src, dst); break;\n+      case Op_MulReductionVI:\n+        mullw(dst, src, dst); break;\n+      case Op_AndReductionV:\n+        andr(dst, src, dst); break;\n+      case Op_OrReductionV:\n+        orr(dst, src, dst); break;\n+      case Op_XorReductionV:\n+        xorr(dst, src, dst); break;\n+      case Op_MinReductionV:\n+        cmpw(CR0, src, dst);\n+        isel(dst, CR0, Assembler::less, \/*invert*\/false, src, dst);\n+        break;\n+      case Op_MaxReductionV:\n+        cmpw(CR0, src, dst);\n+        isel(dst, CR0, Assembler::greater, \/*invert*\/false, src, dst);\n+        break;\n+      default: assert(false, \"wrong opcode\");\n+    }\n+  };\n+\n+  \/\/ vSrc = [i0,i1,i2,i3]\n+  vsldoi(vTmp1, vSrc, vSrc, 8);           \/\/ vTmp1 <- [i2,i3,i0,i1]\n+  fn_vec_op(opcode, vTmp2, vSrc, vTmp1);  \/\/ vTmp2 <- [op(i0,i2), op(i1,i3), op(i2,i0), op(i3,i1)]\n+  vsldoi(vTmp1, vTmp2, vTmp2, 4);         \/\/ vTmp1 <- [op(i1,i3), op(i2,i0), op(i3,i1), op(i0,i2)]\n+  fn_vec_op(opcode, vTmp1, vTmp1, vTmp2); \/\/ vTmp1 <- [op(i0,i1,i2,i3), op(i0,i1,i2,i3), op(i0,i1,i2,i3), op(i0,i1,i2,i3)]\n+  mfvsrwz(dst, vTmp1.to_vsr());           \/\/\n+  fn_scalar_op(opcode, dst, iSrc);        \/\/ dst <- op(iSrc, dst)\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.cpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+  void reduceI(int opcode, Register dst, Register iSrc, VectorRegister vSrc, VectorRegister vTmp1, VectorRegister vTmp2);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2407,0 +2407,12 @@\n+    case Op_MinV:\n+    case Op_MaxV:\n+    case Op_AndV:\n+    case Op_OrV:\n+    case Op_XorV:\n+    case Op_AddReductionVI:\n+    case Op_MulReductionVI:\n+    case Op_AndReductionV:\n+    case Op_OrReductionV:\n+    case Op_XorReductionV:\n+    case Op_MinReductionV:\n+    case Op_MaxReductionV:\n@@ -2448,0 +2460,16 @@\n+  \/\/ Special cases\n+  switch (opcode) {\n+    \/\/ Reductions only support INT at the moment.\n+    case Op_AddReductionVI:\n+    case Op_MulReductionVI:\n+    case Op_AndReductionV:\n+    case Op_OrReductionV:\n+    case Op_XorReductionV:\n+    case Op_MinReductionV:\n+    case Op_MaxReductionV:\n+      return bt == T_INT;\n+    \/\/ MaxV, MinV need types == INT || LONG.\n+    case Op_MaxV:\n+    case Op_MinV:\n+      return bt == T_INT || bt == T_LONG;\n+  }\n@@ -14253,0 +14281,107 @@\n+\/\/ Vector Min \/ Max Instructions\n+\n+instruct vmin_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (MinV src1 src2));\n+  format %{ \"VMIN  $dst,$src1,$src2\\t\/\/ vector min\" %}\n+  size(4);\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    switch (bt) {\n+      case T_INT:\n+        __ vminsw($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+        break;\n+      case T_LONG:\n+        __ vminsd($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vmax_reg(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (MaxV src1 src2));\n+  format %{ \"VMAX  $dst,$src1,$src2\\t\/\/ vector max\" %}\n+  size(4);\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    switch (bt) {\n+      case T_INT:\n+        __ vmaxsw($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+        break;\n+      case T_LONG:\n+        __ vmaxsd($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vand(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (AndV src1 src2));\n+  size(4);\n+  format %{ \"VAND   $dst,$src1,$src2\\t\/\/ and vectors\" %}\n+  ins_encode %{\n+    __ vand($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vor(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (OrV src1 src2));\n+  size(4);\n+  format %{ \"VOR   $dst,$src1,$src2\\t\/\/ or vectors\" %}\n+  ins_encode %{\n+    __ vor($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vxor(vecX dst, vecX src1, vecX src2) %{\n+  match(Set dst (XorV src1 src2));\n+  size(4);\n+  format %{ \"VXOR   $dst,$src1,$src2\\t\/\/ xor vectors\" %}\n+  ins_encode %{\n+    __ vxor($dst$$VectorSRegister->to_vr(), $src1$$VectorSRegister->to_vr(), $src2$$VectorSRegister->to_vr());\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct reductionI_arith_logic(iRegIdst dst, iRegIsrc srcInt, vecX srcVec, vecX tmp1, vecX tmp2) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_INT);\n+  match(Set dst (AddReductionVI srcInt srcVec));\n+  match(Set dst (MulReductionVI srcInt srcVec));\n+  match(Set dst (AndReductionV  srcInt srcVec));\n+  match(Set dst ( OrReductionV  srcInt srcVec));\n+  match(Set dst (XorReductionV  srcInt srcVec));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+  ins_cost(DEFAULT_COST * 6);\n+  format %{ \"REDUCEI_ARITH_LOGIC \/\/ $dst,$srcInt,$srcVec,$tmp1,$tmp2\\t\/\/ reduce vector int add\/mul\/and\/or\/xor\" %}\n+  size(24);\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    __ reduceI(opcode, $dst$$Register, $srcInt$$Register, $srcVec$$VectorSRegister->to_vr(),\n+        $tmp1$$VectorSRegister->to_vr(), $tmp2$$VectorSRegister->to_vr());\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct reductionI_min_max(iRegIdst dst, iRegIsrc srcInt, vecX srcVec, vecX tmp1, vecX tmp2, flagsRegCR0 cr0) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_INT);\n+  match(Set dst (MinReductionV srcInt srcVec));\n+  match(Set dst (MaxReductionV srcInt srcVec));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, KILL cr0);\n+  ins_cost(DEFAULT_COST * 7);\n+  format %{ \"REDUCEI_MINMAX \/\/ $dst,$srcInt,$srcVec,$tmp1,$tmp2,cr0\\t\/\/ reduce vector int min\/max\" %}\n+  size(28);\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    __ reduceI(opcode, $dst$$Register, $srcInt$$Register, $srcVec$$VectorSRegister->to_vr(),\n+        $tmp1$$VectorSRegister->to_vr(), $tmp2$$VectorSRegister->to_vr());\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":135,"deletions":0,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -99,0 +99,2 @@\n+    @IR(applyIfPlatform = {\"ppc\", \"true\"},\n+        counts = {IRNode.MIN_REDUCTION_V, \" > 0\"})\n@@ -113,0 +115,2 @@\n+    @IR(applyIfPlatform = {\"ppc\", \"true\"},\n+        counts = {IRNode.MAX_REDUCTION_V, \" > 0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/MinMaxRed_Int.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}