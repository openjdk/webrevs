{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import java.io.ByteArrayInputStream;\n@@ -31,1 +30,0 @@\n-import java.io.InputStreamReader;\n@@ -33,0 +31,1 @@\n+import java.io.StringReader;\n@@ -34,0 +33,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -46,1 +46,1 @@\n-import jdk.jpackage.internal.util.CommandOutputControl.ProcessSpec;\n+import jdk.jpackage.internal.util.CommandOutputControl.ProcessAttributes;\n@@ -214,3 +214,1 @@\n-        \/\/ Capture interleaved STDOUT & STDERR streams\n-        final ByteArrayOutputStream sink;\n-\n+        PrintableOutputBuilder printableOutputBuilder;\n@@ -218,5 +216,1 @@\n-            sink = new ByteArrayOutputStream();\n-            \/\/ Dump into the sink.\n-            var ps = new PrintStream(sink, false, coc.charset());\n-            \/\/ Redirect stderr in stdout.\n-            coc.dumpOutput(true).dumpStdout(ps).dumpStderr(ps);\n+            printableOutputBuilder = new PrintableOutputBuilder(coc);\n@@ -224,1 +218,1 @@\n-            sink = null;\n+            printableOutputBuilder = null;\n@@ -243,1 +237,1 @@\n-            log(result, sink, coc.charset());\n+            log(result, printableOutputBuilder.create());\n@@ -302,1 +296,1 @@\n-    private static void log(Result result, ByteArrayOutputStream outputSink, Charset outputSinkCharset) throws IOException {\n+    private static void log(Result result, String printableOutput) throws IOException {\n@@ -304,2 +298,1 @@\n-        Objects.requireNonNull(outputSink);\n-        Objects.requireNonNull(outputSinkCharset);\n+        Objects.requireNonNull(printableOutput);\n@@ -308,2 +301,2 @@\n-        if (result.execSpec() instanceof ProcessSpec spec) {\n-            pid = spec.pid();\n+        if (result.execAttrs() instanceof ProcessAttributes attrs) {\n+            pid = attrs.pid();\n@@ -319,1 +312,1 @@\n-        sb.append(\":\\n    \").append(result.execSpec());\n+        sb.append(\":\\n    \").append(result.execAttrs());\n@@ -322,2 +315,1 @@\n-        var lines = toStringList(outputSink.toByteArray(), outputSinkCharset);\n-        if (!lines.isEmpty()) {\n+        if (!printableOutput.isEmpty()) {\n@@ -326,2 +318,4 @@\n-            for (String s : lines) {\n-                sb.append(\"\\n    \").append(s);\n+            try (var lines = new BufferedReader(new StringReader(printableOutput)).lines()) {\n+                lines.forEach(line -> {\n+                    sb.append(\"\\n    \").append(line);\n+                });\n@@ -339,3 +333,19 @@\n-    private static List<String> toStringList(byte[] data, Charset charset) throws IOException {\n-        try (var bufReader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(data), charset))) {\n-            return bufReader.lines().toList();\n+    private static final class PrintableOutputBuilder {\n+\n+        PrintableOutputBuilder(CommandOutputControl coc) {\n+            coc.dumpOutput(true);\n+            charset = coc.charset();\n+            if (coc.isBinaryOutput()) {\n+                \/\/ Assume binary output goes into stdout and text error messages go into stderr, so keep them separated.\n+                sinks = new ByteArrayOutputStream[2];\n+                sinks[0] = new ByteArrayOutputStream();\n+                sinks[1] = new ByteArrayOutputStream();\n+                coc.dumpStdout(new PrintStream(sinks[0], false, charset))\n+                    .dumpStderr(new PrintStream(sinks[1], false, charset));\n+            } else {\n+                sinks = new ByteArrayOutputStream[1];\n+                sinks[0] = new ByteArrayOutputStream();\n+                var ps = new PrintStream(sinks[0], false, charset);\n+                \/\/ Redirect stderr in stdout.\n+                coc.dumpStdout(ps).dumpStderr(ps);\n+            }\n@@ -343,0 +353,23 @@\n+\n+        String create() {\n+            if (isBinaryOutput()) {\n+                \/\/ In case of binary output:\n+                \/\/  - Convert binary stdout to text using ISO-8859-1 encoding and\n+                \/\/    replace non-printable characters with the question mark symbol (?).\n+                \/\/  - Convert binary stderr to text using designated encoding (assume stderr is always a character stream).\n+                \/\/  - Merge text stdout and stderr into a single string;\n+                \/\/    stderr first, stdout follows, with the aim to present user error messages first.\n+                var sb = new StringBuilder();\n+                var stdout = sinks[0].toString(StandardCharsets.ISO_8859_1).replaceAll(\"[^\\\\p{Print}\\\\p{Space}]\", \"?\");\n+                return sb.append(sinks[1].toString(charset)).append(stdout).toString();\n+            } else {\n+                return sinks[0].toString(charset);\n+            }\n+        }\n+\n+        private boolean isBinaryOutput() {\n+            return sinks.length == 2;\n+        }\n+\n+        private final ByteArrayOutputStream sinks[];\n+        private final Charset charset;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Executor.java","additions":59,"deletions":26,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -7,1 +7,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n@@ -795,1 +797,2 @@\n-    public interface ExecutableSpec {\n+    public interface ExecutableAttributes {\n+        List<String> commandLine();\n@@ -800,1 +803,1 @@\n-        ExecutableSpec spec();\n+        ExecutableAttributes attributes();\n@@ -807,2 +810,2 @@\n-    public record ProcessSpec(Optional<Long> pid, List<String> cmdline) implements ExecutableSpec {\n-        public ProcessSpec {\n+    public record ProcessAttributes(Optional<Long> pid, List<String> commandLine) implements ExecutableAttributes {\n+        public ProcessAttributes {\n@@ -810,1 +813,1 @@\n-            cmdline.forEach(Objects::requireNonNull);\n+            commandLine.forEach(Objects::requireNonNull);\n@@ -815,1 +818,1 @@\n-            return CommandLineFormat.DEFAULT.apply(cmdline);\n+            return CommandLineFormat.DEFAULT.apply(commandLine());\n@@ -819,2 +822,2 @@\n-    public record ToolProviderSpec(String name, List<String> args) implements ExecutableSpec {\n-        public ToolProviderSpec {\n+    public record ToolProviderAttributes(String name, List<String> args) implements ExecutableAttributes {\n+        public ToolProviderAttributes {\n@@ -827,1 +830,6 @@\n-            return CommandLineFormat.DEFAULT.apply(Stream.concat(Stream.of(name), args.stream()).toList());\n+            return CommandLineFormat.DEFAULT.apply(commandLine());\n+        }\n+\n+        @Override\n+        public List<String> commandLine() {\n+            return Stream.concat(Stream.of(name), args.stream()).toList();\n@@ -831,1 +839,1 @@\n-    public static ExecutableSpec EMPTY_EXECUTABLE_SPEC = new ExecutableSpec() {\n+    public static ExecutableAttributes EMPTY_EXECUTABLE_ATTRIBUTES = new ExecutableAttributes() {\n@@ -836,0 +844,5 @@\n+\n+        @Override\n+        public List<String> commandLine() {\n+            return List.of();\n+        }\n@@ -850,1 +863,1 @@\n-            ExecutableSpec execSpec) {\n+            ExecutableAttributes execAttrs) {\n@@ -856,1 +869,1 @@\n-            Objects.requireNonNull(execSpec);\n+            Objects.requireNonNull(execAttrs);\n@@ -860,1 +873,1 @@\n-            this(Optional.of(exitCode), Optional.empty(), Optional.empty(), EMPTY_EXECUTABLE_SPEC);\n+            this(Optional.of(exitCode), Optional.empty(), Optional.empty(), EMPTY_EXECUTABLE_ATTRIBUTES);\n@@ -982,1 +995,1 @@\n-                return new Result(exitCode, Optional.of(newOutput), byteOutput.filter(_ -> keepByteContent), execSpec);\n+                return new Result(exitCode, Optional.of(newOutput), byteOutput.filter(_ -> keepByteContent), execAttrs);\n@@ -988,2 +1001,2 @@\n-        public Result copyWithExecutableSpec(ExecutableSpec execSpec) {\n-            return new Result(exitCode, output, byteOutput, Objects.requireNonNull(execSpec));\n+        public Result copyWithExecutableAttributes(ExecutableAttributes execAttrs) {\n+            return new Result(exitCode, output, byteOutput, Objects.requireNonNull(execAttrs));\n@@ -1009,1 +1022,1 @@\n-            this(value, String.format(\"Unexpected result from executing the command %s\", value.execSpec()));\n+            this(value, String.format(\"Unexpected result from executing the command %s\", value.execAttrs()));\n@@ -1028,1 +1041,1 @@\n-            this(value, String.format(\"Unexpected exit code %d from executing the command %s\", value.getExitCode(), value.execSpec()));\n+            this(value, String.format(\"Unexpected exit code %d from executing the command %s\", value.getExitCode(), value.execAttrs()));\n@@ -1156,1 +1169,1 @@\n-        return csc.createResult(exitCode, new ProcessSpec(getPID(process), pb.command()));\n+        return csc.createResult(exitCode, new ProcessAttributes(getPID(process), pb.command()));\n@@ -1200,1 +1213,1 @@\n-        return csc.createResult(exitCode, new ToolProviderSpec(tp.name(), List.of(args)));\n+        return csc.createResult(exitCode, new ToolProviderAttributes(tp.name(), List.of(args)));\n@@ -1561,1 +1574,1 @@\n-        Result createResult(Optional<Integer> exitCode, ExecutableSpec execSpec) throws IOException {\n+        Result createResult(Optional<Integer> exitCode, ExecutableAttributes execAttrs) throws IOException {\n@@ -1599,1 +1612,1 @@\n-            return new Result(exitCode, Optional.ofNullable(output), Optional.ofNullable(byteOutput), execSpec);\n+            return new Result(exitCode, Optional.ofNullable(output), Optional.ofNullable(byteOutput), execAttrs);\n@@ -1794,2 +1807,2 @@\n-        public ExecutableSpec spec() {\n-            return new ToolProviderSpec(tp.name(), args);\n+        public ExecutableAttributes attributes() {\n+            return new ToolProviderAttributes(tp.name(), args);\n@@ -1817,2 +1830,2 @@\n-        public ExecutableSpec spec() {\n-            return new ProcessSpec(Optional.empty(), pb.command());\n+        public ExecutableAttributes attributes() {\n+            return new ProcessAttributes(Optional.empty(), pb.command());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/CommandOutputControl.java","additions":40,"deletions":27,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-        } catch (Error|RuntimeException t) {\n+        } catch (Error | RuntimeException t) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/RetryExecutor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-                            base.execSpec(), expectedExitCode));\n+                            base.execAttrs(), expectedExitCode));\n@@ -288,1 +288,1 @@\n-                            base.execSpec(), expectedExitCodes.stream().sorted().toList()));\n+                            base.execAttrs(), expectedExitCodes.stream().sorted().toList()));\n@@ -303,1 +303,1 @@\n-            return base.execSpec().toString();\n+            return base.execAttrs().toString();\n@@ -509,1 +509,2 @@\n-        return new Result(baseResult.copyWithExecutableSpec(new ExecutableSpec(getPrintableCommandLine())));\n+        return new Result(baseResult.copyWithExecutableAttributes(\n+                new ExecutableAttributes(baseResult.execAttrs(), getPrintableCommandLine())));\n@@ -530,3 +531,6 @@\n-    private record ExecutableSpec(String cmdline) implements CommandOutputControl.ExecutableSpec {\n-        ExecutableSpec {\n-            if (cmdline.isBlank()) {\n+    private record ExecutableAttributes(CommandOutputControl.ExecutableAttributes base, String toStringValue)\n+            implements CommandOutputControl.ExecutableAttributes {\n+\n+        ExecutableAttributes {\n+            Objects.requireNonNull(base);\n+            if (toStringValue.isBlank()) {\n@@ -539,1 +543,6 @@\n-            return cmdline;\n+            return toStringValue;\n+        }\n+\n+        @Override\n+        public List<String> commandLine() {\n+            return base.commandLine();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Executor.java","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import java.util.concurrent.CompletableFuture;\n@@ -783,4 +784,3 @@\n-     * Starts a new thread. In this thread calls\n-     * {@link #useToolProviderByDefault(ToolProvider)} with the specified\n-     * {@code jpackageToolProvider} and then calls {@code workload.run()}. Joins the\n-     * thread.\n+     * In a separate thread calls {@link #useToolProviderByDefault(ToolProvider)}\n+     * with the specified {@code jpackageToolProvider} and then calls\n+     * {@code workload.run()}. Joins the thread.\n@@ -797,2 +797,1 @@\n-    public static void withToolProvider(ToolProvider jpackageToolProvider, Runnable workload) {\n-        Objects.requireNonNull(jpackageToolProvider);\n+    public static void withToolProvider(Runnable workload, ToolProvider jpackageToolProvider) {\n@@ -800,1 +799,4 @@\n-        ThrowingRunnable.toRunnable(Thread.ofVirtual().start(() -> {\n+        Objects.requireNonNull(jpackageToolProvider);\n+\n+        CompletableFuture.runAsync(() -> {\n+            var oldValue = defaultToolProvider.get();\n@@ -802,2 +804,6 @@\n-            workload.run();\n-        })::join).run();\n+            try {\n+                workload.run();\n+            } finally {\n+                defaultToolProvider.set(oldValue);\n+            }\n+        }).join();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -23,1 +23,0 @@\n-\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/CommandMockExit.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -140,3 +140,1 @@\n-            ExecutorFactory executorFactory= MockUtils.withCommandMocks(script).apply(ExecutorFactory.DEFAULT);\n-\n-            Globals.instance().executorFactory(executorFactory);\n+            MockUtils.buildJPackage().script(script).applyToGlobals();\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/jdk.jpackage\/jdk\/jpackage\/internal\/LinuxPackageArchTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,3 +89,1 @@\n-                ExecutorFactory executorFactory = MockUtils.withCommandMocks(script).apply(ExecutorFactory.DEFAULT);\n-\n-                Globals.instance().executorFactory(executorFactory);\n+                MockUtils.buildJPackage().script(script).applyToGlobals();\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/jdk.jpackage\/jdk\/jpackage\/internal\/LinuxSystemEnvironmentTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -243,5 +243,2 @@\n-            ExecutorFactory commandMocksExecutorFactory = MockUtils.withCommandMocks(script).apply(ExecutorFactory.DEFAULT);\n-\n-            ExecutorFactory recordingExecutorFactory = MockUtils.withCommandListener(System.out::println).apply(commandMocksExecutorFactory);\n-\n-            var executorFactory = recordingExecutorFactory;\n+            ExecutorFactory executorFactory = MockUtils.buildJPackage()\n+                    .script(script).listener(System.out::println).createExecutorFactory();\n","filename":"test\/jdk\/tools\/jpackage\/junit\/macosx\/jdk.jpackage\/jdk\/jpackage\/internal\/MacDmgPackagerTest.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -145,2 +145,0 @@\n-            ExecutorFactory ef = MockUtils.withCommandMocks(script).apply(ExecutorFactory.DEFAULT);\n-\n@@ -148,1 +146,1 @@\n-                Globals.instance().executorFactory(ef);\n+                MockUtils.buildJPackage().script(script).applyToGlobals();\n","filename":"test\/jdk\/tools\/jpackage\/junit\/macosx\/jdk.jpackage\/jdk\/jpackage\/internal\/MacDmgSystemEnvironmentTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,6 +99,4 @@\n-        ExecutorFactory commandMocksExecutorFactory = MockUtils.withCommandMocks(script).apply(ExecutorFactory.DEFAULT);\n-\n-        ExecutorFactory recordingExecutorFactory = MockUtils.withCommandListener(executedCommands::add).apply(commandMocksExecutorFactory);\n-\n-        ToolProvider jpackage = MockUtils.createJPackageToolProvider(op.os(),\n-                ObjectFactory.build().executorFactory(recordingExecutorFactory).create());\n+        ToolProvider jpackage = MockUtils.buildJPackage()\n+                .os(op.os())\n+                .script(script)\n+                .listener(executedCommands::add).create();\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/DefaultBundlingEnvironmentTest.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-final class MockUtils {\n+public final class MockUtils {\n@@ -51,1 +51,78 @@\n-    static UnaryOperator<ExecutorFactory> withCommandListener(Consumer<List<String>> listener) {\n+    public static JPackageToolProviderBuilder buildJPackage() {\n+        return new JPackageToolProviderBuilder();\n+    }\n+\n+    public static final class JPackageToolProviderBuilder {\n+\n+        public ToolProvider create() {\n+            return createJPackageToolProvider(os(), createObjectFactory());\n+        }\n+\n+        public Consumer<Globals> createGlobalsMutator() {\n+            var objectFactory = createObjectFactory();\n+            return globals -> {\n+                globals.objectFactory(objectFactory);\n+            };\n+        }\n+\n+        public void applyToGlobals() {\n+            createGlobalsMutator().accept(Globals.instance());\n+        }\n+\n+        ExecutorFactory createExecutorFactory() {\n+            var commandMocksExecutorFactory = Optional.ofNullable(script).map(MockUtils::withCommandMocks).map(mapper -> {\n+                return mapper.apply(ExecutorFactory.DEFAULT);\n+            }).orElse(ExecutorFactory.DEFAULT);\n+\n+            var recordingExecutorFactory = Optional.ofNullable(listener).map(MockUtils::withCommandListener).map(mapper -> {\n+                return mapper.apply(commandMocksExecutorFactory);\n+            }).orElse(commandMocksExecutorFactory);\n+\n+            return recordingExecutorFactory;\n+        }\n+\n+        ObjectFactory createObjectFactory() {\n+            var executorFactory = createExecutorFactory();\n+            if (executorFactory == ExecutorFactory.DEFAULT) {\n+                return ObjectFactory.DEFAULT;\n+            } else {\n+                return ObjectFactory.build().executorFactory(executorFactory).create();\n+            }\n+        }\n+\n+        public JPackageToolProviderBuilder listener(Consumer<List<String>> v) {\n+            listener = v;\n+            return this;\n+        }\n+\n+        public JPackageToolProviderBuilder script(Script v) {\n+            script = v;\n+            return this;\n+        }\n+\n+        public JPackageToolProviderBuilder os(OperatingSystem v) {\n+            os = v;\n+            return this;\n+        }\n+\n+        private OperatingSystem os() {\n+            return Optional.ofNullable(os).orElseGet(OperatingSystem::current);\n+        }\n+\n+        private Consumer<List<String>> listener;\n+        private OperatingSystem os;\n+        private Script script;\n+    }\n+\n+    public static ToolProvider createJPackageToolProvider(OperatingSystem os, Script script) {\n+        return buildJPackage()\n+                .os(Objects.requireNonNull(os))\n+                .script(Objects.requireNonNull(script))\n+                .create();\n+    }\n+\n+    public static ToolProvider createJPackageToolProvider(Script script) {\n+        return createJPackageToolProvider(OperatingSystem.current(), script);\n+    }\n+\n+    private static UnaryOperator<ExecutorFactory> withCommandListener(Consumer<List<String>> listener) {\n@@ -70,1 +147,1 @@\n-    static UnaryOperator<ExecutorFactory> withCommandMocks(Script script) {\n+    private static UnaryOperator<ExecutorFactory> withCommandMocks(Script script) {\n@@ -91,5 +168,1 @@\n-                            if (exec.processBuilder().isPresent()) {\n-                                copy.args(commandLine.subList(1, commandLine.size()));\n-                            } else {\n-                                copy.args(commandLine);\n-                            }\n+                            copy.args(commandLine.subList(1, commandLine.size()));\n@@ -110,1 +183,1 @@\n-    static CliBundlingEnvironment createBundlingEnvironment(OperatingSystem os) {\n+    public static CliBundlingEnvironment createBundlingEnvironment(OperatingSystem os) {\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/MockUtils.java","additions":82,"deletions":9,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-                JPackageCommand.withToolProvider(jpackageToolProviderMock, () -> {\n+                JPackageCommand.withToolProvider(() -> {\n@@ -209,1 +209,1 @@\n-                });\n+                }, jpackageToolProviderMock);\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionsValidationFailTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,0 +103,13 @@\n+    \/**\n+     * Runs cherry-picked {@link OutputTestSpec} test cases.\n+     * <p>\n+     * This test method is mutual exclusive with\n+     * {@link #testSavedOutput(OutputTestSpec)} and is aimed for debugging\n+     * {@code OutputTestSpec} test cases.\n+     * <p>\n+     * It is disabled by default. To enable it, manually edit {@link #testSomeSavedOutput()}.\n+     *\n+     * @see #testSomeSavedOutput()\n+     *\n+     * @param spec the test case\n+     *\/\n@@ -129,1 +142,0 @@\n-\/\/        System.out.println(desc);\n@@ -172,1 +184,1 @@\n-    public void test_ExecutableSpec(boolean toolProvider) {\n+    public void test_ExecutableAttributes(boolean toolProvider) {\n@@ -194,1 +206,1 @@\n-        assertEquals(\"runme --foo --baz=10\", exec.spec().toString());\n+        assertEquals(\"runme --foo --baz=10\", exec.attributes().toString());\n@@ -204,1 +216,1 @@\n-        assertSame(Objects.requireNonNull(CommandOutputControl.EMPTY_EXECUTABLE_SPEC), result.execSpec());\n+        assertSame(Objects.requireNonNull(CommandOutputControl.EMPTY_EXECUTABLE_ATTRIBUTES), result.execAttrs());\n@@ -262,1 +274,1 @@\n-    public void test_Result_toCharacterResult_copyWithExecutableSpec() {\n+    public void test_Result_toCharacterResult_copyWithExecutableAttributes() {\n@@ -266,1 +278,1 @@\n-        var execSpec = new CommandOutputControl.ExecutableSpec() {\n+        var execAttrs = new CommandOutputControl.ExecutableAttributes() {\n@@ -271,0 +283,5 @@\n+\n+            @Override\n+            public List<String> commandLine() {\n+                return List.of();\n+            }\n@@ -273,1 +290,1 @@\n-        var copy = empty.copyWithExecutableSpec(execSpec);\n+        var copy = empty.copyWithExecutableAttributes(execAttrs);\n@@ -278,1 +295,1 @@\n-        assertSame(execSpec, copy.execSpec());\n+        assertSame(execAttrs, copy.execAttrs());\n@@ -664,1 +681,1 @@\n-            assertSame(byteResult.execSpec(), actual.execSpec());\n+            assertSame(byteResult.execAttrs(), actual.execAttrs());\n@@ -696,0 +713,20 @@\n+    \/**\n+     * Returns test cases for {@link #testSomeSavedOutput(OutputTestSpec)}.\n+     * <p>\n+     * Aimed to simplify debugging of {@link #OutputTestSpec} test cases.\n+     * <p>\n+     * The total number of {@code #OutputTestSpec} test cases is ~1500. When some\n+     * fail and need debugging, it is a waste of time to run them all. This method\n+     * allows running only selected test cases. It works this way:\n+     * <ul>\n+     * <li>Run CommandOutputControlTest test.\n+     * <li>If some {@linke #testSavedOutput(OutputTestSpec)} invocations fail,\n+     * capture their IDs (test case ID is an index starting from 1).\n+     * <li>Replace \"\/* 10, 67, 456 *&#47;\" comment in the body of this method with\n+     * the captured test case IDs.\n+     * <li>Rerun CommandOutputControlTest test. This time, it will run\n+     * {@link #testSomeSavedOutput(OutputTestSpec)} method instead of\n+     * {@link #testSavedOutput(OutputTestSpec)} with the list of the captured test\n+     * case IDs.\n+     * <\/ul>\n+     *\/\n@@ -1003,1 +1040,1 @@\n-                                \/\/ Not used, no pint to implement.\n+                                \/\/ Not used, no point to implement.\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/CommandOutputControlTest.java","additions":47,"deletions":10,"binary":false,"changes":57,"status":"modified"}]}