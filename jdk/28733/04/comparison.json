{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+import jdk.jpackage.internal.util.Enquoter;\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/DesktopIntegration.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.util.List;\n@@ -32,1 +31,0 @@\n-import java.util.Objects;\n@@ -34,2 +32,0 @@\n-import java.util.Set;\n-import java.util.ArrayList;\n@@ -37,0 +33,3 @@\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n@@ -51,3 +50,0 @@\n-    public LibProvidersLookup() {\n-    }\n-\n@@ -90,10 +86,1 @@\n-        List<Path> result = new ArrayList<>();\n-        int ret = Executor.of(TOOL_LDD, path.toString()).setOutputConsumer(lines -> {\n-            lines.map(line -> {\n-                Matcher matcher = LIB_IN_LDD_OUTPUT_REGEX.matcher(line);\n-                if (matcher.find()) {\n-                    return matcher.group(1);\n-                }\n-                return null;\n-            }).filter(Objects::nonNull).map(Path::of).forEach(result::add);\n-        }).execute();\n+        final var result = Executor.of(TOOL_LDD, path.toString()).saveOutput().execute();\n@@ -101,1 +88,1 @@\n-        if (ret != 0) {\n+        if (result.getExitCode() != 0) {\n@@ -106,1 +93,7 @@\n-        return result;\n+        return result.stdout().stream().map(line -> {\n+            Matcher matcher = LIB_IN_LDD_OUTPUT_REGEX.matcher(line);\n+            if (matcher.find()) {\n+                return matcher.group(1);\n+            }\n+            return null;\n+        }).filter(Objects::nonNull).map(Path::of).toList();\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LibProvidersLookup.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.function.Supplier;\n@@ -47,7 +48,22 @@\n-        super(build()\n-                .defaultOperation(() -> {\n-                    return LazyLoad.SYS_ENV.value().map(LinuxSystemEnvironment::nativePackageType).map(DESCRIPTORS::get);\n-                })\n-                .bundler(CREATE_LINUX_APP_IMAGE, LinuxBundlingEnvironment::createAppImage)\n-                .bundler(CREATE_LINUX_DEB, LazyLoad::debSysEnv, LinuxBundlingEnvironment::createDebPackage)\n-                .bundler(CREATE_LINUX_RPM, LazyLoad::rpmSysEnv, LinuxBundlingEnvironment::createRpmPackage));\n+        super(build().mutate(builder -> {\n+\n+            \/\/ Wrap the generic Linux system environment supplier in the run-once wrapper\n+            \/\/ as this supplier is called from both RPM and DEB Linux system environment suppliers.\n+            var sysEnv = runOnce(() -> {\n+                return LinuxSystemEnvironment.create();\n+            });\n+\n+            Supplier<Result<LinuxDebSystemEnvironment>> debSysEnv = () -> {\n+                return LinuxDebSystemEnvironment.create(sysEnv.get());\n+            };\n+\n+            Supplier<Result<LinuxRpmSystemEnvironment>> rpmSysEnv = () -> {\n+                return LinuxRpmSystemEnvironment.create(sysEnv.get());\n+            };\n+\n+            builder.defaultOperation(() -> {\n+                return sysEnv.get().value().map(LinuxSystemEnvironment::nativePackageType).map(DESCRIPTORS::get);\n+            })\n+            .bundler(CREATE_LINUX_DEB, debSysEnv, LinuxBundlingEnvironment::createDebPackage)\n+            .bundler(CREATE_LINUX_RPM, rpmSysEnv, LinuxBundlingEnvironment::createRpmPackage);\n+        }).bundler(CREATE_LINUX_APP_IMAGE, LinuxBundlingEnvironment::createAppImage));\n@@ -59,1 +75,1 @@\n-                LinuxFromOptions.createLinuxDebPackage(options),\n+                LinuxFromOptions.createLinuxDebPackage(options, sysEnv),\n@@ -70,1 +86,1 @@\n-                LinuxFromOptions.createLinuxRpmPackage(options),\n+                LinuxFromOptions.createLinuxRpmPackage(options, sysEnv),\n@@ -93,17 +109,0 @@\n-    private static final class LazyLoad {\n-\n-        static Result<LinuxDebSystemEnvironment> debSysEnv() {\n-            return DEB_SYS_ENV;\n-        }\n-\n-        static Result<LinuxRpmSystemEnvironment> rpmSysEnv() {\n-            return RPM_SYS_ENV;\n-        }\n-\n-        private static final Result<LinuxSystemEnvironment> SYS_ENV = LinuxSystemEnvironment.create();\n-\n-        private static final Result<LinuxDebSystemEnvironment> DEB_SYS_ENV = LinuxDebSystemEnvironment.create(SYS_ENV);\n-\n-        private static final Result<LinuxRpmSystemEnvironment> RPM_SYS_ENV = LinuxRpmSystemEnvironment.create(SYS_ENV);\n-    }\n-\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxBundlingEnvironment.java","additions":26,"deletions":27,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import static jdk.jpackage.internal.model.StandardPackageType.LINUX_DEB;\n@@ -79,1 +78,1 @@\n-                return findProvidingPackages(realPath, sysEnv.dpkg());\n+                return findProvidingPackages(realPath, sysEnv);\n@@ -83,1 +82,1 @@\n-                    return findProvidingPackages(file, sysEnv.dpkg());\n+                    return findProvidingPackages(file, sysEnv);\n@@ -110,1 +109,1 @@\n-        Map<String, String> actualValues = Executor.of(cmdline.toArray(String[]::new))\n+        Map<String, String> actualValues = Executor.of(cmdline)\n@@ -161,3 +160,2 @@\n-        RetryExecutor.retryOnKnownErrorMessage(\n-                \"semop(1): encountered an error: Invalid argument\").execute(\n-                        cmdline.toArray(String[]::new));\n+        Executor.of(cmdline).retryOnKnownErrorMessage(\n+                \"semop(1): encountered an error: Invalid argument\").execute();\n@@ -236,1 +234,1 @@\n-    private static Stream<String> findProvidingPackages(Path file, Path dpkg) throws IOException {\n+    private static Stream<String> findProvidingPackages(Path file, LinuxDebSystemEnvironment sysEnv) throws IOException {\n@@ -282,1 +280,1 @@\n-        var debArch = LinuxPackageArch.getValue(LINUX_DEB);\n+        var debArch = sysEnv.packageArch().value();\n@@ -284,1 +282,1 @@\n-        Executor.of(dpkg.toString(), \"-S\", file.toString())\n+        Executor.of(sysEnv.dpkg().toString(), \"-S\", file.toString())\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebPackager.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-public interface LinuxDebSystemEnvironment extends LinuxSystemEnvironment, LinuxDebSystemEnvironmentMixin {\n+interface LinuxDebSystemEnvironment extends LinuxSystemEnvironment, LinuxDebSystemEnvironmentMixin {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebSystemEnvironment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-public interface LinuxDebSystemEnvironmentMixin {\n+interface LinuxDebSystemEnvironmentMixin {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebSystemEnvironmentMixin.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-    static LinuxRpmPackage createLinuxRpmPackage(Options options) {\n+    static LinuxRpmPackage createLinuxRpmPackage(Options options, LinuxRpmSystemEnvironment sysEnv) {\n@@ -75,1 +75,1 @@\n-        final var superPkgBuilder = createLinuxPackageBuilder(options, LINUX_RPM);\n+        final var superPkgBuilder = createLinuxPackageBuilder(options, sysEnv, LINUX_RPM);\n@@ -84,1 +84,1 @@\n-    static LinuxDebPackage createLinuxDebPackage(Options options) {\n+    static LinuxDebPackage createLinuxDebPackage(Options options, LinuxDebSystemEnvironment sysEnv) {\n@@ -86,1 +86,1 @@\n-        final var superPkgBuilder = createLinuxPackageBuilder(options, LINUX_DEB);\n+        final var superPkgBuilder = createLinuxPackageBuilder(options, sysEnv, LINUX_DEB);\n@@ -102,1 +102,1 @@\n-    private static LinuxPackageBuilder createLinuxPackageBuilder(Options options, StandardPackageType type) {\n+    private static LinuxPackageBuilder createLinuxPackageBuilder(Options options, LinuxSystemEnvironment sysEnv, StandardPackageType type) {\n@@ -110,0 +110,2 @@\n+        pkgBuilder.arch(sysEnv.packageArch());\n+\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxFromOptions.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import jdk.jpackage.internal.util.Enquoter;\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxLaunchersAsServices.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+import java.util.ArrayList;\n@@ -30,0 +30,2 @@\n+import jdk.jpackage.internal.util.CommandOutputControl;\n+import jdk.jpackage.internal.util.Result;\n@@ -31,1 +33,1 @@\n-final class LinuxPackageArch {\n+record LinuxPackageArch(String value) {\n@@ -33,1 +35,1 @@\n-    static String getValue(StandardPackageType pkgType) {\n+    static Result<LinuxPackageArch> create(StandardPackageType pkgType) {\n@@ -36,1 +38,1 @@\n-                return RpmPackageArch.VALUE;\n+                return rpm().map(LinuxPackageArch::new);\n@@ -39,1 +41,1 @@\n-                return DebPackageArch.VALUE;\n+                return deb().map(LinuxPackageArch::new);\n@@ -47,8 +49,4 @@\n-    private static class DebPackageArch {\n-\n-        static final String VALUE = toSupplier(DebPackageArch::getValue).get();\n-\n-        private static String getValue() throws IOException {\n-            return Executor.of(\"dpkg\", \"--print-architecture\").saveOutput(true)\n-                    .executeExpectSuccess().getOutput().get(0);\n-        }\n+    private static Result<String> deb() {\n+        var exec = Executor.of(\"dpkg\", \"--print-architecture\").saveOutput(true);\n+        return Result.of(exec::executeExpectSuccess, IOException.class)\n+                .flatMap(LinuxPackageArch::getStdoutFirstLine);\n@@ -57,1 +55,10 @@\n-    private static class RpmPackageArch {\n+    private static Result<String> rpm() {\n+        var errors = new ArrayList<Exception>();\n+        for (var tool : RpmArchReader.values()) {\n+            var result = tool.getRpmArch();\n+            if (result.hasValue()) {\n+                return result;\n+            } else {\n+                errors.addAll(result.errors());\n+            }\n+        }\n@@ -59,8 +66,2 @@\n-        \/*\n-         * Various ways to get rpm arch. Needed to address JDK-8233143. rpmbuild is mandatory for\n-         * rpm packaging, try it first. rpm is optional and may not be available, use as the last\n-         * resort.\n-         *\/\n-        private static enum RpmArchReader {\n-            Rpmbuild(\"rpmbuild\", \"--eval=%{_target_cpu}\"),\n-            Rpm(\"rpm\", \"--eval=%{_target_cpu}\");\n+        return Result.ofErrors(errors);\n+    }\n@@ -68,3 +69,8 @@\n-            RpmArchReader(String... cmdline) {\n-                this.cmdline = cmdline;\n-            }\n+    \/*\n+     * Various ways to get rpm arch. Needed to address JDK-8233143. rpmbuild is mandatory for\n+     * rpm packaging, try it first. rpm is optional and may not be available, use as the last\n+     * resort.\n+     *\/\n+    private enum RpmArchReader {\n+        RPMBUILD(\"rpmbuild\", \"--eval=%{_target_cpu}\"),\n+        RPM(\"rpm\", \"--eval=%{_target_cpu}\");\n@@ -72,17 +78,3 @@\n-            String getRpmArch() throws IOException {\n-                Executor exec = Executor.of(cmdline).saveOutput(true);\n-                switch (this) {\n-                    case Rpm -> {\n-                        exec.executeExpectSuccess();\n-                    }\n-                    case Rpmbuild -> {\n-                        if (exec.execute() != 0) {\n-                            return null;\n-                        }\n-                    }\n-                    default -> {\n-                        throw new UnsupportedOperationException();\n-                    }\n-                }\n-                return exec.getOutput().get(0);\n-            }\n+        RpmArchReader(String... cmdline) {\n+            this.cmdline = cmdline;\n+        }\n@@ -90,1 +82,4 @@\n-            private final String[] cmdline;\n+        Result<String> getRpmArch() {\n+            var exec = Executor.of(cmdline).saveOutput(true);\n+            return Result.of(exec::executeExpectSuccess, IOException.class)\n+                    .flatMap(LinuxPackageArch::getStdoutFirstLine);\n@@ -93,1 +88,2 @@\n-        static final String VALUE = toSupplier(RpmPackageArch::getValue).get();\n+        private final String[] cmdline;\n+    }\n@@ -95,9 +91,4 @@\n-        private static String getValue() throws IOException {\n-            for (var rpmArchReader : RpmArchReader.values()) {\n-                var rpmArchStr = rpmArchReader.getRpmArch();\n-                if (rpmArchStr != null) {\n-                    return rpmArchStr;\n-                }\n-            }\n-            throw new RuntimeException(\"error.rpm-arch-not-detected\");\n-        }\n+    private static Result<String> getStdoutFirstLine(CommandOutputControl.Result result) {\n+        return Result.of(() -> {\n+            return result.stdout().stream().findFirst().orElseThrow(result::unexpected);\n+        }, IOException.class);\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageArch.java","additions":45,"deletions":54,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-                pkg.asStandardPackageType().map(LinuxPackageArch::getValue).orElseThrow()));\n+                arch.value()));\n@@ -122,0 +122,5 @@\n+    LinuxPackageBuilder arch(LinuxPackageArch v) {\n+        arch = v;\n+        return this;\n+    }\n+\n@@ -187,0 +192,1 @@\n+    private LinuxPackageArch arch;\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageBuilder.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-public interface LinuxRpmSystemEnvironment extends LinuxSystemEnvironment, LinuxRpmSystemEnvironmentMixin {\n+interface LinuxRpmSystemEnvironment extends LinuxSystemEnvironment, LinuxRpmSystemEnvironmentMixin {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmSystemEnvironment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-public interface LinuxRpmSystemEnvironmentMixin {\n+interface LinuxRpmSystemEnvironmentMixin {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmSystemEnvironmentMixin.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.util.Objects;\n@@ -38,1 +37,1 @@\n-public interface LinuxSystemEnvironment extends SystemEnvironment {\n+interface LinuxSystemEnvironment extends SystemEnvironment {\n@@ -41,0 +40,1 @@\n+    LinuxPackageArch packageArch();\n@@ -48,1 +48,1 @@\n-    static Optional<PackageType> detectNativePackageType() {\n+    static Optional<StandardPackageType> detectNativePackageType() {\n@@ -58,3 +58,4 @@\n-    static Result<LinuxSystemEnvironment> create(PackageType nativePackageType) {\n-        return Result.ofValue(new Stub(LibProvidersLookup.supported(),\n-                Objects.requireNonNull(nativePackageType)));\n+    static Result<LinuxSystemEnvironment> create(StandardPackageType nativePackageType) {\n+        return LinuxPackageArch.create(nativePackageType).map(arch -> {\n+            return new Stub(LibProvidersLookup.supported(), nativePackageType, arch);\n+        });\n@@ -64,1 +65,1 @@\n-        return CompositeProxy.create(type, base, mixin);\n+        return CompositeProxy.build().invokeTunnel(CompositeProxyTunnel.INSTANCE).create(type, base, mixin);\n@@ -82,1 +83,1 @@\n-    record Stub(boolean soLookupAvailable, PackageType nativePackageType) implements LinuxSystemEnvironment {\n+    record Stub(boolean soLookupAvailable, PackageType nativePackageType, LinuxPackageArch packageArch) implements LinuxSystemEnvironment {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxSystemEnvironment.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import jdk.jpackage.internal.util.Result;\n@@ -191,5 +192,3 @@\n-        try {\n-            return Executor.of(\"\/usr\/bin\/xcrun\", \"--help\").setQuiet(true).execute() == 0;\n-        } catch (IOException ex) {\n-            return false;\n-        }\n+        return Result.of(\n+                Executor.of(\"\/usr\/bin\/xcrun\", \"--help\").setQuiet(true)::executeExpectSuccess,\n+                IOException.class).hasValue();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageSigner.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import java.util.stream.Stream;\n@@ -97,4 +96,1 @@\n-        var exec = Executor.of(Stream.concat(\n-                cmdline.stream(),\n-                Stream.of(path.toString())).toArray(String[]::new)\n-        ).saveOutput(true);\n+        var exec = Executor.of(cmdline).args(path.toString()).saveOutput(true);\n@@ -103,2 +99,3 @@\n-        if (exec.execute() != 0) {\n-            throw new CodesignException(exec.getOutput().toArray(String[]::new));\n+        var result = exec.execute();\n+        if (result.getExitCode() != 0) {\n+            throw new CodesignException(result.getOutput().toArray(String[]::new));\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/Codesign.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import jdk.jpackage.internal.util.Result;\n@@ -48,1 +47,1 @@\n-                .bundler(CREATE_MAC_DMG, LazyLoad::dmgSysEnv, MacBundlingEnvironment::createDmdPackage)\n+                .bundler(CREATE_MAC_DMG, MacDmgSystemEnvironment::create, MacBundlingEnvironment::createDmdPackage)\n@@ -101,9 +100,0 @@\n-\n-    private static final class LazyLoad {\n-\n-        static Result<MacDmgSystemEnvironment> dmgSysEnv() {\n-            return DMG_SYS_ENV;\n-        }\n-\n-        private static final Result<MacDmgSystemEnvironment> DMG_SYS_ENV = MacDmgSystemEnvironment.create();\n-    }\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBundlingEnvironment.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-            final var output = Executor.of(args.toArray(String[]::new))\n+            final var output = Executor.of(args)\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacCertificateUtils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.ArrayList;\n@@ -38,0 +39,1 @@\n+import java.util.List;\n@@ -40,0 +42,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -41,0 +44,1 @@\n+import java.util.function.Function;\n@@ -108,0 +112,4 @@\n+    private Path finalDmg() {\n+        return outputDir.resolve(pkg.packageFileNameWithSuffix());\n+    }\n+\n@@ -131,0 +139,4 @@\n+    private Executor hdiutil(String... args) {\n+        return Executor.of(sysEnv.hdiutil().toString()).args(args).storeOutputInFiles();\n+    }\n+\n@@ -214,0 +226,4 @@\n+    private String hdiUtilVerbosityFlag() {\n+        return env.verbose() ? \"-verbose\" : \"-quiet\";\n+    }\n+\n@@ -217,2 +233,2 @@\n-        Path protoDMG = protoDmg();\n-        Path finalDMG = outputDir.resolve(pkg.packageFileNameWithSuffix());\n+        final Path protoDMG = protoDmg();\n+        final Path finalDMG = finalDmg();\n@@ -220,1 +236,1 @@\n-        Path srcFolder = env.appImageDir();\n+        final Path srcFolder = env.appImageDir();\n@@ -236,2 +252,1 @@\n-        String hdiUtilVerbosityFlag = env.verbose() ?\n-                \"-verbose\" : \"-quiet\";\n+        final String hdiUtilVerbosityFlag = hdiUtilVerbosityFlag();\n@@ -240,9 +255,0 @@\n-        ProcessBuilder pb = new ProcessBuilder(\n-                sysEnv.hdiutil().toString(),\n-                \"create\",\n-                hdiUtilVerbosityFlag,\n-                \"-srcfolder\", normalizedAbsolutePathString(srcFolder),\n-                \"-volname\", volumeName(),\n-                \"-ov\", normalizedAbsolutePathString(protoDMG),\n-                \"-fs\", \"HFS+\",\n-                \"-format\", \"UDRW\");\n@@ -250,1 +256,7 @@\n-            IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n+            hdiutil(\"create\",\n+                    hdiUtilVerbosityFlag,\n+                    \"-srcfolder\", normalizedAbsolutePathString(srcFolder),\n+                    \"-volname\", volumeName(),\n+                    \"-ov\", normalizedAbsolutePathString(protoDMG),\n+                    \"-fs\", \"HFS+\",\n+                    \"-format\", \"UDRW\").executeExpectSuccess();\n@@ -263,13 +275,11 @@\n-            pb = new ProcessBuilder(\n-                sysEnv.hdiutil().toString(),\n-                \"create\",\n-                hdiUtilVerbosityFlag,\n-                \"-size\", String.valueOf(size),\n-                \"-volname\", volumeName(),\n-                \"-ov\", normalizedAbsolutePathString(protoDMG),\n-                \"-fs\", \"HFS+\");\n-            new RetryExecutor()\n-                .setMaxAttemptsCount(10)\n-                .setAttemptTimeoutMillis(3000)\n-                .setWriteOutputToFile(true)\n-                .execute(pb);\n+            hdiutil(\n+                    \"create\",\n+                    hdiUtilVerbosityFlag,\n+                    \"-size\", String.valueOf(size),\n+                    \"-volname\", volumeName(),\n+                    \"-ov\", normalizedAbsolutePathString(protoDMG),\n+                    \"-fs\", \"HFS+\"\n+            ).retry()\n+                    .setMaxAttemptsCount(10)\n+                    .setAttemptTimeout(3, TimeUnit.SECONDS)\n+                    .execute();\n@@ -278,0 +288,2 @@\n+        final Path mountedVolume = volumePath();\n+\n@@ -279,3 +291,1 @@\n-        pb = new ProcessBuilder(\n-                sysEnv.hdiutil().toString(),\n-                \"attach\",\n+        hdiutil(\"attach\",\n@@ -284,4 +294,1 @@\n-                \"-mountroot\", protoDMG.getParent().toString());\n-        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n-\n-        final Path mountedVolume = volumePath();\n+                \"-mountroot\", mountedVolume.getParent().toString()).executeExpectSuccess();\n@@ -305,3 +312,7 @@\n-                pb = new ProcessBuilder(sysEnv.osascript().toString(),\n-                        normalizedAbsolutePathString(volumeScript()));\n-                IOUtils.exec(pb, 180); \/\/ Wait 3 minutes. See JDK-8248248.\n+                Executor.of(\n+                        sysEnv.osascript().toString(),\n+                        normalizedAbsolutePathString(volumeScript())\n+                )\n+                \/\/ Wait 3 minutes. See JDK-8248248.\n+                .timeout(3, TimeUnit.MINUTES)\n+                .executeExpectSuccess();\n@@ -328,1 +339,1 @@\n-                    pb = new ProcessBuilder(\n+                    Executor.of(\n@@ -331,2 +342,2 @@\n-                            normalizedAbsolutePathString(volumeIconFile));\n-                    IOUtils.exec(pb);\n+                            normalizedAbsolutePathString(volumeIconFile)\n+                    ).executeExpectSuccess();\n@@ -335,1 +346,1 @@\n-                    pb = new ProcessBuilder(\n+                    Executor.of(\n@@ -338,2 +349,2 @@\n-                            normalizedAbsolutePathString(mountedVolume));\n-                    IOUtils.exec(pb);\n+                            normalizedAbsolutePathString(mountedVolume)\n+                    ).executeExpectSuccess();\n@@ -350,33 +361,1 @@\n-            pb = new ProcessBuilder(\n-                    sysEnv.hdiutil().toString(),\n-                    \"detach\",\n-                    hdiUtilVerbosityFlag,\n-                    normalizedAbsolutePathString(mountedVolume));\n-            \/\/ \"hdiutil detach\" might not work right away due to resource busy error, so\n-            \/\/ repeat detach several times.\n-            RetryExecutor retryExecutor = new RetryExecutor();\n-            \/\/ Image can get detach even if we got resource busy error, so stop\n-            \/\/ trying to detach it if it is no longer attached.\n-            retryExecutor.setExecutorInitializer(exec -> {\n-                if (!Files.exists(mountedVolume)) {\n-                    retryExecutor.abort();\n-                }\n-            });\n-            try {\n-                \/\/ 10 times with 6 second delays.\n-                retryExecutor.setMaxAttemptsCount(10).setAttemptTimeoutMillis(6000)\n-                        .execute(pb);\n-            } catch (IOException ex) {\n-                if (!retryExecutor.isAborted()) {\n-                    \/\/ Now force to detach if it still attached\n-                    if (Files.exists(mountedVolume)) {\n-                        pb = new ProcessBuilder(\n-                                sysEnv.hdiutil().toString(),\n-                                \"detach\",\n-                                \"-force\",\n-                                hdiUtilVerbosityFlag,\n-                                normalizedAbsolutePathString(mountedVolume));\n-                        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n-                    }\n-                }\n-            }\n+            detachVolume();\n@@ -386,29 +365,1 @@\n-        pb = new ProcessBuilder(\n-                sysEnv.hdiutil().toString(),\n-                \"convert\",\n-                normalizedAbsolutePathString(protoDMG),\n-                hdiUtilVerbosityFlag,\n-                \"-format\", \"UDZO\",\n-                \"-o\", normalizedAbsolutePathString(finalDMG));\n-        try {\n-            new RetryExecutor()\n-                .setMaxAttemptsCount(10)\n-                .setAttemptTimeoutMillis(3000)\n-                .execute(pb);\n-        } catch (Exception ex) {\n-            \/\/ Convert might failed if something holds file. Try to convert copy.\n-            Path protoCopyDMG = protoCopyDmg();\n-            Files.copy(protoDMG, protoCopyDMG);\n-            try {\n-                pb = new ProcessBuilder(\n-                        sysEnv.hdiutil().toString(),\n-                        \"convert\",\n-                        normalizedAbsolutePathString(protoCopyDMG),\n-                        hdiUtilVerbosityFlag,\n-                        \"-format\", \"UDZO\",\n-                        \"-o\", normalizedAbsolutePathString(finalDMG));\n-                IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n-            } finally {\n-                Files.deleteIfExists(protoCopyDMG);\n-            }\n-        }\n+        convertProtoDmg();\n@@ -418,2 +369,1 @@\n-            pb = new ProcessBuilder(\n-                    sysEnv.hdiutil().toString(),\n+            hdiutil(\n@@ -424,5 +374,4 @@\n-            );\n-            new RetryExecutor()\n-                .setMaxAttemptsCount(10)\n-                .setAttemptTimeoutMillis(3000)\n-                .execute(pb);\n+            ).retry()\n+                    .setMaxAttemptsCount(10)\n+                    .setAttemptTimeout(3, TimeUnit.SECONDS)\n+                    .execute();\n@@ -444,0 +393,63 @@\n+    private void detachVolume() throws IOException {\n+        var mountedVolume = volumePath();\n+\n+        \/\/ \"hdiutil detach\" might not work right away due to resource busy error, so\n+        \/\/ repeat detach several times.\n+        Globals.instance().objectFactory().<Void, IOException>retryExecutor(IOException.class).setExecutable(context -> {\n+\n+            List<String> cmdline = new ArrayList<>();\n+            cmdline.add(\"detach\");\n+\n+            if (context.isLastAttempt()) {\n+                \/\/ The last attempt, force detach.\n+                cmdline.add(\"-force\");\n+            }\n+\n+            cmdline.addAll(List.of(\n+                    hdiUtilVerbosityFlag(),\n+                    normalizedAbsolutePathString(mountedVolume)\n+            ));\n+\n+            \/\/ The image can get detached even if we get a resource busy error,\n+            \/\/ so execute the detach command without checking the exit code.\n+            var result = hdiutil(cmdline.toArray(String[]::new)).execute();\n+\n+            if (result.getExitCode() == 0 || !Files.exists(mountedVolume)) {\n+                \/\/ Detached successfully!\n+                return null;\n+            } else {\n+                throw result.unexpected();\n+            }\n+        }).setMaxAttemptsCount(10).setAttemptTimeout(6, TimeUnit.SECONDS).execute();\n+    }\n+\n+    private void convertProtoDmg() throws IOException {\n+\n+        Function<Path, Executor> convert = srcDmg -> {\n+            return hdiutil(\n+                    \"convert\",\n+                    normalizedAbsolutePathString(srcDmg),\n+                    hdiUtilVerbosityFlag(),\n+                    \"-format\", \"UDZO\",\n+                    \"-o\", normalizedAbsolutePathString(finalDmg()));\n+        };\n+\n+        \/\/ Convert it to a new image.\n+        try {\n+            convert.apply(protoDmg()).retry()\n+                .setMaxAttemptsCount(10)\n+                .setAttemptTimeout(3, TimeUnit.SECONDS)\n+                .execute();\n+        } catch (IOException ex) {\n+            Log.verbose(ex);\n+            \/\/ Something holds the file, try to convert a copy.\n+            Path copyDmg = protoCopyDmg();\n+            Files.copy(protoDmg(), copyDmg);\n+            try {\n+                convert.apply(copyDmg).executeExpectSuccess();\n+            } finally {\n+                Files.deleteIfExists(copyDmg);\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgPackager.java","additions":126,"deletions":114,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.nio.file.Files;\n@@ -30,0 +29,1 @@\n+import java.util.List;\n@@ -32,0 +32,1 @@\n+import java.util.stream.Collectors;\n@@ -57,3 +58,9 @@\n-    private static Optional<Path> findSetFileUtility() {\n-        String typicalPaths[] = {\"\/Developer\/Tools\/SetFile\",\n-                \"\/usr\/bin\/SetFile\", \"\/Developer\/usr\/bin\/SetFile\"};\n+    static Optional<Path> findSetFileUtility() {\n+        return SETFILE_KNOWN_PATHS.stream().filter(setFilePath -> {\n+            \/\/ Validate SetFile, if Xcode is not installed it will run, but exit with error code\n+            return Result.of(\n+                    Executor.of(setFilePath.toString(), \"-h\").setQuiet(true)::executeExpectSuccess,\n+                    IOException.class).hasValue();\n+        }).findFirst().or(() -> {\n+            \/\/ generic find attempt\n+            final var executor = Executor.of(\"\/usr\/bin\/xcrun\", \"-find\", \"SetFile\").setQuiet(true).saveFirstLineOfOutput();\n@@ -61,29 +68,8 @@\n-        final var setFilePath = Stream.of(typicalPaths).map(Path::of).filter(Files::isExecutable).findFirst();\n-        if (setFilePath.isPresent()) {\n-            \/\/ Validate SetFile, if Xcode is not installed it will run, but exit with error\n-            \/\/ code\n-            try {\n-                if (Executor.of(setFilePath.orElseThrow().toString(), \"-h\").setQuiet(true).execute() == 0) {\n-                    return setFilePath;\n-                }\n-            } catch (Exception ignored) {\n-                \/\/ No need for generic find attempt. We found it, but it does not work.\n-                \/\/ Probably due to missing xcode.\n-                return Optional.empty();\n-            }\n-        }\n-\n-        \/\/ generic find attempt\n-        try {\n-            final var executor = Executor.of(\"\/usr\/bin\/xcrun\", \"-find\", \"SetFile\");\n-            final var code = executor.setQuiet(true).saveOutput(true).execute();\n-            if (code == 0 && !executor.getOutput().isEmpty()) {\n-                final var firstLine = executor.getOutput().getFirst();\n-                Path f = Path.of(firstLine);\n-                if (new ToolValidator(f).checkExistsOnly().validate() == null) {\n-                    return Optional.of(f.toAbsolutePath());\n-                }\n-            }\n-        } catch (IOException ignored) {}\n-\n-        return Optional.empty();\n+            return Result.of(executor::executeExpectSuccess, IOException.class).flatMap(execResult -> {\n+                return Result.of(() -> {\n+                    return execResult.stdout().stream().findFirst().map(Path::of).orElseThrow(execResult::unexpected);\n+                }, Exception.class);\n+            }).value().filter(v -> {\n+                return new ToolValidator(v).checkExistsOnly().validate() == null;\n+            }).map(Path::toAbsolutePath);\n+        });\n@@ -92,0 +78,5 @@\n+    static final List<Path> SETFILE_KNOWN_PATHS = Stream.of(\n+            \"\/Developer\/Tools\/SetFile\",\n+            \"\/usr\/bin\/SetFile\",\n+            \"\/Developer\/usr\/bin\/SetFile\").map(Path::of).collect(Collectors.toUnmodifiableList());\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgSystemEnvironment.java","additions":25,"deletions":34,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.nio.file.DirectoryStream;\n@@ -60,0 +59,1 @@\n+import jdk.jpackage.internal.util.Enquoter;\n@@ -111,1 +111,1 @@\n-                IOUtils.exec(new ProcessBuilder(cmdline), false, null, true, Executor.INFINITE_TIMEOUT);\n+                Executor.of(cmdline).executeExpectSuccess();\n@@ -490,1 +490,1 @@\n-        final var pb = new ProcessBuilder(\"\/usr\/bin\/pkgbuild\",\n+        Executor.of(\"\/usr\/bin\/pkgbuild\",\n@@ -496,3 +496,1 @@\n-                normalizedAbsolutePathString(cpl));\n-\n-        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n+                normalizedAbsolutePathString(cpl)).executeExpectSuccess();\n@@ -547,2 +545,1 @@\n-        final var pb = new ProcessBuilder(commandLine);\n-        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n+        Executor.of(commandLine).executeExpectSuccess();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgPackager.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.io.UncheckedIOException;\n@@ -33,0 +34,1 @@\n+import java.util.function.Consumer;\n@@ -34,1 +36,0 @@\n-import jdk.jpackage.internal.util.function.ThrowingConsumer;\n@@ -38,1 +39,2 @@\n-    static void withKeychains(ThrowingConsumer<List<Keychain>, ? extends Exception> keychainConsumer, List<Keychain> keychains) throws Exception {\n+    static void withKeychains(Consumer<List<Keychain>> keychainConsumer, List<Keychain> keychains) {\n+\n@@ -46,0 +48,2 @@\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n@@ -50,1 +54,2 @@\n-    static void withKeychain(ThrowingConsumer<Keychain, ? extends Exception> keychainConsumer, Keychain keychain) throws Exception {\n+    static void withKeychain(Consumer<Keychain> keychainConsumer, Keychain keychain) {\n+\n@@ -81,1 +86,1 @@\n-            Executor.of(args.toArray(String[]::new)).executeExpectSuccess();\n+            Executor.of(args).executeExpectSuccess();\n@@ -92,1 +97,1 @@\n-            Executor.of(restoreKeychainsCmd.toArray(String[]::new)).executeExpectSuccess();\n+            Executor.of(restoreKeychainsCmd).executeExpectSuccess();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/TempKeychain.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-            return new CachingSupplier<>(e.getValue());\n+            return runOnce(e.getValue());\n@@ -71,1 +71,1 @@\n-        this.defaultOperationSupplier = Objects.requireNonNull(defaultOperationSupplier).map(CachingSupplier::new);\n+        this.defaultOperationSupplier = Objects.requireNonNull(defaultOperationSupplier).map(DefaultBundlingEnvironment::runOnce);\n@@ -101,0 +101,5 @@\n+        Builder mutate(Consumer<Builder> mutator) {\n+            mutator.accept(this);\n+            return this;\n+        }\n+\n@@ -110,0 +115,4 @@\n+    static <T> Supplier<T> runOnce(Supplier<T> supplier) {\n+        return new CachingSupplier<>(supplier);\n+    }\n+\n@@ -282,1 +291,1 @@\n-    private final Optional<CachingSupplier<Optional<BundlingOperationDescriptor>>> defaultOperationSupplier;\n+    private final Optional<Supplier<Optional<BundlingOperationDescriptor>>> defaultOperationSupplier;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/DefaultBundlingEnvironment.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import java.util.Optional;\n-import java.util.function.BiConsumer;\n-import java.util.function.Predicate;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * Add quotes to the given string in a configurable way.\n- *\/\n-final class Enquoter {\n-\n-    private Enquoter() {\n-        setQuoteChar('\"');\n-    }\n-\n-    static Enquoter forPropertyValues() {\n-        return new Enquoter()\n-                .setEnquotePredicate(QUOTE_IF_WHITESPACES)\n-                .setEscaper(PREPEND_BACKSLASH);\n-    }\n-\n-    static Enquoter forShellLiterals() {\n-        return forShellLiterals('\\'');\n-    }\n-\n-    static Enquoter forShellLiterals(char quoteChar) {\n-        return new Enquoter()\n-                .setQuoteChar(quoteChar)\n-                .setEnquotePredicate(x -> true)\n-                .setEscaper(PREPEND_BACKSLASH);\n-    }\n-\n-    String applyTo(String v) {\n-        if (!needQuotes.test(v)) {\n-            return v;\n-        } else {\n-            var buf = new StringBuilder();\n-            buf.appendCodePoint(beginQuoteChr);\n-            Optional.of(escaper).ifPresentOrElse(op -> {\n-                v.codePoints().forEachOrdered(chr -> {\n-                    if (chr == beginQuoteChr || chr == endQuoteChr) {\n-                        escaper.accept(chr, buf);\n-                    } else {\n-                        buf.appendCodePoint(chr);\n-                    }\n-                });\n-            }, () -> {\n-                buf.append(v);\n-            });\n-            buf.appendCodePoint(endQuoteChr);\n-            return buf.toString();\n-        }\n-    }\n-\n-    Enquoter setQuoteChar(char chr) {\n-        beginQuoteChr = chr;\n-        endQuoteChr = chr;\n-        return this;\n-    }\n-\n-    Enquoter setEscaper(BiConsumer<Integer, StringBuilder> v) {\n-        escaper = v;\n-        return this;\n-    }\n-\n-    Enquoter setEnquotePredicate(Predicate<String> v) {\n-        needQuotes = v;\n-        return this;\n-    }\n-\n-    private int beginQuoteChr;\n-    private int endQuoteChr;\n-    private BiConsumer<Integer, StringBuilder> escaper;\n-    private Predicate<String> needQuotes = str -> false;\n-\n-    private static final Predicate<String> QUOTE_IF_WHITESPACES = new Predicate<String>() {\n-        @Override\n-        public boolean test(String t) {\n-            return pattern.matcher(t).find();\n-        }\n-        private final Pattern pattern = Pattern.compile(\"\\\\s\");\n-    };\n-\n-    private static final BiConsumer<Integer, StringBuilder> PREPEND_BACKSLASH = (chr, buf) -> {\n-        buf.append('\\\\');\n-        buf.appendCodePoint(chr);\n-    };\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Enquoter.java","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -29,3 +30,7 @@\n-import java.io.InputStreamReader;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n+import java.io.PrintStream;\n+import java.io.StringReader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n@@ -33,0 +38,2 @@\n+import java.util.Objects;\n+import java.util.Optional;\n@@ -34,2 +41,2 @@\n-import java.util.function.Consumer;\n-import java.util.function.Supplier;\n+import java.util.function.UnaryOperator;\n+import java.util.spi.ToolProvider;\n@@ -37,0 +44,6 @@\n+import jdk.jpackage.internal.util.CommandLineFormat;\n+import jdk.jpackage.internal.util.CommandOutputControl;\n+import jdk.jpackage.internal.util.CommandOutputControl.ProcessAttributes;\n+import jdk.jpackage.internal.util.CommandOutputControl.Result;\n+import jdk.jpackage.internal.util.RetryExecutor;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n@@ -38,1 +51,1 @@\n-public final class Executor {\n+final class Executor {\n@@ -40,1 +53,2 @@\n-    Executor() {\n+    static Executor of(String... cmdline) {\n+        return of(List.of(cmdline));\n@@ -43,3 +57,21 @@\n-    Executor setOutputConsumer(Consumer<Stream<String>> v) {\n-        outputConsumer = v;\n-        return this;\n+    static Executor of(List<String> cmdline) {\n+        return of(new ProcessBuilder(cmdline));\n+    }\n+\n+    static Executor of(ProcessBuilder pb) {\n+        return Globals.instance().objectFactory().executor().processBuilder(pb);\n+    }\n+\n+    public Executor() {\n+        commandOutputControl = new CommandOutputControl();\n+        args = new ArrayList<>();\n+    }\n+\n+    private Executor(Executor other) {\n+        commandOutputControl = other.commandOutputControl.copy();\n+        quietCommand = other.quietCommand;\n+        args = new ArrayList<>(other.args);\n+        processBuilder = other.processBuilder;\n+        toolProvider = other.toolProvider;\n+        timeout = other.timeout;\n+        mapper = other.mapper;\n@@ -49,1 +81,15 @@\n-        saveOutput = v;\n+        commandOutputControl.saveOutput(v);\n+        return this;\n+    }\n+\n+    Executor saveOutput() {\n+        return saveOutput(true);\n+    }\n+\n+    Executor saveFirstLineOfOutput() {\n+        commandOutputControl.saveFirstLineOfOutput();\n+        return this;\n+    }\n+\n+    Executor charset(Charset v) {\n+        commandOutputControl.charset(v);\n@@ -53,2 +99,2 @@\n-    Executor setWriteOutputToFile(boolean v) {\n-        writeOutputToFile = v;\n+    Executor storeOutputInFiles(boolean v) {\n+        commandOutputControl.storeOutputInFiles(v);\n@@ -58,1 +104,36 @@\n-    Executor setTimeout(long v) {\n+    Executor storeOutputInFiles() {\n+        return storeOutputInFiles(true);\n+    }\n+\n+    Executor binaryOutput(boolean v) {\n+        commandOutputControl.binaryOutput(v);\n+        return this;\n+    }\n+\n+    Executor binaryOutput() {\n+        return binaryOutput(true);\n+    }\n+\n+    Executor discardStdout(boolean v) {\n+        commandOutputControl.discardStdout(v);\n+        return this;\n+    }\n+\n+    Executor discardStdout() {\n+        return discardStdout(true);\n+    }\n+\n+    Executor discardStderr(boolean v) {\n+        commandOutputControl.discardStderr(v);\n+        return this;\n+    }\n+\n+    Executor discardStderr() {\n+        return discardStderr(true);\n+    }\n+\n+    Executor timeout(long v, TimeUnit unit) {\n+        return timeout(Duration.of(v, unit.toChronoUnit()));\n+    }\n+\n+    Executor timeout(Duration v) {\n@@ -60,5 +141,0 @@\n-        if (timeout != INFINITE_TIMEOUT) {\n-            \/\/ Redirect output to file if timeout is requested, otherwise we will\n-            \/\/ reading until process ends and timeout will never be reached.\n-            setWriteOutputToFile(true);\n-        }\n@@ -68,2 +144,3 @@\n-    Executor setProcessBuilder(ProcessBuilder v) {\n-        pb = v;\n+    Executor toolProvider(ToolProvider v) {\n+        toolProvider = Objects.requireNonNull(v);\n+        processBuilder = null;\n@@ -73,2 +150,25 @@\n-    Executor setCommandLine(String... cmdline) {\n-        return setProcessBuilder(new ProcessBuilder(cmdline));\n+    Optional<ToolProvider> toolProvider() {\n+        return Optional.ofNullable(toolProvider);\n+    }\n+\n+    Executor processBuilder(ProcessBuilder v) {\n+        processBuilder = Objects.requireNonNull(v);\n+        toolProvider = null;\n+        return this;\n+    }\n+\n+    Optional<ProcessBuilder> processBuilder() {\n+        return Optional.ofNullable(processBuilder);\n+    }\n+\n+    Executor args(List<String> v) {\n+        args.addAll(v);\n+        return this;\n+    }\n+\n+    Executor args(String... args) {\n+        return args(List.of(args));\n+    }\n+\n+    List<String> args() {\n+        return args;\n@@ -82,2 +182,3 @@\n-    List<String> getOutput() {\n-        return output;\n+    Executor mapper(UnaryOperator<Executor> v) {\n+        mapper = v;\n+        return this;\n@@ -86,8 +187,2 @@\n-    Executor executeExpectSuccess() throws IOException {\n-        int ret = execute();\n-        if (0 != ret) {\n-            throw new IOException(\n-                    String.format(\"Command %s exited with %d code\",\n-                            createLogMessage(pb, false), ret));\n-        }\n-        return this;\n+    Optional<UnaryOperator<Executor>> mapper() {\n+        return Optional.ofNullable(mapper);\n@@ -96,2 +191,3 @@\n-    int execute() throws IOException {\n-        output = null;\n+    Executor copy() {\n+        return new Executor(this);\n+    }\n@@ -99,7 +195,5 @@\n-        boolean needProcessOutput = outputConsumer != null || Log.isVerbose() || saveOutput;\n-        Path outputFile = null;\n-        if (needProcessOutput) {\n-            pb.redirectErrorStream(true);\n-            if (writeOutputToFile) {\n-                outputFile = Files.createTempFile(\"jpackageOutputTempFile\", \".tmp\");\n-                pb.redirectOutput(outputFile.toFile());\n+    Result execute() throws IOException {\n+        if (mapper != null) {\n+            var mappedExecutor = Objects.requireNonNull(mapper.apply(this));\n+            if (mappedExecutor != this) {\n+                return mappedExecutor.execute();\n@@ -107,6 +201,0 @@\n-        } else {\n-            \/\/ We are not going to read process output, so need to notify\n-            \/\/ ProcessBuilder about this. Otherwise some processes might just\n-            \/\/ hang up (`ldconfig -p`).\n-            pb.redirectError(ProcessBuilder.Redirect.DISCARD);\n-            pb.redirectOutput(ProcessBuilder.Redirect.DISCARD);\n@@ -115,3 +203,1 @@\n-        if (!quietCommand) {\n-            Log.verbose(String.format(\"Running %s\", createLogMessage(pb, true)));\n-        }\n+        var coc = commandOutputControl.copy();\n@@ -119,1 +205,8 @@\n-        Process p = pb.start();\n+        final CommandOutputControl.Executable exec;\n+        if (processBuilder != null) {\n+            exec = coc.createExecutable(copyProcessBuilder());\n+        } else if (toolProvider != null) {\n+            exec = coc.createExecutable(toolProvider, args.toArray(String[]::new));\n+        } else {\n+            throw new IllegalStateException(\"No target to execute\");\n+        }\n@@ -121,8 +214,5 @@\n-        int code = 0;\n-        if (writeOutputToFile) {\n-            try {\n-                code = waitForProcess(p);\n-            } catch (InterruptedException ex) {\n-                Log.verbose(ex);\n-                throw new RuntimeException(ex);\n-            }\n+        PrintableOutputBuilder printableOutputBuilder;\n+        if (dumpOutput()) {\n+            printableOutputBuilder = new PrintableOutputBuilder(coc);\n+        } else {\n+            printableOutputBuilder = null;\n@@ -131,49 +221,2 @@\n-        if (needProcessOutput) {\n-            final List<String> savedOutput;\n-            Supplier<Stream<String>> outputStream;\n-\n-            if (writeOutputToFile) {\n-                output = savedOutput = Files.readAllLines(outputFile);\n-                Files.delete(outputFile);\n-                outputStream = () -> {\n-                    if (savedOutput != null) {\n-                        return savedOutput.stream();\n-                    }\n-                    return null;\n-                };\n-                if (outputConsumer != null) {\n-                    outputConsumer.accept(outputStream.get());\n-                }\n-            } else {\n-                try (var br = new BufferedReader(new InputStreamReader(\n-                        p.getInputStream()))) {\n-\n-                    if ((outputConsumer != null || Log.isVerbose())\n-                            || saveOutput) {\n-                        savedOutput = br.lines().toList();\n-                    } else {\n-                        savedOutput = null;\n-                    }\n-                    output = savedOutput;\n-\n-                    outputStream = () -> {\n-                        if (savedOutput != null) {\n-                            return savedOutput.stream();\n-                        }\n-                        return br.lines();\n-                    };\n-                    if (outputConsumer != null) {\n-                        outputConsumer.accept(outputStream.get());\n-                    }\n-\n-                    if (savedOutput == null) {\n-                        \/\/ For some processes on Linux if the output stream\n-                        \/\/ of the process is opened but not consumed, the process\n-                        \/\/ would exit with code 141.\n-                        \/\/ It turned out that reading just a single line of process\n-                        \/\/ output fixes the problem, but let's process\n-                        \/\/ all of the output, just in case.\n-                        br.lines().forEach(x -> {});\n-                    }\n-                }\n-            }\n+        if (dumpOutput()) {\n+            Log.verbose(String.format(\"Running %s\", CommandLineFormat.DEFAULT.apply(List.of(commandLine().getFirst()))));\n@@ -182,0 +225,1 @@\n+        Result result;\n@@ -183,5 +227,4 @@\n-            if (!writeOutputToFile) {\n-                code = p.waitFor();\n-            }\n-            if (!quietCommand) {\n-                Log.verbose(pb.command(), getOutput(), code, IOUtils.getPID(p));\n+            if (timeout == null) {\n+                result = exec.execute();\n+            } else {\n+                result = exec.execute(timeout.toMillis(), TimeUnit.MILLISECONDS);\n@@ -189,1 +232,0 @@\n-            return code;\n@@ -191,2 +233,1 @@\n-            Log.verbose(ex);\n-            throw new RuntimeException(ex);\n+            throw ExceptionBox.toUnchecked(ex);\n@@ -194,0 +235,6 @@\n+\n+        if (dumpOutput()) {\n+            log(result, printableOutputBuilder.create());\n+        }\n+\n+        return result;\n@@ -196,11 +243,20 @@\n-    private int waitForProcess(Process p) throws InterruptedException {\n-        if (timeout == INFINITE_TIMEOUT) {\n-            return p.waitFor();\n-        } else {\n-            if (p.waitFor(timeout, TimeUnit.SECONDS)) {\n-                return p.exitValue();\n-            } else {\n-                Log.verbose(String.format(\"Command %s timeout after %d seconds\",\n-                            createLogMessage(pb, false), timeout));\n-                p.destroy();\n-                return -1;\n+    Result executeExpectSuccess() throws IOException {\n+        return execute().expectExitCode(0);\n+    }\n+\n+    Result executeExpect(int mainExitCode, int... otherExitCodes) throws IOException {\n+        return execute().expectExitCode(mainExitCode, otherExitCodes);\n+    }\n+\n+    RetryExecutor<Result, IOException> retry() {\n+        return Globals.instance().objectFactory().<Result, IOException>retryExecutor(IOException.class)\n+                .setExecutable(this::executeExpectSuccess);\n+    }\n+\n+    RetryExecutor<Result, IOException> retryOnKnownErrorMessage(String msg) {\n+        Objects.requireNonNull(msg);\n+        return saveOutput().retry().setExecutable(() -> {\n+            \/\/ Execute it without exit code check.\n+            var result = execute();\n+            if (result.stderr().stream().anyMatch(msg::equals)) {\n+                throw result.unexpected();\n@@ -208,0 +264,11 @@\n+            return result;\n+        });\n+    }\n+\n+    List<String> commandLine() {\n+        if (processBuilder != null) {\n+            return Stream.of(processBuilder.command(), args).flatMap(Collection::stream).toList();\n+        } else if (toolProvider != null) {\n+            return Stream.concat(Stream.of(toolProvider.name()), args.stream()).toList();\n+        } else {\n+            throw new IllegalStateException(\"No target to execute\");\n@@ -211,2 +278,12 @@\n-    static Executor of(String... cmdline) {\n-        return new Executor().setCommandLine(cmdline);\n+    private ProcessBuilder copyProcessBuilder() {\n+        if (processBuilder == null) {\n+            throw new IllegalStateException();\n+        }\n+\n+        var copy = new ProcessBuilder(commandLine());\n+        copy.directory(processBuilder.directory());\n+        var env = copy.environment();\n+        env.clear();\n+        env.putAll(processBuilder.environment());\n+\n+        return copy;\n@@ -215,2 +292,2 @@\n-    static Executor of(ProcessBuilder pb) {\n-        return new Executor().setProcessBuilder(pb);\n+    private boolean dumpOutput() {\n+        return Log.isVerbose() && !quietCommand;\n@@ -219,5 +296,28 @@\n-    private static String createLogMessage(ProcessBuilder pb, boolean quiet) {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append((quiet) ? pb.command().get(0) : pb.command());\n-        if (pb.directory() != null) {\n-            sb.append(String.format(\" in %s\", pb.directory().getAbsolutePath()));\n+    private static void log(Result result, String printableOutput) throws IOException {\n+        Objects.requireNonNull(result);\n+        Objects.requireNonNull(printableOutput);\n+\n+        Optional<Long> pid;\n+        if (result.execAttrs() instanceof ProcessAttributes attrs) {\n+            pid = attrs.pid();\n+        } else {\n+            pid = Optional.empty();\n+        }\n+\n+        var sb = new StringBuilder();\n+        sb.append(\"Command\");\n+        pid.ifPresent(p -> {\n+            sb.append(\" [PID: \").append(p).append(\"]\");\n+        });\n+        sb.append(\":\\n    \").append(result.execAttrs());\n+        Log.verbose(sb.toString());\n+\n+        if (!printableOutput.isEmpty()) {\n+            sb.delete(0, sb.length());\n+            sb.append(\"Output:\");\n+            try (var lines = new BufferedReader(new StringReader(printableOutput)).lines()) {\n+                lines.forEach(line -> {\n+                    sb.append(\"\\n    \").append(line);\n+                });\n+            }\n+            Log.verbose(sb.toString());\n@@ -225,1 +325,6 @@\n-        return sb.toString();\n+\n+        result.exitCode().ifPresentOrElse(exitCode -> {\n+            Log.verbose(\"Returned: \" + exitCode + \"\\n\");\n+        }, () -> {\n+            Log.verbose(\"Aborted: timed-out\" + \"\\n\");\n+        });\n@@ -228,1 +333,44 @@\n-    public static final int INFINITE_TIMEOUT = -1;\n+    private static final class PrintableOutputBuilder {\n+\n+        PrintableOutputBuilder(CommandOutputControl coc) {\n+            coc.dumpOutput(true);\n+            charset = coc.charset();\n+            if (coc.isBinaryOutput()) {\n+                \/\/ Assume binary output goes into stdout and text error messages go into stderr, so keep them separated.\n+                sinks = new ByteArrayOutputStream[2];\n+                sinks[0] = new ByteArrayOutputStream();\n+                sinks[1] = new ByteArrayOutputStream();\n+                coc.dumpStdout(new PrintStream(sinks[0], false, charset))\n+                    .dumpStderr(new PrintStream(sinks[1], false, charset));\n+            } else {\n+                sinks = new ByteArrayOutputStream[1];\n+                sinks[0] = new ByteArrayOutputStream();\n+                var ps = new PrintStream(sinks[0], false, charset);\n+                \/\/ Redirect stderr in stdout.\n+                coc.dumpStdout(ps).dumpStderr(ps);\n+            }\n+        }\n+\n+        String create() {\n+            if (isBinaryOutput()) {\n+                \/\/ In case of binary output:\n+                \/\/  - Convert binary stdout to text using ISO-8859-1 encoding and\n+                \/\/    replace non-printable characters with the question mark symbol (?).\n+                \/\/  - Convert binary stderr to text using designated encoding (assume stderr is always a character stream).\n+                \/\/  - Merge text stdout and stderr into a single string;\n+                \/\/    stderr first, stdout follows, with the aim to present user error messages first.\n+                var sb = new StringBuilder();\n+                var stdout = sinks[0].toString(StandardCharsets.ISO_8859_1).replaceAll(\"[^\\\\p{Print}\\\\p{Space}]\", \"?\");\n+                return sb.append(sinks[1].toString(charset)).append(stdout).toString();\n+            } else {\n+                return sinks[0].toString(charset);\n+            }\n+        }\n+\n+        private boolean isBinaryOutput() {\n+            return sinks.length == 2;\n+        }\n+\n+        private final ByteArrayOutputStream sinks[];\n+        private final Charset charset;\n+    }\n@@ -230,3 +378,1 @@\n-    private ProcessBuilder pb;\n-    private boolean saveOutput;\n-    private boolean writeOutputToFile;\n+    private final CommandOutputControl commandOutputControl;\n@@ -234,3 +380,5 @@\n-    private long timeout = INFINITE_TIMEOUT;\n-    private List<String> output;\n-    private Consumer<Stream<String>> outputConsumer;\n+    private final List<String> args;\n+    private ProcessBuilder processBuilder;\n+    private ToolProvider toolProvider;\n+    private Duration timeout;\n+    private UnaryOperator<Executor> mapper;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Executor.java","additions":294,"deletions":146,"binary":false,"changes":440,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+@FunctionalInterface\n+interface ExecutorFactory {\n+\n+    Executor executor();\n+\n+    static final ExecutorFactory DEFAULT = Executor::new;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ExecutorFactory.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+public final class Globals {\n+\n+    private Globals() {\n+    }\n+\n+    Globals objectFactory(ObjectFactory v) {\n+        checkMutable();\n+        objectFactory = Optional.ofNullable(v).orElse(ObjectFactory.DEFAULT);\n+        return this;\n+    }\n+\n+    ObjectFactory objectFactory() {\n+        return objectFactory;\n+    }\n+\n+    Globals executorFactory(ExecutorFactory v) {\n+        return objectFactory(ObjectFactory.build(objectFactory).executorFactory(v).create());\n+    }\n+\n+    public static int main(Supplier<Integer> mainBody) {\n+        if (INSTANCE.isBound()) {\n+            return mainBody.get();\n+        } else {\n+            return ScopedValue.where(INSTANCE, new Globals()).call(mainBody::get);\n+        }\n+    }\n+\n+    public static Globals instance() {\n+        return INSTANCE.orElse(DEFAULT);\n+    }\n+\n+    private void checkMutable() {\n+        if (this == DEFAULT) {\n+            throw new UnsupportedOperationException(\"Can't modify immutable instance\");\n+        }\n+    }\n+\n+    private ObjectFactory objectFactory = ObjectFactory.DEFAULT;\n+\n+    private static final ScopedValue<Globals> INSTANCE = ScopedValue.newInstance();\n+    private static final Globals DEFAULT = new Globals();\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Globals.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.io.PrintStream;\n@@ -33,2 +32,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -53,40 +50,0 @@\n-    public static void exec(ProcessBuilder pb)\n-            throws IOException {\n-        exec(pb, false, null, false, Executor.INFINITE_TIMEOUT);\n-    }\n-\n-    \/\/ timeout in seconds. -1 will be return if process timeouts.\n-    public static void exec(ProcessBuilder pb, long timeout)\n-            throws IOException {\n-        exec(pb, false, null, false, timeout);\n-    }\n-\n-    static void exec(ProcessBuilder pb, boolean testForPresenceOnly,\n-            PrintStream consumer, boolean writeOutputToFile, long timeout)\n-            throws IOException {\n-        exec(pb, testForPresenceOnly, consumer, writeOutputToFile,\n-                timeout, false);\n-    }\n-\n-    static void exec(ProcessBuilder pb, boolean testForPresenceOnly,\n-            PrintStream consumer, boolean writeOutputToFile,\n-            long timeout, boolean quiet) throws IOException {\n-        List<String> output = new ArrayList<>();\n-        Executor exec = Executor.of(pb)\n-                .setWriteOutputToFile(writeOutputToFile)\n-                .setTimeout(timeout)\n-                .setQuiet(quiet)\n-                .setOutputConsumer(lines -> {\n-                    lines.forEach(output::add);\n-                    if (consumer != null) {\n-                        output.forEach(consumer::println);\n-                    }\n-                });\n-\n-        if (testForPresenceOnly) {\n-            exec.execute();\n-        } else {\n-            exec.executeExpectSuccess();\n-        }\n-    }\n-\n@@ -106,11 +63,0 @@\n-\n-    public static long getPID(Process p) {\n-        try {\n-            return p.pid();\n-        } catch (UnsupportedOperationException ex) {\n-            Log.verbose(ex); \/\/ Just log exception and ignore it. This method\n-                             \/\/ is used for verbose output, so not a problem\n-                             \/\/ if unsupported.\n-            return -1;\n-        }\n-    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/IOUtils.java","additions":1,"deletions":55,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -26,0 +27,1 @@\n+\n@@ -27,0 +29,1 @@\n+import static jdk.jpackage.internal.util.function.ThrowingRunnable.toRunnable;\n@@ -30,2 +33,0 @@\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n@@ -53,1 +54,0 @@\n-import jdk.jpackage.internal.model.JPackageException;\n@@ -61,1 +61,1 @@\n-        this.jlinkCmdLine = jlinkCmdLine;\n+        this.jlinkCmdLine = Objects.requireNonNull(jlinkCmdLine);\n@@ -66,16 +66,4 @@\n-        var args = new ArrayList<String>();\n-        args.add(\"--output\");\n-        args.add(appImageLayout.runtimeDirectory().toString());\n-        args.addAll(jlinkCmdLine);\n-\n-        StringWriter writer = new StringWriter();\n-        PrintWriter pw = new PrintWriter(writer);\n-\n-        int retVal = LazyLoad.JLINK_TOOL.run(pw, pw, args.toArray(String[]::new));\n-        String jlinkOut = writer.toString();\n-\n-        args.add(0, \"jlink\");\n-        Log.verbose(args, List.of(jlinkOut), retVal, -1);\n-        if (retVal != 0) {\n-            throw new JPackageException(I18N.format(\"error.jlink.failed\", jlinkOut));\n-        }\n+        toRunnable(Executor.of()\n+                .toolProvider(LazyLoad.JLINK_TOOL)\n+                .args(\"--output\", appImageLayout.runtimeDirectory().toString())\n+                .args(jlinkCmdLine)::executeExpectSuccess).run();\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JLinkRuntimeBuilder.java","additions":9,"deletions":21,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.util.List;\n@@ -108,23 +107,0 @@\n-        public void verbose(List<String> strings,\n-                List<String> output, int returnCode, long pid) {\n-            if (verbose) {\n-                StringBuilder sb = new StringBuilder();\n-                sb.append(\"Command [PID: \");\n-                sb.append(pid);\n-                sb.append(\"]:\\n   \");\n-\n-                for (String s : strings) {\n-                    sb.append(\" \" + s);\n-                }\n-                verbose(sb.toString());\n-                if (output != null && !output.isEmpty()) {\n-                    sb = new StringBuilder(\"Output:\");\n-                    for (String s : output) {\n-                        sb.append(\"\\n    \" + s);\n-                    }\n-                    verbose(sb.toString());\n-                }\n-                verbose(\"Returned: \" + returnCode + \"\\n\");\n-            }\n-        }\n-\n@@ -180,5 +156,0 @@\n-\n-    public static void verbose(List<String> strings, List<String> out,\n-            int ret, long pid) {\n-       instance.get().verbose(strings, out, ret, pid);\n-    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Log.java","additions":1,"deletions":30,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+interface ObjectFactory extends ExecutorFactory, RetryExecutorFactory {\n+\n+    static ObjectFactory.Builder build() {\n+        return new Builder();\n+    }\n+\n+    static ObjectFactory.Builder build(ObjectFactory from) {\n+        return build().initFrom(from);\n+    }\n+\n+    static final class Builder {\n+        private Builder() {\n+        }\n+\n+        ObjectFactory create() {\n+            return CompositeProxy.build().invokeTunnel(CompositeProxyTunnel.INSTANCE).create(\n+                    ObjectFactory.class,\n+                    Optional.ofNullable(executorFactory).orElse(ExecutorFactory.DEFAULT),\n+                    Optional.ofNullable(retryExecutorFactory).orElse(RetryExecutorFactory.DEFAULT));\n+        }\n+\n+        Builder initFrom(ObjectFactory of) {\n+            Objects.requireNonNull(of);\n+            return executorFactory(of).retryExecutorFactory(of);\n+        }\n+\n+        Builder executorFactory(ExecutorFactory v) {\n+            executorFactory = v;\n+            return this;\n+        }\n+\n+        Builder retryExecutorFactory(RetryExecutorFactory v) {\n+            retryExecutorFactory = v;\n+            return this;\n+        }\n+\n+        private ExecutorFactory executorFactory;\n+        private RetryExecutorFactory retryExecutorFactory;\n+    }\n+\n+    static final ObjectFactory DEFAULT = build().create();\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ObjectFactory.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -1,136 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.function.Consumer;\n-import java.util.function.Supplier;\n-\n-public final class RetryExecutor {\n-    public RetryExecutor() {\n-        setMaxAttemptsCount(5);\n-        setAttemptTimeoutMillis(2 * 1000);\n-        setWriteOutputToFile(false);\n-    }\n-\n-    public RetryExecutor setMaxAttemptsCount(int v) {\n-        attempts = v;\n-        return this;\n-    }\n-\n-    public RetryExecutor setAttemptTimeoutMillis(int v) {\n-        timeoutMillis = v;\n-        return this;\n-    }\n-\n-    public RetryExecutor saveOutput(boolean v) {\n-        saveOutput = v;\n-        return this;\n-    }\n-\n-    public List<String> getOutput() {\n-        return output;\n-    }\n-\n-    public RetryExecutor setWriteOutputToFile(boolean v) {\n-        writeOutputToFile = v;\n-        return this;\n-    }\n-\n-    public RetryExecutor setExecutorInitializer(Consumer<Executor> v) {\n-        executorInitializer = v;\n-        return this;\n-    }\n-\n-    public void abort() {\n-        aborted = true;\n-    }\n-\n-    public boolean isAborted() {\n-        return aborted;\n-    }\n-\n-    static RetryExecutor retryOnKnownErrorMessage(String v) {\n-        RetryExecutor result = new RetryExecutor();\n-        return result.setExecutorInitializer(exec -> {\n-            exec.setOutputConsumer(output -> {\n-                if (!output.anyMatch(v::equals)) {\n-                    result.abort();\n-                }\n-            });\n-        });\n-    }\n-\n-    public void execute(String cmdline[]) throws IOException {\n-        executeLoop(() ->\n-                Executor.of(cmdline).setWriteOutputToFile(writeOutputToFile));\n-    }\n-\n-    public void execute(ProcessBuilder pb) throws IOException {\n-        executeLoop(() ->\n-                Executor.of(pb).setWriteOutputToFile(writeOutputToFile));\n-    }\n-\n-    private void executeLoop(Supplier<Executor> execSupplier) throws IOException {\n-        aborted = false;\n-        for (;;) {\n-            if (aborted) {\n-                break;\n-            }\n-\n-            try {\n-                Executor exec = execSupplier.get().saveOutput(saveOutput);\n-                if (executorInitializer != null) {\n-                    executorInitializer.accept(exec);\n-                }\n-                exec.executeExpectSuccess();\n-                if (saveOutput) {\n-                    output = exec.getOutput();\n-                }\n-                break;\n-            } catch (IOException ex) {\n-                if (aborted || (--attempts) <= 0) {\n-                    throw ex;\n-                }\n-            }\n-\n-            try {\n-                Thread.sleep(timeoutMillis);\n-            } catch (InterruptedException ex) {\n-                Log.verbose(ex);\n-                throw new RuntimeException(ex);\n-            }\n-        }\n-    }\n-\n-    private Consumer<Executor> executorInitializer;\n-    private boolean aborted;\n-    private int attempts;\n-    private int timeoutMillis;\n-    private boolean saveOutput;\n-    private List<String> output;\n-    private boolean writeOutputToFile;\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/RetryExecutor.java","additions":0,"deletions":136,"binary":false,"changes":136,"status":"deleted"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import jdk.jpackage.internal.util.RetryExecutor;\n+\n+@FunctionalInterface\n+interface RetryExecutorFactory {\n+\n+    <T, E extends Exception> RetryExecutor<T, E> retryExecutor(Class<? extends E> exceptionType);\n+\n+    static final RetryExecutorFactory DEFAULT = RetryExecutor::new;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/RetryExecutorFactory.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-public interface SystemEnvironment {\n+interface SystemEnvironment {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/SystemEnvironment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,1 @@\n-        boolean canUseTool[] = new boolean[1];\n+        boolean canUseTool = false;\n@@ -127,1 +127,1 @@\n-            canUseTool[0] = true;\n+            canUseTool = true;\n@@ -130,1 +130,1 @@\n-        String[] version = new String[1];\n+        String version = null;\n@@ -133,6 +133,6 @@\n-            Executor.of(cmdline.toArray(String[]::new)).setQuiet(true).setOutputConsumer(lines -> {\n-                if (versionParser != null && minimalVersion != null) {\n-                    version[0] = versionParser.apply(lines);\n-                    if (version[0] != null && minimalVersion.compareTo(version[0]) <= 0) {\n-                        canUseTool[0] = true;\n-                    }\n+            var result = Executor.of(cmdline).setQuiet(true).saveOutput().execute();\n+            var lines = result.content();\n+            if (versionParser != null && minimalVersion != null) {\n+                version = versionParser.apply(lines.stream());\n+                if (version != null && minimalVersion.compareTo(version) <= 0) {\n+                    canUseTool = true;\n@@ -140,1 +140,1 @@\n-            }).execute();\n+            }\n@@ -145,1 +145,1 @@\n-        if (canUseTool[0]) {\n+        if (canUseTool) {\n@@ -149,1 +149,1 @@\n-            return toolOldVersionErrorHandler.apply(toolPath, version[0]);\n+            return toolOldVersionErrorHandler.apply(toolPath, version);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ToolValidator.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+import jdk.jpackage.internal.Globals;\n@@ -59,1 +60,9 @@\n-    public static final class Provider implements ToolProvider {\n+    public record Provider(Supplier<CliBundlingEnvironment> bundlingEnvSupplier) implements ToolProvider {\n+\n+        public Provider {\n+            Objects.requireNonNull(bundlingEnvSupplier);\n+        }\n+\n+        public Provider() {\n+            this(Main::loadBundlingEnvironment);\n+        }\n@@ -68,1 +77,1 @@\n-            return Main.run(out, err, args);\n+            return Main.run(bundlingEnvSupplier, out, err, args);\n@@ -97,1 +106,17 @@\n-    public static int run(PrintWriter out, PrintWriter err, String... args) {\n+    static int run(PrintWriter out, PrintWriter err, String... args) {\n+        return run(Main::loadBundlingEnvironment, out, err, args);\n+    }\n+\n+    static int run(Supplier<CliBundlingEnvironment> bundlingEnvSupplier, PrintWriter out, PrintWriter err, String... args) {\n+        return Globals.main(() -> {\n+            return runWithGlobals(bundlingEnvSupplier, out, err, args);\n+        });\n+    }\n+\n+    private static int runWithGlobals(\n+            Supplier<CliBundlingEnvironment> bundlingEnvSupplier,\n+            PrintWriter out,\n+            PrintWriter err,\n+            String... args) {\n+\n+        Objects.requireNonNull(bundlingEnvSupplier);\n@@ -131,2 +156,1 @@\n-            final var bundlingEnv = ServiceLoader.load(CliBundlingEnvironment.class,\n-                    CliBundlingEnvironment.class.getClassLoader()).findFirst().orElseThrow();\n+            final var bundlingEnv = bundlingEnvSupplier.get();\n@@ -288,0 +312,6 @@\n+\n+    private static CliBundlingEnvironment loadBundlingEnvironment() {\n+        return ServiceLoader.load(\n+                CliBundlingEnvironment.class,\n+                CliBundlingEnvironment.class.getClassLoader()).findFirst().orElseThrow();\n+    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/Main.java","additions":36,"deletions":6,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,0 @@\n-error.jlink.failed=jlink failed with: {0}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Formats command line arguments.\n+ *\/\n+public final class CommandLineFormat {\n+\n+    public String format(List<String> cmdline) {\n+        return cmdline.stream().map(enquoter::applyTo).collect(Collectors.joining(\" \"));\n+    }\n+\n+    public static CommandLineFormat platform() {\n+        var format = new CommandLineFormat();\n+        format.enquoter = Enquoter.identity().setEnquotePredicate(Enquoter.QUOTE_IF_WHITESPACES).setQuoteChar('\\'');\n+        return format;\n+    }\n+\n+    private CommandLineFormat() {\n+    }\n+\n+    private Enquoter enquoter;\n+\n+    public static final Function<List<String>, String> DEFAULT = platform()::format;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/CommandLineFormat.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,1904 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import static java.util.stream.Collectors.joining;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.StringReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.IntPredicate;\n+import java.util.function.Predicate;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+import jdk.jpackage.internal.util.function.ThrowingRunnable;\n+\n+\/**\n+ * Runs commands and processes their stdout and stderr streams.\n+ * <p>\n+ * A command is either a subprocess represented by {@link ProcessBuilder} or a\n+ * tool provided by {@link ToolProvider}.\n+ * <p>\n+ * A command is executed synchronously, and the result of its execution is\n+ * stored in a {@link Result} instance which captures the exit code and any\n+ * saved output streams.\n+ * <p>\n+ * Depending on the configuration, it can save the entire output stream, only\n+ * the first line, or not save the output at all. Stdout and stderr streams can\n+ * be configured independently.\n+ * <p>\n+ * Output streams can be treated as either byte streams or character streams.\n+ *\n+ * <p>\n+ * The table below shows how different parameter combinations affect the content\n+ * written to streams returned by {@link #dumpStdout()} and\n+ * {@link #dumpStderr()} for subsequently executed tools, regardless of whether\n+ * their output streams are saved, or for subprocesses when the output streams\n+ * are saved:\n+ * <table border=\"1\">\n+ * <thead>\n+ * <tr>\n+ * <th><\/th>\n+ * <th>discardStdout(false) and discardStderr(false)<\/th>\n+ * <th>discardStdout(false) and discardStderr(true)<\/th>\n+ * <th>discardStdout(true) and discardStderr(false)<\/th>\n+ * <\/tr>\n+ * <\/thead> <tbody>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(true) and dumpOutput(true)<\/th>\n+ * <td>\n+ * <p>\n+ * dumpStdout(): STDOUT and STDERR interleaved\n+ * <p>\n+ * dumpStderr(): unchanged<\/td>\n+ * <td>\n+ * <p>\n+ * dumpStdout(): STDOUT\n+ * <p>\n+ * dumpStderr(): unchanged<\/td>\n+ * <td>\n+ * <p>\n+ * dumpStdout(): STDERR;\n+ * <p>\n+ * dumpStderr(): unchanged<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(false) and dumpOutput(true)<\/th>\n+ * <td>\n+ * <p>\n+ * dumpStdout(): STDOUT\n+ * <p>\n+ * dumpStderr(): STDERR<\/td>\n+ * <td>\n+ * <p>\n+ * dumpStdout(): STDOUT\n+ * <p>\n+ * dumpStderr(): unchanged<\/td>\n+ * <td>\n+ * <p>\n+ * dumpStdout(): unchanged\n+ * <p>\n+ * dumpStderr(): STDERR<\/td>\n+ * <\/tr>\n+ * <\/tbody>\n+ * <\/table>\n+ *\n+ * <p>\n+ * The table below shows how different parameter combinations affect the content\n+ * written to the native file descriptors associated with {@link System#out} and\n+ * {@link System#err} for subsequently executed subprocesses when the output\n+ * streams are not saved:\n+ * <table border=\"1\">\n+ * <thead>\n+ * <tr>\n+ * <th><\/th>\n+ * <th>discardStdout(false) and discardStderr(false)<\/th>\n+ * <th>discardStdout(false) and discardStderr(true)<\/th>\n+ * <th>discardStdout(true) and discardStderr(false)<\/th>\n+ * <\/tr>\n+ * <\/thead> <tbody>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(true) and dumpOutput(true)<\/th>\n+ * <td>\n+ * <p>\n+ * System.out: STDOUT and STDERR interleaved\n+ * <p>\n+ * System.err: unchanged<\/td>\n+ * <td>\n+ * <p>\n+ * System.out: STDOUT\n+ * <p>\n+ * System.err: unchanged<\/td>\n+ * <td>\n+ * <p>\n+ * System.out: STDERR;\n+ * <p>\n+ * The command's STDERR will be written to the stream referenced by\n+ * {@link #dumpStdout()} rather than to the underlying file descriptor\n+ * associated with the Java process's STDOUT\n+ * <p>\n+ * System.err: unchanged<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(false) and dumpOutput(true)<\/th>\n+ * <td>\n+ * <p>\n+ * System.out: STDOUT\n+ * <p>\n+ * System.err: STDERR<\/td>\n+ * <td>\n+ * <p>\n+ * System.out: STDOUT\n+ * <p>\n+ * System.err: unchanged<\/td>\n+ * <td>\n+ * <p>\n+ * System.out: unchanged\n+ * <p>\n+ * System.err: STDERR<\/td>\n+ * <\/tr>\n+ * <\/tbody>\n+ * <\/table>\n+ *\n+ * <p>\n+ * The table below shows how different parameter combinations affect the\n+ * properties of {@link Result} objects returned by\n+ * {@link #execute(ProcessBuilder, long)} or\n+ * {@link #execute(ToolProvider, long, String...)} when processing character\n+ * streams:\n+ * <table border=\"1\">\n+ * <thead>\n+ * <tr>\n+ * <th><\/th>\n+ * <th>saveOutput(true)<\/th>\n+ * <th>saveFirstLineOfOutput()<\/th>\n+ * <\/tr>\n+ * <\/thead> <tbody>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(true) and discardStdout(false) and\n+ * discardStderr(false)<\/th>\n+ * <td>\n+ * <p>\n+ * content(): STDOUT and STDERR interleaved\n+ * <p>\n+ * findStdout(): {@code Optional.empty()}\n+ * <p>\n+ * findStderr(): {@code Optional.empty()}<\/td>\n+ * <td>\n+ * <p>\n+ * content(): a single-item list containing the first line of interleaved STDOUT\n+ * and STDERR if the command produced any output; otherwise, an empty list\n+ * <p>\n+ * findStdout(): {@code Optional.empty()}\n+ * <p>\n+ * findStderr(): {@code Optional.empty()}<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(false) and discardStdout(false) and\n+ * discardStderr(false)<\/th>\n+ * <td>\n+ * <p>\n+ * content(): STDOUT followed by STDERR\n+ * <p>\n+ * stdout(): STDOUT\n+ * <p>\n+ * stderr(): STDERR<\/td>\n+ * <td>\n+ * <p>\n+ * content(): a list containing at most two items: the first line of STDOUT (if\n+ * the command produced any), followed by the first line of STDERR (if the\n+ * command produced any)\n+ * <p>\n+ * stdout(): The first line of STDOUT (if the command produced any); otherwise\n+ * an empty list\n+ * <p>\n+ * findStderr(): The first line of STDERR (if the command produced any);\n+ * otherwise an empty list\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(true) and discardStdout(false) and\n+ * discardStderr(true)<\/th>\n+ * <td>\n+ * <p>\n+ * content(): STDOUT\n+ * <p>\n+ * stdout(): The same as content()\n+ * <p>\n+ * findStderr(): {@code Optional.empty()}<\/td>\n+ * <td>\n+ * <p>\n+ * content(): The first line of STDOUT (if the command produced any); otherwise\n+ * an empty list\n+ * <p>\n+ * stdout(): The same as content()\n+ * <p>\n+ * findStderr(): {@code Optional.empty()}<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(false) and discardStdout(false) and\n+ * discardStderr(true)<\/th>\n+ * <td>\n+ * <p>\n+ * content(): STDOUT\n+ * <p>\n+ * stdout(): The same as content()\n+ * <p>\n+ * stderr(): an empty list<\/td>\n+ * <td>\n+ * <p>\n+ * content(): The first line of STDOUT (if the command produced any); otherwise\n+ * an empty list\n+ * <p>\n+ * stdout(): The same as content()\n+ * <p>\n+ * stderr(): an empty list<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(true) and discardStdout(true) and\n+ * discardStderr(false)<\/th>\n+ * <td>\n+ * <p>\n+ * content(): STDERR\n+ * <p>\n+ * stdout(): The same as content()\n+ * <p>\n+ * findStderr(): {@code Optional.empty()}<\/td>\n+ * <td>\n+ * <p>\n+ * content(): The first line of STDERR (if the command produced any); otherwise\n+ * an empty list\n+ * <p>\n+ * stdout(): The same as content()\n+ * <p>\n+ * findStderr(): {@code Optional.empty()}<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(false) and discardStdout(true) and\n+ * discardStderr(false)<\/th>\n+ * <td>\n+ * <p>\n+ * content(): STDERR\n+ * <p>\n+ * findStdout(): an empty list\n+ * <p>\n+ * stderr(): The same as content()<\/td>\n+ * <td>\n+ * <p>\n+ * content(): The first line of STDERR (if the command produced any); otherwise\n+ * an empty list\n+ * <p>\n+ * findStdout(): an empty list\n+ * <p>\n+ * stderr(): The same as content()<\/td>\n+ * <\/tr>\n+ * <\/tbody>\n+ * <\/table>\n+ * <p>\n+ * The table below shows how different parameter combinations affect the\n+ * properties of {@link Result} objects returned by\n+ * {@link #execute(ProcessBuilder, long)} or\n+ * {@link #execute(ToolProvider, long, String...)} when processing byte streams:\n+ * <table border=\"1\">\n+ * <thead>\n+ * <tr>\n+ * <th><\/th>\n+ * <th>saveOutput(true) or saveFirstLineOfOutput()<\/th>\n+ * <\/tr>\n+ * <\/thead> <tbody>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(true) and discardStdout(false) and\n+ * discardStderr(false)<\/th>\n+ * <td>\n+ * <p>\n+ * byteContent(): STDOUT and STDERR interleaved\n+ * <p>\n+ * findByteStdout(): {@code Optional.empty()}\n+ * <p>\n+ * findByteStderr(): {@code Optional.empty()}<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(false) and discardStdout(false) and\n+ * discardStderr(false)<\/th>\n+ * <td>\n+ * <p>\n+ * byteContent(): STDOUT followed by STDERR\n+ * <p>\n+ * byteStdout(): STDOUT\n+ * <p>\n+ * byteStderr(): STDERR<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(true) and discardStdout(false) and\n+ * discardStderr(true)<\/th>\n+ * <td>\n+ * <p>\n+ * byteContent(): STDOUT\n+ * <p>\n+ * byteStdout(): The same as byteContent()\n+ * <p>\n+ * findByteStderr(): {@code Optional.empty()}<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(false) and discardStdout(false) and\n+ * discardStderr(true)<\/th>\n+ * <td>\n+ * <p>\n+ * byteContent(): STDOUT\n+ * <p>\n+ * byteStdout(): The same as byteContent()\n+ * <p>\n+ * byteStderr(): an empty array<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(true) and discardStdout(true) and\n+ * discardStderr(false)<\/th>\n+ * <td>\n+ * <p>\n+ * byteContent(): STDERR\n+ * <p>\n+ * byteStdout(): The same as byteContent()\n+ * <p>\n+ * findByteStderr(): {@code Optional.empty()}<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(false) and discardStdout(true) and\n+ * discardStderr(false)<\/th>\n+ * <td>\n+ * <p>\n+ * byteContent(): STDERR\n+ * <p>\n+ * findByteStdout(): an empty array\n+ * <p>\n+ * byteStderr(): The same as byteContent()<\/td>\n+ * <\/tr>\n+ * <\/tbody>\n+ * <\/table>\n+ *\/\n+public final class CommandOutputControl {\n+\n+    public CommandOutputControl() {\n+        outputStreamsControl = new OutputStreamsControl();\n+    }\n+\n+    private CommandOutputControl(CommandOutputControl other) {\n+        flags = other.flags;\n+        outputStreamsControl = other.outputStreamsControl.copy();\n+        dumpStdout = other.dumpStdout;\n+        dumpStderr = other.dumpStderr;\n+        charset = other.charset;\n+        processListener = other.processListener;\n+    }\n+\n+    \/**\n+     * Specifies whether the full output produced by commands subsequently executed\n+     * by this object will be saved.\n+     * <p>\n+     * If {@code v} is {@code true}, both stdout and stderr streams will be saved;\n+     * otherwise, they will not be saved.\n+     * <p>\n+     * This setting is mutually exclusive with {@link #saveFirstLineOfOutput()}.\n+     *\n+     * @param v {@code true} to save the full stdout and stderr streams;\n+     *          {@code false} otherwise\n+     * @return this\n+     *\/\n+    public CommandOutputControl saveOutput(boolean v) {\n+        return setOutputControl(v, OutputControlOption.SAVE_ALL);\n+    }\n+\n+    \/**\n+     * Returns whether this object will save the complete output of commands\n+     * subsequently executed.\n+     *\n+     * @return {@code true} if this object will save the full output of commands it\n+     *         executes subsequently; {@code false} otherwise\n+     *\/\n+    public boolean isSaveOutput() {\n+        return outputStreamsControl.stdout().saveAll();\n+    }\n+\n+    \/**\n+     * Specifies whether the first line of the output, combined from the stdout and\n+     * stderr streams of commands subsequently executed by this object, will be\n+     * saved.\n+     * <p>\n+     * This setting is mutually exclusive with {@link #saveOutput(boolean)}.\n+     *\n+     * @return this\n+     *\/\n+    public CommandOutputControl saveFirstLineOfOutput() {\n+        return setOutputControl(true, OutputControlOption.SAVE_FIRST_LINE);\n+    }\n+\n+    \/**\n+     * Returns whether this object will save the first line of the output of\n+     * commands subsequently executed.\n+     *\n+     * @return {@code true} if this object will save the first line of the output of\n+     *         commands it executes subsequently; {@code false} otherwise\n+     *\/\n+    public boolean isSaveFirstLineOfOutput() {\n+        return outputStreamsControl.stdout().saveFirstLine();\n+    }\n+\n+    \/**\n+     * Specifies whether this object will dump the output streams from\n+     * subsequently executed commands into the streams returned by\n+     * {@link #dumpStdout()} and {@link #dumpStdout()} methods respectively.\n+     * <p>\n+     * If this object is configured to redirect stderr of subsequently executed\n+     * commands into their stdout ({@code redirectStderr(true)}), their output\n+     * streams will be dumped into the stream returned by {@code dumpStdout()}\n+     * method. Otherwise, their stdout and stderr streams will be dumped into the\n+     * stream returned by {@code dumpStdout()} and {@code dumpStderr()} methods\n+     * respectively.\n+     *\n+     * @param v if output streams from subsequently executed commands will be\n+     *          dumped into streams returned by {@code dumpStdout()} and\n+     *          {@code dumpStderr()} methods respectively\n+     *\n+     * @return this\n+     *\n+     * @see #redirectStderr(boolean)\n+     * @see #dumpStdout()\n+     * @see #dumpStderr()\n+     *\/\n+    public CommandOutputControl dumpOutput(boolean v) {\n+        setFlag(Flag.DUMP, v);\n+        return setOutputControl(v, OutputControlOption.DUMP);\n+    }\n+\n+    \/**\n+     * Returns the value passed in the last call of {@link #dumpOutput(boolean)}\n+     * method on this object, or {@code false} if the method has not been called.\n+     *\n+     * @return the value passed in the last call of {@link #dumpOutput(boolean)}\n+     *\/\n+    public boolean isDumpOutput() {\n+        return Flag.DUMP.isSet(flags);\n+    }\n+\n+    \/**\n+     * Specifies whether this object will treat output streams of subsequently\n+     * executed commands as byte streams rather than character streams.\n+     *\n+     * @param v {@code true} if this object will treat the output streams of\n+     *          subsequently executed commands as byte streams, and {@code false}\n+     *          otherwise\n+     *\n+     * @return this\n+     *\/\n+    public CommandOutputControl binaryOutput(boolean v) {\n+        return setFlag(Flag.BINARY_OUTPUT, v);\n+    }\n+\n+    \/**\n+     * Returns the value passed in the last call of {@link #binaryOutput(boolean)}\n+     * method on this object, or {@code false} if the method has not been called.\n+     *\n+     * @return the value passed in the last call of {@link #binaryOutput(boolean)}\n+     *\/\n+    public boolean isBinaryOutput() {\n+        return Flag.BINARY_OUTPUT.isSet(flags);\n+    }\n+\n+    \/**\n+     * Sets character encoding that will be applied to the stdout and the stderr\n+     * streams of commands (subprocesses and {@code ToolProvider}-s) subsequently\n+     * executed by this object. The default encoding is {@code UTF-8}.\n+     * <p>\n+     * The value will be ignored if this object is configured for byte output\n+     * streams.\n+     *\n+     * @param v character encoding for output streams of subsequently executed\n+     *          commands\n+     *\n+     * @see #binaryOutput(boolean)\n+     *\n+     * @return this\n+     *\/\n+    public CommandOutputControl charset(Charset v) {\n+        charset = v;\n+        return this;\n+    }\n+\n+    \/**\n+     * Returns the value passed in the last call of\n+     * {@link #charset(Charset)} method on this object, or\n+     * {@link StandardCharsets#UTF_8} if the method has not been called.\n+     *\n+     * @return the character encoding that will be applied to the stdout and stderr\n+     *         streams of commands subsequently executed by this object\n+     *\/\n+    public Charset charset() {\n+        return Optional.ofNullable(charset).orElse(StandardCharsets.UTF_8);\n+    }\n+\n+    \/**\n+     * Specifies whether the stderr stream will be redirected into the stdout stream\n+     * for commands subsequently executed by this object.\n+     *\n+     * @see ProcessBuilder#redirectErrorStream(boolean)\n+     *\n+     * @param v {@code true} if the stderr stream of commands subsequently executed\n+     *          by this object will be redirected into the stdout stream;\n+     *          {@code false} otherwise\n+     *\n+     * @return this\n+     *\/\n+    public CommandOutputControl redirectStderr(boolean v) {\n+        return setFlag(Flag.REDIRECT_STDERR, v);\n+    }\n+\n+    \/**\n+     * Returns the value passed in the last call of {@link #redirectStderr(boolean)}\n+     * method on this object, or {@code false} if the method has not been called.\n+     *\n+     * @return the value passed in the last call of {@link #redirectStderr(boolean)}\n+     *\/\n+    public boolean isRedirectStderr() {\n+        return Flag.REDIRECT_STDERR.isSet(flags);\n+    }\n+\n+    \/**\n+     * Specifies whether stderr and stdout streams for subprocesses subsequently\n+     * executed by this object will be stored in files.\n+     * <p>\n+     * By default, if an output stream of a subprocess is configured for saving,\n+     * this object will retrieve the content using {@link Process#getInputStream()}\n+     * function for stdout and {@link Process#getErrorStream()} function for stderr.\n+     * However, these functions don't always work correctly due to a\n+     * <a href=\"https:\/\/bugs.openjdk.org\/browse\/JDK-8236825\">JDK-8236825<\/a> bug\n+     * still reproducible on macOS JDK26. The alternative way to get the content of\n+     * output streams of a subprocess is to redirect them into files and read these\n+     * files when the subprocess terminates.\n+     * <p>\n+     * It will use {@code Files.createTempFile(\"jpackageOutputTempFile\", \".tmp\")} to\n+     * create a file for each subprocess's output stream configured for saving. All\n+     * created files will be automatically deleted at the exit of\n+     * {@link #execute(ProcessBuilder, long)} method.\n+     * <p>\n+     * Doesn't apply to executing {@code ToolProvider}-s.\n+     * <p>\n+     * Storing output streams in files takes longer than managing them in memory and\n+     * should be avoided if possible.\n+     *\n+     * @param v {@code true} if this object will use files to store saved output\n+     *          streams of subsequently executed subprocesses; {@code false}\n+     *          otherwise\n+     * @return this\n+     *\/\n+    public CommandOutputControl storeOutputInFiles(boolean v) {\n+        return setFlag(Flag.STORE_OUTPUT_IN_FILES, v);\n+    }\n+\n+    \/**\n+     * Returns the value passed in the last call of {@link #storeOutputInFiles(boolean)}\n+     * method on this object, or {@code false} if the method has not been called.\n+     *\n+     * @return the value passed in the last call of {@link #storeOutputInFiles(boolean)}\n+     *\/\n+    public boolean isStoreOutputInFiles() {\n+        return Flag.STORE_OUTPUT_IN_FILES.isSet(flags);\n+    }\n+\n+    \/**\n+     * Specifies whether stdout streams from commands subsequently executed by this\n+     * object will be discarded.\n+     *\n+     * @param v {@code true} if this object will discard stdout streams from\n+     *          commands subsequently executed by this object; {@code false}\n+     *          otherwise\n+     * @return this\n+     *\/\n+    public CommandOutputControl discardStdout(boolean v) {\n+        setFlag(Flag.DISCARD_STDOUT, v);\n+        outputStreamsControl.stdout().discard(v);\n+        return this;\n+    }\n+\n+    \/**\n+     * Returns the value passed in the last call of {@link #discardStdout(boolean)}\n+     * method on this object, or {@code false} if the method has not been called.\n+     *\n+     * @return the value passed in the last call of {@link #discardStdout(boolean)}\n+     *\/\n+    public boolean isDiscardStdout() {\n+        return Flag.DISCARD_STDOUT.isSet(flags);\n+    }\n+\n+    \/**\n+     * Specifies whether stderr streams from commands subsequently executed by this\n+     * object will be discarded.\n+     *\n+     * @param v {@code true} if this object will discard stderr streams from\n+     *          commands subsequently executed by this object; {@code false}\n+     *          otherwise\n+     * @return this\n+     *\/\n+    public CommandOutputControl discardStderr(boolean v) {\n+        setFlag(Flag.DISCARD_STDERR, v);\n+        outputStreamsControl.stderr().discard(v);\n+        return this;\n+    }\n+\n+    \/**\n+     * Returns the value passed in the last call of {@link #discardStderr(boolean)}\n+     * method on this object, or {@code false} if the method has not been called.\n+     *\n+     * @return the value passed in the last call of {@link #discardStderr(boolean)}\n+     *\/\n+    public boolean isDiscardStderr() {\n+        return Flag.DISCARD_STDERR.isSet(flags);\n+    }\n+\n+    \/**\n+     * Specifies the stream where stdout streams from commands subsequently executed\n+     * by this object will be dumped.\n+     * <p>\n+     * If the {@code null} is specified and this object configuration is equivalent\n+     * to {@code dumpOutput(true).saveOutput(false).discardStdout(false)} the stdout\n+     * streams from commands subsequently executed by this object will be written\n+     * into the file descriptor associated with the {@code Systsem.out} stream. If\n+     * you want them to be written into the {@code Systsem.out} object, pass the\n+     * {@code Systsem.out} reference into this function.\n+     *\n+     * @param v the stream where stdout streams from commands subsequently executed\n+     *          by this object will be dumped; {@code null} permitted\n+     * @return this\n+     *\/\n+    public CommandOutputControl dumpStdout(PrintStream v) {\n+        dumpStdout = v;\n+        return this;\n+    }\n+\n+    \/**\n+     * Returns the value passed in the last call of {@link #dumpStdout(PrintStream)}\n+     * method on this object, or {@link System#out} if the method has not been\n+     * called.\n+     *\n+     * @return the stream where stdout streams from commands subsequently executed\n+     *         by this object will be dumped\n+     *\/\n+    public PrintStream dumpStdout() {\n+        return Optional.ofNullable(dumpStdout).orElse(System.out);\n+    }\n+\n+    \/**\n+     * Specifies the stream where stderr streams from commands subsequently executed\n+     * by this object will be dumped.\n+     * <p>\n+     * If the {@code null} is specified and this object configuration is equivalent\n+     * to\n+     * {@code dumpOutput(true).saveOutput(false).redirectStderr(false).discardStderr(false)}\n+     * the stderr streams from commands subsequently executed by this object will be\n+     * written into the file descriptor associated with the {@code Systsem.err}\n+     * stream. If you want them to be written into the {@code Systsem.err} object,\n+     * pass the {@code Systsem.err} reference into this function.\n+     *\n+     * @param v the stream where stderr streams from commands subsequently executed\n+     *          by this object will be dumped; {@code null} permitted\n+     * @return this\n+     *\/\n+    public CommandOutputControl dumpStderr(PrintStream v) {\n+        dumpStderr = v;\n+        return this;\n+    }\n+\n+    \/**\n+     * Returns the value passed in the last call of {@link #dumpStderr(PrintStream)}\n+     * method on this object, or {@link System#err} if the method has not been\n+     * called.\n+     *\n+     * @return the stream where stderr streams from commands subsequently executed\n+     *         by this object will be dumped\n+     *\/\n+    public PrintStream dumpStderr() {\n+        return Optional.ofNullable(dumpStderr).orElse(System.err);\n+    }\n+\n+    \/**\n+     * Sets the callback to be invoked when this object starts a subprocess from\n+     * subsequent {@link #execute(ProcessBuilder, long)} calls.\n+     *\n+     * <p>\n+     * This object maintains a single callback. Calling this method replaces any\n+     * previously set callback.\n+     *\n+     * <p>\n+     * The callback is invoked on the thread that calls\n+     * {@link #execute(ProcessBuilder, long)} after the subprocess's output streams\n+     * begin being pumped.\n+     *\n+     * @param v the callback for notifying a subprocess being started or\n+     *          {@code null}\n+     * @return this\n+     *\/\n+    public CommandOutputControl processListener(Consumer<Process> v) {\n+        processListener = v;\n+        return this;\n+    }\n+\n+    \/**\n+     * Returns an {@code Optional} wrapping the value passed in the last call of\n+     * {@link #processListener(Consumer)} method on this object, or an empty\n+     * {@code Optional} if the method has not been called or {@code null} was passed in the last call.\n+     *\n+     * @return an {@code Optional} wrapping the value passed in the last call of\n+     *         {@link #processListener(Consumer)}\n+     *\/\n+    public Optional<Consumer<Process>> processListener() {\n+        return Optional.ofNullable(processListener);\n+    }\n+\n+    \/**\n+     * Returns a deep copy of this object. Changes to the copy will not affect the\n+     * original.\n+     *\n+     * @return a deep copy of this object\n+     *\/\n+    public CommandOutputControl copy() {\n+        return new CommandOutputControl(this);\n+    }\n+\n+    public interface ExecutableAttributes {\n+        List<String> commandLine();\n+    }\n+\n+    public sealed interface Executable {\n+\n+        ExecutableAttributes attributes();\n+\n+        Result execute() throws IOException, InterruptedException;\n+\n+        Result execute(long timeout, TimeUnit unit) throws IOException, InterruptedException;\n+    }\n+\n+    public record ProcessAttributes(Optional<Long> pid, List<String> commandLine) implements ExecutableAttributes {\n+        public ProcessAttributes {\n+            Objects.requireNonNull(pid);\n+            commandLine.forEach(Objects::requireNonNull);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return CommandLineFormat.DEFAULT.apply(commandLine());\n+        }\n+    }\n+\n+    public record ToolProviderAttributes(String name, List<String> args) implements ExecutableAttributes {\n+        public ToolProviderAttributes {\n+            Objects.requireNonNull(name);\n+            args.forEach(Objects::requireNonNull);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return CommandLineFormat.DEFAULT.apply(commandLine());\n+        }\n+\n+        @Override\n+        public List<String> commandLine() {\n+            return Stream.concat(Stream.of(name), args.stream()).toList();\n+        }\n+    }\n+\n+    public static ExecutableAttributes EMPTY_EXECUTABLE_ATTRIBUTES = new ExecutableAttributes() {\n+        @Override\n+        public String toString() {\n+            return \"<unknown>\";\n+        }\n+\n+        @Override\n+        public List<String> commandLine() {\n+            return List.of();\n+        }\n+    };\n+\n+    public Executable createExecutable(ToolProvider tp, String... args) {\n+        return new ToolProviderExecutable(tp, List.of(args), this);\n+    }\n+\n+    public Executable createExecutable(ProcessBuilder pb) {\n+        return new ProcessExecutable(pb, this);\n+    }\n+\n+    public record Result(\n+            Optional<Integer> exitCode,\n+            Optional<CommandOutput<List<String>>> output,\n+            Optional<CommandOutput<byte[]>> byteOutput,\n+            ExecutableAttributes execAttrs) {\n+\n+        public Result {\n+            Objects.requireNonNull(exitCode);\n+            Objects.requireNonNull(output);\n+            Objects.requireNonNull(byteOutput);\n+            Objects.requireNonNull(execAttrs);\n+        }\n+\n+        public Result(int exitCode) {\n+            this(Optional.of(exitCode), Optional.empty(), Optional.empty(), EMPTY_EXECUTABLE_ATTRIBUTES);\n+        }\n+\n+        public int getExitCode() {\n+            return exitCode.orElseThrow(() -> {\n+                return new IllegalStateException(\"Exit code is unavailable for timed-out command\");\n+            });\n+        }\n+\n+        public Result expectExitCode(int main, int... other) throws UnexpectedExitCodeException {\n+            return expectExitCode(v -> {\n+                return IntStream.concat(IntStream.of(main), IntStream.of(other)).boxed().anyMatch(Predicate.isEqual(v));\n+            });\n+        }\n+\n+        public Result expectExitCode(Collection<Integer> expected) throws UnexpectedExitCodeException {\n+            return expectExitCode(expected::contains);\n+        }\n+\n+        public Result expectExitCode(IntPredicate expected) throws UnexpectedExitCodeException {\n+            if (!expected.test(getExitCode())) {\n+                throw new UnexpectedExitCodeException(this);\n+            }\n+            return this;\n+        }\n+\n+        public UnexpectedResultException unexpected() {\n+            return new UnexpectedResultException(this);\n+        }\n+\n+        public UnexpectedResultException unexpected(String message) {\n+            return new UnexpectedResultException(this, message);\n+        }\n+\n+        public Optional<List<String>> findContent() {\n+            return output.flatMap(CommandOutput::combined);\n+        }\n+\n+        public Optional<List<String>> findStdout() {\n+            return output.flatMap(CommandOutput::stdout);\n+        }\n+\n+        public Optional<List<String>> findStderr() {\n+            return output.flatMap(CommandOutput::stderr);\n+        }\n+\n+        \/\/ For backward compatibility\n+        public List<String> getOutput() {\n+            return content();\n+        }\n+\n+        public List<String> content() {\n+            return findContent().orElseThrow();\n+        }\n+\n+        public List<String> stdout() {\n+            return findStdout().orElseThrow();\n+        }\n+\n+        public List<String> stderr() {\n+            return findStderr().orElseThrow();\n+        }\n+\n+        public Optional<byte[]> findByteContent() {\n+            return byteOutput.flatMap(CommandOutput::combined);\n+        }\n+\n+        public Optional<byte[]> findByteStdout() {\n+            return byteOutput.flatMap(CommandOutput::stdout);\n+        }\n+\n+        public Optional<byte[]> findByteStderr() {\n+            return byteOutput.flatMap(CommandOutput::stderr);\n+        }\n+\n+        public byte[] byteContent() {\n+            return findByteContent().orElseThrow();\n+        }\n+\n+        public byte[] byteStdout() {\n+            return findByteStdout().orElseThrow();\n+        }\n+\n+        public byte[] byteStderr() {\n+            return findByteStderr().orElseThrow();\n+        }\n+\n+        public Result toCharacterResult(Charset charset, boolean keepByteContent) throws IOException {\n+            Objects.requireNonNull(charset);\n+\n+            if (byteOutput.isEmpty()) {\n+                return this;\n+            }\n+\n+            var theByteOutput = byteOutput.get();\n+\n+            try {\n+                Optional<? extends Content<List<String>>> out;\n+                if (theByteOutput.content().isEmpty()) {\n+                    \/\/ The content is unavailable.\n+                    out = Optional.empty();\n+                } else if (theByteOutput.stdoutContentSize() == 0) {\n+                    \/\/ The content is available, but empty.\n+                    out = Optional.of(new StringListContent(List.of()));\n+                } else if (theByteOutput.interleaved()) {\n+                    \/\/ STDOUT and STDERR streams are interleaved.\n+                    out = theByteOutput.combined().map(data -> {\n+                        return toStringList(data, charset);\n+                    });\n+                } else {\n+                    \/\/ Non-empty STDOUT not interleaved with STDERR.\n+                    out = findByteStdout().map(data -> {\n+                        return toStringList(data, charset);\n+                    });\n+                }\n+\n+                var err = findByteStderr().map(data -> {\n+                    return toStringList(data, charset);\n+                });\n+\n+                var newOutput = combine(out, err, theByteOutput.interleaved);\n+\n+                return new Result(exitCode, Optional.of(newOutput), byteOutput.filter(_ -> keepByteContent), execAttrs);\n+            } catch (UncheckedIOException ex) {\n+                throw ex.getCause();\n+            }\n+        }\n+\n+        public Result copyWithExecutableAttributes(ExecutableAttributes execAttrs) {\n+            return new Result(exitCode, output, byteOutput, Objects.requireNonNull(execAttrs));\n+        }\n+\n+        private static StringListContent toStringList(byte[] data, Charset charset) {\n+            try (var bufReader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(data), charset))) {\n+                return new StringListContent(bufReader.lines().toList());\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+    }\n+\n+    public static sealed class UnexpectedResultException extends IOException {\n+\n+        private UnexpectedResultException(Result value, String message) {\n+            super(Objects.requireNonNull(message));\n+            this.value = Objects.requireNonNull(value);\n+        }\n+\n+        private UnexpectedResultException(Result value) {\n+            this(value, String.format(\"Unexpected result from executing the command %s\", value.execAttrs()));\n+        }\n+\n+        public Result getResult() {\n+            return value;\n+        }\n+\n+        private final transient Result value;\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    public static final class UnexpectedExitCodeException extends UnexpectedResultException {\n+\n+        public UnexpectedExitCodeException(Result value, String message) {\n+            super(value, message);\n+        }\n+\n+        public UnexpectedExitCodeException(Result value) {\n+            this(value, String.format(\"Unexpected exit code %d from executing the command %s\", value.getExitCode(), value.execAttrs()));\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    public String description() {\n+        var tokens = outputStreamsControl.descriptionTokens();\n+        if (isBinaryOutput()) {\n+            tokens.add(\"byte\");\n+        }\n+        if (redirectRetainedStderr()) {\n+            tokens.add(\"interleave\");\n+        }\n+        return String.join(\"; \", tokens);\n+    }\n+\n+    private Result execute(ProcessBuilder pb, long timeoutMillis)\n+            throws IOException, InterruptedException {\n+\n+        Objects.requireNonNull(pb);\n+\n+        var theCharset = charset();\n+\n+        configureProcessBuilder(pb);\n+\n+        var csc = new CachingStreamsConfig();\n+\n+        var process = pb.start();\n+\n+        BiConsumer<InputStream, PrintStream> gobbler = (in, ps) -> {\n+            try {\n+                if (isBinaryOutput()) {\n+                    try (in) {\n+                        in.transferTo(ps);\n+                    } catch (IOException ex) {\n+                        throw new UncheckedIOException(ex);\n+                    }\n+                } else {\n+                    try (var bufReader = new BufferedReader(new InputStreamReader(in, theCharset))) {\n+                        bufReader.lines().forEach(ps::println);\n+                    } catch (IOException ex) {\n+                        throw new UncheckedIOException(ex);\n+                    }\n+                }\n+            } finally {\n+                suppressIOException(ps::flush);\n+            }\n+        };\n+\n+        \/\/ Start fetching process output streams.\n+        \/\/ Do it before waiting for the process termination to avoid deadlocks.\n+\n+        final Optional<CompletableFuture<Void>> stdoutGobbler;\n+        if (mustReadOutputStream(pb.redirectOutput())) {\n+            stdoutGobbler = Optional.of(CompletableFuture.runAsync(() -> {\n+                gobbler.accept(process.getInputStream(), csc.out());\n+            }, gobblerExecutor));\n+        } else {\n+            stdoutGobbler = Optional.empty();\n+        }\n+\n+        final Optional<CompletableFuture<Void>> stderrGobbler;\n+        if (!pb.redirectErrorStream() && mustReadOutputStream(pb.redirectError())) {\n+            stderrGobbler = Optional.of(CompletableFuture.runAsync(() -> {\n+                gobbler.accept(process.getErrorStream(), csc.err());\n+            }, gobblerExecutor));\n+        } else {\n+            stderrGobbler = Optional.empty();\n+        }\n+\n+        processListener().ifPresent(c -> {\n+            c.accept(process);\n+        });\n+\n+        final Optional<Integer> exitCode;\n+        if (timeoutMillis < 0) {\n+            exitCode = Optional.of(process.waitFor());\n+        } else if (!process.waitFor(timeoutMillis, TimeUnit.MILLISECONDS)) {\n+            \/\/ Destroy the process and cancel the process output stream gobblers.\n+            process.destroy();\n+            for (var g : List.of(stdoutGobbler, stderrGobbler)) {\n+                g.ifPresent(future -> {\n+                    future.cancel(true);\n+                });\n+            }\n+            exitCode = Optional.empty();\n+        } else {\n+            exitCode = Optional.of(process.exitValue());\n+        }\n+\n+        try {\n+            if (isStoreOutputInFiles()) {\n+                var stdoutStorage = streamFileSink(pb.redirectOutput());\n+                var stderrStorage = streamFileSink(pb.redirectError());\n+\n+                Function<Path, InputStream> toInputStream = path -> {\n+                    try {\n+                        return Files.newInputStream(path);\n+                    } catch (IOException ex) {\n+                        throw new UncheckedIOException(ex);\n+                    }\n+                };\n+\n+                try {\n+                    stdoutStorage.map(toInputStream).ifPresent(in -> {\n+                        gobbler.accept(in, csc.out());\n+                    });\n+\n+                    stderrStorage.map(toInputStream).ifPresent(in -> {\n+                        gobbler.accept(in, csc.err());\n+                    });\n+                } finally {\n+                    Consumer<Path> silentDeleter = path -> {\n+                        suppressIOException(Files::delete, path);\n+                    };\n+\n+                    stdoutStorage.ifPresent(silentDeleter);\n+                    stderrStorage.ifPresent(silentDeleter);\n+                }\n+            } else {\n+                stdoutGobbler.ifPresent(CommandOutputControl::join);\n+                stderrGobbler.ifPresent(CommandOutputControl::join);\n+            }\n+        } catch (UncheckedIOException ex) {\n+            throw ex.getCause();\n+        }\n+\n+        return csc.createResult(exitCode, new ProcessAttributes(getPID(process), pb.command()));\n+    }\n+\n+    private Result execute(ToolProvider tp, long timeoutMillis, String... args)\n+            throws IOException, InterruptedException {\n+\n+        var csc = new CachingStreamsConfig();\n+\n+        Optional<Integer> exitCode;\n+        var out = csc.out();\n+        var err = csc.err();\n+        try {\n+            if (timeoutMillis < 0) {\n+                exitCode = Optional.of(tp.run(out, err, args));\n+            } else {\n+                var future = new CompletableFuture<Optional<Integer>>();\n+\n+                var workerThread = Thread.ofVirtual().start(() -> {\n+                    Optional<Integer> result = Optional.empty();\n+                    try {\n+                        result = Optional.of(tp.run(out, err, args));\n+                    } catch (Exception ex) {\n+                        future.completeExceptionally(ex);\n+                        return;\n+                    }\n+                    future.complete(result);\n+                });\n+\n+                try {\n+                    exitCode = future.get(timeoutMillis, TimeUnit.MILLISECONDS);\n+                } catch (ExecutionException ex) {\n+                    \/\/ Rethrow the cause (ex.getCause()) as a RuntimeException.\n+                    \/\/ If `ex.getCause()` returns an Error, ExceptionBox.unbox() will throw it.\n+                    throw ExceptionBox.toUnchecked(ExceptionBox.unbox(ex.getCause()));\n+                } catch (TimeoutException ex) {\n+                    workerThread.interrupt();\n+                    exitCode = Optional.empty();\n+                }\n+            }\n+        } finally {\n+            suppressIOException(out::flush);\n+            suppressIOException(err::flush);\n+        }\n+\n+        return csc.createResult(exitCode, new ToolProviderAttributes(tp.name(), List.of(args)));\n+    }\n+\n+    private CommandOutputControl setOutputControl(boolean set, OutputControlOption v) {\n+        outputStreamsControl.stdout().set(set, v);\n+        outputStreamsControl.stderr().set(set, v);\n+        return this;\n+    }\n+\n+    private CommandOutputControl setFlag(Flag flag, boolean v) {\n+        flags = flag.set(flags, v);\n+        return this;\n+    }\n+\n+    private Optional<Path> streamFileSink(ProcessBuilder.Redirect redirect) {\n+        return Optional.of(redirect)\n+                .filter(Predicate.isEqual(ProcessBuilder.Redirect.DISCARD).negate())\n+                .map(ProcessBuilder.Redirect::file)\n+                .map(File::toPath);\n+    }\n+\n+    private void configureProcessBuilder(ProcessBuilder pb) throws IOException {\n+\n+        var stdoutRedirect = outputStreamsControl.stdout().asProcessBuilderRedirect();\n+        var stderrRedirect = outputStreamsControl.stderr().asProcessBuilderRedirect();\n+\n+        if (!stdoutRedirect.equals(stderrRedirect) && Stream.of(\n+                stdoutRedirect,\n+                stderrRedirect\n+        ).noneMatch(Predicate.isEqual(ProcessBuilder.Redirect.DISCARD)) && redirectRetainedStderr()) {\n+            throw new IllegalStateException(String.format(\n+                    \"Can't redirect stderr into stdout because they have different redirects: stdout=%s; stderr=%s\",\n+                    stdoutRedirect, stderrRedirect));\n+        }\n+\n+        pb.redirectErrorStream(redirectRetainedStderr());\n+        if (replaceStdoutWithStderr()) {\n+            if (stderrRedirect.equals(ProcessBuilder.Redirect.INHERIT)) {\n+                stderrRedirect = ProcessBuilder.Redirect.PIPE;\n+            }\n+            pb.redirectErrorStream(false);\n+        }\n+\n+        stdoutRedirect = mapRedirect(stdoutRedirect);\n+        stderrRedirect = mapRedirect(stderrRedirect);\n+\n+        if (dumpStdout != null && stdoutRedirect.equals(ProcessBuilder.Redirect.INHERIT)) {\n+            stdoutRedirect = ProcessBuilder.Redirect.PIPE;\n+        }\n+\n+        if (dumpStderr != null && stderrRedirect.equals(ProcessBuilder.Redirect.INHERIT)) {\n+            stderrRedirect = ProcessBuilder.Redirect.PIPE;\n+        }\n+\n+        pb.redirectOutput(stdoutRedirect);\n+        pb.redirectError(stderrRedirect);\n+    }\n+\n+    private ProcessBuilder.Redirect mapRedirect(ProcessBuilder.Redirect redirect) throws IOException {\n+        if (isStoreOutputInFiles() && redirect.equals(ProcessBuilder.Redirect.PIPE)) {\n+            var sink = Files.createTempFile(\"jpackageOutputTempFile\", \".tmp\");\n+            return ProcessBuilder.Redirect.to(sink.toFile());\n+        } else {\n+            return redirect;\n+        }\n+    }\n+\n+    \/**\n+     * Returns {@code true} if STDERR is not discarded and will be redirected to STDOUT, and {@code false} otherwise.\n+     *\/\n+    private boolean redirectRetainedStderr() {\n+        return isRedirectStderr() && !outputStreamsControl.stderr().discard();\n+    }\n+\n+    \/**\n+     * Returns {@code true} if STDERR will replace STDOUT, and {@code false} otherwise.\n+     * <p>\n+     * STDERR will replace STDOUT if it is redirected and not discarded, and if STDOUT is discarded.\n+     *\/\n+    private boolean replaceStdoutWithStderr() {\n+        return redirectRetainedStderr() && outputStreamsControl.stdout().discard();\n+    }\n+\n+    private static <T> T join(CompletableFuture<T> future, T cancelledValue) {\n+        Objects.requireNonNull(future);\n+        try {\n+            return future.join();\n+        } catch (CancellationException ex) {\n+            return cancelledValue;\n+        } catch (CompletionException ex) {\n+            switch (ExceptionBox.unbox(ex.getCause())) {\n+                case IOException cause -> {\n+                    throw new UncheckedIOException(cause);\n+                }\n+                case UncheckedIOException cause -> {\n+                    throw cause;\n+                }\n+                case Exception cause -> {\n+                    throw ExceptionBox.toUnchecked(cause);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void join(CompletableFuture<Void> future) {\n+        join(future, null);\n+    }\n+\n+    private static boolean mustReadOutputStream(ProcessBuilder.Redirect redirect) {\n+        return redirect.equals(ProcessBuilder.Redirect.PIPE);\n+    }\n+\n+    private static Optional<List<String>> read(OutputControl outputControl, CachingPrintStream cps) throws IOException {\n+        final var bufferAsString = cps.bufferContents();\n+        try (final var bufReader = new BufferedReader(new StringReader(bufferAsString.orElse(\"\")))) {\n+            if (outputControl.saveFirstLine()) {\n+                return Optional.of(bufReader.lines().findFirst().map(List::of).orElseGet(List::of));\n+            } else if (outputControl.saveAll()) {\n+                return Optional.of(bufReader.lines().toList());\n+            } else {\n+                return Optional.empty();\n+            }\n+        } catch (UncheckedIOException ex) {\n+            throw ex.getCause();\n+        }\n+    }\n+\n+    private static Optional<byte[]> readBinary(OutputControl outputControl, CachingPrintStream cps) {\n+        if (outputControl.save()) {\n+            return cps.buf().map(ByteArrayOutputStream::toByteArray).or(() -> {\n+                return Optional.of(new byte[0]);\n+            });\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static <T> CommandOutput<T> combine(\n+            Optional<? extends Content<T>> out,\n+            Optional<? extends Content<T>> err,\n+            boolean interleaved) {\n+\n+        if (out.isEmpty() && err.isEmpty()) {\n+            return CommandOutput.empty();\n+        } else if (out.isEmpty()) {\n+            \/\/ This branch is unreachable because it is impossible to make it save stderr without saving stdout.\n+            \/\/ If streams are configured for saving and stdout is discarded,\n+            \/\/ its saved contents will be an Optional instance wrapping an empty content, not an empty Optional.\n+            throw ExceptionBox.reachedUnreachable();\n+        } else if (err.isEmpty()) {\n+            return new CommandOutput<>(out, Integer.MAX_VALUE, interleaved);\n+        } else {\n+            final var combined = out.get().append(err.get());\n+            return new CommandOutput<>(Optional.of(combined), out.orElseThrow().size(), interleaved);\n+        }\n+    }\n+\n+    private static PrintStream nullPrintStream() {\n+        return new PrintStream(OutputStream.nullOutputStream());\n+    }\n+\n+    private sealed interface Content<T> {\n+        T data();\n+        int size();\n+        Content<T> slice(int from, int to);\n+        Content<T> append(Content<T> other);\n+    }\n+\n+    private record StringListContent(List<String> data) implements Content<List<String>> {\n+        StringListContent {\n+            Objects.requireNonNull(data);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return data.size();\n+        }\n+\n+        @Override\n+        public StringListContent slice(int from, int to) {\n+            return new StringListContent(data.subList(from, to));\n+        }\n+\n+        @Override\n+        public StringListContent append(Content<List<String>> other) {\n+            return new StringListContent(Stream.of(data, other.data()).flatMap(List::stream).toList());\n+        }\n+    }\n+\n+    private record ByteContent(byte[] data) implements Content<byte[]> {\n+        ByteContent {\n+            Objects.requireNonNull(data);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return data.length;\n+        }\n+\n+        @Override\n+        public ByteContent slice(int from, int to) {\n+            return new ByteContent(Arrays.copyOfRange(data, from, to));\n+        }\n+\n+        @Override\n+        public ByteContent append(Content<byte[]> other) {\n+            byte[] combined = new byte[size() + other.size()];\n+            System.arraycopy(data, 0, combined, 0, data.length);\n+            System.arraycopy(other.data(), 0, combined, data.length, other.size());\n+            return new ByteContent(combined);\n+        }\n+    }\n+\n+    private record OutputStreamsControl(OutputControl stdout, OutputControl stderr) {\n+        OutputStreamsControl {\n+            Objects.requireNonNull(stdout);\n+            Objects.requireNonNull(stderr);\n+        }\n+\n+        OutputStreamsControl() {\n+            this(new OutputControl(), new OutputControl());\n+        }\n+\n+        OutputStreamsControl copy() {\n+            return new OutputStreamsControl(stdout.copy(), stderr.copy());\n+        }\n+\n+        List<String> descriptionTokens() {\n+            final List<String> tokens = new ArrayList<>();\n+            if (stdout.save()) { \/\/ Save flags are the same for stdout and stderr, checking stdout is sufficient.\n+                streamsLabel(\"save \", true).ifPresent(tokens::add);\n+            }\n+            if (stdout.dump() || stderr.dump()) {\n+                streamsLabel(\"echo \", true).ifPresent(tokens::add);\n+            }\n+            streamsLabel(\"discard \", false).ifPresent(tokens::add);\n+            if (tokens.isEmpty()) {\n+                \/\/ Unreachable because there is always at least one token in the description.\n+                throw ExceptionBox.reachedUnreachable();\n+            } else {\n+                return tokens;\n+            }\n+        }\n+\n+        private Optional<String> streamsLabel(String prefix, boolean negate) {\n+            Objects.requireNonNull(prefix);\n+            final var str = Stream.of(stdoutLabel(negate), stderrLabel(negate))\n+                    .filter(Optional::isPresent)\n+                    .map(Optional::orElseThrow)\n+                    .collect(joining(\"+\"));\n+            if (str.isEmpty()) {\n+                return Optional.empty();\n+            } else {\n+                return Optional.of(prefix + str);\n+            }\n+        }\n+\n+        private Optional<String> stdoutLabel(boolean negate) {\n+            if ((stdout.discard() && !negate) || (!stdout.discard() && negate)) {\n+                return Optional.of(\"out\");\n+            } else {\n+                return Optional.empty();\n+            }\n+        }\n+\n+        private Optional<String> stderrLabel(boolean negate) {\n+            if ((stderr.discard() && !negate) || (!stderr.discard() && negate)) {\n+                return Optional.of(\"err\");\n+            } else {\n+                return Optional.empty();\n+            }\n+        }\n+    }\n+\n+    private record CachingPrintStream(PrintStream ps, Optional<ByteArrayOutputStream> buf) {\n+        CachingPrintStream {\n+            Objects.requireNonNull(ps);\n+            Objects.requireNonNull(buf);\n+        }\n+\n+        Optional<String> bufferContents() {\n+            return buf.map(ByteArrayOutputStream::toString);\n+        }\n+\n+        static Builder build(Charset charset) {\n+            return new Builder(charset);\n+        }\n+\n+        static final class Builder {\n+\n+            private Builder(Charset charset) {\n+                this.charset = Objects.requireNonNull(charset);\n+            }\n+\n+            Builder save(boolean v) {\n+                save = v;\n+                return this;\n+            }\n+\n+            Builder discard(boolean v) {\n+                discard = v;\n+                return this;\n+            }\n+\n+            Builder dumpStream(PrintStream v) {\n+                dumpStream = v;\n+                return this;\n+            }\n+\n+            Builder buffer(ByteArrayOutputStream v) {\n+                externalBuffer = v;\n+                return this;\n+            }\n+\n+            CachingPrintStream create() {\n+                final Optional<ByteArrayOutputStream> buf;\n+                if (save && !discard) {\n+                    buf = Optional.ofNullable(externalBuffer).or(() -> {\n+                        return Optional.of(new ByteArrayOutputStream());\n+                    });\n+                } else {\n+                    buf = Optional.empty();\n+                }\n+\n+                final PrintStream ps;\n+                if (buf.isPresent() && dumpStream != null) {\n+                    ps = new PrintStream(new TeeOutputStream(List.of(buf.get(), dumpStream)), true, dumpStream.charset());\n+                } else if (!discard) {\n+                    ps = buf.map(in -> {\n+                        return new PrintStream(in, false, charset);\n+                    }).or(() -> {\n+                        return Optional.ofNullable(dumpStream);\n+                    }).orElseGet(CommandOutputControl::nullPrintStream);\n+                } else {\n+                    ps = nullPrintStream();\n+                }\n+\n+                return new CachingPrintStream(ps, buf);\n+            }\n+\n+            private boolean save;\n+            private boolean discard;\n+            private PrintStream dumpStream;\n+            private ByteArrayOutputStream externalBuffer;\n+            private final Charset charset;\n+        }\n+    }\n+\n+    private final class CachingStreamsConfig {\n+\n+        CachingStreamsConfig() {\n+            out = outputStreamsControl.stdout().buildCachingPrintStream(dumpStdout(), charset()).create();\n+            if (isRedirectStderr()) {\n+                var builder = outputStreamsControl.stderr().buildCachingPrintStream(dumpStdout(), charset());\n+                out.buf().ifPresent(builder::buffer);\n+                err = builder.create();\n+            } else {\n+                err = outputStreamsControl.stderr().buildCachingPrintStream(dumpStderr(), charset()).create();\n+            }\n+        }\n+\n+        Result createResult(Optional<Integer> exitCode, ExecutableAttributes execAttrs) throws IOException {\n+\n+            CommandOutput<List<String>> output;\n+            CommandOutput<byte[]> byteOutput;\n+\n+            CachingPrintStream effectiveOut;\n+            if (out.buf().isEmpty() && isRedirectStderr()) {\n+                effectiveOut = new CachingPrintStream(nullPrintStream(), err.buf());\n+            } else {\n+                effectiveOut = out;\n+            }\n+\n+            if (isBinaryOutput()) {\n+                Optional<ByteContent> outContent, errContent;\n+                if (isRedirectStderr()) {\n+                    outContent = readBinary(outputStreamsControl.stdout(), effectiveOut).map(ByteContent::new);\n+                    errContent = Optional.empty();\n+                } else {\n+                    outContent = readBinary(outputStreamsControl.stdout(), out).map(ByteContent::new);\n+                    errContent = readBinary(outputStreamsControl.stderr(), err).map(ByteContent::new);\n+                }\n+\n+                byteOutput = combine(outContent, errContent, redirectRetainedStderr());\n+                output = null;\n+            } else {\n+                Optional<StringListContent> outContent, errContent;\n+                if (isRedirectStderr()) {\n+                    outContent = read(outputStreamsControl.stdout(), effectiveOut).map(StringListContent::new);\n+                    errContent = Optional.empty();\n+                } else {\n+                    outContent = read(outputStreamsControl.stdout(), out).map(StringListContent::new);\n+                    errContent = read(outputStreamsControl.stderr(), err).map(StringListContent::new);\n+                }\n+\n+                output = combine(outContent, errContent, redirectRetainedStderr());\n+                byteOutput = null;\n+            }\n+\n+            return new Result(exitCode, Optional.ofNullable(output), Optional.ofNullable(byteOutput), execAttrs);\n+        }\n+\n+        PrintStream out() {\n+            return out.ps();\n+        }\n+\n+        PrintStream err() {\n+            return err.ps();\n+        }\n+\n+        private final CachingPrintStream out;\n+        private final CachingPrintStream err;\n+    }\n+\n+    private static final class OutputControl {\n+\n+        OutputControl() {\n+        }\n+\n+        private OutputControl(OutputControl other) {\n+            dump = other.dump;\n+            discard = other.discard;\n+            save = other.save;\n+        }\n+\n+        boolean save() {\n+            return save.isPresent();\n+        }\n+\n+        boolean saveAll() {\n+            return save.orElse(null) == OutputControlOption.SAVE_ALL;\n+        }\n+\n+        boolean saveFirstLine() {\n+            return save.orElse(null) == OutputControlOption.SAVE_FIRST_LINE;\n+        }\n+\n+        boolean discard() {\n+            return discard || (!dump && save.isEmpty());\n+        }\n+\n+        boolean dump() {\n+            return !discard && dump;\n+        }\n+\n+        OutputControl dump(boolean v) {\n+            this.dump = v;\n+            return this;\n+        }\n+\n+        OutputControl discard(boolean v) {\n+            this.discard = v;\n+            return this;\n+        }\n+\n+        OutputControl saveAll(boolean v) {\n+            if (v) {\n+                save = Optional.of(OutputControlOption.SAVE_ALL);\n+            } else {\n+                save = Optional.empty();\n+            }\n+            return this;\n+        }\n+\n+        OutputControl saveFirstLine(boolean v) {\n+            if (v) {\n+                save = Optional.of(OutputControlOption.SAVE_FIRST_LINE);\n+            } else {\n+                save = Optional.empty();\n+            }\n+            return this;\n+        }\n+\n+        OutputControl set(boolean set, OutputControlOption v) {\n+            switch (v) {\n+            case DUMP -> dump(set);\n+            case SAVE_ALL -> saveAll(set);\n+            case SAVE_FIRST_LINE -> saveFirstLine(set);\n+            }\n+            return this;\n+        }\n+\n+        OutputControl copy() {\n+            return new OutputControl(this);\n+        }\n+\n+        ProcessBuilder.Redirect asProcessBuilderRedirect() {\n+            if (discard()) {\n+                return ProcessBuilder.Redirect.DISCARD;\n+            } else if (dump && !save()) {\n+                return ProcessBuilder.Redirect.INHERIT;\n+            } else {\n+                return ProcessBuilder.Redirect.PIPE;\n+            }\n+        }\n+\n+        CachingPrintStream.Builder buildCachingPrintStream(PrintStream dumpStream, Charset charset) {\n+            Objects.requireNonNull(dumpStream);\n+            final var builder = CachingPrintStream.build(charset).save(save()).discard(discard());\n+            if (dump()) {\n+                builder.dumpStream(dumpStream);\n+            }\n+            return builder;\n+        }\n+\n+        private boolean dump;\n+        private boolean discard;\n+        private Optional<OutputControlOption> save = Optional.empty();\n+    }\n+\n+    private record CommandOutput<T>(Optional<? extends Content<T>> content, int stdoutContentSize, boolean interleaved) {\n+\n+        CommandOutput {\n+            Objects.requireNonNull(content);\n+            if (interleaved) {\n+                stdoutContentSize = content.map(Content::size).orElse(-1);\n+            }\n+        }\n+\n+        CommandOutput() {\n+            this(Optional.empty(), 0, false);\n+        }\n+\n+        Optional<T> combined() {\n+            return content.map(Content::data);\n+        }\n+\n+        \/**\n+         * Returns non-empty {@code Optional} if stdout is available and stdout and stderr are not interleaved.\n+         * @return stdout if it can be extracted from the combined output\n+         *\/\n+        Optional<T> stdout() {\n+            if (withoutExtractableStdout()) {\n+                return Optional.empty();\n+            }\n+\n+            final var theContent = content.orElseThrow();\n+            if (stdoutContentSize == theContent.size()) {\n+                return combined();\n+            } else {\n+                return Optional.of(theContent.slice(0, Integer.min(stdoutContentSize, theContent.size())).data());\n+            }\n+        }\n+\n+        \/**\n+         * Returns non-empty {@code Optional} if stderr is available and stdout and stderr are not interleaved.\n+         * @return stderr if it can be extracted from the combined output\n+         *\/\n+        Optional<T> stderr() {\n+            if (withoutExtractableStderr()) {\n+                return Optional.empty();\n+            } else if (stdoutContentSize <= 0) {\n+                return combined();\n+            } else {\n+                final var theContent = content.orElseThrow();\n+                return Optional.of(theContent.slice(stdoutContentSize, theContent.size()).data());\n+            }\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        static <T> CommandOutput<T> empty() {\n+            return (CommandOutput<T>)EMPTY;\n+        }\n+\n+        private boolean withoutExtractableStdout() {\n+            return interleaved || content.isEmpty() || stdoutContentSize < 0;\n+        }\n+\n+        private boolean withoutExtractableStderr() {\n+            return interleaved || content.isEmpty() || stdoutContentSize > content.get().size();\n+        }\n+\n+        private static final CommandOutput<?> EMPTY = new CommandOutput<>();\n+    }\n+\n+    private record ToolProviderExecutable(ToolProvider tp, List<String> args, CommandOutputControl coc) implements Executable {\n+\n+        ToolProviderExecutable {\n+            Objects.requireNonNull(tp);\n+            Objects.requireNonNull(args);\n+            Objects.requireNonNull(coc);\n+        }\n+\n+        @Override\n+        public Result execute() throws IOException, InterruptedException {\n+            return coc.execute(tp, -1, args.toArray(String[]::new));\n+        }\n+\n+        @Override\n+        public Result execute(long timeout, TimeUnit unit) throws IOException, InterruptedException {\n+            return coc.execute(tp, unit.toMillis(timeout), args.toArray(String[]::new));\n+        }\n+\n+        @Override\n+        public ExecutableAttributes attributes() {\n+            return new ToolProviderAttributes(tp.name(), args);\n+        }\n+    }\n+\n+    private record ProcessExecutable(ProcessBuilder pb, CommandOutputControl coc) implements Executable {\n+\n+        ProcessExecutable {\n+            Objects.requireNonNull(pb);\n+            Objects.requireNonNull(coc);\n+        }\n+\n+        @Override\n+        public Result execute() throws IOException, InterruptedException {\n+            return coc.execute(pb, -1L);\n+        }\n+\n+        @Override\n+        public Result execute(long timeout, TimeUnit unit) throws IOException, InterruptedException {\n+            return coc.execute(pb, unit.toMillis(timeout));\n+        }\n+\n+        @Override\n+        public ExecutableAttributes attributes() {\n+            return new ProcessAttributes(Optional.empty(), pb.command());\n+        }\n+    }\n+\n+    private static Optional<Long> getPID(Process p) {\n+        try {\n+            return Optional.of(p.pid());\n+        } catch (UnsupportedOperationException ex) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static void suppressIOException(ThrowingRunnable<IOException> r) {\n+        try {\n+            r.run();\n+        } catch (IOException ex) {}\n+    }\n+\n+    private static <T> void suppressIOException(ThrowingConsumer<T, IOException> c, T value) {\n+        suppressIOException(() -> {\n+            c.accept(value);\n+        });\n+    }\n+\n+    private int flags;\n+    private final OutputStreamsControl outputStreamsControl;\n+    private PrintStream dumpStdout;\n+    private PrintStream dumpStderr;\n+    private Charset charset;\n+    private Consumer<Process> processListener;\n+\n+    \/\/ Executor to run subprocess output stream gobblers.\n+    \/\/ Output stream gobblers should start fetching output streams ASAP after the process starts.\n+    \/\/ No pooling, no waiting.\n+    \/\/ CompletableFuture#runAsync() method starts an output stream gobbler.\n+    \/\/ If used with the default executor, it is known to make WiX3 light.exe create\n+    \/\/ a locked msi file when multiple jpackage tool providers are executed asynchronously.\n+    \/\/ The AsyncTest fails with cryptic java.nio.file.FileSystemException error:\n+    \/\/ jtreg_open_test_jdk_tools_jpackage_share_AsyncTest_java\\\\tmp\\\\jdk.jpackage8108811639097525318\\\\msi\\\\Foo-1.0.msi: The process cannot access the file because it is being used by another process.\n+    \/\/ The remedy for the problem is to use non-pooling executor to run subprocess output stream gobblers.\n+    private final java.util.concurrent.Executor gobblerExecutor = Executors.newVirtualThreadPerTaskExecutor();\n+\n+    private enum OutputControlOption {\n+        SAVE_ALL, SAVE_FIRST_LINE, DUMP\n+    }\n+\n+    private enum Flag {\n+        DUMP                    (0x01),\n+        REDIRECT_STDERR         (0x02),\n+        BINARY_OUTPUT           (0x04),\n+        STORE_OUTPUT_IN_FILES   (0x08),\n+        DISCARD_STDOUT          (0x10),\n+        DISCARD_STDERR          (0x20),\n+        ;\n+\n+        Flag(int value) {\n+            this.value = value;\n+        }\n+\n+        int set(int flags, boolean set) {\n+            if (set) {\n+                return flags | value;\n+            } else {\n+                return flags & ~value;\n+            }\n+        }\n+\n+        boolean isSet(int flags) {\n+            return (flags & value) != 0;\n+        }\n+\n+        private final int value;\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/CommandOutputControl.java","additions":1904,"deletions":0,"binary":false,"changes":1904,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Add quotes to the given string in a configurable way.\n+ *\/\n+public final class Enquoter {\n+\n+    private Enquoter() {\n+        setQuoteChar('\"');\n+    }\n+\n+    public static Enquoter identity() {\n+        return new Enquoter();\n+    }\n+\n+    public static Enquoter forPropertyValues() {\n+        return new Enquoter()\n+                .setEnquotePredicate(QUOTE_IF_WHITESPACES)\n+                .setEscaper(PREPEND_BACKSLASH);\n+    }\n+\n+    public static Enquoter forShellLiterals() {\n+        return forShellLiterals('\\'');\n+    }\n+\n+    public static Enquoter forShellLiterals(char quoteChar) {\n+        return new Enquoter()\n+                .setQuoteChar(quoteChar)\n+                .setEnquotePredicate(x -> true)\n+                .setEscaper(PREPEND_BACKSLASH);\n+    }\n+\n+    public String applyTo(String v) {\n+        if (!needQuotes.test(v)) {\n+            return v;\n+        } else {\n+            var buf = new StringBuilder();\n+            buf.appendCodePoint(beginQuoteChr);\n+            Optional.ofNullable(escaper).ifPresentOrElse(op -> {\n+                v.codePoints().forEachOrdered(chr -> {\n+                    if (chr == beginQuoteChr || chr == endQuoteChr) {\n+                        op.accept(chr, buf);\n+                    } else {\n+                        buf.appendCodePoint(chr);\n+                    }\n+                });\n+            }, () -> {\n+                buf.append(v);\n+            });\n+            buf.appendCodePoint(endQuoteChr);\n+            return buf.toString();\n+        }\n+    }\n+\n+    public Enquoter setQuoteChar(char chr) {\n+        beginQuoteChr = chr;\n+        endQuoteChr = chr;\n+        return this;\n+    }\n+\n+    public Enquoter setEscaper(BiConsumer<Integer, StringBuilder> v) {\n+        escaper = v;\n+        return this;\n+    }\n+\n+    public Enquoter setEnquotePredicate(Predicate<String> v) {\n+        needQuotes = v;\n+        return this;\n+    }\n+\n+    public static final Predicate<String> QUOTE_IF_WHITESPACES = new Predicate<String>() {\n+        @Override\n+        public boolean test(String t) {\n+            return pattern.matcher(t).find();\n+        }\n+        private final Pattern pattern = Pattern.compile(\"\\\\s\");\n+    };\n+\n+    public static final BiConsumer<Integer, StringBuilder> PREPEND_BACKSLASH = (chr, buf) -> {\n+        buf.append('\\\\');\n+        buf.appendCodePoint(chr);\n+    };\n+\n+    private int beginQuoteChr;\n+    private int endQuoteChr;\n+    private BiConsumer<Integer, StringBuilder> escaper;\n+    private Predicate<String> needQuotes = str -> false;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/Enquoter.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+\n+import java.time.Duration;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import jdk.jpackage.internal.util.function.ThrowingFunction;\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n+\n+public class RetryExecutor<T, E extends Exception> {\n+\n+    public RetryExecutor(Class<? extends E> exceptionType) {\n+        this.exceptionType = Objects.requireNonNull(exceptionType);\n+        setMaxAttemptsCount(5);\n+        setAttemptTimeout(2, TimeUnit.SECONDS);\n+    }\n+\n+    final public Class<? extends E> exceptionType() {\n+        return exceptionType;\n+    }\n+\n+    public RetryExecutor<T, E> setExecutable(ThrowingFunction<Context<RetryExecutor<T, E>>, T, E> v) {\n+        executable = v;\n+        return this;\n+    }\n+\n+    final public RetryExecutor<T, E> setExecutable(ThrowingSupplier<T, E> v) {\n+        if (v != null) {\n+            setExecutable(_ -> {\n+                return v.get();\n+            });\n+        } else {\n+            executable = null;\n+        }\n+        return this;\n+    }\n+\n+    public RetryExecutor<T, E> setMaxAttemptsCount(int v) {\n+        attempts = v;\n+        return this;\n+    }\n+\n+    final public RetryExecutor<T, E> setAttemptTimeout(long v, TimeUnit unit) {\n+        return setAttemptTimeout(Duration.of(v, unit.toChronoUnit()));\n+    }\n+\n+    public RetryExecutor<T, E> setAttemptTimeout(Duration v) {\n+        timeout = v;\n+        return this;\n+    }\n+\n+    public RetryExecutor<T, E> setExceptionMapper(Function<E, RuntimeException> v) {\n+        toUnchecked = v;\n+        return this;\n+    }\n+\n+    public RetryExecutor<T, E> setSleepFunction(Consumer<Duration> v) {\n+        sleepFunction = v;\n+        return this;\n+    }\n+\n+    final public RetryExecutor<T, E> mutate(Consumer<RetryExecutor<T, E>> mutator) {\n+        mutator.accept(this);\n+        return this;\n+    }\n+\n+    public T execute() throws E {\n+        var curExecutable = executable();\n+        T result = null;\n+        var attemptIter = new DefaultContext();\n+        while (attemptIter.hasNext()) {\n+            attemptIter.next();\n+            try {\n+                result = curExecutable.apply(attemptIter);\n+                break;\n+            } catch (Exception ex) {\n+                if (!exceptionType.isInstance(ex)) {\n+                    throw ExceptionBox.toUnchecked(ex);\n+                } else if (attemptIter.isLastAttempt()) {\n+                    \/\/ No more attempts left. This is fatal.\n+                    throw exceptionType.cast(ex);\n+                } else {\n+                    curExecutable = executable();\n+                }\n+            }\n+\n+            sleep();\n+        }\n+\n+        return result;\n+    }\n+\n+    final public T executeUnchecked() {\n+        try {\n+            return execute();\n+        } catch (Error | RuntimeException t) {\n+            throw t;\n+        } catch (Exception ex) {\n+            if (exceptionType.isInstance(ex)) {\n+                throw Optional.ofNullable(toUnchecked).orElse(ExceptionBox::toUnchecked).apply(exceptionType.cast(ex));\n+            } else {\n+                \/\/ Unreachable unless it is a direct subclass of Throwable,\n+                \/\/ which is not Error or Exception which should not happen.\n+                throw ExceptionBox.reachedUnreachable();\n+            }\n+        }\n+    }\n+\n+    public interface Context<T> {\n+        boolean isLastAttempt();\n+        int attempt();\n+        T executor();\n+    }\n+\n+    private final class DefaultContext implements Context<RetryExecutor<T, E>>, Iterator<Void> {\n+\n+        @Override\n+        public boolean isLastAttempt() {\n+            return !hasNext();\n+        }\n+\n+        @Override\n+        public int attempt() {\n+            return attempt;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return (attempts - attempt) > 1;\n+        }\n+\n+        @Override\n+        public Void next() {\n+            attempt++;\n+            return null;\n+        }\n+\n+        @Override\n+        public RetryExecutor<T, E> executor() {\n+            return RetryExecutor.this;\n+        }\n+\n+        private int attempt = -1;\n+    }\n+\n+    private ThrowingFunction<Context<RetryExecutor<T, E>>, T, E> executable() {\n+        return Optional.ofNullable(executable).orElseThrow(() -> {\n+            return new IllegalStateException(\"No executable\");\n+        });\n+    }\n+\n+    private void sleep() {\n+        Optional.ofNullable(timeout).ifPresent(Optional.ofNullable(sleepFunction).orElseGet(() -> {\n+            return toConsumer(Thread::sleep);\n+        }));\n+    }\n+\n+    private final Class<? extends E> exceptionType;\n+    private ThrowingFunction<Context<RetryExecutor<T, E>>, T, E> executable;\n+    private int attempts;\n+    private Duration timeout;\n+    private Function<E, RuntimeException> toUnchecked;\n+    private Consumer<Duration> sleepFunction;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/RetryExecutor.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import java.io.Closeable;\n+import java.io.Flushable;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.Objects;\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+\n+public final class TeeOutputStream extends OutputStream {\n+\n+    public TeeOutputStream(Iterable<OutputStream> items) {\n+        items.forEach(Objects::requireNonNull);\n+        this.items = items;\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+        for (final var item : items) {\n+            item.write(b);\n+        }\n+    }\n+\n+    @Override\n+    public void write(byte[] b) throws IOException {\n+        for (final var item : items) {\n+            item.write(b);\n+        }\n+    }\n+\n+    @Override\n+    public void write(byte[] b, int off, int len) throws IOException {\n+        for (final var item : items) {\n+            item.write(b, off, len);\n+        }\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+        forEach(Flushable::flush);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        forEach(Closeable::close);\n+    }\n+\n+    private void forEach(ThrowingConsumer<OutputStream, IOException> c) throws IOException {\n+        IOException firstEx = null;\n+        for (final var item : items) {\n+            try {\n+                c.accept(item);\n+            } catch (IOException e) {\n+                if (firstEx == null) {\n+                    firstEx = e;\n+                }\n+            }\n+        }\n+        if (firstEx != null) {\n+            throw firstEx;\n+        }\n+    }\n+\n+    private final Iterable<OutputStream> items;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/TeeOutputStream.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import jdk.jpackage.internal.model.Launcher;\n-import jdk.jpackage.internal.model.Application;\n@@ -39,0 +37,3 @@\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.util.Enquoter;\n","filename":"src\/jdk.jpackage\/unix\/classes\/jdk\/jpackage\/internal\/UnixLaunchersAsServices.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import jdk.jpackage.internal.util.Result;\n@@ -39,5 +38,7 @@\n-        super(build()\n-                .defaultOperation(CREATE_WIN_EXE)\n-                .bundler(CREATE_WIN_APP_IMAGE, WinBundlingEnvironment::createAppImage)\n-                .bundler(CREATE_WIN_EXE, LazyLoad::sysEnv, WinBundlingEnvironment::createExePackage)\n-                .bundler(CREATE_WIN_MSI, LazyLoad::sysEnv, WinBundlingEnvironment::createMsiPackage));\n+        super(build().mutate(builder -> {\n+            var sysEnv = runOnce(WinSystemEnvironment::create);\n+\n+            builder\n+            .bundler(CREATE_WIN_EXE, sysEnv, WinBundlingEnvironment::createExePackage)\n+            .bundler(CREATE_WIN_MSI, sysEnv, WinBundlingEnvironment::createMsiPackage);\n+        }).defaultOperation(CREATE_WIN_EXE).bundler(CREATE_WIN_APP_IMAGE, WinBundlingEnvironment::createAppImage));\n@@ -101,8 +102,0 @@\n-    private static final class LazyLoad {\n-\n-        static Result<WinSystemEnvironment> sysEnv() {\n-            return SYS_ENV;\n-        }\n-\n-        private static final Result<WinSystemEnvironment> SYS_ENV = WinSystemEnvironment.create();\n-    }\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinBundlingEnvironment.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -236,2 +236,2 @@\n-                        final var exec = Executor.of(toolPath.toString(), \"-?\").setQuiet(true).saveOutput(true);\n-                        final var exitCode = exec.execute();\n+                        final var result = Executor.of(toolPath.toString(), \"-?\").setQuiet(true).saveOutput(true).execute();\n+                        final var exitCode = result.getExitCode();\n@@ -239,1 +239,1 @@\n-                            final var output = exec.getOutput();\n+                            final var output = result.getOutput();\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixTool.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,401 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.test;\n-\n-import static java.util.stream.Collectors.joining;\n-import static java.util.stream.Collectors.toSet;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.junit.jupiter.api.Assertions.assertNull;\n-\n-import java.io.BufferedReader;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.PrintStream;\n-import java.io.PrintWriter;\n-import java.io.UncheckedIOException;\n-import java.nio.charset.Charset;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.function.Consumer;\n-import java.util.spi.ToolProvider;\n-import java.util.stream.Stream;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-public class ExecutorTest extends JUnitAdapter {\n-\n-    private record Command(List<String> stdout, List<String> stderr) {\n-        Command {\n-            stdout.forEach(Objects::requireNonNull);\n-            stderr.forEach(Objects::requireNonNull);\n-        }\n-\n-        List<String> asExecutable() {\n-            final List<String> commandline = new ArrayList<>();\n-            if (TKit.isWindows()) {\n-                commandline.addAll(List.of(\"cmd\", \"\/C\"));\n-            } else {\n-                commandline.addAll(List.of(\"sh\", \"-c\"));\n-            }\n-            commandline.add(Stream.concat(createEchoCommands(stdout),\n-                    createEchoCommands(stderr).map(v -> v + \">&2\")).collect(joining(\" && \")));\n-            return commandline;\n-        }\n-\n-        private static Stream<String> createEchoCommands(List<String> lines) {\n-            return lines.stream().map(line -> {\n-                if (TKit.isWindows()) {\n-                    return \"(echo \" + line + \")\";\n-                } else {\n-                    return \"echo \" + line;\n-                }\n-            });\n-        }\n-\n-        ToolProvider asToolProvider() {\n-            return new ToolProvider() {\n-\n-                @Override\n-                public int run(PrintWriter out, PrintWriter err, String... args) {\n-                    stdout.forEach(out::println);\n-                    stderr.forEach(err::println);\n-                    return 0;\n-                }\n-\n-                @Override\n-                public String name() {\n-                    return \"test\";\n-                }\n-            };\n-        }\n-    }\n-\n-    private enum OutputData {\n-        EMPTY(List.of()),\n-        ONE_LINE(List.of(\"Jupiter\")),\n-        MANY(List.of(\"Uranus\", \"Saturn\", \"Earth\"));\n-\n-        OutputData(List<String> data) {\n-            data.forEach(Objects::requireNonNull);\n-            this.data = data;\n-        }\n-\n-        final List<String> data;\n-    }\n-\n-    private record CommandSpec(OutputData stdout, OutputData stderr) {\n-        CommandSpec {\n-            Objects.requireNonNull(stdout);\n-            Objects.requireNonNull(stderr);\n-        }\n-\n-        Command command() {\n-            return new Command(stdout.data.stream().map(line -> {\n-                return \"stdout.\" + line;\n-            }).toList(), stderr.data.stream().map(line -> {\n-                return \"stderr.\" + line;\n-            }).toList());\n-        }\n-    }\n-\n-    public enum OutputControl {\n-        DUMP(Executor::dumpOutput),\n-        SAVE_ALL(Executor::saveOutput),\n-        SAVE_FIRST_LINE(Executor::saveFirstLineOfOutput),\n-        DISCARD_STDOUT(Executor::discardStdout),\n-        DISCARD_STDERR(Executor::discardStderr),\n-        ;\n-\n-        OutputControl(Consumer<Executor> configureExector) {\n-            this.configureExector = Objects.requireNonNull(configureExector);\n-        }\n-\n-        Executor applyTo(Executor exec) {\n-            configureExector.accept(exec);\n-            return exec;\n-        }\n-\n-        static List<Set<OutputControl>> variants() {\n-            final List<Set<OutputControl>> variants = new ArrayList<>();\n-            for (final var withDump : BOOLEAN_VALUES) {\n-                variants.addAll(Stream.of(\n-                        Set.<OutputControl>of(),\n-                        Set.of(SAVE_ALL),\n-                        Set.of(SAVE_FIRST_LINE),\n-                        Set.of(DISCARD_STDOUT),\n-                        Set.of(DISCARD_STDERR),\n-                        Set.of(SAVE_ALL, DISCARD_STDOUT),\n-                        Set.of(SAVE_FIRST_LINE, DISCARD_STDOUT),\n-                        Set.of(SAVE_ALL, DISCARD_STDERR),\n-                        Set.of(SAVE_FIRST_LINE, DISCARD_STDERR),\n-                        Set.of(SAVE_ALL, DISCARD_STDOUT, DISCARD_STDERR),\n-                        Set.of(SAVE_FIRST_LINE, DISCARD_STDOUT, DISCARD_STDERR)\n-                ).map(v -> {\n-                    if (withDump) {\n-                        return Stream.concat(Stream.of(DUMP), v.stream()).collect(toSet());\n-                    } else {\n-                        return v;\n-                    }\n-                }).toList());\n-            }\n-            return variants.stream().map(options -> {\n-                return options.stream().filter(o -> {\n-                    return o.configureExector != NOP;\n-                }).collect(toSet());\n-            }).distinct().toList();\n-        }\n-\n-        private final Consumer<Executor> configureExector;\n-\n-        static final Set<OutputControl> SAVE = Set.of(SAVE_ALL, SAVE_FIRST_LINE);\n-    }\n-\n-    public record OutputTestSpec(boolean toolProvider, Set<OutputControl> outputControl, CommandSpec commandSpec) {\n-        public OutputTestSpec {\n-            outputControl.forEach(Objects::requireNonNull);\n-            if (outputControl.containsAll(OutputControl.SAVE)) {\n-                throw new IllegalArgumentException();\n-            }\n-            Objects.requireNonNull(commandSpec);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            final List<String> tokens = new ArrayList<>();\n-\n-            if (toolProvider) {\n-                tokens.add(\"tool-provider\");\n-            }\n-\n-            tokens.add(\"output=\" + format(outputControl));\n-            tokens.add(\"command=\" + commandSpec);\n-\n-            return String.join(\",\", tokens.toArray(String[]::new));\n-        }\n-\n-        void test() {\n-            final var command = commandSpec.command();\n-            final var commandWithDiscardedStreams = discardStreams(command);\n-\n-            final Executor.Result[] result = new Executor.Result[1];\n-            final var outputCapture = OutputCapture.captureOutput(() -> {\n-                result[0] = createExecutor(command).executeWithoutExitCodeCheck();\n-            });\n-\n-            assertEquals(0, result[0].getExitCode());\n-\n-            \/\/ If we dump the subprocesses's output, and the command produced both STDOUT and STDERR,\n-            \/\/ then the captured STDOUT may contain interleaved command's STDOUT and STDERR,\n-            \/\/ not in sequential order (STDOUT followed by STDERR).\n-            \/\/ In this case don't check the contents of the captured command's STDOUT.\n-            if (toolProvider || outputCapture.outLines().isEmpty() || (command.stdout().isEmpty() || command.stderr().isEmpty())) {\n-                assertEquals(expectedCapturedSystemOut(commandWithDiscardedStreams), outputCapture.outLines());\n-            }\n-            assertEquals(expectedCapturedSystemErr(commandWithDiscardedStreams), outputCapture.errLines());\n-\n-            assertEquals(expectedResultStdout(commandWithDiscardedStreams), result[0].stdout().getOutput());\n-            assertEquals(expectedResultStderr(commandWithDiscardedStreams), result[0].stderr().getOutput());\n-\n-            if (!saveOutput()) {\n-                assertNull(result[0].getOutput());\n-            } else {\n-                assertNotNull(result[0].getOutput());\n-                final var allExpectedOutput = expectedCommandOutput(command);\n-                assertEquals(allExpectedOutput.isEmpty(), result[0].getOutput().isEmpty());\n-                if (!allExpectedOutput.isEmpty()) {\n-                    if (outputControl.contains(OutputControl.SAVE_ALL)) {\n-                        assertEquals(allExpectedOutput, result[0].getOutput());\n-                    } else if (outputControl.contains(OutputControl.SAVE_FIRST_LINE)) {\n-                        assertEquals(1, result[0].getOutput().size());\n-                        assertEquals(allExpectedOutput.getFirst(), result[0].getFirstLineOfOutput());\n-                    } else {\n-                        throw new UnsupportedOperationException();\n-                    }\n-                }\n-            }\n-        }\n-\n-        private boolean dumpOutput() {\n-            return outputControl.contains(OutputControl.DUMP);\n-        }\n-\n-        private boolean saveOutput() {\n-            return !Collections.disjoint(outputControl, OutputControl.SAVE);\n-        }\n-\n-        private boolean discardStdout() {\n-            return outputControl.contains(OutputControl.DISCARD_STDOUT);\n-        }\n-\n-        private boolean discardStderr() {\n-            return outputControl.contains(OutputControl.DISCARD_STDERR);\n-        }\n-\n-        private static String format(Set<OutputControl> outputControl) {\n-            return outputControl.stream().map(OutputControl::name).sorted().collect(joining(\"+\"));\n-        }\n-\n-        private List<String> expectedCapturedSystemOut(Command command) {\n-            if (!dumpOutput() || (!toolProvider && !saveOutput())) {\n-                return List.of();\n-            } else if(saveOutput()) {\n-                return Stream.concat(command.stdout().stream(), command.stderr().stream()).toList();\n-            } else {\n-                return command.stdout();\n-            }\n-        }\n-\n-        private List<String> expectedCapturedSystemErr(Command command) {\n-            if (!dumpOutput() || (!toolProvider && !saveOutput())) {\n-                return List.of();\n-            } else if(saveOutput()) {\n-                return List.of();\n-            } else {\n-                return command.stderr();\n-            }\n-        }\n-\n-        private List<String> expectedResultStdout(Command command) {\n-            return expectedResultStream(command.stdout());\n-        }\n-\n-        private List<String> expectedResultStderr(Command command) {\n-            if (outputControl.contains(OutputControl.SAVE_FIRST_LINE) && !command.stdout().isEmpty()) {\n-                return List.of();\n-            }\n-            return expectedResultStream(command.stderr());\n-        }\n-\n-        private List<String> expectedResultStream(List<String> commandOutput) {\n-            Objects.requireNonNull(commandOutput);\n-            if (outputControl.contains(OutputControl.SAVE_ALL)) {\n-                return commandOutput;\n-            } else if (outputControl.contains(OutputControl.SAVE_FIRST_LINE)) {\n-                return commandOutput.stream().findFirst().map(List::of).orElseGet(List::of);\n-            } else {\n-                return null;\n-            }\n-        }\n-\n-        private Command discardStreams(Command command) {\n-            return new Command(discardStdout() ? List.of() : command.stdout(), discardStderr() ? List.of() : command.stderr());\n-        }\n-\n-        private record OutputCapture(byte[] out, byte[] err, Charset outCharset, Charset errCharset) {\n-            OutputCapture {\n-                Objects.requireNonNull(out);\n-                Objects.requireNonNull(err);\n-                Objects.requireNonNull(outCharset);\n-                Objects.requireNonNull(errCharset);\n-            }\n-\n-            List<String> outLines() {\n-                return toLines(out, outCharset);\n-            }\n-\n-            List<String> errLines() {\n-                return toLines(err, errCharset);\n-            }\n-\n-            private static List<String> toLines(byte[] buf, Charset charset) {\n-                try (var reader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(buf), charset))) {\n-                    return reader.lines().filter(line -> {\n-                        return !line.contains(\"TRACE\");\n-                    }).toList();\n-                } catch (IOException ex) {\n-                    throw new UncheckedIOException(ex);\n-                }\n-            }\n-\n-            static OutputCapture captureOutput(Runnable runnable) {\n-                final var captureOut = new ByteArrayOutputStream();\n-                final var captureErr = new ByteArrayOutputStream();\n-\n-                final var out = System.out;\n-                final var err = System.err;\n-                try {\n-                    final var outCharset = System.out.charset();\n-                    final var errCharset = System.err.charset();\n-                    System.setOut(new PrintStream(captureOut, true, outCharset));\n-                    System.setErr(new PrintStream(captureErr, true, errCharset));\n-                    runnable.run();\n-                    return new OutputCapture(captureOut.toByteArray(), captureErr.toByteArray(), outCharset, errCharset);\n-                } finally {\n-                    try {\n-                        System.setOut(out);\n-                    } finally {\n-                        System.setErr(err);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private List<String> expectedCommandOutput(Command command) {\n-            command = discardStreams(command);\n-            return Stream.of(command.stdout(), command.stderr()).flatMap(List::stream).toList();\n-        }\n-\n-        private Executor createExecutor(Command command) {\n-            final Executor exec;\n-            if (toolProvider) {\n-                exec = Executor.of(command.asToolProvider());\n-            } else {\n-                exec = Executor.of(command.asExecutable());\n-            }\n-\n-            outputControl.forEach(control -> control.applyTo(exec));\n-\n-            return exec;\n-        }\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource\n-    public void testSavedOutput(OutputTestSpec spec) {\n-        spec.test();\n-    }\n-\n-    public static List<OutputTestSpec> testSavedOutput() {\n-        List<OutputTestSpec> testCases = new ArrayList<>();\n-        for (final var toolProvider : BOOLEAN_VALUES) {\n-            for (final var outputControl : OutputControl.variants()) {\n-                for (final var stdoutContent : List.of(OutputData.values())) {\n-                    for (final var stderrContent : List.of(OutputData.values())) {\n-                        final var commandSpec = new CommandSpec(stdoutContent, stderrContent);\n-                        testCases.add(new OutputTestSpec(toolProvider, outputControl, commandSpec));\n-                    }\n-                }\n-            }\n-        }\n-        return testCases;\n-    }\n-\n-    private static final List<Boolean> BOOLEAN_VALUES = List.of(Boolean.TRUE, Boolean.FALSE);\n-    private static final Consumer<Executor> NOP = exec -> {};\n-}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/ExecutorTest.java","additions":0,"deletions":401,"binary":false,"changes":401,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -216,1 +216,1 @@\n-            jpackageExitCode = result.exitCode();\n+            jpackageExitCode = result.getExitCode();\n@@ -374,2 +374,1 @@\n-                        return new Executor.Result(actualJPackageExitCode,\n-                                this::getPrintableCommandLine).assertExitCodeIs(expectedExitCode);\n+                        return new Executor.Result(actualJPackageExitCode).assertExitCodeIs(expectedExitCode);\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/PackageTestTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,4 +25,0 @@\n-import static java.util.stream.Collectors.joining;\n-\n-import java.io.BufferedReader;\n-import java.io.ByteArrayOutputStream;\n@@ -30,5 +26,0 @@\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.OutputStream;\n-import java.io.PrintStream;\n-import java.io.StringReader;\n@@ -36,1 +27,1 @@\n-import java.io.Writer;\n+import java.nio.charset.Charset;\n@@ -46,2 +37,1 @@\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.CompletionException;\n+import java.util.concurrent.TimeUnit;\n@@ -49,1 +39,0 @@\n-import java.util.regex.Pattern;\n@@ -51,1 +40,1 @@\n-import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n@@ -53,1 +42,4 @@\n-import jdk.jpackage.internal.util.function.ThrowingSupplier;\n+import jdk.jpackage.internal.util.CommandLineFormat;\n+import jdk.jpackage.internal.util.CommandOutputControl;\n+import jdk.jpackage.internal.util.CommandOutputControl.UnexpectedExitCodeException;\n+import jdk.jpackage.internal.util.RetryExecutor;\n@@ -55,0 +47,1 @@\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n@@ -72,2 +65,0 @@\n-        outputStreamsControl = new OutputStreamsControl();\n-        winEnglishOutput = false;\n@@ -139,8 +130,0 @@\n-    \/**\n-     * Configures this instance to save all stdout and stderr streams from the to be\n-     * executed command.\n-     * <p>\n-     * This function is mutually exclusive with {@link #saveFirstLineOfOutput()}.\n-     *\n-     * @return this\n-     *\/\n@@ -151,12 +134,0 @@\n-    \/**\n-     * Configures if all stdout and stderr streams from the to be executed command\n-     * should be saved.\n-     * <p>\n-     * If <code>v<\/code> is <code>true<\/code>, the function call is equivalent to\n-     * {@link #saveOutput()} call. If <code>v<\/code> is <code>false<\/code>, command\n-     * output will not be saved.\n-     *\n-     * @parameter v if both stdout and stderr streams should be saved\n-     *\n-     * @return this\n-     *\/\n@@ -164,1 +135,2 @@\n-        return setOutputControl(v, OutputControlOption.SAVE_ALL);\n+        commandOutputControl.saveOutput(v);\n+        return this;\n@@ -167,8 +139,0 @@\n-    \/**\n-     * Configures this instance to save the first line of a stream merged from\n-     * stdout and stderr streams from the to be executed command.\n-     * <p>\n-     * This function is mutually exclusive with {@link #saveOutput()}.\n-     *\n-     * @return this\n-     *\/\n@@ -176,1 +140,2 @@\n-        return setOutputControl(true, OutputControlOption.SAVE_FIRST_LINE);\n+        commandOutputControl.saveFirstLineOfOutput();\n+        return this;\n@@ -179,6 +144,0 @@\n-    \/**\n-     * Configures this instance to dump both stdout and stderr streams from the to\n-     * be executed command into {@link System.out}.\n-     *\n-     * @return this\n-     *\/\n@@ -190,1 +149,2 @@\n-        return setOutputControl(v, OutputControlOption.DUMP);\n+        commandOutputControl.dumpOutput(v);\n+        return this;\n@@ -194,1 +154,1 @@\n-        outputStreamsControl.stdout().discard(v);\n+        commandOutputControl.discardStdout(v);\n@@ -203,1 +163,1 @@\n-        outputStreamsControl.stderr().discard(v);\n+        commandOutputControl.discardStderr(v);\n@@ -211,2 +171,4 @@\n-    public interface Output {\n-        public List<String> getOutput();\n+    public Executor binaryOutput(boolean v) {\n+        commandOutputControl.binaryOutput(v);\n+        return this;\n+    }\n@@ -214,3 +176,3 @@\n-        public default String getFirstLineOfOutput() {\n-            return findFirstLineOfOutput().orElseThrow();\n-        }\n+    public Executor binaryOutput() {\n+        return binaryOutput(true);\n+    }\n@@ -218,3 +180,12 @@\n-        public default Optional<String> findFirstLineOfOutput() {\n-            return getOutput().stream().findFirst();\n-        }\n+    public Executor charset(Charset v) {\n+        commandOutputControl.charset(v);\n+        return this;\n+    }\n+\n+    public Charset charset() {\n+        return commandOutputControl.charset();\n+    }\n+\n+    Executor storeOutputInFiles(boolean v) {\n+        commandOutputControl.storeOutputInFiles(v);\n+        return this;\n@@ -223,1 +194,5 @@\n-    public record Result(int exitCode, CommandOutput output, Supplier<String> cmdline) implements Output {\n+    Executor storeOutputInFiles() {\n+        return storeOutputInFiles(true);\n+    }\n+\n+    public record Result(CommandOutputControl.Result base) {\n@@ -225,2 +200,1 @@\n-            Objects.requireNonNull(output);\n-            Objects.requireNonNull(cmdline);\n+            Objects.requireNonNull(base);\n@@ -229,2 +203,2 @@\n-        public Result(int exitCode, Supplier<String> cmdline) {\n-            this(exitCode, CommandOutput.EMPTY, cmdline);\n+        public Result(int exitCode) {\n+            this(new CommandOutputControl.Result(exitCode));\n@@ -233,1 +207,0 @@\n-        @Override\n@@ -235,1 +208,29 @@\n-            return output.lines().orElse(null);\n+            return base.content();\n+        }\n+\n+        public String getFirstLineOfOutput() {\n+            return getOutput().getFirst();\n+        }\n+\n+        public List<String> stdout() {\n+            return base.stdout();\n+        }\n+\n+        public List<String> stderr() {\n+            return base.stderr();\n+        }\n+\n+        public Optional<List<String>> findContent() {\n+            return base.findContent();\n+        }\n+\n+        public Optional<List<String>> findStdout() {\n+            return base.findStdout();\n+        }\n+\n+        public Optional<List<String>> findStderr() {\n+            return base.findStderr();\n+        }\n+\n+        public byte[] byteContent() {\n+            return base.byteContent();\n@@ -238,2 +239,2 @@\n-        public Output stdout() {\n-            return createView(output.stdoutLines());\n+        public byte[] byteStdout() {\n+            return base.byteStdout();\n@@ -242,2 +243,2 @@\n-        public Output stderr() {\n-            return createView(output.stderrLines());\n+        public byte[] byteStderr() {\n+            return base.byteStderr();\n@@ -246,4 +247,44 @@\n-        public Result assertExitCodeIs(int expectedExitCode) {\n-            TKit.assertEquals(expectedExitCode, exitCode, String.format(\n-                    \"Check command %s exited with %d code\",\n-                    cmdline.get(), expectedExitCode));\n+        public Optional<byte[]> findByteContent() {\n+            return base.findByteContent();\n+        }\n+\n+        public Optional<byte[]> findByteStdout() {\n+            return base.findByteStdout();\n+        }\n+\n+        public Optional<byte[]> findByteStderr() {\n+            return base.findByteStderr();\n+        }\n+\n+        public Result toCharacterResult(Charset charset, boolean keepByteContent) {\n+            try {\n+                return new Result(base.toCharacterResult(charset, keepByteContent));\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        public Result assertExitCodeIs(int main, int... other) {\n+            if (other.length != 0) {\n+                return assertExitCodeIs(IntStream.concat(IntStream.of(main), IntStream.of(other)).boxed().toList());\n+            } else {\n+                return assertExitCodeIs(List.of(main));\n+            }\n+        }\n+\n+        private Result assertExitCodeIs(List<Integer> expectedExitCodes) {\n+            Objects.requireNonNull(expectedExitCodes);\n+            switch (expectedExitCodes.size()) {\n+                case 0 -> {\n+                    throw new IllegalArgumentException();\n+                } case 1 -> {\n+                    long expectedExitCode = expectedExitCodes.getFirst();\n+                    TKit.assertEquals(expectedExitCode, getExitCode(), String.format(\n+                            \"Check command %s exited with %d code\",\n+                            base.execAttrs(), expectedExitCode));\n+                } default -> {\n+                    TKit.assertTrue(expectedExitCodes.contains(getExitCode()), String.format(\n+                            \"Check command %s exited with one of %s codes\",\n+                            base.execAttrs(), expectedExitCodes.stream().sorted().toList()));\n+                }\n+            }\n@@ -258,1 +299,1 @@\n-            return exitCode;\n+            return base.getExitCode();\n@@ -261,7 +302,2 @@\n-        private static Output createView(Optional<List<String>> lines) {\n-            return new Output() {\n-                @Override\n-                public List<String> getOutput() {\n-                    return lines.orElse(null);\n-                }\n-            };\n+        public String getPrintableCommandLine() {\n+            return base.execAttrs().toString();\n@@ -295,2 +331,2 @@\n-    public Result execute(int expectedCode) {\n-        return executeWithoutExitCodeCheck().assertExitCodeIs(expectedCode);\n+    Result execute(int mainExitCode, int... otherExitCodes) {\n+        return executeWithoutExitCodeCheck().assertExitCodeIs(mainExitCode, otherExitCodes);\n@@ -304,1 +340,1 @@\n-        return saveFirstLineOfOutput().execute().getFirstLineOfOutput();\n+        return saveFirstLineOfOutput().execute().getOutput().getFirst();\n@@ -311,3 +347,3 @@\n-    private static class BadResultException extends RuntimeException {\n-        BadResultException(Result v) {\n-            value = v;\n+    private static class FailedAttemptException extends Exception {\n+        FailedAttemptException(Exception cause) {\n+            super(Objects.requireNonNull(cause));\n@@ -316,5 +352,0 @@\n-        Result getValue() {\n-            return value;\n-        }\n-\n-        private final transient Result value;\n@@ -324,0 +355,13 @@\n+    public RetryExecutor<Result, UnexpectedExitCodeException> retryUntilExitCodeIs(\n+            int mainExpectedExitCode, int... otherExpectedExitCodes) {\n+        return new RetryExecutor<Result, UnexpectedExitCodeException>(UnexpectedExitCodeException.class).setExecutable(() -> {\n+            var result = executeWithoutExitCodeCheck();\n+            result.base().expectExitCode(mainExpectedExitCode, otherExpectedExitCodes);\n+            return result;\n+        }).setExceptionMapper((UnexpectedExitCodeException ex) -> {\n+            createResult(ex.getResult()).assertExitCodeIs(mainExpectedExitCode, otherExpectedExitCodes);\n+            \/\/ Unreachable, because the above `Result.assertExitCodeIs(...)` must throw.\n+            throw ExceptionBox.reachedUnreachable();\n+        });\n+    }\n+\n@@ -325,1 +369,1 @@\n-     * Executes the configured command {@code max} at most times and waits for\n+     * Executes the configured command at most {@code max} times and waits for\n@@ -335,11 +379,4 @@\n-        try {\n-            return tryRunMultipleTimes(() -> {\n-                Result result = executeWithoutExitCodeCheck();\n-                if (result.getExitCode() != expectedExitCode) {\n-                    throw new BadResultException(result);\n-                }\n-                return result;\n-            }, max, wait).assertExitCodeIs(expectedExitCode);\n-        } catch (BadResultException ex) {\n-            return ex.getValue().assertExitCodeIs(expectedExitCode);\n-        }\n+        return retryUntilExitCodeIs(expectedExitCode)\n+                .setAttemptTimeout(wait, TimeUnit.SECONDS)\n+                .setMaxAttemptsCount(max)\n+                .executeUnchecked();\n@@ -362,4 +399,1 @@\n-        RuntimeException lastException = null;\n-        int count = 0;\n-\n-        do {\n+        return new RetryExecutor<T, FailedAttemptException>(FailedAttemptException.class).setExecutable(() -> {\n@@ -369,1 +403,1 @@\n-                lastException = ex;\n+                throw new FailedAttemptException(ex);\n@@ -371,0 +405,3 @@\n+        }).setExceptionMapper((FailedAttemptException ex) -> {\n+            return (RuntimeException)ex.getCause();\n+        }).setAttemptTimeout(wait, TimeUnit.SECONDS).setMaxAttemptsCount(max).executeUnchecked();\n@@ -372,10 +409,0 @@\n-            try {\n-                Thread.sleep(wait * 1000);\n-            } catch (InterruptedException ex) {\n-                throw new RuntimeException(ex);\n-            }\n-\n-            count++;\n-        } while (count < max);\n-\n-        throw lastException;\n@@ -395,6 +422,0 @@\n-    private Executor setOutputControl(boolean set, OutputControlOption v) {\n-        outputStreamsControl.stdout().set(set, v);\n-        outputStreamsControl.stderr().set(set, v);\n-        return this;\n-    }\n-\n@@ -434,2 +455,0 @@\n-        outputStreamsControl.applyTo(builder);\n-\n@@ -437,3 +456,1 @@\n-        outputStreamsControl.describe().ifPresent(desc -> {\n-            sb.append(\"; \").append(desc);\n-        });\n+        sb.append(\"; \").append(commandOutputControl.description());\n@@ -469,39 +486,1 @@\n-        trace(\"Execute \" + sb.toString() + \"...\");\n-        Process process = builder.start();\n-\n-        var stdoutGobbler = CompletableFuture.<Optional<List<String>>>supplyAsync(() -> {\n-            try {\n-                return processProcessStream(outputStreamsControl.stdout(), process.getInputStream());\n-            } catch (IOException ex) {\n-                throw new UncheckedIOException(ex);\n-            }\n-        });\n-\n-        var stderrGobbler = CompletableFuture.<Optional<List<String>>>supplyAsync(() -> {\n-            try {\n-                return processProcessStream(outputStreamsControl.stderr(), process.getErrorStream());\n-            } catch (IOException ex) {\n-                throw new UncheckedIOException(ex);\n-            }\n-        });\n-\n-        final CommandOutput output;\n-\n-        try {\n-            output = combine(stdoutGobbler.join(), stderrGobbler.join());\n-        } catch (CompletionException ex) {\n-            var cause = ex.getCause();\n-            switch (cause) {\n-                case UncheckedIOException uioex -> {\n-                    throw uioex.getCause();\n-                }\n-                default -> {\n-                    throw ExceptionBox.toUnchecked(ExceptionBox.unbox(cause));\n-                }\n-            }\n-        }\n-\n-        final int exitCode = process.waitFor();\n-        trace(\"Done. Exit code: \" + exitCode);\n-\n-        return createResult(exitCode, output);\n+        return execute(sb, commandOutputControl.createExecutable(builder));\n@@ -510,1 +489,1 @@\n-    private int runToolProvider(PrintStream out, PrintStream err) {\n+    private Result runToolProvider() throws IOException, InterruptedException {\n@@ -512,12 +491,1 @@\n-        outputStreamsControl.describe().ifPresent(desc -> {\n-            sb.append(\"; \").append(desc);\n-        });\n-        trace(\"Execute \" + sb + \"...\");\n-        final int exitCode = toolProvider.run(out, err, args.toArray(\n-                String[]::new));\n-        trace(\"Done. Exit code: \" + exitCode);\n-        return exitCode;\n-    }\n-\n-    private Result runToolProvider() throws IOException {\n-        final var toolProviderStreamConfig = ToolProviderStreamConfig.create(outputStreamsControl);\n+        sb.append(\"; \").append(commandOutputControl.description());\n@@ -525,6 +493,1 @@\n-        final var exitCode = runToolProvider(toolProviderStreamConfig);\n-\n-        final var output = combine(\n-                read(outputStreamsControl.stdout(), toolProviderStreamConfig.out()),\n-                read(outputStreamsControl.stderr(), toolProviderStreamConfig.err()));\n-        return createResult(exitCode, output);\n+        return execute(sb, commandOutputControl.createExecutable(toolProvider, args.toArray(String[]::new)));\n@@ -533,8 +496,2 @@\n-    private int runToolProvider(ToolProviderStreamConfig cfg) throws IOException {\n-        try {\n-            return runToolProvider(cfg.out().ps(), cfg.err().ps());\n-        } finally {\n-            cfg.out().ps().flush();\n-            cfg.err().ps().flush();\n-        }\n-    }\n+    private Result execute(StringBuilder traceMsg, CommandOutputControl.Executable exec) throws IOException, InterruptedException {\n+        Objects.requireNonNull(traceMsg);\n@@ -542,26 +499,1 @@\n-    private static Optional<List<String>> processProcessStream(OutputControl outputControl, InputStream in) throws IOException {\n-        List<String> outputLines = null;\n-        try (final var bufReader = new BufferedReader(new InputStreamReader(in))) {\n-            if (outputControl.dump() || outputControl.saveAll()) {\n-                outputLines = bufReader.lines().toList();\n-            } else if (outputControl.saveFirstLine()) {\n-                outputLines = Optional.ofNullable(bufReader.readLine()).map(List::of).orElseGet(List::of);\n-                \/\/ Read all input, or the started process may exit with an error (cmd.exe does so).\n-                bufReader.transferTo(Writer.nullWriter());\n-            } else {\n-                \/\/ This should be empty input stream, fetch it anyway.\n-                bufReader.transferTo(Writer.nullWriter());\n-            }\n-        } finally {\n-            if (outputControl.dump() && outputLines != null) {\n-                outputLines.forEach(System.out::println);\n-                if (outputControl.saveFirstLine()) {\n-                    outputLines = outputLines.stream().findFirst().map(List::of).orElseGet(List::of);\n-                }\n-            }\n-            if (!outputControl.save()) {\n-                outputLines = null;\n-            }\n-        }\n-        return Optional.ofNullable(outputLines);\n-    }\n+        trace(\"Execute \" + traceMsg + \"...\");\n@@ -569,14 +501,1 @@\n-    private static Optional<List<String>> read(OutputControl outputControl, CachingPrintStream cps) throws IOException {\n-        final var bufferAsString = cps.bufferContents();\n-        try (final var bufReader = new BufferedReader(new StringReader(bufferAsString.orElse(\"\")))) {\n-            if (outputControl.saveFirstLine()) {\n-                return Optional.of(bufReader.lines().findFirst().map(List::of).orElseGet(List::of));\n-            } else if (outputControl.saveAll()) {\n-                return Optional.of(bufReader.lines().toList());\n-            } else if (bufferAsString.isPresent()) {\n-                return Optional.of(List.of());\n-            } else {\n-                return Optional.empty();\n-            }\n-        }\n-    }\n+        var result = exec.execute();\n@@ -584,16 +503,3 @@\n-    private CommandOutput combine(Optional<List<String>> out, Optional<List<String>> err) {\n-        if (out.isEmpty() && err.isEmpty()) {\n-            return new CommandOutput();\n-        } else if (out.isEmpty()) {\n-            return new CommandOutput(err, -1);\n-        } else if (err.isEmpty()) {\n-            return new CommandOutput(out, Integer.MAX_VALUE);\n-        } else {\n-            final var combined = Stream.of(out, err).map(Optional::orElseThrow).flatMap(List::stream);\n-            if (outputStreamsControl.stdout().saveFirstLine() && outputStreamsControl.stderr().saveFirstLine()) {\n-                return new CommandOutput(Optional.of(combined.findFirst().map(List::of).orElseGet(List::of)),\n-                        Integer.min(1, out.orElseThrow().size()));\n-            } else {\n-                return new CommandOutput(Optional.of(combined.toList()), out.orElseThrow().size());\n-            }\n-        }\n+        trace(\"Done. Exit code: \" + result.getExitCode());\n+\n+        return createResult(result);\n@@ -602,2 +508,3 @@\n-    private Result createResult(int exitCode, CommandOutput output) {\n-        return new Result(exitCode, output, this::getPrintableCommandLine);\n+    private Result createResult(CommandOutputControl.Result baseResult) {\n+        return new Result(baseResult.copyWithExecutableAttributes(\n+                new ExecutableAttributes(baseResult.execAttrs(), getPrintableCommandLine())));\n@@ -621,235 +528,1 @@\n-        return String.format(format, printCommandLine(cmdline), cmdline.size());\n-    }\n-\n-    private static String printCommandLine(List<String> cmdline) {\n-        \/\/ Want command line printed in a way it can be easily copy\/pasted\n-        \/\/ to be executed manually\n-        Pattern regex = Pattern.compile(\"\\\\s\");\n-        return cmdline.stream().map(\n-                v -> (v.isEmpty() || regex.matcher(v).find()) ? \"\\\"\" + v + \"\\\"\" : v).collect(\n-                        Collectors.joining(\" \"));\n-    }\n-\n-    private static void trace(String msg) {\n-        TKit.trace(String.format(\"exec: %s\", msg));\n-    }\n-\n-    private static PrintStream nullPrintStream() {\n-        return new PrintStream(OutputStream.nullOutputStream());\n-    }\n-\n-    private record OutputStreamsControl(OutputControl stdout, OutputControl stderr) {\n-        OutputStreamsControl {\n-            Objects.requireNonNull(stdout);\n-            Objects.requireNonNull(stderr);\n-        }\n-\n-        OutputStreamsControl() {\n-            this(new OutputControl(), new OutputControl());\n-        }\n-\n-        void applyTo(ProcessBuilder pb) {\n-            pb.redirectOutput(stdout.asProcessBuilderRedirect());\n-            pb.redirectError(stderr.asProcessBuilderRedirect());\n-        }\n-\n-        Optional<String> describe() {\n-            final List<String> tokens = new ArrayList<>();\n-            if (stdout.save() || stderr.save()) {\n-                streamsLabel(\"save \", true).ifPresent(tokens::add);\n-            }\n-            if (stdout.dump() || stderr.dump()) {\n-                streamsLabel(\"inherit \", true).ifPresent(tokens::add);\n-            }\n-            streamsLabel(\"discard \", false).ifPresent(tokens::add);\n-            if (tokens.isEmpty()) {\n-                return Optional.empty();\n-            } else {\n-                return Optional.of(String.join(\"; \", tokens));\n-            }\n-        }\n-\n-        Optional<String> streamsLabel(String prefix, boolean negate) {\n-            Objects.requireNonNull(prefix);\n-            final var str = Stream.of(stdoutLabel(negate), stderrLabel(negate))\n-                    .filter(Optional::isPresent)\n-                    .map(Optional::orElseThrow)\n-                    .collect(joining(\"+\"));\n-            if (str.isEmpty()) {\n-                return Optional.empty();\n-            } else {\n-                return Optional.of(prefix + str);\n-            }\n-        }\n-\n-        private Optional<String> stdoutLabel(boolean negate) {\n-            if ((stdout.discard() && !negate) || (!stdout.discard() && negate)) {\n-                return Optional.of(\"out\");\n-            } else {\n-                return Optional.empty();\n-            }\n-        }\n-\n-        private Optional<String> stderrLabel(boolean negate) {\n-            if ((stderr.discard() && !negate) || (!stderr.discard() && negate)) {\n-                return Optional.of(\"err\");\n-            } else {\n-                return Optional.empty();\n-            }\n-        }\n-    }\n-\n-    private record CachingPrintStream(PrintStream ps, Optional<ByteArrayOutputStream> buf) {\n-        CachingPrintStream {\n-            Objects.requireNonNull(ps);\n-            Objects.requireNonNull(buf);\n-        }\n-\n-        Optional<String> bufferContents() {\n-            return buf.map(ByteArrayOutputStream::toString);\n-        }\n-\n-        static Builder build() {\n-            return new Builder();\n-        }\n-\n-        static final class Builder {\n-\n-            Builder save(boolean v) {\n-                save = v;\n-                return this;\n-            }\n-\n-            Builder discard(boolean v) {\n-                discard = v;\n-                return this;\n-            }\n-\n-            Builder dumpStream(PrintStream v) {\n-                dumpStream = v;\n-                return this;\n-            }\n-\n-            CachingPrintStream create() {\n-                final Optional<ByteArrayOutputStream> buf;\n-                if (save && !discard) {\n-                    buf = Optional.of(new ByteArrayOutputStream());\n-                } else {\n-                    buf = Optional.empty();\n-                }\n-\n-                final PrintStream ps;\n-                if (buf.isPresent() && dumpStream != null) {\n-                    ps = new PrintStream(new TeeOutputStream(List.of(buf.orElseThrow(), dumpStream)), true, dumpStream.charset());\n-                } else if (!discard) {\n-                    ps = buf.map(PrintStream::new).or(() -> Optional.ofNullable(dumpStream)).orElseGet(Executor::nullPrintStream);\n-                } else {\n-                    ps = nullPrintStream();\n-                }\n-\n-                return new CachingPrintStream(ps, buf);\n-            }\n-\n-            private boolean save;\n-            private boolean discard;\n-            private PrintStream dumpStream;\n-        }\n-    }\n-\n-    private record ToolProviderStreamConfig(CachingPrintStream out, CachingPrintStream err) {\n-        ToolProviderStreamConfig {\n-            Objects.requireNonNull(out);\n-            Objects.requireNonNull(err);\n-        }\n-\n-        static ToolProviderStreamConfig create(OutputStreamsControl cfg) {\n-            final var errCfgBuilder = cfg.stderr().buildCachingPrintStream(System.err);\n-            if (cfg.stderr().dump() && cfg.stderr().save()) {\n-                errCfgBuilder.dumpStream(System.out);\n-            }\n-            return new ToolProviderStreamConfig(\n-                    cfg.stdout().buildCachingPrintStream(System.out).create(), errCfgBuilder.create());\n-        }\n-    }\n-\n-    private static final class OutputControl {\n-\n-        boolean save() {\n-            return save.isPresent();\n-        }\n-\n-        boolean saveAll() {\n-            return save.orElse(null) == OutputControlOption.SAVE_ALL;\n-        }\n-\n-        boolean saveFirstLine() {\n-            return save.orElse(null) == OutputControlOption.SAVE_FIRST_LINE;\n-        }\n-\n-        boolean discard() {\n-            return discard || (!dump && save.isEmpty());\n-        }\n-\n-        boolean dump() {\n-            return !discard && dump;\n-        }\n-\n-        OutputControl dump(boolean v) {\n-            this.dump = v;\n-            return this;\n-        }\n-\n-        OutputControl discard(boolean v) {\n-            this.discard = v;\n-            return this;\n-        }\n-\n-        OutputControl saveAll(boolean v) {\n-            if (v) {\n-                save = Optional.of(OutputControlOption.SAVE_ALL);\n-            } else {\n-                save = Optional.empty();\n-            }\n-            return this;\n-        }\n-\n-        OutputControl saveFirstLine(boolean v) {\n-            if (v) {\n-                save = Optional.of(OutputControlOption.SAVE_FIRST_LINE);\n-            } else {\n-                save = Optional.empty();\n-            }\n-            return this;\n-        }\n-\n-        OutputControl set(boolean set, OutputControlOption v) {\n-            switch (v) {\n-            case DUMP -> dump(set);\n-            case SAVE_ALL -> saveAll(set);\n-            case SAVE_FIRST_LINE -> saveFirstLine(set);\n-            }\n-            return this;\n-        }\n-\n-        ProcessBuilder.Redirect asProcessBuilderRedirect() {\n-            if (discard()) {\n-                return ProcessBuilder.Redirect.DISCARD;\n-            } else if (dump && !save()) {\n-                return ProcessBuilder.Redirect.INHERIT;\n-            } else {\n-                return ProcessBuilder.Redirect.PIPE;\n-            }\n-        }\n-\n-        CachingPrintStream.Builder buildCachingPrintStream(PrintStream dumpStream) {\n-            Objects.requireNonNull(dumpStream);\n-            final var builder = CachingPrintStream.build().save(save()).discard(discard());\n-            if (dump()) {\n-                builder.dumpStream(dumpStream);\n-            }\n-            return builder;\n-        }\n-\n-        private boolean dump;\n-        private boolean discard;\n-        private Optional<OutputControlOption> save = Optional.empty();\n+        return String.format(format, CommandLineFormat.DEFAULT.apply(cmdline), cmdline.size());\n@@ -858,20 +531,2 @@\n-    private static final class TeeOutputStream extends OutputStream {\n-\n-        public TeeOutputStream(Iterable<OutputStream> streams) {\n-            streams.forEach(Objects::requireNonNull);\n-            this.streams = streams;\n-        }\n-\n-        @Override\n-        public void write(int b) throws IOException {\n-            for (final var out : streams) {\n-                out.write(b);\n-            }\n-        }\n-\n-        @Override\n-        public void write(byte[] b) throws IOException {\n-            for (final var out : streams) {\n-                out.write(b);\n-            }\n-        }\n+    private record ExecutableAttributes(CommandOutputControl.ExecutableAttributes base, String toStringValue)\n+            implements CommandOutputControl.ExecutableAttributes {\n@@ -879,4 +534,4 @@\n-        @Override\n-        public void write(byte[] b, int off, int len) throws IOException {\n-            for (final var out : streams) {\n-                out.write(b, off, len);\n+        ExecutableAttributes {\n+            Objects.requireNonNull(base);\n+            if (toStringValue.isBlank()) {\n+                throw new IllegalArgumentException();\n@@ -887,2 +542,2 @@\n-        public void flush() throws IOException {\n-            forEach(OutputStream::flush);\n+        public String toString() {\n+            return toStringValue;\n@@ -892,18 +547,2 @@\n-        public void close() throws IOException {\n-            forEach(OutputStream::close);\n-        }\n-\n-        private void forEach(OutputStreamConsumer c) throws IOException {\n-            IOException firstEx = null;\n-            for (final var out : streams) {\n-                try {\n-                    c.accept(out);\n-                } catch (IOException e) {\n-                    if (firstEx == null) {\n-                        firstEx = e;\n-                    }\n-                }\n-            }\n-            if (firstEx != null) {\n-                throw firstEx;\n-            }\n+        public List<String> commandLine() {\n+            return base.commandLine();\n@@ -911,7 +550,0 @@\n-\n-        @FunctionalInterface\n-        private static interface OutputStreamConsumer {\n-            void accept(OutputStream out) throws IOException;\n-        }\n-\n-        private final Iterable<OutputStream> streams;\n@@ -920,42 +552,2 @@\n-    private static final class CommandOutput {\n-        CommandOutput(Optional<List<String>> lines, int stdoutLineCount) {\n-            this.lines = Objects.requireNonNull(lines);\n-            this.stdoutLineCount = stdoutLineCount;\n-        }\n-\n-        CommandOutput() {\n-            this(Optional.empty(), 0);\n-        }\n-\n-        Optional<List<String>> lines() {\n-            return lines;\n-        }\n-\n-        Optional<List<String>> stdoutLines() {\n-            if (lines.isEmpty() || stdoutLineCount < 0) {\n-                return Optional.empty();\n-            }\n-\n-            final var theLines = lines.orElseThrow();\n-            if (stdoutLineCount == theLines.size()) {\n-                return lines;\n-            } else {\n-                return Optional.of(theLines.subList(0, Integer.min(stdoutLineCount, theLines.size())));\n-            }\n-        }\n-\n-        Optional<List<String>> stderrLines() {\n-            if (lines.isEmpty() || stdoutLineCount > lines.orElseThrow().size()) {\n-                return Optional.empty();\n-            } else if (stdoutLineCount == 0) {\n-                return lines;\n-            } else {\n-                final var theLines = lines.orElseThrow();\n-                return Optional.of(theLines.subList(stdoutLineCount, theLines.size()));\n-            }\n-        }\n-\n-        private final Optional<List<String>> lines;\n-        private final int stdoutLineCount;\n-\n-        static final CommandOutput EMPTY = new CommandOutput();\n+    private static void trace(String msg) {\n+        TKit.trace(String.format(\"exec: %s\", msg));\n@@ -966,1 +558,1 @@\n-    private OutputStreamsControl outputStreamsControl;\n+    private final CommandOutputControl commandOutputControl = new CommandOutputControl();\n@@ -972,4 +564,0 @@\n-\n-    private static enum OutputControlOption {\n-        SAVE_ALL, SAVE_FIRST_LINE, DUMP\n-    }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Executor.java","additions":182,"deletions":594,"binary":false,"changes":776,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,2 @@\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n@@ -783,4 +785,3 @@\n-     * Starts a new thread. In this thread calls\n-     * {@link #useToolProviderByDefault(ToolProvider)} with the specified\n-     * {@code jpackageToolProvider} and then calls {@code workload.run()}. Joins the\n-     * thread.\n+     * In a separate thread calls {@link #useToolProviderByDefault(ToolProvider)}\n+     * with the specified {@code jpackageToolProvider} and then calls\n+     * {@code workload.run()}. Joins the thread.\n@@ -797,2 +798,1 @@\n-    public static void withToolProvider(ToolProvider jpackageToolProvider, Runnable workload) {\n-        Objects.requireNonNull(jpackageToolProvider);\n+    public static void withToolProvider(Runnable workload, ToolProvider jpackageToolProvider) {\n@@ -800,1 +800,4 @@\n-        ThrowingRunnable.toRunnable(Thread.ofVirtual().start(() -> {\n+        Objects.requireNonNull(jpackageToolProvider);\n+\n+        CompletableFuture.runAsync(() -> {\n+            var oldValue = defaultToolProvider.get();\n@@ -802,2 +805,10 @@\n-            workload.run();\n-        })::join).run();\n+            try {\n+                workload.run();\n+            } finally {\n+                defaultToolProvider.set(oldValue);\n+            }\n+            \/\/ Run the future in a new native thread. Don't run it in a virtual\/pooled thread.\n+            \/\/ Pooled and\/or virtual threads are problematic when used with inheritable thread-local variables.\n+            \/\/ TKit class depends on such a variable, which results in intermittent test failures\n+            \/\/ if the default executor runs this future.\n+        }, Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory())).join();\n@@ -1025,1 +1036,1 @@\n-        if (result.exitCode() == 0 && expectedExitCode.isPresent()) {\n+        if (result.getExitCode() == 0 && expectedExitCode.isPresent()) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -726,1 +726,3 @@\n-                .discardStderr().saveFirstLineOfOutput().execute().findFirstLineOfOutput();\n+                .discardStderr()\n+                .saveFirstLineOfOutput()\n+                .execute().getOutput().stream().findFirst();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LinuxHelper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-import java.util.NoSuchElementException;\n@@ -57,0 +56,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -69,1 +69,0 @@\n-import jdk.jpackage.internal.RetryExecutor;\n@@ -73,0 +72,1 @@\n+import jdk.jpackage.internal.util.RetryExecutor;\n@@ -93,17 +93,10 @@\n-        String attachCMD[] = {\n-            \"sh\", \"-c\",\n-            String.join(\" \", \"yes\", \"|\", \"\/usr\/bin\/hdiutil\", \"attach\",\n-                    JPackageCommand.escapeAndJoin(cmd.outputBundle().toString()),\n-                    \"-mountroot\", PathUtils.normalizedAbsolutePathString(mountRoot),\n-                    \"-nobrowse\", \"-plist\")};\n-        RetryExecutor attachExecutor = new RetryExecutor();\n-        try {\n-            \/\/ 10 times with 6 second delays.\n-            attachExecutor.setMaxAttemptsCount(10)\n-                    .setAttemptTimeoutMillis(6000)\n-                    .setWriteOutputToFile(true)\n-                    .saveOutput(true)\n-                    .execute(attachCMD);\n-        } catch (IOException ex) {\n-            throw new RuntimeException(ex);\n-        }\n+        final var attachStdout = Executor.of(\"sh\", \"-c\", String.join(\" \",\n+                \"yes\",\n+                \"|\",\n+                \"\/usr\/bin\/hdiutil\",\n+                \"attach\",\n+                JPackageCommand.escapeAndJoin(cmd.outputBundle().toString()),\n+                \"-mountroot\", PathUtils.normalizedAbsolutePathString(mountRoot),\n+                \"-nobrowse\",\n+                \"-plist\"\n+        )).saveOutput().storeOutputInFiles().executeAndRepeatUntilExitCode(0, 10, 6).stdout();\n@@ -111,1 +104,3 @@\n-        Path mountPoint = null;\n+        final Path mountPoint;\n+\n+        boolean mountPointInitialized = false;\n@@ -114,7 +109,8 @@\n-            mountPoint = readPList(attachExecutor.getOutput()).queryArrayValue(\"system-entities\", false).map(PListReader.class::cast).map(dict -> {\n-                try {\n-                    return dict.queryValue(\"mount-point\");\n-                } catch (NoSuchElementException ex) {\n-                    return (String)null;\n-                }\n-            }).filter(Objects::nonNull).map(Path::of).findFirst().orElseThrow();\n+            mountPoint = readPList(attachStdout).queryArrayValue(\"system-entities\", false)\n+                    .map(PListReader.class::cast)\n+                    .map(dict -> {\n+                        return dict.findValue(\"mount-point\");\n+                    })\n+                    .filter(Optional::isPresent).map(Optional::get)\n+                    .map(Path::of).findFirst().orElseThrow();\n+            mountPointInitialized = true;\n@@ -122,1 +118,1 @@\n-            if (mountPoint == null) {\n+            if (!mountPointInitialized) {\n@@ -124,1 +120,1 @@\n-                attachExecutor.getOutput().forEach(TKit::trace);\n+                attachStdout.forEach(TKit::trace);\n@@ -141,5 +137,0 @@\n-            String detachCMD[] = {\n-                \"\/usr\/bin\/hdiutil\",\n-                \"detach\",\n-                \"-verbose\",\n-                mountPoint.toAbsolutePath().toString()};\n@@ -148,7 +139,5 @@\n-            RetryExecutor detachExecutor = new RetryExecutor();\n-            \/\/ Image can get detach even if we got resource busy error, so stop\n-            \/\/ trying to detach it if it is no longer attached.\n-            final Path mp = mountPoint;\n-            detachExecutor.setExecutorInitializer(exec -> {\n-                if (!Files.exists(mp)) {\n-                    detachExecutor.abort();\n+            new RetryExecutor<Void, RuntimeException>(RuntimeException.class).setExecutable(context -> {\n+                var exec = Executor.of(\"\/usr\/bin\/hdiutil\", \"detach\").storeOutputInFiles();\n+                if (context.isLastAttempt()) {\n+                    \/\/ The last attempt, force detach.\n+                    exec.addArgument(\"-force\");\n@@ -156,16 +145,11 @@\n-            });\n-            try {\n-                \/\/ 10 times with 6 second delays.\n-                detachExecutor.setMaxAttemptsCount(10)\n-                        .setAttemptTimeoutMillis(6000)\n-                        .setWriteOutputToFile(true)\n-                        .saveOutput(true)\n-                        .execute(detachCMD);\n-            } catch (IOException ex) {\n-                if (!detachExecutor.isAborted()) {\n-                    \/\/ Now force to detach if it still attached\n-                    if (Files.exists(mountPoint)) {\n-                        Executor.of(\"\/usr\/bin\/hdiutil\", \"detach\",\n-                                    \"-force\", \"-verbose\")\n-                                 .addArgument(mountPoint).execute();\n-                    }\n+                exec.addArgument(mountPoint);\n+\n+                \/\/ The image can get detached even if we get a resource busy error,\n+                \/\/ so execute the detach command without checking the exit code.\n+                var result = exec.executeWithoutExitCodeCheck();\n+\n+                if (result.getExitCode() == 0 || !Files.exists(mountPoint)) {\n+                    \/\/ Detached successfully!\n+                    return null;\n+                } else {\n+                    throw new RuntimeException(String.format(\"[%s] mount point still attached\", mountPoint));\n@@ -173,1 +157,1 @@\n-            }\n+            }).setMaxAttemptsCount(10).setAttemptTimeout(6, TimeUnit.SECONDS).execute();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":43,"deletions":59,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1175,1 +1175,1 @@\n-            if (result.exitCode() == 0) {\n+            if (result.getExitCode() == 0) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSign.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-        var xml = result.stdout().getOutput();\n+        var xml = result.stdout();\n@@ -140,1 +140,1 @@\n-        TKit.assertTrue(Set.of(0, 3).contains(result.exitCode()),\n+        TKit.assertTrue(Set.of(0, 3).contains(result.getExitCode()),\n@@ -176,1 +176,1 @@\n-            reportUnexpectedCommandOutcome(exec.getPrintableCommandLine(), result);\n+            reportUnexpectedCommandOutcome(result);\n@@ -208,1 +208,1 @@\n-            reportUnexpectedCommandOutcome(exec.getPrintableCommandLine(), result);\n+            reportUnexpectedCommandOutcome(result);\n@@ -267,1 +267,1 @@\n-                reportUnexpectedCommandOutcome(exec.getPrintableCommandLine(), result);\n+                reportUnexpectedCommandOutcome(result);\n@@ -273,1 +273,1 @@\n-            reportUnexpectedCommandOutcome(exec.getPrintableCommandLine(), result);\n+            reportUnexpectedCommandOutcome(result);\n@@ -285,2 +285,1 @@\n-    private static void reportUnexpectedCommandOutcome(String printableCommandLine, Executor.Result result) {\n-        Objects.requireNonNull(printableCommandLine);\n+    private static void reportUnexpectedCommandOutcome(Executor.Result result) {\n@@ -289,1 +288,1 @@\n-                printableCommandLine, result.getExitCode()));\n+                result.getPrintableCommandLine(), result.getExitCode()));\n@@ -292,1 +291,1 @@\n-        TKit.assertUnexpected(String.format(\"Outcome of command %s\", printableCommandLine));\n+        TKit.assertUnexpected(String.format(\"Outcome of command %s\", result.getPrintableCommandLine()));\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSignVerify.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-            if (result.exitCode() == 1605) {\n+            if (result.getExitCode() == 1605) {\n@@ -87,1 +87,1 @@\n-                return result.exitCode();\n+                return result.getExitCode();\n@@ -93,1 +93,1 @@\n-            if ((result.exitCode() == 1618) || (result.exitCode() == 1603 && isUnpack)) {\n+            if ((result.getExitCode() == 1618) || (result.getExitCode() == 1603 && isUnpack)) {\n@@ -103,1 +103,1 @@\n-        return result.exitCode();\n+        return result.getExitCode();\n@@ -465,1 +465,1 @@\n-        if (status.exitCode() == 1) {\n+        if (status.getExitCode() == 1) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WindowsHelper.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.io.PrintStream;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+\/**\n+ * An action.\n+ *\/\n+@FunctionalInterface\n+public interface CommandAction {\n+\n+    public record Context(PrintStream out, PrintStream err, List<String> args) {\n+\n+        public Context {\n+            Objects.requireNonNull(out);\n+            Objects.requireNonNull(err);\n+            args.forEach(Objects::requireNonNull);\n+        }\n+\n+        public Optional<String> findOptionValue(String option) {\n+            Objects.requireNonNull(option);\n+            var idx = args.indexOf(option);\n+            if (idx >= 0 && idx + 1 < args.size()) {\n+                return Optional.of(args.get(idx + 1));\n+            } else {\n+                return Optional.empty();\n+            }\n+        }\n+\n+        public String optionValue(String option) {\n+            return findOptionValue(option).orElseThrow(() -> {\n+                throw new MockIllegalStateException(String.format(\"No option %s\", option));\n+            });\n+        }\n+\n+        public MockIllegalStateException unexpectedArguments() {\n+            return new MockIllegalStateException(String.format(\"Unexpected arguments: %s\", args));\n+        }\n+    }\n+\n+    \/**\n+     * Runs the action in the given context.\n+     *\n+     * @param context the context\n+     * @return an {@code Optional} wrapping the exit code, indicating it is the last\n+     *         action in the sequence or an empty {@code Optional} otherwise\n+     * @throws Exception                 simulates a failure\n+     * @throws MockIllegalStateException if error in internal mock logic occurred.\n+     *                                   E.g.: if the action was called unexpectedly\n+     *\/\n+    Optional<Integer> run(Context context) throws Exception, MockIllegalStateException;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/CommandAction.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+import jdk.jpackage.internal.util.function.ThrowingRunnable;\n+\n+\/**\n+ * Specification of a {@link CommandAction}.\n+ * <p>\n+ * Comprised of a human-readable description and an associated action.\n+ *\/\n+public interface CommandActionSpec {\n+\n+    String description();\n+    CommandAction action();\n+\n+    public static CommandActionSpec create(String description, CommandAction action) {\n+        return new Internal.DefaultCommandActionSpec(description, action);\n+    }\n+\n+    public static CommandActionSpec create(String description, ThrowingSupplier<Integer, Exception> action) {\n+        Objects.requireNonNull(action);\n+        return create(description, _ -> {\n+            return Optional.of(action.get());\n+        });\n+    }\n+\n+    public static CommandActionSpec create(String description, ThrowingRunnable<Exception> action) {\n+        Objects.requireNonNull(action);\n+        return create(description, _ -> {\n+            action.run();\n+            return Optional.empty();\n+        });\n+    }\n+\n+    @SuppressWarnings(\"overloads\")\n+    public static CommandActionSpec create(String description, ThrowingConsumer<CommandAction.Context, Exception> action) {\n+        Objects.requireNonNull(action);\n+        return create(description, context -> {\n+            action.accept(context);\n+            return Optional.empty();\n+        });\n+    }\n+\n+    final class Internal {\n+\n+        private Internal() {\n+        }\n+\n+        private record DefaultCommandActionSpec(String description, CommandAction action) implements CommandActionSpec {\n+            DefaultCommandActionSpec {\n+                Objects.requireNonNull(description);\n+                Objects.requireNonNull(action);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return description();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/CommandActionSpec.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+\n+\/**\n+ * A sequence of actions.\n+ *\/\n+public record CommandActionSpecs(List<CommandActionSpec> specs) {\n+\n+    public CommandActionSpecs {\n+        Objects.requireNonNull(specs);\n+    }\n+\n+    public CommandActionSpecs andThen(CommandActionSpecs other) {\n+        return build().append(this).append(other).create();\n+    }\n+\n+    public Stream<CommandAction> actions() {\n+        return specs.stream().map(CommandActionSpec::action);\n+    }\n+\n+    public CommandMock.Builder toCommandMockBuilder() {\n+        return new CommandMock.Builder().mutate(builder -> {\n+            builder.actions().append(this);\n+        });\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return specs.toString();\n+    }\n+\n+    public static Builder build() {\n+        return new Builder();\n+    }\n+\n+    public static final class Builder {\n+\n+        public CommandActionSpecs create() {\n+            return new CommandActionSpecs(List.copyOf(specs));\n+        }\n+\n+        public Builder stdout(List<String> content) {\n+            Objects.requireNonNull(content);\n+            return action(CommandActionSpec.create(String.format(\"%s>>1\", content), context -> {\n+                var out = context.out();\n+                content.forEach(out::println);\n+            }));\n+        }\n+\n+        public Builder stdout(String... str) {\n+            return stdout(List.of(str));\n+        }\n+\n+        public Builder stderr(List<String> content) {\n+            Objects.requireNonNull(content);\n+            return action(CommandActionSpec.create(String.format(\"%s>>2\", content), context -> {\n+                var err = context.err();\n+                content.forEach(err::println);\n+            }));\n+        }\n+\n+        public Builder stderr(String... str) {\n+            return stderr(List.of(str));\n+        }\n+\n+        public Builder printToStdout(List<String> content) {\n+            Objects.requireNonNull(content);\n+            return action(CommandActionSpec.create(String.format(\"%s(no-eol)>>1\", content), context -> {\n+                var out = context.out();\n+                content.forEach(out::print);\n+            }));\n+        }\n+\n+        public Builder printToStdout(String... str) {\n+            return printToStdout(List.of(str));\n+        }\n+\n+        public Builder printToStderr(List<String> content) {\n+            Objects.requireNonNull(content);\n+            return action(CommandActionSpec.create(String.format(\"%s(no-eol)>>2\", content), context -> {\n+                var err = context.err();\n+                content.forEach(err::print);\n+            }));\n+        }\n+\n+        public Builder printToStderr(String... str) {\n+            return printToStderr(List.of(str));\n+        }\n+\n+        public Builder exit(int exitCode) {\n+            return action(CommandActionSpec.create(String.format(\"exit(%d)\", exitCode), () -> {\n+                return exitCode;\n+            }));\n+        }\n+\n+        public Builder exit() {\n+            return exit(0);\n+        }\n+\n+        public Builder exit(CommandMockExit exit) {\n+            switch (exit) {\n+                case SUCCEED -> {\n+                    return exit();\n+                }\n+                case EXIT_1 -> {\n+                    return exit(1);\n+                }\n+                case THROW_MOCK_IO_EXCEPTION -> {\n+                    return action(CommandActionSpec.create(\"<I\/O error>\", () -> {\n+                        throw new MockingToolProvider.RethrowableException(new MockIOException(\"Kaput!\"));\n+                    }));\n+                }\n+                default -> {\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+        }\n+\n+        public Builder mutate(Consumer<Builder> mutator) {\n+            mutator.accept(this);\n+            return this;\n+        }\n+\n+        public Builder append(Builder other) {\n+            return append(other.specs);\n+        }\n+\n+        public Builder append(CommandActionSpecs other) {\n+            return append(other.specs());\n+        }\n+\n+        public Builder append(List<CommandActionSpec> other) {\n+            specs.addAll(other);\n+            return this;\n+        }\n+\n+        public Builder action(CommandActionSpec v) {\n+            specs.add(Objects.requireNonNull(v));\n+            return this;\n+        }\n+\n+        public Builder copy() {\n+            return new Builder().append(this);\n+        }\n+\n+        public CommandMock.Builder toCommandMockBuilder() {\n+            return new CommandMock.Builder().mutate(builder -> {\n+                builder.actions(this);\n+            });\n+        }\n+\n+        private final List<CommandActionSpec> specs = new ArrayList<>();\n+    }\n+\n+    public static final CommandActionSpecs UNREACHABLE = new CommandActionSpecs(List.of());\n+}\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/CommandActionSpecs.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * Command mock.\n+ *\/\n+public sealed interface CommandMock permits ToolProviderCommandMock, VerbatimCommandMock, CompletableCommandMock {\n+\n+    public static CommandMock ioerror(String name) {\n+        return CommandActionSpecs.build()\n+                .exit(CommandMockExit.THROW_MOCK_IO_EXCEPTION)\n+                .toCommandMockBuilder().name(Objects.requireNonNull(name)).create();\n+    }\n+\n+    public static CommandMock fail(String name) {\n+        return CommandActionSpecs.build()\n+                .exit(CommandMockExit.EXIT_1)\n+                .toCommandMockBuilder().name(Objects.requireNonNull(name)).create();\n+    }\n+\n+    public static CommandMock succeed(String name) {\n+        return CommandActionSpecs.build()\n+                .exit(CommandMockExit.SUCCEED)\n+                .toCommandMockBuilder().name(Objects.requireNonNull(name)).create();\n+    }\n+\n+    public static CommandMock unreachable() {\n+        return MockingToolProvider.UNREACHABLE;\n+    }\n+\n+    public final class Builder {\n+\n+        public ToolProviderCommandMock create() {\n+\n+            var actionSpecs = Optional.ofNullable(scriptBuilder)\n+                    .map(CommandActionSpecs.Builder::create)\n+                    .orElse(CommandActionSpecs.UNREACHABLE);\n+            if (actionSpecs.equals(CommandActionSpecs.UNREACHABLE)) {\n+                return (ToolProviderCommandMock)unreachable();\n+            }\n+\n+            var theName = Optional.ofNullable(name).orElse(\"mock\");\n+            var script = actionSpecs.actions().toList();\n+            switch (repeat) {\n+                case 0 -> {\n+                    return MockingToolProvider.create(theName, script);\n+                }\n+                case -1 -> {\n+                    return MockingToolProvider.createLoop(theName, script);\n+                }\n+                default -> {\n+                    var repeatedScript = IntStream.rangeClosed(0, repeat)\n+                            .mapToObj(i -> script)\n+                            .flatMap(List::stream)\n+                            .toList();\n+                    return MockingToolProvider.create(theName, repeatedScript);\n+                }\n+            }\n+        }\n+\n+        public Builder name(String v) {\n+            name = v;\n+            return this;\n+        }\n+\n+        public Builder mutate(Consumer<Builder> mutator) {\n+            mutator.accept(this);\n+            return this;\n+        }\n+\n+        public Builder repeat(int v) {\n+            repeat = Integer.max(-1, v);\n+            return this;\n+        }\n+\n+        public Builder noRepeats() {\n+            return repeat(0);\n+        }\n+\n+        public Builder repeatInfinitely() {\n+            return repeat(-1);\n+        }\n+\n+        public Builder actions(CommandActionSpecs.Builder v) {\n+            scriptBuilder = Optional.ofNullable(v).orElseGet(CommandActionSpecs::build);\n+            return this;\n+        }\n+\n+        public CommandActionSpecs.Builder actions() {\n+            if (scriptBuilder == null) {\n+                scriptBuilder = CommandActionSpecs.build();\n+            }\n+            return scriptBuilder;\n+        }\n+\n+        private String name;\n+        private int repeat = -1;\n+        private CommandActionSpecs.Builder scriptBuilder;\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/CommandMock.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import jdk.jpackage.internal.util.CommandOutputControl;\n+\n+public enum CommandMockExit {\n+    \/**\n+     * Exit normally with \"0\" exit code.\n+     *\/\n+    SUCCEED(true, true),\n+    \/**\n+     * Exit normally with \"1\" exit code.\n+     *\/\n+    EXIT_1(false, true),\n+    \/**\n+     * Throw {@link MockIOException}. This simulates a situation when an I\/O error\n+     * occurs starting a subprocess with {@link ProcessBuilder#start()}.\n+     * {@link CommandOutputControl.Executable#execute()} will handle I\/O errors and\n+     * let them out.\n+     *\/\n+    THROW_MOCK_IO_EXCEPTION(false, false),\n+    ;\n+\n+    CommandMockExit(boolean succeed, boolean exitNormally) {\n+        this.succeed = succeed;\n+        this.exitNormally = exitNormally;\n+    }\n+\n+    public boolean succeed() {\n+        return succeed;\n+    }\n+\n+    public boolean exitNormally() {\n+        return exitNormally;\n+    }\n+\n+    private final boolean succeed;\n+    private final boolean exitNormally;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/CommandMockExit.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+\n+\/**\n+ * Specification of a {@link CommandMock}.\n+ *\/\n+public record CommandMockSpec(Path name, Path mockName, CommandActionSpecs actions) {\n+\n+    public CommandMockSpec {\n+        Objects.requireNonNull(name);\n+        Objects.requireNonNull(mockName);\n+        Objects.requireNonNull(actions);\n+    }\n+\n+    public CommandMockSpec(Path name, CommandActionSpecs actions) {\n+        this(name, Path.of(name.toString() + \"-mock\"), actions);\n+    }\n+\n+    public CommandMockSpec(String name, CommandActionSpecs actions) {\n+        this(Path.of(name), actions);\n+    }\n+\n+    public CommandMockSpec(String name, String mockName, CommandActionSpecs actions) {\n+        this(Path.of(name), Path.of(mockName), actions);\n+    }\n+\n+    public CommandMock.Builder toCommandMockBuilder() {\n+        return actions.toCommandMockBuilder().name(mockName.toString());\n+    }\n+\n+    public boolean isDefaultMockName() {\n+        return (name.getFileName().toString() + \"-mock\").equals(mockName.getFileName().toString());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"mock-of(%s)%s\", name, actions);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/CommandMockSpec.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+\/**\n+ * Command mock that runs a finite sequence of actions.\n+ *\/\n+public sealed interface CompletableCommandMock extends CommandMock permits ToolProviderCompletableCommandMock {\n+\n+    boolean completed();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/CompletableCommandMock.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.io.IOException;\n+\n+\/**\n+ * Simulates I\/O error.\n+ *\n+ * @see CommandMockExit#THROW_MOCK_IO_EXCEPTION\n+ *\/\n+public final class MockIOException extends IOException {\n+\n+    MockIOException(String msg) {\n+        super(msg);\n+    }\n+\n+    private static final long serialVersionUID = 1L;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/MockIOException.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+\/**\n+ * Indicates command mock internal error.\n+ *\/\n+public final class MockIllegalStateException extends IllegalStateException {\n+\n+    public MockIllegalStateException(String msg) {\n+        super(msg);\n+    }\n+\n+    private static final long serialVersionUID = 1L;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/MockIllegalStateException.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+\n+\/**\n+ * A command simulator implementing {@code ToolProvider}.\n+ * <p>\n+ * Iterates over actions and runs them. Each action is write to stdout\/stderr, create a file, etc.\n+ *\/\n+abstract sealed class MockingToolProvider implements ToolProviderCommandMock {\n+\n+    MockingToolProvider(String name, Iterator<CommandAction> actionIter) {\n+        this.name = Objects.requireNonNull(name);\n+        this.actionIter = Objects.requireNonNull(actionIter);\n+    }\n+\n+    static ToolProviderCommandMock createLoop(String name, Iterable<CommandAction> actions) {\n+        return new MockingToolProvider.NonCompletable(name, actions);\n+    }\n+\n+    static MockingToolProvider create(String name, Iterable<CommandAction> actions) {\n+        return new MockingToolProvider.Completable(name, actions);\n+    }\n+\n+    public boolean completed() {\n+        return !actionIter.hasNext();\n+    }\n+\n+    @Override\n+    public String name() {\n+        return name;\n+    }\n+\n+    @Override\n+    public int run(PrintStream out, PrintStream err, String... args) {\n+        var context = new CommandAction.Context(out, err, List.of(args));\n+        try {\n+            while (actionIter.hasNext()) {\n+                var action = actionIter.next();\n+                var reply = action.run(context);\n+                if (reply.isPresent()) {\n+                    return reply.get();\n+                }\n+            }\n+        } catch (RethrowableException ex) {\n+            \/\/ Let the checked exception out.\n+            throwAny(ex.getCause());\n+            \/\/ Unreachable\n+            return 0;\n+        } catch (Exception ex) {\n+            throw ExceptionBox.toUnchecked(ex);\n+        }\n+\n+        \/\/ No more actions to execute, but still expect it to keep going.\n+        throw new MockIllegalStateException(\"No more actions to execute\");\n+    }\n+\n+    @Override\n+    public int run(PrintWriter out, PrintWriter err, String... args) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    static final class RethrowableException extends Exception {\n+\n+        RethrowableException(Exception ex) {\n+            super(Objects.requireNonNull(ex));\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <E extends Throwable> void throwAny(Throwable e) throws E {\n+        throw (E)e;\n+    }\n+\n+    private static final class LoopIterator<T> implements Iterator<T> {\n+\n+        LoopIterator(Iterable<T> iterable) {\n+            this.iterable = Objects.requireNonNull(iterable);\n+            rewind();\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return iter != null;\n+        }\n+\n+        @Override\n+        public T next() {\n+            if (!hasNext()) {\n+                throw new NoSuchElementException();\n+            } else if (iter.hasNext()) {\n+                return iter.next();\n+            } else {\n+                rewind();\n+                if (!hasNext()) {\n+                    throw new NoSuchElementException();\n+                } else {\n+                    return iter.next();\n+                }\n+            }\n+        }\n+\n+        private void rewind() {\n+            iter = Objects.requireNonNull(iterable.iterator());\n+            if (!iter.hasNext()) {\n+                iter = null;\n+            }\n+        }\n+\n+        private final Iterable<T> iterable;\n+        private Iterator<T> iter;\n+    }\n+\n+    static final class NonCompletable extends MockingToolProvider {\n+\n+        NonCompletable(String name, Iterable<CommandAction> actions) {\n+            super(name, new LoopIterator<>(actions));\n+        }\n+\n+    }\n+\n+    static final class Completable extends MockingToolProvider implements ToolProviderCompletableCommandMock {\n+\n+        Completable(String name, Iterable<CommandAction> actions) {\n+            super(name, actions.iterator());\n+        }\n+\n+    }\n+\n+    private final String name;\n+    private final Iterator<CommandAction> actionIter;\n+\n+    static ToolProviderCommandMock UNREACHABLE = new MockingToolProvider.NonCompletable(\"<unreachable>\", List.of());\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/MockingToolProvider.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,297 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.IdentityWrapper;\n+\n+\/**\n+ * Script of command mocks.\n+ *\/\n+public interface Script {\n+\n+    \/**\n+     * Returns a command mock for the given command line.\n+     *\n+     * @param cmdline the command line for which to look up a command mock\n+     *\n+     * @return a command mock matching the given command line\n+     * @throws ScriptException if an internal script error occures\n+     *\/\n+    CommandMock map(List<String> cmdline) throws ScriptException;\n+\n+    \/**\n+     * Returns command mocks registered with this object that have not completed yet.\n+     *\n+     * @See {@link CompletableCommandMock#completed()}\n+     *\n+     * @return the command mocks registered with this object that have not completed yet\n+     *\/\n+    Collection<CompletableCommandMock> incompleteMocks();\n+\n+    public static Builder build() {\n+        return new Builder();\n+    }\n+\n+    public static <T> Predicate<List<String>> cmdlinePredicate(\n+            Predicate<T> pred,\n+            Function<String, T> conv,\n+            Function<List<String>, Stream<String>> toStream) {\n+\n+        Objects.requireNonNull(pred);\n+        Objects.requireNonNull(conv);\n+        Objects.requireNonNull(toStream);\n+\n+        return cmdline -> {\n+            return toStream.apply(cmdline).map(conv).filter(pred).findFirst().isPresent();\n+        };\n+    }\n+\n+    public static Predicate<List<String>> cmdlineContains(String arg) {\n+        return cmdlinePredicate(Predicate.isEqual(Objects.requireNonNull(arg)), x -> x, List::stream);\n+    }\n+\n+    public static Predicate<List<String>> cmdlineContains(Path arg) {\n+        return cmdlinePredicate(Predicate.<Path>isEqual(Objects.requireNonNull(arg)), Path::of, List::stream);\n+    }\n+\n+    public static Predicate<List<String>> cmdlineStartsWith(String arg) {\n+        return cmdlinePredicate(Predicate.isEqual(Objects.requireNonNull(arg)), x -> x, cmdline -> {\n+            return cmdline.stream().limit(1);\n+        });\n+    }\n+\n+    public static Predicate<List<String>> cmdlineStartsWith(Path arg) {\n+        return cmdlinePredicate(Predicate.<Path>isEqual(Objects.requireNonNull(arg)), Path::of, cmdline -> {\n+            return cmdline.stream().limit(1);\n+        });\n+    }\n+\n+    public final class ScriptException extends RuntimeException {\n+\n+        ScriptException(RuntimeException cause) {\n+            super(Objects.requireNonNull(cause));\n+        }\n+\n+        ScriptException(String msg) {\n+            super(Objects.requireNonNull(msg));\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    public final class Builder {\n+\n+        public Script createSequence() {\n+            return new SequenceScript(List.copyOf(instructions), completableMocks());\n+        }\n+\n+        public Script createLoop() {\n+            return new LoopScript(List.copyOf(instructions), completableMocks());\n+        }\n+\n+        public Builder map(Predicate<List<String>> pred, CommandMock mock) {\n+            Objects.requireNonNull(pred);\n+            Objects.requireNonNull(mock);\n+            if (mock instanceof CompletableCommandMock completable) {\n+                completableMocks.add(new IdentityWrapper<>(completable));\n+            }\n+            instruction(cmdline -> {\n+                if (pred.test(cmdline)) {\n+                    return new CommandMockResult(Optional.of(mock));\n+                } else {\n+                    return new CommandMockResult(Optional.empty());\n+                }\n+            });\n+            return this;\n+        }\n+\n+        public Builder map(Predicate<List<String>> pred, CommandMock.Builder mock) {\n+            Optional.ofNullable(commandMockBuilderMutator).ifPresent(mock::mutate);\n+            return map(pred, mock.create());\n+        }\n+\n+        public Builder map(Predicate<List<String>> pred, CommandMockSpec mock) {\n+            return map(pred, mock.toCommandMockBuilder());\n+        }\n+\n+        public Builder map(CommandMockSpec mock) {\n+            return map(cmdlineStartsWith(mock.name()), mock.toCommandMockBuilder());\n+        }\n+\n+        public Builder use(CommandMock mock) {\n+            return map(_ -> true, mock);\n+        }\n+\n+        public Builder use(Predicate<List<String>> pred, CommandMock.Builder mock) {\n+            return map(_ -> true, mock);\n+        }\n+\n+        public Builder use(Predicate<List<String>> pred, CommandMockSpec mock) {\n+            return map(_ -> true, mock);\n+        }\n+\n+        public Builder branch(Predicate<List<String>> pred, Script script) {\n+            Objects.requireNonNull(pred);\n+            Objects.requireNonNull(script);\n+            instruction(cmdline -> {\n+                if (pred.test(cmdline)) {\n+                    return new ScriptResult(script);\n+                } else {\n+                    return new CommandMockResult(Optional.empty());\n+                }\n+            });\n+            return this;\n+        }\n+\n+        public Builder commandMockBuilderMutator(Consumer<CommandMock.Builder> v) {\n+            commandMockBuilderMutator = v;\n+            return this;\n+        }\n+\n+        public Builder mutate(Consumer<Script.Builder> mutator) {\n+            mutator.accept(this);\n+            return this;\n+        }\n+\n+        private Builder instruction(Function<List<String>, Result> instruction) {\n+            instructions.add(Objects.requireNonNull(instruction));\n+            return this;\n+        }\n+\n+        private Collection<CompletableCommandMock> completableMocks() {\n+            return completableMocks.stream().map(IdentityWrapper::value).toList();\n+        }\n+\n+        private static RuntimeException noMapping(List<String> cmdline) {\n+            return new ScriptException(String.format(\"Mapping for %s command line not found\", cmdline));\n+        }\n+\n+        private sealed interface Result {\n+        }\n+\n+        private record CommandMockResult(Optional<CommandMock> value) implements Result {\n+            CommandMockResult {\n+                Objects.requireNonNull(value);\n+            }\n+        }\n+\n+        private record ScriptResult(Script value) implements Result {\n+            ScriptResult {\n+                Objects.requireNonNull(value);\n+            }\n+        }\n+\n+        private abstract static class AbstractScript implements Script {\n+\n+            AbstractScript(Collection<CompletableCommandMock> completableMocks) {\n+                this.completableMocks = Objects.requireNonNull(completableMocks);\n+            }\n+\n+            @Override\n+            public Collection<CompletableCommandMock> incompleteMocks() {\n+                return completableMocks.stream().filter(Predicate.not(CompletableCommandMock::completed)).toList();\n+            }\n+\n+            private final Collection<CompletableCommandMock> completableMocks;\n+        }\n+\n+        private static final class LoopScript extends AbstractScript {\n+\n+            LoopScript(List<Function<List<String>, Result>> instructions,\n+                    Collection<CompletableCommandMock> completableMocks) {\n+                super(completableMocks);\n+                this.instructions = Objects.requireNonNull(instructions);\n+            }\n+\n+            @Override\n+            public CommandMock map(List<String> cmdline) {\n+                for (var instruction : instructions) {\n+                    switch (instruction.apply(cmdline)) {\n+                        case CommandMockResult result -> {\n+                            var mock = result.value();\n+                            if (mock.isPresent()) {\n+                                return mock.get();\n+                            }\n+                        }\n+                        case ScriptResult result -> {\n+                            return result.value().map(cmdline);\n+                        }\n+                    }\n+                }\n+\n+                throw noMapping(cmdline);\n+            }\n+\n+            private final List<Function<List<String>, Result>> instructions;\n+        }\n+\n+        private static final class SequenceScript extends AbstractScript {\n+\n+            SequenceScript(List<Function<List<String>, Result>> instructions,\n+                    Collection<CompletableCommandMock> completableMocks) {\n+                super(completableMocks);\n+                this.iter = instructions.iterator();\n+            }\n+\n+            @Override\n+            public CommandMock map(List<String> cmdline) {\n+                if (!iter.hasNext()) {\n+                    throw new ScriptException(\"No more mappings\");\n+                } else {\n+                    switch (iter.next().apply(cmdline)) {\n+                        case CommandMockResult result -> {\n+                            var mock = result.value();\n+                            if (mock.isPresent()) {\n+                                return mock.get();\n+                            }\n+                        }\n+                        case ScriptResult result -> {\n+                            return result.value().map(cmdline);\n+                        }\n+                    }\n+                }\n+\n+                throw noMapping(cmdline);\n+            }\n+\n+            private final Iterator<Function<List<String>, Result>> iter;\n+        }\n+\n+        private Consumer<CommandMock.Builder> commandMockBuilderMutator = CommandMock.Builder::noRepeats;\n+        private final List<Function<List<String>, Result>> instructions = new ArrayList<>();\n+        private final Set<IdentityWrapper<CompletableCommandMock>> completableMocks = new HashSet<>();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/Script.java","additions":297,"deletions":0,"binary":false,"changes":297,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * Specification of a {@link Script}.\n+ *\/\n+public record ScriptSpec(List<Item> items, boolean loop) {\n+\n+    public ScriptSpec {\n+        Objects.requireNonNull(items);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        var sb = new StringBuilder();\n+        sb.append(items.toString());\n+        if (loop) {\n+            \/\/ Append \"Clockwise Gapped Circle Arrow\" Unicode symbol.\n+            sb.append('(').appendCodePoint(0x27F3).append(')');\n+        }\n+        return sb.toString();\n+    }\n+\n+    public Script create() {\n+        var script = Script.build();\n+        items.forEach(item -> {\n+            item.applyTo(script, loop);\n+        });\n+        if (loop) {\n+            return script.createLoop();\n+        } else {\n+            return script.createSequence();\n+        }\n+    }\n+\n+    public Collection<Path> commandNames() {\n+        return items.stream().map(Item::mockSpec).map(CommandMockSpec::name).distinct().toList();\n+    }\n+\n+    private record Item(CommandMockSpec mockSpec, int repeatCount, boolean detailedDescription) {\n+\n+        private Item {\n+            Objects.requireNonNull(mockSpec);\n+            if (repeatCount < 0) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            var sb = new StringBuilder();\n+            if (detailedDescription) {\n+                sb.append(mockSpec);\n+            } else if (mockSpec.isDefaultMockName()) {\n+                sb.append(mockSpec.name());\n+            } else {\n+                sb.append(mockSpec.mockName());\n+            }\n+            if (repeatCount > 0) {\n+                sb.append('(').append(repeatCount + 1).append(')');\n+            }\n+            return sb.toString();\n+        }\n+\n+        void applyTo(Script.Builder script, boolean loopScript) {\n+            var pred = Script.cmdlineStartsWith(mockSpec.name());\n+\n+            var mockBuilder = mockSpec.toCommandMockBuilder();\n+            if (loopScript) {\n+                script.map(pred, mockBuilder.repeat(repeatCount).create());\n+            } else {\n+                mockBuilder.repeat(0);\n+                IntStream.rangeClosed(0, repeatCount).forEach(_ -> {\n+                    script.map(pred, mockBuilder.create());\n+                });\n+            }\n+        }\n+\n+    }\n+\n+    public static Builder build() {\n+        return new Builder();\n+    }\n+\n+    public static final class Builder {\n+\n+        private Builder() {\n+        }\n+\n+        public ScriptSpec create() {\n+            return new ScriptSpec(List.copyOf(items), loop);\n+        }\n+\n+        public Builder loop(boolean v) {\n+            loop = v;\n+            return this;\n+        }\n+\n+        public Builder loop() {\n+            return loop(true);\n+        }\n+\n+        public final class ItemBuilder {\n+\n+            private ItemBuilder(CommandMockSpec mockSpec) {\n+                this.mockSpec = Objects.requireNonNull(mockSpec);\n+            }\n+\n+            public Builder add() {\n+                items.add(new Item(mockSpec, repeat, detailedDescription));\n+                return Builder.this;\n+            }\n+\n+            public ItemBuilder repeat(int v) {\n+                if (repeat < 0) {\n+                    throw new IllegalArgumentException();\n+                }\n+                repeat = v;\n+                return this;\n+            }\n+\n+            public ItemBuilder detailedDescription(boolean v) {\n+                detailedDescription = v;\n+                return this;\n+            }\n+\n+            public ItemBuilder detailedDescription() {\n+                return detailedDescription(true);\n+            }\n+\n+            private final CommandMockSpec mockSpec;\n+            private int repeat;\n+            private boolean detailedDescription;\n+        }\n+\n+        public Builder add(CommandMockSpec mockSpec) {\n+            return build(mockSpec).add();\n+        }\n+\n+        public Builder addLoop(CommandMockSpec mockSpec) {\n+            return build(mockSpec).add();\n+        }\n+\n+        public ItemBuilder build(CommandMockSpec mockSpec) {\n+            return new ItemBuilder(mockSpec);\n+        }\n+\n+        private final List<Item> items = new ArrayList<>();\n+        private boolean loop;\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/ScriptSpec.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+\n+\/**\n+ * Specification of a {@link Script} bound to a specific directory.\n+ *\/\n+public class ScriptSpecInDir {\n+\n+    public ScriptSpecInDir() {\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return scriptSpec.toString();\n+    }\n+\n+    public boolean isPathInDir(Path path) {\n+        return path.startsWith(dir);\n+    }\n+\n+    public ScriptSpecInDir dir(Path v) {\n+        dir = v;\n+        return this;\n+    }\n+\n+    public ScriptSpecInDir scriptSpec(ScriptSpec v) {\n+        scriptSpec = v;\n+        return this;\n+    }\n+\n+    public ScriptSpec scriptSpec() {\n+        Objects.requireNonNull(dir);\n+        return Objects.requireNonNull(scriptSpec);\n+    }\n+\n+    public Script create() {\n+        return scriptSpec().create();\n+    }\n+\n+    private ScriptSpec scriptSpec;\n+    private Path dir;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/ScriptSpecInDir.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.util.spi.ToolProvider;\n+\n+public sealed interface ToolProviderCommandMock extends CommandMock, ToolProvider\n+    permits ToolProviderCompletableCommandMock, MockingToolProvider {\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/ToolProviderCommandMock.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+public sealed interface ToolProviderCompletableCommandMock extends ToolProviderCommandMock, CompletableCommandMock\n+    permits MockingToolProvider.Completable {\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/ToolProviderCompletableCommandMock.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+public enum VerbatimCommandMock implements CommandMock {\n+\n+    INSTANCE\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/VerbatimCommandMock.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import jdk.jpackage.test.mock.CommandActionSpecs;\n+import jdk.jpackage.test.mock.CommandMockExit;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+\n+public class LibProvidersLookupTest {\n+\n+    @ParameterizedTest\n+    @EnumSource(value = CommandMockExit.class)\n+    public void test_supported(CommandMockExit exit) {\n+\n+        var ldd = CommandActionSpecs.build().exit(exit).toCommandMockBuilder().name(\"ldd-mock\").create();\n+\n+        Globals.main(() -> {\n+            Globals.instance().executorFactory(() -> {\n+                return new Executor().mapper(executor -> {\n+                    return executor.copy().mapper(null).toolProvider(ldd);\n+                });\n+            });\n+\n+            boolean actual = LibProvidersLookup.supported();\n+            assertEquals(exit.exitNormally(), actual);\n+\n+            return 0;\n+        });\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/jdk.jpackage\/jdk\/jpackage\/internal\/LibProvidersLookupTest.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.model.StandardPackageType.LINUX_DEB;\n+import static jdk.jpackage.internal.model.StandardPackageType.LINUX_RPM;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.internal.util.Result;\n+import jdk.jpackage.test.mock.CommandActionSpecs;\n+import jdk.jpackage.test.mock.CommandMockExit;\n+import jdk.jpackage.test.mock.CommandMockSpec;\n+import jdk.jpackage.test.mock.Script;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class LinuxPackageArchTest {\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test(Runnable test) {\n+        test.run();\n+    }\n+\n+    private static List<Runnable> test() {\n+        var data = new ArrayList<Runnable>();\n+\n+        \/\/ \"foo\" stdout interleaved with \"bar\" stderr\n+        var fooArch = CommandActionSpecs.build()\n+                .printToStdout(\"f\").printToStderr(\"b\")\n+                .printToStdout(\"o\").printToStderr(\"a\")\n+                .printToStdout(\"o\").printToStderr(\"r\");\n+\n+        for (var exit : CommandMockExit.values()) {\n+            var dpkg = fooArch.copy().printToStdout(\"-deb\").exit(exit).create();\n+\n+            data.add(new DebTestSpec(dpkg, Optional.of(\"foo-deb\").filter(_ -> {\n+                return exit.succeed();\n+            })));\n+        }\n+\n+        for (var rpmbuildExit : CommandMockExit.values()) {\n+            var rpmbuild = fooArch.copy().printToStdout(\"-rpmbuild\").exit(rpmbuildExit).create();\n+            for (var rpmExit : CommandMockExit.values()) {\n+                var rpm = fooArch.copy().printToStdout(\"-rpm\").exit(rpmExit).create();\n+                Optional<String> expect;\n+                if (rpmbuildExit.succeed()) {\n+                    expect = Optional.of(\"foo-rpmbuild\");\n+                    rpm = CommandActionSpecs.UNREACHABLE;\n+                } else {\n+                    if (rpmExit.succeed()) {\n+                        expect = Optional.of(\"foo-rpm\");\n+                    } else {\n+                        expect = Optional.empty();\n+                    }\n+                }\n+\n+                data.add(new RpmTestSpec(rpmbuild, rpm, expect));\n+            }\n+        }\n+\n+        return data;\n+    }\n+\n+    record RpmTestSpec(CommandActionSpecs rpmbuild, CommandActionSpecs rpm, Optional<String> expect) implements Runnable {\n+\n+        RpmTestSpec {\n+            Objects.requireNonNull(rpm);\n+            Objects.requireNonNull(rpmbuild);\n+            Objects.requireNonNull(expect);\n+        }\n+\n+        @Override\n+        public void run() {\n+\n+            \/\/ Create an executor factory that will:\n+            \/\/  - Substitute the \"rpm\" command with `rpm` mock.\n+            \/\/  - Substitute the \"rpmbuild\" command with `rpmbuild` mock.\n+            \/\/  - Throw if a command with the name other than \"rpm\" and \"rpmbuild\" is requested for execution.\n+\n+            var script = Script.build()\n+                    \/\/ LinuxPackageArch must run the \"rpmbuild\" command first. Put its mapping at the first position.\n+                    .map(new CommandMockSpec(\"rpmbuild\", rpmbuild))\n+                    \/\/ LinuxPackageArch may optionally run the \"rpm\" command. Put its mapping after the \"rpmbuild\" command mapping.\n+                    .map(new CommandMockSpec(\"rpm\", rpm))\n+                    \/\/ Create a sequential script: after every Script#map() call, the script will advance the current mapping.\n+                    \/\/ This means each mapping in the script will be considered only once.\n+                    \/\/ If \"rpm\" and \"rpmbuild\" commands are executed in reverse order, the second Script#map() will throw.\n+                    .createSequence();\n+\n+            test(expect, LINUX_RPM, script);\n+        }\n+    }\n+\n+    record DebTestSpec(CommandActionSpecs dpkg, Optional<String> expect) implements Runnable {\n+\n+        DebTestSpec {\n+            Objects.requireNonNull(dpkg);\n+            Objects.requireNonNull(expect);\n+        }\n+\n+        @Override\n+        public void run() {\n+            var script = Script.build().map(new CommandMockSpec(\"dpkg\", dpkg)).createSequence();\n+\n+            test(expect, LINUX_DEB, script);\n+        }\n+    }\n+\n+    private static void test(Optional<String> expectedArch, StandardPackageType pkgType, Script script) {\n+\n+        Globals.main(() -> {\n+\n+            MockUtils.buildJPackage().script(script).applyToGlobals();\n+\n+            Result<LinuxPackageArch> arch = LinuxPackageArch.create(pkgType);\n+\n+            assertEquals(arch.hasValue(), expectedArch.isPresent());\n+            expectedArch.ifPresent(v -> {\n+                assertEquals(v, arch.orElseThrow().value());\n+            });\n+\n+            assertEquals(List.of(), script.incompleteMocks());\n+\n+            return 0;\n+        });\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/jdk.jpackage\/jdk\/jpackage\/internal\/LinuxPackageArchTest.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.test.mock.CommandActionSpecs;\n+import jdk.jpackage.test.mock.CommandMockExit;\n+import jdk.jpackage.test.mock.CommandMockSpec;\n+import jdk.jpackage.test.mock.Script;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class LinuxSystemEnvironmentTest {\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_detectNativePackageType(DetectNativePackageTypeTestSpec test) {\n+        test.run();\n+    }\n+\n+    private static List<DetectNativePackageTypeTestSpec> test_detectNativePackageType() {\n+        var data = new ArrayList<DetectNativePackageTypeTestSpec>();\n+        for (var rpmExit : CommandMockExit.values()) {\n+            for (var debExit : CommandMockExit.values()) {\n+                CommandActionSpecs deb = CommandActionSpecs.build().exit(debExit).create();\n+                CommandActionSpecs rpm;\n+                Optional<StandardPackageType> expected;\n+                if (debExit.succeed()) {\n+                    expected = Optional.of(StandardPackageType.LINUX_DEB);\n+                    rpm = CommandActionSpecs.UNREACHABLE;\n+                } else {\n+                    rpm = CommandActionSpecs.build().exit(rpmExit).create();\n+                    if (rpmExit.succeed()) {\n+                        expected = Optional.of(StandardPackageType.LINUX_RPM);\n+                    } else {\n+                        expected = Optional.empty();\n+                    }\n+                }\n+                data.add(new DetectNativePackageTypeTestSpec(expected, rpm, deb));\n+            }\n+        }\n+        return data;\n+    }\n+\n+    record DetectNativePackageTypeTestSpec(Optional<StandardPackageType> expect, CommandActionSpecs rpm, CommandActionSpecs deb) {\n+\n+        DetectNativePackageTypeTestSpec {\n+            Objects.requireNonNull(expect);\n+            Objects.requireNonNull(rpm);\n+            Objects.requireNonNull(deb);\n+        }\n+\n+        void run() {\n+\n+            var script = Script.build()\n+                    .map(new CommandMockSpec(\"rpm\", rpm))\n+                    .map(new CommandMockSpec(\"dpkg\", deb))\n+                    .createLoop();\n+\n+            Globals.main(() -> {\n+\n+                MockUtils.buildJPackage().script(script).applyToGlobals();\n+\n+                var actual = LinuxSystemEnvironment.detectNativePackageType();\n+\n+                assertEquals(expect, actual);\n+\n+                assertEquals(List.of(), script.incompleteMocks());\n+\n+                return 0;\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/jdk.jpackage\/jdk\/jpackage\/internal\/LinuxSystemEnvironmentTest.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,32 @@\n+\n+\/* @test\n+ * @summary Test LinuxSystemEnvironment\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.mock.*\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/LinuxSystemEnvironmentTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/MockUtils.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.LinuxSystemEnvironmentTest\n+ *\/\n+\n+\/* @test\n+ * @summary Test LibProvidersLookup\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.mock.*\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/LibProvidersLookupTest.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.LibProvidersLookupTest\n+ *\/\n+\n+\/* @test\n+ * @summary Test LinuxPackageArch\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.mock.*\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/LinuxPackageArchTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/MockUtils.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.LinuxPackageArchTest\n+ *\/\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/junit.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,420 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.model.StandardPackageType.MAC_DMG;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.MacPackagingPipeline.MacBuildApplicationTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.BuildApplicationTaskID;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.RuntimeBuilder;\n+import jdk.jpackage.internal.util.CommandOutputControl.UnexpectedResultException;\n+import jdk.jpackage.internal.util.FileUtils;\n+import jdk.jpackage.internal.util.RetryExecutor;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import jdk.jpackage.test.mock.CommandActionSpec;\n+import jdk.jpackage.test.mock.CommandActionSpecs;\n+import jdk.jpackage.test.mock.CommandMockSpec;\n+import jdk.jpackage.test.mock.MockIllegalStateException;\n+import jdk.jpackage.test.mock.ScriptSpec;\n+import jdk.jpackage.test.mock.ScriptSpecInDir;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class MacDmgPackagerTest {\n+\n+    \/**\n+     * Exercise branches in {@link MacDmgPackager#buildDMG()}.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test(DmgScript scriptSpec, @TempDir Path workDir) {\n+        scriptSpec.run(workDir);\n+    }\n+\n+    private static List<DmgScript> test() {\n+        var data = new ArrayList<DmgScript>();\n+\n+        var succeed = CommandActionSpecs.build().exit().create();\n+        var fail = CommandActionSpecs.build().exit(1).create();\n+\n+        \/\/ Test create\n+        for (var createFullSucceed : List.of(true, false)) {\n+            var dmgScript = new DmgScript();\n+\n+            var scriptBuilder = ScriptSpec.build();\n+\n+            if (createFullSucceed) {\n+                \/\/ `hdiutil create -srcfolder` succeeds\n+                scriptBuilder.add(new CommandMockSpec(\"hdiutil\", \"hdiutil-create\", dmgScript.hdiutilCreate().exit().create()));\n+            } else {\n+                \/\/ `hdiutil create -srcfolder` fails\n+                scriptBuilder.add(new CommandMockSpec(\"hdiutil\", \"hdiutil-create\", fail));\n+                scriptBuilder.add(new CommandMockSpec(\"hdiutil\", \"hdiutil-create-empty\", dmgScript.hdiutilCreateEmpty().exit().create()));\n+            }\n+\n+            scriptBuilder\n+                    \/\/ `hdiutil attach` succeeds\n+                    .add(new CommandMockSpec(\"hdiutil\", \"hdiutil-attach\", succeed))\n+                    \/\/ `osascript` succeeds\n+                    .add(new CommandMockSpec(\"osascript\", succeed))\n+                    \/\/ `hdiutil detach` succeeds\n+                    .add(new CommandMockSpec(\"hdiutil\", \"hdiutil-detach\", dmgScript.hdiutilDetach().exit().create()))\n+                    \/\/ `hdiutil convert` succeeds\n+                    .add(new CommandMockSpec(\"hdiutil\", \"hdiutil-convert\", dmgScript.hdiutilConvert().exit().create()));\n+\n+            data.add(dmgScript.scriptSpec(scriptBuilder.create()));\n+        }\n+\n+        \/\/ Test detach\n+        for (var detachResult : DetachResult.values()) {\n+            var dmgScript = new DmgScript();\n+\n+            var scriptBuilder = ScriptSpec.build()\n+                    .add(new CommandMockSpec(\"hdiutil\", \"hdiutil-create\", dmgScript.hdiutilCreate().exit().create()))\n+                    .add(new CommandMockSpec(\"hdiutil\", \"hdiutil-attach\", succeed))\n+                    .add(new CommandMockSpec(\"osascript\", succeed));\n+\n+            switch (detachResult) {\n+                case ALL_FAIL -> {\n+                    dmgScript.expect(UnexpectedResultException.class);\n+                    scriptBuilder.build(new CommandMockSpec(\"hdiutil\", \"hdiutil-detach\", fail)).repeat(9).add();\n+                }\n+                case LAST_SUCCEED -> {\n+                    scriptBuilder\n+                            .build(new CommandMockSpec(\"hdiutil\", \"hdiutil-detach\", fail)).repeat(8).add()\n+                            .add(new CommandMockSpec(\"hdiutil\", \"hdiutil-detach\", dmgScript.hdiutilDetach().exit().create()))\n+                            .add(new CommandMockSpec(\"hdiutil\", \"hdiutil-convert\", dmgScript.hdiutilConvert().exit().create()));\n+                }\n+                case FIRST_SUCCEED_WITH_EXIT_1 -> {\n+                    scriptBuilder\n+                            .build(new CommandMockSpec(\"hdiutil\", \"hdiutil-detach\", dmgScript.hdiutilDetach().exit(1).create()))\n+                                    .detailedDescription().add()\n+                            .add(new CommandMockSpec(\"hdiutil\", \"hdiutil-convert\", dmgScript.hdiutilConvert().exit().create()));\n+                }\n+                case FIRST_SUCCEED_MOUNT_POINT_REMAINS -> {\n+                    scriptBuilder\n+                            .build(new CommandMockSpec(\"hdiutil\", \"hdiutil-detach\", dmgScript.hdiutilDetach(false).exit().create()))\n+                                    .detailedDescription().add()\n+                            .add(new CommandMockSpec(\"hdiutil\", \"hdiutil-convert\", dmgScript.hdiutilConvert().exit().create()));\n+                }\n+            }\n+\n+            data.add(dmgScript.scriptSpec(scriptBuilder.create()));\n+        }\n+\n+        return data;\n+    }\n+\n+    private enum DetachResult {\n+        ALL_FAIL,\n+        LAST_SUCCEED,\n+        \/\/ The first `hdiutil detach` attempt exits with exit code \"1\" but deletes the mounted directory.\n+        FIRST_SUCCEED_WITH_EXIT_1,\n+        \/\/ The first `hdiutil detach` attempt exits with exit code \"0\" and the mounted directory stays undeleted.\n+        FIRST_SUCCEED_MOUNT_POINT_REMAINS,\n+        ;\n+    }\n+\n+    private static MacDmgSystemEnvironment createSysEnv(ScriptSpec scriptSpec) {\n+        return new MacDmgSystemEnvironment(\n+                Path.of(\"hdiutil\"),\n+                Path.of(\"osascript\"),\n+                Stream.of(\"SetFile\").map(Path::of).filter(scriptSpec.commandNames()::contains).findFirst()\n+        );\n+    }\n+\n+    private static RuntimeBuilder createRuntimeBuilder() {\n+        return new RuntimeBuilder() {\n+            @Override\n+            public void create(AppImageLayout appImageLayout) {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+    }\n+\n+    private static void runPackagingMock(Path workDir, MacDmgSystemEnvironment sysEnv) {\n+\n+        var app = new ApplicationBuilder()\n+                .appImageLayout(MacPackagingPipeline.APPLICATION_LAYOUT)\n+                .runtimeBuilder(createRuntimeBuilder())\n+                .name(\"foo\")\n+                .create();\n+\n+        var macApp = new MacApplicationBuilder(app).create();\n+\n+        var macDmgPkg = new MacDmgPackageBuilder(new MacPackageBuilder(new PackageBuilder(macApp, MAC_DMG))).create();\n+\n+        var buildEnv = new BuildEnvBuilder(workDir.resolve(\"build-root\")).appImageDirFor(macDmgPkg).create();\n+\n+        var packager = new MacDmgPackager(buildEnv, macDmgPkg, workDir, sysEnv);\n+\n+        var pipelineBuilder = MacPackagingPipeline.build(Optional.of(packager.pkg()));\n+        packager.accept(pipelineBuilder);\n+\n+        \/\/ Disable actions of tasks filling an application image.\n+        Stream.concat(\n+                Stream.of(BuildApplicationTaskID.values()),\n+                Stream.of(MacBuildApplicationTaskID.values())\n+        ).forEach(taskId -> {\n+            pipelineBuilder.task(taskId).noaction().add();\n+        });\n+\n+        var contentMock = new ContentMock();\n+\n+        \/\/ Fill application image with content mock.\n+        pipelineBuilder.task(BuildApplicationTaskID.CONTENT).applicationAction(env -> {\n+            contentMock.create(env.resolvedLayout().contentDirectory());\n+        }).add();\n+\n+        pipelineBuilder.create().execute(buildEnv, packager.pkg(), packager.outputDir());\n+\n+        var outputDmg = packager.outputDir().resolve(packager.pkg().packageFileNameWithSuffix());\n+\n+        contentMock.verifyStoredInFile(outputDmg);\n+    }\n+\n+    private static final class DmgScript extends ScriptSpecInDir {\n+\n+        @Override\n+        public String toString() {\n+            var sb = new StringBuilder();\n+            sb.append(super.toString());\n+            Optional.ofNullable(expectedErrorType).ifPresent(type -> {\n+                sb.append(\"; \").append(type.getCanonicalName());\n+            });\n+            return sb.toString();\n+        }\n+\n+        @Override\n+        public DmgScript scriptSpec(ScriptSpec v) {\n+            super.scriptSpec(v);\n+            return this;\n+        }\n+\n+        DmgScript expect(Class<? extends Exception> v) {\n+            expectedErrorType = v;\n+            return this;\n+        }\n+\n+        void run(Path workDir) {\n+\n+            var script = dir(Objects.requireNonNull(workDir)).create();\n+\n+            ExecutorFactory executorFactory = MockUtils.buildJPackage()\n+                    .script(script).listener(System.out::println).createExecutorFactory();\n+\n+            var objectFactory = ObjectFactory.build()\n+                    .executorFactory(executorFactory)\n+                    .retryExecutorFactory(new RetryExecutorFactory() {\n+                        @Override\n+                        public <T, E extends Exception> RetryExecutor<T, E> retryExecutor(Class<? extends E> exceptionType) {\n+                            return RetryExecutorFactory.DEFAULT.<T, E>retryExecutor(exceptionType).setSleepFunction(_ -> {\n+                                \/\/ Don't \"sleep\" to make the test run faster.\n+                            });\n+                        }\n+                    })\n+                    .create();\n+\n+            Globals.main(() -> {\n+                Globals.instance().objectFactory(objectFactory);\n+                if (expectedErrorType == null) {\n+                    runPackagingMock(workDir, createSysEnv(scriptSpec()));\n+                } else {\n+                    var ex = assertThrows(Exception.class, () -> {\n+                        runPackagingMock(workDir, createSysEnv(scriptSpec()));\n+                    });\n+                    var cause = ExceptionBox.unbox(ex);\n+                    assertEquals(expectedErrorType, cause.getClass());\n+                }\n+                return 0;\n+            });\n+\n+            assertEquals(List.of(), script.incompleteMocks());\n+        }\n+\n+        CommandActionSpecs.Builder hdiutilCreate(boolean empty) {\n+            CommandActionSpec action = CommandActionSpec.create(\"create\", context -> {\n+                var dstDmg = Path.of(context.optionValue(\"-ov\"));\n+                assertTrue(isPathInDir(dstDmg));\n+\n+                var volumeName = context.optionValue(\"-volname\");\n+\n+                if (empty) {\n+                    createDmg(new CreateDmgResult(dstDmg, volumeName, Optional.empty()));\n+                    Files.createFile(dstDmg);\n+                } else {\n+                    var srcDir = Path.of(context.optionValue(\"-srcfolder\"));\n+                    assertTrue(isPathInDir(srcDir));\n+\n+                    createDmg(new CreateDmgResult(dstDmg, volumeName, Optional.of(srcDir)));\n+\n+                    try (var walk = Files.walk(srcDir)) {\n+                        var paths = walk.map(srcDir::relativize).map(Path::toString).toList();\n+                        Files.write(dstDmg, paths);\n+                    }\n+                }\n+            });\n+            return CommandActionSpecs.build().action(action);\n+        }\n+\n+        CommandActionSpecs.Builder hdiutilCreate() {\n+            return hdiutilCreate(false);\n+        }\n+\n+        CommandActionSpecs.Builder hdiutilCreateEmpty() {\n+            return hdiutilCreate(true);\n+        }\n+\n+        CommandActionSpecs.Builder hdiutilDetach() {\n+            return hdiutilDetach(true);\n+        }\n+\n+        CommandActionSpecs.Builder hdiutilDetach(boolean deleteMountPoint) {\n+            var sb = new StringBuilder();\n+            sb.append(\"detach\");\n+            if (!deleteMountPoint) {\n+                sb.append(\"(rm-mount-point)\");\n+            }\n+            CommandActionSpec action = CommandActionSpec.create(sb.toString(), context -> {\n+                var mountPoint = Path.of(context.args().getLast());\n+                assertTrue(isPathInDir(mountPoint));\n+\n+                try (var walk = Files.walk(mountPoint)) {\n+                    var dstDmg = dmg().dmg();\n+                    var paths = Stream.concat(\n+                            walk.map(mountPoint::relativize),\n+                            Files.readAllLines(dstDmg).stream().filter(Predicate.not(String::isEmpty)).map(Path::of)\n+                    ).sorted().map(Path::toString).toList();\n+                    Files.write(dstDmg, paths);\n+                }\n+\n+                if (deleteMountPoint) {\n+                    FileUtils.deleteRecursive(mountPoint);\n+                }\n+            });\n+            return CommandActionSpecs.build().action(action);\n+        }\n+\n+        CommandActionSpecs.Builder hdiutilConvert() {\n+            CommandActionSpec action = CommandActionSpec.create(\"convert\", context -> {\n+                var srcDmg = Path.of(context.args().get(1));\n+                assertTrue(isPathInDir(srcDmg));\n+\n+                var dstDmg = Path.of(context.args().getLast());\n+                assertTrue(isPathInDir(dstDmg));\n+\n+                Files.copy(srcDmg, dstDmg);\n+            });\n+            return CommandActionSpecs.build().action(action);\n+        }\n+\n+        private void createDmg(CreateDmgResult v) {\n+            if (dmg != null) {\n+                throw new MockIllegalStateException(\"The DMG already set\");\n+            } else {\n+                dmg = Objects.requireNonNull(v);\n+            }\n+        }\n+\n+        private CreateDmgResult dmg() {\n+            if (dmg == null) {\n+                throw new MockIllegalStateException(\"The DMG not set\");\n+            } else {\n+                return dmg;\n+            }\n+        }\n+\n+        private record CreateDmgResult(Path dmg, String volumeName, Optional<Path> srcFolder) {\n+            CreateDmgResult {\n+                Objects.requireNonNull(dmg);\n+                Objects.requireNonNull(volumeName);\n+                Objects.requireNonNull(srcFolder);\n+            }\n+        }\n+\n+        private CreateDmgResult dmg;\n+        private Class<? extends Exception> expectedErrorType;\n+    }\n+\n+    private static final class ContentMock {\n+\n+        void create(Path dir) throws IOException {\n+            Files.createDirectories(dir.resolve(\"foo\/bar\"));\n+            Files.writeString(dir.resolve(\"foo\/bar\/buz\"), \"Hello!\");\n+            if (!OperatingSystem.isWindows()) {\n+                Files.createSymbolicLink(dir.resolve(\"symlink\"), Path.of(\"foo\"));\n+            }\n+        }\n+\n+        void verifyStoredInFile(Path file) {\n+            try {\n+                var expectedPaths = Stream.of(\n+                        Stream.of(Path.of(\"\")),\n+                        DMG_ICON_FILES.stream(),\n+                        Stream.of(\n+                                Stream.of(\"foo\/bar\/buz\"),\n+                                Stream.of(\"symlink\").filter(_ -> {\n+                                    return !OperatingSystem.isWindows();\n+                                })\n+                        ).flatMap(x -> x).map(Path::of).map(Path.of(\"foo.app\/Contents\")::resolve)\n+                ).flatMap(x -> x).mapMulti(EXPAND_PATH).sorted().distinct().toList();\n+                var actualPaths = Files.readAllLines(file).stream().map(Path::of).toList();\n+                assertEquals(expectedPaths, actualPaths);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+    }\n+\n+    private final static BiConsumer<Path, Consumer<Path>> EXPAND_PATH = (path, sink) -> {\n+        do {\n+            sink.accept(path);\n+            path = path.getParent();\n+        } while (path != null);\n+    };\n+\n+    private final static List<Path> DMG_ICON_FILES = Stream.of(\n+            \".VolumeIcon.icns\",\n+            \".background\/background.tiff\"\n+    ).map(Path::of).collect(Collectors.toUnmodifiableList());\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/macosx\/jdk.jpackage\/jdk\/jpackage\/internal\/MacDmgPackagerTest.java","additions":420,"deletions":0,"binary":false,"changes":420,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import jdk.jpackage.internal.util.RetryExecutor;\n+import jdk.jpackage.test.mock.CommandActionSpecs;\n+import jdk.jpackage.test.mock.CommandMockExit;\n+import jdk.jpackage.test.mock.CommandMockSpec;\n+import jdk.jpackage.test.mock.Script;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class MacDmgSystemEnvironmentTest {\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void test_findSetFileUtility(FindSetFileUtilityTestSpec test) {\n+        test.run();\n+    }\n+\n+    private static List<FindSetFileUtilityTestSpec> test_findSetFileUtility() {\n+        var data = new ArrayList<FindSetFileUtilityTestSpec>();\n+\n+        var succeed = CommandActionSpecs.build().exit().create();\n+\n+        for (var failureCause : List.of(CommandMockExit.EXIT_1, CommandMockExit.THROW_MOCK_IO_EXCEPTION)) {\n+\n+            var fail = CommandActionSpecs.build().exit(failureCause).create();\n+\n+            for (var i = 0; i != MacDmgSystemEnvironment.SETFILE_KNOWN_PATHS.size(); i++) {\n+\n+                var expected = MacDmgSystemEnvironment.SETFILE_KNOWN_PATHS.get(i);\n+\n+                var mocks = new ArrayList<CommandMockSpec>();\n+\n+                MacDmgSystemEnvironment.SETFILE_KNOWN_PATHS.subList(0, i).stream().map(failureSetFilePath -> {\n+                    return new CommandMockSpec(failureSetFilePath, fail);\n+                }).forEach(mocks::add);\n+\n+                mocks.add(new CommandMockSpec(expected, succeed));\n+\n+                data.add(new FindSetFileUtilityTestSpec(Optional.of(expected), mocks));\n+            }\n+\n+            var lastMocks = data.getLast().mockSpecs();\n+            var lastSucceedMock = lastMocks.getLast();\n+            var lastFailMock = new CommandMockSpec(lastSucceedMock.name(), lastSucceedMock.mockName(), fail);\n+\n+            var mocks = new ArrayList<>(lastMocks);\n+            mocks.set(mocks.size() - 1, lastFailMock);\n+\n+            for (var xcrunOutout : List.<Map.Entry<Optional<String>, Boolean>>of(\n+                    \/\/ Use the path to the command of the current process\n+                    \/\/ as an output mock for the \/usr\/bin\/xcrun command.\n+                    \/\/ MacDmgSystemEnvironment.findSetFileUtility() reads the command output\n+                    \/\/ and checks whether it is an executable file,\n+                    \/\/ so the hardcoded value is not an option for the output mock.\n+                    Map.entry(Optional.of(ProcessHandle.current().info().command().orElseThrow()), true),\n+                    \/\/ \"\/usr\/bin\/xcrun\" outputs a path to non-executable file.\n+                    Map.entry(Optional.of(\"\/dev\/null\"), false),\n+                    \/\/ \"\/usr\/bin\/xcrun\" outputs '\\0' making subsequent Path.of(\"\\0\") fail.\n+                    Map.entry(Optional.of(\"\\0\"), false),\n+                    \/\/ \"\/usr\/bin\/xcrun\" doesn't output anything.\n+                    Map.entry(Optional.empty(), false)\n+            )) {\n+\n+\n+                mocks.add(new CommandMockSpec(\"\/usr\/bin\/xcrun\", CommandActionSpecs.build().mutate(builder -> {\n+                    xcrunOutout.getKey().ifPresent(builder::stdout);\n+                }).exit(CommandMockExit.SUCCEED).create()));\n+\n+                Optional<String> expected;\n+                if (xcrunOutout.getValue()) {\n+                    expected = xcrunOutout.getKey();\n+                } else {\n+                    expected = Optional.empty();\n+                }\n+\n+                data.add(new FindSetFileUtilityTestSpec(expected.map(Path::of), List.copyOf(mocks)));\n+\n+                mocks.removeLast();\n+            }\n+\n+            \/\/ The last test case: \"\/usr\/bin\/xcrun\" fails\n+            mocks.add(new CommandMockSpec(\"\/usr\/bin\/xcrun\", fail));\n+            data.add(new FindSetFileUtilityTestSpec(Optional.empty(), mocks));\n+        }\n+\n+        return data;\n+    }\n+\n+    record FindSetFileUtilityTestSpec(Optional<Path> expected, List<CommandMockSpec> mockSpecs) {\n+\n+        FindSetFileUtilityTestSpec {\n+            Objects.requireNonNull(expected);\n+            Objects.requireNonNull(mockSpecs);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            var tokens = new ArrayList<String>();\n+            expected.ifPresent(v -> {\n+                tokens.add(String.format(\"expect=%s\", v));\n+            });\n+            tokens.add(mockSpecs.toString());\n+            return tokens.stream().collect(Collectors.joining(\", \"));\n+        }\n+\n+        void run() {\n+\n+            var script = Script.build().mutate(builder -> {\n+                mockSpecs.forEach(builder::map);\n+            }).createSequence();\n+\n+            Globals.main(() -> {\n+                MockUtils.buildJPackage().script(script).applyToGlobals();\n+\n+                var actual = MacDmgSystemEnvironment.findSetFileUtility();\n+\n+                assertEquals(expected, actual);\n+                assertEquals(List.of(), script.incompleteMocks());\n+\n+                return 0;\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/macosx\/jdk.jpackage\/jdk\/jpackage\/internal\/MacDmgSystemEnvironmentTest.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,22 @@\n+\n+\/* @test\n+ * @summary Test MacDmgSystemEnvironmentTest\n+ * @requires (os.family == \"mac\")\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.mock.*\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/MacDmgSystemEnvironmentTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/MockUtils.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.MacDmgSystemEnvironmentTest\n+ *\/\n+\n+\/* @test\n+ * @summary Test MacDmgPackagerTest\n+ * @requires (os.family == \"mac\")\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.mock.*\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/MacDmgPackagerTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/MockUtils.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.MacDmgPackagerTest\n+ *\/\n","filename":"test\/jdk\/tools\/jpackage\/junit\/macosx\/junit.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,4 @@\n+\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+import static jdk.jpackage.test.mock.CommandMock.ioerror;\n+import static jdk.jpackage.test.mock.CommandMock.succeed;\n@@ -27,0 +31,7 @@\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n@@ -28,0 +39,3 @@\n+import java.util.Set;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n@@ -29,0 +43,2 @@\n+import jdk.jpackage.internal.cli.StandardBundlingOperation;\n+import jdk.jpackage.internal.model.AppImagePackageType;\n@@ -30,0 +46,11 @@\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.test.Annotations;\n+import jdk.jpackage.test.HelloApp;\n+import jdk.jpackage.test.JUnitAdapter;\n+import jdk.jpackage.test.JavaAppDesc;\n+import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.mock.CommandActionSpecs;\n+import jdk.jpackage.test.mock.CommandMock;\n+import jdk.jpackage.test.mock.CommandMockExit;\n+import jdk.jpackage.test.mock.Script;\n@@ -33,1 +60,1 @@\n-public class DefaultBundlingEnvironmentTest {\n+public class DefaultBundlingEnvironmentTest extends JUnitAdapter {\n@@ -58,0 +85,196 @@\n+\n+    \/**\n+     * Tests that commands executed to initialize the system environment are\n+     * executed only once.\n+     * @throws IOException\n+     *\/\n+    @Annotations.Test\n+    @Annotations.ParameterSupplier\n+    public void testInitializedOnce(StandardBundlingOperation op) throws IOException {\n+\n+        List<List<String>> executedCommands = Collections.synchronizedList(new ArrayList<>());\n+\n+        var script = createMockScript(op);\n+\n+        ToolProvider jpackage = MockUtils.buildJPackage()\n+                .os(op.os())\n+                .script(script)\n+                .listener(executedCommands::add).create();\n+\n+        var inputDir = TKit.createTempDirectory(\"input\");\n+        var appDesc = JavaAppDesc.parse(null);\n+        HelloApp.createBundle(appDesc, inputDir);\n+\n+        \/\/\n+        \/\/ The command line should fail as the main class name is not specified and it is not set in the main jar.\n+        \/\/\n+        \/\/ Run native packaging twice.\n+        \/\/ It can execute commands required to configure the system environment in the first iteration.\n+        \/\/ It must not execute a single command in the second iteration.\n+        \/\/\n+        \/\/ Run app image packaging once.\n+        \/\/ It must not execute a single command because app image packaging should not require native commands (Unless\n+        \/\/ it is macOS where it will sign the app image with an ad hoc signature\n+        \/\/ using the codesign tool. But: #1 - it is not a variable part of the system environment;\n+        \/\/ #2 - jpackage should bail out earlier).\n+        \/\/\n+\n+        final var type = op.packageTypeValue();\n+        final int iterationCount;\n+        if (op.packageType() instanceof AppImagePackageType) {\n+            iterationCount = 1;\n+        } else {\n+            iterationCount = 2;\n+        }\n+\n+        for (var i = 0; i != iterationCount; i++) {\n+            var result = new Executor().toolProvider(jpackage).saveOutput().args(\n+                    \"--type=\" + type,\n+                    \"--input\", inputDir.toString(),\n+                    \"--main-jar\", appDesc.jarFileName()).execute();\n+\n+            assertEquals(1, result.getExitCode());\n+\n+            \/\/ Assert it bailed out with the expected error.\n+            assertEquals(List.of(\n+                    I18N.format(\"message.error-header\", I18N.format(\"error.no-main-class-with-main-jar\", appDesc.jarFileName())),\n+                    I18N.format(\"message.advice-header\", I18N.format(\"error.no-main-class-with-main-jar.advice\", appDesc.jarFileName()))\n+            ), result.stderr());\n+\n+            TKit.trace(\"The list of executed commands:\");\n+            executedCommands.forEach(cmdline -> {\n+                TKit.trace(\"  \" + cmdline);\n+            });\n+            TKit.trace(\"Done\");\n+\n+            if (i == 0) {\n+                executedCommands.clear();\n+            }\n+        }\n+\n+        assertEquals(List.of(), executedCommands);\n+        assertEquals(List.of(), script.incompleteMocks());\n+    }\n+\n+    public static List<Object[]> testInitializedOnce() {\n+        return StandardBundlingOperation.ofPlatform(OperatingSystem.current())\n+                .filter(StandardBundlingOperation::isCreateBundle).map(v -> {\n+                    return new Object[] {v};\n+                }).toList();\n+    }\n+\n+    private static Script createMockScript(StandardBundlingOperation op) {\n+\n+        if (op.packageType() instanceof AppImagePackageType) {\n+            return Script.build().createSequence();\n+        }\n+\n+        switch (op.os()) {\n+            case WINDOWS -> {\n+                return createWinMockScript();\n+            }\n+            case LINUX -> {\n+                return createLinuxMockScript(op.packageType());\n+            }\n+            case MACOS -> {\n+                return createMacMockScript();\n+            }\n+            default -> {\n+                throw new AssertionError();\n+            }\n+        }\n+    }\n+\n+    private static Script createWinMockScript() {\n+\n+        \/\/ Make \"candle.exe\" and \"light.exe\" always fail.\n+        var candle = ioerror(\"candle-mock\");\n+        var light = ioerror(\"light-mock\");\n+\n+        \/\/ Make the \"wix.exe\" functional.\n+        var wix = CommandActionSpecs.build()\n+                .stdout(\"5.0.2+aa65968c\")\n+                .exit(CommandMockExit.SUCCEED)\n+                .toCommandMockBuilder().name(\"wix-mock\").create();\n+\n+        var script = Script.build()\n+                .map(Script.cmdlineStartsWith(\"candle.exe\"), candle)\n+                .map(Script.cmdlineStartsWith(\"light.exe\"), light)\n+                .map(Script.cmdlineStartsWith(\"wix.exe\"), wix)\n+                .createLoop();\n+\n+        return script;\n+    }\n+\n+    private static Script createMacMockScript() {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        var setfilePaths = (List<Path>)toSupplier(() -> {\n+            return Class.forName(String.join(\".\",\n+                    DefaultBundlingEnvironmentTest.class.getPackageName(),\n+                    \"MacDmgSystemEnvironment\"\n+            )).getDeclaredField(\"SETFILE_KNOWN_PATHS\").get(null);\n+        }).get();\n+\n+        var script = Script.build();\n+\n+        for (var setfilePath: setfilePaths) {\n+            script.map(Script.cmdlineStartsWith(setfilePath), ioerror(setfilePath.toString() + \"-mock\"));\n+        }\n+\n+        script.map(Script.cmdlineStartsWith(\"\/usr\/bin\/xcrun\"), succeed(\"\/usr\/bin\/xcrun-mock\"));\n+\n+        return script.createLoop();\n+    }\n+\n+    private static Script createLinuxMockScript(PackageType pkgType) {\n+\n+        final Map<String, CommandMock> mocks = new HashMap<>();\n+\n+        var script = Script.build();\n+\n+        final Set<String> debCommandNames = Set.of(\"dpkg\", \"dpkg-deb\", \"fakeroot\");\n+        final Set<String> rpmCommandNames = Set.of(\"rpm\", \"rpmbuild\");\n+\n+        final Set<String> succeedCommandNames;\n+        switch (pkgType) {\n+            case StandardPackageType.LINUX_DEB -> {\n+                succeedCommandNames = debCommandNames;\n+                \/\/ Simulate \"dpkg --print-architecture\".\n+                var dpkg = CommandActionSpecs.build()\n+                        .stdout(\"foo-arch\")\n+                        .exit(CommandMockExit.SUCCEED)\n+                        .toCommandMockBuilder().name(\"dpkg-mock\").create();\n+                mocks.put(\"dpkg\", dpkg);\n+            }\n+            case StandardPackageType.LINUX_RPM -> {\n+                succeedCommandNames = rpmCommandNames;\n+                \/\/ Simulate \"rpmbuild --version\" prints the minimal acceptable version.\n+                var rpmbuild = CommandActionSpecs.build()\n+                        .stdout(\"RPM version 4.10\")\n+                        .exit(CommandMockExit.SUCCEED)\n+                        .toCommandMockBuilder().name(\"rpmbuild-mock\").create();\n+                mocks.put(\"rpmbuild\", rpmbuild);\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        script.map(Script.cmdlineStartsWith(\"ldd\"), succeed(\"ldd-mock\"));\n+\n+        for (var commandName : succeedCommandNames) {\n+            if (!mocks.containsKey(commandName)) {\n+                mocks.put(commandName, succeed(commandName + \"-mock\"));\n+            }\n+        }\n+\n+        Stream.of(debCommandNames, rpmCommandNames).flatMap(Set::stream).forEach(commandName -> {\n+            var mock = Optional.ofNullable(mocks.get(commandName)).orElseGet(() -> {\n+                return ioerror(commandName + \"-mock\");\n+            });\n+            script.map(Script.cmdlineStartsWith(commandName), mock);\n+        });\n+\n+        return script.createLoop();\n+    }\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/DefaultBundlingEnvironmentTest.java","additions":225,"deletions":2,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.util.stream.Stream;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-\n-public class EnquoterTest {\n-\n-    @ParameterizedTest\n-    @MethodSource\n-    public void testForShellLiterals(String expected, String input) {\n-        var actual = Enquoter.forShellLiterals().applyTo(input);\n-        assertEquals(expected, actual);\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource\n-    public void testForPropertyValues(String expected, String input) {\n-        var actual = Enquoter.forPropertyValues().applyTo(input);\n-        assertEquals(expected, actual);\n-    }\n-\n-    private static Stream<org.junit.jupiter.params.provider.Arguments> testForShellLiterals() {\n-        return Stream.of(\n-                makeArguments(\"''\", \"\"),\n-                makeArguments(\"'foo'\", \"foo\"),\n-                makeArguments(\"' foo '\", \" foo \"),\n-                makeArguments(\"'foo bar'\", \"foo bar\"),\n-                makeArguments(\"'foo\\\\' bar'\", \"foo' bar\")\n-        );\n-    }\n-\n-    private static Stream<org.junit.jupiter.params.provider.Arguments> testForPropertyValues() {\n-        return Stream.of(\n-                makeArguments(\"\", \"\"),\n-                makeArguments(\"foo\", \"foo\"),\n-                makeArguments(\"\\\" foo \\\"\", \" foo \"),\n-                makeArguments(\"\\\"foo bar\\\"\", \"foo bar\"),\n-                makeArguments(\"\\\"foo' bar\\\"\", \"foo' bar\")\n-        );\n-    }\n-\n-    static org.junit.jupiter.params.provider.Arguments makeArguments(Object ... args) {\n-        return org.junit.jupiter.params.provider.Arguments.of(args);\n-    }\n-}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/EnquoterTest.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.CommandOutputControl.UnexpectedResultException;\n+import jdk.jpackage.test.mock.CommandActionSpecs;\n+import jdk.jpackage.test.mock.CommandMockExit;\n+import jdk.jpackage.test.mock.CompletableCommandMock;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class ExecutorTest {\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_retryOnKnownErrorMessage(RetryOnKnownErrorMessageTestSpec test) {\n+        test.run();\n+    }\n+\n+    private static Stream<RetryOnKnownErrorMessageTestSpec> test_retryOnKnownErrorMessage() {\n+        var data = new ArrayList<RetryOnKnownErrorMessageTestSpec.Builder>();\n+\n+        final var subject = \"French fries\";\n+\n+        Supplier<RetryOnKnownErrorMessageTestSpec.Builder> build = () -> {\n+            return RetryOnKnownErrorMessageTestSpec.build().subject(subject);\n+        };\n+\n+        for (var exit : Stream.of(CommandMockExit.values()).filter(CommandMockExit::exitNormally).toList()) {\n+            \/\/ These should succeed as there is no \"French fries\" in stderr.\n+            Stream.of(\n+                    build.get().mock(CommandActionSpecs.build().stderr(\"Coleslaw\").exit(exit)),\n+                    build.get().mock(CommandActionSpecs.build().stdout(subject).exit(exit)),\n+                    build.get()\n+                            \/\/ Fail in the first attempt (triggering text in the stderr)\n+                            .mock(CommandActionSpecs.build().stderr(subject).exit())\n+                            \/\/ Fail in the second attempt (same reason)\n+                            .repeatLastMoc()\n+                            \/\/ Pass in the next attempt (no triggering text in the stderr)\n+                            .mock(CommandActionSpecs.build().stderr(\"Coleslaw\").exit(exit)),\n+                   build.get()\n+                           \/\/ Fail in the first attempt (triggering text in the stderr)\n+                           .mock(CommandActionSpecs.build().stderr(subject))\n+                           \/\/ Fail in the second attempt (error running the command)\n+                           .mock(CommandActionSpecs.build().exit(CommandMockExit.THROW_MOCK_IO_EXCEPTION))\n+                           \/\/ Pass in the next attempt (no triggering text in the stderr)\n+                           .mock(CommandActionSpecs.build().exit(exit))\n+            ).map(RetryOnKnownErrorMessageTestSpec.Builder::success).forEach(data::add);\n+        }\n+\n+        \/\/ These should fail as there is \"French fries\" in stderr.\n+        data.addAll(List.of(\n+                \/\/ Try once and fail.\n+                build.get().mock(CommandActionSpecs.build().stderr(subject).exit()),\n+                \/\/ Try twice and fail.\n+                build.get().mock(CommandActionSpecs.build().stderr(subject).exit()).repeatLastMoc()\n+        ));\n+\n+        return data.stream().map(RetryOnKnownErrorMessageTestSpec.Builder::create);\n+    }\n+\n+    record RetryOnKnownErrorMessageTestSpec(List<CommandActionSpecs> mockSpecs, String subject, boolean success) {\n+\n+        RetryOnKnownErrorMessageTestSpec {\n+            Objects.requireNonNull(mockSpecs);\n+            Objects.requireNonNull(subject);\n+\n+            if (mockSpecs.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        void run() {\n+            var mock = mockSpecs.stream()\n+                    .reduce(CommandActionSpecs::andThen)\n+                    .orElseThrow().toCommandMockBuilder()\n+                    \/\/ Ensure attempts to run the command more times than expected will fail.\n+                    .noRepeats().create();\n+\n+            var retry = new Executor().toolProvider(mock).retryOnKnownErrorMessage(subject)\n+                    .setAttemptTimeout(null)\n+                    .setMaxAttemptsCount(mockSpecs.size());\n+\n+            if (success) {\n+                assertDoesNotThrow(retry::execute);\n+            } else {\n+                assertThrowsExactly(UnexpectedResultException.class, retry::execute);\n+            }\n+\n+            assertTrue(((CompletableCommandMock)mock).completed());\n+        }\n+\n+        static Builder build() {\n+            return new Builder();\n+        }\n+\n+        static final class Builder {\n+\n+            RetryOnKnownErrorMessageTestSpec create() {\n+                return new RetryOnKnownErrorMessageTestSpec(mockSpecs, subject, success);\n+            }\n+\n+            public Builder mock(CommandActionSpecs v) {\n+                mockSpecs.add(Objects.requireNonNull(v));\n+                return this;\n+            }\n+\n+            public Builder mock(CommandActionSpecs.Builder v) {\n+                return mock(v.create());\n+            }\n+\n+            public Builder repeatLastMoc() {\n+                return mock(mockSpecs.getLast());\n+            }\n+\n+            public Builder subject(String v) {\n+                subject = v;\n+                return this;\n+            }\n+\n+            public Builder success(boolean v) {\n+                success = v;\n+                return this;\n+            }\n+\n+            public Builder success() {\n+                return success(true);\n+            }\n+\n+            private final List<CommandActionSpecs> mockSpecs = new ArrayList<>();\n+            private String subject;\n+            private boolean success;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/ExecutorTest.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+\n+import java.io.PrintWriter;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n+import java.util.spi.ToolProvider;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.cli.CliBundlingEnvironment;\n+import jdk.jpackage.internal.cli.Main;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import jdk.jpackage.test.mock.Script;\n+import jdk.jpackage.test.mock.ToolProviderCommandMock;\n+import jdk.jpackage.test.mock.VerbatimCommandMock;\n+\n+\/**\n+ * Bridges \"jdk.jpackage.internal\" and \"jdk.jpackage.test.mock\" packages.\n+ *\/\n+public final class MockUtils {\n+\n+    private MockUtils() {\n+    }\n+\n+    public static JPackageToolProviderBuilder buildJPackage() {\n+        return new JPackageToolProviderBuilder();\n+    }\n+\n+    public static final class JPackageToolProviderBuilder {\n+\n+        public ToolProvider create() {\n+            return createJPackageToolProvider(os(), createObjectFactory());\n+        }\n+\n+        public Consumer<Globals> createGlobalsMutator() {\n+            var objectFactory = createObjectFactory();\n+            return globals -> {\n+                globals.objectFactory(objectFactory);\n+            };\n+        }\n+\n+        public void applyToGlobals() {\n+            createGlobalsMutator().accept(Globals.instance());\n+        }\n+\n+        ExecutorFactory createExecutorFactory() {\n+            var commandMocksExecutorFactory = Optional.ofNullable(script).map(MockUtils::withCommandMocks).map(mapper -> {\n+                return mapper.apply(ExecutorFactory.DEFAULT);\n+            }).orElse(ExecutorFactory.DEFAULT);\n+\n+            var recordingExecutorFactory = Optional.ofNullable(listener).map(MockUtils::withCommandListener).map(mapper -> {\n+                return mapper.apply(commandMocksExecutorFactory);\n+            }).orElse(commandMocksExecutorFactory);\n+\n+            return recordingExecutorFactory;\n+        }\n+\n+        ObjectFactory createObjectFactory() {\n+            var executorFactory = createExecutorFactory();\n+            if (executorFactory == ExecutorFactory.DEFAULT) {\n+                return ObjectFactory.DEFAULT;\n+            } else {\n+                return ObjectFactory.build().executorFactory(executorFactory).create();\n+            }\n+        }\n+\n+        public JPackageToolProviderBuilder listener(Consumer<List<String>> v) {\n+            listener = v;\n+            return this;\n+        }\n+\n+        public JPackageToolProviderBuilder script(Script v) {\n+            script = v;\n+            return this;\n+        }\n+\n+        public JPackageToolProviderBuilder os(OperatingSystem v) {\n+            os = v;\n+            return this;\n+        }\n+\n+        private OperatingSystem os() {\n+            return Optional.ofNullable(os).orElseGet(OperatingSystem::current);\n+        }\n+\n+        private Consumer<List<String>> listener;\n+        private OperatingSystem os;\n+        private Script script;\n+    }\n+\n+    public static ToolProvider createJPackageToolProvider(OperatingSystem os, Script script) {\n+        return buildJPackage()\n+                .os(Objects.requireNonNull(os))\n+                .script(Objects.requireNonNull(script))\n+                .create();\n+    }\n+\n+    public static ToolProvider createJPackageToolProvider(Script script) {\n+        return createJPackageToolProvider(OperatingSystem.current(), script);\n+    }\n+\n+    private static UnaryOperator<ExecutorFactory> withCommandListener(Consumer<List<String>> listener) {\n+        Objects.requireNonNull(listener);\n+        return executorFactory -> {\n+            Objects.requireNonNull(executorFactory);\n+            return () -> {\n+                var executor = executorFactory.executor();\n+\n+                Optional<UnaryOperator<Executor>> oldMapper = executor.mapper();\n+\n+                UnaryOperator<Executor> newMapper = exec -> {\n+                    listener.accept(exec.commandLine());\n+                    return exec;\n+                };\n+\n+                return executor.mapper(oldMapper.map(newMapper::compose).orElse(newMapper)::apply);\n+            };\n+        };\n+    }\n+\n+    private static UnaryOperator<ExecutorFactory> withCommandMocks(Script script) {\n+        return executorFactory -> {\n+            Objects.requireNonNull(executorFactory);\n+            return () -> {\n+                var executor = executorFactory.executor();\n+\n+                Optional<UnaryOperator<Executor>> oldMapper = executor.mapper();\n+\n+                UnaryOperator<Executor> newMapper = exec -> {\n+                    var commandLine = exec.commandLine();\n+                    var mock = Objects.requireNonNull(script.map(commandLine));\n+                    switch (mock) {\n+                        case VerbatimCommandMock.INSTANCE -> {\n+                            \/\/ No mock for this command line.\n+                            return exec;\n+                        }\n+                        case ToolProviderCommandMock tp -> {\n+                            \/\/ Create a copy of the executor with the old mapper to prevent further recursion.\n+                            var copy = exec.copy().mapper(oldMapper.orElse(null));\n+                            copy.toolProvider(tp);\n+                            copy.args().clear();\n+                            copy.args(commandLine.subList(1, commandLine.size()));\n+                            return copy;\n+                        }\n+                        default -> {\n+                            \/\/ Unreachable because there are no other cases for this switch.\n+                            throw ExceptionBox.reachedUnreachable();\n+                        }\n+                    }\n+                };\n+\n+                return executor.mapper(oldMapper.map(newMapper::compose).orElse(newMapper)::apply);\n+            };\n+        };\n+    }\n+\n+    public static CliBundlingEnvironment createBundlingEnvironment(OperatingSystem os) {\n+        Objects.requireNonNull(os);\n+\n+        String bundlingEnvironmentClassName;\n+        switch (os) {\n+            case WINDOWS -> {\n+                bundlingEnvironmentClassName = \"WinBundlingEnvironment\";\n+            }\n+            case LINUX -> {\n+                bundlingEnvironmentClassName = \"LinuxBundlingEnvironment\";\n+            }\n+            case MACOS -> {\n+                bundlingEnvironmentClassName = \"MacBundlingEnvironment\";\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        return toSupplier(() -> {\n+            var ctor = Class.forName(String.join(\".\",\n+                    DefaultBundlingEnvironment.class.getPackageName(),\n+                    bundlingEnvironmentClassName\n+            )).getConstructor();\n+            return (CliBundlingEnvironment)ctor.newInstance();\n+        }).get();\n+    }\n+\n+    static ToolProvider createJPackageToolProvider(OperatingSystem os, ObjectFactory of) {\n+        Objects.requireNonNull(os);\n+        Objects.requireNonNull(of);\n+\n+        var impl = new Main.Provider(DefaultBundlingEnvironment.runOnce(() -> {\n+            return createBundlingEnvironment(os);\n+        }));\n+\n+        return new ToolProvider() {\n+\n+            @Override\n+            public int run(PrintWriter out, PrintWriter err, String... args) {\n+                return Globals.main(() -> {\n+                    Globals.instance().objectFactory(of);\n+                    return impl.run(out, err, args);\n+                });\n+            }\n+\n+            @Override\n+            public String name() {\n+                return impl.name();\n+            }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/MockUtils.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -7,1 +7,0 @@\n-ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--jlink-options, --foo]; errors=[message.error-header+[error.jlink.failed, Error: unknown option: --foo]])\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionsValidationFailTest.excludes","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-                JPackageCommand.withToolProvider(jpackageToolProviderMock, () -> {\n+                JPackageCommand.withToolProvider(() -> {\n@@ -209,1 +209,1 @@\n-                });\n+                }, jpackageToolProviderMock);\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionsValidationFailTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,1846 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import static java.util.stream.Collectors.joining;\n+import static jdk.jpackage.internal.util.CommandOutputControlTestUtils.isInterleave;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingRunnable.toRunnable;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+import static jdk.jpackage.test.JUnitUtils.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.MessageDigest;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.DisabledIf;\n+import org.junit.jupiter.api.condition.DisabledOnOs;\n+import org.junit.jupiter.api.condition.EnabledIf;\n+import org.junit.jupiter.api.condition.OS;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.EnumSource.Mode;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class CommandOutputControlTest {\n+\n+    @DisabledIf(\"cherryPickSavedOutputTestCases\")\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testSavedOutput(OutputTestSpec spec) {\n+        spec.test();\n+    }\n+\n+    \/**\n+     * Runs cherry-picked {@link OutputTestSpec} test cases.\n+     * <p>\n+     * This test method is mutual exclusive with\n+     * {@link #testSavedOutput(OutputTestSpec)} and is aimed for debugging\n+     * {@code OutputTestSpec} test cases.\n+     * <p>\n+     * It is disabled by default. To enable it, manually edit {@link #testSomeSavedOutput()}.\n+     *\n+     * @see #testSomeSavedOutput()\n+     *\n+     * @param spec the test case\n+     *\/\n+    @EnabledIf(\"cherryPickSavedOutputTestCases\")\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testSomeSavedOutput(OutputTestSpec spec) {\n+        System.out.println(spec);\n+        spec.test();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testDumpStreams(OutputTestSpec spec) {\n+        spec.test();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testCharset(CharsetTestSpec spec) throws IOException, InterruptedException {\n+        spec.test();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_description(CommandOutputControlSpec spec) {\n+        \/\/ This test is mostly for coverage.\n+        var desc = spec.create().description();\n+        assertFalse(desc.isBlank());\n+    }\n+\n+    @Test\n+    public void test_copy() {\n+        var orig = new CommandOutputControl();\n+        var copy = orig.copy();\n+        assertNotSame(orig, copy);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(names = \"SAVE_NOTHING\", mode = Mode.EXCLUDE)\n+    public void test_flag(OutputControl flag) {\n+        var coc = new CommandOutputControl();\n+        assertFalse(flag.get(coc));\n+        flag.set(coc);\n+        assertTrue(flag.get(coc));\n+        if (flag.canUnset()) {\n+            flag.unset(coc);\n+            assertFalse(flag.get(coc));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_mutual_exclusive_flags(List<OutputControl> controls) {\n+        if (controls.isEmpty()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        var coc = new CommandOutputControl();\n+        for (var c : controls) {\n+            c.set(coc);\n+        }\n+\n+        for (var c : controls.subList(0, controls.size() - 1)) {\n+            assertFalse(c.get(coc));\n+        }\n+        assertTrue(controls.getLast().get(coc));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_ExecutableAttributes(boolean toolProvider) {\n+        var coc = new CommandOutputControl();\n+        CommandOutputControl.Executable exec;\n+        if (toolProvider) {\n+            exec = coc.createExecutable(new ToolProvider() {\n+\n+                @Override\n+                public String name() {\n+                    return \"runme\";\n+                }\n+\n+                @Override\n+                public int run(PrintWriter out, PrintWriter err, String... args) {\n+                    fail(\"Should never be called\");\n+                    return 0;\n+                }\n+\n+            }, \"--foo\", \"--baz=10\");\n+        } else {\n+            exec = coc.createExecutable(new ProcessBuilder(\"runme\", \"--foo\", \"--baz=10\"));\n+        }\n+\n+        assertEquals(\"runme --foo --baz=10\", exec.attributes().toString());\n+    }\n+\n+    @Test\n+    public void test_Result_no_args_ctor() {\n+        var result = new CommandOutputControl.Result(7);\n+        assertFalse(result.findContent().isPresent());\n+        assertFalse(result.findStdout().isPresent());\n+        assertFalse(result.findStderr().isPresent());\n+        assertEquals(7, result.getExitCode());\n+        assertSame(Objects.requireNonNull(CommandOutputControl.EMPTY_EXECUTABLE_ATTRIBUTES), result.execAttrs());\n+    }\n+\n+    @Test\n+    public void test_Result_expectExitCode() throws IOException {\n+        var result = new CommandOutputControl.Result(7);\n+\n+        assertSame(result, result.expectExitCode(7));\n+        assertSame(result, result.expectExitCode(7, 2));\n+        assertSame(result, result.expectExitCode(2, 7));\n+\n+        assertSame(result, result.expectExitCode(List.of(7)));\n+        assertSame(result, result.expectExitCode(Set.of(7, 2)));\n+        assertSame(result, result.expectExitCode(List.of(2, 7)));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_Result_expectExitCode_negative(boolean collection) {\n+        var result = new CommandOutputControl.Result(3);\n+\n+        var ex = assertThrowsExactly(CommandOutputControl.UnexpectedExitCodeException.class, () -> {\n+            if (collection) {\n+                result.expectExitCode(List.of(17, 12));\n+            } else {\n+                result.expectExitCode(17, 12);\n+            }\n+        });\n+\n+        assertNull(ex.getCause());\n+        assertSame(result, ex.getResult());\n+        assertEquals(\"Unexpected exit code 3 from executing the command <unknown>\", ex.getMessage());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_Result_toCharacterResult(ToCharacterResultTestSpec spec) throws IOException, InterruptedException {\n+        spec.test();\n+    }\n+\n+    @Test\n+    public void test_Result_toCharacterResult_nop() throws IOException, InterruptedException {\n+\n+        var charset = StandardCharsets.UTF_8;\n+\n+        var emptyResult = new CommandOutputControl.Result(7);\n+        assertSame(emptyResult, emptyResult.toCharacterResult(charset, true));\n+        assertSame(emptyResult, emptyResult.toCharacterResult(charset, false));\n+\n+        var coc = new CommandOutputControl().saveOutput(true);\n+\n+        var result = coc.createExecutable(new Command(List.of(\"foo\"), List.of()).asToolProvider()).execute();\n+\n+        assertSame(result, result.toCharacterResult(charset, true));\n+        assertSame(result, result.toCharacterResult(charset, false));\n+    }\n+\n+    @Test\n+    public void test_Result_toCharacterResult_copyWithExecutableAttributes() {\n+\n+        var empty = new CommandOutputControl.Result(0);\n+\n+        var execAttrs = new CommandOutputControl.ExecutableAttributes() {\n+            @Override\n+            public String toString() {\n+                return \"foo\";\n+            }\n+\n+            @Override\n+            public List<String> commandLine() {\n+                return List.of();\n+            }\n+        };\n+\n+        var copy = empty.copyWithExecutableAttributes(execAttrs);\n+\n+        assertSame(empty.exitCode(), copy.exitCode());\n+        assertSame(empty.output(), copy.output());\n+        assertSame(empty.byteOutput(), copy.byteOutput());\n+        assertSame(execAttrs, copy.execAttrs());\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ExecutableType.class)\n+    public void test_timeout_expires(ExecutableType mode) throws InterruptedException, IOException {\n+\n+        final var toolProvider = (mode == ExecutableType.TOOL_PROVIDER);\n+        final var storeOutputInFiles = (mode == ExecutableType.PROCESS_BUILDER_WITH_STREAMS_IN_FILES);\n+\n+        var actions = List.<CommandAction>of(\n+                CommandAction.echoStdout(\"The quick brown fox jumps\"),\n+                CommandAction.sleep(5),\n+                CommandAction.echoStdout(\"over the lazy dog\")\n+        );\n+\n+        var coc = new CommandOutputControl().saveOutput(true).dumpOutput(true).storeOutputInFiles(storeOutputInFiles);\n+\n+        CommandOutputControl.Executable exec;\n+\n+        InterruptibleToolProvider tp;\n+\n+        if (toolProvider) {\n+            tp = new InterruptibleToolProvider(Command.createToolProvider(actions));\n+            exec = coc.createExecutable(tp);\n+        } else {\n+            var cmdline = Command.createShellCommandLine(actions);\n+            tp = null;\n+            exec = coc.createExecutable(new ProcessBuilder(cmdline));\n+        }\n+\n+        var result = exec.execute(1, TimeUnit.SECONDS);\n+        assertFalse(result.exitCode().isPresent());\n+\n+        var getExitCodeEx = assertThrowsExactly(IllegalStateException.class, result::getExitCode);\n+        assertEquals((\"Exit code is unavailable for timed-out command\"), getExitCodeEx.getMessage());\n+\n+        \/\/ We want to check that the saved output contains only the text emitted before the \"sleep\" action.\n+        \/\/ It works for a subprocess, but in the case of a ToolProvider, sometimes the timing is such\n+        \/\/ that it gets interrupted before having written anything to the stdout, and the saved output is empty.\n+        \/\/ This happens when the test case is executed together with other test cases\n+        \/\/ and never when it is executed individually.\n+        if (!toolProvider || !result.content().isEmpty()) {\n+            assertEquals(List.of(\"The quick brown fox jumps\"), result.content());\n+        }\n+\n+        if (toolProvider) {\n+            assertTrue(tp.interrupted());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_timeout(boolean toolProvider) throws InterruptedException, IOException {\n+\n+        var actions = List.<CommandAction>of(\n+                CommandAction.echoStdout(\"Sphinx of black quartz,\"),\n+                CommandAction.echoStdout(\"judge my vow\")\n+        );\n+\n+        var coc = new CommandOutputControl().saveOutput(true).dumpOutput(true);\n+\n+        CommandOutputControl.Executable exec;\n+\n+        if (toolProvider) {\n+            var tp = Command.createToolProvider(actions);\n+            exec = coc.createExecutable(tp);\n+        } else {\n+            var cmdline = Command.createShellCommandLine(actions);\n+            exec = coc.createExecutable(new ProcessBuilder(cmdline));\n+        }\n+\n+        var result = exec.execute(10, TimeUnit.SECONDS);\n+        assertTrue(result.exitCode().isPresent());\n+        assertEquals(List.of(\"Sphinx of black quartz,\", \"judge my vow\"), result.content());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_passthrough_exceptions(boolean withTimeout) throws IOException {\n+\n+        var expected = new RuntimeException(\"Kaput!\");\n+\n+        var exec = new CommandOutputControl().createExecutable(new ToolProvider() {\n+\n+            @Override\n+            public String name() {\n+                return \"foo\";\n+            }\n+\n+            @Override\n+            public int run(PrintWriter out, PrintWriter err, String... args) {\n+                throw expected;\n+            }\n+        });\n+\n+        var actual = assertThrowsExactly(expected.getClass(), () -> {\n+            if (withTimeout) {\n+                exec.execute(10, TimeUnit.SECONDS);\n+            } else {\n+                exec.execute();\n+            }\n+        });\n+\n+        assertSame(expected, actual);\n+    }\n+\n+    @Test\n+    public void test_externally_terminated() throws InterruptedException, IOException {\n+        var cmdline = Command.createShellCommandLine(List.<CommandAction>of(\n+                CommandAction.echoStderr(\"The five boxing wizards\"),\n+                CommandAction.sleep(10),\n+                CommandAction.echoStderr(\"jump quickly\")\n+        ));\n+\n+        var processDestroyer = Slot.<CompletableFuture<Void>>createEmpty();\n+\n+        var coc = new CommandOutputControl().saveOutput(true).dumpOutput(true).processListener(process -> {\n+            \/\/ Once we are notified the process has been started, schedule its destruction.\n+            \/\/ Give it a second to warm up and print some output and then destroy it.\n+            processDestroyer.set(CompletableFuture.runAsync(toRunnable(() -> {\n+                Thread.sleep(Duration.ofSeconds(1));\n+                \/\/ On Windows, CommandAction#sleep is implemented with the \"ping\" command.\n+                \/\/ By some reason, when the parent \"cmd\" process is destroyed,\n+                \/\/ the child \"ping\" command stays alive, and the test waits when it completes,\n+                \/\/ making it last for at least 10 seconds.\n+                \/\/ To optimize the test work time, destroy the entire subprocess tree.\n+                \/\/ Even though this is essential on Windows keep this logic on all platforms for simplicity.\n+                var descendants = List.<ProcessHandle>of();\n+                try (var descendantsStream = process.descendants()) {\n+                    descendants = descendantsStream.toList();\n+                } finally {\n+                    process.destroyForcibly();\n+                }\n+                descendants.forEach(ProcessHandle::destroyForcibly);\n+            })));\n+        });\n+        var exec = coc.createExecutable(new ProcessBuilder(cmdline));\n+\n+        var result = exec.execute();\n+        assertNotEquals(0, result.getExitCode());\n+        assertEquals(List.of(\"The five boxing wizards\"), result.content());\n+        processDestroyer.get().join();\n+    }\n+\n+    @DisabledOnOs(value = OS.MAC, disabledReason = \"Closing a stream doesn't consistently cause a trouble as it should\")\n+    @ParameterizedTest\n+    @EnumSource(OutputStreams.class)\n+    public void test_close_streams(OutputStreams action) throws InterruptedException, IOException {\n+        var cmdline = Command.createShellCommandLine(List.<CommandAction>of(\n+                CommandAction.echoStdout(\"Hello stdout\"),\n+                CommandAction.echoStderr(\"Bye stderr\")\n+        ));\n+\n+        var coc = new CommandOutputControl().saveOutput(true).dumpOutput(true).processListener(toConsumer(process -> {\n+            \/\/ Close process output stream(s). This should make corresponding stream gobbler(s) throw IOException.\n+            switch (action) {\n+                case STDOUT -> {\n+                    process.getInputStream().close();\n+                }\n+                case STDERR -> {\n+                    process.getErrorStream().close();\n+                }\n+                case STDOUT_AND_STDERR -> {\n+                    process.getInputStream().close();\n+                    process.getErrorStream().close();\n+                }\n+            }\n+        }));\n+        var exec = coc.createExecutable(new ProcessBuilder(cmdline));\n+\n+        var ex = assertThrows(IOException.class, exec::execute);\n+        System.out.println(\"test_close_streams: \" + action);\n+        ex.printStackTrace(System.out);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_interleaved(boolean customDumpStreams) throws IOException, InterruptedException {\n+        var cmdline = Command.createShellCommandLine(List.<CommandAction>of(\n+                CommandAction.echoStdout(\"Eat some more\"),\n+                CommandAction.echoStderr(\"of these\"),\n+                CommandAction.echoStdout(\"soft French pastries\"),\n+                CommandAction.echoStderr(\"and drink some tea\")\n+        ));\n+\n+        var coc = new CommandOutputControl();\n+        var exec = coc.createExecutable(new ProcessBuilder(cmdline));\n+\n+        coc.saveOutput(true).dumpOutput(true);\n+\n+        CommandOutputControl.Result result;\n+\n+        if (customDumpStreams) {\n+            \/\/ Execute the command so that its stdout and stderr are dumped to the same sink.\n+            var sink = new ByteArrayOutputStream();\n+            var ps = new PrintStream(sink);\n+\n+            coc.dumpStdout(ps).dumpStderr(ps);\n+\n+            result = exec.execute();\n+\n+            var commandStdout = List.of(\"Eat some more\", \"soft French pastries\");\n+            var commandStderr = List.of(\"of these\", \"and drink some tea\");\n+\n+            var sinkContent = toStringList(sink.toByteArray(), StandardCharsets.US_ASCII);\n+\n+            if (!isInterleave(sinkContent, commandStdout, commandStderr)) {\n+                fail(String.format(\"Unexpected combined output=%s; stdout=%s; stderr=%s\",\n+                        sinkContent, commandStdout, commandStderr));\n+            }\n+\n+            \/\/ CommandOutputControl was not configured to redirect stderr in stdout,\n+            \/\/ hence the output is ordered: stdout goes first, stderr follows.\n+            assertEquals(Stream.of(commandStdout, commandStderr).flatMap(List::stream).toList(), result.content());\n+\n+            \/\/ Saved stdout an stderr can be accessed individually.\n+            assertEquals(commandStdout, result.stdout());\n+            assertEquals(commandStderr, result.stderr());\n+        } else {\n+            \/\/ Execute the command so that its stdout and stderr are dumped into System.out.\n+            coc.redirectStderr(true);\n+            result = exec.execute();\n+\n+            \/\/ CommandOutputControl was configured to redirect stderr in stdout,\n+            \/\/ hence the output is interleaved.\n+            assertEquals(List.of(\"Eat some more\", \"of these\", \"soft French pastries\", \"and drink some tea\"), result.content());\n+\n+            \/\/ Saved stdout an stderr can NOT be accessed individually because they are interleaved.\n+            assertTrue(result.findStdout().isEmpty());\n+            assertTrue(result.findStderr().isEmpty());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true})\n+    public void stressTest(boolean binaryOutput, @TempDir Path workDir) throws Exception {\n+\n+        \/\/ Execute multiple subprocesses asynchronously.\n+        \/\/ Each subprocess writes a few chunks of data each larger than the default buffer size (8192 bytes)\n+\n+        final var chunkCount = 5;\n+        final var subprocessCount = 100;\n+        final var subprocessExecutor = Executors.newVirtualThreadPerTaskExecutor();\n+\n+        final var md = MessageDigest.getInstance(\"MD5\");\n+\n+        var cmdline = Command.createShellCommandLine(IntStream.range(0, chunkCount).mapToObj(chunk -> {\n+            byte[] bytes = new byte[10 * 1024]; \/\/ 10K to exceed the default BufferedOutputStream's buffer size of 8192.\n+            new Random().nextBytes(bytes);\n+            md.update(bytes);\n+            var path = workDir.resolve(Integer.toString(chunk));\n+            try {\n+                Files.write(path, bytes);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+            return path;\n+        }).map(CommandAction::cat).toList());\n+\n+        final var digest = HexFormat.of().formatHex(md.digest());\n+\n+        \/\/ Schedule to start every subprocess in a separate virtual thread.\n+        \/\/ Start and suspend threads, waiting until all scheduled threads have started.\n+        \/\/ After all scheduled threads start, resume them.\n+        \/\/ This should result in starting all scheduled subprocesses simultaneously.\n+\n+        var readyLatch = new CountDownLatch(subprocessCount);\n+        var startLatch = new CountDownLatch(1);\n+\n+        var futures = IntStream.range(0, subprocessCount).mapToObj(_ -> {\n+            return CompletableFuture.supplyAsync(toSupplier(() -> {\n+\n+                var exec = new CommandOutputControl()\n+                        .saveOutput(true)\n+                        .binaryOutput(binaryOutput)\n+                        .createExecutable(new ProcessBuilder(cmdline));\n+\n+                readyLatch.countDown();\n+                startLatch.await();\n+\n+                var result = exec.execute();\n+\n+                var localMd = MessageDigest.getInstance(\"MD5\");\n+                localMd.update(result.byteContent());\n+\n+                return HexFormat.of().formatHex(localMd.digest());\n+\n+            }), subprocessExecutor);\n+        }).toList();\n+\n+        readyLatch.await();\n+        startLatch.countDown();\n+\n+        CompletableFuture.allOf(futures.toArray(CompletableFuture[]::new)).join();\n+\n+        futures.forEach(future -> {\n+            var actualDigest = future.join();\n+            assertEquals(digest, actualDigest);\n+        });\n+    }\n+\n+    public enum OutputStreams {\n+        STDOUT,\n+        STDERR,\n+        STDOUT_AND_STDERR\n+    }\n+\n+    private static List<CommandOutputControlSpec> test_description() {\n+        List<CommandOutputControlSpec> testCases = new ArrayList<>();\n+        testCases.add(new CommandOutputControlSpec(Set.of()));\n+        for (var outputControl : OutputControl.variants()) {\n+            testCases.add(new CommandOutputControlSpec(outputControl));\n+        }\n+        return testCases;\n+    }\n+\n+    private static List<List<OutputControl>> test_mutual_exclusive_flags() {\n+        List<List<OutputControl>> data = new ArrayList<>();\n+\n+        var flags = List.of(OutputControl.SAVE_ALL, OutputControl.SAVE_FIRST_LINE, OutputControl.SAVE_NOTHING);\n+\n+        List<OutputControl> seq = new ArrayList<>();\n+        for (var _1 : flags) {\n+            seq.add(_1);\n+            var flags2 = flags.stream().filter(Predicate.isEqual(_1).negate()).toList();\n+            for (var _2 : flags2) {\n+                seq.add(_2);\n+                var flags3 = flags2.stream().filter(Predicate.isEqual(_2).negate()).toList();\n+                for (var _3 : flags3) {\n+                    seq.add(_3);\n+                    data.add(List.copyOf(seq));\n+                    seq.removeLast();\n+                }\n+                seq.removeLast();\n+            }\n+            seq.removeLast();\n+        }\n+\n+        return data;\n+    }\n+\n+    public record ToCharacterResultTestSpec(OutputTestSpec execSpec, boolean keepByteContent) {\n+\n+        public ToCharacterResultTestSpec {\n+            Objects.requireNonNull(execSpec);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final List<String> tokens = new ArrayList<>();\n+\n+            tokens.add(execSpec.toString());\n+            if (keepByteContent) {\n+                tokens.add(\"keepByteContent\");\n+            }\n+\n+            return String.join(\", \", tokens.toArray(String[]::new));\n+        }\n+\n+        void test() throws IOException, InterruptedException {\n+            var coc = execSpec.cocSpec().create();\n+\n+            var command = execSpec.commandSpec().command().asToolProvider();\n+\n+            var expected = coc.binaryOutput(false).createExecutable(command).execute();\n+\n+            var byteResult = coc.binaryOutput(true).createExecutable(command).execute();\n+\n+            var actual = byteResult.toCharacterResult(coc.charset(), keepByteContent);\n+\n+            CommandOutputControl.Result expectedByteContent;\n+            if (keepByteContent) {\n+                expectedByteContent = byteResult;\n+            } else {\n+                expectedByteContent = expected;\n+            }\n+\n+            assertArrayEquals(expectedByteContent.findByteContent().orElse(null), actual.findByteContent().orElse(null));\n+            assertArrayEquals(expectedByteContent.findByteStdout().orElse(null), actual.findByteStdout().orElse(null));\n+            assertArrayEquals(expectedByteContent.findByteStderr().orElse(null), actual.findByteStderr().orElse(null));\n+\n+            assertEquals(expected.findContent(), actual.findContent());\n+            assertEquals(expected.findStdout(), actual.findStdout());\n+            assertEquals(expected.findStderr(), actual.findStderr());\n+\n+            assertSame(byteResult.execAttrs(), actual.execAttrs());\n+            assertEquals(expected.exitCode(), actual.exitCode());\n+        }\n+    }\n+\n+    private static Stream<ToCharacterResultTestSpec> test_Result_toCharacterResult() {\n+        List<OutputTestSpec> testCases = new ArrayList<>();\n+\n+        var skip = Set.of(OutputControl.BINARY_OUTPUT, OutputControl.DUMP, OutputControl.SAVE_FIRST_LINE);\n+\n+        for (var outputControl : OutputControl.variants().stream().filter(spec -> {\n+            return !skip.stream().anyMatch(spec::contains);\n+        }).toList()) {\n+            for (var stdoutContent : List.of(OutputData.EMPTY, OutputData.MANY)) {\n+                for (var stderrContent : List.of(OutputData.EMPTY, OutputData.MANY)) {\n+                    var commandSpec = new CommandSpec(stdoutContent, stderrContent);\n+                    testCases.add(new OutputTestSpec(false, new CommandOutputControlSpec(outputControl), commandSpec));\n+                }\n+            }\n+        }\n+\n+        return testCases.stream().flatMap(execSpec -> {\n+            return Stream.of(true, false).map(keepByteContent -> {\n+                return new ToCharacterResultTestSpec(execSpec, keepByteContent);\n+            });\n+        });\n+    }\n+\n+    private static boolean cherryPickSavedOutputTestCases() {\n+        return !testSomeSavedOutput().isEmpty();\n+    }\n+\n+    \/**\n+     * Returns test cases for {@link #testSomeSavedOutput(OutputTestSpec)}.\n+     * <p>\n+     * Aimed to simplify debugging of {@link #OutputTestSpec} test cases.\n+     * <p>\n+     * The total number of {@code #OutputTestSpec} test cases is ~1500. When some\n+     * fail and need debugging, it is a waste of time to run them all. This method\n+     * allows running only selected test cases. It works this way:\n+     * <ul>\n+     * <li>Run CommandOutputControlTest test.\n+     * <li>If some {@linke #testSavedOutput(OutputTestSpec)} invocations fail,\n+     * capture their IDs (test case ID is an index starting from 1).\n+     * <li>Replace \"\/* 10, 67, 456 *&#47;\" comment in the body of this method with\n+     * the captured test case IDs.\n+     * <li>Rerun CommandOutputControlTest test. This time, it will run\n+     * {@link #testSomeSavedOutput(OutputTestSpec)} method instead of\n+     * {@link #testSavedOutput(OutputTestSpec)} with the list of the captured test\n+     * case IDs.\n+     * <\/ul>\n+     *\/\n+    private static List<OutputTestSpec> testSomeSavedOutput() {\n+        var testIds = List.<Integer>of(\/* 10, 67, 456 *\/);\n+        if (testIds.isEmpty()) {\n+            return List.of();\n+        } else {\n+            var allTestCases = testSavedOutput();\n+            return testIds.stream().map(testId -> {\n+                return allTestCases.get(testId - 1);\n+            }).toList();\n+        }\n+    }\n+\n+    private static List<OutputTestSpec> testSavedOutput() {\n+        List<OutputTestSpec> testCases = new ArrayList<>();\n+        for (final var executableType : List.of(ExecutableType.values())) {\n+            for (var outputControl : OutputControl.variants()) {\n+                for (final var stdoutContent : List.of(OutputData.values())) {\n+                    for (final var stderrContent : List.of(OutputData.values())) {\n+\n+                        if (outputControl.contains(OutputControl.BINARY_OUTPUT)\n+                                && (stdoutContent == OutputData.ONE_LINE || stderrContent == OutputData.ONE_LINE)) {\n+                            \/\/ Skip a test case if it runs a command writing\n+                            \/\/ a single line in stdout or stderr, and handles command output as a byte stream.\n+                            \/\/ It duplicates test cases that write multiple lines in stdout or stderr.\n+                            continue;\n+                        }\n+\n+                        final var commandSpec = new CommandSpec(stdoutContent, stderrContent);\n+                        boolean toolProvider;\n+                        switch (executableType) {\n+                            case PROCESS_BUILDER -> {\n+                                toolProvider = false;\n+                            }\n+                            case PROCESS_BUILDER_WITH_STREAMS_IN_FILES -> {\n+                                outputControl = new SetBuilder<OutputControl>()\n+                                        .add(outputControl)\n+                                        .add(OutputControl.STORE_STREAMS_IN_FILES)\n+                                        .create();\n+                                toolProvider = false;\n+                            }\n+                            case TOOL_PROVIDER -> {\n+                                toolProvider = true;\n+                            }\n+                            default -> {\n+                                \/\/ Unreachable\n+                                throw ExceptionBox.reachedUnreachable();\n+                            }\n+                        }\n+                        testCases.add(new OutputTestSpec(\n+                                toolProvider,\n+                                new CommandOutputControlSpec(outputControl),\n+                                commandSpec));\n+                    }\n+                }\n+            }\n+        }\n+        return testCases;\n+    }\n+\n+    private static List<OutputTestSpec> testDumpStreams() {\n+        List<OutputTestSpec> testCases = new ArrayList<>();\n+        final var commandSpec = new CommandSpec(OutputData.MANY, OutputData.MANY);\n+        for (var discardStdout : withAndWithout(OutputControl.DISCARD_STDOUT)) {\n+            for (var discardStderr : withAndWithout(OutputControl.DISCARD_STDERR)) {\n+                for (var redirectStderr : withAndWithout(OutputControl.REDIRECT_STDERR)) {\n+                    for (var binaryOutput : withAndWithout(OutputControl.BINARY_OUTPUT)) {\n+                        for (var dumpStdout : withAndWithout(OutputControl.DUMP_STDOUT_IN_SYSTEM_OUT)) {\n+                            for (var dumpStderr : withAndWithout(OutputControl.DUMP_STDERR_IN_SYSTEM_ERR)) {\n+\n+                                if (dumpStderr.isEmpty() && dumpStdout.isEmpty()) {\n+                                    \/\/ Output dumping disabled\n+                                    continue;\n+                                }\n+\n+                                if (discardStderr.isPresent() && discardStdout.isPresent()) {\n+                                    \/\/ Output dumping enabled, but all stream discarded\n+                                    continue;\n+                                }\n+\n+                                if (dumpStderr.isPresent() == discardStderr.isPresent() && dumpStdout.isEmpty()) {\n+                                    \/\/ Stderr dumping enabled but discarded, stdout dumping disabled\n+                                    continue;\n+                                }\n+\n+                                if (dumpStdout.isPresent() == discardStdout.isPresent() && dumpStderr.isEmpty()) {\n+                                    \/\/ Stdout dumping enabled but discarded, stderr dumping disabled\n+                                    continue;\n+                                }\n+\n+                                final var outputControl = new HashSet<OutputControl>();\n+                                outputControl.add(OutputControl.DUMP);\n+                                discardStdout.ifPresent(outputControl::add);\n+                                discardStderr.ifPresent(outputControl::add);\n+                                redirectStderr.ifPresent(outputControl::add);\n+                                binaryOutput.ifPresent(outputControl::add);\n+                                dumpStdout.ifPresent(outputControl::add);\n+                                dumpStderr.ifPresent(outputControl::add);\n+\n+                                testCases.add(new OutputTestSpec(\n+                                        false,\n+                                        new CommandOutputControlSpec(outputControl),\n+                                        commandSpec));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return testCases;\n+    }\n+\n+    private static List<CharsetTestSpec> testCharset() {\n+        List<CharsetTestSpec> testCases = new ArrayList<>();\n+\n+        for (boolean toolProvider : BOOLEAN_VALUES) {\n+            for (var redirectStderr : withAndWithout(OutputControl.REDIRECT_STDERR)) {\n+                for (var charset : withAndWithout(OutputControl.CHARSET_UTF16LE)) {\n+                    var stdoutSink = new CharsetTestSpec.DumpOutputSink(StandardCharsets.US_ASCII, OutputStreams.STDOUT);\n+                    var stderrSink = new CharsetTestSpec.DumpOutputSink(StandardCharsets.UTF_32LE, OutputStreams.STDERR);\n+                    var outputControl = new HashSet<CommandOutputControlMutator>();\n+                    redirectStderr.ifPresent(outputControl::add);\n+                    charset.ifPresent(outputControl::add);\n+                    outputControl.add(stdoutSink);\n+                    outputControl.add(stderrSink);\n+                    testCases.add(new CharsetTestSpec(toolProvider, new CommandOutputControlSpec(outputControl)));\n+                }\n+            }\n+        }\n+\n+        return testCases;\n+    }\n+\n+    private enum ExecutableType {\n+        TOOL_PROVIDER,\n+        PROCESS_BUILDER,\n+        PROCESS_BUILDER_WITH_STREAMS_IN_FILES,\n+        ;\n+    }\n+\n+    private sealed interface CommandAction {\n+        static SleepCommandAction sleep(int seconds) {\n+            return new SleepCommandAction(seconds);\n+        }\n+\n+        static EchoCommandAction echoStdout(String str) {\n+            return new EchoCommandAction(str, false);\n+        }\n+\n+        static EchoCommandAction echoStderr(String str) {\n+            return new EchoCommandAction(str, true);\n+        }\n+\n+        static WriteCommandAction writeStdout(byte[] binary) {\n+            return new WriteCommandAction(binary, false);\n+        }\n+\n+        static WriteCommandAction writeStderr(byte[] binary) {\n+            return new WriteCommandAction(binary, true);\n+        }\n+\n+        static CatCommandAction cat(Path file) {\n+            return new CatCommandAction(file);\n+        }\n+    }\n+\n+    private record EchoCommandAction(String value, boolean stderr) implements CommandAction {\n+        EchoCommandAction {\n+            Objects.requireNonNull(value);\n+        }\n+    }\n+\n+    private record WriteCommandAction(byte[] value, boolean stderr) implements CommandAction {\n+        WriteCommandAction {\n+            Objects.requireNonNull(value);\n+        }\n+    }\n+\n+    private record CatCommandAction(Path file) implements CommandAction {\n+        CatCommandAction {\n+            Objects.requireNonNull(file);\n+        }\n+    }\n+\n+    private record SleepCommandAction(int seconds) implements CommandAction {\n+        SleepCommandAction {\n+            if (seconds < 0) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+    }\n+\n+    private record Command(List<String> stdout, List<String> stderr) {\n+        Command {\n+            stdout.forEach(Objects::requireNonNull);\n+            stderr.forEach(Objects::requireNonNull);\n+        }\n+\n+        List<String> asExecutable() {\n+            return createShellCommandLine(actions());\n+        }\n+\n+        ToolProvider asToolProvider() {\n+            return createToolProvider(actions());\n+        }\n+\n+        \/\/\n+        \/\/ Type of shell for which to create a command line.\n+        \/\/ On Unix it is always the \"sh\".\n+        \/\/ On Windows, it is \"cmd\" by default and \"powershell\" when a command needs to write binary data to output stream(s).\n+        \/\/ Extra complexity on Windows is because \"powershell\" is times slower than \"cmd\",\n+        \/\/ and the latter doesn't support binary output.\n+        \/\/\n+        private enum ShellType {\n+            SH(OperatingSystem.LINUX, OperatingSystem.MACOS),\n+            CMD(OperatingSystem.WINDOWS),\n+            POWERSHELL(OperatingSystem.WINDOWS),\n+            ;\n+\n+            ShellType(OperatingSystem... os) {\n+                if (os.length == 0) {\n+                    throw new IllegalArgumentException();\n+                }\n+                this.os = Set.of(os);\n+            }\n+\n+            boolean isSupportedOnCurrentOS() {\n+                return os.contains(OperatingSystem.current());\n+            }\n+\n+            private final Set<OperatingSystem> os;\n+        }\n+\n+        private List<CommandAction> actions() {\n+            return Stream.<CommandAction>concat(\n+                    stdout.stream().map(CommandAction::echoStdout),\n+                    stderr.stream().map(CommandAction::echoStderr)\n+            ).toList();\n+        }\n+\n+        static List<String> createShellCommandLine(List<? extends CommandAction> actions) {\n+            final var shellType = detectShellType(actions);\n+            final List<String> commandline = new ArrayList<>();\n+            final String commandSeparator;\n+            switch (shellType) {\n+                case SH -> {\n+                    commandline.addAll(List.of(\"sh\", \"-c\"));\n+                    commandSeparator = \" && \";\n+                }\n+                case CMD -> {\n+                    commandline.addAll(List.of(\"cmd\", \"\/C\"));\n+                    commandSeparator = \" && \";\n+                }\n+                case POWERSHELL -> {\n+                    commandline.addAll(List.of(\"powershell\", \"-NoProfile\", \"-Command\"));\n+                    commandSeparator = \"; \";\n+                }\n+                default -> {\n+                    \/\/ Unreachable\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+            commandline.add(actions.stream().map(action -> {\n+                return Command.toString(action, shellType);\n+            }).collect(joining(commandSeparator)));\n+            return commandline;\n+        }\n+\n+        static ToolProvider createToolProvider(List<? extends CommandAction> actions) {\n+            var copiedActions = List.copyOf(actions);\n+            return new ToolProvider() {\n+\n+                @Override\n+                public int run(PrintWriter out, PrintWriter err, String... args) {\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                @Override\n+                public int run(PrintStream out, PrintStream err, String... args) {\n+                    for (var action : copiedActions) {\n+                        switch (action) {\n+                            case EchoCommandAction echo -> {\n+                                if (echo.stderr()) {\n+                                    err.println(echo.value());\n+                                } else {\n+                                    out.println(echo.value());\n+                                }\n+                            }\n+                            case WriteCommandAction write -> {\n+                                try {\n+                                    if (write.stderr()) {\n+                                        err.write(write.value());\n+                                    } else {\n+                                        out.write(write.value());\n+                                    }\n+                                } catch (IOException ex) {\n+                                    throw new UncheckedIOException(ex);\n+                                }\n+                            }\n+                            case SleepCommandAction sleep -> {\n+                                toRunnable(() -> {\n+                                    synchronized (this) {\n+                                        var millis = Duration.ofSeconds(sleep.seconds()).toMillis();\n+                                        this.wait(millis);\n+                                    }\n+                                }).run();\n+                            }\n+                            case CatCommandAction _ -> {\n+                                \/\/ Not used, no point to implement.\n+                                throw new UnsupportedOperationException();\n+                            }\n+                        }\n+                    }\n+                    return 0;\n+                }\n+\n+                @Override\n+                public String name() {\n+                    return \"test\";\n+                }\n+            };\n+        }\n+\n+        private static ShellType detectShellType(List<? extends CommandAction> actions) {\n+            var supportedShellTypes = Stream.of(ShellType.values())\n+                    .filter(ShellType::isSupportedOnCurrentOS)\n+                    .collect(Collectors.toCollection(HashSet::new));\n+            for (var action : actions) {\n+                if (action instanceof WriteCommandAction) {\n+                    supportedShellTypes.remove(ShellType.CMD);\n+                }\n+            }\n+            return supportedShellTypes.stream()\n+                    .sorted(Comparator.comparingInt(Enum::ordinal))\n+                    .findFirst().orElseThrow();\n+        }\n+\n+        private static String toString(CommandAction action, ShellType shellType) {\n+            switch (action) {\n+                case EchoCommandAction a -> {\n+                    return toString(a, shellType);\n+                }\n+                case WriteCommandAction a -> {\n+                    return toString(a, shellType);\n+                }\n+                case SleepCommandAction a -> {\n+                    return toString(a, shellType);\n+                }\n+                case CatCommandAction a -> {\n+                    return toString(a, shellType);\n+                }\n+            }\n+        }\n+\n+        private static String toString(EchoCommandAction echo, ShellType shellType) {\n+            String str;\n+            switch (shellType) {\n+                case SH -> {\n+                    str = \"echo \" + echo.value();\n+                    if (echo.stderr()) {\n+                        str += \">&2\";\n+                    }\n+                }\n+                case CMD -> {\n+                    str = \"(echo \" + echo.value() + \")\";\n+                    if (echo.stderr()) {\n+                        str += \">&2\";\n+                    }\n+                }\n+                case POWERSHELL -> {\n+                    str = String.format(\"[Console]::%s.WriteLine(\\\\\\\"%s\\\\\\\")\",\n+                            echo.stderr() ? \"Error\" : \"Out\", echo.value());\n+                }\n+                default -> {\n+                    \/\/ Unreachable\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+            return str;\n+        }\n+\n+        private static String toString(WriteCommandAction write, ShellType shellType) {\n+            String str;\n+            switch (shellType) {\n+                case SH -> {\n+                    \/\/ Convert byte[] to octal string to make it work with POSIX printf.\n+                    \/\/ POSIX printf doesn't recognize hex strings, so can't use handy HexFormat.\n+                    var sb = new StringBuilder();\n+                    sb.append(\"printf \");\n+                    for (var b : write.value()) {\n+                        sb.append(\"\\\\\\\\\").append(Integer.toOctalString(b & 0xFF));\n+                    }\n+                    if (write.stderr()) {\n+                        sb.append(\">&2\");\n+                    }\n+                    str = sb.toString();\n+                }\n+                case CMD -> {\n+                    throw new UnsupportedOperationException(\"Can't output binary data with 'cmd'\");\n+                }\n+                case POWERSHELL -> {\n+                    var base64 = Base64.getEncoder().encodeToString(write.value());\n+                    str = String.format(\n+                            \"$base64 = '%s'; \" +\n+                            \"$bytes = [Convert]::FromBase64String($base64); \" +\n+                            \"[Console]::%s().Write($bytes, 0, $bytes.Length)\",\n+                            base64, write.stderr() ? \"OpenStandardError\" : \"OpenStandardOutput\");\n+                }\n+                default -> {\n+                    \/\/ Unreachable\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+            return str;\n+        }\n+\n+        private static String toString(SleepCommandAction sleep, ShellType shellType) {\n+            switch (shellType) {\n+                case SH -> {\n+                    return \"sleep \" + sleep.seconds();\n+                }\n+                case CMD -> {\n+                    \/\/ The standard way to sleep in \"cmd\" is to use the \"ping\" command.\n+                    \/\/ It sends packets every second.\n+                    \/\/ To wait N seconds, it should send N+1 packets.\n+                    \/\/ The \"timeout\" command works only in a console.\n+                    return String.format(\"(ping -n %d localhost > nul)\", sleep.seconds() + 1);\n+                }\n+                case POWERSHELL -> {\n+                    return \"Start-Sleep -Seconds \" + sleep.seconds();\n+                }\n+                default -> {\n+                    \/\/ Unreachable\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+        }\n+\n+        private static String toString(CatCommandAction cat, ShellType shellType) {\n+            switch (shellType) {\n+                case SH -> {\n+                    return \"cat \" + cat.file();\n+                }\n+                case CMD -> {\n+                    return \"type \" + cat.file();\n+                }\n+                case POWERSHELL -> {\n+                    \/\/ Not used, no point to implement.\n+                    throw new UnsupportedOperationException();\n+                }\n+                default -> {\n+                    \/\/ Unreachable\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    private enum OutputData {\n+        EMPTY(List.of()),\n+        ONE_LINE(List.of(\"Jupiter\")),\n+        MANY(List.of(\"Uranus\", \"Saturn\", \"Earth\"));\n+\n+        OutputData(List<String> data) {\n+            data.forEach(Objects::requireNonNull);\n+            this.data = data;\n+        }\n+\n+        final List<String> data;\n+    }\n+\n+    private record CommandSpec(OutputData stdout, OutputData stderr) {\n+        CommandSpec {\n+            Objects.requireNonNull(stdout);\n+            Objects.requireNonNull(stderr);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"[stdout=%s, stderr=%s]\", stdout, stderr);\n+        }\n+\n+        Command command() {\n+            return new Command(stdout.data.stream().map(line -> {\n+                return \"stdout.\" + line;\n+            }).toList(), stderr.data.stream().map(line -> {\n+                return \"stderr.\" + line;\n+            }).toList());\n+        }\n+    }\n+\n+    public interface CommandOutputControlMutator {\n+        String name();\n+        void mutate(CommandOutputControl coc);\n+\n+        static <T extends CommandOutputControlMutator> Function<T, Set<T>> addToSet(Set<T> set) {\n+            return m -> {\n+                return new SetBuilder<T>().add(set).add(m).create();\n+            };\n+        }\n+    }\n+\n+    public enum OutputControl implements CommandOutputControlMutator {\n+        DUMP(CommandOutputControl::dumpOutput, CommandOutputControl::isDumpOutput),\n+        SAVE_ALL(CommandOutputControl::saveOutput, CommandOutputControl::isSaveOutput),\n+        SAVE_FIRST_LINE(CommandOutputControl::saveFirstLineOfOutput, CommandOutputControl::isSaveFirstLineOfOutput),\n+        SAVE_NOTHING(coc -> {\n+            coc.saveOutput(false);\n+        }, coc -> {\n+            return !coc.isSaveOutput() && !coc.isSaveFirstLineOfOutput();\n+        }),\n+        DISCARD_STDOUT(CommandOutputControl::discardStdout, CommandOutputControl::isDiscardStdout),\n+        DISCARD_STDERR(CommandOutputControl::discardStderr, CommandOutputControl::isDiscardStderr),\n+        REDIRECT_STDERR(CommandOutputControl::redirectStderr, CommandOutputControl::isRedirectStderr),\n+        STORE_STREAMS_IN_FILES(CommandOutputControl::storeOutputInFiles, CommandOutputControl::isStoreOutputInFiles),\n+        BINARY_OUTPUT(CommandOutputControl::binaryOutput, CommandOutputControl::isBinaryOutput),\n+        DUMP_STDOUT_IN_SYSTEM_OUT(coc -> {\n+            coc.dumpStdout(new PrintStreamWrapper(System.out));\n+        }, coc -> {\n+            return coc.dumpStdout() instanceof PrintStreamWrapper;\n+        }),\n+        DUMP_STDERR_IN_SYSTEM_ERR(coc -> {\n+            coc.dumpStderr(new PrintStreamWrapper(System.err));\n+        }, coc -> {\n+            return coc.dumpStderr() instanceof PrintStreamWrapper;\n+        }),\n+        CHARSET_UTF16LE(coc -> {\n+            coc.charset(StandardCharsets.UTF_16LE);\n+        }, coc -> {\n+            return coc.charset() == StandardCharsets.UTF_16LE;\n+        }),\n+        ;\n+\n+        OutputControl(Consumer<CommandOutputControl> setter, Function<CommandOutputControl, Boolean> getter) {\n+            this.setter = Objects.requireNonNull(setter);\n+            this.unsetter = null;\n+            this.getter = Objects.requireNonNull(getter);\n+        }\n+\n+        OutputControl(BiConsumer<CommandOutputControl, Boolean> setter, Function<CommandOutputControl, Boolean> getter) {\n+            Objects.requireNonNull(setter);\n+            this.setter = coc -> {\n+                setter.accept(coc, true);\n+            };\n+            this.unsetter = coc -> {\n+                setter.accept(coc, false);\n+            };\n+            this.getter = Objects.requireNonNull(getter);\n+        }\n+\n+        @Override\n+        public void mutate(CommandOutputControl coc) {\n+            set(coc);\n+        }\n+\n+        CommandOutputControl set(CommandOutputControl coc) {\n+            setter.accept(coc);\n+            return coc;\n+        }\n+\n+        CommandOutputControl unset(CommandOutputControl coc) {\n+            Objects.requireNonNull(unsetter).accept(coc);\n+            return coc;\n+        }\n+\n+        boolean canUnset() {\n+            return unsetter != null;\n+        }\n+\n+        boolean get(CommandOutputControl coc) {\n+            return getter.apply(coc);\n+        }\n+\n+        static List<Set<OutputControl>> variants() {\n+            final List<Set<OutputControl>> variants = new ArrayList<>();\n+            for (final var binaryOutput : withAndWithout(BINARY_OUTPUT)) {\n+                for (final var redirectStderr : withAndWithout(REDIRECT_STDERR)) {\n+                    for (final var withDump : withAndWithout(DUMP)) {\n+                        variants.addAll(Stream.of(\n+                                Set.<OutputControl>of(),\n+                                Set.of(SAVE_ALL),\n+                                Set.of(SAVE_FIRST_LINE),\n+                                Set.of(DISCARD_STDOUT),\n+                                Set.of(DISCARD_STDERR),\n+                                Set.of(SAVE_ALL, DISCARD_STDOUT),\n+                                Set.of(SAVE_FIRST_LINE, DISCARD_STDOUT),\n+                                Set.of(SAVE_ALL, DISCARD_STDERR),\n+                                Set.of(SAVE_FIRST_LINE, DISCARD_STDERR),\n+                                Set.of(SAVE_ALL, DISCARD_STDOUT, DISCARD_STDERR),\n+                                Set.of(SAVE_FIRST_LINE, DISCARD_STDOUT, DISCARD_STDERR)\n+                        ).map(v -> {\n+                            return withDump.map(CommandOutputControlMutator.addToSet(v)).orElse(v);\n+                        }).map(v -> {\n+                            return redirectStderr.filter(_ -> {\n+                                return !v.containsAll(List.of(DISCARD_STDOUT, DISCARD_STDERR));\n+                            }).map(CommandOutputControlMutator.addToSet(v)).orElse(v);\n+                        }).map(v -> {\n+                            return binaryOutput.map(CommandOutputControlMutator.addToSet(v)).orElse(v);\n+                        }).toList());\n+                    }\n+                }\n+            }\n+            return variants.stream().distinct().toList();\n+        }\n+\n+        private static final class PrintStreamWrapper extends PrintStream {\n+            PrintStreamWrapper(PrintStream out) {\n+                super(out, true);\n+            }\n+        }\n+\n+        private final Consumer<CommandOutputControl> setter;\n+        private final Consumer<CommandOutputControl> unsetter;\n+        private final Function<CommandOutputControl, Boolean> getter;\n+\n+        static final Set<OutputControl> SAVE = Set.of(SAVE_ALL, SAVE_FIRST_LINE);\n+    }\n+\n+    public record CommandOutputControlSpec(Set<? extends CommandOutputControlMutator> outputControl) {\n+        public CommandOutputControlSpec {\n+            outputControl.forEach(Objects::requireNonNull);\n+            if (outputControl.containsAll(OutputControl.SAVE)) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return outputControl.stream().map(CommandOutputControlMutator::name).sorted().collect(joining(\"+\"));\n+        }\n+\n+        boolean contains(OutputControl v) {\n+            return outputControl.contains(Objects.requireNonNull(v));\n+        }\n+\n+        boolean dumpOutput() {\n+            return contains(OutputControl.DUMP);\n+        }\n+\n+        boolean saveOutput() {\n+            return !Collections.disjoint(outputControl, OutputControl.SAVE);\n+        }\n+\n+        boolean discardStdout() {\n+            return contains(OutputControl.DISCARD_STDOUT);\n+        }\n+\n+        boolean discardStderr() {\n+            return contains(OutputControl.DISCARD_STDERR);\n+        }\n+\n+        boolean redirectStderr() {\n+            return contains(OutputControl.REDIRECT_STDERR);\n+        }\n+\n+        CommandOutputControl create() {\n+            final CommandOutputControl coc = new CommandOutputControl();\n+            outputControl.forEach(control -> control.mutate(coc));\n+            return coc;\n+        }\n+    }\n+\n+    public record OutputTestSpec(boolean toolProvider, CommandOutputControlSpec cocSpec, CommandSpec commandSpec) {\n+        public OutputTestSpec {\n+            Objects.requireNonNull(cocSpec);\n+            Objects.requireNonNull(commandSpec);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final List<String> tokens = new ArrayList<>();\n+\n+            if (toolProvider) {\n+                tokens.add(\"tool-provider\");\n+            }\n+\n+            tokens.add(\"output=\" + cocSpec.toString());\n+            tokens.add(\"command=\" + commandSpec);\n+\n+            return String.join(\", \", tokens.toArray(String[]::new));\n+        }\n+\n+        void test() {\n+            final var command = commandSpec.command();\n+\n+            final Slot<CommandOutputControl.Result> result = Slot.createEmpty();\n+            final var dumpCapture = DumpCapture.captureDump(toRunnable(() -> {\n+                result.set(createExecutable(command).execute());\n+            }));\n+\n+            assertEquals(0, result.get().getExitCode());\n+\n+            verifyDump(dumpCapture, command);\n+            if (contains(OutputControl.BINARY_OUTPUT)) {\n+                verifyByteResultContent(result.get(), command, StandardCharsets.UTF_8);\n+            } else {\n+                verifyResultContent(result.get(), command);\n+            }\n+        }\n+\n+        private boolean contains(OutputControl v) {\n+            return cocSpec.contains(v);\n+        }\n+\n+        private boolean dumpOutput() {\n+            return cocSpec.dumpOutput();\n+        }\n+\n+        private boolean saveOutput() {\n+            return cocSpec.saveOutput();\n+        }\n+\n+        private boolean discardStdout() {\n+            return cocSpec.discardStdout();\n+        }\n+\n+        private boolean discardStderr() {\n+            return cocSpec.discardStderr();\n+        }\n+\n+        private boolean redirectStderr() {\n+            return cocSpec.redirectStderr();\n+        }\n+\n+        private boolean replaceStdoutWithStderr() {\n+            return redirectStderr() && discardStdout() && !discardStderr();\n+        }\n+\n+        private boolean stdoutInherited() {\n+            if (toolProvider || saveOutput() || replaceStdoutWithStderr()) {\n+                return false;\n+            }\n+            return dumpOutput() && !discardStdout() && !contains(OutputControl.DUMP_STDOUT_IN_SYSTEM_OUT);\n+        }\n+\n+        private boolean stderrInherited() {\n+            if (toolProvider || saveOutput() || redirectStderr()) {\n+                return false;\n+            }\n+            return dumpOutput() && !discardStderr() && !contains(OutputControl.DUMP_STDERR_IN_SYSTEM_ERR);\n+        }\n+\n+        private void verifyDump(DumpCapture dumpCapture, Command command) {\n+            if (!dumpOutput()) {\n+                assertEquals(List.of(), dumpCapture.outLines());\n+                assertEquals(List.of(), dumpCapture.errLines());\n+                return;\n+            }\n+\n+            if (replaceStdoutWithStderr()) {\n+                \/\/ STDERR replaces STDOUT\n+                assertEquals(command.stderr(), dumpCapture.outLines());\n+                assertEquals(List.of(), dumpCapture.errLines());\n+                return;\n+            }\n+\n+            verifyDumpedStdout(dumpCapture, command);\n+            verifyDumpedStderr(dumpCapture, command);\n+        }\n+\n+        private void verifyDumpedStdout(DumpCapture dumpCapture, Command command) {\n+            if (stdoutInherited()) {\n+                \/\/ A subprocess wrote its STDOUT into a file descriptor associated\n+                \/\/ with the Java process's STDOUT, not into System.out. Can't capture it.\n+                assertEquals(List.of(), dumpCapture.outLines());\n+                return;\n+            }\n+\n+            if (redirectStderr() && !discardStderr()) {\n+                \/\/ Interleaved STDOUT and STDERR\n+                if (!isInterleave(dumpCapture.outLines(), command.stdout(), command.stderr())) {\n+                    fail(String.format(\"Unexpected combined output=%s; stdout=%s; stderr=%s\",\n+                            dumpCapture.outLines(), command.stdout(), command.stderr()));\n+                }\n+            } else if (discardStdout()) {\n+                assertEquals(List.of(), dumpCapture.outLines());\n+            } else {\n+                assertEquals(command.stdout(), dumpCapture.outLines());\n+            }\n+        }\n+\n+        private void verifyDumpedStderr(DumpCapture dumpCapture, Command command) {\n+            if (stderrInherited()) {\n+                \/\/ A subprocess wrote its STDERR into a file descriptor associated\n+                \/\/ with the Java process's STDERR, not into System.err. Can't capture it.\n+                assertEquals(List.of(), dumpCapture.errLines());\n+                return;\n+            }\n+\n+            if (redirectStderr() || discardStderr()) {\n+                assertEquals(List.of(), dumpCapture.errLines());\n+            } else {\n+                assertEquals(command.stderr(), dumpCapture.errLines());\n+            }\n+        }\n+\n+        private void verifyResultContent(CommandOutputControl.Result result, Command command) {\n+            Objects.requireNonNull(result);\n+            Objects.requireNonNull(command);\n+\n+            assertTrue(result.findByteContent().isEmpty());\n+            assertTrue(result.findByteStdout().isEmpty());\n+            assertTrue(result.findByteStderr().isEmpty());\n+\n+            if (!saveOutput()) {\n+                assertTrue(result.findContent().isEmpty());\n+                assertTrue(result.findStdout().isEmpty());\n+                assertTrue(result.findStderr().isEmpty());\n+                return;\n+            }\n+\n+            assertTrue(result.findContent().isPresent());\n+\n+            command = filterSavedStreams(command);\n+\n+            var content = result.content();\n+\n+            if (contains(OutputControl.SAVE_FIRST_LINE)) {\n+                assertTrue(content.size() <= 2, String.format(\"The number of saved lines must be less than or equal to two. Actual: %d\", result.content().size()));\n+            }\n+\n+            if (!redirectStderr()) {\n+                var stdout = result.stdout();\n+                var stderr = result.stderr();\n+\n+                assertEquals(command.stdout(), stdout);\n+                assertEquals(command.stderr(), stderr);\n+                assertEquals(Stream.of(\n+                        stdout,\n+                        stderr\n+                ).flatMap(List::stream).toList(), content);\n+            } else {\n+                assertEquals(discardStderr(), result.findStdout().isPresent());\n+                assertTrue(result.findStderr().isEmpty());\n+                if (contains(OutputControl.SAVE_FIRST_LINE)) {\n+                    assertTrue(List.of(command.stdout(), command.stderr()).contains(result.content()),\n+                            String.format(\"Saved content %s is either %s or %s\",\n+                                    content, command.stdout(), command.stderr()));\n+                } else if (contains(OutputControl.SAVE_ALL)) {\n+                    if (!isInterleave(content, command.stdout(), command.stderr())) {\n+                        fail(String.format(\"Unexpected combined saved content=%s; stdout=%s; stderr=%s\",\n+                                content, command.stdout(), command.stderr()));\n+                    }\n+                } else {\n+                    \/\/ Unreachable\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+        }\n+\n+        private void verifyByteResultContent(CommandOutputControl.Result result, Command command, Charset charset) {\n+            Objects.requireNonNull(result);\n+            Objects.requireNonNull(command);\n+            Objects.requireNonNull(charset);\n+\n+            assertTrue(result.findContent().isEmpty());\n+            assertTrue(result.findStdout().isEmpty());\n+            assertTrue(result.findStderr().isEmpty());\n+\n+            if (!saveOutput()) {\n+                assertTrue(result.findByteContent().isEmpty());\n+                assertTrue(result.findByteStdout().isEmpty());\n+                assertTrue(result.findByteStderr().isEmpty());\n+                return;\n+            }\n+\n+            assertTrue(result.findByteContent().isPresent());\n+\n+            command = filterSavedStreams(command);\n+\n+            if (!redirectStderr()) {\n+                assertEquals(command.stdout(), toStringList(result.byteStdout(), charset));\n+                assertEquals(command.stderr(), toStringList(result.byteStderr(), charset));\n+                assertEquals(Stream.of(\n+                        command.stdout(),\n+                        command.stderr()\n+                ).flatMap(List::stream).toList(), toStringList(result.byteContent(), charset));\n+            } else {\n+                assertEquals(discardStderr(), result.findByteStdout().isPresent());\n+                assertTrue(result.findByteStderr().isEmpty());\n+\n+                var combined = toStringList(result.byteContent(), charset);\n+                if (!isInterleave(combined, command.stdout(), command.stderr())) {\n+                    fail(String.format(\"Unexpected combined saved content=%s; stdout=%s; stderr=%s\",\n+                            combined, command.stdout(), command.stderr()));\n+                }\n+            }\n+        }\n+\n+        private List<String> expectedSavedStream(List<String> commandOutput) {\n+            Objects.requireNonNull(commandOutput);\n+            if (contains(OutputControl.SAVE_ALL) || (contains(OutputControl.SAVE_FIRST_LINE) && contains(OutputControl.BINARY_OUTPUT))) {\n+                return commandOutput;\n+            } else if (contains(OutputControl.SAVE_FIRST_LINE)) {\n+                return commandOutput.stream().findFirst().map(List::of).orElseGet(List::of);\n+            } else {\n+                throw new IllegalStateException();\n+            }\n+        }\n+\n+        private Command filterSavedStreams(Command command) {\n+            return new Command(\n+                    (discardStdout() ? List.of() : expectedSavedStream(command.stdout())),\n+                    (discardStderr() ? List.of() : expectedSavedStream(command.stderr())));\n+        }\n+\n+        private record DumpCapture(byte[] out, byte[] err, Charset outCharset, Charset errCharset) {\n+            DumpCapture {\n+                Objects.requireNonNull(out);\n+                Objects.requireNonNull(err);\n+                Objects.requireNonNull(outCharset);\n+                Objects.requireNonNull(errCharset);\n+            }\n+\n+            List<String> outLines() {\n+                return toStringList(out, outCharset);\n+            }\n+\n+            List<String> errLines() {\n+                return toStringList(err, errCharset);\n+            }\n+\n+            static DumpCapture captureDump(Runnable runnable) {\n+                final var captureOut = new ByteArrayOutputStream();\n+                final var captureErr = new ByteArrayOutputStream();\n+\n+                final var out = System.out;\n+                final var err = System.err;\n+                try {\n+                    final var outCharset = System.out.charset();\n+                    final var errCharset = System.err.charset();\n+                    System.setOut(new PrintStream(captureOut, true, outCharset));\n+                    System.setErr(new PrintStream(captureErr, true, errCharset));\n+                    runnable.run();\n+                    return new DumpCapture(captureOut.toByteArray(), captureErr.toByteArray(), outCharset, errCharset);\n+                } finally {\n+                    try {\n+                        System.setOut(out);\n+                    } finally {\n+                        System.setErr(err);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private CommandOutputControl.Executable createExecutable(Command command) {\n+            final var coc = cocSpec.create();\n+            if (toolProvider) {\n+                return coc.createExecutable(command.asToolProvider());\n+            } else {\n+                return coc.createExecutable(new ProcessBuilder(command.asExecutable()));\n+            }\n+        }\n+    }\n+\n+    record CharsetTestSpec(boolean toolProvider, CommandOutputControlSpec cocSpec) {\n+\n+        void test() throws IOException, InterruptedException {\n+            if (cocSpec.outputControl().stream().noneMatch(DumpOutputSink.class::isInstance)) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            final var expectedString = \"veni-vidi-vici\";\n+\n+            var coc = cocSpec.create().dumpOutput(true);\n+\n+            CommandOutputControl.Executable exec;\n+            if (toolProvider) {\n+                var tp = Command.createToolProvider(Stream.of(expectedString).<CommandAction>mapMulti((str, sink) -> {\n+                    sink.accept(CommandAction.echoStdout(str));\n+                    sink.accept(CommandAction.echoStderr(str));\n+                }).toList());\n+                exec = coc.createExecutable(tp);\n+            } else {\n+                var cmdline = Command.createShellCommandLine(Stream.of(expectedString).map(str -> {\n+                    return (str + System.lineSeparator()).getBytes(coc.charset());\n+                }).<CommandAction>mapMulti((bytes, sink) -> {\n+                    sink.accept(CommandAction.writeStdout(bytes));\n+                    sink.accept(CommandAction.writeStderr(bytes));\n+                }).toList());\n+                exec = coc.createExecutable(new ProcessBuilder(cmdline));\n+            }\n+\n+            exec.execute();\n+\n+            for (var outputContolMutator : cocSpec.outputControl()) {\n+                if (outputContolMutator instanceof DumpOutputSink sink) {\n+                    var actual = sink.lines();\n+                    List<String> expected;\n+                    if (cocSpec.redirectStderr()) {\n+                        switch (sink.streams()) {\n+                            case STDERR -> {\n+                                expected = List.of();\n+                            }\n+                            default -> {\n+                                expected = List.of(expectedString, expectedString);\n+                            }\n+                        }\n+                    } else {\n+                        expected = List.of(expectedString);\n+                    }\n+                    assertEquals(expected, actual);\n+                }\n+            }\n+\n+        }\n+\n+        record DumpOutputSink(Charset charset, ByteArrayOutputStream buffer, OutputStreams streams) implements CommandOutputControlMutator {\n+            DumpOutputSink {\n+                Objects.requireNonNull(charset);\n+                Objects.requireNonNull(buffer);\n+                Objects.requireNonNull(streams);\n+            }\n+\n+            DumpOutputSink(Charset charset, OutputStreams streams) {\n+                this(charset, new ByteArrayOutputStream(), streams);\n+            }\n+\n+            List<String> lines() {\n+                var str = buffer.toString(charset);\n+                return new BufferedReader(new StringReader(str)).lines().toList();\n+            }\n+\n+            @Override\n+            public String name() {\n+                return String.format(\"DUMP-%s-%s\", streams, charset.name());\n+            }\n+\n+            @Override\n+            public void mutate(CommandOutputControl coc) {\n+                var ps = new PrintStream(buffer, false, charset);\n+                switch (streams) {\n+                    case STDOUT -> {\n+                        coc.dumpStdout(ps);\n+                    }\n+                    case STDERR -> {\n+                        coc.dumpStderr(ps);\n+                    }\n+                    case STDOUT_AND_STDERR -> {\n+                        \/\/ Easy to implement, but not used.\n+                        throw new IllegalArgumentException();\n+                    }\n+                    default -> {\n+                        \/\/ Unreachable\n+                        throw ExceptionBox.reachedUnreachable();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private final static class InterruptibleToolProvider implements ToolProvider {\n+\n+        InterruptibleToolProvider(ToolProvider impl) {\n+            this.impl = impl;\n+        }\n+\n+        @Override\n+        public String name() {\n+            return impl.name();\n+        }\n+\n+        @Override\n+        public int run(PrintStream out, PrintStream err, String... args) {\n+            return run(_ -> {\n+                return impl.run(out, err, args);\n+            }, args);\n+        }\n+\n+        @Override\n+        public int run(PrintWriter out, PrintWriter err, String... args) {\n+            return run(_ -> {\n+                return impl.run(out, err, args);\n+            }, args);\n+        }\n+\n+        boolean interrupted() {\n+            return interrupted.join();\n+        }\n+\n+        private int run(Function<String[], Integer> workload, String... args) {\n+            boolean interruptedValue = false;\n+            try {\n+                return workload.apply(args);\n+            } catch (ExceptionBox ex) {\n+                if (ex.getCause() instanceof InterruptedException) {\n+                    interruptedValue = true;\n+                    return 1;\n+                } else {\n+                    throw ex;\n+                }\n+            } finally {\n+                interrupted.complete(interruptedValue);\n+            }\n+        }\n+\n+        private final ToolProvider impl;\n+        private final CompletableFuture<Boolean> interrupted = new CompletableFuture<>();\n+    }\n+\n+    private static List<String> toStringList(byte[] data, Charset charset) {\n+        try (var bufReader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(data), charset))) {\n+            return bufReader.lines().toList();\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private static <T> List<Optional<T>> withAndWithout (T value) {\n+        return List.of(Optional.empty(), Optional.of(value));\n+    }\n+\n+    private static final List<Boolean> BOOLEAN_VALUES = List.of(true, false);\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/CommandOutputControlTest.java","additions":1846,"deletions":0,"binary":false,"changes":1846,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class CommandOutputControlTestUtils {\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_isInterleave(TestSpec test) {\n+        test.run();\n+    }\n+\n+    private static Stream<TestSpec> test_isInterleave() {\n+        var data = new ArrayList<TestSpec>();\n+\n+        data.addAll(List.of(\n+                interleaved(\"Toaday\", \"Today\", \"a\"),\n+                interleaved(\"Todanaay\", \"Today\", \"ana\"),\n+                interleaved(\"aaaababaaa\", \"aaaba\", \"aabaa\"),\n+                interleaved(\"xxxxxxxxxxxyxxyx\", \"xxxxxxxy\", \"xxxxxyxx\"),\n+                interleaved(\"xyxxxxyxxxxxxxxx\", \"yxxxxxxx\", \"xxxyxxxx\"),\n+                interleaved(\"xxxxxxxyxxxxyxxx\", \"xxxyxxxx\", \"xxxxxxyx\"),\n+                interleaved(\"cbdddcdaadacdbddbdcdddccdabbadba\", \"cdddaaddbcdcdbab\", \"bdcadcbddddcabda\"),\n+                interleaved(\"ddbdcacddddbddbdbddadcaaccdcabab\", \"dbccdddbbddacdaa\", \"ddaddbdddacaccbb\"),\n+                interleaved(\"adccbacbacaacddadddcdbbddbbddddd\", \"acbcaacddddbdbdd\", \"dcabcadadcbdbddd\"),\n+                interleaved(\"abdbdabdaacdcdbddddadbbccddcddac\", \"addbaccbdddbcdda\", \"bbadaddddabcdcdc\"),\n+                interleaved(\"cdaacbddaabdddbddbddbddadbacccdc\", \"dabdadddbddabccc\", \"cacdabdbddbddacd\"),\n+                notInterleaved(\"Toady\", \"Today\", \"a\"),\n+                notInterleaved(\"\", \"Today\", \"a\")\n+        ));\n+\n+        data.addAll(generateTestData(\"abcdefghijklmnopqrstuvwxyz\", 10));\n+        data.addAll(generateTestData(\"xxxxxxxy\", 8));\n+        data.addAll(generateTestData(\"aaabbbcccddddddd\", 50));\n+\n+        return data.stream().flatMap(test -> {\n+            return Stream.of(test, test.flip());\n+        });\n+    }\n+\n+    private static List<TestSpec> generateTestData(String src, int iteration) {\n+\n+        var srcCodePoints = new ArrayList<Integer>();\n+        src.codePoints().mapToObj(Integer::valueOf).forEach(srcCodePoints::add);\n+\n+        var data = new ArrayList<TestSpec>();\n+\n+        Function<List<Integer>, String> toString = codePoints -> {\n+            var arr = codePoints.stream().mapToInt(Integer::intValue).toArray();\n+            return new String(arr, 0, arr.length);\n+        };\n+\n+        for (int i = 0; i < 10; i++) {\n+            Collections.shuffle(srcCodePoints);\n+            var a = List.copyOf(srcCodePoints);\n+\n+            Collections.shuffle(srcCodePoints);\n+            var b = List.copyOf(srcCodePoints);\n+\n+            var zip = new int[srcCodePoints.size() * 2];\n+            for (int codePointIdx = 0; codePointIdx != a.size(); codePointIdx++) {\n+                var dstIdx = codePointIdx * 2;\n+                zip[dstIdx] = a.get(codePointIdx);\n+                zip[dstIdx + 1] = b.get(codePointIdx);\n+            }\n+\n+            data.add(interleaved(toString.apply(Arrays.stream(zip).boxed().toList()), toString.apply(a), toString.apply(b)));\n+        }\n+\n+        return data;\n+    }\n+\n+    public record TestSpec(String combined, String a, String b, boolean expected) {\n+\n+        public TestSpec {\n+            Objects.requireNonNull(combined);\n+            Objects.requireNonNull(a);\n+            Objects.requireNonNull(b);\n+        }\n+\n+        TestSpec flip() {\n+            return new TestSpec(combined, b, a, expected);\n+        }\n+\n+        void run() {\n+            assertEquals(expected, isInterleave(\n+                    combined.chars().mapToObj(Integer::valueOf).toList(),\n+                    a.chars().mapToObj(Integer::valueOf).toList(),\n+                    b.chars().mapToObj(Integer::valueOf).toList()),\n+                    String.format(\"combined: %s; a=%s; b=%s\", combined, a, b));\n+        }\n+    }\n+\n+    private static TestSpec interleaved(String combined, String a, String b) {\n+        return new TestSpec(combined, a, b, true);\n+    }\n+\n+    private static TestSpec notInterleaved(String combined, String a, String b) {\n+        return new TestSpec(combined, a, b, false);\n+    }\n+\n+    \/\/ Solves the standard \"Find if a string C is an interleave of strings A and B.\"\n+    \/\/ problem but use containers instead of strings.\n+    static <T> boolean isInterleave(List<T> combined, List<T> a, List<T> b) {\n+\n+        if (a.size() + b.size() != combined.size()) {\n+            return false;\n+        }\n+\n+        final var n = a.size();\n+        final var m = b.size();\n+\n+        var prev = new boolean[m + 1];\n+        final var cur = new boolean[m + 1];\n+\n+        prev[0] = true;\n+\n+        for (int j = 1; j <= m; j++) {\n+            prev[j] = prev[j - 1] && Objects.equals(b.get(j - 1), combined.get(j - 1));\n+        }\n+\n+        for (int i = 1; i <= n; i++) {\n+            cur[0] = prev[0] && Objects.equals(a.get(i - 1), combined.get(i - 1));\n+\n+            for (int j = 1; j <= m; j++) {\n+                int k = i + j;\n+                cur[j] = (prev[j] && Objects.equals(a.get(i - 1), combined.get(k - 1)))\n+                        || (cur[j - 1] && Objects.equals(b.get(j - 1), combined.get(k - 1)));\n+            }\n+\n+            prev = cur.clone();\n+        }\n+\n+        return prev[m];\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/CommandOutputControlTestUtils.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.stream.Stream;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+\n+public class EnquoterTest {\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testForShellLiterals(String expected, String input) {\n+        var actual = Enquoter.forShellLiterals().applyTo(input);\n+        assertEquals(expected, actual);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testForPropertyValues(String expected, String input) {\n+        var actual = Enquoter.forPropertyValues().applyTo(input);\n+        assertEquals(expected, actual);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testIdentity(String input) {\n+        var actual = Enquoter.identity().applyTo(input);\n+        assertEquals(input, actual);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testIdentity\")\n+    public void testNoEscaper(String input) {\n+        var actual = Enquoter.identity().setEnquotePredicate(_ -> true).applyTo(input);\n+        assertEquals('\"' + input + '\"', actual);\n+    }\n+\n+    private static Stream<Arguments> testForShellLiterals() {\n+        return Stream.of(\n+                Arguments.of(\"''\", \"\"),\n+                Arguments.of(\"'foo'\", \"foo\"),\n+                Arguments.of(\"' foo '\", \" foo \"),\n+                Arguments.of(\"'foo bar'\", \"foo bar\"),\n+                Arguments.of(\"'foo\\\\' bar'\", \"foo' bar\")\n+        );\n+    }\n+\n+    private static Stream<Arguments> testForPropertyValues() {\n+        return Stream.of(\n+                Arguments.of(\"\", \"\"),\n+                Arguments.of(\"foo\", \"foo\"),\n+                Arguments.of(\"\\\" foo \\\"\", \" foo \"),\n+                Arguments.of(\"\\\"foo bar\\\"\", \"foo bar\"),\n+                Arguments.of(\"\\\"foo' bar\\\"\", \"foo' bar\")\n+        );\n+    }\n+\n+    private static Stream<String> testIdentity() {\n+        return Stream.of(\"\", \"foo\", \" foo \", \"foo bar\", \"foo' bar\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/EnquoterTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,331 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Objects;\n+import jdk.jpackage.internal.util.RetryExecutor.Context;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import jdk.jpackage.internal.util.function.ThrowingFunction;\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class RetryExecutorTest {\n+\n+    @Test\n+    public void test_defaults() {\n+\n+        var executor = new AttemptCounter<Void, Exception>(context -> {\n+            throw new AttemptFailedException();\n+        });\n+\n+        var defaultTimeout = Duration.ofSeconds(2);\n+        var defaultAttemptCount = 5;\n+\n+        var timeout = Slot.<Duration>createEmpty();\n+\n+        assertThrowsExactly(AttemptFailedException.class, new RetryExecutor<Void, Exception>(Exception.class)\n+                .setExecutable(executor)\n+                .setSleepFunction(t -> {\n+                    assertEquals(defaultTimeout, t);\n+                    timeout.set(t);\n+                    return;\n+                })::execute);\n+\n+        assertEquals(defaultTimeout, timeout.get());\n+        assertEquals(defaultAttemptCount, executor.count());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {0, 1, 2, 3, -4})\n+    public void test_N_attempts_fail(int maxAttemptsCount) throws AttemptFailedException {\n+\n+        var retry = new RetryExecutor<String, AttemptFailedException>(AttemptFailedException.class)\n+                .setMaxAttemptsCount(maxAttemptsCount)\n+                .setAttemptTimeout(null)\n+                .setExecutable(context -> {\n+                    if (context.attempt() == (maxAttemptsCount - 1)) {\n+                        assertTrue(context.isLastAttempt());\n+                    } else {\n+                        assertFalse(context.isLastAttempt());\n+                    }\n+                    throw new AttemptFailedException(\"Attempt: \" + context.attempt());\n+                });\n+\n+        if (maxAttemptsCount <= 0) {\n+            assertNull(retry.execute());\n+        } else {\n+            var ex = assertThrowsExactly(AttemptFailedException.class, retry::execute);\n+            assertEquals(\"Attempt: \" + (maxAttemptsCount - 1), ex.getMessage());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {1, 2, 3})\n+    public void test_N_attempts_last_succeed(int maxAttemptsCount) throws AttemptFailedException {\n+        test_N_attempts_M_succeed(maxAttemptsCount, maxAttemptsCount - 1, false);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {2, 3})\n+    public void test_N_attempts_first_succeed(int maxAttemptsCount) throws AttemptFailedException {\n+        test_N_attempts_M_succeed(maxAttemptsCount, 0, false);\n+    }\n+\n+    @Test\n+    public void test_N_attempts_2nd_succeed() throws AttemptFailedException {\n+        test_N_attempts_M_succeed(4, 1, false);\n+    }\n+\n+    @Test\n+    public void test_N_attempts_2nd_succeed_unchecked() throws AttemptFailedException {\n+        test_N_attempts_M_succeed(4, 1, true);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_null_executor(boolean dynamic) {\n+        var retry = new RetryExecutor<Void, AttemptFailedException>(AttemptFailedException.class)\n+                .setAttemptTimeout(null).setMaxAttemptsCount(1000);\n+\n+        if (dynamic) {\n+            int maxAttemptsCount = 3;\n+            var executor = new AttemptCounter<Void, AttemptFailedException>(context -> {\n+                assertTrue(context.attempt() <= (maxAttemptsCount - 1));\n+                if (context.attempt() == (maxAttemptsCount - 1)) {\n+                    context.executor().setExecutable((ThrowingSupplier<Void, AttemptFailedException>)null);\n+                }\n+                throw new AttemptFailedException(\"foo\");\n+            });\n+\n+            retry.setExecutable(executor);\n+\n+            var ex = assertThrowsExactly(IllegalStateException.class, retry::execute);\n+            assertEquals(\"No executable\", ex.getMessage());\n+            assertEquals(3, executor.count());\n+        } else {\n+            var ex = assertThrowsExactly(IllegalStateException.class, retry::execute);\n+            assertEquals(\"No executable\", ex.getMessage());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_unexpected_exception(boolean executeUnchecked) {\n+        var cause = new UnsupportedOperationException(\"foo\");\n+\n+        var executor = new AttemptCounter<Void, IOException>(context -> {\n+            assertEquals(0, context.attempt());\n+            throw cause;\n+        });\n+\n+        var retry = new RetryExecutor<Void, IOException>(IOException.class).setExecutable(executor)\n+                .setMaxAttemptsCount(10).setAttemptTimeout(null);\n+\n+        UnsupportedOperationException ex;\n+        if (executeUnchecked) {\n+            ex = assertThrowsExactly(UnsupportedOperationException.class, retry::executeUnchecked);\n+        } else {\n+            ex = assertThrowsExactly(UnsupportedOperationException.class, retry::execute);\n+        }\n+        assertSame(cause, ex);\n+        assertEquals(1, executor.count());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_dynamic(boolean abort) {\n+        int maxAttemptsCount = 4;\n+\n+        var secondExecutor = new AttemptCounter<String, AttemptFailedException>(context -> {\n+            throw new AttemptFailedException(\"bar\");\n+        });\n+\n+        var firstExecutor = new AttemptCounter<String, AttemptFailedException>(context -> {\n+            assertTrue(context.attempt() <= (maxAttemptsCount - 1));\n+            if (context.attempt() == (maxAttemptsCount - 1)) {\n+                if (abort) {\n+                    context.executor().setMaxAttemptsCount(maxAttemptsCount);\n+                } else {\n+                    \/\/ Let it go two more times.\n+                    context.executor().setMaxAttemptsCount(maxAttemptsCount + 2);\n+                }\n+                context.executor().setExecutable(secondExecutor);\n+            }\n+            throw new AttemptFailedException(\"foo\");\n+        });\n+\n+        var retry = new RetryExecutor<String, AttemptFailedException>(AttemptFailedException.class)\n+                .setExecutable(firstExecutor)\n+                .setMaxAttemptsCount(1000000)\n+                .setAttemptTimeout(null);\n+\n+        var ex = assertThrowsExactly(AttemptFailedException.class, retry::execute);\n+        if (abort) {\n+            assertEquals(\"foo\", ex.getMessage());\n+            assertEquals(0, secondExecutor.count());\n+        } else {\n+            assertEquals(\"bar\", ex.getMessage());\n+            assertEquals(2, secondExecutor.count());\n+        }\n+        assertEquals(maxAttemptsCount, firstExecutor.count());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_supplier_executor(boolean isNull) throws Exception {\n+        var retry = new RetryExecutor<String, Exception>(Exception.class).setMaxAttemptsCount(1);\n+        if (isNull) {\n+            retry.setExecutable((ThrowingSupplier<String, Exception>)null);\n+            var ex = assertThrowsExactly(IllegalStateException.class, retry::execute);\n+            assertEquals(\"No executable\", ex.getMessage());\n+        } else {\n+            retry.setExecutable(() -> \"Hello\");\n+            assertEquals(\"Hello\", retry.execute());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_executeUnchecked_fail(boolean withExceptionMapper) throws AttemptFailedException {\n+        var retry = new RetryExecutor<String, AttemptFailedException>(AttemptFailedException.class).setExecutable(() -> {\n+            throw new AttemptFailedException(\"kaput!\");\n+        }).setMaxAttemptsCount(1);\n+\n+        Class<? extends Exception> expectedExceptionType;\n+        if (withExceptionMapper) {\n+            retry.setExceptionMapper((AttemptFailedException ex) -> {\n+                assertEquals(\"kaput!\", ex.getMessage());\n+                return new UncheckedAttemptFailedException(ex);\n+            });\n+            expectedExceptionType = UncheckedAttemptFailedException.class;\n+        } else {\n+            expectedExceptionType = ExceptionBox.class;\n+        }\n+\n+        var ex = assertThrowsExactly(expectedExceptionType, retry::executeUnchecked);\n+        assertEquals(AttemptFailedException.class, ex.getCause().getClass());\n+        assertEquals(\"kaput!\", ex.getCause().getMessage());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_setSleepFunction(boolean withTimeout) {\n+\n+        var timeout = Slot.<Duration>createEmpty();\n+\n+        assertDoesNotThrow(new RetryExecutor<Void, AttemptFailedException>(AttemptFailedException.class)\n+                .setMaxAttemptsCount(2)\n+                .mutate(retry -> {\n+                    if (withTimeout) {\n+                        retry.setAttemptTimeout(Duration.ofDays(100));\n+                    } else {\n+                        retry.setAttemptTimeout(null);\n+                    }\n+                })\n+                .setExecutable(context -> {\n+                    if (context.isLastAttempt()) {\n+                        return null;\n+                    } else {\n+                        throw new AttemptFailedException();\n+                    }\n+                })\n+                .setSleepFunction(timeout::set)::execute);\n+\n+        assertEquals(withTimeout, timeout.find().isPresent());\n+        if (withTimeout) {\n+            assertEquals(Duration.ofDays(100), timeout.get());\n+        }\n+    }\n+\n+    private static void test_N_attempts_M_succeed(int maxAttempts, int failedAttempts, boolean unchecked) throws AttemptFailedException {\n+\n+        var countingExecutor = new AttemptCounter<String, AttemptFailedException>(context -> {\n+            if (context.attempt() == failedAttempts) {\n+                return \"You made it!\";\n+            } else {\n+                throw new AttemptFailedException();\n+            }\n+        });\n+\n+        var retry = new RetryExecutor<String, AttemptFailedException>(AttemptFailedException.class)\n+                .setMaxAttemptsCount(maxAttempts)\n+                .setAttemptTimeout(null)\n+                .setExecutable(countingExecutor);\n+\n+        assertEquals(\"You made it!\", unchecked ? retry.execute() : retry.executeUnchecked());\n+        assertEquals(failedAttempts, countingExecutor.count() - 1);\n+    }\n+\n+    private static final class AttemptCounter<T, E extends Exception> implements ThrowingFunction<Context<RetryExecutor<T, E>>, T, E> {\n+\n+        AttemptCounter(ThrowingFunction<Context<RetryExecutor<T, E>>, T, E> impl) {\n+            this.impl = Objects.requireNonNull(impl);\n+        }\n+\n+        @Override\n+        public T apply(Context<RetryExecutor<T, E>> context) throws E {\n+            counter++;\n+            return impl.apply(context);\n+        }\n+\n+        int count() {\n+            return counter;\n+        }\n+\n+        private int counter;\n+        private final ThrowingFunction<Context<RetryExecutor<T, E>>, T, E> impl;\n+    }\n+\n+    private static final class AttemptFailedException extends Exception {\n+\n+        AttemptFailedException(String msg) {\n+            super(msg);\n+        }\n+\n+        AttemptFailedException() {\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    private static final class UncheckedAttemptFailedException extends RuntimeException {\n+\n+        UncheckedAttemptFailedException(AttemptFailedException ex) {\n+            super(ex);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/RetryExecutorTest.java","additions":331,"deletions":0,"binary":false,"changes":331,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -444,4 +444,1 @@\n-                    .error(\"ERR_CannotParseOptions\", \"foo\"),\n-            \/\/ invalid jlink option\n-            testSpec().addArgs(\"--jlink-options\", \"--foo\")\n-                    .error(\"error.jlink.failed\", \"Error: unknown option: --foo\")\n+                    .error(\"ERR_CannotParseOptions\", \"foo\")\n","filename":"test\/jdk\/tools\/jpackage\/share\/ErrorTest.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -232,1 +232,1 @@\n-            final var imageDir = result.stdout().getOutput().stream().map(String::stripLeading).filter(str -> {\n+            final var imageDir = result.stdout().stream().map(String::stripLeading).filter(str -> {\n","filename":"test\/jdk\/tools\/jpackage\/share\/PostImageScriptTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}