{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-                          StringBuffer buffer) {\n+                          Format.StringBuf buffer) {\n@@ -96,1 +96,1 @@\n-                          int start, int end, StringBuffer buffer) {\n+                          int start, int end, Format.StringBuf buffer) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/CharacterIteratorFieldDelegate.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -517,1 +517,7 @@\n-        return format((double)number, toAppendTo, status);\n+        return format((double) number, StringBufFactory.of(toAppendTo), status).asStringBuffer();\n+    }\n+\n+    @Override\n+    StringBuf format(long number, StringBuf toAppendTo,\n+                     FieldPosition status) {\n+        return format((double) number, toAppendTo, status);\n@@ -534,0 +540,6 @@\n+        return format(number, StringBufFactory.of(toAppendTo), status).asStringBuffer();\n+    }\n+\n+    @Override\n+    StringBuf format(double number, StringBuf toAppendTo,\n+                         FieldPosition status) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/ChoiceFormat.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -555,0 +555,29 @@\n+        } else if (number instanceof BigDecimal) {\n+            return format((BigDecimal) number, StringBufFactory.of(toAppendTo), fieldPosition).asStringBuffer();\n+        } else if (number instanceof BigInteger) {\n+            return format((BigInteger) number, StringBufFactory.of(toAppendTo), fieldPosition).asStringBuffer();\n+        } else if (number instanceof Number) {\n+            return format(((Number) number).doubleValue(), toAppendTo, fieldPosition);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot format \"\n+                    + number.getClass().getName() + \" as a number\");\n+        }\n+    }\n+\n+    @Override\n+    StringBuf format(Object number,\n+                     StringBuf toAppendTo,\n+                     FieldPosition fieldPosition) {\n+\n+        if (number == null) {\n+            throw new IllegalArgumentException(\"Cannot format null as a number\");\n+        }\n+\n+        if (number instanceof Long || number instanceof Integer\n+                    || number instanceof Short || number instanceof Byte\n+                    || number instanceof AtomicInteger\n+                    || number instanceof AtomicLong\n+                    || (number instanceof BigInteger\n+                                && ((BigInteger) number).bitLength() < 64)) {\n+            return format(((Number) number).longValue(), toAppendTo,\n+                    fieldPosition);\n@@ -563,1 +592,1 @@\n-                    + number.getClass().getName() + \" as a number\");\n+                                                       + number.getClass().getName() + \" as a number\");\n@@ -594,0 +623,9 @@\n+        fieldPosition.setBeginIndex(0);\n+        fieldPosition.setEndIndex(0);\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate()).asStringBuffer();\n+    }\n+\n+    @Override\n+    StringBuf format(double number, StringBuf result,\n+                     FieldPosition fieldPosition) {\n+\n@@ -599,1 +637,1 @@\n-    private StringBuffer format(double number, StringBuffer result,\n+    private StringBuf format(double number, StringBuf result,\n@@ -684,0 +722,9 @@\n+        fieldPosition.setBeginIndex(0);\n+        fieldPosition.setEndIndex(0);\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate()).asStringBuffer();\n+    }\n+\n+    @Override\n+    StringBuf format(long number, StringBuf result,\n+                     FieldPosition fieldPosition) {\n+\n@@ -689,1 +736,1 @@\n-    private StringBuffer format(long number, StringBuffer result, FieldDelegate delegate) {\n+    private StringBuf format(long number, StringBuf result, FieldDelegate delegate) {\n@@ -760,1 +807,1 @@\n-     * @return        the {@code StringBuffer} passed in as {@code result}\n+     * @return        the {@code StringBuf} passed in as {@code result}\n@@ -767,2 +814,2 @@\n-    private StringBuffer format(BigDecimal number, StringBuffer result,\n-            FieldPosition fieldPosition) {\n+    private StringBuf format(BigDecimal number, StringBuf result,\n+                             FieldPosition fieldPosition) {\n@@ -776,1 +823,1 @@\n-    private StringBuffer format(BigDecimal number, StringBuffer result,\n+    private StringBuf format(BigDecimal number, StringBuf result,\n@@ -846,1 +893,1 @@\n-     * @return        the {@code StringBuffer} passed in as {@code result}\n+     * @return        the {@code StringBuf} passed in as {@code result}\n@@ -853,2 +900,2 @@\n-    private StringBuffer format(BigInteger number, StringBuffer result,\n-            FieldPosition fieldPosition) {\n+    private StringBuf format(BigInteger number, StringBuf result,\n+                             FieldPosition fieldPosition) {\n@@ -862,1 +909,1 @@\n-    private StringBuffer format(BigInteger number, StringBuffer result,\n+    private StringBuf format(BigInteger number, StringBuf result,\n@@ -939,1 +986,1 @@\n-    private void appendPrefix(StringBuffer result, String prefix,\n+    private void appendPrefix(StringBuf result, String prefix,\n@@ -955,1 +1002,1 @@\n-    private void appendSuffix(StringBuffer result, String suffix,\n+    private void appendSuffix(StringBuf result, String suffix,\n@@ -971,1 +1018,1 @@\n-    private void append(StringBuffer result, String string,\n+    private void append(StringBuf result, String string,\n@@ -1137,1 +1184,1 @@\n-        StringBuffer sb = new StringBuffer();\n+        StringBuf sb = StringBufFactory.of();\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":62,"deletions":15,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -349,0 +349,13 @@\n+    @Override\n+    final StringBuf format(Object obj, StringBuf toAppendTo,\n+                           FieldPosition fieldPosition) {\n+        if (obj instanceof Date) {\n+            return format((Date) obj, toAppendTo, fieldPosition);\n+        } else if (obj instanceof Number) {\n+            return format(new Date(((Number) obj).longValue()),\n+                    toAppendTo, fieldPosition);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot format given Object as a Date\");\n+        }\n+    }\n+\n@@ -374,0 +387,5 @@\n+    StringBuf format(Date date, StringBuf toAppendTo,\n+                     FieldPosition fieldPosition) {\n+        throw new UnsupportedOperationException(\"Subclasses should override this method\");\n+    }\n+\n@@ -382,2 +400,8 @@\n-        return format(date, new StringBuffer(),\n-                      DontCareFieldPosition.INSTANCE).toString();\n+        if (\"java.text\".equals(getClass().getPackageName())\n+                    && \"java.text\".equals(numberFormat.getClass().getPackageName())) {\n+            return format(date, StringBufFactory.of(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        } else {\n+            return format(date, new StringBuffer(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/text\/DateFormat.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -559,1 +559,1 @@\n-            return format((BigDecimal)number, toAppendTo, pos);\n+            return format((BigDecimal)number, StringBufFactory.of(toAppendTo), pos).asStringBuffer();\n@@ -561,1 +561,1 @@\n-            return format((BigInteger)number, toAppendTo, pos);\n+            return format((BigInteger)number, StringBufFactory.of(toAppendTo), pos).asStringBuffer();\n@@ -569,0 +569,22 @@\n+    @Override\n+    final StringBuf format(Object number,\n+                           StringBuf toAppendTo,\n+                           FieldPosition pos) {\n+        if (number instanceof Long || number instanceof Integer ||\n+                    number instanceof Short || number instanceof Byte ||\n+                    number instanceof AtomicInteger ||\n+                    number instanceof AtomicLong ||\n+                    (number instanceof BigInteger &&\n+                             ((BigInteger) number).bitLength() < 64)) {\n+            return format(((Number) number).longValue(), toAppendTo, pos);\n+        } else if (number instanceof BigDecimal) {\n+            return format((BigDecimal) number, toAppendTo, pos);\n+        } else if (number instanceof BigInteger) {\n+            return format((BigInteger) number, toAppendTo, pos);\n+        } else if (number instanceof Number) {\n+            return format(((Number) number).doubleValue(), toAppendTo, pos);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot format given Object as a Number\");\n+        }\n+    }\n+\n@@ -591,0 +613,6 @@\n+        return format(number, StringBufFactory.of(result), fieldPosition).asStringBuffer();\n+    }\n+\n+    @Override\n+    StringBuf format(double number, StringBuf result,\n+                     FieldPosition fieldPosition) {\n@@ -622,2 +650,2 @@\n-    StringBuffer format(double number, StringBuffer result,\n-                                FieldDelegate delegate) {\n+    StringBuf format(double number, StringBuf result,\n+                     FieldDelegate delegate) {\n@@ -669,1 +697,1 @@\n-    boolean handleNaN(double number, StringBuffer result,\n+    boolean handleNaN(double number, StringBuf result,\n@@ -694,1 +722,1 @@\n-    boolean handleInfinity(double number, StringBuffer result,\n+    boolean handleInfinity(double number, StringBuf result,\n@@ -723,1 +751,1 @@\n-    StringBuffer doubleSubformat(double number, StringBuffer result,\n+    StringBuf doubleSubformat(double number, StringBuf result,\n@@ -764,0 +792,8 @@\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate()).asStringBuffer();\n+    }\n+\n+    StringBuf format(long number, StringBuf result,\n+                     FieldPosition fieldPosition) {\n+        fieldPosition.setBeginIndex(0);\n+        fieldPosition.setEndIndex(0);\n+\n@@ -777,2 +813,2 @@\n-    StringBuffer format(long number, StringBuffer result,\n-                               FieldDelegate delegate) {\n+    StringBuf format(long number, StringBuf result,\n+                     FieldDelegate delegate) {\n@@ -852,2 +888,2 @@\n-    private StringBuffer format(BigDecimal number, StringBuffer result,\n-                                FieldPosition fieldPosition) {\n+    private StringBuf format(BigDecimal number, StringBuf result,\n+                             FieldPosition fieldPosition) {\n@@ -868,2 +904,2 @@\n-    StringBuffer format(BigDecimal number, StringBuffer result,\n-                                FieldDelegate delegate) {\n+    StringBuf format(BigDecimal number, StringBuf result,\n+                     FieldDelegate delegate) {\n@@ -911,2 +947,2 @@\n-    private StringBuffer format(BigInteger number, StringBuffer result,\n-                               FieldPosition fieldPosition) {\n+    private StringBuf format(BigInteger number, StringBuf result,\n+                             FieldPosition fieldPosition) {\n@@ -929,2 +965,2 @@\n-    StringBuffer format(BigInteger number, StringBuffer result,\n-                               FieldDelegate delegate, boolean formatLong) {\n+    StringBuf format(BigInteger number, StringBuf result,\n+                     FieldDelegate delegate, boolean formatLong) {\n@@ -989,1 +1025,1 @@\n-        StringBuffer sb = new StringBuffer();\n+        StringBuf sb = StringBufFactory.of();\n@@ -1782,1 +1818,1 @@\n-    private StringBuffer subformat(StringBuffer result, FieldDelegate delegate,\n+    private StringBuf subformat(StringBuf result, FieldDelegate delegate,\n@@ -1824,1 +1860,1 @@\n-    void subformatNumber(StringBuffer result, FieldDelegate delegate,\n+    void subformatNumber(StringBuf result, FieldDelegate delegate,\n@@ -2111,1 +2147,1 @@\n-    private void append(StringBuffer result, String string,\n+    private void append(StringBuf result, String string,\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":57,"deletions":21,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-                              int end, StringBuffer buffer) {\n+                              int end, Format.StringBuf buffer) {\n@@ -42,1 +42,1 @@\n-                              int start, int end, StringBuffer buffer) {\n+                              int start, int end, Format.StringBuf buffer) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/DontCareFieldPosition.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -293,1 +293,1 @@\n-                              int end, StringBuffer buffer) {\n+                              int end, Format.StringBuf buffer) {\n@@ -302,1 +302,1 @@\n-                              int start, int end, StringBuffer buffer) {\n+                              int start, int end, Format.StringBuf buffer) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/FieldPosition.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,1 +151,2 @@\n-     * Formats an object to produce a string. This is equivalent to\n+     * Formats an object to produce a string.\n+     * This method returns a string that would be equal to the string returned by\n@@ -163,1 +164,5 @@\n-        return format(obj, new StringBuffer(), new FieldPosition(0)).toString();\n+        if (\"java.text\".equals(getClass().getPackageName())) {\n+            return format(obj, StringBufFactory.of(), new FieldPosition(0)).toString();\n+        } else {\n+            return format(obj, new StringBuffer(), new FieldPosition(0)).toString();\n+        }\n@@ -188,0 +193,6 @@\n+    StringBuf format(Object obj,\n+                     StringBuf toAppendTo,\n+                     FieldPosition pos) {\n+        throw new UnsupportedOperationException(\"Subclasses should override this method\");\n+    }\n+\n@@ -397,1 +408,1 @@\n-                              int end, StringBuffer buffer);\n+                              int end, StringBuf buffer);\n@@ -411,1 +422,33 @@\n-                              int start, int end, StringBuffer buffer);\n+                              int start, int end, StringBuf buffer);\n+    }\n+\n+    \/**\n+     * StringBuf is the minimal common interface of {@code StringBuffer} and {@code StringBuilder}.\n+     * It is used by the various {@code Format} implementations as the internal string buffer.\n+     *\/\n+    sealed interface StringBuf\n+            permits StringBufFactory.StringBufferImpl, StringBufFactory.StringBuilderImpl {\n+\n+        int length();\n+\n+        String substring(int start, int end);\n+\n+        String substring(int start);\n+\n+        StringBuf append(char c);\n+\n+        StringBuf append(String str);\n+\n+        StringBuf append(int i);\n+\n+        StringBuf append(char[] str, int offset, int len);\n+\n+        StringBuf append(CharSequence s, int start, int end);\n+\n+        StringBuf append(StringBuffer sb);\n+\n+        boolean isProxyStringBuilder();\n+\n+        StringBuffer asStringBuffer();\n+\n+        StringBuilder asStringBuilder();\n","filename":"src\/java.base\/share\/classes\/java\/text\/Format.java","additions":48,"deletions":5,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -359,1 +359,1 @@\n-        return format(input, new StringBuffer(),\n+        return format(input, StringBufFactory.of(),\n@@ -384,0 +384,12 @@\n+        return format(obj, StringBufFactory.of(toAppendTo)).asStringBuffer();\n+    }\n+\n+    @Override\n+    StringBuf format(Object obj, StringBuf toAppendTo, FieldPosition pos) {\n+        Objects.requireNonNull(obj);\n+        Objects.requireNonNull(toAppendTo);\n+\n+        return format(obj, toAppendTo);\n+    }\n+\n+    private StringBuf format(Object obj, StringBuf toAppendTo) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/ListFormat.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1030,1 +1030,1 @@\n-        return subformat(arguments, result, pos, null);\n+        return subformat(arguments, StringBufFactory.of(result), pos, null).asStringBuffer();\n@@ -1035,1 +1035,2 @@\n-     * to format the given arguments. This is equivalent to\n+     * to format the given arguments.\n+     * This method returns a string that would be equal to the string returned by\n@@ -1079,0 +1080,6 @@\n+        return subformat((Object[]) arguments, StringBufFactory.of(result), pos, null).asStringBuffer();\n+    }\n+\n+    @Override\n+    final StringBuf format(Object arguments, StringBuf result,\n+                           FieldPosition pos) {\n@@ -1119,1 +1126,1 @@\n-        StringBuffer result = new StringBuffer();\n+        StringBuf result = StringBufFactory.of();\n@@ -1475,1 +1482,1 @@\n-    private StringBuffer subformat(Object[] arguments, StringBuffer result,\n+    private StringBuf subformat(Object[] arguments, StringBuf result,\n@@ -1585,1 +1592,1 @@\n-     * {@code iterator} to the StringBuffer {@code result}.\n+     * {@code iterator} to the StringBuf {@code result}.\n@@ -1587,1 +1594,1 @@\n-    private void append(StringBuffer result, CharacterIterator iterator) {\n+    private void append(StringBuf result, CharacterIterator iterator) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/MessageFormat.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -318,0 +318,17 @@\n+    @Override\n+    StringBuf format(Object number,\n+                     StringBuf toAppendTo,\n+                     FieldPosition pos) {\n+        if (number instanceof Long || number instanceof Integer ||\n+                    number instanceof Short || number instanceof Byte ||\n+                    number instanceof AtomicInteger || number instanceof AtomicLong ||\n+                    (number instanceof BigInteger &&\n+                             ((BigInteger) number).bitLength() < 64)) {\n+            return format(((Number) number).longValue(), toAppendTo, pos);\n+        } else if (number instanceof Number) {\n+            return format(((Number) number).doubleValue(), toAppendTo, pos);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot format given Object as a Number\");\n+        }\n+    }\n+\n@@ -350,2 +367,7 @@\n-        return format(number, new StringBuffer(),\n-                      DontCareFieldPosition.INSTANCE).toString();\n+        if (\"java.text\".equals(getClass().getPackageName())) {\n+            return format(number, StringBufFactory.of(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        } else {\n+            return format(number, new StringBuffer(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        }\n@@ -370,2 +392,7 @@\n-        return format(number, new StringBuffer(),\n-                      DontCareFieldPosition.INSTANCE).toString();\n+        if (\"java.text\".equals(getClass().getPackageName())) {\n+            return format(number, StringBufFactory.of(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        } else {\n+            return format(number, new StringBuffer(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        }\n@@ -397,0 +424,6 @@\n+    StringBuf format(double number,\n+                     StringBuf toAppendTo,\n+                     FieldPosition pos) {\n+        throw new UnsupportedOperationException(\"Subclasses should override this method\");\n+    }\n+\n@@ -420,0 +453,6 @@\n+    StringBuf format(long number,\n+                     StringBuf toAppendTo,\n+                     FieldPosition pos) {\n+        throw new UnsupportedOperationException(\"Subclasses should override this method\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":43,"deletions":4,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -971,0 +971,7 @@\n+        return format(date, StringBufFactory.of(toAppendTo), pos.getFieldDelegate()).asStringBuffer();\n+    }\n+\n+    @Override\n+    final StringBuf format(Date date, StringBuf toAppendTo,\n+                           FieldPosition pos) {\n+        pos.beginIndex = pos.endIndex = 0;\n@@ -975,1 +982,1 @@\n-    private StringBuffer format(Date date, StringBuffer toAppendTo,\n+    private StringBuf format(Date date, StringBuf toAppendTo,\n@@ -1027,1 +1034,1 @@\n-        StringBuffer sb = new StringBuffer();\n+        StringBuf sb = StringBufFactory.of();\n@@ -1133,1 +1140,1 @@\n-                           FieldDelegate delegate, StringBuffer buffer,\n+                           FieldDelegate delegate, StringBuf buffer,\n@@ -1323,1 +1330,5 @@\n-            CalendarUtils.sprintf0d(buffer, num, width);\n+            if (buffer.isProxyStringBuilder()) {\n+                CalendarUtils.sprintf0d(buffer.asStringBuilder(), num, width);\n+            } else {\n+                CalendarUtils.sprintf0d(buffer.asStringBuffer(), num, width);\n+            }\n@@ -1343,1 +1354,5 @@\n-            CalendarUtils.sprintf0d(buffer, value \/ 60, 2);\n+            if (buffer.isProxyStringBuilder()) {\n+                CalendarUtils.sprintf0d(buffer.asStringBuilder(), value \/ 60, 2);\n+            } else {\n+                CalendarUtils.sprintf0d(buffer.asStringBuffer(), value \/ 60, 2);\n+            }\n@@ -1351,1 +1366,5 @@\n-            CalendarUtils.sprintf0d(buffer, value % 60, 2);\n+            if (buffer.isProxyStringBuilder()) {\n+                CalendarUtils.sprintf0d(buffer.asStringBuilder(), value % 60, 2);\n+            } else {\n+                CalendarUtils.sprintf0d(buffer.asStringBuffer(), value % 60, 2);\n+            }\n@@ -1385,1 +1404,1 @@\n-    private void zeroPaddingNumber(int value, int minDigits, int maxDigits, StringBuffer buffer)\n+    private void zeroPaddingNumber(int value, int minDigits, int maxDigits, StringBuf buffer)\n@@ -1428,1 +1447,11 @@\n-        numberFormat.format((long)value, buffer, DontCareFieldPosition.INSTANCE);\n+        if (buffer.isProxyStringBuilder()) {\n+            \/\/User can set numberFormat with a user-defined NumberFormat which\n+            \/\/not override format(long, StringBuf, FieldPosition).\n+            if (\"java.text\".equals(numberFormat.getClass().getPackageName())) {\n+                numberFormat.format((long) value, buffer, DontCareFieldPosition.INSTANCE);\n+            } else {\n+                buffer.append(numberFormat.format((long) value, new StringBuffer(), DontCareFieldPosition.INSTANCE));\n+            }\n+        } else {\n+            numberFormat.format((long) value, buffer.asStringBuffer(), DontCareFieldPosition.INSTANCE);\n+        }\n@@ -2568,1 +2597,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/text\/SimpleDateFormat.java","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.text;\n+\n+import java.text.Format.StringBuf;\n+\n+\/**\n+ * {@code StringBufFactory} creates implementations of {@code Format.StringBuf},\n+ * which is an interface with the minimum overlap required to support {@code StringBuffer}\n+ * and {@code StringBuilder} in {@code Format}. This allows for {@code StringBuilder} to be used\n+ * in place of {@code StringBuffer} to provide performance benefits for JDK internal\n+ * {@code Format} subclasses.\n+ *\/\n+final class StringBufFactory {\n+\n+    private StringBufFactory() {\n+    }\n+\n+    static StringBuf of(StringBuffer sb) {\n+        return new StringBufferImpl(sb);\n+    }\n+\n+    static StringBuf of(StringBuilder sb) {\n+        return new StringBuilderImpl(sb);\n+    }\n+\n+    static StringBuf of() {\n+        return new StringBuilderImpl();\n+    }\n+\n+    final static class StringBufferImpl implements StringBuf {\n+        private final StringBuffer sb;\n+\n+        StringBufferImpl(StringBuffer sb) {\n+            this.sb = sb;\n+        }\n+\n+        @Override\n+        public int length() {\n+            return sb.length();\n+        }\n+\n+        @Override\n+        public String substring(int start, int end) {\n+            return sb.substring(start, end);\n+        }\n+\n+        @Override\n+        public String substring(int start) {\n+            return sb.substring(start);\n+        }\n+\n+        @Override\n+        public StringBuf append(char c) {\n+            sb.append(c);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(String str) {\n+            sb.append(str);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(int i) {\n+            sb.append(i);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(char[] str, int offset, int len) {\n+            sb.append(str, offset, len);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(CharSequence s, int start, int end) {\n+            sb.append(s, start, end);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(StringBuffer asb) {\n+            sb.append(asb);\n+            return this;\n+        }\n+\n+        @Override\n+        public boolean isProxyStringBuilder() {\n+            return false;\n+        }\n+\n+        @Override\n+        public StringBuffer asStringBuffer() {\n+            return sb;\n+        }\n+\n+        @Override\n+        public StringBuilder asStringBuilder() {\n+            throw new AssertionError(\"Can't cast StringBuffer to StringBuilder\");\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return sb.toString();\n+        }\n+    }\n+\n+    final static class StringBuilderImpl implements StringBuf {\n+        private final StringBuilder sb;\n+\n+        StringBuilderImpl(StringBuilder sb) {\n+            this.sb = sb;\n+        }\n+\n+        StringBuilderImpl() {\n+            this.sb = new StringBuilder();\n+        }\n+\n+        @Override\n+        public int length() {\n+            return sb.length();\n+        }\n+\n+        @Override\n+        public String substring(int start, int end) {\n+            return sb.substring(start, end);\n+        }\n+\n+        @Override\n+        public String substring(int start) {\n+            return sb.substring(start);\n+        }\n+\n+        @Override\n+        public StringBuf append(char c) {\n+            sb.append(c);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(String str) {\n+            sb.append(str);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(int i) {\n+            sb.append(i);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(char[] str, int offset, int len) {\n+            sb.append(str, offset, len);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(CharSequence s, int start, int end) {\n+            sb.append(s, start, end);\n+            return this;\n+        }\n+\n+        @Override\n+        public StringBuf append(StringBuffer asb) {\n+            sb.append(asb);\n+            return this;\n+        }\n+\n+\n+        @Override\n+        public boolean isProxyStringBuilder() {\n+            return true;\n+        }\n+\n+        @Override\n+        public StringBuffer asStringBuffer() {\n+            throw new AssertionError(\"Can't cast StringBuilder to StringBuffer\");\n+        }\n+\n+        @Override\n+        public StringBuilder asStringBuilder() {\n+            return sb;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return sb.toString();\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/text\/StringBufFactory.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.text;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.text.DateFormat;\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+@State(Scope.Benchmark)\n+public class DateFormatterBench {\n+\n+    private Date date;\n+\n+    private Object objDate;\n+\n+    @Setup\n+    public void setup() {\n+        date = new Date();\n+        objDate = new Date();\n+    }\n+\n+    private DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.FULL, Locale.ENGLISH);\n+\n+    @Benchmark\n+    public String testFormatDate() {\n+        return dateFormat.format(date);\n+    }\n+\n+    @Benchmark\n+    public String testFormatObject() {\n+        return dateFormat.format(objDate);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        Options opts = new OptionsBuilder().include(DateFormatterBench.class.getSimpleName()).shouldDoGC(true).build();\n+        new Runner(opts).run();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/text\/DateFormatterBench.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.text;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.text.ListFormat;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+@State(Scope.Benchmark)\n+public class ListFormatterBench {\n+\n+    private List<String> data;\n+\n+    @Setup\n+    public void setup() {\n+        data = List.of(\"foo\", \"bar\", \"baz\", \"qux\", \"quux\", \"quuz\");\n+    }\n+\n+    private ListFormat listFormat = ListFormat.getInstance();\n+\n+    @Benchmark\n+    public String testListFormat() {\n+        return listFormat.format(data);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        Options opts = new OptionsBuilder().include(ListFormatterBench.class.getSimpleName()).shouldDoGC(true).build();\n+        new Runner(opts).run();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/text\/ListFormatterBench.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.text;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.text.MessageFormat;\n+import java.util.Locale;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+@State(Scope.Benchmark)\n+public class MessageFormatterBench {\n+\n+    private Object[][] values;\n+\n+    @Setup\n+    public void setup() {\n+        values = new Object[][]{\n+                new Object[]{Integer.valueOf(13), \"MyDisk1\"},\n+                new Object[]{Float.valueOf(25.6f), \"MyDisk2\"},\n+                new Object[]{Double.valueOf(123.89), \"MyDisk3\"},\n+                new Object[]{Long.valueOf(1234567), \"MyDisk4\"},\n+        };\n+    }\n+\n+    private MessageFormat messageFormat = new MessageFormat(\"There is {0} GB of free space on the {1}.\", Locale.ENGLISH);\n+\n+    @Benchmark\n+    @OperationsPerInvocation(4)\n+    public void testMessageFormat(final Blackhole bh) {\n+        for (Object[] value : values) {\n+            bh.consume(messageFormat.format(value));\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        Options opts = new OptionsBuilder().include(MessageFormatterBench.class.getSimpleName()).shouldDoGC(true).build();\n+        new Runner(opts).run();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/text\/MessageFormatterBench.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"}]}