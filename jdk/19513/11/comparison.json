{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-                          StringBuffer buffer) {\n+                          Format.StringBuf buffer) {\n@@ -96,1 +96,1 @@\n-                          int start, int end, StringBuffer buffer) {\n+                          int start, int end, Format.StringBuf buffer) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/CharacterIteratorFieldDelegate.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -517,1 +517,7 @@\n-        return format((double)number, toAppendTo, status);\n+        return format((double) number, StringBufFactory.of(toAppendTo), status).asStringBuffer();\n+    }\n+\n+    @Override\n+    StringBuilder format(long number, StringBuilder toAppendTo,\n+                         FieldPosition status) {\n+        return format((double) number, StringBufFactory.of(toAppendTo), status).asStringBuilder();\n@@ -534,0 +540,12 @@\n+        return format(number, StringBufFactory.of(toAppendTo), status).asStringBuffer();\n+    }\n+\n+    @Override\n+    StringBuilder format(double number,\n+                         StringBuilder toAppendTo,\n+                         FieldPosition status) {\n+        return format(number, StringBufFactory.of(toAppendTo), status).asStringBuilder();\n+    }\n+\n+    private StringBuf format(double number, StringBuf toAppendTo,\n+                         FieldPosition status) {\n@@ -728,0 +746,5 @@\n+    @Override\n+    boolean isInternalSubclass() {\n+        return true;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/ChoiceFormat.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -567,0 +567,29 @@\n+    @Override\n+    StringBuilder format(Object number,\n+                                     StringBuilder toAppendTo,\n+                                     FieldPosition fieldPosition) {\n+\n+        if (number == null) {\n+            throw new IllegalArgumentException(\"Cannot format null as a number\");\n+        }\n+\n+        if (number instanceof Long || number instanceof Integer\n+                    || number instanceof Short || number instanceof Byte\n+                    || number instanceof AtomicInteger\n+                    || number instanceof AtomicLong\n+                    || (number instanceof BigInteger\n+                                && ((BigInteger) number).bitLength() < 64)) {\n+            return format(((Number) number).longValue(), toAppendTo,\n+                    fieldPosition);\n+        } else if (number instanceof BigDecimal) {\n+            return format((BigDecimal) number, toAppendTo, fieldPosition);\n+        } else if (number instanceof BigInteger) {\n+            return format((BigInteger) number, toAppendTo, fieldPosition);\n+        } else if (number instanceof Number) {\n+            return format(((Number) number).doubleValue(), toAppendTo, fieldPosition);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot format \"\n+                                                       + number.getClass().getName() + \" as a number\");\n+        }\n+    }\n+\n@@ -596,1 +625,1 @@\n-        return format(number, result, fieldPosition.getFieldDelegate());\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate()).asStringBuffer();\n@@ -599,1 +628,9 @@\n-    private StringBuffer format(double number, StringBuffer result,\n+    @Override\n+    StringBuilder format(double number, StringBuilder result,\n+                         FieldPosition fieldPosition) {\n+        fieldPosition.setBeginIndex(0);\n+        fieldPosition.setEndIndex(0);\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate()).asStringBuilder();\n+    }\n+\n+    private StringBuf format(double number, StringBuf result,\n@@ -686,1 +723,1 @@\n-        return format(number, result, fieldPosition.getFieldDelegate());\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate()).asStringBuffer();\n@@ -689,1 +726,9 @@\n-    private StringBuffer format(long number, StringBuffer result, FieldDelegate delegate) {\n+    @Override\n+    StringBuilder format(long number, StringBuilder result,\n+                         FieldPosition fieldPosition) {\n+        fieldPosition.setBeginIndex(0);\n+        fieldPosition.setEndIndex(0);\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate()).asStringBuilder();\n+    }\n+\n+    private StringBuf format(long number, StringBuf result, FieldDelegate delegate) {\n@@ -773,1 +818,1 @@\n-        return format(number, result, fieldPosition.getFieldDelegate());\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate()).asStringBuffer();\n@@ -776,1 +821,9 @@\n-    private StringBuffer format(BigDecimal number, StringBuffer result,\n+    private StringBuilder format(BigDecimal number, StringBuilder result,\n+                                 FieldPosition fieldPosition) {\n+        Objects.requireNonNull(number);\n+        fieldPosition.setBeginIndex(0);\n+        fieldPosition.setEndIndex(0);\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate()).asStringBuilder();\n+    }\n+\n+    private StringBuf format(BigDecimal number, StringBuf result,\n@@ -859,1 +912,1 @@\n-        return format(number, result, fieldPosition.getFieldDelegate(), false);\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate(), false).asStringBuffer();\n@@ -862,1 +915,9 @@\n-    private StringBuffer format(BigInteger number, StringBuffer result,\n+    private StringBuilder format(BigInteger number, StringBuilder result,\n+                                 FieldPosition fieldPosition) {\n+        Objects.requireNonNull(number);\n+        fieldPosition.setBeginIndex(0);\n+        fieldPosition.setEndIndex(0);\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate(), false).asStringBuilder();\n+    }\n+\n+    private StringBuf format(BigInteger number, StringBuf result,\n@@ -939,1 +1000,1 @@\n-    private void appendPrefix(StringBuffer result, String prefix,\n+    private void appendPrefix(StringBuf result, String prefix,\n@@ -955,1 +1016,1 @@\n-    private void appendSuffix(StringBuffer result, String suffix,\n+    private void appendSuffix(StringBuf result, String suffix,\n@@ -971,1 +1032,1 @@\n-    private void append(StringBuffer result, String string,\n+    private void append(StringBuf result, String string,\n@@ -1140,1 +1201,1 @@\n-            format(((Number) obj).doubleValue(), sb, delegate);\n+            format(((Number) obj).doubleValue(), StringBufFactory.of(sb), delegate);\n@@ -1144,1 +1205,1 @@\n-            format(((Number) obj).longValue(), sb, delegate);\n+            format(((Number) obj).longValue(), StringBufFactory.of(sb), delegate);\n@@ -1146,1 +1207,1 @@\n-            format((BigDecimal) obj, sb, delegate);\n+            format((BigDecimal) obj, StringBufFactory.of(sb), delegate);\n@@ -1148,1 +1209,1 @@\n-            format((BigInteger) obj, sb, delegate, false);\n+            format((BigInteger) obj, StringBufFactory.of(sb), delegate, false);\n@@ -2524,0 +2585,5 @@\n+    @Override\n+    boolean isInternalSubclass() {\n+        return true;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":81,"deletions":15,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -349,0 +349,13 @@\n+    @Override\n+    final StringBuilder format(Object obj, StringBuilder toAppendTo,\n+                               FieldPosition fieldPosition) {\n+        if (obj instanceof Date) {\n+            return format((Date) obj, toAppendTo, fieldPosition);\n+        } else if (obj instanceof Number) {\n+            return format(new Date(((Number) obj).longValue()),\n+                    toAppendTo, fieldPosition);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot format given Object as a Date\");\n+        }\n+    }\n+\n@@ -374,0 +387,5 @@\n+    StringBuilder format(Date date, StringBuilder toAppendTo,\n+                         FieldPosition fieldPosition) {\n+        throw new UnsupportedOperationException(\"Subclasses should override this method\");\n+    }\n+\n@@ -382,2 +400,7 @@\n-        return format(date, new StringBuffer(),\n-                      DontCareFieldPosition.INSTANCE).toString();\n+        if (isInternalSubclass() && numberFormat.isInternalSubclass()) {\n+            return format(date, new StringBuilder(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        } else {\n+            return format(date, new StringBuffer(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/text\/DateFormat.java","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -569,0 +569,22 @@\n+    @Override\n+    final StringBuilder format(Object number,\n+                               StringBuilder toAppendTo,\n+                               FieldPosition pos) {\n+        if (number instanceof Long || number instanceof Integer ||\n+                    number instanceof Short || number instanceof Byte ||\n+                    number instanceof AtomicInteger ||\n+                    number instanceof AtomicLong ||\n+                    (number instanceof BigInteger &&\n+                             ((BigInteger) number).bitLength() < 64)) {\n+            return format(((Number) number).longValue(), toAppendTo, pos);\n+        } else if (number instanceof BigDecimal) {\n+            return format((BigDecimal) number, toAppendTo, pos);\n+        } else if (number instanceof BigInteger) {\n+            return format((BigInteger) number, toAppendTo, pos);\n+        } else if (number instanceof Number) {\n+            return format(((Number) number).doubleValue(), toAppendTo, pos);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot format given Object as a Number\");\n+        }\n+    }\n+\n@@ -591,0 +613,11 @@\n+        return format(number, StringBufFactory.of(result), fieldPosition).asStringBuffer();\n+    }\n+\n+    @Override\n+    StringBuilder format(double number, StringBuilder result,\n+                         FieldPosition fieldPosition) {\n+        return format(number, StringBufFactory.of(result), fieldPosition).asStringBuilder();\n+    }\n+\n+    private StringBuf format(double number, StringBuf result,\n+                             FieldPosition fieldPosition) {\n@@ -622,2 +655,2 @@\n-    StringBuffer format(double number, StringBuffer result,\n-                                FieldDelegate delegate) {\n+    StringBuf format(double number, StringBuf result,\n+                     FieldDelegate delegate) {\n@@ -669,1 +702,1 @@\n-    boolean handleNaN(double number, StringBuffer result,\n+    boolean handleNaN(double number, StringBuf result,\n@@ -694,1 +727,1 @@\n-    boolean handleInfinity(double number, StringBuffer result,\n+    boolean handleInfinity(double number, StringBuf result,\n@@ -723,1 +756,1 @@\n-    StringBuffer doubleSubformat(double number, StringBuffer result,\n+    StringBuf doubleSubformat(double number, StringBuf result,\n@@ -764,1 +797,10 @@\n-        return format(number, result, fieldPosition.getFieldDelegate());\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate()).asStringBuffer();\n+    }\n+\n+    @Override\n+    StringBuilder format(long number, StringBuilder result,\n+                         FieldPosition fieldPosition) {\n+        fieldPosition.setBeginIndex(0);\n+        fieldPosition.setEndIndex(0);\n+\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate()).asStringBuilder();\n@@ -777,2 +819,2 @@\n-    StringBuffer format(long number, StringBuffer result,\n-                               FieldDelegate delegate) {\n+    StringBuf format(long number, StringBuf result,\n+                     FieldDelegate delegate) {\n@@ -856,1 +898,8 @@\n-        return format(number, result, fieldPosition.getFieldDelegate());\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate()).asStringBuffer();\n+    }\n+\n+    private StringBuilder format(BigDecimal number, StringBuilder result,\n+                                FieldPosition fieldPosition) {\n+        fieldPosition.setBeginIndex(0);\n+        fieldPosition.setEndIndex(0);\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate()).asStringBuilder();\n@@ -868,2 +917,2 @@\n-    StringBuffer format(BigDecimal number, StringBuffer result,\n-                                FieldDelegate delegate) {\n+    StringBuf format(BigDecimal number, StringBuf result,\n+                     FieldDelegate delegate) {\n@@ -916,1 +965,9 @@\n-        return format(number, result, fieldPosition.getFieldDelegate(), false);\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate(), false).asStringBuffer();\n+    }\n+\n+    private StringBuilder format(BigInteger number, StringBuilder result,\n+                                FieldPosition fieldPosition) {\n+        fieldPosition.setBeginIndex(0);\n+        fieldPosition.setEndIndex(0);\n+\n+        return format(number, StringBufFactory.of(result), fieldPosition.getFieldDelegate(), false).asStringBuilder();\n@@ -929,2 +986,2 @@\n-    StringBuffer format(BigInteger number, StringBuffer result,\n-                               FieldDelegate delegate, boolean formatLong) {\n+    StringBuf format(BigInteger number, StringBuf result,\n+                     FieldDelegate delegate, boolean formatLong) {\n@@ -992,1 +1049,1 @@\n-            format(((Number)obj).doubleValue(), sb, delegate);\n+            format(((Number)obj).doubleValue(), StringBufFactory.of(sb), delegate);\n@@ -996,1 +1053,1 @@\n-            format(((Number)obj).longValue(), sb, delegate);\n+            format(((Number)obj).longValue(), StringBufFactory.of(sb), delegate);\n@@ -998,1 +1055,1 @@\n-            format((BigDecimal)obj, sb, delegate);\n+            format((BigDecimal)obj, StringBufFactory.of(sb), delegate);\n@@ -1000,1 +1057,1 @@\n-            format((BigInteger)obj, sb, delegate, false);\n+            format((BigInteger)obj, StringBufFactory.of(sb), delegate, false);\n@@ -1782,1 +1839,1 @@\n-    private StringBuffer subformat(StringBuffer result, FieldDelegate delegate,\n+    private StringBuf subformat(StringBuf result, FieldDelegate delegate,\n@@ -1824,1 +1881,1 @@\n-    void subformatNumber(StringBuffer result, FieldDelegate delegate,\n+    void subformatNumber(StringBuf result, FieldDelegate delegate,\n@@ -2111,1 +2168,1 @@\n-    private void append(StringBuffer result, String string,\n+    private void append(StringBuf result, String string,\n@@ -4170,0 +4227,5 @@\n+    @Override\n+    boolean isInternalSubclass() {\n+        return true;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":83,"deletions":21,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-                              int end, StringBuffer buffer) {\n+                              int end, Format.StringBuf buffer) {\n@@ -42,1 +42,1 @@\n-                              int start, int end, StringBuffer buffer) {\n+                              int start, int end, Format.StringBuf buffer) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/DontCareFieldPosition.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -293,1 +293,1 @@\n-                              int end, StringBuffer buffer) {\n+                              int end, Format.StringBuf buffer) {\n@@ -302,1 +302,1 @@\n-                              int start, int end, StringBuffer buffer) {\n+                              int start, int end, Format.StringBuf buffer) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/FieldPosition.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,1 +163,5 @@\n-        return format(obj, new StringBuffer(), new FieldPosition(0)).toString();\n+        if (isInternalSubclass()) {\n+            return format(obj, new StringBuilder(), new FieldPosition(0)).toString();\n+        } else {\n+            return format(obj, new StringBuffer(), new FieldPosition(0)).toString();\n+        }\n@@ -188,0 +192,6 @@\n+    StringBuilder format(Object obj,\n+                         StringBuilder toAppendTo,\n+                         FieldPosition pos) {\n+        throw new UnsupportedOperationException(\"Subclasses should override this method\");\n+    }\n+\n@@ -397,1 +407,1 @@\n-                              int end, StringBuffer buffer);\n+                              int end, StringBuf buffer);\n@@ -411,1 +421,42 @@\n-                              int start, int end, StringBuffer buffer);\n+                              int start, int end, StringBuf buffer);\n+    }\n+\n+\n+    \/**\n+     * Used to distinguish JDK internal subclass and user-defined subclass\n+     * of {code Format}.\n+     *\n+     * @return {@code true}  if current class is a JDK internal subclass of {code Format};\n+     *         {@code false} otherwise\n+     *\/\n+    boolean isInternalSubclass() {\n+        return false;\n+    }\n+\n+    \/**\n+     * StringBuf is the minimal common interface of {code StringBuffer} and {code StringBuilder}.\n+     * It used by the various {code Format} implementations as the internal string buffer.\n+     *\/\n+    interface StringBuf {\n+\n+        int length();\n+\n+        String substring(int start, int end);\n+\n+        String substring(int start);\n+\n+        StringBuf append(char c);\n+\n+        StringBuf append(String str);\n+\n+        StringBuf append(int i);\n+\n+        StringBuf append(char[] str, int offset, int len);\n+\n+        StringBuf append(CharSequence s, int start, int end);\n+\n+        boolean isProxyStringBuilder();\n+\n+        StringBuffer asStringBuffer();\n+\n+        StringBuilder asStringBuilder();\n","filename":"src\/java.base\/share\/classes\/java\/text\/Format.java","additions":55,"deletions":4,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -359,2 +359,7 @@\n-        return format(input, new StringBuffer(),\n-                DontCareFieldPosition.INSTANCE).toString();\n+        if (isInternalSubclass()) {\n+            return format(input, new StringBuilder(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        } else {\n+            return format(input, new StringBuffer(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        }\n@@ -384,0 +389,12 @@\n+        return format(obj, StringBufFactory.of(toAppendTo), pos).asStringBuffer();\n+    }\n+\n+    @Override\n+    StringBuilder format(Object obj, StringBuilder toAppendTo, FieldPosition pos) {\n+        Objects.requireNonNull(obj);\n+        Objects.requireNonNull(toAppendTo);\n+\n+        return format(obj, StringBufFactory.of(toAppendTo), pos).asStringBuilder();\n+    }\n+\n+    private StringBuf format(Object obj, StringBuf toAppendTo, FieldPosition pos) {\n@@ -571,0 +588,5 @@\n+    @Override\n+    boolean isInternalSubclass() {\n+        return true;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/ListFormat.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1030,1 +1030,1 @@\n-        return subformat(arguments, result, pos, null);\n+        return subformat(arguments, StringBufFactory.of(result), pos, null).asStringBuffer();\n@@ -1079,0 +1079,11 @@\n+        return subformat((Object[]) arguments, StringBufFactory.of(result), pos, null).asStringBuffer();\n+    }\n+\n+    @Override\n+    final StringBuilder format(Object arguments, StringBuilder result,\n+                               FieldPosition pos) {\n+        return subformat((Object[]) arguments, StringBufFactory.of(result), pos, null).asStringBuilder();\n+    }\n+\n+    final StringBuf format(Object arguments, StringBuf result,\n+                           FieldPosition pos) {\n@@ -1119,1 +1130,1 @@\n-        StringBuffer result = new StringBuffer();\n+        StringBuilder result = new StringBuilder();\n@@ -1122,1 +1133,1 @@\n-        subformat((Object[]) arguments, result, null, iterators);\n+        subformat((Object[]) arguments, StringBufFactory.of(result), null, iterators);\n@@ -1475,1 +1486,1 @@\n-    private StringBuffer subformat(Object[] arguments, StringBuffer result,\n+    private StringBuf subformat(Object[] arguments, StringBuf result,\n@@ -1587,1 +1598,1 @@\n-    private void append(StringBuffer result, CharacterIterator iterator) {\n+    private void append(StringBuf result, CharacterIterator iterator) {\n@@ -2020,0 +2031,5 @@\n+\n+    @Override\n+    boolean isInternalSubclass() {\n+        return true;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/text\/MessageFormat.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -318,0 +318,16 @@\n+    StringBuilder format(Object number,\n+                         StringBuilder toAppendTo,\n+                         FieldPosition pos) {\n+        if (number instanceof Long || number instanceof Integer ||\n+                    number instanceof Short || number instanceof Byte ||\n+                    number instanceof AtomicInteger || number instanceof AtomicLong ||\n+                    (number instanceof BigInteger &&\n+                             ((BigInteger) number).bitLength() < 64)) {\n+            return format(((Number) number).longValue(), toAppendTo, pos);\n+        } else if (number instanceof Number) {\n+            return format(((Number) number).doubleValue(), toAppendTo, pos);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot format given Object as a Number\");\n+        }\n+    }\n+\n@@ -350,2 +366,7 @@\n-        return format(number, new StringBuffer(),\n-                      DontCareFieldPosition.INSTANCE).toString();\n+        if (isInternalSubclass()) {\n+            return format(number, new StringBuilder(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        } else {\n+            return format(number, new StringBuffer(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        }\n@@ -370,2 +391,7 @@\n-        return format(number, new StringBuffer(),\n-                      DontCareFieldPosition.INSTANCE).toString();\n+        if (isInternalSubclass()) {\n+            return format(number, new StringBuilder(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        } else {\n+            return format(number, new StringBuffer(),\n+                    DontCareFieldPosition.INSTANCE).toString();\n+        }\n@@ -397,0 +423,6 @@\n+    StringBuilder format(double number,\n+                         StringBuilder toAppendTo,\n+                         FieldPosition pos) {\n+        throw new UnsupportedOperationException(\"Subclasses should override this method\");\n+    }\n+\n@@ -420,0 +452,6 @@\n+    StringBuilder format(long number,\n+                         StringBuilder toAppendTo,\n+                         FieldPosition pos) {\n+        throw new UnsupportedOperationException(\"Subclasses should override this method\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":42,"deletions":4,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -971,1 +971,8 @@\n-        return format(date, toAppendTo, pos.getFieldDelegate());\n+        return format(date, StringBufFactory.of(toAppendTo), pos.getFieldDelegate()).asStringBuffer();\n+    }\n+\n+    @Override\n+    final StringBuilder format(Date date, StringBuilder toAppendTo,\n+                         FieldPosition pos) {\n+        pos.beginIndex = pos.endIndex = 0;\n+        return format(date, StringBufFactory.of(toAppendTo), pos.getFieldDelegate()).asStringBuilder();\n@@ -975,1 +982,1 @@\n-    private StringBuffer format(Date date, StringBuffer toAppendTo,\n+    private StringBuf format(Date date, StringBuf toAppendTo,\n@@ -1027,1 +1034,1 @@\n-        StringBuffer sb = new StringBuffer();\n+        StringBuilder sb = new StringBuilder();\n@@ -1032,1 +1039,1 @@\n-            format((Date)obj, sb, delegate);\n+            format((Date)obj, StringBufFactory.of(sb), delegate);\n@@ -1035,1 +1042,1 @@\n-            format(new Date(((Number)obj).longValue()), sb, delegate);\n+            format(new Date(((Number)obj).longValue()), StringBufFactory.of(sb), delegate);\n@@ -1133,1 +1140,1 @@\n-                           FieldDelegate delegate, StringBuffer buffer,\n+                           FieldDelegate delegate, StringBuf buffer,\n@@ -1323,1 +1330,5 @@\n-            CalendarUtils.sprintf0d(buffer, num, width);\n+            if (buffer.isProxyStringBuilder()) {\n+                CalendarUtils.sprintf0d(buffer.asStringBuilder(), num, width);\n+            } else {\n+                CalendarUtils.sprintf0d(buffer.asStringBuffer(), num, width);\n+            }\n@@ -1343,1 +1354,5 @@\n-            CalendarUtils.sprintf0d(buffer, value \/ 60, 2);\n+            if (buffer.isProxyStringBuilder()) {\n+                CalendarUtils.sprintf0d(buffer.asStringBuilder(), value \/ 60, 2);\n+            } else {\n+                CalendarUtils.sprintf0d(buffer.asStringBuffer(), value \/ 60, 2);\n+            }\n@@ -1351,1 +1366,5 @@\n-            CalendarUtils.sprintf0d(buffer, value % 60, 2);\n+            if (buffer.isProxyStringBuilder()) {\n+                CalendarUtils.sprintf0d(buffer.asStringBuilder(), value % 60, 2);\n+            } else {\n+                CalendarUtils.sprintf0d(buffer.asStringBuffer(), value % 60, 2);\n+            }\n@@ -1385,1 +1404,1 @@\n-    private void zeroPaddingNumber(int value, int minDigits, int maxDigits, StringBuffer buffer)\n+    private void zeroPaddingNumber(int value, int minDigits, int maxDigits, StringBuf buffer)\n@@ -1428,1 +1447,5 @@\n-        numberFormat.format((long)value, buffer, DontCareFieldPosition.INSTANCE);\n+        if (buffer.isProxyStringBuilder()) {\n+            numberFormat.format((long)value, buffer.asStringBuilder(), DontCareFieldPosition.INSTANCE);\n+        } else {\n+            numberFormat.format((long)value, buffer.asStringBuffer(), DontCareFieldPosition.INSTANCE);\n+        }\n@@ -2569,0 +2592,4 @@\n+    @Override\n+    boolean isInternalSubclass() {\n+        return true;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/text\/SimpleDateFormat.java","additions":38,"deletions":11,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.text;\n+\n+\/**\n+ * StringBufFactory create {code Format.StringBuf}'s implements that\n+ * backend with {code StringBuffer} and {code StringBuilder}.\n+ * It used by {code Format}'s implements to replace inner string\n+ * buffer from {code StringBuffer} to {code StringBuilder} to gain\n+ * a better performance.\n+ *\/\n+final class StringBufFactory {\n+\n+    static Format.StringBuf of(StringBuffer sb) {\n+        return new StringBufferImpl(sb);\n+    }\n+\n+    static Format.StringBuf of(StringBuilder sb) {\n+        return new StringBuilderImpl(sb);\n+    }\n+\n+    private static class StringBufferImpl implements Format.StringBuf {\n+        private final StringBuffer sb;\n+\n+        StringBufferImpl(StringBuffer sb) {\n+            this.sb = sb;\n+        }\n+\n+        @Override\n+        public int length() {\n+            return sb.length();\n+        }\n+\n+        @Override\n+        public String substring(int start, int end) {\n+            return sb.substring(start, end);\n+        }\n+\n+        @Override\n+        public String substring(int start) {\n+            return sb.substring(start);\n+        }\n+\n+        @Override\n+        public Format.StringBuf append(char c) {\n+            sb.append(c);\n+            return this;\n+        }\n+\n+        @Override\n+        public Format.StringBuf append(String str) {\n+            sb.append(str);\n+            return this;\n+        }\n+\n+        @Override\n+        public Format.StringBuf append(int i) {\n+            sb.append(i);\n+            return this;\n+        }\n+\n+        @Override\n+        public Format.StringBuf append(char[] str, int offset, int len) {\n+            sb.append(str, offset, len);\n+            return this;\n+        }\n+\n+        @Override\n+        public Format.StringBuf append(CharSequence s, int start, int end) {\n+            sb.append(s, start, end);\n+            return this;\n+        }\n+\n+        @Override\n+        public boolean isProxyStringBuilder() {\n+            return false;\n+        }\n+\n+        @Override\n+        public StringBuffer asStringBuffer() {\n+            return sb;\n+        }\n+\n+        @Override\n+        public StringBuilder asStringBuilder() {\n+            throw new AssertionError(\"Can't cast StringBuffer to StringBuilder\");\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return sb.toString();\n+        }\n+    }\n+\n+    private static class StringBuilderImpl implements Format.StringBuf {\n+        private final StringBuilder sb;\n+\n+        StringBuilderImpl(StringBuilder sb) {\n+            this.sb = sb;\n+        }\n+\n+        @Override\n+        public int length() {\n+            return sb.length();\n+        }\n+\n+        @Override\n+        public String substring(int start, int end) {\n+            return sb.substring(start, end);\n+        }\n+\n+        @Override\n+        public String substring(int start) {\n+            return sb.substring(start);\n+        }\n+\n+        @Override\n+        public Format.StringBuf append(char c) {\n+            sb.append(c);\n+            return this;\n+        }\n+\n+        @Override\n+        public Format.StringBuf append(String str) {\n+            sb.append(str);\n+            return this;\n+        }\n+\n+        @Override\n+        public Format.StringBuf append(int i) {\n+            sb.append(i);\n+            return this;\n+        }\n+\n+        @Override\n+        public Format.StringBuf append(char[] str, int offset, int len) {\n+            sb.append(str, offset, len);\n+            return this;\n+        }\n+\n+        @Override\n+        public Format.StringBuf append(CharSequence s, int start, int end) {\n+            sb.append(s, start, end);\n+            return this;\n+        }\n+\n+        @Override\n+        public boolean isProxyStringBuilder() {\n+            return true;\n+        }\n+\n+        @Override\n+        public StringBuffer asStringBuffer() {\n+            throw new AssertionError(\"Can't cast StringBuilder to StringBuffer\");\n+        }\n+\n+        @Override\n+        public StringBuilder asStringBuilder() {\n+            return sb;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return sb.toString();\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/text\/StringBufFactory.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"}]}