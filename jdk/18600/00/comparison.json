{"files":[{"patch":"@@ -0,0 +1,450 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @summary Test virtual threads with a synchronized native method and a native method\n+ *      that enter\/exits a monitor with JNI MonitorEnter\/MonitorExit\n+ * @requires vm.continuations\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run junit\/othervm SynchronizedNative\n+ *\/\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadPinner;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class SynchronizedNative {\n+    private static int initialParallelism;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        \/\/ need at least two carriers when main thread is a virtual thread\n+        if (Thread.currentThread().isVirtual()) {\n+            initialParallelism = VThreadRunner.ensureParallelism(2);\n+        }\n+        System.loadLibrary(\"SynchronizedNative\");\n+    }\n+\n+    @AfterAll\n+    static void finish() {\n+        \/\/ restore parallelism if needed\n+        if (initialParallelism > 0) {\n+            VThreadRunner.setParallelism(initialParallelism);\n+        }\n+    }\n+\n+    \/**\n+     * Test entering a monitor with a synchronized native method, no contention.\n+     *\/\n+    @Test\n+    void testEnter() throws Exception {\n+        Object lock = this;\n+        VThreadRunner.run(() -> {\n+            runWithSynchronizedNative(() -> {\n+                assertTrue(Thread.holdsLock(lock));\n+            });\n+            assertFalse(Thread.holdsLock(lock));\n+        });\n+    }\n+\n+    \/**\n+     * Test reentering a monitor with synchronized native method, no contention.\n+     *\/\n+    @Test\n+    void testReenter() throws Exception {\n+        Object lock = this;\n+        VThreadRunner.run(() -> {\n+\n+            \/\/ enter, reenter with a synchronized native method\n+            synchronized (lock) {\n+                runWithSynchronizedNative(() -> {\n+                    assertTrue(Thread.holdsLock(lock));\n+                });\n+                assertTrue(Thread.holdsLock(lock));\n+            }\n+            assertFalse(Thread.holdsLock(lock));\n+\n+            \/\/ enter with synchronized native method, reenter with synchronized statement\n+            runWithSynchronizedNative(() -> {\n+                assertTrue(Thread.holdsLock(lock));\n+                synchronized (lock) {\n+                    assertTrue(Thread.holdsLock(lock));\n+                }\n+                assertTrue(Thread.holdsLock(lock));\n+            });\n+            assertFalse(Thread.holdsLock(lock));\n+\n+            \/\/ enter with synchronized native method, reenter with synchronized native method\n+            runWithSynchronizedNative(() -> {\n+                assertTrue(Thread.holdsLock(lock));\n+                runWithSynchronizedNative(() -> {\n+                    assertTrue(Thread.holdsLock(lock));\n+                });\n+                assertTrue(Thread.holdsLock(lock));\n+            });\n+            assertFalse(Thread.holdsLock(lock));\n+        });\n+    }\n+\n+    \/**\n+     * Test entering a monitor with a synchronized native method and with contention.\n+     *\/\n+    @Test\n+    void testEnterWithContention() throws Exception {\n+        var lock = this;\n+        var started = new CountDownLatch(1);\n+        var entered = new AtomicBoolean();\n+        var vthread = Thread.ofVirtual().unstarted(() -> {\n+            started.countDown();\n+            runWithSynchronizedNative(() -> {\n+                assertTrue(Thread.holdsLock(lock));\n+                entered.set(true);\n+            });\n+        });\n+        try {\n+            synchronized (lock) {\n+                vthread.start();\n+\n+                \/\/ wait for thread to start and block\n+                started.await();\n+                await(vthread, Thread.State.BLOCKED);\n+\n+                assertFalse(entered.get());\n+            }\n+        } finally {\n+            vthread.join();\n+        }\n+        assertTrue(entered.get());\n+    }\n+\n+    \/**\n+     * Returns a stream of elements that are ordered pairs of platform and virtual thread\n+     * counts. 0,2,4 platform threads. 2,4,6,8 virtual threads.\n+     *\/\n+    static Stream<Arguments> threadCounts() {\n+        return IntStream.range(0, 5)\n+                .filter(i -> i % 2 == 0)\n+                .mapToObj(i -> i)\n+                .flatMap(np -> IntStream.range(2, 9)\n+                        .filter(i -> i % 2 == 0)\n+                        .mapToObj(vp -> Arguments.of(np, vp)));\n+    }\n+\n+    \/**\n+     * Execute a task concurrently from both platform and virtual threads.\n+     *\/\n+    private void executeConcurrently(int nPlatformThreads,\n+                                     int nVirtualThreads,\n+                                     Runnable task) throws Exception {\n+        int parallism = nVirtualThreads;\n+        if (Thread.currentThread().isVirtual()) {\n+            parallism++;\n+        }\n+        int previousParallelism = VThreadRunner.ensureParallelism(parallism);\n+        try {\n+            int nthreads = nPlatformThreads + nVirtualThreads;\n+            var phaser = new Phaser(nthreads + 1);\n+\n+            \/\/ start all threads\n+            var threads = new Thread[nthreads];\n+            int index = 0;\n+            for (int i = 0; i < nPlatformThreads; i++) {\n+                threads[index++] = Thread.ofPlatform().start(() -> {\n+                    phaser.arriveAndAwaitAdvance();\n+                    task.run();\n+                });\n+            }\n+            for (int i = 0; i < nVirtualThreads; i++) {\n+                threads[index++] = Thread.ofVirtual().start(() -> {\n+                    phaser.arriveAndAwaitAdvance();\n+                    task.run();\n+                });\n+            }\n+\n+            \/\/ wait for all threads to start\n+            phaser.arriveAndAwaitAdvance();\n+            System.err.printf(\"  %d threads started%n\", nthreads);\n+\n+            \/\/ wait for all threads to terminate\n+            for (Thread thread : threads) {\n+                if (thread != null) {\n+                    System.err.printf(\"  join %s ...%n\", thread);\n+                    thread.join();\n+                }\n+            }\n+        } finally {\n+            \/\/ reset parallelism\n+            VThreadRunner.setParallelism(previousParallelism);\n+        }\n+    }\n+\n+\n+    \/**\n+     * Test entering a monitor with a synchronized native method from many threads\n+     * at the same time.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"threadCounts\")\n+    void testEnterConcurrently(int nPlatformThreads, int nVirtualThreads) throws Exception {\n+        var counter = new Object() {\n+            int value;\n+            int value() { return value; }\n+            void increment() { value++; }\n+        };\n+        var lock = this;\n+        executeConcurrently(nPlatformThreads, nVirtualThreads, () -> {\n+            runWithSynchronizedNative(() -> {\n+                assertTrue(Thread.holdsLock(lock));\n+                counter.increment();\n+                LockSupport.parkNanos(100_000_000);  \/\/ 100ms\n+            });\n+        });\n+        synchronized (lock) {\n+            assertEquals(nPlatformThreads + nVirtualThreads, counter.value());\n+        }\n+    }\n+\n+    \/**\n+     * Test entering a monitor with JNI MonitorEnter.\n+     *\/\n+    @Test\n+    void testEnterInNative() throws Exception {\n+        Object lock = new Object();\n+        VThreadRunner.run(() -> {\n+            runWithMonitorEnteredInNative(lock, () -> {\n+                assertTrue(Thread.holdsLock(lock));\n+            });\n+            assertFalse(Thread.holdsLock(lock));\n+        });\n+    }\n+\n+    \/**\n+     * Test reentering a monitor with JNI MonitorEnter.\n+     *\/\n+    @Test\n+    void testReenterInNative() throws Exception {\n+        Object lock = new Object();\n+        VThreadRunner.run(() -> {\n+\n+            \/\/ enter, reenter with JNI MonitorEnter\n+            synchronized (lock) {\n+                runWithMonitorEnteredInNative(lock, () -> {\n+                    assertTrue(Thread.holdsLock(lock));\n+                });\n+                assertTrue(Thread.holdsLock(lock));\n+            }\n+            assertFalse(Thread.holdsLock(lock));\n+\n+            \/\/ enter with JNI MonitorEnter, reenter with synchronized statement\n+            runWithMonitorEnteredInNative(lock, () -> {\n+                assertTrue(Thread.holdsLock(lock));\n+                synchronized (lock) {\n+                    assertTrue(Thread.holdsLock(lock));\n+                }\n+                assertTrue(Thread.holdsLock(lock));\n+            });\n+            assertFalse(Thread.holdsLock(lock));\n+\n+            \/\/ enter with JNI MonitorEnter, reenter with JNI MonitorEnter\n+            runWithMonitorEnteredInNative(lock, () -> {\n+                assertTrue(Thread.holdsLock(lock));\n+                runWithMonitorEnteredInNative(lock, () -> {\n+                    assertTrue(Thread.holdsLock(lock));\n+                });\n+                assertTrue(Thread.holdsLock(lock));\n+            });\n+            assertFalse(Thread.holdsLock(lock));\n+        });\n+    }\n+\n+    \/**\n+     * Test entering a monitor with JNI MonitorEnter and with contention.\n+     *\/\n+    @Test\n+    void testEnterInNativeWithContention() throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n+        var entered = new AtomicBoolean();\n+        var vthread = Thread.ofVirtual().unstarted(() -> {\n+            started.countDown();\n+            runWithMonitorEnteredInNative(lock, () -> {\n+                assertTrue(Thread.holdsLock(lock));\n+                entered.set(true);\n+            });\n+        });\n+        try {\n+            synchronized (lock) {\n+                vthread.start();\n+\n+                \/\/ wait for thread to start and block\n+                started.await();\n+                await(vthread, Thread.State.BLOCKED);\n+\n+                assertFalse(entered.get());\n+            }\n+        } finally {\n+            vthread.join();\n+        }\n+        assertTrue(entered.get());\n+    }\n+\n+    \/**\n+     * Test entering a monitor with JNI MonitorEnter from many threads at the same time.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"threadCounts\")\n+    void testEnterInNativeConcurrently(int nPlatformThreads, int nVirtualThreads) throws Exception {\n+        var counter = new Object() {\n+            int value;\n+            int value() { return value; }\n+            void increment() { value++; }\n+        };\n+        var lock = counter;\n+        executeConcurrently(nPlatformThreads, nVirtualThreads, () -> {\n+            runWithMonitorEnteredInNative(lock, () -> {\n+                assertTrue(Thread.holdsLock(lock));\n+                counter.increment();\n+                LockSupport.parkNanos(100_000_000);  \/\/ 100ms\n+            });\n+        });\n+        synchronized (lock) {\n+            assertEquals(nPlatformThreads + nVirtualThreads, counter.value());\n+        }\n+    }\n+\n+    \/**\n+     * Test parking with synchronized native method on stack.\n+     *\/\n+    @Test\n+    void testParkingWhenPinned() throws Exception {\n+        var lock = this;\n+        var started = new CountDownLatch(1);\n+        var entered = new AtomicBoolean();\n+        var done = new AtomicBoolean();\n+        var vthread = Thread.ofVirtual().start(() -> {\n+            started.countDown();\n+            runWithSynchronizedNative(() -> {\n+                assertTrue(Thread.holdsLock(lock));\n+                entered.set(true);\n+                while (!done.get()) {\n+                    LockSupport.park();\n+                }\n+            });\n+        });\n+        try {\n+            \/\/ wait for thread to start and block\n+            started.await();\n+            await(vthread, Thread.State.WAITING);\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(vthread);\n+            vthread.join();\n+        }\n+        assertTrue(entered.get());\n+    }\n+\n+    \/**\n+     * Test blocking with synchronized native method on stack.\n+     *\/\n+    @Test\n+    void testBlockingWhenPinned() throws Exception {\n+        var lock1 = this;\n+        var lock2 = new Object();\n+\n+        var started = new CountDownLatch(1);\n+        var entered1 = new AtomicBoolean();   \/\/ set to true when vthread enters lock1\n+        var entered2 = new AtomicBoolean();   \/\/ set to true when vthread enters lock2\n+\n+        var vthread = Thread.ofVirtual().unstarted(() -> {\n+            started.countDown();\n+            runWithSynchronizedNative(() -> {\n+                assertTrue(Thread.holdsLock(lock1));\n+                entered1.set(true);\n+                synchronized (lock2) {   \/\/ should block\n+                    assertTrue(Thread.holdsLock(lock2));\n+                    entered2.set(true);\n+                }\n+            });\n+        });\n+        try {\n+            synchronized (lock2) {\n+                \/\/ start thread and wait for it to block trying to enter lock2\n+                vthread.start();\n+                started.await();\n+                await(vthread, Thread.State.BLOCKED);\n+\n+                assertTrue(entered1.get());\n+                assertFalse(entered2.get());\n+            }\n+        } finally {\n+            vthread.join();\n+        }\n+        assertTrue(entered2.get());\n+    }\n+\n+    \/**\n+     * Invokes the given task's run method while holding the monitor for \"this\".\n+     *\/\n+    private synchronized native void runWithSynchronizedNative(Runnable task);\n+\n+    \/**\n+     * Invokes the given task's run method while holding the monitor for the given\n+     * object. The monitor is entered with JNI MonitorEnter, and exited with JNI MonitorExit.\n+     *\/\n+    private native void runWithMonitorEnteredInNative(Object lock, Runnable task);\n+\n+    \/**\n+     * Called from native methods to run the given task.\n+     *\/\n+    private void run(Runnable task) {\n+        task.run();\n+    }\n+\n+    \/**\n+     * Waits for the given thread to reach a given state.\n+     *\/\n+    private void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            assertTrue(state != Thread.State.TERMINATED, \"Thread has terminated\");\n+            Thread.sleep(10);\n+            state = thread.getState();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/SynchronizedNative.java","additions":450,"deletions":0,"binary":false,"changes":450,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+\n+JNIEXPORT void JNICALL\n+Java_SynchronizedNative_runWithSynchronizedNative(JNIEnv *env, jobject obj, jobject task) {\n+    jclass clazz = (*env)->GetObjectClass(env, obj);\n+    jmethodID mid = (*env)->GetMethodID(env, clazz, \"run\", \"(Ljava\/lang\/Runnable;)V\");\n+    if (mid != NULL) {\n+        (*env)->CallVoidMethod(env, obj, mid, task);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_SynchronizedNative_runWithMonitorEnteredInNative(JNIEnv *env, jobject obj, jobject lock, jobject task) {\n+    jclass clazz = (*env)->GetObjectClass(env, obj);\n+    jmethodID mid = (*env)->GetMethodID(env, clazz, \"run\", \"(Ljava\/lang\/Runnable;)V\");\n+    if (mid != NULL && (*env)->MonitorEnter(env, lock) == 0) {\n+        (*env)->CallVoidMethod(env, obj, mid, task);\n+        (*env)->MonitorExit(env, lock);  \/\/ can be called with pending exception\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/libSynchronizedNative.c","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"}]}