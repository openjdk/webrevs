{"files":[{"patch":"@@ -104,0 +104,3 @@\n+hotspot_compiler_arraycopy = \\\n+  compiler\/arraycopy\/stress\n+\n@@ -125,1 +128,2 @@\n-  compiler\/gcbarriers\/PreserveFPRegistersTest.java\n+  compiler\/gcbarriers\/PreserveFPRegistersTest.java \\\n+  :hotspot_compiler_arraycopy\n@@ -142,0 +146,1 @@\n+  -:hotspot_slow_compiler\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Random;\n+\n+public abstract class AbstractStressArrayCopy {\n+    \/**\n+     * Max array size to test. This should be reasonably high to test\n+     * massive vectorized copies, plus cases that cross the cache lines and\n+     * (small) page boundaries. But it should also be reasonably low to\n+     * keep the test costs down.\n+     *\n+     * A rough guideline:\n+     *   - AVX-512: 64-byte copies over 32 registers copies roughly 2K per step.\n+     *   - AArch64: small pages can be about 64K large\n+     *\/\n+    static final int MAX_SIZE = 128*1024 + 1;\n+\n+    \/**\n+     * Arrays up to this size would be tested exhaustively: with all combinations\n+     * of source\/destination starts and copy lengths. Exercise restraint when bumping\n+     * this value, as the test costs are proportional to N^3 of this setting.\n+     *\/\n+    static final int EXHAUSTIVE_SIZES = Integer.getInteger(\"exhaustiveSizes\", 192);\n+\n+    \/*\n+     * Larger arrays would fuzzed with this many attempts.\n+     *\/\n+    static final int FUZZ_COUNT = Integer.getInteger(\"fuzzCount\", 300);\n+\n+    public static void throwSeedError(int len, int pos) {\n+        throw new RuntimeException(\"Error after seed: \" +\n+            len + \" elements, at pos \" + pos);\n+    }\n+\n+    public static void throwContentsError(int l, int r, int len, int pos) {\n+        throwError(\"in contents\", l, r, len, pos);\n+    }\n+\n+    public static void throwHeadError(int l, int r, int len, int pos) {\n+        throwError(\"in head\", l, r, len, pos);\n+    }\n+\n+    public static void throwTailError(int l, int r, int len, int pos) {\n+        throwError(\"in tail\", l, r, len, pos);\n+    }\n+\n+    private static void throwError(String phase, int l, int r, int len, int pos) {\n+        throw new RuntimeException(\"Error \" + phase + \": \" +\n+            len + \" elements, \" +\n+            \"[\" + l + \", \" + (l+len) + \") -> \" +\n+            \"[\" + r + \", \" + (r+len) + \"), \" +\n+            \"at pos \" + pos);\n+    }\n+\n+    protected abstract void testWith(int size, int l, int r, int len);\n+\n+    private void checkBounds(int size, int l, int r, int len) {\n+        if (l >= size)      throw new IllegalStateException(\"l is out of bounds\");\n+        if (l + len > size) throw new IllegalStateException(\"l+len is out of bounds\");\n+        if (r >= size)      throw new IllegalStateException(\"r is out of bounds\");\n+        if (r + len > size) throw new IllegalStateException(\"r+len is out of bounds: \" + l + \" \" + r + \" \" + len + \" \" + size);\n+    }\n+\n+    private void checkDisjoint(int size, int l, int r, int len) {\n+        if (l == r)               throw new IllegalStateException(\"Not disjoint: l == r\");\n+        if (l < r && l + len > r) throw new IllegalStateException(\"Not disjoint\");\n+        if (l > r && r + len > l) throw new IllegalStateException(\"Not disjoint\");\n+    }\n+\n+    private void checkConjoint(int size, int l, int r, int len) {\n+        if (l == r) return; \/\/ Definitely conjoint, even with zero len\n+        if (l < r && l + len < r) throw new IllegalStateException(\"Not conjoint\");\n+        if (l > r && r + len < l) throw new IllegalStateException(\"Not conjoint\");\n+    }\n+\n+    public void exhaustiveWith(int size) {\n+        for (int l = 0; l < size; l++) {\n+            for (int r = 0; r < size; r++) {\n+                int maxLen = Math.min(size - l, size - r);\n+                for (int len = 0; len <= maxLen; len++) {\n+                    checkBounds(size, l, r, len);\n+                    testWith(size, l, r, len);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void fuzzWith(Random rand, int size) {\n+        \/\/ Some basic checks first\n+        testWith(size, 0, 1, 1);\n+        testWith(size, 0, 1, size-1);\n+\n+        \/\/ Test disjoint:\n+        for (int c = 0; c < FUZZ_COUNT; c++) {\n+            int l = rand.nextInt(size \/ 2);\n+            int len = rand.nextInt((size - l) \/ 2);\n+            int r = (l + len + 1) + rand.nextInt(size - 2*len - l - 1);\n+\n+            checkBounds(size, l, r, len);\n+            checkDisjoint(size, l, r, len);\n+\n+            testWith(size, l, r, len);\n+            testWith(size, r, l, len);\n+        }\n+\n+        \/\/ Test conjoint:\n+        for (int c = 0; c < FUZZ_COUNT; c++) {\n+            int l = rand.nextInt(size);\n+            int len = rand.nextInt(size - l);\n+            int r = Math.min(l + (len > 0 ? rand.nextInt(len) : 0), size - len);\n+\n+            checkBounds(size, l, r, len);\n+            checkConjoint(size, l, r, len);\n+\n+            testWith(size, l, r, len);\n+            testWith(size, r, l, len);\n+        }\n+    }\n+\n+    public void run(Random rand) {\n+        \/\/ Exhaustive on all small arrays\n+        for (int size = 1; size <= EXHAUSTIVE_SIZES; size++) {\n+            exhaustiveWith(size);\n+        }\n+\n+        \/\/ Fuzz powers of ten\n+        for (int size = 10; size < MAX_SIZE; size *= 10) {\n+            if (size <= EXHAUSTIVE_SIZES) continue;\n+            fuzzWith(rand, size - 1);\n+            fuzzWith(rand, size);\n+            fuzzWith(rand, size + 1);\n+        }\n+\n+        \/\/ Fuzz powers of two\n+        for (int size = 2; size < MAX_SIZE; size *= 2) {\n+            if (size <= EXHAUSTIVE_SIZES) continue;\n+            fuzzWith(rand, size - 1);\n+            fuzzWith(rand, size);\n+            fuzzWith(rand, size + 1);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/AbstractStressArrayCopy.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressBooleanArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final boolean[] orig = new boolean[MAX_SIZE];\n+    private static final boolean[] test = new boolean[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextBoolean();\n+        }\n+        new StressBooleanArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressBooleanArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressByteArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final byte[] orig = new byte[MAX_SIZE];\n+    private static final byte[] test = new byte[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = (byte)rand.nextInt();\n+        }\n+        new StressByteArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressByteArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressCharArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final char[] orig = new char[MAX_SIZE];\n+    private static final char[] test = new char[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = (char)rand.nextInt();\n+        }\n+        new StressCharArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressCharArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressDoubleArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final double[] orig = new double[MAX_SIZE];\n+    private static final double[] test = new double[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextDouble();\n+        }\n+        new StressDoubleArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressDoubleArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressFloatArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final float[] orig = new float[MAX_SIZE];\n+    private static final float[] test = new float[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextFloat();\n+        }\n+        new StressFloatArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressFloatArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressIntArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final int[] orig = new int[MAX_SIZE];\n+    private static final int[] test = new int[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextInt();\n+        }\n+        new StressIntArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressIntArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressLongArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final long[] orig = new long[MAX_SIZE];\n+    private static final long[] test = new long[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextLong();\n+        }\n+        new StressLongArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressLongArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressObjectArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final Object[] orig = new Object[MAX_SIZE];\n+    private static final Object[] test = new Object[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = new Object();\n+        }\n+        new StressObjectArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressObjectArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressShortArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final short[] orig = new short[MAX_SIZE];\n+    private static final short[] test = new short[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = (short)rand.nextInt();\n+        }\n+        new StressShortArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressShortArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n+\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @library \/test\/lib\n+ * @build compiler.arraycopy.stress.AbstractStressArrayCopy\n+ *        compiler.arraycopy.stress.StressBooleanArrayCopy\n+ *        compiler.arraycopy.stress.StressByteArrayCopy\n+ *        compiler.arraycopy.stress.StressCharArrayCopy\n+ *        compiler.arraycopy.stress.StressShortArrayCopy\n+ *        compiler.arraycopy.stress.StressIntArrayCopy\n+ *        compiler.arraycopy.stress.StressFloatArrayCopy\n+ *        compiler.arraycopy.stress.StressLongArrayCopy\n+ *        compiler.arraycopy.stress.StressDoubleArrayCopy\n+ *        compiler.arraycopy.stress.StressObjectArrayCopy\n+ *        jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=7200\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      compiler.arraycopy.stress.TestStressArrayCopy\n+ *\/\n+public class TestStressArrayCopy {\n+\n+    \/\/ These tests are remarkably memory bandwidth hungry. Running multiple\n+    \/\/ configs in parallel makes sense only when running a single test in\n+    \/\/ isolation, and only on machines with many memory channels. In common\n+    \/\/ testing, or even running all arraycopy stress tests at once, overloading\n+    \/\/ the system with many configs become counter-productive very quickly.\n+    \/\/\n+    \/\/ Default to 1\/4 of the CPUs, and allow users to override.\n+    static final int MAX_PARALLELISM = Integer.getInteger(\"maxParallelism\",\n+        Math.max(1, Runtime.getRuntime().availableProcessors() \/ 4));\n+\n+    private static List<String> mix(List<String> o, String... mix) {\n+        List<String> n = new ArrayList<>(o);\n+        for (String m : mix) {\n+            n.add(m);\n+        }\n+        return n;\n+    }\n+\n+    private static List<List<String>> product(List<List<String>> list, String... mix) {\n+        List<List<String>> newList = new ArrayList<>();\n+        for (List<String> c : list) {\n+            for (String m : mix) {\n+                newList.add(mix(c, m));\n+            }\n+        }\n+        return newList;\n+    }\n+\n+    private static List<List<String>> alternate(List<List<String>> list, String opt) {\n+        return product(list, \"-XX:+\" + opt, \"-XX:-\" + opt);\n+    }\n+\n+    private static boolean containsFuzzy(List<String> list, String sub) {\n+        for (String s : list) {\n+            if (s.contains(sub)) return true;\n+        }\n+        return false;\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        List<List<String>> configs = new ArrayList<>();\n+        List<String> cpuFeatures = CPUInfo.getFeatures();\n+\n+        if (Platform.isX64() || Platform.isX86()) {\n+            \/\/ If CPU features were not found, provide a default config.\n+            if (cpuFeatures.isEmpty()) {\n+                configs.add(new ArrayList());\n+            }\n+\n+            \/\/ Otherwise, select the tests that make sense on current platform.\n+            if (containsFuzzy(cpuFeatures, \"avx512\")) {\n+                configs.add(List.of(\"-XX:UseAVX=3\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"avx2\")) {\n+                configs.add(List.of(\"-XX:UseAVX=2\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"avx\")) {\n+                configs.add(List.of(\"-XX:UseAVX=1\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"sse4\")) {\n+                configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=4\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"sse3\")) {\n+                configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=3\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"sse2\")) {\n+                configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=2\"));\n+            }\n+\n+            \/\/ x86_64 always has UseSSE >= 2. These lower configurations only\n+            \/\/ make sense for x86_32.\n+            if (Platform.isX86()) {\n+                if (containsFuzzy(cpuFeatures, \"sse\")) {\n+                    configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=1\"));\n+                }\n+\n+                configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=0\"));\n+            }\n+\n+            \/\/ Alternate configs with other flags\n+            if (Platform.isX64()) {\n+                configs = alternate(configs, \"UseCompressedOops\");\n+            }\n+            configs = alternate(configs, \"UseUnalignedLoadStores\");\n+\n+        } else if (Platform.isAArch64()) {\n+            \/\/ AArch64.\n+            configs.add(new ArrayList());\n+\n+            \/\/ Alternate configs with other flags\n+            configs = alternate(configs, \"UseCompressedOops\");\n+            configs = alternate(configs, \"UseSIMDForMemoryOps\");\n+        } else {\n+            \/\/ Generic config.\n+            configs.add(new ArrayList());\n+        }\n+\n+        String[] classNames = {\n+            \"compiler.arraycopy.stress.StressBooleanArrayCopy\",\n+            \"compiler.arraycopy.stress.StressByteArrayCopy\",\n+            \"compiler.arraycopy.stress.StressCharArrayCopy\",\n+            \"compiler.arraycopy.stress.StressShortArrayCopy\",\n+            \"compiler.arraycopy.stress.StressIntArrayCopy\",\n+            \"compiler.arraycopy.stress.StressFloatArrayCopy\",\n+            \"compiler.arraycopy.stress.StressLongArrayCopy\",\n+            \"compiler.arraycopy.stress.StressDoubleArrayCopy\",\n+            \"compiler.arraycopy.stress.StressObjectArrayCopy\",\n+        };\n+\n+        ArrayList<Fork> forks = new ArrayList<>();\n+        int jobs = 0;\n+\n+        for (List<String> c : configs) {\n+            for (String className : classNames) {\n+                \/\/ Start a new job\n+                {\n+                    ProcessBuilder pb = ProcessTools.createTestJvm(mix(c, \"-Xmx256m\", className));\n+                    Process p = pb.start();\n+                    OutputAnalyzer oa = new OutputAnalyzer(p);\n+                    forks.add(new Fork(p, oa));\n+                    jobs++;\n+                }\n+\n+                \/\/ Wait for the completion of other jobs\n+                while (jobs >= MAX_PARALLELISM) {\n+                    Fork f = findDone(forks);\n+                    if (f != null) {\n+                        OutputAnalyzer oa = f.oa();\n+                        oa.shouldHaveExitValue(0);\n+                        forks.remove(f);\n+                        jobs--;\n+                    } else {\n+                        \/\/ Nothing is done, wait a little.\n+                        Thread.sleep(200);\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Drain the rest\n+        for (Fork f : forks) {\n+            OutputAnalyzer oa = f.oa();\n+            oa.shouldHaveExitValue(0);\n+        }\n+    }\n+\n+    private static Fork findDone(List<Fork> forks) {\n+        for (Fork f : forks) {\n+            if (!f.p().isAlive()) {\n+                return f;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static record Fork(Process p, OutputAnalyzer oa) {};\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/TestStressArrayCopy.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"}]}