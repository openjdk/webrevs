{"files":[{"patch":"@@ -46,2 +46,5 @@\n-    java\/lang\/classfile\/components\/snippet-files \\\n-    java\/lang\/foreign\/snippet-files\n+    java\/lang\/classfile\/attribute\/snippet-files \\\n+    java\/lang\/classfile\/constantpool\/snippet-files \\\n+    java\/lang\/foreign\/snippet-files \\\n+    javax\/crypto\/spec\/snippet-files \\\n+    jdk\/internal\/classfile\/components\/snippet-files\n","filename":"make\/modules\/java.base\/Java.gmk","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.Serial;\n@@ -30,2 +31,11 @@\n-import java.security.*;\n-import java.security.interfaces.ECKey;\n+import java.security.AsymmetricKey;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.KeyFactory;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n@@ -33,1 +43,0 @@\n-import java.security.interfaces.XECKey;\n@@ -35,1 +44,10 @@\n-import java.security.spec.*;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.ECParameterSpec;\n+import java.security.spec.ECPoint;\n+import java.security.spec.ECPrivateKeySpec;\n+import java.security.spec.ECPublicKeySpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.security.spec.XECPrivateKeySpec;\n+import java.security.spec.XECPublicKeySpec;\n@@ -38,1 +56,7 @@\n-import javax.crypto.*;\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.KDF;\n+import javax.crypto.KEM;\n+import javax.crypto.KEMSpi;\n+import javax.crypto.KeyAgreement;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -42,2 +66,6 @@\n-import sun.security.ssl.HKDF;\n-import sun.security.util.*;\n+import sun.security.util.ArrayUtil;\n+import sun.security.util.CurveDB;\n+import sun.security.util.ECUtil;\n+import sun.security.util.InternalPrivateKey;\n+import sun.security.util.NamedCurve;\n+import sun.security.util.SliceableSecretKey;\n@@ -46,1 +74,0 @@\n-\/\/ without the AuthEncap and AuthDecap functions\n@@ -66,1 +93,2 @@\n-                           PrivateKey skR, PublicKey pkR)\n+                           PrivateKey skS, PublicKey pkS, \/\/ sender keys\n+                           PrivateKey skR, PublicKey pkR) \/\/ receiver keys\n@@ -78,1 +106,0 @@\n-            byte[] kem_context = concat(pkEm, pkRm);\n@@ -80,5 +107,14 @@\n-                byte[] dh = params.DH(skE, pkR);\n-                byte[] key = params.ExtractAndExpand(dh, kem_context);\n-                return new KEM.Encapsulated(\n-                        new SecretKeySpec(key, from, to - from, algorithm),\n-                        pkEm, null);\n+                SecretKey key;\n+                if (skS == null) {\n+                    byte[] kem_context = concat(pkEm, pkRm);\n+                    key = params.deriveKey(algorithm, from, to, kem_context,\n+                            params.DH(skE, pkR));\n+                } else {\n+                    byte[] pkSm = params.SerializePublicKey(pkS);\n+                    byte[] kem_context = concat(pkEm, pkRm, pkSm);\n+                    key = params.deriveKey(algorithm, from, to, kem_context,\n+                            params.DH(skE, pkR), params.DH(skS, pkR));\n+                }\n+                return new KEM.Encapsulated(key, pkEm, null);\n+            } catch (UnsupportedOperationException e) {\n+                throw e;\n@@ -101,1 +137,0 @@\n-                byte[] dh = params.DH(skR, pkE);\n@@ -103,3 +138,12 @@\n-                byte[] kem_context = concat(encapsulation, pkRm);\n-                byte[] key = params.ExtractAndExpand(dh, kem_context);\n-                return new SecretKeySpec(key, from, to - from, algorithm);\n+                if (pkS == null) {\n+                    byte[] kem_context = concat(encapsulation, pkRm);\n+                    return params.deriveKey(algorithm, from, to, kem_context,\n+                            params.DH(skR, pkE));\n+                } else {\n+                    byte[] pkSm = params.SerializePublicKey(pkS);\n+                    byte[] kem_context = concat(encapsulation, pkRm, pkSm);\n+                    return params.deriveKey(algorithm, from, to, kem_context,\n+                            params.DH(skR, pkE), params.DH(skR, pkS));\n+                }\n+            } catch (UnsupportedOperationException e) {\n+                throw e;\n@@ -127,1 +171,2 @@\n-        static final long serialVersionUID = 0L;\n+        @Serial\n+        private static final long serialVersionUID = 0L;\n@@ -136,1 +181,1 @@\n-        public KeyPair derive(Params params) {\n+        private KeyPair derive(Params params) {\n@@ -156,1 +201,1 @@\n-                \"ECDH\", \"EC\", CurveDB.P_256, \"SHA-256\"),\n+                \"ECDH\", \"EC\", CurveDB.P_256, \"HKDF-SHA256\"),\n@@ -159,1 +204,1 @@\n-                \"ECDH\", \"EC\", CurveDB.P_384, \"SHA-384\"),\n+                \"ECDH\", \"EC\", CurveDB.P_384, \"HKDF-SHA384\"),\n@@ -162,1 +207,1 @@\n-                \"ECDH\", \"EC\", CurveDB.P_521, \"SHA-512\"),\n+                \"ECDH\", \"EC\", CurveDB.P_521, \"HKDF-SHA512\"),\n@@ -165,1 +210,1 @@\n-                \"XDH\", \"XDH\", NamedParameterSpec.X25519, \"SHA-256\"),\n+                \"XDH\", \"XDH\", NamedParameterSpec.X25519, \"HKDF-SHA256\"),\n@@ -168,1 +213,1 @@\n-                \"XDH\", \"XDH\", NamedParameterSpec.X448, \"SHA-512\"),\n+                \"XDH\", \"XDH\", NamedParameterSpec.X448, \"HKDF-SHA512\"),\n@@ -240,1 +285,1 @@\n-        private byte[] DH(PrivateKey skE, PublicKey pkR)\n+        private SecretKey DH(PrivateKey skE, PublicKey pkR)\n@@ -245,1 +290,1 @@\n-            return ka.generateSecret();\n+            return ka.generateSecret(\"Generic\");\n@@ -248,6 +293,39 @@\n-        private byte[] ExtractAndExpand(byte[] dh, byte[] kem_context)\n-                throws NoSuchAlgorithmException, InvalidKeyException {\n-            HKDF kdf = new HKDF(hkdfAlgorithm);\n-            SecretKey eae_prk = LabeledExtract(kdf, suiteId, null, EAE_PRK, dh);\n-            return LabeledExpand(kdf, suiteId, eae_prk, SHARED_SECRET,\n-                    kem_context, Nsecret);\n+        \/\/ The final shared secret derivation of either the encapsulator\n+        \/\/ or the decapsulator. The key slicing is implemented inside.\n+        \/\/ Throws UOE if a slice of the key cannot be found.\n+        private SecretKey deriveKey(String alg, int from, int to,\n+                byte[] kem_context, SecretKey... dhs)\n+                throws NoSuchAlgorithmException {\n+            if (from == 0 && to == Nsecret) {\n+                return ExtractAndExpand(kem_context, alg, dhs);\n+            } else {\n+                \/\/ First get shared secrets in \"Generic\" and then get a slice\n+                \/\/ of it in the requested algorithm.\n+                var fullKey = ExtractAndExpand(kem_context, \"Generic\", dhs);\n+                if (\"RAW\".equalsIgnoreCase(fullKey.getFormat())) {\n+                    byte[] km = fullKey.getEncoded();\n+                    if (km == null) {\n+                        \/\/ Should not happen if format is \"RAW\"\n+                        throw new UnsupportedOperationException(\"Key extract failed\");\n+                    } else {\n+                        return new SecretKeySpec(km, from, to - from, alg);\n+                    }\n+                } else if (fullKey instanceof SliceableSecretKey ssk) {\n+                    return ssk.slice(alg, from, to);\n+                } else {\n+                    throw new UnsupportedOperationException(\"Cannot extract key\");\n+                }\n+            }\n+        }\n+\n+        private SecretKey ExtractAndExpand(byte[] kem_context, String alg, SecretKey... dhs)\n+                throws NoSuchAlgorithmException {\n+            var kdf = KDF.getInstance(hkdfAlgorithm);\n+            var builder = labeledExtract(suiteId, EAE_PRK);\n+            for (var dh : dhs) builder.addIKM(dh);\n+            try {\n+                return kdf.deriveKey(alg,\n+                        labeledExpand(builder, suiteId, SHARED_SECRET, kem_context, Nsecret));\n+            } catch (InvalidAlgorithmParameterException e) {\n+                throw new ProviderException(e);\n+            }\n@@ -280,2 +358,2 @@\n-            HKDF kdf = new HKDF(hkdfAlgorithm);\n-            SecretKey dkp_prk = LabeledExtract(kdf, suiteId, null, DKP_PRK, ikm);\n+            var kdf = KDF.getInstance(hkdfAlgorithm);\n+            var builder = labeledExtract(suiteId, DKP_PRK).addIKM(ikm);\n@@ -288,1 +366,2 @@\n-                        throw new RuntimeException();\n+                        \/\/ So unlucky and should not happen\n+                        throw new ProviderException(\"DeriveKeyPairError\");\n@@ -290,2 +369,2 @@\n-                    byte[] bytes = LabeledExpand(kdf, suiteId, dkp_prk,\n-                            CANDIDATE, I2OSP(counter, 1), Nsk);\n+                    byte[] bytes = kdf.deriveData(labeledExpand(builder,\n+                            suiteId, CANDIDATE, I2OSP(counter, 1), Nsk));\n@@ -302,1 +381,2 @@\n-                byte[] sk = LabeledExpand(kdf, suiteId, dkp_prk, SK, EMPTY, Nsk);\n+                byte[] sk = kdf.deriveData(labeledExpand(builder,\n+                        suiteId, SK, EMPTY, Nsk));\n@@ -331,1 +411,16 @@\n-        return new Handler(params, getSecureRandom(secureRandom), null, pk);\n+        return new Handler(params, getSecureRandom(secureRandom), null, null, null, pk);\n+    }\n+\n+    \/\/ AuthEncap is not public KEM API\n+    public EncapsulatorSpi engineNewAuthEncapsulator(PublicKey pkR, PrivateKey skS,\n+            AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (pkR == null || skS == null) {\n+            throw new InvalidKeyException(\"input key is null\");\n+        }\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\"no spec needed\");\n+        }\n+        Params params = paramsFromKey(pkR);\n+        return new Handler(params, getSecureRandom(secureRandom),\n+                skS, params.getPublicKey(skS), null, pkR);\n@@ -344,1 +439,1 @@\n-        return new Handler(params, null, sk, params.getPublicKey(sk));\n+        return new Handler(params, null, null, null, sk, params.getPublicKey(sk));\n@@ -347,3 +442,18 @@\n-    private Params paramsFromKey(Key k) throws InvalidKeyException {\n-        if (k instanceof ECKey eckey) {\n-            if (ECUtil.equals(eckey.getParams(), CurveDB.P_256)) {\n+    \/\/ AuthDecap is not public KEM API\n+    public DecapsulatorSpi engineNewAuthDecapsulator(\n+            PrivateKey skR, PublicKey pkS, AlgorithmParameterSpec spec)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (skR == null || pkS == null) {\n+            throw new InvalidKeyException(\"input key is null\");\n+        }\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\"no spec needed\");\n+        }\n+        Params params = paramsFromKey(skR);\n+        return new Handler(params, null, null, pkS, skR, params.getPublicKey(skR));\n+    }\n+\n+    private Params paramsFromKey(AsymmetricKey k) throws InvalidKeyException {\n+        var p = k.getParams();\n+        if (p instanceof ECParameterSpec ecp) {\n+            if (ECUtil.equals(ecp, CurveDB.P_256)) {\n@@ -351,1 +461,1 @@\n-            } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_384)) {\n+            } else if (ECUtil.equals(ecp, CurveDB.P_384)) {\n@@ -353,1 +463,1 @@\n-            } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_521)) {\n+            } else if (ECUtil.equals(ecp, CurveDB.P_521)) {\n@@ -356,2 +466,1 @@\n-        } else if (k instanceof XECKey xkey\n-                && xkey.getParams() instanceof NamedParameterSpec ns) {\n+        } else if (p instanceof NamedParameterSpec ns) {\n@@ -373,2 +482,5 @@\n-    private static byte[] I2OSP(int n, int w) {\n-        assert n < 256;\n+    \/\/ I2OSP(n, w) as defined in RFC 9180 Section 3.\n+    \/\/ In DHKEM and HPKE, number is always <65536\n+    \/\/ and converted to at most 2 bytes.\n+    public static byte[] I2OSP(int n, int w) {\n+        assert n < 65536;\n@@ -383,5 +495,20 @@\n-    private static SecretKey LabeledExtract(HKDF kdf, byte[] suite_id,\n-            byte[] salt, byte[] label, byte[] ikm) throws InvalidKeyException {\n-        return kdf.extract(salt,\n-                new SecretKeySpec(concat(HPKE_V1, suite_id, label, ikm), \"IKM\"),\n-                    \"HKDF-PRK\");\n+    \/\/ Create a LabeledExtract builder with labels.\n+    \/\/ You can add more IKM and salt into the result.\n+    public static HKDFParameterSpec.Builder labeledExtract(\n+            byte[] suiteId, byte[] label) {\n+        return HKDFParameterSpec.ofExtract()\n+                .addIKM(HPKE_V1).addIKM(suiteId).addIKM(label);\n+    }\n+\n+    \/\/ Create a labeled info from info and labels\n+    private static byte[] labeledInfo(\n+            byte[] suiteId, byte[] label, byte[] info, int L) {\n+        return concat(I2OSP(L, 2), HPKE_V1, suiteId, label, info);\n+    }\n+\n+    \/\/ LabeledExpand from a builder\n+    public static HKDFParameterSpec labeledExpand(\n+            HKDFParameterSpec.Builder builder,\n+            byte[] suiteId, byte[] label, byte[] info, int L) {\n+        return builder.thenExpand(\n+                labeledInfo(suiteId, label, info, L), L);\n@@ -390,6 +517,5 @@\n-    private static byte[] LabeledExpand(HKDF kdf, byte[] suite_id,\n-            SecretKey prk, byte[] label, byte[] info, int L)\n-            throws InvalidKeyException {\n-        byte[] labeled_info = concat(I2OSP(L, 2), HPKE_V1,\n-                suite_id, label, info);\n-        return kdf.expand(prk, labeled_info, L, \"NONE\").getEncoded();\n+    \/\/ LabeledExpand from a prk\n+    public static HKDFParameterSpec labeledExpand(\n+            SecretKey prk, byte[] suiteId, byte[] label, byte[] info, int L) {\n+        return HKDFParameterSpec.expandOnly(\n+                prk, labeledInfo(suiteId, label, info, L), L);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKEM.java","additions":189,"deletions":63,"binary":false,"changes":252,"status":"modified"},{"patch":"@@ -0,0 +1,612 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.crypto.provider;\n+\n+import sun.security.util.CurveDB;\n+import sun.security.util.ECUtil;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.CipherSpi;\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.KDF;\n+import javax.crypto.KEM;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.HPKEParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.ByteBuffer;\n+import java.security.AlgorithmParameters;\n+import java.security.AsymmetricKey;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.ECParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Arrays;\n+\n+public class HPKE extends CipherSpi {\n+\n+    private static final byte[] HPKE = new byte[]\n+            {'H', 'P', 'K', 'E'};\n+    private static final byte[] SEC = new byte[]\n+            {'s', 'e', 'c'};\n+    private static final byte[] PSK_ID_HASH = new byte[]\n+            {'p', 's', 'k', '_', 'i', 'd', '_', 'h', 'a', 's', 'h'};\n+    private static final byte[] INFO_HASH = new byte[]\n+            {'i', 'n', 'f', 'o', '_', 'h', 'a', 's', 'h'};\n+    private static final byte[] SECRET = new byte[]\n+            {'s', 'e', 'c', 'r', 'e', 't'};\n+    private static final byte[] EXP = new byte[]\n+            {'e', 'x', 'p'};\n+    private static final byte[] KEY = new byte[]\n+            {'k', 'e', 'y'};\n+    private static final byte[] BASE_NONCE = new byte[]\n+            {'b', 'a', 's', 'e', '_', 'n', 'o', 'n', 'c', 'e'};\n+\n+    private static final int BEGIN = 1;\n+    private static final int EXPORT_ONLY = 2; \/\/ init done with aead_id == 65535\n+    private static final int ENCRYPT_AND_EXPORT = 3; \/\/ int done with AEAD\n+    private static final int AFTER_FINAL = 4; \/\/ after doFinal, need reinit internal cipher\n+\n+    private int state = BEGIN;\n+    private Impl impl;\n+\n+    @Override\n+    protected void engineSetMode(String mode) throws NoSuchAlgorithmException {\n+        throw new NoSuchAlgorithmException(mode);\n+    }\n+\n+    @Override\n+    protected void engineSetPadding(String padding) throws NoSuchPaddingException {\n+        throw new NoSuchPaddingException(padding);\n+    }\n+\n+    @Override\n+    protected int engineGetBlockSize() {\n+        if (state == ENCRYPT_AND_EXPORT || state == AFTER_FINAL) {\n+            return impl.aead.cipher.getBlockSize();\n+        } else {\n+            throw new IllegalStateException(\"No AEAD cipher\");\n+        }\n+    }\n+\n+    @Override\n+    protected int engineGetOutputSize(int inputLen) {\n+        if (state == ENCRYPT_AND_EXPORT || state == AFTER_FINAL) {\n+            return impl.aead.cipher.getOutputSize(inputLen);\n+        } else {\n+            throw new IllegalStateException(\"No AEAD cipher\");\n+        }\n+    }\n+\n+    @Override\n+    protected byte[] engineGetIV() {\n+        return state == BEGIN ? null : impl.params.encapsulation();\n+    }\n+\n+    @Override\n+    protected AlgorithmParameters engineGetParameters() {\n+        if (state == BEGIN) {\n+            return null;\n+        }\n+        try {\n+            var result = AlgorithmParameters.getInstance(\"HPKE\");\n+            result.init(impl.params);\n+            return result;\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new ProviderException(\"Cannot find implementations\", e);\n+        } catch (InvalidParameterSpecException e) {\n+            throw new ProviderException(\"Parameters not supported\", e);\n+        }\n+    }\n+\n+    @Override\n+    protected void engineInit(int opmode, Key key, SecureRandom random)\n+            throws InvalidKeyException {\n+        try {\n+            engineInit(opmode, key, (AlgorithmParameterSpec) null, random);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            \/\/ Parent spec says \"throws InvalidKeyException if the given key\n+            \/\/ requires algorithm parameters that cannot be determined from\n+            \/\/ the given key\"\n+            throw new InvalidKeyException(e);\n+        }\n+    }\n+\n+    @Override\n+    protected void engineInit(int opmode, Key key,\n+            AlgorithmParameterSpec params, SecureRandom random)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        impl = new Impl(opmode);\n+        if (!(key instanceof AsymmetricKey ak)) {\n+            throw new InvalidKeyException(\"Not asymmetric key\");\n+        }\n+        if (params == null) {\n+            impl.init(ak, HPKEParameterSpec.of(), random);\n+        } else if (params instanceof HPKEParameterSpec hps) {\n+            impl.init(ak, hps, random);\n+        } else {\n+            throw new InvalidAlgorithmParameterException(\n+                    \"Unsupported params type: \" + params.getClass());\n+        }\n+        if (impl.hasEncrypt()) {\n+            impl.aead.start(impl.opmode, impl.context.k, impl.context.ComputeNonce());\n+            state = ENCRYPT_AND_EXPORT;\n+        } else {\n+            state = EXPORT_ONLY;\n+        }\n+    }\n+\n+    @Override\n+    protected void engineInit(int opmode, Key key,\n+            AlgorithmParameters params, SecureRandom random)\n+            throws InvalidAlgorithmParameterException {\n+        throw new InvalidAlgorithmParameterException(\n+                \"Does not support init from AlgorithmParameters\");\n+    }\n+\n+    \/\/ state is ENCRYPT_AND_EXPORT after this call succeeds\n+    private void maybeReinitInternalCipher() {\n+        if (state == BEGIN) {\n+            throw new IllegalStateException(\"Illegal state: \" + state);\n+        }\n+        if (state == EXPORT_ONLY) {\n+            throw new UnsupportedOperationException();\n+        }\n+        if (state == AFTER_FINAL) {\n+            impl.aead.start(impl.opmode, impl.context.k, impl.context.ComputeNonce());\n+            state = ENCRYPT_AND_EXPORT;\n+        }\n+    }\n+\n+    @Override\n+    protected byte[] engineUpdate(byte[] input, int inputOffset, int inputLen) {\n+        maybeReinitInternalCipher();\n+        return impl.aead.cipher.update(input, inputOffset, inputLen);\n+    }\n+\n+    @Override\n+    protected int engineUpdate(byte[] input, int inputOffset, int inputLen,\n+            byte[] output, int outputOffset) throws ShortBufferException {\n+        maybeReinitInternalCipher();\n+        return impl.aead.cipher.update(\n+                input, inputOffset, inputLen, output, outputOffset);\n+    }\n+\n+    @Override\n+    protected void engineUpdateAAD(byte[] src, int offset, int len) {\n+        maybeReinitInternalCipher();\n+        impl.aead.cipher.updateAAD(src, offset, len);\n+    }\n+\n+    @Override\n+    protected void engineUpdateAAD(ByteBuffer src) {\n+        maybeReinitInternalCipher();\n+        impl.aead.cipher.updateAAD(src);\n+    }\n+\n+    @Override\n+    protected byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen)\n+            throws IllegalBlockSizeException, BadPaddingException {\n+        maybeReinitInternalCipher();\n+        impl.context.IncrementSeq();\n+        state = AFTER_FINAL;\n+        if (input == null) { \/\/ a bug in doFinal(null, ?, ?)\n+            return impl.aead.cipher.doFinal();\n+        } else {\n+            return impl.aead.cipher.doFinal(input, inputOffset, inputLen);\n+        }\n+    }\n+\n+    @Override\n+    protected int engineDoFinal(byte[] input, int inputOffset, int inputLen,\n+            byte[] output, int outputOffset) throws ShortBufferException,\n+            IllegalBlockSizeException, BadPaddingException {\n+        maybeReinitInternalCipher();\n+        impl.context.IncrementSeq();\n+        state = AFTER_FINAL;\n+        return impl.aead.cipher.doFinal(\n+                input, inputOffset, inputLen, output, outputOffset);\n+    }\n+\n+    \/\/@Override\n+    protected SecretKey engineExportKey(byte[] context, String algorithm, int length) {\n+        if (state == BEGIN) {\n+            throw new IllegalStateException(\"State: \" + state);\n+        } else {\n+            return impl.context.Export(context, algorithm, length);\n+        }\n+    }\n+\n+    private static class AEAD {\n+        final Cipher cipher;\n+        final int Nk, Nn, Nt;\n+        final int id;\n+        public AEAD(int id) throws InvalidAlgorithmParameterException {\n+            this.id = id;\n+            try {\n+                switch (id) {\n+                    case HPKEParameterSpec.AEAD_AES_128_GCM -> {\n+                        cipher = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n+                        Nk = 16;\n+                    }\n+                    case HPKEParameterSpec.AEAD_AES_256_GCM -> {\n+                        cipher = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n+                        Nk = 32;\n+                    }\n+                    case HPKEParameterSpec.AEAD_CHACHA20_POLY1305 -> {\n+                        cipher = Cipher.getInstance(\"ChaCha20-Poly1305\");\n+                        Nk = 32;\n+                    }\n+                    case HPKEParameterSpec.EXPORT_ONLY -> {\n+                        cipher = null;\n+                        Nk = -1;\n+                    }\n+                    default -> throw new InvalidAlgorithmParameterException(\n+                            \"Unknown aead_id: \" + id);\n+                }\n+            } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n+                throw new ProviderException(\"Internal error\", e);\n+            }\n+            Nn = 12; Nt = 16;\n+        }\n+\n+        void start(int opmode, SecretKey key, byte[] nonce) {\n+            try {\n+                if (id == HPKEParameterSpec.AEAD_CHACHA20_POLY1305) {\n+                    cipher.init(opmode, key, new IvParameterSpec(nonce));\n+                } else {\n+                    cipher.init(opmode, key, new GCMParameterSpec(Nt * 8, nonce));\n+                }\n+            } catch (InvalidAlgorithmParameterException | InvalidKeyException e) {\n+                throw new ProviderException(\"Internal error\", e);\n+            }\n+        }\n+    }\n+\n+    private static class Impl {\n+\n+        final int opmode;\n+\n+        HPKEParameterSpec params;\n+        Context context;\n+        AEAD aead;\n+\n+        byte[] suite_id;\n+        String kdfAlg;\n+        int kdfNh;\n+\n+        class Context {\n+            final SecretKey k; \/\/ null if only export\n+            final byte[] base_nonce;\n+            final SecretKey exporter_secret;\n+\n+            byte[] seq = new byte[aead.Nn];\n+\n+            public Context(SecretKey sk, byte[] base_nonce,\n+                    SecretKey exporter_secret) {\n+                this.k = sk;\n+                this.base_nonce = base_nonce;\n+                this.exporter_secret = exporter_secret;\n+            }\n+\n+            SecretKey Export(byte[] exporter_context, String algorithm, int L) {\n+                try {\n+                    var kdf = KDF.getInstance(kdfAlg);\n+                    return kdf.deriveKey(algorithm, DHKEM.labeledExpand(\n+                            exporter_secret, suite_id, SEC, exporter_context, L));\n+                } catch (InvalidAlgorithmParameterException | NoSuchAlgorithmException e) {\n+                    \/\/ algorithm not accepted by HKDF, L too big or too small\n+                    throw new IllegalArgumentException(\"Invalid input\", e);\n+                }\n+            }\n+\n+            private byte[] ComputeNonce() {\n+                var result = new byte[aead.Nn];\n+                for (var i = 0; i < result.length; i++) {\n+                    result[i] = (byte)(seq[i] ^ base_nonce[i]);\n+                }\n+                return result;\n+            }\n+\n+            private void IncrementSeq() {\n+                for (var i = seq.length - 1; i >= 0; i--) {\n+                    if ((seq[i] & 0xff) == 0xff) {\n+                        seq[i] = 0;\n+                    } else {\n+                        seq[i]++;\n+                        return;\n+                    }\n+                }\n+                \/\/ seq >= (1 << (8*aead.Nn)) - 1 when this method is called\n+                throw new ProviderException(\"MessageLimitReachedError\");\n+            }\n+        }\n+\n+        public Impl(int opmode) {\n+            this.opmode = opmode;\n+        }\n+\n+        public boolean hasEncrypt() {\n+            return params.aead_id() != 65535;\n+        }\n+\n+        \/\/ Section 7.2.1 of RFC 9180 has restrictions on size of psk, psk_id,\n+        \/\/ info, and exporter_context (~2^61 for HMAC-SHA256 and ~2^125 for\n+        \/\/ HMAC-SHA384 and HMAC-SHA512). This method does not pose any\n+        \/\/ restrictions.\n+        public void init(AsymmetricKey key, HPKEParameterSpec p, SecureRandom rand)\n+                throws InvalidKeyException, InvalidAlgorithmParameterException {\n+            if (opmode != Cipher.ENCRYPT_MODE && opmode != Cipher.DECRYPT_MODE) {\n+                throw new UnsupportedOperationException(\n+                        \"Can only be used for encryption and decryption\");\n+            }\n+            setParams(key, p);\n+            SecretKey shared_secret;\n+            if (opmode == Cipher.ENCRYPT_MODE) {\n+                if (!(key instanceof PublicKey pk)) {\n+                    throw new InvalidKeyException(\n+                            \"Cannot encrypt with private key\");\n+                }\n+                if (p.encapsulation() != null) {\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"Must not provide key encapsulation message on sender side\");\n+                }\n+                checkMatch(pk, params.kem_id());\n+                KEM.Encapsulated enc;\n+                if (p.authKey() == null) {\n+                    var e = kem().newEncapsulator(pk, rand);\n+                    enc = e.encapsulate();\n+                } else if (p.authKey() instanceof PrivateKey skS) {\n+                    \/\/ AuthEncap not public KEM API but it's internally supported\n+                    var e = new DHKEM().engineNewAuthEncapsulator(pk, skS, null, rand);\n+                    enc = e.engineEncapsulate(0, e.engineSecretSize(), \"Generic\");\n+                } else {\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"Cannot auth with public key\");\n+                }\n+                params = params.encapsulation(enc.encapsulation());\n+                shared_secret = enc.key();\n+            } else {\n+                if (!(key instanceof PrivateKey sk)) {\n+                    throw new InvalidKeyException(\"Cannot decrypt with public key\");\n+                }\n+                checkMatch(sk, params.kem_id());\n+                try {\n+                    var encap = p.encapsulation();\n+                    if (encap == null) {\n+                        throw new InvalidAlgorithmParameterException(\n+                                \"Must provide key encapsulation message on recipient side\");\n+                    }\n+                    if (p.authKey() == null) {\n+                        var d = kem().newDecapsulator(sk);\n+                        shared_secret = d.decapsulate(encap);\n+                    } else if (p.authKey() instanceof PublicKey pkS) {\n+                        \/\/ AuthDecap not public KEM API but it's internally supported\n+                        var d = new DHKEM().engineNewAuthDecapsulator(sk, pkS, null);\n+                        shared_secret = d.engineDecapsulate(\n+                                encap, 0, d.engineSecretSize(), \"Generic\");\n+                    } else {\n+                        throw new InvalidAlgorithmParameterException(\n+                                \"Cannot auth with private key\");\n+                    }\n+                } catch (DecapsulateException e) {\n+                    throw new InvalidAlgorithmParameterException(e);\n+                }\n+            }\n+\n+            var usePSK = usePSK(params.psk());\n+            int mode = params.authKey() == null ? (usePSK ? 1 : 0) : (usePSK ? 3 : 2);\n+            context = KeySchedule(mode, shared_secret,\n+                    params.info(),\n+                    params.psk(),\n+                    params.psk_id());\n+        }\n+\n+        private static void checkMatch(AsymmetricKey k, int kem_id)\n+                throws InvalidKeyException, InvalidAlgorithmParameterException {\n+            var p = k.getParams();\n+            if (p instanceof ECParameterSpec ecp) {\n+                if ((!ECUtil.equals(ecp, CurveDB.P_256)\n+                        || kem_id != HPKEParameterSpec.KEM_DHKEM_P_256_HKDF_SHA256)\n+                        && (!ECUtil.equals(ecp, CurveDB.P_384)\n+                        || kem_id != HPKEParameterSpec.KEM_DHKEM_P_384_HKDF_SHA384)\n+                        && (!ECUtil.equals(ecp, CurveDB.P_521)\n+                        || kem_id != HPKEParameterSpec.KEM_DHKEM_P_521_HKDF_SHA512)) {\n+                    var name = ECUtil.getCurveName(ecp);\n+                    throw new InvalidAlgorithmParameterException(\n+                            name + \" does not match \" + kem_id);\n+                }\n+            } else if (p instanceof NamedParameterSpec ns) {\n+                var name = ns.getName();\n+                if ((!name.equalsIgnoreCase(\"x25519\")\n+                        || kem_id != HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256)\n+                        && (!name.equalsIgnoreCase(\"x448\")\n+                        || kem_id != HPKEParameterSpec.KEM_DHKEM_X448_HKDF_SHA512)) {\n+                    throw new InvalidAlgorithmParameterException(\n+                            name + \" does not match \" + kem_id);\n+                }\n+            } else {\n+                throw new InvalidKeyException(\n+                        k.getClass() + \" does not match \" + kem_id);\n+            }\n+        }\n+\n+        private KEM kem() {\n+            try {\n+                return KEM.getInstance(\"DHKEM\");\n+            } catch (NoSuchAlgorithmException e) {\n+                throw new ProviderException(\"Internal error\", e);\n+            }\n+        }\n+\n+        private int kemIdFromKey(AsymmetricKey k) throws InvalidKeyException {\n+            var p = k.getParams();\n+            if (p instanceof ECParameterSpec ecp) {\n+                if (ECUtil.equals(ecp, CurveDB.P_256)) {\n+                    return HPKEParameterSpec.KEM_DHKEM_P_256_HKDF_SHA256;\n+                } else if (ECUtil.equals(ecp, CurveDB.P_384)) {\n+                    return HPKEParameterSpec.KEM_DHKEM_P_384_HKDF_SHA384;\n+                } else if (ECUtil.equals(ecp, CurveDB.P_521)) {\n+                    return HPKEParameterSpec.KEM_DHKEM_P_521_HKDF_SHA512;\n+                }\n+            } else if (p instanceof NamedParameterSpec ns) {\n+                if (ns.getName().equalsIgnoreCase(\"X25519\")) {\n+                    return HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256;\n+                } else if (ns.getName().equalsIgnoreCase(\"X448\")) {\n+                    return HPKEParameterSpec.KEM_DHKEM_X448_HKDF_SHA512;\n+                }\n+            }\n+            throw new InvalidKeyException(\"Unsupported key\");\n+        }\n+\n+        private void setParams(AsymmetricKey key, HPKEParameterSpec p)\n+                throws InvalidKeyException, InvalidAlgorithmParameterException {\n+            if (p.kem_id() == -1 || p.kdf_id() == -1 || p.aead_id() == -1) {\n+                if (opmode == Cipher.DECRYPT_MODE) {\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"Algorithm identifiers must be provided on receiver\");\n+                }\n+                var kem_id = p.kem_id() != -1\n+                        ? p.kem_id()\n+                        : kemIdFromKey(key);\n+                var kdf_id = p.kdf_id() != -1\n+                        ? p.kdf_id()\n+                        : switch (kem_id) {\n+                    case HPKEParameterSpec.KEM_DHKEM_P_256_HKDF_SHA256,\n+                         HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256\n+                            -> HPKEParameterSpec.KDF_HKDF_SHA256;\n+                    case HPKEParameterSpec.KEM_DHKEM_P_384_HKDF_SHA384\n+                            -> HPKEParameterSpec.KDF_HKDF_SHA384;\n+                    case HPKEParameterSpec.KEM_DHKEM_P_521_HKDF_SHA512,\n+                         HPKEParameterSpec.KEM_DHKEM_X448_HKDF_SHA512\n+                            -> HPKEParameterSpec.KDF_HKDF_SHA512;\n+                    default -> throw new InvalidAlgorithmParameterException(\n+                            \"Unsupported kem_id: \" + params.kem_id());\n+                };\n+                var aead_id = p.aead_id() != -1\n+                        ? p.aead_id()\n+                        : HPKEParameterSpec.AEAD_AES_256_GCM;\n+                params = HPKEParameterSpec.of(kem_id, kdf_id, aead_id)\n+                        .info(p.info())\n+                        .psk(p.psk(), p.psk_id())\n+                        .authKey(p.authKey())\n+                        .encapsulation(p.encapsulation());\n+            } else {\n+                params = p;\n+            }\n+            suite_id = concat(\n+                    HPKE,\n+                    DHKEM.I2OSP(params.kem_id(), 2),\n+                    DHKEM.I2OSP(params.kdf_id(), 2),\n+                    DHKEM.I2OSP(params.aead_id(), 2));\n+            kdfAlg = switch (params.kdf_id()) {\n+                case HPKEParameterSpec.KDF_HKDF_SHA256 -> \"HKDF-SHA256\";\n+                case HPKEParameterSpec.KDF_HKDF_SHA384 -> \"HKDF-SHA384\";\n+                case HPKEParameterSpec.KDF_HKDF_SHA512 -> \"HKDF-SHA512\";\n+                default -> throw new InvalidAlgorithmParameterException(\n+                        \"Unsupported kdf_id: \" + params.kdf_id());\n+            };\n+            kdfNh = switch (params.kdf_id()) {\n+                case HPKEParameterSpec.KDF_HKDF_SHA256 -> 32;\n+                case HPKEParameterSpec.KDF_HKDF_SHA384 -> 48;\n+                case HPKEParameterSpec.KDF_HKDF_SHA512 -> 64;\n+                default -> throw new InvalidAlgorithmParameterException(\n+                        \"Unsupported kdf_id: \" + params.kdf_id());\n+            };\n+            aead = new AEAD(params.aead_id());\n+        }\n+\n+        private Context KeySchedule(int mode,\n+                SecretKey shared_secret,\n+                byte[] info,\n+                SecretKey psk,\n+                byte[] psk_id) {\n+            try {\n+                var psk_id_hash_x = DHKEM.labeledExtract(suite_id, PSK_ID_HASH)\n+                        .addIKM(psk_id).extractOnly();\n+                var info_hash_x = DHKEM.labeledExtract(suite_id, INFO_HASH)\n+                        .addIKM(info).extractOnly();\n+\n+                \/\/ deriveData must and can be called because all info to\n+                \/\/ thw builder are just byte arrays. Any KDF impl can handle this.\n+                var kdf = KDF.getInstance(kdfAlg);\n+                var key_schedule_context = concat(new byte[]{(byte) mode},\n+                        kdf.deriveData(psk_id_hash_x),\n+                        kdf.deriveData(info_hash_x));\n+\n+                var secret_x_builder = DHKEM.labeledExtract(suite_id, SECRET);\n+                if (psk != null) {\n+                    secret_x_builder.addIKM(psk);\n+                }\n+                secret_x_builder.addSalt(shared_secret);\n+\n+                \/\/ A new KDF object must be created because secret_x_builder\n+                \/\/ might contain provider-specific keys which the previous\n+                \/\/ KDF (provider already chosen) cannot handle.\n+                kdf = KDF.getInstance(kdfAlg);\n+                var exporter_secret = kdf.deriveKey(\"Generic\", DHKEM.labeledExpand(\n+                        secret_x_builder, suite_id, EXP, key_schedule_context, kdfNh));\n+\n+                if (hasEncrypt()) {\n+                    \/\/ ChaCha20-Poly1305 does not care about algorithm name\n+                    var key = kdf.deriveKey(\"AES\", DHKEM.labeledExpand(secret_x_builder,\n+                            suite_id, KEY, key_schedule_context, aead.Nk));\n+                    \/\/ deriveData must be called because we need to increment nonce\n+                    var base_nonce = kdf.deriveData(DHKEM.labeledExpand(secret_x_builder,\n+                            suite_id, BASE_NONCE, key_schedule_context, aead.Nn));\n+                    return new Context(key, base_nonce, exporter_secret);\n+                } else {\n+                    return new Context(null, null, exporter_secret);\n+                }\n+            } catch (InvalidAlgorithmParameterException\n+                     | NoSuchAlgorithmException | UnsupportedOperationException e) {\n+                throw new ProviderException(\"Internal error\", e);\n+            }\n+        }\n+    }\n+\n+    private static boolean usePSK(SecretKey psk) {\n+        return psk != null;\n+    }\n+\n+    private static byte[] concat(byte[]... inputs) {\n+        var o = new ByteArrayOutputStream();\n+        Arrays.stream(inputs).forEach(o::writeBytes);\n+        return o.toByteArray();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HPKE.java","additions":612,"deletions":0,"binary":false,"changes":612,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import javax.crypto.spec.HPKEParameterSpec;\n+import java.io.IOException;\n+import java.security.AlgorithmParametersSpi;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+\n+\/**\n+ * This AlgorithmParametersSpi only supports HPKEParameterSpec.\n+ * There is no ASN.1 format defined.\n+ *\/\n+public class HPKEParameters extends AlgorithmParametersSpi {\n+\n+    private HPKEParameterSpec spec;\n+\n+    @Override\n+    protected void engineInit(AlgorithmParameterSpec paramSpec)\n+            throws InvalidParameterSpecException {\n+        if (!(paramSpec instanceof HPKEParameterSpec hspec)) {\n+            throw new InvalidParameterSpecException(\"Not an HPKEParameterSpec\");\n+        }\n+        this.spec = hspec;\n+    }\n+\n+    @Override\n+    protected void engineInit(byte[] params) throws IOException {\n+        throw new IOException(\n+                \"HPKE does not support parameters as a byte array.\");\n+    }\n+\n+    @Override\n+    protected void engineInit(byte[] params, String format) throws IOException {\n+        throw new IOException(\n+                \"HPKE does not support parameters as a byte array.\");\n+    }\n+\n+    @Override\n+    protected <T extends AlgorithmParameterSpec> T engineGetParameterSpec(\n+            Class<T> paramSpec) throws InvalidParameterSpecException {\n+\n+        if (paramSpec.isAssignableFrom(HPKEParameterSpec.class)) {\n+            return paramSpec.cast(spec);\n+        }\n+        throw new InvalidParameterSpecException(\n+                \"Only HPKEParameterSpec supported.\");\n+    }\n+\n+    @Override\n+    protected byte[] engineGetEncoded() throws IOException {\n+        throw new IOException(\n+                \"HPKE does not support parameters as a byte array.\");\n+    }\n+\n+    @Override\n+    protected byte[] engineGetEncoded(String format) throws IOException {\n+        throw new IOException(\n+                \"HPKE does not support parameters as a byte array.\");\n+    }\n+\n+    @Override\n+    protected String engineToString() {\n+        return \"HPKE\";\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HPKEParameters.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -370,0 +370,4 @@\n+        ps(\"Cipher\", \"HPKE\", \"com.sun.crypto.provider.HPKE\");\n+        ps(\"AlgorithmParameters\", \"HPKE\", \"com.sun.crypto.provider.HPKEParameters\");\n+\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,443 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javax.crypto.spec;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.Key;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Objects;\n+\n+\/**\n+ * This immutable class specifies the set of parameters used with a {@code Cipher} for the\n+ * <a href=\"https:\/\/www.rfc-editor.org\/info\/rfc9180\">Hybrid Public Key Encryption<\/a>\n+ * (HPKE) algorithm. The <a href=\n+ * \"{@docRoot}\/..\/specs\/security\/standard-names.html#cipher-algorithms\">\n+ * standard algorithm name<\/a> for the cipher is \"HPKE\".\n+ * <p>\n+ * In HPKE, the sender's {@code Cipher} is always initialized with the\n+ * recipient's public key in {@linkplain Cipher#ENCRYPT_MODE encrypt mode},\n+ * while the recipient's {@code Cipher} object is initialized with its own\n+ * private key in {@linkplain Cipher#DECRYPT_MODE decrypt mode}.\n+ * <p>\n+ * An {@code HPKEParameterSpec} object can be provided at HPKE\n+ * {@linkplain Cipher#init(int, Key, AlgorithmParameterSpec) cipher initialization}.\n+ * <p>\n+ * An {@code HPKEParameterSpec} object can be created in two ways:\n+ * <ul>\n+ * <li> {@link #of()} creates an instance with unspecified KEM, KDF, and AEAD\n+ * algorithms, which will be determined by the implementation based on the key\n+ * provided to {@code init()}. This instance can only be used by the sender.\n+ * <li> {@link #of(int, int, int)} creates an instance with explicitly\n+ * specified KEM, KDF, and AEAD algorithm identifiers. This instance can be\n+ * used by both the sender and the receiver.\n+ * <\/ul>\n+ * The terms \"KEM algorithm identifiers\", \"KDF algorithm identifiers\", and\n+ * \"AEAD algorithm identifiers\" refer to their respective numeric values\n+ * (specifically, {@code kem_id}, {@code kdf_id}, and {@code aead_id}) as\n+ * defined in <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#section-7\">Section 7<\/a>\n+ * of RFC 9180 and the\n+ * <a href=\"https:\/\/www.iana.org\/assignments\/hpke\/hpke.xhtml\">IANA HPKE page<\/a>.\n+ * This class has defined constants for the standard algorithm identifiers.\n+ * For example, {@link #KEM_DHKEM_P_256_HKDF_SHA256}, {@link #KDF_HKDF_SHA256},\n+ * and {@link #AEAD_AES_128_GCM}.\n+ * <p>\n+ * Once an {@code HPKEParameterSpec} object is created, additional methods\n+ * are available to generate new {@code HPKEParameterSpec} objects with\n+ * different features:\n+ * <ul>\n+ * <li>\n+ * Application-supplied information can be provided using the\n+ * {@link #info(byte[])} method by both sides.\n+ * <li>\n+ * If HPKE modes {@code mode_auth} or {@code mode_auth_psk} are used,\n+ * the asymmetric keys for authentication must be provided using the\n+ * {@link #authKey(Key)} method. Precisely, the sender must call this method\n+ * with its own private key and the recipient must call it with the sender's\n+ * public key.\n+ * <li>\n+ * If HPKE modes {@code mode_psk} or {@code mode_auth_psk} are used,\n+ * the pre-shared key for authentication and its identifier must be provided\n+ * using the {@link #psk(SecretKey, byte[])} method by both sides.\n+ * <li>\n+ * In HPKE, a shared secret is negotiated during the KEM step and a key\n+ * encapsulation message must be transmitted from the sender to the recipient\n+ * so that the recipient can recover this shared secret. On the sender side,\n+ * after the cipher is initialized, the key encapsulation message can be\n+ * retrieved directly using the {@link Cipher#getIV()} method, or from the\n+ * {@code HPKEParameterSpec} object contained in the returned value of the\n+ * {@link Cipher#getParameters} method. On the recipient side, the key\n+ * encapsulation message must be provided using the {@link #encapsulation(byte[])}\n+ * method.\n+ * <\/ul>\n+ * For successful interoperability, both sides need to supply identical\n+ * {@code info}, {@code psk}, and {@code psk_id} or matching authentication\n+ * keys if provided. For details about HPKE modes, refer to\n+ * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#section-5\">Section 5<\/a>\n+ * of RFC 9180.\n+ * <p>\n+ * If the sender cipher is initialized without parameters, it assumes a\n+ * default parameters object is used, which is equivalent to\n+ * {@code HPKEParameterSpec.of()}. In this case, the\n+ * cipher always works in {@code mode_base} mode with an empty {@code info}.\n+ * If the recipient side is initialized without parameters, an\n+ * {@code InvalidKeyException} will be thrown.\n+ * <p>\n+ * At HPKE cipher initialization, if no HPKE implementation supports the provided\n+ * key type, an {@code InvalidKeyException} should be thrown. If an\n+ * {@code HPKEParameterSpec} is provided but it is not supported by any HPKE\n+ * implementation, an {@code InvalidAlgorithmParameterException} will be thrown.\n+ * For example:\n+ * <ul>\n+ * <li> The algorithm identifiers do not match the provided key type.\n+ * <li> The algorithm identifiers are not specified on the receiver side.\n+ * <li> An attempt to use {@code authKey(key)} is made with an incompatible key.\n+ * <li> An attempt to use {@code authKey(key)} is made but the selected KEM\n+ *      does not support authentication.\n+ * <\/ul>\n+ * <p>\n+ * After an HPKE cipher is initialized, the {@link Cipher#getParameters} method\n+ * returns an {@link java.security.AlgorithmParameters} object containing the\n+ * actual {@code HPKEParameterSpec} object used by the cipher. Users can call\n+ * {@link #kem_id()}, {@link #kdf_id()}, and {@link #aead_id()} on the\n+ * {@code HPKEParameterSpec} object to obtain the algorithm identifiers\n+ * selected during initialization. On the sender side, the key encapsulation\n+ * message is also included in this {@code HPKEParameterSpec} object,\n+ * even if it was not provided to the cipher initialization.\n+ * <p>\n+ * Example:\n+ * {@snippet lang=java class=\"PackageSnippets\" region=\"hpke-spec-example\"}\n+ *\n+ * @implNote\n+ * In the HPKE implementation in the SunJCE provider included in this JDK\n+ * implementation, if the sender's HPKE cipher is initialized with\n+ * {@code HPKEParameterSpec.of()}, the following KEM, KDF, and AEAD algorithm\n+ * identifiers will be chosen depending on the provided key type and returned\n+ * by the {@code getParameters} method:\n+ * <table class=\"striped\">\n+ * <caption style=\"display:none\">Default Algorithm Identifiers<\/caption>\n+ * <thead>\n+ * <tr><th scope=\"col\">key type\n+ *     <th scope=\"col\">{@code kem_id}\n+ *     <th scope=\"col\">{@code kdf_id}\n+ *     <th scope=\"col\">{@code aead_id}\n+ * <\/thead>\n+ * <tbody>\n+ * <tr><td>EC (secp256r1)\n+ *     <td>{@link #KEM_DHKEM_P_256_HKDF_SHA256}\n+ *     <td>{@link #KDF_HKDF_SHA256}\n+ *     <td rowspan=\"5\">{@link #AEAD_AES_256_GCM}\n+ * <tr><td>EC (secp384r1)\n+ *     <td>{@link #KEM_DHKEM_P_384_HKDF_SHA384}\n+ *     <td>{@link #KDF_HKDF_SHA384}\n+ * <tr><td>EC (secp521r1)\n+ *     <td>{@link #KEM_DHKEM_P_521_HKDF_SHA512}\n+ *     <td>{@link #KDF_HKDF_SHA512}\n+ * <tr><td>XDH (X25519)\n+ *     <td>{@link #KEM_DHKEM_X25519_HKDF_SHA256}\n+ *     <td>{@link #KDF_HKDF_SHA256}\n+ * <tr><td>XDH (X448)\n+ *     <td>{@link #KEM_DHKEM_X448_HKDF_SHA512}\n+ *     <td>{@link #KDF_HKDF_SHA512}\n+ * <\/tbody>\n+ * <\/table>\n+ * No other keys are supported.\n+ *\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc9180\n+ *      RFC 9180: Hybrid Public Key Encryption\n+ * @spec security\/standard-names.html\n+ *      Java Security Standard Algorithm Names\n+ * @since 25\n+ *\/\n+public final class HPKEParameterSpec implements AlgorithmParameterSpec {\n+\n+    \/**\n+     * KEM algorithm identifier for DHKEM(P-256, HKDF-SHA256) as defined in\n+     * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#name-key-encapsulation-mechanism\">Section 7.1 of RFC 9180<\/a>.\n+     *\/\n+    public static final int KEM_DHKEM_P_256_HKDF_SHA256 = 0x10;\n+\n+    \/**\n+     * KEM algorithm identifier for DHKEM(P-384, HKDF-SHA384) as defined in\n+     * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#name-key-encapsulation-mechanism\">Section 7.1 of RFC 9180<\/a>.\n+     *\/\n+    public static final int KEM_DHKEM_P_384_HKDF_SHA384 = 0x11;\n+\n+    \/**\n+     * KEM algorithm identifier for DHKEM(P-521, HKDF-SHA512) as defined in\n+     * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#name-key-encapsulation-mechanism\">Section 7.1 of RFC 9180<\/a>.\n+     *\/\n+    public static final int KEM_DHKEM_P_521_HKDF_SHA512 = 0x12;\n+\n+    \/**\n+     * KEM algorithm identifier for DHKEM(X25519, HKDF-SHA256) as defined in\n+     * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#name-key-encapsulation-mechanism\">Section 7.1 of RFC 9180<\/a>.\n+     *\/\n+    public static final int KEM_DHKEM_X25519_HKDF_SHA256 = 0x20;\n+\n+    \/**\n+     * KEM algorithm identifier for DHKEM(X448, HKDF-SHA512) as defined in\n+     * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#name-key-encapsulation-mechanism\">Section 7.1 of RFC 9180<\/a>.\n+     *\/\n+    public static final int KEM_DHKEM_X448_HKDF_SHA512 = 0x21;\n+\n+    \/**\n+     * KDF algorithm identifier for HKDF-SHA256 as defined in\n+     * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#name-key-derivation-functions-kd\">Section 7.2 of RFC 9180<\/a>.\n+     *\/\n+    public static final int KDF_HKDF_SHA256 = 0x1;\n+\n+    \/**\n+     * KDF algorithm identifier for HKDF-SHA384 as defined in\n+     * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#name-key-derivation-functions-kd\">Section 7.2 of RFC 9180<\/a>.\n+     *\/\n+    public static final int KDF_HKDF_SHA384 = 0x2;\n+\n+    \/**\n+     * KDF algorithm identifier for HKDF-SHA512 as defined in\n+     * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#name-key-derivation-functions-kd\">Section 7.2 of RFC 9180<\/a>.\n+     *\/\n+    public static final int KDF_HKDF_SHA512 = 0x3;\n+\n+    \/**\n+     * AEAD algorithm identifier for AES-128-GCM as defined in\n+     * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#name-authenticated-encryption-wi\">Section 7.3 of RFC 9180<\/a>.\n+     *\/\n+    public static final int AEAD_AES_128_GCM = 0x1;\n+\n+    \/**\n+     * AEAD algorithm identifier for AES-256-GCM as defined in\n+     * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#name-authenticated-encryption-wi\">Section 7.3 of RFC 9180<\/a>.\n+     *\/\n+    public static final int AEAD_AES_256_GCM = 0x2;\n+\n+    \/**\n+     * AEAD algorithm identifier for ChaCha20Poly1305 as defined in\n+     * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#name-authenticated-encryption-wi\">Section 7.3 of RFC 9180<\/a>.\n+     *\/\n+    public static final int AEAD_CHACHA20_POLY1305 = 0x3;\n+\n+    \/**\n+     * AEAD algorithm identifier for Export-only as defined in\n+     * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#name-authenticated-encryption-wi\">Section 7.3 of RFC 9180<\/a>.\n+     *\/\n+    public static final int EXPORT_ONLY = 0xffff;\n+\n+    private final int kem_id; \/\/ -1 is determined by key later\n+    private final int kdf_id; \/\/ -1 is determined by key later\n+    private final int aead_id; \/\/ -1 is determined by key later\n+    private final byte[] info; \/\/ never null, can be empty\n+    private final SecretKey psk; \/\/ null if not used\n+    private final byte[] psk_id; \/\/ never null, can be empty\n+    private final Key kS; \/\/ null if not used\n+    private final byte[] encapsulation; \/\/ null if none\n+\n+    \/\/ Note: this constructor does not clone array arguments.\n+    private HPKEParameterSpec(int kem_id, int kdf_id, int aead_id, byte[] info,\n+            SecretKey psk, byte[] psk_id, Key kS, byte[] encapsulation) {\n+        this.kem_id = kem_id;\n+        this.kdf_id = kdf_id;\n+        this.aead_id = aead_id;\n+        this.info = info;\n+        this.psk = psk;\n+        this.psk_id = psk_id;\n+        this.kS = kS;\n+        this.encapsulation = encapsulation;\n+    }\n+\n+    \/**\n+     * A factory method to create an empty {@code HPKEParameterSpec} in\n+     * {@code mode_base} mode with an empty {@code info}. The KEM, KDF,\n+     * and AEAD algorithm identifiers are not specified and will be\n+     * determined by the key used in cipher initialization.\n+     *\n+     * @return a new {@code HPKEParameterSpec} object\n+     *\/\n+    public static HPKEParameterSpec of() {\n+        return new HPKEParameterSpec(-1, -1, -1,\n+                new byte[0], null, new byte[0], null, null);\n+    }\n+\n+    \/**\n+     * A factory method to create a new {@code HPKEParameterSpec} object with\n+     * specified KEM, KDF, and AEAD algorithm identifiers in {@code mode_base}\n+     * mode with an empty {@code info}.\n+     *\n+     * @param kem_id identifier for KEM, must be between 0 and 65535 (inclusive)\n+     * @param kdf_id identifier for KDF, must be between 0 and 65535 (inclusive)\n+     * @param aead_id identifier for AEAD, must be between 0 and 65535 (inclusive)\n+     * @return a new {@code HPKEParameterSpec} object\n+     * @throws IllegalArgumentException if any input value\n+     *      is out of range (must be between 0 and 65535, inclusive).\n+     *\/\n+    public static HPKEParameterSpec of(int kem_id, int kdf_id, int aead_id) {\n+        if (kem_id < 0 || kem_id > 65535) {\n+            throw new IllegalArgumentException(\"Invalid kem_id: \" + kem_id);\n+        }\n+        if (kdf_id < 0 || kdf_id > 65535) {\n+            throw new IllegalArgumentException(\"Invalid kdf_id: \" + kdf_id);\n+        }\n+        if (aead_id < 0 || aead_id > 65535) {\n+            throw new IllegalArgumentException(\"Invalid aead_id: \" + aead_id);\n+        }\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                new byte[0], null, new byte[0], null, null);\n+    }\n+\n+    \/**\n+     * Creates a new {@code HPKEParameterSpec} object with a different\n+     * {@code info} value.\n+     * <p>\n+     * For interoperability, RFC 9180 Section 7.2.1 recommends limiting\n+     * this value to a maximum of 64 bytes.\n+     *\n+     * @param info application-supplied information. Must not be {@code null}.\n+     *      If set to empty, the previous info is cleared.\n+     *      The contents of the array are copied to protect\n+     *      against subsequent modification.\n+     * @return a new {@code HPKEParameterSpec} object\n+     * @throws NullPointerException if {@code info} is {@code null}\n+     *\/\n+    public HPKEParameterSpec info(byte[] info) {\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                Objects.requireNonNull(info).clone(), psk, psk_id, kS, encapsulation);\n+    }\n+\n+    \/**\n+     * Creates a new {@code HPKEParameterSpec} object with different\n+     * {@code psk} value and {@code psk_id} values.\n+     * <p>\n+     * For interoperability, RFC 9180 Section 7.2.1 recommends limiting both\n+     * values to a maximum of 64 bytes.\n+     *\n+     * @param psk pre-shared key. Set to {@code null} if no pre-shared key is used.\n+     * @param psk_id identifier for PSK. Set to empty if no pre-shared key is used.\n+     *               Must not be {@code null}. The contents of the array are copied\n+     *               to protect against subsequent modification.\n+     * @return a new {@code HPKEParameterSpec} object\n+     * @throws NullPointerException if {@code psk_id} is {@code null}\n+     * @throws InvalidAlgorithmParameterException if {@code psk} and {@code psk_id} are\n+     *      not consistent, i.e. {@code psk} is not {@code null} but\n+     *      {@code psk_id} is empty, or {@code psk} is {@code null} but\n+     *      {@code psk_id} is not empty.\n+     *\/\n+    public HPKEParameterSpec psk(SecretKey psk, byte[] psk_id)\n+            throws InvalidAlgorithmParameterException {\n+        Objects.requireNonNull(psk_id);\n+        if (psk == null && psk_id.length != 0\n+                || psk != null && psk_id.length == 0) {\n+            throw new InvalidAlgorithmParameterException(\"psk and psk_id do not match\");\n+        }\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                info, psk, psk_id.clone(), kS, encapsulation);\n+    }\n+\n+    \/**\n+     * Creates a new {@code HPKEParameterSpec} object with a different\n+     * key encapsulation message value that will be used by the recipient.\n+     *\n+     * @param encapsulation the key encapsulation message. If set to\n+     *      {@code null}, the previous key encapsulation message is cleared.\n+     *      The contents of the array are copied to protect against\n+     *      subsequent modification.\n+     *\n+     * @return a new {@code HPKEParameterSpec} object\n+     *\/\n+    public HPKEParameterSpec encapsulation(byte[] encapsulation) {\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                info, psk, psk_id, kS,\n+                encapsulation == null ? null : encapsulation.clone());\n+    }\n+\n+    \/**\n+     * Creates a new {@code HPKEParameterSpec} object with a different\n+     * authentication key value.\n+     *\n+     * @param kS the authentication key. If set to {@code null}, the previous\n+     *          authentication key is cleared.\n+     * @return a new {@code HPKEParameterSpec} object\n+     *\/\n+    public HPKEParameterSpec authKey(Key kS) {\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                info, psk, psk_id, kS, encapsulation);\n+    }\n+\n+    \/**\n+     * {@return the identifier for KEM, -1 if unspecified}\n+     *\/\n+    public int kem_id() {\n+        return kem_id;\n+    }\n+\n+    \/**\n+     * {@return the identifier for KDF, -1 if unspecified}\n+     *\/\n+    public int kdf_id() {\n+        return kdf_id;\n+    }\n+\n+    \/**\n+     * {@return the identifier for AEAD, -1 if unspecified}\n+     *\/\n+    public int aead_id() {\n+        return aead_id;\n+    }\n+\n+    \/**\n+     * {@return a copy of the application-supplied information, empty if none}\n+     *\/\n+    public byte[] info() {\n+        return info.clone();\n+    }\n+\n+    \/**\n+     * {@return pre-shared key, {@code null} if none}\n+     *\/\n+    public SecretKey psk() {\n+        return psk;\n+    }\n+\n+    \/**\n+     * {@return a copy of the identifier for PSK, empty if none}\n+     *\/\n+    public byte[] psk_id() {\n+        return psk_id.clone();\n+    }\n+\n+    \/**\n+     * {@return the key for authentication, {@code null} if none}\n+     *\/\n+    public Key authKey() {\n+        return kS;\n+    }\n+\n+    \/**\n+     * {@return a copy of the key encapsulation message, {@code null} if none}\n+     *\/\n+    public byte[] encapsulation() {\n+        return encapsulation == null ? null : encapsulation.clone();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/HPKEParameterSpec.java","additions":443,"deletions":0,"binary":false,"changes":443,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.HPKEParameterSpec;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.util.Arrays;\n+\n+class PackageSnippets {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ @start region=\"hpke-spec-example\"\n+        \/\/ Key pair generation\n+        KeyPairGenerator g = KeyPairGenerator.getInstance(\"X25519\");\n+        KeyPair kp = g.generateKeyPair();\n+\n+        \/\/ The HPKE sender side is initialized with the recipient's public key\n+        \/\/ and default HPKEParameterSpec with an application-supplied info.\n+        Cipher sender = Cipher.getInstance(\"HPKE\");\n+        HPKEParameterSpec ps = HPKEParameterSpec.of()\n+                .info(\"app_info\".getBytes(StandardCharsets.UTF_8));\n+        sender.init(Cipher.ENCRYPT_MODE, kp.getPublic(), ps);\n+\n+        \/\/ Retrieve the actual parameters used from the sender.\n+        HPKEParameterSpec actual = sender.getParameters()\n+                .getParameterSpec(HPKEParameterSpec.class);\n+\n+        \/\/ Retrieve the key encapsulation message (the KEM output) from the sender.\n+        \/\/ It can also be retrieved using sender.getIV().\n+        byte[] kemEncap = actual.encapsulation();\n+\n+        \/\/ The HPKE recipient side is initialized with its own private key,\n+        \/\/ the same algorithm identifiers as used by the sender,\n+        \/\/ and the key encapsulation message from the sender\n+        Cipher recipient = Cipher.getInstance(\"HPKE\");\n+        HPKEParameterSpec pr = HPKEParameterSpec\n+                .of(actual.kem_id(), actual.kdf_id(), actual.aead_id())\n+                .info(\"app_info\".getBytes(StandardCharsets.UTF_8))\n+                .encapsulation(kemEncap);\n+        recipient.init(Cipher.DECRYPT_MODE, kp.getPrivate(), pr);\n+\n+        \/\/ Secure communication between the 2 sides\n+        byte[] msg = \"Hello World\".getBytes(StandardCharsets.UTF_8);\n+        byte[] ct = sender.doFinal(msg);\n+        byte[] pt = recipient.doFinal(ct);\n+\n+        assert Arrays.equals(msg, pt);\n+        \/\/ @end\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/snippet-files\/PackageSnippets.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.security.util;\n+\n+import javax.crypto.SecretKey;\n+\n+\/**\n+ * An interface for <code>SecretKey<\/code>s that support using its slice as a new\n+ * <code>SecretKey<\/code>\n+ * <p>\n+ * This is mainly used by PKCS #11 implementations that support the\n+ * EXTRACT_KEY_FROM_KEY mechanism even if the key itself is sensitive\n+ * and non-extractable.\n+ *\/\n+public interface SliceableSecretKey {\n+\n+    \/**\n+     * Returns a slice as a new <code>SecretKey<\/code>.\n+     *\n+     * @param alg the new algorithm name\n+     * @param from the byte offset of the new key in the full key\n+     * @param to the to offset (exclusive) of the new key in the full key\n+     * @return the new key\n+     * @throws ArrayIndexOutOfBoundsException for improper <code>from<\/code>\n+     *      and <code>to<\/code> values\n+     * @throws UnsupportedOperationException if slicing is not supported\n+     *\/\n+    SecretKey slice(String alg, int from, int to);\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SliceableSecretKey.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,270 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.HPKEParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+\n+import static javax.crypto.spec.HPKEParameterSpec.AEAD_AES_256_GCM;\n+import static javax.crypto.spec.HPKEParameterSpec.EXPORT_ONLY;\n+import static javax.crypto.spec.HPKEParameterSpec.KDF_HKDF_SHA256;\n+import static javax.crypto.spec.HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256;\n+\n+\/*\n+ * @test\n+ * @bug 8325448\n+ * @library \/test\/lib\n+ * @summary HPKE compliance test\n+ *\/\n+public class Compliance {\n+    public static void main(String[] args) throws Exception {\n+\n+        var emptyParams = HPKEParameterSpec.of();\n+        var defaultParams = HPKEParameterSpec.of(\n+                KEM_DHKEM_X25519_HKDF_SHA256,\n+                KDF_HKDF_SHA256,\n+                AEAD_AES_256_GCM);\n+\n+        var kp = KeyPairGenerator.getInstance(\"X25519\").generateKeyPair();\n+        var info = \"info\".getBytes(StandardCharsets.UTF_8);\n+        var psk = new SecretKeySpec(new byte[32], \"ONE\");\n+        var psk_id = \"psk_id\".getBytes(StandardCharsets.UTF_8);\n+\n+        \/\/ HPKEParameterSpec\n+\n+        \/\/ Default values\n+        var spec = emptyParams;\n+        Asserts.assertEQ(spec.kem_id(), -1);\n+        Asserts.assertEQ(spec.kdf_id(), -1);\n+        Asserts.assertEQ(spec.aead_id(), -1);\n+        Asserts.assertEQ(spec.authKey(), null);\n+        Asserts.assertEQ(spec.encapsulation(), null);\n+        Asserts.assertEqualsByteArray(spec.info(), new byte[0]);\n+        Asserts.assertEQ(spec.psk(), null);\n+        Asserts.assertEqualsByteArray(spec.psk_id(), new byte[0]);\n+\n+        \/\/ Specified values\n+        var spec2 = HPKEParameterSpec.of(0, 0, 0);\n+        Asserts.assertEQ(spec2.kem_id(), 0);\n+        Asserts.assertEQ(spec2.kdf_id(), 0);\n+        Asserts.assertEQ(spec2.aead_id(), 0);\n+        Asserts.assertEQ(spec2.authKey(), null);\n+        Asserts.assertEQ(spec2.encapsulation(), null);\n+        Asserts.assertEqualsByteArray(spec2.info(), new byte[0]);\n+        Asserts.assertEQ(spec2.psk(), null);\n+        Asserts.assertEqualsByteArray(spec2.psk_id(), new byte[0]);\n+\n+        \/\/ identifiers must be in range\n+        HPKEParameterSpec.of(65535, 65535, 65535);\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> HPKEParameterSpec.of(-1, 0, 0));\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> HPKEParameterSpec.of(0, -1, 0));\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> HPKEParameterSpec.of(0, 0, -1));\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> HPKEParameterSpec.of(65536, 0, 0));\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> HPKEParameterSpec.of(0, 65536, 0));\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> HPKEParameterSpec.of(0, 0, 65536));\n+\n+        Asserts.assertTrue(spec.authKey(null).authKey() == null);\n+        Asserts.assertTrue(spec.authKey(kp.getPrivate()).authKey() != null);\n+        Asserts.assertTrue(spec.authKey(kp.getPublic()).authKey() != null);\n+        Asserts.assertTrue(spec.authKey(kp.getPrivate()).authKey(null).authKey() == null);\n+\n+        \/\/ Info can be empty but not null\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.info(null));\n+        Asserts.assertEqualsByteArray(spec.info(info).info(), info);\n+\n+        Asserts.assertTrue(spec.encapsulation(null).encapsulation() == null);\n+        Asserts.assertEqualsByteArray(spec.encapsulation(info).encapsulation(), info);\n+        Asserts.assertTrue(spec.encapsulation(info).encapsulation(null).encapsulation() == null);\n+\n+        \/\/ psk_id can be empty but not null\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.psk(psk, null));\n+\n+        \/\/ psk and psk_id must match\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class, () -> spec.psk(psk, new byte[0]));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class, () -> spec.psk(null, psk_id));\n+\n+        Asserts.assertEqualsByteArray(spec.psk(psk, psk_id).psk().getEncoded(), psk.getEncoded());\n+        Asserts.assertEqualsByteArray(spec.psk(psk, psk_id).psk_id(), psk_id);\n+        Asserts.assertTrue(spec.psk(null, new byte[0]).psk() == null);\n+        Asserts.assertEqualsByteArray(spec.psk(null, new byte[0]).psk_id(), new byte[0]);\n+\n+        \/\/ HPKE\n+        var c1 = Cipher.getInstance(\"HPKE\");\n+        var c2 = Cipher.getInstance(\"HPKE\");\n+\n+        \/\/ Still at BEGIN, not initialized\n+        Asserts.assertEQ(c1.getIV(), null);\n+        Asserts.assertEQ(c1.getParameters(), null);\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.getBlockSize());\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.getOutputSize(100));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.update(new byte[1]));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.update(new byte[1], 0, 1));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.updateAAD(new byte[1]));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.updateAAD(new byte[1], 0, 1));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.doFinal());\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.doFinal(new byte[1]));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.doFinal(new byte[1], 0, 1));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.doFinal(new byte[1], 0, 1, new byte[1024], 0));\n+\n+        \/\/ Simplest usages\n+        c1.init(Cipher.ENCRYPT_MODE, kp.getPublic());\n+        var encap = c1.getIV();\n+        c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                defaultParams.encapsulation(encap));\n+\n+        var params = c1.getParameters().getParameterSpec(HPKEParameterSpec.class);\n+        Asserts.assertEqualsByteArray(encap, params.encapsulation());\n+\n+        \/\/ Does not support WRAP and UNWRAP mode\n+        Asserts.assertThrows(UnsupportedOperationException.class,\n+                () -> c1.init(Cipher.WRAP_MODE, kp.getPublic()));\n+        Asserts.assertThrows(UnsupportedOperationException.class,\n+                () -> c1.init(Cipher.UNWRAP_MODE, kp.getPublic()));\n+\n+        \/\/ Cannot init sender with private key\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPrivate()));\n+\n+        \/\/ Cannot provide key encap msg to sender\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        emptyParams.encapsulation(new byte[32])));\n+\n+        \/\/ Cannot init recipient without algorithm identifiers\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate()));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                        emptyParams));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                        emptyParams.encapsulation(encap)));\n+\n+        \/\/ Cannot init recipient with public key\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPublic(),\n+                        defaultParams.encapsulation(encap)));\n+        \/\/ Must provide key encap msg to recipient\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(), defaultParams));\n+\n+        \/\/ Unsupported identifiers\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of(0, KDF_HKDF_SHA256, AEAD_AES_256_GCM)));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of(0x200, KDF_HKDF_SHA256, AEAD_AES_256_GCM)));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of(KEM_DHKEM_X25519_HKDF_SHA256, 4, AEAD_AES_256_GCM)));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of(KEM_DHKEM_X25519_HKDF_SHA256, KDF_HKDF_SHA256, 4)));\n+\n+        \/\/ No key encap msg for recipient (export only)\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                        HPKEParameterSpec.of(\n+                                KEM_DHKEM_X25519_HKDF_SHA256, KDF_HKDF_SHA256, EXPORT_ONLY)));\n+\n+        var aad = \"AAD\".getBytes(StandardCharsets.UTF_8);\n+\n+        \/\/ HPKE with encryption\n+        c1.init(Cipher.ENCRYPT_MODE, kp.getPublic());\n+        c1.getBlockSize();\n+        c1.getOutputSize(100);\n+        c1.updateAAD(aad);\n+        var ct = c1.doFinal(new byte[2]);\n+\n+        c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                defaultParams.encapsulation(c1.getIV()));\n+        c2.getBlockSize();\n+        c2.getOutputSize(100);\n+        c2.updateAAD(aad);\n+        Asserts.assertEqualsByteArray(c2.doFinal(ct), new byte[2]);\n+\n+        \/\/ info and psk\n+        checkEncryptDecrypt(kp,\n+                defaultParams.info(info).psk(psk, psk_id),\n+                defaultParams.info(info).psk(psk, psk_id));\n+\n+        var kp2 = KeyPairGenerator.getInstance(\"X25519\").generateKeyPair();\n+\n+        \/\/ mod_auth, wrong key type\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        defaultParams.authKey(kp2.getPublic())));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                        defaultParams.authKey(kp2.getPrivate())));\n+\n+        \/\/ mod_auth\n+        checkEncryptDecrypt(kp,\n+                defaultParams.authKey(kp2.getPrivate()),\n+                defaultParams.authKey(kp2.getPublic()));\n+\n+        \/\/ check default values\n+        checkEncryptDecrypt(kp,\n+                emptyParams,\n+                defaultParams);\n+\n+        checkEncryptDecrypt(kp,\n+                defaultParams,\n+                defaultParams.info(new byte[0]));\n+\n+        checkEncryptDecrypt(kp,\n+                defaultParams,\n+                defaultParams.psk(null, new byte[0]));\n+    }\n+\n+    static void checkEncryptDecrypt(KeyPair kp, HPKEParameterSpec ps,\n+            HPKEParameterSpec pr) throws Exception {\n+\n+        var c1 = Cipher.getInstance(\"HPKE\");\n+        var c2 = Cipher.getInstance(\"HPKE\");\n+        var aad = \"AAD\".getBytes(StandardCharsets.UTF_8);\n+\n+        c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), ps);\n+        c1.updateAAD(aad);\n+        var ct = c1.doFinal(new byte[2]);\n+\n+        c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                pr.encapsulation(c1.getIV()));\n+        c2.updateAAD(aad);\n+        Asserts.assertEqualsByteArray(c2.doFinal(ct), new byte[2]);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/Compliance.java","additions":270,"deletions":0,"binary":false,"changes":270,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.HPKEParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.spec.ECGenParameterSpec;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug 8325448\n+ * @library \/test\/lib\n+ * @summary HPKE running with different keys\n+ *\/\n+public class Functions {\n+    record Params(String name) {}\n+    static List<Params> PARAMS = List.of(\n+            new Params(\"secp256r1\"),\n+            new Params(\"secp384r1\"),\n+            new Params(\"secp521r1\"),\n+            new Params(\"X25519\"),\n+            new Params(\"X448\")\n+    );\n+    public static void main(String[] args) throws Exception {\n+\n+        var msg = \"hello\".getBytes(StandardCharsets.UTF_8);\n+        var info = \"info\".getBytes(StandardCharsets.UTF_8);\n+        var psk = new SecretKeySpec(\"this is a key\".getBytes(StandardCharsets.UTF_8), \"Generic\");\n+        var psk_id = \"psk1\".getBytes(StandardCharsets.UTF_8);\n+\n+        for (var param : PARAMS) {\n+            System.out.println(param);\n+            var c = Cipher.getInstance(\"HPKE\");\n+            var kp = genKeyPair(param.name());\n+            var kp2 = genKeyPair(param.name());\n+\n+            c.init(Cipher.ENCRYPT_MODE, kp.getPublic());\n+            var ct = c.doFinal(msg);\n+            var params = c.getParameters().getParameterSpec(HPKEParameterSpec.class);\n+\n+            c.init(Cipher.DECRYPT_MODE, kp.getPrivate(), params);\n+            Asserts.assertEqualsByteArray(msg, c.doFinal(ct));\n+\n+            c.init(Cipher.ENCRYPT_MODE, kp.getPublic(), HPKEParameterSpec.of()\n+                    .authKey(kp2.getPrivate())\n+                    .info(info)\n+                    .psk(psk, psk_id));\n+            ct = c.doFinal(msg);\n+            params = c.getParameters().getParameterSpec(HPKEParameterSpec.class);\n+\n+            c.init(Cipher.DECRYPT_MODE, kp.getPrivate(), params\n+                    .authKey(kp2.getPublic()));\n+            Asserts.assertEqualsByteArray(msg, c.doFinal(ct));\n+        }\n+    }\n+\n+    static KeyPair genKeyPair(String name) throws Exception {\n+        if (name.startsWith(\"secp\")) {\n+            var g = KeyPairGenerator.getInstance(\"EC\");\n+            g.initialize(new ECGenParameterSpec(name));\n+            return g.generateKeyPair();\n+        } else {\n+            return KeyPairGenerator.getInstance(name).generateKeyPair();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/Functions.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8325448\n+ * @summary KAT inside RFC 9180\n+ * @library \/test\/lib\n+ * @modules java.base\/com.sun.crypto.provider\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.artifacts.Artifact;\n+import jdk.test.lib.artifacts.ArtifactResolver;\n+import jdk.test.lib.json.JSONValue;\n+\n+import com.sun.crypto.provider.DHKEM;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.HPKEParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HexFormat;\n+\n+\/\/\/ This test is based on Appendix A (Test Vectors) of\n+\/\/\/ [RFC 9180](https:\/\/datatracker.ietf.org\/doc\/html\/rfc9180#name-test-vectors)\n+\/\/\/ The test data is available as a JSON file at:\n+\/\/\/ https:\/\/github.com\/cfrg\/draft-irtf-cfrg-hpke\/blob\/5f503c564da00b0687b3de75f1dfbdfc4079ad31\/test-vectors.json.\n+\/\/\/\n+\/\/\/ The JSON file can either be hosted on an artifactory server or\n+\/\/\/ provided via a local path with\n+\/\/\/ ```\n+\/\/\/ jtreg -Djdk.test.lib.artifacts.rfc9180-test-vectors=<local-json-file> KAT9180.java\n+\/\/\/ ```\n+public class KAT9180 {\n+\n+    @Artifact(\n+            organization = \"jpg.tests.jdk.ietf\",\n+            name = \"rfc9180-test-vectors\",\n+            revision = \"5f503c5\",\n+            extension = \"json\",\n+            unpack = false)\n+    private static class RFC_9180_KAT {\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        var h = HexFormat.of();\n+        Path archivePath = ArtifactResolver.fetchOne(RFC_9180_KAT.class);\n+        System.out.println(\"Data path: \" + archivePath);\n+        var c1 = Cipher.getInstance(\"HPKE\");\n+        var c2 = Cipher.getInstance(\"HPKE\");\n+        var ts = JSONValue.parse(new String(Files.readAllBytes(archivePath), StandardCharsets.UTF_8));\n+        for (var tg : ts.asArray()) {\n+            var mode = Integer.parseInt(tg.get(\"mode\").asString());\n+            System.err.print('I');\n+            var kem_id = Integer.parseInt(tg.get(\"kem_id\").asString());\n+            var kdf_id = Integer.parseInt(tg.get(\"kdf_id\").asString());\n+            var aead_id = Integer.parseInt(tg.get(\"aead_id\").asString());\n+            var ikmR = h.parseHex(tg.get(\"ikmR\").asString());\n+            var ikmE = h.parseHex(tg.get(\"ikmE\").asString());\n+            var info = h.parseHex(tg.get(\"info\").asString());\n+\n+            var kpR = new DHKEM.RFC9180DeriveKeyPairSR(ikmR).derive(kem_id);\n+            var spec = HPKEParameterSpec.of(kem_id, kdf_id, aead_id).info(info);\n+            var rand = new DHKEM.RFC9180DeriveKeyPairSR(ikmE);\n+\n+            if (mode == 1 || mode == 3) {\n+                spec = spec.psk(\n+                        new SecretKeySpec(h.parseHex(tg.get(\"psk\").asString()), \"Generic\"),\n+                        h.parseHex(tg.get(\"psk_id\").asString()));\n+            }\n+            if (mode == 0 || mode == 1) {\n+                c1.init(Cipher.ENCRYPT_MODE, kpR.getPublic(), spec, rand);\n+                c2.init(Cipher.DECRYPT_MODE, kpR.getPrivate(),\n+                        spec.encapsulation(c1.getIV()));\n+            } else {\n+                var ikmS = h.parseHex(tg.get(\"ikmS\").asString());\n+                var kpS = new DHKEM.RFC9180DeriveKeyPairSR(ikmS).derive(kem_id);\n+                c1.init(Cipher.ENCRYPT_MODE, kpR.getPublic(),\n+                        spec.authKey(kpS.getPrivate()), rand);\n+                c2.init(Cipher.DECRYPT_MODE, kpR.getPrivate(),\n+                        spec.encapsulation(c1.getIV()).authKey(kpS.getPublic()));\n+            }\n+            var enc = tg.get(\"encryptions\");\n+            if (enc != null) {\n+                System.err.print('e');\n+                var count = 0;\n+                for (var p : enc.asArray()) {\n+                    var aad = h.parseHex(p.get(\"aad\").asString());\n+                    var pt = h.parseHex(p.get(\"pt\").asString());\n+                    var ct = h.parseHex(p.get(\"ct\").asString());\n+                    c1.updateAAD(aad);\n+                    var ct1 = c1.doFinal(pt);\n+                    Asserts.assertEqualsByteArray(ct, ct1);\n+                    c2.updateAAD(aad);\n+                    var pt1 = c2.doFinal(ct);\n+                    Asserts.assertEqualsByteArray(pt, pt1);\n+                    count++;\n+                }\n+                System.err.print(count);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/KAT9180.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import jdk.test.lib.Utils;\n@@ -44,1 +43,0 @@\n-import java.util.Objects;\n@@ -46,1 +44,0 @@\n-import java.util.function.Consumer;\n@@ -69,6 +66,4 @@\n-        Utils.runAndCheckException(\n-                () -> new KEM.Encapsulated(null, new byte[0], null),\n-                NullPointerException.class);\n-        Utils.runAndCheckException(\n-                () -> new KEM.Encapsulated(new SecretKeySpec(new byte[1], \"X\"), null, null),\n-                NullPointerException.class);\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> new KEM.Encapsulated(null, new byte[0], null));\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> new KEM.Encapsulated(new SecretKeySpec(new byte[1], \"X\"), null, null));\n@@ -89,16 +84,11 @@\n-        Utils.runAndCheckException(\n-                () -> KEM.getInstance(\"OLALA\"),\n-                NoSuchAlgorithmException.class);\n-        Utils.runAndCheckException(\n-                () -> KEM.getInstance(\"DHKEM\", \"NoWhere\"),\n-                NoSuchProviderException.class);\n-        Utils.runAndCheckException(\n-                () -> KEM.getInstance(\"DHKEM\", \"SunRsaSign\"),\n-                NoSuchAlgorithmException.class);\n-\n-        Utils.runAndCheckException(\n-                () -> kem.newEncapsulator(null),\n-                InvalidKeyException.class);\n-        Utils.runAndCheckException(\n-                () -> kem.newDecapsulator(null),\n-                InvalidKeyException.class);\n+        Asserts.assertThrows(NoSuchAlgorithmException.class,\n+                () -> KEM.getInstance(\"OLALA\"));\n+        Asserts.assertThrows(NoSuchProviderException.class,\n+                () -> KEM.getInstance(\"DHKEM\", \"NoWhere\"));\n+        Asserts.assertThrows(NoSuchAlgorithmException.class,\n+                () -> KEM.getInstance(\"DHKEM\", \"SunRsaSign\"));\n+\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> kem.newEncapsulator(null));\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> kem.newDecapsulator(null));\n@@ -107,3 +97,4 @@\n-        Utils.runAndCheckException(\n-                () -> kem.newEncapsulator(badECKey()),\n-                ExChecker.of(InvalidKeyException.class).by(DHKEM.class));\n+        checkThrownBy(Asserts.assertThrows(\n+                InvalidKeyException.class,\n+                () -> kem.newEncapsulator(badECKey())),\n+                DHKEM.class.getName());\n@@ -113,3 +104,4 @@\n-        Utils.runAndCheckException(\n-                () -> kem.newEncapsulator(kpRSA.getPublic()),\n-                ExChecker.of(InvalidKeyException.class).by(KEM.class.getName() + \"$DelayedKEM\"));\n+        checkThrownBy(Asserts.assertThrows(\n+                InvalidKeyException.class,\n+                () -> kem.newEncapsulator(kpRSA.getPublic())),\n+                KEM.class.getName() + \"$DelayedKEM\");\n@@ -117,3 +109,2 @@\n-        Utils.runAndCheckException(\n-                () -> kem.newDecapsulator(kpRSA.getPrivate()),\n-                InvalidKeyException.class);\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> kem.newDecapsulator(kpRSA.getPrivate()));\n@@ -128,9 +119,6 @@\n-        Utils.runAndCheckException(\n-                () -> e2.encapsulate(-1, 12, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> e2.encapsulate(0, e2.secretSize() + 1, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> e2.encapsulate(0, e2.secretSize(), null),\n-                NullPointerException.class);\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> e2.encapsulate(-1, 12, \"AES\"));\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> e2.encapsulate(0, e2.secretSize() + 1, \"AES\"));\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> e2.encapsulate(0, e2.secretSize(), null));\n@@ -165,12 +153,8 @@\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(null),\n-                NullPointerException.class);\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(enc.encapsulation(), -1, 12, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize() + 1, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize(), null),\n-                NullPointerException.class);\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> d.decapsulate(null));\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> d.decapsulate(enc.encapsulation(), -1, 12, \"AES\"));\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize() + 1, \"AES\"));\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize(), null));\n@@ -181,3 +165,2 @@\n-        Utils.runAndCheckException(\n-                () -> d3.decapsulate(enc2.encapsulation()),\n-                DecapsulateException.class);\n+        Asserts.assertThrows(DecapsulateException.class,\n+                () -> d3.decapsulate(enc2.encapsulation()));\n@@ -185,3 +168,2 @@\n-        Utils.runAndCheckException(\n-                () -> d3.decapsulate(new byte[100]),\n-                DecapsulateException.class);\n+        Asserts.assertThrows(DecapsulateException.class,\n+                () -> d3.decapsulate(new byte[100]));\n@@ -276,29 +258,3 @@\n-    \/\/ Used by Utils.runAndCheckException. Checks for type and final thrower.\n-    record ExChecker(Class<? extends Throwable> ex, String caller)\n-            implements Consumer<Throwable> {\n-        ExChecker {\n-            Objects.requireNonNull(ex);\n-        }\n-        static ExChecker of(Class<? extends Throwable> ex) {\n-            return new ExChecker(ex, null);\n-        }\n-        ExChecker by(String caller) {\n-            return new ExChecker(ex(), caller);\n-        }\n-        ExChecker by(Class<?> caller) {\n-            return new ExChecker(ex(), caller.getName());\n-        }\n-        @Override\n-        public void accept(Throwable t) {\n-            if (t == null) {\n-                throw new AssertionError(\"no exception thrown\");\n-            } else if (!ex.isAssignableFrom(t.getClass())) {\n-                throw new AssertionError(\"exception thrown is \" + t.getClass());\n-            } else if (caller == null) {\n-                return;\n-            } else if (t.getStackTrace()[0].getClassName().equals(caller)) {\n-                return;\n-            } else {\n-                throw new AssertionError(\"thrown by \" + t.getStackTrace()[0].getClassName());\n-            }\n-        }\n+    \/\/ Ensures `t` is thrown by `caller`\n+    static <T extends Throwable> void checkThrownBy(T t, String caller) {\n+        Asserts.assertEquals(caller, t.getStackTrace()[0].getClassName());\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/DHKEM\/Compliance.java","additions":47,"deletions":91,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -242,0 +242,2 @@\n+        } if (s.equals(\"HPKE\")) {\n+            return generateKeyPair(\"EC\", 3).getPublic();\n","filename":"test\/jdk\/sun\/security\/provider\/all\/Deterministic.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}