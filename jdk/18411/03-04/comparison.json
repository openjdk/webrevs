{"files":[{"patch":"@@ -307,1 +307,1 @@\n-            var ext = labeledBuilder(suiteId, EAE_PRK).addIKM(dh);\n+            var builder = labeledExtact(suiteId, EAE_PRK).addIKM(dh);\n@@ -309,3 +309,2 @@\n-                return kdf.deriveKey(alg, ext.thenExpand(\n-                        labeledInfo(suiteId, SHARED_SECRET, kem_context, Nsecret),\n-                        Nsecret));\n+                return kdf.deriveKey(alg,\n+                        labeledExpand(builder, suiteId, SHARED_SECRET, kem_context, Nsecret));\n@@ -342,1 +341,1 @@\n-            var extract = labeledBuilder(suiteId, DKP_PRK).addIKM(ikm);\n+            var builder = labeledExtact(suiteId, DKP_PRK).addIKM(ikm);\n@@ -351,2 +350,2 @@\n-                    byte[] bytes = kdf.deriveData(extract.thenExpand(labeledInfo(\n-                            suiteId, CANDIDATE, I2OSP(counter, 1), Nsk), Nsk));\n+                    byte[] bytes = kdf.deriveData(labeledExpand(builder,\n+                            suiteId, CANDIDATE, I2OSP(counter, 1), Nsk));\n@@ -363,2 +362,2 @@\n-                byte[] sk = kdf.deriveData(extract.thenExpand(\n-                        labeledInfo(suiteId, SK, EMPTY, Nsk), Nsk));\n+                byte[] sk = kdf.deriveData(labeledExpand(builder,\n+                        suiteId, SK, EMPTY, Nsk));\n@@ -448,1 +447,1 @@\n-    \/\/ Create an HKDFParameterSpec.Builder with HPKE label.\n+    \/\/ Create a LabeledExtract builder with labels.\n@@ -450,1 +449,1 @@\n-    public static HKDFParameterSpec.Builder labeledBuilder(\n+    public static HKDFParameterSpec.Builder labeledExtact(\n@@ -456,2 +455,3 @@\n-    \/\/ Create an HPKE labeled info\n-    public static byte[] labeledInfo(byte[] suiteId, byte[] label, byte[] info, int L) {\n+    \/\/ Create a labeled info from info and labels\n+    private static byte[] labeledInfo(\n+            byte[] suiteId, byte[] label, byte[] info, int L) {\n@@ -460,0 +460,15 @@\n+\n+    \/\/ LabeledExpand from a builder\n+    public static HKDFParameterSpec labeledExpand(\n+            HKDFParameterSpec.Builder builder,\n+            byte[] suiteId, byte[] label, byte[] info, int L) {\n+        return builder.thenExpand(\n+                labeledInfo(suiteId, label, info, L), L);\n+    }\n+\n+    \/\/ LabeledExpand from a prk\n+    public static HKDFParameterSpec labeledExpand(\n+            SecretKey prk, byte[] suiteId, byte[] label, byte[] info, int L) {\n+        return HKDFParameterSpec.expandOnly(\n+                prk, labeledInfo(suiteId, label, info, L), L);\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKEM.java","additions":28,"deletions":13,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import javax.crypto.spec.HKDFParameterSpec;\n@@ -47,1 +46,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -65,1 +63,0 @@\n-import java.util.Objects;\n@@ -69,0 +66,17 @@\n+    private static final byte[] HPKE = new byte[]\n+            {'H', 'P', 'K', 'E'};\n+    private static final byte[] SEC = new byte[]\n+            {'s', 'e', 'c'};\n+    private static final byte[] PSK_ID_HASH = new byte[]\n+            {'p', 's', 'k', '_', 'i', 'd', '_', 'h', 'a', 's', 'h'};\n+    private static final byte[] INFO_HASH = new byte[]\n+            {'i', 'n', 'f', 'o', '_', 'h', 'a', 's', 'h'};\n+    private static final byte[] SECRET = new byte[]\n+            {'s', 'e', 'c', 'r', 'e', 't'};\n+    private static final byte[] EXP = new byte[]\n+            {'e', 'x', 'p'};\n+    private static final byte[] KEY = new byte[]\n+            {'k', 'e', 'y'};\n+    private static final byte[] BASE_NONCE = new byte[]\n+            {'b', 'a', 's', 'e', '_', 'n', 'o', 'n', 'c', 'e'};\n+\n@@ -129,1 +143,2 @@\n-    protected void engineInit(int opmode, Key key, AlgorithmParameterSpec params, SecureRandom random)\n+    protected void engineInit(int opmode, Key key,\n+            AlgorithmParameterSpec params, SecureRandom random)\n@@ -142,1 +157,2 @@\n-            throw new InvalidAlgorithmParameterException(\"Unsupported params type: \" + params.getClass());\n+            throw new InvalidAlgorithmParameterException(\n+                    \"Unsupported params type: \" + params.getClass());\n@@ -153,1 +169,2 @@\n-    protected void engineInit(int opmode, Key key, AlgorithmParameters params, SecureRandom random)\n+    protected void engineInit(int opmode, Key key,\n+            AlgorithmParameters params, SecureRandom random)\n@@ -179,1 +196,2 @@\n-    protected int engineUpdate(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws ShortBufferException {\n+    protected int engineUpdate(byte[] input, int inputOffset, int inputLen,\n+            byte[] output, int outputOffset) throws ShortBufferException {\n@@ -181,1 +199,2 @@\n-        return impl.aead.cipher.update(input, inputOffset, inputLen, output, outputOffset);\n+        return impl.aead.cipher.update(\n+                input, inputOffset, inputLen, output, outputOffset);\n@@ -197,1 +216,2 @@\n-    protected byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen) throws IllegalBlockSizeException, BadPaddingException {\n+    protected byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen)\n+            throws IllegalBlockSizeException, BadPaddingException {\n@@ -209,1 +229,3 @@\n-    protected int engineDoFinal(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException {\n+    protected int engineDoFinal(byte[] input, int inputOffset, int inputLen,\n+            byte[] output, int outputOffset) throws ShortBufferException,\n+            IllegalBlockSizeException, BadPaddingException {\n@@ -213,1 +235,2 @@\n-        return impl.aead.cipher.doFinal(input, inputOffset, inputLen, output, outputOffset);\n+        return impl.aead.cipher.doFinal(\n+                input, inputOffset, inputLen, output, outputOffset);\n@@ -289,1 +312,1 @@\n-            long seq = 0;\n+            byte[] seq = new byte[aead.Nn];\n@@ -301,3 +324,2 @@\n-                    return kdf.deriveKey(algorithm, HKDFParameterSpec.expandOnly(exporter_secret,\n-                            DHKEM.labeledInfo(suite_id, \"sec\".getBytes(StandardCharsets.UTF_8),\n-                                    exporter_context, L), L));\n+                    return kdf.deriveKey(algorithm, DHKEM.labeledExpand(\n+                            exporter_secret, suite_id, SEC, exporter_context, L));\n@@ -311,1 +333,1 @@\n-                var result = I2OSP(seq, aead.Nn);\n+                var result = new byte[aead.Nn];\n@@ -313,1 +335,1 @@\n-                    result[i] ^= base_nonce[i];\n+                    result[i] = (byte)(seq[i] ^ base_nonce[i]);\n@@ -319,4 +341,7 @@\n-                if (seq == Long.MAX_VALUE) {\n-                    \/\/ Should check if (seq >= (1 << (8*aead.Nn)) - 1), but\n-                    \/\/ when Nn == 12 this is too big\n-                    throw new ProviderException(\"MessageLimitReachedError\");\n+                for (var i = seq.length - 1; i >= 0; i--) {\n+                    if ((seq[i] & 0xff) == 0xff) {\n+                        seq[i] = 0;\n+                    } else {\n+                        seq[i]++;\n+                        return;\n+                    }\n@@ -324,1 +349,2 @@\n-                seq++;\n+                \/\/ seq >= (1 << (8*aead.Nn)) - 1 when this method is called\n+                throw new ProviderException(\"MessageLimitReachedError\");\n@@ -336,0 +362,4 @@\n+        \/\/ Section 7.2.1 of RFC 9180 has restrictions on size of psk, psk_id,\n+        \/\/ info, and exporter_context (~2^61 for HMAC-SHA256 and ~2^125 for\n+        \/\/ HMAC-SHA384 and HMAC-SHA512). This method does not pose any\n+        \/\/ restrictions.\n@@ -339,1 +369,2 @@\n-                throw new UnsupportedOperationException(\"Can only be used for encryption and decryption\");\n+                throw new UnsupportedOperationException(\n+                        \"Can only be used for encryption and decryption\");\n@@ -345,1 +376,2 @@\n-                    throw new InvalidKeyException(\"Cannot encrypt with private key\");\n+                    throw new InvalidKeyException(\n+                            \"Cannot encrypt with private key\");\n@@ -357,1 +389,2 @@\n-                        throw new UnsupportedOperationException(\"auth mode not supported\");\n+                        throw new UnsupportedOperationException(\n+                                \"auth mode not supported\");\n@@ -359,1 +392,2 @@\n-                        throw new InvalidAlgorithmParameterException(\"Cannot auth with public key\");\n+                        throw new InvalidAlgorithmParameterException(\n+                                \"Cannot auth with public key\");\n@@ -376,1 +410,2 @@\n-                            throw new UnsupportedOperationException(\"auth mode not supported\");\n+                            throw new UnsupportedOperationException(\n+                                    \"auth mode not supported\");\n@@ -378,1 +413,2 @@\n-                            throw new InvalidAlgorithmParameterException(\"Cannot auth with private key\");\n+                            throw new InvalidAlgorithmParameterException(\n+                                    \"Cannot auth with private key\");\n@@ -403,5 +439,3 @@\n-                if ((ECUtil.equals(ecp, CurveDB.P_256) && kem_id == 0x10)\n-                        || (ECUtil.equals(ecp, CurveDB.P_384) && kem_id == 0x11)\n-                        || (ECUtil.equals(ecp, CurveDB.P_521) && kem_id == 0x12)) {\n-                    return;\n-                } else {\n+                if ((!ECUtil.equals(ecp, CurveDB.P_256) || kem_id != 0x10)\n+                        && (!ECUtil.equals(ecp, CurveDB.P_384) || kem_id != 0x11)\n+                        && (!ECUtil.equals(ecp, CurveDB.P_521) || kem_id != 0x12)) {\n@@ -409,1 +443,2 @@\n-                    throw new InvalidAlgorithmParameterException(name + \" does not match \" + kem_id);\n+                    throw new InvalidAlgorithmParameterException(\n+                            name + \" does not match \" + kem_id);\n@@ -413,5 +448,4 @@\n-                if ((name.equalsIgnoreCase(\"x25519\") && kem_id == 0x20)\n-                        || (name.equalsIgnoreCase(\"x448\") && kem_id == 0x21)) {\n-                    return;\n-                } else {\n-                    throw new InvalidAlgorithmParameterException(name + \" does not match \" + kem_id);\n+                if ((!name.equalsIgnoreCase(\"x25519\") || kem_id != 0x20)\n+                        && (!name.equalsIgnoreCase(\"x448\") || kem_id != 0x21)) {\n+                    throw new InvalidAlgorithmParameterException(\n+                            name + \" does not match \" + kem_id);\n@@ -420,1 +454,2 @@\n-                throw new InvalidKeyException(k.getClass() + \" does not match \" + kem_id);\n+                throw new InvalidKeyException(\n+                        k.getClass() + \" does not match \" + kem_id);\n@@ -474,1 +509,1 @@\n-                    \"HPKE\".getBytes(StandardCharsets.UTF_8),\n+                    HPKE,\n@@ -568,4 +603,4 @@\n-                var psk_id_hash_x = DHKEM.labeledBuilder(suite_id, \"psk_id_hash\".getBytes(StandardCharsets.UTF_8))\n-                        .addIKM(psk_id);\n-                var info_hash_x = DHKEM.labeledBuilder(suite_id, \"info_hash\".getBytes(StandardCharsets.UTF_8))\n-                        .addIKM(info);\n+                var psk_id_hash_x = DHKEM.labeledExtact(suite_id, PSK_ID_HASH)\n+                        .addIKM(psk_id).extractOnly();\n+                var info_hash_x = DHKEM.labeledExtact(suite_id, INFO_HASH)\n+                        .addIKM(info).extractOnly();\n@@ -573,2 +608,2 @@\n-                \/\/ deriveData must and can be called because all info are extractable.\n-                \/\/ Any KDF impl can handle this.\n+                \/\/ deriveData must and can be called because all info to\n+                \/\/ thw builder are just byte arrays. Any KDF impl can handle this.\n@@ -577,5 +612,6 @@\n-                        kdf.deriveData(psk_id_hash_x.extractOnly()),\n-                        kdf.deriveData(info_hash_x.extractOnly()));\n-                var secret_x = DHKEM.labeledBuilder(suite_id, \"secret\".getBytes(StandardCharsets.UTF_8))\n-                        .addIKM(psk == null ? new byte[0] : Objects.requireNonNull(psk.getEncoded()))\n-                        .addSalt(shared_secret);\n+                        kdf.deriveData(psk_id_hash_x),\n+                        kdf.deriveData(info_hash_x));\n+\n+                var secret_x_builder = DHKEM.labeledExtact(suite_id, SECRET);\n+                if (psk != null) secret_x_builder = secret_x_builder.addIKM(psk);\n+                secret_x_builder = secret_x_builder.addSalt(shared_secret);\n@@ -583,1 +619,3 @@\n-                \/\/ Create a new KDF object because secret_x might contain provider-specific keys\n+                \/\/ A new KDF object must be created because secret_x_builder\n+                \/\/ might contain provider-specific keys which the previous\n+                \/\/ KDF (provider already chosen) cannot handle.\n@@ -585,2 +623,2 @@\n-                var exporter_secret = kdf.deriveKey(\"Generic\",\n-                        secret_x.thenExpand(DHKEM.labeledInfo(suite_id, \"exp\".getBytes(StandardCharsets.UTF_8), key_schedule_context, kdfNh), kdfNh));\n+                var exporter_secret = kdf.deriveKey(\"Generic\", DHKEM.labeledExpand(\n+                        secret_x_builder, suite_id, EXP, key_schedule_context, kdfNh));\n@@ -590,5 +628,5 @@\n-                    var key = kdf.deriveKey(\"AES\", secret_x.thenExpand(DHKEM.labeledInfo(suite_id, \"key\".getBytes(StandardCharsets.UTF_8),\n-                            key_schedule_context, aead.Nk), aead.Nk));\n-                    \/\/ deriveData must be called because we need to increment nonce, the info must be allowed\n-                    var base_nonce = kdf.deriveData(secret_x.thenExpand(DHKEM.labeledInfo(suite_id, \"base_nonce\".getBytes(StandardCharsets.UTF_8),\n-                            key_schedule_context, aead.Nn), aead.Nn));\n+                    var key = kdf.deriveKey(\"AES\", DHKEM.labeledExpand(secret_x_builder,\n+                            suite_id, KEY, key_schedule_context, aead.Nk));\n+                    \/\/ deriveData must be called because we need to increment nonce\n+                    var base_nonce = kdf.deriveData(DHKEM.labeledExpand(secret_x_builder,\n+                            suite_id, BASE_NONCE, key_schedule_context, aead.Nn));\n@@ -599,1 +637,2 @@\n-            } catch (InvalidAlgorithmParameterException | NoSuchAlgorithmException e) {\n+            } catch (InvalidAlgorithmParameterException\n+                     | NoSuchAlgorithmException | UnsupportedOperationException e) {\n@@ -614,14 +653,0 @@\n-\n-    private static byte[] I2OSP(long n, int w) {\n-        var full = BigInteger.valueOf(n).toByteArray();\n-        var fullLen = full.length;\n-        if (fullLen == w) {\n-            return full;\n-        } else if (fullLen > w) {\n-            return Arrays.copyOfRange(full, fullLen - w, fullLen);\n-        } else {\n-            var result = new byte[w];\n-            System.arraycopy(full, 0, result, w - fullLen, fullLen);\n-            return result;\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HPKE.java","additions":100,"deletions":75,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -243,1 +243,2 @@\n-        return new HPKEParameterSpec(kem_id, kdf_id, aead_id, new byte[0], null, new byte[0], null, null);\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                new byte[0], null, new byte[0], null, null);\n@@ -249,0 +250,3 @@\n+     * <p>\n+     * For interoperability, RFC 9180 Section 7.2.1 recommends limiting\n+     * this value to a maximum of 64 bytes.\n@@ -264,0 +268,3 @@\n+     * <p>\n+     * For interoperability, RFC 9180 Section 7.2.1 recommends limiting both\n+     * values to a maximum of 64 bytes.\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/HPKEParameterSpec.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-\/\/\/ jtreg -Djdk.test.lib.artifacts.test-vectors=<local-json-file> KAT9180.java\n+\/\/\/ jtreg -Djdk.test.lib.artifacts.rfc9180-test-vectors=<local-json-file> KAT9180.java\n@@ -61,2 +61,2 @@\n-            organization = \"jpg.tests.jdk.ietf.rfc9180\",\n-            name = \"test-vectors\",\n+            organization = \"jpg.tests.jdk.ietf\",\n+            name = \"rfc9180-test-vectors\",\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/KAT9180.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}