{"files":[{"patch":"@@ -41,1 +41,1 @@\n- * arbitrary-sized plaintexts to a receiver's public key. It combines a key\n+ * arbitrary-sized plaintexts with a receiver's public key. It combines a key\n@@ -119,2 +119,2 @@\n- * call performs a complete HPKE encryption or decryption operation using\n- * a distinct nonce derived from an internal sequence counter, as specified by\n+ * performs a complete HPKE encryption or decryption operation using a distinct\n+ * IV derived from an internal sequence counter, as specified in\n@@ -122,10 +122,7 @@\n- * of RFC 9180.\n- * <p>\n- * HPKE internally uses an AEAD cipher for message encryption and decryption.\n- * As with any AEAD cipher, each {@code doFinal} call on the receiver side must\n- * correspond to exactly one complete ciphertext, and the number and order of\n- * calls must match on both sides. Unlike the direct use of an AEAD cipher,\n- * however, an HPKE cipher manages nonce generation internally, and there is no\n- * need for the application to reinitialize the cipher with a new IV for each\n- * message. This simplifies usage while ensuring nonce uniqueness and preserving\n- * AEAD security guarantees.\n+ * of RFC 9180. On the receiver side, each {@code doFinal} call must correspond\n+ * to exactly one complete ciphertext, and the number and order of calls must\n+ * match those on the sender side. This differs from the direct use of an AEAD\n+ * cipher, where the caller must provide a fresh IV and reinitialize the cipher\n+ * for each message. By managing IVs internally, HPKE allows a single\n+ * initialization to support multiple messages while still ensuring IV\n+ * uniqueness and preserving AEAD security guarantees.\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/HPKEParameterSpec.java","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"}]}