{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.io.Serial;\n@@ -30,2 +31,11 @@\n-import java.security.*;\n-import java.security.interfaces.ECKey;\n+import java.security.AsymmetricKey;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.KeyFactory;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n@@ -33,1 +43,0 @@\n-import java.security.interfaces.XECKey;\n@@ -35,1 +44,10 @@\n-import java.security.spec.*;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.ECParameterSpec;\n+import java.security.spec.ECPoint;\n+import java.security.spec.ECPrivateKeySpec;\n+import java.security.spec.ECPublicKeySpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.security.spec.XECPrivateKeySpec;\n+import java.security.spec.XECPublicKeySpec;\n@@ -38,2 +56,6 @@\n-import javax.crypto.*;\n-import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.KDF;\n+import javax.crypto.KEM;\n+import javax.crypto.KEMSpi;\n+import javax.crypto.KeyAgreement;\n+import javax.crypto.SecretKey;\n@@ -41,0 +63,1 @@\n+import javax.crypto.spec.SecretKeySpec;\n@@ -43,3 +66,6 @@\n-import sun.security.util.*;\n-\n-import jdk.internal.access.SharedSecrets;\n+import sun.security.util.ArrayUtil;\n+import sun.security.util.CurveDB;\n+import sun.security.util.ECUtil;\n+import sun.security.util.InternalPrivateKey;\n+import sun.security.util.NamedCurve;\n+import sun.security.util.SliceableSecretKey;\n@@ -48,1 +74,0 @@\n-\/\/ without the AuthEncap and AuthDecap functions\n@@ -68,1 +93,2 @@\n-                           PrivateKey skR, PublicKey pkR)\n+                           PrivateKey skS, PublicKey pkS, \/\/ sender keys\n+                           PrivateKey skR, PublicKey pkR) \/\/ receiver keys\n@@ -80,1 +106,0 @@\n-            byte[] kem_context = concat(pkEm, pkRm);\n@@ -82,5 +107,14 @@\n-                byte[] dh = params.DH(skE, pkR);\n-                byte[] key = params.ExtractAndExpand(dh, kem_context);\n-                return new KEM.Encapsulated(\n-                        new SecretKeySpec(key, from, to - from, algorithm),\n-                        pkEm, null);\n+                SecretKey key;\n+                if (skS == null) {\n+                    byte[] kem_context = concat(pkEm, pkRm);\n+                    key = params.deriveKey(algorithm, from, to, kem_context,\n+                            params.DH(skE, pkR));\n+                } else {\n+                    byte[] pkSm = params.SerializePublicKey(pkS);\n+                    byte[] kem_context = concat(pkEm, pkRm, pkSm);\n+                    key = params.deriveKey(algorithm, from, to, kem_context,\n+                            params.DH(skE, pkR), params.DH(skS, pkR));\n+                }\n+                return new KEM.Encapsulated(key, pkEm, null);\n+            } catch (UnsupportedOperationException e) {\n+                throw e;\n@@ -103,1 +137,0 @@\n-                byte[] dh = params.DH(skR, pkE);\n@@ -105,3 +138,12 @@\n-                byte[] kem_context = concat(encapsulation, pkRm);\n-                byte[] key = params.ExtractAndExpand(dh, kem_context);\n-                return new SecretKeySpec(key, from, to - from, algorithm);\n+                if (pkS == null) {\n+                    byte[] kem_context = concat(encapsulation, pkRm);\n+                    return params.deriveKey(algorithm, from, to, kem_context,\n+                            params.DH(skR, pkE));\n+                } else {\n+                    byte[] pkSm = params.SerializePublicKey(pkS);\n+                    byte[] kem_context = concat(encapsulation, pkRm, pkSm);\n+                    return params.deriveKey(algorithm, from, to, kem_context,\n+                            params.DH(skR, pkE), params.DH(skR, pkS));\n+                }\n+            } catch (UnsupportedOperationException e) {\n+                throw e;\n@@ -129,1 +171,2 @@\n-        static final long serialVersionUID = 0L;\n+        @Serial\n+        private static final long serialVersionUID = 0L;\n@@ -138,1 +181,1 @@\n-        public KeyPair derive(Params params) {\n+        private KeyPair derive(Params params) {\n@@ -242,1 +285,1 @@\n-        private byte[] DH(PrivateKey skE, PublicKey pkR)\n+        private SecretKey DH(PrivateKey skE, PublicKey pkR)\n@@ -247,1 +290,1 @@\n-            return ka.generateSecret();\n+            return ka.generateSecret(\"Generic\");\n@@ -250,11 +293,24 @@\n-        private byte[] ExtractAndExpand(byte[] dh, byte[] kem_context)\n-                throws NoSuchAlgorithmException, InvalidKeyException {\n-            KDF hkdf = KDF.getInstance(hkdfAlgorithm);\n-            SecretKey eae_prk = LabeledExtract(hkdf, suiteId, EAE_PRK, dh);\n-            try {\n-                return LabeledExpand(hkdf, suiteId, eae_prk, SHARED_SECRET,\n-                        kem_context, Nsecret);\n-            } finally {\n-                if (eae_prk instanceof SecretKeySpec s) {\n-                    SharedSecrets.getJavaxCryptoSpecAccess()\n-                            .clearSecretKeySpec(s);\n+        \/\/ The final shared secret derivation of either the encapsulator\n+        \/\/ or the decapsulator. The key slicing is implemented inside.\n+        \/\/ Throws UOE if a slice of the key cannot be found.\n+        private SecretKey deriveKey(String alg, int from, int to,\n+                byte[] kem_context, SecretKey... dhs)\n+                throws NoSuchAlgorithmException {\n+            if (from == 0 && to == Nsecret) {\n+                return ExtractAndExpand(kem_context, alg, dhs);\n+            } else {\n+                \/\/ First get shared secrets in \"Generic\" and then get a slice\n+                \/\/ of it in the requested algorithm.\n+                var fullKey = ExtractAndExpand(kem_context, \"Generic\", dhs);\n+                if (\"RAW\".equalsIgnoreCase(fullKey.getFormat())) {\n+                    byte[] km = fullKey.getEncoded();\n+                    if (km == null) {\n+                        \/\/ Should not happen if format is \"RAW\"\n+                        throw new UnsupportedOperationException(\"Key extract failed\");\n+                    } else {\n+                        return new SecretKeySpec(km, from, to - from, alg);\n+                    }\n+                } else if (fullKey instanceof SliceableSecretKey ssk) {\n+                    return ssk.slice(alg, from, to);\n+                } else {\n+                    throw new UnsupportedOperationException(\"Cannot extract key\");\n@@ -265,0 +321,13 @@\n+        private SecretKey ExtractAndExpand(byte[] kem_context, String alg, SecretKey... dhs)\n+                throws NoSuchAlgorithmException {\n+            var kdf = KDF.getInstance(hkdfAlgorithm);\n+            var builder = labeledExtract(suiteId, EAE_PRK);\n+            for (var dh : dhs) builder.addIKM(dh);\n+            try {\n+                return kdf.deriveKey(alg,\n+                        labeledExpand(builder, suiteId, SHARED_SECRET, kem_context, Nsecret));\n+            } catch (InvalidAlgorithmParameterException e) {\n+                throw new ProviderException(e);\n+            }\n+        }\n+\n@@ -289,21 +358,10 @@\n-            KDF hkdf = KDF.getInstance(hkdfAlgorithm);\n-            SecretKey dkp_prk = LabeledExtract(hkdf, suiteId, DKP_PRK, ikm);\n-            try {\n-                if (isEC()) {\n-                    NamedCurve curve = (NamedCurve) spec;\n-                    BigInteger sk = BigInteger.ZERO;\n-                    int counter = 0;\n-                    while (sk.signum() == 0 ||\n-                            sk.compareTo(curve.getOrder()) >= 0) {\n-                        if (counter > 255) {\n-                            throw new RuntimeException();\n-                        }\n-                        byte[] bytes = LabeledExpand(hkdf, suiteId, dkp_prk,\n-                                CANDIDATE, I2OSP(counter, 1), Nsk);\n-                        \/\/ bitmask is defined to be 0xFF for P-256 and P-384,\n-                        \/\/ and 0x01 for P-521\n-                        if (this == Params.P521) {\n-                            bytes[0] = (byte) (bytes[0] & 0x01);\n-                        }\n-                        sk = new BigInteger(1, (bytes));\n-                        counter = counter + 1;\n+            var kdf = KDF.getInstance(hkdfAlgorithm);\n+            var builder = labeledExtract(suiteId, DKP_PRK).addIKM(ikm);\n+            if (isEC()) {\n+                NamedCurve curve = (NamedCurve) spec;\n+                BigInteger sk = BigInteger.ZERO;\n+                int counter = 0;\n+                while (sk.signum() == 0 || sk.compareTo(curve.getOrder()) >= 0) {\n+                    if (counter > 255) {\n+                        \/\/ So unlucky and should not happen\n+                        throw new ProviderException(\"DeriveKeyPairError\");\n@@ -311,12 +369,8 @@\n-                    PrivateKey k = DeserializePrivateKey(sk.toByteArray());\n-                    return new KeyPair(getPublicKey(k), k);\n-                } else {\n-                    byte[] sk = LabeledExpand(hkdf, suiteId, dkp_prk, SK, EMPTY,\n-                            Nsk);\n-                    PrivateKey k = DeserializePrivateKey(sk);\n-                    return new KeyPair(getPublicKey(k), k);\n-                }\n-            } finally {\n-                if (dkp_prk instanceof SecretKeySpec s) {\n-                    SharedSecrets.getJavaxCryptoSpecAccess()\n-                            .clearSecretKeySpec(s);\n+                    byte[] bytes = kdf.deriveData(labeledExpand(builder,\n+                            suiteId, CANDIDATE, I2OSP(counter, 1), Nsk));\n+                    \/\/ bitmask is defined to be 0xFF for P-256 and P-384, and 0x01 for P-521\n+                    if (this == Params.P521) {\n+                        bytes[0] = (byte) (bytes[0] & 0x01);\n+                    }\n+                    sk = new BigInteger(1, (bytes));\n+                    counter = counter + 1;\n@@ -324,0 +378,7 @@\n+                PrivateKey k = DeserializePrivateKey(sk.toByteArray());\n+                return new KeyPair(getPublicKey(k), k);\n+            } else {\n+                byte[] sk = kdf.deriveData(labeledExpand(builder,\n+                        suiteId, SK, EMPTY, Nsk));\n+                PrivateKey k = DeserializePrivateKey(sk);\n+                return new KeyPair(getPublicKey(k), k);\n@@ -350,1 +411,16 @@\n-        return new Handler(params, getSecureRandom(secureRandom), null, pk);\n+        return new Handler(params, getSecureRandom(secureRandom), null, null, null, pk);\n+    }\n+\n+    \/\/ AuthEncap is not public KEM API\n+    public EncapsulatorSpi engineNewAuthEncapsulator(PublicKey pkR, PrivateKey skS,\n+            AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (pkR == null || skS == null) {\n+            throw new InvalidKeyException(\"input key is null\");\n+        }\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\"no spec needed\");\n+        }\n+        Params params = paramsFromKey(pkR);\n+        return new Handler(params, getSecureRandom(secureRandom),\n+                skS, params.getPublicKey(skS), null, pkR);\n@@ -363,1 +439,15 @@\n-        return new Handler(params, null, sk, params.getPublicKey(sk));\n+        return new Handler(params, null, null, null, sk, params.getPublicKey(sk));\n+    }\n+\n+    \/\/ AuthDecap is not public KEM API\n+    public DecapsulatorSpi engineNewAuthDecapsulator(\n+            PrivateKey skR, PublicKey pkS, AlgorithmParameterSpec spec)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (skR == null || pkS == null) {\n+            throw new InvalidKeyException(\"input key is null\");\n+        }\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\"no spec needed\");\n+        }\n+        Params params = paramsFromKey(skR);\n+        return new Handler(params, null, null, pkS, skR, params.getPublicKey(skR));\n@@ -366,3 +456,4 @@\n-    private Params paramsFromKey(Key k) throws InvalidKeyException {\n-        if (k instanceof ECKey eckey) {\n-            if (ECUtil.equals(eckey.getParams(), CurveDB.P_256)) {\n+    private Params paramsFromKey(AsymmetricKey k) throws InvalidKeyException {\n+        var p = k.getParams();\n+        if (p instanceof ECParameterSpec ecp) {\n+            if (ECUtil.equals(ecp, CurveDB.P_256)) {\n@@ -370,1 +461,1 @@\n-            } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_384)) {\n+            } else if (ECUtil.equals(ecp, CurveDB.P_384)) {\n@@ -372,1 +463,1 @@\n-            } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_521)) {\n+            } else if (ECUtil.equals(ecp, CurveDB.P_521)) {\n@@ -375,2 +466,1 @@\n-        } else if (k instanceof XECKey xkey\n-                && xkey.getParams() instanceof NamedParameterSpec ns) {\n+        } else if (p instanceof NamedParameterSpec ns) {\n@@ -392,2 +482,5 @@\n-    private static byte[] I2OSP(int n, int w) {\n-        assert n < 256;\n+    \/\/ I2OSP(n, w) as defined in RFC 9180 Section 3.\n+    \/\/ In DHKEM and HPKE, number is always <65536\n+    \/\/ and converted to at most 2 bytes.\n+    public static byte[] I2OSP(int n, int w) {\n+        assert n < 65536;\n@@ -402,14 +495,6 @@\n-    private static SecretKey LabeledExtract(KDF hkdf, byte[] suite_id,\n-            byte[] label, byte[] ikm) throws InvalidKeyException {\n-        SecretKeySpec s = new SecretKeySpec(concat(HPKE_V1, suite_id, label,\n-                ikm), \"IKM\");\n-        try {\n-            HKDFParameterSpec spec =\n-                    HKDFParameterSpec.ofExtract().addIKM(s).extractOnly();\n-            return hkdf.deriveKey(\"Generic\", spec);\n-        } catch (InvalidAlgorithmParameterException |\n-                 NoSuchAlgorithmException e) {\n-            throw new InvalidKeyException(e.getMessage(), e);\n-        } finally {\n-            SharedSecrets.getJavaxCryptoSpecAccess().clearSecretKeySpec(s);\n-        }\n+    \/\/ Create a LabeledExtract builder with labels.\n+    \/\/ You can add more IKM and salt into the result.\n+    public static HKDFParameterSpec.Builder labeledExtract(\n+            byte[] suiteId, byte[] label) {\n+        return HKDFParameterSpec.ofExtract()\n+                .addIKM(HPKE_V1).addIKM(suiteId).addIKM(label);\n@@ -418,11 +503,19 @@\n-    private static byte[] LabeledExpand(KDF hkdf, byte[] suite_id,\n-            SecretKey prk, byte[] label, byte[] info, int L)\n-            throws InvalidKeyException {\n-        byte[] labeled_info = concat(I2OSP(L, 2), HPKE_V1, suite_id, label,\n-                info);\n-        try {\n-            return hkdf.deriveData(HKDFParameterSpec.expandOnly(\n-                    prk, labeled_info, L));\n-        } catch (InvalidAlgorithmParameterException iape) {\n-            throw new InvalidKeyException(iape.getMessage(), iape);\n-        }\n+    \/\/ Create a labeled info from info and labels\n+    private static byte[] labeledInfo(\n+            byte[] suiteId, byte[] label, byte[] info, int L) {\n+        return concat(I2OSP(L, 2), HPKE_V1, suiteId, label, info);\n+    }\n+\n+    \/\/ LabeledExpand from a builder\n+    public static HKDFParameterSpec labeledExpand(\n+            HKDFParameterSpec.Builder builder,\n+            byte[] suiteId, byte[] label, byte[] info, int L) {\n+        return builder.thenExpand(\n+                labeledInfo(suiteId, label, info, L), L);\n+    }\n+\n+    \/\/ LabeledExpand from a prk\n+    public static HKDFParameterSpec labeledExpand(\n+            SecretKey prk, byte[] suiteId, byte[] label, byte[] info, int L) {\n+        return HKDFParameterSpec.expandOnly(\n+                prk, labeledInfo(suiteId, label, info, L), L);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKEM.java","additions":198,"deletions":105,"binary":false,"changes":303,"status":"modified"},{"patch":"@@ -0,0 +1,585 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.crypto.provider;\n+\n+import sun.security.util.CurveDB;\n+import sun.security.util.ECUtil;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.CipherSpi;\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.KDF;\n+import javax.crypto.KEM;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.HPKEParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.ByteBuffer;\n+import java.security.AlgorithmParameters;\n+import java.security.AsymmetricKey;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.ECParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Arrays;\n+\n+public class HPKE extends CipherSpi {\n+\n+    private static final byte[] HPKE = new byte[]\n+            {'H', 'P', 'K', 'E'};\n+    private static final byte[] SEC = new byte[]\n+            {'s', 'e', 'c'};\n+    private static final byte[] PSK_ID_HASH = new byte[]\n+            {'p', 's', 'k', '_', 'i', 'd', '_', 'h', 'a', 's', 'h'};\n+    private static final byte[] INFO_HASH = new byte[]\n+            {'i', 'n', 'f', 'o', '_', 'h', 'a', 's', 'h'};\n+    private static final byte[] SECRET = new byte[]\n+            {'s', 'e', 'c', 'r', 'e', 't'};\n+    private static final byte[] EXP = new byte[]\n+            {'e', 'x', 'p'};\n+    private static final byte[] KEY = new byte[]\n+            {'k', 'e', 'y'};\n+    private static final byte[] BASE_NONCE = new byte[]\n+            {'b', 'a', 's', 'e', '_', 'n', 'o', 'n', 'c', 'e'};\n+\n+    private static final int BEGIN = 1;\n+    private static final int EXPORT_ONLY = 2; \/\/ init done with aead_id == 65535\n+    private static final int ENCRYPT_AND_EXPORT = 3; \/\/ int done with AEAD\n+    private static final int AFTER_FINAL = 4; \/\/ after doFinal, need reinit internal cipher\n+\n+    private int state = BEGIN;\n+    private Impl impl;\n+\n+    @Override\n+    protected void engineSetMode(String mode) throws NoSuchAlgorithmException {\n+        throw new NoSuchAlgorithmException(mode);\n+    }\n+\n+    @Override\n+    protected void engineSetPadding(String padding) throws NoSuchPaddingException {\n+        throw new NoSuchPaddingException(padding);\n+    }\n+\n+    @Override\n+    protected int engineGetBlockSize() {\n+        if (state == ENCRYPT_AND_EXPORT || state == AFTER_FINAL) {\n+            return impl.aead.cipher.getBlockSize();\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    protected int engineGetOutputSize(int inputLen) {\n+        if (state == ENCRYPT_AND_EXPORT || state == AFTER_FINAL) {\n+            return impl.aead.cipher.getOutputSize(inputLen);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    protected byte[] engineGetIV() {\n+        return (state == BEGIN || impl.kemEncaps == null)\n+                ? null : impl.kemEncaps.clone();\n+    }\n+\n+    @Override\n+    protected AlgorithmParameters engineGetParameters() {\n+        return null;\n+    }\n+\n+    @Override\n+    protected void engineInit(int opmode, Key key, SecureRandom random)\n+            throws InvalidKeyException {\n+        throw new InvalidKeyException(\"HPKEParameterSpec must be provided\");\n+    }\n+\n+    @Override\n+    protected void engineInit(int opmode, Key key,\n+            AlgorithmParameterSpec params, SecureRandom random)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        impl = new Impl(opmode);\n+        if (!(key instanceof AsymmetricKey ak)) {\n+            throw new InvalidKeyException(\"Not an asymmetric key\");\n+        }\n+        if (params instanceof HPKEParameterSpec hps) {\n+            impl.init(ak, hps, random);\n+        } else {\n+            throw new InvalidAlgorithmParameterException(\n+                    \"Unsupported params type: \" + params.getClass());\n+        }\n+        if (impl.hasEncrypt()) {\n+            impl.aead.start(impl.opmode, impl.context.k, impl.context.ComputeNonce());\n+            state = ENCRYPT_AND_EXPORT;\n+        } else {\n+            state = EXPORT_ONLY;\n+        }\n+    }\n+\n+    @Override\n+    protected void engineInit(int opmode, Key key,\n+            AlgorithmParameters params, SecureRandom random)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        throw new InvalidKeyException(\"HPKEParameterSpec must be provided\");\n+    }\n+\n+    \/\/ state is ENCRYPT_AND_EXPORT after this call succeeds\n+    private void maybeReinitInternalCipher() {\n+        if (state == BEGIN) {\n+            throw new IllegalStateException(\"Illegal state: \" + state);\n+        }\n+        if (state == EXPORT_ONLY) {\n+            throw new UnsupportedOperationException();\n+        }\n+        if (state == AFTER_FINAL) {\n+            impl.aead.start(impl.opmode, impl.context.k, impl.context.ComputeNonce());\n+            state = ENCRYPT_AND_EXPORT;\n+        }\n+    }\n+\n+    @Override\n+    protected byte[] engineUpdate(byte[] input, int inputOffset, int inputLen) {\n+        maybeReinitInternalCipher();\n+        return impl.aead.cipher.update(input, inputOffset, inputLen);\n+    }\n+\n+    @Override\n+    protected int engineUpdate(byte[] input, int inputOffset, int inputLen,\n+            byte[] output, int outputOffset) throws ShortBufferException {\n+        maybeReinitInternalCipher();\n+        return impl.aead.cipher.update(\n+                input, inputOffset, inputLen, output, outputOffset);\n+    }\n+\n+    @Override\n+    protected void engineUpdateAAD(byte[] src, int offset, int len) {\n+        maybeReinitInternalCipher();\n+        impl.aead.cipher.updateAAD(src, offset, len);\n+    }\n+\n+    @Override\n+    protected void engineUpdateAAD(ByteBuffer src) {\n+        maybeReinitInternalCipher();\n+        impl.aead.cipher.updateAAD(src);\n+    }\n+\n+    @Override\n+    protected byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen)\n+            throws IllegalBlockSizeException, BadPaddingException {\n+        maybeReinitInternalCipher();\n+        impl.context.IncrementSeq();\n+        state = AFTER_FINAL;\n+        if (input == null) { \/\/ a bug in doFinal(null, ?, ?)\n+            return impl.aead.cipher.doFinal();\n+        } else {\n+            return impl.aead.cipher.doFinal(input, inputOffset, inputLen);\n+        }\n+    }\n+\n+    @Override\n+    protected int engineDoFinal(byte[] input, int inputOffset, int inputLen,\n+            byte[] output, int outputOffset) throws ShortBufferException,\n+            IllegalBlockSizeException, BadPaddingException {\n+        maybeReinitInternalCipher();\n+        impl.context.IncrementSeq();\n+        state = AFTER_FINAL;\n+        return impl.aead.cipher.doFinal(\n+                input, inputOffset, inputLen, output, outputOffset);\n+    }\n+\n+    \/\/@Override\n+    protected SecretKey engineExportKey(String algorithm, byte[] context, int length) {\n+        if (state == BEGIN) {\n+            throw new IllegalStateException(\"State: \" + state);\n+        } else {\n+            return impl.context.ExportKey(algorithm, context, length);\n+        }\n+    }\n+\n+    \/\/@Override\n+    protected byte[] engineExportData(byte[] context, int length) {\n+        if (state == BEGIN) {\n+            throw new IllegalStateException(\"State: \" + state);\n+        } else {\n+            return impl.context.ExportData(context, length);\n+        }\n+    }\n+\n+    private static class AEAD {\n+        final Cipher cipher;\n+        final int Nk, Nn, Nt;\n+        final int id;\n+        public AEAD(int id) throws InvalidAlgorithmParameterException {\n+            this.id = id;\n+            try {\n+                switch (id) {\n+                    case HPKEParameterSpec.AEAD_AES_128_GCM -> {\n+                        cipher = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n+                        Nk = 16;\n+                    }\n+                    case HPKEParameterSpec.AEAD_AES_256_GCM -> {\n+                        cipher = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n+                        Nk = 32;\n+                    }\n+                    case HPKEParameterSpec.AEAD_CHACHA20_POLY1305 -> {\n+                        cipher = Cipher.getInstance(\"ChaCha20-Poly1305\");\n+                        Nk = 32;\n+                    }\n+                    case HPKEParameterSpec.EXPORT_ONLY -> {\n+                        cipher = null;\n+                        Nk = -1;\n+                    }\n+                    default -> throw new InvalidAlgorithmParameterException(\n+                            \"Unknown aead_id: \" + id);\n+                }\n+            } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n+                throw new ProviderException(\"Internal error\", e);\n+            }\n+            Nn = 12; Nt = 16;\n+        }\n+\n+        void start(int opmode, SecretKey key, byte[] nonce) {\n+            try {\n+                if (id == HPKEParameterSpec.AEAD_CHACHA20_POLY1305) {\n+                    cipher.init(opmode, key, new IvParameterSpec(nonce));\n+                } else {\n+                    cipher.init(opmode, key, new GCMParameterSpec(Nt * 8, nonce));\n+                }\n+            } catch (InvalidAlgorithmParameterException | InvalidKeyException e) {\n+                throw new ProviderException(\"Internal error\", e);\n+            }\n+        }\n+    }\n+\n+    private static class Impl {\n+\n+        final int opmode;\n+\n+        HPKEParameterSpec params;\n+        Context context;\n+        AEAD aead;\n+\n+        byte[] suite_id;\n+        String kdfAlg;\n+        int kdfNh;\n+\n+        \/\/ only used on sender side\n+        byte[] kemEncaps;\n+\n+        class Context {\n+            final SecretKey k; \/\/ null if only export\n+            final byte[] base_nonce;\n+            final SecretKey exporter_secret;\n+\n+            byte[] seq = new byte[aead.Nn];\n+\n+            public Context(SecretKey sk, byte[] base_nonce,\n+                    SecretKey exporter_secret) {\n+                this.k = sk;\n+                this.base_nonce = base_nonce;\n+                this.exporter_secret = exporter_secret;\n+            }\n+\n+            SecretKey ExportKey(String algorithm, byte[] exporter_context, int L) {\n+                if (exporter_context == null) {\n+                    throw new IllegalArgumentException(\"Null exporter_context\");\n+                }\n+                try {\n+                    var kdf = KDF.getInstance(kdfAlg);\n+                    return kdf.deriveKey(algorithm, DHKEM.labeledExpand(\n+                            exporter_secret, suite_id, SEC, exporter_context, L));\n+                } catch (InvalidAlgorithmParameterException | NoSuchAlgorithmException e) {\n+                    \/\/ algorithm not accepted by HKDF, L too big or too small\n+                    throw new IllegalArgumentException(\"Invalid input\", e);\n+                }\n+            }\n+\n+            byte[] ExportData(byte[] exporter_context, int L) {\n+                if (exporter_context == null) {\n+                    throw new IllegalArgumentException(\"Null exporter_context\");\n+                }\n+                try {\n+                    var kdf = KDF.getInstance(kdfAlg);\n+                    return kdf.deriveData(DHKEM.labeledExpand(\n+                            exporter_secret, suite_id, SEC, exporter_context, L));\n+                } catch (InvalidAlgorithmParameterException | NoSuchAlgorithmException e) {\n+                    \/\/ algorithm not accepted by HKDF, L too big or too small\n+                    throw new IllegalArgumentException(\"Invalid input\", e);\n+                }\n+            }\n+\n+            private byte[] ComputeNonce() {\n+                var result = new byte[aead.Nn];\n+                for (var i = 0; i < result.length; i++) {\n+                    result[i] = (byte)(seq[i] ^ base_nonce[i]);\n+                }\n+                return result;\n+            }\n+\n+            private void IncrementSeq() {\n+                for (var i = seq.length - 1; i >= 0; i--) {\n+                    if ((seq[i] & 0xff) == 0xff) {\n+                        seq[i] = 0;\n+                    } else {\n+                        seq[i]++;\n+                        return;\n+                    }\n+                }\n+                \/\/ seq >= (1 << (8*aead.Nn)) - 1 when this method is called\n+                throw new ProviderException(\"MessageLimitReachedError\");\n+            }\n+        }\n+\n+        public Impl(int opmode) {\n+            this.opmode = opmode;\n+        }\n+\n+        public boolean hasEncrypt() {\n+            return params.aead_id() != 65535;\n+        }\n+\n+        \/\/ Section 7.2.1 of RFC 9180 has restrictions on size of psk, psk_id,\n+        \/\/ info, and exporter_context (~2^61 for HMAC-SHA256 and ~2^125 for\n+        \/\/ HMAC-SHA384 and HMAC-SHA512). This method does not pose any\n+        \/\/ restrictions.\n+        public void init(AsymmetricKey key, HPKEParameterSpec p, SecureRandom rand)\n+                throws InvalidKeyException, InvalidAlgorithmParameterException {\n+            if (opmode != Cipher.ENCRYPT_MODE && opmode != Cipher.DECRYPT_MODE) {\n+                throw new UnsupportedOperationException(\n+                        \"Can only be used for encryption and decryption\");\n+            }\n+            setParams(p);\n+            SecretKey shared_secret;\n+            if (opmode == Cipher.ENCRYPT_MODE) {\n+                if (!(key instanceof PublicKey pk)) {\n+                    throw new InvalidKeyException(\n+                            \"Cannot encrypt with private key\");\n+                }\n+                if (p.encapsulation() != null) {\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"Must not provide key encapsulation message on sender side\");\n+                }\n+                checkMatch(false, pk, params.kem_id());\n+                KEM.Encapsulated enc;\n+                switch (p.authKey()) {\n+                    case null -> {\n+                        var e = kem().newEncapsulator(pk, rand);\n+                        enc = e.encapsulate();\n+                    }\n+                    case PrivateKey skS -> {\n+                        checkMatch(true, skS, params.kem_id());\n+                        \/\/ AuthEncap not public KEM API but it's internally supported\n+                        var e = new DHKEM().engineNewAuthEncapsulator(pk, skS, null, rand);\n+                        enc = e.engineEncapsulate(0, e.engineSecretSize(), \"Generic\");\n+                    }\n+                    default -> throw new InvalidAlgorithmParameterException(\n+                            \"Cannot auth with public key\");\n+                }\n+                kemEncaps = enc.encapsulation();\n+                shared_secret = enc.key();\n+            } else {\n+                if (!(key instanceof PrivateKey sk)) {\n+                    throw new InvalidKeyException(\"Cannot decrypt with public key\");\n+                }\n+                checkMatch(false, sk, params.kem_id());\n+                try {\n+                    var encap = p.encapsulation();\n+                    if (encap == null) {\n+                        throw new InvalidAlgorithmParameterException(\n+                                \"Must provide key encapsulation message on recipient side\");\n+                    }\n+                    switch (p.authKey()) {\n+                        case null -> {\n+                            var d = kem().newDecapsulator(sk);\n+                            shared_secret = d.decapsulate(encap);\n+                        }\n+                        case PublicKey pkS -> {\n+                            checkMatch(true, pkS, params.kem_id());\n+                            \/\/ AuthDecap not public KEM API but it's internally supported\n+                            var d = new DHKEM().engineNewAuthDecapsulator(sk, pkS, null);\n+                            shared_secret = d.engineDecapsulate(\n+                                    encap, 0, d.engineSecretSize(), \"Generic\");\n+                        }\n+                        default -> throw new InvalidAlgorithmParameterException(\n+                                \"Cannot auth with private key\");\n+                    }\n+                } catch (DecapsulateException e) {\n+                    throw new InvalidAlgorithmParameterException(e);\n+                }\n+            }\n+\n+            var usePSK = usePSK(params.psk());\n+            int mode = params.authKey() == null ? (usePSK ? 1 : 0) : (usePSK ? 3 : 2);\n+            context = KeySchedule(mode, shared_secret,\n+                    params.info(),\n+                    params.psk(),\n+                    params.psk_id());\n+        }\n+\n+        private static void checkMatch(boolean inSpec, AsymmetricKey k, int kem_id)\n+                throws InvalidKeyException, InvalidAlgorithmParameterException {\n+            var p = k.getParams();\n+            switch (p) {\n+                case ECParameterSpec ecp -> {\n+                    if ((!ECUtil.equals(ecp, CurveDB.P_256)\n+                            || kem_id != HPKEParameterSpec.KEM_DHKEM_P_256_HKDF_SHA256)\n+                            && (!ECUtil.equals(ecp, CurveDB.P_384)\n+                            || kem_id != HPKEParameterSpec.KEM_DHKEM_P_384_HKDF_SHA384)\n+                            && (!ECUtil.equals(ecp, CurveDB.P_521)\n+                            || kem_id != HPKEParameterSpec.KEM_DHKEM_P_521_HKDF_SHA512)) {\n+                        var name = ECUtil.getCurveName(ecp);\n+                        throw new InvalidAlgorithmParameterException(\n+                                name + \" does not match \" + kem_id);\n+                    }\n+                }\n+                case NamedParameterSpec ns -> {\n+                    var name = ns.getName();\n+                    if ((!name.equalsIgnoreCase(\"x25519\")\n+                            || kem_id != HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256)\n+                            && (!name.equalsIgnoreCase(\"x448\")\n+                            || kem_id != HPKEParameterSpec.KEM_DHKEM_X448_HKDF_SHA512)) {\n+                        throw new InvalidAlgorithmParameterException(\n+                                name + \" does not match \" + kem_id);\n+                    }\n+                }\n+                case null, default -> {\n+                    var msg = k.getClass() + \" does not match \" + kem_id;\n+                    if (inSpec) {\n+                        throw new InvalidAlgorithmParameterException(msg);\n+                    } else {\n+                        throw new InvalidKeyException(msg);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private KEM kem() {\n+            try {\n+                return KEM.getInstance(\"DHKEM\");\n+            } catch (NoSuchAlgorithmException e) {\n+                throw new ProviderException(\"Internal error\", e);\n+            }\n+        }\n+\n+        private void setParams(HPKEParameterSpec p)\n+                throws InvalidAlgorithmParameterException {\n+            params = p;\n+            suite_id = concat(\n+                    HPKE,\n+                    DHKEM.I2OSP(params.kem_id(), 2),\n+                    DHKEM.I2OSP(params.kdf_id(), 2),\n+                    DHKEM.I2OSP(params.aead_id(), 2));\n+            switch (params.kdf_id()) {\n+                case HPKEParameterSpec.KDF_HKDF_SHA256 -> {\n+                    kdfAlg = \"HKDF-SHA256\";\n+                    kdfNh = 32;\n+                }\n+                case HPKEParameterSpec.KDF_HKDF_SHA384 -> {\n+                    kdfAlg = \"HKDF-SHA384\";\n+                    kdfNh = 48;\n+                }\n+                case HPKEParameterSpec.KDF_HKDF_SHA512 -> {\n+                    kdfAlg = \"HKDF-SHA512\";\n+                    kdfNh = 64;\n+                }\n+                default -> throw new InvalidAlgorithmParameterException(\n+                        \"Unsupported kdf_id: \" + params.kdf_id());\n+            }\n+            aead = new AEAD(params.aead_id());\n+        }\n+\n+        private Context KeySchedule(int mode,\n+                SecretKey shared_secret,\n+                byte[] info,\n+                SecretKey psk,\n+                byte[] psk_id) {\n+            try {\n+                var psk_id_hash_x = DHKEM.labeledExtract(suite_id, PSK_ID_HASH)\n+                        .addIKM(psk_id).extractOnly();\n+                var info_hash_x = DHKEM.labeledExtract(suite_id, INFO_HASH)\n+                        .addIKM(info).extractOnly();\n+\n+                \/\/ deriveData must and can be called because all info to\n+                \/\/ thw builder are just byte arrays. Any KDF impl can handle this.\n+                var kdf = KDF.getInstance(kdfAlg);\n+                var key_schedule_context = concat(new byte[]{(byte) mode},\n+                        kdf.deriveData(psk_id_hash_x),\n+                        kdf.deriveData(info_hash_x));\n+\n+                var secret_x_builder = DHKEM.labeledExtract(suite_id, SECRET);\n+                if (psk != null) {\n+                    secret_x_builder.addIKM(psk);\n+                }\n+                secret_x_builder.addSalt(shared_secret);\n+                var secret_x = kdf.deriveKey(\"Generic\", secret_x_builder.extractOnly());\n+\n+                \/\/ A new KDF object must be created because secret_x_builder\n+                \/\/ might contain provider-specific keys which the previous\n+                \/\/ KDF (provider already chosen) cannot handle.\n+                kdf = KDF.getInstance(kdfAlg);\n+                var exporter_secret = kdf.deriveKey(\"Generic\", DHKEM.labeledExpand(\n+                        secret_x, suite_id, EXP, key_schedule_context, kdfNh));\n+\n+                if (hasEncrypt()) {\n+                    \/\/ ChaCha20-Poly1305 does not care about algorithm name\n+                    var key = kdf.deriveKey(\"AES\", DHKEM.labeledExpand(secret_x,\n+                            suite_id, KEY, key_schedule_context, aead.Nk));\n+                    \/\/ deriveData must be called because we need to increment nonce\n+                    var base_nonce = kdf.deriveData(DHKEM.labeledExpand(secret_x,\n+                            suite_id, BASE_NONCE, key_schedule_context, aead.Nn));\n+                    return new Context(key, base_nonce, exporter_secret);\n+                } else {\n+                    return new Context(null, null, exporter_secret);\n+                }\n+            } catch (InvalidAlgorithmParameterException\n+                     | NoSuchAlgorithmException | UnsupportedOperationException e) {\n+                throw new ProviderException(\"Internal error\", e);\n+            }\n+        }\n+    }\n+\n+    private static boolean usePSK(SecretKey psk) {\n+        return psk != null;\n+    }\n+\n+    private static byte[] concat(byte[]... inputs) {\n+        var o = new ByteArrayOutputStream();\n+        Arrays.stream(inputs).forEach(o::writeBytes);\n+        return o.toByteArray();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HPKE.java","additions":585,"deletions":0,"binary":false,"changes":585,"status":"added"},{"patch":"@@ -374,0 +374,2 @@\n+        ps(\"Cipher\", \"HPKE\", \"com.sun.crypto.provider.HPKE\");\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,443 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javax.crypto.spec;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import java.nio.charset.StandardCharsets;\n+import java.security.AsymmetricKey;\n+import java.security.Key;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.Objects;\n+\n+\/**\n+ * This immutable class specifies the set of parameters used with a {@code Cipher} for the\n+ * <a href=\"https:\/\/www.rfc-editor.org\/info\/rfc9180\">Hybrid Public Key Encryption<\/a>\n+ * (HPKE) algorithm. HPKE is a public key encryption scheme for encrypting\n+ * arbitrary-sized plaintexts with a recipient's public key. It combines a key\n+ * encapsulation mechanism (KEM), a key derivation function (KDF), and an\n+ * authenticated encryption with additional data (AEAD) cipher.\n+ * <p>\n+ * The <a href=\"{@docRoot}\/..\/specs\/security\/standard-names.html#cipher-algorithms\">\n+ * standard algorithm name<\/a> for the cipher is \"HPKE\". Unlike most other\n+ * ciphers, HPKE is not expressed as a transformation string of the form\n+ * \"algorithm\/mode\/padding\". Therefore, the argument to {@code Cipher.getInstance}\n+ * must be the single algorithm name \"HPKE\".\n+ * <p>\n+ * In HPKE, the sender's {@code Cipher} is always initialized with the\n+ * recipient's public key in {@linkplain Cipher#ENCRYPT_MODE encrypt mode},\n+ * while the recipient's {@code Cipher} object is initialized with its own\n+ * private key in {@linkplain Cipher#DECRYPT_MODE decrypt mode}.\n+ * <p>\n+ * An {@code HPKEParameterSpec} object must be provided at HPKE\n+ * {@linkplain Cipher#init(int, Key, AlgorithmParameterSpec) cipher initialization}.\n+ * <p>\n+ * The {@link #of(int, int, int)} static method returns an {@code HPKEParameterSpec}\n+ * object with the specified KEM, KDF, and AEAD algorithm identifiers.\n+ * The terms \"KEM algorithm identifiers\", \"KDF algorithm identifiers\", and\n+ * \"AEAD algorithm identifiers\" refer to their respective numeric values\n+ * (specifically, {@code kem_id}, {@code kdf_id}, and {@code aead_id}) as\n+ * defined in <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#section-7\">Section 7<\/a>\n+ * of RFC 9180 and maintained on the\n+ * <a href=\"https:\/\/www.iana.org\/assignments\/hpke\/hpke.xhtml\">IANA HPKE page<\/a>.\n+ * <p>\n+ * Once an {@code HPKEParameterSpec} object is created, additional methods\n+ * are available to generate new {@code HPKEParameterSpec} objects with\n+ * different features:\n+ * <ul>\n+ * <li>\n+ * Application-supplied information can be provided using the\n+ * {@link #withInfo(byte[])} method by both sides.\n+ * <li>\n+ * To authenticate using a pre-shared key ({@code mode_psk}), the\n+ * pre-shared key and its identifier must be provided using the\n+ * {@link #withPsk(SecretKey, byte[])} method by both sides.\n+ * <li>\n+ * To authenticate using an asymmetric key ({@code mode_auth}),\n+ * the asymmetric keys must be provided using the {@link #withAuthKey(AsymmetricKey)}\n+ * method. Precisely, the sender must call this method with its own private key\n+ * and the recipient must call it with the sender's public key.\n+ * <li>\n+ * To authenticate using both a PSK and an asymmetric key\n+ * ({@code mode_auth_psk}), both {@link #withAuthKey(AsymmetricKey)} and\n+ * {@link #withPsk(SecretKey, byte[])} methods must be called as described above.\n+ * <li>\n+ * In HPKE, a shared secret is negotiated during the KEM step and a key\n+ * encapsulation message must be transmitted from the sender to the recipient\n+ * so that the recipient can recover the shared secret. On the sender side,\n+ * after the cipher is initialized, the key encapsulation message can be\n+ * retrieved using the {@link Cipher#getIV()} method. On the recipient side,\n+ * this message must be supplied as part of an {@code HPKEParameterSpec}\n+ * object obtained from the {@link #withEncapsulation(byte[])} method.\n+ * <\/ul>\n+ * For successful interoperability, both sides need to have identical algorithm\n+ * identifiers, and supply identical\n+ * {@code info}, {@code psk}, and {@code psk_id} or matching authentication\n+ * keys if provided. For details about HPKE modes, refer to\n+ * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#section-5\">Section 5<\/a>\n+ * of RFC 9180.\n+ * <p>\n+ * If an HPKE cipher is {@linkplain Cipher#init(int, Key) initialized without\n+ * parameters}, an {@code InvalidKeyException} is thrown.\n+ * <p>\n+ * At HPKE cipher initialization, if no HPKE implementation supports the\n+ * provided key type, an {@code InvalidKeyException} is thrown. If the provided\n+ * {@code HPKEParameterSpec} is not accepted by any HPKE implementation,\n+ * an {@code InvalidAlgorithmParameterException} is thrown. For example:\n+ * <ul>\n+ * <li> An algorithm identifier is unsupported or does not match the provided key type.\n+ * <li> A key encapsulation message is provided on the sender side.\n+ * <li> A key encapsulation message is not provided on the recipient side.\n+ * <li> An attempt to use {@code withAuthKey(key)} is made with an incompatible key.\n+ * <li> An attempt to use {@code withAuthKey(key)} is made but {@code mode_auth}\n+ *      or {@code mode_auth_psk} is not supported by the KEM algorithm used.\n+ * <\/ul>\n+ * After initialization, both the sender and recipient can process multiple\n+ * messages in sequence with repeated {@code doFinal} calls, optionally preceded\n+ * by one or more {@code updateAAD} and {@code update}. Each {@code doFinal}\n+ * performs a complete HPKE encryption or decryption operation using a distinct\n+ * IV derived from an internal sequence counter, as specified in\n+ * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#section-5.2\">Section 5.2<\/a>\n+ * of RFC 9180. On the recipient side, each {@code doFinal} call must correspond\n+ * to exactly one complete ciphertext, and the number and order of calls must\n+ * match those on the sender side. This differs from the direct use of an AEAD\n+ * cipher, where the caller must provide a fresh IV and reinitialize the cipher\n+ * for each message. By managing IVs internally, HPKE allows a single\n+ * initialization to support multiple messages while still ensuring IV\n+ * uniqueness and preserving AEAD security guarantees.\n+ * <p>\n+ * This example shows a sender and a recipient using HPKE to securely exchange\n+ * messages with an X25519 key pair.\n+ * {@snippet lang=java class=\"PackageSnippets\" region=\"hpke-spec-example\"}\n+ *\n+ * @implNote This class defines constants for some of the standard algorithm\n+ * identifiers such as {@link #KEM_DHKEM_P_256_HKDF_SHA256},\n+ * {@link #KDF_HKDF_SHA256}, and {@link #AEAD_AES_128_GCM}. An HPKE {@code Cipher}\n+ * implementation may support all, some, or none of the algorithm identifiers\n+ * defined here. An implementation may also support additional identifiers not\n+ * listed here, including private or experimental values.\n+ *\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc9180\n+ *      RFC 9180: Hybrid Public Key Encryption\n+ * @spec security\/standard-names.html\n+ *      Java Security Standard Algorithm Names\n+ * @since 26\n+ *\/\n+public final class HPKEParameterSpec implements AlgorithmParameterSpec {\n+\n+    \/**\n+     * KEM algorithm identifier for DHKEM(P-256, HKDF-SHA256) as defined in RFC 9180.\n+     *\/\n+    public static final int KEM_DHKEM_P_256_HKDF_SHA256 = 0x10;\n+\n+    \/**\n+     * KEM algorithm identifier for DHKEM(P-384, HKDF-SHA384) as defined in RFC 9180.\n+     *\/\n+    public static final int KEM_DHKEM_P_384_HKDF_SHA384 = 0x11;\n+\n+    \/**\n+     * KEM algorithm identifier for DHKEM(P-521, HKDF-SHA512) as defined in RFC 9180.\n+     *\/\n+    public static final int KEM_DHKEM_P_521_HKDF_SHA512 = 0x12;\n+\n+    \/**\n+     * KEM algorithm identifier for DHKEM(X25519, HKDF-SHA256) as defined in RFC 9180.\n+     *\/\n+    public static final int KEM_DHKEM_X25519_HKDF_SHA256 = 0x20;\n+\n+    \/**\n+     * KEM algorithm identifier for DHKEM(X448, HKDF-SHA512) as defined in RFC 9180.\n+     *\/\n+    public static final int KEM_DHKEM_X448_HKDF_SHA512 = 0x21;\n+\n+    \/**\n+     * KDF algorithm identifier for HKDF-SHA256 as defined in RFC 9180.\n+     *\/\n+    public static final int KDF_HKDF_SHA256 = 0x1;\n+\n+    \/**\n+     * KDF algorithm identifier for HKDF-SHA384 as defined in RFC 9180.\n+     *\/\n+    public static final int KDF_HKDF_SHA384 = 0x2;\n+\n+    \/**\n+     * KDF algorithm identifier for HKDF-SHA512 as defined in RFC 9180.\n+     *\/\n+    public static final int KDF_HKDF_SHA512 = 0x3;\n+\n+    \/**\n+     * AEAD algorithm identifier for AES-128-GCM as defined in RFC 9180.\n+     *\/\n+    public static final int AEAD_AES_128_GCM = 0x1;\n+\n+    \/**\n+     * AEAD algorithm identifier for AES-256-GCM as defined in RFC 9180.\n+     *\/\n+    public static final int AEAD_AES_256_GCM = 0x2;\n+\n+    \/**\n+     * AEAD algorithm identifier for ChaCha20Poly1305 as defined in RFC 9180.\n+     *\/\n+    public static final int AEAD_CHACHA20_POLY1305 = 0x3;\n+\n+    \/**\n+     * AEAD algorithm identifier for Export-only as defined in RFC 9180.\n+     *\/\n+    public static final int EXPORT_ONLY = 0xffff;\n+\n+    private final int kem_id;\n+    private final int kdf_id;\n+    private final int aead_id;\n+    private final byte[] info; \/\/ never null, can be empty\n+    private final SecretKey psk; \/\/ null if not used\n+    private final byte[] psk_id; \/\/ never null, can be empty\n+    private final AsymmetricKey kS; \/\/ null if not used\n+    private final byte[] encapsulation; \/\/ null if none\n+\n+    \/\/ Note: this constructor does not clone array arguments.\n+    private HPKEParameterSpec(int kem_id, int kdf_id, int aead_id, byte[] info,\n+            SecretKey psk, byte[] psk_id, AsymmetricKey kS, byte[] encapsulation) {\n+        this.kem_id = kem_id;\n+        this.kdf_id = kdf_id;\n+        this.aead_id = aead_id;\n+        this.info = info;\n+        this.psk = psk;\n+        this.psk_id = psk_id;\n+        this.kS = kS;\n+        this.encapsulation = encapsulation;\n+    }\n+\n+    \/**\n+     * A factory method to create a new {@code HPKEParameterSpec} object with\n+     * specified KEM, KDF, and AEAD algorithm identifiers in {@code mode_base}\n+     * mode with an empty {@code info}.\n+     *\n+     * @param kem_id algorithm identifier for KEM, must be between 0 and 65535 (inclusive)\n+     * @param kdf_id algorithm identifier for KDF, must be between 0 and 65535 (inclusive)\n+     * @param aead_id algorithm identifier for AEAD, must be between 0 and 65535 (inclusive)\n+     * @return a new {@code HPKEParameterSpec} object\n+     * @throws IllegalArgumentException if any input value\n+     *      is out of range (must be between 0 and 65535, inclusive).\n+     *\/\n+    public static HPKEParameterSpec of(int kem_id, int kdf_id, int aead_id) {\n+        if (kem_id < 0 || kem_id > 65535) {\n+            throw new IllegalArgumentException(\"Invalid kem_id: \" + kem_id);\n+        }\n+        if (kdf_id < 0 || kdf_id > 65535) {\n+            throw new IllegalArgumentException(\"Invalid kdf_id: \" + kdf_id);\n+        }\n+        if (aead_id < 0 || aead_id > 65535) {\n+            throw new IllegalArgumentException(\"Invalid aead_id: \" + aead_id);\n+        }\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                new byte[0], null, new byte[0], null, null);\n+    }\n+\n+    \/**\n+     * Creates a new {@code HPKEParameterSpec} object with the specified\n+     * {@code info} value.\n+     * <p>\n+     * For interoperability, RFC 9180 Section 7.2.1 recommends limiting\n+     * this value to a maximum of 64 bytes.\n+     *\n+     * @param info application-supplied information.\n+     *      The contents of the array are copied to protect\n+     *      against subsequent modification.\n+     * @return a new {@code HPKEParameterSpec} object\n+     * @throws NullPointerException if {@code info} is {@code null}\n+     * @throws IllegalArgumentException if {@code info} is empty.\n+     *\/\n+    public HPKEParameterSpec withInfo(byte[] info) {\n+        Objects.requireNonNull(info);\n+        if (info.length == 0) {\n+            throw new IllegalArgumentException(\"info is empty\");\n+        }\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                info.clone(), psk, psk_id, kS, encapsulation);\n+    }\n+\n+    \/**\n+     * Creates a new {@code HPKEParameterSpec} object with the specified\n+     * {@code psk} and {@code psk_id} values.\n+     * <p>\n+     * RFC 9180 Section 5.1.2 requires the PSK MUST have at least 32 bytes\n+     * of entropy. For interoperability, RFC 9180 Section 7.2.1 recommends\n+     * limiting the key size and identifier length to a maximum of 64 bytes.\n+     *\n+     * @param psk pre-shared key\n+     * @param psk_id identifier for PSK. The contents of the array are copied\n+     *               to protect against subsequent modification.\n+     * @return a new {@code HPKEParameterSpec} object\n+     * @throws NullPointerException if {@code psk} or {@code psk_id} is {@code null}\n+     * @throws IllegalArgumentException if {@code psk} is shorter than 32 bytes\n+     *                                  or {@code psk_id} is empty\n+     *\/\n+    public HPKEParameterSpec withPsk(SecretKey psk, byte[] psk_id) {\n+        Objects.requireNonNull(psk);\n+        Objects.requireNonNull(psk_id);\n+        if (psk_id.length == 0) {\n+            throw new IllegalArgumentException(\"psk_id is empty\");\n+        }\n+        if (\"RAW\".equalsIgnoreCase(psk.getFormat())) {\n+            \/\/ We can only check when psk is extractable. We can only\n+            \/\/ check the length and not the real entropy size\n+            var keyBytes = psk.getEncoded();\n+            assert keyBytes != null;\n+            Arrays.fill(keyBytes, (byte)0);\n+            if (keyBytes.length < 32) {\n+                throw new IllegalArgumentException(\"psk is too short\");\n+            }\n+        }\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                info, psk, psk_id.clone(), kS, encapsulation);\n+    }\n+\n+    \/**\n+     * Creates a new {@code HPKEParameterSpec} object with the specified\n+     * key encapsulation message value that will be used by the recipient.\n+     *\n+     * @param encapsulation the key encapsulation message.\n+     *      The contents of the array are copied to protect against\n+     *      subsequent modification.\n+     *\n+     * @return a new {@code HPKEParameterSpec} object\n+     * @throws NullPointerException if {@code encapsulation} is {@code null}\n+     *\/\n+    public HPKEParameterSpec withEncapsulation(byte[] encapsulation) {\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                info, psk, psk_id, kS,\n+                Objects.requireNonNull(encapsulation).clone());\n+    }\n+\n+    \/**\n+     * Creates a new {@code HPKEParameterSpec} object with the specified\n+     * authentication key value.\n+     * <p>\n+     * Note: this method does not check whether the KEM algorithm supports\n+     * {@code mode_auth} or {@code mode_auth_psk}. If the resulting object is\n+     * used to initialize an HPKE cipher with an unsupported mode, an\n+     * {@code InvalidAlgorithmParameterException} will be thrown at that time.\n+     *\n+     * @param kS the authentication key\n+     * @return a new {@code HPKEParameterSpec} object\n+     * @throws NullPointerException if {@code kS} is {@code null}\n+     *\/\n+    public HPKEParameterSpec withAuthKey(AsymmetricKey kS) {\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                info, psk, psk_id,\n+                Objects.requireNonNull(kS),\n+                encapsulation);\n+    }\n+\n+    \/**\n+     * {@return the algorithm identifier for KEM }\n+     *\/\n+    public int kem_id() {\n+        return kem_id;\n+    }\n+\n+    \/**\n+     * {@return the algorithm identifier for KDF }\n+     *\/\n+    public int kdf_id() {\n+        return kdf_id;\n+    }\n+\n+    \/**\n+     * {@return the algorithm identifier for AEAD }\n+     *\/\n+    public int aead_id() {\n+        return aead_id;\n+    }\n+\n+    \/**\n+     * {@return a copy of the application-supplied information, empty if none}\n+     *\/\n+    public byte[] info() {\n+        return info.clone();\n+    }\n+\n+    \/**\n+     * {@return pre-shared key, {@code null} if none}\n+     *\/\n+    public SecretKey psk() {\n+        return psk;\n+    }\n+\n+    \/**\n+     * {@return a copy of the identifier for PSK, empty if none}\n+     *\/\n+    public byte[] psk_id() {\n+        return psk_id.clone();\n+    }\n+\n+    \/**\n+     * {@return the key for authentication, {@code null} if none}\n+     *\/\n+    public AsymmetricKey authKey() {\n+        return kS;\n+    }\n+\n+    \/**\n+     * {@return a copy of the key encapsulation message, {@code null} if none}\n+     *\/\n+    public byte[] encapsulation() {\n+        return encapsulation == null ? null : encapsulation.clone();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HPKEParameterSpec{\" +\n+                \"kem_id=\" + kem_id +\n+                \", kdf_id=\" + kdf_id +\n+                \", aead_id=\" + aead_id +\n+                \", info=\" + bytesToString(info) +\n+                \", \" + (psk == null\n+                        ? (kS == null ? \"mode_base\" : \"mode_auth\")\n+                        : (kS == null ? \"mode_psk\" : \"mode_auth_psk\")) + \"}\";\n+    }\n+\n+    \/\/ Returns a human-readable representation of a byte array.\n+    private static String bytesToString(byte[] input) {\n+        if (input.length == 0) {\n+            return \"(empty)\";\n+        } else {\n+            for (byte b : input) {\n+                if (b < 0x20 || b > 0x7E || b == '\"') {\n+                    \/\/ Non-ASCII or control characters are hard to read, and\n+                    \/\/ `\"` requires character escaping. If any of these are\n+                    \/\/ present, return only the HEX representation.\n+                    return HexFormat.of().formatHex(input);\n+                }\n+            }\n+            \/\/ Otherwise, all characters are printable and safe.\n+            \/\/ Return both HEX and ASCII representations.\n+            return HexFormat.of().formatHex(input)\n+                    + \" (\\\"\" + new String(input, StandardCharsets.US_ASCII) + \"\\\")\";\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/HPKEParameterSpec.java","additions":443,"deletions":0,"binary":false,"changes":443,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.HPKEParameterSpec;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+\n+class PackageSnippets {\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ @start region=\"hpke-spec-example\"\n+        \/\/ Recipient key pair generation\n+        KeyPairGenerator g = KeyPairGenerator.getInstance(\"X25519\");\n+        KeyPair kp = g.generateKeyPair();\n+\n+        \/\/ The HPKE sender cipher is initialized with the recipient's public\n+        \/\/ key and an HPKEParameterSpec using specified algorithm identifiers\n+        \/\/ and application-supplied info.\n+        Cipher senderCipher = Cipher.getInstance(\"HPKE\");\n+        HPKEParameterSpec ps = HPKEParameterSpec.of(\n+                        HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256,\n+                        HPKEParameterSpec.KDF_HKDF_SHA256,\n+                        HPKEParameterSpec.AEAD_AES_128_GCM)\n+                .withInfo(HexFormat.of().parseHex(\"010203040506\"));\n+        senderCipher.init(Cipher.ENCRYPT_MODE, kp.getPublic(), ps);\n+\n+        \/\/ Retrieve the key encapsulation message (from the KEM step) from\n+        \/\/ the sender.\n+        byte[] kemEncap = senderCipher.getIV();\n+\n+        \/\/ The HPKE recipient cipher is initialized with its own private key,\n+        \/\/ an HPKEParameterSpec using the same algorithm identifiers as used by\n+        \/\/ the sender, and the key encapsulation message from the sender.\n+        Cipher recipientCipher = Cipher.getInstance(\"HPKE\");\n+        HPKEParameterSpec pr = HPKEParameterSpec.of(\n+                        HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256,\n+                        HPKEParameterSpec.KDF_HKDF_SHA256,\n+                        HPKEParameterSpec.AEAD_AES_128_GCM)\n+                .withInfo(HexFormat.of().parseHex(\"010203040506\"))\n+                .withEncapsulation(kemEncap);\n+        recipientCipher.init(Cipher.DECRYPT_MODE, kp.getPrivate(), pr);\n+\n+        \/\/ Encryption and decryption\n+        byte[] msg = \"Hello World\".getBytes(StandardCharsets.UTF_8);\n+        byte[] ct = senderCipher.doFinal(msg);\n+        byte[] pt = recipientCipher.doFinal(ct);\n+\n+        assert Arrays.equals(msg, pt);\n+        \/\/ @end\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/snippet-files\/PackageSnippets.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.security.util;\n+\n+import javax.crypto.SecretKey;\n+\n+\/**\n+ * An interface for <code>SecretKey<\/code>s that support using its slice as a new\n+ * <code>SecretKey<\/code>.\n+ * <p>\n+ * This is mainly used by PKCS #11 implementations that support the\n+ * EXTRACT_KEY_FROM_KEY mechanism even if the key itself is sensitive\n+ * and non-extractable.\n+ *\/\n+public interface SliceableSecretKey {\n+\n+    \/**\n+     * Returns a slice as a new <code>SecretKey<\/code>.\n+     *\n+     * @param alg the new algorithm name\n+     * @param from the byte offset of the new key in the full key\n+     * @param to the to offset (exclusive) of the new key in the full key\n+     * @return the new key\n+     * @throws ArrayIndexOutOfBoundsException for improper <code>from<\/code>\n+     *      and <code>to<\/code> values\n+     * @throws UnsupportedOperationException if slicing is not supported\n+     *\/\n+    SecretKey slice(String alg, int from, int to);\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SliceableSecretKey.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.HPKEParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.NamedParameterSpec;\n+\n+import static javax.crypto.spec.HPKEParameterSpec.AEAD_AES_256_GCM;\n+import static javax.crypto.spec.HPKEParameterSpec.KDF_HKDF_SHA256;\n+import static javax.crypto.spec.HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256;\n+\n+\/*\n+ * @test\n+ * @bug 8325448\n+ * @library \/test\/lib\n+ * @summary HPKE compliance test\n+ *\/\n+public class Compliance {\n+    public static void main(String[] args) throws Exception {\n+\n+        var kp = KeyPairGenerator.getInstance(\"X25519\").generateKeyPair();\n+        var info = \"info\".getBytes(StandardCharsets.UTF_8);\n+        var psk = new SecretKeySpec(new byte[32], \"ONE\");\n+        var shortKey = new SecretKeySpec(new byte[31], \"ONE\");\n+        var psk_id = \"psk_id\".getBytes(StandardCharsets.UTF_8);\n+        var emptyKey = new SecretKey() {\n+            public String getAlgorithm() { return \"GENERIC\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return new byte[0]; }\n+        };\n+\n+        \/\/ HPKEParameterSpec\n+\n+        \/\/ A typical spec\n+        var spec = HPKEParameterSpec.of(\n+                KEM_DHKEM_X25519_HKDF_SHA256,\n+                KDF_HKDF_SHA256,\n+                AEAD_AES_256_GCM);\n+        Asserts.assertEQ(spec.kem_id(), KEM_DHKEM_X25519_HKDF_SHA256);\n+        Asserts.assertEQ(spec.kdf_id(), KDF_HKDF_SHA256);\n+        Asserts.assertEQ(spec.aead_id(), AEAD_AES_256_GCM);\n+        Asserts.assertEQ(spec.authKey(), null);\n+        Asserts.assertEQ(spec.encapsulation(), null);\n+        Asserts.assertEqualsByteArray(spec.info(), new byte[0]);\n+        Asserts.assertEQ(spec.psk(), null);\n+        Asserts.assertEqualsByteArray(spec.psk_id(), new byte[0]);\n+\n+        \/\/ A fake spec but still valid\n+        var specZero = HPKEParameterSpec.of(0, 0, 0);\n+        Asserts.assertEQ(specZero.kem_id(), 0);\n+        Asserts.assertEQ(specZero.kdf_id(), 0);\n+        Asserts.assertEQ(specZero.aead_id(), 0);\n+        Asserts.assertEQ(specZero.authKey(), null);\n+        Asserts.assertEQ(specZero.encapsulation(), null);\n+        Asserts.assertEqualsByteArray(specZero.info(), new byte[0]);\n+        Asserts.assertEQ(specZero.psk(), null);\n+        Asserts.assertEqualsByteArray(specZero.psk_id(), new byte[0]);\n+\n+        \/\/ identifiers\n+        HPKEParameterSpec.of(65535, 65535, 65535);\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> HPKEParameterSpec.of(-1, 0, 0));\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> HPKEParameterSpec.of(0, -1, 0));\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> HPKEParameterSpec.of(0, 0, -1));\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> HPKEParameterSpec.of(65536, 0, 0));\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> HPKEParameterSpec.of(0, 65536, 0));\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> HPKEParameterSpec.of(0, 0, 65536));\n+\n+        \/\/ auth key\n+        Asserts.assertTrue(spec.withAuthKey(kp.getPrivate()).authKey() != null);\n+        Asserts.assertTrue(spec.withAuthKey(kp.getPublic()).authKey() != null);\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.withAuthKey(null));\n+\n+        \/\/ info\n+        Asserts.assertEqualsByteArray(spec.withInfo(info).info(), info);\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.withInfo(null));\n+        Asserts.assertThrows(IllegalArgumentException.class, () -> spec.withInfo(new byte[0]));\n+\n+        \/\/ encapsulation\n+        Asserts.assertEqualsByteArray(spec.withEncapsulation(info).encapsulation(), info);\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.withEncapsulation(null));\n+        Asserts.assertTrue(spec.withEncapsulation(new byte[0]).encapsulation().length == 0); \/\/ not emptiness check (yet)\n+\n+        \/\/ psk_id and psk\n+        Asserts.assertEqualsByteArray(spec.withPsk(psk, psk_id).psk().getEncoded(), psk.getEncoded());\n+        Asserts.assertEqualsByteArray(spec.withPsk(psk, psk_id).psk_id(), psk_id);\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.withPsk(psk, null));\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.withPsk(null, psk_id));\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.withPsk(null, null));\n+        Asserts.assertThrows(IllegalArgumentException.class, () -> spec.withPsk(psk, new byte[0]));\n+        Asserts.assertThrows(IllegalArgumentException.class, () -> spec.withPsk(emptyKey, psk_id));\n+        Asserts.assertThrows(IllegalArgumentException.class, () -> spec.withPsk(shortKey, psk_id));\n+\n+        \/\/ toString\n+        Asserts.assertTrue(spec.toString().contains(\"kem_id=32, kdf_id=1, aead_id=2\"));\n+        Asserts.assertTrue(spec.toString().contains(\"info=(empty),\"));\n+        Asserts.assertTrue(spec.withInfo(new byte[3]).toString().contains(\"info=000000,\"));\n+        Asserts.assertTrue(spec.withInfo(\"info\".getBytes(StandardCharsets.UTF_8))\n+                .toString().contains(\"info=696e666f (\\\"info\\\"),\"));\n+        Asserts.assertTrue(spec.withInfo(\"\\\"info\\\"\".getBytes(StandardCharsets.UTF_8))\n+                .toString().contains(\"info=22696e666f22,\"));\n+        Asserts.assertTrue(spec.withInfo(\"'info'\".getBytes(StandardCharsets.UTF_8))\n+                .toString().contains(\"info=27696e666f27 (\\\"'info'\\\"),\"));\n+        Asserts.assertTrue(spec.withInfo(\"i\\\\n\\\\f\\\\o\".getBytes(StandardCharsets.UTF_8))\n+                .toString().contains(\"info=695c6e5c665c6f (\\\"i\\\\n\\\\f\\\\o\\\"),\"));\n+        Asserts.assertTrue(spec.toString().contains(\"mode_base}\"));\n+        Asserts.assertTrue(spec.withPsk(psk, psk_id).toString().contains(\"mode_psk}\"));\n+        Asserts.assertTrue(spec.withAuthKey(kp.getPrivate()).toString().contains(\"mode_auth}\"));\n+        Asserts.assertTrue(spec.withAuthKey(kp.getPrivate()).withPsk(psk, psk_id).toString().contains(\"mode_auth_psk}\"));\n+\n+        var c1 = Cipher.getInstance(\"HPKE\");\n+\n+        Asserts.assertThrows(NoSuchAlgorithmException.class, () -> Cipher.getInstance(\"HPKE\/None\/NoPadding\"));\n+\n+        \/\/ Still at BEGIN, not initialized\n+        Asserts.assertEQ(c1.getIV(), null);\n+        Asserts.assertEQ(c1.getParameters(), null);\n+        Asserts.assertEquals(0, c1.getBlockSize());\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.getOutputSize(100));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.update(new byte[1]));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.update(new byte[1], 0, 1));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.updateAAD(new byte[1]));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.updateAAD(new byte[1], 0, 1));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.doFinal());\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.doFinal(new byte[1]));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.doFinal(new byte[1], 0, 1));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.doFinal(new byte[1], 0, 1, new byte[1024], 0));\n+\n+        c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), spec);\n+        var encap = c1.getIV();\n+\n+        \/\/ Does not support WRAP and UNWRAP mode\n+        Asserts.assertThrows(UnsupportedOperationException.class,\n+                () -> c1.init(Cipher.WRAP_MODE, kp.getPublic(), spec));\n+        Asserts.assertThrows(UnsupportedOperationException.class,\n+                () -> c1.init(Cipher.UNWRAP_MODE, kp.getPublic(), spec));\n+\n+        \/\/ Cannot init sender with private key\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPrivate(), spec));\n+\n+        \/\/ Cannot provide key encap msg to sender\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        spec.withEncapsulation(encap)));\n+\n+        \/\/ Cannot init without HPKEParameterSpec\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic()));\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> c1.init(Cipher.DECRYPT_MODE, kp.getPrivate()));\n+\n+        \/\/ Cannot init with a spec not HPKEParameterSpec\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        NamedParameterSpec.X25519));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                        NamedParameterSpec.X25519));\n+\n+        \/\/ Cannot init recipient with public key\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> c1.init(Cipher.DECRYPT_MODE, kp.getPublic(),\n+                        spec.withEncapsulation(new byte[32])));\n+        \/\/ Cannot provide key encap msg to sender\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), spec.withEncapsulation(encap)));\n+        \/\/ Must provide key encap msg to recipient\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.DECRYPT_MODE, kp.getPrivate(), spec));\n+\n+        \/\/ Unsupported identifiers\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of(0, KDF_HKDF_SHA256, AEAD_AES_256_GCM)));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of(0x200, KDF_HKDF_SHA256, AEAD_AES_256_GCM)));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of(KEM_DHKEM_X25519_HKDF_SHA256, 4, AEAD_AES_256_GCM)));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of(KEM_DHKEM_X25519_HKDF_SHA256, KDF_HKDF_SHA256, 4)));\n+\n+        \/\/ HPKE\n+        checkEncryptDecrypt(kp, spec, spec);\n+\n+        \/\/ extra features\n+        var kp2 = KeyPairGenerator.getInstance(\"X25519\").generateKeyPair();\n+        checkEncryptDecrypt(kp,\n+                spec.withInfo(info),\n+                spec.withInfo(info));\n+        checkEncryptDecrypt(kp,\n+                spec.withPsk(psk, psk_id),\n+                spec.withPsk(psk, psk_id));\n+        checkEncryptDecrypt(kp,\n+                spec.withAuthKey(kp2.getPrivate()),\n+                spec.withAuthKey(kp2.getPublic()));\n+        checkEncryptDecrypt(kp,\n+                spec.withInfo(info).withPsk(psk, psk_id).withAuthKey(kp2.getPrivate()),\n+                spec.withInfo(info).withPsk(psk, psk_id).withAuthKey(kp2.getPublic()));\n+\n+        \/\/ wrong keys\n+        var kpRSA = KeyPairGenerator.getInstance(\"RSA\").generateKeyPair();\n+        var kpEC = KeyPairGenerator.getInstance(\"EC\").generateKeyPair();\n+\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kpRSA.getPublic(), spec));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kpEC.getPublic(), spec));\n+\n+        \/\/ mod_auth, wrong key type\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        spec.withAuthKey(kp2.getPublic())));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                        spec.withAuthKey(kp2.getPrivate())));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        spec.withAuthKey(kpRSA.getPrivate())));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        spec.withAuthKey(kpEC.getPrivate())));\n+    }\n+\n+    static void checkEncryptDecrypt(KeyPair kp, HPKEParameterSpec ps,\n+            HPKEParameterSpec pr) throws Exception {\n+\n+        var c1 = Cipher.getInstance(\"HPKE\");\n+        var c2 = Cipher.getInstance(\"HPKE\");\n+        var aad = \"AAD\".getBytes(StandardCharsets.UTF_8);\n+\n+        c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), ps);\n+        Asserts.assertEquals(16, c1.getBlockSize());\n+        Asserts.assertEquals(116, c1.getOutputSize(100));\n+        c1.updateAAD(aad);\n+        var ct = c1.doFinal(new byte[2]);\n+\n+        c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                pr.withEncapsulation(c1.getIV()));\n+        Asserts.assertEquals(16, c2.getBlockSize());\n+        Asserts.assertEquals(84, c2.getOutputSize(100));\n+        c2.updateAAD(aad);\n+        Asserts.assertEqualsByteArray(c2.doFinal(ct), new byte[2]);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/Compliance.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.HPKEParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.spec.ECGenParameterSpec;\n+import java.util.List;\n+\n+import static javax.crypto.spec.HPKEParameterSpec.AEAD_AES_128_GCM;\n+import static javax.crypto.spec.HPKEParameterSpec.AEAD_AES_256_GCM;\n+import static javax.crypto.spec.HPKEParameterSpec.AEAD_CHACHA20_POLY1305;\n+import static javax.crypto.spec.HPKEParameterSpec.KDF_HKDF_SHA256;\n+import static javax.crypto.spec.HPKEParameterSpec.KDF_HKDF_SHA384;\n+import static javax.crypto.spec.HPKEParameterSpec.KDF_HKDF_SHA512;\n+import static javax.crypto.spec.HPKEParameterSpec.KEM_DHKEM_P_256_HKDF_SHA256;\n+import static javax.crypto.spec.HPKEParameterSpec.KEM_DHKEM_P_384_HKDF_SHA384;\n+import static javax.crypto.spec.HPKEParameterSpec.KEM_DHKEM_P_521_HKDF_SHA512;\n+import static javax.crypto.spec.HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256;\n+import static javax.crypto.spec.HPKEParameterSpec.KEM_DHKEM_X448_HKDF_SHA512;\n+\n+\/*\n+ * @test\n+ * @bug 8325448\n+ * @library \/test\/lib\n+ * @summary HPKE running with different keys\n+ *\/\n+public class Functions {\n+\n+    record Params(String name, int kem) {}\n+    static List<Params> PARAMS = List.of(\n+            new Params(\"secp256r1\", KEM_DHKEM_P_256_HKDF_SHA256),\n+            new Params(\"secp384r1\", KEM_DHKEM_P_384_HKDF_SHA384),\n+            new Params(\"secp521r1\", KEM_DHKEM_P_521_HKDF_SHA512),\n+            new Params(\"X25519\", KEM_DHKEM_X25519_HKDF_SHA256),\n+            new Params(\"X448\", KEM_DHKEM_X448_HKDF_SHA512)\n+    );\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        var msg = \"hello\".getBytes(StandardCharsets.UTF_8);\n+        var msg2 = \"goodbye\".getBytes(StandardCharsets.UTF_8);\n+        var info = \"info\".getBytes(StandardCharsets.UTF_8);\n+        var psk = new SecretKeySpec(\"K\".repeat(32).getBytes(StandardCharsets.UTF_8), \"Generic\");\n+        var psk_id = \"psk1\".getBytes(StandardCharsets.UTF_8);\n+\n+        for (var param : PARAMS) {\n+            var c1 = Cipher.getInstance(\"HPKE\");\n+            var c2 = Cipher.getInstance(\"HPKE\");\n+            var kp = genKeyPair(param.name());\n+            var kp2 = genKeyPair(param.name());\n+            for (var kdf : List.of(KDF_HKDF_SHA256, KDF_HKDF_SHA384, KDF_HKDF_SHA512)) {\n+                for (var aead : List.of(AEAD_AES_256_GCM, AEAD_AES_128_GCM, AEAD_CHACHA20_POLY1305)) {\n+\n+                    var params = HPKEParameterSpec.of(param.kem, kdf, aead);\n+                    System.out.println(params);\n+\n+                    c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), params);\n+                    c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(), params.withEncapsulation(c1.getIV()));\n+                    Asserts.assertEqualsByteArray(msg, c2.doFinal(c1.doFinal(msg)));\n+                    Asserts.assertEqualsByteArray(msg2, c2.doFinal(c1.doFinal(msg2)));\n+\n+                    c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), params\n+                            .withAuthKey(kp2.getPrivate())\n+                            .withInfo(info)\n+                            .withPsk(psk, psk_id));\n+                    c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(), params\n+                            .withAuthKey(kp2.getPublic())\n+                            .withInfo(info)\n+                            .withPsk(psk, psk_id)\n+                            .withEncapsulation(c1.getIV()));\n+                    Asserts.assertEqualsByteArray(msg, c2.doFinal(c1.doFinal(msg)));\n+                    Asserts.assertEqualsByteArray(msg2, c2.doFinal(c1.doFinal(msg2)));\n+                }\n+            }\n+        }\n+    }\n+\n+    static KeyPair genKeyPair(String name) throws Exception {\n+        if (name.startsWith(\"secp\")) {\n+            var g = KeyPairGenerator.getInstance(\"EC\");\n+            g.initialize(new ECGenParameterSpec(name));\n+            return g.generateKeyPair();\n+        } else {\n+            return KeyPairGenerator.getInstance(name).generateKeyPair();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/Functions.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8325448\n+ * @summary KAT inside RFC 9180\n+ * @library \/test\/lib\n+ * @modules java.base\/com.sun.crypto.provider\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.artifacts.Artifact;\n+import jdk.test.lib.artifacts.ArtifactResolver;\n+import jdk.test.lib.json.JSONValue;\n+\n+import com.sun.crypto.provider.DHKEM;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.HPKEParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HexFormat;\n+\n+\/\/\/ This test is based on Appendix A (Test Vectors) of\n+\/\/\/ [RFC 9180](https:\/\/datatracker.ietf.org\/doc\/html\/rfc9180#name-test-vectors)\n+\/\/\/ The test data is available as a JSON file at:\n+\/\/\/ https:\/\/github.com\/cfrg\/draft-irtf-cfrg-hpke\/blob\/5f503c564da00b0687b3de75f1dfbdfc4079ad31\/test-vectors.json.\n+\/\/\/\n+\/\/\/ The JSON file can either be hosted on an artifactory server or\n+\/\/\/ provided via a local path with\n+\/\/\/ ```\n+\/\/\/ jtreg -Djdk.test.lib.artifacts.rfc9180-test-vectors=<local-json-file> KAT9180.java\n+\/\/\/ ```\n+public class KAT9180 {\n+\n+    @Artifact(\n+            organization = \"jpg.tests.jdk.ietf\",\n+            name = \"rfc9180-test-vectors\",\n+            revision = \"5f503c5\",\n+            extension = \"json\",\n+            unpack = false)\n+    private static class RFC_9180_KAT {\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        var h = HexFormat.of();\n+        Path archivePath = ArtifactResolver.fetchOne(RFC_9180_KAT.class);\n+        System.out.println(\"Data path: \" + archivePath);\n+        var c1 = Cipher.getInstance(\"HPKE\");\n+        var c2 = Cipher.getInstance(\"HPKE\");\n+        var ts = JSONValue.parse(new String(Files.readAllBytes(archivePath), StandardCharsets.UTF_8));\n+        for (var tg : ts.asArray()) {\n+            var mode = Integer.parseInt(tg.get(\"mode\").asString());\n+            System.err.print('I');\n+            var kem_id = Integer.parseInt(tg.get(\"kem_id\").asString());\n+            var kdf_id = Integer.parseInt(tg.get(\"kdf_id\").asString());\n+            var aead_id = Integer.parseInt(tg.get(\"aead_id\").asString());\n+            var ikmR = h.parseHex(tg.get(\"ikmR\").asString());\n+            var ikmE = h.parseHex(tg.get(\"ikmE\").asString());\n+            var info = h.parseHex(tg.get(\"info\").asString());\n+\n+            var kpR = new DHKEM.RFC9180DeriveKeyPairSR(ikmR).derive(kem_id);\n+            var spec = HPKEParameterSpec.of(kem_id, kdf_id, aead_id).withInfo(info);\n+            var rand = new DHKEM.RFC9180DeriveKeyPairSR(ikmE);\n+\n+            if (mode == 1 || mode == 3) {\n+                spec = spec.withPsk(\n+                        new SecretKeySpec(h.parseHex(tg.get(\"psk\").asString()), \"Generic\"),\n+                        h.parseHex(tg.get(\"psk_id\").asString()));\n+            }\n+            if (mode == 0 || mode == 1) {\n+                c1.init(Cipher.ENCRYPT_MODE, kpR.getPublic(), spec, rand);\n+                c2.init(Cipher.DECRYPT_MODE, kpR.getPrivate(),\n+                        spec.withEncapsulation(c1.getIV()));\n+            } else {\n+                var ikmS = h.parseHex(tg.get(\"ikmS\").asString());\n+                var kpS = new DHKEM.RFC9180DeriveKeyPairSR(ikmS).derive(kem_id);\n+                c1.init(Cipher.ENCRYPT_MODE, kpR.getPublic(),\n+                        spec.withAuthKey(kpS.getPrivate()), rand);\n+                c2.init(Cipher.DECRYPT_MODE, kpR.getPrivate(),\n+                        spec.withEncapsulation(c1.getIV()).withAuthKey(kpS.getPublic()));\n+            }\n+            var enc = tg.get(\"encryptions\");\n+            if (enc != null) {\n+                System.err.print('e');\n+                var count = 0;\n+                for (var p : enc.asArray()) {\n+                    var aad = h.parseHex(p.get(\"aad\").asString());\n+                    var pt = h.parseHex(p.get(\"pt\").asString());\n+                    var ct = h.parseHex(p.get(\"ct\").asString());\n+                    c1.updateAAD(aad);\n+                    var ct1 = c1.doFinal(pt);\n+                    Asserts.assertEqualsByteArray(ct, ct1);\n+                    c2.updateAAD(aad);\n+                    var pt1 = c2.doFinal(ct);\n+                    Asserts.assertEqualsByteArray(pt, pt1);\n+                    count++;\n+                }\n+                System.err.print(count);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/KAT9180.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import jdk.test.lib.Utils;\n@@ -44,1 +43,0 @@\n-import java.util.Objects;\n@@ -46,1 +44,0 @@\n-import java.util.function.Consumer;\n@@ -69,6 +66,4 @@\n-        Utils.runAndCheckException(\n-                () -> new KEM.Encapsulated(null, new byte[0], null),\n-                NullPointerException.class);\n-        Utils.runAndCheckException(\n-                () -> new KEM.Encapsulated(new SecretKeySpec(new byte[1], \"X\"), null, null),\n-                NullPointerException.class);\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> new KEM.Encapsulated(null, new byte[0], null));\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> new KEM.Encapsulated(new SecretKeySpec(new byte[1], \"X\"), null, null));\n@@ -89,16 +84,11 @@\n-        Utils.runAndCheckException(\n-                () -> KEM.getInstance(\"OLALA\"),\n-                NoSuchAlgorithmException.class);\n-        Utils.runAndCheckException(\n-                () -> KEM.getInstance(\"DHKEM\", \"NoWhere\"),\n-                NoSuchProviderException.class);\n-        Utils.runAndCheckException(\n-                () -> KEM.getInstance(\"DHKEM\", \"SunRsaSign\"),\n-                NoSuchAlgorithmException.class);\n-\n-        Utils.runAndCheckException(\n-                () -> kem.newEncapsulator(null),\n-                InvalidKeyException.class);\n-        Utils.runAndCheckException(\n-                () -> kem.newDecapsulator(null),\n-                InvalidKeyException.class);\n+        Asserts.assertThrows(NoSuchAlgorithmException.class,\n+                () -> KEM.getInstance(\"OLALA\"));\n+        Asserts.assertThrows(NoSuchProviderException.class,\n+                () -> KEM.getInstance(\"DHKEM\", \"NoWhere\"));\n+        Asserts.assertThrows(NoSuchAlgorithmException.class,\n+                () -> KEM.getInstance(\"DHKEM\", \"SunRsaSign\"));\n+\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> kem.newEncapsulator(null));\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> kem.newDecapsulator(null));\n@@ -107,3 +97,4 @@\n-        Utils.runAndCheckException(\n-                () -> kem.newEncapsulator(badECKey()),\n-                ExChecker.of(InvalidKeyException.class).by(DHKEM.class));\n+        checkThrownBy(Asserts.assertThrows(\n+                InvalidKeyException.class,\n+                () -> kem.newEncapsulator(badECKey())),\n+                DHKEM.class.getName());\n@@ -113,3 +104,4 @@\n-        Utils.runAndCheckException(\n-                () -> kem.newEncapsulator(kpRSA.getPublic()),\n-                ExChecker.of(InvalidKeyException.class).by(KEM.class.getName() + \"$DelayedKEM\"));\n+        checkThrownBy(Asserts.assertThrows(\n+                InvalidKeyException.class,\n+                () -> kem.newEncapsulator(kpRSA.getPublic())),\n+                KEM.class.getName() + \"$DelayedKEM\");\n@@ -117,3 +109,2 @@\n-        Utils.runAndCheckException(\n-                () -> kem.newDecapsulator(kpRSA.getPrivate()),\n-                InvalidKeyException.class);\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> kem.newDecapsulator(kpRSA.getPrivate()));\n@@ -128,9 +119,6 @@\n-        Utils.runAndCheckException(\n-                () -> e2.encapsulate(-1, 12, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> e2.encapsulate(0, e2.secretSize() + 1, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> e2.encapsulate(0, e2.secretSize(), null),\n-                NullPointerException.class);\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> e2.encapsulate(-1, 12, \"AES\"));\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> e2.encapsulate(0, e2.secretSize() + 1, \"AES\"));\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> e2.encapsulate(0, e2.secretSize(), null));\n@@ -165,12 +153,8 @@\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(null),\n-                NullPointerException.class);\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(enc.encapsulation(), -1, 12, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize() + 1, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize(), null),\n-                NullPointerException.class);\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> d.decapsulate(null));\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> d.decapsulate(enc.encapsulation(), -1, 12, \"AES\"));\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize() + 1, \"AES\"));\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize(), null));\n@@ -181,3 +165,2 @@\n-        Utils.runAndCheckException(\n-                () -> d3.decapsulate(enc2.encapsulation()),\n-                DecapsulateException.class);\n+        Asserts.assertThrows(DecapsulateException.class,\n+                () -> d3.decapsulate(enc2.encapsulation()));\n@@ -185,3 +168,2 @@\n-        Utils.runAndCheckException(\n-                () -> d3.decapsulate(new byte[100]),\n-                DecapsulateException.class);\n+        Asserts.assertThrows(DecapsulateException.class,\n+                () -> d3.decapsulate(new byte[100]));\n@@ -276,29 +258,3 @@\n-    \/\/ Used by Utils.runAndCheckException. Checks for type and final thrower.\n-    record ExChecker(Class<? extends Throwable> ex, String caller)\n-            implements Consumer<Throwable> {\n-        ExChecker {\n-            Objects.requireNonNull(ex);\n-        }\n-        static ExChecker of(Class<? extends Throwable> ex) {\n-            return new ExChecker(ex, null);\n-        }\n-        ExChecker by(String caller) {\n-            return new ExChecker(ex(), caller);\n-        }\n-        ExChecker by(Class<?> caller) {\n-            return new ExChecker(ex(), caller.getName());\n-        }\n-        @Override\n-        public void accept(Throwable t) {\n-            if (t == null) {\n-                throw new AssertionError(\"no exception thrown\");\n-            } else if (!ex.isAssignableFrom(t.getClass())) {\n-                throw new AssertionError(\"exception thrown is \" + t.getClass());\n-            } else if (caller == null) {\n-                return;\n-            } else if (t.getStackTrace()[0].getClassName().equals(caller)) {\n-                return;\n-            } else {\n-                throw new AssertionError(\"thrown by \" + t.getStackTrace()[0].getClassName());\n-            }\n-        }\n+    \/\/ Ensures `t` is thrown by `caller`\n+    static <T extends Throwable> void checkThrownBy(T t, String caller) {\n+        Asserts.assertEquals(caller, t.getStackTrace()[0].getClassName());\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/DHKEM\/Compliance.java","additions":47,"deletions":91,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import javax.crypto.spec.HPKEParameterSpec;\n@@ -99,0 +100,5 @@\n+        } else if (alg.equals(\"HPKE\")) {\n+            key = KeyPairGenerator.getInstance(\"x25519\").generateKeyPair().getPublic();\n+            spec = HPKEParameterSpec.of(HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256,\n+                    HPKEParameterSpec.KDF_HKDF_SHA256,\n+                    HPKEParameterSpec.AEAD_AES_256_GCM);\n@@ -242,0 +248,2 @@\n+        } if (s.equals(\"HPKE\")) {\n+            return generateKeyPair(\"EC\", 3).getPublic();\n","filename":"test\/jdk\/sun\/security\/provider\/all\/Deterministic.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.util.SliceableSecretKey;\n+\n+import javax.crypto.KDF;\n+import javax.crypto.KDFParameters;\n+import javax.crypto.KDFSpi;\n+import javax.crypto.KEM;\n+import javax.crypto.SecretKey;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+\n+\/*\n+ * @test\n+ * @bug 8325448\n+ * @library \/test\/lib \/test\/jdk\/security\/unsignedjce\n+ * @build java.base\/javax.crypto.ProviderVerifier\n+ * @modules java.base\/sun.security.util\n+ * @run main\/othervm SoftSliceable\n+ * @summary Showcase how Sliceable can be used in DHKEM\n+ *\/\n+public class SoftSliceable {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Put an HKDF-SHA256 impl that is preferred to the SunJCE one\n+        Security.insertProviderAt(new ProviderImpl(), 1);\n+\n+        \/\/ Just plain KEM calls\n+        var kp = KeyPairGenerator.getInstance(\"X25519\").generateKeyPair();\n+        var k = KEM.getInstance(\"DHKEM\");\n+        var e = k.newEncapsulator(kp.getPublic());\n+        var d = k.newDecapsulator(kp.getPrivate());\n+        var enc = e.encapsulate(3, 9, \"Generic\");\n+        var k2 = d.decapsulate(enc.encapsulation(), 3, 9, \"Generic\");\n+        var k2full = d.decapsulate(enc.encapsulation());\n+\n+        if (enc.key() instanceof KeyImpl ki1\n+                && k2 instanceof KeyImpl ki2\n+                && k2full instanceof KeyImpl ki2full) {\n+            \/\/ So the keys do come from the new provider, and\n+            \/\/ 1. It has the correct length\n+            Asserts.assertEquals(6, ki1.bytes.length);\n+            \/\/ 2. encaps and decaps result in same keys\n+            Asserts.assertEqualsByteArray(ki1.bytes, ki2.bytes);\n+            \/\/ 3. The key is the correct slice from the full shared secret\n+            Asserts.assertEqualsByteArray(\n+                    Arrays.copyOfRange(ki2full.bytes, 3, 9), ki2.bytes);\n+        } else {\n+            throw new Exception(\"Unexpected key types\");\n+        }\n+    }\n+\n+    \/\/ A trivial SliceableSecretKey that is non-extractable with getBytes()\n+    public static class KeyImpl implements SecretKey, SliceableSecretKey {\n+\n+        private final byte[] bytes;\n+        private final String algorithm;\n+\n+        public KeyImpl(byte[] bytes, String algorithm) {\n+            this.bytes = bytes.clone();\n+            this.algorithm = algorithm;\n+        }\n+\n+        @Override\n+        public String getAlgorithm() {\n+            return algorithm;\n+        }\n+\n+        @Override\n+        public String getFormat() {\n+            return null;\n+        }\n+\n+        @Override\n+        public byte[] getEncoded() {\n+            return null;\n+        }\n+\n+        @Override\n+        public SecretKey slice(String alg, int from, int to) {\n+            return new KeyImpl(Arrays.copyOfRange(bytes, from, to), algorithm);\n+        }\n+    }\n+\n+    \/\/ Our new provider\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"A\", \"A\", \"A\");\n+            put(\"KDF.HKDF-SHA256\", KDFImpl.class.getName());\n+        }\n+    }\n+\n+    \/\/ Our new HKDF-SHA256 impl that always returns a KeyImpl object\n+    public static class KDFImpl extends KDFSpi {\n+\n+        public KDFImpl(KDFParameters p)\n+                throws InvalidAlgorithmParameterException {\n+            super(p);\n+        }\n+\n+        @Override\n+        protected KDFParameters engineGetParameters() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected SecretKey engineDeriveKey(String alg, AlgorithmParameterSpec spec)\n+                throws InvalidAlgorithmParameterException {\n+            try {\n+                var kdf = KDF.getInstance(\"HKDF-SHA256\", \"SunJCE\");\n+                var bytes = kdf.deriveData(spec);\n+                return new KeyImpl(bytes, alg);\n+            } catch (NoSuchAlgorithmException | NoSuchProviderException e) {\n+                throw new AssertionError(\"Cannot happen\", e);\n+            }\n+        }\n+\n+        @Override\n+        protected byte[] engineDeriveData(AlgorithmParameterSpec spec) {\n+            throw new UnsupportedOperationException(\"Cannot derive data\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/util\/SliceableSecretKey\/SoftSliceable.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"}]}