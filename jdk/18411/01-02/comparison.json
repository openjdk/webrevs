{"files":[{"patch":"@@ -121,2 +121,2 @@\n- * var g = KeyPairGenerator.getInstance(\"X25519\");\n- * var kp = g.generateKeyPair();\n+ * KeyPairGenerator g = KeyPairGenerator.getInstance(\"X25519\");\n+ * KeyPair kp = g.generateKeyPair();\n@@ -125,2 +125,2 @@\n- * var sender = Cipher.getInstance(\"HPKE\");\n- * var ps = HPKEParameterSpec.of()\n+ * Cipher sender = Cipher.getInstance(\"HPKE\");\n+ * HPKEParameterSpec ps = HPKEParameterSpec.of()\n@@ -131,1 +131,1 @@\n- * var kemEncap = sender.getIV();\n+ * byte[] kemEncap = sender.getIV();\n@@ -135,2 +135,2 @@\n- * var recipient = Cipher.getInstance(\"HPKE\");\n- * var pr = HPKEParameterSpec.of()\n+ * Cipher recipient = Cipher.getInstance(\"HPKE\");\n+ * HPKEParameterSpec pr = HPKEParameterSpec.of()\n@@ -142,3 +142,3 @@\n- * var msg = \"Hello World\".getBytes(StandardCharsets.UTF_8);\n- * var ct = sender.doFinal(msg);\n- * var pt = recipient.doFinal(ct);\n+ * byte[] msg = \"Hello World\".getBytes(StandardCharsets.UTF_8);\n+ * byte[] ct = sender.doFinal(msg);\n+ * byte[] pt = recipient.doFinal(ct);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/HPKEParameterSpec.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -38,3 +38,0 @@\n-    \/\/\/ This method may return the original object if `from` is 0 and\n-    \/\/\/ `to` is the length of the original key.\n-    \/\/\/\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SliceableSecretKey.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8325448\n+ * @summary KAT inside RFC 9180\n+ * @library \/test\/lib\n+ * @modules java.base\/com.sun.crypto.provider\n+ *\/\n+import jdk.test.lib.artifacts.Artifact;\n+import jdk.test.lib.artifacts.ArtifactResolver;\n+import jdk.test.lib.artifacts.ArtifactResolverException;\n+import jdk.test.lib.json.JSONValue;\n+import jtreg.SkippedException;\n+\n+import com.sun.crypto.provider.DHKEM;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.HPKEParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+\n+\/\/\/ This test is baed on Appendix A (Test Vectors) of\n+\/\/\/ [RFC 9180](https:\/\/datatracker.ietf.org\/doc\/html\/rfc9180#name-test-vectors)\n+\/\/\/ The test data is available as a JSON file at:\n+\/\/\/ https:\/\/github.com\/cfrg\/draft-irtf-cfrg-hpke\/blob\/5f503c564da00b0687b3de75f1dfbdfc4079ad31\/test-vectors.json.\n+\/\/\/\n+\/\/\/ The JSON file can either be hosted on an artifactory server or\n+\/\/\/ provided via a local path with\n+\/\/\/ ```\n+\/\/\/ jtreg -Djdk.test.lib.artifacts.test-vectors=<local-json-file> KAT9180.java\n+\/\/\/ ```\n+public class KAT9180 {\n+\n+    @Artifact(\n+            organization = \"jpg.tests.jdk.ietf.rfc9180\",\n+            name = \"test-vectors\",\n+            revision = \"5f503c5\",\n+            extension = \"json\",\n+            unpack = false)\n+    private static class RFC_9180_KAT {\n+    }\n+\n+    private static Path fetchACVPServerTests(Class<?> clazz) {\n+        try {\n+            return ArtifactResolver.resolve(clazz).entrySet().stream()\n+                    .findAny().get().getValue();\n+        } catch (ArtifactResolverException e) {\n+            Throwable cause = e.getCause();\n+            if (cause == null) {\n+                throw new SkippedException(\"Cannot resolve artifact, \"\n+                        + \"please check if JIB jar is present in classpath.\", e);\n+            }\n+\n+            throw new SkippedException(\"Fetch artifact failed: \" + clazz, e);\n+        }\n+    }\n+\n+    static final HexFormat h = HexFormat.of();\n+\n+    public static void main(String[] args) throws Exception {\n+        Path archivePath = fetchACVPServerTests(RFC_9180_KAT.class);\n+        System.out.println(\"Data path: \" + archivePath);\n+        var c1 = Cipher.getInstance(\"HPKE\");\n+        var c2 = Cipher.getInstance(\"HPKE\");\n+        var ts = JSONValue.parse(new String(Files.readAllBytes(archivePath), StandardCharsets.UTF_8));\n+        for (var tg : ts.asArray()) {\n+            var mode = tg.get(\"mode\").asString();\n+            if (mode.equals(\"0\") || mode.equals(\"1\")) {\n+                System.err.print('I');\n+                var kem_id = Integer.parseInt(tg.get(\"kem_id\").asString());\n+                var kdf_id = Integer.parseInt(tg.get(\"kdf_id\").asString());\n+                var aead_id = Integer.parseInt(tg.get(\"aead_id\").asString());\n+                var ikmR = h.parseHex(tg.get(\"ikmR\").asString());\n+                var ikmE = h.parseHex(tg.get(\"ikmE\").asString());\n+                var info = h.parseHex(tg.get(\"info\").asString());\n+                var kpR = new DHKEM.RFC9180DeriveKeyPairSR(ikmR).derive(kem_id);\n+                var spec = HPKEParameterSpec.of(kem_id, kdf_id, aead_id).info(info);\n+                if (mode.equals(\"1\")) {\n+                    spec = spec.psk(\n+                            new SecretKeySpec(h.parseHex(tg.get(\"psk\").asString()), \"Generic\"),\n+                            h.parseHex(tg.get(\"psk_id\").asString()));\n+                }\n+                c1.init(Cipher.ENCRYPT_MODE, kpR.getPublic(), spec,\n+                        new DHKEM.RFC9180DeriveKeyPairSR(ikmE));\n+                c2.init(Cipher.DECRYPT_MODE, kpR.getPrivate(),\n+                        spec.encapsulation(c1.getIV()));\n+            } else {\n+                continue; \/\/ auth not supported\n+            }\n+            var enc = tg.get(\"encryptions\");\n+            if (enc != null) {\n+                System.err.print('e');\n+                var count = 0;\n+                for (var p : enc.asArray()) {\n+                    var aad = h.parseHex(p.get(\"aad\").asString());\n+                    var pt = h.parseHex(p.get(\"pt\").asString());\n+                    var ct = h.parseHex(p.get(\"ct\").asString());\n+                    c1.updateAAD(aad);\n+                    var ct1 = c1.doFinal(pt);\n+                    assertEQ(ct, ct1);\n+                    c2.updateAAD(aad);\n+                    var pt1 = c2.doFinal(ct);\n+                    assertEQ(pt, pt1);\n+                    count++;\n+                }\n+                System.err.print(count);\n+            }\n+        }\n+    }\n+\n+    private static void assertEQ(byte[] s1, byte[] s2) {\n+        if (!Arrays.equals(s1, s2)) {\n+            System.out.println(h.formatHex(s1));\n+            System.out.println(h.formatHex(s2));\n+            throw new RuntimeException(\"not same\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/KAT9180.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"}]}