{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.security.interfaces.ECKey;\n@@ -33,1 +32,0 @@\n-import java.security.interfaces.XECKey;\n@@ -39,0 +37,1 @@\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -42,1 +41,0 @@\n-import sun.security.ssl.HKDF;\n@@ -80,5 +78,5 @@\n-                byte[] dh = params.DH(skE, pkR);\n-                byte[] key = params.ExtractAndExpand(dh, kem_context);\n-                return new KEM.Encapsulated(\n-                        new SecretKeySpec(key, from, to - from, algorithm),\n-                        pkEm, null);\n+                var dh = params.DH(skE, pkR);\n+                return new KEM.Encapsulated(params.deriveKey(\n+                        algorithm, from, to, kem_context, dh), pkEm, null);\n+            } catch (UnsupportedOperationException e) {\n+                throw e;\n@@ -101,1 +99,1 @@\n-                byte[] dh = params.DH(skR, pkE);\n+                var dh = params.DH(skR, pkE);\n@@ -104,2 +102,3 @@\n-                byte[] key = params.ExtractAndExpand(dh, kem_context);\n-                return new SecretKeySpec(key, from, to - from, algorithm);\n+                return params.deriveKey(algorithm, from, to, kem_context, dh);\n+            } catch (UnsupportedOperationException e) {\n+                throw e;\n@@ -156,1 +155,1 @@\n-                \"ECDH\", \"EC\", CurveDB.P_256, \"SHA-256\"),\n+                \"ECDH\", \"EC\", CurveDB.P_256, \"HKDF-SHA256\"),\n@@ -159,1 +158,1 @@\n-                \"ECDH\", \"EC\", CurveDB.P_384, \"SHA-384\"),\n+                \"ECDH\", \"EC\", CurveDB.P_384, \"HKDF-SHA384\"),\n@@ -162,1 +161,1 @@\n-                \"ECDH\", \"EC\", CurveDB.P_521, \"SHA-512\"),\n+                \"ECDH\", \"EC\", CurveDB.P_521, \"HKDF-SHA512\"),\n@@ -165,1 +164,1 @@\n-                \"XDH\", \"XDH\", NamedParameterSpec.X25519, \"SHA-256\"),\n+                \"XDH\", \"XDH\", NamedParameterSpec.X25519, \"HKDF-SHA256\"),\n@@ -168,1 +167,1 @@\n-                \"XDH\", \"XDH\", NamedParameterSpec.X448, \"SHA-512\"),\n+                \"XDH\", \"XDH\", NamedParameterSpec.X448, \"HKDF-SHA512\"),\n@@ -240,1 +239,1 @@\n-        private byte[] DH(PrivateKey skE, PublicKey pkR)\n+        private SecretKey DH(PrivateKey skE, PublicKey pkR)\n@@ -245,1 +244,1 @@\n-            return ka.generateSecret();\n+            return ka.generateSecret(\"Generic\");\n@@ -248,6 +247,39 @@\n-        private byte[] ExtractAndExpand(byte[] dh, byte[] kem_context)\n-                throws NoSuchAlgorithmException, InvalidKeyException {\n-            HKDF kdf = new HKDF(hkdfAlgorithm);\n-            SecretKey eae_prk = LabeledExtract(kdf, suiteId, null, EAE_PRK, dh);\n-            return LabeledExpand(kdf, suiteId, eae_prk, SHARED_SECRET,\n-                    kem_context, Nsecret);\n+        \/\/ The final shared secret derivation of either the encapsulator\n+        \/\/ or the decapsulator. The key slicing is implemented inside.\n+        \/\/ Throws UOE if cannot get a slice of the key.\n+        private SecretKey deriveKey(String alg, int from, int to,\n+                byte[] kem_context, SecretKey dh)\n+                throws NoSuchAlgorithmException {\n+            if (from == 0 && to == Nsecret) {\n+                return ExtractAndExpand(dh, kem_context, alg);\n+            } else {\n+                \/\/ First get shared secrets in \"Generic\" and then get a slice\n+                \/\/ of it in the requested algorithm.\n+                var fullKey = ExtractAndExpand(dh, kem_context, \"Generic\");\n+                if (\"RAW\".equalsIgnoreCase(fullKey.getFormat())) {\n+                    byte[] km = fullKey.getEncoded();\n+                    if (km == null) {\n+                        \/\/ Should not happen if format is \"RAW\"\n+                        throw new UnsupportedOperationException(\"Key extract failed\");\n+                    } else {\n+                        return new SecretKeySpec(km, from, to - from, alg);\n+                    }\n+                } else if (fullKey instanceof SliceableSecretKey ssk) {\n+                    return ssk.slice(alg, from, to);\n+                } else {\n+                    throw new UnsupportedOperationException(\"Cannot extract key\");\n+                }\n+            }\n+        }\n+\n+        private SecretKey ExtractAndExpand(SecretKey dh, byte[] kem_context, String alg)\n+                throws NoSuchAlgorithmException {\n+            var kdf = KDF.getInstance(hkdfAlgorithm);\n+            var ext = labeledBuilder(suiteId, EAE_PRK).addIKM(dh);\n+            try {\n+                return kdf.deriveKey(alg, ext.thenExpand(\n+                        labeledInfo(suiteId, SHARED_SECRET, kem_context, Nsecret),\n+                        Nsecret));\n+            } catch (InvalidAlgorithmParameterException e) {\n+                throw new ProviderException(e);\n+            }\n@@ -280,2 +312,2 @@\n-            HKDF kdf = new HKDF(hkdfAlgorithm);\n-            SecretKey dkp_prk = LabeledExtract(kdf, suiteId, null, DKP_PRK, ikm);\n+            var kdf = KDF.getInstance(hkdfAlgorithm);\n+            var extract = labeledBuilder(suiteId, DKP_PRK).addIKM(ikm);\n@@ -290,2 +322,2 @@\n-                    byte[] bytes = LabeledExpand(kdf, suiteId, dkp_prk,\n-                            CANDIDATE, I2OSP(counter, 1), Nsk);\n+                    byte[] bytes = kdf.deriveData(extract.thenExpand(labeledInfo(\n+                            suiteId, CANDIDATE, I2OSP(counter, 1), Nsk), Nsk));\n@@ -302,1 +334,2 @@\n-                byte[] sk = LabeledExpand(kdf, suiteId, dkp_prk, SK, EMPTY, Nsk);\n+                byte[] sk = kdf.deriveData(extract.thenExpand(\n+                        labeledInfo(suiteId, SK, EMPTY, Nsk), Nsk));\n@@ -347,3 +380,4 @@\n-    private Params paramsFromKey(Key k) throws InvalidKeyException {\n-        if (k instanceof ECKey eckey) {\n-            if (ECUtil.equals(eckey.getParams(), CurveDB.P_256)) {\n+    private Params paramsFromKey(AsymmetricKey k) throws InvalidKeyException {\n+        var p = k.getParams();\n+        if (p instanceof ECParameterSpec ecp) {\n+            if (ECUtil.equals(ecp, CurveDB.P_256)) {\n@@ -351,1 +385,1 @@\n-            } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_384)) {\n+            } else if (ECUtil.equals(ecp, CurveDB.P_384)) {\n@@ -353,1 +387,1 @@\n-            } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_521)) {\n+            } else if (ECUtil.equals(ecp, CurveDB.P_521)) {\n@@ -356,2 +390,1 @@\n-        } else if (k instanceof XECKey xkey\n-                && xkey.getParams() instanceof NamedParameterSpec ns) {\n+        } else if (p instanceof NamedParameterSpec ns) {\n@@ -373,2 +406,2 @@\n-    private static byte[] I2OSP(int n, int w) {\n-        assert n < 256;\n+    public static byte[] I2OSP(int n, int w) {\n+        assert n < 65536;\n@@ -383,5 +416,6 @@\n-    private static SecretKey LabeledExtract(HKDF kdf, byte[] suite_id,\n-            byte[] salt, byte[] label, byte[] ikm) throws InvalidKeyException {\n-        return kdf.extract(salt,\n-                new SecretKeySpec(concat(HPKE_V1, suite_id, label, ikm), \"IKM\"),\n-                    \"HKDF-PRK\");\n+    \/\/ Create an HKDFParameterSpec.Builder with HPKE label.\n+    \/\/ You can add more IKM and salt into the result.\n+    public static HKDFParameterSpec.Builder labeledBuilder(\n+            byte[] suiteId, byte[] label) {\n+        return HKDFParameterSpec.ofExtract()\n+                .addIKM(HPKE_V1).addIKM(suiteId).addIKM(label);\n@@ -390,6 +424,3 @@\n-    private static byte[] LabeledExpand(HKDF kdf, byte[] suite_id,\n-            SecretKey prk, byte[] label, byte[] info, int L)\n-            throws InvalidKeyException {\n-        byte[] labeled_info = concat(I2OSP(L, 2), HPKE_V1,\n-                suite_id, label, info);\n-        return kdf.expand(prk, labeled_info, L, \"NONE\").getEncoded();\n+    \/\/ Create an HPKE labeled info\n+    public static byte[] labeledInfo(byte[] suiteId, byte[] label, byte[] info, int L) {\n+        return concat(I2OSP(L, 2), HPKE_V1, suiteId, label, info);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKEM.java","additions":81,"deletions":50,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -0,0 +1,616 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.crypto.provider;\n+\n+import sun.security.util.CurveDB;\n+import sun.security.util.Debug;\n+import sun.security.util.ECUtil;\n+\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+import java.io.ByteArrayOutputStream;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.security.AlgorithmParameters;\n+import java.security.AsymmetricKey;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.Security;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.ECParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class HPKE extends CipherSpi {\n+\n+    private static final int BEGIN = 1;\n+    private static final int EXPORT_ONLY = 2; \/\/ init done with aead_id == 65535\n+    private static final int ENCRYPT_AND_EXPORT = 3; \/\/ int done with AEAD\n+    private static final int AFTER_FINAL = 4; \/\/ after doFinal, need reinit internal cipher\n+\n+    private int state = BEGIN;\n+    private Impl impl;\n+\n+    @Override\n+    protected void engineSetMode(String mode) throws NoSuchAlgorithmException {\n+        throw new NoSuchAlgorithmException(mode);\n+    }\n+\n+    @Override\n+    protected void engineSetPadding(String padding) throws NoSuchPaddingException {\n+        throw new NoSuchPaddingException(padding);\n+    }\n+\n+    @Override\n+    protected int engineGetBlockSize() {\n+        if (state == ENCRYPT_AND_EXPORT || state == AFTER_FINAL) {\n+            return impl.aead.cipher.getBlockSize();\n+        } else {\n+            throw new IllegalStateException(\"No AEAD cipher\");\n+        }\n+    }\n+\n+    @Override\n+    protected int engineGetOutputSize(int inputLen) {\n+        if (state == ENCRYPT_AND_EXPORT || state == AFTER_FINAL) {\n+            return impl.aead.cipher.getOutputSize(inputLen);\n+        } else {\n+            throw new IllegalStateException(\"No AEAD cipher\");\n+        }\n+    }\n+\n+    @Override\n+    protected byte[] engineGetIV() {\n+        return state == BEGIN ? null : impl.iv;\n+    }\n+\n+    @Override\n+    protected AlgorithmParameters engineGetParameters() {\n+        return null;\n+    }\n+\n+    @Override\n+    protected void engineInit(int opmode, Key key, SecureRandom random)\n+            throws InvalidKeyException {\n+        try {\n+            engineInit(opmode, key, (AlgorithmParameterSpec) null, random);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            \/\/ Parent spec says \"throws InvalidKeyException if the given key\n+            \/\/ requires algorithm parameters that cannot be determined from\n+            \/\/ the given key\"\n+            throw new InvalidKeyException(e);\n+        }\n+    }\n+\n+    @Override\n+    protected void engineInit(int opmode, Key key, AlgorithmParameterSpec params, SecureRandom random)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        impl = new Impl(opmode);\n+        if (!(key instanceof AsymmetricKey ak)) {\n+            throw new InvalidKeyException(\"Not asymmetric key\");\n+        }\n+        if (params == null) {\n+            impl.init(ak, HPKEParameterSpec.of(), random);\n+        } else if (params instanceof IvParameterSpec iv) {\n+            impl.init(ak, HPKEParameterSpec.of().encapsulation(iv.getIV()), random);\n+        } else if (params instanceof HPKEParameterSpec hps) {\n+            impl.init(ak, hps, random);\n+        } else {\n+            throw new InvalidAlgorithmParameterException(\"Unsupported params type: \" + params.getClass());\n+        }\n+        if (impl.hasEncrypt()) {\n+            impl.aead.start(impl.opmode, impl.context.k, impl.context.ComputeNonce());\n+            state = ENCRYPT_AND_EXPORT;\n+        } else {\n+            state = EXPORT_ONLY;\n+        }\n+    }\n+\n+    @Override\n+    protected void engineInit(int opmode, Key key, AlgorithmParameters params, SecureRandom random)\n+            throws InvalidAlgorithmParameterException {\n+        throw new InvalidAlgorithmParameterException();\n+    }\n+\n+    \/\/ state is ENCRYPT_AND_EXPORT after this call succeeds\n+    private void maybeReinitInternalCipher() {\n+        if (state == BEGIN) {\n+            throw new IllegalStateException();\n+        }\n+        if (state == EXPORT_ONLY) {\n+            throw new UnsupportedOperationException();\n+        }\n+        if (state == AFTER_FINAL) {\n+            impl.aead.start(impl.opmode, impl.context.k, impl.context.ComputeNonce());\n+            state = ENCRYPT_AND_EXPORT;\n+        }\n+    }\n+\n+    @Override\n+    protected byte[] engineUpdate(byte[] input, int inputOffset, int inputLen) {\n+        maybeReinitInternalCipher();\n+        return impl.aead.cipher.update(input, inputOffset, inputLen);\n+    }\n+\n+    @Override\n+    protected int engineUpdate(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws ShortBufferException {\n+        maybeReinitInternalCipher();\n+        return impl.aead.cipher.update(input, inputOffset, inputLen, output, outputOffset);\n+    }\n+\n+    @Override\n+    protected void engineUpdateAAD(byte[] src, int offset, int len) {\n+        maybeReinitInternalCipher();\n+        impl.aead.cipher.updateAAD(src, offset, len);\n+    }\n+\n+    @Override\n+    protected void engineUpdateAAD(ByteBuffer src) {\n+        maybeReinitInternalCipher();\n+        impl.aead.cipher.updateAAD(src);\n+    }\n+\n+    @Override\n+    protected byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen) throws IllegalBlockSizeException, BadPaddingException {\n+        maybeReinitInternalCipher();\n+        impl.context.IncrementSeq();\n+        state = AFTER_FINAL;\n+        if (input == null) { \/\/ a bug in doFinal(null, ?, ?)\n+            return impl.aead.cipher.doFinal();\n+        } else {\n+            return impl.aead.cipher.doFinal(input, inputOffset, inputLen);\n+        }\n+    }\n+\n+    @Override\n+    protected int engineDoFinal(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException {\n+        maybeReinitInternalCipher();\n+        impl.context.IncrementSeq();\n+        state = AFTER_FINAL;\n+        return impl.aead.cipher.doFinal(input, inputOffset, inputLen, output, outputOffset);\n+    }\n+\n+    \/\/@Override\n+    protected SecretKey engineExportKey(byte[] context, String algorithm, int length) {\n+        if (state == BEGIN) {\n+            throw new IllegalStateException(\"State: \" + state);\n+        } else {\n+            return impl.context.Export(context, algorithm, length);\n+        }\n+    }\n+\n+    private static class AEAD {\n+        final Cipher cipher;\n+        final int Nk, Nn, Nt;\n+        final int id;\n+        public AEAD(int id) throws InvalidAlgorithmParameterException {\n+            this.id = id;\n+            try {\n+                switch (id) {\n+                    case 1 -> {\n+                        cipher = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n+                        Nk = 16;\n+                    }\n+                    case 2 -> {\n+                        cipher = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n+                        Nk = 32;\n+                    }\n+                    case 3 -> {\n+                        cipher = Cipher.getInstance(\"ChaCha20-Poly1305\");\n+                        Nk = 32;\n+                    }\n+                    case 65535 -> {\n+                        cipher = null;\n+                        Nk = -1;\n+                    }\n+                    default -> throw new InvalidAlgorithmParameterException();\n+                }\n+            } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n+                throw new ProviderException(e);\n+            }\n+            Nn = 12; Nt = 16;\n+        }\n+\n+        void start(int opmode, SecretKey key, byte[] nonce) {\n+            try {\n+                if (id == 3) {\n+                    cipher.init(opmode, key, new IvParameterSpec(nonce));\n+                } else {\n+                    cipher.init(opmode, key, new GCMParameterSpec(Nt * 8, nonce));\n+                }\n+            } catch (InvalidAlgorithmParameterException | InvalidKeyException e) {\n+                throw new ProviderException(e);\n+            }\n+        }\n+    }\n+\n+    private static class Impl {\n+\n+        final int opmode;\n+\n+        HPKEParameterSpec params;\n+        Context context;\n+        AEAD aead;\n+\n+        byte[] suite_id;\n+        String kdfAlg;\n+        int kdfNh;\n+\n+        byte[] iv; \/\/ sender side\n+\n+        class Context {\n+            final SecretKey k; \/\/ null if only export\n+            final byte[] base_nonce;\n+            final SecretKey exporter_secret;\n+\n+            long seq = 0;\n+\n+            public Context(SecretKey sk, byte[] base_nonce,\n+                    SecretKey exporter_secret) {\n+                this.k = sk;\n+                this.base_nonce = base_nonce;\n+                this.exporter_secret = exporter_secret;\n+            }\n+\n+            SecretKey Export(byte[] exporter_context, String algorithm, int L) {\n+                try {\n+                    var kdf = KDF.getInstance(kdfAlg);\n+                    return kdf.deriveKey(algorithm, HKDFParameterSpec.expandOnly(exporter_secret,\n+                            DHKEM.labeledInfo(suite_id, \"sec\".getBytes(StandardCharsets.UTF_8),\n+                                    exporter_context, L), L));\n+                } catch (InvalidAlgorithmParameterException | NoSuchAlgorithmException e) {\n+                    throw new ProviderException(\"Internal error\", e);\n+                }\n+            }\n+\n+            private byte[] ComputeNonce() {\n+                var result = I2OSP(seq, aead.Nn);\n+                for (var i = 0; i < result.length; i++) {\n+                    result[i] ^= base_nonce[i];\n+                }\n+                return result;\n+            }\n+\n+            private void IncrementSeq() {\n+                if (seq == Long.MAX_VALUE) {\n+                    \/\/ Should check if (seq >= (1 << (8*aead.Nn)) - 1), but\n+                    \/\/ when Nn == 12 this is too big\n+                    throw new ProviderException(\"MessageLimitReachedError\");\n+                }\n+                seq++;\n+            }\n+        }\n+\n+        public Impl(int opmode) {\n+            this.opmode = opmode;\n+        }\n+\n+        public boolean hasEncrypt() {\n+            return params.aead_id() != 65535;\n+        }\n+\n+        public void init(AsymmetricKey key, HPKEParameterSpec p, SecureRandom rand)\n+                throws InvalidKeyException, InvalidAlgorithmParameterException {\n+            if (opmode != Cipher.ENCRYPT_MODE && opmode != Cipher.DECRYPT_MODE) {\n+                throw new UnsupportedOperationException(\"Can only be used for encryption and decryption\");\n+            }\n+            setParams(key, p);\n+            SecretKey shared_secret;\n+            if (opmode == Cipher.ENCRYPT_MODE) {\n+                if (!(key instanceof PublicKey pk)) {\n+                    throw new InvalidKeyException(\"Cannot encrypt with private key\");\n+                }\n+                if (p.encapsulation() != null) {\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"Must not provide key encapsulation message on sender side\");\n+                }\n+                checkMatch(pk, params.kem_id());\n+                KEM.Encapsulator e;\n+                if (p.authKey() == null) {\n+                    e = kem().newEncapsulator(pk, rand);\n+                } else {\n+                    if (p.authKey() instanceof PrivateKey) {\n+                        throw new UnsupportedOperationException(\"auth mode not supported\");\n+                    } else {\n+                        throw new InvalidAlgorithmParameterException(\"Cannot auth with public key\");\n+                    }\n+                }\n+                var enc = e.encapsulate();\n+                iv = enc.encapsulation();\n+                shared_secret = enc.key();\n+            } else {\n+                if (!(key instanceof PrivateKey sk)) {\n+                    throw new InvalidKeyException(\"Cannot decrypt with public key\");\n+                }\n+                checkMatch(sk, params.kem_id());\n+                try {\n+                    KEM.Decapsulator d;\n+                    if (p.authKey() == null) {\n+                        d = kem().newDecapsulator(sk);\n+                    } else {\n+                        if (p.authKey() instanceof PublicKey) {\n+                            throw new UnsupportedOperationException(\"auth mode not supported\");\n+                        } else {\n+                            throw new InvalidAlgorithmParameterException(\"Cannot auth with private key\");\n+                        }\n+                    }\n+                    if (p.encapsulation() == null) {\n+                        throw new InvalidAlgorithmParameterException(\n+                                \"Must provide key encapsulation message on recipient side\");\n+                    }\n+                    shared_secret = d.decapsulate(p.encapsulation());\n+                } catch (DecapsulateException e) {\n+                    throw new InvalidAlgorithmParameterException(e);\n+                }\n+            }\n+\n+            var usePSK = usePSK(params.psk(), params.psk_id());\n+            int mode = params.authKey() == null ? (usePSK ? 1 : 0) : (usePSK ? 3 : 2);\n+            context = KeySchedule(mode, shared_secret,\n+                    params.info(),\n+                    params.psk(),\n+                    params.psk_id());\n+        }\n+\n+        private static void checkMatch(AsymmetricKey k, int kem_id)\n+                throws InvalidKeyException, InvalidAlgorithmParameterException {\n+            var p = k.getParams();\n+            if (p instanceof ECParameterSpec ecp) {\n+                if ((ECUtil.equals(ecp, CurveDB.P_256) && kem_id == 0x10)\n+                        || (ECUtil.equals(ecp, CurveDB.P_384) && kem_id == 0x11)\n+                        || (ECUtil.equals(ecp, CurveDB.P_521) && kem_id == 0x12)) {\n+                    return;\n+                } else {\n+                    var name = ECUtil.getCurveName(ecp);\n+                    throw new InvalidAlgorithmParameterException(name + \" does not match \" + kem_id);\n+                }\n+            } else if (p instanceof NamedParameterSpec ns) {\n+                var name = ns.getName();\n+                if ((name.equalsIgnoreCase(\"x25519\") && kem_id == 0x20)\n+                        || (name.equalsIgnoreCase(\"x448\") && kem_id == 0x21)) {\n+                    return;\n+                } else {\n+                    throw new InvalidAlgorithmParameterException(name + \" does not match \" + kem_id);\n+                }\n+            } else {\n+                throw new InvalidKeyException(k.getClass() + \" does not match \" + kem_id);\n+            }\n+        }\n+\n+        private KEM kem() {\n+            try {\n+                return KEM.getInstance(\"DHKEM\");\n+            } catch (NoSuchAlgorithmException e) {\n+                throw new ProviderException(e);\n+            }\n+        }\n+\n+        private int paramsFromKey(AsymmetricKey k) throws InvalidKeyException {\n+            var p = k.getParams();\n+            if (p instanceof ECParameterSpec ecp) {\n+                if (ECUtil.equals(ecp, CurveDB.P_256)) {\n+                    return 0x10;\n+                } else if (ECUtil.equals(ecp, CurveDB.P_384)) {\n+                    return 0x11;\n+                } else if (ECUtil.equals(ecp, CurveDB.P_521)) {\n+                    return 0x12;\n+                }\n+            } else if (p instanceof NamedParameterSpec ns) {\n+                if (ns.getName().equalsIgnoreCase(\"X25519\")) {\n+                    return 0x20;\n+                } else if (ns.getName().equalsIgnoreCase(\"X448\")) {\n+                    return 0x21;\n+                }\n+            }\n+            throw new InvalidKeyException(\"Unsupported key\");\n+        }\n+\n+        private void setParams(AsymmetricKey key, HPKEParameterSpec p)\n+                throws InvalidKeyException, InvalidAlgorithmParameterException {\n+            this.params = p;\n+            if (p.kem_id() == 0) {\n+                int kem_id = paramsFromKey(key);\n+                int kdf_id = switch (kem_id) {\n+                    case 0x10, 0x20 -> 0x1;\n+                    case 0x11 -> 0x2;\n+                    case 0x12, 0x21 -> 0x3;\n+                    default -> throw new InvalidAlgorithmParameterException();\n+                };\n+                int aead_id = 0x2;\n+                params = HPKEParameterSpec.of(kem_id, kdf_id, aead_id)\n+                        .info(p.info())\n+                        .psk(p.psk(), p.psk_id())\n+                        .authKey(p.authKey())\n+                        .encapsulation(p.encapsulation());\n+            } else {\n+                params = p;\n+            }\n+            checkDisabledAlgorithms(params);\n+            suite_id = concat(\n+                    \"HPKE\".getBytes(StandardCharsets.UTF_8),\n+                    DHKEM.I2OSP(params.kem_id(), 2),\n+                    DHKEM.I2OSP(params.kdf_id(), 2),\n+                    DHKEM.I2OSP(params.aead_id(), 2));\n+            kdfAlg = switch (params.kdf_id()) {\n+                case 1 -> \"HKDF-SHA256\";\n+                case 2 -> \"HKDF-SHA384\";\n+                case 3 -> \"HKDF-SHA512\";\n+                default -> throw new InvalidAlgorithmParameterException();\n+            };\n+            kdfNh = switch (params.kdf_id()) {\n+                case 1 -> 32;\n+                case 2 -> 48;\n+                case 3 -> 64;\n+                default -> throw new InvalidAlgorithmParameterException();\n+            };\n+            aead = new AEAD(params.aead_id());\n+        }\n+\n+        private static int[][][] disabledIdentifiers;\n+        static {\n+            disabledIdentifiers = new int[3][][];\n+            List<int[]> disabledKEMs = new ArrayList<>();\n+            List<int[]> disabledKDFs = new ArrayList<>();\n+            List<int[]> disabledAEADs = new ArrayList<>();\n+            String property = Security.getProperty(\"jdk.hpke.disabledAlgorithms\");\n+            if (property != null) {\n+                for (String rule : property.split(\",\")) {\n+                    if (rule == null) {\n+                        continue;\n+                    }\n+                    rule = rule.trim();\n+                    if (rule.isEmpty()) {\n+                        continue;\n+                    }\n+                    int pos1 = rule.indexOf(\"=\");\n+                    int pos2 = rule.indexOf(\"-\", pos1);\n+                    if (pos1 == -1) {\n+                        throw new IllegalArgumentException(\n+                                \"Invalid jdk.hpke.disabledAlgorithms: \" + property);\n+                    }\n+                    int[] range = new int[2];\n+                    try {\n+                        if (pos2 == -1) {\n+                            range[0] = range[1] = Integer.decode(rule.substring(pos1 + 1).trim());\n+                        } else {\n+                            range[0] = Integer.decode(rule.substring(pos1 + 1, pos2).trim());\n+                            range[1] = Integer.decode(rule.substring(pos2 + 1).trim());\n+                            if (range[0] > range[1]) {\n+                                throw new IllegalArgumentException(\n+                                        \"Invalid jdk.hpke.disabledAlgorithms: \" + property);\n+                            }\n+                        }\n+                    } catch (NumberFormatException e) {\n+                        throw new IllegalArgumentException(\n+                                \"Invalid jdk.hpke.disabledAlgorithms: \" + property, e);\n+                    }\n+                    switch (rule.substring(0, pos1).trim()) {\n+                        case \"kem_id\" -> disabledKEMs.add(range);\n+                        case \"kdf_id\" -> disabledKDFs.add(range);\n+                        case \"aead_id\" -> disabledAEADs.add(range);\n+                        default -> throw new IllegalArgumentException(\n+                                \"Invalid jdk.hpke.disabledAlgorithms: \" + property);\n+                    }\n+                }\n+            }\n+            disabledIdentifiers[0] = disabledKEMs.toArray(new int[0][]);\n+            disabledIdentifiers[1] = disabledKDFs.toArray(new int[0][]);\n+            disabledIdentifiers[2] = disabledAEADs.toArray(new int[0][]);\n+        }\n+\n+        private static void checkDisabledAlgorithms(HPKEParameterSpec params)\n+                throws InvalidAlgorithmParameterException {\n+            checkDisabled(\"kem_id\", disabledIdentifiers[0], params.kem_id());\n+            checkDisabled(\"kdf_id\", disabledIdentifiers[1], params.kdf_id());\n+            checkDisabled(\"aead_id\", disabledIdentifiers[2], params.aead_id());\n+        }\n+\n+        private static void checkDisabled(String label, int[][] ranges, int id)\n+                throws InvalidAlgorithmParameterException {\n+            for (int[] range : ranges) {\n+                if (id >= range[0] && id <= range[1]) {\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"Disabled \" + label + \": \" + id);\n+                }\n+            }\n+        }\n+\n+        private Context KeySchedule(int mode,\n+                SecretKey shared_secret,\n+                byte[] info,\n+                SecretKey psk,\n+                byte[] psk_id) {\n+            try {\n+                var psk_id_hash_x = DHKEM.labeledBuilder(suite_id, \"psk_id_hash\".getBytes(StandardCharsets.UTF_8))\n+                        .addIKM(psk_id);\n+                var info_hash_x = DHKEM.labeledBuilder(suite_id, \"info_hash\".getBytes(StandardCharsets.UTF_8))\n+                        .addIKM(info);\n+\n+                \/\/ deriveData must and can be called because all info are extractable.\n+                \/\/ Any KDF impl can handle this.\n+                var kdf = KDF.getInstance(kdfAlg);\n+                var key_schedule_context = concat(new byte[]{(byte) mode},\n+                        kdf.deriveData(psk_id_hash_x.extractOnly()),\n+                        kdf.deriveData(info_hash_x.extractOnly()));\n+                var secret_x = DHKEM.labeledBuilder(suite_id, \"secret\".getBytes(StandardCharsets.UTF_8))\n+                        .addIKM(psk == null ? new byte[0] : Objects.requireNonNull(psk.getEncoded()))\n+                        .addSalt(shared_secret);\n+\n+                \/\/ Create a new KDF object because secret_x might contain provider-specific keys\n+                kdf = KDF.getInstance(kdfAlg);\n+                var exporter_secret = kdf.deriveKey(\"Generic\",\n+                        secret_x.thenExpand(DHKEM.labeledInfo(suite_id, \"exp\".getBytes(StandardCharsets.UTF_8), key_schedule_context, kdfNh), kdfNh));\n+\n+                if (hasEncrypt()) {\n+                    \/\/ ChaCha20-Poly1305 does not care about algorithm name\n+                    var key = kdf.deriveKey(\"AES\", secret_x.thenExpand(DHKEM.labeledInfo(suite_id, \"key\".getBytes(StandardCharsets.UTF_8),\n+                            key_schedule_context, aead.Nk), aead.Nk));\n+                    \/\/ deriveData must be called because we need to increment nonce, the info must be allowed\n+                    var base_nonce = kdf.deriveData(secret_x.thenExpand(DHKEM.labeledInfo(suite_id, \"base_nonce\".getBytes(StandardCharsets.UTF_8),\n+                            key_schedule_context, aead.Nn), aead.Nn));\n+                    return new Context(key, base_nonce, exporter_secret);\n+                } else {\n+                    return new Context(null, null, exporter_secret);\n+                }\n+            } catch (InvalidAlgorithmParameterException | NoSuchAlgorithmException e) {\n+                throw new ProviderException(\"Internal error\", e);\n+            }\n+        }\n+    }\n+\n+    private static boolean usePSK(SecretKey psk, byte[] psk_id) {\n+        return psk != null;\n+    }\n+\n+    private static byte[] concat(byte[]... inputs) {\n+        var o = new ByteArrayOutputStream();\n+        Arrays.stream(inputs).forEach(o::writeBytes);\n+        return o.toByteArray();\n+    }\n+\n+    private static byte[] I2OSP(long n, int w) {\n+        var full = BigInteger.valueOf(n).toByteArray();\n+        var fullLen = full.length;\n+        if (fullLen == w) {\n+            return full;\n+        } else if (fullLen > w) {\n+            return Arrays.copyOfRange(full, fullLen - w, fullLen);\n+        } else {\n+            var result = new byte[w];\n+            System.arraycopy(full, 0, result, w - fullLen, fullLen);\n+            return result;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HPKE.java","additions":616,"deletions":0,"binary":false,"changes":616,"status":"added"},{"patch":"@@ -370,0 +370,3 @@\n+        ps(\"Cipher\", \"HPKE\", \"com.sun.crypto.provider.HPKE\");\n+\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,372 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javax.crypto.spec;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.Key;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Objects;\n+\n+\/**\n+ * This immutable class specifies the set of parameters used with a {@code Cipher} for the\n+ * <a href=\"https:\/\/www.rfc-editor.org\/info\/rfc9180\">Hybrid Public Key Encryption<\/a>\n+ * (HPKE) algorithm. The <a href=\n+ * \"{@docRoot}\/..\/specs\/security\/standard-names.html#cipher-algorithms\">\n+ * standard algorithm name<\/a> for the cipher is \"HPKE\".\n+ * <p>\n+ * In HPKE, the {@code Cipher} object on the sender side is always initialized\n+ * with the recipient's public key in {@linkplain Cipher#ENCRYPT_MODE encrypt mode},\n+ * and {@code Cipher} object on the recipient side is always initialized with\n+ * its own private key in {@linkplain Cipher#DECRYPT_MODE decrypt mode}.\n+ * <p>\n+ * An {@code HPKEParameterSpec} object can be provided at HPKE\n+ * {@linkplain Cipher#init(int, Key, AlgorithmParameterSpec) cipher initialization}.\n+ * <p>\n+ * An {@code HPKEParameterSpec} object can be created in two ways.\n+ * <ul>\n+ * <li> The {@link #of()} method creates an object whose KEM, KDF, and AEAD\n+ * algorithms are determined by the type of key provided to the {@code init()}\n+ * method.\n+ * <li>\n+ * The {@link #of(int, int, int)} method creates an object whose KEM, KDF,\n+ * and AEAD algorithms are determined by the specified numeric identifiers,\n+ * which must not be zero.\n+ * <\/ul>\n+ * The terms \"KEM algorithm identifiers\", \"KDF algorithm identifiers\", and\n+ * \"AEAD algorithm identifiers\" refer to the numeric values (for example,\n+ * {@code kem_id}, {@code kdf_id}, and {@code aead_id}) as defined in\n+ * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#section-7\">Section 7<\/a>\n+ * of RFC 9180 and the\n+ * <a href=\"https:\/\/www.iana.org\/assignments\/hpke\/hpke.xhtml\">IANA HPKE page<\/a>.\n+ * <p>\n+ * Once an {@code HPKEParameterSpec} object is created, additional methods\n+ * are available to generate new {@code HPKEParameterSpec} objects with\n+ * different features:\n+ * <ul>\n+ * <li>\n+ * Application-supplied information can be provided using the\n+ * {@link #info(byte[])} method by both sides.\n+ * <li>\n+ * If HPKE modes {@code mode_auth} or {@code mode_auth_psk} are used,\n+ * the asymmetric keys for authentication must be provided using the\n+ * {@link #authKey(Key)} method. Precisely, the sender must call this method\n+ * with its own private key and the recipient must call it with the sender's\n+ * public key.\n+ * <li>\n+ * If HPKE modes {@code mode_psk} or {@code mode_auth_psk} are used,\n+ * the pre-shared key for authentication and its identifier must be provided\n+ * using the {@link #psk(SecretKey, byte[])} method by both sides.\n+ * <li>\n+ * In HPKE, a shared secret is negotiated during the KEM step and a key\n+ * encapsulation message must be transmitted from the sender to the recipient\n+ * so that the recipient can recover this shared secret. On the sender side,\n+ * the key encapsulation message can be retrieved using the {@link Cipher#getIV()}\n+ * method after the cipher is initialized. On the recipient side, the key\n+ * encapsulation message can be provided using the {@link #encapsulation(byte[])}\n+ * method.\n+ * <\/ul>\n+ * For successful interoperability, both sides need to supply identical\n+ * {@code info}, {@code psk}, and {@code psk_id} or matching authentication\n+ * keys if provided. For details about HPKE modes, refer to\n+ * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#section-5\">Section 5<\/a>\n+ * of RFC 9180.\n+ * <p>\n+ * If the sender cipher is initialized without parameters, it assumes a\n+ * default parameters object is used, which is equivalent to\n+ * {@code HPKEParameterSpec.of()}. The recipient cipher can also be initialized\n+ * with a {@code new IvParameterSpec(encap)} object, which is equivalent to\n+ * {@code HPKEParameterSpec.of().encapsulation(encap)}. In either case, the\n+ * cipher always works in {@code mode_base} mode with an empty {@code info}.\n+ * If the recipient side is initialized without any parameters, an\n+ * {@code InvalidKeyException} will be thrown.\n+ * <p>\n+ * At HPKE cipher initialization, if no HPKE implementation supports the provided\n+ * key type, an {@code InvalidKeyException} should be thrown. If an\n+ * {@code HPKEParameterSpec} is provided but it is not supported by any HPKE\n+ * implementation, an {@code InvalidAlgorithmParameterException} will be thrown.\n+ * For example:\n+ * <ul>\n+ * <li> The algorithm identifiers do not match the provided key type.\n+ * <li> An attempt to use {@code authKey(key)} is made with an incompatible key.\n+ * <li> An attempt to use {@code authKey(key)} is made but the selected KEM\n+ *      does not support authentication.\n+ * <\/ul>\n+ * Example:\n+ * {@snippet lang = java:\n+ * \/\/ Key pair generation\n+ * var g = KeyPairGenerator.getInstance(\"X25519\");\n+ * var kp = g.generateKeyPair();\n+ *\n+ * \/\/ The HPKE sender side is initialized with the recipient's public key\n+ * var sender = Cipher.getInstance(\"HPKE\");\n+ * var ps = HPKEParameterSpec.of()\n+ *         .info(\"this_info\".getBytes(StandardCharsets.UTF_8));\n+ * sender.init(Cipher.ENCRYPT_MODE, kp.getPublic(), ps);\n+ *\n+ * \/\/ Retrieve the key encapsulation message (the KEM output) from the sender\n+ * var kemEncap = sender.getIV();\n+ *\n+ * \/\/ The HPKE recipient side is initialized with its own private key\n+ * \/\/ and the key encapsulation message from the sender\n+ * var recipient = Cipher.getInstance(\"HPKE\");\n+ * var pr = HPKEParameterSpec.of()\n+ *         .info(\"this_info\".getBytes(StandardCharsets.UTF_8))\n+ *         .encapsulation(kemEncap);\n+ * recipient.init(Cipher.DECRYPT_MODE, kp.getPrivate(), pr);\n+ *\n+ * \/\/ Secure communication between the 2 sides\n+ * var msg = \"Hello World\".getBytes(StandardCharsets.UTF_8);\n+ * var ct = sender.doFinal(msg);\n+ * var pt = recipient.doFinal(ct);\n+ *\n+ * assert Arrays.equals(msg, pt);\n+ * }\n+ *\n+ * @implNote\n+ * In the HPKE implementation in the SunJCE provider included in this JDK\n+ * implementation, {@code HPKEParameterSpec.of()} chooses the following\n+ * KEM, KDF, and AEAD algorithms depending on the provided key type:\n+ * <table class=\"striped\">\n+ * <caption style=\"display:none\">Default Algorithm Identifiers<\/caption>\n+ * <thead>\n+ * <tr><th scope=\"col\">key type\n+ *     <th scope=\"col\">{@code kem_id}\n+ *     <th scope=\"col\">{@code kdf_id}\n+ *     <th scope=\"col\">{@code aead_id}\n+ * <\/thead>\n+ * <tbody>\n+ * <tr><td>EC (secp256r1)\n+ *     <td>0x10<br>DHKEM(P-256, HKDF-SHA256)\n+ *     <td>0x1<br>HKDF-SHA256\n+ *     <td rowspan=\"5\">0x2<br>AES-256-GCM\n+ * <tr><td>EC (secp384r1)\n+ *     <td>0x11<br>DHKEM(P-384, HKDF-SHA384)\n+ *     <td>0x2<br>HKDF-SHA384\n+ * <tr><td>EC (secp521r1)\n+ *     <td>0x12<br>DHKEM(P-521, HKDF-SHA512)\n+ *     <td>0x3<br>HKDF-SHA512\n+ * <tr><td>XDH (X25519)\n+ *     <td>0x20<br>DHKEM(X25519, HKDF-SHA256)\n+ *     <td>0x1<br>HKDF-SHA256\n+ * <tr><td>XDH (X448)\n+ *     <td>0x21<br>DHKEM(X448, HKDF-SHA512)\n+ *     <td>0x3<br>HKDF-SHA512\n+ * <\/tbody>\n+ * <\/table>\n+ * No other keys are supported.\n+ *\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc9180\n+ *      RFC 9180: Hybrid Public Key Encryption\n+ * @spec security\/standard-names.html\n+ *      Java Security Standard Algorithm Names\n+ * @since 25\n+ *\/\n+public final class HPKEParameterSpec implements AlgorithmParameterSpec {\n+\n+    private final int kem_id; \/\/ 0 is determined by key later\n+    private final int kdf_id; \/\/ 0 is determined by key later\n+    private final int aead_id; \/\/ 0 is determined by key later\n+    private final byte[] info; \/\/ never null, can be empty\n+    private final SecretKey psk; \/\/ null if not used\n+    private final byte[] psk_id; \/\/ never null, can be empty\n+    private final Key kS; \/\/ null if not used\n+    private final byte[] encapsulation; \/\/ null if none\n+\n+    \/\/ Note: this constructor does not clone array arguments.\n+    private HPKEParameterSpec(int kem_id, int kdf_id, int aead_id, byte[] info,\n+            SecretKey psk, byte[] psk_id, Key kS, byte[] encapsulation) {\n+        this.kem_id = kem_id;\n+        this.kdf_id = kdf_id;\n+        this.aead_id = aead_id;\n+        this.info = info;\n+        this.psk = psk;\n+        this.psk_id = psk_id;\n+        this.kS = kS;\n+        this.encapsulation = encapsulation;\n+    }\n+\n+    \/**\n+     * A factory method to create an empty {@code HPKEParameterSpec} in\n+     * {@code mode_base} mode with an empty {@code info}. The KEM, KDF,\n+     * and AEAD algorithm identifiers are not specified and will be\n+     * determined by the key used in cipher initialization.\n+     *\n+     * @return a new {@code HPKEParameterSpec} object\n+     *\/\n+    public static HPKEParameterSpec of() {\n+        return new HPKEParameterSpec(0, 0, 0, new byte[0], null, new byte[0], null, null);\n+    }\n+\n+    \/**\n+     * A factory method to create a new {@code HPKEParameterSpec} object with\n+     * specified KEM, KDF, and AEAD algorithm identifiers in {@code mode_base}\n+     * mode with an empty {@code info}.\n+     *\n+     * @param kem_id identifier for KEM, must not be zero\n+     * @param kdf_id identifier for KDF, must not be zero\n+     * @param aead_id identifier for AEAD, must not be zero\n+     * @return a new {@code HPKEParameterSpec} object\n+     * @throws InvalidAlgorithmParameterException if any of the provided\n+     *      identifiers is zero\n+     *\/\n+    public static HPKEParameterSpec of(int kem_id, int kdf_id, int aead_id)\n+            throws InvalidAlgorithmParameterException {\n+        if (kem_id < 1 || kem_id > 65535\n+                || kdf_id < 1 || kdf_id > 65535\n+                || aead_id < 1 || aead_id > 65535) {\n+            throw new InvalidAlgorithmParameterException();\n+        }\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id, new byte[0], null, new byte[0], null, null);\n+    }\n+\n+    \/**\n+     * Creates a new {@code HPKEParameterSpec} object with a different\n+     * {@code info} value.\n+     *\n+     * @param info application-specific info. Must not be {@code null}.\n+     *      The contents of the array are copied to protect\n+     *      against subsequent modification.\n+     * @return a new {@code HPKEParameterSpec} object\n+     * @throws NullPointerException if {@code info} is {@code null}\n+     *\/\n+    public HPKEParameterSpec info(byte[] info) {\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                Objects.requireNonNull(info).clone(), psk, psk_id, kS, encapsulation);\n+    }\n+\n+    \/**\n+     * Creates a new {@code HPKEParameterSpec} object with different\n+     * {@code psk} value and {@code psk_id} values.\n+     *\n+     * @param psk pre-shared key. Set to {@code null} if no pre-shared key is used.\n+     * @param psk_id identifier for PSK. Set to empty if no pre-shared key is used.\n+     *               Must not be {@code null}. The contents of the array are copied\n+     *               to protect against subsequent modification.\n+     * @return a new {@code HPKEParameterSpec} object\n+     * @throws NullPointerException if {@code psk_id} is {@code null}\n+     * @throws InvalidAlgorithmParameterException if {@code psk} and {@code psk_id} are\n+     *      not consistent, i.e. {@code psk} is not {@code null} but\n+     *      {@code psk_id} is empty, or {@code psk} is {@code null} but\n+     *      {@code psk_id} is not empty.\n+     *\/\n+    public HPKEParameterSpec psk(SecretKey psk, byte[] psk_id)\n+            throws InvalidAlgorithmParameterException {\n+        Objects.requireNonNull(psk_id);\n+        if (psk == null && psk_id.length != 0\n+                || psk != null && psk_id.length == 0) {\n+            throw new InvalidAlgorithmParameterException(\"psk and psk_id do not match\");\n+        }\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                info, psk, psk_id.clone(), kS, encapsulation);\n+    }\n+\n+    \/**\n+     * Creates a new {@code HPKEParameterSpec} object with a different\n+     * key encapsulation message value that will be used by the recipient.\n+     *\n+     * @param encapsulation the key encapsulation message. If set to\n+     *      {@code null}, the previous key encapsulation message is cleared.\n+     *      The contents of the array are copied to protect against\n+     *      subsequent modification.\n+     *\n+     * @return a new {@code HPKEParameterSpec} object\n+     *\/\n+    public HPKEParameterSpec encapsulation(byte[] encapsulation) {\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                info, psk, psk_id, kS,\n+                encapsulation == null ? null : encapsulation.clone());\n+    }\n+\n+    \/**\n+     * Creates a new {@code HPKEParameterSpec} object with a different\n+     * authentication key value.\n+     *\n+     * @param kS the authentication key. If set to {@code null}, the previous\n+     *          authentication key is cleared.\n+     * @return a new {@code HPKEParameterSpec} object\n+     *\/\n+    public HPKEParameterSpec authKey(Key kS) {\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                info, psk, psk_id, kS, encapsulation);\n+    }\n+\n+    \/**\n+     * {@return the identifier for KEM, 0 if determined by key type}\n+     *\/\n+    public int kem_id() {\n+        return kem_id;\n+    }\n+\n+    \/**\n+     * {@return the identifier for KDF, 0 if determined by key type}\n+     *\/\n+    public int kdf_id() {\n+        return kdf_id;\n+    }\n+\n+    \/**\n+     * {@return the identifier for AEAD, 0 if determined by key type}\n+     *\/\n+    public int aead_id() {\n+        return aead_id;\n+    }\n+\n+    \/**\n+     * {@return a copy of the application-specific info, empty if none}\n+     *\/\n+    public byte[] info() {\n+        return info.clone();\n+    }\n+\n+    \/**\n+     * {@return pre-shared key, {@code null} if none}\n+     *\/\n+    public SecretKey psk() {\n+        return psk;\n+    }\n+\n+    \/**\n+     * {@return a copy of the identifier for PSK, empty if none}\n+     *\/\n+    public byte[] psk_id() {\n+        return psk_id.clone();\n+    }\n+\n+    \/**\n+     * {@return the key for authentication, {@code null} if none}\n+     *\/\n+    public Key authKey() {\n+        return kS;\n+    }\n+\n+    \/**\n+     * {@return a copy of the key encapsulation message, {@code null} if none}\n+     *\/\n+    public byte[] encapsulation() {\n+        return encapsulation == null ? null : encapsulation.clone();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/HPKEParameterSpec.java","additions":372,"deletions":0,"binary":false,"changes":372,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.security.util;\n+\n+import javax.crypto.SecretKey;\n+\n+\/\/\/ An interface for `SecretKey`s that supports using its slice as a new\n+\/\/\/ `SecretKey`.\n+\/\/\/\n+\/\/\/ This is mainly used by PKCS #11 implementations that supports the\n+\/\/\/ EXTRACT_KEY_FROM_KEY mechanism even if the key itself is sensitive\n+\/\/\/ and non-extractable.\n+public interface SliceableSecretKey {\n+    \/\/\/ Returns a slice as a new `SecretKey`.\n+    \/\/\/\n+    \/\/\/ This method may return the original object if `from` is 0 and\n+    \/\/\/ `to` is the length of the original key.\n+    \/\/\/\n+    \/\/\/ @param alg the new algorithm name\n+    \/\/\/ @param from the byte offset of the new key in the full key\n+    \/\/\/ @param to the to offset (exclusive) of the new key in the full key\n+    \/\/\/ @return the new key\n+    \/\/\/ @throws ArrayIndexOutOfBoundsException for improper `from` and `to` values\n+    \/\/\/ @throws UnsupportedOperationException if slicing is not supported\n+    SecretKey slice(String alg, int from, int to);\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SliceableSecretKey.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -638,0 +638,35 @@\n+#\n+# Algorithm restrictions for Hybrid Public Key Encryption (HPKE)\n+#\n+# In some environments, certain algorithm identifiers may be undesirable\n+# for Hybrid Public Key Encryption. See the specification of HPKEParameterSpec\n+# for definition of algorithm identifiers used in HPKE.\n+#\n+# The value for this property is a comma-separate-list of equations. Each one\n+# taking the form of one of\n+#\n+#   kem_id=<number>\n+#   kem_id=<number>-<number>\n+#   kdf_id=<number>\n+#   kdf_id=<number>-<number>\n+#   aead_id=<number>\n+#   aead_id=<number>-<number>\n+#\n+# If only one number is provided, the algorithm identifier is disabled. If a\n+# range is provided, the algorithm identifiers within the range (inclusive\n+# on both sides) are disabled. Initializing an HPKE cipher with disabled\n+# algorithm identifier(s) will throw an InvalidAlgorithmParameterException.\n+#\n+# The numbers can be in any format that Integer::decode accepts.\n+# All whitespaces around delimiters are ignored. The names are case-sensitive.\n+#\n+# Note: This property is currently used by the JDK Reference\n+# implementation. It is not guaranteed to be examined and used by other\n+# implementations.\n+#\n+# Example:\n+#   jdk.hpke.disabledAlgorithms=kem_id=16-18\n+#   jdk.hpke.disabledAlgorithms=kem_id=0x10,kdf_id=0x01,aead_id=0xffff\n+#\n+jdk.hpke.disabledAlgorithms=\n+\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,248 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.HPKEParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.KeyPairGenerator;\n+import java.util.Arrays;\n+\n+\/*\n+ * @test\n+ * @bug 8325448\n+ * @library \/test\/lib\n+ * @summary HPKE compliance test\n+ *\/\n+public class Compliance {\n+    public static void main(String[] args) throws Exception {\n+\n+        var kp = KeyPairGenerator.getInstance(\"X25519\").generateKeyPair();\n+        var info = \"info\".getBytes(StandardCharsets.UTF_8);\n+        var psk = new SecretKeySpec(new byte[32], \"ONE\");\n+        var psk_id = \"psk_id\".getBytes(StandardCharsets.UTF_8);\n+\n+        \/\/ HPKEParameterSpec\n+\n+        \/\/ Default values\n+        var spec = HPKEParameterSpec.of();\n+        Asserts.assertEQ(spec.kdf_id(), 0);\n+        Asserts.assertEQ(spec.kem_id(), 0);\n+        Asserts.assertEQ(spec.aead_id(), 0);\n+        Asserts.assertEQ(spec.authKey(), null);\n+        Asserts.assertEQ(spec.encapsulation(), null);\n+        Asserts.assertTrue(Arrays.equals(spec.info(), new byte[0]));\n+        Asserts.assertEQ(spec.psk(), null);\n+        Asserts.assertTrue(Arrays.equals(spec.psk_id(), new byte[0]));\n+\n+        \/\/ Partial default values\n+        var spec2 = HPKEParameterSpec.of(1, 1, 1);\n+        Asserts.assertEQ(spec2.kdf_id(), 1);\n+        Asserts.assertEQ(spec2.kem_id(), 1);\n+        Asserts.assertEQ(spec2.aead_id(), 1);\n+        Asserts.assertEQ(spec2.authKey(), null);\n+        Asserts.assertEQ(spec2.encapsulation(), null);\n+        Asserts.assertTrue(Arrays.equals(spec2.info(), new byte[0]));\n+        Asserts.assertEQ(spec2.psk(), null);\n+        Asserts.assertTrue(Arrays.equals(spec2.psk_id(), new byte[0]));\n+\n+        HPKEParameterSpec.of(65535, 65535, 65535);\n+\n+        \/\/ Cannot provide zero identifiers\n+        Utils.runAndCheckException(\n+                () -> HPKEParameterSpec.of(0, 1, 1),\n+                InvalidAlgorithmParameterException.class);\n+        Utils.runAndCheckException(\n+                () -> HPKEParameterSpec.of(1, 0, 1),\n+                InvalidAlgorithmParameterException.class);\n+        Utils.runAndCheckException(\n+                () -> HPKEParameterSpec.of(1, 1, 0),\n+                InvalidAlgorithmParameterException.class);\n+\n+        Asserts.assertTrue(spec.authKey(null).authKey() == null);\n+        Asserts.assertTrue(spec.authKey(kp.getPrivate()).authKey() != null);\n+        Asserts.assertTrue(spec.authKey(kp.getPublic()).authKey() != null);\n+        Asserts.assertTrue(spec.authKey(kp.getPrivate()).authKey(null).authKey() == null);\n+\n+        \/\/ Info can be empty but not null\n+        Utils.runAndCheckException(\n+                () -> spec.info(null),\n+                NullPointerException.class);\n+        Asserts.assertTrue(Arrays.equals(spec.info(info).info(), info));\n+\n+        Asserts.assertTrue(spec.encapsulation(null).encapsulation() == null);\n+        Asserts.assertTrue(Arrays.equals(spec.encapsulation(info).encapsulation(), info));\n+        Asserts.assertTrue(spec.encapsulation(info).encapsulation(null).encapsulation() == null);\n+\n+        \/\/ psk_id can be empty but not null\n+        Utils.runAndCheckException(\n+                () -> spec.psk(psk, null),\n+                NullPointerException.class);\n+\n+        \/\/ psk and psk_id must match\n+        Utils.runAndCheckException(\n+                () -> spec.psk(psk, new byte[0]),\n+                InvalidAlgorithmParameterException.class);\n+        Utils.runAndCheckException(\n+                () -> spec.psk(null, psk_id),\n+                InvalidAlgorithmParameterException.class);\n+\n+        Asserts.assertTrue(Arrays.equals(spec.psk(psk, psk_id).psk().getEncoded(), psk.getEncoded()));\n+        Asserts.assertTrue(Arrays.equals(spec.psk(psk, psk_id).psk_id(), psk_id));\n+        Asserts.assertTrue(spec.psk(null, new byte[0]).psk() == null);\n+        Asserts.assertTrue(Arrays.equals(spec.psk(null, new byte[0]).psk_id(), new byte[0]));\n+\n+        \/\/ HPKE\n+        var c1 = Cipher.getInstance(\"HPKE\");\n+        var c2 = Cipher.getInstance(\"HPKE\");\n+\n+        \/\/ Still at BEGIN, not initialized\n+        Asserts.assertEQ(c1.getIV(), null);\n+        Utils.runAndCheckException(() -> c1.getBlockSize(), IllegalStateException.class);\n+        Utils.runAndCheckException(() -> c1.getOutputSize(100), IllegalStateException.class);\n+        Utils.runAndCheckException(() -> c1.update(new byte[1]), IllegalStateException.class);\n+        Utils.runAndCheckException(() -> c1.update(new byte[1], 0, 1), IllegalStateException.class);\n+        Utils.runAndCheckException(() -> c1.updateAAD(new byte[1]), IllegalStateException.class);\n+        Utils.runAndCheckException(() -> c1.updateAAD(new byte[1], 0, 1), IllegalStateException.class);\n+        Utils.runAndCheckException(() -> c1.doFinal(), IllegalStateException.class);\n+        Utils.runAndCheckException(() -> c1.doFinal(new byte[1]), IllegalStateException.class);\n+        Utils.runAndCheckException(() -> c1.doFinal(new byte[1], 0, 1), IllegalStateException.class);\n+        Utils.runAndCheckException(() -> c1.doFinal(new byte[1], 0, 1, new byte[1024], 0), IllegalStateException.class);\n+\n+        \/\/ Simplest usages\n+        c1.init(Cipher.ENCRYPT_MODE, kp.getPublic());\n+        c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(), new IvParameterSpec(c1.getIV()));\n+        c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(), HPKEParameterSpec.of().encapsulation(c1.getIV()));\n+\n+        \/\/ Does not support WRAP and UNWRAP mode\n+        Utils.runAndCheckException(\n+                () -> c1.init(Cipher.WRAP_MODE, kp.getPublic()),\n+                UnsupportedOperationException.class);\n+        Utils.runAndCheckException(\n+                () -> c1.init(Cipher.UNWRAP_MODE, kp.getPublic()),\n+                UnsupportedOperationException.class);\n+\n+        \/\/ Cannot init sender with private key\n+        Utils.runAndCheckException(\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPrivate()),\n+                InvalidKeyException.class);\n+        \/\/ Cannot provide key encap msg to sender\n+        Utils.runAndCheckException(\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of().encapsulation(new byte[32])),\n+                InvalidAlgorithmParameterException.class);\n+\n+        \/\/ Cannot init recipient with public key\n+        Utils.runAndCheckException(\n+                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPublic()),\n+                InvalidKeyException.class);\n+        \/\/ Must provide key encap msg to recipient\n+        Utils.runAndCheckException(\n+                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate()),\n+                InvalidKeyException.class);\n+\n+        \/\/ Unknown identifiers\n+        c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), HPKEParameterSpec.of(0x20, 1, 1));\n+\n+        \/\/ Unknown identifiers\n+        Utils.runAndCheckException(\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), HPKEParameterSpec.of(0x200, 1, 1)),\n+                InvalidAlgorithmParameterException.class);\n+        Utils.runAndCheckException(\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), HPKEParameterSpec.of(0x20, 4, 1)),\n+                InvalidAlgorithmParameterException.class);\n+        Utils.runAndCheckException(\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), HPKEParameterSpec.of(0x20, 1, 4)),\n+                InvalidAlgorithmParameterException.class);\n+\n+        \/\/ No key encap msg for recipient\n+        Utils.runAndCheckException(\n+                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(), HPKEParameterSpec.of(0x20, 1, 1)),\n+                InvalidAlgorithmParameterException.class);\n+\n+        \/\/ No key encap msg for recipient\n+        Utils.runAndCheckException(\n+                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(), HPKEParameterSpec.of(0x20, 1, 65535)),\n+                InvalidAlgorithmParameterException.class);\n+\n+        var aad = \"AAD\".getBytes(StandardCharsets.UTF_8);\n+\n+        \/\/ HPKE with encryption\n+        c1.init(Cipher.ENCRYPT_MODE, kp.getPublic());\n+        c1.getBlockSize();\n+        c1.getOutputSize(100);\n+        c1.updateAAD(aad);\n+        var ct = c1.doFinal(new byte[2]);\n+\n+        c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(), HPKEParameterSpec.of().encapsulation(c1.getIV()));\n+        c2.getBlockSize();\n+        c2.getOutputSize(100);\n+        c2.updateAAD(aad);\n+        Asserts.assertTrue(Arrays.equals(c2.doFinal(ct), new byte[2]));\n+\n+        c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(), new IvParameterSpec(c1.getIV()));\n+        c2.updateAAD(aad);\n+        c2.update(ct);\n+        Asserts.assertTrue(Arrays.equals(c2.doFinal(), new byte[2]));\n+\n+        \/\/ info and psk\n+        var kp2 = KeyPairGenerator.getInstance(\"X25519\").generateKeyPair();\n+        c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                HPKEParameterSpec.of()\n+                        .info(info)\n+                        .psk(psk, psk_id));\n+        c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                HPKEParameterSpec.of()\n+                        .info(info)\n+                        .psk(psk, psk_id)\n+                        .encapsulation(c1.getIV()));\n+        ct = c1.doFinal(new byte[2]);\n+        Asserts.assertTrue(Arrays.equals(c2.doFinal(ct), new byte[2]));\n+\n+        \/\/ mod_auth, wrong key type\n+        Utils.runAndCheckException(\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of().authKey(kp2.getPublic())),\n+                InvalidAlgorithmParameterException.class);\n+        Utils.runAndCheckException(\n+                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                        HPKEParameterSpec.of().authKey(kp2.getPrivate())),\n+                InvalidAlgorithmParameterException.class);\n+\n+        \/\/ mod_auth, not supported\n+        Utils.runAndCheckException(\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of().authKey(kp2.getPrivate())),\n+                UnsupportedOperationException.class);\n+        Utils.runAndCheckException(\n+                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                        HPKEParameterSpec.of().authKey(kp2.getPublic())),\n+                UnsupportedOperationException.class);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/Compliance.java","additions":248,"deletions":0,"binary":false,"changes":248,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.Proc;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.HPKEParameterSpec;\n+import java.security.PrivateKey;\n+\n+\/*\n+ * @test\n+ * @bug 8325448\n+ * @library \/test\/lib\n+ * @summary disabling HPKE algorithm identifiers\n+ *\/\n+public class Disabled {\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            \/\/ Try if an HPKE cipher can be initialized with HPKEParameterSpec.of(16, 1, 1).\n+            \/\/ When \"Cannot encrypt with private key\" is seen, alg id check already passed\n+            test(null).stderrShouldContain(\"Cannot encrypt with private key\");\n+            test(\"kem_id=17\").stderrShouldContain(\"Cannot encrypt with private key\");\n+            test(\"kem_id=17-19\").stderrShouldContain(\"Cannot encrypt with private key\");\n+            test(\"kem_id=1-15\").stderrShouldContain(\"Cannot encrypt with private key\");\n+\n+            test(\"kem_id=16\").stderrShouldContain(\"Disabled kem_id: 16\");\n+            test(\"kem_id=16-19\").stderrShouldContain(\"Disabled kem_id: 16\");\n+            test(\"kem_id=11-16\").stderrShouldContain(\"Disabled kem_id: 16\");\n+            test(\"kem_id=0x10\").stderrShouldContain(\"Disabled kem_id: 16\");\n+            test(\"kem_id=#10\").stderrShouldContain(\"Disabled kem_id: 16\");\n+\n+            test(\"kem_id=17,kdf_id=2,aead_id=2\").stderrShouldContain(\"Cannot encrypt with private key\");\n+            test(\"kem_id=16,kdf_id=2,aead_id=2\").stderrShouldContain(\"Disabled kem_id: 16\");\n+            test(\"kem_id=17,kdf_id=1,aead_id=2\").stderrShouldContain(\"Disabled kdf_id: 1\");\n+            test(\"kem_id=17,kdf_id=2,aead_id=1\").stderrShouldContain(\"Disabled aead_id: 1\");\n+        } else {\n+            var c = Cipher.getInstance(\"HPKE\");\n+            var ak = new PrivateKey() {\n+                public String getAlgorithm() { return \"EC\"; }\n+                public String getFormat() { return null; }\n+                public byte[] getEncoded() { return null; }\n+            };\n+            c.init(Cipher.ENCRYPT_MODE, ak, HPKEParameterSpec.of(16, 1, 1));\n+        }\n+    }\n+\n+    static OutputAnalyzer test(String v) throws Exception {\n+        var proc = Proc.create(\"Disabled\");\n+        if (v != null) proc.secprop(\"jdk.hpke.disabledAlgorithms\", v);\n+        return proc.args(\"test\").start().output();\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/Disabled.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.HPKEParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.spec.ECGenParameterSpec;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug 8325448\n+ * @library \/test\/lib\n+ * @summary HPKE running with different keys\n+ *\/\n+public class Functions {\n+    record Params(String name) {}\n+    static List<Params> PARAMS = List.of(\n+            new Params(\"secp256r1\"),\n+            new Params(\"secp384r1\"),\n+            new Params(\"secp521r1\"),\n+            new Params(\"X25519\"),\n+            new Params(\"X448\")\n+    );\n+    public static void main(String[] args) throws Exception {\n+\n+        var msg = \"hello\".getBytes(StandardCharsets.UTF_8);\n+        var info = \"info\".getBytes(StandardCharsets.UTF_8);\n+        var psk = new SecretKeySpec(\"this is a key\".getBytes(StandardCharsets.UTF_8), \"Generic\");\n+        var psk_id = \"psk1\".getBytes(StandardCharsets.UTF_8);\n+\n+        for (var param : PARAMS) {\n+            System.out.println(param);\n+            var c = Cipher.getInstance(\"HPKE\");\n+            var kp = genKeyPair(param.name());\n+\n+            c.init(Cipher.ENCRYPT_MODE, kp.getPublic());\n+            var enc = c.getIV();\n+            var ct = c.doFinal(msg);\n+\n+            c.init(Cipher.DECRYPT_MODE, kp.getPrivate(), new IvParameterSpec(enc));\n+            Asserts.assertEqualsByteArray(msg, c.doFinal(ct));\n+            c.init(Cipher.DECRYPT_MODE, kp.getPrivate(), HPKEParameterSpec.of().encapsulation(enc));\n+            Asserts.assertEqualsByteArray(msg, c.doFinal(ct));\n+\n+            c.init(Cipher.ENCRYPT_MODE, kp.getPublic(), HPKEParameterSpec.of()\n+                    .info(info)\n+                    .psk(psk, psk_id));\n+            ct = c.doFinal(msg);\n+\n+            c.init(Cipher.DECRYPT_MODE, kp.getPrivate(), HPKEParameterSpec.of()\n+                    .info(info)\n+                    .psk(psk, psk_id)\n+                    .encapsulation(c.getIV()));\n+            Asserts.assertEqualsByteArray(msg, c.doFinal(ct));\n+        }\n+    }\n+\n+    static KeyPair genKeyPair(String name) throws Exception {\n+        if (name.startsWith(\"secp\")) {\n+            var g = KeyPairGenerator.getInstance(\"EC\");\n+            g.initialize(new ECGenParameterSpec(name));\n+            return g.generateKeyPair();\n+        } else {\n+            return KeyPairGenerator.getInstance(name).generateKeyPair();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/Functions.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -242,0 +242,2 @@\n+        } if (s.equals(\"HPKE\")) {\n+            return generateKeyPair(\"EC\", 3).getPublic();\n","filename":"test\/jdk\/sun\/security\/provider\/all\/Deterministic.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}