{"files":[{"patch":"@@ -57,1 +57,0 @@\n-import java.security.spec.InvalidParameterSpecException;\n@@ -123,12 +122,1 @@\n-        if (state == BEGIN) {\n-            return null;\n-        }\n-        try {\n-            var result = AlgorithmParameters.getInstance(\"HPKE\");\n-            result.init(impl.params);\n-            return result;\n-        } catch (NoSuchAlgorithmException e) {\n-            throw new ProviderException(\"Cannot find implementations\", e);\n-        } catch (InvalidParameterSpecException e) {\n-            throw new ProviderException(\"Parameters not supported\", e);\n-        }\n+        return null;\n@@ -140,8 +128,1 @@\n-        try {\n-            engineInit(opmode, key, (AlgorithmParameterSpec) null, random);\n-        } catch (InvalidAlgorithmParameterException e) {\n-            \/\/ Parent spec says \"throws InvalidKeyException if the given key\n-            \/\/ requires algorithm parameters that cannot be determined from\n-            \/\/ the given key\"\n-            throw new InvalidKeyException(e);\n-        }\n+        throw new InvalidKeyException(\"HPKEParameterSpec must be provided\");\n@@ -158,3 +139,1 @@\n-        if (params == null) {\n-            impl.init(ak, HPKEParameterSpec.of(), random);\n-        } else if (params instanceof HPKEParameterSpec hps) {\n+        if (params instanceof HPKEParameterSpec hps) {\n@@ -178,5 +157,1 @@\n-        try {\n-            engineInit(opmode, key, params.getParameterSpec(HPKEParameterSpec.class), random);\n-        } catch (InvalidParameterSpecException e) {\n-            throw new InvalidAlgorithmParameterException(\"Cannot extract HPKEParameterSpec\", e);\n-        }\n+        throw new InvalidKeyException(\"HPKEParameterSpec must be provided\");\n@@ -407,1 +382,1 @@\n-            setParams(key, p);\n+            setParams(p);\n@@ -506,55 +481,3 @@\n-        private int kemIdFromKey(AsymmetricKey k) throws InvalidKeyException {\n-            var p = k.getParams();\n-            if (p instanceof ECParameterSpec ecp) {\n-                if (ECUtil.equals(ecp, CurveDB.P_256)) {\n-                    return HPKEParameterSpec.KEM_DHKEM_P_256_HKDF_SHA256;\n-                } else if (ECUtil.equals(ecp, CurveDB.P_384)) {\n-                    return HPKEParameterSpec.KEM_DHKEM_P_384_HKDF_SHA384;\n-                } else if (ECUtil.equals(ecp, CurveDB.P_521)) {\n-                    return HPKEParameterSpec.KEM_DHKEM_P_521_HKDF_SHA512;\n-                }\n-            } else if (p instanceof NamedParameterSpec ns) {\n-                if (ns.getName().equalsIgnoreCase(\"X25519\")) {\n-                    return HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256;\n-                } else if (ns.getName().equalsIgnoreCase(\"X448\")) {\n-                    return HPKEParameterSpec.KEM_DHKEM_X448_HKDF_SHA512;\n-                }\n-            }\n-            throw new InvalidKeyException(\"Unsupported key\");\n-        }\n-\n-        private void setParams(AsymmetricKey key, HPKEParameterSpec p)\n-                throws InvalidKeyException, InvalidAlgorithmParameterException {\n-            if (p.kem_id() == -1 || p.kdf_id() == -1 || p.aead_id() == -1) {\n-                if (opmode == Cipher.DECRYPT_MODE) {\n-                    throw new InvalidAlgorithmParameterException(\n-                            \"Algorithm identifiers must be provided on receiver\");\n-                }\n-                var kem_id = p.kem_id() != -1\n-                        ? p.kem_id()\n-                        : kemIdFromKey(key);\n-                var kdf_id = p.kdf_id() != -1\n-                        ? p.kdf_id()\n-                        : switch (kem_id) {\n-                    case HPKEParameterSpec.KEM_DHKEM_P_256_HKDF_SHA256,\n-                         HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256\n-                            -> HPKEParameterSpec.KDF_HKDF_SHA256;\n-                    case HPKEParameterSpec.KEM_DHKEM_P_384_HKDF_SHA384\n-                            -> HPKEParameterSpec.KDF_HKDF_SHA384;\n-                    case HPKEParameterSpec.KEM_DHKEM_P_521_HKDF_SHA512,\n-                         HPKEParameterSpec.KEM_DHKEM_X448_HKDF_SHA512\n-                            -> HPKEParameterSpec.KDF_HKDF_SHA512;\n-                    default -> throw new InvalidAlgorithmParameterException(\n-                            \"Unsupported kem_id: \" + params.kem_id());\n-                };\n-                var aead_id = p.aead_id() != -1\n-                        ? p.aead_id()\n-                        : HPKEParameterSpec.AEAD_AES_256_GCM;\n-                params = HPKEParameterSpec.of(kem_id, kdf_id, aead_id)\n-                        .info(p.info())\n-                        .psk(p.psk(), p.psk_id())\n-                        .authKey(p.authKey())\n-                        .encapsulation(p.encapsulation());\n-            } else {\n-                params = p;\n-            }\n+        private void setParams(HPKEParameterSpec p)\n+                throws InvalidAlgorithmParameterException {\n+            params = p;\n@@ -606,0 +529,1 @@\n+                var secret_x = kdf.deriveKey(\"Generic\", secret_x_builder.extractOnly());\n@@ -612,1 +536,1 @@\n-                        secret_x_builder, suite_id, EXP, key_schedule_context, kdfNh));\n+                        secret_x, suite_id, EXP, key_schedule_context, kdfNh));\n@@ -616,1 +540,1 @@\n-                    var key = kdf.deriveKey(\"AES\", DHKEM.labeledExpand(secret_x_builder,\n+                    var key = kdf.deriveKey(\"AES\", DHKEM.labeledExpand(secret_x,\n@@ -619,1 +543,1 @@\n-                    var base_nonce = kdf.deriveData(DHKEM.labeledExpand(secret_x_builder,\n+                    var base_nonce = kdf.deriveData(DHKEM.labeledExpand(secret_x,\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HPKE.java","additions":12,"deletions":88,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n- * An {@code HPKEParameterSpec} object can be provided at HPKE\n+ * An {@code HPKEParameterSpec} object must be provided at HPKE\n@@ -51,11 +51,2 @@\n- * An {@code HPKEParameterSpec} object can be created in two ways:\n- * <ul>\n- * <li> {@link #of()} creates an instance with unspecified KEM, KDF, and AEAD\n- * algorithm identifiers, which will be determined by the implementation based\n- * on the key provided to {@code init()}. This instance can only be used by the\n- * sender. If an implementation does not support initializing with default\n- * algorithm identifiers, an {@code InvalidAlgorithmParameterException} will be thrown.\n- * <li> {@link #of(int, int, int)} creates an instance with explicitly\n- * specified KEM, KDF, and AEAD algorithm identifiers. This instance can be\n- * used by both the sender and the receiver.\n- * <\/ul>\n+ * {@link #of(int, int, int)} creates an {@code HPKEParameterSpec} instance with\n+ * specified KEM, KDF, and AEAD algorithm identifiers.\n@@ -102,1 +93,2 @@\n- * For successful interoperability, both sides need to supply identical\n+ * For successful interoperability, both sides need to have identical algorithm\n+ * identifiers, and supply identical\n@@ -108,5 +100,1 @@\n- * If the sender cipher is initialized without parameters, it assumes a\n- * default parameters object is used, which is equivalent to\n- * {@code HPKEParameterSpec.of()}. In this case, the\n- * cipher always works in {@code mode_base} mode with an empty {@code info}.\n- * If the recipient side is initialized without parameters, an\n+ * If an HPKE cipher is initialized without parameters, an\n@@ -122,1 +110,0 @@\n- * <li> The algorithm identifiers are not specified on the receiver side.\n@@ -128,9 +115,0 @@\n- * After an HPKE cipher is initialized, the {@link Cipher#getParameters} method\n- * returns an {@link java.security.AlgorithmParameters} object containing the\n- * actual {@code HPKEParameterSpec} object used by the cipher. Users can call\n- * {@link #kem_id()}, {@link #kdf_id()}, and {@link #aead_id()} on the\n- * {@code HPKEParameterSpec} object to obtain the algorithm identifiers\n- * selected during initialization. On the sender side, the key encapsulation\n- * message is also included in this {@code HPKEParameterSpec} object,\n- * even if it was not provided to the cipher initialization.\n- * <p>\n@@ -140,35 +118,0 @@\n- * @implNote\n- * In the HPKE implementation in the SunJCE provider included in this JDK\n- * implementation, if the sender's HPKE cipher is initialized with\n- * {@code HPKEParameterSpec.of()}, the following KEM, KDF, and AEAD algorithm\n- * identifiers will be chosen depending on the provided key type and returned\n- * by the {@code getParameters} method:\n- * <table class=\"striped\">\n- * <caption style=\"display:none\">Default Algorithm Identifiers<\/caption>\n- * <thead>\n- * <tr><th scope=\"col\">key type\n- *     <th scope=\"col\">{@code kem_id}\n- *     <th scope=\"col\">{@code kdf_id}\n- *     <th scope=\"col\">{@code aead_id}\n- * <\/thead>\n- * <tbody>\n- * <tr><td>EC (secp256r1)\n- *     <td>{@link #KEM_DHKEM_P_256_HKDF_SHA256}\n- *     <td>{@link #KDF_HKDF_SHA256}\n- *     <td rowspan=\"5\">{@link #AEAD_AES_256_GCM}\n- * <tr><td>EC (secp384r1)\n- *     <td>{@link #KEM_DHKEM_P_384_HKDF_SHA384}\n- *     <td>{@link #KDF_HKDF_SHA384}\n- * <tr><td>EC (secp521r1)\n- *     <td>{@link #KEM_DHKEM_P_521_HKDF_SHA512}\n- *     <td>{@link #KDF_HKDF_SHA512}\n- * <tr><td>XDH (X25519)\n- *     <td>{@link #KEM_DHKEM_X25519_HKDF_SHA256}\n- *     <td>{@link #KDF_HKDF_SHA256}\n- * <tr><td>XDH (X448)\n- *     <td>{@link #KEM_DHKEM_X448_HKDF_SHA512}\n- *     <td>{@link #KDF_HKDF_SHA512}\n- * <\/tbody>\n- * <\/table>\n- * No other keys are supported.\n- *\n@@ -255,3 +198,3 @@\n-    private final int kem_id; \/\/ -1 is determined by key later\n-    private final int kdf_id; \/\/ -1 is determined by key later\n-    private final int aead_id; \/\/ -1 is determined by key later\n+    private final int kem_id;\n+    private final int kdf_id;\n+    private final int aead_id;\n@@ -277,13 +220,0 @@\n-    \/**\n-     * A factory method to create an empty {@code HPKEParameterSpec} in\n-     * {@code mode_base} mode with an empty {@code info}. The KEM, KDF,\n-     * and AEAD algorithm identifiers are not specified and will be\n-     * determined by the key used in cipher initialization.\n-     *\n-     * @return a new {@code HPKEParameterSpec} object\n-     *\/\n-    public static HPKEParameterSpec of() {\n-        return new HPKEParameterSpec(-1, -1, -1,\n-                new byte[0], null, new byte[0], null, null);\n-    }\n-\n@@ -395,1 +325,1 @@\n-     * {@return the identifier for KEM, -1 if unspecified}\n+     * {@return the identifier for KEM }\n@@ -402,1 +332,1 @@\n-     * {@return the identifier for KDF, -1 if unspecified}\n+     * {@return the identifier for KDF }\n@@ -409,1 +339,1 @@\n-     * {@return the identifier for AEAD, -1 if unspecified}\n+     * {@return the identifier for AEAD }\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/HPKEParameterSpec.java","additions":12,"deletions":82,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -34,0 +34,5 @@\n+\n+        int kem_id = HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256;\n+        int kdf_id = HPKEParameterSpec.KDF_HKDF_SHA256;\n+        int aead_id = HPKEParameterSpec.AEAD_AES_128_GCM;\n+\n@@ -42,1 +47,1 @@\n-        HPKEParameterSpec ps = HPKEParameterSpec.of()\n+        HPKEParameterSpec ps = HPKEParameterSpec.of(kem_id, kdf_id, aead_id)\n@@ -46,4 +51,0 @@\n-        \/\/ Retrieve the actual parameters used from the sender.\n-        HPKEParameterSpec actual = senderCipher.getParameters()\n-                .getParameterSpec(HPKEParameterSpec.class);\n-\n@@ -51,2 +52,1 @@\n-        \/\/ It can also be retrieved using sender.getIV().\n-        byte[] kemEncap = actual.encapsulation();\n+        byte[] kemEncap = senderCipher.getIV();\n@@ -58,2 +58,1 @@\n-        HPKEParameterSpec pr = HPKEParameterSpec\n-                .of(actual.kem_id(), actual.kdf_id(), actual.aead_id())\n+        HPKEParameterSpec pr = HPKEParameterSpec.of(kem_id, kdf_id, aead_id)\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/snippet-files\/PackageSnippets.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-        var emptyParams = HPKEParameterSpec.of();\n@@ -67,4 +66,4 @@\n-        var spec = emptyParams;\n-        Asserts.assertEQ(spec.kem_id(), -1);\n-        Asserts.assertEQ(spec.kdf_id(), -1);\n-        Asserts.assertEQ(spec.aead_id(), -1);\n+        var spec = defaultParams;\n+        Asserts.assertEQ(spec.kem_id(), KEM_DHKEM_X25519_HKDF_SHA256);\n+        Asserts.assertEQ(spec.kdf_id(), KDF_HKDF_SHA256);\n+        Asserts.assertEQ(spec.aead_id(), AEAD_AES_256_GCM);\n@@ -154,1 +153,1 @@\n-        c1.init(Cipher.ENCRYPT_MODE, kp.getPublic());\n+        c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), defaultParams);\n@@ -159,3 +158,0 @@\n-        var params = c1.getParameters().getParameterSpec(HPKEParameterSpec.class);\n-        Asserts.assertEqualsByteArray(encap, params.encapsulation());\n-\n@@ -164,1 +160,1 @@\n-                () -> c1.init(Cipher.WRAP_MODE, kp.getPublic()));\n+                () -> c1.init(Cipher.WRAP_MODE, kp.getPublic(), defaultParams));\n@@ -166,1 +162,1 @@\n-                () -> c1.init(Cipher.UNWRAP_MODE, kp.getPublic()));\n+                () -> c1.init(Cipher.UNWRAP_MODE, kp.getPublic(), defaultParams));\n@@ -175,1 +171,1 @@\n-                        emptyParams.encapsulation(new byte[32])));\n+                        defaultParams.encapsulation(new byte[32])));\n@@ -177,1 +173,3 @@\n-        \/\/ Cannot init recipient without algorithm identifiers\n+        \/\/ Cannot init without algorithm identifiers\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> c2.init(Cipher.ENCRYPT_MODE, kp.getPublic()));\n@@ -180,6 +178,0 @@\n-        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n-                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n-                        emptyParams));\n-        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n-                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n-                        emptyParams.encapsulation(encap)));\n@@ -218,1 +210,1 @@\n-        c1.init(Cipher.ENCRYPT_MODE, kp.getPublic());\n+        c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), defaultParams);\n@@ -251,5 +243,0 @@\n-        \/\/ check default values\n-        checkEncryptDecrypt(kp,\n-                emptyParams,\n-                defaultParams);\n-\n@@ -269,2 +256,0 @@\n-        Asserts.assertThrows(InvalidParameterSpecException.class,\n-                () -> ap.init(emptyParams));\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/Compliance.java","additions":12,"deletions":27,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -35,0 +35,8 @@\n+import static javax.crypto.spec.HPKEParameterSpec.AEAD_AES_256_GCM;\n+import static javax.crypto.spec.HPKEParameterSpec.KDF_HKDF_SHA256;\n+import static javax.crypto.spec.HPKEParameterSpec.KEM_DHKEM_P_256_HKDF_SHA256;\n+import static javax.crypto.spec.HPKEParameterSpec.KEM_DHKEM_P_384_HKDF_SHA384;\n+import static javax.crypto.spec.HPKEParameterSpec.KEM_DHKEM_P_521_HKDF_SHA512;\n+import static javax.crypto.spec.HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256;\n+import static javax.crypto.spec.HPKEParameterSpec.KEM_DHKEM_X448_HKDF_SHA512;\n+\n@@ -42,1 +50,1 @@\n-    record Params(String name) {}\n+    record Params(String name, int kem) {}\n@@ -44,5 +52,5 @@\n-            new Params(\"secp256r1\"),\n-            new Params(\"secp384r1\"),\n-            new Params(\"secp521r1\"),\n-            new Params(\"X25519\"),\n-            new Params(\"X448\")\n+            new Params(\"secp256r1\", KEM_DHKEM_P_256_HKDF_SHA256),\n+            new Params(\"secp384r1\", KEM_DHKEM_P_384_HKDF_SHA384),\n+            new Params(\"secp521r1\", KEM_DHKEM_P_521_HKDF_SHA512),\n+            new Params(\"X25519\", KEM_DHKEM_X25519_HKDF_SHA256),\n+            new Params(\"X448\", KEM_DHKEM_X448_HKDF_SHA512)\n@@ -62,0 +70,2 @@\n+            var params = HPKEParameterSpec\n+                    .of(param.kem, KDF_HKDF_SHA256, AEAD_AES_256_GCM);\n@@ -63,1 +73,1 @@\n-            c.init(Cipher.ENCRYPT_MODE, kp.getPublic());\n+            c.init(Cipher.ENCRYPT_MODE, kp.getPublic(), params);\n@@ -66,7 +76,1 @@\n-            var ap = c.getParameters();\n-            var spec = ap.getParameterSpec(HPKEParameterSpec.class);\n-\n-            c.init(Cipher.DECRYPT_MODE, kp.getPrivate(), ap);\n-            Asserts.assertEqualsByteArray(msg, c.doFinal(ct));\n-\n-            c.init(Cipher.DECRYPT_MODE, kp.getPrivate(), spec);\n+            c.init(Cipher.DECRYPT_MODE, kp.getPrivate(), params.encapsulation(c.getIV()));\n@@ -75,1 +79,1 @@\n-            c.init(Cipher.ENCRYPT_MODE, kp.getPublic(), HPKEParameterSpec.of()\n+            c.init(Cipher.ENCRYPT_MODE, kp.getPublic(), params\n@@ -80,1 +84,0 @@\n-            var params = c.getParameters().getParameterSpec(HPKEParameterSpec.class);\n@@ -83,1 +86,5 @@\n-                    .authKey(kp2.getPublic()));\n+                    .authKey(kp2.getPublic())\n+                    .info(info)\n+                    .psk(psk, psk_id)\n+                    .encapsulation(c.getIV()));\n+\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/Functions.java","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"}]}