{"files":[{"patch":"@@ -74,1 +74,0 @@\n-\/\/ without the AuthEncap and AuthDecap functions\n@@ -94,1 +93,2 @@\n-                           PrivateKey skR, PublicKey pkR)\n+                           PrivateKey skS, PublicKey pkS, \/\/ sender keys\n+                           PrivateKey skR, PublicKey pkR) \/\/ receiver keys\n@@ -106,1 +106,0 @@\n-            byte[] kem_context = concat(pkEm, pkRm);\n@@ -108,3 +107,12 @@\n-                var dh = params.DH(skE, pkR);\n-                return new KEM.Encapsulated(params.deriveKey(\n-                        algorithm, from, to, kem_context, dh), pkEm, null);\n+                SecretKey key;\n+                if (skS == null) {\n+                    byte[] kem_context = concat(pkEm, pkRm);\n+                    key = params.deriveKey(algorithm, from, to, kem_context,\n+                            params.DH(skE, pkR));\n+                } else {\n+                    byte[] pkSm = params.SerializePublicKey(pkS);\n+                    byte[] kem_context = concat(pkEm, pkRm, pkSm);\n+                    key = params.deriveKey(algorithm, from, to, kem_context,\n+                            params.DH(skE, pkR), params.DH(skS, pkR));\n+                }\n+                return new KEM.Encapsulated(key, pkEm, null);\n@@ -129,1 +137,0 @@\n-                var dh = params.DH(skR, pkE);\n@@ -131,2 +138,10 @@\n-                byte[] kem_context = concat(encapsulation, pkRm);\n-                return params.deriveKey(algorithm, from, to, kem_context, dh);\n+                if (pkS == null) {\n+                    byte[] kem_context = concat(encapsulation, pkRm);\n+                    return params.deriveKey(algorithm, from, to, kem_context,\n+                            params.DH(skR, pkE));\n+                } else {\n+                    byte[] pkSm = params.SerializePublicKey(pkS);\n+                    byte[] kem_context = concat(encapsulation, pkRm, pkSm);\n+                    return params.deriveKey(algorithm, from, to, kem_context,\n+                            params.DH(skR, pkE), params.DH(skR, pkS));\n+                }\n@@ -282,1 +297,1 @@\n-                byte[] kem_context, SecretKey dh)\n+                byte[] kem_context, SecretKey... dhs)\n@@ -285,1 +300,1 @@\n-                return ExtractAndExpand(dh, kem_context, alg);\n+                return ExtractAndExpand(kem_context, alg, dhs);\n@@ -289,1 +304,1 @@\n-                var fullKey = ExtractAndExpand(dh, kem_context, \"Generic\");\n+                var fullKey = ExtractAndExpand(kem_context, \"Generic\", dhs);\n@@ -306,1 +321,1 @@\n-        private SecretKey ExtractAndExpand(SecretKey dh, byte[] kem_context, String alg)\n+        private SecretKey ExtractAndExpand(byte[] kem_context, String alg, SecretKey... dhs)\n@@ -309,1 +324,2 @@\n-            var builder = labeledExtract(suiteId, EAE_PRK).addIKM(dh);\n+            var builder = labeledExtract(suiteId, EAE_PRK);\n+            for (var dh : dhs) builder.addIKM(dh);\n@@ -395,1 +411,16 @@\n-        return new Handler(params, getSecureRandom(secureRandom), null, pk);\n+        return new Handler(params, getSecureRandom(secureRandom), null, null, null, pk);\n+    }\n+\n+    \/\/ AuthEncap is not public KEM API\n+    public EncapsulatorSpi engineNewAuthEncapsulator(PublicKey pkR, PrivateKey skS,\n+            AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (pkR == null || skS == null) {\n+            throw new InvalidKeyException(\"input key is null\");\n+        }\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\"no spec needed\");\n+        }\n+        Params params = paramsFromKey(pkR);\n+        return new Handler(params, getSecureRandom(secureRandom),\n+                skS, params.getPublicKey(skS), null, pkR);\n@@ -408,1 +439,15 @@\n-        return new Handler(params, null, sk, params.getPublicKey(sk));\n+        return new Handler(params, null, null, null, sk, params.getPublicKey(sk));\n+    }\n+\n+    \/\/ AuthDecap is not public KEM API\n+    public DecapsulatorSpi engineNewAuthDecapsulator(\n+            PrivateKey skR, PublicKey pkS, AlgorithmParameterSpec spec)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (skR == null || pkS == null) {\n+            throw new InvalidKeyException(\"input key is null\");\n+        }\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\"no spec needed\");\n+        }\n+        Params params = paramsFromKey(skR);\n+        return new Handler(params, null, null, pkS, skR, params.getPublicKey(skR));\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKEM.java","additions":61,"deletions":16,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -385,1 +385,1 @@\n-                KEM.Encapsulator e;\n+                KEM.Encapsulated enc;\n@@ -387,1 +387,6 @@\n-                    e = kem().newEncapsulator(pk, rand);\n+                    var e = kem().newEncapsulator(pk, rand);\n+                    enc = e.encapsulate();\n+                } else if (p.authKey() instanceof PrivateKey skS) {\n+                    \/\/ AuthEncap not public KEM API but it's internally supported\n+                    var e = new DHKEM().engineNewAuthEncapsulator(pk, skS, null, rand);\n+                    enc = e.engineEncapsulate(0, e.engineSecretSize(), \"Generic\");\n@@ -389,7 +394,2 @@\n-                    if (p.authKey() instanceof PrivateKey) {\n-                        throw new UnsupportedOperationException(\n-                                \"auth mode not supported\");\n-                    } else {\n-                        throw new InvalidAlgorithmParameterException(\n-                                \"Cannot auth with public key\");\n-                    }\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"Cannot auth with public key\");\n@@ -397,1 +397,0 @@\n-                var enc = e.encapsulate();\n@@ -406,1 +405,5 @@\n-                    KEM.Decapsulator d;\n+                    var encap = p.encapsulation();\n+                    if (encap == null) {\n+                        throw new InvalidAlgorithmParameterException(\n+                                \"Must provide key encapsulation message on recipient side\");\n+                    }\n@@ -408,1 +411,7 @@\n-                        d = kem().newDecapsulator(sk);\n+                        var d = kem().newDecapsulator(sk);\n+                        shared_secret = d.decapsulate(encap);\n+                    } else if (p.authKey() instanceof PublicKey pkS) {\n+                        \/\/ AuthDecap not public KEM API but it's internally supported\n+                        var d = new DHKEM().engineNewAuthDecapsulator(sk, pkS, null);\n+                        shared_secret = d.engineDecapsulate(\n+                                encap, 0, d.engineSecretSize(), \"Generic\");\n@@ -410,9 +419,0 @@\n-                        if (p.authKey() instanceof PublicKey) {\n-                            throw new UnsupportedOperationException(\n-                                    \"auth mode not supported\");\n-                        } else {\n-                            throw new InvalidAlgorithmParameterException(\n-                                    \"Cannot auth with private key\");\n-                        }\n-                    }\n-                    if (p.encapsulation() == null) {\n@@ -420,1 +420,1 @@\n-                                \"Must provide key encapsulation message on recipient side\");\n+                                \"Cannot auth with private key\");\n@@ -422,1 +422,0 @@\n-                    shared_secret = d.decapsulate(p.encapsulation());\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HPKE.java","additions":22,"deletions":23,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -41,4 +41,4 @@\n- * In HPKE, the {@code Cipher} object on the sender side is always initialized\n- * with the recipient's public key in {@linkplain Cipher#ENCRYPT_MODE encrypt mode},\n- * and {@code Cipher} object on the recipient side is always initialized with\n- * its own private key in {@linkplain Cipher#DECRYPT_MODE decrypt mode}.\n+ * In HPKE, the sender's {@code Cipher} is always initialized with the\n+ * recipient's public key in {@linkplain Cipher#ENCRYPT_MODE encrypt mode},\n+ * while the recipient's {@code Cipher} object is initialized with its own\n+ * private key in {@linkplain Cipher#DECRYPT_MODE decrypt mode}.\n@@ -49,1 +49,1 @@\n- * An {@code HPKEParameterSpec} object can be created in two ways.\n+ * An {@code HPKEParameterSpec} object can be created in two ways:\n@@ -51,6 +51,5 @@\n- * <li> The {@link #of()} method creates an object whose KEM, KDF, and AEAD\n- * algorithms are determined by the type of key provided to the {@code init()}\n- * method.\n- * <li>\n- * The {@link #of(int, int, int)} method creates an object whose KEM, KDF,\n- * and AEAD algorithms are determined by the specified numeric identifiers.\n+ * <li> {@link #of()} creates an instance with unspecified KEM, KDF, and AEAD\n+ * algorithms, which will be determined by the implementation based on the key\n+ * provided to {@code init()}.\n+ * <li> {@link #of(int, int, int)} creates an instance with explicitly\n+ * specified KEM, KDF, and AEAD algorithm identifiers.\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/HPKEParameterSpec.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -251,9 +251,8 @@\n-        \/\/ mod_auth, not supported\n-        Utils.runAndCheckException(\n-                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n-                        HPKEParameterSpec.of().authKey(kp2.getPrivate())),\n-                UnsupportedOperationException.class);\n-        Utils.runAndCheckException(\n-                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n-                        HPKEParameterSpec.of().authKey(kp2.getPublic())),\n-                UnsupportedOperationException.class);\n+        \/\/ mod_auth\n+        c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of().authKey(kp2.getPrivate()));\n+        ct = c1.doFinal(new byte[2]);\n+        c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                        HPKEParameterSpec.of().authKey(kp2.getPublic())\n+                                .encapsulation(c1.getIV()));\n+        Asserts.assertEqualsByteArray(c2.doFinal(ct), new byte[2]);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/Compliance.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+            var kp2 = genKeyPair(param.name());\n@@ -73,0 +74,1 @@\n+                    .authKey(kp2.getPrivate())\n@@ -78,0 +80,1 @@\n+                    .authKey(kp2.getPublic())\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/Functions.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -94,0 +94,17 @@\n+            System.err.print('I');\n+            var kem_id = Integer.parseInt(tg.get(\"kem_id\").asString());\n+            var kdf_id = Integer.parseInt(tg.get(\"kdf_id\").asString());\n+            var aead_id = Integer.parseInt(tg.get(\"aead_id\").asString());\n+            var ikmR = h.parseHex(tg.get(\"ikmR\").asString());\n+            var ikmE = h.parseHex(tg.get(\"ikmE\").asString());\n+            var info = h.parseHex(tg.get(\"info\").asString());\n+\n+            var kpR = new DHKEM.RFC9180DeriveKeyPairSR(ikmR).derive(kem_id);\n+            var spec = HPKEParameterSpec.of(kem_id, kdf_id, aead_id).info(info);\n+            var rand = new DHKEM.RFC9180DeriveKeyPairSR(ikmE);\n+\n+            if (mode == 1 || mode == 3) {\n+                spec = spec.psk(\n+                        new SecretKeySpec(h.parseHex(tg.get(\"psk\").asString()), \"Generic\"),\n+                        h.parseHex(tg.get(\"psk_id\").asString()));\n+            }\n@@ -95,16 +112,1 @@\n-                System.err.print('I');\n-                var kem_id = Integer.parseInt(tg.get(\"kem_id\").asString());\n-                var kdf_id = Integer.parseInt(tg.get(\"kdf_id\").asString());\n-                var aead_id = Integer.parseInt(tg.get(\"aead_id\").asString());\n-                var ikmR = h.parseHex(tg.get(\"ikmR\").asString());\n-                var ikmE = h.parseHex(tg.get(\"ikmE\").asString());\n-                var info = h.parseHex(tg.get(\"info\").asString());\n-                var kpR = new DHKEM.RFC9180DeriveKeyPairSR(ikmR).derive(kem_id);\n-                var spec = HPKEParameterSpec.of(kem_id, kdf_id, aead_id).info(info);\n-                if (mode == 1) {\n-                    spec = spec.psk(\n-                            new SecretKeySpec(h.parseHex(tg.get(\"psk\").asString()), \"Generic\"),\n-                            h.parseHex(tg.get(\"psk_id\").asString()));\n-                }\n-                c1.init(Cipher.ENCRYPT_MODE, kpR.getPublic(), spec,\n-                        new DHKEM.RFC9180DeriveKeyPairSR(ikmE));\n+                c1.init(Cipher.ENCRYPT_MODE, kpR.getPublic(), spec, rand);\n@@ -114,1 +116,6 @@\n-                continue; \/\/ auth not supported\n+                var ikmS = h.parseHex(tg.get(\"ikmS\").asString());\n+                var kpS = new DHKEM.RFC9180DeriveKeyPairSR(ikmS).derive(kem_id);\n+                c1.init(Cipher.ENCRYPT_MODE, kpR.getPublic(),\n+                        spec.authKey(kpS.getPrivate()), rand);\n+                c2.init(Cipher.DECRYPT_MODE, kpR.getPrivate(),\n+                        spec.encapsulation(c1.getIV()).authKey(kpS.getPublic()));\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/KAT9180.java","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"}]}