{"files":[{"patch":"@@ -118,1 +118,1 @@\n-        return state == BEGIN ? null : impl.iv;\n+        return state == BEGIN ? null : impl.params.encapsulation();\n@@ -123,0 +123,3 @@\n+        if (state == BEGIN) {\n+            return null;\n+        }\n@@ -157,2 +160,0 @@\n-        } else if (params instanceof IvParameterSpec iv) {\n-            impl.init(ak, HPKEParameterSpec.of().encapsulation(iv.getIV()), random);\n@@ -184,1 +185,1 @@\n-            throw new IllegalStateException();\n+            throw new IllegalStateException(\"Illegal state: \" + state);\n@@ -312,2 +313,0 @@\n-        byte[] iv; \/\/ sender side\n-\n@@ -403,1 +402,1 @@\n-                iv = enc.encapsulation();\n+                params = params.encapsulation(enc.encapsulation());\n@@ -501,0 +500,4 @@\n+                if (opmode == Cipher.DECRYPT_MODE) {\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"Algorithm identifiers must be provided on receiver\");\n+                }\n@@ -515,1 +518,2 @@\n-                    default -> throw new InvalidAlgorithmParameterException();\n+                    default -> throw new InvalidAlgorithmParameterException(\n+                            \"Unsupported kem_id: \" + params.kem_id());\n@@ -537,1 +541,2 @@\n-                default -> throw new InvalidAlgorithmParameterException();\n+                default -> throw new InvalidAlgorithmParameterException(\n+                        \"Unsupported kdf_id: \" + params.kdf_id());\n@@ -543,1 +548,2 @@\n-                default -> throw new InvalidAlgorithmParameterException();\n+                default -> throw new InvalidAlgorithmParameterException(\n+                        \"Unsupported kdf_id: \" + params.kdf_id());\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HPKE.java","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -53,4 +53,1 @@\n- * provided to {@code init()}.\n- * <li> {@link #of(int, int)} creates an instance with explicitly specified\n- * KDF, and AEAD algorithm identifiers. The KEM algorithm identifier will be\n- * determined by the implementation based on the key provided to {@code init()}.\n+ * provided to {@code init()}. This instance can only be used by the sender.\n@@ -58,1 +55,2 @@\n- * specified KEM, KDF, and AEAD algorithm identifiers.\n+ * specified KEM, KDF, and AEAD algorithm identifiers. This instance can be\n+ * used by both the sender and the receiver.\n@@ -91,3 +89,5 @@\n- * the key encapsulation message can be retrieved using the {@link Cipher#getIV()}\n- * method after the cipher is initialized. On the recipient side, the key\n- * encapsulation message can be provided using the {@link #encapsulation(byte[])}\n+ * after the cipher is initialized, the key encapsulation message can be\n+ * retrieved directly using the {@link Cipher#getIV()} method, or from the\n+ * {@code HPKEParameterSpec} object contained in the returned value of the\n+ * {@link Cipher#getParameters} method. On the recipient side, the key\n+ * encapsulation message must be provided using the {@link #encapsulation(byte[])}\n@@ -104,3 +104,1 @@\n- * {@code HPKEParameterSpec.of()}. The recipient cipher can also be initialized\n- * with a {@code new IvParameterSpec(encap)} object, which is equivalent to\n- * {@code HPKEParameterSpec.of().encapsulation(encap)}. In either case, the\n+ * {@code HPKEParameterSpec.of()}. In this case, the\n@@ -108,1 +106,1 @@\n- * If the recipient side is initialized without any parameters, an\n+ * If the recipient side is initialized without parameters, an\n@@ -118,0 +116,1 @@\n+ * <li> The algorithm identifiers are not specified on the receiver side.\n@@ -123,2 +122,2 @@\n- * After an HPKE cipher is initialized, the {@code getParameters} method returns\n- * an {@link java.security.AlgorithmParameters} object containing the\n+ * After an HPKE cipher is initialized, the {@link Cipher#getParameters} method\n+ * returns an {@link java.security.AlgorithmParameters} object containing the\n@@ -128,1 +127,3 @@\n- * selected during initialization.\n+ * selected during initialization. On the sender side, the key encapsulation\n+ * message is also included in this {@code HPKEParameterSpec} object,\n+ * even if it was not provided to the cipher initialization.\n@@ -135,2 +136,4 @@\n- * implementation, {@code HPKEParameterSpec.of()} chooses the following\n- * KEM, KDF, and AEAD algorithms depending on the provided key type:\n+ * implementation, if the sender's HPKE cipher is initialized with\n+ * {@code HPKEParameterSpec.of()}, the following KEM, KDF, and AEAD algorithm\n+ * identifiers will be chosen depending on the provided key type and returned\n+ * by the {@code getParameters} method:\n@@ -147,3 +150,3 @@\n- *     <td>0x10<br>DHKEM(P-256, HKDF-SHA256)\n- *     <td>0x1<br>HKDF-SHA256\n- *     <td rowspan=\"5\">0x2<br>AES-256-GCM\n+ *     <td>{@link #KEM_DHKEM_P_256_HKDF_SHA256}\n+ *     <td>{@link #KDF_HKDF_SHA256}\n+ *     <td rowspan=\"5\">{@link #AEAD_AES_256_GCM}\n@@ -151,2 +154,2 @@\n- *     <td>0x11<br>DHKEM(P-384, HKDF-SHA384)\n- *     <td>0x2<br>HKDF-SHA384\n+ *     <td>{@link #KEM_DHKEM_P_384_HKDF_SHA384}\n+ *     <td>{@link #KDF_HKDF_SHA384}\n@@ -154,2 +157,2 @@\n- *     <td>0x12<br>DHKEM(P-521, HKDF-SHA512)\n- *     <td>0x3<br>HKDF-SHA512\n+ *     <td>{@link #KEM_DHKEM_P_521_HKDF_SHA512}\n+ *     <td>{@link #KDF_HKDF_SHA512}\n@@ -157,2 +160,2 @@\n- *     <td>0x20<br>DHKEM(X25519, HKDF-SHA256)\n- *     <td>0x1<br>HKDF-SHA256\n+ *     <td>{@link #KEM_DHKEM_X25519_HKDF_SHA256}\n+ *     <td>{@link #KDF_HKDF_SHA256}\n@@ -160,2 +163,2 @@\n- *     <td>0x21<br>DHKEM(X448, HKDF-SHA512)\n- *     <td>0x3<br>HKDF-SHA512\n+ *     <td>{@link #KEM_DHKEM_X448_HKDF_SHA512}\n+ *     <td>{@link #KDF_HKDF_SHA512}\n@@ -281,23 +284,0 @@\n-    \/**\n-     * A factory method to create a new {@code HPKEParameterSpec} object with\n-     * specified KDF and AEAD algorithm identifiers in {@code mode_base}\n-     * mode with an empty {@code info}. The KEM algorithm identifier is not\n-     * specified and will be determined by the key used in cipher initialization.\n-     *\n-     * @param kdf_id identifier for KDF, must be between 0 and 65535 (inclusive)\n-     * @param aead_id identifier for AEAD, must be between 0 and 65535 (inclusive)\n-     * @return a new {@code HPKEParameterSpec} object\n-     * @throws IllegalArgumentException if any input value\n-     *      is out of range (must be between 0 and 65535, inclusive).\n-     *\/\n-    public static HPKEParameterSpec of(int kdf_id, int aead_id) {\n-        if (kdf_id < 0 || kdf_id > 65535) {\n-            throw new IllegalArgumentException(\"Invalid kdf_id: \" + kdf_id);\n-        }\n-        if (aead_id < 0 || aead_id > 65535) {\n-            throw new IllegalArgumentException(\"Invalid aead_id: \" + aead_id);\n-        }\n-        return new HPKEParameterSpec(-1, kdf_id, aead_id,\n-                new byte[0], null, new byte[0], null, null);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/HPKEParameterSpec.java","additions":31,"deletions":51,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-package javax.crypto.spec.snippets;\n-\n@@ -48,3 +46,0 @@\n-        \/\/ Retrieve the key encapsulation message (the KEM output) from the sender\n-        byte[] kemEncap = sender.getIV();\n-\n@@ -54,3 +49,4 @@\n-        assert actual.kem_id() == HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256;\n-        assert actual.kdf_id() == HPKEParameterSpec.KDF_HKDF_SHA256;\n-        assert actual.aead_id() == HPKEParameterSpec.AEAD_AES_256_GCM;\n+\n+        \/\/ Retrieve the key encapsulation message (the KEM output) from the sender.\n+        \/\/ It can also be retrieved using sender.getIV().\n+        byte[] kemEncap = actual.encapsulation();\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/snippet-files\/PackageSnippets.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import javax.crypto.spec.IvParameterSpec;\n@@ -36,0 +35,5 @@\n+import static javax.crypto.spec.HPKEParameterSpec.AEAD_AES_256_GCM;\n+import static javax.crypto.spec.HPKEParameterSpec.EXPORT_ONLY;\n+import static javax.crypto.spec.HPKEParameterSpec.KDF_HKDF_SHA256;\n+import static javax.crypto.spec.HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256;\n+\n@@ -45,0 +49,6 @@\n+        var emptyParams = HPKEParameterSpec.of();\n+        var defaultParams = HPKEParameterSpec.of(\n+                KEM_DHKEM_X25519_HKDF_SHA256,\n+                KDF_HKDF_SHA256,\n+                AEAD_AES_256_GCM);\n+\n@@ -53,1 +63,1 @@\n-        var spec = HPKEParameterSpec.of();\n+        var spec = emptyParams;\n@@ -63,1 +73,1 @@\n-        \/\/ Partial default values\n+        \/\/ Specified values\n@@ -74,12 +84,0 @@\n-        var spec3 = HPKEParameterSpec.of(0, 0);\n-\n-        HPKEParameterSpec.of(65535, 65535, 65535);\n-        Asserts.assertEQ(spec3.kem_id(), -1);\n-        Asserts.assertEQ(spec3.kdf_id(), 0);\n-        Asserts.assertEQ(spec3.aead_id(), 0);\n-        Asserts.assertEQ(spec3.authKey(), null);\n-        Asserts.assertEQ(spec3.encapsulation(), null);\n-        Asserts.assertEqualsByteArray(spec3.info(), new byte[0]);\n-        Asserts.assertEQ(spec3.psk(), null);\n-        Asserts.assertEqualsByteArray(spec3.psk_id(), new byte[0]);\n-\n@@ -87,8 +85,1 @@\n-        Asserts.assertThrows(IllegalArgumentException.class,\n-                () -> HPKEParameterSpec.of(-1, 0));\n-        Asserts.assertThrows(IllegalArgumentException.class,\n-                () -> HPKEParameterSpec.of(0, -1));\n-        Asserts.assertThrows(IllegalArgumentException.class,\n-                () -> HPKEParameterSpec.of(65536, 0));\n-        Asserts.assertThrows(IllegalArgumentException.class,\n-                () -> HPKEParameterSpec.of(0, 65536));\n+        HPKEParameterSpec.of(65535, 65535, 65535);\n@@ -139,0 +130,1 @@\n+        Asserts.assertEQ(c1.getParameters(), null);\n@@ -152,2 +144,6 @@\n-        c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(), new IvParameterSpec(c1.getIV()));\n-        c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(), HPKEParameterSpec.of().encapsulation(c1.getIV()));\n+        var encap = c1.getIV();\n+        c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                defaultParams.encapsulation(encap));\n+\n+        var params = c1.getParameters().getParameterSpec(HPKEParameterSpec.class);\n+        Asserts.assertEqualsByteArray(encap, params.encapsulation());\n@@ -164,0 +160,1 @@\n+\n@@ -167,1 +164,1 @@\n-                        HPKEParameterSpec.of().encapsulation(new byte[32])));\n+                        emptyParams.encapsulation(new byte[32])));\n@@ -169,4 +166,1 @@\n-        \/\/ Cannot init recipient with public key\n-        Asserts.assertThrows(InvalidKeyException.class,\n-                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPublic()));\n-        \/\/ Must provide key encap msg to recipient\n+        \/\/ Cannot init recipient without algorithm identifiers\n@@ -175,0 +169,6 @@\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                        emptyParams));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                        emptyParams.encapsulation(encap)));\n@@ -176,4 +176,5 @@\n-        \/\/ Unknown identifiers\n-        c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), HPKEParameterSpec.of(0x20, 1, 1));\n-\n-        \/\/ Unknown identifiers\n+        \/\/ Cannot init recipient with public key\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPublic(),\n+                        defaultParams.encapsulation(encap)));\n+        \/\/ Must provide key encap msg to recipient\n@@ -181,1 +182,3 @@\n-                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), HPKEParameterSpec.of(0, 1, 1)));\n+                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(), defaultParams));\n+\n+        \/\/ Unsupported identifiers\n@@ -183,1 +186,2 @@\n-                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), HPKEParameterSpec.of(0x200, 1, 1)));\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of(0, KDF_HKDF_SHA256, AEAD_AES_256_GCM)));\n@@ -185,1 +189,2 @@\n-                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), HPKEParameterSpec.of(0x20, 4, 1)));\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of(0x200, KDF_HKDF_SHA256, AEAD_AES_256_GCM)));\n@@ -187,3 +192,2 @@\n-                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), HPKEParameterSpec.of(0x20, 1, 4)));\n-\n-        \/\/ No key encap msg for recipient\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of(KEM_DHKEM_X25519_HKDF_SHA256, 4, AEAD_AES_256_GCM)));\n@@ -191,1 +195,2 @@\n-                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(), HPKEParameterSpec.of(0x20, 1, 1)));\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of(KEM_DHKEM_X25519_HKDF_SHA256, KDF_HKDF_SHA256, 4)));\n@@ -193,1 +198,1 @@\n-        \/\/ No key encap msg for recipient\n+        \/\/ No key encap msg for recipient (export only)\n@@ -195,1 +200,3 @@\n-                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(), HPKEParameterSpec.of(0x20, 1, 65535)));\n+                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                        HPKEParameterSpec.of(\n+                                KEM_DHKEM_X25519_HKDF_SHA256, KDF_HKDF_SHA256, EXPORT_ONLY)));\n@@ -207,2 +214,1 @@\n-                HPKEParameterSpec.of().encapsulation(c1.getIV()));\n-        Asserts.assertEQ(c2.getIV(), null);\n+                defaultParams.encapsulation(c1.getIV()));\n@@ -214,5 +220,0 @@\n-        c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(), new IvParameterSpec(c1.getIV()));\n-        c2.updateAAD(aad);\n-        c2.update(ct);\n-        Asserts.assertEqualsByteArray(c2.doFinal(), new byte[2]);\n-\n@@ -221,2 +222,2 @@\n-                HPKEParameterSpec.of().info(info).psk(psk, psk_id),\n-                HPKEParameterSpec.of().info(info).psk(psk, psk_id));\n+                defaultParams.info(info).psk(psk, psk_id),\n+                defaultParams.info(info).psk(psk, psk_id));\n@@ -229,1 +230,1 @@\n-                        HPKEParameterSpec.of().authKey(kp2.getPublic())));\n+                        defaultParams.authKey(kp2.getPublic())));\n@@ -232,1 +233,1 @@\n-                        HPKEParameterSpec.of().authKey(kp2.getPrivate())));\n+                        defaultParams.authKey(kp2.getPrivate())));\n@@ -236,2 +237,2 @@\n-                HPKEParameterSpec.of().authKey(kp2.getPrivate()),\n-                HPKEParameterSpec.of().authKey(kp2.getPublic()));\n+                defaultParams.authKey(kp2.getPrivate()),\n+                defaultParams.authKey(kp2.getPublic()));\n@@ -241,11 +242,2 @@\n-                HPKEParameterSpec.of(),\n-                HPKEParameterSpec.of(\n-                        HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256,\n-                        HPKEParameterSpec.KDF_HKDF_SHA256,\n-                        HPKEParameterSpec.AEAD_AES_256_GCM));\n-\n-        checkEncryptDecrypt(kp,\n-                HPKEParameterSpec.of(),\n-                HPKEParameterSpec.of(\n-                        HPKEParameterSpec.KDF_HKDF_SHA256,\n-                        HPKEParameterSpec.AEAD_AES_256_GCM));\n+                emptyParams,\n+                defaultParams);\n@@ -254,2 +246,2 @@\n-                HPKEParameterSpec.of(),\n-                HPKEParameterSpec.of().info(new byte[0]));\n+                defaultParams,\n+                defaultParams.info(new byte[0]));\n@@ -258,2 +250,2 @@\n-                HPKEParameterSpec.of(),\n-                HPKEParameterSpec.of().psk(null, new byte[0]));\n+                defaultParams,\n+                defaultParams.psk(null, new byte[0]));\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/Compliance.java","additions":63,"deletions":71,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import javax.crypto.spec.IvParameterSpec;\n@@ -65,1 +64,0 @@\n-            var enc = c.getIV();\n@@ -67,0 +65,1 @@\n+            var params = c.getParameters().getParameterSpec(HPKEParameterSpec.class);\n@@ -68,3 +67,1 @@\n-            c.init(Cipher.DECRYPT_MODE, kp.getPrivate(), new IvParameterSpec(enc));\n-            Asserts.assertEqualsByteArray(msg, c.doFinal(ct));\n-            c.init(Cipher.DECRYPT_MODE, kp.getPrivate(), HPKEParameterSpec.of().encapsulation(enc));\n+            c.init(Cipher.DECRYPT_MODE, kp.getPrivate(), params);\n@@ -78,0 +75,1 @@\n+            params = c.getParameters().getParameterSpec(HPKEParameterSpec.class);\n@@ -79,5 +77,2 @@\n-            c.init(Cipher.DECRYPT_MODE, kp.getPrivate(), HPKEParameterSpec.of()\n-                    .authKey(kp2.getPublic())\n-                    .info(info)\n-                    .psk(psk, psk_id)\n-                    .encapsulation(c.getIV()));\n+            c.init(Cipher.DECRYPT_MODE, kp.getPrivate(), params\n+                    .authKey(kp2.getPublic()));\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/Functions.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.test.lib.Asserts;\n@@ -33,1 +34,0 @@\n-import jdk.test.lib.artifacts.ArtifactResolverException;\n@@ -35,1 +35,0 @@\n-import jtreg.SkippedException;\n@@ -45,1 +44,0 @@\n-import java.util.Arrays;\n@@ -48,1 +46,1 @@\n-\/\/\/ This test is baed on Appendix A (Test Vectors) of\n+\/\/\/ This test is based on Appendix A (Test Vectors) of\n@@ -69,16 +67,0 @@\n-    private static Path fetchACVPServerTests(Class<?> clazz) {\n-        try {\n-            return ArtifactResolver.resolve(clazz).entrySet().stream()\n-                    .findAny().get().getValue();\n-        } catch (ArtifactResolverException e) {\n-            Throwable cause = e.getCause();\n-            if (cause == null) {\n-                throw new SkippedException(\"Cannot resolve artifact, \"\n-                        + \"please check if JIB jar is present in classpath.\", e);\n-            }\n-\n-            throw new SkippedException(\"Fetch artifact failed: \" + clazz, e);\n-        }\n-    }\n-\n-    static final HexFormat h = HexFormat.of();\n@@ -87,1 +69,2 @@\n-        Path archivePath = fetchACVPServerTests(RFC_9180_KAT.class);\n+        var h = HexFormat.of();\n+        Path archivePath = ArtifactResolver.fetchOne(RFC_9180_KAT.class);\n@@ -133,1 +116,1 @@\n-                    assertEQ(ct, ct1);\n+                    Asserts.assertEqualsByteArray(ct, ct1);\n@@ -136,1 +119,1 @@\n-                    assertEQ(pt, pt1);\n+                    Asserts.assertEqualsByteArray(pt, pt1);\n@@ -143,8 +126,0 @@\n-\n-    private static void assertEQ(byte[] s1, byte[] s2) {\n-        if (!Arrays.equals(s1, s2)) {\n-            System.out.println(h.formatHex(s1));\n-            System.out.println(h.formatHex(s2));\n-            throw new RuntimeException(\"not same\");\n-        }\n-    }\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/KAT9180.java","additions":6,"deletions":31,"binary":false,"changes":37,"status":"modified"}]}