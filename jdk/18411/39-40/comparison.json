{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Arrays;\n@@ -275,2 +276,1 @@\n-     * @param info application-supplied information. Must not be {@code null}.\n-     *      If set to empty, the previous info is cleared.\n+     * @param info application-supplied information.\n@@ -281,0 +281,1 @@\n+     * @throws IllegalArgumentException if {@code info} is empty.\n@@ -283,0 +284,4 @@\n+        Objects.requireNonNull(info);\n+        if (info.length == 0) {\n+            throw new IllegalArgumentException(\"info is empty\");\n+        }\n@@ -284,1 +289,1 @@\n-                Objects.requireNonNull(info).clone(), psk, psk_id, kS, encapsulation);\n+                info.clone(), psk, psk_id, kS, encapsulation);\n@@ -291,2 +296,3 @@\n-     * For interoperability, RFC 9180 Section 7.2.1 recommends limiting both\n-     * values to a maximum of 64 bytes.\n+     * RFC 9180 Section 5.1.2 requires the PSK MUST have at least 32 bytes\n+     * of entropy. For interoperability, RFC 9180 Section 7.2.1 recommends\n+     * limiting the key size and identifier length to a maximum of 64 bytes.\n@@ -294,3 +300,2 @@\n-     * @param psk pre-shared key. Set to {@code null} if no pre-shared key is used.\n-     * @param psk_id identifier for PSK. Set to empty if no pre-shared key is used.\n-     *               Must not be {@code null}. The contents of the array are copied\n+     * @param psk pre-shared key\n+     * @param psk_id identifier for PSK. The contents of the array are copied\n@@ -299,5 +304,3 @@\n-     * @throws NullPointerException if {@code psk_id} is {@code null}\n-     * @throws IllegalArgumentException if {@code psk} and {@code psk_id} are\n-     *      not consistent, i.e. {@code psk} is not {@code null} but\n-     *      {@code psk_id} is empty, or {@code psk} is {@code null} but\n-     *      {@code psk_id} is not empty.\n+     * @throws NullPointerException if {@code psk} or {@code psk_id} is {@code null}\n+     * @throws IllegalArgumentException if {@code psk} is shorter than 32 bytes\n+     *                                  or {@code psk_id} is empty\n@@ -306,0 +309,1 @@\n+        Objects.requireNonNull(psk);\n@@ -307,3 +311,12 @@\n-        if (psk == null && psk_id.length != 0\n-                || psk != null && psk_id.length == 0) {\n-            throw new IllegalArgumentException(\"psk and psk_id do not match\");\n+        if (psk_id.length == 0) {\n+            throw new IllegalArgumentException(\"psk_id is empty\");\n+        }\n+        if (\"RAW\".equalsIgnoreCase(psk.getFormat())) {\n+            \/\/ We can only check when psk is extractable. We can only\n+            \/\/ check the length and not the real entropy size\n+            var keyBytes = psk.getEncoded();\n+            assert keyBytes != null;\n+            Arrays.fill(keyBytes, (byte)0);\n+            if (keyBytes.length < 32) {\n+                throw new IllegalArgumentException(\"psk is too short\");\n+            }\n@@ -319,2 +332,1 @@\n-     * @param encapsulation the key encapsulation message. If set to\n-     *      {@code null}, the previous key encapsulation message is cleared.\n+     * @param encapsulation the key encapsulation message.\n@@ -325,0 +337,1 @@\n+     * @throws NullPointerException if {@code encapsulation} is {@code null}\n@@ -329,1 +342,1 @@\n-                encapsulation == null ? null : encapsulation.clone());\n+                Objects.requireNonNull(encapsulation).clone());\n@@ -341,2 +354,1 @@\n-     * @param kS the authentication key. If set to {@code null}, the previous\n-     *          authentication key is cleared.\n+     * @param kS the authentication key\n@@ -344,0 +356,1 @@\n+     * @throws NullPointerException if {@code kS} is {@code null}\n@@ -347,1 +360,3 @@\n-                info, psk, psk_id, kS, encapsulation);\n+                info, psk, psk_id,\n+                Objects.requireNonNull(kS),\n+                encapsulation);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/HPKEParameterSpec.java","additions":37,"deletions":22,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import javax.crypto.SecretKey;\n@@ -36,1 +37,0 @@\n-import static javax.crypto.spec.HPKEParameterSpec.EXPORT_ONLY;\n@@ -52,0 +52,1 @@\n+        var shortKey = new SecretKeySpec(new byte[31], \"ONE\");\n@@ -53,0 +54,5 @@\n+        var emptyKey = new SecretKey() {\n+            public String getAlgorithm() { return \"GENERIC\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return new byte[0]; }\n+        };\n@@ -81,1 +87,1 @@\n-        \/\/ identifiers must be in range\n+        \/\/ identifiers\n@@ -96,1 +102,1 @@\n-        Asserts.assertTrue(spec.withAuthKey(null).authKey() == null);\n+        \/\/ auth key\n@@ -99,1 +105,1 @@\n-        Asserts.assertTrue(spec.withAuthKey(kp.getPrivate()).withAuthKey(null).authKey() == null);\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.withAuthKey(null));\n@@ -101,0 +107,21 @@\n+        \/\/ info\n+        Asserts.assertEqualsByteArray(spec.withInfo(info).info(), info);\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.withInfo(null));\n+        Asserts.assertThrows(IllegalArgumentException.class, () -> spec.withInfo(new byte[0]));\n+\n+        \/\/ encapsulation\n+        Asserts.assertEqualsByteArray(spec.withEncapsulation(info).encapsulation(), info);\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.withEncapsulation(null));\n+        Asserts.assertTrue(spec.withEncapsulation(new byte[0]).encapsulation().length == 0); \/\/ not emptiness check (yet)\n+\n+        \/\/ psk_id and psk\n+        Asserts.assertEqualsByteArray(spec.withPsk(psk, psk_id).psk().getEncoded(), psk.getEncoded());\n+        Asserts.assertEqualsByteArray(spec.withPsk(psk, psk_id).psk_id(), psk_id);\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.withPsk(psk, null));\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.withPsk(null, psk_id));\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.withPsk(null, null));\n+        Asserts.assertThrows(IllegalArgumentException.class, () -> spec.withPsk(psk, new byte[0]));\n+        Asserts.assertThrows(IllegalArgumentException.class, () -> spec.withPsk(emptyKey, psk_id));\n+        Asserts.assertThrows(IllegalArgumentException.class, () -> spec.withPsk(shortKey, psk_id));\n+\n+        \/\/ toString\n@@ -117,21 +144,0 @@\n-        \/\/ Info can be empty but not null\n-        Asserts.assertThrows(NullPointerException.class, () -> spec.withInfo(null));\n-        Asserts.assertEqualsByteArray(spec.withInfo(info).info(), info);\n-\n-        Asserts.assertTrue(spec.withEncapsulation(null).encapsulation() == null);\n-        Asserts.assertEqualsByteArray(spec.withEncapsulation(info).encapsulation(), info);\n-        Asserts.assertTrue(spec.withEncapsulation(info).withEncapsulation(null).encapsulation() == null);\n-\n-        \/\/ psk_id can be empty but not null\n-        Asserts.assertThrows(NullPointerException.class, () -> spec.withPsk(psk, null));\n-\n-        \/\/ psk and psk_id must match\n-        Asserts.assertThrows(IllegalArgumentException.class, () -> spec.withPsk(psk, new byte[0]));\n-        Asserts.assertThrows(IllegalArgumentException.class, () -> spec.withPsk(null, psk_id));\n-\n-        Asserts.assertEqualsByteArray(spec.withPsk(psk, psk_id).psk().getEncoded(), psk.getEncoded());\n-        Asserts.assertEqualsByteArray(spec.withPsk(psk, psk_id).psk_id(), psk_id);\n-        Asserts.assertTrue(spec.withPsk(null, new byte[0]).psk() == null);\n-        Asserts.assertEqualsByteArray(spec.withPsk(null, new byte[0]).psk_id(), new byte[0]);\n-\n-        \/\/ HPKE\n@@ -139,1 +145,0 @@\n-        var c2 = Cipher.getInstance(\"HPKE\");\n@@ -155,6 +160,0 @@\n-        \/\/ Simplest usages\n-        c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), spec);\n-        var encap = c1.getIV();\n-        c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n-                spec.withEncapsulation(encap));\n-\n@@ -178,1 +177,1 @@\n-                () -> c2.init(Cipher.ENCRYPT_MODE, kp.getPublic()));\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic()));\n@@ -180,1 +179,1 @@\n-                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate()));\n+                () -> c1.init(Cipher.DECRYPT_MODE, kp.getPrivate()));\n@@ -184,2 +183,2 @@\n-                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPublic(),\n-                        spec.withEncapsulation(encap)));\n+                () -> c1.init(Cipher.DECRYPT_MODE, kp.getPublic(),\n+                        spec.withEncapsulation(new byte[32])));\n@@ -188,1 +187,1 @@\n-                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(), spec));\n+                () -> c1.init(Cipher.DECRYPT_MODE, kp.getPrivate(), spec));\n@@ -204,26 +203,2 @@\n-        \/\/ No key encap msg for recipient (export only)\n-        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n-                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n-                        HPKEParameterSpec.of(\n-                                KEM_DHKEM_X25519_HKDF_SHA256, KDF_HKDF_SHA256, EXPORT_ONLY)));\n-\n-        var aad = \"AAD\".getBytes(StandardCharsets.UTF_8);\n-\n-        \/\/ HPKE with encryption\n-        c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), spec);\n-        Asserts.assertEquals(16, c1.getBlockSize());\n-        Asserts.assertEquals(116, c1.getOutputSize(100));\n-        c1.updateAAD(aad);\n-        var ct = c1.doFinal(new byte[2]);\n-\n-        c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n-                spec.withEncapsulation(c1.getIV()));\n-        Asserts.assertEquals(16, c2.getBlockSize());\n-        Asserts.assertEquals(84, c2.getOutputSize(100));\n-        c2.updateAAD(aad);\n-        Asserts.assertEqualsByteArray(c2.doFinal(ct), new byte[2]);\n-\n-        \/\/ info and psk\n-        checkEncryptDecrypt(kp,\n-                spec.withInfo(info).withPsk(psk, psk_id),\n-                spec.withInfo(info).withPsk(psk, psk_id));\n+        \/\/ HPKE\n+        checkEncryptDecrypt(kp, spec, spec);\n@@ -231,0 +206,1 @@\n+        \/\/ extra features\n@@ -232,0 +208,12 @@\n+        checkEncryptDecrypt(kp,\n+                spec.withInfo(info),\n+                spec.withInfo(info));\n+        checkEncryptDecrypt(kp,\n+                spec.withPsk(psk, psk_id),\n+                spec.withPsk(psk, psk_id));\n+        checkEncryptDecrypt(kp,\n+                spec.withAuthKey(kp2.getPrivate()),\n+                spec.withAuthKey(kp2.getPublic()));\n+        checkEncryptDecrypt(kp,\n+                spec.withInfo(info).withPsk(psk, psk_id).withAuthKey(kp2.getPrivate()),\n+                spec.withInfo(info).withPsk(psk, psk_id).withAuthKey(kp2.getPublic()));\n@@ -238,1 +226,1 @@\n-                () -> c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                () -> c1.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n@@ -240,13 +228,0 @@\n-\n-        \/\/ mod_auth\n-        checkEncryptDecrypt(kp,\n-                spec.withAuthKey(kp2.getPrivate()),\n-                spec.withAuthKey(kp2.getPublic()));\n-\n-        checkEncryptDecrypt(kp,\n-                spec,\n-                spec.withInfo(new byte[0]));\n-\n-        checkEncryptDecrypt(kp,\n-                spec,\n-                spec.withPsk(null, new byte[0]));\n@@ -263,0 +238,2 @@\n+        Asserts.assertEquals(16, c1.getBlockSize());\n+        Asserts.assertEquals(116, c1.getOutputSize(100));\n@@ -268,0 +245,2 @@\n+        Asserts.assertEquals(16, c2.getBlockSize());\n+        Asserts.assertEquals(84, c2.getOutputSize(100));\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/Compliance.java","additions":56,"deletions":77,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        var psk = new SecretKeySpec(\"this is a key\".getBytes(StandardCharsets.UTF_8), \"Generic\");\n+        var psk = new SecretKeySpec(\"K\".repeat(32).getBytes(StandardCharsets.UTF_8), \"Generic\");\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/Functions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}