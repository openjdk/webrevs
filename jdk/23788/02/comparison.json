{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -300,1 +300,0 @@\n-        assert(current() == 'L');\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/parser\/SignatureParser.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350704\n+ * @summary Test behaviors with various bad EnclosingMethod attribute\n+ * @library \/test\/lib\n+ * @run junit BadEnclosingMethodTest\n+ *\/\n+\n+import jdk.test.lib.ByteCodeLoader;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.attribute.EnclosingMethodAttribute;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class BadEnclosingMethodTest {\n+\n+    private static Path classPath(String className) {\n+        return Path.of(System.getProperty(\"test.classes\"), className + \".class\");\n+    }\n+\n+    \/**\n+     * Loads a test class that is transformed from the Enclosed local class in\n+     * the Encloser::work method. This local class has its EnclosingMethod\n+     * attribute transformed to the specific name and type, which may be malformed\n+     * strings.\n+     *\n+     * @param name the new enclosing method name, may be malformed\n+     * @param type the new enclosing method type, may be malformed\n+     * @return the loaded test class, for reflective inspection\n+     *\/\n+    private Class<?> loadTestClass(String name, String type) throws Exception {\n+        var outerName = \"Encloser\";\n+        var className = outerName + \"$1Enclosed\";\n+\n+        var cf = ClassFile.of();\n+        var cm = cf.parse(classPath(className));\n+\n+        var bytes = cf.transformClass(cm, (cb, ce) -> {\n+            if (ce instanceof EnclosingMethodAttribute em) {\n+                var cp = cb.constantPool();\n+                var enclosingMethodName = cp.utf8Entry(name);\n+                var enclosingMethodType = cp.utf8Entry(type); \/\/ a malformed method type\n+                cb.with(EnclosingMethodAttribute.of(em.enclosingClass(), Optional.of(cp.nameAndTypeEntry(\n+                        enclosingMethodName, enclosingMethodType\n+                ))));\n+            } else {\n+                cb.with(ce);\n+            }\n+        });\n+\n+        var map = Map.of(\n+                outerName, Files.readAllBytes(classPath(outerName)),\n+                className, bytes\n+        );\n+\n+        return new ByteCodeLoader(map, BadEnclosingMethodTest.class.getClassLoader())\n+                .loadClass(className);\n+    }\n+\n+    \/**\n+     * Test reflection behaviors when the EnclosingMethod attribute's type is\n+     * an invalid string.\n+     *\/\n+    @Test\n+    void testMalformedTypes() throws Exception {\n+        assertThrows(ClassFormatError.class, () -> loadTestClass(\"methodName\", \"(L[;)V\"));\n+        assertThrows(ClassFormatError.class, () -> loadTestClass(INIT_NAME, \"(L[;)V\"));\n+    }\n+\n+    \/**\n+     * Test reflective behaviors when the EnclosingMethod attribute's type is\n+     * valid, but refers to a class or interface that cannot be found.\n+     *\/\n+    @Test\n+    void testAbsentMethods() throws Exception {\n+        var absentMethodType = loadTestClass(\"methodName\", \"(Ldoes\/not\/Exist;)V\");\n+        var ex = assertThrows(TypeNotPresentException.class,\n+                absentMethodType::getEnclosingMethod);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+\n+        var absentConstructorType = loadTestClass(INIT_NAME, \"(Ldoes\/not\/Exist;)V\");\n+        ex = assertThrows(TypeNotPresentException.class,\n+                absentConstructorType::getEnclosingConstructor);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+    }\n+}\n+\n+class Encloser {\n+    private static void work() {\n+        class Enclosed {\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Class\/getEnclosingMethod\/BadEnclosingMethodTest.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8345614 8350704\n+ * @summary Ensure behavior with duplicated annotations - class, method, or\n+ *          field fails fast on duplicate annotations, but parameter allows them\n+ * @library \/test\/lib\n+ * @run junit DuplicateAnnotationsTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.annotation.AnnotationFormatError;\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.AnnotatedElement;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.test.lib.ByteCodeLoader;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.function.Executable;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class DuplicateAnnotationsTest {\n+    static ClassModel cm;\n+\n+    @BeforeAll\n+    static void setup() throws IOException {\n+        Path annoDuplicatedClass = Path.of(System.getProperty(\"test.classes\")).resolve(\"AnnotationDuplicated.class\");\n+        cm = ClassFile.of().parse(annoDuplicatedClass);\n+    }\n+\n+    interface Extractor {\n+        AnnotatedElement find(Class<?> cl) throws ReflectiveOperationException;\n+    }\n+\n+    \/\/ Compiler hint\n+    static Extractor extract(Extractor e) {\n+        return e;\n+    }\n+\n+    static Arguments[] arguments() {\n+        Annotation annotationOne = Annotation.of(ClassDesc.of(\"java.lang.Deprecated\"), AnnotationElement.ofBoolean(\"forRemoval\", true));\n+        Annotation annotationTwo = Annotation.of(ClassDesc.of(\"java.lang.Deprecated\"), AnnotationElement.ofString(\"since\", \"24\"));\n+        RuntimeVisibleAnnotationsAttribute rvaa = RuntimeVisibleAnnotationsAttribute.of(\n+                List.of(annotationOne, annotationTwo)\n+        );\n+\n+        return new Arguments[]{\n+                Arguments.of(\n+                        \"class\", true,\n+                        ClassTransform.endHandler(cob -> cob.with(rvaa)),\n+                        extract(c -> c)\n+                ),\n+                Arguments.of(\n+                        \"field\", true,\n+                        ClassTransform.transformingFields(FieldTransform.endHandler(fb -> fb.with(rvaa))),\n+                        extract(c -> c.getDeclaredField(\"field\"))\n+                ),\n+                Arguments.of(\n+                        \"method\", true,\n+                        ClassTransform.transformingMethods(MethodTransform.endHandler(mb -> mb.with(rvaa))),\n+                        extract(c -> c.getDeclaredConstructor(int.class))\n+                ),\n+                Arguments.of(\n+                        \"parameter\", false, \/\/ Surprisingly, parameters always allowed duplicate annotations\n+                        ClassTransform.transformingMethods(MethodTransform.endHandler(mb -> mb.with(\n+                                RuntimeVisibleParameterAnnotationsAttribute.of(\n+                                        List.of(List.of(annotationOne, annotationTwo))\n+                                )\n+                        ))),\n+                        extract(c -> c.getDeclaredConstructor(int.class).getParameters()[0])\n+                ),\n+        };\n+    }\n+\n+    \/**\n+     * A test case represents a declaration that can be annotated.\n+     * Different declarations have different behaviors when multiple annotations\n+     * of the same interface are present (without a container annotation).\n+     *\n+     * @param caseName the type of declaration, for pretty printing in JUnit\n+     * @param fails whether this case should fail upon encountering duplicate annotations\n+     * @param ct transform to install duplicate annotations on the specific declaration\n+     * @param extractor function to access the AnnotatedElement representing that declaration\n+     *\/\n+    @MethodSource(\"arguments\")\n+    @ParameterizedTest\n+    void test(String caseName, boolean fails, ClassTransform ct, Extractor extractor) throws IOException, ReflectiveOperationException {\n+        var clazz = ByteCodeLoader.load(\"AnnotationDuplicated\", ClassFile.of().transformClass(cm, ct));\n+        var element = assertDoesNotThrow(() -> extractor.find(clazz));\n+        Executable exec = () -> element.getAnnotation(Deprecated.class);\n+        if (fails) {\n+            var ex = assertThrows(AnnotationFormatError.class, exec, \"no duplicate annotation access\");\n+            assertTrue(ex.getMessage().contains(\"Deprecated\"), () -> \"missing problematic annotation: \" + ex.getMessage());\n+            assertTrue(ex.getMessage().contains(\"AnnotationDuplicated\"), () -> \"missing container class: \" + ex.getMessage());\n+        } else {\n+            assertDoesNotThrow(exec, \"obtaining duplicate annotations should be fine\");\n+            assertEquals(2, Arrays.stream(element.getAnnotations())\n+                    .filter(anno -> anno instanceof Deprecated)\n+                    .count());\n+        }\n+    }\n+}\n+\n+\/\/ Duplicate annotations on class, field, method (constructor), method parameter\n+class AnnotationDuplicated {\n+    int field;\n+\n+    AnnotationDuplicated(int arg) {\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/annotation\/DuplicateAnnotationsTest.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350704\n+ * @summary Test behaviors with malformed annotations (in class files)\n+ * @library \/test\/lib\n+ * @run junit MalformedAnnotationTest\n+ *\/\n+\n+import jdk.test.lib.ByteCodeLoader;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.classfile.Annotation;\n+import java.lang.classfile.AnnotationElement;\n+import java.lang.classfile.AnnotationValue;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.GenericSignatureFormatError;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class MalformedAnnotationTest {\n+\n+    \/**\n+     * An annotation that has elements of the Class type.\n+     * Useful for checking behavior when the string is not a descriptor string.\n+     *\/\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface ClassCarrier {\n+        Class<?> value();\n+    }\n+\n+    \/**\n+     * Ensures bad class descriptors in annotations lead to\n+     * {@link GenericSignatureFormatError} and the error message contains the\n+     * malformed descriptor string.\n+     *\/\n+    @Test\n+    void testMalformedClassValue() throws Exception {\n+        var badDescString = \"Not a_descriptor\";\n+        var bytes = ClassFile.of().build(ClassDesc.of(\"Test\"), clb -> clb\n+                .with(RuntimeVisibleAnnotationsAttribute.of(\n+                        Annotation.of(ClassCarrier.class.describeConstable().orElseThrow(),\n+                                AnnotationElement.of(\"value\", AnnotationValue.ofClass(clb\n+                                        .constantPool().utf8Entry(badDescString))))\n+                )));\n+        var cl = new ByteCodeLoader(\"Test\", bytes, MalformedAnnotationTest.class.getClassLoader()).loadClass(\"Test\");\n+        var ex = assertThrows(GenericSignatureFormatError.class, () -> cl.getDeclaredAnnotation(ClassCarrier.class));\n+        assertTrue(ex.getMessage().contains(badDescString), () -> \"Uninformative error: \" + ex);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/annotation\/MalformedAnnotationTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6832374 7052898 8350704\n+ * @summary Test behaviors with malformed signature strings in Signature attribute.\n+ * @library \/test\/lib\n+ * @run junit MalformedSignatureTest\n+ *\/\n+\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.RecordAttribute;\n+import java.lang.classfile.attribute.RecordComponentInfo;\n+import java.lang.classfile.attribute.SignatureAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.GenericSignatureFormatError;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.ByteCodeLoader;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.lang.constant.ConstantDescs.MTD_void;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class MalformedSignatureTest {\n+\n+    private static final String BASIC_BAD_SIGNATURE_TEXT = \"i_aM_NoT_A_Signature\";\n+    static Class<?> sampleClass, sampleRecord;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        var compiledDir = Path.of(System.getProperty(\"test.classes\"));\n+        var cf = ClassFile.of();\n+\n+        \/\/ Transform that installs malformed signature strings to classes,\n+        \/\/ fields, methods, and record components.\n+        var badSignatureTransform = new ClassTransform() {\n+            private SignatureAttribute badSignature;\n+\n+            @Override\n+            public void atStart(ClassBuilder builder) {\n+                badSignature = SignatureAttribute.of(builder.constantPool().utf8Entry(BASIC_BAD_SIGNATURE_TEXT));\n+            }\n+\n+            @Override\n+            public void accept(ClassBuilder builder, ClassElement element) {\n+                switch (element) {\n+                    case SignatureAttribute _ -> {} \/\/ dropping\n+                    case FieldModel f -> builder\n+                            .transformField(f, FieldTransform.dropping(SignatureAttribute.class::isInstance)\n+                                    .andThen(FieldTransform.endHandler(fb -> fb.with(badSignature))));\n+                    case MethodModel m -> builder\n+                            .transformMethod(m, MethodTransform.dropping(SignatureAttribute.class::isInstance)\n+                                    .andThen(MethodTransform.endHandler(fb -> fb.with(badSignature))));\n+                    case RecordAttribute rec -> builder.with(RecordAttribute.of(rec.components().stream().map(comp ->\n+                                    RecordComponentInfo.of(comp.name(), comp.descriptor(), Stream.concat(\n+                                                    Stream.of(badSignature), comp.attributes().stream()\n+                                                            .filter(Predicate.not(SignatureAttribute.class::isInstance)))\n+                                            .toList()))\n+                            .toList()));\n+                    default -> builder.with(element);\n+                }\n+            }\n+\n+            @Override\n+            public void atEnd(ClassBuilder builder) {\n+                builder.with(badSignature);\n+            }\n+        };\n+\n+        var plainBytes = cf.transformClass(cf.parse(compiledDir.resolve(\"SampleClass.class\")), badSignatureTransform);\n+        sampleClass = ByteCodeLoader.load(\"SampleClass\", plainBytes);\n+        var recordBytes = cf.transformClass(cf.parse(compiledDir.resolve(\"SampleRecord.class\")), badSignatureTransform);\n+        sampleRecord = ByteCodeLoader.load(\"SampleRecord\", recordBytes);\n+    }\n+\n+    \/**\n+     * Ensures the reflective generic inspection of a malformed Class throws\n+     * GenericSignatureFormatError while the non-generic inspection is fine.\n+     *\/\n+    @Test\n+    void testBasicClass() {\n+        assertEquals(ArrayList.class, sampleClass.getSuperclass());\n+        assertArrayEquals(new Class<?>[] {Predicate.class}, sampleClass.getInterfaces());\n+        var ex = assertThrows(GenericSignatureFormatError.class, sampleClass::getGenericSuperclass);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+        ex = assertThrows(GenericSignatureFormatError.class, sampleClass::getGenericInterfaces);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+    }\n+\n+    \/**\n+     * Ensures the reflective generic inspection of a malformed Field throws\n+     * GenericSignatureFormatError while the non-generic inspection is fine.\n+     *\/\n+    @Test\n+    void testBasicField() throws ReflectiveOperationException {\n+        var field = sampleClass.getDeclaredField(\"field\");\n+        assertEquals(Optional.class, field.getType());\n+        var ex = assertThrows(GenericSignatureFormatError.class, field::getGenericType);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+    }\n+\n+    \/**\n+     * Ensures the reflective generic inspection of a malformed Constructor throws\n+     * GenericSignatureFormatError while the non-generic inspection is fine.\n+     *\/\n+    @Test\n+    void testBasicConstructor() throws ReflectiveOperationException {\n+        var constructor = sampleClass.getDeclaredConstructors()[0];\n+        assertArrayEquals(new Class<?>[] {Optional.class}, constructor.getParameterTypes());\n+        assertArrayEquals(new Class<?>[] {RuntimeException.class}, constructor.getExceptionTypes());\n+        var ex = assertThrows(GenericSignatureFormatError.class, constructor::getGenericParameterTypes);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+        ex = assertThrows(GenericSignatureFormatError.class, constructor::getGenericExceptionTypes);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+    }\n+\n+    \/**\n+     * Ensures the reflective generic inspection of a malformed Method throws\n+     * GenericSignatureFormatError while the non-generic inspection is fine.\n+     *\/\n+    @Test\n+    void testBasicMethod() throws ReflectiveOperationException {\n+        var method = sampleClass.getDeclaredMethods()[0];\n+        assertEquals(Optional.class, method.getReturnType());\n+        assertArrayEquals(new Class<?>[] {Optional.class}, method.getParameterTypes());\n+        assertArrayEquals(new Class<?>[] {RuntimeException.class}, method.getExceptionTypes());\n+        var ex = assertThrows(GenericSignatureFormatError.class, method::getGenericReturnType);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+        ex = assertThrows(GenericSignatureFormatError.class, method::getGenericParameterTypes);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+        ex = assertThrows(GenericSignatureFormatError.class, method::getGenericExceptionTypes);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+    }\n+\n+    \/**\n+     * Ensures the reflective generic inspection of a malformed RecordComponent throws\n+     * GenericSignatureFormatError while the non-generic inspection is fine.\n+     *\/\n+    @Test\n+    void testBasicRecordComponent() {\n+        var rcs = sampleRecord.getRecordComponents();\n+        assertNotNull(rcs);\n+        assertEquals(1, rcs.length);\n+        var rc = rcs[0];\n+        assertNotNull(rc);\n+\n+        assertEquals(Optional.class, rc.getType());\n+        assertEquals(BASIC_BAD_SIGNATURE_TEXT, rc.getGenericSignature());\n+        var ex = assertThrows(GenericSignatureFormatError.class, rc::getGenericType);\n+        assertTrue(ex.getMessage().contains(BASIC_BAD_SIGNATURE_TEXT));\n+    }\n+\n+    static String[] badMethodSignatures() {\n+        return new String[] {\n+                \/\/ Missing \":\" after first type bound\n+                \"<T:Lfoo\/tools\/nsc\/symtab\/Names;Lfoo\/tools\/nsc\/symtab\/Symbols;\",\n+\n+                \/\/ Arrays improperly indicated for exception information\n+                \"<E:Ljava\/lang\/Exception;>(TE;[Ljava\/lang\/RuntimeException;)V^[TE;\",\n+        };\n+    }\n+\n+    \/**\n+     * Ensures that particular strings are invalid as method signature strings.\n+     *\/\n+    @MethodSource(\"badMethodSignatures\")\n+    @ParameterizedTest\n+    void testSignatureForMethod(String badSig) throws Throwable {\n+        var className = \"BadSignature\";\n+        var bytes = ClassFile.of().build(ClassDesc.of(className), clb ->\n+                clb.withMethod(\"test\", MTD_void, 0, mb -> mb\n+                        .withCode(CodeBuilder::return_)\n+                        .with(SignatureAttribute.of(clb.constantPool().utf8Entry(badSig)))));\n+\n+        var cl = ByteCodeLoader.load(className, bytes);\n+        var method = cl.getDeclaredMethod(\"test\");\n+        var ex = assertThrows(GenericSignatureFormatError.class, method::getGenericParameterTypes);\n+        \/\/assertTrue(ex.getMessage().contains(badSig), \"Missing bad signature in error message\");\n+    }\n+}\n+\n+\/\/ Sample classes shared with TypeNotPresentInSignatureTest\n+abstract class SampleClass extends ArrayList<RuntimeException> implements Predicate<RuntimeException> { \/\/ class\n+    Optional<RuntimeException> field; \/\/ field\n+\n+    <T extends RuntimeException> SampleClass(Optional<RuntimeException> param) throws T {\n+    } \/\/ constructor\n+\n+    <T extends RuntimeException> Optional<RuntimeException> method(Optional<RuntimeException> param) throws T {\n+        return null;\n+    } \/\/ method\n+}\n+\n+record SampleRecord(Optional<RuntimeException> component) {\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/MalformedSignatureTest.java","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 6832374 7052898\n- * @summary Test bad signatures get a GenericSignatureFormatError thrown.\n- * @author Joseph D. Darcy\n- * @modules java.base\/sun.reflect.generics.parser\n- *\/\n-\n-import java.lang.reflect.*;\n-import sun.reflect.generics.parser.SignatureParser;\n-\n-public class TestBadSignatures {\n-    public static void main(String[] args) {\n-        String[] badSignatures = {\n-            \/\/ Missing \":\" after first type bound\n-            \"<T:Lfoo\/tools\/nsc\/symtab\/Names;Lfoo\/tools\/nsc\/symtab\/Symbols;\",\n-\n-            \/\/ Arrays improperly indicated for exception information\n-            \"<E:Ljava\/lang\/Exception;>(TE;[Ljava\/lang\/RuntimeException;)V^[TE;\",\n-        };\n-\n-        for(String badSig : badSignatures) {\n-            try {\n-                SignatureParser.make().parseMethodSig(badSig);\n-                throw new RuntimeException(\"Expected GenericSignatureFormatError for \" +\n-                                           badSig);\n-            } catch(GenericSignatureFormatError gsfe) {\n-                System.out.println(gsfe.toString()); \/\/ Expected\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/TestBadSignatures.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350704\n+ * @summary Test behaviors with Signature attribute with any absent\n+ *          class or interface (the string is of valid format)\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.classfile.components\n+ * @compile MalformedSignatureTest.java\n+ * @comment reuses Sample classes from MalformedSignatureTest\n+ * @run junit TypeNotPresentInSignatureTest\n+ *\/\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.attribute.ExceptionsAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.TypeVariable;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import jdk.internal.classfile.components.ClassRemapper;\n+import jdk.test.lib.ByteCodeLoader;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class TypeNotPresentInSignatureTest {\n+\n+    static Class<?> sampleClass, sampleRecord;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        var compiledDir = Path.of(System.getProperty(\"test.classes\"));\n+        var cf = ClassFile.of();\n+\n+        \/\/ Transforms all references to RuntimeException to an absent class or\n+        \/\/ interface does.not.Exist. The signature string format is still valid.\n+        var reDesc = ClassDesc.of(\"java.lang.RuntimeException\");\n+        var fix = ClassRemapper.of(Map.of(reDesc, ClassDesc.of(\"does.not.Exist\")));\n+        var f2 = ClassTransform.transformingMethods((mb, me) -> {\n+            if (me instanceof ExceptionsAttribute) {\n+                mb.with(ExceptionsAttribute.ofSymbols(reDesc));\n+            } else {\n+                mb.with(me);\n+            }\n+        });\n+\n+        var plainBytes = cf.transformClass(cf.parse(compiledDir.resolve(\"SampleClass.class\")), fix);\n+        plainBytes = cf.transformClass(cf.parse(plainBytes), f2);\n+        sampleClass = ByteCodeLoader.load(\"SampleClass\", plainBytes);\n+        var recordBytes = cf.transformClass(cf.parse(compiledDir.resolve(\"SampleRecord.class\")), fix);\n+        recordBytes = cf.transformClass(cf.parse(recordBytes), f2);\n+        sampleRecord = ByteCodeLoader.load(\"SampleRecord\", recordBytes);\n+    }\n+\n+    \/**\n+     * Ensures the reflective generic inspection of a Class with missing class\n+     * or interface throws TypeNotPresentException while the non-generic\n+     * inspection is fine.\n+     *\/\n+    @Test\n+    void testClass() {\n+        assertEquals(ArrayList.class, sampleClass.getSuperclass());\n+        assertArrayEquals(new Class<?>[] {Predicate.class}, sampleClass.getInterfaces());\n+        var ex = assertThrows(TypeNotPresentException.class, sampleClass::getGenericSuperclass);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+        ex = assertThrows(TypeNotPresentException.class, sampleClass::getGenericInterfaces);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+    }\n+\n+    \/**\n+     * Ensures the reflective generic inspection of a Field with missing class\n+     * or interface throws TypeNotPresentException while the non-generic\n+     * inspection is fine.\n+     *\/\n+    @Test\n+    void testField() throws ReflectiveOperationException {\n+        var field = sampleClass.getDeclaredField(\"field\");\n+        assertEquals(Optional.class, field.getType());\n+        var ex = assertThrows(TypeNotPresentException.class, field::getGenericType);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+    }\n+\n+    \/**\n+     * Ensures the reflective generic inspection of a Constructor with missing class\n+     * or interface throws TypeNotPresentException while the non-generic\n+     * inspection is fine.\n+     *\/\n+    @Test\n+    void testConstructor() throws ReflectiveOperationException {\n+        var constructor = sampleClass.getDeclaredConstructor(Optional.class);\n+        assertArrayEquals(new Class<?>[] {Optional.class}, constructor.getParameterTypes());\n+        assertArrayEquals(new Class<?>[] {RuntimeException.class}, constructor.getExceptionTypes());\n+        var ex = assertThrows(TypeNotPresentException.class, constructor::getGenericParameterTypes);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+        var typeVar = (TypeVariable<?>) constructor.getGenericExceptionTypes()[0];\n+        ex = assertThrows(TypeNotPresentException.class, typeVar::getBounds);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+    }\n+\n+    \/**\n+     * Ensures the reflective generic inspection of a Method with missing class\n+     * or interface throws TypeNotPresentException while the non-generic\n+     * inspection is fine.\n+     *\/\n+    @Test\n+    void testMethod() throws ReflectiveOperationException {\n+        var method = sampleClass.getDeclaredMethod(\"method\", Optional.class);\n+        assertEquals(Optional.class, method.getReturnType());\n+        assertArrayEquals(new Class<?>[] {Optional.class}, method.getParameterTypes());\n+        assertArrayEquals(new Class<?>[] {RuntimeException.class}, method.getExceptionTypes());\n+        var ex = assertThrows(TypeNotPresentException.class, method::getGenericReturnType);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+        ex = assertThrows(TypeNotPresentException.class, method::getGenericParameterTypes);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+        var typeVar = (TypeVariable<?>) method.getGenericExceptionTypes()[0];\n+        ex = assertThrows(TypeNotPresentException.class, typeVar::getBounds);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+    }\n+\n+    \/**\n+     * Ensures the reflective generic inspection of a RecordComponent with missing class\n+     * or interface throws TypeNotPresentException while the non-generic\n+     * inspection is fine.\n+     *\/\n+    @Test\n+    void testRecordComponent() {\n+        var rcs = sampleRecord.getRecordComponents();\n+        assertNotNull(rcs);\n+        assertEquals(1, rcs.length);\n+        var rc = rcs[0];\n+        assertNotNull(rc);\n+\n+        assertEquals(Optional.class, rc.getType());\n+        assertEquals(\"Ljava\/util\/Optional<Ldoes\/not\/Exist;>;\", rc.getGenericSignature());\n+        var ex = assertThrows(TypeNotPresentException.class, rc::getGenericType);\n+        assertEquals(\"does.not.Exist\", ex.typeName());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/TypeNotPresentInSignatureTest.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"}]}