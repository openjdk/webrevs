{"files":[{"patch":"@@ -129,1 +129,0 @@\n-  log_trace(gc)(\"MarkStackSize: %uk  MarkStackSizeMax: %uk\", (uint)(MarkStackSize \/ K), (uint)(MarkStackSizeMax \/ K));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -97,3 +98,1 @@\n-  _max_chunk_capacity(0),\n-  _base(nullptr),\n-  _chunk_capacity(0) {\n+  _chunk_allocator() {\n@@ -103,4 +102,3 @@\n-bool G1CMMarkStack::resize(size_t new_capacity) {\n-  assert(is_empty(), \"Only resize when stack is empty.\");\n-  assert(new_capacity <= _max_chunk_capacity,\n-         \"Trying to resize stack to \" SIZE_FORMAT \" chunks when the maximum is \" SIZE_FORMAT, new_capacity, _max_chunk_capacity);\n+size_t G1CMMarkStack::capacity_alignment() {\n+  return (size_t)lcm(os::vm_allocation_granularity(), sizeof(TaskQueueEntryChunk)) \/ sizeof(G1TaskQueueEntry);\n+}\n@@ -108,1 +106,2 @@\n-  TaskQueueEntryChunk* new_base = MmapArrayAllocator<TaskQueueEntryChunk>::allocate_or_null(new_capacity, mtGC);\n+bool G1CMMarkStack::initialize() {\n+  guarantee(_chunk_allocator.capacity() == 0, \"G1CMMarkStack already initialized.\");\n@@ -110,3 +109,25 @@\n-  if (new_base == nullptr) {\n-    log_warning(gc)(\"Failed to reserve memory for new overflow mark stack with \" SIZE_FORMAT \" chunks and size \" SIZE_FORMAT \"B.\", new_capacity, new_capacity * sizeof(TaskQueueEntryChunk));\n-    return false;\n+  size_t initial_capacity = MarkStackSize;\n+  size_t max_capacity = MarkStackSizeMax;\n+\n+  size_t const TaskEntryChunkSizeInVoidStar = sizeof(TaskQueueEntryChunk) \/ sizeof(G1TaskQueueEntry);\n+\n+  max_capacity = align_up(max_capacity, capacity_alignment()) \/ TaskEntryChunkSizeInVoidStar;\n+  size_t initial_chunk_capacity = align_up(initial_capacity, capacity_alignment()) \/ TaskEntryChunkSizeInVoidStar;\n+\n+  initial_chunk_capacity = round_up_power_of_2(initial_chunk_capacity);\n+  max_capacity = MAX2(initial_chunk_capacity, max_capacity);\n+\n+  FLAG_SET_ERGO(MarkStackSizeMax, (max_capacity * TaskEntryChunkSizeInVoidStar));\n+  FLAG_SET_ERGO(MarkStackSize, (initial_chunk_capacity * TaskEntryChunkSizeInVoidStar));\n+\n+  log_trace(gc)(\"MarkStackSize: %uk  MarkStackSizeMax: %uk\", (uint)(MarkStackSize \/ K), (uint)(MarkStackSizeMax \/ K));\n+\n+  log_debug(gc)(\"Initialize mark stack with \" SIZE_FORMAT \" chunks, maximum \" SIZE_FORMAT,\n+                initial_chunk_capacity, max_capacity);\n+\n+  return _chunk_allocator.initialize(initial_chunk_capacity, max_capacity);\n+}\n+\n+G1CMMarkStack::TaskQueueEntryChunk* G1CMMarkStack::ChunkAllocator::allocate_new_chunk() {\n+  if (_size >= _max_capacity) {\n+    return nullptr;\n@@ -114,3 +135,5 @@\n-  \/\/ Release old mapping.\n-  if (_base != nullptr) {\n-    MmapArrayAllocator<TaskQueueEntryChunk>::free(_base, _chunk_capacity);\n+\n+  size_t cur_idx = Atomic::fetch_then_add(&_size, 1u);\n+\n+  if (cur_idx >= _max_capacity) {\n+    return nullptr;\n@@ -119,3 +142,1 @@\n-  _base = new_base;\n-  _chunk_capacity = new_capacity;\n-  set_empty();\n+  size_t bucket = get_bucket(cur_idx);\n@@ -123,2 +144,5 @@\n-  return true;\n-}\n+  if (Atomic::load_acquire(&_buckets[bucket]) == nullptr) {\n+    if (!_growable) {\n+      \/\/ Prefer to restart the CM.\n+      return nullptr;\n+    }\n@@ -126,2 +150,13 @@\n-size_t G1CMMarkStack::capacity_alignment() {\n-  return (size_t)lcm(os::vm_allocation_granularity(), sizeof(TaskQueueEntryChunk)) \/ sizeof(G1TaskQueueEntry);\n+    MutexLocker x(MarkStackChunkList_lock, Mutex::_no_safepoint_check_flag);\n+    if (Atomic::load_acquire(&_buckets[bucket]) == nullptr) {\n+      size_t new_capacity = bucket_size(bucket) * 2;\n+      if (!reserve(new_capacity)) {\n+        return nullptr;\n+      }\n+    }\n+  }\n+\n+  size_t bucket_idx = get_bucket_index(cur_idx);\n+  TaskQueueEntryChunk* result = ::new (&_buckets[bucket][bucket_idx]) TaskQueueEntryChunk;\n+  result->next = nullptr;\n+  return result;\n@@ -130,2 +165,9 @@\n-bool G1CMMarkStack::initialize(size_t initial_capacity, size_t max_capacity) {\n-  guarantee(_max_chunk_capacity == 0, \"G1CMMarkStack already initialized.\");\n+G1CMMarkStack::ChunkAllocator::ChunkAllocator() :\n+  _min_capacity(0),\n+  _max_capacity(0),\n+  _capacity(0),\n+  _num_buckets(0),\n+  _growable(false),\n+  _buckets(nullptr),\n+  _size(0)\n+{ }\n@@ -133,1 +175,2 @@\n-  size_t const TaskEntryChunkSizeInVoidStar = sizeof(TaskQueueEntryChunk) \/ sizeof(G1TaskQueueEntry);\n+bool G1CMMarkStack::ChunkAllocator::initialize(size_t initial_capacity, size_t max_capacity) {\n+  guarantee(is_power_of_2(initial_capacity), \"Invalid initial_capacity\");\n@@ -135,2 +178,3 @@\n-  _max_chunk_capacity = align_up(max_capacity, capacity_alignment()) \/ TaskEntryChunkSizeInVoidStar;\n-  size_t initial_chunk_capacity = align_up(initial_capacity, capacity_alignment()) \/ TaskEntryChunkSizeInVoidStar;\n+  _min_capacity = initial_capacity;\n+  _max_capacity = max_capacity;\n+  _num_buckets  = get_bucket(_max_capacity);\n@@ -138,4 +182,1 @@\n-  guarantee(initial_chunk_capacity <= _max_chunk_capacity,\n-            \"Maximum chunk capacity \" SIZE_FORMAT \" smaller than initial capacity \" SIZE_FORMAT,\n-            _max_chunk_capacity,\n-            initial_chunk_capacity);\n+  _buckets = NEW_C_HEAP_ARRAY(TaskQueueEntryChunk*, _num_buckets, mtGC);\n@@ -143,2 +184,3 @@\n-  log_debug(gc)(\"Initialize mark stack with \" SIZE_FORMAT \" chunks, maximum \" SIZE_FORMAT,\n-                initial_chunk_capacity, _max_chunk_capacity);\n+  for (size_t i = 0; i < _num_buckets; i++) {\n+    _buckets[i] = nullptr;\n+  }\n@@ -146,2 +188,1 @@\n-  return resize(initial_chunk_capacity);\n-}\n+  size_t new_capacity = bucket_size(0);\n@@ -149,4 +190,3 @@\n-void G1CMMarkStack::expand() {\n-  if (_chunk_capacity == _max_chunk_capacity) {\n-    log_debug(gc)(\"Can not expand overflow mark stack further, already at maximum capacity of \" SIZE_FORMAT \" chunks.\", _chunk_capacity);\n-    return;\n+  if (!reserve(new_capacity)) {\n+    log_warning(gc)(\"Failed to reserve memory for new overflow mark stack with \" SIZE_FORMAT \" chunks and size \" SIZE_FORMAT \"B.\", new_capacity, new_capacity * sizeof(TaskQueueEntryChunk));\n+    return false;\n@@ -154,1 +194,5 @@\n-  size_t old_capacity = _chunk_capacity;\n+  return true;\n+}\n+\n+void G1CMMarkStack::ChunkAllocator::expand() {\n+  size_t old_capacity = _capacity;\n@@ -156,1 +200,1 @@\n-  size_t new_capacity = MIN2(old_capacity * 2, _max_chunk_capacity);\n+  size_t new_capacity = MIN2(old_capacity * 2, _max_capacity);\n@@ -158,2 +202,2 @@\n-  if (resize(new_capacity)) {\n-    log_debug(gc)(\"Expanded mark stack capacity from \" SIZE_FORMAT \" to \" SIZE_FORMAT \" chunks\",\n+  if (reserve(new_capacity)) {\n+    log_debug(gc)(\"Expanded the mark stack capacity from \" SIZE_FORMAT \" to \" SIZE_FORMAT \" chunks\",\n@@ -161,3 +205,0 @@\n-  } else {\n-    log_warning(gc)(\"Failed to expand mark stack capacity from \" SIZE_FORMAT \" to \" SIZE_FORMAT \" chunks\",\n-                    old_capacity, new_capacity);\n@@ -165,0 +206,3 @@\n+  \/\/ We reset without regard for the outcome of the expansion attempt.\n+  \/\/ Expand is called in preparation for restart.\n+  reset();\n@@ -167,3 +211,38 @@\n-G1CMMarkStack::~G1CMMarkStack() {\n-  if (_base != nullptr) {\n-    MmapArrayAllocator<TaskQueueEntryChunk>::free(_base, _chunk_capacity);\n+G1CMMarkStack::ChunkAllocator::~ChunkAllocator() {\n+  if (_buckets == nullptr) {\n+    return;\n+  }\n+\n+  for (size_t i = 0; i < _num_buckets; i++) {\n+    if (_buckets[i] != nullptr) {\n+      MmapArrayAllocator<TaskQueueEntryChunk>::free(_buckets[i],  bucket_size(i));\n+      _buckets[i] = nullptr;\n+    }\n+  }\n+\n+  FREE_C_HEAP_ARRAY(TaskQueueEntryChunk*, _buckets);\n+}\n+\n+bool G1CMMarkStack::ChunkAllocator::reserve(size_t new_capacity) {\n+  if (new_capacity > _max_capacity) {\n+    log_debug(gc)(\"Cannot expand overflow mark stack beyond the max_capacity\" SIZE_FORMAT \" chunks.\", _max_capacity);\n+    return false;\n+  }\n+\n+  size_t highest_bucket = get_bucket(new_capacity);\n+  size_t i = get_bucket(_capacity);\n+  for (; i <= highest_bucket; i++) {\n+    if (Atomic::load_acquire(&_buckets[i]) != nullptr) {\n+      continue; \/\/ Skip over already allocated buckets.\n+    }\n+\n+    size_t bucket_capacity = bucket_size(i);\n+    TaskQueueEntryChunk* bucket_base = MmapArrayAllocator<TaskQueueEntryChunk>::allocate_or_null(bucket_capacity, mtGC);\n+\n+    if (bucket_base == nullptr) {\n+      log_warning(gc)(\"Failed to reserve memory for increasing the overflow mark stack capacity with \" SIZE_FORMAT \" chunks and size \" SIZE_FORMAT \"B.\",\n+                      bucket_capacity, bucket_capacity * sizeof(TaskQueueEntryChunk));\n+      return false;\n+    }\n+    _capacity += bucket_capacity;\n+    Atomic::release_store(&_buckets[i], bucket_base);\n@@ -171,0 +250,5 @@\n+  return true;\n+}\n+\n+void G1CMMarkStack::expand() {\n+  _chunk_allocator.expand();\n@@ -211,18 +295,0 @@\n-G1CMMarkStack::TaskQueueEntryChunk* G1CMMarkStack::allocate_new_chunk() {\n-  \/\/ This dirty read of _hwm is okay because we only ever increase the _hwm in parallel code.\n-  \/\/ Further this limits _hwm to a value of _chunk_capacity + #threads, avoiding\n-  \/\/ wraparound of _hwm.\n-  if (_hwm >= _chunk_capacity) {\n-    return nullptr;\n-  }\n-\n-  size_t cur_idx = Atomic::fetch_then_add(&_hwm, 1u);\n-  if (cur_idx >= _chunk_capacity) {\n-    return nullptr;\n-  }\n-\n-  TaskQueueEntryChunk* result = ::new (&_base[cur_idx]) TaskQueueEntryChunk;\n-  result->next = nullptr;\n-  return result;\n-}\n-\n@@ -235,1 +301,1 @@\n-    new_chunk = allocate_new_chunk();\n+    new_chunk = _chunk_allocator.allocate_new_chunk();\n@@ -264,1 +330,0 @@\n-  _hwm = 0;\n@@ -267,0 +332,1 @@\n+  _chunk_allocator.reset();\n@@ -443,1 +509,1 @@\n-  if (!_global_mark_stack.initialize(MarkStackSize, MarkStackSizeMax)) {\n+  if (!_global_mark_stack.initialize()) {\n@@ -1638,0 +1704,3 @@\n+    \/\/ Prefer to grow the stack until the max capacity.\n+    _global_mark_stack.grow_incrementally();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":138,"deletions":69,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -139,1 +139,61 @@\n-  size_t _max_chunk_capacity;    \/\/ Maximum number of TaskQueueEntryChunk elements on the stack.\n+  class ChunkAllocator {\n+    size_t _min_capacity;\n+    size_t _max_capacity;\n+    size_t _capacity;\n+    size_t _num_buckets;\n+    bool _growable;\n+    TaskQueueEntryChunk* volatile* _buckets;\n+    char _pad0[DEFAULT_CACHE_LINE_SIZE];\n+    volatile size_t _size;\n+    char _pad4[DEFAULT_CACHE_LINE_SIZE - sizeof(size_t)];\n+\n+    size_t bucket_size(size_t bucket) {\n+      return (bucket == 0) ?\n+              _min_capacity :\n+              _min_capacity * ( 1ULL << (bucket -1));\n+    }\n+\n+    \/\/ Find highest 1, undefined if empty\/0\n+    static unsigned int find_highest_bit(uintptr_t mask) {\n+      return count_leading_zeros(mask) ^ (BitsPerWord - 1U);\n+    }\n+\n+    size_t get_bucket(size_t array_idx) {\n+      if (array_idx < _min_capacity) {\n+        return 0;\n+      }\n+\n+      return find_highest_bit(array_idx) - find_highest_bit(_min_capacity) + 1;\n+    }\n+\n+    size_t get_bucket_index(size_t array_idx) {\n+      if (array_idx < _min_capacity) {\n+        return array_idx;\n+      }\n+      return array_idx - (1ULL << find_highest_bit(array_idx));\n+    }\n+\n+    bool reserve(size_t new_capacity);\n+\n+  public:\n+    ChunkAllocator();\n+\n+    ~ChunkAllocator();\n+\n+    bool initialize(size_t initial_capacity, size_t max_capacity);\n+\n+    void reset() {\n+      _size = 0;\n+      _growable = false;\n+    }\n+\n+    void grow_incrementally() {\n+      _growable = true;\n+    }\n+\n+    size_t capacity() const { return _capacity; }\n+\n+    void expand();\n+\n+    TaskQueueEntryChunk* allocate_new_chunk();\n+  };\n@@ -141,2 +201,1 @@\n-  TaskQueueEntryChunk* _base;    \/\/ Bottom address of allocated memory area.\n-  size_t _chunk_capacity;        \/\/ Current maximum number of TaskQueueEntryChunk elements.\n+  ChunkAllocator _chunk_allocator;\n@@ -151,3 +210,0 @@\n-  volatile size_t _hwm;          \/\/ High water mark within the reserved space.\n-  char _pad4[DEFAULT_CACHE_LINE_SIZE - sizeof(size_t)];\n-\n@@ -170,4 +226,0 @@\n-  \/\/ Resizes the mark stack to the given new capacity. Releases any previous\n-  \/\/ memory if successful.\n-  bool resize(size_t new_capacity);\n-\n@@ -176,1 +228,1 @@\n-  ~G1CMMarkStack();\n+  ~G1CMMarkStack() = default;\n@@ -181,2 +233,2 @@\n-  \/\/ Allocate and initialize the mark stack with the given number of oops.\n-  bool initialize(size_t initial_capacity, size_t max_capacity);\n+  \/\/ Allocate and initialize the mark stack.\n+  bool initialize();\n@@ -200,1 +252,5 @@\n-  size_t capacity() const  { return _chunk_capacity; }\n+  size_t capacity() const  { return _chunk_allocator.capacity(); }\n+\n+  void grow_incrementally() {\n+    _chunk_allocator.grow_incrementally();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":70,"deletions":14,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+import java.util.LinkedHashMap;\n+\n+\/* @test\n+ * @bug 8313212\n+ * @summary Finalizing objects may create new concurrent marking work during reference processing.\n+ * If the marking work overflows the global mark stack, we should resize the global mark stack\n+ * until MarkStackSizeMax if possible.\n+ * @requires vm.gc.G1\n+ * @run main\/othervm -XX:ActiveProcessorCount=2 -XX:MarkStackSize=1 -Xmx250m gc.g1.TestMarkStackOverflow\n+ *\/\n+\n+public class TestMarkStackOverflow {\n+    public static void main(String[] args) throws Exception {\n+        for (int i = 0; i < 10; i++) {\n+            Finalizable holder1 = new Finalizable();\n+            System.out.printf(\"Used mem %.2f MB\\n\", getUsedMem());\n+        }\n+    }\n+\n+    private static double getUsedMem() {\n+        return (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) \/ (double) (1024 * 1024);\n+    }\n+\n+    private static class Finalizable {\n+        public static final int NUM_OBJECTS = 200_000;\n+        private final LinkedHashMap<Object, Object> list = new LinkedHashMap<>();\n+\n+        public Finalizable() {\n+            for (int i = 0; i < NUM_OBJECTS; i++) {\n+                Object entry = new Object();\n+                list.put(entry, entry);\n+            }\n+        }\n+\n+        @SuppressWarnings(\"removal\")\n+        protected void finalize() {\n+            System.out.print(\"\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestMarkStackOverflow.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -69,2 +69,0 @@\n-tools\/javac\/lambda\/bytecode\/TestLambdaBytecodeTargetRelease14.java              8312534    linux-i586     fails with assert \"g1ConcurrentMark.cpp: Overflow during reference processing\"\n-tools\/javac\/varargs\/warning\/Warn5.java                                          8312534    linux-i586     fails with assert \"g1ConcurrentMark.cpp: Overflow during reference processing\"\n","filename":"test\/langtools\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}