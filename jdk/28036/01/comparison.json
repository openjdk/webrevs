{"files":[{"patch":"@@ -768,14 +768,0 @@\n-HeapWord* ShenandoahFreeSet::allocate_from_partition_with_affiliation(ShenandoahAffiliation affiliation,\n-                                                                      ShenandoahAllocRequest& req, bool& in_new_region) {\n-\n-  shenandoah_assert_heaplocked();\n-  ShenandoahFreeSetPartitionId which_partition = req.is_old()? ShenandoahFreeSetPartitionId::OldCollector: ShenandoahFreeSetPartitionId::Collector;\n-  if (_partitions.alloc_from_left_bias(which_partition)) {\n-    ShenandoahLeftRightIterator iterator(&_partitions, which_partition, affiliation == ShenandoahAffiliation::FREE);\n-    return allocate_with_affiliation(iterator, affiliation, req, in_new_region);\n-  } else {\n-    ShenandoahRightLeftIterator iterator(&_partitions, which_partition, affiliation == ShenandoahAffiliation::FREE);\n-    return allocate_with_affiliation(iterator, affiliation, req, in_new_region);\n-  }\n-}\n-\n@@ -783,1 +769,7 @@\n-HeapWord* ShenandoahFreeSet::allocate_with_affiliation(Iter& iterator, ShenandoahAffiliation affiliation, ShenandoahAllocRequest& req, bool& in_new_region) {\n+HeapWord* ShenandoahFreeSet::allocate_with_affiliation(Iter& iterator,\n+                                                       ShenandoahAffiliation affiliation,\n+                                                       ShenandoahAllocRequest& req,\n+                                                       bool& in_new_region,\n+                                                       bool& allow_new_region) {\n+  assert(affiliation != ShenandoahAffiliation::FREE, \"Must not\");\n+  ShenandoahHeapRegion* free_region = nullptr;\n@@ -791,0 +783,2 @@\n+    } else if (free_region == nullptr && r->affiliation() == FREE) {\n+      free_region = r;\n@@ -793,0 +787,6 @@\n+  \/\/ Failed to allocate within any affiliated region, try the first free region in the partition.\n+  if (free_region != nullptr && (allow_new_region = can_allocate_in_new_region(req)) == true) {\n+    HeapWord* result = try_allocate_in(free_region, req, in_new_region);\n+    assert(result != nullptr, \"Allocate in free region in the partition always succeed.\");\n+    return result;\n+  }\n@@ -894,5 +894,10 @@\n-  \/\/ Fast-path: try to allocate in the collector view first\n-  HeapWord* result;\n-  result = allocate_from_partition_with_affiliation(req.affiliation(), req, in_new_region);\n-  if (result != nullptr) {\n-    return result;\n+  shenandoah_assert_heaplocked();\n+  ShenandoahFreeSetPartitionId which_partition = req.is_old()? ShenandoahFreeSetPartitionId::OldCollector: ShenandoahFreeSetPartitionId::Collector;\n+  HeapWord* result = nullptr;\n+  bool allow_new_region = false;\n+  if (_partitions.alloc_from_left_bias(which_partition)) {\n+    ShenandoahLeftRightIterator iterator(&_partitions, which_partition);\n+    result = allocate_with_affiliation(iterator, req.affiliation(), req, in_new_region, allow_new_region);\n+  } else {\n+    ShenandoahRightLeftIterator iterator(&_partitions, which_partition);\n+    result = allocate_with_affiliation(iterator, req.affiliation(), req, in_new_region, allow_new_region);\n@@ -901,7 +906,2 @@\n-  bool allow_new_region = can_allocate_in_new_region(req);\n-  if (allow_new_region) {\n-    \/\/ Try a free region that is dedicated to GC allocations.\n-    result = allocate_from_partition_with_affiliation(ShenandoahAffiliation::FREE, req, in_new_region);\n-    if (result != nullptr) {\n-      return result;\n-    }\n+  if (result != nullptr) {\n+    return result;\n@@ -915,11 +915,1 @@\n-  if (!allow_new_region && req.is_old() && (_heap->young_generation()->free_unaffiliated_regions() > 0)) {\n-    \/\/ This allows us to flip a mutator region to old_collector\n-    allow_new_region = true;\n-  }\n-\n-  \/\/ We should expand old-gen if this can prevent an old-gen evacuation failure.  We don't care so much about\n-  \/\/ promotion failures since they can be mitigated in a subsequent GC pass.  Would be nice to know if this\n-  \/\/ allocation request is for evacuation or promotion.  Individual threads limit their use of PLAB memory for\n-  \/\/ promotions, so we already have an assurance that any additional memory set aside for old-gen will be used\n-  \/\/ only for old-gen evacuations.\n-  if (allow_new_region) {\n+  if (allow_new_region || (req.is_old() && _heap->young_generation()->free_unaffiliated_regions() > 0)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":28,"deletions":38,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -321,5 +321,0 @@\n-  \/\/ Return the address of memory allocated, setting in_new_region to true iff the allocation is taken\n-  \/\/ from a region that was previously empty.  Return nullptr if memory could not be allocated.\n-  inline HeapWord* allocate_from_partition_with_affiliation(ShenandoahAffiliation affiliation,\n-                                                            ShenandoahAllocRequest& req, bool& in_new_region);\n-\n@@ -375,1 +370,2 @@\n-  \/\/ Search for allocation in region with same affiliation as request, using given iterator.\n+  \/\/ Search for allocation in region with same affiliation as request, using given iterator,\n+  \/\/ or affiliate the first usable FREE region with given affiliation and allocate in.\n@@ -377,1 +373,5 @@\n-  HeapWord* allocate_with_affiliation(Iter& iterator, ShenandoahAffiliation affiliation, ShenandoahAllocRequest& req, bool& in_new_region);\n+  HeapWord* allocate_with_affiliation(Iter& iterator,\n+                                      ShenandoahAffiliation affiliation,\n+                                      ShenandoahAllocRequest& req,\n+                                      bool& in_new_region,\n+                                      bool& allow_new_region);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"}]}