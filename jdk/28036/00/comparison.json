{"files":[{"patch":"@@ -768,14 +768,0 @@\n-HeapWord* ShenandoahFreeSet::allocate_from_partition_with_affiliation(ShenandoahAffiliation affiliation,\n-                                                                      ShenandoahAllocRequest& req, bool& in_new_region) {\n-\n-  shenandoah_assert_heaplocked();\n-  ShenandoahFreeSetPartitionId which_partition = req.is_old()? ShenandoahFreeSetPartitionId::OldCollector: ShenandoahFreeSetPartitionId::Collector;\n-  if (_partitions.alloc_from_left_bias(which_partition)) {\n-    ShenandoahLeftRightIterator iterator(&_partitions, which_partition, affiliation == ShenandoahAffiliation::FREE);\n-    return allocate_with_affiliation(iterator, affiliation, req, in_new_region);\n-  } else {\n-    ShenandoahRightLeftIterator iterator(&_partitions, which_partition, affiliation == ShenandoahAffiliation::FREE);\n-    return allocate_with_affiliation(iterator, affiliation, req, in_new_region);\n-  }\n-}\n-\n@@ -784,0 +770,2 @@\n+  assert(affiliation != ShenandoahAffiliation::FREE, \"Must not\");\n+  ShenandoahHeapRegion* free_region = nullptr;\n@@ -791,0 +779,3 @@\n+    } else if (free_region == nullptr && r->affiliation() == FREE &&\n+               (!r->is_trash() || !_heap->is_concurrent_weak_root_in_progress())) {\n+      free_region = r;\n@@ -793,0 +784,6 @@\n+  \/\/ Failed to allocate within any affiliated region, try the first free region in the partition.\n+  if (free_region != nullptr) {\n+    HeapWord* result = try_allocate_in(free_region, req, in_new_region);\n+    assert(result != nullptr, \"Allocate in free region in the partition always succeed.\");\n+    return result;\n+  }\n@@ -894,5 +891,9 @@\n-  \/\/ Fast-path: try to allocate in the collector view first\n-  HeapWord* result;\n-  result = allocate_from_partition_with_affiliation(req.affiliation(), req, in_new_region);\n-  if (result != nullptr) {\n-    return result;\n+  shenandoah_assert_heaplocked();\n+  ShenandoahFreeSetPartitionId which_partition = req.is_old()? ShenandoahFreeSetPartitionId::OldCollector: ShenandoahFreeSetPartitionId::Collector;\n+  HeapWord* result = nullptr;\n+  if (_partitions.alloc_from_left_bias(which_partition)) {\n+    ShenandoahLeftRightIterator iterator(&_partitions, which_partition);\n+    result = allocate_with_affiliation(iterator, req.affiliation(), req, in_new_region);\n+  } else {\n+    ShenandoahRightLeftIterator iterator(&_partitions, which_partition);\n+    result = allocate_with_affiliation(iterator, req.affiliation(), req, in_new_region);\n@@ -901,7 +902,2 @@\n-  bool allow_new_region = can_allocate_in_new_region(req);\n-  if (allow_new_region) {\n-    \/\/ Try a free region that is dedicated to GC allocations.\n-    result = allocate_from_partition_with_affiliation(ShenandoahAffiliation::FREE, req, in_new_region);\n-    if (result != nullptr) {\n-      return result;\n-    }\n+  if (result != nullptr) {\n+    return result;\n@@ -915,11 +911,2 @@\n-  if (!allow_new_region && req.is_old() && (_heap->young_generation()->free_unaffiliated_regions() > 0)) {\n-    \/\/ This allows us to flip a mutator region to old_collector\n-    allow_new_region = true;\n-  }\n-\n-  \/\/ We should expand old-gen if this can prevent an old-gen evacuation failure.  We don't care so much about\n-  \/\/ promotion failures since they can be mitigated in a subsequent GC pass.  Would be nice to know if this\n-  \/\/ allocation request is for evacuation or promotion.  Individual threads limit their use of PLAB memory for\n-  \/\/ promotions, so we already have an assurance that any additional memory set aside for old-gen will be used\n-  \/\/ only for old-gen evacuations.\n-  if (allow_new_region) {\n+  if (!_heap->mode()->is_generational() ||\n+      _heap->young_generation()->free_unaffiliated_regions() > 0) {\n@@ -935,10 +922,0 @@\n-bool ShenandoahFreeSet::can_allocate_in_new_region(const ShenandoahAllocRequest& req) {\n-  if (!_heap->mode()->is_generational()) {\n-    return true;\n-  }\n-\n-  assert(req.is_old() || req.is_young(), \"Should request affiliation\");\n-  return (req.is_old() && _heap->old_generation()->free_unaffiliated_regions() > 0)\n-         || (req.is_young() && _heap->young_generation()->free_unaffiliated_regions() > 0);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":24,"deletions":47,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -321,5 +321,0 @@\n-  \/\/ Return the address of memory allocated, setting in_new_region to true iff the allocation is taken\n-  \/\/ from a region that was previously empty.  Return nullptr if memory could not be allocated.\n-  inline HeapWord* allocate_from_partition_with_affiliation(ShenandoahAffiliation affiliation,\n-                                                            ShenandoahAllocRequest& req, bool& in_new_region);\n-\n@@ -375,1 +370,2 @@\n-  \/\/ Search for allocation in region with same affiliation as request, using given iterator.\n+  \/\/ Search for allocation in region with same affiliation as request, using given iterator,\n+  \/\/ or affiliate the first usable FREE region with given affiliation and allocate in.\n@@ -379,3 +375,0 @@\n-  \/\/ Return true if the respective generation for this request has free regions.\n-  bool can_allocate_in_new_region(const ShenandoahAllocRequest& req);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"}]}