{"files":[{"patch":"@@ -2722,1 +2722,1 @@\n-        if (this.signum < 0)\n+        if (this.signum < 0) {\n@@ -2724,0 +2724,1 @@\n+        }\n@@ -2744,1 +2745,1 @@\n-        if (this.signum < 0)\n+        if (this.signum < 0) {\n@@ -2746,0 +2747,1 @@\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n- * @author  Fabio Romano\n@@ -125,1 +124,1 @@\n-            value = new int[2];\n+            value = new int[] { hi, (int) val };\n@@ -127,2 +126,0 @@\n-            value[0] = hi;\n-            value[1] = (int) val;\n@@ -133,1 +130,1 @@\n-        value = new int[1];\n+        value = new int[] { val };\n@@ -135,1 +132,0 @@\n-        value[0] = val;\n@@ -1912,1 +1908,1 @@\n-     * The contents of {@code this} are <b>not<\/b> changed.\n+     * The contents of {@code this} are <em>not<\/em> changed.\n@@ -1914,0 +1910,2 @@\n+     *\n+     * @return the integer square root of {@code this} and the remainder if needed\n@@ -1916,1 +1914,0 @@\n-     * @return the integer square root of {@code this} and the remainder if needed\n@@ -1920,5 +1917,1 @@\n-        if (this.isZero()) {\n-            return new MutableBigInteger[] {\n-                    new MutableBigInteger(), needRemainder ? new MutableBigInteger() : null\n-            };\n-        } else if (this.intLen <= 2) {\n+        if (this.intLen <= 2) {\n@@ -1927,15 +1920,8 @@\n-            if (this.intLen == 1) {\n-                if (x < 4) \/\/ result is unity\n-                    return new MutableBigInteger[] {\n-                            ONE, needRemainder ? new MutableBigInteger((int) (x - 1)) : null\n-                    };\n-\n-                long s = (long) Math.sqrt(x); \/\/ Math.sqrt is exact\n-                return new MutableBigInteger[] {\n-                        new MutableBigInteger((int) s),\n-                        needRemainder ? new MutableBigInteger((int) (x - s * s)) : null\n-                };\n-            }\n-\n-            \/\/ Initial estimate is the square root of the unsigned long value.\n-            long s = (long) Math.sqrt(x > 0 ? x : x + 0x1p64);\n+            \/* For every long value s in [0, 2^32) such that x == s * s,\n+             * it is true that s == (long) Math.sqrt(x >= 0 ? x : x + 0x1p64).\n+             * This means that Math.sqrt() returns the correct value for every perfect square,\n+             * so the value returned by Math.sqrt() for a long value in the range [0, 2^64)\n+             * is either correct, or rounded up by one if the value is too high\n+             * and too close to the next perfect square.\n+             *\/\n+            long s = (long) Math.sqrt(x >= 0 ? x : x + 0x1p64);\n@@ -1997,1 +1983,1 @@\n-            long s = (long) Math.sqrt(x > 0 ? x : x + 0x1p64);\n+            long s = (long) Math.sqrt(x >= 0 ? x : x + 0x1p64);\n@@ -2021,2 +2007,2 @@\n-        final int limit = len;\n-        final int excessInts = (-len) & 3;\n+        final int limit = offset + len;\n+        final int excessInts = (-len) & 3; \/\/ Compute 4 * ceil(len \/ 4) - len\n@@ -2027,1 +2013,1 @@\n-        final int blockLen = len >> 2, blockBitLen = blockLen << 5;\n+        final int blockLen = len >> 2;\n@@ -2029,2 +2015,1 @@\n-        dividend.leftShift(blockBitLen);\n-        dividend.add(getBlockZimmermann(1, len, limit, blockLen));\n+        dividend.shiftAddDisjoint(getBlockZimmermann(1, len, limit, blockLen), blockLen);\n@@ -2037,1 +2022,1 @@\n-        sqrt.leftShift(blockBitLen);\n+        sqrt.leftShift(blockLen << 5);\n@@ -2040,3 +2025,2 @@\n-        MutableBigInteger chunk = u;\n-        chunk.leftShift(blockBitLen);\n-        chunk.add(getBlockZimmermann(0, len, limit, blockLen));\n+        MutableBigInteger chunk = u; \/\/ Corresponds to ub + a_0 in the paper\n+        chunk.shiftAddDisjoint(getBlockZimmermann(0, len, limit, blockLen), blockLen);\n@@ -2068,1 +2052,1 @@\n-                MutableBigInteger s0 = sqrt.getBlockZimmermann(0, sqrt.intLen, sqrt.intLen, s0Ints);\n+                MutableBigInteger s0 = sqrt.getBlockZimmermann(0, sqrt.intLen, sqrt.offset + sqrt.intLen, s0Ints);\n@@ -2091,0 +2075,44 @@\n+    \/**\n+     * Shifts {@code this} of {@code n} ints to the left and adds {@code addend}.\n+     * Assume {@code addend.intLen <= n}.\n+     *\/\n+    private void shiftAddDisjoint(MutableBigInteger addend, int n) {\n+        if (intLen == 0) { \/\/ Avoid unnormal values\n+            copyValue(addend);\n+            return;\n+        }\n+\n+        int[] res;\n+        final int resLen = intLen + n, resOffset;\n+        if (resLen > value.length) {\n+            res = new int[resLen];\n+            System.arraycopy(value, offset, res, 0, intLen);\n+            resOffset = 0;\n+        } else {\n+            res = value;\n+            if (offset + resLen > value.length) {\n+                System.arraycopy(value, offset, res, 0, intLen);\n+                resOffset = 0;\n+            } else {\n+                resOffset = offset;\n+            }\n+            \/\/ Clean words where necessary\n+            Arrays.fill(res, resOffset + intLen, resOffset + resLen - addend.intLen, 0);\n+        }\n+\n+        System.arraycopy(addend.value, addend.offset, res, resOffset + resLen - addend.intLen, addend.intLen);\n+\n+        value = res;\n+        offset = resOffset;\n+        intLen = resLen;\n+    }\n+\n+    \/**\n+     * Returns a {@code MutableBigInteger} obtained taking {@code blockLen} ints from\n+     * {@code this} number, starting at {@code blockIndex*blockLen}.<br\/>\n+     * Used by Zimmermann square root.\n+     * @param blockIndex the block index\n+     * @param len the logical length of the input value in units of 32 bits\n+     * @param limit the offset which is the end of valid words in the input value\n+     * @param blockLength the length of the block in units of 32 bits\n+     *\/\n@@ -2093,1 +2121,1 @@\n-        final int to = Math.min(blockEnd, offset + limit);\n+        final int to = Math.min(blockEnd, limit);\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":68,"deletions":40,"binary":false,"changes":108,"status":"modified"}]}