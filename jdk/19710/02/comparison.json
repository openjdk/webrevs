{"files":[{"patch":"@@ -492,1 +492,1 @@\n-    private BigInteger(int signum, int[] magnitude) {\n+    BigInteger(int signum, int[] magnitude) {\n@@ -2722,5 +2722,1 @@\n-        if (this.signum < 0) {\n-            throw new ArithmeticException(\"Negative BigInteger\");\n-        }\n-\n-        return new MutableBigInteger(this.mag).sqrt().toBigInteger();\n+        return sqrtAndRemainder()[0];\n@@ -2745,4 +2741,5 @@\n-        BigInteger s = sqrt();\n-        BigInteger r = this.subtract(s.square());\n-        assert r.compareTo(BigInteger.ZERO) >= 0;\n-        return new BigInteger[] {s, r};\n+        if (this.signum < 0)\n+            throw new ArithmeticException(\"Negative BigInteger\");\n+\n+        MutableBigInteger[] sqrtRem = new MutableBigInteger(this.mag).sqrtRem();\n+        return new BigInteger[] { sqrtRem[0].toBigInteger(), sqrtRem[1].toBigInteger() };\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.math.DoubleConsts;\n@@ -46,0 +47,1 @@\n+ * @author  Fabio Romano\n@@ -265,0 +267,3 @@\n+        this.normalize();\n+        b.normalize();\n+\n@@ -290,0 +295,3 @@\n+        this.normalize();\n+        b.normalize();\n+\n@@ -482,0 +490,1 @@\n+        normalize();\n@@ -489,0 +498,1 @@\n+        normalize();\n@@ -1885,0 +1895,170 @@\n+    \/**\n+     * Calculate the integer square root {@code floor(sqrt(this))} and the remainder,\n+     * where {@code sqrt(.)} denotes the mathematical square root.\n+     * The contents of {@code this} are <b>not<\/b> changed.\n+     * The value of {@code this} is assumed to be non-negative.\n+     * @throws ArithmeticException if the value returned by {@code bitLength()}\n+     * overflows the range of {@code int}.\n+     * @return the integer square root of {@code this}\n+     *\/\n+    MutableBigInteger[] sqrtRem() {\n+        \/\/ Special cases.\n+        if (this.isZero()) {\n+            return new MutableBigInteger[] { new MutableBigInteger(), new MutableBigInteger() };\n+        } else if (this.intLen <= 2) {\n+            final long x = this.toLong(); \/\/ unsigned\n+\n+            if (this.intLen == 1) {\n+                if (x < 4) \/\/ result is unity\n+                    return new MutableBigInteger[] { ONE, new MutableBigInteger((int) (x - 1)) };\n+\n+                long s = (long) Math.sqrt(x); \/\/ Math.sqrt is exact\n+                return new MutableBigInteger[] {\n+                        new MutableBigInteger((int) s), new MutableBigInteger((int) (x - s * s))\n+                };\n+            }\n+\n+            \/\/ Initial estimate is the square root of the unsigned long value.\n+            long s = (long) Math.sqrt(x > 0 ? x : x + 0x1p64);\n+            if (s > LONG_MASK \/\/ avoid overflow of s * s\n+                    || Long.compareUnsigned(x, s * s) < 0) {\n+                s--;\n+            }\n+\n+            long r = x - s * s;\n+            return new MutableBigInteger[] {\n+                    new MutableBigInteger((int) s),\n+                    r <= LONG_MASK ? new MutableBigInteger((int) r)\n+                    : new MutableBigInteger(new int[] { 1,  (int) r})\n+            };\n+        }\n+\n+        long bitLength = this.bitLength();\n+        if (bitLength != (int) bitLength)\n+            throw new ArithmeticException(\"bitLength() integer overflow\");\n+\n+        \/\/ Normalize\n+        MutableBigInteger x = this;\n+        int shift = Integer.numberOfLeadingZeros(x.value[x.offset]) & ~1; \/\/ shift must be even\n+        if (shift != 0) {\n+            x = new MutableBigInteger(x);\n+            x.primitiveLeftShift(shift);\n+        }\n+\n+        MutableBigInteger[] sqrtRem = x.sqrtRemZimmermann(x.intLen);\n+\n+        \/\/ Unnormalize\n+        if (shift != 0) {\n+            final int halfShift = shift >> 1;\n+            if (!sqrtRem[1].isZero()) {\n+                final int sqrtEnd = sqrtRem[0].offset + sqrtRem[0].intLen;\n+                final int s0 = sqrtRem[0].value[sqrtEnd - 1] & ((1 << halfShift) - 1);\n+                if (s0 != 0) { \/\/ An optimization\n+                    \/\/ s0 is at most 15 bit long\n+                    sqrtRem[1].add(new MutableBigInteger(sqrtRem[0].toBigInteger().multiply(s0 << 1).mag));\n+                    sqrtRem[1].subtract(new MutableBigInteger(s0 * s0));\n+                }\n+                sqrtRem[1].primitiveRightShift(shift);\n+            }\n+            sqrtRem[0].primitiveRightShift(halfShift);\n+        }\n+        return sqrtRem;\n+    }\n+\n+    \/**\n+     * Assume {@code 2 <= len <= intLen && Integer.numberOfLeadingZeros(value[offset]) <= 1}\n+     * @implNote The implementation is based on Zimmermann's works available\n+     * <a href=\"https:\/\/inria.hal.science\/inria-00072854\/en\/\">  here<\/a> and\n+     * <a href=\"https:\/\/www.researchgate.net\/publication\/220532560_A_proof_of_GMP_square_root\">  here<\/a>\n+     *\/\n+    private MutableBigInteger[] sqrtRemZimmermann(int len) {\n+        if (len == 2) { \/\/ Base case\n+            long x = ((value[offset] & LONG_MASK) << 32) | (value[offset + 1] & LONG_MASK);\n+            long s = (long) Math.sqrt(x > 0 ? x : x + 0x1p64);\n+            if (s > LONG_MASK || Long.compareUnsigned(x, s * s) < 0)\n+                s--;\n+\n+            long r = x - s * s;\n+\n+            \/\/ Allocate sufficient space to hold the normalized final square root\n+            MutableBigInteger sqrt = new MutableBigInteger(new int[(intLen + ((-intLen) & 3) + 1) >> 1]);\n+\n+            \/\/ Place the partial square root\n+            sqrt.intLen = 1;\n+            sqrt.value[0] = (int) s;\n+\n+            return new MutableBigInteger[] { sqrt,\n+                    r <= LONG_MASK ? new MutableBigInteger((int) r)\n+                    : new MutableBigInteger(new int[] { 1,  (int) r})\n+            };\n+        }\n+\n+        \/\/ Recursive step (len >= 3)\n+\n+        \/\/ Normalize\n+        final int limit = len;\n+        final int excessInts = (-len) & 3;\n+        len += excessInts; \/\/ len must be a multiple of 4\n+\n+        MutableBigInteger[] sr = sqrtRemZimmermann(len >> 1); \/\/ Recursive invocation\n+\n+        final int blockLen = len >> 2, blockBitLen = blockLen << 5;\n+        MutableBigInteger dividend = sr[1];\n+        dividend.leftShift(blockBitLen);\n+        dividend.add(getBlockZimmermann(1, len, limit, blockLen));\n+        MutableBigInteger twiceSqrt = new MutableBigInteger(sr[0]);\n+        twiceSqrt.leftShift(1);\n+        MutableBigInteger q = new MutableBigInteger();\n+        MutableBigInteger u = dividend.divide(twiceSqrt, q);\n+\n+        MutableBigInteger sqrt = sr[0];\n+        sqrt.leftShift(blockBitLen);\n+        sqrt.add(q);\n+\n+        MutableBigInteger rem = u;\n+        rem.leftShift(blockBitLen);\n+        rem.add(getBlockZimmermann(0, len, limit, blockLen));\n+        BigInteger qBig = q.toBigInteger();\n+        int rSign = rem.subtract(new MutableBigInteger(qBig.multiply(qBig).mag));\n+\n+        if (rSign == -1) {\n+            twiceSqrt = new MutableBigInteger(sqrt);\n+            twiceSqrt.leftShift(1);\n+\n+            rem.add(ONE);\n+            rem.subtract(twiceSqrt);\n+            sqrt.subtract(ONE);\n+        }\n+\n+        \/\/ Unnormalize\n+        if (excessInts != 0) {\n+            final int halfShift = excessInts << 4;\n+            if (!rem.isZero()) {\n+                final int sqrtEnd = sqrt.offset + sqrt.intLen, s0Len = (halfShift + 31) >> 5;\n+                int[] s0Mag = Arrays.copyOfRange(sqrt.value, sqrtEnd - s0Len, sqrtEnd);\n+                if ((halfShift & 31) != 0)\n+                    s0Mag[0] &= (1 << halfShift) - 1;\n+\n+                BigInteger s0 = new BigInteger(1, s0Mag);\n+                if (s0.signum != 0) { \/\/ An optimization\n+                    rem.add(new MutableBigInteger(s0.shiftLeft(1).multiply(sqrt.toBigInteger()).mag));\n+                    rem.subtract(new MutableBigInteger(s0.multiply(s0).mag));\n+                }\n+                rem.intLen -= excessInts;\n+            }\n+            sqrt.rightShift(halfShift);\n+        }\n+        return new MutableBigInteger[] { sqrt, rem };\n+    }\n+\n+    private MutableBigInteger getBlockZimmermann(int blockIndex, int len, int limit, int blockLen) {\n+        int from = offset + len - (blockIndex + 1) * blockLen;\n+        int intEnd = offset + limit;\n+        if (from >= intEnd)\n+            return new MutableBigInteger();\n+\n+        int[] block = new int[blockLen];\n+        System.arraycopy(value, from, block, 0, Math.min(intEnd - from, blockLen));\n+        return new MutableBigInteger(block);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"modified"}]}