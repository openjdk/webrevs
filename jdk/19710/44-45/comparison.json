{"files":[{"patch":"@@ -1867,90 +1867,0 @@\n-    \/**\n-     * Calculate the integer square root {@code floor(sqrt(this))} where\n-     * {@code sqrt(.)} denotes the mathematical square root. The contents of\n-     * {@code this} are <b>not<\/b> changed. The value of {@code this} is assumed\n-     * to be non-negative.\n-     *\n-     * @implNote The implementation is based on the material in Henry S. Warren,\n-     * Jr., <i>Hacker's Delight (2nd ed.)<\/i> (Addison Wesley, 2013), 279-282.\n-     *\n-     * @throws ArithmeticException if the value returned by {@code bitLength()}\n-     * overflows the range of {@code int}.\n-     * @return the integer square root of {@code this}\n-     * @since 9\n-     *\/\n-    MutableBigInteger sqrt() {\n-        \/\/ Special cases.\n-        if (this.isZero()) {\n-            return new MutableBigInteger(0);\n-        } else if (this.value.length == 1\n-                && (this.value[0] & LONG_MASK) < 4) { \/\/ result is unity\n-            return ONE;\n-        }\n-\n-        if (bitLength() <= 63) {\n-            \/\/ Initial estimate is the square root of the positive long value.\n-            long v = new BigInteger(this.value, 1).longValueExact();\n-            long xk = (long)Math.floor(Math.sqrt(v));\n-\n-            \/\/ Refine the estimate.\n-            do {\n-                long xk1 = (xk + v\/xk)\/2;\n-\n-                \/\/ Terminate when non-decreasing.\n-                if (xk1 >= xk) {\n-                    return new MutableBigInteger(new int[] {\n-                        (int)(xk >>> 32), (int)(xk & LONG_MASK)\n-                    });\n-                }\n-\n-                xk = xk1;\n-            } while (true);\n-        } else {\n-            \/\/ Set up the initial estimate of the iteration.\n-\n-            \/\/ Obtain the bitLength > 63.\n-            int bitLength = (int) this.bitLength();\n-            if (bitLength != this.bitLength()) {\n-                throw new ArithmeticException(\"bitLength() integer overflow\");\n-            }\n-\n-            \/\/ Determine an even valued right shift into positive long range.\n-            int shift = bitLength - 63;\n-            if (shift % 2 == 1) {\n-                shift++;\n-            }\n-\n-            \/\/ Shift the value into positive long range.\n-            MutableBigInteger xk = new MutableBigInteger(this);\n-            xk.rightShift(shift);\n-            xk.normalize();\n-\n-            \/\/ Use the square root of the shifted value as an approximation.\n-            double d = new BigInteger(xk.value, 1).doubleValue();\n-            BigInteger bi = BigInteger.valueOf((long)Math.ceil(Math.sqrt(d)));\n-            xk = new MutableBigInteger(bi.mag);\n-\n-            \/\/ Shift the approximate square root back into the original range.\n-            xk.leftShift(shift \/ 2);\n-\n-            \/\/ Refine the estimate.\n-            MutableBigInteger xk1 = new MutableBigInteger();\n-            do {\n-                \/\/ xk1 = (xk + n\/xk)\/2\n-                this.divide(xk, xk1, false);\n-                xk1.add(xk);\n-                xk1.rightShift(1);\n-\n-                \/\/ Terminate when non-decreasing.\n-                if (xk1.compare(xk) >= 0) {\n-                    return xk;\n-                }\n-\n-                \/\/ xk = xk1\n-                xk.copyValue(xk1);\n-\n-                xk1.reset();\n-            } while (true);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"modified"}]}