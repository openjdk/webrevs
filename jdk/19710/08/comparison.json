{"files":[{"patch":"@@ -2722,5 +2722,1 @@\n-        if (this.signum < 0) {\n-            throw new ArithmeticException(\"Negative BigInteger\");\n-        }\n-\n-        return new MutableBigInteger(this.mag).sqrt().toBigInteger();\n+        return sqrtAndRemainder()[0];\n@@ -2745,4 +2741,5 @@\n-        BigInteger s = sqrt();\n-        BigInteger r = this.subtract(s.square());\n-        assert r.compareTo(BigInteger.ZERO) >= 0;\n-        return new BigInteger[] {s, r};\n+        if (this.signum < 0)\n+            throw new ArithmeticException(\"Negative BigInteger\");\n+\n+        MutableBigInteger[] sqrtRem = new MutableBigInteger(this.mag).sqrtRem();\n+        return new BigInteger[] { sqrtRem[0].toBigInteger(), sqrtRem[1].toBigInteger() };\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+ * @author  Fabio Romano\n@@ -112,0 +113,19 @@\n+        init(val);\n+    }\n+\n+    \/**\n+     * Construct a new MutableBigInteger with a magnitude specified by\n+     * the long val.\n+     *\/\n+    MutableBigInteger(long val) {\n+        if ((val & LONG_MASK) == val) {\n+            init((int) val);\n+        } else {\n+            value = new int[2];\n+            intLen = 2;\n+            value[0] = (int) (val >>> 32);\n+            value[1] = (int) val;\n+        }\n+    }\n+\n+    private void init(int val) {\n@@ -263,0 +283,1 @@\n+     * Assumes no leading unnecessary zeros.\n@@ -288,0 +309,1 @@\n+     * Assumes no leading unnecessary zeros.\n@@ -1885,0 +1907,167 @@\n+    \/**\n+     * Calculate the integer square root {@code floor(sqrt(this))} and the remainder,\n+     * where {@code sqrt(.)} denotes the mathematical square root.\n+     * The contents of {@code this} are <b>not<\/b> changed.\n+     * The value of {@code this} is assumed to be non-negative.\n+     * @throws ArithmeticException if the value returned by {@code bitLength()}\n+     * overflows the range of {@code int}.\n+     * @return the integer square root of {@code this}\n+     *\/\n+    MutableBigInteger[] sqrtRem() {\n+        \/\/ Special cases.\n+        if (this.isZero()) {\n+            return new MutableBigInteger[] { new MutableBigInteger(), new MutableBigInteger() };\n+        } else if (this.intLen <= 2) {\n+            final long x = this.toLong(); \/\/ unsigned\n+\n+            if (this.intLen == 1) {\n+                if (x < 4) \/\/ result is unity\n+                    return new MutableBigInteger[] { ONE, new MutableBigInteger((int) (x - 1)) };\n+\n+                long s = (long) Math.sqrt(x); \/\/ Math.sqrt is exact\n+                return new MutableBigInteger[] {\n+                        new MutableBigInteger((int) s), new MutableBigInteger((int) (x - s * s))\n+                };\n+            }\n+\n+            \/\/ Initial estimate is the square root of the unsigned long value.\n+            long s = (long) Math.sqrt(x > 0 ? x : x + 0x1p64);\n+            if (s > LONG_MASK \/\/ avoid overflow of s * s\n+                    || Long.compareUnsigned(x, s * s) < 0) {\n+                s--;\n+            }\n+\n+            return new MutableBigInteger[] { new MutableBigInteger((int) s), new MutableBigInteger(x - s * s) };\n+        }\n+\n+        long bitLength = this.bitLength();\n+        if (bitLength != (int) bitLength)\n+            throw new ArithmeticException(\"bitLength() integer overflow\");\n+\n+        \/\/ Normalize\n+        MutableBigInteger x = this;\n+        int shift = Integer.numberOfLeadingZeros(x.value[x.offset]) & ~1; \/\/ shift must be even\n+        if (shift != 0) {\n+            x = new MutableBigInteger(x);\n+            x.primitiveLeftShift(shift);\n+        }\n+\n+        MutableBigInteger[] sqrtRem = x.sqrtRemZimmermann(x.intLen);\n+\n+        \/\/ Unnormalize\n+        if (shift != 0) {\n+            final int halfShift = shift >> 1;\n+            if (!sqrtRem[1].isZero()) {\n+                final int sqrtEnd = sqrtRem[0].offset + sqrtRem[0].intLen;\n+                final int s0 = sqrtRem[0].value[sqrtEnd - 1] & ((1 << halfShift) - 1);\n+                if (s0 != 0) { \/\/ An optimization\n+                    \/\/ s0 is at most 15 bit long\n+                    sqrtRem[1].add(new MutableBigInteger(sqrtRem[0].toBigInteger().multiply(s0 << 1).mag));\n+                    sqrtRem[1].subtract(new MutableBigInteger(s0 * s0));\n+                }\n+                sqrtRem[1].primitiveRightShift(shift);\n+            }\n+            sqrtRem[0].primitiveRightShift(halfShift);\n+        }\n+        return sqrtRem;\n+    }\n+\n+    \/**\n+     * Assume {@code 2 <= len <= intLen && Integer.numberOfLeadingZeros(value[offset]) <= 1}\n+     * @implNote The implementation is based on Zimmermann's works available\n+     * <a href=\"https:\/\/inria.hal.science\/inria-00072854\/en\/\">  here<\/a> and\n+     * <a href=\"https:\/\/www.researchgate.net\/publication\/220532560_A_proof_of_GMP_square_root\">  here<\/a>\n+     *\/\n+    private MutableBigInteger[] sqrtRemZimmermann(int len) {\n+        if (len == 2) { \/\/ Base case\n+            long x = ((value[offset] & LONG_MASK) << 32) | (value[offset + 1] & LONG_MASK);\n+            long s = (long) Math.sqrt(x > 0 ? x : x + 0x1p64);\n+            if (s > LONG_MASK || Long.compareUnsigned(x, s * s) < 0)\n+                s--;\n+\n+            long r = x - s * s;\n+\n+            \/\/ Allocate sufficient space to hold the normalized final square root\n+            MutableBigInteger sqrt = new MutableBigInteger(new int[(intLen + ((-intLen) & 3) + 1) >> 1]);\n+\n+            \/\/ Place the partial square root\n+            sqrt.intLen = 1;\n+            sqrt.value[0] = (int) s;\n+\n+            return new MutableBigInteger[] { sqrt, new MutableBigInteger(x - s * s) };\n+        }\n+\n+        \/\/ Recursive step (len >= 3)\n+\n+        \/\/ Normalize\n+        final int limit = len;\n+        final int excessInts = (-len) & 3;\n+        len += excessInts; \/\/ len must be a multiple of 4\n+\n+        MutableBigInteger[] sr = sqrtRemZimmermann(len >> 1); \/\/ Recursive invocation\n+\n+        final int blockLen = len >> 2, blockBitLen = blockLen << 5;\n+        MutableBigInteger dividend = sr[1];\n+        dividend.leftShift(blockBitLen);\n+        dividend.add(new MutableBigInteger(getBlockZimmermann(1, len, limit, blockLen)));\n+        MutableBigInteger twiceSqrt = new MutableBigInteger(sr[0]);\n+        twiceSqrt.leftShift(1);\n+        MutableBigInteger q = new MutableBigInteger();\n+        MutableBigInteger u = dividend.divide(twiceSqrt, q);\n+\n+        MutableBigInteger sqrt = sr[0];\n+        sqrt.leftShift(blockBitLen);\n+        sqrt.add(q);\n+\n+        MutableBigInteger rem = u;\n+        rem.leftShift(blockBitLen);\n+        rem.add(new MutableBigInteger(getBlockZimmermann(0, len, limit, blockLen)));\n+        BigInteger qBig = q.toBigInteger();\n+        int rSign = rem.subtract(new MutableBigInteger(qBig.multiply(qBig).mag));\n+\n+        if (rSign == -1) {\n+            twiceSqrt = new MutableBigInteger(sqrt);\n+            twiceSqrt.leftShift(1);\n+\n+            rem.add(ONE);\n+            rem.subtract(twiceSqrt);\n+            sqrt.subtract(ONE);\n+        }\n+\n+        \/\/ Unnormalize\n+        if (excessInts != 0) {\n+            final int halfShift = excessInts << 4;\n+            if (!rem.isZero()) {\n+                final int s0Len = (halfShift + 31) >> 5;\n+                int[] s0Mag = sqrt.getBlockZimmermann(0, sqrt.intLen, sqrt.intLen, s0Len);\n+                if (s0Mag.length == s0Len && (halfShift & 31) != 0)\n+                    s0Mag[0] &= (1 << halfShift) - 1; \/\/ Remove excess bits\n+\n+                BigInteger s0 = new BigInteger(s0Mag, 1);\n+                if (s0.signum != 0) { \/\/ An optimization\n+                    rem.add(new MutableBigInteger(s0.shiftLeft(1).multiply(sqrt.toBigInteger()).mag));\n+                    rem.subtract(new MutableBigInteger(s0.multiply(s0).mag));\n+                }\n+                rem.intLen -= excessInts;\n+            }\n+            sqrt.rightShift(halfShift);\n+        }\n+        return new MutableBigInteger[] { sqrt, rem };\n+    }\n+\n+    private int[] getBlockZimmermann(int blockIndex, int len, int limit, int blockLen) {\n+        final int blockEnd = offset + len - blockIndex * blockLen;\n+        final int to = Math.min(blockEnd, offset + limit);\n+\n+        \/\/ Skip leading zeros\n+        int from;\n+        for (from = blockEnd - blockLen; from < to && value[from] == 0; from++);\n+\n+        if (from >= to)\n+            return new int[0];\n+\n+        int[] block = new int[blockEnd - from];\n+        System.arraycopy(value, from, block, 0, to - from);\n+        return block;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":189,"deletions":0,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.math;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.math.BigInteger;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class BigIntegerSquareRoot {\n+\n+    private BigInteger[] hugeArray, largeArray, smallArray;\n+    private static final int TESTSIZE = 1000;\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random(1123);\n+        int numbits = r.nextInt(16384);\n+\n+        hugeArray = new BigInteger[TESTSIZE]; \/*\n+         * Huge numbers larger than\n+         * MAX_LONG\n+         *\/\n+        largeArray = new BigInteger[TESTSIZE]; \/*\n+         * Large numbers less than\n+         * MAX_LONG but larger than\n+         * MAX_INT\n+         *\/\n+        smallArray = new BigInteger[TESTSIZE]; \/*\n+         * Small number less than\n+         * MAX_INT\n+         *\/\n+\n+        for (int i = 0; i < TESTSIZE; i++) {\n+            int value = Math.abs(r.nextInt());\n+\n+            hugeArray[i] = new BigInteger(\"\" + ((long) value + (long) Integer.MAX_VALUE)\n+                    + ((long) value + (long) Integer.MAX_VALUE));\n+            largeArray[i] = new BigInteger(\"\" + ((long) value + (long) Integer.MAX_VALUE));\n+            smallArray[i] = new BigInteger(\"\" + ((long) value \/ 1000));\n+        }\n+    }\n+\n+    \/** Test BigInteger.sqrtAndRemainder() with huge numbers larger than MAX_LONG *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testHugeSqrtAndRemainder(Blackhole bh) {\n+        for (BigInteger s : hugeArray) {\n+            bh.consume(s.sqrtAndRemainder());\n+        }\n+    }\n+\n+    \/** Test BigInteger.sqrtAndRemainder() with large numbers less than MAX_LONG but larger than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testLargeSqrtAndRemainder(Blackhole bh) {\n+        for (BigInteger s : largeArray) {\n+            bh.consume(s.sqrtAndRemainder());\n+        }\n+    }\n+\n+    \/** Test BigInteger.sqrtAndRemainder() with small numbers less than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testSmallSqrtAndRemainder(Blackhole bh) {\n+        for (BigInteger s : smallArray) {\n+            bh.consume(s.sqrtAndRemainder());\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegerSquareRoot.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"}]}