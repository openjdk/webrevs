{"files":[{"patch":"@@ -328,0 +328,1 @@\n+ * @author  Fabio Romano\n@@ -2143,11 +2144,0 @@\n-             * The following code draws on the algorithm presented in\n-             * \"Properly Rounded Variable Precision Square Root,\" Hull and\n-             * Abrham, ACM Transactions on Mathematical Software, Vol 11,\n-             * No. 3, September 1985, Pages 229-237.\n-             *\n-             * The BigDecimal computational model differs from the one\n-             * presented in the paper in several ways: first BigDecimal\n-             * numbers aren't necessarily normalized, second many more\n-             * rounding modes are supported, including UNNECESSARY, and\n-             * exact results can be requested.\n-             *\n@@ -2155,2 +2145,2 @@\n-             * first argument reduce the value to the numerical range\n-             * [1, 10) using the following relations:\n+             * first argument reduce the value to an integer\n+             * using the following relations:\n@@ -2162,1 +2152,1 @@\n-             * Then use Newton's iteration on the reduced value to compute\n+             * Then use BigInteger.sqrt() on the reduced value to compute\n@@ -2198,92 +2188,1 @@\n-            \/\/ precision for the cohort of the numerical value. To\n-            \/\/ allow binary floating-point hardware to be used to get\n-            \/\/ approximately a 15 digit approximation to the square\n-            \/\/ root, it is helpful to instead normalize this so that\n-            \/\/ the significand portion is to right of the decimal\n-            \/\/ point by roughly (scale() - precision() + 1).\n-\n-            \/\/ Now the precision \/ scale adjustment\n-            int scaleAdjust = 0;\n-            int scale = stripped.scale() - stripped.precision() + 1;\n-            if (scale % 2 == 0) {\n-                scaleAdjust = scale;\n-            } else {\n-                scaleAdjust = scale - 1;\n-            }\n-\n-            BigDecimal working = stripped.scaleByPowerOfTen(scaleAdjust);\n-\n-            assert  \/\/ Verify 0.1 <= working < 10\n-                ONE_TENTH.compareTo(working) <= 0 && working.compareTo(TEN) < 0;\n-\n-            \/\/ Use good ole' Math.sqrt to get the initial guess for\n-            \/\/ the Newton iteration, good to at least 15 decimal\n-            \/\/ digits. This approach does incur the cost of a\n-            \/\/\n-            \/\/ BigDecimal -> double -> BigDecimal\n-            \/\/\n-            \/\/ conversion cycle, but it avoids the need for several\n-            \/\/ Newton iterations in BigDecimal arithmetic to get the\n-            \/\/ working answer to 15 digits of precision. If many fewer\n-            \/\/ than 15 digits were needed, it might be faster to do\n-            \/\/ the loop entirely in BigDecimal arithmetic.\n-            \/\/\n-            \/\/ (A double value might have as many as 17 decimal\n-            \/\/ digits of precision; it depends on the relative density\n-            \/\/ of binary and decimal numbers at different regions of\n-            \/\/ the number line.)\n-            \/\/\n-            \/\/ (It would be possible to check for certain special\n-            \/\/ cases to avoid doing any Newton iterations. For\n-            \/\/ example, if the BigDecimal -> double conversion was\n-            \/\/ known to be exact and the rounding mode had a\n-            \/\/ low-enough precision, the post-Newton rounding logic\n-            \/\/ could be applied directly.)\n-\n-            BigDecimal guess = new BigDecimal(Math.sqrt(working.doubleValue()));\n-            int guessPrecision = 15;\n-            int originalPrecision = mc.getPrecision();\n-            int targetPrecision;\n-\n-            \/\/ If an exact value is requested, it must only need about\n-            \/\/ half of the input digits to represent since multiplying\n-            \/\/ an N digit number by itself yield a 2N-1 digit or 2N\n-            \/\/ digit result.\n-            if (originalPrecision == 0) {\n-                targetPrecision = stripped.precision()\/2 + 1;\n-            } else {\n-                \/*\n-                 * To avoid the need for post-Newton fix-up logic, in\n-                 * the case of half-way rounding modes, double the\n-                 * target precision so that the \"2p + 2\" property can\n-                 * be relied on to accomplish the final rounding.\n-                 *\/\n-                switch (mc.getRoundingMode()) {\n-                case HALF_UP:\n-                case HALF_DOWN:\n-                case HALF_EVEN:\n-                    targetPrecision = 2 * originalPrecision;\n-                    if (targetPrecision < 0) \/\/ Overflow\n-                        targetPrecision = Integer.MAX_VALUE - 2;\n-                    break;\n-\n-                default:\n-                    targetPrecision = originalPrecision;\n-                    break;\n-                }\n-            }\n-\n-            \/\/ When setting the precision to use inside the Newton\n-            \/\/ iteration loop, take care to avoid the case where the\n-            \/\/ precision of the input exceeds the requested precision\n-            \/\/ and rounding the input value too soon.\n-            BigDecimal approx = guess;\n-            int workingPrecision = working.precision();\n-            do {\n-                int tmpPrecision = Math.max(Math.max(guessPrecision, targetPrecision + 2),\n-                                           workingPrecision);\n-                MathContext mcTmp = new MathContext(tmpPrecision, RoundingMode.HALF_EVEN);\n-                \/\/ approx = 0.5 * (approx + fraction \/ approx)\n-                approx = ONE_HALF.multiply(approx.add(working.divide(approx, mcTmp), mcTmp));\n-                guessPrecision *= 2;\n-            } while (guessPrecision < targetPrecision + 2);\n+            \/\/ precision for the cohort of the numerical value.\n@@ -2292,6 +2191,11 @@\n-            RoundingMode targetRm = mc.getRoundingMode();\n-            if (targetRm == RoundingMode.UNNECESSARY || originalPrecision == 0) {\n-                RoundingMode tmpRm =\n-                    (targetRm == RoundingMode.UNNECESSARY) ? RoundingMode.DOWN : targetRm;\n-                MathContext mcTmp = new MathContext(targetPrecision, tmpRm);\n-                result = approx.scaleByPowerOfTen(-scaleAdjust\/2).round(mcTmp);\n+            if (mc.roundingMode == RoundingMode.UNNECESSARY || mc.precision == 0) {\n+                \/\/ Exact result requested\n+                BigInteger working = stripped.unscaledValue();\n+                if ((stripped.scale & 1) != 0)\n+                    working.multiply(BigInteger.TEN);\n+\n+                BigInteger[] sqrtRem = working.sqrtAndRemainder();\n+                \/\/ Use shift to round down if stripped.scale < 0\n+                result = new BigDecimal(sqrtRem[0], stripped.scale >> 1);\n+                if (mc.precision != 0)\n+                    result = result.round(new MathContext(mc.precision, RoundingMode.DOWN));\n@@ -2301,1 +2205,1 @@\n-                if (this.subtract(result.square()).compareTo(ZERO) != 0) {\n+                if (sqrtRem[1].signum != 0 || result.square().compareTo(this) != 0)\n@@ -2303,1 +2207,0 @@\n-                }\n@@ -2305,18 +2208,26 @@\n-                result = approx.scaleByPowerOfTen(-scaleAdjust\/2).round(mc);\n-\n-                switch (targetRm) {\n-                case DOWN:\n-                case FLOOR:\n-                    \/\/ Check if too big\n-                    if (result.square().compareTo(this) > 0) {\n-                        BigDecimal ulp = result.ulp();\n-                        \/\/ Adjust increment down in case of 1.0 = 10^0\n-                        \/\/ since the next smaller number is only 1\/10\n-                        \/\/ as far way as the next larger at exponent\n-                        \/\/ boundaries. Test approx and *not* result to\n-                        \/\/ avoid having to detect an arbitrary power\n-                        \/\/ of ten.\n-                        if (approx.compareTo(ONE) == 0) {\n-                            ulp = ulp.multiply(ONE_TENTH);\n-                        }\n-                        result = result.subtract(ulp);\n+                \/\/ To allow BigInteger.sqrt() to be used to get the square\n+                \/\/ root, it is necessary to normalize this so that\n+                \/\/ its precision is sufficient to get the square root\n+                \/\/ with the desired precision.\n+\n+                \/\/ To obtain a root with N digits,\n+                \/\/ the radicand must have at least 2*(N-1)+1 == 2*N-1 digits.\n+                final long minWorkingPrec = ((long) mc.precision << 1) - 1;\n+                long scale = minWorkingPrec - (stripped.precision() - stripped.scale());\n+                if ((scale & 1) != 0) \/\/ scale must be even\n+                    scale++;\n+\n+                final int scaleAdjust = (int) scale;\n+                if (scaleAdjust != scale)\n+                    throw new ArithmeticException(\"Overflow\");\n+\n+                BigDecimal working = stripped.scaleByPowerOfTen(scaleAdjust);\n+                BigInteger workingInt = working.toBigInteger();\n+                BigInteger[] sqrtRem = workingInt.sqrtAndRemainder();\n+                result = new BigDecimal(sqrtRem[0], scaleAdjust >> 1);\n+\n+                switch (mc.roundingMode) {\n+                case UP, CEILING:\n+                    \/\/ Check if remainder is non-zero\n+                    if (sqrtRem[1].signum != 0 || working.compareTo(new BigDecimal(workingInt)) != 0) {\n+                        result = result.add(result.ulp());\n@@ -2326,5 +2237,15 @@\n-                case UP:\n-                case CEILING:\n-                    \/\/ Check if too small\n-                    if (result.square().compareTo(this) < 0) {\n-                        result = result.add(result.ulp());\n+                case HALF_DOWN, HALF_UP, HALF_EVEN:\n+                    \/\/ x >= (s + 1\/2)^2\n+                    \/\/ <=> x >= s^2 + s + 1\/4\n+                    \/\/ <=> s^2 + r >= s^2 + s + 1\/4, if x == s^2 + r\n+                    \/\/ <=> r >= s + 1\/4\n+                    BigDecimal r = new BigDecimal(sqrtRem[1]).add(working.subtract(new BigDecimal(workingInt)));\n+                    int cmp = r.compareTo(new BigDecimal(sqrtRem[0]).add(valueOf(25, 2)));\n+                    boolean increment;\n+                    if (cmp > 0) {\n+                        increment = true;\n+                    } else if (cmp == 0) {\n+                        increment = mc.roundingMode == RoundingMode.HALF_UP\n+                                || mc.roundingMode == RoundingMode.HALF_EVEN && sqrtRem[0].testBit(0);\n+                    } else {\n+                        increment = false;\n@@ -2332,1 +2253,0 @@\n-                    break;\n@@ -2334,0 +2254,3 @@\n+                    if (increment)\n+                        result = result.add(result.ulp());\n+                    break;\n@@ -2335,10 +2258,0 @@\n-                    \/\/ No additional work, rely on \"2p + 2\" property\n-                    \/\/ for correct rounding. Alternatively, could\n-                    \/\/ instead run the Newton iteration to around p\n-                    \/\/ digits and then do tests and fix-ups on the\n-                    \/\/ rounded value. One possible set of tests and\n-                    \/\/ fix-ups is given in the Hull and Abrham paper;\n-                    \/\/ however, additional half-way cases can occur\n-                    \/\/ for BigDecimal given the more varied\n-                    \/\/ combinations of input and output precisions\n-                    \/\/ supported.\n@@ -2346,0 +2259,3 @@\n+                \/\/ case DOWN\n+                \/\/ case FLOOR\n+                \/\/ result is already rounded down\n@@ -2347,1 +2263,0 @@\n-\n@@ -2363,1 +2278,1 @@\n-                        new MathContext(originalPrecision, RoundingMode.UNNECESSARY));\n+                        new MathContext(mc.precision, RoundingMode.UNNECESSARY));\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":65,"deletions":150,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -2722,1 +2722,1 @@\n-        if (this.signum < 0) {\n+        if (this.signum < 0)\n@@ -2724,1 +2724,0 @@\n-        }\n@@ -2726,1 +2725,1 @@\n-        return new MutableBigInteger(this.mag).sqrt().toBigInteger();\n+        return new MutableBigInteger(this.mag).sqrtRem(false)[0].toBigInteger();\n@@ -2745,4 +2744,5 @@\n-        BigInteger s = sqrt();\n-        BigInteger r = this.subtract(s.square());\n-        assert r.compareTo(BigInteger.ZERO) >= 0;\n-        return new BigInteger[] {s, r};\n+        if (this.signum < 0)\n+            throw new ArithmeticException(\"Negative BigInteger\");\n+\n+        MutableBigInteger[] sqrtRem = new MutableBigInteger(this.mag).sqrtRem(true);\n+        return new BigInteger[] { sqrtRem[0].toBigInteger(), sqrtRem[1].toBigInteger() };\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+ * @author  Fabio Romano\n@@ -112,0 +113,19 @@\n+        init(val);\n+    }\n+\n+    \/**\n+     * Construct a new MutableBigInteger with a magnitude specified by\n+     * the long val.\n+     *\/\n+    MutableBigInteger(long val) {\n+        if ((val & LONG_MASK) == val) {\n+            init((int) val);\n+        } else {\n+            value = new int[2];\n+            intLen = 2;\n+            value[0] = (int) (val >>> 32);\n+            value[1] = (int) val;\n+        }\n+    }\n+\n+    private void init(int val) {\n@@ -263,0 +283,1 @@\n+     * Assumes no leading unnecessary zeros.\n@@ -288,0 +309,1 @@\n+     * Assumes no leading unnecessary zeros.\n@@ -1885,0 +1907,192 @@\n+    \/**\n+     * Calculate the integer square root {@code floor(sqrt(this))} and the remainder\n+     * if needed, where {@code sqrt(.)} denotes the mathematical square root.\n+     * The contents of {@code this} are <b>not<\/b> changed.\n+     * The value of {@code this} is assumed to be non-negative.\n+     * @throws ArithmeticException if the value returned by {@code bitLength()}\n+     * overflows the range of {@code int}.\n+     * @return the integer square root of {@code this} and the remainder if needed\n+     *\/\n+    MutableBigInteger[] sqrtRem(boolean needRemainder) {\n+        \/\/ Special cases.\n+        if (this.isZero()) {\n+            return new MutableBigInteger[] {\n+                    new MutableBigInteger(), needRemainder ? new MutableBigInteger() : null\n+            };\n+        } else if (this.intLen <= 2) {\n+            final long x = this.toLong(); \/\/ unsigned\n+\n+            if (this.intLen == 1) {\n+                if (x < 4) \/\/ result is unity\n+                    return new MutableBigInteger[] {\n+                            ONE, needRemainder ? new MutableBigInteger((int) (x - 1)) : null\n+                    };\n+\n+                long s = (long) Math.sqrt(x); \/\/ Math.sqrt is exact\n+                return new MutableBigInteger[] {\n+                        new MutableBigInteger((int) s),\n+                        needRemainder ? new MutableBigInteger((int) (x - s * s)) : null\n+                };\n+            }\n+\n+            \/\/ Initial estimate is the square root of the unsigned long value.\n+            long s = (long) Math.sqrt(x > 0 ? x : x + 0x1p64);\n+            if (s > LONG_MASK \/\/ avoid overflow of s * s\n+                    || Long.compareUnsigned(x, s * s) < 0) {\n+                s--;\n+            }\n+\n+            return new MutableBigInteger[] {\n+                    new MutableBigInteger((int) s),\n+                    needRemainder ? new MutableBigInteger(x - s * s) : null\n+            };\n+        }\n+\n+        long bitLength = this.bitLength();\n+        if (bitLength != (int) bitLength)\n+            throw new ArithmeticException(\"bitLength() integer overflow\");\n+\n+        \/\/ Normalize\n+        MutableBigInteger x = this;\n+        int shift = Integer.numberOfLeadingZeros(x.value[x.offset]) & ~1; \/\/ shift must be even\n+        if (shift != 0) {\n+            x = new MutableBigInteger(x);\n+            x.primitiveLeftShift(shift);\n+        }\n+\n+        MutableBigInteger[] sqrtRem = x.sqrtRemZimmermann(x.intLen, needRemainder);\n+\n+        \/\/ Unnormalize\n+        if (shift != 0) {\n+            final int halfShift = shift >> 1;\n+            if (needRemainder && !sqrtRem[1].isZero()) {\n+                final int s0 = sqrtRem[0].value[sqrtRem[0].offset + sqrtRem[0].intLen - 1]\n+                        & (-1 >>> -halfShift); \/\/ Remove excess bits\n+                if (s0 != 0) { \/\/ An optimization\n+                    \/\/ s0 is at most 15 bit long\n+                    MutableBigInteger doubleProd = new MutableBigInteger();\n+                    sqrtRem[0].mul(s0 << 1, doubleProd);\n+\n+                    sqrtRem[1].add(doubleProd);\n+                    sqrtRem[1].subtract(new MutableBigInteger(s0 * s0));\n+                }\n+                sqrtRem[1].primitiveRightShift(shift);\n+            }\n+            sqrtRem[0].primitiveRightShift(halfShift);\n+        }\n+        return sqrtRem;\n+    }\n+\n+    \/**\n+     * Assume {@code 2 <= len <= intLen && Integer.numberOfLeadingZeros(value[offset]) <= 1}\n+     * @implNote The implementation is based on Zimmermann's works available\n+     * <a href=\"https:\/\/inria.hal.science\/inria-00072854\/en\/\">  here<\/a> and\n+     * <a href=\"https:\/\/www.researchgate.net\/publication\/220532560_A_proof_of_GMP_square_root\">  here<\/a>\n+     *\/\n+    private MutableBigInteger[] sqrtRemZimmermann(int len, boolean needRemainder) {\n+        if (len == 2) { \/\/ Base case\n+            long x = ((value[offset] & LONG_MASK) << 32) | (value[offset + 1] & LONG_MASK);\n+            long s = (long) Math.sqrt(x > 0 ? x : x + 0x1p64);\n+            if (s > LONG_MASK || Long.compareUnsigned(x, s * s) < 0)\n+                s--;\n+\n+            \/\/ Allocate sufficient space to hold the normalized final square root\n+            MutableBigInteger sqrt = new MutableBigInteger(new int[(intLen + ((-intLen) & 3) + 1) >> 1]);\n+\n+            \/\/ Place the partial square root\n+            sqrt.intLen = 1;\n+            sqrt.value[0] = (int) s;\n+\n+            \/\/ The first invocation is never a base case, so the remainder is needed\n+            return new MutableBigInteger[] { sqrt, new MutableBigInteger(x - s * s) };\n+        }\n+\n+        \/\/ Recursive step (len >= 3)\n+\n+        \/\/ Normalize\n+        final int limit = len;\n+        final int excessInts = (-len) & 3;\n+        len += excessInts; \/\/ len must be a multiple of 4\n+\n+        MutableBigInteger[] sr = sqrtRemZimmermann(len >> 1, true); \/\/ Recursive invocation\n+\n+        final int blockLen = len >> 2, blockBitLen = blockLen << 5;\n+        MutableBigInteger dividend = sr[1];\n+        dividend.leftShift(blockBitLen);\n+        dividend.add(getBlockZimmermann(1, len, limit, blockLen));\n+        MutableBigInteger twiceSqrt = new MutableBigInteger(sr[0]);\n+        twiceSqrt.leftShift(1);\n+        MutableBigInteger q = new MutableBigInteger();\n+        MutableBigInteger u = dividend.divide(twiceSqrt, q);\n+\n+        MutableBigInteger sqrt = sr[0];\n+        sqrt.leftShift(blockBitLen);\n+        sqrt.add(q);\n+\n+        MutableBigInteger chunk = u;\n+        chunk.leftShift(blockBitLen);\n+        chunk.add(getBlockZimmermann(0, len, limit, blockLen));\n+        BigInteger qBig = q.toBigInteger(); \/\/ Cast to BigInteger to use fast multiplication\n+        MutableBigInteger qSqr = new MutableBigInteger(qBig.multiply(qBig).mag);\n+\n+        MutableBigInteger rem;\n+        if (needRemainder) {\n+            rem = chunk;\n+            if (rem.subtract(qSqr) == -1) {\n+                twiceSqrt = new MutableBigInteger(sqrt);\n+                twiceSqrt.leftShift(1);\n+\n+                rem.add(ONE);\n+                rem.subtract(twiceSqrt);\n+                sqrt.subtract(ONE);\n+            }\n+        } else {\n+            rem = null;\n+            if (chunk.compare(qSqr) == -1)\n+                sqrt.subtract(ONE);\n+        }\n+\n+        \/\/ Unnormalize\n+        if (excessInts != 0) {\n+            final int halfShift = excessInts << 4;\n+            if (needRemainder && !rem.isZero()) {\n+                final int s0Ints = (halfShift + 31) >> 5;\n+                MutableBigInteger s0 = sqrt.getBlockZimmermann(0, sqrt.intLen, sqrt.intLen, s0Ints);\n+                if (s0.intLen == s0Ints)\n+                    s0.value[0] &= -1 >>> -halfShift; \/\/ Remove excess bits\n+\n+                if (!s0.isZero()) { \/\/ An optimization\n+                    MutableBigInteger twiceS0 = new MutableBigInteger(s0);\n+                    twiceS0.leftShift(1);\n+                    MutableBigInteger doubleProd = new MutableBigInteger();\n+                    twiceS0.multiply(sqrt, doubleProd); \/\/ Use classic multiplication\n+\n+                    MutableBigInteger s0Sqr = new MutableBigInteger();\n+                    s0.multiply(s0, s0Sqr);\n+\n+                    rem.add(doubleProd);\n+                    rem.subtract(s0Sqr);\n+                }\n+                rem.intLen -= excessInts;\n+            }\n+            sqrt.rightShift(halfShift);\n+        }\n+        return new MutableBigInteger[] { sqrt, rem };\n+    }\n+\n+    private MutableBigInteger getBlockZimmermann(int blockIndex, int len, int limit, int blockLen) {\n+        final int blockEnd = offset + len - blockIndex * blockLen;\n+        final int to = Math.min(blockEnd, offset + limit);\n+\n+        \/\/ Skip leading zeros\n+        int from;\n+        for (from = blockEnd - blockLen; from < to && value[from] == 0; from++);\n+\n+        if (from >= to)\n+            return new MutableBigInteger();\n+\n+        int[] block = new int[blockEnd - from];\n+        System.arraycopy(value, from, block, 0, to - from);\n+        return new MutableBigInteger(block);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.math;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.math.BigInteger;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class BigIntegerSquareRoot {\n+\n+    private BigInteger[] hugeArray, largeArray, smallArray;\n+    private static final int TESTSIZE = 1000;\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random(1123);\n+        int numbits = r.nextInt(16384);\n+\n+        hugeArray = new BigInteger[TESTSIZE]; \/*\n+         * Huge numbers larger than\n+         * MAX_LONG\n+         *\/\n+        largeArray = new BigInteger[TESTSIZE]; \/*\n+         * Large numbers less than\n+         * MAX_LONG but larger than\n+         * MAX_INT\n+         *\/\n+        smallArray = new BigInteger[TESTSIZE]; \/*\n+         * Small number less than\n+         * MAX_INT\n+         *\/\n+\n+        for (int i = 0; i < TESTSIZE; i++) {\n+            int value = Math.abs(r.nextInt());\n+\n+            hugeArray[i] = new BigInteger(\"\" + ((long) value + (long) Integer.MAX_VALUE)\n+                    + ((long) value + (long) Integer.MAX_VALUE));\n+            largeArray[i] = new BigInteger(\"\" + ((long) value + (long) Integer.MAX_VALUE));\n+            smallArray[i] = new BigInteger(\"\" + ((long) value \/ 1000));\n+        }\n+    }\n+\n+    \/** Test BigInteger.sqrtAndRemainder() with huge numbers larger than MAX_LONG *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testHugeSqrtAndRemainder(Blackhole bh) {\n+        for (BigInteger s : hugeArray) {\n+            bh.consume(s.sqrtAndRemainder());\n+        }\n+    }\n+\n+    \/** Test BigInteger.sqrtAndRemainder() with large numbers less than MAX_LONG but larger than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testLargeSqrtAndRemainder(Blackhole bh) {\n+        for (BigInteger s : largeArray) {\n+            bh.consume(s.sqrtAndRemainder());\n+        }\n+    }\n+\n+    \/** Test BigInteger.sqrtAndRemainder() with small numbers less than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testSmallSqrtAndRemainder(Blackhole bh) {\n+        for (BigInteger s : smallArray) {\n+            bh.consume(s.sqrtAndRemainder());\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegerSquareRoot.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"}]}