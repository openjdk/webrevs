{"files":[{"patch":"@@ -2726,1 +2726,1 @@\n-        return new MutableBigInteger(this.mag).sqrt().toBigInteger();\n+        return new MutableBigInteger(this.mag).sqrtRem(false)[0].toBigInteger();\n@@ -2745,4 +2745,6 @@\n-        BigInteger s = sqrt();\n-        BigInteger r = this.subtract(s.square());\n-        assert r.compareTo(BigInteger.ZERO) >= 0;\n-        return new BigInteger[] {s, r};\n+        if (this.signum < 0) {\n+            throw new ArithmeticException(\"Negative BigInteger\");\n+        }\n+\n+        MutableBigInteger[] sqrtRem = new MutableBigInteger(this.mag).sqrtRem(true);\n+        return new BigInteger[] { sqrtRem[0].toBigInteger(), sqrtRem[1].toBigInteger() };\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -112,3 +112,20 @@\n-        value = new int[1];\n-        intLen = 1;\n-        value[0] = val;\n+        init(val);\n+    }\n+\n+    \/**\n+     * Construct a new MutableBigInteger with a magnitude specified by\n+     * the long val.\n+     *\/\n+    MutableBigInteger(long val) {\n+        int hi = (int) (val >>> 32);\n+        if (hi == 0) {\n+            init((int) val);\n+        } else {\n+            value = new int[] { hi, (int) val };\n+            intLen = 2;\n+        }\n+    }\n+\n+    private void init(int val) {\n+        value = new int[] { val };\n+        intLen = val != 0 ? 1 : 0;\n@@ -263,0 +280,1 @@\n+     * Assumes no leading unnecessary zeros.\n@@ -288,0 +306,1 @@\n+     * Assumes no leading unnecessary zeros.\n@@ -914,0 +933,52 @@\n+    \/**\n+     * Shifts {@code this} of {@code n} ints to the left and adds {@code addend}.\n+     * Assumes {@code n > 0} for speed.\n+     *\/\n+    void shiftAdd(MutableBigInteger addend, int n) {\n+        \/\/ Fast cases\n+        if (addend.intLen <= n) {\n+            shiftAddDisjoint(addend, n);\n+        } else if (intLen == 0) {\n+            copyValue(addend);\n+        } else {\n+            leftShift(n << 5);\n+            add(addend);\n+        }\n+    }\n+\n+    \/**\n+     * Shifts {@code this} of {@code n} ints to the left and adds {@code addend}.\n+     * Assume {@code addend.intLen <= n}.\n+     *\/\n+    void shiftAddDisjoint(MutableBigInteger addend, int n) {\n+        if (intLen == 0) { \/\/ Avoid unnormal values\n+            copyValue(addend);\n+            return;\n+        }\n+\n+        int[] res;\n+        final int resLen = intLen + n, resOffset;\n+        if (resLen > value.length) {\n+            res = new int[resLen];\n+            System.arraycopy(value, offset, res, 0, intLen);\n+            resOffset = 0;\n+        } else {\n+            res = value;\n+            if (offset + resLen > value.length) {\n+                System.arraycopy(value, offset, res, 0, intLen);\n+                resOffset = 0;\n+            } else {\n+                resOffset = offset;\n+            }\n+            \/\/ Clear words where necessary\n+            if (addend.intLen < n)\n+                Arrays.fill(res, resOffset + intLen, resOffset + resLen - addend.intLen, 0);\n+        }\n+\n+        System.arraycopy(addend.value, addend.offset, res, resOffset + resLen - addend.intLen, addend.intLen);\n+\n+        value = res;\n+        offset = resOffset;\n+        intLen = resLen;\n+    }\n+\n@@ -1006,0 +1077,1 @@\n+     * Assume {@code intLen > 0}\n@@ -1885,0 +1957,203 @@\n+    \/**\n+     * Calculate the integer square root {@code floor(sqrt(this))} and the remainder\n+     * if needed, where {@code sqrt(.)} denotes the mathematical square root.\n+     * The contents of {@code this} are <em>not<\/em> changed.\n+     * The value of {@code this} is assumed to be non-negative.\n+     *\n+     * @return the integer square root of {@code this} and the remainder if needed\n+     * @throws ArithmeticException if the value returned by {@code bitLength()}\n+     * overflows the range of {@code int}.\n+     *\/\n+    MutableBigInteger[] sqrtRem(boolean needRemainder) {\n+        \/\/ Special cases.\n+        if (this.intLen <= 2) {\n+            final long x = this.toLong(); \/\/ unsigned\n+            long s = ulongSqrt(x);\n+\n+            return new MutableBigInteger[] {\n+                    new MutableBigInteger((int) s),\n+                    needRemainder ? new MutableBigInteger(x - s * s) : null\n+            };\n+        }\n+\n+        long bitLength = this.bitLength();\n+        if (bitLength != (int) bitLength)\n+            throw new ArithmeticException(\"bitLength() integer overflow\");\n+\n+        \/\/ Normalize\n+        MutableBigInteger x = this;\n+        int shift = Integer.numberOfLeadingZeros(x.value[x.offset]) & ~1; \/\/ shift must be even\n+        if (shift != 0) {\n+            x = new MutableBigInteger(x);\n+            x.primitiveLeftShift(shift);\n+        }\n+\n+        MutableBigInteger[] sqrtRem = x.sqrtRemZimmermann(x.intLen, needRemainder);\n+\n+        \/\/ Unnormalize\n+        if (shift != 0) {\n+            final int halfShift = shift >> 1;\n+            if (needRemainder && !sqrtRem[1].isZero()) {\n+                final int s0 = sqrtRem[0].value[sqrtRem[0].offset + sqrtRem[0].intLen - 1]\n+                        & (-1 >>> -halfShift); \/\/ Remove excess bits\n+                if (s0 != 0) { \/\/ An optimization\n+                    \/\/ s0 is at most 15 bit long\n+                    MutableBigInteger doubleProd = new MutableBigInteger();\n+                    sqrtRem[0].mul(s0 << 1, doubleProd);\n+\n+                    sqrtRem[1].add(doubleProd);\n+                    sqrtRem[1].subtract(new MutableBigInteger(s0 * s0));\n+                }\n+                sqrtRem[1].primitiveRightShift(shift);\n+            }\n+            sqrtRem[0].primitiveRightShift(halfShift);\n+        }\n+        return sqrtRem;\n+    }\n+\n+    private static long ulongSqrt(long x) {\n+        \/* For every long value s in [0, 2^32) such that x == s * s,\n+         * it is true that s - 1 <= (long) Math.sqrt(x >= 0 ? x : x + 0x1p64) <= s,\n+         * and if x == 2^64 - 1, then (long) Math.sqrt(x >= 0 ? x : x + 0x1p64) == 2^32.\n+         * Since both cast to long and `Math.sqrt()` are (weakly) increasing,\n+         * this means that the value returned by Math.sqrt()\n+         * for a long value in the range [0, 2^64) is either correct,\n+         * or rounded up\/down by one if the value is too high\n+         * and too close to a perfect square.\n+         *\/\n+        long s = (long) Math.sqrt(x >= 0 ? x : x + 0x1p64);\n+        long s2 = s * s;  \/\/ overflows iff s == 2^32\n+        return s > LONG_MASK || Long.compareUnsigned(x, s2) < 0\n+                ? s - 1\n+                : (Long.compareUnsigned(x, s2 + (s << 1)) <= 0 \/\/ x <= (s + 1)^2 - 1, does not overflow\n+                        ? s\n+                        : s + 1);\n+    }\n+\n+    \/**\n+     * Assume {@code 2 <= len <= intLen && Integer.numberOfLeadingZeros(value[offset]) <= 1}\n+     * @implNote The implementation is based on Zimmermann's works available\n+     * <a href=\"https:\/\/inria.hal.science\/inria-00072854\/en\/\">  here<\/a> and\n+     * <a href=\"https:\/\/www.researchgate.net\/publication\/220532560_A_proof_of_GMP_square_root\">  here<\/a>\n+     *\/\n+    private MutableBigInteger[] sqrtRemZimmermann(int len, boolean needRemainder) {\n+        if (len == 2) { \/\/ Base case\n+            long x = ((value[offset] & LONG_MASK) << 32) | (value[offset + 1] & LONG_MASK);\n+            long s = ulongSqrt(x);\n+\n+            \/\/ Allocate sufficient space to hold the normalized final square root\n+            \/\/ (4 * ceil(intLen \/ 4)) \/ 2 == (intLen + ((-intLen) & 3)) >> 1\n+            MutableBigInteger sqrt = new MutableBigInteger(new int[(intLen + ((-intLen) & 3)) >> 1]);\n+\n+            \/\/ Place the partial square root\n+            sqrt.intLen = 1;\n+            sqrt.value[0] = (int) s;\n+\n+            \/\/ The first invocation is never a base case, so the remainder is needed\n+            return new MutableBigInteger[] { sqrt, new MutableBigInteger(x - s * s) };\n+        }\n+\n+        \/\/ Recursive step (len >= 3)\n+\n+        \/\/ Normalize\n+        \/* For speed, the normalization is performed only \"logically\",\n+         * which means that the contents of the input are not changed,\n+         * but only its logical length, which is stored in the parameter len.\n+         * The length is normalized to a mutiple of 4 because, in this way,\n+         * the input can be always split in blocks of words without twiddling with bits.\n+         *\/\n+        final int limit = offset + len;\n+        final int excessInts = (-len) & 3; \/\/ Compute 4 * ceil(len \/ 4) - len\n+        len += excessInts; \/\/ len must be a multiple of 4\n+\n+        MutableBigInteger[] sr = sqrtRemZimmermann(len >> 1, true); \/\/ Recursive invocation\n+\n+        final int blockLen = len >> 2;\n+        MutableBigInteger dividend = sr[1];\n+        dividend.shiftAddDisjoint(getBlockZimmermann(1, len, limit, blockLen), blockLen);\n+        MutableBigInteger twiceSqrt = new MutableBigInteger(sr[0]);\n+        twiceSqrt.leftShift(1);\n+        MutableBigInteger q = new MutableBigInteger();\n+        MutableBigInteger u = dividend.divide(twiceSqrt, q);\n+\n+        MutableBigInteger sqrt = sr[0];\n+        sqrt.shiftAdd(q, blockLen);\n+\n+        \/\/ Corresponds to ub + a_0 in the paper\n+        u.shiftAddDisjoint(getBlockZimmermann(0, len, limit, blockLen), blockLen);\n+        BigInteger qBig = q.toBigInteger(); \/\/ Cast to BigInteger to use fast multiplication\n+        MutableBigInteger qSqr = new MutableBigInteger(qBig.multiply(qBig).mag);\n+\n+        MutableBigInteger rem;\n+        if (needRemainder) {\n+            rem = u;\n+            if (rem.subtract(qSqr) == -1) {\n+                twiceSqrt = new MutableBigInteger(sqrt);\n+                twiceSqrt.leftShift(1);\n+\n+                rem.add(ONE);\n+                rem.subtract(twiceSqrt);\n+                sqrt.subtract(ONE);\n+            }\n+        } else {\n+            rem = null;\n+            if (u.compare(qSqr) == -1)\n+                sqrt.subtract(ONE);\n+        }\n+\n+        \/\/ Unnormalize\n+        if (excessInts != 0) {\n+            final int halfShift = excessInts << 4;\n+            if (needRemainder && !rem.isZero()) {\n+                final int s0Ints = (halfShift + 31) >> 5;\n+                MutableBigInteger s0 = sqrt.getBlockZimmermann(0, sqrt.intLen, sqrt.offset + sqrt.intLen, s0Ints);\n+                if (s0.intLen == s0Ints)\n+                    s0.value[0] &= -1 >>> -halfShift; \/\/ Remove excess bits\n+\n+                if (!s0.isZero()) { \/\/ MutableBigInteger.multiply() assumes intLen != 0\n+                    MutableBigInteger twiceS0 = new MutableBigInteger(s0);\n+                    twiceS0.leftShift(1);\n+                    MutableBigInteger doubleProd = new MutableBigInteger();\n+                    twiceS0.multiply(sqrt, doubleProd); \/\/ Use classic multiplication\n+\n+                    MutableBigInteger s0Sqr = new MutableBigInteger();\n+                    s0.multiply(s0, s0Sqr);\n+\n+                    rem.add(doubleProd);\n+                    rem.subtract(s0Sqr);\n+                }\n+                rem.intLen -= excessInts;\n+            }\n+            sqrt.rightShift(halfShift);\n+        }\n+        return new MutableBigInteger[] { sqrt, rem };\n+    }\n+\n+    \/**\n+     * Returns a {@code MutableBigInteger} obtained by taking {@code blockLen} ints from\n+     * {@code this} number, ending at {@code blockIndex*blockLen} (exclusive).<br\/>\n+     * Used in Zimmermann's square root.\n+     * @param blockIndex the block index, starting from the lowest\n+     * @param len the logical length of the input value in units of 32 bits\n+     * @param limit the offset which is the end of valid words in the input value\n+     * @param blockLen the length of the block in units of 32 bits\n+     *\n+     * @return a {@code MutableBigInteger} obtained by taking {@code blockLen} ints from\n+     * {@code this} number, ending at {@code blockIndex*blockLen} (exclusive).\n+     *\/\n+    private MutableBigInteger getBlockZimmermann(int blockIndex, int len, int limit, int blockLen) {\n+        final int blockEnd = offset + len - blockIndex * blockLen;\n+        final int to = Math.min(blockEnd, limit);\n+\n+        \/\/ Skip leading zeros\n+        int from;\n+        for (from = blockEnd - blockLen; from < to && value[from] == 0; from++);\n+\n+        if (from >= to)\n+            return new MutableBigInteger();\n+\n+        int[] block = new int[blockEnd - from];\n+        System.arraycopy(value, from, block, 0, to - from);\n+        return new MutableBigInteger(block);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":278,"deletions":3,"binary":false,"changes":281,"status":"modified"},{"patch":"@@ -296,0 +296,20 @@\n+    private static void perfectSquaresLong() {\n+        \/* For every long value n in [0, 2^32) such that x == n * n,\n+         * n - 1 <= (long) Math.sqrt(x >= 0 ? x : x + 0x1p64) <= n\n+         * must be true.\n+         *\/\n+        int failCount = 0;\n+\n+        long limit = 1L << 32;\n+        for (long n = 0; n < limit; n++) {\n+            long x = n * n;\n+            long s = (long) Math.sqrt(x >= 0 ? x : x + 0x1p64);\n+            if (!(s == n || s == n - 1)) {\n+                failCount++;\n+                System.err.println(s + \"^2 != \" + x + \" && (\" + s + \"+1)^2 != \" + x);\n+            }\n+        }\n+\n+        report(\"perfectSquaresLong\", failCount);\n+    }\n+\n@@ -298,0 +318,1 @@\n+        perfectSquaresLong();\n","filename":"test\/jdk\/java\/math\/BigInteger\/BigIntegerTest.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.math;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.math.BigInteger;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class BigIntegerSquareRoot {\n+\n+    private BigInteger[] hugeArray, largeArray, smallArray;\n+    private static final int TESTSIZE = 1000;\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random(1123);\n+        int numbits = r.nextInt(16384);\n+\n+        hugeArray = new BigInteger[TESTSIZE]; \/*\n+         * Huge numbers larger than\n+         * MAX_LONG\n+         *\/\n+        largeArray = new BigInteger[TESTSIZE]; \/*\n+         * Large numbers less than\n+         * MAX_LONG but larger than\n+         * MAX_INT\n+         *\/\n+        smallArray = new BigInteger[TESTSIZE]; \/*\n+         * Small number less than\n+         * MAX_INT\n+         *\/\n+\n+        for (int i = 0; i < TESTSIZE; i++) {\n+            int value = Math.abs(r.nextInt());\n+\n+            hugeArray[i] = new BigInteger(\"\" + ((long) value + (long) Integer.MAX_VALUE)\n+                    + ((long) value + (long) Integer.MAX_VALUE));\n+            largeArray[i] = new BigInteger(\"\" + ((long) value + (long) Integer.MAX_VALUE));\n+            smallArray[i] = new BigInteger(\"\" + ((long) value \/ 1000));\n+        }\n+    }\n+\n+    \/** Test BigInteger.sqrtAndRemainder() with huge numbers larger than MAX_LONG *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testHugeSqrtAndRemainder(Blackhole bh) {\n+        for (BigInteger s : hugeArray) {\n+            bh.consume(s.sqrtAndRemainder());\n+        }\n+    }\n+\n+    \/** Test BigInteger.sqrtAndRemainder() with large numbers less than MAX_LONG but larger than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testLargeSqrtAndRemainder(Blackhole bh) {\n+        for (BigInteger s : largeArray) {\n+            bh.consume(s.sqrtAndRemainder());\n+        }\n+    }\n+\n+    \/** Test BigInteger.sqrtAndRemainder() with small numbers less than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testSmallSqrtAndRemainder(Blackhole bh) {\n+        for (BigInteger s : smallArray) {\n+            bh.consume(s.sqrtAndRemainder());\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegerSquareRoot.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"}]}