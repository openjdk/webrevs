{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.math.DoubleConsts;\n@@ -1906,8 +1907,12 @@\n-            return new MutableBigInteger[] { this, this };\n-        } else if (this.intLen == 1) {\n-            MutableBigInteger r = new MutableBigInteger(this);\n-\n-            final long val = this.value[offset] & LONG_MASK;\n-            if (val < 4) { \/\/ result is unity\n-                r.subtract(ONE);\n-                return new MutableBigInteger[] { ONE, r };\n+            return new MutableBigInteger[] { new MutableBigInteger(), new MutableBigInteger() };\n+        } else if (this.intLen <= 2) {\n+            final long x = this.toLong(); \/\/ unsigned\n+\n+            if (this.intLen == 1) {\n+                if (x < 4) \/\/ result is unity\n+                    return new MutableBigInteger[] { ONE, new MutableBigInteger((int) (x - 1)) };\n+\n+                long s = (long) Math.sqrt(x); \/\/ Math.sqrt is exact\n+                return new MutableBigInteger[] {\n+                        new MutableBigInteger((int) s), new MutableBigInteger((int) (x - s * s))\n+                };\n@@ -1916,3 +1921,13 @@\n-            int s = (int) Math.sqrt(val); \/\/ Math.sqrt is exact\n-            r.subtract(new MutableBigInteger(s * s));\n-            return new MutableBigInteger[] { new MutableBigInteger(s), r };\n+            \/\/ Initial estimate is the square root of the unsigned long value.\n+            long s = (long) Math.sqrt(x > 0 ? x : x + 0x1p64);\n+            if (s > LONG_MASK \/\/ avoid overflow of s * s\n+                    || Long.compareUnsigned(x, s * s) < 0) {\n+                s--;\n+            }\n+\n+            long r = x - s * s;\n+            return new MutableBigInteger[] {\n+                    new MutableBigInteger((int) s),\n+                    r <= LONG_MASK ? new MutableBigInteger((int) r)\n+                    : new MutableBigInteger(new int[] { 1,  (int) r})\n+            };\n@@ -1961,12 +1976,3 @@\n-            long hi = value[offset] & LONG_MASK, lo = value[offset + 1] & LONG_MASK;\n-            long s = (long) Math.sqrt(hi); \/\/ Math.sqrt is exact\n-            long r = hi - s * s;\n-\n-            final long dividend = (r << 16) | (lo >> 16), divisor = s << 1;\n-            final long q = dividend \/ divisor;\n-            final long u = dividend % divisor;\n-            s = (s << 16) + q;\n-            r = ((u << 16) | (lo & 0xffffL)) - q * q;\n-\n-            if (r < 0) {\n-                r += (s << 1) - 1;\n+            long x = ((value[offset] & LONG_MASK) << 32) | (value[offset + 1] & LONG_MASK);\n+            long s = (long) Math.sqrt(x > 0 ? x : x + 0x1p64);\n+            if (s > LONG_MASK || Long.compareUnsigned(x, s * s) < 0)\n@@ -1974,1 +1980,0 @@\n-            }\n@@ -1976,1 +1981,3 @@\n-            \/\/ Allocate sufficient space to hold the normalized final result\n+            long r = x - s * s;\n+\n+            \/\/ Allocate sufficient space to hold the normalized final square root\n@@ -1979,1 +1986,1 @@\n-            \/\/ Place the partial result\n+            \/\/ Place the partial square root\n@@ -1983,3 +1990,4 @@\n-            return new MutableBigInteger[] { sqrt, (r & LONG_MASK) == r\n-                    ? new MutableBigInteger((int) r)\n-                    : new MutableBigInteger(new int[] { 1,  (int) r}) };\n+            return new MutableBigInteger[] { sqrt,\n+                    r <= LONG_MASK ? new MutableBigInteger((int) r)\n+                    : new MutableBigInteger(new int[] { 1,  (int) r})\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":37,"deletions":29,"binary":false,"changes":66,"status":"modified"}]}