{"files":[{"patch":"@@ -2018,1 +2018,2 @@\n-         * This means that the value returned by Math.sqrt()\n+         * Since both cast to long and `Math.sqrt()` are (weakly) increasing,\n+         * this means that the value returned by Math.sqrt()\n@@ -2024,9 +2025,6 @@\n-        if (s > LONG_MASK \/\/ avoid overflow of s * s\n-                || Long.compareUnsigned(x, s * s) < 0) {\n-            s--;\n-        } else if (s < LONG_MASK) { \/\/ avoid overflow of (s + 1) * (s + 1)\n-            long s1 = s + 1;\n-            if (Long.compareUnsigned(x, s1 * s1) >= 0)\n-                s = s1;\n-        }\n-        return s;\n+        long s2 = s * s;  \/\/ overflows iff s == 2^32\n+        return s > LONG_MASK || Long.compareUnsigned(x, s2) < 0\n+                ? s - 1\n+                : (Long.compareUnsigned(x, s2 + (s << 1)) <= 0 \/\/ x <= (s + 1)^2 - 1, does not overflow\n+                        ? s\n+                        : s + 1);\n@@ -2047,0 +2045,1 @@\n+            \/\/ (4 * ceil(intLen \/ 4)) \/ 2 == (intLen + ((-intLen) & 3)) >> 1\n@@ -2083,2 +2082,2 @@\n-        MutableBigInteger chunk = u; \/\/ Corresponds to ub + a_0 in the paper\n-        chunk.shiftAddDisjoint(getBlockZimmermann(0, len, limit, blockLen), blockLen);\n+        \/\/ Corresponds to ub + a_0 in the paper\n+        u.shiftAddDisjoint(getBlockZimmermann(0, len, limit, blockLen), blockLen);\n@@ -2090,1 +2089,1 @@\n-            rem = chunk;\n+            rem = u;\n@@ -2101,1 +2100,1 @@\n-            if (chunk.compare(qSqr) == -1)\n+            if (u.compare(qSqr) == -1)\n@@ -2134,4 +2133,4 @@\n-     * Returns a {@code MutableBigInteger} obtained taking {@code blockLen} ints from\n-     * {@code this} number, starting at {@code blockIndex*blockLen}.<br\/>\n-     * Used by Zimmermann square root.\n-     * @param blockIndex the block index\n+     * Returns a {@code MutableBigInteger} obtained by taking {@code blockLen} ints from\n+     * {@code this} number, ending at {@code blockIndex*blockLen} (exclusive).<br\/>\n+     * Used in Zimmermann's square root.\n+     * @param blockIndex the block index, starting from the lowest\n@@ -2141,0 +2140,3 @@\n+     *\n+     * @return a {@code MutableBigInteger} obtained by taking {@code blockLen} ints from\n+     * {@code this} number, ending at {@code blockIndex*blockLen} (exclusive).\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -296,0 +296,20 @@\n+    private static void perfectSquaresLong() {\n+        \/* For every long value n in [0, 2^32) such that x == n * n,\n+         * n - 1 <= (long) Math.sqrt(x >= 0 ? x : x + 0x1p64) <= n\n+         * must be true.\n+         *\/\n+        int failCount = 0;\n+\n+        long limit = 1L << 32;\n+        for (long n = 0; n < limit; n++) {\n+            long x = n * n;\n+            long s = (long) Math.sqrt(x >= 0 ? x : x + 0x1p64);\n+            if (!(s == n || s == n - 1)) {\n+                failCount++;\n+                System.err.println(s + \"^2 != \" + x + \" && (\" + s + \"+1)^2 != \" + x);\n+            }\n+        }\n+\n+        report(\"perfectSquaresLong\", failCount);\n+    }\n+\n@@ -298,0 +318,1 @@\n+        perfectSquaresLong();\n","filename":"test\/jdk\/java\/math\/BigInteger\/BigIntegerTest.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}