{"files":[{"patch":"@@ -1961,2 +1961,2 @@\n-                final int sqrtEnd = sqrtRem[0].offset + sqrtRem[0].intLen;\n-                final int s0 = sqrtRem[0].value[sqrtEnd - 1] & (-1 >>> -halfShift);\n+                final int s0 = sqrtRem[0].value[sqrtRem[0].offset + sqrtRem[0].intLen - 1]\n+                        & (-1 >>> -halfShift); \/\/ Remove excess bits\n@@ -1965,1 +1965,4 @@\n-                    sqrtRem[1].add(new MutableBigInteger(sqrtRem[0].toBigInteger().multiply(s0 << 1).mag));\n+                    MutableBigInteger doubleProd = new MutableBigInteger();\n+                    sqrtRem[0].mul(s0 << 1, doubleProd);\n+\n+                    sqrtRem[1].add(doubleProd);\n@@ -2010,1 +2013,1 @@\n-        dividend.add(new MutableBigInteger(getBlockZimmermann(1, len, limit, blockLen)));\n+        dividend.add(getBlockZimmermann(1, len, limit, blockLen));\n@@ -2022,2 +2025,2 @@\n-        rem.add(new MutableBigInteger(getBlockZimmermann(0, len, limit, blockLen)));\n-        BigInteger qBig = q.toBigInteger();\n+        rem.add(getBlockZimmermann(0, len, limit, blockLen));\n+        BigInteger qBig = q.toBigInteger(); \/\/ Cast to BigInteger to use fast multiplication\n@@ -2039,9 +2042,16 @@\n-                final int s0Len = (halfShift + 31) >> 5;\n-                int[] s0Mag = sqrt.getBlockZimmermann(0, sqrt.intLen, sqrt.intLen, s0Len);\n-                if (s0Mag.length == s0Len)\n-                    s0Mag[0] &= -1 >>> -halfShift; \/\/ Remove excess bits\n-\n-                BigInteger s0 = new BigInteger(s0Mag, 1);\n-                if (s0.signum != 0) { \/\/ An optimization\n-                    rem.add(new MutableBigInteger(s0.shiftLeft(1).multiply(sqrt.toBigInteger()).mag));\n-                    rem.subtract(new MutableBigInteger(s0.multiply(s0).mag));\n+                final int s0Ints = (halfShift + 31) >> 5;\n+                MutableBigInteger s0 = sqrt.getBlockZimmermann(0, sqrt.intLen, sqrt.intLen, s0Ints);\n+                if (s0.intLen == s0Ints)\n+                    s0.value[0] &= -1 >>> -halfShift; \/\/ Remove excess bits\n+\n+                if (!s0.isZero()) { \/\/ An optimization\n+                    MutableBigInteger twiceS0 = new MutableBigInteger(s0);\n+                    twiceS0.leftShift(1);\n+                    MutableBigInteger doubleProd = new MutableBigInteger();\n+                    twiceS0.multiply(sqrt, doubleProd); \/\/ Use classic multiplication\n+\n+                    MutableBigInteger s0Sqr = new MutableBigInteger();\n+                    s0.multiply(s0, s0Sqr);\n+\n+                    rem.add(doubleProd);\n+                    rem.subtract(s0Sqr);\n@@ -2056,1 +2066,1 @@\n-    private int[] getBlockZimmermann(int blockIndex, int len, int limit, int blockLen) {\n+    private MutableBigInteger getBlockZimmermann(int blockIndex, int len, int limit, int blockLen) {\n@@ -2065,1 +2075,1 @@\n-            return new int[0];\n+            return new MutableBigInteger();\n@@ -2069,1 +2079,1 @@\n-        return block;\n+        return new MutableBigInteger(block);\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":28,"deletions":18,"binary":false,"changes":46,"status":"modified"}]}