{"files":[{"patch":"@@ -2726,1 +2726,1 @@\n-        return new MutableBigInteger(this.mag).sqrt().toBigInteger();\n+        return new MutableBigInteger(this.mag).sqrtRem(false)[0].toBigInteger();\n@@ -2745,4 +2745,6 @@\n-        BigInteger s = sqrt();\n-        BigInteger r = this.subtract(s.square());\n-        assert r.compareTo(BigInteger.ZERO) >= 0;\n-        return new BigInteger[] {s, r};\n+        if (this.signum < 0) {\n+            throw new ArithmeticException(\"Negative BigInteger\");\n+        }\n+\n+        MutableBigInteger[] sqrtRem = new MutableBigInteger(this.mag).sqrtRem(true);\n+        return new BigInteger[] { sqrtRem[0].toBigInteger(), sqrtRem[1].toBigInteger() };\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -112,3 +112,20 @@\n-        value = new int[1];\n-        intLen = 1;\n-        value[0] = val;\n+        init(val);\n+    }\n+\n+    \/**\n+     * Construct a new MutableBigInteger with a magnitude specified by\n+     * the long val.\n+     *\/\n+    MutableBigInteger(long val) {\n+        int hi = (int) (val >>> 32);\n+        if (hi == 0) {\n+            init((int) val);\n+        } else {\n+            value = new int[] { hi, (int) val };\n+            intLen = 2;\n+        }\n+    }\n+\n+    private void init(int val) {\n+        value = new int[] { val };\n+        intLen = val != 0 ? 1 : 0;\n@@ -263,0 +280,1 @@\n+     * Assumes no leading unnecessary zeros.\n@@ -288,0 +306,1 @@\n+     * Assumes no leading unnecessary zeros.\n@@ -541,0 +560,1 @@\n+     * Assumes {@code Math.ceilDiv(n, 32) <= intLen || intLen == 0}\n@@ -914,0 +934,52 @@\n+    \/**\n+     * Shifts {@code this} of {@code n} ints to the left and adds {@code addend}.\n+     * Assumes {@code n > 0} for speed.\n+     *\/\n+    void shiftAdd(MutableBigInteger addend, int n) {\n+        \/\/ Fast cases\n+        if (addend.intLen <= n) {\n+            shiftAddDisjoint(addend, n);\n+        } else if (intLen == 0) {\n+            copyValue(addend);\n+        } else {\n+            leftShift(n << 5);\n+            add(addend);\n+        }\n+    }\n+\n+    \/**\n+     * Shifts {@code this} of {@code n} ints to the left and adds {@code addend}.\n+     * Assumes {@code addend.intLen <= n}.\n+     *\/\n+    void shiftAddDisjoint(MutableBigInteger addend, int n) {\n+        if (intLen == 0) { \/\/ Avoid unnormal values\n+            copyValue(addend);\n+            return;\n+        }\n+\n+        int[] res;\n+        final int resLen = intLen + n, resOffset;\n+        if (resLen > value.length) {\n+            res = new int[resLen];\n+            System.arraycopy(value, offset, res, 0, intLen);\n+            resOffset = 0;\n+        } else {\n+            res = value;\n+            if (offset + resLen > value.length) {\n+                System.arraycopy(value, offset, res, 0, intLen);\n+                resOffset = 0;\n+            } else {\n+                resOffset = offset;\n+            }\n+            \/\/ Clear words where necessary\n+            if (addend.intLen < n)\n+                Arrays.fill(res, resOffset + intLen, resOffset + resLen - addend.intLen, 0);\n+        }\n+\n+        System.arraycopy(addend.value, addend.offset, res, resOffset + resLen - addend.intLen, addend.intLen);\n+\n+        value = res;\n+        offset = resOffset;\n+        intLen = resLen;\n+    }\n+\n@@ -1006,0 +1078,1 @@\n+     * Assume {@code intLen > 0}\n@@ -1796,4 +1869,4 @@\n-     * Calculate the integer square root {@code floor(sqrt(this))} where\n-     * {@code sqrt(.)} denotes the mathematical square root. The contents of\n-     * {@code this} are <b>not<\/b> changed. The value of {@code this} is assumed\n-     * to be non-negative.\n+     * Calculate the integer square root {@code floor(sqrt(this))} and the remainder\n+     * if needed, where {@code sqrt(.)} denotes the mathematical square root.\n+     * The contents of {@code this} are <em>not<\/em> changed.\n+     * The value of {@code this} is assumed to be non-negative.\n@@ -1801,7 +1874,1 @@\n-     * @implNote The implementation is based on the material in Henry S. Warren,\n-     * Jr., <i>Hacker's Delight (2nd ed.)<\/i> (Addison Wesley, 2013), 279-282.\n-     *\n-     * @throws ArithmeticException if the value returned by {@code bitLength()}\n-     * overflows the range of {@code int}.\n-     * @return the integer square root of {@code this}\n-     * @since 9\n+     * @return the integer square root of {@code this} and the remainder if needed\n@@ -1809,1 +1876,1 @@\n-    MutableBigInteger sqrt() {\n+    MutableBigInteger[] sqrtRem(boolean needRemainder) {\n@@ -1811,21 +1878,36 @@\n-        if (this.isZero()) {\n-            return new MutableBigInteger(0);\n-        } else if (this.value.length == 1\n-                && (this.value[0] & LONG_MASK) < 4) { \/\/ result is unity\n-            return ONE;\n-        }\n-\n-        if (bitLength() <= 63) {\n-            \/\/ Initial estimate is the square root of the positive long value.\n-            long v = new BigInteger(this.value, 1).longValueExact();\n-            long xk = (long)Math.floor(Math.sqrt(v));\n-\n-            \/\/ Refine the estimate.\n-            do {\n-                long xk1 = (xk + v\/xk)\/2;\n-\n-                \/\/ Terminate when non-decreasing.\n-                if (xk1 >= xk) {\n-                    return new MutableBigInteger(new int[] {\n-                        (int)(xk >>> 32), (int)(xk & LONG_MASK)\n-                    });\n+        if (this.intLen <= 2) {\n+            final long x = this.toLong(); \/\/ unsigned\n+            long s = unsignedLongSqrt(x);\n+\n+            return new MutableBigInteger[] {\n+                    new MutableBigInteger((int) s),\n+                    needRemainder ? new MutableBigInteger(x - s * s) : null\n+            };\n+        }\n+\n+        \/\/ Normalize\n+        MutableBigInteger x = this;\n+        final int shift = (Integer.numberOfLeadingZeros(x.value[x.offset]) & ~1) \/\/ shift must be even\n+                + ((x.intLen & 1) << 5); \/\/ x.intLen must be even\n+\n+        if (shift != 0) {\n+            x = new MutableBigInteger(x);\n+            x.leftShift(shift);\n+        }\n+\n+        \/\/ Compute sqrt and remainder\n+        MutableBigInteger[] sqrtRem = x.sqrtRemKaratsuba(x.intLen, needRemainder);\n+\n+        \/\/ Unnormalize\n+        if (shift != 0) {\n+            final int halfShift = shift >> 1;\n+            if (needRemainder) {\n+                \/\/ shift <= 62, so s0 is at most 31 bit long\n+                final long s0 = sqrtRem[0].value[sqrtRem[0].offset + sqrtRem[0].intLen - 1]\n+                        & (-1 >>> -halfShift); \/\/ Remove excess bits\n+                if (s0 != 0L) { \/\/ An optimization\n+                    MutableBigInteger doubleProd = new MutableBigInteger();\n+                    sqrtRem[0].mul((int) (s0 << 1), doubleProd);\n+\n+                    sqrtRem[1].add(doubleProd);\n+                    sqrtRem[1].subtract(new MutableBigInteger(s0 * s0));\n@@ -1833,0 +1915,6 @@\n+                sqrtRem[1].rightShift(shift);\n+            }\n+            sqrtRem[0].primitiveRightShift(halfShift);\n+        }\n+        return sqrtRem;\n+    }\n@@ -1834,4 +1922,18 @@\n-                xk = xk1;\n-            } while (true);\n-        } else {\n-            \/\/ Set up the initial estimate of the iteration.\n+    private static long unsignedLongSqrt(long x) {\n+        \/* For every long value s in [0, 2^32) such that x == s * s,\n+         * it is true that s - 1 <= (long) Math.sqrt(x >= 0 ? x : x + 0x1p64) <= s,\n+         * and if x == 2^64 - 1, then (long) Math.sqrt(x >= 0 ? x : x + 0x1p64) == 2^32.\n+         * Since both cast to long and `Math.sqrt()` are (weakly) increasing,\n+         * this means that the value returned by Math.sqrt()\n+         * for a long value in the range [0, 2^64) is either correct,\n+         * or rounded up\/down by one if the value is too high\n+         * and too close to a perfect square.\n+         *\/\n+        long s = (long) Math.sqrt(x >= 0 ? x : x + 0x1p64);\n+        long s2 = s * s;  \/\/ overflows iff s == 2^32\n+        return Long.compareUnsigned(x, s2) < 0 || s > LONG_MASK\n+                ? s - 1\n+                : (Long.compareUnsigned(x, s2 + (s << 1)) <= 0 \/\/ x <= (s + 1)^2 - 1, does not overflow\n+                        ? s\n+                        : s + 1);\n+    }\n@@ -1839,5 +1941,11 @@\n-            \/\/ Obtain the bitLength > 63.\n-            int bitLength = (int) this.bitLength();\n-            if (bitLength != this.bitLength()) {\n-                throw new ArithmeticException(\"bitLength() integer overflow\");\n-            }\n+    \/**\n+     * Assumes {@code 2 <= len <= intLen && len % 2 == 0\n+     * && Integer.numberOfLeadingZeros(value[offset]) <= 1}\n+     * @implNote The implementation is based on Zimmermann's works available\n+     * <a href=\"https:\/\/inria.hal.science\/inria-00072854v1\/document\">  here<\/a> and\n+     * <a href=\"https:\/\/inria.hal.science\/inria-00072113\/document\">  here<\/a>\n+     *\/\n+    private MutableBigInteger[] sqrtRemKaratsuba(int len, boolean needRemainder) {\n+        if (len == 2) { \/\/ Base case\n+            long x = ((value[offset] & LONG_MASK) << 32) | (value[offset + 1] & LONG_MASK);\n+            long s = unsignedLongSqrt(x);\n@@ -1845,5 +1953,2 @@\n-            \/\/ Determine an even valued right shift into positive long range.\n-            int shift = bitLength - 63;\n-            if (shift % 2 == 1) {\n-                shift++;\n-            }\n+            \/\/ Allocate sufficient space to hold the final square root, assuming intLen % 2 == 0\n+            MutableBigInteger sqrt = new MutableBigInteger(new int[intLen >> 1]);\n@@ -1851,25 +1956,8 @@\n-            \/\/ Shift the value into positive long range.\n-            MutableBigInteger xk = new MutableBigInteger(this);\n-            xk.rightShift(shift);\n-            xk.normalize();\n-\n-            \/\/ Use the square root of the shifted value as an approximation.\n-            double d = new BigInteger(xk.value, 1).doubleValue();\n-            BigInteger bi = BigInteger.valueOf((long)Math.ceil(Math.sqrt(d)));\n-            xk = new MutableBigInteger(bi.mag);\n-\n-            \/\/ Shift the approximate square root back into the original range.\n-            xk.leftShift(shift \/ 2);\n-\n-            \/\/ Refine the estimate.\n-            MutableBigInteger xk1 = new MutableBigInteger();\n-            do {\n-                \/\/ xk1 = (xk + n\/xk)\/2\n-                this.divide(xk, xk1, false);\n-                xk1.add(xk);\n-                xk1.rightShift(1);\n-\n-                \/\/ Terminate when non-decreasing.\n-                if (xk1.compare(xk) >= 0) {\n-                    return xk;\n-                }\n+            \/\/ Place the partial square root\n+            sqrt.intLen = 1;\n+            sqrt.value[0] = (int) s;\n+\n+            return new MutableBigInteger[] { sqrt, new MutableBigInteger(x - s * s) };\n+        }\n+\n+        \/\/ Recursive step (len >= 4)\n@@ -1877,2 +1965,3 @@\n-                \/\/ xk = xk1\n-                xk.copyValue(xk1);\n+        final int halfLen = len >> 1;\n+        \/\/ Recursive invocation\n+        MutableBigInteger[] sr = sqrtRemKaratsuba(halfLen + (halfLen & 1), true);\n@@ -1880,2 +1969,36 @@\n-                xk1.reset();\n-            } while (true);\n+        final int blockLen = halfLen >> 1;\n+        MutableBigInteger dividend = sr[1];\n+        dividend.shiftAddDisjoint(getBlockForSqrt(1, len, blockLen), blockLen);\n+\n+        \/\/ Compute dividend \/ (2*sqrt)\n+        MutableBigInteger sqrt = sr[0];\n+        MutableBigInteger q = new MutableBigInteger();\n+        MutableBigInteger u = dividend.divide(sqrt, q);\n+        if (q.isOdd())\n+            u.add(sqrt);\n+        q.rightShift(1);\n+\n+        sqrt.shiftAdd(q, blockLen);\n+        \/\/ Corresponds to ub + a_0 in the paper\n+        u.shiftAddDisjoint(getBlockForSqrt(0, len, blockLen), blockLen);\n+        BigInteger qBig = q.toBigInteger(); \/\/ Cast to BigInteger to use fast multiplication\n+        MutableBigInteger qSqr = new MutableBigInteger(qBig.multiply(qBig).mag);\n+\n+        MutableBigInteger rem;\n+        if (needRemainder) {\n+            rem = u;\n+            if (rem.subtract(qSqr) < 0) {\n+                MutableBigInteger twiceSqrt = new MutableBigInteger(sqrt);\n+                twiceSqrt.leftShift(1);\n+\n+                \/\/ Since subtract() performs an absolute difference, to get the correct algebraic sum\n+                \/\/ we must first add the sum of absolute values of addends concordant with the sign of rem\n+                \/\/ and then subtract the sum of absolute values of addends that are discordant\n+                rem.add(ONE);\n+                rem.subtract(twiceSqrt);\n+                sqrt.subtract(ONE);\n+            }\n+        } else {\n+            rem = null;\n+            if (u.compare(qSqr) < 0)\n+                sqrt.subtract(ONE);\n@@ -1883,0 +2006,26 @@\n+\n+        sr[1] = rem;\n+        return sr;\n+    }\n+\n+    \/**\n+     * Returns a {@code MutableBigInteger} obtained by taking {@code blockLen} ints from\n+     * {@code this} number, ending at {@code blockIndex*blockLen} (exclusive).<br\/>\n+     * Used in Karatsuba square root.\n+     * @param blockIndex the block index, starting from the lowest\n+     * @param len the logical length of the input value in units of 32 bits\n+     * @param blockLen the length of the block in units of 32 bits\n+     *\n+     * @return a {@code MutableBigInteger} obtained by taking {@code blockLen} ints from\n+     * {@code this} number, ending at {@code blockIndex*blockLen} (exclusive).\n+     *\/\n+    private MutableBigInteger getBlockForSqrt(int blockIndex, int len, int blockLen) {\n+        final int to = offset + len - blockIndex * blockLen;\n+\n+        \/\/ Skip leading zeros\n+        int from;\n+        for (from = to - blockLen; from < to && value[from] == 0; from++);\n+\n+        return from == to\n+                ? new MutableBigInteger()\n+                : new MutableBigInteger(Arrays.copyOfRange(value, from, to));\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":228,"deletions":79,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -296,0 +296,21 @@\n+    private static void perfectSquaresLong() {\n+        \/* For every long value n in [0, 2^32) such that x == n * n,\n+         * n - 1 <= (long) Math.sqrt(x >= 0 ? x : x + 0x1p64) <= n\n+         * must be true.\n+         * This property is used to implement MutableBigInteger.unsignedLongSqrt().\n+         *\/\n+        int failCount = 0;\n+\n+        long limit = 1L << 32;\n+        for (long n = 0; n < limit; n++) {\n+            long x = n * n;\n+            long s = (long) Math.sqrt(x >= 0 ? x : x + 0x1p64);\n+            if (!(s == n || s == n - 1)) {\n+                failCount++;\n+                System.err.println(s + \"^2 != \" + x + \" && (\" + s + \"+1)^2 != \" + x);\n+            }\n+        }\n+\n+        report(\"perfectSquaresLong\", failCount);\n+    }\n+\n@@ -298,0 +319,1 @@\n+        perfectSquaresLong();\n","filename":"test\/jdk\/java\/math\/BigInteger\/BigIntegerTest.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.math;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.math.BigInteger;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class BigIntegerSquareRoot {\n+\n+    private BigInteger[] xsArray, sArray, mArray, lArray, xlArray;\n+    private static final int TESTSIZE = 1000;\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random(1123);\n+\n+        xsArray = new BigInteger[TESTSIZE]; \/*\n+         * Each array entry is atmost 64 bits\n+         * in size\n+         *\/\n+        sArray = new BigInteger[TESTSIZE]; \/*\n+         * Each array entry is atmost 256 bits\n+         * in size\n+         *\/\n+        mArray = new BigInteger[TESTSIZE]; \/*\n+         * Each array entry is atmost 1024 bits\n+         * in size\n+         *\/\n+        lArray = new BigInteger[TESTSIZE]; \/*\n+         * Each array entry is atmost 4096 bits\n+         * in size\n+         *\/\n+        xlArray = new BigInteger[TESTSIZE]; \/*\n+         * Each array entry is atmost 16384 bits\n+         * in size\n+         *\/\n+\n+        for (int i = 0; i < TESTSIZE; i++) {\n+            xsArray[i] = new BigInteger(r.nextInt(64), r);\n+            sArray[i] = new BigInteger(r.nextInt(256), r);\n+            mArray[i] = new BigInteger(r.nextInt(1024), r);\n+            lArray[i] = new BigInteger(r.nextInt(4096), r);\n+            xlArray[i] = new BigInteger(r.nextInt(16384), r);\n+        }\n+    }\n+\n+    \/** Test BigInteger.sqrt() with numbers long at most 64 bits  *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testSqrtXS(Blackhole bh) {\n+        for (BigInteger s : xsArray) {\n+            bh.consume(s.sqrt());\n+        }\n+    }\n+\n+    \/** Test BigInteger.sqrt() with numbers long at most 256 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testSqrtS(Blackhole bh) {\n+        for (BigInteger s : sArray) {\n+            bh.consume(s.sqrt());\n+        }\n+    }\n+\n+    \/** Test BigInteger.sqrt() with numbers long at most 1024 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testSqrtM(Blackhole bh) {\n+        for (BigInteger s : mArray) {\n+            bh.consume(s.sqrt());\n+        }\n+    }\n+\n+    \/** Test BigInteger.sqrt() with numbers long at most 4096 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testSqrtL(Blackhole bh) {\n+        for (BigInteger s : lArray) {\n+            bh.consume(s.sqrt());\n+        }\n+    }\n+\n+    \/** Test BigInteger.sqrt() with numbers long at most 16384 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testSqrtXL(Blackhole bh) {\n+        for (BigInteger s : xlArray) {\n+            bh.consume(s.sqrt());\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegerSquareRoot.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"}]}