{"files":[{"patch":"@@ -328,0 +328,1 @@\n+ * @author  Fabio Romano\n@@ -2143,11 +2144,0 @@\n-             * The following code draws on the algorithm presented in\n-             * \"Properly Rounded Variable Precision Square Root,\" Hull and\n-             * Abrham, ACM Transactions on Mathematical Software, Vol 11,\n-             * No. 3, September 1985, Pages 229-237.\n-             *\n-             * The BigDecimal computational model differs from the one\n-             * presented in the paper in several ways: first BigDecimal\n-             * numbers aren't necessarily normalized, second many more\n-             * rounding modes are supported, including UNNECESSARY, and\n-             * exact results can be requested.\n-             *\n@@ -2155,2 +2145,2 @@\n-             * first argument reduce the value to the numerical range\n-             * [1, 10) using the following relations:\n+             * first argument reduce the value to an integer\n+             * using the following relations:\n@@ -2162,1 +2152,1 @@\n-             * Then use Newton's iteration on the reduced value to compute\n+             * Then use BigInteger.sqrt() on the reduced value to compute\n@@ -2198,92 +2188,1 @@\n-            \/\/ precision for the cohort of the numerical value. To\n-            \/\/ allow binary floating-point hardware to be used to get\n-            \/\/ approximately a 15 digit approximation to the square\n-            \/\/ root, it is helpful to instead normalize this so that\n-            \/\/ the significand portion is to right of the decimal\n-            \/\/ point by roughly (scale() - precision() + 1).\n-\n-            \/\/ Now the precision \/ scale adjustment\n-            int scaleAdjust = 0;\n-            int scale = stripped.scale() - stripped.precision() + 1;\n-            if (scale % 2 == 0) {\n-                scaleAdjust = scale;\n-            } else {\n-                scaleAdjust = scale - 1;\n-            }\n-\n-            BigDecimal working = stripped.scaleByPowerOfTen(scaleAdjust);\n-\n-            assert  \/\/ Verify 0.1 <= working < 10\n-                ONE_TENTH.compareTo(working) <= 0 && working.compareTo(TEN) < 0;\n-\n-            \/\/ Use good ole' Math.sqrt to get the initial guess for\n-            \/\/ the Newton iteration, good to at least 15 decimal\n-            \/\/ digits. This approach does incur the cost of a\n-            \/\/\n-            \/\/ BigDecimal -> double -> BigDecimal\n-            \/\/\n-            \/\/ conversion cycle, but it avoids the need for several\n-            \/\/ Newton iterations in BigDecimal arithmetic to get the\n-            \/\/ working answer to 15 digits of precision. If many fewer\n-            \/\/ than 15 digits were needed, it might be faster to do\n-            \/\/ the loop entirely in BigDecimal arithmetic.\n-            \/\/\n-            \/\/ (A double value might have as many as 17 decimal\n-            \/\/ digits of precision; it depends on the relative density\n-            \/\/ of binary and decimal numbers at different regions of\n-            \/\/ the number line.)\n-            \/\/\n-            \/\/ (It would be possible to check for certain special\n-            \/\/ cases to avoid doing any Newton iterations. For\n-            \/\/ example, if the BigDecimal -> double conversion was\n-            \/\/ known to be exact and the rounding mode had a\n-            \/\/ low-enough precision, the post-Newton rounding logic\n-            \/\/ could be applied directly.)\n-\n-            BigDecimal guess = new BigDecimal(Math.sqrt(working.doubleValue()));\n-            int guessPrecision = 15;\n-            int originalPrecision = mc.getPrecision();\n-            int targetPrecision;\n-\n-            \/\/ If an exact value is requested, it must only need about\n-            \/\/ half of the input digits to represent since multiplying\n-            \/\/ an N digit number by itself yield a 2N-1 digit or 2N\n-            \/\/ digit result.\n-            if (originalPrecision == 0) {\n-                targetPrecision = stripped.precision()\/2 + 1;\n-            } else {\n-                \/*\n-                 * To avoid the need for post-Newton fix-up logic, in\n-                 * the case of half-way rounding modes, double the\n-                 * target precision so that the \"2p + 2\" property can\n-                 * be relied on to accomplish the final rounding.\n-                 *\/\n-                switch (mc.getRoundingMode()) {\n-                case HALF_UP:\n-                case HALF_DOWN:\n-                case HALF_EVEN:\n-                    targetPrecision = 2 * originalPrecision;\n-                    if (targetPrecision < 0) \/\/ Overflow\n-                        targetPrecision = Integer.MAX_VALUE - 2;\n-                    break;\n-\n-                default:\n-                    targetPrecision = originalPrecision;\n-                    break;\n-                }\n-            }\n-\n-            \/\/ When setting the precision to use inside the Newton\n-            \/\/ iteration loop, take care to avoid the case where the\n-            \/\/ precision of the input exceeds the requested precision\n-            \/\/ and rounding the input value too soon.\n-            BigDecimal approx = guess;\n-            int workingPrecision = working.precision();\n-            do {\n-                int tmpPrecision = Math.max(Math.max(guessPrecision, targetPrecision + 2),\n-                                           workingPrecision);\n-                MathContext mcTmp = new MathContext(tmpPrecision, RoundingMode.HALF_EVEN);\n-                \/\/ approx = 0.5 * (approx + fraction \/ approx)\n-                approx = ONE_HALF.multiply(approx.add(working.divide(approx, mcTmp), mcTmp));\n-                guessPrecision *= 2;\n-            } while (guessPrecision < targetPrecision + 2);\n+            \/\/ precision for the cohort of the numerical value.\n@@ -2292,6 +2191,10 @@\n-            RoundingMode targetRm = mc.getRoundingMode();\n-            if (targetRm == RoundingMode.UNNECESSARY || originalPrecision == 0) {\n-                RoundingMode tmpRm =\n-                    (targetRm == RoundingMode.UNNECESSARY) ? RoundingMode.DOWN : targetRm;\n-                MathContext mcTmp = new MathContext(targetPrecision, tmpRm);\n-                result = approx.scaleByPowerOfTen(-scaleAdjust\/2).round(mcTmp);\n+            if (mc.roundingMode == RoundingMode.UNNECESSARY || mc.precision == 0) {\n+                \/\/ Exact result requested\n+                BigInteger working = stripped.unscaledValue();\n+                if ((stripped.scale & 1) != 0)\n+                    working.multiply(BigInteger.TEN);\n+\n+                BigInteger[] sqrtRem = working.sqrtAndRemainder();\n+                result = new BigDecimal(sqrtRem[0], stripped.scale \/ 2);\n+                if (mc.precision != 0)\n+                    result = result.round(new MathContext(mc.precision, RoundingMode.DOWN));\n@@ -2301,1 +2204,1 @@\n-                if (this.subtract(result.square()).compareTo(ZERO) != 0) {\n+                if (sqrtRem[1].signum != 0 || result.square().compareTo(this) != 0)\n@@ -2303,1 +2206,0 @@\n-                }\n@@ -2305,18 +2207,26 @@\n-                result = approx.scaleByPowerOfTen(-scaleAdjust\/2).round(mc);\n-\n-                switch (targetRm) {\n-                case DOWN:\n-                case FLOOR:\n-                    \/\/ Check if too big\n-                    if (result.square().compareTo(this) > 0) {\n-                        BigDecimal ulp = result.ulp();\n-                        \/\/ Adjust increment down in case of 1.0 = 10^0\n-                        \/\/ since the next smaller number is only 1\/10\n-                        \/\/ as far way as the next larger at exponent\n-                        \/\/ boundaries. Test approx and *not* result to\n-                        \/\/ avoid having to detect an arbitrary power\n-                        \/\/ of ten.\n-                        if (approx.compareTo(ONE) == 0) {\n-                            ulp = ulp.multiply(ONE_TENTH);\n-                        }\n-                        result = result.subtract(ulp);\n+                \/\/ To allow BigInteger.sqrt() to be used to get the square\n+                \/\/ root, it is necessary to normalize this so that\n+                \/\/ its precision is sufficient to get the square root\n+                \/\/ with the desired precision.\n+\n+                \/\/ To obtain a root with N digits,\n+                \/\/ the radicand must have at least 2*(N-1)+1 == 2*N-1 digits.\n+                final long minWorkingPrec = ((long) mc.precision << 1) - 1;\n+                long scale = minWorkingPrec - (stripped.precision() - stripped.scale());\n+                if ((scale & 1) != 0) \/\/ scale must be even\n+                    scale++;\n+\n+                final int scaleAdjust = (int) scale;\n+                if (scaleAdjust != scale)\n+                    new ArithmeticException(\"Overflow\");\n+\n+                BigDecimal working = stripped.scaleByPowerOfTen(scaleAdjust);\n+                BigInteger workingInt = working.toBigInteger();\n+                BigInteger[] sqrtRem = workingInt.sqrtAndRemainder();\n+                result = new BigDecimal(sqrtRem[0], scaleAdjust >> 1);\n+\n+                switch (mc.roundingMode) {\n+                case UP, CEILING:\n+                    \/\/ Check if remainder is non-zero\n+                    if (sqrtRem[1].signum != 0 || working.compareTo(new BigDecimal(workingInt)) != 0) {\n+                        result = result.add(result.ulp());\n@@ -2326,5 +2236,15 @@\n-                case UP:\n-                case CEILING:\n-                    \/\/ Check if too small\n-                    if (result.square().compareTo(this) < 0) {\n-                        result = result.add(result.ulp());\n+                case HALF_DOWN, HALF_UP, HALF_EVEN:\n+                    \/\/ x >= (s + 1\/2)^2\n+                    \/\/ <=> x >= s^2 + s + 1\/4\n+                    \/\/ <=> s^2 + r >= s^2 + s + 1\/4, if x == s^2 + r\n+                    \/\/ <=> r >= s + 1\/4\n+                    BigDecimal r = new BigDecimal(sqrtRem[1]).add(working.subtract(new BigDecimal(workingInt)));\n+                    int cmp = r.compareTo(new BigDecimal(sqrtRem[0]).add(valueOf(25, 2)));\n+                    boolean increment;\n+                    if (cmp > 0) {\n+                        increment = true;\n+                    } else if (cmp == 0) {\n+                        increment = mc.roundingMode == RoundingMode.HALF_UP\n+                                || mc.roundingMode == RoundingMode.HALF_EVEN && sqrtRem[0].testBit(0);\n+                    } else {\n+                        increment = false;\n@@ -2332,1 +2252,0 @@\n-                    break;\n@@ -2334,0 +2253,3 @@\n+                    if (increment)\n+                        result = result.add(result.ulp());\n+                    break;\n@@ -2335,10 +2257,0 @@\n-                    \/\/ No additional work, rely on \"2p + 2\" property\n-                    \/\/ for correct rounding. Alternatively, could\n-                    \/\/ instead run the Newton iteration to around p\n-                    \/\/ digits and then do tests and fix-ups on the\n-                    \/\/ rounded value. One possible set of tests and\n-                    \/\/ fix-ups is given in the Hull and Abrham paper;\n-                    \/\/ however, additional half-way cases can occur\n-                    \/\/ for BigDecimal given the more varied\n-                    \/\/ combinations of input and output precisions\n-                    \/\/ supported.\n@@ -2346,0 +2258,3 @@\n+                \/\/ case DOWN\n+                \/\/ case FLOOR\n+                \/\/ result is already rounded down\n@@ -2347,1 +2262,0 @@\n-\n@@ -2363,1 +2277,1 @@\n-                        new MathContext(originalPrecision, RoundingMode.UNNECESSARY));\n+                        new MathContext(mc.precision, RoundingMode.UNNECESSARY));\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":64,"deletions":150,"binary":false,"changes":214,"status":"modified"}]}