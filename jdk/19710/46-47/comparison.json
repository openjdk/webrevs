{"files":[{"patch":"@@ -550,1 +550,1 @@\n-        if (n >= bitLength()) {\n+        if (n\/32 >= intLen) {\n@@ -560,0 +560,1 @@\n+     * Assume {@code Math.ceilDiv(n, 32) <= intLen || intLen == 0}\n@@ -1879,1 +1880,1 @@\n-            long s = ulongSqrt(x);\n+            long s = unsignedLongSqrt(x);\n@@ -1889,3 +1890,2 @@\n-        int shift = Integer.numberOfLeadingZeros(x.value[x.offset]) & ~1; \/\/ shift must be even\n-        if ((x.intLen & 1) != 0)\n-            shift += 32; \/\/ x.intLen must be even\n+        final int shift = (Integer.numberOfLeadingZeros(x.value[x.offset]) & ~1) \/\/ shift must be even\n+                + ((x.intLen & 1) << 5); \/\/ x.intLen must be even\n@@ -1899,1 +1899,1 @@\n-        MutableBigInteger[] sqrtRem = x.sqrtRemZimmermann(x.intLen, needRemainder);\n+        MutableBigInteger[] sqrtRem = x.sqrtRemKaratsuba(x.intLen, needRemainder);\n@@ -1922,1 +1922,1 @@\n-    private static long ulongSqrt(long x) {\n+    private static long unsignedLongSqrt(long x) {\n@@ -1945,2 +1945,2 @@\n-     * <a href=\"https:\/\/inria.hal.science\/inria-00072854\/en\/\">  here<\/a> and\n-     * <a href=\"https:\/\/www.researchgate.net\/publication\/220532560_A_proof_of_GMP_square_root\">  here<\/a>\n+     * <a href=\"https:\/\/inria.hal.science\/inria-00072854v1\/document\">  here<\/a> and\n+     * <a href=\"https:\/\/inria.hal.science\/inria-00072113\/document\">  here<\/a>\n@@ -1948,1 +1948,1 @@\n-    private MutableBigInteger[] sqrtRemZimmermann(int len, boolean needRemainder) {\n+    private MutableBigInteger[] sqrtRemKaratsuba(int len, boolean needRemainder) {\n@@ -1951,1 +1951,1 @@\n-            long s = ulongSqrt(x);\n+            long s = unsignedLongSqrt(x);\n@@ -1964,1 +1964,1 @@\n-        \/\/ Recursive step (len >= 3)\n+        \/\/ Recursive step (len >= 4)\n@@ -1968,1 +1968,1 @@\n-        MutableBigInteger[] sr = sqrtRemZimmermann((halfLen & 1) == 0 ? halfLen : halfLen + 1, true);\n+        MutableBigInteger[] sr = sqrtRemKaratsuba(halfLen + (halfLen & 1), true);\n@@ -1972,1 +1972,1 @@\n-        dividend.shiftAddDisjoint(getBlockZimmermann(1, len, blockLen), blockLen);\n+        dividend.shiftAddDisjoint(getBlockForSqrt(1, len, blockLen), blockLen);\n@@ -1980,1 +1980,1 @@\n-        q.safeRightShift(1);\n+        q.rightShift(1);\n@@ -1984,1 +1984,1 @@\n-        u.shiftAddDisjoint(getBlockZimmermann(0, len, blockLen), blockLen);\n+        u.shiftAddDisjoint(getBlockForSqrt(0, len, blockLen), blockLen);\n@@ -2004,0 +2004,1 @@\n+\n@@ -2010,1 +2011,1 @@\n-     * Used in Zimmermann's square root.\n+     * Used in Karatsuba square root.\n@@ -2018,1 +2019,1 @@\n-    private MutableBigInteger getBlockZimmermann(int blockIndex, int len, int blockLen) {\n+    private MutableBigInteger getBlockForSqrt(int blockIndex, int len, int blockLen) {\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -300,0 +300,1 @@\n+         * This property is used to implement MutableBigInteger.unsignedLongSqrt().\n","filename":"test\/jdk\/java\/math\/BigInteger\/BigIntegerTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    private BigInteger[] hugeArray, bigArray, largeArray, smallArray;\n+    private BigInteger[] xsArray, sArray, mArray, lArray, xlArray;\n@@ -58,2 +58,2 @@\n-        hugeArray = new BigInteger[TESTSIZE]; \/*\n-         * Each array entry is atmost 16k bits\n+        xsArray = new BigInteger[TESTSIZE]; \/*\n+         * Each array entry is atmost 64 bits\n@@ -62,3 +62,3 @@\n-        bigArray = new BigInteger[TESTSIZE]; \/*\n-         * Big numbers larger than\n-         * MAX_LONG\n+        sArray = new BigInteger[TESTSIZE]; \/*\n+         * Each array entry is atmost 256 bits\n+         * in size\n@@ -66,4 +66,3 @@\n-        largeArray = new BigInteger[TESTSIZE]; \/*\n-         * Large numbers less than\n-         * MAX_LONG but larger than\n-         * MAX_INT\n+        mArray = new BigInteger[TESTSIZE]; \/*\n+         * Each array entry is atmost 1024 bits\n+         * in size\n@@ -71,3 +70,7 @@\n-        smallArray = new BigInteger[TESTSIZE]; \/*\n-         * Small number less than\n-         * MAX_INT\n+        lArray = new BigInteger[TESTSIZE]; \/*\n+         * Each array entry is atmost 4096 bits\n+         * in size\n+         *\/\n+        xlArray = new BigInteger[TESTSIZE]; \/*\n+         * Each array entry is atmost 16384 bits\n+         * in size\n@@ -77,3 +80,7 @@\n-            int nBits = r.nextInt(32);\n-            long hi = r.nextLong(1L << nBits);\n-            long value = r.nextLong(1L << 31);\n+            xsArray[i] = new BigInteger(r.nextInt(64), r);\n+            sArray[i] = new BigInteger(r.nextInt(256), r);\n+            mArray[i] = new BigInteger(r.nextInt(1024), r);\n+            lArray[i] = new BigInteger(r.nextInt(4096), r);\n+            xlArray[i] = new BigInteger(r.nextInt(16384), r);\n+        }\n+    }\n@@ -81,4 +88,6 @@\n-            hugeArray[i] = new BigInteger(r.nextInt(16384), r);\n-            bigArray[i] = new BigInteger(\"\" + hi + (value + Integer.MAX_VALUE));\n-            largeArray[i] = new BigInteger(\"\" + (value \/ 1000));\n-            smallArray[i] = new BigInteger(\"\" + hi);\n+    \/** Test BigInteger.sqrt() with numbers long at most 64 bits  *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testSqrtXS(Blackhole bh) {\n+        for (BigInteger s : xsArray) {\n+            bh.consume(s.sqrt());\n@@ -88,1 +97,1 @@\n-    \/** Test BigInteger.sqrtAndRemainder() with huge numbers long at most 16k bits  *\/\n+    \/** Test BigInteger.sqrt() with numbers long at most 256 bits *\/\n@@ -91,3 +100,3 @@\n-    public void testHugeSqrtAndRemainder(Blackhole bh) {\n-        for (BigInteger s : hugeArray) {\n-            bh.consume(s.sqrtAndRemainder());\n+    public void testSqrtS(Blackhole bh) {\n+        for (BigInteger s : sArray) {\n+            bh.consume(s.sqrt());\n@@ -97,1 +106,1 @@\n-    \/** Test BigInteger.sqrtAndRemainder() with big numbers larger than MAX_LONG *\/\n+    \/** Test BigInteger.sqrt() with numbers long at most 1024 bits *\/\n@@ -100,3 +109,3 @@\n-    public void testBigSqrtAndRemainder(Blackhole bh) {\n-        for (BigInteger s : bigArray) {\n-            bh.consume(s.sqrtAndRemainder());\n+    public void testSqrtM(Blackhole bh) {\n+        for (BigInteger s : mArray) {\n+            bh.consume(s.sqrt());\n@@ -106,1 +115,1 @@\n-    \/** Test BigInteger.sqrtAndRemainder() with large numbers less than MAX_LONG but larger than MAX_INT *\/\n+    \/** Test BigInteger.sqrt() with numbers long at most 4096 bits *\/\n@@ -109,3 +118,3 @@\n-    public void testLargeSqrtAndRemainder(Blackhole bh) {\n-        for (BigInteger s : largeArray) {\n-            bh.consume(s.sqrtAndRemainder());\n+    public void testSqrtL(Blackhole bh) {\n+        for (BigInteger s : lArray) {\n+            bh.consume(s.sqrt());\n@@ -115,1 +124,1 @@\n-    \/** Test BigInteger.sqrtAndRemainder() with small numbers less than MAX_INT *\/\n+    \/** Test BigInteger.sqrt() with numbers long at most 16384 bits *\/\n@@ -118,3 +127,3 @@\n-    public void testSmallSqrtAndRemainder(Blackhole bh) {\n-        for (BigInteger s : smallArray) {\n-            bh.consume(s.sqrtAndRemainder());\n+    public void testSqrtXL(Blackhole bh) {\n+        for (BigInteger s : xlArray) {\n+            bh.consume(s.sqrt());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegerSquareRoot.java","additions":45,"deletions":36,"binary":false,"changes":81,"status":"modified"}]}