{"files":[{"patch":"@@ -1986,0 +1986,3 @@\n+        if ((x.intLen & 1) != 0)\n+            shift += 32; \/\/ x.intLen must be even\n+\n@@ -1988,1 +1991,1 @@\n-            x.primitiveLeftShift(shift);\n+            x.leftShift(shift);\n@@ -1991,0 +1994,1 @@\n+        \/\/ Compute sqrt and remainder\n@@ -1997,1 +2001,2 @@\n-                final int s0 = sqrtRem[0].value[sqrtRem[0].offset + sqrtRem[0].intLen - 1]\n+                \/\/ shift <= 62, so s0 is at most 31 bit long\n+                final long s0 = sqrtRem[0].value[sqrtRem[0].offset + sqrtRem[0].intLen - 1]\n@@ -1999,2 +2004,1 @@\n-                if (s0 != 0) { \/\/ An optimization\n-                    \/\/ s0 is at most 15 bit long\n+                if (s0 != 0L) { \/\/ An optimization\n@@ -2002,1 +2006,1 @@\n-                    sqrtRem[0].mul(s0 << 1, doubleProd);\n+                    sqrtRem[0].mul((int) (s0 << 1), doubleProd);\n@@ -2007,1 +2011,1 @@\n-                sqrtRem[1].primitiveRightShift(shift);\n+                sqrtRem[1].rightShift(shift);\n@@ -2009,1 +2013,1 @@\n-            sqrtRem[0].primitiveRightShift(halfShift);\n+            sqrtRem[0].rightShift(halfShift);\n@@ -2034,1 +2038,2 @@\n-     * Assume {@code 2 <= len <= intLen && Integer.numberOfLeadingZeros(value[offset]) <= 1}\n+     * Assume {@code 2 <= len <= intLen && len % 2 == 0\n+     * && Integer.numberOfLeadingZeros(value[offset]) <= 1}\n@@ -2044,3 +2049,2 @@\n-            \/\/ Allocate sufficient space to hold the normalized final square root\n-            \/\/ (4 * ceil(intLen \/ 4)) \/ 2 == (intLen + ((-intLen) & 3)) >> 1\n-            MutableBigInteger sqrt = new MutableBigInteger(new int[(intLen + ((-intLen) & 3)) >> 1]);\n+            \/\/ Allocate sufficient space to hold the final square root, assuming intLen % 2 == 0\n+            MutableBigInteger sqrt = new MutableBigInteger(new int[intLen >> 1]);\n@@ -2058,12 +2062,3 @@\n-        \/\/ Normalize\n-        \/* For speed, the normalization is performed only \"logically\",\n-         * which means that the contents of the input are not changed,\n-         * but only its logical length, which is stored in the parameter len.\n-         * The length is normalized to a mutiple of 4 because, in this way,\n-         * the input can be always split in blocks of words without twiddling with bits.\n-         *\/\n-        final int limit = offset + len;\n-        final int excessInts = (-len) & 3; \/\/ Compute 4 * ceil(len \/ 4) - len\n-        len += excessInts; \/\/ len must be a multiple of 4\n-\n-        MutableBigInteger[] sr = sqrtRemZimmermann(len >> 1, true); \/\/ Recursive invocation\n+        final int halfLen = len >> 1;\n+        \/\/ Recursive invocation\n+        MutableBigInteger[] sr = sqrtRemZimmermann((halfLen & 1) == 0 ? halfLen : halfLen + 1, true);\n@@ -2071,1 +2066,1 @@\n-        final int blockLen = len >> 2;\n+        final int blockLen = halfLen >> 1;\n@@ -2073,1 +2068,1 @@\n-        dividend.shiftAddDisjoint(getBlockZimmermann(1, len, limit, blockLen), blockLen);\n+        dividend.shiftAddDisjoint(getBlockZimmermann(1, len, blockLen), blockLen);\n@@ -2083,1 +2078,1 @@\n-        u.shiftAddDisjoint(getBlockZimmermann(0, len, limit, blockLen), blockLen);\n+        u.shiftAddDisjoint(getBlockZimmermann(0, len, blockLen), blockLen);\n@@ -2103,26 +2098,0 @@\n-\n-        \/\/ Unnormalize\n-        if (excessInts != 0) {\n-            final int halfShift = excessInts << 4;\n-            if (needRemainder && !rem.isZero()) {\n-                final int s0Ints = (halfShift + 31) >> 5;\n-                MutableBigInteger s0 = sqrt.getBlockZimmermann(0, sqrt.intLen, sqrt.offset + sqrt.intLen, s0Ints);\n-                if (s0.intLen == s0Ints)\n-                    s0.value[0] &= -1 >>> -halfShift; \/\/ Remove excess bits\n-\n-                if (!s0.isZero()) { \/\/ MutableBigInteger.multiply() assumes intLen != 0\n-                    MutableBigInteger twiceS0 = new MutableBigInteger(s0);\n-                    twiceS0.leftShift(1);\n-                    MutableBigInteger doubleProd = new MutableBigInteger();\n-                    twiceS0.multiply(sqrt, doubleProd); \/\/ Use classic multiplication\n-\n-                    MutableBigInteger s0Sqr = new MutableBigInteger();\n-                    s0.multiply(s0, s0Sqr);\n-\n-                    rem.add(doubleProd);\n-                    rem.subtract(s0Sqr);\n-                }\n-                rem.intLen -= excessInts;\n-            }\n-            sqrt.rightShift(halfShift);\n-        }\n@@ -2138,1 +2107,0 @@\n-     * @param limit the offset which is the end of valid words in the input value\n@@ -2144,3 +2112,2 @@\n-    private MutableBigInteger getBlockZimmermann(int blockIndex, int len, int limit, int blockLen) {\n-        final int blockEnd = offset + len - blockIndex * blockLen;\n-        final int to = Math.min(blockEnd, limit);\n+    private MutableBigInteger getBlockZimmermann(int blockIndex, int len, int blockLen) {\n+        final int to = offset + len - blockIndex * blockLen;\n@@ -2150,1 +2117,1 @@\n-        for (from = blockEnd - blockLen; from < to && value[from] == 0; from++);\n+        for (from = to - blockLen; from < to && value[from] == 0; from++);\n@@ -2155,3 +2122,1 @@\n-        int[] block = new int[blockEnd - from];\n-        System.arraycopy(value, from, block, 0, to - from);\n-        return new MutableBigInteger(block);\n+        return new MutableBigInteger(Arrays.copyOfRange(value, from, to));\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":25,"deletions":60,"binary":false,"changes":85,"status":"modified"}]}