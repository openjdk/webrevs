{"files":[{"patch":"@@ -560,1 +560,1 @@\n-     * Assume {@code Math.ceilDiv(n, 32) <= intLen || intLen == 0}\n+     * Assumes {@code Math.ceilDiv(n, 32) <= intLen || intLen == 0}\n@@ -952,1 +952,1 @@\n-     * Assume {@code addend.intLen <= n}.\n+     * Assumes {@code addend.intLen <= n}.\n@@ -1942,1 +1942,1 @@\n-     * Assume {@code 2 <= len <= intLen && len % 2 == 0\n+     * Assumes {@code 2 <= len <= intLen && len % 2 == 0\n@@ -1960,1 +1960,0 @@\n-            \/\/ The first invocation is never a base case, so the remainder is needed\n@@ -1991,1 +1990,1 @@\n-            if (rem.subtract(qSqr) == -1) {\n+            if (rem.subtract(qSqr) < 0) {\n@@ -1995,0 +1994,3 @@\n+                \/\/ Since subtract() performs an absolute difference, to get the correct algebraic sum\n+                \/\/ we must first add the sum of absolute values of addends concordant with the sign of rem\n+                \/\/ and then subtract the sum of absolute values of addends that are discordant\n@@ -2001,1 +2003,1 @@\n-            if (u.compare(qSqr) == -1)\n+            if (u.compare(qSqr) < 0)\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/math\/BigInteger\/BigIntegerTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegerSquareRoot.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}