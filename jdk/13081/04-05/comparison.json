{"files":[{"patch":"@@ -803,7 +803,1 @@\n-void os::free(void *memblock) {\n-\n-  \/\/ Special handling for NMT preinit phase before arguments are parsed\n-  if (NMTPreInit::handle_free(memblock)) {\n-    return;\n-  }\n-\n+static void free_common(void *memblock) {\n@@ -822,1 +816,1 @@\n-void os::free_sized(void *memblock, size_t size) {\n+void os::free(void *memblock) {\n@@ -825,1 +819,1 @@\n-  if (NMTPreInit::handle_free_sized(memblock, size)) {\n+  if (NMTPreInit::handle_free(memblock)) {\n@@ -829,4 +823,2 @@\n-  if (memblock == nullptr) {\n-    assert(size == 0, \"size mismatch\");\n-    return;\n-  }\n+  free_common(memblock);\n+}\n@@ -834,1 +826,1 @@\n-  DEBUG_ONLY(break_if_ptr_caught(memblock);)\n+void os::free_sized(void *memblock, size_t size) {\n@@ -836,2 +828,4 @@\n-  \/\/ When NMT is enabled this checks for heap overwrites, then deaccounts the old block.\n-  void* const old_outer_ptr = MemTracker::record_free(memblock);\n+  \/\/ Special handling for NMT preinit phase before arguments are parsed\n+  if (NMTPreInit::handle_free_sized(memblock, size)) {\n+    return;\n+  }\n@@ -839,3 +833,1 @@\n-  \/\/ C23 introduced free_sized, but no libc implementations have added it yet at the time of\n-  \/\/ writing.\n-  ALLOW_C_FUNCTION(::free, ::free(old_outer_ptr);)\n+  free_common(memblock);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":11,"deletions":19,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -257,0 +257,42 @@\n+  static bool handle_free_common(void* p, size_t* size) {\n+    if (p == nullptr) { \/\/ free(null)\n+      assert(size == nullptr || *size == 0, \"size mismatch\");\n+      return true;\n+    }\n+    switch (MemTracker::tracking_level()) {\n+      case NMT_unknown: {\n+        \/\/ pre-NMT-init:\n+        \/\/ - the allocation must be in the hash map, since all allocations went through\n+        \/\/   NMTPreInit::handle_malloc()\n+        \/\/ - find the old entry, unhang from map, free it\n+        NMTPreInitAllocation* a = find_and_remove_in_map(p);\n+        assert(size == nullptr || a->size == *size, \"size mismatch\");\n+        NMTPreInitAllocation::do_free(a);\n+        _num_frees_pre++;\n+        return true;\n+      }\n+      break;\n+      case NMT_off: {\n+        \/\/ post-NMT-init, NMT *disabled*:\n+        \/\/ Neither pre- nor post-init-allocation use malloc headers, therefore we can just\n+        \/\/ relegate the realloc to os::realloc.\n+        return false;\n+      }\n+      break;\n+      default: {\n+        \/\/ post-NMT-init, NMT *enabled*:\n+        \/\/ - look up (but don't remove! lu table is read-only here.) the entry\n+        \/\/ - if found, we do nothing: the lu table is readonly, so we keep the old address\n+        \/\/   in the table. We leave the block allocated to prevent the libc from returning\n+        \/\/   the same address and confusing us.\n+        \/\/ - if not found, we let regular os::free() handle this pointer\n+        const NMTPreInitAllocation* a = find_in_map(p);\n+        if (a != nullptr) {\n+          assert(size == nullptr || a->size == *size, \"size mismatch\");\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n@@ -338,35 +380,1 @@\n-    if (p == nullptr) { \/\/ free(null)\n-      return true;\n-    }\n-    switch (MemTracker::tracking_level()) {\n-      case NMT_unknown: {\n-        \/\/ pre-NMT-init:\n-        \/\/ - the allocation must be in the hash map, since all allocations went through\n-        \/\/   NMTPreInit::handle_malloc()\n-        \/\/ - find the old entry, unhang from map, free it\n-        NMTPreInitAllocation* a = find_and_remove_in_map(p);\n-        NMTPreInitAllocation::do_free(a);\n-        _num_frees_pre++;\n-        return true;\n-      }\n-      break;\n-      case NMT_off: {\n-        \/\/ post-NMT-init, NMT *disabled*:\n-        \/\/ Neither pre- nor post-init-allocation use malloc headers, therefore we can just\n-        \/\/ relegate the realloc to os::realloc.\n-        return false;\n-      }\n-      break;\n-      default: {\n-        \/\/ post-NMT-init, NMT *enabled*:\n-        \/\/ - look up (but don't remove! lu table is read-only here.) the entry\n-        \/\/ - if found, we do nothing: the lu table is readonly, so we keep the old address\n-        \/\/   in the table. We leave the block allocated to prevent the libc from returning\n-        \/\/   the same address and confusing us.\n-        \/\/ - if not found, we let regular os::free() handle this pointer\n-        if (find_in_map(p) != nullptr) {\n-          return true;\n-        }\n-      }\n-    }\n-    return false;\n+    return handle_free_common(p, nullptr);\n@@ -376,39 +384,1 @@\n-    if (p == nullptr) { \/\/ free(null)\n-      assert(size == 0, \"size mismatch\");\n-      return true;\n-    }\n-    switch (MemTracker::tracking_level()) {\n-      case NMT_unknown: {\n-        \/\/ pre-NMT-init:\n-        \/\/ - the allocation must be in the hash map, since all allocations went through\n-        \/\/   NMTPreInit::handle_malloc()\n-        \/\/ - find the old entry, unhang from map, free it\n-        NMTPreInitAllocation* a = find_and_remove_in_map(p);\n-        assert(a->size == size, \"size mismatch\");\n-        NMTPreInitAllocation::do_free(a);\n-        _num_frees_pre++;\n-        return true;\n-      }\n-      break;\n-      case NMT_off: {\n-        \/\/ post-NMT-init, NMT *disabled*:\n-        \/\/ Neither pre- nor post-init-allocation use malloc headers, therefore we can just\n-        \/\/ relegate the realloc to os::realloc.\n-        return false;\n-      }\n-      break;\n-      default: {\n-        \/\/ post-NMT-init, NMT *enabled*:\n-        \/\/ - look up (but don't remove! lu table is read-only here.) the entry\n-        \/\/ - if found, we do nothing: the lu table is readonly, so we keep the old address\n-        \/\/   in the table. We leave the block allocated to prevent the libc from returning\n-        \/\/   the same address and confusing us.\n-        \/\/ - if not found, we let regular os::free() handle this pointer\n-        const NMTPreInitAllocation* a = find_in_map(p);\n-        if (a != nullptr) {\n-          assert(a->size == size, \"size mismatch\");\n-          return true;\n-        }\n-      }\n-    }\n-    return false;\n+    return handle_free_common(p, &size);\n","filename":"src\/hotspot\/share\/services\/nmtPreInit.hpp","additions":44,"deletions":74,"binary":false,"changes":118,"status":"modified"}]}