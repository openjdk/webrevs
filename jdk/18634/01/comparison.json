{"files":[{"patch":"@@ -2230,2 +2230,2 @@\n-    \/\/ Populate the archive regions' G1BlockOffsetTableParts. That ensures\n-    \/\/ fast G1BlockOffsetTablePart::block_start operations for any given address\n+    \/\/ Populate the archive regions' G1BlockOffsetTables. That ensures\n+    \/\/ fast G1BlockOffsetTable::block_start operations for any given address\n@@ -2234,1 +2234,1 @@\n-    G1CollectedHeap::heap()->populate_archive_regions_bot_part(_mapped_heap_memregion);\n+    G1CollectedHeap::heap()->populate_archive_regions_bot(_mapped_heap_memregion);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,4 +34,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ G1BlockOffsetTable\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n@@ -65,8 +61,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ G1BlockOffsetTablePart\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-G1BlockOffsetTablePart::G1BlockOffsetTablePart(G1BlockOffsetTable* array, HeapRegion* hr) :\n-  _bot(array),\n-  _hr(hr) {}\n-\n@@ -105,1 +93,1 @@\n-void G1BlockOffsetTablePart::set_remainder_to_point_to_start_incl(uint8_t* start_card, uint8_t* end_card) {\n+void G1BlockOffsetTable::set_remainder_to_point_to_start_incl(uint8_t* start_card, uint8_t* end_card) {\n@@ -107,2 +95,1 @@\n-  assert(start_card > _bot->entry_for_addr(_hr->bottom()), \"Cannot be first card\");\n-  assert(_bot->offset_array(start_card-1) < CardTable::card_size_in_words(),\n+  assert(offset_array(start_card-1) < CardTable::card_size_in_words(),\n@@ -119,1 +106,1 @@\n-      _bot->set_offset_array(start_card_for_region, end_card, offset);\n+      set_offset_array(start_card_for_region, end_card, offset);\n@@ -123,1 +110,1 @@\n-    _bot->set_offset_array(start_card_for_region, reach, offset);\n+    set_offset_array(start_card_for_region, reach, offset);\n@@ -134,1 +121,1 @@\n-void G1BlockOffsetTablePart::check_all_cards(uint8_t* start_card, uint8_t* end_card) const {\n+void G1BlockOffsetTable::check_all_cards(uint8_t* start_card, uint8_t* end_card) const {\n@@ -138,1 +125,1 @@\n-  guarantee(_bot->offset_array(start_card) == CardTable::card_size_in_words(), \"Wrong value in second card\");\n+  guarantee(offset_array(start_card) == CardTable::card_size_in_words(), \"Wrong value in second card\");\n@@ -140,1 +127,1 @@\n-    uint8_t entry = _bot->offset_array(c);\n+    uint8_t entry = offset_array(c);\n@@ -147,1 +134,1 @@\n-                (uint)entry, (uint)_bot->offset_array(c), CardTable::card_size_in_words());\n+                (uint)entry, (uint)offset_array(c), CardTable::card_size_in_words());\n@@ -153,1 +140,1 @@\n-      guarantee(_bot->offset_array(landing_card) <= entry,\n+      guarantee(offset_array(landing_card) <= entry,\n@@ -156,1 +143,1 @@\n-                (uint)_bot->offset_array(landing_card), (uint)entry);\n+                (uint)offset_array(landing_card), (uint)entry);\n@@ -160,1 +147,1 @@\n-      guarantee(_bot->offset_array(landing_card) < CardTable::card_size_in_words(),\n+      guarantee(offset_array(landing_card) < CardTable::card_size_in_words(),\n@@ -163,1 +150,1 @@\n-                (uint)_bot->offset_array(landing_card), (uint)CardTable::card_size_in_words());\n+                (uint)offset_array(landing_card), (uint)CardTable::card_size_in_words());\n@@ -179,1 +166,1 @@\n-void G1BlockOffsetTablePart::update_for_block_work(HeapWord* blk_start,\n+void G1BlockOffsetTable::update_for_block_work(HeapWord* blk_start,\n@@ -182,1 +169,1 @@\n-  uint8_t* const offset_card =  _bot->entry_for_addr(cur_card_boundary);\n+  uint8_t* const offset_card = entry_for_addr(cur_card_boundary);\n@@ -194,1 +181,1 @@\n-  assert(cur_card_boundary == _bot->addr_for_entry(offset_card),\n+  assert(cur_card_boundary == addr_for_entry(offset_card),\n@@ -198,1 +185,1 @@\n-  _bot->set_offset_array(offset_card, cur_card_boundary, blk_start);\n+  set_offset_array(offset_card, cur_card_boundary, blk_start);\n@@ -203,1 +190,1 @@\n-  uint8_t* end_card = _bot->entry_for_addr(blk_end - 1);\n+  uint8_t* end_card = entry_for_addr(blk_end - 1);\n@@ -213,1 +200,1 @@\n-  HeapWord* new_card_boundary = _bot->addr_for_entry(end_card) + CardTable::card_size_in_words();\n+  HeapWord* new_card_boundary = addr_for_entry(end_card) + CardTable::card_size_in_words();\n@@ -218,4 +205,4 @@\n-  uint8_t* previous_card = _bot->entry_for_addr(blk_start);\n-  HeapWord* boundary = _bot->addr_for_entry(previous_card);\n-  assert((_bot->offset_array(offset_card) == 0 && blk_start == boundary) ||\n-         (_bot->offset_array(offset_card) > 0 && _bot->offset_array(offset_card) < CardTable::card_size_in_words()),\n+  uint8_t* previous_card = entry_for_addr(blk_start);\n+  HeapWord* boundary = addr_for_entry(previous_card);\n+  assert((offset_array(offset_card) == 0 && blk_start == boundary) ||\n+         (offset_array(offset_card) > 0 && offset_array(offset_card) < CardTable::card_size_in_words()),\n@@ -226,1 +213,1 @@\n-         (uint)_bot->offset_array(offset_card),\n+         (uint)offset_array(offset_card),\n@@ -229,3 +216,2 @@\n-    assert(_bot->offset_array(j) > 0 &&\n-           _bot->offset_array(j) <=\n-             (uint8_t) (CardTable::card_size_in_words() + BOTConstants::N_powers - 1),\n+    assert(offset_array(j) > 0 &&\n+           offset_array(j) <= (uint8_t) (CardTable::card_size_in_words() + BOTConstants::N_powers - 1),\n@@ -234,2 +220,2 @@\n-           (uint) _bot->offset_array(j),\n-           (uint) _bot->offset_array(j),\n+           (uint) offset_array(j),\n+           (uint) offset_array(j),\n@@ -241,4 +227,4 @@\n-void G1BlockOffsetTablePart::verify() const {\n-  assert(_hr->bottom() < _hr->top(), \"Only non-empty regions should be verified.\");\n-  uint8_t* start_card = _bot->entry_for_addr(_hr->bottom());\n-  uint8_t* end_card = _bot->entry_for_addr(_hr->top() - 1);\n+void G1BlockOffsetTable::verify(const HeapRegion* hr) const {\n+  assert(hr->bottom() < hr->top(), \"Only non-empty regions should be verified.\");\n+  uint8_t* start_card = entry_for_addr(hr->bottom());\n+  uint8_t* end_card = entry_for_addr(hr->top() - 1);\n@@ -247,1 +233,1 @@\n-    uint8_t entry = _bot->offset_array(current_card);\n+    uint8_t entry = offset_array(current_card);\n@@ -252,1 +238,1 @@\n-      HeapWord* card_address = _bot->addr_for_entry(current_card);\n+      HeapWord* card_address = addr_for_entry(current_card);\n@@ -256,1 +242,1 @@\n-        size_t obj_size = _hr->block_size(obj);\n+        size_t obj_size = hr->block_size(obj);\n@@ -258,1 +244,1 @@\n-        guarantee(obj_end > obj && obj_end <= _hr->top(),\n+        guarantee(obj_end > obj && obj_end <= hr->top(),\n@@ -260,1 +246,1 @@\n-                  p2i(obj), obj_size, p2i(obj_end), p2i(_hr->top()));\n+                  p2i(obj), obj_size, p2i(obj_end), p2i(hr->top()));\n@@ -274,2 +260,2 @@\n-      HeapWord* backskip_address = _bot->addr_for_entry(current_card - backskip);\n-      guarantee(backskip_address >= _hr->bottom(),\n+      HeapWord* backskip_address = addr_for_entry(current_card - backskip);\n+      guarantee(backskip_address >= hr->bottom(),\n@@ -277,1 +263,1 @@\n-                p2i(_hr->bottom()), p2i(backskip_address));\n+                p2i(hr->bottom()), p2i(backskip_address));\n@@ -282,17 +268,2 @@\n-#ifndef PRODUCT\n-void G1BlockOffsetTablePart::print_on(outputStream* out) {\n-  uint8_t* from_card = _bot->entry_for_addr(_hr->bottom());\n-  uint8_t* to_card = _bot->entry_for_addr(_hr->end());\n-  out->print_cr(\">> BOT for area [\" PTR_FORMAT \",\" PTR_FORMAT \") \"\n-                \"cards [\" SIZE_FORMAT \",\" SIZE_FORMAT \")\",\n-                p2i(_hr->bottom()), p2i(_hr->end()), p2i(from_card), p2i(to_card));\n-  for (uint8_t* i = from_card; i < to_card; ++i) {\n-    out->print_cr(\"  entry \" SIZE_FORMAT_W(8) \" | \" PTR_FORMAT \" : %3u\",\n-                  p2i(i), p2i(_bot->addr_for_entry(i)),\n-                  (uint) _bot->offset_array(i));\n-  }\n-}\n-#endif \/\/ !PRODUCT\n-\n-void G1BlockOffsetTablePart::set_for_starts_humongous(HeapWord* obj_top, size_t fill_size) {\n-  update_for_block(_hr->bottom(), obj_top);\n+void G1BlockOffsetTable::set_for_starts_humongous(HeapRegion* hr, HeapWord* obj_top, size_t fill_size) {\n+  update_for_block(hr->bottom(), obj_top);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.cpp","additions":41,"deletions":70,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-class G1BlockOffsetTable;\n@@ -44,1 +43,1 @@\n-\/\/ Each G1BlockOffsetTablePart is owned by a HeapRegion.\n+\/\/ Each G1BlockOffsetTable is owned by a HeapRegion.\n@@ -47,1 +46,0 @@\n-  friend class G1BlockOffsetTablePart;\n@@ -76,0 +74,17 @@\n+  \/\/ Sets the entries corresponding to the cards starting at \"start\" and ending\n+  \/\/ at \"end\" to point back to the card before \"start\"; [start, end]\n+  void set_remainder_to_point_to_start_incl(uint8_t* start, uint8_t* end);\n+\n+  \/\/ Update BOT entries corresponding to the mem range [blk_start, blk_end).\n+  void update_for_block_work(HeapWord* blk_start, HeapWord* blk_end);\n+\n+  void check_all_cards(uint8_t* left_card, uint8_t* right_card) const NOT_DEBUG_RETURN;\n+\n+  static HeapWord* align_up_by_card_size(HeapWord* const addr) {\n+    return align_up(addr, CardTable::card_size());\n+  }\n+\n+  void update_for_block(HeapWord* blk_start, size_t size) {\n+    update_for_block(blk_start, blk_start + size);\n+  }\n+\n@@ -99,8 +114,0 @@\n-};\n-\n-class G1BlockOffsetTablePart {\n-  friend class G1BlockOffsetTable;\n-  friend class VMStructs;\n-private:\n-  \/\/ This is the global BlockOffsetTable.\n-  G1BlockOffsetTable* _bot;\n@@ -108,20 +115,0 @@\n-  \/\/ The region that owns this part of the BOT.\n-  HeapRegion* _hr;\n-\n-  \/\/ Sets the entries corresponding to the cards starting at \"start\" and ending\n-  \/\/ at \"end\" to point back to the card before \"start\"; [start, end]\n-  void set_remainder_to_point_to_start_incl(uint8_t* start, uint8_t* end);\n-\n-  \/\/ Update BOT entries corresponding to the mem range [blk_start, blk_end).\n-  void update_for_block_work(HeapWord* blk_start, HeapWord* blk_end);\n-\n-  void check_all_cards(uint8_t* left_card, uint8_t* right_card) const NOT_DEBUG_RETURN;\n-\n-  static HeapWord* align_up_by_card_size(HeapWord* const addr) {\n-    return align_up(addr, CardTable::card_size());\n-  }\n-\n-  void update_for_block(HeapWord* blk_start, size_t size) {\n-    update_for_block(blk_start, blk_start + size);\n-  }\n-public:\n@@ -135,4 +122,1 @@\n-  \/\/  The elements of the array are initialized to zero.\n-  G1BlockOffsetTablePart(G1BlockOffsetTable* array, HeapRegion* hr);\n-\n-  void verify() const;\n+  void verify(const HeapRegion* hr) const;\n@@ -150,3 +134,1 @@\n-  void set_for_starts_humongous(HeapWord* obj_top, size_t fill_size);\n-\n-  void print_on(outputStream* out) PRODUCT_RETURN;\n+  void set_for_starts_humongous(HeapRegion* hr, HeapWord* obj_top, size_t fill_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":20,"deletions":38,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-inline HeapWord* G1BlockOffsetTablePart::block_start_reaching_into_card(const void* addr) const {\n-  assert(addr >= _hr->bottom() && addr < _hr->top(), \"invalid address\");\n+inline HeapWord* G1BlockOffsetTable::block_start_reaching_into_card(const void* addr) const {\n+  assert(_reserved.contains(addr), \"invalid address\");\n@@ -38,11 +38,2 @@\n-#ifdef ASSERT\n-  if (!_hr->is_continues_humongous()) {\n-    \/\/ For non-ContinuesHumongous regions, the first obj always starts from bottom.\n-    uint8_t offset = _bot->offset_array(_bot->entry_for_addr(_hr->bottom()));\n-    assert(offset == 0, \"Found offset %u instead of 0 for region %u %s\",\n-           offset, _hr->hrm_index(), _hr->get_short_type_str());\n-  }\n-#endif\n-\n-  uint8_t* entry = _bot->entry_for_addr(addr);\n-  uint8_t offset = _bot->offset_array(entry);\n+  uint8_t* entry = entry_for_addr(addr);\n+  uint8_t offset = offset_array(entry);\n@@ -54,1 +45,1 @@\n-    offset = _bot->offset_array(entry);\n+    offset = offset_array(entry);\n@@ -57,1 +48,1 @@\n-  HeapWord* q = _bot->addr_for_entry(entry);\n+  HeapWord* q = addr_for_entry(entry);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -535,1 +535,1 @@\n-void G1CollectedHeap::populate_archive_regions_bot_part(MemRegion range) {\n+void G1CollectedHeap::populate_archive_regions_bot(MemRegion range) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -720,1 +720,1 @@\n-  \/\/ Populate the G1BlockOffsetTablePart for archived regions with the given\n+  \/\/ Populate the G1BlockOffsetTable for archived regions with the given\n@@ -722,1 +722,1 @@\n-  void populate_archive_regions_bot_part(MemRegion range);\n+  void populate_archive_regions_bot(MemRegion range);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-  _bot_part.set_for_starts_humongous(obj_top, fill_size);\n+  _bot->set_for_starts_humongous(this, obj_top, fill_size);\n@@ -222,1 +222,1 @@\n-  _bot_part(bot, this),\n+  _bot(bot),\n@@ -681,1 +681,1 @@\n-    _bot_part.verify();\n+    _bot->verify(this);\n@@ -710,1 +710,1 @@\n-  _bot_part.update_for_block(start, end);\n+  _bot->update_for_block(start, end);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-  G1BlockOffsetTablePart _bot_part;\n+  G1BlockOffsetTable* _bot;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    assert(!G1BlockOffsetTablePart::is_crossing_card_boundary(cur_block, (HeapWord*)addr), \"must be\");\n+    assert(!G1BlockOffsetTable::is_crossing_card_boundary(cur_block, (HeapWord*)addr), \"must be\");\n@@ -108,1 +108,1 @@\n-  HeapWord* first_block = _bot_part.block_start_reaching_into_card(addr);\n+  HeapWord* first_block = _bot->block_start_reaching_into_card(addr);\n@@ -265,1 +265,1 @@\n-  _bot_part.update_for_block(obj_start, obj_end);\n+  _bot->update_for_block(obj_start, obj_end);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}