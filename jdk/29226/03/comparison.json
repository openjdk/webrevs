{"files":[{"patch":"@@ -1,264 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2011, Oracle and\/or its affiliates. All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- *   - Redistributions of source code must retain the above copyright\n- *     notice, this list of conditions and the following disclaimer.\n- *\n- *   - Redistributions in binary form must reproduce the above copyright\n- *     notice, this list of conditions and the following disclaimer in the\n- *     documentation and\/or other materials provided with the distribution.\n- *\n- *   - Neither the name of Oracle nor the names of its\n- *     contributors may be used to endorse or promote products derived\n- *     from this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n- * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-\/*\n- * This source code is provided to illustrate the usage of a given feature\n- * or technique and has been deliberately simplified. Additional steps\n- * required for a production-quality application, such as security checks,\n- * input validation and proper error handling, might not be present in\n- * this sample code.\n- *\/\n-\n-\n-\n-import java.util.EventObject;\n-import java.util.List;\n-import javax.swing.JTable;\n-import javax.swing.table.DefaultTableModel;\n-import javax.swing.table.TableCellEditor;\n-import javax.swing.table.TableCellRenderer;\n-import javax.swing.table.TableColumn;\n-\n-\n-\/**\n- *  The OldJTable is an unsupported class containing some methods that were\n- *  deleted from the JTable between releases 0.6 and 0.7\n- *\/\n-@SuppressWarnings(\"serial\")\n-public class OldJTable extends JTable\n-{\n-   \/*\n-    *  A new convenience method returning the index of the column in the\n-    *  co-ordinate space of the view.\n-    *\/\n-    public int getColumnIndex(Object identifier) {\n-        return getColumnModel().getColumnIndex(identifier);\n-    }\n-\n-\/\/\n-\/\/  Methods deleted from the JTable because they only work with the\n-\/\/  DefaultTableModel.\n-\/\/\n-\n-    public TableColumn addColumn(Object columnIdentifier, int width) {\n-        return addColumn(columnIdentifier, width, null, null, null);\n-    }\n-\n-    public TableColumn addColumn(Object columnIdentifier, List<?> columnData) {\n-        return addColumn(columnIdentifier, -1, null, null, columnData);\n-    }\n-\n-    \/\/ Override the new JTable implementation - it will not add a column to the\n-    \/\/ DefaultTableModel.\n-    public TableColumn addColumn(Object columnIdentifier, int width,\n-                                 TableCellRenderer renderer,\n-                                 TableCellEditor editor) {\n-        return addColumn(columnIdentifier, width, renderer, editor, null);\n-    }\n-\n-    public TableColumn addColumn(Object columnIdentifier, int width,\n-                                 TableCellRenderer renderer,\n-                                 TableCellEditor editor, List<?> columnData) {\n-        checkDefaultTableModel();\n-\n-        \/\/ Set up the model side first\n-        DefaultTableModel m = (DefaultTableModel)getModel();\n-        m.addColumn(columnIdentifier, columnData.toArray());\n-\n-        \/\/ The column will have been added to the end, so the index of the\n-        \/\/ column in the model is the last element.\n-        TableColumn newColumn = new TableColumn(\n-                m.getColumnCount()-1, width, renderer, editor);\n-        super.addColumn(newColumn);\n-        return newColumn;\n-    }\n-\n-    \/\/ Not possilble to make this work the same way ... change it so that\n-    \/\/ it does not delete columns from the model.\n-    public void removeColumn(Object columnIdentifier) {\n-        super.removeColumn(getColumn(columnIdentifier));\n-    }\n-\n-    public void addRow(Object[] rowData) {\n-        checkDefaultTableModel();\n-        ((DefaultTableModel)getModel()).addRow(rowData);\n-    }\n-\n-    public void addRow(List<?> rowData) {\n-        checkDefaultTableModel();\n-        ((DefaultTableModel)getModel()).addRow(rowData.toArray());\n-    }\n-\n-    public void removeRow(int rowIndex) {\n-        checkDefaultTableModel();\n-        ((DefaultTableModel)getModel()).removeRow(rowIndex);\n-    }\n-\n-    public void moveRow(int startIndex, int endIndex, int toIndex) {\n-        checkDefaultTableModel();\n-        ((DefaultTableModel)getModel()).moveRow(startIndex, endIndex, toIndex);\n-    }\n-\n-    public void insertRow(int rowIndex, Object[] rowData) {\n-        checkDefaultTableModel();\n-        ((DefaultTableModel)getModel()).insertRow(rowIndex, rowData);\n-    }\n-\n-    public void insertRow(int rowIndex, List<?> rowData) {\n-        checkDefaultTableModel();\n-        ((DefaultTableModel)getModel()).insertRow(rowIndex, rowData.toArray());\n-    }\n-\n-    public void setNumRows(int newSize) {\n-        checkDefaultTableModel();\n-        ((DefaultTableModel)getModel()).setNumRows(newSize);\n-    }\n-\n-    public void setDataVector(Object[][] newData, List<?> columnIds) {\n-        checkDefaultTableModel();\n-        ((DefaultTableModel)getModel()).setDataVector(\n-                newData, columnIds.toArray());\n-    }\n-\n-    public void setDataVector(Object[][] newData, Object[] columnIds) {\n-        checkDefaultTableModel();\n-        ((DefaultTableModel)getModel()).setDataVector(newData, columnIds);\n-    }\n-\n-    protected void checkDefaultTableModel() {\n-        if(!(dataModel instanceof DefaultTableModel))\n-            throw new InternalError(\"In order to use this method, the data model must be an instance of DefaultTableModel.\");\n-    }\n-\n-\/\/\n-\/\/  Methods removed from JTable in the move from identifiers to ints.\n-\/\/\n-\n-    public Object getValueAt(Object columnIdentifier, int rowIndex) {\n-        return super.getValueAt(rowIndex, getColumnIndex(columnIdentifier));\n-    }\n-\n-    public boolean isCellEditable(Object columnIdentifier, int rowIndex) {\n-        return super.isCellEditable(rowIndex, getColumnIndex(columnIdentifier));\n-    }\n-\n-    public void setValueAt(Object aValue, Object columnIdentifier, int rowIndex) {\n-        super.setValueAt(aValue, rowIndex, getColumnIndex(columnIdentifier));\n-    }\n-\n-    public boolean editColumnRow(Object identifier, int row) {\n-        return super.editCellAt(row, getColumnIndex(identifier));\n-    }\n-\n-    public void moveColumn(Object columnIdentifier, Object targetColumnIdentifier) {\n-        moveColumn(getColumnIndex(columnIdentifier),\n-                   getColumnIndex(targetColumnIdentifier));\n-    }\n-\n-    public boolean isColumnSelected(Object identifier) {\n-        return isColumnSelected(getColumnIndex(identifier));\n-    }\n-\n-    public TableColumn addColumn(int modelColumn, int width) {\n-        return addColumn(modelColumn, width, null, null);\n-    }\n-\n-    public TableColumn addColumn(int modelColumn) {\n-        return addColumn(modelColumn, 75, null, null);\n-    }\n-\n-    \/**\n-     *  Creates a new column with <I>modelColumn<\/I>, <I>width<\/I>,\n-     *  <I>renderer<\/I>, and <I>editor<\/I> and adds it to the end of\n-     *  the JTable's array of columns. This method also retrieves the\n-     *  name of the column using the model's <I>getColumnName(modelColumn)<\/I>\n-     *  method, and sets the both the header value and the identifier\n-     *  for this TableColumn accordingly.\n-     *  <p>\n-     *  The <I>modelColumn<\/I> is the index of the column in the model which\n-     *  will supply the data for this column in the table. This, like the\n-     *  <I>columnIdentifier<\/I> in previous releases, does not change as the\n-     *  columns are moved in the view.\n-     *  <p>\n-     *  For the rest of the JTable API, and all of its associated classes,\n-     *  columns are referred to in the co-ordinate system of the view, the\n-     *  index of the column in the model is kept inside the TableColumn\n-     *  and is used only to retrieve the information from the appropraite\n-     *  column in the model.\n-     *  <p>\n-     *\n-     *  @param  modelColumn     The index of the column in the model\n-     *  @param  width           The new column's width.  Or -1 to use\n-     *                          the default width\n-     *  @param  renderer        The renderer used with the new column.\n-     *                          Or null to use the default renderer.\n-     *  @param  editor          The editor used with the new column.\n-     *                          Or null to use the default editor.\n-     *\/\n-    public TableColumn addColumn(int modelColumn, int width,\n-                                 TableCellRenderer renderer,\n-                                 TableCellEditor editor) {\n-        TableColumn newColumn = new TableColumn(\n-                modelColumn, width, renderer, editor);\n-        addColumn(newColumn);\n-        return newColumn;\n-    }\n-\n-\/\/\n-\/\/  Methods that had their arguments switched.\n-\/\/\n-\n-\/\/ These won't work with the new table package.\n-\n-\/*\n-    public Object getValueAt(int columnIndex, int rowIndex) {\n-        return super.getValueAt(rowIndex, columnIndex);\n-    }\n-\n-    public boolean isCellEditable(int columnIndex, int rowIndex) {\n-        return super.isCellEditable(rowIndex, columnIndex);\n-    }\n-\n-    public void setValueAt(Object aValue, int columnIndex, int rowIndex) {\n-        super.setValueAt(aValue, rowIndex, columnIndex);\n-    }\n-*\/\n-\n-    public boolean editColumnRow(int columnIndex, int rowIndex) {\n-        return super.editCellAt(rowIndex, columnIndex);\n-    }\n-\n-    public boolean editColumnRow(int columnIndex, int rowIndex, EventObject e){\n-        return super.editCellAt(rowIndex, columnIndex, e);\n-    }\n-\n-\n-}  \/\/ End Of Class OldJTable\n","filename":"src\/demo\/share\/jfc\/TableExample\/OldJTable.java","additions":0,"deletions":264,"binary":false,"changes":264,"status":"deleted"}]}