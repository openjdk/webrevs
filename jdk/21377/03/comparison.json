{"files":[{"patch":"@@ -567,2 +567,2 @@\n-                                size = get64(extra, off);\n-                                csize = get64(extra, off + 8);\n+                                size = get64S(extra, off);\n+                                csize = get64S(extra, off + 8);\n@@ -575,1 +575,1 @@\n-                                size = get64(extra, off);\n+                                size = get64S(extra, off);\n@@ -580,1 +580,1 @@\n-                                csize = get64(extra, off + 8);\n+                                csize = get64S(extra, off + 8);\n@@ -591,1 +591,1 @@\n-                    long wtime = get64(extra, pos + 4);\n+                    long wtime = get64S(extra, pos + 4);\n@@ -595,1 +595,1 @@\n-                    wtime = get64(extra, pos + 12);\n+                    wtime = get64S(extra, pos + 12);\n@@ -599,1 +599,1 @@\n-                    wtime = get64(extra, pos + 20);\n+                    wtime = get64S(extra, pos + 20);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipEntry.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -909,1 +909,1 @@\n-                        size = get64(cen, off);\n+                        size = get64S(cen, off);\n@@ -916,1 +916,1 @@\n-                        rem = get64(cen, off);\n+                        rem = get64S(cen, off);\n@@ -923,1 +923,1 @@\n-                        pos = get64(cen, off);\n+                        pos = get64S(cen, off);\n@@ -1379,1 +1379,1 @@\n-                    if (get64(cen, off) < 0) {\n+                    if (get64S(cen, off) < 0) {\n@@ -1391,1 +1391,1 @@\n-                    if (get64(cen, off) < 0) {\n+                    if (get64S(cen, off) < 0) {\n@@ -1403,1 +1403,1 @@\n-                    if (get64(cen, off) < 0) {\n+                    if (get64S(cen, off) < 0) {\n@@ -1644,4 +1644,1 @@\n-                    if (buf[i+0] == (byte)'P'    &&\n-                        buf[i+1] == (byte)'K'    &&\n-                        buf[i+2] == (byte)'\\005' &&\n-                        buf[i+3] == (byte)'\\006') {\n+                    if (get32(buf, i) == ENDSIG) {\n@@ -1667,1 +1664,1 @@\n-                                 GETSIG(sbuf) != CENSIG ||\n+                                 get32(sbuf, 0) != CENSIG ||\n@@ -1669,1 +1666,1 @@\n-                                 GETSIG(sbuf) != LOCSIG) {\n+                                 get32(sbuf, 0) != LOCSIG) {\n@@ -1684,1 +1681,1 @@\n-                                != loc64.length || GETSIG(loc64) != ZIP64_LOCSIG) {\n+                                != loc64.length || get32(loc64, 0) != ZIP64_LOCSIG) {\n@@ -1690,1 +1687,1 @@\n-                                != end64buf.length || GETSIG(end64buf) != ZIP64_ENDSIG) {\n+                                != end64buf.length || get32(end64buf, 0) != ZIP64_ENDSIG) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -606,2 +606,2 @@\n-                    e.csize = get64(tmpbuf, ZIP64_EXTSIZ - ZIP64_EXTCRC);\n-                    e.size = get64(tmpbuf, ZIP64_EXTLEN - ZIP64_EXTCRC);\n+                    e.csize = get64S(tmpbuf, ZIP64_EXTSIZ - ZIP64_EXTCRC);\n+                    e.size = get64S(tmpbuf, ZIP64_EXTLEN - ZIP64_EXTCRC);\n@@ -612,2 +612,2 @@\n-                    e.csize = get64(tmpbuf, ZIP64_EXTSIZ);\n-                    e.size = get64(tmpbuf, ZIP64_EXTLEN);\n+                    e.csize = get64S(tmpbuf, ZIP64_EXTSIZ);\n+                    e.size = get64S(tmpbuf, ZIP64_EXTLEN);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipInputStream.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -173,1 +174,4 @@\n-        return (b[off] & 0xff) | ((b[off + 1] & 0xff) << 8);\n+        Preconditions.checkIndex(off, b.length, Preconditions.AIOOBE_FORMATTER);\n+        Preconditions.checkIndex(off + 1, b.length, Preconditions.AIOOBE_FORMATTER);\n+        return Short.toUnsignedInt(\n+                UNSAFE.getShortUnaligned(b, off + Unsafe.ARRAY_BYTE_BASE_OFFSET, false));\n@@ -181,1 +185,4 @@\n-        return (get16(b, off) | ((long)get16(b, off+2) << 16)) & 0xffffffffL;\n+        Preconditions.checkIndex(off, b.length, Preconditions.AIOOBE_FORMATTER);\n+        Preconditions.checkIndex(off + 3, b.length, Preconditions.AIOOBE_FORMATTER);\n+        return Integer.toUnsignedLong(\n+                UNSAFE.getIntUnaligned(b, off + Unsafe.ARRAY_BYTE_BASE_OFFSET, false));\n@@ -188,2 +195,4 @@\n-    public static final long get64(byte[] b, int off) {\n-        return get32(b, off) | (get32(b, off+4) << 32);\n+    public static final long get64S(byte[] b, int off) {\n+        Preconditions.checkIndex(off, b.length, Preconditions.AIOOBE_FORMATTER);\n+        Preconditions.checkIndex(off + 7, b.length, Preconditions.AIOOBE_FORMATTER);\n+        return UNSAFE.getLongUnaligned(b, off + Unsafe.ARRAY_BYTE_BASE_OFFSET, false);\n@@ -198,22 +207,3 @@\n-        return (get16(b, off) | (get16(b, off+2) << 16));\n-    }\n-\n-    \/\/ fields access methods\n-    static final int CH(byte[] b, int n) {\n-        return b[n] & 0xff ;\n-    }\n-\n-    static final int SH(byte[] b, int n) {\n-        return (b[n] & 0xff) | ((b[n + 1] & 0xff) << 8);\n-    }\n-\n-    static final long LG(byte[] b, int n) {\n-        return ((SH(b, n)) | (SH(b, n + 2) << 16)) & 0xffffffffL;\n-    }\n-\n-    static final long LL(byte[] b, int n) {\n-        return (LG(b, n)) | (LG(b, n + 4) << 32);\n-    }\n-\n-    static final long GETSIG(byte[] b) {\n-        return LG(b, 0);\n+        Preconditions.checkIndex(off, b.length, Preconditions.AIOOBE_FORMATTER);\n+        Preconditions.checkIndex(off + 3, b.length, Preconditions.AIOOBE_FORMATTER);\n+        return UNSAFE.getIntUnaligned(b, off + Unsafe.ARRAY_BYTE_BASE_OFFSET, false);\n@@ -234,10 +224,10 @@\n-    static final long LOCSIG(byte[] b) { return LG(b, 0); } \/\/ signature\n-    static final int  LOCVER(byte[] b) { return SH(b, 4); } \/\/ version needed to extract\n-    static final int  LOCFLG(byte[] b) { return SH(b, 6); } \/\/ general purpose bit flags\n-    static final int  LOCHOW(byte[] b) { return SH(b, 8); } \/\/ compression method\n-    static final long LOCTIM(byte[] b) { return LG(b, 10);} \/\/ modification time\n-    static final long LOCCRC(byte[] b) { return LG(b, 14);} \/\/ crc of uncompressed data\n-    static final long LOCSIZ(byte[] b) { return LG(b, 18);} \/\/ compressed data size\n-    static final long LOCLEN(byte[] b) { return LG(b, 22);} \/\/ uncompressed data size\n-    static final int  LOCNAM(byte[] b) { return SH(b, 26);} \/\/ filename length\n-    static final int  LOCEXT(byte[] b) { return SH(b, 28);} \/\/ extra field length\n+    static final long LOCSIG(byte[] b) { return get32(b, 0); } \/\/ signature\n+    static final int  LOCVER(byte[] b) { return get16(b, 4); } \/\/ version needed to extract\n+    static final int  LOCFLG(byte[] b) { return get16(b, 6); } \/\/ general purpose bit flags\n+    static final int  LOCHOW(byte[] b) { return get16(b, 8); } \/\/ compression method\n+    static final long LOCTIM(byte[] b) { return get32(b, 10);} \/\/ modification time\n+    static final long LOCCRC(byte[] b) { return get32(b, 14);} \/\/ crc of uncompressed data\n+    static final long LOCSIZ(byte[] b) { return get32(b, 18);} \/\/ compressed data size\n+    static final long LOCLEN(byte[] b) { return get32(b, 22);} \/\/ uncompressed data size\n+    static final int  LOCNAM(byte[] b) { return get16(b, 26);} \/\/ filename length\n+    static final int  LOCEXT(byte[] b) { return get16(b, 28);} \/\/ extra field length\n@@ -246,3 +236,3 @@\n-    static final long EXTCRC(byte[] b) { return LG(b, 4);}  \/\/ crc of uncompressed data\n-    static final long EXTSIZ(byte[] b) { return LG(b, 8);}  \/\/ compressed size\n-    static final long EXTLEN(byte[] b) { return LG(b, 12);} \/\/ uncompressed size\n+    static final long EXTCRC(byte[] b) { return get32(b, 4);}  \/\/ crc of uncompressed data\n+    static final long EXTSIZ(byte[] b) { return get32(b, 8);}  \/\/ compressed size\n+    static final long EXTLEN(byte[] b) { return get32(b, 12);} \/\/ uncompressed size\n@@ -251,13 +241,13 @@\n-    static final int  ENDSUB(byte[] b) { return SH(b, 8); }  \/\/ number of entries on this disk\n-    static final int  ENDTOT(byte[] b) { return SH(b, 10);}  \/\/ total number of entries\n-    static final long ENDSIZ(byte[] b) { return LG(b, 12);}  \/\/ central directory size\n-    static final long ENDOFF(byte[] b) { return LG(b, 16);}  \/\/ central directory offset\n-    static final int  ENDCOM(byte[] b) { return SH(b, 20);}  \/\/ size of ZIP file comment\n-    static final int  ENDCOM(byte[] b, int off) { return SH(b, off + 20);}\n-\n-    \/\/ zip64 end of central directory recoder fields\n-    static final long ZIP64_ENDTOD(byte[] b) { return LL(b, 24);}  \/\/ total number of entries on disk\n-    static final long ZIP64_ENDTOT(byte[] b) { return LL(b, 32);}  \/\/ total number of entries\n-    static final long ZIP64_ENDSIZ(byte[] b) { return LL(b, 40);}  \/\/ central directory size\n-    static final long ZIP64_ENDOFF(byte[] b) { return LL(b, 48);}  \/\/ central directory offset\n-    static final long ZIP64_LOCOFF(byte[] b) { return LL(b, 8);}   \/\/ zip64 end offset\n+    static final int  ENDSUB(byte[] b) { return get16(b, 8); }  \/\/ number of entries on this disk\n+    static final int  ENDTOT(byte[] b) { return get16(b, 10);}  \/\/ total number of entries\n+    static final long ENDSIZ(byte[] b) { return get32(b, 12);}  \/\/ central directory size\n+    static final long ENDOFF(byte[] b) { return get32(b, 16);}  \/\/ central directory offset\n+    static final int  ENDCOM(byte[] b) { return get16(b, 20);}  \/\/ size of ZIP file comment\n+    static final int  ENDCOM(byte[] b, int off) { return get16(b, off + 20);}\n+\n+    \/\/ zip64 end of central directory record fields\n+    static final long ZIP64_ENDTOD(byte[] b) { return get64S(b, 24);}  \/\/ total number of entries on disk\n+    static final long ZIP64_ENDTOT(byte[] b) { return get64S(b, 32);}  \/\/ total number of entries\n+    static final long ZIP64_ENDSIZ(byte[] b) { return get64S(b, 40);}  \/\/ central directory size\n+    static final long ZIP64_ENDOFF(byte[] b) { return get64S(b, 48);}  \/\/ central directory offset\n+    static final long ZIP64_LOCOFF(byte[] b) { return get64S(b, 8);}   \/\/ zip64 end offset\n@@ -266,18 +256,18 @@\n-    static final long CENSIG(byte[] b, int pos) { return LG(b, pos + 0); }\n-    static final int  CENVEM(byte[] b, int pos) { return SH(b, pos + 4); }\n-    static final int  CENVEM_FA(byte[] b, int pos) { return CH(b, pos + 5); } \/\/ file attribute compatibility\n-    static final int  CENVER(byte[] b, int pos) { return SH(b, pos + 6); }\n-    static final int  CENFLG(byte[] b, int pos) { return SH(b, pos + 8); }\n-    static final int  CENHOW(byte[] b, int pos) { return SH(b, pos + 10);}\n-    static final long CENTIM(byte[] b, int pos) { return LG(b, pos + 12);}\n-    static final long CENCRC(byte[] b, int pos) { return LG(b, pos + 16);}\n-    static final long CENSIZ(byte[] b, int pos) { return LG(b, pos + 20);}\n-    static final long CENLEN(byte[] b, int pos) { return LG(b, pos + 24);}\n-    static final int  CENNAM(byte[] b, int pos) { return SH(b, pos + 28);}\n-    static final int  CENEXT(byte[] b, int pos) { return SH(b, pos + 30);}\n-    static final int  CENCOM(byte[] b, int pos) { return SH(b, pos + 32);}\n-    static final int  CENDSK(byte[] b, int pos) { return SH(b, pos + 34);}\n-    static final int  CENATT(byte[] b, int pos) { return SH(b, pos + 36);}\n-    static final long CENATX(byte[] b, int pos) { return LG(b, pos + 38);}\n-    static final int  CENATX_PERMS(byte[] b, int pos) { return SH(b, pos + 40);} \/\/ posix permission data\n-    static final long CENOFF(byte[] b, int pos) { return LG(b, pos + 42);}\n+    static final long CENSIG(byte[] b, int pos) { return get32(b, pos + 0); }\n+    static final int  CENVEM(byte[] b, int pos) { return get16(b, pos + 4); }\n+    static final int  CENVEM_FA(byte[] b, int pos) { return Byte.toUnsignedInt(b[pos + 5]); } \/\/ file attribute compatibility\n+    static final int  CENVER(byte[] b, int pos) { return get16(b, pos + 6); }\n+    static final int  CENFLG(byte[] b, int pos) { return get16(b, pos + 8); }\n+    static final int  CENHOW(byte[] b, int pos) { return get16(b, pos + 10);}\n+    static final long CENTIM(byte[] b, int pos) { return get32(b, pos + 12);}\n+    static final long CENCRC(byte[] b, int pos) { return get32(b, pos + 16);}\n+    static final long CENSIZ(byte[] b, int pos) { return get32(b, pos + 20);}\n+    static final long CENLEN(byte[] b, int pos) { return get32(b, pos + 24);}\n+    static final int  CENNAM(byte[] b, int pos) { return get16(b, pos + 28);}\n+    static final int  CENEXT(byte[] b, int pos) { return get16(b, pos + 30);}\n+    static final int  CENCOM(byte[] b, int pos) { return get16(b, pos + 32);}\n+    static final int  CENDSK(byte[] b, int pos) { return get16(b, pos + 34);}\n+    static final int  CENATT(byte[] b, int pos) { return get16(b, pos + 36);}\n+    static final long CENATX(byte[] b, int pos) { return get32(b, pos + 38);}\n+    static final int  CENATX_PERMS(byte[] b, int pos) { return get16(b, pos + 40);} \/\/ posix permission data\n+    static final long CENOFF(byte[] b, int pos) { return get32(b, pos + 42);}\n@@ -296,1 +286,1 @@\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n@@ -298,2 +288,2 @@\n-    private static final long byteBufferArrayOffset = unsafe.objectFieldOffset(ByteBuffer.class, \"hb\");\n-    private static final long byteBufferOffsetOffset = unsafe.objectFieldOffset(ByteBuffer.class, \"offset\");\n+    private static final long byteBufferArrayOffset = UNSAFE.objectFieldOffset(ByteBuffer.class, \"hb\");\n+    private static final long byteBufferOffsetOffset = UNSAFE.objectFieldOffset(ByteBuffer.class, \"offset\");\n@@ -302,1 +292,1 @@\n-        return (byte[]) unsafe.getReference(byteBuffer, byteBufferArrayOffset);\n+        return (byte[]) UNSAFE.getReference(byteBuffer, byteBufferArrayOffset);\n@@ -306,1 +296,1 @@\n-        return unsafe.getInt(byteBuffer, byteBufferOffsetOffset);\n+        return UNSAFE.getInt(byteBuffer, byteBufferOffsetOffset);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipUtils.java","additions":65,"deletions":75,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,0 +110,9 @@\n+\n+    \/\/ Provide a simple one-off run without JMH dependencies enable simple debugging,\n+    \/\/ diagnostics and dual-purposing this micro as a startup test.\n+    public static void main(String... args) throws Exception {\n+        var bench = new ZipFileOpen();\n+        bench.size = 1024*4;\n+        bench.beforeRun();\n+        bench.openCloseZipFile();\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/zip\/ZipFileOpen.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"}]}