{"files":[{"patch":"@@ -2989,6 +2989,7 @@\n-\/\/------------------------------ insert_cmpi_loop_exit -------------------------------------\n-\/\/ Clone a signed compare loop exit from an unsigned compare and\n-\/\/ insert it before the unsigned cmp on the stay-in-loop path.\n-\/\/ All new nodes inserted in the dominator tree between the original\n-\/\/ if and it's projections.  The original if test is replaced with\n-\/\/ a constant to force the stay-in-loop path.\n+\/\/ Idea\n+\/\/ ----\n+\/\/ Partial Peeling tries to rotate the loop in such a way that it can later be turned into a counted loop. Counted loops\n+\/\/ require a signed loop exit test. When calling this method, we've only found a suitable unsigned test to partial peel\n+\/\/ with. Therefore, we try to split off a signed loop exit test from the unsigned test such that it can be used as new\n+\/\/ loop exit while keeping the unsigned test unchanged and preserving the same behavior as if we've used the unsigned\n+\/\/ test alone instead:\n@@ -2996,4 +2997,8 @@\n-\/\/ This is done to make sure that the original if and it's projections\n-\/\/ still dominate the same set of control nodes, that the ctrl() relation\n-\/\/ from data nodes to them is preserved, and that their loop nesting is\n-\/\/ preserved.\n+\/\/ Before Partial Peeling:\n+\/\/   Loop:\n+\/\/     <peeled section>\n+\/\/     Split off signed loop exit test\n+\/\/     <-- CUT HERE -->\n+\/\/     Unchanged unsigned loop exit test\n+\/\/     <rest of unpeeled section>\n+\/\/     goto Loop\n@@ -3001,2 +3006,14 @@\n-\/\/ before\n-\/\/          if(i <u limit)    unsigned compare loop exit\n+\/\/ After Partial Peeling:\n+\/\/   <cloned peeled section>\n+\/\/   Cloned split off signed loop exit test\n+\/\/   Loop:\n+\/\/     Unchanged unsigned loop exit test\n+\/\/     <rest of unpeeled section>\n+\/\/     <peeled section>\n+\/\/     Split off signed loop exit test\n+\/\/     goto Loop\n+\/\/\n+\/\/ Details\n+\/\/ -------\n+\/\/ Before:\n+\/\/          if (i <u limit)    Unsigned loop exit condition\n@@ -3007,5 +3024,6 @@\n-\/\/ after\n-\/\/          if(stay-in-loop-const)  original if\n-\/\/         \/       |\n-\/\/        \/        v\n-\/\/       \/  if(i <  limit)    new signed test\n+\/\/ Split off a signed loop exit test (i.e. with CmpI) from an unsigned loop exit test (i.e. with CmpU) and insert it\n+\/\/ before the CmpU on the stay-in-loop path and keep both tests:\n+\/\/\n+\/\/          if (i <u limit)    Signed loop exit test\n+\/\/        \/        |\n+\/\/       \/  if (i <u limit)    Unsigned loop exit test\n@@ -3013,10 +3031,28 @@\n-\/\/     \/  \/        v\n-\/\/    \/  \/  if(i <u limit)    new cloned unsigned test\n-\/\/   \/  \/   \/      |\n-\/\/   v  v  v       |\n-\/\/    region       |\n-\/\/        |        |\n-\/\/      dum-if     |\n-\/\/     \/  |        |\n-\/\/ ether  |        |\n-\/\/        v        v\n+\/\/     v  v        v\n+\/\/  exit-region  stay-in-loop-proj\n+\/\/\n+\/\/ Implementation\n+\/\/ --------------\n+\/\/ We need to make sure that the new signed loop exit test is properly inserted into the graph such that the unsigned\n+\/\/ loop exit test still dominates the same set of control nodes, the ctrl() relation from data nodes to both loop\n+\/\/ exit tests is preserved, and their loop nesting is correct.\n+\/\/\n+\/\/ To achieve that, we clone the unsigned loop exit test completely (leave it unchanged), insert the signed loop exit\n+\/\/ test above it and kill the original unsigned loop exit test by setting it's condition to a constant\n+\/\/ (i.e. stay-in-loop-const in graph below) such that IGVN can fold it later:\n+\/\/\n+\/\/           if (stay-in-loop-const)  Killed original unsigned loop exit test\n+\/\/          \/       |\n+\/\/         \/        v\n+\/\/        \/  if (i <  limit)          Split off signed loop exit test\n+\/\/       \/  \/       |\n+\/\/      \/  \/        v\n+\/\/     \/  \/  if (i <u limit)          Cloned unsigned loop exit test\n+\/\/    \/  \/   \/      |\n+\/\/   v  v  v        |\n+\/\/  exit-region     |\n+\/\/        |         |\n+\/\/    dummy-if      |\n+\/\/     \/  |         |\n+\/\/ other  |         |\n+\/\/        v         v\n@@ -3025,1 +3061,6 @@\n-IfNode* PhaseIdealLoop::insert_cmpi_loop_exit(IfNode* if_cmpu, IdealLoopTree *loop) {\n+\/\/ Requirements\n+\/\/ ------------\n+\/\/ Note that we can only split off a signed loop exit test from the unsigned loop exit test when the behavior is exactly\n+\/\/ the same as before with only a single unsigned test. This is only possible if certain requirements are met.\n+\/\/ Otherwise, we need to bail out (see comments in the code below).\n+IfNode* PhaseIdealLoop::insert_cmpi_loop_exit(IfNode* if_cmpu, IdealLoopTree* loop) {\n@@ -3030,1 +3071,3 @@\n-  if (bol->_test._test != BoolTest::lt) return nullptr;\n+  if (bol->_test._test != BoolTest::lt) {\n+    return nullptr;\n+  }\n@@ -3032,1 +3075,2 @@\n-  if (cmpu->Opcode() != Op_CmpU) return nullptr;\n+  assert(cmpu->Opcode() == Op_CmpU, \"must be unsigned comparison\");\n+\n@@ -3034,1 +3078,3 @@\n-  if (stride == 0) return nullptr;\n+  if (stride == 0) {\n+    return nullptr;\n+  }\n@@ -3049,4 +3095,0 @@\n-  \/\/ If\n-  \/\/   limit >= 0   (COND)\n-  \/\/ then the unsigned loop exit condition is equivalent to the signed loop exit condition\n-  \/\/   i < 0 || i >= limit\n@@ -3054,2 +3096,20 @@\n-  \/\/ Note that this does not hold for limit < 0:\n-  \/\/ Example with i = -3 and limit = -2:\n+  \/\/ First, we note that for any x for which\n+  \/\/   0 <= x <= INT_MAX\n+  \/\/ we can convert x to an unsigned int and still get the same guarantee:\n+  \/\/   0 <=  (uint) x <=  INT_MAX = (uint) INT_MAX\n+  \/\/   0 <=u (uint) x <=u INT_MAX = (uint) INT_MAX   (LEMMA)\n+  \/\/\n+  \/\/ With that in mind, if\n+  \/\/   limit >= 0             (COND)\n+  \/\/ then the unsigned loop exit condition\n+  \/\/   i >=u limit            (ULE)\n+  \/\/ is equivalent to\n+  \/\/   i < 0 || i >= limit    (SLE-full)\n+  \/\/ because either i is negative and therefore always greater than MAX_INT when converting to unsigned\n+  \/\/   (uint) i >=u MAX_INT >= limit >= 0\n+  \/\/ or otherwise\n+  \/\/   i >= limit >= 0\n+  \/\/ holds due to (LEMMA).\n+  \/\/\n+  \/\/ For completeness, a counterexample with limit < 0:\n+  \/\/ Assume i = -3 and limit = -2:\n@@ -3068,5 +3128,6 @@\n-  \/\/ For stride < 0, we split off the signed loop exit condition\n-  \/\/   i < 0\n-  \/\/ and for stride > 0\n-  \/\/   i >= limit\n-  \/\/ such that we have the following graph before Partial Peeling:\n+  \/\/ From (SLE-full), we can extract a single signed loop exit condition depending on the stride:\n+  \/\/   stride < 0:\n+  \/\/     i < 0        (SLE-negative)\n+  \/\/   stride > 0:\n+  \/\/     i >= limit   (SLE-positive)\n+  \/\/ such that we have the following graph before Partial Peeling with stride > 0 (similar for stride < 0):\n@@ -3076,1 +3137,1 @@\n-  \/\/   Signed Loop Exit Condition i < 0 or i >= limit\n+  \/\/   i >= limit    (SLE-positive)\n@@ -3078,1 +3139,1 @@\n-  \/\/   Unsigned Loop Exit Condition i >=u limit\n+  \/\/   i >=u limit   (ULE)\n@@ -3082,14 +3143,20 @@\n-  \/\/ We either exit the loop with the Unsigned Loop Exit Condition if the Signed Loop Exit Condition is false, or we\n-  \/\/ exit the loop with the Signed Loop Exit Condition. In the latter case, the Unsigned Loop Exit Condition also needs\n-  \/\/ to be true (otherwise, we wrongly exit a loop that should not have been exited). More formally, we need to ensure:\n-  \/\/   \"Signed Loop Exit Test\" implies \"Unsigned Loop Exit Test\"\n-  \/\/ This is trivially given:\n-  \/\/ - Stride < 0:\n-  \/\/      i <   0        \/\/ Signed Loop Exit Condition\n-  \/\/      i >u  MAX_INT  \/\/ all negative values are greater than MAX_INT when converted to unsigned\n-  \/\/      i >=u limit    \/\/ limit <= MAX_INT (trivially) and since limit >= 0 assumption (COND)\n-  \/\/    which is the Unsigned Loop Exit Condition.\n-  \/\/ - Stride > 0:\n-  \/\/      i >=  limit   \/\/ Signed Loop Exit Condition\n-  \/\/      i >=u limit   \/\/ Since limit >= 0 assumption (COND)\n-  \/\/    which is the Unsigned Loop Exit Condition.\n+  \/\/ We exit the loop if:\n+  \/\/   (SLE) is true OR (ULE) is true\n+  \/\/ However, if (SLE) is true then (ULE) also needs to be true to ensure the exact same behavior. Otherwise, we wrongly\n+  \/\/ exit a loop that should not have been exited if we did not apply Partial Peeling. More formally, we need to ensure:\n+  \/\/   (SLE) IMPLIES (ULE)\n+  \/\/ This indeed holds when (COND) is given:\n+  \/\/ - stride > 0:\n+  \/\/       i >=  limit             \/\/ (SLE-positive)\n+  \/\/       i >=  limit >= 0        \/\/ (COND)\n+  \/\/       i >=u limit >= 0        \/\/ (LEMMA)\n+  \/\/     which is the unsigned loop exit condition (ULE).\n+  \/\/ - stride < 0:\n+  \/\/       i        <  0           \/\/ (SLE-negative)\n+  \/\/       (uint) i >u MAX_INT     \/\/ (NEG) all negative values are greater than MAX_INT when converted to unsigned\n+  \/\/       MAX_INT >= limit >= 0   \/\/ (COND)\n+  \/\/       MAX_INT >=u limit >= 0  \/\/ (LEMMA)\n+  \/\/     and thus from (NEG) and (LEMMA):\n+  \/\/       i >=u limit\n+  \/\/     which is the unsigned loop exit condition (ULE).\n+  \/\/\n@@ -3097,1 +3164,1 @@\n-  \/\/ After Partial Peeling, we have the following structure:\n+  \/\/ After Partial Peeling, we have the following structure for stride > 0 (similar for stride < 0):\n@@ -3099,1 +3166,1 @@\n-  \/\/   Signed Loop Exit Condition i < 0 or i >= limit\n+  \/\/   i >= limit (SLE)\n@@ -3101,1 +3168,1 @@\n-  \/\/     Unsigned Loop Exit Condition i >=u limit\n+  \/\/     i >=u limit (ULE)\n@@ -3104,1 +3171,1 @@\n-  \/\/     Signed Loop Exit Condition i < 0 or i >= limit\n+  \/\/     i >= limit (SLE)\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":129,"deletions":62,"binary":false,"changes":191,"status":"modified"}]}