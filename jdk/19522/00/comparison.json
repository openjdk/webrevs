{"files":[{"patch":"@@ -3046,3 +3046,61 @@\n-  \/\/ The loop exit condition is !(i <u limit) ==> (i < 0 || i >= limit).\n-  \/\/ Split out the exit condition (i < 0) for stride < 0 or (i >= limit) for stride > 0.\n-  Node* limit = nullptr;\n+  \/\/ The unsigned loop exit condition is\n+  \/\/   !(i <u  limit)\n+  \/\/ =   i >=u limit\n+  \/\/ If\n+  \/\/   limit >= 0   (COND)\n+  \/\/ then the unsigned loop exit condition is equivalent to the signed loop exit condition\n+  \/\/   i < 0 || i >= limit\n+  \/\/\n+  \/\/ Note that this does not hold for limit < 0:\n+  \/\/ Example with i = -3 and limit = -2:\n+  \/\/   i  < 0\n+  \/\/   -2 < 0\n+  \/\/ is true and thus also \"i < 0 || i >= limit\". But\n+  \/\/   i  >=u limit\n+  \/\/   -3 >=u -2\n+  \/\/ is false.\n+  Node* limit = cmpu->in(2);\n+  const TypeInt* type_limit = _igvn.type(limit)->is_int();\n+  if (type_limit->_lo < 0) {\n+    return nullptr;\n+  }\n+\n+  \/\/ For stride < 0, we split off the signed loop exit condition\n+  \/\/   i < 0\n+  \/\/ and for stride > 0\n+  \/\/   i >= limit\n+  \/\/ such that we have the following graph before Partial Peeling:\n+  \/\/\n+  \/\/ Loop:\n+  \/\/   <peeled section>\n+  \/\/   Signed Loop Exit Condition i < 0 or i >= limit\n+  \/\/   <-- CUT HERE -->\n+  \/\/   Unsigned Loop Exit Condition i >=u limit\n+  \/\/   <rest of unpeeled section>\n+  \/\/   goto Loop\n+  \/\/\n+  \/\/ We either exit the loop with the Unsigned Loop Exit Condition if the Signed Loop Exit Condition is false, or we\n+  \/\/ exit the loop with the Signed Loop Exit Condition. In the latter case, the Unsigned Loop Exit Condition also needs\n+  \/\/ to be true (otherwise, we wrongly exit a loop that should not have been exited). More formally, we need to ensure:\n+  \/\/   \"Signed Loop Exit Test\" implies \"Unsigned Loop Exit Test\"\n+  \/\/ This is trivially given:\n+  \/\/ - Stride < 0:\n+  \/\/      i <   0        \/\/ Signed Loop Exit Condition\n+  \/\/      i >u  MAX_INT  \/\/ all negative values are greater than MAX_INT when converted to unsigned\n+  \/\/      i >=u limit    \/\/ limit <= MAX_INT (trivially) and since limit >= 0 assumption (COND)\n+  \/\/    which is the Unsigned Loop Exit Condition.\n+  \/\/ - Stride > 0:\n+  \/\/      i >=  limit   \/\/ Signed Loop Exit Condition\n+  \/\/      i >=u limit   \/\/ Since limit >= 0 assumption (COND)\n+  \/\/    which is the Unsigned Loop Exit Condition.\n+  \/\/\n+  \/\/ After Partial Peeling, we have the following structure:\n+  \/\/   <cloned peeled section>\n+  \/\/   Signed Loop Exit Condition i < 0 or i >= limit\n+  \/\/   Loop:\n+  \/\/     Unsigned Loop Exit Condition i >=u limit\n+  \/\/     <rest of unpeeled section>\n+  \/\/     <peeled section>\n+  \/\/     Signed Loop Exit Condition i < 0 or i >= limit\n+  \/\/     goto Loop\n+  Node* rhs_cmpi;\n@@ -3050,1 +3108,1 @@\n-    limit = cmpu->in(2);\n+    rhs_cmpi = limit; \/\/ For i >= limit\n@@ -3052,2 +3110,2 @@\n-    limit = _igvn.makecon(TypeInt::ZERO);\n-    set_ctrl(limit, C->root());\n+    rhs_cmpi = _igvn.makecon(TypeInt::ZERO); \/\/ For i < 0\n+    set_ctrl(rhs_cmpi, C->root());\n@@ -3061,1 +3119,1 @@\n-  ProjNode* cmpi_exit = insert_if_before_proj(cmpu->in(1), Signed, rel_i, limit, lp_continue);\n+  ProjNode* cmpi_exit = insert_if_before_proj(cmpu->in(1), Signed, rel_i, rhs_cmpi, lp_continue);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":65,"deletions":7,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -0,0 +1,279 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=Xbatch\n+ * @bug 8332920\n+ * @summary Tests partial peeling at unsigned tests with limit being negative in exit tests \"i >u limit\".\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ *                   -XX:CompileOnly=*TestPartialPeel*::original*,*TestPartialPeel*::test*\n+ *                   compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n+ *\/\n+\n+\/*\n+ * @test id=Xcomp-run-inline\n+ * @bug 8332920\n+ * @summary Tests partial peeling at unsigned tests with limit being negative in exit tests \"i >u limit\".\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   -XX:CompileOnly=*TestPartialPeel*::original*,*TestPartialPeel*::run*\n+ *                   -XX:CompileCommand=inline,*TestPartialPeelAtUnsignedTestsNegativeLimit::test*\n+ *                   -XX:CompileCommand=dontinline,*TestPartialPeelAtUnsignedTestsNegativeLimit::check\n+ *                   compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n+ *\/\n+\n+\/*\n+ * @test id=Xcomp-compile-test\n+ * @bug 8332920\n+ * @summary Tests partial peeling at unsigned tests with limit being negative in exit tests \"i >u limit\".\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=*TestPartialPeel*::original*,*TestPartialPeel*::test*\n+ *                   compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n+ *\/\n+\n+\/*\n+ * @test id=vanilla\n+ * @bug 8332920\n+ * @summary Tests partial peeling at unsigned tests with limit being negative in exit tests \"i >u limit\".\n+ * @run main compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n+ *\/\n+\n+package compiler.loopopts;\n+\n+import static java.lang.Integer.*;\n+\n+public class TestPartialPeelAtUnsignedTestsNegativeLimit {\n+    static int iFld = 10000;\n+    static int iterations = 0;\n+    static int iFld2;\n+    static boolean flag;\n+\n+    public static void main(String[] args) {\n+        compareUnsigned(3, 3); \/\/ Load Integer class for -Xcomp\n+        for (int i = 0; i < 2; i++) {\n+            if (!originalTest()) {\n+                throw new RuntimeException(\"originalTest() failed\");\n+            }\n+        }\n+\n+        for (int i = 0; i < 2000; i++) {\n+            \/\/ For profiling\n+            iFld = -1;\n+            originalTestVariation1();\n+\n+            \/\/ Actual run\n+            iFld = MAX_VALUE - 100_000;\n+            if (!originalTestVariation1()) {\n+                throw new RuntimeException(\"originalTestVariation1() failed\");\n+            }\n+        }\n+\n+        for (int i = 0; i < 2000; ++i) {\n+            \/\/ For profiling\n+            iFld = MAX_VALUE;\n+            originalTestVariation2();\n+\n+            \/\/ Actual run\n+            iFld = MIN_VALUE + 100000;\n+            if (!originalTestVariation2()) {\n+                throw new RuntimeException(\"originalTestVariation2() failed\");\n+            }\n+        }\n+\n+        runWhileLTIncr();\n+        runWhileLTDecr();\n+    }\n+\n+    \/\/ Originally reported simplified regression test with 2 variations (see below).\n+    public static boolean originalTest() {\n+        for (int i = MAX_VALUE - 50_000; compareUnsigned(i, -1) < 0; i++) {\n+            if (compareUnsigned(MIN_VALUE, i) < 0) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public static boolean originalTestVariation1() {\n+        int a = 0;\n+        for (int i = iFld; compareUnsigned(i, -1) < 0; ++i) { \/\/ i <u -1\n+\n+            if (i >= Integer.MIN_VALUE + 1 && i <= 100) { \/\/ Transformed to unsigned test.\n+                return true;\n+            }\n+            a *= 23;\n+        }\n+        return false;\n+    }\n+\n+    public static boolean originalTestVariation2() {\n+        int a = 0;\n+        for (int i = iFld; compareUnsigned(i, -1000) < 0; i--) { \/\/ i <u -1\n+            if (compareUnsigned(MAX_VALUE - 20, i) > 0) {\n+                return true;\n+            }\n+            a = i;\n+        }\n+        System.out.println(a);\n+        return false;\n+    }\n+\n+\n+    public static void testWhileLTIncr(int init, int limit) {\n+        int i = init;\n+        while (true) {\n+            \/\/ <Peeled Section>\n+\n+            \/\/ Found as loop head in ciTypeFlow, but both path inside loop -> head not cloned.\n+            \/\/ As a result, this head has the safepoint as backedge instead of the loop exit test\n+            \/\/ and we cannot create a counted loop (yet). We first need to partial peel.\n+            if (flag) {\n+            }\n+\n+            iFld2++;\n+\n+            \/\/ Loop exit test i >=u limit (i.e. \"while (i <u limit)\") to partial peel with.\n+            \/\/ insert_cmpi_loop_exit() changes this exit condition into a signed and an unsigned test:\n+            \/\/   i >= limit && i >=u limit\n+            \/\/ where the signed condition can be used as proper loop exit condition for a counted loop\n+            \/\/ (we cannot use an unsigned counted loop exit condition).\n+            \/\/\n+            \/\/ After Partial Peeling, we have:\n+            \/\/   if (i >= limit) goto Exit\n+            \/\/ Loop:\n+            \/\/   if (i >=u limit) goto Exit\n+            \/\/   ...\n+            \/\/   i++;\n+            \/\/   if (i >= limit) goto Exit\n+            \/\/   goto Loop\n+            \/\/ Exit:\n+            \/\/   ...\n+            \/\/\n+            \/\/ If init = MAX_VALUE and limit = MIN_VALUE:\n+            \/\/   i >= limit\n+            \/\/   MAX_VALUE >= MIN_VALUE\n+            \/\/ which is true where\n+            \/\/   i >=u limit\n+            \/\/   MAX_VALUE >=u MIN_VALUE\n+            \/\/   MAX_VALUE >=u (uint)(MAX_INT + 1)\n+            \/\/ is false and we wrongly never enter the loop even though we should have.\n+            \/\/ This results in a wrong execution.\n+            if (compareUnsigned(i, limit) >= 0) {\n+                return;\n+            }\n+            \/\/ <-- Partial Peeling CUT -->\n+            \/\/ Safepoint\n+            \/\/ <Unpeeled Section>\n+            iterations++;\n+            i++;\n+        }\n+    }\n+\n+    \/\/ Same as testWhileLTIncr() but with decrement instead.\n+    public static void testWhileLTDecr(int init, int limit) {\n+        int i = init;\n+        while (true) {\n+            if (flag) {\n+            }\n+\n+            \/\/ Loop exit test.\n+            if (compareUnsigned(i, limit) >= 0) { \/\/ While (i <u limit)\n+                return;\n+            }\n+\n+            iterations++;\n+            i--;\n+        }\n+    }\n+\n+    public static void runWhileLTIncr() {\n+        \/\/ Currently works:\n+        testWhileLTIncr(MAX_VALUE, -1);\n+        check(MIN_VALUE); \/\/ MAX_VALUE + 1 iterations\n+        testWhileLTIncr(-1, 1);\n+        check(0);\n+        flag = !flag; \/\/ Change profiling\n+        testWhileLTIncr(MAX_VALUE - 2000, MAX_VALUE);\n+        check(2000);\n+        testWhileLTIncr(MAX_VALUE - 1990, MAX_VALUE);\n+        check(1990);\n+        testWhileLTIncr(MAX_VALUE - 1, MAX_VALUE);\n+        check(1);\n+        testWhileLTIncr(MIN_VALUE, MIN_VALUE + 2000);\n+        check(2000);\n+        testWhileLTIncr(MIN_VALUE, MIN_VALUE + 1990);\n+        check(1990);\n+        testWhileLTIncr(MIN_VALUE, MIN_VALUE + 1);\n+        check(1);\n+\n+        flag = !flag;\n+        \/\/ Overflow currently does not work with negative limit and is fixed with patch:\n+        testWhileLTIncr(MAX_VALUE, MIN_VALUE);\n+        check(1);\n+        testWhileLTIncr(MAX_VALUE - 2000, MIN_VALUE);\n+        check(2001);\n+        testWhileLTIncr(MAX_VALUE, MIN_VALUE + 2000);\n+        check(2001);\n+        testWhileLTIncr(MAX_VALUE - 2000, MIN_VALUE + 2000);\n+        check(4001);\n+    }\n+\n+    public static void runWhileLTDecr() {\n+        \/\/ Currently works:\n+        testWhileLTDecr(1, -1);\n+        check(2);\n+        testWhileLTDecr(-1, 1);\n+        check(0);\n+        flag = !flag;\n+        testWhileLTDecr(MAX_VALUE, MIN_VALUE);\n+        check(MIN_VALUE); \/\/ MAX_VALUE + 1 iterations\n+        testWhileLTDecr(MAX_VALUE, -1);\n+        check(MIN_VALUE); \/\/ MAX_VALUE + 1 iterations\n+        testWhileLTDecr(MAX_VALUE, MIN_VALUE);\n+        check(MIN_VALUE); \/\/ MAX_VALUE + 1 iterations\n+        testWhileLTDecr(MIN_VALUE, 0);\n+        check(0);\n+        testWhileLTDecr(MIN_VALUE, 1);\n+        check(0);\n+        flag = !flag;\n+\n+        \/\/ Underflow currently does not work with negative limit and is fixed with patch:\n+        testWhileLTDecr(MIN_VALUE, -1);\n+        check(MIN_VALUE + 1); \/\/ MAX_VALUE + 2 iterations\n+        testWhileLTDecr(MIN_VALUE, -2000);\n+        check(MIN_VALUE + 1); \/\/ MAX_VALUE + 2 iterations\n+        testWhileLTDecr(MIN_VALUE, MIN_VALUE + 1);\n+        check(MIN_VALUE + 1); \/\/ MAX_VALUE + 2 iterations\n+        testWhileLTDecr(MIN_VALUE + 2000, -1);\n+        check(MIN_VALUE + 2001); \/\/ MAX_VALUE + 2002 iterations\n+        testWhileLTDecr(MIN_VALUE + 2000, -2000);\n+        check(MIN_VALUE + 2001); \/\/ MAX_VALUE + 2002 iterations\n+        testWhileLTDecr(MIN_VALUE + 2000, MIN_VALUE + 2001);\n+        check(MIN_VALUE + 2001); \/\/ MAX_VALUE + 2002 iterations\n+    }\n+\n+    static void check(int expectedIterations) {\n+        if (expectedIterations != iterations) {\n+            throw new RuntimeException(\"Expected \" + expectedIterations + \" iterations but only got \" + iterations);\n+        }\n+        iterations = 0; \/\/ Reset\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestPartialPeelAtUnsignedTestsNegativeLimit.java","additions":279,"deletions":0,"binary":false,"changes":279,"status":"added"}]}