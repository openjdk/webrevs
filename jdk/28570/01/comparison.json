{"files":[{"patch":"@@ -747,1 +747,1 @@\n-    ac->set_adr_type(TypeRawPtr::BOTTOM);\n+    ac->set_out_adr_type(TypeRawPtr::BOTTOM);\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -889,1 +889,1 @@\n-    Node* mem_phi = new PhiNode(region, Type::MEMORY, TypeRawPtr::BOTTOM);\n+    Node* mem_phi = new PhiNode(region, Type::MEMORY, TypePtr::BOTTOM);\n@@ -917,1 +917,1 @@\n-                                       TypeRawPtr::BOTTOM,\n+                                       TypePtr::BOTTOM,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"opto\/opcodes.hpp\"\n@@ -805,1 +806,1 @@\n-      if (c->is_Call() && c->as_Call()->adr_type() != nullptr) {\n+      if (c->is_Call() && c->as_Call()->out_adr_type() != nullptr) {\n@@ -839,1 +840,1 @@\n-        assert(!c->is_Call() || c->as_Call()->adr_type() != nullptr || mem == nullptr, \"no mem projection expected\");\n+        assert(!c->is_Call() || c->as_Call()->out_adr_type() != nullptr || mem == nullptr, \"no mem projection expected\");\n@@ -1006,1 +1007,1 @@\n-  Node* call = new CallLeafNode(ShenandoahBarrierSetC2::load_reference_barrier_Type(), calladdr, name, TypeRawPtr::BOTTOM);\n+  Node* call = new CallLeafNode(ShenandoahBarrierSetC2::load_reference_barrier_Type(), calladdr, name, nullptr, nullptr);\n@@ -1604,0 +1605,3 @@\n+        } else if (mem->Opcode() == Op_StrInflatedCopy || mem->Opcode() == Op_StrCompressedCopy || mem->Opcode() == Op_EncodeISOArray) {\n+          stack.push(mem, mem->req());\n+          mem = mem->in(1);\n@@ -2148,3 +2152,4 @@\n-      } else if ((u->adr_type() == TypePtr::BOTTOM && u->Opcode() != Op_StrInflatedCopy) ||\n-                 u->adr_type() == nullptr) {\n-        assert(u->adr_type() != nullptr ||\n+      } else if ((u->in_adr_type() == TypePtr::BOTTOM &&\n+                  u->Opcode() != Op_StrInflatedCopy && mem->Opcode() != Op_StrCompressedCopy && mem->Opcode() != Op_EncodeISOArray) ||\n+                 u->in_adr_type() == nullptr) {\n+        assert(u->in_adr_type() != nullptr ||\n@@ -2156,1 +2161,1 @@\n-               u->Opcode() == Op_CallLeaf, \"\");\n+               u->Opcode() == Op_CallLeaf || u->Opcode() == Op_CallLeafNoFP, \"\");\n@@ -2163,1 +2168,1 @@\n-      } else if (_phase->C->get_alias_index(u->adr_type()) == alias) {\n+      } else if (_phase->C->get_alias_index(u->in_adr_type()) == alias) {\n@@ -2170,1 +2175,1 @@\n-      } else if (u->adr_type() != TypePtr::BOTTOM &&\n+      } else if (u->in_adr_type() != TypePtr::BOTTOM &&\n@@ -2334,3 +2339,4 @@\n-      } else if ((u->adr_type() == TypePtr::BOTTOM && u->Opcode() != Op_StrInflatedCopy) ||\n-                 u->adr_type() == nullptr) {\n-        assert(u->adr_type() != nullptr ||\n+      } else if ((u->in_adr_type() == TypePtr::BOTTOM &&\n+                  u->Opcode() != Op_StrInflatedCopy && mem->Opcode() != Op_StrCompressedCopy && mem->Opcode() != Op_EncodeISOArray) ||\n+                 u->in_adr_type() == nullptr) {\n+        assert(u->in_adr_type() != nullptr ||\n@@ -2342,1 +2348,1 @@\n-               u->Opcode() == Op_CallLeaf, \"%s\", u->Name());\n+               u->Opcode() == Op_CallLeaf || u->Opcode() == Op_CallLeafNoFP, \"%s\", u->Name());\n@@ -2350,1 +2356,1 @@\n-      } else if (_phase->C->get_alias_index(u->adr_type()) == _alias) {\n+      } else if (_phase->C->get_alias_index(u->in_adr_type()) == _alias) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -233,1 +233,0 @@\n-  virtual const class TypePtr *adr_type() const { return TypeOopPtr::BOTTOM; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  : CallNode(arraycopy_type(), nullptr, TypePtr::BOTTOM),\n+  : CallNode(arraycopy_type(), nullptr, TypePtr::BOTTOM, TypePtr::BOTTOM),\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -762,0 +762,4 @@\n+  if (in_adr_type() != nullptr && in(TypeFunc::Memory)->is_top()) {\n+    \/\/ The memory input died, this node should be dead, too\n+    return Type::TOP;\n+  }\n@@ -1693,0 +1697,2 @@\n+\/\/ The entire memory state is needed for slow path of the allocation since GC and deoptimization\n+\/\/ can happened, so in_adr_type = TypePtr::BOTTOM\n@@ -1696,1 +1702,1 @@\n-  : CallNode(atype, nullptr, TypeRawPtr::BOTTOM)\n+  : CallNode(atype, nullptr, TypeRawPtr::BOTTOM, TypePtr::BOTTOM)\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-  virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }\n@@ -85,0 +84,4 @@\n+\n+private:\n+  virtual const TypePtr* in_adr_type_impl() const { return nullptr; }\n+  virtual const TypePtr* out_adr_type_impl() const { return TypePtr::BOTTOM; }\n@@ -344,4 +347,4 @@\n-  \/\/ Many calls take *all* of memory as input,\n-  \/\/ but some produce a limited subset of that memory as output.\n-  \/\/ The adr_type reports the call's behavior as a store, not a load.\n-  const TypePtr*  _adr_type;  \/\/ What type of memory does this node produce?\n+  \/\/ Java calls consume and produce all memory, pure calls do not consume or produce memory,\n+  \/\/ runtime calls have various memory effects\n+  const TypePtr*  _out_adr_type;\n+  const TypePtr*  _in_adr_type;\n@@ -358,1 +361,1 @@\n-                const TypePtr* adr_type = nullptr)\n+                const TypePtr* out_adr_type = nullptr, const TypePtr* in_adr_type = nullptr)\n@@ -361,1 +364,2 @@\n-      _adr_type(adr_type),\n+      _out_adr_type(out_adr_type),\n+      _in_adr_type(in_adr_type),\n@@ -515,2 +519,1 @@\n-  virtual const TypePtr* adr_type() const { return _adr_type; }\n-  void set_adr_type(const TypePtr* adr_type) { _adr_type = adr_type; }\n+  void set_out_adr_type(const TypePtr* adr_type) { _out_adr_type = adr_type; }\n@@ -527,0 +530,4 @@\n+\n+private:\n+  virtual const TypePtr* out_adr_type_impl() const { return _out_adr_type; }\n+  virtual const TypePtr* in_adr_type_impl() const { return _in_adr_type; }\n@@ -699,2 +706,2 @@\n-  CallNode(const TypeFunc* tf, address addr, const TypePtr* adr_type, JVMState* jvms = nullptr)\n-    : SafePointNode(tf->domain()->cnt(), jvms, adr_type),\n+  CallNode(const TypeFunc* tf, address addr, const TypePtr* out_adr_type, const TypePtr* in_adr_type, JVMState* jvms = nullptr)\n+    : SafePointNode(tf->domain()->cnt(), jvms, out_adr_type, in_adr_type),\n@@ -785,1 +792,1 @@\n-    : CallNode(tf, addr, TypePtr::BOTTOM),\n+    : CallNode(tf, addr, TypePtr::BOTTOM, TypePtr::BOTTOM),\n@@ -830,1 +837,1 @@\n-  CallStaticJavaNode(const TypeFunc* tf, address addr, const char* name, const TypePtr* adr_type)\n+  CallStaticJavaNode(const TypeFunc* tf, address addr, const char* name, const TypePtr* out_adr_type, const TypePtr* in_adr_type)\n@@ -834,1 +841,2 @@\n-    _adr_type = adr_type;\n+    _out_adr_type = out_adr_type;\n+    _in_adr_type = in_adr_type;\n@@ -894,2 +902,2 @@\n-                  const TypePtr* adr_type, JVMState* jvms = nullptr)\n-    : CallNode(tf, addr, adr_type, jvms)\n+                  const TypePtr* out_adr_type, const TypePtr* in_adr_type, JVMState* jvms = nullptr)\n+    : CallNode(tf, addr, out_adr_type, in_adr_type, jvms)\n@@ -915,2 +923,2 @@\n-               const TypePtr* adr_type)\n-    : CallRuntimeNode(tf, addr, name, adr_type)\n+               const TypePtr* out_adr_type, const TypePtr* in_adr_type)\n+    : CallRuntimeNode(tf, addr, name, out_adr_type, in_adr_type)\n@@ -945,3 +953,1 @@\n-  CallLeafPureNode(const TypeFunc* tf, address addr, const char* name,\n-                   const TypePtr* adr_type)\n-      : CallLeafNode(tf, addr, name, adr_type) {\n+  CallLeafPureNode(const TypeFunc* tf, address addr, const char* name) : CallLeafNode(tf, addr, name, nullptr, nullptr) {\n@@ -960,2 +966,2 @@\n-                   const TypePtr* adr_type)\n-    : CallLeafNode(tf, addr, name, adr_type)\n+                   const TypePtr* out_adr_type, const TypePtr* in_adr_type)\n+    : CallLeafNode(tf, addr, name, out_adr_type, in_adr_type)\n@@ -978,2 +984,2 @@\n-                   const TypePtr* adr_type, uint num_bits)\n-    : CallLeafNode(tf, addr, name, adr_type), _num_bits(num_bits)\n+                   const TypePtr* out_adr_type, const TypePtr* in_adr_type, uint num_bits)\n+    : CallLeafNode(tf, addr, name, out_adr_type, in_adr_type), _num_bits(num_bits)\n@@ -1175,2 +1181,2 @@\n-  AbstractLockNode(const TypeFunc *tf)\n-    : CallNode(tf, nullptr, TypeRawPtr::BOTTOM),\n+  AbstractLockNode(const TypeFunc *tf, const TypePtr* out_adr_type, const TypePtr* in_adr_type)\n+    : CallNode(tf, nullptr, out_adr_type, in_adr_type),\n@@ -1257,1 +1263,1 @@\n-  LockNode(Compile* C, const TypeFunc *tf) : AbstractLockNode( tf ) {\n+  LockNode(Compile* C, const TypeFunc *tf) : AbstractLockNode(tf, TypeRawPtr::BOTTOM, TypePtr::BOTTOM) {\n@@ -1282,1 +1288,1 @@\n-  UnlockNode(Compile* C, const TypeFunc *tf) : AbstractLockNode( tf )\n+  UnlockNode(Compile* C, const TypeFunc *tf) : AbstractLockNode(tf, TypeRawPtr::BOTTOM, TypeRawPtr::BOTTOM)\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":35,"deletions":29,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1078,1 +1078,1 @@\n-  if (t == Type::MEMORY)  at = flatten_phi_adr_type(x->adr_type());\n+  if (t == Type::MEMORY)  at = flatten_phi_adr_type(x->out_adr_type());\n@@ -1084,1 +1084,1 @@\n-  if (t == Type::MEMORY)  at = flatten_phi_adr_type(x->adr_type());\n+  if (t == Type::MEMORY)  at = flatten_phi_adr_type(x->out_adr_type());\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -242,1 +242,0 @@\n-  virtual const TypePtr *adr_type() const { verify_adr_type(true); return _adr_type; }\n@@ -274,0 +273,3 @@\n+\n+private:\n+  virtual const TypePtr* out_adr_type_impl() const { verify_adr_type(true); return _adr_type; }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -2401,0 +2402,2 @@\n+  DEBUG_ONLY(verify_memory_graph());\n+\n@@ -2519,0 +2522,2 @@\n+  DEBUG_ONLY(verify_memory_graph());\n+\n@@ -3317,2 +3322,1 @@\n-      CallNode* new_call = new CallLeafNode(call->tf(), call->entry_point(),\n-                                            call->_name, TypeRawPtr::BOTTOM);\n+      CallNode* new_call = new CallLeafNode(call->tf(), call->entry_point(), call->_name, nullptr, nullptr);\n@@ -4422,0 +4426,104 @@\n+\n+\/\/ At each node, verify the soundness of the memory graph\n+void Compile::verify_memory_graph() {\n+  auto verify_edge = [&](Node* use, Node* def) {\n+    assert(def != nullptr, \"must have a memory input\");\n+    const TypePtr* use_in_adr = use->in_adr_type();\n+    const TypePtr* def_out_adr = def->out_adr_type();\n+    \/\/ A node cannot use more than what its memory input produces\n+    if (!C->must_alias(use_in_adr, get_alias_index(def_out_adr))) {\n+      stringStream ss;\n+      ss.print(\", in: \");\n+      if (def_out_adr == nullptr) {\n+        ss.print(\"nullptr\");\n+      } else {\n+        def_out_adr->dump_on(&ss);\n+      }\n+      ss.print(\", out: \");\n+      use_in_adr->dump_on(&ss);\n+      assert(false, \"Use %s consumes more than def %s produces%s\", use->Name(), def->Name(), ss.as_string());\n+    }\n+  };\n+\n+  auto verify_node = [&](Node* n) {\n+    const TypePtr* out_adr = n->out_adr_type();\n+    const TypePtr* in_adr = n->in_adr_type();\n+\n+    \/\/ out_adr_type verifies that it is contained in in_adr_type, we do it again for explicitness\n+    if (!n->is_Start() && out_adr != nullptr && in_adr != TypePtr::BOTTOM && in_adr != out_adr) {\n+      stringStream ss;\n+      ss.print(\", in: \");\n+      if (in_adr == nullptr) {\n+        ss.print(\"nullptr\");\n+      } else {\n+        in_adr->dump_on(&ss);\n+      }\n+      ss.print(\", out: \");\n+      out_adr->dump_on(&ss);\n+      assert(false, \"Node %s: in_adr_type must contain out_adr_type%s\", n->Name(), ss.as_string());\n+    }\n+\n+    if (in_adr == nullptr) {\n+      \/\/ Since in_adr == nullptr, out_adr == nullptr, too, or n is Start\n+      return;\n+    }\n+\n+    \/\/ These should have the same in_adr and out_adr\n+    if (n->is_Proj() || n->is_memory_phi() || n->is_MergeMem() || n->is_MemBar()) {\n+      if (in_adr != out_adr) {\n+        stringStream ss;\n+        ss.print(\", in: \");\n+        in_adr->dump_on(&ss);\n+        ss.print(\", out: \");\n+        if (out_adr == nullptr) {\n+          ss.print(\"nullptr\");\n+        } else {\n+          out_adr->dump_on(&ss);\n+        }\n+        assert(false, \"Node %s: in_adr_type should be the same as out_adr_type%s\", n->Name(), ss.as_string());\n+      }\n+    }\n+\n+    if (n->is_MergeMem()) {\n+      return;\n+    }\n+\n+    if (n->is_Mem()) {\n+      \/\/ This case includes LoadStore\n+      verify_edge(n, n->in(MemNode::Memory));\n+    } else if (n->is_Proj()) {\n+      if (!n->is_NarrowMemProj()) {\n+        verify_edge(n, n->in(0));\n+      }\n+    } else if (n->is_Phi()) {\n+      for (uint i = 1; i < n->req(); i++) {\n+        verify_edge(n, n->in(i));\n+      }\n+    } else if (n->bottom_type()->base() == Type::Tuple) {\n+      verify_edge(n, n->in(TypeFunc::Memory));\n+    } else if (n->is_ClearArray()) {\n+      verify_edge(n, n->in(1));\n+    } else if (n->Opcode() == Op_StrComp || n->Opcode() == Op_StrEquals || n->Opcode() == Op_StrIndexOf || n->Opcode() == Op_StrIndexOfChar ||\n+               n->Opcode() == Op_StrCompressedCopy || n->Opcode() == Op_StrInflatedCopy || n->Opcode() == Op_AryEq ||\n+               n->Opcode() == Op_CountPositives || n->Opcode() == Op_VectorizedHashCode || n->Opcode() == Op_EncodeISOArray) {\n+      verify_edge(n, n->in(1));\n+    } else {\n+      assert(false, \"unexpected memory consumer %s\", n->Name());\n+    }\n+  };\n+\n+  ResourceMark rm;\n+  Unique_Node_List wq;\n+  wq.push(root());\n+  for (uint i = 0; i < wq.size(); i++) {\n+    Node* n = wq.at(i);\n+    verify_node(n);\n+\n+    for (uint j = 0; j < n->req(); j++) {\n+      Node* in = n->in(j);\n+      if (in != nullptr) {\n+        wq.push(in);\n+      }\n+    }\n+  }\n+}\n@@ -5465,1 +5573,1 @@\n-  Node* call = new CallLeafNode(type, call_addr, \"debug_print\", TypeRawPtr::BOTTOM);\n+  Node* call = new CallLeafNode(type, call_addr, \"debug_print\", nullptr, nullptr);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":111,"deletions":3,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -1283,0 +1283,3 @@\n+  \/\/ Verify that the memory graph is sound\n+  void verify_memory_graph() PRODUCT_RETURN;\n+\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-ModFloatingNode::ModFloatingNode(Compile* C, const TypeFunc* tf, address addr, const char* name) : CallLeafPureNode(tf, addr, name, TypeRawPtr::BOTTOM) {\n+ModFloatingNode::ModFloatingNode(Compile* C, const TypeFunc* tf, address addr, const char* name) : CallLeafPureNode(tf, addr, name) {\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-  CallRuntimeNode* call = new CallRuntimeNode(c_sig, C_function, name, TypePtr::BOTTOM, new (C) JVMState(0));\n+  CallRuntimeNode* call = new CallRuntimeNode(c_sig, C_function, name, TypePtr::BOTTOM, TypePtr::BOTTOM, new (C) JVMState(0));\n","filename":"src\/hotspot\/share\/opto\/generateOptoStub.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1933,1 +1933,1 @@\n-    assert(C->alias_type(call->adr_type()) == C->alias_type(hook_mem),\n+    assert(C->alias_type(call->out_adr_type()) == C->alias_type(hook_mem),\n@@ -2495,0 +2495,3 @@\n+  bool wide_in  = !(flags & RC_NARROW_MEM);\n+  bool wide_out = (C->get_alias_index(adr_type) == Compile::AliasIdxBot);\n+\n@@ -2500,0 +2503,1 @@\n+  const TypePtr* in_adr_type = wide_in ? TypePtr::BOTTOM : adr_type;\n@@ -2501,1 +2505,1 @@\n-    call = new CallStaticJavaNode(call_type, call_addr, call_name, adr_type);\n+    call = new CallStaticJavaNode(call_type, call_addr, call_name, adr_type, in_adr_type);\n@@ -2503,1 +2507,1 @@\n-    call = new CallLeafNoFPNode(call_type, call_addr, call_name, adr_type);\n+    call = new CallLeafNoFPNode(call_type, call_addr, call_name, adr_type, in_adr_type);\n@@ -2506,1 +2510,1 @@\n-    call = new CallLeafVectorNode(call_type, call_addr, call_name, adr_type, num_bits);\n+    call = new CallLeafVectorNode(call_type, call_addr, call_name, adr_type, in_adr_type, num_bits);\n@@ -2508,1 +2512,2 @@\n-    call = new CallLeafPureNode(call_type, call_addr, call_name, adr_type);\n+    assert(adr_type == nullptr, \"adr_type for pure call must be null\");\n+    call = new CallLeafPureNode(call_type, call_addr, call_name);\n@@ -2510,1 +2515,1 @@\n-    call = new CallLeafNode(call_type, call_addr, call_name, adr_type);\n+    call = new CallLeafNode(call_type, call_addr, call_name, adr_type, in_adr_type);\n@@ -2516,4 +2521,0 @@\n-  \/\/ Slow path call has no side-effects, uses few values\n-  bool wide_in  = !(flags & RC_NARROW_MEM);\n-  bool wide_out = (C->get_alias_index(adr_type) == Compile::AliasIdxBot);\n-\n@@ -4157,1 +4158,1 @@\n-Node* GraphKit::capture_memory(const TypePtr* src_type, const TypePtr* dst_type) {\n+Node* GraphKit::capture_memory(const TypePtr*& combined_type, const TypePtr* src_type, const TypePtr* dst_type) {\n@@ -4160,0 +4161,1 @@\n+    combined_type = src_type;\n@@ -4162,7 +4164,4 @@\n-  MergeMemNode* merge = MergeMemNode::make(map()->memory());\n-  record_for_igvn(merge); \/\/ fold it up later, if possible\n-  int src_idx = C->get_alias_index(src_type);\n-  int dst_idx = C->get_alias_index(dst_type);\n-  merge->set_memory_at(src_idx, memory(src_idx));\n-  merge->set_memory_at(dst_idx, memory(dst_idx));\n-  return merge;\n+  Node* mem = reset_memory();\n+  set_all_memory(mem);\n+  combined_type = TypePtr::BOTTOM;\n+  return mem;\n@@ -4187,2 +4186,3 @@\n-  Node* mem = capture_memory(src_type, TypeAryPtr::BYTES);\n-  StrCompressedCopyNode* str = new StrCompressedCopyNode(control(), mem, src, dst, count);\n+  const TypePtr* adr_type = nullptr;\n+  Node* mem = capture_memory(adr_type, src_type, TypeAryPtr::BYTES);\n+  StrCompressedCopyNode* str = new StrCompressedCopyNode(control(), mem, adr_type, src, dst, count);\n@@ -4190,1 +4190,6 @@\n-  set_memory(res_mem, TypeAryPtr::BYTES);\n+\n+  if (adr_type == TypePtr::BOTTOM) {\n+    set_all_memory(res_mem);\n+  } else {\n+    set_memory(res_mem, adr_type);\n+  }\n@@ -4198,3 +4203,9 @@\n-  Node* mem = capture_memory(TypeAryPtr::BYTES, dst_type);\n-  StrInflatedCopyNode* str = new StrInflatedCopyNode(control(), mem, src, dst, count);\n-  set_memory(_gvn.transform(str), dst_type);\n+  const TypePtr* adr_type = nullptr;\n+  Node* mem = capture_memory(adr_type, TypeAryPtr::BYTES, dst_type);\n+  StrInflatedCopyNode* str = new StrInflatedCopyNode(control(), mem, adr_type, src, dst, count);\n+  Node* res_mem = _gvn.transform(str);\n+  if (adr_type == TypePtr::BOTTOM) {\n+    set_all_memory(res_mem);\n+  } else {\n+    set_memory(res_mem, adr_type);\n+  }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":35,"deletions":24,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -846,1 +846,1 @@\n-  Node* capture_memory(const TypePtr* src_type, const TypePtr* dst_type);\n+  Node* capture_memory(const TypePtr*& combined_type, const TypePtr* src_type, const TypePtr* dst_type);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -462,4 +462,12 @@\n-    if (n->adr_type() != nullptr) {\n-      stringStream adr_type_stream;\n-      n->adr_type()->dump_on(&adr_type_stream);\n-      print_prop(\"adr_type\", adr_type_stream.freeze());\n+    if (n->in_adr_type() != nullptr) {\n+      stringStream out_adr_type_stream;\n+      if (n->out_adr_type() == nullptr) {\n+        out_adr_type_stream.print(\"null\");\n+      } else {\n+        n->out_adr_type()->dump_on(&out_adr_type_stream);\n+      }\n+      print_prop(\"out_adr_type\", out_adr_type_stream.freeze());\n+\n+      stringStream in_adr_type_stream;\n+      n->in_adr_type()->dump_on(&in_adr_type_stream);\n+      print_prop(\"in_adr_type\", in_adr_type_stream.freeze());\n@@ -603,1 +611,1 @@\n-      MemNode::dump_adr_type(node->adr_type(), &s2);\n+      MemNode::dump_adr_type(node->out_adr_type(), &s2);\n@@ -609,1 +617,1 @@\n-    const TypePtr* adr_type = node->adr_type();\n+    const TypePtr* adr_type = node->in_adr_type();\n@@ -857,1 +865,1 @@\n-  const TypePtr* adr_type = node->adr_type();\n+  const TypePtr* adr_type = node->in_adr_type();\n@@ -880,1 +888,1 @@\n-    if (node->adr_type() != nullptr && node->adr_type()->isa_aryptr()) {\n+    if (node->in_adr_type() != nullptr && node->in_adr_type()->isa_aryptr()) {\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -473,1 +473,1 @@\n-  CallNode *call =  (CallNode*)new CallLeafNode( slow_call_type, slow_call, leaf_name, adr_type);\n+  CallNode *call =  (CallNode*)new CallLeafNode( slow_call_type, slow_call, leaf_name, adr_type, adr_type);\n@@ -525,1 +525,1 @@\n-  CallNode *call =  (CallNode*)new CallLeafNoFPNode( slow_call_type, slow_call, leaf_name, adr_type);\n+  CallNode *call =  (CallNode*)new CallLeafNoFPNode( slow_call_type, slow_call, leaf_name, adr_type, adr_type);\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,2 +67,0 @@\n-uint StrIntrinsicNode::size_of() const { return sizeof(*this); }\n-\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/type.hpp\"\n@@ -59,1 +60,5 @@\n-  virtual uint size_of() const;\n+  virtual uint size_of() const { return sizeof(StrIntrinsicNode); }\n+  virtual uint hash() const { return Node::hash() + _encoding; }\n+  virtual bool cmp(const Node& n) const {\n+    return Node::cmp(n) && _encoding == static_cast<const StrIntrinsicNode&>(n)._encoding;\n+  }\n@@ -78,1 +83,0 @@\n-  virtual const TypePtr* adr_type() const { return TypeAryPtr::BYTES; }\n@@ -94,0 +98,4 @@\n+\n+private:\n+  virtual const TypePtr* out_adr_type_impl() const { return nullptr; }\n+  virtual const TypePtr* in_adr_type_impl() const { return TypeAryPtr::BYTES; }\n@@ -104,0 +112,4 @@\n+\n+private:\n+  virtual const TypePtr* out_adr_type_impl() const { return nullptr; }\n+  virtual const TypePtr* in_adr_type_impl() const { return TypeAryPtr::BYTES; }\n@@ -114,0 +126,4 @@\n+\n+private:\n+  virtual const TypePtr* out_adr_type_impl() const { return nullptr; }\n+  virtual const TypePtr* in_adr_type_impl() const { return TypeAryPtr::BYTES; }\n@@ -124,0 +140,4 @@\n+\n+private:\n+  virtual const TypePtr* out_adr_type_impl() const { return nullptr; }\n+  virtual const TypePtr* in_adr_type_impl() const { return TypeAryPtr::BYTES; }\n@@ -128,2 +148,5 @@\n- public:\n-  StrCompressedCopyNode(Node* control, Node* arymem,\n+private:\n+  const TypePtr* const _adr_type;\n+\n+public:\n+  StrCompressedCopyNode(Node* control, Node* arymem, const TypePtr* adr_type,\n@@ -131,1 +154,1 @@\n-  StrIntrinsicNode(control, arymem, s1, s2, c, none) {};\n+  StrIntrinsicNode(control, arymem, s1, s2, c, none), _adr_type(adr_type) {};\n@@ -134,1 +157,0 @@\n-  virtual const TypePtr* adr_type() const { return TypePtr::BOTTOM; }\n@@ -136,0 +158,8 @@\n+\n+private:\n+  virtual uint size_of() const { return sizeof(StrCompressedCopyNode); }\n+  virtual uint hash() const { return StrIntrinsicNode::hash() + (uint)(uintptr_t) _adr_type; }\n+  virtual bool cmp(const Node& n) const {\n+    return StrIntrinsicNode::cmp(n) && _adr_type == static_cast<const StrCompressedCopyNode&>(n)._adr_type;\n+  }\n+  virtual const TypePtr* out_adr_type_impl() const { return _adr_type; }\n@@ -140,2 +170,5 @@\n- public:\n-  StrInflatedCopyNode(Node* control, Node* arymem,\n+private:\n+  const TypePtr* const _adr_type;\n+\n+public:\n+  StrInflatedCopyNode(Node* control, Node* arymem, const TypePtr* adr_type,\n@@ -143,1 +176,1 @@\n-  StrIntrinsicNode(control, arymem, s1, s2, c, none) {};\n+  StrIntrinsicNode(control, arymem, s1, s2, c, none), _adr_type(adr_type) {};\n@@ -146,1 +179,0 @@\n-  virtual const TypePtr* adr_type() const { return TypePtr::BOTTOM; }\n@@ -148,0 +180,9 @@\n+\n+private:\n+  virtual uint size_of() const { return sizeof(StrInflatedCopyNode); }\n+  virtual uint hash() const { return StrIntrinsicNode::hash() + (uint)(uintptr_t) _adr_type; }\n+  virtual bool cmp(const Node& n) const {\n+    const StrInflatedCopyNode& s = static_cast<const StrInflatedCopyNode&>(n);\n+    return StrIntrinsicNode::cmp(n) && _adr_type == s._adr_type;\n+  }\n+  virtual const TypePtr* out_adr_type_impl() const { return _adr_type; }\n@@ -152,2 +193,5 @@\n- public:\n-  AryEqNode(Node* control, Node* char_array_mem,\n+private:\n+  const TypeAryPtr* const _in_adr_type;\n+\n+public:\n+  AryEqNode(Node* control, Node* char_array_mem, const TypeAryPtr* in_adr_type,\n@@ -155,1 +199,1 @@\n-  StrIntrinsicNode(control, char_array_mem, s1, s2, encoding) {};\n+  StrIntrinsicNode(control, char_array_mem, s1, s2, encoding), _in_adr_type(in_adr_type) {};\n@@ -158,0 +202,9 @@\n+\n+private:\n+  virtual uint size_of() const { return sizeof(AryEqNode); }\n+  virtual uint hash() const { return StrIntrinsicNode::hash() + (uint)(uintptr_t) _in_adr_type; }\n+  virtual bool cmp(const Node& n) const {\n+    return StrIntrinsicNode::cmp(n) && _in_adr_type == static_cast<const AryEqNode&>(n)._in_adr_type;\n+  }\n+  virtual const TypePtr* out_adr_type_impl() const { return nullptr; }\n+  virtual const TypePtr* in_adr_type_impl() const { return _in_adr_type; }\n@@ -167,0 +220,4 @@\n+\n+private:\n+  virtual const TypePtr* out_adr_type_impl() const { return nullptr; }\n+  virtual const TypePtr* in_adr_type_impl() const { return TypeAryPtr::BYTES; }\n@@ -171,3 +228,6 @@\n- public:\n-  VectorizedHashCodeNode(Node* control, Node* ary_mem, Node* arg1, Node* cnt1, Node* result, Node* basic_type)\n-    : Node(control, ary_mem, arg1, cnt1, result, basic_type) {};\n+private:\n+  const TypeAryPtr* const _in_adr_type;\n+\n+public:\n+  VectorizedHashCodeNode(Node* control, Node* ary_mem, const TypeAryPtr* in_adr_type, Node* arg1, Node* cnt1, Node* result, Node* basic_type)\n+    : Node(control, ary_mem, arg1, cnt1, result, basic_type), _in_adr_type(in_adr_type) {};\n@@ -177,1 +237,0 @@\n-  virtual const TypePtr* adr_type() const { return TypePtr::BOTTOM; }\n@@ -182,0 +241,9 @@\n+\n+private:\n+  virtual uint size_of() const { return sizeof(VectorizedHashCodeNode); }\n+  virtual uint hash() const { return Node::hash() + (uint)(uintptr_t) _in_adr_type; }\n+  virtual bool cmp(const Node& n) const {\n+    return Node::cmp(n) && _in_adr_type == static_cast<const VectorizedHashCodeNode&>(n)._in_adr_type;\n+  }\n+  virtual const TypePtr* out_adr_type_impl() const { return nullptr; }\n+  virtual const TypePtr* in_adr_type_impl() const { return _in_adr_type; }\n@@ -187,0 +255,1 @@\n+  const TypePtr* const _adr_type;\n@@ -188,3 +257,4 @@\n- public:\n-  EncodeISOArrayNode(Node* control, Node* arymem, Node* s1, Node* s2, Node* c, bool ascii)\n-    : Node(control, arymem, s1, s2, c), _ascii(ascii) {}\n+\n+public:\n+  EncodeISOArrayNode(Node* control, Node* arymem, const TypePtr* adr_type, Node* s1, Node* s2, Node* c, bool ascii)\n+    : Node(control, arymem, s1, s2, c), _adr_type(adr_type), _ascii(ascii) {}\n@@ -196,1 +266,0 @@\n-  virtual const TypePtr* adr_type() const { return TypePtr::BOTTOM; }\n@@ -201,0 +270,2 @@\n+\n+private:\n@@ -202,1 +273,1 @@\n-  virtual uint hash() const { return Node::hash() + _ascii; }\n+  virtual uint hash() const { return Node::hash() + (uint)(uintptr_t) _adr_type + _ascii; }\n@@ -204,1 +275,2 @@\n-    return Node::cmp(n) && _ascii == ((EncodeISOArrayNode&)n).is_ascii();\n+    const EncodeISOArrayNode& e = static_cast<const EncodeISOArrayNode&>(n);\n+    return Node::cmp(n) && _ascii == e._ascii && _adr_type == e._adr_type;\n@@ -206,0 +278,1 @@\n+  virtual const TypePtr* out_adr_type_impl() const { return _adr_type; }\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":96,"deletions":23,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/accessDecorators.hpp\"\n@@ -61,0 +62,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -1124,1 +1126,1 @@\n-  set_result(_gvn.transform(new AryEqNode(control(), memory(mtype), arg1, arg2, ae)));\n+  set_result(_gvn.transform(new AryEqNode(control(), memory(mtype), mtype, arg1, arg2, ae)));\n@@ -3673,1 +3675,1 @@\n-  Node* thread_equal_carrierThread = _gvn.transform(new IfFalseNode(iff_thread_not_equal_carrierThread));\n+  set_control(_gvn.transform(new IfFalseNode(iff_thread_not_equal_carrierThread)));\n@@ -3675,3 +3677,3 @@\n-  Node* vthread_false_memory = store_to_memory(thread_equal_carrierThread, vthread_offset, _gvn.intcon(0), T_BOOLEAN, MemNode::release, true);\n-\n-  set_all_memory(input_memory_state);\n+  access_store_at(jt, vthread_offset, TypeRawPtr::BOTTOM, intcon(0), TypeInt::BOOL, T_BOOLEAN, IN_NATIVE | MO_RELEASE);\n+  Node* thread_equal_carrierThread = control();\n+  Node* vthread_false_memory = reset_memory();\n@@ -3682,0 +3684,1 @@\n+  set_all_memory(input_memory_state);\n@@ -3696,1 +3699,3 @@\n-  Node* tid_memory = store_to_memory(control(), thread_id_offset, tid, T_LONG, MemNode::unordered, true);\n+  store_to_memory(control(), thread_id_offset, tid, T_LONG, MemNode::unordered, true);\n+  Node* tid_memory = reset_memory();\n+  set_all_memory(tid_memory);\n@@ -3718,1 +3723,2 @@\n-  Node* included_memory = store_to_memory(control(), vthread_epoch_offset, epoch, T_CHAR, MemNode::unordered, true);\n+  store_to_memory(control(), vthread_epoch_offset, epoch, T_CHAR, MemNode::unordered, true);\n+  Node* included_memory = reset_memory();\n@@ -3744,1 +3750,2 @@\n-  Node * vthread_true_memory = store_to_memory(control(), vthread_offset, _gvn.intcon(1), T_BOOLEAN, MemNode::release, true);\n+  access_store_at(jt, vthread_offset, TypeRawPtr::BOTTOM, intcon(1), TypeInt::BOOL, T_BOOLEAN, IN_NATIVE | MO_RELEASE);\n+  Node* vthread_true_memory = reset_memory();\n@@ -6199,2 +6206,3 @@\n-  const TypeAryPtr* mtype = TypeAryPtr::BYTES;\n-  Node* enc = new EncodeISOArrayNode(control(), memory(mtype), src_start, dst_start, length, ascii);\n+  const TypePtr* adr_type = nullptr;\n+  Node* mem = capture_memory(adr_type, TypeAryPtr::get_array_body_type(src_elem), TypeAryPtr::BYTES);\n+  Node* enc = new EncodeISOArrayNode(control(), mem, adr_type, src_start, dst_start, length, ascii);\n@@ -6203,1 +6211,5 @@\n-  set_memory(res_mem, mtype);\n+  if (adr_type == TypePtr::BOTTOM) {\n+    set_all_memory(res_mem);\n+  } else {\n+    set_memory(res_mem, adr_type);\n+  }\n@@ -6682,1 +6694,2 @@\n-  set_result(_gvn.transform(new VectorizedHashCodeNode(control(), memory(TypeAryPtr::get_array_body_type(bt)),\n+  const TypeAryPtr* in_adr_type = TypeAryPtr::get_array_body_type(bt);\n+  set_result(_gvn.transform(new VectorizedHashCodeNode(control(), memory(in_adr_type), in_adr_type,\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":25,"deletions":12,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -4027,2 +4027,2 @@\n-  CallLeafNode *call = new CallLeafNoFPNode(call_type, fill,\n-                                            fill_name, TypeAryPtr::get_array_body_type(t));\n+  const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(t);\n+  CallLeafNode *call = new CallLeafNoFPNode(call_type, fill, fill_name, adr_type, adr_type);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -606,1 +606,1 @@\n-                                           no_memory_effects);\n+                                           no_memory_effects, sfpt->is_Call() ? sfpt->out_adr_type() : sfpt->in_adr_type());\n@@ -6480,2 +6480,2 @@\n-  if (n->is_Load() && LCA != early) {\n-    LCA = get_late_ctrl_with_anti_dep(n->as_Load(), early, LCA);\n+  if (n->out_adr_type() == nullptr && n->in_adr_type() != nullptr && LCA != early) {\n+    LCA = get_late_ctrl_with_anti_dep(n, early, LCA);\n@@ -6494,2 +6494,4 @@\n-Node* PhaseIdealLoop::get_late_ctrl_with_anti_dep(LoadNode* n, Node* early, Node* LCA) {\n-  int load_alias_idx = C->get_alias_index(n->adr_type());\n+Node* PhaseIdealLoop::get_late_ctrl_with_anti_dep(Node* n, Node* early, Node* LCA) {\n+  int load_alias_idx = C->get_alias_index(n->in_adr_type());\n+  Node* mem = n->in(MemNode::Memory);\n+  assert(mem->bottom_type() == Type::MEMORY, \"must be a memory input for %s\", n->Name());\n@@ -6499,1 +6501,0 @@\n-    Node* mem = n->in(MemNode::Memory);\n@@ -6506,3 +6507,1 @@\n-      if (s->is_Load() || s->Opcode() == Op_SafePoint ||\n-          (s->is_CallStaticJava() && s->as_CallStaticJava()->uncommon_trap_request() != 0) ||\n-          s->is_Phi()) {\n+      if (s->is_Phi() || s->out_adr_type() == nullptr) {\n@@ -6519,1 +6518,1 @@\n-          const TypePtr* adr_type = s->adr_type();\n+          const TypePtr* adr_type = s->out_adr_type();\n@@ -6549,1 +6548,1 @@\n-        if (s->is_Phi() && C->can_alias(s->adr_type(), load_alias_idx)) {\n+        if (s->is_Phi() && C->can_alias(s->out_adr_type(), load_alias_idx)) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1921,1 +1921,1 @@\n-  Node* get_late_ctrl_with_anti_dep(LoadNode* n, Node* early, Node* LCA);\n+  Node* get_late_ctrl_with_anti_dep(Node* n, Node* early, Node* LCA);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-const class TypePtr *MachNode::adr_type() const {\n+const class TypePtr* MachNode::out_adr_type_impl() const {\n@@ -644,16 +644,0 @@\n-const TypePtr *MachProjNode::adr_type() const {\n-  if (bottom_type() == Type::MEMORY) {\n-    \/\/ in(0) might be a narrow MemBar; otherwise we will report TypePtr::BOTTOM\n-    Node* ctrl = in(0);\n-    if (ctrl == nullptr)  return nullptr; \/\/ node is dead\n-    const TypePtr* adr_type = ctrl->adr_type();\n-    #ifdef ASSERT\n-    if (!VMError::is_error_reported() && !Node::in_dump())\n-      assert(adr_type != nullptr, \"source must have adr_type\");\n-    #endif\n-    return adr_type;\n-  }\n-  assert(bottom_type()->base() != Type::Memory, \"no other memories?\");\n-  return nullptr;\n-}\n-\n@@ -685,1 +669,1 @@\n-const TypePtr *MachReturnNode::adr_type() const {\n+const TypePtr *MachReturnNode::out_adr_type_impl() const {\n@@ -872,1 +856,1 @@\n-const TypePtr *MachMemBarNode::adr_type() const {\n+const TypePtr *MachMemBarNode::out_adr_type_impl() const {\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":3,"deletions":19,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -365,3 +365,0 @@\n-  \/\/ Call \"get_base_and_disp\" to decide which category of memory is used here.\n-  virtual const class TypePtr *adr_type() const;\n-\n@@ -404,0 +401,6 @@\n+\n+private:\n+  \/\/ Although it is technically incorrect to assume the memory here is produced, for MachNode, it\n+  \/\/ should be fine since the compiler does not distinguish in_adr_type and out_adr_type, for now.\n+  \/\/ Call \"get_base_and_disp\" to decide which category of memory is used here.\n+  virtual const TypePtr* out_adr_type_impl() const;\n@@ -771,1 +774,0 @@\n-  virtual const TypePtr *adr_type() const;\n@@ -844,1 +846,3 @@\n-  virtual const TypePtr *adr_type() const;\n+\n+private:\n+  virtual const TypePtr* out_adr_type_impl() const;\n@@ -1070,1 +1074,3 @@\n-  virtual const TypePtr *adr_type() const;\n+\n+private:\n+  virtual const TypePtr* out_adr_type_impl() const;\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -129,2 +129,2 @@\n-   ? (CallNode*)new CallLeafNode      ( slow_call_type, slow_call, leaf_name, TypeRawPtr::BOTTOM )\n-   : (CallNode*)new CallStaticJavaNode( slow_call_type, slow_call, OptoRuntime::stub_name(slow_call), TypeRawPtr::BOTTOM );\n+   ? (CallNode*)new CallLeafNode      (slow_call_type, slow_call, leaf_name, TypeRawPtr::BOTTOM, oldcall->in_adr_type())\n+   : (CallNode*)new CallStaticJavaNode(slow_call_type, slow_call, OptoRuntime::stub_name(slow_call), TypeRawPtr::BOTTOM, oldcall->in_adr_type());\n@@ -1445,1 +1445,1 @@\n-                               TypePtr::BOTTOM);\n+                               TypePtr::BOTTOM, TypePtr::BOTTOM);\n@@ -1726,1 +1726,1 @@\n-                                          TypeRawPtr::BOTTOM);\n+                                          TypeRawPtr::BOTTOM, TypeRawPtr::BOTTOM);\n@@ -2660,2 +2660,1 @@\n-        CallNode* call = new CallLeafPureNode(mod_macro->tf(), mod_macro->entry_point(),\n-                                              mod_macro->_name, TypeRawPtr::BOTTOM);\n+        CallNode* call = new CallLeafPureNode(mod_macro->tf(), mod_macro->entry_point(), mod_macro->_name);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-                       const TypePtr* adr_type,\n+                       const TypePtr* out_adr_type,\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-                                       const TypePtr* adr_type,\n+                                       const TypePtr* out_adr_type,\n@@ -85,1 +85,2 @@\n-  Node* call = new CallLeafNoFPNode(call_type, call_addr, call_name, adr_type);\n+  assert(mem->out_adr_type() == TypePtr::BOTTOM, \"should have bottom memory input\");\n+  Node* call = new CallLeafNoFPNode(call_type, call_addr, call_name, out_adr_type, TypePtr::BOTTOM);\n@@ -1067,0 +1068,1 @@\n+  assert(mem->out_adr_type() == TypePtr::BOTTOM, \"should have bottom memory input\");\n@@ -1070,1 +1072,1 @@\n-                                          \"slow_arraycopy\", TypePtr::BOTTOM);\n+                                          \"slow_arraycopy\", adr_type, TypePtr::BOTTOM);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1248,1 +1248,1 @@\n-  msfpt->set_adr_type(sfpt->adr_type());\n+  msfpt->set_adr_type(sfpt->out_adr_type());\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-const TypePtr *MemNode::adr_type() const {\n+const TypePtr* MemNode::in_adr_type_impl() const {\n@@ -3914,1 +3914,0 @@\n-    _adr_type(at),\n@@ -3922,0 +3921,1 @@\n+  DEBUG_ONLY(_adr_type = at; adr_type();)\n@@ -3996,0 +3996,6 @@\n+const TypePtr* LoadStoreNode::out_adr_type_impl() const {\n+  const TypePtr* cross_check = nullptr;\n+  DEBUG_ONLY(cross_check = _adr_type);\n+  return MemNode::calculate_adr_type(in(MemNode::Memory)->bottom_type(), cross_check);\n+}\n+\n@@ -4013,1 +4019,1 @@\n-const TypePtr* ClearArrayNode::adr_type() const {\n+const TypePtr* ClearArrayNode::out_adr_type_impl() const {\n@@ -4319,2 +4325,5 @@\n-  if( !in(0) ) return Type::TOP;\n-  if( phase->type(in(0)) == Type::TOP )\n+  if (in(0) == nullptr || phase->type(in(0)) == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  if (in_adr_type() != nullptr && in(TypeFunc::Memory)->is_top()) {\n+    \/\/ The memory input died, this node should be dead, too\n@@ -4322,0 +4331,1 @@\n+  }\n@@ -5871,1 +5881,1 @@\n-  const TypePtr* n_adr_type = n->adr_type();\n+  const TypePtr* n_adr_type = n->out_adr_type();\n@@ -5912,3 +5922,3 @@\n-           || n->adr_type() == nullptr \/\/ address is TOP\n-           || n->adr_type() == TypePtr::BOTTOM\n-           || n->adr_type() == TypeRawPtr::BOTTOM\n+           || n->out_adr_type() == nullptr \/\/ address is TOP\n+           || n->out_adr_type() == TypePtr::BOTTOM\n+           || n->out_adr_type() == TypeRawPtr::BOTTOM\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -115,2 +115,0 @@\n-  virtual const class TypePtr *adr_type() const;  \/\/ returns bottom_type of address\n-\n@@ -173,0 +171,4 @@\n+\n+private:\n+  virtual const TypePtr* out_adr_type_impl() const { return is_Load() ? nullptr : in_adr_type_impl(); }\n+  virtual const TypePtr* in_adr_type_impl() const;  \/\/ returns bottom_type of address\n@@ -800,5 +802,0 @@\n-  virtual const TypePtr *adr_type() const {\n-    Node* ctrl = in(0);\n-    if (ctrl == nullptr)  return nullptr; \/\/ node is dead\n-    return ctrl->in(MemNode::Memory)->adr_type();\n-  }\n@@ -817,1 +814,0 @@\n-  const TypePtr* _adr_type;     \/\/ What kind of memory is being addressed?\n@@ -819,0 +815,5 @@\n+\n+#ifdef ASSERT\n+  const TypePtr* _adr_type;     \/\/ What kind of memory is being addressed?\n+#endif \/\/ ASSERT\n+\n@@ -820,0 +821,1 @@\n+\n@@ -827,1 +829,0 @@\n-  virtual const class TypePtr *adr_type() const { return _adr_type; }  \/\/ returns bottom_type of address\n@@ -835,0 +836,3 @@\n+\n+private:\n+  virtual const class TypePtr* out_adr_type_impl() const;\n@@ -1085,3 +1089,0 @@\n-  \/\/ ClearArray modifies array elements, and so affects only the\n-  \/\/ array memory addressed by the bottom_type of its base address.\n-  virtual const class TypePtr *adr_type() const;\n@@ -1117,0 +1118,5 @@\n+\n+private:\n+  \/\/ ClearArray modifies array elements, and so affects only the\n+  \/\/ array memory addressed by the bottom_type of its base address.\n+  virtual const TypePtr* out_adr_type_impl() const;\n@@ -1157,1 +1163,0 @@\n-  virtual const class TypePtr *adr_type() const { return _adr_type; }\n@@ -1188,0 +1193,3 @@\n+\n+private:\n+  virtual const TypePtr* out_adr_type_impl() const { return _adr_type; }\n@@ -1454,1 +1462,0 @@\n-  virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }\n@@ -1477,0 +1484,3 @@\n+\n+private:\n+  virtual const TypePtr* out_adr_type_impl() const { return TypePtr::BOTTOM; }\n@@ -1677,1 +1687,0 @@\n-  virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }\n@@ -1679,0 +1688,3 @@\n+\n+private:\n+  virtual const TypePtr* out_adr_type_impl() const { return TypePtr::BOTTOM; }\n@@ -1689,1 +1701,0 @@\n-  virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }\n@@ -1691,0 +1702,3 @@\n+\n+private:\n+  virtual const TypePtr* out_adr_type_impl() const { return TypePtr::BOTTOM; }\n@@ -1701,1 +1715,0 @@\n-  virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }\n@@ -1703,0 +1716,3 @@\n+\n+private:\n+  virtual const TypePtr* out_adr_type_impl() const { return TypePtr::BOTTOM; }\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":33,"deletions":17,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -147,15 +147,11 @@\n-const TypePtr *ProjNode::adr_type() const {\n-  if (bottom_type() == Type::MEMORY) {\n-    \/\/ in(0) might be a narrow MemBar; otherwise we will report TypePtr::BOTTOM\n-    Node* ctrl = in(0);\n-    if (ctrl->Opcode() == Op_Tuple) {\n-      \/\/ Jumping over Tuples: the i-th projection of a Tuple is the i-th input of the Tuple.\n-      ctrl = ctrl->in(_con);\n-    }\n-    if (ctrl == nullptr)  return nullptr; \/\/ node is dead\n-    const TypePtr* adr_type = ctrl->adr_type();\n-    #ifdef ASSERT\n-    if (!VMError::is_error_reported() && !Node::in_dump())\n-      assert(adr_type != nullptr, \"source must have adr_type\");\n-    #endif\n-    return adr_type;\n+const TypePtr* ProjNode::out_adr_type_impl() const {\n+  if (bottom_type() != Type::MEMORY) {\n+    assert(bottom_type()->base() != Type::Memory, \"no other memories?\");\n+    return nullptr;\n+  }\n+\n+  \/\/ in(0) might be a narrow MemBar; otherwise we will report TypePtr::BOTTOM\n+  Node* ctrl = in(0);\n+  if (ctrl->Opcode() == Op_Tuple) {\n+    \/\/ Jumping over Tuples: the i-th projection of a Tuple is the i-th input of the Tuple.\n+    ctrl = ctrl->in(_con);\n@@ -163,2 +159,11 @@\n-  assert(bottom_type()->base() != Type::Memory, \"no other memories?\");\n-  return nullptr;\n+  if (ctrl == nullptr) {\n+    \/\/ node is dead\n+    return nullptr;\n+  }\n+  const TypePtr* adr_type = ctrl->out_adr_type();\n+#ifdef ASSERT\n+  if (!VMError::is_error_reported() && !Node::in_dump()) {\n+    assert(adr_type != nullptr, \"source must have adr_type\");\n+  }\n+#endif\n+  return adr_type;\n","filename":"src\/hotspot\/share\/opto\/multnode.cpp","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -182,1 +182,0 @@\n-  virtual const TypePtr *adr_type() const;\n@@ -206,0 +205,3 @@\n+\n+private:\n+  virtual const TypePtr* out_adr_type_impl() const;\n@@ -226,4 +228,0 @@\n-  virtual const TypePtr* adr_type() const {\n-    return _adr_type;\n-  }\n-\n@@ -231,0 +229,3 @@\n+\n+private:\n+  virtual const TypePtr* out_adr_type_impl() const { return _adr_type; }\n","filename":"src\/hotspot\/share\/opto\/multnode.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -1133,0 +1134,64 @@\n+const TypePtr* Node::out_adr_type() const {\n+  const TypePtr* res = out_adr_type_impl();\n+\n+#ifdef ASSERT\n+  \/\/ Verify that in_adr_type contains out_adr_type, except for Start, obviously it consumes nothing\n+  if (is_Start() || (is_Proj() && in(0)->is_Start())) {\n+    return res;\n+  }\n+\n+  const TypePtr* in_type;\n+  if (is_Proj()) {\n+    in_type = in(0)->in_adr_type();\n+  } else {\n+    in_type = in_adr_type();\n+  }\n+  \/\/ For some reasons, Raw can be used as Bot (see GraphKit::set_output_for_allocation for\n+  \/\/ example), so be lenient here\n+  if (res != nullptr && in_type != TypePtr::BOTTOM && in_type != TypeRawPtr::BOTTOM && res != in_type) {\n+    stringStream ss;\n+    ss.print(\", out: \");\n+    res->dump_on(&ss);\n+    ss.print(\", in: \");\n+    if (in_type == nullptr) {\n+      ss.print(\"nullptr\");\n+    } else {\n+      in_type->dump_on(&ss);\n+    }\n+    assert(false, \"Node %s: in_adr_type must contain out_adr_type%s\", Name(), ss.as_string());\n+  }\n+\n+  \/\/ Unless this node is pinned, we must either have no out_adr_type or have the same out_adr_type\n+  \/\/ and in_adr_type. This is because we DO NOT know how to compute the anti-dependency of any\n+  \/\/ other node (see PhaseIdealLoop::get_late_ctrl and InstructForm::needs_anti_dependence_check).\n+  if (!is_Proj() && !pinned() && res != nullptr && res != in_type) {\n+    stringStream ss;\n+    ss.print(\", out: \");\n+    res->dump_on(&ss);\n+    ss.print(\", in: \");\n+    in_type->dump_on(&ss);\n+    assert(false, \"Node %s: cannot compute anti-dependency%s\", Name(), ss.as_string());\n+  }\n+#endif \/\/ ASSERT\n+\n+  return res;\n+}\n+\n+const TypePtr* Node::adr_type() const {\n+  \/\/ Only makes sense if in_adr_type == out_adr_type or out_adr_type == nullptr, otherwise it would\n+  \/\/ be ambiguous\n+  const TypePtr* in_type = in_adr_type();\n+#ifdef ASSERT\n+  const TypePtr* out_type = out_adr_type();\n+  if (in_type != out_type && out_type != nullptr) {\n+    stringStream ss;\n+    ss.print(\", in: \");\n+    in_type->dump_on(&ss);\n+    ss.print(\", out: \");\n+    out_type->dump_on(&ss);\n+    assert(false, \"ambiguous result for %s%s\", Name(), ss.as_string());\n+  }\n+#endif \/\/ ASSERT\n+  return in_type;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1113,0 +1113,7 @@\n+  \/\/ Get the memory which this node produces\n+  const TypePtr* out_adr_type() const;\n+\n+  \/\/ Get the memory which this node consumes, it must include the out_adr_type, since if the node\n+  \/\/ produces some memory, it also kills that memory, which is a form of consuming\n+  const TypePtr* in_adr_type() const { return in_adr_type_impl(); }\n+\n@@ -1117,1 +1124,7 @@\n-  virtual const class TypePtr *adr_type() const { return nullptr; }\n+  const TypePtr* adr_type() const;\n+\n+private:\n+  virtual const TypePtr* out_adr_type_impl() const { return nullptr; }\n+  virtual const TypePtr* in_adr_type_impl() const { return out_adr_type_impl(); }\n+\n+public:\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-                                                        no_memory_effects);\n+                                                        no_memory_effects, TypePtr::BOTTOM);\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}