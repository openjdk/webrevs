{"files":[{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8359412\n+ * @bug 8359412 8370922\n@@ -30,0 +30,1 @@\n+ * @modules jdk.incubator.vector\n@@ -58,0 +59,1 @@\n+import static compiler.lib.template_framework.library.CodeGenerationDataNameType.SCALAR_NUMERIC_TYPES;\n@@ -87,1 +89,1 @@\n-        comp.compile();\n+        comp.compile(\"--add-modules=jdk.incubator.vector\");\n@@ -90,1 +92,5 @@\n-        comp.invoke(\"compiler.igvn.templated.ExpressionFuzzerInnerTest\", \"main\", new Object[] {new String[] {}});\n+        comp.invoke(\"compiler.igvn.templated.ExpressionFuzzerInnerTest\", \"main\", new Object[] {new String[] {\n+            \"--add-modules=jdk.incubator.vector\",\n+            \"--add-opens\", \"jdk.incubator.vector\/jdk.incubator.vector=ALL-UNNAMED\",\n+            \"--add-opens\", \"java.base\/java.lang=ALL-UNNAMED\"\n+        }});\n@@ -192,1 +198,1 @@\n-                case \"float\", \"double\" -> \"val\";\n+                case \"float\", \"double\", \"Float16\" -> \"val\";\n@@ -195,1 +201,1 @@\n-                default -> throw new RuntimeException(\"should only be primitive types\");\n+                default -> throw new RuntimeException(\"type not supported yet: \" + expression.returnType.name());\n@@ -227,1 +233,1 @@\n-                case \"boolean\", \"float\", \"double\" -> \"return v;\\n\";\n+                case \"boolean\", \"float\", \"double\", \"Float16\" -> \"return v;\\n\";\n@@ -244,1 +250,1 @@\n-                default -> throw new RuntimeException(\"should only be primitive types\");\n+                default -> throw new RuntimeException(\"type not supported yet: \" + type.name());\n@@ -328,0 +334,1 @@\n+            \/\/ Prmitive expressions are most important, so let's create many expressions per output type.\n@@ -336,0 +343,15 @@\n+        \/\/ Generate expressions with any scalar numeric types.\n+        for (CodeGenerationDataNameType type : SCALAR_NUMERIC_TYPES) {\n+            \/\/ The extended set of scalar numeric expressions (incl. special types such as Float16) are relevant\n+            \/\/ but don't currently warrant the same number amount of testing time, so we only create 2 cases\n+            \/\/ per type. Note: this still produces a lot of expressions, given that we have a lot of output\n+            \/\/ types, and even if the output type is \"float\", we can still use other types in the expression,\n+            \/\/ such as \"float -> Float16 -> float\". We can consider adjusting this arbitrary count in the future.\n+            for (int i = 0; i < 2; i++) {\n+                \/\/ The depth determines roughly how many operations are going to be used in the expression.\n+                int depth = RANDOM.nextInt(1, 20);\n+                Expression expression = Expression.nestRandomly(type, Operations.SCALAR_NUMERIC_OPERATIONS, depth);\n+                tests.add(testTemplate.asToken(expression));\n+            }\n+        }\n+\n@@ -344,1 +366,2 @@\n-                   \"compiler.lib.generators.*\"),\n+                   \"compiler.lib.generators.*\",\n+                   \"jdk.incubator.vector.Float16\"),\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/ExpressionFuzzer.java","additions":31,"deletions":8,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -103,0 +103,7 @@\n+    \/**\n+     * The Float16 type.\n+     *\n+     * @return The Float16 type.\n+     *\/\n+    static CodeGenerationDataNameType float16() { return Float16Type.FLOAT16; }\n+\n@@ -157,0 +164,15 @@\n+\n+    \/**\n+     * List of all scalar numeric types.\n+     *\/\n+    List<CodeGenerationDataNameType> SCALAR_NUMERIC_TYPES = List.of(\n+        bytes(),\n+        chars(),\n+        shorts(),\n+        ints(),\n+        longs(),\n+        floats(),\n+        doubles(),\n+        booleans(),\n+        float16()\n+    );\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/CodeGenerationDataNameType.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework.library;\n+\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.Generator;\n+\n+import compiler.lib.template_framework.DataName;\n+\n+\/**\n+ * The {@link Float16Type} models Java's {@link Float16} type.\n+ *\/\n+final class Float16Type implements CodeGenerationDataNameType {\n+    private static final Generator<Short> GEN_FLOAT16 = Generators.G.float16s();\n+\n+    \/\/ We only need one static instance of the class.\n+    static final Float16Type FLOAT16 = new Float16Type();\n+\n+    \/\/ Private constructor so nobody can create duplicate instances.\n+    private Float16Type() {}\n+\n+    @Override\n+    public boolean isSubtypeOf(DataName.Type other) {\n+        return other instanceof Float16Type;\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"Float16\";\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name();\n+    }\n+\n+    @Override\n+    public Object con() {\n+        return \"Float16.shortBitsToFloat16((short)\" + GEN_FLOAT16.next() + \")\";\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/Float16Type.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -26,1 +26,0 @@\n-import java.util.List;\n@@ -28,0 +27,2 @@\n+import java.util.Arrays;\n+import java.util.List;\n@@ -29,0 +30,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -38,0 +41,1 @@\n+import static compiler.lib.template_framework.library.Float16Type.FLOAT16;\n@@ -48,0 +52,4 @@\n+    private static Expression.Info WITH_ARITHMETIC_EXCEPTION = new Expression.Info().withExceptions(Set.of(\"ArithmeticException\"));\n+    private static Expression.Info WITH_NONDETERMINISTIC_RESULT = new Expression.Info().withNondeterministicResult();\n+\n+\n@@ -54,0 +62,20 @@\n+    public static final List<Expression> FLOAT16_OPERATIONS = generateFloat16Operations();\n+\n+    public static final List<Expression> SCALAR_NUMERIC_OPERATIONS = concat(\n+            PRIMITIVE_OPERATIONS,\n+            FLOAT16_OPERATIONS\n+    );\n+\n+    @SafeVarargs\n+    private static List<Expression> concat(List<Expression>... lists) {\n+        return Arrays.stream(lists)\n+                     .flatMap(List::stream)\n+                     .collect(Collectors.toList());\n+    }\n+\n+    private static void addComparisonOperations(List<Expression> ops, String operatorName, CodeGenerationDataNameType type) {\n+        for (String mask : List.of(\"==\", \"!=\", \"<\", \">\", \"<=\", \">=\")) {\n+            ops.add(Expression.make(BOOLEANS, \"(\" + operatorName + \"(\", type, \", \", type, \")\" + mask + \"0)\"));\n+        }\n+    }\n+\n@@ -57,3 +85,0 @@\n-        Expression.Info withArithmeticException = new Expression.Info().withExceptions(Set.of(\"ArithmeticException\"));\n-        Expression.Info withNondeterministicResult = new Expression.Info().withNondeterministicResult();\n-\n@@ -78,2 +103,2 @@\n-            ops.add(Expression.make(type, \"(\", type, \" \/ \", type, \")\", withArithmeticException));\n-            ops.add(Expression.make(type, \"(\", type, \" % \", type, \")\", withArithmeticException));\n+            ops.add(Expression.make(type, \"(\", type, \" \/ \", type, \")\", WITH_ARITHMETIC_EXCEPTION));\n+            ops.add(Expression.make(type, \"(\", type, \" % \", type, \")\", WITH_ARITHMETIC_EXCEPTION));\n@@ -97,0 +122,2 @@\n+            addComparisonOperations(ops, type.boxedTypeName() + \".compare\", type);\n+            addComparisonOperations(ops, type.boxedTypeName() + \".compareUnsigned\", type); \/\/ ugt, uge, ule, ult\n@@ -115,0 +142,1 @@\n+            addComparisonOperations(ops, type.boxedTypeName() + \".compare\", type);\n@@ -155,1 +183,1 @@\n-        ops.add(Expression.make(INTS,  \"Integer.divideUnsigned(\", INTS, \", \", INTS, \")\", withArithmeticException));\n+        ops.add(Expression.make(INTS,  \"Integer.divideUnsigned(\", INTS, \", \", INTS, \")\", WITH_ARITHMETIC_EXCEPTION));\n@@ -163,1 +191,1 @@\n-        ops.add(Expression.make(INTS,  \"Integer.remainderUnsigned(\", INTS, \", \", INTS, \")\", withArithmeticException));\n+        ops.add(Expression.make(INTS,  \"Integer.remainderUnsigned(\", INTS, \", \", INTS, \")\", WITH_ARITHMETIC_EXCEPTION));\n@@ -181,1 +209,1 @@\n-        ops.add(Expression.make(LONGS, \"Long.divideUnsigned(\", LONGS, \", \", LONGS, \")\", withArithmeticException));\n+        ops.add(Expression.make(LONGS, \"Long.divideUnsigned(\", LONGS, \", \", LONGS, \")\", WITH_ARITHMETIC_EXCEPTION));\n@@ -189,1 +217,1 @@\n-        ops.add(Expression.make(LONGS, \"Long.remainderUnsigned(\", LONGS, \", \", LONGS, \")\", withArithmeticException));\n+        ops.add(Expression.make(LONGS, \"Long.remainderUnsigned(\", LONGS, \", \", LONGS, \")\", WITH_ARITHMETIC_EXCEPTION));\n@@ -204,1 +232,1 @@\n-        ops.add(Expression.make(INTS, \"Float.floatToRawIntBits(\", FLOATS, \")\", withNondeterministicResult));\n+        ops.add(Expression.make(INTS, \"Float.floatToRawIntBits(\", FLOATS, \")\", WITH_NONDETERMINISTIC_RESULT));\n@@ -223,1 +251,1 @@\n-        ops.add(Expression.make(LONGS,    \"Double.doubleToRawLongBits(\", DOUBLES, \")\", withNondeterministicResult));\n+        ops.add(Expression.make(LONGS,    \"Double.doubleToRawLongBits(\", DOUBLES, \")\", WITH_NONDETERMINISTIC_RESULT));\n@@ -253,0 +281,42 @@\n+\n+    private static List<Expression> generateFloat16Operations() {\n+        List<Expression> ops = new ArrayList<>();\n+\n+        \/\/ Casts.\n+        CodeGenerationDataNameType.INTEGRAL_AND_FLOATING_TYPES.stream().forEach(type -> {\n+            if (type == CHARS) { return; }\n+            ops.add(Expression.make(FLOAT16, \"Float16.valueOf(\", type, \")\"));\n+            ops.add(Expression.make(type, \"\", FLOAT16, \".\" + type.name() + \"Value()\"));\n+        });\n+\n+        ops.add(Expression.make(FLOAT16, \"Float16.abs(\", FLOAT16, \")\"));\n+        ops.add(Expression.make(FLOAT16, \"Float16.add(\", FLOAT16, \",\", FLOAT16, \")\"));\n+        ops.add(Expression.make(INTS, \"Float16.compare(\", FLOAT16, \",\", FLOAT16, \")\"));\n+        addComparisonOperations(ops, \"Float16.compare\", FLOAT16);\n+        ops.add(Expression.make(INTS, \"(\", FLOAT16, \").compareTo(\",  FLOAT16, \")\"));\n+        ops.add(Expression.make(FLOAT16, \"Float16.copySign(\", FLOAT16, \",\", FLOAT16, \")\"));\n+        ops.add(Expression.make(FLOAT16, \"Float16.divide(\", FLOAT16, \",\", FLOAT16, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"\", FLOAT16, \".equals(\", FLOAT16, \")\"));\n+        ops.add(Expression.make(SHORTS, \"Float16.float16ToRawShortBits(\", FLOAT16, \")\"));\n+        ops.add(Expression.make(SHORTS, \"Float16.float16ToShortBits(\", FLOAT16, \")\"));\n+        ops.add(Expression.make(FLOAT16, \"Float16.fma(\", FLOAT16, \",\", FLOAT16, \", \", FLOAT16, \")\"));\n+        ops.add(Expression.make(INTS, \"Float16.getExponent(\", FLOAT16, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"Float16.isFinite(\", FLOAT16, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"Float16.isInfinite(\", FLOAT16, \")\"));\n+        ops.add(Expression.make(BOOLEANS, \"Float16.isNaN(\", FLOAT16, \")\"));\n+        ops.add(Expression.make(FLOAT16, \"Float16.max(\", FLOAT16, \",\", FLOAT16, \")\"));\n+        ops.add(Expression.make(FLOAT16, \"Float16.min(\", FLOAT16, \",\", FLOAT16, \")\"));\n+        ops.add(Expression.make(FLOAT16, \"Float16.multiply(\", FLOAT16, \",\", FLOAT16, \")\"));\n+        ops.add(Expression.make(FLOAT16, \"Float16.negate(\", FLOAT16, \")\"));\n+        ops.add(Expression.make(FLOAT16, \"Float16.nextDown(\", FLOAT16, \")\"));\n+        ops.add(Expression.make(FLOAT16, \"Float16.nextUp(\", FLOAT16, \")\"));\n+        ops.add(Expression.make(FLOAT16, \"Float16.scalb(\", FLOAT16, \", \", INTS, \")\"));\n+        ops.add(Expression.make(FLOAT16, \"Float16.shortBitsToFloat16(\", SHORTS, \")\"));\n+        ops.add(Expression.make(FLOAT16, \"Float16.signum(\", FLOAT16, \")\"));\n+        ops.add(Expression.make(FLOAT16, \"Float16.sqrt(\", FLOAT16, \")\"));\n+        ops.add(Expression.make(FLOAT16, \"Float16.subtract(\", FLOAT16, \",\", FLOAT16, \")\"));\n+        ops.add(Expression.make(FLOAT16, \"Float16.ulp(\", FLOAT16, \")\"));\n+\n+        \/\/ Make sure the list is not modifiable.\n+        return List.copyOf(ops);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/Operations.java","additions":82,"deletions":12,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -96,0 +96,1 @@\n+    @Override\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/PrimitiveType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -153,0 +153,2 @@\n+                } else if (isFloat16Class(ca)) {\n+                    checkEQForFloat16Class(a, b, field, aParent, bParent);\n@@ -459,0 +461,34 @@\n+    private static boolean isFloat16Class(Class<?> c) {\n+        return c.getName().equals(\"jdk.incubator.vector.Float16\");\n+    }\n+\n+    \/**\n+     * We do not want to import jdk.incubator.vector.Float16 explicitly, because it would mean we would\n+     * also have to add \"--add-modules=jdk.incubator.vector\" to the command-line of every test that uses\n+     * the Verify class. So we hack this via reflection.\n+     *\n+     * An additional challenge is the boxing and NaNs, see also isFloatEQ.\n+     *\/\n+    private void checkEQForFloat16Class(Object a, Object b, String field, Object aParent, Object bParent) {\n+        Class<?> ca = a.getClass();\n+        short bitsA;\n+        short bitsB;\n+        try {\n+            Method m = isFloatCheckWithRawBits ? ca.getMethod(\"float16ToRawShortBits\", ca)\n+                                               : ca.getMethod(\"float16ToShortBits\", ca);\n+            m.setAccessible(true);\n+            bitsA = (short)m.invoke(null, a);\n+            bitsB = (short)m.invoke(null, b);\n+        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n+            throw new RuntimeException(\"Could not invoke float16ToRawShortBits on \" + ca.getName(), e);\n+        }\n+\n+        if (bitsA != bitsB) {\n+            System.err.println(\"ERROR: Equality matching failed: value mismatch. check raw: \" + isFloatCheckWithRawBits);\n+            System.err.println(\"  Values: \" + a + \" vs \" + b);\n+            System.err.println(\"  Bits:   \" + bitsA + \" vs \" + bitsB);\n+            print(a, b, field, aParent, bParent);\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/verify\/Verify.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8359412\n+ * @bug 8359412 8370922\n@@ -29,0 +29,1 @@\n+ * @modules jdk.incubator.vector\n@@ -31,1 +32,1 @@\n- * @run main template_framework.examples.TestExpressions\n+ * @run main ${test.main.class}\n@@ -58,1 +59,1 @@\n-        comp.compile();\n+        comp.compile(\"--add-modules=jdk.incubator.vector\");\n@@ -61,1 +62,5 @@\n-        comp.invoke(\"p.xyz.InnerTest\", \"main\", new Object[] {new String[] {}});\n+        comp.invoke(\"p.xyz.InnerTest\", \"main\", new Object[] {new String[] {\n+            \"--add-modules=jdk.incubator.vector\",\n+            \"--add-opens\", \"jdk.incubator.vector\/jdk.incubator.vector=ALL-UNNAMED\",\n+            \"--add-opens\", \"java.base\/java.lang=ALL-UNNAMED\"\n+        }});\n@@ -124,1 +129,1 @@\n-        for (Expression operation : Operations.PRIMITIVE_OPERATIONS) {\n+        for (Expression operation : Operations.SCALAR_NUMERIC_OPERATIONS) {\n@@ -133,1 +138,1 @@\n-            Set.of(\"compiler.lib.verify.*\"),\n+            Set.of(\"compiler.lib.verify.*\", \"jdk.incubator.vector.Float16\"),\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestExpressions.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @summary Test functionality of IntGenerator implementations.\n+ * @summary Test basic functionality of Verify implementations.\n@@ -29,1 +29,1 @@\n- * @run driver verify.tests.TestVerify\n+ * @run driver ${test.main.class}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/verify\/tests\/TestVerify.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test functionality of Verify implementations for Float16.\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run driver ${test.main.class}\n+ *\/\n+\n+package verify.tests;\n+\n+import java.lang.foreign.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+import jdk.incubator.vector.Float16;\n+\n+import compiler.lib.verify.*;\n+\n+public class TestVerifyFloat16 {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        testArrayFloat16();\n+        testRawFloat16();\n+        testFloat16Random();\n+    }\n+\n+    public static void testArrayFloat16() {\n+        Float16[] a = new Float16[1000];\n+        Float16[] b = new Float16[1001];\n+        Float16[] c = new Float16[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        c[RANDOM.nextInt(c.length)] = Float16.valueOf(1f);\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+    }\n+\n+    public static void testRawFloat16() {\n+        Float16 nan1 = Float16.shortBitsToFloat16((short)0xFFFF);\n+        Float16 nan2 = Float16.shortBitsToFloat16((short)0x7FFF);\n+        if (!Float16.isNaN(nan1)) { throw new RuntimeException(\"must be NaN\"); }\n+        if (!Float16.isNaN(nan2)) { throw new RuntimeException(\"must be NaN\"); }\n+        if (Float16.float16ToRawShortBits(nan1) != (short)0xFFFF) { throw new RuntimeException(\"wrong bits\"); }\n+        if (Float16.float16ToRawShortBits(nan2) != (short)0x7FFF) { throw new RuntimeException(\"wrong bits\"); }\n+\n+        Float16[] arr1 = new Float16[]{nan1};\n+        Float16[] arr2 = new Float16[]{nan2};\n+\n+        Verify.checkEQ(nan1, Float16.NaN);\n+        Verify.checkEQ(nan1, nan1);\n+        Verify.checkEQWithRawBits(nan1, nan1);\n+        Verify.checkEQ(nan1, nan2);\n+\n+        Verify.checkEQ(arr1, arr1);\n+        Verify.checkEQWithRawBits(arr1, arr1);\n+        Verify.checkEQ(arr1, arr2);\n+\n+        checkNEWithRawBits(nan1, nan2);\n+\n+        checkNEWithRawBits(arr1, arr2);\n+    }\n+\n+    public static void testFloat16Random() {\n+        \/\/ Testing all 2^16 * 2^16 = 2^32 would take a bit long, so we randomly sample instead.\n+        for (int i = 0; i < 10_000; i++) {\n+            short bitsA = (short)RANDOM.nextInt();\n+            short bitsB = (short)RANDOM.nextInt();\n+            Float16 a = Float16.shortBitsToFloat16(bitsA);\n+            Float16 b = Float16.shortBitsToFloat16(bitsB);\n+            if (bitsA == bitsB) {\n+                Verify.checkEQWithRawBits(a, b);\n+            } else {\n+                checkNEWithRawBits(a, b);\n+            }\n+            if (a.equals(b)) {\n+                Verify.checkEQ(a, b);\n+            } else {\n+                checkNE(a, b);\n+            }\n+        }\n+    }\n+\n+    public static void checkNE(Object a, Object b) {\n+         try {\n+            Verify.checkEQ(a, b);\n+            throw new RuntimeException(\"Should have thrown: \" + a + \" vs \" + b);\n+        } catch (VerifyException e) {}\n+    }\n+\n+    public static void checkNEWithRawBits(Object a, Object b) {\n+         try {\n+            Verify.checkEQWithRawBits(a, b);\n+            throw new RuntimeException(\"Should have thrown: \" + a + \" vs \" + b);\n+        } catch (VerifyException e) {}\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/verify\/tests\/TestVerifyFloat16.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"}]}