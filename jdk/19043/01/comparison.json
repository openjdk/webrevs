{"files":[{"patch":"@@ -2361,1 +2361,7 @@\n-    \/** Reads a record. *\/\n+    \/**\n+     * Reads and returns a record.\n+     * If an exception is marked for any of the fields, the dependency\n+     * mechanism marks the record as having an exception.\n+     * Null is returned from readRecord and later the exception is thrown at\n+     * the exit of {@link #readObject(Class)}.\n+     **\/\n@@ -2374,0 +2380,3 @@\n+        if (handles.lookupException(passHandle) != null) {\n+            return null;     \/\/ slot marked with exception, don't create record\n+        }\n@@ -2467,2 +2476,5 @@\n-                        values.defaultCheckFieldValues(obj);\n-                        values.defaultSetFieldValues(obj);\n+                        if (handles.lookupException(passHandle) == null) {\n+                            \/\/ passHandle NOT marked with an exception; set field values\n+                            values.defaultCheckFieldValues(obj);\n+                            values.defaultSetFieldValues(obj);\n+                        }\n@@ -2487,1 +2499,2 @@\n-        if (obj != null && slotValues != null) {\n+        if (obj != null && slotValues != null && handles.lookupException(passHandle) == null) {\n+            \/\/ passHandle NOT marked with an exception\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.util.SerializationUtils;\n+import jdk.test.lib.hexdump.HexPrinter;\n+import jdk.test.lib.hexdump.ObjectStreamPrinter;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @bug 8331224\n+ * @summary Test missing class throws CNFE before creating record or setting class fields\n+ * @library \/test\/lib\n+ * @run junit SerialProxyClassNotFound\n+ *\/\n+\n+\/**\n+ * Verify the correct exception (CNFE) is thrown when the class is not found during\n+ * deserialization. Field values for objects should result in CNFE *before* creating the\n+ * record or initializing the fields of a class.\n+ * The issue is exposed by the use of serialization proxy classes; the proxies\n+ * typically have types that are different from the original object type and\n+ * result in ClassCastException.\n+ *\/\n+public class SerialProxyClassNotFound implements Serializable {\n+\n+    private static Stream<Arguments> Cases() {\n+        return Stream.of(\n+                Arguments.of(new Record1(Map.of(\"aaa\", new XX()))), \/\/ Map uses serial proxy\n+                Arguments.of(new Class2(Map.of(\"bbb\", new XX()))),  \/\/ Map uses serial proxy\n+                Arguments.of(new Record4(new Class3(new XX()))),       \/\/ Class3 uses serial proxy\n+                Arguments.of(new Class5(new Class3(new XX()))),        \/\/ Class3 uses serial proxy\n+                Arguments.of(new Class6(new Class3(new XX())))         \/\/ Class3 uses serial proxy\n+        );\n+    }\n+    @ParameterizedTest\n+    @MethodSource(\"Cases\")\n+    void checkForCNFE(Object obj) throws ClassNotFoundException, IOException {\n+        \/\/ A record with field containing a Map with an entry for a class that is not found\n+        byte[] bytes = SerializationUtils.serialize(obj);\n+\n+        \/\/ Scan bytes looking for \"$XX\"; replace all occurrences\n+        boolean replaced = false;\n+        for (int off = 0; off < bytes.length - 3; off++) {\n+            if (bytes[off] == '$' && bytes[off + 1] == 'X' && bytes[off + 2] == 'X') {\n+                \/\/ Modify bytes to change name of class to SerialProxyClassNotFound$YY\n+                bytes[off + 1] = 'Y';\n+                bytes[off + 2] = 'Y';\n+                replaced = true;\n+            }\n+        }\n+        if (!replaced) {\n+            \/\/ Not found, Debug dump the bytes to locate the index of the XX class name\n+            HexPrinter.simple()\n+                    .formatter(ObjectStreamPrinter.formatter())\n+                    .dest(System.err)\n+                    .format(bytes);\n+            fail(\"'$XX' of `SerialProxyClassNotFound$XX` not found in serialized bytes \");\n+        }\n+\n+        try {\n+            Object o = SerializationUtils.deserialize(bytes);\n+            System.out.println(\"Deserialized obj: \" + o);\n+            HexPrinter.simple()\n+                    .formatter(ObjectStreamPrinter.formatter())\n+                    .dest(System.err)\n+                    .format(bytes);\n+            fail(\"deserialize should have thrown ClassNotFoundException\");\n+        } catch (ClassNotFoundException cnfe) {\n+            assertEquals(cnfe.getMessage(),\n+                    \"SerialProxyClassNotFound$YY\",\n+                    \"CNFE message incorrect\");\n+        } catch (IOException ioe) {\n+            HexPrinter.simple()\n+                    .formatter(ObjectStreamPrinter.formatter())\n+                    .dest(System.err)\n+                    .format(bytes);\n+            throw ioe;\n+        }\n+    }\n+\n+    \/\/ A class with a readily identifiable name\n+    static class XX implements Serializable { }\n+\n+    \/\/ A record holding a Map holding a reference to a readily identifiable (but deleted) class\n+    record Record1(Map<String,XX> arg) implements Serializable {};\n+\n+    \/\/ Class holding a Map holding a reference to a (deleted) class\n+    static class Class2 implements Serializable {\n+        Map<String, XX> arg;\n+        Class2(Map<String,XX> arg) {\n+            this.arg = arg;\n+        }\n+        public String toString() {\n+            return \"Class2[arg=\" + arg + \"]\";\n+        }\n+    }\n+\n+    \/\/ Class3 a holder of a reference to a class that will be \"deleted\"\n+    static class Class3 implements Serializable {\n+        XX arg;\n+        Class3(XX arg) {\n+            this.arg = arg;\n+        }\n+        private Object writeReplace() {\n+            return new Class3Proxy(arg);\n+        }\n+        public String toString() {\n+            return \"Class3[arg=\" + arg + \"]\";\n+        }\n+    }\n+\n+    \/\/ Serial proxy for Class3\n+    record Class3Proxy(XX arg) implements Serializable {\n+        private Object readResolve() {\n+            return new Class3(arg);\n+        }\n+    }\n+\n+    \/\/ Record holding a Class3\n+    record Record4(Class3 arg) implements Serializable {}\n+\n+    \/\/ Holder class without custom readObject\n+    \/\/ Causes !hasSpecialReadMethod path through OIS.readSerialData\n+    static class Class5 implements Serializable {\n+        Class3 arg;\n+        Class5(Class3 arg) {\n+            this.arg = arg;\n+        }\n+        public String toString() {\n+            return \"Class5[arg=\" + arg + \"]\";\n+        }\n+    }\n+\n+    \/\/ Holder class with custom readObject\n+    \/\/ Causes hasSpecialReadMethod path taken through OIS.readSerialData\n+    static class Class6 implements Serializable {\n+        Class3 arg;\n+        Class6(Class3 arg) {\n+            this.arg = arg;\n+        }\n+        private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n+            ois.defaultReadObject();\n+        }\n+        public String toString() {\n+            return \"Class6[arg=\" + arg + \"]\";\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/serialProxy\/SerialProxyClassNotFound.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"}]}