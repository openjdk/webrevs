{"files":[{"patch":"@@ -65,0 +65,9 @@\n+# These are needed for deterministic classlist:\n+# - The classlist can be influenced by locale. Always set it to en\/US.\n+# - Run with -Xint, as the compiler can speculatively resolve constant pool entries.\n+# - ForkJoinPool parallelism can cause constant pool resolution to be non-deterministic.\n+CLASSLIST_FILE_VM_OPTS = \\\n+    -Duser.language=en -Duser.country=US \\\n+    -Xint \\\n+    -Djava.util.concurrent.ForkJoinPool.common.parallelism=0\n+\n@@ -72,1 +81,1 @@\n-\t    -Duser.language=en -Duser.country=US \\\n+\t    $(CLASSLIST_FILE_VM_OPTS) \\\n@@ -82,1 +91,1 @@\n-\t    -Duser.language=en -Duser.country=US \\\n+\t    $(CLASSLIST_FILE_VM_OPTS) \\\n","filename":"make\/GenerateLinkOptData.gmk","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -720,0 +720,8 @@\n+void ArchiveBuilder::mark_and_relocate_to_buffered_addr(address* ptr_location) {\n+  assert(*ptr_location != nullptr, \"sanity\");\n+  if (!is_in_mapped_static_archive(*ptr_location)) {\n+    *ptr_location = get_buffered_addr(*ptr_location);\n+  }\n+  ArchivePtrMarker::mark_pointer(ptr_location);\n+}\n+\n@@ -758,0 +766,10 @@\n+  for (int i = 0; i < klasses()->length(); i++) {\n+    \/\/ Some of the code in ConstantPool::remove_unshareable_info() requires the classes\n+    \/\/ to be in linked state, so it must be call here before the next loop, which returns\n+    \/\/ all classes to unlinked state.\n+    Klass* k = get_buffered_addr(klasses()->at(i));\n+    if (k->is_instance_klass()) {\n+      InstanceKlass::cast(k)->constants()->remove_unshareable_info();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -411,0 +411,5 @@\n+  void mark_and_relocate_to_buffered_addr(address* ptr_location);\n+  template <typename T> void mark_and_relocate_to_buffered_addr(T ptr_location) {\n+    mark_and_relocate_to_buffered_addr((address*)ptr_location);\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-        w.stream()->print(\"%s %s\", LAMBDA_PROXY_TAG, pool->pool_holder()->name()->as_C_string());\n+        w.stream()->print(\"%s %s\", ClassListParser::lambda_proxy_tag(), pool->pool_holder()->name()->as_C_string());\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/classPrelinker.hpp\"\n@@ -55,0 +56,4 @@\n+const char* ClassListParser::CONSTANT_POOL_TAG = \"@cp\";\n+const char* ClassListParser::LAMBDA_FORM_TAG = \"@lambda-form-invoker\";\n+const char* ClassListParser::LAMBDA_PROXY_TAG = \"@lambda-proxy\";\n+\n@@ -302,0 +307,3 @@\n+  } else if (strcmp(_token, CONSTANT_POOL_TAG) == 0) {\n+    _token = _line + offset;\n+    parse_constant_pool_tag();\n@@ -398,1 +406,1 @@\n-void ClassListParser::error(const char* msg, ...) {\n+void ClassListParser::print_diagnostic_info(outputStream* st, const char* msg, ...) {\n@@ -401,0 +409,5 @@\n+  print_diagnostic_info(st, msg, ap);\n+  va_end(ap);\n+}\n+\n+void ClassListParser::print_diagnostic_info(outputStream* st, const char* msg, va_list ap) {\n@@ -415,1 +428,1 @@\n-    jio_fprintf(defaultStream::error_stream(), \"\\n\");\n+    st->print(\"\\n\");\n@@ -417,1 +430,1 @@\n-    jio_fprintf(defaultStream::error_stream(), \":\\n\");\n+    st->print(\":\\n\");\n@@ -421,1 +434,1 @@\n-        jio_fprintf(defaultStream::error_stream(), \"%s\", \" \");\n+        st->print(\"%s\", \" \");\n@@ -423,1 +436,1 @@\n-        jio_fprintf(defaultStream::error_stream(), \"%c\", c);\n+        st->print(\"%c\", c);\n@@ -426,1 +439,1 @@\n-    jio_fprintf(defaultStream::error_stream(), \"\\n\");\n+    st->print(\"\\n\");\n@@ -428,1 +441,1 @@\n-      jio_fprintf(defaultStream::error_stream(), \"%s\", \" \");\n+      st->print(\"%s\", \" \");\n@@ -430,1 +443,1 @@\n-    jio_fprintf(defaultStream::error_stream(), \"^\\n\");\n+    st->print(\"^\\n\");\n@@ -432,1 +445,1 @@\n-  va_end(ap);\n+}\n@@ -434,0 +447,9 @@\n+void ClassListParser::error(const char* msg, ...) {\n+  va_list ap;\n+  va_start(ap, msg);\n+  fileStream fs(defaultStream::error_stream());\n+  \/\/TODO: we should write to UL\/error instead, but that requires fixing some tests cases.\n+  \/\/LogTarget(Error, cds) lt;\n+  \/\/LogStream ls(lt);\n+  print_diagnostic_info(&fs, msg, ap);\n+  va_end(ap);\n@@ -456,0 +478,10 @@\n+void ClassListParser::constant_pool_resolution_warning(const char* msg, ...) {\n+  va_list ap;\n+  va_start(ap, msg);\n+  LogTarget(Warning, cds, resolve) lt;\n+  LogStream ls(lt);\n+  print_diagnostic_info(&ls, msg, ap);\n+  ls.print(\"Your classlist may be out of sync with the JDK or the application.\");\n+  va_end(ap);\n+}\n+\n@@ -730,0 +762,89 @@\n+\n+InstanceKlass* ClassListParser::find_builtin_class_helper(JavaThread* current, Symbol* class_name_symbol, oop class_loader_oop) {\n+  Handle class_loader(current, class_loader_oop);\n+  Handle protection_domain;\n+  return SystemDictionary::find_instance_klass(current, class_name_symbol, class_loader, protection_domain);\n+}\n+\n+InstanceKlass* ClassListParser::find_builtin_class(JavaThread* current, const char* class_name) {\n+  TempNewSymbol class_name_symbol = SymbolTable::new_symbol(class_name);\n+  InstanceKlass* ik;\n+\n+  if ( (ik = find_builtin_class_helper(current, class_name_symbol, nullptr)) != nullptr\n+    || (ik = find_builtin_class_helper(current, class_name_symbol, SystemDictionary::java_platform_loader())) != nullptr\n+    || (ik = find_builtin_class_helper(current, class_name_symbol, SystemDictionary::java_system_loader())) != nullptr) {\n+    return ik;\n+  } else {\n+    return nullptr;\n+  }\n+}\n+\n+void ClassListParser::parse_constant_pool_tag() {\n+  if (parse_lambda_forms_invokers_only()) {\n+    return;\n+  }\n+\n+  JavaThread* THREAD = JavaThread::current();\n+  skip_whitespaces();\n+  char* class_name = _token;\n+  skip_non_whitespaces();\n+  *_token = '\\0';\n+  _token ++;\n+\n+  InstanceKlass* ik = find_builtin_class(THREAD, class_name);\n+  if (ik == nullptr) {\n+    _token = class_name;\n+    if (strstr(class_name, \"\/$Proxy\") != nullptr ||\n+        strstr(class_name, \"MethodHandle$Species_\") != nullptr) {\n+      \/\/ ignore -- TODO: we should filter these out in classListWriter.cpp\n+    } else {\n+      constant_pool_resolution_warning(\"class %s is not (yet) loaded by one of the built-in loaders\", class_name);\n+    }\n+    return;\n+  }\n+\n+  ResourceMark rm(THREAD);\n+  constantPoolHandle cp(THREAD, ik->constants());\n+  GrowableArray<bool> preresolve_list(cp->length(), cp->length(), false);\n+  bool preresolve_class = false;\n+  bool preresolve_fmi = false;\n+  bool preresolve_indy = false;\n+\n+  while (*_token) {\n+    int cp_index;\n+    skip_whitespaces();\n+    parse_uint(&cp_index);\n+    if (cp_index < 1 || cp_index >= cp->length()) {\n+      constant_pool_resolution_warning(\"Invalid constant pool index %d\", cp_index);\n+      return;\n+    } else {\n+      preresolve_list.at_put(cp_index, true);\n+    }\n+    constantTag cp_tag = cp->tag_at(cp_index);\n+    switch (cp_tag.value()) {\n+    case JVM_CONSTANT_UnresolvedClass:\n+      preresolve_class = true;\n+      break;\n+    case JVM_CONSTANT_UnresolvedClassInError:\n+    case JVM_CONSTANT_Class:\n+      \/\/ ignore\n+      break;\n+    case JVM_CONSTANT_Fieldref:\n+      preresolve_fmi = true;\n+      break;\n+      break;\n+    default:\n+      constant_pool_resolution_warning(\"Unsupported constant pool index %d: %s (type=%d)\",\n+                                       cp_index, cp_tag.internal_name(), cp_tag.value());\n+      return;\n+    }\n+  }\n+\n+  if (preresolve_class) {\n+    ClassPrelinker::preresolve_class_cp_entries(THREAD, ik, &preresolve_list);\n+  }\n+  if (preresolve_fmi) {\n+    ClassPrelinker::preresolve_field_and_method_cp_entries(THREAD, ik, &preresolve_list);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":130,"deletions":9,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -34,3 +34,0 @@\n-#define LAMBDA_PROXY_TAG \"@lambda-proxy\"\n-#define LAMBDA_FORM_TAG  \"@lambda-form-invoker\"\n-\n@@ -71,0 +68,4 @@\n+  static const char* CONSTANT_POOL_TAG;\n+  static const char* LAMBDA_FORM_TAG;\n+  static const char* LAMBDA_PROXY_TAG;\n+\n@@ -120,0 +121,3 @@\n+  InstanceKlass* find_builtin_class_helper(JavaThread* current, Symbol* class_name_symbol, oop class_loader_oop);\n+  InstanceKlass* find_builtin_class(JavaThread* current, const char* class_name);\n+\n@@ -126,0 +130,1 @@\n+  void parse_constant_pool_tag();\n@@ -131,0 +136,4 @@\n+  void print_diagnostic_info(outputStream* st, const char* msg, va_list ap) ATTRIBUTE_PRINTF(3, 0);\n+  void print_diagnostic_info(outputStream* st, const char* msg, ...) ATTRIBUTE_PRINTF(3, 0);\n+  void constant_pool_resolution_warning(const char* msg, ...) ATTRIBUTE_PRINTF(2, 0);\n+  void error(const char* msg, ...) ATTRIBUTE_PRINTF(2, 0);\n@@ -144,0 +153,6 @@\n+  static const char* lambda_proxy_tag() {\n+    return LAMBDA_PROXY_TAG;\n+  }\n+  static const char* lambda_form_tag() {\n+    return LAMBDA_FORM_TAG;\n+  }\n@@ -150,1 +165,0 @@\n-  void error(const char* msg, ...);\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cds\/lambdaFormInvokers.inline.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -34,0 +36,1 @@\n+#include \"oops\/constantPool.inline.hpp\"\n@@ -192,0 +195,91 @@\n+\n+class ClassListWriter::WriteResolveConstantsCLDClosure : public CLDClosure {\n+public:\n+  void do_cld(ClassLoaderData* cld) {\n+    for (Klass* klass = cld->klasses(); klass != nullptr; klass = klass->next_link()) {\n+      if (klass->is_instance_klass()) {\n+        InstanceKlass* ik = InstanceKlass::cast(klass);\n+        write_resolved_constants_for(ik);\n+      }\n+    }\n+  }\n+};\n+\n+void ClassListWriter::write_resolved_constants() {\n+  if (!is_enabled()) {\n+    return;\n+  }\n+  MutexLocker lock(ClassLoaderDataGraph_lock);\n+  MutexLocker lock2(ClassListFile_lock, Mutex::_no_safepoint_check_flag);\n+\n+  WriteResolveConstantsCLDClosure closure;\n+  ClassLoaderDataGraph::loaded_cld_do(&closure);\n+}\n+\n+void ClassListWriter::write_resolved_constants_for(InstanceKlass* ik) {\n+  if (!SystemDictionaryShared::is_builtin_loader(ik->class_loader_data()) ||\n+      ik->is_hidden()) {\n+    return;\n+  }\n+  if (LambdaFormInvokers::may_be_regenerated_class(ik->name())) {\n+    return;\n+  }\n+  if (ik->name()->equals(\"jdk\/internal\/module\/SystemModules$all\")) {\n+    \/\/ This class is regenerated during JDK build process, so the classlist\n+    \/\/ may not match the version that's in the real jdk image.\n+    return;\n+  }\n+\n+  if (!has_id(ik)) { \/\/ do not resolve CP for classes loaded by custom loaders.\n+    return;\n+  }\n+\n+  ResourceMark rm;\n+  ConstantPool* cp = ik->constants();\n+  GrowableArray<bool> list(cp->length(), cp->length(), false);\n+  bool print = false;\n+\n+  for (int cp_index = 1; cp_index < cp->length(); cp_index++) { \/\/ Index 0 is unused\n+    switch (cp->tag_at(cp_index).value()) {\n+    case JVM_CONSTANT_Class:\n+      {\n+        Klass* k = cp->resolved_klass_at(cp_index);\n+        if (k->is_instance_klass()) {\n+          list.at_put(cp_index, true);\n+          print = true;\n+        }\n+      }\n+      break;\n+    }\n+  }\n+\n+  if (cp->cache() != nullptr) {\n+    Array<ResolvedFieldEntry>* field_entries = cp->cache()->resolved_field_entries();\n+    if (field_entries != nullptr) {\n+      for (int i = 0; i < field_entries->length(); i++) {\n+        ResolvedFieldEntry* rfe = field_entries->adr_at(i);\n+        if (rfe->is_resolved(Bytecodes::_getstatic) ||\n+            rfe->is_resolved(Bytecodes::_putstatic) ||\n+            rfe->is_resolved(Bytecodes::_getfield) ||\n+            rfe->is_resolved(Bytecodes::_putfield)) {\n+          list.at_put(rfe->constant_pool_index(), true);\n+          print = true;\n+        }\n+      }\n+    }\n+  }\n+\n+  if (print) {\n+    outputStream* stream = _classlist_file;\n+    stream->print(\"@cp %s\", ik->name()->as_C_string());\n+    for (int i = 0; i < list.length(); i++) {\n+      if (list.at(i)) {\n+        constantTag cp_tag = cp->tag_at(i).value();\n+        assert(cp_tag.value() == JVM_CONSTANT_Class ||\n+               cp_tag.value() == JVM_CONSTANT_Fieldref, \"sanity\");\n+        stream->print(\" %d\", i);\n+      }\n+    }\n+    stream->cr();\n+  }\n+}\n","filename":"src\/hotspot\/share\/cds\/classListWriter.cpp","additions":95,"deletions":1,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+  class WriteResolveConstantsCLDClosure;\n+\n@@ -45,0 +47,1 @@\n+  static void write_resolved_constants_for(InstanceKlass* klass);\n@@ -69,0 +72,1 @@\n+  static void write_resolved_constants() NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/cds\/classListWriter.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"cds\/regeneratedClasses.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -31,0 +33,2 @@\n+#include \"interpreter\/bytecodeStream.hpp\"\n+#include \"interpreter\/interpreterRuntime.hpp\"\n@@ -76,1 +80,5 @@\n-bool ClassPrelinker::can_archive_resolved_klass(ConstantPool* cp, int cp_index) {\n+\/\/ Returns true if we CAN PROVE that cp_index will always resolve to\n+\/\/ the same information at both dump time and run time. This is a\n+\/\/ necessary (but not sufficient) condition for pre-resolving cp_index\n+\/\/ during CDS archive assembly.\n+bool ClassPrelinker::is_resolution_deterministic(ConstantPool* cp, int cp_index) {\n@@ -78,1 +86,0 @@\n-  assert(cp->tag_at(cp_index).is_klass(), \"must be resolved\");\n@@ -80,2 +87,15 @@\n-  Klass* resolved_klass = cp->resolved_klass_at(cp_index);\n-  assert(resolved_klass != nullptr, \"must be\");\n+  if (cp->tag_at(cp_index).is_klass()) {\n+    \/\/ We require cp_index to be already resolved. This is fine for now, are we\n+    \/\/ currently archive only CP entries that are already resolved.\n+    Klass* resolved_klass = cp->resolved_klass_at(cp_index);\n+    return resolved_klass != nullptr && is_class_resolution_deterministic(cp->pool_holder(), resolved_klass);\n+  } else if (cp->tag_at(cp_index).is_field()) {\n+    int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n+    if (!cp->tag_at(klass_cp_index).is_klass()) {\n+      \/\/ Not yet resolved\n+      return false;\n+    }\n+    Klass* k = cp->resolved_klass_at(klass_cp_index);\n+    if (!is_class_resolution_deterministic(cp->pool_holder(), k)) {\n+      return false;\n+    }\n@@ -83,1 +103,12 @@\n-  return can_archive_resolved_klass(cp->pool_holder(), resolved_klass);\n+    if (!k->is_instance_klass()) {\n+      \/\/ TODO: support non instance klasses as well.\n+      return false;\n+    }\n+\n+    \/\/ Here, We don't check if this entry can actually be resolved to a valid Field\/Method.\n+    \/\/ This method should be called by the ConstantPool to check Fields\/Methods that\n+    \/\/ have already been successfully resolved.\n+    return true;\n+  } else {\n+    return false;\n+  }\n@@ -86,1 +117,1 @@\n-bool ClassPrelinker::can_archive_resolved_klass(InstanceKlass* cp_holder, Klass* resolved_klass) {\n+bool ClassPrelinker::is_class_resolution_deterministic(InstanceKlass* cp_holder, Klass* resolved_class) {\n@@ -88,15 +119,7 @@\n-  assert(!is_in_archivebuilder_buffer(resolved_klass), \"sanity\");\n-\n-  if (resolved_klass->is_instance_klass()) {\n-    InstanceKlass* ik = InstanceKlass::cast(resolved_klass);\n-    if (is_vm_class(ik)) { \/\/ These are safe to resolve. See is_vm_class declaration.\n-      assert(ik->is_shared_boot_class(), \"vmClasses must be loaded by boot loader\");\n-      if (cp_holder->is_shared_boot_class()) {\n-        \/\/ For now, do this for boot loader only. Other loaders\n-        \/\/ must go through ConstantPool::klass_at_impl at runtime\n-        \/\/ to put this class in their directory.\n-\n-        \/\/ TODO: we can support the platform and app loaders as well, if we\n-        \/\/ preload the vmClasses into these two loaders during VM bootstrap.\n-        return true;\n-      }\n+  assert(!is_in_archivebuilder_buffer(resolved_class), \"sanity\");\n+\n+  if (resolved_class->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(resolved_class);\n+\n+    if (!ik->is_shared() && SystemDictionaryShared::is_excluded_class(ik)) {\n+      return false;\n@@ -111,1 +134,19 @@\n-    \/\/ TODO -- allow objArray classes, too\n+    if (is_vm_class(ik)) {\n+      if (ik->class_loader() != cp_holder->class_loader()) {\n+        \/\/ At runtime, cp_holder() may not be able to resolve to the same\n+        \/\/ ik. For example, a different version of ik may be defined in\n+        \/\/ cp->pool_holder()'s loader using MethodHandles.Lookup.defineClass().\n+        return false;\n+      } else {\n+        return true;\n+      }\n+    }\n+  } else if (resolved_class->is_objArray_klass()) {\n+    Klass* elem = ObjArrayKlass::cast(resolved_class)->bottom_klass();\n+    if (elem->is_instance_klass()) {\n+      return is_class_resolution_deterministic(cp_holder, InstanceKlass::cast(elem));\n+    } else if (elem->is_typeArray_klass()) {\n+      return true;\n+    }\n+  } else if (resolved_class->is_typeArray_klass()) {\n+    return true;\n@@ -118,4 +159,1 @@\n-  constantPoolHandle cp(THREAD, ik->constants());\n-  if (cp->cache() == nullptr || cp->reference_map() == nullptr) {\n-    \/\/ The cache may be null if the pool_holder klass fails verification\n-    \/\/ at dump time due to missing dependencies.\n+  if (!ik->is_linked()) {\n@@ -124,1 +162,0 @@\n-\n@@ -132,0 +169,1 @@\n+  constantPoolHandle cp(THREAD, ik->constants());\n@@ -134,4 +172,0 @@\n-    case JVM_CONSTANT_UnresolvedClass:\n-      maybe_resolve_class(cp, cp_index, CHECK);\n-      break;\n-\n@@ -145,4 +179,5 @@\n-Klass* ClassPrelinker::find_loaded_class(JavaThread* THREAD, oop class_loader, Symbol* name) {\n-  HandleMark hm(THREAD);\n-  Handle h_loader(THREAD, class_loader);\n-  Klass* k = SystemDictionary::find_instance_or_array_klass(THREAD, name,\n+\/\/ This works only for the boot\/platform\/app loaders\n+Klass* ClassPrelinker::find_loaded_class(Thread* current, oop class_loader, Symbol* name) {\n+  HandleMark hm(current);\n+  Handle h_loader(current, class_loader);\n+  Klass* k = SystemDictionary::find_instance_or_array_klass(current, name,\n@@ -154,4 +189,9 @@\n-  if (class_loader == SystemDictionary::java_system_loader()) {\n-    return find_loaded_class(THREAD, SystemDictionary::java_platform_loader(), name);\n-  } else if (class_loader == SystemDictionary::java_platform_loader()) {\n-    return find_loaded_class(THREAD, nullptr, name);\n+  if (h_loader() == SystemDictionary::java_system_loader()) {\n+    return find_loaded_class(current, SystemDictionary::java_platform_loader(), name);\n+  } else if (h_loader() == SystemDictionary::java_platform_loader()) {\n+    return find_loaded_class(current, nullptr, name);\n+  } else {\n+    assert(h_loader() == nullptr, \"This function only works for boot\/platform\/app loaders %p %p %p\",\n+           cast_from_oop<address>(h_loader()),\n+           cast_from_oop<address>(SystemDictionary::java_system_loader()),\n+           cast_from_oop<address>(SystemDictionary::java_platform_loader()));\n@@ -163,19 +203,3 @@\n-Klass* ClassPrelinker::maybe_resolve_class(constantPoolHandle cp, int cp_index, TRAPS) {\n-  assert(!is_in_archivebuilder_buffer(cp()), \"sanity\");\n-  InstanceKlass* cp_holder = cp->pool_holder();\n-  if (!cp_holder->is_shared_boot_class() &&\n-      !cp_holder->is_shared_platform_class() &&\n-      !cp_holder->is_shared_app_class()) {\n-    \/\/ Don't trust custom loaders, as they may not be well-behaved\n-    \/\/ when resolving classes.\n-    return nullptr;\n-  }\n-\n-  Symbol* name = cp->klass_name_at(cp_index);\n-  Klass* resolved_klass = find_loaded_class(THREAD, cp_holder->class_loader(), name);\n-  if (resolved_klass != nullptr && can_archive_resolved_klass(cp_holder, resolved_klass)) {\n-    Klass* k = cp->klass_at(cp_index, CHECK_NULL); \/\/ Should fail only with OOM\n-    assert(k == resolved_klass, \"must be\");\n-  }\n-\n-  return resolved_klass;\n+Klass* ClassPrelinker::find_loaded_class(Thread* current, ConstantPool* cp, int class_cp_index) {\n+  Symbol* name = cp->klass_name_at(class_cp_index);\n+  return find_loaded_class(current, cp->pool_holder()->class_loader(), name);\n@@ -193,0 +217,104 @@\n+void ClassPrelinker::preresolve_class_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list) {\n+  if (!SystemDictionaryShared::is_builtin_loader(ik->class_loader_data())) {\n+    return;\n+  }\n+\n+  JavaThread* THREAD = current;\n+  constantPoolHandle cp(THREAD, ik->constants());\n+  for (int cp_index = 1; cp_index < cp->length(); cp_index++) {\n+    if (cp->tag_at(cp_index).value() == JVM_CONSTANT_UnresolvedClass) {\n+      if (preresolve_list != nullptr && preresolve_list->at(cp_index) == false) {\n+        \/\/ This class was not resolved during trial run. Don't attempt to resolve it. Otherwise\n+        \/\/ the compiler may generate less efficient code.\n+        continue;\n+      }\n+      if (find_loaded_class(current, cp(), cp_index) == nullptr) {\n+        \/\/ Do not resolve any class that has not been loaded yet\n+        continue;\n+      }\n+      Klass* resolved_klass = cp->klass_at(cp_index, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n+      } else {\n+        log_trace(cds, resolve)(\"Resolved class  [%3d] %s -> %s\", cp_index, ik->external_name(),\n+                                resolved_klass->external_name());\n+      }\n+    }\n+  }\n+}\n+\n+void ClassPrelinker::preresolve_field_and_method_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list) {\n+  JavaThread* THREAD = current;\n+  constantPoolHandle cp(THREAD, ik->constants());\n+  if (cp->cache() == nullptr) {\n+    return;\n+  }\n+  for (int i = 0; i < ik->methods()->length(); i++) {\n+    Method* m = ik->methods()->at(i);\n+    BytecodeStream bcs(methodHandle(THREAD, m));\n+    while (!bcs.is_last_bytecode()) {\n+      bcs.next();\n+      Bytecodes::Code raw_bc = bcs.raw_code();\n+      switch (raw_bc) {\n+      case Bytecodes::_getfield:\n+      case Bytecodes::_putfield:\n+        maybe_resolve_fmi_ref(ik, m, raw_bc, bcs.get_index_u2(), preresolve_list, THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n+        }\n+        break;\n+      default:\n+        break;\n+      }\n+    }\n+  }\n+}\n+\n+void ClassPrelinker::maybe_resolve_fmi_ref(InstanceKlass* ik, Method* m, Bytecodes::Code bc, int raw_index,\n+                                           GrowableArray<bool>* preresolve_list, TRAPS) {\n+  methodHandle mh(THREAD, m);\n+  constantPoolHandle cp(THREAD, ik->constants());\n+  HandleMark hm(THREAD);\n+  int cp_index = cp->to_cp_index(raw_index, bc);\n+\n+  if (cp->is_resolved(raw_index, bc)) {\n+    return;\n+  }\n+\n+  if (preresolve_list != nullptr && preresolve_list->at(cp_index) == false) {\n+    \/\/ This field wasn't resolved during the trial run. Don't attempt to resolve it. Otherwise\n+    \/\/ the compiler may generate less efficient code.\n+    return;\n+  }\n+\n+  int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n+  if (find_loaded_class(THREAD, cp(), klass_cp_index) == nullptr) {\n+    \/\/ Do not resolve any field\/methods from a class that has not been loaded yet.\n+    return;\n+  }\n+\n+  Klass* resolved_klass = cp->klass_ref_at(raw_index, bc, CHECK);\n+\n+  switch (bc) {\n+  case Bytecodes::_getfield:\n+  case Bytecodes::_putfield:\n+    InterpreterRuntime::resolve_get_put(bc, raw_index, mh, cp, false \/*initialize_holder*\/, CHECK);\n+    break;\n+\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n+  if (log_is_enabled(Trace, cds, resolve)) {\n+    ResourceMark rm(THREAD);\n+    bool resolved = cp->is_resolved(raw_index, bc);\n+    Symbol* name = cp->name_ref_at(raw_index, bc);\n+    Symbol* signature = cp->signature_ref_at(raw_index, bc);\n+    log_trace(cds, resolve)(\"%s %s [%3d] %s -> %s.%s:%s\",\n+                            (resolved ? \"Resolved\" : \"Failed to resolve\"),\n+                            Bytecodes::name(bc), cp_index, ik->external_name(),\n+                            resolved_klass->external_name(),\n+                            name->as_C_string(), signature->as_C_string());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/classPrelinker.cpp","additions":187,"deletions":59,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"interpreter\/bytecodes.hpp\"\n@@ -67,3 +68,1 @@\n-  static Klass* maybe_resolve_class(constantPoolHandle cp, int cp_index, TRAPS);\n-  static bool can_archive_resolved_klass(InstanceKlass* cp_holder, Klass* resolved_klass);\n-  static Klass* find_loaded_class(JavaThread* THREAD, oop class_loader, Symbol* name);\n+  static bool is_class_resolution_deterministic(InstanceKlass* cp_holder, Klass* resolved_class);\n@@ -71,0 +70,6 @@\n+  static Klass* find_loaded_class(Thread* current, oop class_loader, Symbol* name);\n+  static Klass* find_loaded_class(Thread* current, ConstantPool* cp, int class_cp_index);\n+\n+  \/\/ fmi = FieldRef\/MethodRef\/InterfaceMethodRef\n+  static void maybe_resolve_fmi_ref(InstanceKlass* ik, Method* m, Bytecodes::Code bc, int raw_index,\n+                                    GrowableArray<bool>* resolve_fmi_list, TRAPS);\n@@ -75,0 +80,3 @@\n+  static void preresolve_class_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list);\n+  static void preresolve_field_and_method_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list);\n+\n@@ -85,4 +93,1 @@\n-  \/\/ Can we resolve the klass entry at cp_index in this constant pool, and store\n-  \/\/ the result in the CDS archive? Returns true if cp_index is guaranteed to\n-  \/\/ resolve to the same InstanceKlass* at both dump time and run time.\n-  static bool can_archive_resolved_klass(ConstantPool* cp, int cp_index);\n+  static bool is_resolution_deterministic(ConstantPool* cp, int cp_index);\n","filename":"src\/hotspot\/share\/cds\/classPrelinker.hpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,4 +105,8 @@\n-  msg.debug(\"Class CP entries = %d, archived = %d (%3.1f%%)\",\n-            _num_klass_cp_entries, _num_klass_cp_entries_archived,\n-            percent_of(_num_klass_cp_entries_archived, _num_klass_cp_entries));\n-\n+  msg.info(\"Class  CP entries = %6d, archived = %6d (%5.1f%%), reverted = %6d\",\n+           _num_klass_cp_entries, _num_klass_cp_entries_archived,\n+           percent_of(_num_klass_cp_entries_archived, _num_klass_cp_entries),\n+           _num_klass_cp_entries_reverted);\n+  msg.info(\"Field  CP entries = %6d, archived = %6d (%5.1f%%), reverted = %6d\",\n+           _num_field_cp_entries, _num_field_cp_entries_archived,\n+           percent_of(_num_field_cp_entries_archived, _num_field_cp_entries),\n+           _num_field_cp_entries_reverted);\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,3 @@\n+  int _num_field_cp_entries;\n+  int _num_field_cp_entries_archived;\n+  int _num_field_cp_entries_reverted;\n@@ -70,0 +73,1 @@\n+  int _num_klass_cp_entries_reverted;\n@@ -77,2 +81,6 @@\n-    _num_klass_cp_entries = 0;\n-    _num_klass_cp_entries_archived = 0;\n+    _num_field_cp_entries           = 0;\n+    _num_field_cp_entries_archived  = 0;\n+    _num_field_cp_entries_reverted  = 0;\n+    _num_klass_cp_entries           = 0;\n+    _num_klass_cp_entries_archived  = 0;\n+    _num_klass_cp_entries_reverted  = 0;\n@@ -105,1 +113,7 @@\n-  void record_klass_cp_entry(bool archived) {\n+  void record_field_cp_entry(bool archived, bool reverted) {\n+    _num_field_cp_entries ++;\n+    _num_field_cp_entries_archived += archived ? 1 : 0;\n+    _num_field_cp_entries_reverted += reverted ? 1 : 0;\n+  }\n+\n+  void record_klass_cp_entry(bool archived, bool reverted) {\n@@ -108,0 +122,1 @@\n+    _num_klass_cp_entries_reverted += reverted ? 1 : 0;\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.hpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+class SerializeClosure;\n@@ -49,0 +50,1 @@\n+  inline static bool may_be_regenerated_class(Symbol* name);\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_LAMBDAFORMINVOKERS_INLINE_HPP\n+#define SHARE_CDS_LAMBDAFORMINVOKERS_INLINE_HPP\n+\n+#include \"cds\/lambdaFormInvokers.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+\n+inline bool LambdaFormInvokers::may_be_regenerated_class(Symbol* name) {\n+  return name == vmSymbols::java_lang_invoke_Invokers_Holder() ||\n+         name == vmSymbols::java_lang_invoke_DirectMethodHandle_Holder() ||\n+         name == vmSymbols::java_lang_invoke_LambdaForm_Holder() ||\n+         name == vmSymbols::java_lang_invoke_DelegatingMethodHandle_Holder();\n+}\n+\n+#endif \/\/ SHARE_CDS_LAMBDAFORMINVOKERS_INLINE_HPP\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.inline.hpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -648,2 +648,0 @@\n-  \/\/ resolve field\n-  fieldDescriptor info;\n@@ -653,0 +651,9 @@\n+\n+  resolve_get_put(bytecode, last_frame.get_index_u2(bytecode), m, pool, true \/*initialize_holder*\/, current);\n+}\n+\n+void InterpreterRuntime::resolve_get_put(Bytecodes::Code bytecode, int field_index,\n+                                         methodHandle& m,\n+                                         constantPoolHandle& pool,\n+                                         bool initialize_holder, TRAPS) {\n+  fieldDescriptor info;\n@@ -657,1 +664,0 @@\n-  int field_index = last_frame.get_index_u2(bytecode);\n@@ -659,2 +665,1 @@\n-    JvmtiHideSingleStepping jhss(current);\n-    JavaThread* THREAD = current; \/\/ For exception macros.\n+    JvmtiHideSingleStepping jhss(THREAD);\n@@ -662,1 +667,1 @@\n-                                       m, bytecode, CHECK);\n+                                       m, bytecode, initialize_holder, CHECK);\n@@ -668,1 +673,0 @@\n-\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,6 @@\n- private:\n+\n+  \/\/ Used by ClassListParser.\n+  static void resolve_get_put(Bytecodes::Code bytecode, int field_index,\n+                              methodHandle& m, constantPoolHandle& pool, bool initialize_holder, TRAPS);\n+\n+private:\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -975,1 +975,6 @@\n-void LinkResolver::resolve_field_access(fieldDescriptor& fd, const constantPoolHandle& pool, int index, const methodHandle& method, Bytecodes::Code byte, TRAPS) {\n+void LinkResolver::resolve_field_access(fieldDescriptor& fd,\n+                                        const constantPoolHandle& pool,\n+                                        int index,\n+                                        const methodHandle& method,\n+                                        Bytecodes::Code byte,\n+                                        bool initialize_class, TRAPS) {\n@@ -977,1 +982,1 @@\n-  resolve_field(fd, link_info, byte, true, CHECK);\n+  resolve_field(fd, link_info, byte, initialize_class, CHECK);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -296,1 +296,10 @@\n-                                   Bytecodes::Code byte, TRAPS);\n+                                   Bytecodes::Code byte,\n+                                   bool initialize_class, TRAPS);\n+  static void resolve_field_access(fieldDescriptor& result,\n+                                   const constantPoolHandle& pool,\n+                                   int index,\n+                                   const methodHandle& method,\n+                                   Bytecodes::Code byte, TRAPS) {\n+    resolve_field_access(result, pool, index, method, byte,\n+                         \/* initialize_class*\/true, THREAD);\n+  }\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -301,2 +301,3 @@\n-    ConstantPool* orig_pool = ArchiveBuilder::current()->get_source_addr(this);\n-    objArrayOop scratch_rr = HeapShared::scratch_resolved_references(orig_pool);\n+    int rr_len = rr->length();\n+    ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(this);\n+    objArrayOop scratch_rr = HeapShared::scratch_resolved_references(src_cp);\n@@ -305,1 +306,0 @@\n-    int rr_len = rr->length();\n@@ -309,6 +309,8 @@\n-      if (obj != nullptr && i < ref_map_len) {\n-        int index = object_to_cp_index(i);\n-        if (tag_at(index).is_string()) {\n-          assert(java_lang_String::is_instance(obj), \"must be\");\n-          if (!ArchiveHeapWriter::is_string_too_large_to_archive(obj)) {\n-            scratch_rr->obj_at_put(i, obj);\n+      if (obj != nullptr) {\n+        if (i < ref_map_len) {\n+          int index = object_to_cp_index(i);\n+          if (tag_at(index).is_string()) {\n+            assert(java_lang_String::is_instance(obj), \"must be\");\n+            if (!ArchiveHeapWriter::is_string_too_large_to_archive(obj)) {\n+              scratch_rr->obj_at_put(i, obj);\n+            }\n@@ -387,2 +389,38 @@\n-  if (!_pool_holder->is_linked() && !_pool_holder->verified_at_dump_time()) {\n-    return;\n+  \/\/ resolved_references(): remember its length. If it cannot be restored\n+  \/\/ from the archived heap objects at run time, we need to dynamically allocate it.\n+  if (cache() != nullptr) {\n+    set_resolved_reference_length(\n+        resolved_references() != nullptr ? resolved_references()->length() : 0);\n+    set_resolved_references(OopHandle());\n+  }\n+  remove_unshareable_entries();\n+}\n+\n+static const char* get_type(Klass* k) {\n+  const char* type;\n+  Klass* src_k;\n+  if (ArchiveBuilder::is_active() && ArchiveBuilder::current()->is_in_buffer_space(k)) {\n+    src_k = ArchiveBuilder::current()->get_source_addr(k);\n+  } else {\n+    src_k = k;\n+  }\n+\n+  if (src_k->is_objArray_klass()) {\n+    src_k = ObjArrayKlass::cast(src_k)->bottom_klass();\n+    assert(!src_k->is_objArray_klass(), \"sanity\");\n+  }\n+\n+  if (src_k->is_typeArray_klass()) {\n+    type = \"prim\";\n+  } else {\n+    InstanceKlass* src_ik = InstanceKlass::cast(src_k);\n+    oop loader = src_ik->class_loader();\n+    if (loader == nullptr) {\n+      type = \"boot\";\n+    } else if (loader == SystemDictionary::java_platform_loader()) {\n+      type = \"plat\";\n+    } else if (loader == SystemDictionary::java_system_loader()) {\n+      type = \"app\";\n+    } else {\n+      type = \"unreg\";\n+    }\n@@ -390,8 +428,0 @@\n-  \/\/ Resolved references are not in the shared archive.\n-  \/\/ Save the length for restoration.  It is not necessarily the same length\n-  \/\/ as reference_map.length() if invokedynamic is saved. It is needed when\n-  \/\/ re-creating the resolved reference array if archived heap data cannot be map\n-  \/\/ at runtime.\n-  set_resolved_reference_length(\n-    resolved_references() != nullptr ? resolved_references()->length() : 0);\n-  set_resolved_references(OopHandle());\n@@ -399,1 +429,6 @@\n-  bool archived = false;\n+  return type;\n+}\n+\n+void ConstantPool::remove_unshareable_entries() {\n+  ResourceMark rm;\n+  log_info(cds, resolve)(\"Archiving CP entries for %s\", pool_holder()->name()->as_C_string());\n@@ -401,1 +436,5 @@\n-    switch (tag_at(cp_index).value()) {\n+    int cp_tag = tag_at(cp_index).value();\n+    switch (cp_tag) {\n+    case JVM_CONSTANT_UnresolvedClass:\n+      ArchiveBuilder::alloc_stats()->record_klass_cp_entry(false, false);\n+      break;\n@@ -404,0 +443,1 @@\n+      ArchiveBuilder::alloc_stats()->record_klass_cp_entry(false, true);\n@@ -415,2 +455,3 @@\n-      archived = maybe_archive_resolved_klass_at(cp_index);\n-      ArchiveBuilder::alloc_stats()->record_klass_cp_entry(archived);\n+      remove_resolved_klass_if_non_deterministic(cp_index);\n+      break;\n+    default:\n@@ -427,1 +468,1 @@\n-bool ConstantPool::maybe_archive_resolved_klass_at(int cp_index) {\n+void ConstantPool::remove_resolved_klass_if_non_deterministic(int cp_index) {\n@@ -431,5 +472,12 @@\n-  if (pool_holder()->is_hidden() && cp_index == pool_holder()->this_class_index()) {\n-    \/\/ All references to a hidden class's own field\/methods are through this\n-    \/\/ index, which was resolved in ClassFileParser::fill_instance_klass. We\n-    \/\/ must preserve it.\n-    return true;\n+  Klass* k = resolved_klass_at(cp_index);\n+  bool can_archive;\n+\n+  if (k == nullptr) {\n+    \/\/ We'd come here if the referenced class has been excluded via\n+    \/\/ SystemDictionaryShared::is_excluded_class(). As a result, ArchiveBuilder\n+    \/\/ has cleared the resolved_klasses()->at(...) pointer to NULL. Thus, we\n+    \/\/ need to revert the tag to JVM_CONSTANT_UnresolvedClass.\n+    can_archive = false;\n+  } else {\n+    ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(this);\n+    can_archive = ClassPrelinker::is_resolution_deterministic(src_cp, cp_index);\n@@ -438,5 +486,5 @@\n-  CPKlassSlot kslot = klass_slot_at(cp_index);\n-  int resolved_klass_index = kslot.resolved_klass_index();\n-  Klass* k = resolved_klasses()->at(resolved_klass_index);\n-  \/\/ k could be null if the referenced class has been excluded via\n-  \/\/ SystemDictionaryShared::is_excluded_class().\n+  if (!can_archive) {\n+    int resolved_klass_index = klass_slot_at(cp_index).resolved_klass_index();\n+    resolved_klasses()->at_put(resolved_klass_index, nullptr);\n+    tag_at_put(cp_index, JVM_CONSTANT_UnresolvedClass);\n+  }\n@@ -444,9 +492,12 @@\n-  if (k != nullptr) {\n-    ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(this);\n-    if (ClassPrelinker::can_archive_resolved_klass(src_cp, cp_index)) {\n-      if (log_is_enabled(Debug, cds, resolve)) {\n-        ResourceMark rm;\n-        log_debug(cds, resolve)(\"Resolved klass CP entry [%d]: %s => %s\", cp_index,\n-                                pool_holder()->external_name(), k->external_name());\n-      }\n-      return true;\n+  LogStreamHandle(Trace, cds, resolve) log;\n+  if (log.is_enabled()) {\n+    ResourceMark rm;\n+    log.print(\"%s klass  CP entry [%3d]: %s %s\",\n+              (can_archive ? \"archived\" : \"reverted\"),\n+              cp_index, pool_holder()->name()->as_C_string(), get_type(pool_holder()));\n+    if (can_archive) {\n+      log.print(\" => %s %s%s\", k->name()->as_C_string(), get_type(k),\n+                (!k->is_instance_klass() || pool_holder()->is_subtype_of(k)) ? \"\" : \" (not supertype)\");\n+    } else {\n+      Symbol* name = klass_name_at(cp_index);\n+      log.print(\"    %s\", name->as_C_string());\n@@ -456,5 +507,1 @@\n-  \/\/ This referenced class cannot be archived. Revert the tag to UnresolvedClass,\n-  \/\/ so that the proper class loading and initialization can happen at runtime.\n-  resolved_klasses()->at_put(resolved_klass_index, nullptr);\n-  tag_at_put(cp_index, JVM_CONSTANT_UnresolvedClass);\n-  return false;\n+  ArchiveBuilder::alloc_stats()->record_klass_cp_entry(can_archive, \/*reverted=*\/!can_archive);\n@@ -708,0 +755,25 @@\n+bool ConstantPool::is_resolved(int index, Bytecodes::Code code) {\n+  assert(cache() != nullptr, \"'index' is a rewritten index so this class must have been rewritten\");\n+  switch(code) {\n+    case Bytecodes::_invokedynamic:\n+      return resolved_indy_entry_at(index)->is_resolved();\n+\n+    case Bytecodes::_getfield:\n+    case Bytecodes::_getstatic:\n+    case Bytecodes::_putfield:\n+    case Bytecodes::_putstatic:\n+      return resolved_field_entry_at(index)->is_resolved(code);\n+\n+    case Bytecodes::_invokeinterface:\n+    case Bytecodes::_invokehandle:\n+    case Bytecodes::_invokespecial:\n+    case Bytecodes::_invokestatic:\n+    case Bytecodes::_invokevirtual:\n+    case Bytecodes::_fast_invokevfinal: \/\/ Bytecode interpreter uses this\n+      return resolved_method_entry_at(index)->is_resolved(code);\n+\n+    default:\n+      fatal(\"Unexpected bytecode: %s\", Bytecodes::name(code));\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":120,"deletions":48,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -664,0 +664,2 @@\n+  bool is_resolved(int which, Bytecodes::Code code);\n+\n@@ -680,1 +682,0 @@\n-  bool maybe_archive_resolved_klass_at(int cp_index);\n@@ -683,0 +684,3 @@\n+private:\n+  void remove_unshareable_entries();\n+  void remove_resolved_klass_if_non_deterministic(int cp_index);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/classPrelinker.hpp\"\n@@ -391,3 +392,1 @@\n-  \/\/ <this> is the copy to be written into the archive. It's in the ArchiveBuilder's \"buffer space\".\n-  \/\/ However, this->_initial_entries was not copied\/relocated by the ArchiveBuilder, so it's\n-  \/\/ still pointing to the array allocated inside save_for_archive().\n+\n@@ -400,3 +399,1 @@\n-    for (int i = 0; i < _resolved_field_entries->length(); i++) {\n-      resolved_field_entry_at(i)->remove_unshareable_info();\n-    }\n+    remove_resolved_field_entries_if_non_deterministic();\n@@ -410,0 +407,35 @@\n+\n+void ConstantPoolCache::remove_resolved_field_entries_if_non_deterministic() {\n+  ConstantPool* cp = constant_pool();\n+  ConstantPool* src_cp =  ArchiveBuilder::current()->get_source_addr(cp);\n+  for (int i = 0; i < _resolved_field_entries->length(); i++) {\n+    ResolvedFieldEntry* rfi = _resolved_field_entries->adr_at(i);\n+    int cp_index = rfi->constant_pool_index();\n+    bool archived = false;\n+    bool resolved = rfi->is_resolved(Bytecodes::_getfield)  ||\n+                    rfi->is_resolved(Bytecodes::_putfield);\n+    if (resolved && ClassPrelinker::is_resolution_deterministic(src_cp, cp_index)) {\n+      rfi->mark_and_relocate();\n+      archived = true;\n+    } else {\n+      rfi->remove_unshareable_info();\n+    }\n+    if (resolved) {\n+      LogStreamHandle(Trace, cds, resolve) log;\n+      if (log.is_enabled()) {\n+        ResourceMark rm;\n+        int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n+        Symbol* klass_name = cp->klass_name_at(klass_cp_index);\n+        Symbol* name = cp->uncached_name_ref_at(cp_index);\n+        Symbol* signature = cp->uncached_signature_ref_at(cp_index);\n+        log.print(\"%s field  CP entry [%3d]: %s %s %s.%s:%s\",\n+                  (archived ? \"archived\" : \"reverted\"),\n+                  cp_index,\n+                  cp->pool_holder()->name()->as_C_string(),\n+                  (archived ? \"=>\" : \"  \"),\n+                  klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n+      }\n+    }\n+    ArchiveBuilder::alloc_stats()->record_field_cp_entry(archived, resolved && !archived);\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":38,"deletions":6,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -196,1 +196,0 @@\n-  void save_for_archive(TRAPS);\n@@ -203,1 +202,0 @@\n-\n@@ -227,0 +225,4 @@\n+#if INCLUDE_CDS\n+  void remove_resolved_field_entries_if_non_deterministic();\n+#endif\n+\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2558,1 +2558,3 @@\n-  constants()->remove_unshareable_info();\n+  \/\/ Call remove_unshareable_info() on other objects that belong to this class, except\n+  \/\/ for constants()->remove_unshareable_info(), which is called in a separate pass in\n+  \/\/ ArchiveBuilder::make_klasses_shareable(),\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,2 @@\n-#include \"resolvedFieldEntry.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -46,0 +47,1 @@\n+#if INCLUDE_CDS\n@@ -51,0 +53,5 @@\n+\n+void ResolvedFieldEntry::mark_and_relocate() {\n+  ArchiveBuilder::current()->mark_and_relocate_to_buffered_addr(&_field_holder);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,11 @@\n+  void copy_from(const ResolvedFieldEntry& other) {\n+    _field_holder = other._field_holder;\n+    _field_offset = other._field_offset;\n+    _field_index = other._field_index;\n+    _cpool_index = other._cpool_index;\n+    _tos_state = other._tos_state;\n+    _flags = other._flags;\n+    _get_code = other._get_code;\n+    _put_code = other._put_code;\n+  }\n+\n@@ -68,0 +79,1 @@\n+\n@@ -71,0 +83,9 @@\n+  ResolvedFieldEntry(const ResolvedFieldEntry& other) {\n+    copy_from(other);\n+  }\n+\n+  ResolvedFieldEntry& operator=(const ResolvedFieldEntry& other) {\n+    copy_from(other);\n+    return *this;\n+  }\n+\n@@ -134,0 +155,1 @@\n+#if INCLUDE_CDS\n@@ -135,0 +157,2 @@\n+  void mark_and_relocate();\n+#endif\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.hpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"cds\/archiveBuilder.hpp\"\n@@ -40,0 +41,1 @@\n+#if INCLUDE_CDS\n@@ -48,0 +50,6 @@\n+void ResolvedIndyEntry::mark_and_relocate() {\n+  assert(is_resolved(), \"must be\");\n+  ArchiveBuilder::current()->mark_and_relocate_to_buffered_addr(&_method);\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/oops\/resolvedIndyEntry.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,0 +132,1 @@\n+#if INCLUDE_CDS\n@@ -133,0 +134,2 @@\n+  void mark_and_relocate();\n+#endif\n","filename":"src\/hotspot\/share\/oops\/resolvedIndyEntry.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"cds\/archiveBuilder.hpp\"\n@@ -53,0 +54,1 @@\n+#if INCLUDE_CDS\n@@ -57,0 +59,12 @@\n+void ResolvedMethodEntry::mark_and_relocate(ConstantPool* src_cp) {\n+  if (_method == nullptr) {\n+    assert(bytecode2() == Bytecodes::_invokevirtual, \"\");\n+  } else {\n+    ArchiveBuilder::current()->mark_and_relocate_to_buffered_addr(&_method);\n+  }\n+  if (bytecode1() == Bytecodes::_invokeinterface) {\n+    ArchiveBuilder::current()->mark_and_relocate_to_buffered_addr(&_entry_specific._interface_klass);\n+  }\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/oops\/resolvedMethodEntry.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,0 +227,1 @@\n+#if INCLUDE_CDS\n@@ -228,0 +229,2 @@\n+  void mark_and_relocate(ConstantPool* src_cp);\n+#endif\n","filename":"src\/hotspot\/share\/oops\/resolvedMethodEntry.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3732,1 +3732,1 @@\n-      w.stream()->print_cr(\"%s %s\", LAMBDA_FORM_TAG, c_line);\n+      w.stream()->print_cr(\"%s %s\", ClassListParser::lambda_form_tag(), c_line);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/classListWriter.hpp\"\n@@ -434,0 +435,4 @@\n+#if INCLUDE_CDS\n+  ClassListWriter::write_resolved_constants();\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -451,0 +451,1 @@\n+ -runtime\/cds\/appcds\/resolvedConstants \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Dump time resolutiom of constant pool entries.\n+ * @requires vm.cds\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @library \/test\/lib\n+ * @build ResolvedConstants\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar ResolvedConstantsApp ResolvedConstantsFoo ResolvedConstantsBar\n+ * @run driver ResolvedConstants\n+ *\/\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class ResolvedConstants {\n+    static final String classList = \"ResolvedConstants.classlist\";\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = ResolvedConstantsApp.class.getName();\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ dump class list\n+        CDSTestUtils.dumpClassList(classList, \"-cp\", appJar, mainClass)\n+            .assertNormalExit(output -> {\n+                output.shouldContain(\"Hello ResolvedConstantsApp\");\n+            });\n+\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", appJar,\n+                       \"-Xlog:cds+resolve=trace\");\n+        CDSTestUtils.createArchiveAndCheck(opts)\n+            \/\/ Always resolve reference when a class references itself\n+            .shouldMatch(\"cds,resolve.*archived klass.* ResolvedConstantsApp app => ResolvedConstantsApp app\")\n+\n+            \/\/ Always resolve reference when a class references a super class\n+            .shouldMatch(\"cds,resolve.*archived klass.* ResolvedConstantsApp app => java\/lang\/Object boot\")\n+            .shouldMatch(\"cds,resolve.*archived klass.* ResolvedConstantsBar app => ResolvedConstantsFoo app\")\n+\n+            \/\/ Always resolve reference when a class references a super interface\n+            .shouldMatch(\"cds,resolve.*archived klass.* ResolvedConstantsApp app => java\/lang\/Runnable boot\")\n+\n+            \/\/ java\/lang\/System is in the root loader but ResolvedConstantsApp is loaded by the app loader.\n+            \/\/ Even though System is in the vmClasses list, when ResolvedConstantsApp looks up\n+            \/\/ \"java\/lang\/System\" in its ConstantPool, the app loader may not have resolved the System\n+            \/\/ class yet (i.e., there's no initiaited class entry for System in the app loader's dictionary)\n+            .shouldMatch(\"cds,resolve.*reverted klass.* ResolvedConstantsApp .*java\/lang\/System\")\n+\n+            \/\/ Always resolve references to fields in the current class or super class(es)\n+            .shouldMatch(\"cds,resolve.*archived field.* ResolvedConstantsBar => ResolvedConstantsBar.b:I\")\n+            .shouldMatch(\"cds,resolve.*archived field.* ResolvedConstantsBar => ResolvedConstantsBar.a:I\")\n+            .shouldMatch(\"cds,resolve.*archived field.* ResolvedConstantsBar => ResolvedConstantsFoo.a:I\")\n+\n+            \/\/ Do not resolve field references to child classes\n+            .shouldMatch(\"cds,resolve.*archived field.* ResolvedConstantsFoo => ResolvedConstantsFoo.a:I\")\n+            .shouldMatch(\"cds,resolve.*reverted field.* ResolvedConstantsFoo    ResolvedConstantsBar.a:I\")\n+            .shouldMatch(\"cds,resolve.*reverted field.* ResolvedConstantsFoo    ResolvedConstantsBar.b:I\")\n+\n+\n+            \/\/ Do not resolve field references to unrelated classes\n+            .shouldMatch(\"cds,resolve.*reverted field.* ResolvedConstantsApp    ResolvedConstantsBar.a:I\")\n+            .shouldMatch(\"cds,resolve.*reverted field.* ResolvedConstantsApp    ResolvedConstantsBar.b:I\")\n+\n+            ;\n+    }\n+}\n+\n+class ResolvedConstantsApp implements Runnable {\n+    public static void main(String args[]) {\n+        System.out.println(\"Hello ResolvedConstantsApp\");\n+        Object a = new ResolvedConstantsApp();\n+        ((Runnable)a).run();\n+\n+        ResolvedConstantsFoo foo = new ResolvedConstantsFoo();\n+        ResolvedConstantsBar bar = new ResolvedConstantsBar();\n+        bar.a ++;\n+        bar.b ++;\n+        bar.doit();\n+    }\n+    public void run() {}\n+}\n+\n+class ResolvedConstantsFoo {\n+    int a = 1;\n+    void doit() {\n+    }\n+\n+    void doBar(ResolvedConstantsBar bar) {\n+        bar.a ++;\n+        bar.b ++;\n+    }\n+}\n+\n+class ResolvedConstantsBar extends ResolvedConstantsFoo {\n+    int b = 2;\n+    void doit() {\n+        System.out.println(\"Hello ResolvedConstantsBar and \" + ResolvedConstantsFoo.class.getName());\n+        System.out.println(\"a = \" + a);\n+        System.out.println(\"a = \" + ((ResolvedConstantsFoo)this).a);\n+        System.out.println(\"b = \" + b);\n+\n+        doBar(this);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Fieldref entry for putfield bytecodes for a final field cannot be preresolved if it's used by a\n+ *          method outside of <clinit>\n+ * @requires vm.cds\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @library \/test\/lib\n+ * @build ResolvedPutFieldHelper\n+ * @build ResolvedPutField\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar ResolvedPutFieldApp ResolvedPutFieldHelper\n+ * @run driver ResolvedPutField\n+ *\/\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class ResolvedPutField {\n+    static final String classList = \"ResolvedPutField.classlist\";\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = ResolvedPutFieldApp.class.getName();\n+    static final String error = \"Update to non-static final field ResolvedPutFieldHelper.x attempted from a different method (set_x) than the initializer method <init>\";\n+    public static void main(String[] args) throws Exception {\n+        \/\/ dump class list\n+        CDSTestUtils.dumpClassList(classList, \"-cp\", appJar, mainClass)\n+            .assertNormalExit(error);\n+\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", appJar,\n+                       \"-Xlog:cds+resolve=trace\");\n+        CDSTestUtils.createArchiveAndCheck(opts)\n+            .shouldMatch(\"cds,resolve.*Failed to resolve putfield .*ResolvedPutFieldHelper -> ResolvedPutFieldHelper.x:I\");\n+    }\n+}\n+\n+class ResolvedPutFieldApp {\n+    public static void main(String args[]) {\n+        try {\n+            ResolvedPutFieldHelper.main(args);\n+        } catch (IllegalAccessError e) {\n+            System.out.println(\"IllegalAccessError expected:\");\n+            System.out.println(e);\n+            System.exit(0);\n+        }\n+        throw new RuntimeException(\"IllegalAccessError expected!\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/ResolvedPutField.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+\/*\n+\n+class ResolvedPutFieldHelper {\n+   int x; \/\/ change it to 'final'\n+   ResolvedPutFieldHelper() { x = 1; }\n+   void set_x() { x = 2; }\n+\n+    public static void main(String args[]) {\n+        ResolvedPutFieldHelper s = new ResolvedPutFieldHelper();\n+        s.set_x();\n+        System.out.println(s.x);\n+    }\n+}\n+\n+*\/\n+\n+\n+\n+super class ResolvedPutFieldHelper\n+    version 66:0\n+{\n+  \/\/WAS Field x:I;\n+  final Field x:I;\n+\n+  Method \"<init>\":\"()V\"\n+    stack 2 locals 1\n+  {\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        aload_0;\n+        iconst_1;\n+        putfield         Field x:\"I\";\n+        return;\n+  }\n+\n+  \/\/ set_x is not allowed to write to the final \"x\" field. If CDS pre-resolves its\n+  \/\/ ResolvedFieldEntry for the putfield bytecode, then we cannot get\n+  \/\/ the IllegalAccessError at runtime. See JDK-8157181 for the code that\n+  \/\/ throws the IllegalAccessError.\n+\n+  Method set_x:\"()V\"\n+    stack 2 locals 1\n+  {\n+        aload_0;\n+        iconst_2;\n+        putfield         Field x:\"I\";\n+        return;\n+  }\n+  public static Method main:\"([Ljava\/lang\/String;)V\"\n+    stack 2 locals 2\n+  {\n+        new              class ResolvedPutFieldHelper;\n+        dup;\n+        invokespecial    Method \"<init>\":\"()V\";\n+        astore_1;\n+        aload_1;\n+        invokevirtual    Method set_x:\"()V\";\n+        getstatic         Field java\/lang\/System.out:\"Ljava\/io\/PrintStream;\";\n+        aload_1;\n+        getfield         Field x:\"I\";\n+        invokevirtual    Method java\/io\/PrintStream.println:\"(I)V\";\n+        return;\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/ResolvedPutFieldHelper.jasm","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"}]}