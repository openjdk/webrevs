{"files":[{"patch":"@@ -113,8 +113,0 @@\n-  msg.info(\"Method CP entries = %6d, archived = %6d (%5.1f%%), reverted = %6d\",\n-           _num_method_cp_entries, _num_method_cp_entries_archived,\n-           percent_of(_num_method_cp_entries_archived, _num_method_cp_entries),\n-           _num_method_cp_entries_reverted);\n-  msg.info(\"Indy   CP entries = %6d, archived = %6d (%5.1f%%), reverted = %6d\",\n-           _num_indy_cp_entries, _num_indy_cp_entries_archived,\n-           percent_of(_num_indy_cp_entries_archived, _num_indy_cp_entries),\n-           _num_indy_cp_entries_reverted);\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,3 +71,0 @@\n-  int _num_indy_cp_entries;\n-  int _num_indy_cp_entries_archived;\n-  int _num_indy_cp_entries_reverted;\n@@ -77,3 +74,0 @@\n-  int _num_method_cp_entries;\n-  int _num_method_cp_entries_archived;\n-  int _num_method_cp_entries_reverted;\n@@ -90,3 +84,0 @@\n-    _num_indy_cp_entries            = 0;\n-    _num_indy_cp_entries_archived   = 0;\n-    _num_indy_cp_entries_reverted   = 0;\n@@ -96,3 +87,0 @@\n-    _num_method_cp_entries          = 0;\n-    _num_method_cp_entries_archived = 0;\n-    _num_method_cp_entries_reverted = 0;\n@@ -131,6 +119,0 @@\n-  void record_indy_cp_entry(bool archived, bool reverted) {\n-    _num_indy_cp_entries ++;\n-    _num_indy_cp_entries_archived += archived ? 1 : 0;\n-    _num_indy_cp_entries_reverted += reverted ? 1 : 0;\n-  }\n-\n@@ -143,6 +125,0 @@\n-  void record_method_cp_entry(bool archived, bool reverted) {\n-    _num_method_cp_entries ++;\n-    _num_method_cp_entries_archived += archived ? 1 : 0;\n-    _num_method_cp_entries_reverted += reverted ? 1 : 0;\n-  }\n-\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.hpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -464,3 +464,1 @@\n-    remove_resolved_field_entries_if_non_deterministic();\n-    remove_resolved_method_entries_if_non_deterministic();\n-    remove_resolved_indy_entries_if_non_deterministic();\n+    cache()->remove_unshareable_info();\n@@ -511,123 +509,0 @@\n-\n-void ConstantPool::remove_resolved_field_entries_if_non_deterministic() {\n-  ConstantPool* src_cp =  ArchiveBuilder::current()->get_source_addr(this);\n-  Array<ResolvedFieldEntry>* field_entries = cache()->resolved_field_entries();\n-  if (field_entries != nullptr) {\n-    for (int i = 0; i < field_entries->length(); i++) {\n-      ResolvedFieldEntry* rfi = field_entries->adr_at(i);\n-      int cp_index = rfi->constant_pool_index();\n-      bool archived = false;\n-      bool resolved = rfi->is_resolved(Bytecodes::_putfield)  ||\n-                      rfi->is_resolved(Bytecodes::_putfield);\n-      if (resolved && ClassPrelinker::is_resolution_deterministic(src_cp, cp_index)) {\n-        rfi->mark_and_relocate();\n-        archived = true;\n-      } else {\n-        rfi->remove_unshareable_info();\n-      }\n-      if (resolved) {\n-        LogStreamHandle(Trace, cds, resolve) log;\n-        if (log.is_enabled()) {\n-          ResourceMark rm;\n-          int klass_cp_index = uncached_klass_ref_index_at(cp_index);\n-          Symbol* klass_name = klass_name_at(klass_cp_index);\n-          Symbol* name = uncached_name_ref_at(cp_index);\n-          Symbol* signature = uncached_signature_ref_at(cp_index);\n-          log.print(\"%s field  CP entry [%3d]: %s %s %s.%s:%s\",\n-                    (archived ? \"archived\" : \"reverted\"),\n-                    cp_index,\n-                    pool_holder()->name()->as_C_string(),\n-                    (archived ? \"=>\" : \"  \"),\n-                    klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n-        }\n-      }\n-      ArchiveBuilder::alloc_stats()->record_field_cp_entry(archived, resolved && !archived);\n-    }\n-  }\n-}\n-\n-void ConstantPool::remove_resolved_method_entries_if_non_deterministic() {\n-  ConstantPool* src_cp =  ArchiveBuilder::current()->get_source_addr(this);\n-  Array<ResolvedMethodEntry>* method_entries = cache()->resolved_method_entries();\n-  if (method_entries != nullptr) {\n-    for (int i = 0; i < method_entries->length(); i++) {\n-      ResolvedMethodEntry* rme = method_entries->adr_at(i);\n-      int cp_index = rme->constant_pool_index();\n-      bool archived = false;\n-      bool resolved = rme->is_resolved(Bytecodes::_invokevirtual)   ||\n-                      rme->is_resolved(Bytecodes::_invokespecial)   ||\n-                      rme->is_resolved(Bytecodes::_invokestatic)    ||\n-                      rme->is_resolved(Bytecodes::_invokeinterface) ||\n-                      rme->is_resolved(Bytecodes::_invokehandle);\n-      if (resolved && can_archive_resolved_method(rme)) {\n-        rme->mark_and_relocate(src_cp);\n-        archived = true;\n-      } else {\n-        rme->remove_unshareable_info();\n-      }\n-      if (resolved) {\n-        LogStreamHandle(Trace, cds, resolve) log;\n-        if (log.is_enabled()) {\n-          ResourceMark rm;\n-          int klass_cp_index = uncached_klass_ref_index_at(cp_index);\n-          Symbol* klass_name = klass_name_at(klass_cp_index);\n-          Symbol* name = uncached_name_ref_at(cp_index);\n-          Symbol* signature = uncached_signature_ref_at(cp_index);\n-          log.print(\"%s%s method CP entry [%3d]: %s %s.%s:%s\",\n-                    (archived ? \"archived\" : \"reverted\"),\n-                    (rme->is_resolved(Bytecodes::_invokeinterface) ? \" interface\" : \"\"),\n-                    cp_index,\n-                    pool_holder()->name()->as_C_string(),\n-                    klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n-          if (archived) {\n-            Klass* resolved_klass = resolved_klass_at(klass_cp_index);\n-            log.print(\" => %s%s\",\n-                      resolved_klass->name()->as_C_string(),\n-                      (rme->is_resolved(Bytecodes::_invokestatic) ? \" *** static\" : \"\"));\n-          }\n-        }\n-      }\n-      ArchiveBuilder::alloc_stats()->record_method_cp_entry(archived, resolved && !archived);\n-    }\n-  }\n-}\n-\n-void ConstantPool::remove_resolved_indy_entries_if_non_deterministic() {\n-  ConstantPool* src_cp =  ArchiveBuilder::current()->get_source_addr(this);\n-  Array<ResolvedIndyEntry>* indy_entries = cache()->resolved_indy_entries();\n-  if (indy_entries != nullptr) {\n-    for (int i = 0; i < indy_entries->length(); i++) {\n-      ResolvedIndyEntry* rei = indy_entries->adr_at(i);\n-      int cp_index = rei->constant_pool_index();\n-      bool archived = false;\n-      bool resolved = rei->is_resolved();\n-      if (resolved && ClassPrelinker::is_resolution_deterministic(src_cp, cp_index)) {\n-        rei->mark_and_relocate();\n-        archived = true;\n-      } else {\n-        rei->remove_unshareable_info();\n-      }\n-      if (resolved) {\n-        LogStreamHandle(Trace, cds, resolve) log;\n-        if (log.is_enabled()) {\n-          ResourceMark rm;\n-          int bsm = bootstrap_method_ref_index_at(cp_index);\n-          int bsm_ref = method_handle_index_at(bsm);\n-          Symbol* bsm_name = uncached_name_ref_at(bsm_ref);\n-          Symbol* bsm_signature = uncached_signature_ref_at(bsm_ref);\n-          Symbol* bsm_klass = klass_name_at(uncached_klass_ref_index_at(bsm_ref));\n-          log.print(\"%s indy   CP entry [%3d]: %s (%d)\",\n-                    (archived ? \"archived\" : \"reverted\"),\n-                    cp_index, pool_holder()->name()->as_C_string(), i);\n-          log.print(\" %s %s.%s:%s\", (archived ? \"=>\" : \"  \"), bsm_klass->as_C_string(), bsm_name->as_C_string(), bsm_signature->as_C_string());\n-        }\n-      }\n-      ArchiveBuilder::alloc_stats()->record_indy_cp_entry(archived, resolved && !archived);\n-    }\n-  }\n-}\n-\n-bool ConstantPool::can_archive_resolved_method(ResolvedMethodEntry* method_entry) {\n-  \/\/ Archiving of resolved methods are not implemented yet.\n-  return false;\n-}\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":126,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -685,2 +685,0 @@\n-  bool can_archive_invokehandle(ResolvedMethodEntry* rme);\n-  bool can_archive_resolved_method(ResolvedMethodEntry* method_entry);\n@@ -689,3 +687,0 @@\n-  void remove_resolved_field_entries_if_non_deterministic();\n-  void remove_resolved_method_entries_if_non_deterministic();\n-  void remove_resolved_indy_entries_if_non_deterministic();\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/classPrelinker.hpp\"\n@@ -391,3 +392,1 @@\n-  \/\/ <this> is the copy to be written into the archive. It's in the ArchiveBuilder's \"buffer space\".\n-  \/\/ However, this->_initial_entries was not copied\/relocated by the ArchiveBuilder, so it's\n-  \/\/ still pointing to the array allocated inside save_for_archive().\n+\n@@ -400,3 +399,1 @@\n-    for (int i = 0; i < _resolved_field_entries->length(); i++) {\n-      resolved_field_entry_at(i)->remove_unshareable_info();\n-    }\n+    remove_resolved_field_entries_if_non_deterministic();\n@@ -410,0 +407,35 @@\n+\n+void ConstantPoolCache::remove_resolved_field_entries_if_non_deterministic() {\n+  ConstantPool* cp = constant_pool();\n+  ConstantPool* src_cp =  ArchiveBuilder::current()->get_source_addr(cp);\n+  for (int i = 0; i < _resolved_field_entries->length(); i++) {\n+    ResolvedFieldEntry* rfi = _resolved_field_entries->adr_at(i);\n+    int cp_index = rfi->constant_pool_index();\n+    bool archived = false;\n+    bool resolved = rfi->is_resolved(Bytecodes::_getfield)  ||\n+                    rfi->is_resolved(Bytecodes::_putfield);\n+    if (resolved && ClassPrelinker::is_resolution_deterministic(src_cp, cp_index)) {\n+      rfi->mark_and_relocate();\n+      archived = true;\n+    } else {\n+      rfi->remove_unshareable_info();\n+    }\n+    if (resolved) {\n+      LogStreamHandle(Trace, cds, resolve) log;\n+      if (log.is_enabled()) {\n+        ResourceMark rm;\n+        int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n+        Symbol* klass_name = cp->klass_name_at(klass_cp_index);\n+        Symbol* name = cp->uncached_name_ref_at(cp_index);\n+        Symbol* signature = cp->uncached_signature_ref_at(cp_index);\n+        log.print(\"%s field  CP entry [%3d]: %s %s %s.%s:%s\",\n+                  (archived ? \"archived\" : \"reverted\"),\n+                  cp_index,\n+                  cp->pool_holder()->name()->as_C_string(),\n+                  (archived ? \"=>\" : \"  \"),\n+                  klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n+      }\n+    }\n+    ArchiveBuilder::alloc_stats()->record_field_cp_entry(archived, resolved && !archived);\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":38,"deletions":6,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -196,1 +196,0 @@\n-  void save_for_archive(TRAPS);\n@@ -203,1 +202,0 @@\n-\n@@ -227,0 +225,4 @@\n+#if INCLUDE_CDS\n+  void remove_resolved_field_entries_if_non_deterministic();\n+#endif\n+\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}