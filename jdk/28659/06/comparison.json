{"files":[{"patch":"@@ -38,0 +38,2 @@\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/stack.inline.hpp\"\n@@ -51,0 +53,1 @@\n+  dfs.drain_probe_stack();\n@@ -63,0 +66,1 @@\n+  dfs.drain_probe_stack();\n@@ -68,0 +72,1 @@\n+  dfs.drain_probe_stack();\n@@ -72,1 +77,2 @@\n-  _max_depth(max_dfs_depth), _depth(0), _ignore_root_set(false) {\n+  _max_depth(max_dfs_depth), _depth(0), _ignore_root_set(false),\n+  _probe_stack(MIN2(256UL, max_dfs_depth)) {\n@@ -75,16 +81,36 @@\n-void DFSClosure::closure_impl(UnifiedOopRef reference, const oop pointee) {\n-  assert(pointee != nullptr, \"invariant\");\n-  assert(!reference.is_null(), \"invariant\");\n-\n-  if (GranularTimer::is_finished()) {\n-    return;\n-  }\n-\n-  if (_depth == 0 && _ignore_root_set) {\n-    \/\/ Root set is already marked, but we want\n-    \/\/ to continue, so skip is_marked check.\n-    assert(_mark_bits->is_marked(pointee), \"invariant\");\n-    _reference_stack[_depth] = reference;\n-  } else {\n-    if (_mark_bits->is_marked(pointee)) {\n-      return;\n+#ifdef ASSERT\n+DFSClosure::~DFSClosure() {\n+  assert(_probe_stack.is_empty() || GranularTimer::is_finished(),\n+         \"Should have drained the probe stack\");\n+}\n+#endif \/\/ ASSERT\n+\n+void DFSClosure::drain_probe_stack() {\n+\n+  while (!_probe_stack.is_empty() &&\n+         !GranularTimer::is_finished()) {\n+\n+    const ProbeStackItem psi = _probe_stack.pop();\n+\n+    const UnifiedOopRef reference = psi.r;\n+    assert(!reference.is_null(), \"invariant\");\n+    const oop pointee = reference.dereference();\n+    assert(pointee != nullptr, \"invariant\");\n+\n+    _depth = psi.depth;\n+\n+    if (_depth == 0 && _ignore_root_set) {\n+      \/\/ Root set is already marked, but we want\n+      \/\/ to continue, so skip is_marked check.\n+      assert(_mark_bits->is_marked(pointee), \"invariant\");\n+      _reference_stack[_depth] = reference;\n+    } else {\n+      if (_mark_bits->is_marked(pointee)) {\n+        continue;\n+      }\n+      _mark_bits->mark_obj(pointee);\n+      _reference_stack[_depth] = reference;\n+      \/\/ is the pointee a sample object?\n+      if (pointee->mark().is_marked()) {\n+        add_chain();\n+      }\n@@ -92,5 +118,27 @@\n-    _mark_bits->mark_obj(pointee);\n-    _reference_stack[_depth] = reference;\n-    \/\/ is the pointee a sample object?\n-    if (pointee->mark().is_marked()) {\n-      add_chain();\n+    assert(_max_depth >= 1, \"invariant\");\n+    if (_depth < _max_depth - 1) {\n+      _depth++; \/\/ increase range for do_oop() to pick up\n+\n+      if (pointee->is_objArray()) {\n+        objArrayOop pointee_oa = (objArrayOop)pointee;\n+        const int len = pointee_oa->length();\n+        \/\/ since our stack items are larger than those of GC marking stacks,\n+        \/\/ we use a smaller stride\n+        const int stridelen = MAX2((uintx)1, ObjArrayMarkingStride \/ 2);\n+        const int begidx = psi.chunk * stridelen;\n+        const int endidx = MIN2(len, (psi.chunk + 1) * stridelen);\n+        if (endidx > begidx) {\n+          if (endidx < len) {\n+            ProbeStackItem psi2 = psi;\n+            psi2.chunk ++;\n+            _probe_stack.push(psi2);\n+tty->print_cr(\"adding cont task %u %d\", psi2.depth, psi2.chunk);\n+          }\n+          pointee_oa->oop_iterate_range(this, begidx, endidx);\n+        }\n+      } else {\n+        pointee->oop_iterate(this);\n+      }\n+\n+      assert(_depth > 0, \"invariant\");\n+      _depth--;\n@@ -99,7 +147,0 @@\n-  assert(_max_depth >= 1, \"invariant\");\n-  if (_depth < _max_depth - 1) {\n-    _depth++;\n-    pointee->oop_iterate(this);\n-    assert(_depth > 0, \"invariant\");\n-    _depth--;\n-  }\n@@ -109,0 +150,1 @@\n+\n@@ -138,1 +180,2 @@\n-    closure_impl(UnifiedOopRef::encode_in_heap(ref), pointee);\n+    ProbeStackItem psi { UnifiedOopRef::encode_in_heap(ref), checked_cast<unsigned>(_depth), 0 };\n+    _probe_stack.push(psi);\n@@ -147,1 +190,2 @@\n-    closure_impl(UnifiedOopRef::encode_in_heap(ref), pointee);\n+    ProbeStackItem psi { UnifiedOopRef::encode_in_heap(ref), checked_cast<unsigned>(_depth), 0 };\n+    _probe_stack.push(psi);\n@@ -155,1 +199,2 @@\n-  closure_impl(ref, pointee);\n+  ProbeStackItem psi { ref, checked_cast<unsigned>(_depth), 0 };\n+  _probe_stack.push(psi);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/dfsClosure.cpp","additions":77,"deletions":32,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,3 @@\n+#include \"nmt\/memTag.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/stack.hpp\"\n@@ -50,0 +53,3 @@\n+  struct ProbeStackItem { UnifiedOopRef r; unsigned depth; int chunk; };\n+  Stack<ProbeStackItem, mtTracing> _probe_stack;\n+\n@@ -51,0 +57,1 @@\n+  DEBUG_ONLY(~DFSClosure());\n@@ -53,1 +60,1 @@\n-  void closure_impl(UnifiedOopRef reference, const oop pointee);\n+  void drain_probe_stack();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/dfsClosure.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"}]}