{"files":[{"patch":"@@ -38,0 +38,1 @@\n+#include \"utilities\/stack.inline.hpp\"\n@@ -51,0 +52,1 @@\n+  dfs.drain_probe_stack();\n@@ -63,0 +65,1 @@\n+  dfs.drain_probe_stack();\n@@ -68,0 +71,1 @@\n+  dfs.drain_probe_stack();\n@@ -75,3 +79,1 @@\n-void DFSClosure::closure_impl(UnifiedOopRef reference, const oop pointee) {\n-  assert(pointee != nullptr, \"invariant\");\n-  assert(!reference.is_null(), \"invariant\");\n+void DFSClosure::drain_probe_stack() {\n@@ -79,3 +81,1 @@\n-  if (GranularTimer::is_finished()) {\n-    return;\n-  }\n+  while (!_probe_stack.is_empty()) {\n@@ -83,7 +83,1 @@\n-  if (_depth == 0 && _ignore_root_set) {\n-    \/\/ Root set is already marked, but we want\n-    \/\/ to continue, so skip is_marked check.\n-    assert(_mark_bits->is_marked(pointee), \"invariant\");\n-    _reference_stack[_depth] = reference;\n-  } else {\n-    if (_mark_bits->is_marked(pointee)) {\n+    if (GranularTimer::is_finished()) {\n@@ -92,5 +86,32 @@\n-    _mark_bits->mark_obj(pointee);\n-    _reference_stack[_depth] = reference;\n-    \/\/ is the pointee a sample object?\n-    if (pointee->mark().is_marked()) {\n-      add_chain();\n+\n+    const ProbeStackItem psi = _probe_stack.pop();\n+\n+    const UnifiedOopRef reference = psi.r;\n+    assert(!reference.is_null(), \"invariant\");\n+    const oop pointee = reference.dereference();\n+    assert(pointee != nullptr, \"invariant\");\n+\n+    _depth = psi.d;\n+\n+    if (_depth == 0 && _ignore_root_set) {\n+      \/\/ Root set is already marked, but we want\n+      \/\/ to continue, so skip is_marked check.\n+      assert(_mark_bits->is_marked(pointee), \"invariant\");\n+      _reference_stack[_depth] = reference;\n+    } else {\n+      if (_mark_bits->is_marked(pointee)) {\n+        return;\n+      }\n+      _mark_bits->mark_obj(pointee);\n+      _reference_stack[_depth] = reference;\n+      \/\/ is the pointee a sample object?\n+      if (pointee->mark().is_marked()) {\n+        add_chain();\n+      }\n+    }\n+    assert(_max_depth >= 1, \"invariant\");\n+    if (_depth < _max_depth - 1) {\n+      _depth++;\n+      pointee->oop_iterate(this);\n+      assert(_depth > 0, \"invariant\");\n+      _depth--;\n@@ -98,7 +119,0 @@\n-  }\n-  assert(_max_depth >= 1, \"invariant\");\n-  if (_depth < _max_depth - 1) {\n-    _depth++;\n-    pointee->oop_iterate(this);\n-    assert(_depth > 0, \"invariant\");\n-    _depth--;\n@@ -109,0 +123,1 @@\n+\n@@ -138,1 +153,2 @@\n-    closure_impl(UnifiedOopRef::encode_in_heap(ref), pointee);\n+    ProbeStackItem psi { UnifiedOopRef::encode_in_heap(ref), _depth };\n+    _probe_stack.push(psi);\n@@ -147,1 +163,2 @@\n-    closure_impl(UnifiedOopRef::encode_in_heap(ref), pointee);\n+    ProbeStackItem psi { UnifiedOopRef::encode_in_heap(ref), _depth };\n+    _probe_stack.push(psi);\n@@ -155,1 +172,2 @@\n-  closure_impl(ref, pointee);\n+  ProbeStackItem psi { ref, _depth };\n+  _probe_stack.push(psi);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/dfsClosure.cpp","additions":46,"deletions":28,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+#include \"nmt\/memTag.hpp\"\n+#include \"utilities\/stack.hpp\"\n@@ -50,0 +52,3 @@\n+  struct ProbeStackItem { UnifiedOopRef r; size_t d; };\n+  Stack<ProbeStackItem, mtTracing> _probe_stack;\n+\n@@ -53,1 +58,1 @@\n-  void closure_impl(UnifiedOopRef reference, const oop pointee);\n+  void drain_probe_stack();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/dfsClosure.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"}]}