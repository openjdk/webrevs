{"files":[{"patch":"@@ -38,0 +38,2 @@\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/stack.inline.hpp\"\n@@ -51,0 +53,1 @@\n+  dfs.drain_probe_stack();\n@@ -63,0 +66,1 @@\n+  dfs.drain_probe_stack();\n@@ -68,0 +72,1 @@\n+  dfs.drain_probe_stack();\n@@ -72,1 +77,2 @@\n-  _max_depth(max_dfs_depth), _depth(0), _ignore_root_set(false) {\n+  _max_depth(max_dfs_depth), _depth(0), _ignore_root_set(false),\n+  _probe_stack(MIN2(256UL, max_dfs_depth)) {\n@@ -75,16 +81,36 @@\n-void DFSClosure::closure_impl(UnifiedOopRef reference, const oop pointee) {\n-  assert(pointee != nullptr, \"invariant\");\n-  assert(!reference.is_null(), \"invariant\");\n-\n-  if (GranularTimer::is_finished()) {\n-    return;\n-  }\n-\n-  if (_depth == 0 && _ignore_root_set) {\n-    \/\/ Root set is already marked, but we want\n-    \/\/ to continue, so skip is_marked check.\n-    assert(_mark_bits->is_marked(pointee), \"invariant\");\n-    _reference_stack[_depth] = reference;\n-  } else {\n-    if (_mark_bits->is_marked(pointee)) {\n-      return;\n+#ifdef ASSERT\n+DFSClosure::~DFSClosure() {\n+  assert(_probe_stack.is_empty() || GranularTimer::is_finished(),\n+         \"Should have drained the probe stack\");\n+}\n+#endif \/\/ ASSERT\n+\n+void DFSClosure::drain_probe_stack() {\n+\n+  while (!_probe_stack.is_empty() &&\n+         !GranularTimer::is_finished()) {\n+\n+    const ProbeStackItem psi = _probe_stack.pop();\n+\n+    const UnifiedOopRef reference = psi.r;\n+    assert(!reference.is_null(), \"invariant\");\n+    const oop pointee = reference.dereference();\n+    assert(pointee != nullptr, \"invariant\");\n+\n+    _depth = psi.d;\n+\n+    if (_depth == 0 && _ignore_root_set) {\n+      \/\/ Root set is already marked, but we want\n+      \/\/ to continue, so skip is_marked check.\n+      assert(_mark_bits->is_marked(pointee), \"invariant\");\n+      _reference_stack[_depth] = reference;\n+    } else {\n+      if (_mark_bits->is_marked(pointee)) {\n+        continue;\n+      }\n+      _mark_bits->mark_obj(pointee);\n+      _reference_stack[_depth] = reference;\n+      \/\/ is the pointee a sample object?\n+      if (pointee->mark().is_marked()) {\n+        add_chain();\n+      }\n@@ -92,5 +118,6 @@\n-    _mark_bits->mark_obj(pointee);\n-    _reference_stack[_depth] = reference;\n-    \/\/ is the pointee a sample object?\n-    if (pointee->mark().is_marked()) {\n-      add_chain();\n+    assert(_max_depth >= 1, \"invariant\");\n+    if (_depth < _max_depth - 1) {\n+      _depth++;\n+      pointee->oop_iterate(this);\n+      assert(_depth > 0, \"invariant\");\n+      _depth--;\n@@ -99,7 +126,0 @@\n-  assert(_max_depth >= 1, \"invariant\");\n-  if (_depth < _max_depth - 1) {\n-    _depth++;\n-    pointee->oop_iterate(this);\n-    assert(_depth > 0, \"invariant\");\n-    _depth--;\n-  }\n@@ -109,0 +129,1 @@\n+\n@@ -138,1 +159,2 @@\n-    closure_impl(UnifiedOopRef::encode_in_heap(ref), pointee);\n+    ProbeStackItem psi { UnifiedOopRef::encode_in_heap(ref), _depth };\n+    _probe_stack.push(psi);\n@@ -147,1 +169,2 @@\n-    closure_impl(UnifiedOopRef::encode_in_heap(ref), pointee);\n+    ProbeStackItem psi { UnifiedOopRef::encode_in_heap(ref), _depth };\n+    _probe_stack.push(psi);\n@@ -155,1 +178,2 @@\n-  closure_impl(ref, pointee);\n+  ProbeStackItem psi { ref, _depth };\n+  _probe_stack.push(psi);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/dfsClosure.cpp","additions":56,"deletions":32,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,3 @@\n+#include \"nmt\/memTag.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/stack.hpp\"\n@@ -50,0 +53,3 @@\n+  struct ProbeStackItem { UnifiedOopRef r; size_t d; };\n+  Stack<ProbeStackItem, mtTracing> _probe_stack;\n+\n@@ -51,0 +57,1 @@\n+  DEBUG_ONLY(~DFSClosure());\n@@ -53,1 +60,1 @@\n-  void closure_impl(UnifiedOopRef reference, const oop pointee);\n+  void drain_probe_stack();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/dfsClosure.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.util.List;\n+import java.util.*;\n@@ -42,0 +42,15 @@\n+\/**\n+ * @test id=path-to-gc-roots-true-cutoff-inf\n+ * @requires vm.hasJFR & vm.flagless\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -XX:TLABSize=2k -Xmx256M -XX:ErrorLogTimeout=1 jdk.jfr.jcmd.TestJcmdDumpPathToGCRoots true infinity true\n+ *\/\n+\/**\n+ * @test id=path-to-gc-roots-true-cutoff-0\n+ * @requires vm.hasJFR & vm.flagless\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -XX:TLABSize=2k -Xmx256M -XX:ErrorLogTimeout=1 jdk.jfr.jcmd.TestJcmdDumpPathToGCRoots true 0 true\n+ *\/\n+\n@@ -44,2 +59,2 @@\n- * @summary Start a recording with or without path-to-gc-roots\n- * @requires vm.hasJFR\n+ * @test id=path-to-gc-roots-true-cutoff-default\n+ * @requires vm.hasJFR & vm.flagless\n@@ -48,3 +63,49 @@\n- * @requires vm.flagless\n- *\n- * @run main\/othervm -XX:TLABSize=2k jdk.jfr.jcmd.TestJcmdDumpPathToGCRoots\n+ * @run main\/othervm -XX:TLABSize=2k -Xmx256M -XX:ErrorLogTimeout=1 jdk.jfr.jcmd.TestJcmdDumpPathToGCRoots true - true\n+ *\/\n+\n+\/**\n+ * @test id=path-to-gc-roots-false-cutoff-inf\n+ * @requires vm.hasJFR & vm.flagless\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -XX:TLABSize=2k -Xmx256M -XX:ErrorLogTimeout=1 jdk.jfr.jcmd.TestJcmdDumpPathToGCRoots false infinity false\n+ *\/\n+\n+\/**\n+ * @test id=path-to-gc-roots-false-cutoff-0\n+ * @requires vm.hasJFR & vm.flagless\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -XX:TLABSize=2k -Xmx256M -XX:ErrorLogTimeout=1 jdk.jfr.jcmd.TestJcmdDumpPathToGCRoots false 0 false\n+ *\/\n+\n+\/**\n+ * @test id=path-to-gc-roots-false-cutoff-default\n+ * @requires vm.hasJFR & vm.flagless\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -XX:TLABSize=2k -Xmx256M -XX:ErrorLogTimeout=1 jdk.jfr.jcmd.TestJcmdDumpPathToGCRoots false - false\n+ *\/\n+\n+\/**\n+ * @test id=path-to-gc-roots-default-cutoff-inf\n+ * @requires vm.hasJFR & vm.flagless\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -XX:TLABSize=2k -Xmx512M -XX:ErrorLogTimeout=1 jdk.jfr.jcmd.TestJcmdDumpPathToGCRoots - infinity true\n+ *\/\n+\n+\/**\n+ * @test id=path-to-gc-roots-default-cutoff-0\n+ * @requires vm.hasJFR & vm.flagless\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -XX:TLABSize=2k -Xmx512M -XX:ErrorLogTimeout=1 jdk.jfr.jcmd.TestJcmdDumpPathToGCRoots - 0 false\n+ *\/\n+\n+\/**\n+ * @test id=path-to-gc-roots-default-cutoff-default\n+ * @requires vm.hasJFR & vm.flagless\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -XX:TLABSize=2k -Xmx512M -XX:ErrorLogTimeout=1 jdk.jfr.jcmd.TestJcmdDumpPathToGCRoots - - false\n@@ -54,2 +115,4 @@\n-    private static final int OBJECT_COUNT = 100_000;\n-    public static List<Object[]> leak = new ArrayList<>(OBJECT_COUNT);\n+    \/\/ Comfortably large enough to saturate the 32M EdgeQueue in PathToGcRootsOperation\n+    \/\/ and thus exercise both BFS and DFS paths\n+    private static final int OBJECT_COUNT = 2_500_000;\n+    public static List<Object> leak = new ArrayList<>();\n@@ -60,0 +123,4 @@\n+        if (args.length != 3) {\n+            throw new RuntimeException(\"Expected 2 arguments\");\n+        }\n+\n@@ -62,4 +129,12 @@\n-        \/\/ dump parameter trumps previous setting\n-        testDump(\"path-to-gc-roots=true\", Collections.singletonMap(settingName, \"infinity\"), true);\n-        testDump(\"path-to-gc-roots=true\", Collections.singletonMap(settingName, \"0 ns\"), true);\n-        testDump(\"path-to-gc-roots=true\", Collections.emptyMap(), true);\n+        final String ptgcr =\n+            switch (args[0]) {\n+                case \"-\" -> \"\";\n+                default -> \"path-to-gc-roots=\" + args[0];\n+            };\n+\n+        final Map settings = switch (args[1]) {\n+            case \"infinity\" -> Collections.singletonMap(settingName, \"infinity\");\n+            case \"0\" -> Collections.singletonMap(settingName, \"0 ns\");\n+            case \"-\" -> Collections.emptyMap();\n+            default -> throw new RuntimeException(\"Invalid \" + args[1]);\n+        };\n@@ -67,3 +142,4 @@\n-        testDump(\"path-to-gc-roots=false\", Collections.singletonMap(settingName, \"infinity\"), false);\n-        testDump(\"path-to-gc-roots=false\", Collections.singletonMap(settingName, \"0 ns\"), false);\n-        testDump(\"path-to-gc-roots=false\", Collections.emptyMap(), false);\n+        final boolean expectChains = Boolean.valueOf(args[2]);\n+\n+        \/\/ dump parameter trumps previous setting\n+        testDump(ptgcr, settings, expectChains);\n@@ -71,3 +147,0 @@\n-        testDump(\"\", Collections.singletonMap(settingName, \"infinity\"), true);\n-        testDump(\"\", Collections.singletonMap(settingName, \"0 ns\"), false);\n-        testDump(\"\", Collections.emptyMap(), false);\n@@ -93,1 +166,1 @@\n-                File recording = new File(\"TestJcmdDumpPathToGCRoots\" + r.getId() + \".jfr\");\n+                File recording = new File(\"TestJcmdDumpPathToGCRoots.jfr\");\n@@ -134,2 +207,7 @@\n-        for (int i = 0; i < OBJECT_COUNT;i ++) {\n-            leak.add(new Object[0]);\n+        int chainlen = 10000;\n+        for (int i = 0; i < OBJECT_COUNT\/chainlen; i ++) {\n+            LinkedList<Object> l = new LinkedList();\n+            for (int j = 0; j < chainlen; j ++) {\n+                l.add(new Object());\n+            }\n+            leak.add(l);\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdDumpPathToGCRoots.java","additions":99,"deletions":21,"binary":false,"changes":120,"status":"modified"}]}