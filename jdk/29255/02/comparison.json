{"files":[{"patch":"@@ -623,0 +623,1 @@\n+            boolean blocked;\n@@ -626,0 +627,2 @@\n+                \/\/ may have been notified while in transition\n+                blocked = notified && compareAndSetState(WAIT, BLOCKED);\n@@ -640,0 +643,3 @@\n+                    \/\/ May have been notified while in transition. This must be done while\n+                    \/\/ holding the monitor to avoid changing the state of a new timed wait call.\n+                    blocked = notified && compareAndSetState(TIMED_WAIT, BLOCKED);\n@@ -643,3 +649,2 @@\n-            \/\/ may have been notified while in transition to wait state\n-            if (notified && compareAndSetState(newState, BLOCKED)) {\n-                \/\/ may have even been unblocked already\n+            if (blocked) {\n+                \/\/ may have been unblocked already\n@@ -647,1 +652,6 @@\n-                    submitRunContinuation();\n+                    lazySubmitRunContinuation();\n+                }\n+            } else {\n+                \/\/ may have been interrupted while in transition to wait state\n+                if (interruptible && interrupted && compareAndSetState(newState, UNBLOCKED)) {\n+                    lazySubmitRunContinuation();\n@@ -649,7 +659,0 @@\n-                return;\n-            }\n-\n-            \/\/ may have been interrupted while in transition to wait state\n-            if (interruptible && interrupted && compareAndSetState(newState, UNBLOCKED)) {\n-                submitRunContinuation();\n-                return;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8373120\n+ * @summary Stress test two consecutive timed Object.wait calls where only the first one is notified.\n+ * @run main\/othervm -XX:CompileCommand=exclude,java.lang.VirtualThread::afterYield NotifiedThenTimedOutWait 1 100 100\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run main\/othervm -XX:CompileCommand=exclude,java.lang.VirtualThread::afterYield NotifiedThenTimedOutWait 2 100 100\n+ *\/\n+\n+import java.time.Instant;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+public class NotifiedThenTimedOutWait {\n+    public static void main(String[] args) throws Exception {\n+        int race = (args.length > 0) ? Integer.parseInt(args[0]) : 1;\n+        int nruns = (args.length > 1) ? Integer.parseInt(args[1]) : 100;\n+        int iterations = (args.length > 2) ? Integer.parseInt(args[2]) : 100;\n+\n+        for (int i = 1; i <= nruns; i++) {\n+            System.out.println(Instant.now() + \" => \" + i + \" of \" + nruns);\n+            switch (race) {\n+                case 1 -> race1(iterations);\n+                case 2 -> race2(iterations);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Barrier in synchronized block.\n+     *\/\n+    private static void race1(int iterations) throws InterruptedException {\n+        final int timeout = 1;\n+        var lock = new Object();\n+        var start = new Phaser(2);\n+        var end = new Phaser(2);\n+\n+        var vthread = Thread.ofVirtual().start(() -> {\n+            try {\n+                for (int j = 0; j < iterations; j++) {\n+                    synchronized (lock) {\n+                        start.arriveAndAwaitAdvance();\n+                        lock.wait(timeout);\n+                        lock.wait(timeout);\n+                    }\n+                    end.arriveAndAwaitAdvance();\n+                }\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+\n+        ThreadFactory factory = ThreadLocalRandom.current().nextBoolean()\n+                    ? Thread.ofPlatform().factory() : Thread.ofVirtual().factory();\n+        var notifier = factory.newThread(() -> {\n+            for (int j = 0; j < iterations; j++) {\n+                start.arriveAndAwaitAdvance();\n+                synchronized (lock) {\n+                    lock.notify();\n+                }\n+                end.arriveAndAwaitAdvance();\n+            }\n+        });\n+        notifier.start();\n+\n+        vthread.join();\n+        notifier.join();\n+    }\n+\n+    \/**\n+     * Barrier before synchronized block.\n+     *\/\n+    private static void race2(int iterations) throws InterruptedException {\n+        final int timeout = 1;\n+        var lock = new Object();\n+        var start = new Phaser(2);\n+\n+        var vthread = Thread.startVirtualThread(() -> {\n+            try {\n+                for (int i = 0; i < iterations; i++) {\n+                    start.arriveAndAwaitAdvance();\n+                    synchronized (lock) {\n+                        lock.wait(timeout);\n+                        lock.wait(timeout);\n+                    }\n+                }\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+\n+        ThreadFactory factory = ThreadLocalRandom.current().nextBoolean()\n+                    ? Thread.ofPlatform().factory() : Thread.ofVirtual().factory();\n+        var notifier = factory.newThread(() -> {\n+            for (int i = 0; i < iterations; i++) {\n+                start.arriveAndAwaitAdvance();\n+                synchronized (lock) {\n+                    lock.notify();\n+                }\n+            }\n+        });\n+        notifier.start();\n+\n+        vthread.join();\n+        notifier.join();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/NotifiedThenTimedOutWait.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"}]}