{"files":[{"patch":"@@ -2813,1 +2813,6 @@\n-        return resolveQualifiedMethod(new MethodResolutionContext(), pos, env, location, site, name, argtypes, typeargtypes);\n+        try {\n+            return resolveQualifiedMethod(new MethodResolutionContext(), pos, env, location, site, name, argtypes, typeargtypes);\n+        } catch (CompletionFailure cf) {\n+            chk.completionError(pos, cf);\n+            return methodNotFound.access(name, site.tsym);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8301580 8322159 8333107 8332230 8338678 8351260 8366196\n+ * @bug 8301580 8322159 8333107 8332230 8338678 8351260 8366196 8372336\n@@ -35,0 +35,2 @@\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MethodInvocationTree;\n@@ -40,0 +42,1 @@\n+import java.nio.file.Files;\n@@ -397,0 +400,98 @@\n+\n+    @Test \/\/JDK-8372336\n+    public void testCompletionFailureNoBreakInvocation() throws Exception {\n+        Path curPath = Path.of(\".\");\n+        Path lib = curPath.resolve(\"lib\");\n+        Path classes = lib.resolve(\"classes\");\n+        Files.createDirectories(classes);\n+        new JavacTask(tb)\n+            .outdir(classes)\n+            .sources(\"\"\"\n+                     package test;\n+                     public class Intermediate extends Base {}\n+                     \"\"\",\n+                     \"\"\"\n+                     package test;\n+                     public class Base {\n+                         public int get() {\n+                             return -1;\n+                         }\n+                     }\n+                     \"\"\")\n+            .run()\n+            .writeAll();\n+\n+        Files.delete(classes.resolve(\"test\").resolve(\"Base.class\"));\n+\n+        record TestCase(String code, String... expectedErrors) {}\n+        TestCase[] testCases = new TestCase[] {\n+            new TestCase(\"\"\"\n+                         package test;\n+                         public class Test {\n+                             private void test(Intermediate i) {\n+                                 int j = i != null ? i.get() : -1;\n+                             }\n+                         }\n+                         \"\"\",\n+                         \"Test.java:4:30: compiler.err.cant.access: test.Base, (compiler.misc.class.file.not.found: test.Base)\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                         package test;\n+                         public class Test {\n+                             private void test(Intermediate i) {\n+                                 i.get();\n+                             }\n+                         }\n+                         \"\"\",\n+                         \"Test.java:4:10: compiler.err.cant.access: test.Base, (compiler.misc.class.file.not.found: test.Base)\",\n+                         \"1 error\")\n+        };\n+\n+        for (TestCase tc : testCases) {\n+            List<String> actual = new JavacTask(tb)\n+                    .options(\"-XDrawDiagnostics\", \"-XDdev\")\n+                    .classpath(classes)\n+                    .sources(tc.code())\n+                    .outdir(curPath)\n+                    .callback(task -> {\n+                        task.addTaskListener(new TaskListener() {\n+                            @Override\n+                            public void finished(TaskEvent e) {\n+                                if (e.getKind() != TaskEvent.Kind.ANALYZE) {\n+                                    return ;\n+                                }\n+                                Trees trees = Trees.instance(task);\n+                                new TreePathScanner<Void, Void>() {\n+                                    @Override\n+                                    public Void visitMethodInvocation(MethodInvocationTree node, Void p) {\n+                                        if (!node.toString().contains(\"super\")) {\n+                                            verifyElement();\n+                                        }\n+                                        return super.visitMethodInvocation(node, p);\n+                                    }\n+                                    @Override\n+                                    public Void visitMemberReference(MemberReferenceTree node, Void p) {\n+                                        verifyElement();\n+                                        return super.visitMemberReference(node, p);\n+                                    }\n+                                    private void verifyElement() {\n+                                        Element el = trees.getElement(getCurrentPath());\n+                                        if (!el.getSimpleName().contentEquals(\"get\")) {\n+                                            error(\"Expected good Element, but got: \" + el);\n+                                        }\n+                                    }\n+                                }.scan(e.getCompilationUnit(), null);\n+                            }\n+                        });\n+                    })\n+                    .run(Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(OutputKind.DIRECT);\n+\n+            List<String> expected = List.of(tc.expectedErrors);\n+\n+            if (!Objects.equals(actual, expected)) {\n+                error(\"Expected: \" + expected + \", but got: \" + actual);\n+            }\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/recovery\/AttrRecovery.java","additions":102,"deletions":1,"binary":false,"changes":103,"status":"modified"}]}