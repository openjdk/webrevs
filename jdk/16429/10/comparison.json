{"files":[{"patch":"@@ -83,22 +83,0 @@\n-  \/\/ Visit all non-cast uses of the node, bypassing ConstraintCasts.\n-  \/\/ Pattern: this (-> ConstraintCast)* -> non_cast\n-  \/\/ In other words: find all non_cast nodes such that\n-  \/\/ non_cast->uncast() == this.\n-  template <typename Callback>\n-  static void visit_uncasted_uses(const Node* n, Callback callback) {\n-    ResourceMark rm;\n-    Unique_Node_List internals;\n-    internals.push((Node*)n); \/\/ start traversal\n-    for (uint j = 0; j < internals.size(); ++j) {\n-      Node* internal = internals.at(j); \/\/ for every internal\n-      for (DUIterator_Fast kmax, k = internal->fast_outs(kmax); k < kmax; k++) {\n-        Node* internal_use = internal->fast_out(k);\n-        if (internal_use->is_ConstraintCast()) {\n-          internals.push(internal_use); \/\/ traverse this cast also\n-        } else {\n-          callback(internal_use);\n-        }\n-      }\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1131,0 +1131,17 @@\n+  \/\/ Visit boundary uses of the node and apply a callback function for each.\n+  \/\/ Recursively traverse uses, stopping and applying the callback when\n+  \/\/ reaching a boundary node, defined by is_boundary.\n+  \/\/ Note: the function definition appears after the complete type definition\n+  \/\/ of Unique_Node_List.\n+  template <typename Callback, typename Check>\n+  void visit_uses(Callback callback, Check is_boundary);\n+\n+  \/\/ Visit all non-cast uses of the node, bypassing ConstraintCasts.\n+  \/\/ Pattern: this (-> ConstraintCast)* -> non_cast\n+  \/\/ In other words: find all non_cast nodes such that\n+  \/\/ non_cast->uncast() == this.\n+  template <typename Callback>\n+  void visit_uncasted_uses(Callback callback) {\n+     visit_uses(callback, [](Node* n){ return !n->is_ConstraintCast(); });\n+  }\n+\n@@ -1715,0 +1732,27 @@\n+\/\/ Definition must appear after complete type definition of Unique_Node_List\n+template <typename Callback, typename Check>\n+void Node::visit_uses(Callback callback, Check is_boundary) {\n+  ResourceMark rm;\n+  \/\/ Unique_Node_List guarantees no duplicates in the worklist. Note that we\n+  \/\/ never pop anything from the worklist, since that could result in applying\n+  \/\/ the callback for a use more than once (if it is at some point readded to\n+  \/\/ the worklist).\n+  Unique_Node_List worklist;\n+  \/\/ The initial worklist consists of the direct uses\n+  for (DUIterator_Fast kmax, k = fast_outs(kmax); k < kmax; k++) {\n+    worklist.push(fast_out(k));\n+  }\n+  for (uint j = 0; j < worklist.size(); ++j) {\n+    Node* use = worklist.at(j);\n+    if (is_boundary(use)) {\n+      \/\/ Apply callback on boundary nodes\n+      callback(use);\n+    }\n+    else {\n+      for (DUIterator_Fast kmax, k = use->fast_outs(kmax); k < kmax; k++) {\n+        worklist.push(use->fast_out(k));\n+      }\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1608,1 +1608,1 @@\n-      ConstraintCastNode::visit_uncasted_uses(use, push_the_uses_to_worklist);\n+      use->visit_uncasted_uses(push_the_uses_to_worklist);\n@@ -1834,1 +1834,1 @@\n-  assert(!failure, \"Missed optimization opportunity in PhaseCCP\");\n+  assert(!failure, \"PhaseCCP not at fixpoint: analysis result may be unsound.\");\n@@ -1878,1 +1878,1 @@\n-void PhaseCCP::push_more_uses(Unique_Node_List& worklist, Node* parent, const Node* use) const {\n+void PhaseCCP::push_more_uses(Unique_Node_List& worklist, Node* parent, Node* use) const {\n@@ -1977,1 +1977,2 @@\n-void PhaseCCP::push_and(Unique_Node_List& worklist, const Node* parent, const Node* use) const {\n+\/\/ Pattern: parent -> LShift (use) -> (ConstraintCast | ConvI2L)* -> ConstraintCast* -> And\n+void PhaseCCP::push_and(Unique_Node_List& worklist, const Node* parent, Node* use) const {\n@@ -1987,1 +1988,4 @@\n-    ConstraintCastNode::visit_uncasted_uses(use, push_and_uses_to_worklist);\n+    auto is_boundary = [](Node* n) {\n+      return !(n->is_ConstraintCast() || n->Opcode() == Op_ConvI2L);\n+    };\n+    use->visit_uses(push_and_uses_to_worklist, is_boundary);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -618,1 +618,1 @@\n-  void push_more_uses(Unique_Node_List& worklist, Node* parent, const Node* use) const;\n+  void push_more_uses(Unique_Node_List& worklist, Node* parent, Node* use) const;\n@@ -625,1 +625,1 @@\n-  void push_and(Unique_Node_List& worklist, const Node* parent, const Node* use) const;\n+  void push_and(Unique_Node_List& worklist, const Node* parent, Node* use) const;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8313672\n+ * @summary Test CCP notification for value update of AndL through LShiftI and\n+ *          ConvI2L.\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:RepeatCompilation=20 -XX:-TieredCompilation\n+ *                   -XX:+StressIGVN -XX:-CICompileOSR -Xcomp\n+ *                   -XX:CompileCommand=compileonly,compiler.ccp.TestShiftConvertAndNotification::test\n+ *                   compiler.ccp.TestShiftConvertAndNotification\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8313672\n+ * @summary Test CCP notification for value update of AndL through LShiftI and\n+ *          ConvI2L (reduced set of flags).\n+ * @run main\/othervm compiler.ccp.TestShiftConvertAndNotification\n+ *\n+ *\/\n+\n+package compiler.ccp;\n+\n+public class TestShiftConvertAndNotification {\n+  static long instanceCount;\n+  static void test() {\n+    int i, i1 = 7;\n+    for (i = 7; i < 45; i++) {\n+      instanceCount = i;\n+      instanceCount &= i1 * i << i * Math.max(instanceCount, instanceCount);\n+      switch (i % 2) {\n+      case 8:\n+        i1 = 0;\n+      }\n+    }\n+  }\n+  public static void main(String[] strArr) {\n+      for (int i = 0; i < 20_000; i++)\n+        test();\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ccp\/TestShiftConvertAndNotification.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"}]}