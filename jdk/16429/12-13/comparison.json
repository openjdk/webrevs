{"files":[{"patch":"@@ -1138,8 +1138,0 @@\n-  \/\/ Visit all non-cast uses of the node, bypassing ConstraintCasts. Pattern:\n-  \/\/ this (-> ConstraintCast)* -> non_cast. In other words: find all non_cast\n-  \/\/ nodes such that non_cast->uncast() == this.\n-  template <typename Callback>\n-  void visit_uncasted_uses(Callback callback) const {\n-     visit_uses(callback, [](Node* n){ return !n->is_ConstraintCast(); });\n-  }\n-\n@@ -1646,0 +1638,26 @@\n+\/\/ Definition must appear after complete type definition of Node_List\n+template <typename Callback, typename Check>\n+void Node::visit_uses(Callback callback, Check is_boundary) const {\n+  ResourceMark rm;\n+  VectorSet visited;\n+  Node_List worklist;\n+\n+  \/\/ The initial worklist consists of the direct uses\n+  for (DUIterator_Fast kmax, k = fast_outs(kmax); k < kmax; k++)\n+    worklist.push(fast_out(k));\n+\n+  while (worklist.size() > 0) {\n+    Node* use = worklist.pop();\n+    \/\/ Skip already visited nodes\n+    if (visited.test_set(use->_idx)) continue;\n+    \/\/ Apply callback on boundary nodes\n+    if (is_boundary(use)) callback(use);\n+    else {\n+      \/\/ Not a boundary node, continue search\n+      for (DUIterator_Fast kmax, k = use->fast_outs(kmax); k < kmax; k++)\n+        worklist.push(use->fast_out(k));\n+    }\n+  }\n+}\n+\n+\n@@ -1730,27 +1748,0 @@\n-\/\/ Definition must appear after complete type definition of Unique_Node_List\n-template <typename Callback, typename Check>\n-void Node::visit_uses(Callback callback, Check is_boundary) const {\n-  ResourceMark rm;\n-  \/\/ Unique_Node_List guarantees no duplicates in the worklist. Note that we\n-  \/\/ never pop anything from the worklist, since that could result in applying\n-  \/\/ the callback for a use more than once (if it is at some point readded to\n-  \/\/ the worklist).\n-  Unique_Node_List worklist;\n-  \/\/ The initial worklist consists of the direct uses\n-  for (DUIterator_Fast kmax, k = fast_outs(kmax); k < kmax; k++) {\n-    worklist.push(fast_out(k));\n-  }\n-  for (uint j = 0; j < worklist.size(); ++j) {\n-    Node* use = worklist.at(j);\n-    if (is_boundary(use)) {\n-      \/\/ Apply callback on boundary nodes\n-      callback(use);\n-    }\n-    else {\n-      for (DUIterator_Fast kmax, k = use->fast_outs(kmax); k < kmax; k++) {\n-        worklist.push(use->fast_out(k));\n-      }\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":26,"deletions":35,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -1608,1 +1608,3 @@\n-      use->visit_uncasted_uses(push_the_uses_to_worklist);\n+      auto is_boundary = [](Node* n){ return !n->is_ConstraintCast(); };\n+      use->visit_uses(push_the_uses_to_worklist, is_boundary);\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}