{"files":[{"patch":"@@ -1133,2 +1133,1 @@\n-  \/\/ reaching a boundary node, defined by is_boundary. Does NOT guarantee that\n-  \/\/ we visit boundary nodes only once.\n+  \/\/ reaching a boundary node, defined by is_boundary.\n@@ -1737,10 +1736,18 @@\n-  Unique_Node_List internals;\n-  internals.push(this); \/\/ start traversal\n-  for (uint j = 0; j < internals.size(); ++j) {\n-    Node* internal = internals.at(j); \/\/ for every internal\n-    for (DUIterator_Fast kmax, k = internal->fast_outs(kmax); k < kmax; k++) {\n-      Node* internal_use = internal->fast_out(k);\n-      if (is_boundary(internal_use)) {\n-        callback(internal_use);\n-      } else {\n-        internals.push(internal_use); \/\/ continue traversal\n+  \/\/ Unique_Node_List guarantees no duplicates in the worklist. Note that we\n+  \/\/ never pop anything from the worklist, since that could result in applying\n+  \/\/ the callback for a use more than once (if it is at some point readded to\n+  \/\/ the worklist).\n+  Unique_Node_List worklist;\n+  \/\/ The initial worklist consists of the direct uses\n+  for (DUIterator_Fast kmax, k = fast_outs(kmax); k < kmax; k++) {\n+    worklist.push(fast_out(k));\n+  }\n+  for (uint j = 0; j < worklist.size(); ++j) {\n+    Node* use = worklist.at(j);\n+    if (is_boundary(use)) {\n+      \/\/ Apply callback on boundary nodes\n+      callback(use);\n+    }\n+    else {\n+      for (DUIterator_Fast kmax, k = use->fast_outs(kmax); k < kmax; k++) {\n+        worklist.push(use->fast_out(k));\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"}]}