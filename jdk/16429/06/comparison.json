{"files":[{"patch":"@@ -83,22 +83,0 @@\n-  \/\/ Visit all non-cast uses of the node, bypassing ConstraintCasts.\n-  \/\/ Pattern: this (-> ConstraintCast)* -> non_cast\n-  \/\/ In other words: find all non_cast nodes such that\n-  \/\/ non_cast->uncast() == this.\n-  template <typename Callback>\n-  static void visit_uncasted_uses(const Node* n, Callback callback) {\n-    ResourceMark rm;\n-    Unique_Node_List internals;\n-    internals.push((Node*)n); \/\/ start traversal\n-    for (uint j = 0; j < internals.size(); ++j) {\n-      Node* internal = internals.at(j); \/\/ for every internal\n-      for (DUIterator_Fast kmax, k = internal->fast_outs(kmax); k < kmax; k++) {\n-        Node* internal_use = internal->fast_out(k);\n-        if (internal_use->is_ConstraintCast()) {\n-          internals.push(internal_use); \/\/ traverse this cast also\n-        } else {\n-          callback(internal_use);\n-        }\n-      }\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -172,0 +172,1 @@\n+class Unique_Node_List;\n@@ -1131,0 +1132,15 @@\n+  \/\/ Visit all non-cast uses of the node and apply callback, bypassing nodes\n+  \/\/ according to bypass. Note: definition appears after complete type\n+  \/\/ definition of Unique_Node_List\n+  template <typename Callback, typename Bypass>\n+  void visit_uses(Callback callback, Bypass bypass);\n+\n+  \/\/ Visit all non-cast uses of the node, bypassing ConstraintCasts.\n+  \/\/ Pattern: this (-> ConstraintCast)* -> non_cast\n+  \/\/ In other words: find all non_cast nodes such that\n+  \/\/ non_cast->uncast() == this.\n+  template <typename Callback>\n+  void visit_uncasted_uses(Callback callback) {\n+     visit_uses(callback, [](Node* n){ return n->is_ConstraintCast(); });\n+  }\n+\n@@ -1715,0 +1731,19 @@\n+\/\/ Definition must appear after complete type definition of Unique_Node_List\n+template <typename Callback, typename Bypass>\n+void Node::visit_uses(Callback callback, Bypass bypass) {\n+  ResourceMark rm;\n+  Unique_Node_List internals;\n+  internals.push(this); \/\/ start traversal\n+  for (uint j = 0; j < internals.size(); ++j) {\n+    Node* internal = internals.at(j); \/\/ for every internal\n+    for (DUIterator_Fast kmax, k = internal->fast_outs(kmax); k < kmax; k++) {\n+      Node* internal_use = internal->fast_out(k);\n+      if (bypass(internal_use)) {\n+        internals.push(internal_use); \/\/ traverse this also\n+      } else {\n+        callback(internal_use);\n+      }\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1608,1 +1608,1 @@\n-      ConstraintCastNode::visit_uncasted_uses(use, push_the_uses_to_worklist);\n+      use->visit_uncasted_uses(push_the_uses_to_worklist);\n@@ -1834,1 +1834,1 @@\n-  assert(!failure, \"Missed optimization opportunity in PhaseCCP\");\n+  assert(!failure, \"PhaseCCP not at fixpoint: analysis result may be unsound.\");\n@@ -1878,1 +1878,1 @@\n-void PhaseCCP::push_more_uses(Unique_Node_List& worklist, Node* parent, const Node* use) const {\n+void PhaseCCP::push_more_uses(Unique_Node_List& worklist, Node* parent, Node* use) const {\n@@ -1977,1 +1977,2 @@\n-void PhaseCCP::push_and(Unique_Node_List& worklist, const Node* parent, const Node* use) const {\n+\/\/ Pattern: parent -> LShift (use) -> (ConstraintCast | ConvI2L)* -> ConstraintCast* -> And\n+void PhaseCCP::push_and(Unique_Node_List& worklist, const Node* parent, Node* use) const {\n@@ -1987,1 +1988,4 @@\n-    ConstraintCastNode::visit_uncasted_uses(use, push_and_uses_to_worklist);\n+    auto bypass = [](Node* n) {\n+      return n->is_ConstraintCast() || n->Opcode() == Op_ConvI2L;\n+    };\n+    use->visit_uses(push_and_uses_to_worklist, bypass);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -618,1 +618,1 @@\n-  void push_more_uses(Unique_Node_List& worklist, Node* parent, const Node* use) const;\n+  void push_more_uses(Unique_Node_List& worklist, Node* parent, Node* use) const;\n@@ -625,1 +625,1 @@\n-  void push_and(Unique_Node_List& worklist, const Node* parent, const Node* use) const;\n+  void push_and(Unique_Node_List& worklist, const Node* parent, Node* use) const;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8313672\n+ * @summary Test CCP notification for value update of AndL through LShiftI and\n+ *          ConvI2L.\n+ * @run main\/othervm -XX:RepeatCompilation=20 -XX:-TieredCompilation\n+ *                   -XX:+StressIGVN -XX:-CICompileOSR -Xcomp\n+ *                   -XX:CompileCommand=compileonly,compiler.ccp.TestShiftConvertAndNotification::test\n+ *                   compiler.ccp.TestShiftConvertAndNotification\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8313672\n+ * @summary Test CCP notification for value update of AndL through LShiftI and\n+ *          ConvI2L (reduced set of flags).\n+ * @run main\/othervm compiler.ccp.TestShiftConvertAndNotification\n+ *\n+ *\/\n+\n+package compiler.ccp;\n+\n+public class TestShiftConvertAndNotification {\n+  static long instanceCount;\n+  static void test() {\n+    int i, i1 = 7;\n+    for (i = 7; i < 45; i++) {\n+      instanceCount = i;\n+      instanceCount &= i1 * i << i * Math.max(instanceCount, instanceCount);\n+      switch (i % 2) {\n+      case 8:\n+        i1 = 0;\n+      }\n+    }\n+  }\n+  public static void main(String[] strArr) {\n+      for (int i = 0; i < 20_000; i++)\n+        test();\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ccp\/TestShiftConvertAndNotification.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"}]}