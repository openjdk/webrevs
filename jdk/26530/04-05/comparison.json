{"files":[{"patch":"@@ -734,5 +734,4 @@\n-bool os::commit_memory_limit(size_t& limit) {\n-  \/\/ On POSIX systems, the amount of allocatable memory is limited by the\n-  \/\/ size of the virtual address space.\n-  size_t as_limit = reserve_memory_limit();\n-  bool as_is_limited = as_limit != SIZE_MAX;\n+size_t os::commit_memory_limit() {\n+  \/\/ On POSIX systems, the amount of memory that can be commmitted is limited\n+  \/\/ by the size of the reservable memory.\n+  size_t reserve_limit = reserve_memory_limit();\n@@ -741,6 +740,1 @@\n-  if (as_is_limited) {\n-    limit = as_limit;\n-    return true;\n-  }\n-\n-  return false;\n+  return reserve_limit;\n@@ -748,9 +742,5 @@\n-  \/\/ arbitrary virtual space limit for 32 bit Unices found by testing. If\n-  \/\/ getrlimit above returned a limit, bound it with this limit. Otherwise\n-  \/\/ directly use it.\n-  const size_t max_virtual_limit = 3800*M;\n-  if (as_is_limited) {\n-    as_limit = MIN2(as_limit, max_virtual_limit);\n-  } else {\n-    as_limit = max_virtual_limit;\n-  }\n+  \/\/ Arbitrary max reserve limit for 32 bit Unices found by testing.\n+  const size_t max_reserve_limit = 3800 * M;\n+\n+  \/\/ Bound the reserve limit with the arbitrary max.\n+  size_t actual_limit = MIN2(reserve_limit, max_reserve_limit);\n@@ -770,1 +760,1 @@\n-  size_t upper_limit = as_limit;\n+  size_t upper_limit = actual_limit;\n@@ -774,1 +764,1 @@\n-    limit = upper_limit;\n+    \/\/ The actual limit is allocatable, no need to do anything.\n@@ -778,1 +768,1 @@\n-    limit = min_allocation_size;\n+    actual_limit = min_allocation_size;\n@@ -791,1 +781,1 @@\n-    limit = lower_limit;\n+    actual_limit = lower_limit;\n@@ -794,1 +784,1 @@\n-  return true;\n+  return actual_limit;\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":15,"deletions":25,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -3299,1 +3299,1 @@\n-bool os::commit_memory_limit(size_t& limit) {\n+size_t os::commit_memory_limit() {\n@@ -3303,2 +3303,1 @@\n-  limit = (size_t)ms.ullAvailVirtual;\n-  return true;\n+  return (size_t)ms.ullAvailVirtual;\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1490,13 +1490,10 @@\n-  size_t max_allocatable;\n-  size_t result = limit;\n-  if (os::commit_memory_limit(max_allocatable)) {\n-    \/\/ The AggressiveHeap check is a temporary workaround to avoid calling\n-    \/\/ GCarguments::heap_virtual_to_physical_ratio() before a GC has been\n-    \/\/ selected. This works because AggressiveHeap implies UseParallelGC\n-    \/\/ where we know the ratio will be 1. Once the AggressiveHeap option is\n-    \/\/ removed, this can be cleaned up.\n-    size_t heap_virtual_to_physical_ratio = (AggressiveHeap ? 1 : GCConfig::arguments()->heap_virtual_to_physical_ratio());\n-    size_t fraction = MaxVirtMemFraction * heap_virtual_to_physical_ratio;\n-    result = MIN2(result, max_allocatable \/ fraction);\n-  }\n-  return result;\n+  \/\/ The AggressiveHeap check is a temporary workaround to avoid calling\n+  \/\/ GCarguments::heap_virtual_to_physical_ratio() before a GC has been\n+  \/\/ selected. This works because AggressiveHeap implies UseParallelGC\n+  \/\/ where we know the ratio will be 1. Once the AggressiveHeap option is\n+  \/\/ removed, this can be cleaned up.\n+  size_t heap_virtual_to_physical_ratio = (AggressiveHeap ? 1 : GCConfig::arguments()->heap_virtual_to_physical_ratio());\n+  size_t fraction = MaxVirtMemFraction * heap_virtual_to_physical_ratio;\n+  size_t max_allocatable = os::commit_memory_limit();\n+\n+  return MIN2(limit, max_allocatable \/ fraction);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -459,1 +459,1 @@\n-  static bool commit_memory_limit(size_t& limit);\n+  static size_t commit_memory_limit();\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}