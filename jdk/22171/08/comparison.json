{"files":[{"patch":"@@ -190,0 +190,10 @@\n+WB_ENTRY(jint, WB_TakeLockAndHangInSafepoint(JNIEnv* env, jobject wb))\n+  JavaThread* self = JavaThread::current();\n+  \/\/ VMStatistic_lock is used to minimize interference with VM locking\n+  MutexLocker mu(VMStatistic_lock);\n+  VM_HangInSafepoint force_safepoint_stuck_op;\n+  VMThread::execute(&force_safepoint_stuck_op);\n+  ShouldNotReachHere();\n+  return 0;\n+WB_END\n+\n@@ -2997,0 +3007,1 @@\n+  {CC\"lockAndStuckInSafepoint\", CC\"()V\", (void*)&WB_TakeLockAndHangInSafepoint},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -270,0 +270,10 @@\n+static const int MAX_NUM_MUTEX = 1204;\n+static Mutex* _internal_mutex_arr[MAX_NUM_MUTEX];\n+Mutex** Mutex::_mutex_array = _internal_mutex_arr;\n+int Mutex::_num_mutex = 0;\n+\n+void Mutex::add_mutex(Mutex* var) {\n+  assert(Mutex::_num_mutex < MAX_NUM_MUTEX, \"increase MAX_NUM_MUTEX\");\n+  Mutex::_mutex_array[_num_mutex++] = var;\n+}\n+\n@@ -526,0 +536,55 @@\n+\/\/ Print all mutexes\/monitors that are currently owned by a thread; called\n+\/\/ by fatal error handler.\n+void Mutex::print_owned_locks_on_error(outputStream* st) {\n+  st->print(\"VM Mutex\/Monitor currently owned by a thread: \");\n+  bool none = true;\n+  for (int i = 0; i < _num_mutex; i++) {\n+    \/\/ see if it has an owner\n+    if (_mutex_array[i]->owner() != nullptr) {\n+      if (none) {\n+        \/\/ print format used by Mutex::print_on_error()\n+        st->print_cr(\" ([mutex\/lock_event])\");\n+        none = false;\n+      }\n+      _mutex_array[i]->print_on_error(st);\n+      st->cr();\n+    }\n+  }\n+  if (none) st->print_cr(\"None\");\n+}\n+\n+void Mutex::print_lock_ranks(outputStream* st) {\n+  st->print_cr(\"VM Mutex\/Monitor ranks: \");\n+\n+#ifdef ASSERT\n+  \/\/ Be extra defensive and figure out the bounds on\n+  \/\/ ranks right here. This also saves a bit of time\n+  \/\/ in the #ranks*#mutexes loop below.\n+  int min_rank = INT_MAX;\n+  int max_rank = INT_MIN;\n+  for (int i = 0; i < _num_mutex; i++) {\n+    Mutex* m = _mutex_array[i];\n+    int r = (int) m->rank();\n+    if (min_rank > r) min_rank = r;\n+    if (max_rank < r) max_rank = r;\n+  }\n+\n+  \/\/ Print the listings rank by rank\n+  for (int r = min_rank; r <= max_rank; r++) {\n+    bool first = true;\n+    for (int i = 0; i < _num_mutex; i++) {\n+      Mutex* m = _mutex_array[i];\n+      if (r != (int) m->rank()) continue;\n+\n+      if (first) {\n+        st->cr();\n+        st->print_cr(\"Rank \\\"%s\\\":\", m->rank_name());\n+        first = false;\n+      }\n+      st->print_cr(\"  %s\", m->name());\n+    }\n+  }\n+#else\n+  st->print_cr(\"  Only known in debug builds.\");\n+#endif \/\/ ASSERT\n+}\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+ friend class VMStructs;\n@@ -106,0 +107,3 @@\n+  static Mutex** _mutex_array;\n+  static int _num_mutex;\n+\n@@ -134,0 +138,1 @@\n+  static void  add_mutex(Mutex* var);\n@@ -198,0 +203,5 @@\n+\n+  \/\/ Print all mutexes\/monitors that are currently owned by a thread; called\n+  \/\/ by fatal error handler.\n+  static void print_owned_locks_on_error(outputStream* st);\n+  static void print_lock_ranks(outputStream* st);\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -161,4 +161,0 @@\n-#define MAX_NUM_MUTEX 128\n-static Mutex* _mutex_array[MAX_NUM_MUTEX];\n-static int _num_mutex;\n-\n@@ -185,5 +181,0 @@\n-static void add_mutex(Mutex* var) {\n-  assert(_num_mutex < MAX_NUM_MUTEX, \"increase MAX_NUM_MUTEX\");\n-  _mutex_array[_num_mutex++] = var;\n-}\n-\n@@ -196,1 +187,1 @@\n-  add_mutex(name);                                                                              \\\n+  Mutex::add_mutex(name);                                                                       \\\n@@ -374,1 +365,1 @@\n-    print_lock_ranks(&ls);\n+    Mutex::print_lock_ranks(&ls);\n@@ -388,55 +379,0 @@\n-\/\/ Print all mutexes\/monitors that are currently owned by a thread; called\n-\/\/ by fatal error handler.\n-void print_owned_locks_on_error(outputStream* st) {\n-  st->print(\"VM Mutex\/Monitor currently owned by a thread: \");\n-  bool none = true;\n-  for (int i = 0; i < _num_mutex; i++) {\n-     \/\/ see if it has an owner\n-     if (_mutex_array[i]->owner() != nullptr) {\n-       if (none) {\n-          \/\/ print format used by Mutex::print_on_error()\n-          st->print_cr(\" ([mutex\/lock_event])\");\n-          none = false;\n-       }\n-       _mutex_array[i]->print_on_error(st);\n-       st->cr();\n-     }\n-  }\n-  if (none) st->print_cr(\"None\");\n-}\n-\n-void print_lock_ranks(outputStream* st) {\n-  st->print_cr(\"VM Mutex\/Monitor ranks: \");\n-\n-#ifdef ASSERT\n-  \/\/ Be extra defensive and figure out the bounds on\n-  \/\/ ranks right here. This also saves a bit of time\n-  \/\/ in the #ranks*#mutexes loop below.\n-  int min_rank = INT_MAX;\n-  int max_rank = INT_MIN;\n-  for (int i = 0; i < _num_mutex; i++) {\n-    Mutex* m = _mutex_array[i];\n-    int r = (int) m->rank();\n-    if (min_rank > r) min_rank = r;\n-    if (max_rank < r) max_rank = r;\n-  }\n-\n-  \/\/ Print the listings rank by rank\n-  for (int r = min_rank; r <= max_rank; r++) {\n-    bool first = true;\n-    for (int i = 0; i < _num_mutex; i++) {\n-      Mutex* m = _mutex_array[i];\n-      if (r != (int) m->rank()) continue;\n-\n-      if (first) {\n-        st->cr();\n-        st->print_cr(\"Rank \\\"%s\\\":\", m->rank_name());\n-        first = false;\n-      }\n-      st->print_cr(\"  %s\", m->name());\n-    }\n-  }\n-#else\n-  st->print_cr(\"  Only known in debug builds.\");\n-#endif \/\/ ASSERT\n-}\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":66,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -174,5 +174,0 @@\n-\/\/ Print all mutexes\/monitors that are currently owned by a thread; called\n-\/\/ by fatal error handler.\n-void print_owned_locks_on_error(outputStream* st);\n-void print_lock_ranks(outputStream* st);\n-\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -63,0 +63,12 @@\n+\/\/ used by whitebox API to emulate VM issues\n+\/\/ when VM can't operate and doesn't respond to jcmd\n+class VM_HangInSafepoint: public VM_Operation {\n+public:\n+  VMOp_Type type() const { return VMOp_ForceSafepoint; }\n+  void doit() {\n+    while(true) {\n+      os::naked_short_sleep(10);\n+    }\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -662,1 +662,0 @@\n-  nonstatic_field(JavaThread,                  _osthread,                                     OSThread*)                             \\\n@@ -670,0 +669,1 @@\n+  nonstatic_field(Thread,                      _osthread,                                     OSThread*)                             \\\n@@ -1025,1 +1025,5 @@\n-  nonstatic_field(UpcallStub::FrameData,       jfa,                                           JavaFrameAnchor)\n+  nonstatic_field(UpcallStub::FrameData,       jfa,                                           JavaFrameAnchor)                       \\\n+  nonstatic_field(Mutex,                       _name,                                         const char*)                           \\\n+  static_field(Mutex,                          _mutex_array,                                  Mutex**)                               \\\n+  static_field(Mutex,                          _num_mutex,                                    int)                                   \\\n+  volatile_nonstatic_field(Mutex,              _owner,                                        Thread*)\n@@ -1940,0 +1944,1 @@\n+  declare_toplevel_type(Mutex)                                            \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1226,1 +1226,1 @@\n-    print_owned_locks_on_error(st);\n+    Mutex::print_owned_locks_on_error(st);\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.runtime;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.types.AddressField;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+import sun.jvm.hotspot.types.WrongTypeException;\n+import sun.jvm.hotspot.utilities.*;\n+\n+public class Mutex extends VMObject {\n+  private static long          nameFieldOffset;\n+  private static long          ownerFieldOffset;\n+\n+  private static AddressField  mutex_array;\n+  private static int           maxNum;\n+\n+  private static final long addrSize = VM.getVM().getAddressSize();\n+\n+  static {\n+    VM.registerVMInitializedObserver(new Observer() {\n+        public void update(Observable o, Object data) {\n+          initialize(VM.getVM().getTypeDataBase());\n+        }\n+      });\n+  }\n+\n+  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n+    Type type = db.lookupType(\"Mutex\");\n+\n+    sun.jvm.hotspot.types.Field nameField = type.getField(\"_name\");\n+    nameFieldOffset = nameField.getOffset();\n+    sun.jvm.hotspot.types.Field ownerField = type.getField(\"_owner\");\n+    ownerFieldOffset = ownerField.getOffset();\n+\n+    mutex_array = type.getAddressField(\"_mutex_array\");\n+    maxNum = type.getCIntegerField(\"_num_mutex\").getJInt();\n+  }\n+\n+  public Mutex(Address addr) {\n+    super(addr);\n+  }\n+\n+  public String name() { return CStringUtilities.getString(addr.getAddressAt(nameFieldOffset)); }\n+\n+  public Address owner() { return addr.getAddressAt(ownerFieldOffset); }\n+\n+  public static Address at(int i) { return mutex_array.getValue().getAddressAt(i * addrSize); }\n+\n+  public static int maxNum() { return maxNum; }\n+\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Mutex.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+  private static AddressField osThreadField;\n@@ -56,0 +57,2 @@\n+    osThreadField = typeThread.getAddressField(\"_osthread\");\n+\n@@ -126,0 +129,4 @@\n+  public OSThread osThread() {\n+    return new OSThread(osThreadField.getValue(addr));\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Thread.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.runtime;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.memory.SystemDictionary;\n+import sun.jvm.hotspot.oops.DefaultHeapVisitor;\n+import sun.jvm.hotspot.oops.Klass;\n+import sun.jvm.hotspot.oops.ObjectHeap;\n+import sun.jvm.hotspot.oops.Oop;\n+import sun.jvm.hotspot.oops.OopUtilities;\n+\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class VMLocksPrinter {\n+    private PrintStream tty;\n+    private Threads threads = VM.getVM().getThreads();\n+\n+    public VMLocksPrinter(PrintStream tty) {\n+        this.tty = tty;\n+    }\n+\n+    private String ownerThreadName(Address addr) {\n+        try {\n+            JavaThread thread = VM.getVM().getThreads().createJavaThreadWrapper(addr);\n+            return thread.getThreadName();\n+        } catch (Exception e) {\n+            return \"Unknown thread\";\n+        }\n+    }\n+\n+    public void printVMLocks() {\n+         int maxNum = Mutex.maxNum();\n+         for (int i = 0; i < maxNum; i++) {\n+         Mutex mutex = new Mutex(Mutex.at(i));\n+            if (mutex.owner() != null) {\n+                sun.jvm.hotspot.runtime.Thread t = new sun.jvm.hotspot.runtime.Thread(mutex.owner());\n+                int nativeThreadId = t.osThread().threadId();\n+                tty.println(\"Internal VM Mutex \" + mutex.name() + \" is owned by \" + ownerThreadName(mutex.owner())\n+                        + \", nid=\" + nativeThreadId + \", address=\" + mutex.owner());\n+               }\n+         }\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VMLocksPrinter.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -84,0 +84,7 @@\n+         try {\n+             VMLocksPrinter vmLocksPrinter = new VMLocksPrinter(out);\n+             vmLocksPrinter.printVMLocks();\n+         } catch (Exception e) {\n+             out.println(\"can't print VM locks information: \" + e);\n+         }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/PStack.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-                \"field JavaThread _osthread OSThread*\",\n+                \"field Thread _osthread OSThread*\",\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbField.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-                \"field JavaThread _osthread OSThread*\",\n+                \"field Thread _osthread OSThread*\",\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbVmStructsDump.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.lib.apps.LingeredApp;\n+\n+public class LingeredAppWithLockInVM extends LingeredApp {\n+\n+    private static class LockerThread implements Runnable {\n+        public void run() {\n+            while (!isReady()) {\n+                try {\n+                    Thread.sleep(100);\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+            WhiteBox wb = WhiteBox.getWhiteBox();\n+            wb.lockAndStuckInSafepoint();\n+        }\n+    }\n+\n+\n+    public static void main(String args[]) {\n+        if (args.length != 1) {\n+            System.err.println(\"Lock file name is not specified\");\n+            System.exit(7);\n+        }\n+\n+        Thread t = new Thread(new LockerThread());\n+        t.setName(\"LockerThread\");\n+        t.start();\n+\n+        LingeredApp.main(args);\n+    }\n+ }\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/LingeredAppWithLockInVM.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.SA.SATestUtils;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jtreg.SkippedException;\n+\n+\/**\n+ * @test\n+ * @summary Test verifies that jstack --mixed prints information about VM locks\n+ * @requires vm.hasSA\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver TestJhsdbJstackPrintVMLocks\n+ *\/\n+\n+public class TestJhsdbJstackPrintVMLocks {\n+\n+    final static int MAX_ATTEMPTS = 3;\n+    public static void main(String[] args) throws Exception {\n+        SATestUtils.skipIfCannotAttach(); \/\/ throws SkippedException if attach not expected to work.\n+\n+        LingeredApp theApp = null;\n+        try {\n+            theApp = new LingeredAppWithLockInVM();\n+            LingeredApp.startApp(theApp,\n+                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                    \"-XX:+WhiteBoxAPI\",\n+                    \"-Xbootclasspath\/a:.\");\n+\n+            System.out.println(\"Started LingeredApp with pid \" + theApp.getPid());\n+            theApp.waitAppReadyOrCrashed();\n+\n+            for (int attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {\n+                JDKToolLauncher launcher = JDKToolLauncher\n+                        .createUsingTestJDK(\"jhsdb\");\n+                launcher.addToolArg(\"jstack\");\n+                launcher.addToolArg(\"--mixed\");\n+                launcher.addToolArg(\"--pid\");\n+                launcher.addToolArg(Long.toString(theApp.getPid()));\n+\n+                ProcessBuilder pb = SATestUtils.createProcessBuilder(launcher);\n+                Process jhsdb = pb.start();\n+                OutputAnalyzer out = new OutputAnalyzer(jhsdb);\n+\n+                jhsdb.waitFor();\n+\n+                System.out.println(out.getStdout());\n+                System.err.println(out.getStderr());\n+\n+                if (out.contains(\"Mutex VMStatistic_lock is owned by LockerThread\")) {\n+                    System.out.println(\"Test PASSED\");\n+                    return;\n+                }\n+                Thread.sleep(2000);\n+            }\n+            throw new RuntimeException(\"Not able to find lock\");\n+        } finally {\n+            theApp.getProcess().destroyForcibly();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackPrintVMLocks.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -592,0 +592,6 @@\n+    private static volatile boolean isReady = false;\n+\n+    protected static boolean isReady() {\n+        return isReady;\n+    }\n+\n@@ -630,0 +636,1 @@\n+                    isReady = true;\n","filename":"test\/lib\/jdk\/test\/lib\/apps\/LingeredApp.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -102,0 +102,2 @@\n+  public native void lockAndStuckInSafepoint();\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}