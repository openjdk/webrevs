{"files":[{"patch":"@@ -231,1 +231,3 @@\n-                        Set<Symbol> filteredPermitted = new HashSet<>(permitted);\n+\n+                        \/\/the set of pending permitted subtypes needed to cover clazz:\n+                        Set<Symbol> pendingPermitted = new HashSet<>(permitted);\n@@ -235,1 +237,2 @@\n-                                Set<Symbol> currentSubTypes;\n+                                \/\/remove all types from pendingPermitted that we can\n+                                \/\/cover using bpOther:\n@@ -237,9 +240,3 @@\n-                                if (bpOther.type.tsym.isAbstract()) {\n-                                    currentSubTypes =\n-                                            permitted.stream()\n-                                                     .filter(perm -> types.isSubtype(types.erasure(perm.type),\n-                                                                                     types.erasure(bpOther.type)))\n-                                                     .collect(Collectors.toSet());\n-                                } else {\n-                                    currentSubTypes = Set.of();\n-                                }\n+                                \/\/all types that are permitted subtypes of bpOther's type:\n+                                pendingPermitted.removeIf(pending -> types.isSubtype(types.erasure(pending.type),\n+                                                                                     types.erasure(bpOther.type)));\n@@ -247,2 +244,11 @@\n-                                PERMITTED: for (Iterator<Symbol> it = filteredPermitted.iterator(); it.hasNext();) {\n-                                    Symbol perm = it.next();\n+                                if (bpOther.type.tsym.isAbstract()) {\n+                                    \/\/all types that are in a diamond hierarchy with bpOther's type\n+                                    \/\/i.e. there's a common subtype of the given type and bpOther's type:\n+                                    Predicate<Symbol> check =\n+                                            pending -> permitted.stream()\n+                                                                .filter(perm -> types.isSubtype(types.erasure(perm.type),\n+                                                                                                types.erasure(bpOther.type)))\n+                                                                .filter(perm -> types.isSubtype(types.erasure(perm.type),\n+                                                                                                types.erasure(pending.type)))\n+                                                                .findAny()\n+                                                                .isPresent();\n@@ -250,11 +256,1 @@\n-                                    for (Symbol currentPermitted : currentSubTypes) {\n-                                        if (types.isSubtype(types.erasure(currentPermitted.type),\n-                                                            types.erasure(perm.type))) {\n-                                            it.remove();\n-                                            continue PERMITTED;\n-                                        }\n-                                    }\n-                                    if (types.isSubtype(types.erasure(perm.type),\n-                                                        types.erasure(bpOther.type))) {\n-                                        it.remove();\n-                                    }\n+                                    pendingPermitted.removeIf(check);\n@@ -265,1 +261,1 @@\n-                        if (filteredPermitted.isEmpty()) {\n+                        if (pendingPermitted.isEmpty()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ExhaustivenessComputer.java","additions":21,"deletions":25,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2211,0 +2211,28 @@\n+    @Test \/\/JDK-8366968\n+    public void testNonSealedDiamond2(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               class Demo {\n+\n+                   sealed interface Base permits Special, Value {}\n+\n+                   non-sealed interface Value extends Base {}\n+\n+                   non-sealed interface Special extends Base {}\n+\n+                   interface SpecialValue extends Value, Special {}\n+\n+                   static int demo(final Base base) {\n+                       return switch (base) {\n+                           case Value value -> 0;\n+                       };\n+\n+                   }\n+\n+               }\n+               \"\"\",\n+               \"Demo.java:12:16: compiler.err.not.exhaustive\",\n+               \"1 error\");\n+    }\n+\n@@ -2236,0 +2264,50 @@\n+    @Test \/\/JDK-8366968\n+    public void testNonSealedDiamondGeneric(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               class Demo {\n+                   class SomeType {}\n+                   sealed interface Base<T extends SomeType> permits Special, Value {}\n+                   non-sealed interface Value<T extends SomeType> extends Base<T> {}\n+                   sealed interface Special<T extends SomeType> extends Base<T> permits SpecialValue {}\n+                   non-sealed interface SpecialValue<T extends SomeType> extends Value<T>, Special<T> {}\n+\n+                   static <T extends SomeType> int demo(final Base<T> base) {\n+                       return switch (base) {\n+                            case Value<T> value -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test \/\/JDK-8366968\n+    public void testNonSealedDiamondMultiple(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               class Demo {\n+\n+                   sealed interface Base permits Special, Value {}\n+\n+                   non-sealed interface Value extends Base {}\n+\n+                   sealed interface Special extends Base permits SpecialValue, Special2 {}\n+\n+                   non-sealed interface SpecialValue extends Value, Special {}\n+                   non-sealed interface Special2 extends Special {}\n+\n+                   static int demo(final Base base) {\n+                       return switch (base) {\n+                           case Value value -> 0;\n+                       };\n+\n+                   }\n+\n+               }\n+               \"\"\",\n+               \"Demo.java:13:16: compiler.err.not.exhaustive\",\n+               \"1 error\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"modified"}]}