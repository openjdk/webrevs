{"files":[{"patch":"@@ -78,1 +78,1 @@\n-    private static final boolean DISABLE_JAR_CHECKING;\n+    private static final boolean JAR_CHECKING_ENABLED;\n@@ -87,1 +87,3 @@\n-        DISABLE_JAR_CHECKING = p != null ? p.equals(\"true\") || p.isEmpty() : false;\n+        \/\/ JAR check is disabled by default and will be enabled only if the \"disable JAR check\"\n+        \/\/ system property has been set to \"false\".\n+        JAR_CHECKING_ENABLED = p != null && p.equals(\"false\");\n@@ -655,2 +657,4 @@\n-        \/* Throws if the given jar file is does not start with the correct LOC *\/\n-        @SuppressWarnings(\"removal\")\n+        \/*\n+         * Throws an IOException if the LOC file Header Signature (0x04034b50),\n+         * is not found starting at byte 0 of the given jar.\n+         *\/\n@@ -658,2 +662,4 @@\n-            if (System.getSecurityManager() != null && !DISABLE_JAR_CHECKING\n-                && !zipAccess.startsWithLocHeader(jar)) {\n+            if (!JAR_CHECKING_ENABLED) {\n+                return jar;\n+            }\n+            if (!zipAccess.startsWithLocHeader(jar)) {\n@@ -668,1 +674,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.jar.Manifest;\n+\n+import jdk.internal.loader.URLClassPath;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+\/*\n+ * @test\n+ * @bug 8341551\n+ * @summary verify the behaviour of URLClassPath in the presence\/absence of\n+ *          sun.misc.URLClassPath.disableJarChecking system property\n+ *\n+ * @modules java.base\/jdk.internal.loader\n+ *\n+ * @comment the following run is expected to run with jar checking enabled\n+ * @run junit\/othervm -Dsun.misc.URLClassPath.disableJarChecking=false JarCheckTest\n+ *\n+ * @comment the following runs are expected to run with jar checking disabled\n+ * @run junit JarCheckTest\n+ * @run junit\/othervm -Dsun.misc.URLClassPath.disableJarChecking= JarCheckTest\n+ * @run junit\/othervm -Dsun.misc.URLClassPath.disableJarChecking JarCheckTest\n+ * @run junit\/othervm -Dsun.misc.URLClassPath.disableJarChecking=true JarCheckTest\n+ * @run junit\/othervm -Dsun.misc.URLClassPath.disableJarChecking=FALSE JarCheckTest\n+ * @run junit\/othervm -Dsun.misc.URLClassPath.disableJarChecking=foo JarCheckTest\n+ *\/\n+public class JarCheckTest {\n+\n+    private static final Path SCRATCH_DIR = Path.of(\".\").normalize();\n+    private static final String SYS_PROP = \"sun.misc.URLClassPath.disableJarChecking\";\n+    private static final String RESOURCE_IN_NORMAL_JAR = \"foo.txt\";\n+    private static final String RESOURCE_IN_NOT_JUST_A_JAR = \"bar.txt\";\n+\n+\n+    private static final boolean jarCheckEnabled = \"false\".equals(System.getProperty(SYS_PROP));\n+    private static Path normalJar;\n+    private static Path notJustAJar; \/\/ JAR file with additional prefixed bytes\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        final Path tmpDir = Files.createTempDirectory(SCRATCH_DIR, \"8341551\");\n+        \/\/ create a normal JAR file\n+        normalJar = tmpDir.resolve(\"normal.jar\");\n+        createJar(normalJar, RESOURCE_IN_NORMAL_JAR, false);\n+\n+        \/\/ now create another JAR file and have its content prefixed with arbitrary bytes\n+        notJustAJar = tmpDir.resolve(\"notjustajar.jar\");\n+        createJar(notJustAJar, RESOURCE_IN_NOT_JUST_A_JAR, true);\n+    }\n+\n+    private static void createJar(final Path targetJarFile, final String entryName,\n+                                  final boolean prefixArbitraryBytes)\n+            throws IOException {\n+\n+        Files.createFile(targetJarFile);\n+        if (prefixArbitraryBytes) {\n+            final byte[] arbitraryBytes = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06};\n+            Files.write(targetJarFile, arbitraryBytes);\n+        }\n+        final Manifest manifest = new Manifest();\n+        manifest.getMainAttributes().putValue(\"Manifest-Version\", \"1.0\");\n+        final OpenOption openOption = prefixArbitraryBytes\n+                ? StandardOpenOption.APPEND\n+                : StandardOpenOption.WRITE;\n+        try (OutputStream fos = Files.newOutputStream(targetJarFile, openOption);\n+             JarOutputStream jos = new JarOutputStream(fos, manifest)) {\n+\n+            final JarEntry jarEntry = new JarEntry(entryName);\n+            jos.putNextEntry(jarEntry);\n+            jos.write(\"hello\".getBytes(US_ASCII));\n+            jos.closeEntry();\n+        }\n+    }\n+\n+    \/*\n+     * Verifies that the URLClassPath always locates a resource from a normal JAR file\n+     * in the classpath and only conditionally locates a resource from a byte prefixed\n+     * JAR file in the classpath.\n+     *\/\n+    @Test\n+    public void testLocateResource() throws Exception {\n+        System.out.println(\"JAR check enabled=\" + jarCheckEnabled);\n+        final URL[] classpath = new URL[]{\n+                new URI(\"jar:file:\" + normalJar.toString() + \"!\/\").toURL(),\n+                new URI(\"jar:file:\" + notJustAJar.toString() + \"!\/\").toURL()\n+        };\n+        final URLClassPath urlc = new URLClassPath(classpath);\n+        try {\n+            System.out.println(urlc + \" will use classpath: \" + Arrays.toString(classpath));\n+            \/\/ always expected to be found\n+            assertNotNull(urlc.findResource(RESOURCE_IN_NORMAL_JAR),\n+                    \"missing resource \" + RESOURCE_IN_NORMAL_JAR);\n+            \/\/ will be found only if jar check is disabled\n+            final URL resource = urlc.findResource(RESOURCE_IN_NOT_JUST_A_JAR);\n+            if (jarCheckEnabled) {\n+                assertNull(resource, \"unexpectedly found \" + RESOURCE_IN_NOT_JUST_A_JAR\n+                        + \" at \" + resource);\n+            } else {\n+                assertNotNull(resource, \"missing resource \" + RESOURCE_IN_NOT_JUST_A_JAR);\n+            }\n+        } finally {\n+            urlc.closeLoaders();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/loader\/URLClassPath\/JarCheckTest.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"}]}