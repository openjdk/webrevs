{"files":[{"patch":"@@ -208,0 +208,1 @@\n+        boolean stopping = false;\n@@ -212,10 +213,2 @@\n-            } else if (stopped) {\n-                conn.close();\n-                return;\n-            }\n-            if (MAX_POOL_SIZE > 0 && expiryList.size() >= MAX_POOL_SIZE) {\n-                toClose = expiryList.removeOldest();\n-                if (toClose != null) removeFromPool(toClose);\n-            }\n-            if (conn instanceof PlainHttpConnection) {\n-                putConnection(conn, plainPool);\n+            } else if (stopping = stopped) {\n+                toClose = conn;\n@@ -223,2 +216,11 @@\n-                assert conn.isSecure();\n-                putConnection(conn, sslPool);\n+                if (MAX_POOL_SIZE > 0 && expiryList.size() >= MAX_POOL_SIZE) {\n+                    toClose = expiryList.removeOldest();\n+                    if (toClose != null) removeFromPool(toClose);\n+                }\n+                if (conn instanceof PlainHttpConnection) {\n+                    putConnection(conn, plainPool);\n+                } else {\n+                    assert conn.isSecure();\n+                    putConnection(conn, sslPool);\n+                }\n+                expiryList.add(conn, now, keepAlive);\n@@ -226,1 +228,0 @@\n-            expiryList.add(conn, now, keepAlive);\n@@ -232,2 +233,7 @@\n-                debug.log(\"Maximum pool size reached: removing oldest connection %s\",\n-                          toClose.dbgString());\n+                if (stopping) {\n+                    debug.log(\"Stopping: close connection %s\",\n+                            toClose.dbgString());\n+                } else {\n+                    debug.log(\"Maximum pool size reached: removing oldest connection %s\",\n+                            toClose.dbgString());\n+                }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ConnectionPool.java","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1336,0 +1336,7 @@\n+            \/\/ first stop the client to avoid seeing exceptions\n+            \/\/ about \"selector manager closed\"\n+            Log.logTrace(\"{0}: stopping\", owner.dbgTag);\n+            try {\n+                owner.stop();\n+            } catch (Throwable ignored) {\n+            }\n@@ -1348,0 +1355,1 @@\n+                \/\/ cleanup anything that might have been left behind\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -314,9 +314,9 @@\n-            if (Log.channel()) {\n-                Log.logChannel(\"Closing channel: \" + chan);\n-            }\n-            try {\n-                tube.signalClosed(errorRef.get());\n-                chan.close();\n-            } finally {\n-                client().connectionClosed(this);\n-            }\n+        } finally {\n+            stateLock.unlock();\n+        }\n+        if (Log.channel()) {\n+            Log.logChannel(\"Closing channel: \" + chan);\n+        }\n+        try {\n+            tube.signalClosed(errorRef.get());\n+            chan.close();\n@@ -327,1 +327,1 @@\n-            stateLock.unlock();\n+            client().connectionClosed(this);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainHttpConnection.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,382 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import javax.net.ssl.SSLContext;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n+import jdk.test.lib.net.SimpleSSLContext;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Assertions;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+\n+\/*\n+ * @test id=default\n+ * @bug 8372198\n+ * @requires os.family != \"windows\"\n+ * @summary Attempt to check that no deadlock occurs when\n+ *          connections are closed by the ConnectionPool.\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run junit\/othervm\n+ *              -Djdk.httpclient.HttpClient.log=errors\n+ *              -Djdk.httpclient.connectionPoolSize=1\n+ *              ${test.main.class}\n+ *\/\n+\/*\n+ * @test id=windows\n+ * @bug 8372198\n+ * @requires os.family == \"windows\"\n+ * @summary Attempt to check that no deadlock occurs when\n+ *          connections are closed by the ConnectionPool.\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @comment A special jtreg id for windows allows for experimentation\n+ *          with different configuration - for instance, specifying\n+ *          -Djdk.internal.httpclient.tcp.selector.useVirtualThreads=<always|never>\n+ *          on the run command line, or specifying a different request count\n+ *          with -DrequestCount=<integer>.\n+ *          On windows, it seems important to set the backlog for the HTTP\/1.1\n+ *          server to at least the number of concurrent request. This is done\n+ *          in the beforeTest() method.\n+ *          If the test fails waiting for avalaible permits, due to system limitations,\n+ *          even with the backlog correctly configure, adding a margin to the backlog\n+ *          or reducing the requestCount could be envisaged.\n+ * @run junit\/othervm\n+ *              -Djdk.httpclient.HttpClient.log=errors\n+ *              -Djdk.httpclient.connectionPoolSize=1\n+ *              ${test.main.class}\n+ *\/\n+\n+\/\/ -Djava.security.debug=all\n+class PlainConnectionLockTest implements HttpServerAdapters {\n+\n+    private SSLContext sslContext;\n+    private HttpTestServer http1Server;\n+    private HttpTestServer https1Server;\n+    private String http1URI;\n+    private String https1URI;\n+    private ExecutorService serverExecutor;\n+    private Semaphore responseSemaphore;\n+    private Semaphore requestSemaphore;\n+    private boolean successfulCompletion;\n+    private static final int MANY = Integer.getInteger(\"requestCount\", 100);\n+\n+    static {\n+        HttpServerAdapters.enableServerLogging();\n+    }\n+\n+    private boolean blockResponse(Semaphore request, Semaphore response) {\n+        try {\n+            request.release();\n+            response.acquire();\n+            return true;\n+        } catch (InterruptedException x) {\n+            return false;\n+        }\n+    }\n+\n+\n+    @BeforeEach\n+    synchronized void beforeTest() throws Exception {\n+        requestSemaphore = new Semaphore(0);\n+        responseSemaphore = new Semaphore(0);\n+        successfulCompletion = false;\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null) {\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+        }\n+        serverExecutor = Executors.newThreadPerTaskExecutor(\n+                Thread.ofVirtual().name(\"Http1Server\", 0).factory());\n+\n+        \/\/ On windows, sending 100 concurrent requests may\n+        \/\/ fail is the server's connection backlog is less than 100.\n+        \/\/ The default backlog is 50. Just make sure the backlog is\n+        \/\/ big enough.\n+        int backlog = MANY > 50 ? MANY : 50;\n+\n+        \/\/ create a https server for HTTP\/1.1\n+        var loopback = InetAddress.getLoopbackAddress();\n+        var wrappedHttps1Server = HttpsServer.create(new InetSocketAddress(loopback, 0), backlog);\n+        wrappedHttps1Server.setHttpsConfigurator(new TestServerConfigurator(loopback, sslContext));\n+        https1Server = HttpTestServer.of(wrappedHttps1Server, serverExecutor);\n+        https1Server.addHandler((exchange) -> {\n+            if (blockResponse(requestSemaphore, responseSemaphore)) {\n+                exchange.sendResponseHeaders(200, 0);\n+            } else {\n+                exchange.sendResponseHeaders(500, 0);\n+            }\n+        }, \"\/PlainConnectionLockTest\/\");\n+        https1Server.start();\n+        System.out.println(\"HTTPS Server started at \" + https1Server.getAddress());\n+        https1URI = \"https:\/\/\" + https1Server.serverAuthority() + \"\/PlainConnectionLockTest\/https1\";\n+\n+        \/\/ create a plain http server for HTTP\/1.1\n+        var wrappedHttp1Server = HttpServer.create(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), backlog);\n+        http1Server = HttpTestServer.of(wrappedHttp1Server, serverExecutor);\n+        http1Server.addHandler((exchange) -> {\n+            if (blockResponse(requestSemaphore, responseSemaphore)) {\n+                exchange.sendResponseHeaders(200, 0);\n+            } else {\n+                exchange.sendResponseHeaders(500, 0);\n+            }\n+        }, \"\/PlainConnectionLockTest\/\");\n+        http1Server.start();\n+        System.out.println(\"HTTP Server started at \" + http1Server.getAddress());\n+        http1URI = \"http:\/\/\" + http1Server.serverAuthority() + \"\/PlainConnectionLockTest\/http1\";\n+    }\n+\n+    @AfterEach\n+    synchronized void afterTest() throws Exception {\n+        if (http1Server != null) {\n+            System.out.println(\"Stopping HTTP server \" + http1Server.getAddress());\n+            http1Server.stop();\n+        }\n+        if (https1Server != null) {\n+            System.out.println(\"Stopping HTTPS server \" + https1Server.getAddress());\n+            https1Server.stop();\n+        }\n+        if (serverExecutor != null) {\n+            System.out.println(\"Closing server executor\");\n+            if (successfulCompletion) {\n+                serverExecutor.close();\n+            } else {\n+                \/\/ server handlers may be wedged.\n+                serverExecutor.shutdownNow();\n+            }\n+        }\n+        requestSemaphore = null;\n+        responseSemaphore = null;\n+        serverExecutor = null;\n+        http1Server = null;\n+        https1Server = null;\n+        http1URI = null;\n+        https1URI = null;\n+        System.out.println(\"done\\n\");\n+    }\n+\n+    @Test\n+    void sendManyHttpRequestsNoShutdown() throws Exception {\n+        try {\n+            sendManyRequests(http1URI, MANY, false);\n+        } catch (Throwable t) {\n+            t.printStackTrace(System.out);\n+            throw t;\n+        }\n+    }\n+\n+    @Test\n+    void sendManyHttpRequestsShutdownNow() throws Exception {\n+        try {\n+            sendManyRequests(http1URI, MANY, true);\n+        } catch (Throwable t) {\n+            t.printStackTrace(System.out);\n+            throw t;\n+        }\n+    }\n+\n+    @Test\n+    void sendManyHttpsRequestsNoShutdown() throws Exception {\n+        try {\n+            sendManyRequests(https1URI, MANY, false);\n+        } catch (Throwable t) {\n+            t.printStackTrace(System.out);\n+            throw t;\n+        }\n+    }\n+\n+    @Test\n+    void sendManyHttpsRequestsShutdownNow() throws Exception {\n+        try {\n+            sendManyRequests(https1URI, MANY, true);\n+        } catch (Throwable t) {\n+            t.printStackTrace(System.out);\n+            throw t;\n+        }\n+    }\n+\n+    private static void throwCause(CompletionException x) throws Exception {\n+        var cause = x.getCause();\n+        if (cause instanceof Exception ex) throw ex;\n+        if (cause instanceof Error err) throw err;\n+        throw x;\n+    }\n+\n+    static final long start = System.nanoTime();\n+    public static String now() {\n+        long now = System.nanoTime() - start;\n+        long secs = now \/ 1000_000_000;\n+        long mill = (now % 1000_000_000) \/ 1000_000;\n+        long nan = now % 1000_000;\n+        return String.format(\"[%d s, %d ms, %d ns] \", secs, mill, nan);\n+    }\n+\n+    static Throwable getCause(Throwable exception) {\n+        if (exception instanceof IOException) return exception;\n+        if (exception instanceof CancellationException) return exception;\n+        if (exception instanceof CompletionException) return getCause(exception.getCause());\n+        if (exception instanceof ExecutionException) return getCause(exception.getCause());\n+        return exception;\n+    }\n+\n+    private synchronized void sendManyRequests(final String requestURI, final int many, boolean shutdown) throws Exception {\n+        System.out.println(\"\\n%sSending %s requests to %s, shutdown=%s\\n\".formatted(now(), many, requestURI, shutdown));\n+        System.err.println(\"\\n%sSending %s requests to %s, shutdown=%s\\n\".formatted(now(), many, requestURI, shutdown));\n+        assert many > 0;\n+        try (final HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .sslContext(sslContext).build()) {\n+            List<CompletableFuture<HttpResponse<String>>> futures = new ArrayList<>();\n+            final HttpRequest.Builder reqBuilder = HttpRequest.newBuilder().version(HTTP_1_1);\n+            for (int i = 0; i < many; i++) {\n+                \/\/ GET\n+                final URI reqURI = new URI(requestURI + \"?i=\" + i);\n+                final HttpRequest req = reqBuilder.copy().uri(reqURI).GET().build();\n+                System.out.println(now() + \"Issuing request: \" + req);\n+                var cf = client.sendAsync(req, BodyHandlers.ofString());\n+                futures.add(cf);\n+            }\n+            System.out.printf(\"\\n%sWaiting for %s requests to be handled on the server%n\", now(), many);\n+\n+            int count = 0;\n+            \/\/ wait for all exchanges to be handled\n+            while (!requestSemaphore.tryAcquire(many, 5, TimeUnit.SECONDS)) {\n+                count++;\n+                System.out.printf(\"%sFailed to obtain %s permits after %ss - only %s available%n\",\n+                        now(), many, (count * 5), requestSemaphore.availablePermits());\n+                for (var cf : futures) {\n+                    if (cf.isDone() || cf.isCancelled()) {\n+                        System.out.printf(\"%sFound some completed cf: %s%n\", now(), cf);\n+                        if (cf.isCancelled()) {\n+                            System.out.printf(\"%scf is cancelled: %s%n\", now(), cf);\n+                            client.shutdownNow(); \/\/ make sure HttpCient::close won't block waiting for server\n+                            var error = new AssertionError(now() + \"A request cf was cancelled\" + cf);\n+                            System.out.printf(\"%s throwing: %s%n\", now(), error);\n+                            throw error;\n+                        }\n+                        if (cf.isCompletedExceptionally()) {\n+                            System.out.printf(\"%scf is completed exceptionally: %s%n\", now(), cf);\n+                            var exception = getCause(cf.exceptionNow());\n+                            System.out.printf(\"%sexception is: %s%n\", now(), exception);\n+                            client.shutdownNow(); \/\/ make sure HttpCient::close won't block waiting for server\n+                            exception.printStackTrace(System.out);\n+                            var error = new AssertionError(now() + \"A request failed prematurely\", exception);\n+                            System.out.printf(\"%s throwing: %s%n\", now(), error);\n+                            throw error;\n+                        }\n+                        System.out.printf(\"%scf is completed prematurely: %s%n\", now(), cf);\n+                        client.shutdownNow(); \/\/ make sure HttpCient::close won't block waiting for server\n+                        var error = new AssertionError(now() + \"A request succeeded prematurely: \" + cf.join());\n+                        System.out.printf(\"%s throwing: %s%n\", now(), error);\n+                        throw error;\n+                    }\n+                }\n+                System.out.printf(\"%sCouldn't acquire %s permits, only %s available - keep on waiting%n\",\n+                        now(), many, requestSemaphore.availablePermits());\n+            }\n+\n+            System.out.println(now() + \"All requests reached the server: releasing one response\");\n+            \/\/ allow one request to proceed\n+            responseSemaphore.release();\n+            try {\n+                \/\/ wait for the first response.\n+                System.out.println(now() + \"Waiting for the first response\");\n+                CompletableFuture.anyOf(futures.toArray(new CompletableFuture[0])).join();\n+                System.out.println(now() + \"Got first response: \" + futures.stream().filter(CompletableFuture::isDone)\n+                        .findFirst().map(CompletableFuture::join));\n+                if (shutdown) {\n+                    System.out.println(now() + \"Calling HttpClient::shutdownNow\");\n+                    client.shutdownNow();\n+                    client.awaitTermination(Duration.ofSeconds(1));\n+                }\n+            } finally {\n+                System.out.printf(\"%s Releasing %s remaining responses%n\", now(), many - 1);\n+                \/\/ now release the others.\n+                responseSemaphore.release(many - 1);\n+            }\n+\n+            \/\/ wait for all responses\n+            System.out.printf(\"%sWaiting for all %s responses to complete%n\", now(), many);\n+            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).exceptionally(t -> null).join();\n+\n+            \/\/ check\n+            System.out.printf(\"%sAll %s responses completed. Checking...%n%n\", now(), many);\n+            Set<String> conns = new HashSet<>();\n+            int exceptionCount = 0;\n+            int success = 0;\n+            for (var respCF : futures) {\n+                try {\n+                    var resp = respCF.join();\n+                    Assertions.assertEquals(200, resp.statusCode(),\n+                            now() + \"unexpected response code for GET request: \" + resp);\n+                    Assertions.assertTrue(conns.add(resp.connectionLabel().get()),\n+                            now() + \"unexepected reuse of connection: \"\n+                                    + resp.connectionLabel().get() + \" found in \" + conns);\n+                    success++;\n+                } catch (CompletionException x) {\n+                    if (shutdown) exceptionCount++;\n+                    else throwCause(x);\n+                }\n+            }\n+            if (shutdown) {\n+                if (success == 0) {\n+                    throw new AssertionError((\"%s%s: shutdownNow=%s: Expected at least one response, \" +\n+                            \"got success=%s, exceptions=%s\").formatted(now(), requestURI, shutdown, success, exceptionCount));\n+                }\n+            }\n+            System.out.println(\"%sSuccess: %s: shutdownNow:%s, success=%s, exceptions:%s\\n\"\n+                    .formatted(now(), requestURI, shutdown, success, exceptionCount));\n+            successfulCompletion = true;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/PlainConnectionLockTest.java","additions":382,"deletions":0,"binary":false,"changes":382,"status":"added"}]}