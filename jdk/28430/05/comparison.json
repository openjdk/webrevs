{"files":[{"patch":"@@ -208,0 +208,1 @@\n+        boolean stopping = false;\n@@ -212,10 +213,2 @@\n-            } else if (stopped) {\n-                conn.close();\n-                return;\n-            }\n-            if (MAX_POOL_SIZE > 0 && expiryList.size() >= MAX_POOL_SIZE) {\n-                toClose = expiryList.removeOldest();\n-                if (toClose != null) removeFromPool(toClose);\n-            }\n-            if (conn instanceof PlainHttpConnection) {\n-                putConnection(conn, plainPool);\n+            } else if (stopping = stopped) {\n+                toClose = conn;\n@@ -223,2 +216,11 @@\n-                assert conn.isSecure();\n-                putConnection(conn, sslPool);\n+                if (MAX_POOL_SIZE > 0 && expiryList.size() >= MAX_POOL_SIZE) {\n+                    toClose = expiryList.removeOldest();\n+                    if (toClose != null) removeFromPool(toClose);\n+                }\n+                if (conn instanceof PlainHttpConnection) {\n+                    putConnection(conn, plainPool);\n+                } else {\n+                    assert conn.isSecure();\n+                    putConnection(conn, sslPool);\n+                }\n+                expiryList.add(conn, now, keepAlive);\n@@ -226,1 +228,0 @@\n-            expiryList.add(conn, now, keepAlive);\n@@ -232,2 +233,7 @@\n-                debug.log(\"Maximum pool size reached: removing oldest connection %s\",\n-                          toClose.dbgString());\n+                if (stopping) {\n+                    debug.log(\"Stopping: close connection %s\",\n+                            toClose.dbgString());\n+                } else {\n+                    debug.log(\"Maximum pool size reached: removing oldest connection %s\",\n+                            toClose.dbgString());\n+                }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ConnectionPool.java","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1336,0 +1336,7 @@\n+            \/\/ first stop the client to avoid seeing exceptions\n+            \/\/ about \"selector manager closed\"\n+            Log.logTrace(\"{0}: stopping\", owner.dbgTag);\n+            try {\n+                owner.stop();\n+            } catch (Throwable ignored) {\n+            }\n@@ -1348,0 +1355,1 @@\n+                \/\/ cleanup anything that might have been left behind\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -314,9 +314,9 @@\n-            if (Log.channel()) {\n-                Log.logChannel(\"Closing channel: \" + chan);\n-            }\n-            try {\n-                tube.signalClosed(errorRef.get());\n-                chan.close();\n-            } finally {\n-                client().connectionClosed(this);\n-            }\n+        } finally {\n+            stateLock.unlock();\n+        }\n+        if (Log.channel()) {\n+            Log.logChannel(\"Closing channel: \" + chan);\n+        }\n+        try {\n+            tube.signalClosed(errorRef.get());\n+            chan.close();\n@@ -327,1 +327,1 @@\n-            stateLock.unlock();\n+            client().connectionClosed(this);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainHttpConnection.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,241 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Semaphore;\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.test.lib.net.SimpleSSLContext;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Assertions;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+\n+\/*\n+ * @test\n+ * @bug 8372198\n+ * @summary Attempt to check that no deadlock occurs when\n+ *          connections are closed by the ConnectionPool.\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run junit\/othervm\n+ *              -Djdk.httpclient.HttpClient.log=errors\n+ *              -Djdk.httpclient.connectionPoolSize=1\n+ *              ${test.main.class}\n+ *\/\n+\n+\/\/ -Djava.security.debug=all\n+class PlainConnectionLockTest implements HttpServerAdapters {\n+\n+    private SSLContext sslContext;\n+    private HttpTestServer http1Server;\n+    private HttpTestServer https1Server;\n+    private String http1URI;\n+    private String https1URI;\n+    private ExecutorService serverExecutor;\n+    private Semaphore responseSemaphore;\n+    private Semaphore requestSemaphore;\n+    private static final int MANY = 100;\n+\n+    static {\n+        HttpServerAdapters.enableServerLogging();\n+    }\n+\n+    private boolean blockResponse(Semaphore request, Semaphore response) {\n+        try {\n+            request.release();\n+            response.acquire();\n+            return true;\n+        } catch (InterruptedException x) {\n+            return false;\n+        }\n+    }\n+\n+\n+    @BeforeEach\n+    synchronized void beforeTest() throws Exception {\n+        requestSemaphore = new Semaphore(0);\n+        responseSemaphore = new Semaphore(0);\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null) {\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+        }\n+        serverExecutor = Executors.newThreadPerTaskExecutor(\n+                Thread.ofVirtual().name(\"Http1Server\", 0).factory());\n+\n+        \/\/ create a https server for HTTP\/1.1\n+        https1Server = HttpTestServer.create(HTTP_1_1, sslContext, serverExecutor);\n+        https1Server.addHandler((exchange) -> {\n+            if (blockResponse(requestSemaphore, responseSemaphore)) {\n+                exchange.sendResponseHeaders(200, 0);\n+            } else {\n+                exchange.sendResponseHeaders(500, 0);\n+            }\n+        }, \"\/PlainConnectionLockTest\/\");\n+        https1Server.start();\n+        System.out.println(\"HTTPS Server started at \" + https1Server.getAddress());\n+        https1URI = \"https:\/\/\" + https1Server.serverAuthority() + \"\/PlainConnectionLockTest\/https1\";\n+\n+        \/\/ create a plain http server for HTTP\/1.1\n+        http1Server = HttpTestServer.create(HTTP_1_1, null, serverExecutor);\n+        http1Server.addHandler((exchange) -> {\n+            if (blockResponse(requestSemaphore, responseSemaphore)) {\n+                exchange.sendResponseHeaders(200, 0);\n+            } else {\n+                exchange.sendResponseHeaders(500, 0);\n+            }\n+        }, \"\/PlainConnectionLockTest\/\");\n+        http1Server.start();\n+        System.out.println(\"HTTP Server started at \" + http1Server.getAddress());\n+        http1URI = \"http:\/\/\" + http1Server.serverAuthority() + \"\/PlainConnectionLockTest\/http1\";\n+    }\n+\n+    @AfterEach\n+    synchronized void afterTest() throws Exception {\n+        if (http1Server != null) {\n+            System.out.println(\"Stopping HTTP server \" + http1Server.getAddress());\n+            http1Server.stop();\n+        }\n+        if (https1Server != null) {\n+            System.out.println(\"Stopping HTTPS server \" + https1Server.getAddress());\n+            https1Server.stop();\n+        }\n+        if (serverExecutor != null) {\n+            serverExecutor.close();\n+        }\n+        requestSemaphore = null;\n+        responseSemaphore = null;\n+        serverExecutor = null;\n+        http1Server = null;\n+        https1Server = null;\n+        http1URI = null;\n+        https1URI = null;\n+    }\n+\n+    @Test\n+    void sendManyHttpRequestsNoShutdown() throws Exception {\n+        sendManyRequests(http1URI, MANY, false);\n+    }\n+    @Test\n+    void sendManyHttpRequestsShutdownNow() throws Exception {\n+        sendManyRequests(http1URI, MANY, true);\n+    }\n+    @Test\n+    void sendManyHttpsRequestsNoShutdown() throws Exception {\n+        sendManyRequests(https1URI, MANY, false);\n+    }\n+    @Test\n+    void sendManyHttpsRequestsShutdownNow() throws Exception {\n+        sendManyRequests(https1URI, MANY, true);\n+    }\n+\n+    private static void throwCause(CompletionException x) throws Exception {\n+        var cause = x.getCause();\n+        if (cause instanceof Exception ex) throw ex;\n+        if (cause instanceof Error err) throw err;\n+        throw x;\n+    }\n+\n+    private synchronized void sendManyRequests(final String requestURI, final int many, boolean shutdown) throws Exception {\n+        System.out.println(\"\\nSending %s requests to %s, shutdown=%s\\n\".formatted(many, requestURI, shutdown));\n+        System.err.println(\"\\nSending %s requests to %s, shutdown=%s\\n\".formatted(many, requestURI, shutdown));\n+        assert many > 0;\n+        try (final HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .sslContext(sslContext).build()) {\n+            List<CompletableFuture<HttpResponse<String>>> futures = new ArrayList<>();\n+            final HttpRequest.Builder reqBuilder = HttpRequest.newBuilder().version(HTTP_1_1);\n+            for (int i = 0; i < many; i++) {\n+                \/\/ GET\n+                final URI reqURI = new URI(requestURI + \"?i=\" + i);\n+                final HttpRequest req = reqBuilder.copy().uri(reqURI).GET().build();\n+                System.out.println(\"\\nIssuing request: \" + req);\n+                var cf = client.sendAsync(req, BodyHandlers.ofString());\n+                futures.add(cf);\n+            }\n+            \/\/ wait for all exchanges to be handled\n+            requestSemaphore.acquire(many);\n+            \/\/ allow one request to proceed\n+            responseSemaphore.release();\n+            try {\n+                \/\/ wait for the first response.\n+                CompletableFuture.anyOf(futures.toArray(new CompletableFuture[0])).join();\n+                if (shutdown) {\n+                    client.shutdownNow();\n+                    client.awaitTermination(Duration.ofSeconds(1));\n+                }\n+            } finally {\n+                \/\/ now release the others.\n+                responseSemaphore.release(many - 1);\n+            }\n+            \/\/ wait for all responses\n+            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).exceptionally(t -> null).join();\n+\n+            \/\/ check\n+            Set<String> conns = new HashSet<>();\n+            int exceptionCount = 0;\n+            int success = 0;\n+            for (var respCF : futures) {\n+                try {\n+                    var resp = respCF.join();\n+                    Assertions.assertEquals(200, resp.statusCode(),\n+                            \"unexpected response code for GET request: \" + resp);\n+                    Assertions.assertTrue(conns.add(resp.connectionLabel().get()),\n+                            \"unexepected reuse of connection: \"\n+                                    + resp.connectionLabel().get() + \" found in \" + conns);\n+                    success++;\n+                } catch (CompletionException x) {\n+                    if (shutdown) exceptionCount++;\n+                    else throwCause(x);\n+                }\n+            }\n+            if (shutdown) {\n+                if (success == 0) {\n+                    throw new AssertionError((\"%s: shutdownNow=%s: Expected at least one response, \" +\n+                            \"got success=%s, exceptions=%s\").formatted(requestURI, shutdown, success, exceptionCount));\n+                }\n+            }\n+            System.out.println(\"Success: %s: shutdownNow:%s, success=%s, exceptions:%s\"\n+                    .formatted(requestURI, shutdown, success, exceptionCount));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/PlainConnectionLockTest.java","additions":241,"deletions":0,"binary":false,"changes":241,"status":"added"}]}