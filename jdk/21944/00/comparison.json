{"files":[{"patch":"@@ -1783,6 +1783,2 @@\n-void PhaseIdealLoop::update_main_loop_assertion_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init,\n-                                                           const int stride_con) {\n-  Node* entry = ctrl;\n-  Node* prev_proj = ctrl;\n-  LoopNode* outer_loop_head = loop_head->skip_strip_mined();\n-  IdealLoopTree* outer_loop = get_loop(outer_loop_head);\n+void PhaseIdealLoop::update_main_loop_assertion_predicates(CountedLoopNode* main_loop_head) {\n+  Node* init = main_loop_head->init_trip();\n@@ -1792,32 +1788,8 @@\n-  int new_stride_con = stride_con * 2;\n-  Node* max_value = _igvn.intcon(new_stride_con);\n-  set_ctrl(max_value, C->root());\n-\n-  while (entry != nullptr && entry->is_Proj() && entry->in(0)->is_If()) {\n-    IfNode* iff = entry->in(0)->as_If();\n-    ProjNode* proj = iff->proj_out(1 - entry->as_Proj()->_con);\n-    if (!proj->unique_ctrl_out()->is_Halt()) {\n-      break;\n-    }\n-    Node* bol = iff->in(1);\n-    if (bol->is_OpaqueTemplateAssertionPredicate()) {\n-      assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n-      \/\/ This is a Template Assertion Predicate for the initial or last access.\n-      \/\/ Create an Initialized Assertion Predicates for it accordingly:\n-      \/\/ - For the initial access a[init] (same as before)\n-      \/\/ - For the last access a[init+new_stride-orig_stride] (with the new unroll stride)\n-      prev_proj = create_initialized_assertion_predicate(iff, init, max_value, prev_proj);\n-    } else if (bol->is_OpaqueInitializedAssertionPredicate()) {\n-      \/\/ This is one of the two Initialized Assertion Predicates:\n-      \/\/ - For the initial access a[init]\n-      \/\/ - For the last access a[init+old_stride-orig_stride]\n-      \/\/ We could keep the one for the initial access but we do not know which one we currently have here. Just kill both.\n-      _igvn.replace_input_of(iff, 1, _igvn.intcon(1));\n-    }\n-    assert(!bol->is_OpaqueNotNull() || !loop_head->is_main_loop(), \"OpaqueNotNull should not be at main loop\");\n-    entry = entry->in(0)->in(0);\n-  }\n-  if (prev_proj != ctrl) {\n-    _igvn.replace_input_of(outer_loop_head, LoopNode::EntryControl, prev_proj);\n-    set_idom(outer_loop_head, prev_proj, dom_depth(outer_loop_head));\n-  }\n+  int unrolled_stride_con = main_loop_head->stride_con() * 2;\n+  Node* unrolled_stride = _igvn.intcon(unrolled_stride_con);\n+  set_ctrl(unrolled_stride, C->root());\n+\n+  Node* loop_entry = main_loop_head->skip_strip_mined()->in(LoopNode::EntryControl);\n+  PredicateIterator predicate_iterator(loop_entry);\n+  UpdateStrideForAssertionPredicates update_stride_for_assertion_predicates(unrolled_stride, this);\n+  predicate_iterator.for_each(update_stride_for_assertion_predicates);\n@@ -1940,1 +1912,1 @@\n-  update_main_loop_assertion_predicates(ctrl, loop_head, init, stride_con);\n+  update_main_loop_assertion_predicates(loop_head);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":11,"deletions":39,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -951,1 +951,1 @@\n-  void update_main_loop_assertion_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init, int stride_con);\n+  void update_main_loop_assertion_predicates(CountedLoopNode* main_loop_head);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -155,1 +155,0 @@\n-\n@@ -182,0 +181,18 @@\n+\/\/ Replace the input to OpaqueLoopStrideNode with 'new_stride' and leave the other nodes unchanged.\n+void TemplateAssertionPredicate::replace_opaque_stride_input(Node* new_stride, PhaseIterGVN& igvn) const {\n+  TemplateAssertionExpression expression(opaque_node());\n+  expression.replace_opaque_stride_input(new_stride, igvn);\n+}\n+\n+\/\/ Create a new Initialized Assertion Predicate from this template at 'new_control' and return the success projection\n+\/\/ of the newly created Initialized Assertion Predicate.\n+IfTrueNode* TemplateAssertionPredicate::initialize(PhaseIdealLoop* phase, Node* new_control) const {\n+  assert(phase->assertion_predicate_has_loop_opaque_node(head()),\n+         \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n+  InitializedAssertionPredicateCreator initialized_assertion_predicate(phase);\n+  IfTrueNode* success_proj = initialized_assertion_predicate.create_from_template(head(), new_control);\n+  assert(!phase->assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n+         \"Initialized Assertion Predicates do not have OpaqueLoop* nodes in the bool expression anymore\");\n+  return success_proj;\n+}\n+\n@@ -192,0 +209,6 @@\n+void InitializedAssertionPredicate::kill(PhaseIdealLoop* phase) const {\n+  Node* true_con = phase->igvn().intcon(1);\n+  phase->set_ctrl(true_con, phase->C->root());\n+  phase->igvn().replace_input_of(_if_node, 1, true_con);\n+}\n+\n@@ -391,0 +414,57 @@\n+\/\/ This class is used to replace the input to OpaqueLoopStrideNode with a new node while leaving the other nodes\n+\/\/ unchanged.\n+class ReplaceOpaqueStrideInput : public StackObj {\n+  PhaseIterGVN& _igvn;\n+  Unique_Node_List _nodes_to_visit;\n+\n+ public:\n+  ReplaceOpaqueStrideInput(OpaqueTemplateAssertionPredicateNode* start_node, PhaseIterGVN& igvn) : _igvn(igvn) {\n+    _nodes_to_visit.push(start_node);\n+  }\n+  NONCOPYABLE(ReplaceOpaqueStrideInput);\n+\n+  void replace(Node* new_opaque_stride_input) {\n+    for (uint i = 0; i < _nodes_to_visit.size(); i++) {\n+      Node* next = _nodes_to_visit[i];\n+      for (uint j = 1; j < next->req(); j++) {\n+        Node* input = next->in(j);\n+        if (input->is_OpaqueLoopStride()) {\n+          assert(TemplateAssertionExpressionNode::is_maybe_in_expression(input), \"must also pass node filter\");\n+          _igvn.replace_input_of(input, 1, new_opaque_stride_input);\n+        } else if (TemplateAssertionExpressionNode::is_maybe_in_expression(input)) {\n+          _nodes_to_visit.push(input);\n+        }\n+      }\n+    }\n+  }\n+};\n+\n+\/\/ Replace the input to OpaqueLoopStrideNode with 'new_stride' and leave the other nodes unchanged.\n+void TemplateAssertionExpression::replace_opaque_stride_input(Node* new_stride, PhaseIterGVN& igvn) {\n+  ReplaceOpaqueStrideInput replace_opaque_stride_input(_opaque_node, igvn);\n+  replace_opaque_stride_input.replace(new_stride);\n+}\n+\n+\/\/ The transformations of this class fold the OpaqueLoop* nodes by returning their inputs.\n+class RemoveOpaqueLoopNodesStrategy : public TransformStrategyForOpaqueLoopNodes {\n+ public:\n+  Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) const override {\n+    return opaque_init->in(1);\n+  }\n+\n+  Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) const override {\n+    return opaque_stride->in(1);\n+  }\n+};\n+\n+OpaqueInitializedAssertionPredicateNode*\n+TemplateAssertionExpression::clone_and_fold_opaque_loop_nodes(Node* new_control, PhaseIdealLoop* phase) {\n+  RemoveOpaqueLoopNodesStrategy remove_opaque_loop_nodes_strategy;\n+  OpaqueTemplateAssertionPredicateNode* cloned_template_opaque = clone(remove_opaque_loop_nodes_strategy, new_control,\n+                                                                       phase);\n+  OpaqueInitializedAssertionPredicateNode* opaque_initialized_opaque =\n+      new OpaqueInitializedAssertionPredicateNode(cloned_template_opaque->in(1)->as_Bool(), phase->C);\n+  phase->register_new_node(opaque_initialized_opaque, new_control);\n+  return opaque_initialized_opaque;\n+}\n+\n@@ -667,0 +747,13 @@\n+\/\/ Create a new Initialized Assertion Predicate from 'template_assertion_predicate' by cloning it but omitting the\n+\/\/ OpaqueLoop*Notes (i.e. taking their inputs instead).\n+IfTrueNode* InitializedAssertionPredicateCreator::create_from_template(IfNode* template_assertion_predicate,\n+                                                                       Node* new_control) {\n+  OpaqueTemplateAssertionPredicateNode* template_opaque =\n+      template_assertion_predicate->in(1)->as_OpaqueTemplateAssertionPredicate();\n+  TemplateAssertionExpression template_assertion_expression(template_opaque);\n+  OpaqueInitializedAssertionPredicateNode* assertion_expression =\n+      template_assertion_expression.clone_and_fold_opaque_loop_nodes(new_control, _phase);\n+  return create_control_nodes(new_control, template_assertion_predicate->Opcode(), assertion_expression\n+                              NOT_PRODUCT(COMMA template_assertion_predicate->assertion_predicate_type()));\n+}\n+\n@@ -771,1 +864,1 @@\n-const TemplateAssertionPredicate& template_assertion_predicate) const {\n+    const TemplateAssertionPredicate& template_assertion_predicate) const {\n@@ -786,0 +879,33 @@\n+\n+\/\/ Clone the Template Assertion Predicate and set a new input for the OpaqueLoopStrideNode.\n+void UpdateStrideForAssertionPredicates::visit(const TemplateAssertionPredicate& template_assertion_predicate) {\n+  replace_opaque_stride_input(template_assertion_predicate);\n+  Node* template_tail_control_out = template_assertion_predicate.tail()->unique_ctrl_out();\n+  IfTrueNode* initialized_success_proj = initialize_from_updated_template(template_assertion_predicate);\n+  connect_initialized_assertion_predicate(template_tail_control_out, initialized_success_proj);\n+}\n+\n+\/\/ Replace the input to OpaqueLoopStrideNode with 'new_stride' and leave the other nodes unchanged.\n+void UpdateStrideForAssertionPredicates::replace_opaque_stride_input(\n+    const TemplateAssertionPredicate& template_assertion_predicate) const {\n+  template_assertion_predicate.replace_opaque_stride_input(_new_stride, _phase->igvn());\n+}\n+\n+IfTrueNode* UpdateStrideForAssertionPredicates::initialize_from_updated_template(\n+    const TemplateAssertionPredicate& template_assertion_predicate) const {\n+  IfTrueNode* initialized_success_proj = template_assertion_predicate.initialize(_phase, template_assertion_predicate.tail());\n+  return initialized_success_proj;\n+}\n+\n+\/\/ The newly created Initialized Assertion Predicate can safely be inserted because this visitor is already visiting\n+\/\/ the Template Assertion Predicate above this. So, we will not accidentally visit this again and kill it with the\n+\/\/ visit() method for Initialized Assertion Predicates.\n+void UpdateStrideForAssertionPredicates::connect_initialized_assertion_predicate(\n+    Node* new_control_out, IfTrueNode* initialized_success_proj) const {\n+  if (new_control_out->is_Loop()) {\n+    _phase->igvn().replace_input_of(new_control_out, LoopNode::EntryControl, initialized_success_proj);\n+  } else {\n+    _phase->igvn().replace_input_of(new_control_out, 0, initialized_success_proj);\n+  }\n+  _phase->set_idom(new_control_out, initialized_success_proj, _phase->dom_depth(new_control_out));\n+}\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":128,"deletions":2,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -407,0 +407,2 @@\n+  void replace_opaque_stride_input(Node* new_stride, PhaseIterGVN& igvn) const;\n+  IfTrueNode* initialize(PhaseIdealLoop* phase, Node* new_control) const;\n@@ -437,0 +439,1 @@\n+  void kill(PhaseIdealLoop* phase) const;\n@@ -464,0 +467,2 @@\n+  void replace_opaque_stride_input(Node* new_stride, PhaseIterGVN& igvn);\n+  OpaqueInitializedAssertionPredicateNode* clone_and_fold_opaque_loop_nodes(Node* new_ctrl, PhaseIdealLoop* phase);\n@@ -611,0 +616,1 @@\n+  IfTrueNode* create_from_template(IfNode* template_assertion_predicate, Node* new_control);\n@@ -1035,0 +1041,28 @@\n+\/\/ This visitor updates the stride for an Assertion Predicate during Loop Unrolling. The inputs to the OpaqueLoopStride\n+\/\/ nodes Template of Template Assertion Predicates are updated and new Initialized Assertion Predicates are created\n+\/\/ from the updated templates. The old Initialized Assertion Predicates are killed.\n+class UpdateStrideForAssertionPredicates : public PredicateVisitor {\n+  Node* const _new_stride;\n+  PhaseIdealLoop* const _phase;\n+\n+  void replace_opaque_stride_input(const TemplateAssertionPredicate& template_assertion_predicate) const;\n+  IfTrueNode* initialize_from_updated_template(const TemplateAssertionPredicate& template_assertion_predicate) const;\n+  void connect_initialized_assertion_predicate(Node* new_control_out, IfTrueNode* initialized_success_proj) const;\n+\n+ public:\n+  UpdateStrideForAssertionPredicates(Node* const new_stride, PhaseIdealLoop* phase)\n+      : _new_stride(new_stride),\n+        _phase(phase) {}\n+  NONCOPYABLE(UpdateStrideForAssertionPredicates);\n+\n+  using PredicateVisitor::visit;\n+\n+  void visit(const TemplateAssertionPredicate& template_assertion_predicate) override;\n+\n+  \/\/ Kill the old Initialized Assertion Predicates with old strides before unrolling. The new Initialized Assertion\n+  \/\/ Predicates are inserted after the Template Assertion Predicate which ensures that we are not accidentally visiting\n+  \/\/ and killing a newly created Initialized Assertion Predicate here.\n+  void visit(const InitializedAssertionPredicate& initialized_assertion_predicate) override {\n+    initialized_assertion_predicate.kill(_phase);\n+  }\n+};\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"}]}