{"files":[{"patch":"@@ -1335,1 +1335,1 @@\n-  if (jvf->method()->is_native()) {\n+  if (jvf->method()->is_native() || (depth == 0 && state->top_frame_is_exiting())) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1877,0 +1877,4 @@\n+  \/\/ Do not allow NotifyFramePop to add new FramePop event request at\n+  \/\/ depth 0 as it is already late in the method exiting dance.\n+  state->set_top_frame_is_exiting();\n+\n@@ -1885,0 +1889,4 @@\n+  \/\/ The JRT_BLOCK_END can safepoint in ThreadInVMfromJava desctructor. Now it is safe to allow\n+  \/\/ adding FramePop event requests as no safepoint can happen before removing activation.\n+  state->clr_top_frame_is_exiting();\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+  _top_frame_is_exiting = false;\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -193,0 +193,1 @@\n+  bool              _top_frame_is_exiting;\n@@ -360,0 +361,5 @@\n+  \/\/ For synchronization between NotifyFramePop and FramePop posting code.\n+  void set_top_frame_is_exiting() { _top_frame_is_exiting = true;  }\n+  void clr_top_frame_is_exiting() { _top_frame_is_exiting = false; }\n+  bool top_frame_is_exiting()     { return _top_frame_is_exiting;  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8340698\n+ * @summary JVMTI FRAME_POP event is sometimes missed if NotifyFramePop is called as a method is returning\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @compile NotifyFramePopStressTest.java\n+ * @run main\/othervm\/native -agentlib:NotifyFramePopStressTest NotifyFramePopStressTest\n+ *\/\n+\n+import jtreg.SkippedException;\n+\n+public class NotifyFramePopStressTest {\n+    static volatile boolean done = false;\n+\n+    public static void main(String args[]) {\n+        if (!canGenerateFramePopEvents()) {\n+            throw new SkippedException(\"FramePop event is not supported\");\n+        }\n+        Thread testThread = Thread.currentThread();\n+        Thread controlThread = new Thread(() -> control(testThread), \"Control Thread\");\n+\n+        setFramePopNotificationMode(testThread);\n+        controlThread.start();\n+        sleep(10);\n+\n+        for (int i = 0; i < 10*1000; i++) {\n+            foo();\n+            bar();\n+        }\n+        done = true;\n+\n+        try {\n+            controlThread.join();\n+        } catch (InterruptedException e) {\n+        }\n+\n+        if (failed()) {\n+            throw new RuntimeException(\"Test FAILED: see log for details\");\n+        } else {\n+            log(\"Test PASSED\");\n+        }\n+    }\n+\n+    private static void sleep(long ms) {\n+        try {\n+            Thread.sleep(ms);\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private static void control(Thread thread) {\n+        int notifyCount = 0;\n+\n+        log(\"control has started\");\n+        while (!done) {\n+            suspend(thread);\n+            if (notifyFramePop(thread)) {\n+                notifyCount++;\n+                log(\"control incremented notifyCount to \" + notifyCount);\n+            }\n+            resume(thread);\n+            int waitCount = 0;\n+            while (notifyCount != getPopCount()) {\n+                sleep(1);\n+                waitCount++;\n+                if (waitCount > 1000) {\n+                    break;\n+                }\n+            }\n+            if (waitCount > 100) {\n+                log(\"About to fail. notifyCount=\" + notifyCount + \" getPopCount()=\" + getPopCount());\n+                throw new RuntimeException(\"Test FAILED: Waited too long for notify: \" + waitCount);\n+            }\n+        }\n+        log(\"control has finished: \" + notifyCount);\n+    }\n+\n+    private native static void suspend(Thread thread);\n+    private native static void resume(Thread thread);\n+    private native static int getPopCount();\n+    private native static boolean failed();\n+    private native static boolean canGenerateFramePopEvents();\n+    private native static void setFramePopNotificationMode(Thread thread);\n+    private native static boolean notifyFramePop(Thread thread);\n+\n+    private static void log(String msg) {\n+        System.out.println(msg);\n+    }\n+\n+    private static int fetchIntFoo() {\n+        return 13;\n+    }\n+\n+    private static int fetchIntBar() {\n+        return 33;\n+    }\n+\n+    private static int foo() {\n+        return fetchIntFoo();\n+    }\n+\n+    private static int bar() {\n+        return fetchIntBar();\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NotifyFramePopStressTest\/NotifyFramePopStressTest.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.hpp\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+static jvmtiEnv *jvmti = nullptr;\n+static jvmtiCapabilities caps;\n+static jvmtiEventCallbacks callbacks;\n+static volatile jint pop_count = 0;\n+static char* volatile last_notify_method;\n+static volatile jboolean failed = JNI_FALSE;\n+static jboolean seenMain = JNI_FALSE;\n+\n+static jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved);\n+\n+JNIEXPORT\n+jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT\n+jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT\n+jint JNICALL JNI_OnLoad(JavaVM *jvm, void *reserved) {\n+  return JNI_VERSION_9;\n+}\n+\n+static void JNICALL\n+FramePop(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread,\n+         jmethodID method, jboolean wasPoppedByException) {\n+  jvmtiError err;\n+  jclass cls = nullptr;\n+  char* csig = nullptr;\n+  char* name = nullptr;\n+\n+  pop_count++;\n+\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  check_jvmti_status(jni, err, \"FramePop: Failed in JVMTI GetMethodDeclaringClass\");\n+\n+  err = jvmti->GetClassSignature(cls, &csig, nullptr);\n+  check_jvmti_status(jni, err, \"FramePop: Failed in JVMTI GetClassSignature\");\n+\n+  name = get_method_name(jvmti, jni, method);\n+  LOG(\"FramePop(%d) event from method: %s %s\\n\", pop_count, csig, name);\n+\n+  if (strcmp(name, \"main\") != 0) { \/\/ ignore FRAME_POP for main that comes in as the test exits\n+    if (strcmp(name, (char*)last_notify_method) != 0) {\n+      LOG(\"ERROR: FramePop event is for wrong method: expected %s, got %s\\n\", last_notify_method, name);\n+      failed = JNI_TRUE;\n+    }\n+  }\n+  deallocate(jvmti, jni, csig);\n+  deallocate(jvmti, jni, name);\n+}\n+\n+static\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jint res;\n+  jvmtiError err;\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_9);\n+  if (res != JNI_OK || jvmti == nullptr) {\n+    LOG(\"GetEnv(JVMTI_VERSION_9) failed error(%d)\", res);\n+    return JNI_ERR;\n+  }\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  check_jvmti_error(err, \"Agent: GetPotentialCapabilities failed\");\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  check_jvmti_error(err, \"Agent: AddCapabilities failed\");\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  check_jvmti_error(err, \"Agent: GetCapabilities failed\");\n+\n+  if (caps.can_generate_frame_pop_events) {\n+    callbacks.FramePop = &FramePop;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    check_jvmti_error(err, \"Agent: SetEventCallbacks failed\");\n+  }\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_NotifyFramePopStressTest_canGenerateFramePopEvents(JNIEnv *env, jclass cls) {\n+  return caps.can_generate_frame_pop_events ? JNI_TRUE : JNI_FALSE;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_NotifyFramePopStressTest_setFramePopNotificationMode(JNIEnv *env, jclass cl, jthread thread) {\n+  set_event_notification_mode(jvmti, env, JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, thread);\n+}\n+\n+\/*\n+ * Call NotifyFramePop on the current frame.\n+ *\/\n+JNIEXPORT jboolean JNICALL\n+Java_NotifyFramePopStressTest_notifyFramePop(JNIEnv *jni, jclass cls, jthread thread) {\n+  jmethodID method;\n+  jlocation loc;\n+  char* name;\n+  jvmtiError err;\n+  jboolean isMain;\n+\n+  err = jvmti->GetFrameLocation(thread, 0, &method, &loc);\n+  check_jvmti_status(jni, err, \"notifyFramePop: Failed in JVMTI GetFrameLocation\");\n+\n+  name = get_method_name(jvmti, jni, method);\n+\n+  \/\/ We only want to do a NotifyFramePop once for the main method. The sole purpose is\n+  \/\/ to force the thread into interpOnly mode, which seems to help the test's timing\n+  \/\/ in a way that makes it more likely to reproduce the issue.\n+  isMain = (strcmp(name, \"main\") == 0);\n+  if (isMain) {\n+    if (seenMain) {\n+      deallocate(jvmti, jni, name);\n+      return JNI_FALSE; \/\/ Only do NotifyFramePop once for main()\n+    } else {\n+      seenMain = JNI_TRUE;\n+    }\n+  }\n+\n+  err= jvmti->NotifyFramePop(thread, 0);\n+  if (err == JVMTI_ERROR_OPAQUE_FRAME || err == JVMTI_ERROR_DUPLICATE) {\n+    \/\/LOG(\"\\nNotifyFramePop for method %s returned acceptable error: %s\\n\", name, TranslateError(err));\n+    deallocate(jvmti, jni, name);\n+    return JNI_FALSE;\n+  }\n+  check_jvmti_status(jni, err, \"notifyFramePop: Failed in JVMTI notifyFramePop\");\n+  LOG(\"\\nNotifyFramePop called for method %s\\n\", name);\n+\n+  if (isMain) {\n+    LOG(\"notifyFramePop not counting main method\\n\");\n+    deallocate(jvmti, jni, name);\n+    return JNI_FALSE;\n+  } else {\n+    deallocate(jvmti, jni, last_notify_method);\n+    last_notify_method = name;\n+    return JNI_TRUE;\n+  }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_NotifyFramePopStressTest_suspend(JNIEnv *jni, jclass cls, jthread thread) {\n+  suspend_thread(jvmti, jni, thread);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_NotifyFramePopStressTest_resume(JNIEnv *jni, jclass cls, jthread thread) {\n+  resume_thread(jvmti, jni, thread);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_NotifyFramePopStressTest_getPopCount(JNIEnv *env, jclass cls) {\n+  return pop_count;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_NotifyFramePopStressTest_failed(JNIEnv *env, jclass cls) {\n+  return failed;\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NotifyFramePopStressTest\/libNotifyFramePopStressTest.cpp","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"}]}