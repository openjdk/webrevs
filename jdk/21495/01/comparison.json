{"files":[{"patch":"@@ -4191,0 +4191,1 @@\n+        chk.validate(tree.var.vartype, env, true);\n@@ -4200,1 +4201,0 @@\n-        chk.validate(tree.var.vartype, env, true);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -741,1 +741,1 @@\n-     *  to make the reference unique.\n+     *  to make the reference unique. The types in the AST nodes will be erased.\n@@ -744,1 +744,1 @@\n-        return isUnqualifiable(sym)\n+        JCExpression result = isUnqualifiable(sym)\n@@ -747,0 +747,6 @@\n+\n+        if (sym.kind == TYP) {\n+            result.setType(types.erasure(sym.type));\n+        }\n+\n+        return result;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8332725\n+ * @bug 8332725 8341901\n@@ -32,0 +32,2 @@\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.MemberSelectTree;\n@@ -33,0 +35,1 @@\n+import com.sun.source.tree.VariableTree;\n@@ -34,0 +37,1 @@\n+import com.sun.source.util.TreePathScanner;\n@@ -35,0 +39,1 @@\n+import com.sun.source.util.Trees;\n@@ -38,0 +43,5 @@\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.tools.Diagnostic;\n+import javax.tools.DiagnosticListener;\n@@ -48,0 +58,1 @@\n+        new BindingPatternVarTypeModel().runVarParameterized();\n@@ -89,0 +100,81 @@\n+\n+    private void runVarParameterized() throws Exception {\n+        JavaFileObject input =\n+                SimpleJavaFileObject.forSource(URI.create(\"mem:\/\/\/Test.java\"),\n+                                               \"\"\"\n+                                               package test;\n+                                               public class Test {\n+                                                   record R(N.I i) {}\n+                                                   int test(Object o) {\n+                                                       Test.N.I checkType0 = null;\n+                                                       var checkType1 = checkType0;\n+                                                       return switch (o) {\n+                                                           case R(var checkType2) -> 0;\n+                                                           default -> 0;\n+                                                       };\n+                                                   }\n+                                                   static class N<T> {\n+                                                       interface I {}\n+                                                   }\n+                                               }\n+                                               \"\"\");\n+        DiagnosticListener<JavaFileObject> noErrors = d -> {\n+            if (d.getKind() == Diagnostic.Kind.ERROR) {\n+                throw new IllegalStateException(d.toString());\n+            }\n+        };\n+        JavacTask task =\n+                (JavacTask) compiler.getTask(null, null, noErrors, null, null, List.of(input));\n+        CompilationUnitTree cut = task.parse().iterator().next();\n+        Trees trees = Trees.instance(task);\n+\n+        task.analyze();\n+\n+        new TreePathScanner<Void, Void>() {\n+            private boolean checkAttributes;\n+            @Override\n+            public Void visitVariable(VariableTree node, Void p) {\n+                boolean prevCheckAttributes = checkAttributes;\n+                try {\n+                    checkAttributes |=\n+                            node.getName().toString().startsWith(\"checkType\");\n+                    return super.visitVariable(node, p);\n+                } finally {\n+                    checkAttributes = prevCheckAttributes;\n+                }\n+            }\n+\n+            @Override\n+            public Void visitIdentifier(IdentifierTree node, Void p) {\n+                checkType();\n+                return super.visitIdentifier(node, p);\n+            }\n+\n+            @Override\n+            public Void visitMemberSelect(MemberSelectTree node, Void p) {\n+                checkType();\n+                return super.visitMemberSelect(node, p);\n+            }\n+\n+            private void checkType() {\n+                if (!checkAttributes) {\n+                    return ;\n+                }\n+\n+                TypeMirror type = trees.getTypeMirror(getCurrentPath());\n+\n+                if (type.getKind() == TypeKind.PACKAGE) {\n+                    return ; \/\/OK\n+                }\n+                if (type.getKind() != TypeKind.DECLARED) {\n+                    throw new AssertionError(\"Expected a declared type, but got: \" +\n+                                             type.getKind());\n+                }\n+\n+                if (!((DeclaredType) type).getTypeArguments().isEmpty()) {\n+                    throw new AssertionError(\"Unexpected type arguments: \" +\n+                                             ((DeclaredType) type).getTypeArguments());\n+                }\n+            }\n+        }.scan(cut, null);\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/BindingPatternVarTypeModel.java","additions":93,"deletions":1,"binary":false,"changes":94,"status":"modified"}]}