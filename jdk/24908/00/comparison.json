{"files":[{"patch":"@@ -104,2 +104,0 @@\n-import com.sun.tools.javac.jvm.Target;\n-import com.sun.tools.javac.util.Assert;\n@@ -107,1 +105,1 @@\n-import com.sun.tools.javac.util.Pair;\n+\n@@ -969,3 +967,3 @@\n-    @SuppressWarnings(\"unchecked\")\n-    private void addGenericAttributes(FeatureDescription desc, ClassFileBuilder<?, ?> builder) {\n-        addGenericAttributes(desc, (Consumer<? super Attribute<?>>) builder, builder.constantPool());\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    private void addGenericAttributes(FeatureDescription desc, ClassFileBuilder builder) {\n+        addGenericAttributes(desc, (Consumer<Attribute<?>>) builder, builder.constantPool());\n@@ -974,3 +972,1 @@\n-    private void addGenericAttributes(FeatureDescription desc, Consumer<? super Attribute<?>> sink, ConstantPoolBuilder cpb) {\n-        @SuppressWarnings(\"unchecked\")\n-        var builder = (Consumer<Attribute<?>>) sink;\n+    private void addGenericAttributes(FeatureDescription desc, Consumer<Attribute<?>> builder, ConstantPoolBuilder cpb) {\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.internal.classfile.impl.TransformImpl;\n@@ -60,1 +61,1 @@\n-        extends ClassFileBuilder<ClassElement, ClassBuilder>\n+        extends ClassFileBuilder<ClassTransform, ClassElement, ClassBuilder>\n@@ -363,0 +364,14 @@\n+\n+    \/\/ Implementations\n+\n+    \/**\n+     * @since 25\n+     *\/\n+    @Override\n+    default ClassBuilder transforming(ClassTransform transform, Consumer<? super ClassBuilder> handler) {\n+        var resolved = TransformImpl.resolve(transform, this);\n+        resolved.startHandler().run();\n+        handler.accept(new ChainedClassBuilder(this, resolved.consumer()));\n+        resolved.endHandler().run();\n+        return this;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassBuilder.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.classfile.attribute.CharacterRangeInfo;\n@@ -31,2 +30,0 @@\n-import java.lang.classfile.attribute.LocalVariableInfo;\n-import java.lang.classfile.attribute.LocalVariableTypeInfo;\n@@ -683,2 +680,2 @@\n-     * and to distinguish from {@link ClassFileBuilder#transform}, which is\n-     * more generic and powerful.\n+     * and to distinguish from {@link ClassFileBuilder#transform} and {@link\n+     * ClassFileBuilder#transforming}, which are more generic and powerful.\n@@ -707,2 +704,2 @@\n-     * and to distinguish from {@link ClassFileBuilder#transform}, which is\n-     * more generic and powerful.\n+     * and to distinguish from {@link ClassFileBuilder#transform} and {@link\n+     * ClassFileBuilder#transforming}, which are more generic and powerful.\n@@ -739,2 +736,2 @@\n-     * and to distinguish from {@link ClassFileBuilder#transform}, which is\n-     * more generic and powerful.\n+     * and to distinguish from {@link ClassFileBuilder#transform} and {@link\n+     * ClassFileBuilder#transforming}, which are more generic and powerful.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Objects;\n@@ -62,0 +63,1 @@\n+ * @param <C> the type of transform that runs on this builder\n@@ -67,1 +69,1 @@\n-public sealed interface ClassFileBuilder<E extends ClassFileElement, B extends ClassFileBuilder<E, B>>\n+public sealed interface ClassFileBuilder<C extends ClassFileTransform<C, E, B>, E extends ClassFileElement, B extends ClassFileBuilder<C, E, B>>\n@@ -109,0 +111,4 @@\n+     * A {@linkplain #transforming(ClassFileTransform, Consumer) handler-based}\n+     * version behaves similarly; the elements built by the handler are passed\n+     * instead of elements from an existing structure.\n+     * <p>\n@@ -110,1 +116,1 @@\n-     * structures, integrating member elements of different origins.\n+     * structures and handlers, integrating member elements of different origins.\n@@ -125,0 +131,1 @@\n+     * @see #transforming(ClassFileTransform, Consumer)\n@@ -126,1 +133,7 @@\n-    default B transform(CompoundElement<E> model, ClassFileTransform<?, E, B> transform) {\n+    default B transform(CompoundElement<E> model, C transform) {\n+        Objects.requireNonNull(model);\n+        Objects.requireNonNull(transform);\n+\n+        \/\/ This can be as simple as:\n+        \/\/ return transform(Util.writingAll(model), transform);\n+        \/\/ but this version saves an additional builder\n@@ -135,0 +148,38 @@\n+\n+    \/**\n+     * Applies a transform to a structure built by a handler, directing results\n+     * to this builder.  The builder passed to the handler is initialized with\n+     * the same required arguments as this builder.\n+     * <p>\n+     * The transform will receive each element built by the handler, as well\n+     * as this builder for building the structure.  The transform is free\n+     * to preserve, remove, or replace elements as it sees fit.\n+     * <p>\n+     * A {@linkplain #transform(CompoundElement, ClassFileTransform)\n+     * structure-based} version behaves similarly; the elements from an existing\n+     * source are passed instead of elements built by a handler.\n+     * <p>\n+     * A builder can run multiple transforms against different compound\n+     * structures and handlers, integrating member elements of different origins.\n+     *\n+     * @apiNote\n+     * Many subinterfaces have methods like {@link ClassBuilder#transformMethod}\n+     * or {@link MethodBuilder#transformCode}.  However, calling them is\n+     * fundamentally different from calling this method: those methods call the\n+     * {@code transform} on the child builders instead of on itself.  For\n+     * example, {@code classBuilder.transformMethod} calls {@code\n+     * methodBuilder.transform} with a new method builder instead of calling\n+     * {@code classBuilder.transform} on itself.\n+     * <p>\n+     * If elements are sourced from a {@link CompoundElement}, the {@linkplain\n+     * #transform(CompoundElement, ClassFileTransform) structure-based} version\n+     * may be more efficient.\n+     *\n+     * @param transform the transform to apply\n+     * @param handler the handler to produce elements to be transformed\n+     * @return this builder\n+     * @see ClassFileTransform\n+     * @see #transform(CompoundElement, ClassFileTransform)\n+     * @since 25\n+     *\/\n+    B transforming(C transform, Consumer<? super B> handler);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFileBuilder.java","additions":54,"deletions":3,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.util.function.Supplier;\n@@ -34,3 +33,4 @@\n- * through {@link ClassFileBuilder#transform}.  A subtype of {@code\n- * ClassFileTransform} is defined for each subtype of {@link CompoundElement}\n- * and {@link ClassFileBuilder}, as shown in the sealed class hierarchy below.\n+ * through {@link ClassFileBuilder#transform} and {@link\n+ * ClassFileBuilder#transforming}.  A subtype of {@code ClassFileTransform} is\n+ * defined for each subtype of {@link CompoundElement} and {@link\n+ * ClassFileBuilder}, as shown in the sealed class hierarchy below.\n@@ -88,2 +88,3 @@\n- * Besides {@link ClassFileBuilder#transform}, there are other methods that\n- * accepts a transform conveniently, such as {@link ClassFile#transformClass},\n+ * Besides {@link ClassFileBuilder#transform} and {@link\n+ * ClassFileBuilder#transforming}, there are other methods that accepts a\n+ * transform conveniently, such as {@link ClassFile#transformClass},\n@@ -104,1 +105,1 @@\n-        B extends ClassFileBuilder<E, B>>\n+        B extends ClassFileBuilder<C, E, B>>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFileTransform.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Objects;\n@@ -95,1 +96,1 @@\n-        extends ClassFileBuilder<CodeElement, CodeBuilder>\n+        extends ClassFileBuilder<CodeTransform, CodeElement, CodeBuilder>\n@@ -153,2 +154,1 @@\n-     * Apply a transform to the code built by a handler, directing results to\n-     * this builder.\n+     * {@inheritDoc}\n@@ -156,10 +156,8 @@\n-     * @apiNote\n-     * This is similar to {@link #transform}, but this does not require the\n-     * code elements to be viewed as a {@link CodeModel} first.\n-     *\n-     * @param transform the transform to apply to the code built by the handler\n-     * @param handler the handler that receives a {@link CodeBuilder} to\n-     * build the code\n-     * @return this builder\n-     *\/\n-    default CodeBuilder transforming(CodeTransform transform, Consumer<CodeBuilder> handler) {\n+     * @param transform {@inheritDoc}\n+     * @param handler {@inheritDoc}\n+     * @return {@inheritDoc}\n+     *\/ \/\/ remove supertype incorrect since\n+    @Override\n+    default CodeBuilder transforming(CodeTransform transform, Consumer<? super CodeBuilder> handler) {\n+        Objects.requireNonNull(handler);\n+        Objects.requireNonNull(transform);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.classfile.impl.TransformImpl;\n@@ -51,1 +52,1 @@\n-        extends ClassFileBuilder<FieldElement, FieldBuilder>\n+        extends ClassFileBuilder<FieldTransform, FieldElement, FieldBuilder>\n@@ -80,0 +81,13 @@\n+    \/\/ Implementations\n+\n+    \/**\n+     * @since 25\n+     *\/\n+    @Override\n+    default FieldBuilder transforming(FieldTransform transform, Consumer<? super FieldBuilder> handler) {\n+        var resolved = TransformImpl.resolve(transform, this);\n+        resolved.startHandler().run();\n+        handler.accept(new ChainedFieldBuilder(this, resolved.consumer()));\n+        resolved.endHandler().run();\n+        return this;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/FieldBuilder.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.classfile.impl.TransformImpl;\n@@ -52,1 +53,1 @@\n-        extends ClassFileBuilder<MethodElement, MethodBuilder>\n+        extends ClassFileBuilder<MethodTransform, MethodElement, MethodBuilder>\n@@ -109,0 +110,14 @@\n+\n+    \/\/ Implementations\n+\n+    \/**\n+     * @since 25\n+     *\/\n+    @Override\n+    default MethodBuilder transforming(MethodTransform transform, Consumer<? super MethodBuilder> handler) {\n+        var resolved = TransformImpl.resolve(transform, this);\n+        resolved.startHandler().run();\n+        handler.accept(new ChainedMethodBuilder(this, resolved.consumer()));\n+        resolved.endHandler().run();\n+        return this;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodBuilder.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-    FieldRefEntry classData(ClassFileBuilder<?, ?> cfb, Object arg, ClassDesc desc) {\n+    FieldRefEntry classData(ClassFileBuilder<?, ?, ?> cfb, Object arg, ClassDesc desc) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n-    public static <E extends ClassFileElement, B extends ClassFileBuilder<E, B>>\n-            ResolvedTransform<E> resolve(ClassFileTransform<?, E, B> transform, B builder) {\n+    public static <E extends ClassFileElement, B extends ClassFileBuilder<C, E, B>, C extends ClassFileTransform<C, E, B>>\n+            ResolvedTransform<E> resolve(C transform, B builder) {\n@@ -48,1 +48,1 @@\n-            var ut = (ResolvableTransform<E, B>) transform;\n+            var ut = (ResolvableTransform<E, B, C>) transform;\n@@ -56,1 +56,1 @@\n-    interface ResolvableTransform<E extends ClassFileElement, B extends ClassFileBuilder<E, B>> {\n+    interface ResolvableTransform<E extends ClassFileElement, B extends ClassFileBuilder<C, E, B>, C extends ClassFileTransform<C, E, B>> {\n@@ -60,1 +60,1 @@\n-    interface UnresolvedClassTransform extends ClassTransform, ResolvableTransform<ClassElement, ClassBuilder> {\n+    interface UnresolvedClassTransform extends ClassTransform, ResolvableTransform<ClassElement, ClassBuilder, ClassTransform> {\n@@ -156,1 +156,1 @@\n-    interface UnresolvedMethodTransform extends MethodTransform, ResolvableTransform<MethodElement, MethodBuilder> {\n+    interface UnresolvedMethodTransform extends MethodTransform, ResolvableTransform<MethodElement, MethodBuilder, MethodTransform> {\n@@ -220,1 +220,1 @@\n-    interface UnresolvedFieldTransform extends FieldTransform, ResolvableTransform<FieldElement, FieldBuilder> {\n+    interface UnresolvedFieldTransform extends FieldTransform, ResolvableTransform<FieldElement, FieldBuilder, FieldTransform> {\n@@ -260,1 +260,1 @@\n-    interface UnresolvedCodeTransform extends CodeTransform, ResolvableTransform<CodeElement, CodeBuilder> {\n+    interface UnresolvedCodeTransform extends CodeTransform, ResolvableTransform<CodeElement, CodeBuilder, CodeTransform> {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TransformImpl.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,14 +31,1 @@\n-import java.lang.classfile.ClassBuilder;\n-import java.lang.classfile.ClassElement;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.ClassModel;\n-import java.lang.classfile.ClassTransform;\n-import java.lang.classfile.CodeBuilder;\n-import java.lang.classfile.CodeElement;\n-import java.lang.classfile.CodeModel;\n-import java.lang.classfile.CodeTransform;\n-import java.lang.classfile.FieldModel;\n-import java.lang.classfile.FieldTransform;\n-import java.lang.classfile.Label;\n-import java.lang.classfile.MethodModel;\n-import java.lang.classfile.MethodTransform;\n+import java.lang.classfile.*;\n@@ -60,0 +47,2 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n@@ -88,6 +77,13 @@\n-    static ClassTransform transformCode(CodeTransform x) {\n-        return (cb, ce) -> {\n-            if (ce instanceof MethodModel mm) {\n-                cb.transformMethod(mm, (mb, me) -> {\n-                    if (me instanceof CodeModel xm) {\n-                        mb.transformCode(xm, x);\n+    enum CodeTransformLifter {\n+        MB_TRANSFORM_CODE {\n+            @Override\n+            public ClassTransform transformCode(CodeTransform x) {\n+                return (cb, ce) -> {\n+                    if (ce instanceof MethodModel mm) {\n+                        cb.transformMethod(mm, (mb, me) -> {\n+                            if (me instanceof CodeModel xm) {\n+                                mb.transformCode(xm, x);\n+                            }\n+                            else\n+                                mb.with(me);\n+                        });\n@@ -96,2 +92,38 @@\n-                        mb.with(me);\n-                });\n+                        cb.with(ce);\n+                };\n+            }\n+        },\n+        COB_TRANSFORM_CODE_MODEL {\n+            @Override\n+            public ClassTransform transformCode(CodeTransform x) {\n+                return (cb, ce) -> {\n+                    if (ce instanceof MethodModel mm) {\n+                        cb.transformMethod(mm, (mb, me) -> {\n+                            if (me instanceof CodeModel xm) {\n+                                mb.withCode(cob -> cob.transform(xm, x));\n+                            }\n+                            else\n+                                mb.with(me);\n+                        });\n+                    }\n+                    else\n+                        cb.with(ce);\n+                };\n+            }\n+        },\n+        COB_TRANSFORM_CODE_HANDLER {\n+            @Override\n+            public ClassTransform transformCode(CodeTransform x) {\n+                return (cb, ce) -> {\n+                    if (ce instanceof MethodModel mm) {\n+                        cb.transformMethod(mm, (mb, me) -> {\n+                            if (me instanceof CodeModel xm) {\n+                                mb.withCode(cob -> cob.transforming(x, xm::forEach));\n+                            }\n+                            else\n+                                mb.with(me);\n+                        });\n+                    }\n+                    else\n+                        cb.with(ce);\n+                };\n@@ -99,2 +131,0 @@\n-            else\n-                cb.with(ce);\n@@ -102,0 +132,1 @@\n+        public abstract ClassTransform transformCode(CodeTransform x);\n@@ -111,2 +142,3 @@\n-    @Test\n-    void testSingleTransform() throws Exception {\n+    @EnumSource\n+    @ParameterizedTest\n+    void testSingleTransform(CodeTransformLifter lifter) throws Exception {\n@@ -118,3 +150,3 @@\n-        assertEquals(invoke(bytes), \"foo\");\n-        assertEquals(invoke(cc.transformClass(cm, transformCode(foo2foo))), \"foo\");\n-        assertEquals(invoke(cc.transformClass(cm, transformCode(foo2bar))), \"bar\");\n+        assertEquals(\"foo\", invoke(bytes));\n+        assertEquals(\"foo\", invoke(cc.transformClass(cm, lifter.transformCode(foo2foo))));\n+        assertEquals(\"bar\", invoke(cc.transformClass(cm, lifter.transformCode(foo2bar))));\n@@ -123,2 +155,3 @@\n-    @Test\n-    void testSeq2() throws Exception {\n+    @EnumSource\n+    @ParameterizedTest\n+    void testSeq2(CodeTransformLifter lifter) throws Exception {\n@@ -130,3 +163,3 @@\n-        assertEquals(invoke(bytes), \"foo\");\n-        ClassTransform transform = transformCode(foo2bar.andThen(bar2baz));\n-        assertEquals(invoke(cc.transformClass(cm, transform)), \"baz\");\n+        assertEquals(\"foo\", invoke(bytes));\n+        ClassTransform transform = lifter.transformCode(foo2bar.andThen(bar2baz));\n+        assertEquals(\"baz\", invoke(cc.transformClass(cm, transform)));\n@@ -135,2 +168,3 @@\n-    @Test\n-    void testSeqN() throws Exception {\n+    @EnumSource\n+    @ParameterizedTest\n+    void testSeqN(CodeTransformLifter lifter) throws Exception {\n@@ -142,4 +176,4 @@\n-        assertEquals(invoke(bytes), \"foo\");\n-        assertEquals(invoke(cc.transformClass(cm, transformCode(foo2bar.andThen(bar2baz).andThen(baz2foo)))), \"foo\");\n-        assertEquals(invoke(cc.transformClass(cm, transformCode(foo2bar.andThen(bar2baz).andThen(baz2quux)))), \"quux\");\n-        assertEquals(invoke(cc.transformClass(cm, transformCode(foo2foo.andThen(foo2bar).andThen(bar2baz)))), \"baz\");\n+        assertEquals(\"foo\", invoke(bytes));\n+        assertEquals(\"foo\", invoke(cc.transformClass(cm, lifter.transformCode(foo2bar.andThen(bar2baz).andThen(baz2foo)))));\n+        assertEquals(\"quux\", invoke(cc.transformClass(cm, lifter.transformCode(foo2bar.andThen(bar2baz).andThen(baz2quux)))));\n+        assertEquals(\"baz\", invoke(cc.transformClass(cm, lifter.transformCode(foo2foo.andThen(foo2bar).andThen(bar2baz)))));\n@@ -332,0 +366,59 @@\n+    private static final MethodTypeDesc MTD_String = MethodTypeDesc.of(CD_String);\n+\n+    @Test\n+    void testHandlerTransforms() throws Exception {\n+        var cf = ClassFile.of();\n+        byte[] bytes;\n+        \/\/ ClassBuilder\n+        bytes = cf.build(ClassDesc.of(testClassName), clb -> clb\n+                .transforming((clb2, cle) -> {\n+                              if (cle instanceof MethodModel mm) {\n+                                  assertEquals(\"bar\", mm.methodName().stringValue());\n+                                  assertEquals(MTD_String, mm.methodTypeSymbol());\n+                                  assertEquals(0, mm.flags().flagsMask());\n+                                  clb2.withMethod(\"foo\", MTD_String, ACC_PUBLIC | ACC_STATIC, mm::forEach);\n+                              } else {\n+                                  clb2.with(cle);\n+                              }\n+                          }, clb2 -> clb2.withMethodBody(\"bar\", MTD_String, 0, cob -> cob\n+                                .loadConstant(\"foo\")\n+                                .areturn())));\n+        assertEquals(\"foo\", invoke(bytes));\n+        \/\/ MethodBuilder\n+        bytes = cf.build(ClassDesc.of(testClassName), clb -> clb\n+                .withMethod(\"foo\", MTD_String, ACC_PUBLIC | ACC_STATIC, mb -> mb\n+                        .transforming((mb1, me) -> {\n+                            if (me instanceof CodeModel cm) {\n+                                var list = cm.elementList()\n+                                        .stream()\n+                                        .<Instruction>mapMulti((e, sink) -> {\n+                                            if (e instanceof Instruction inst) {\n+                                                sink.accept(inst);\n+                                            }\n+                                        }).toList();\n+                                assertEquals(2, list.size());\n+                                assertInstanceOf(ConstantInstruction.class, list.getFirst());\n+                                assertEquals(Opcode.ARETURN, ((Instruction) list.get(1)).opcode());\n+\n+                                mb1.withCode(cob -> cob\n+                                        .loadConstant(\"baz\")\n+                                        .areturn());\n+                            } else {\n+                                mb1.with(me);\n+                            }\n+                        }, mb1 -> mb1.withCode(cob -> cob.loadConstant(\"bar\").areturn()))));\n+        assertEquals(\"baz\", invoke(bytes));\n+        \/\/ CodeBuilder\n+        bytes = cf.build(ClassDesc.of(testClassName), clb -> clb\n+                .withMethodBody(\"foo\", MTD_String, ACC_PUBLIC | ACC_STATIC, cob -> cob\n+                        .transforming((cob1, coe) -> {\n+                                    if (coe instanceof ConstantInstruction.LoadConstantInstruction inst) {\n+                                        assertEquals(\"dub\", inst.constantValue());\n+                                        cob1.loadConstant(\"hot\");\n+                                    } else {\n+                                        cob1.with(coe);\n+                                    }\n+                                }, cob1 -> cob1.loadConstant(\"dub\").areturn())));\n+        assertEquals(\"hot\", invoke(bytes));\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/TransformTests.java","additions":134,"deletions":41,"binary":false,"changes":175,"status":"modified"}]}