{"files":[{"patch":"@@ -870,0 +870,4 @@\n+  Node* scalarized_obj(const JVMState* jvms, uint idx) const {\n+    assert(verify_jvms(jvms), \"jvms must match\");\n+    return in(_jvmadj + jvms->scloff() + idx);\n+  }\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -977,0 +977,21 @@\n+\/\/ Determine if there is a scalar replaced object description represented by 'ov'.\n+bool PhaseOutput::contains_as_scalarized_obj(JVMState* jvms, MachSafePointNode* sfn,\n+                                             GrowableArray<ScopeValue*>* objs,\n+                                             ObjectValue* ov) const {\n+  for (int i = 0; i < jvms->scl_size(); i++) {\n+    Node* n = sfn->scalarized_obj(jvms, i);\n+    \/\/ Other kinds of nodes that we may encounter here, for instance constants\n+    \/\/ representing values of fields of objects scalarized, aren't relevant for\n+    \/\/ us, since they don't map to ObjectValue.\n+    if (!n->is_SafePointScalarObject()) {\n+      continue;\n+    }\n+\n+    ObjectValue* other = (ObjectValue*) sv_for_node_id(objs, n->_idx);\n+    if (ov == other) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -1140,1 +1161,4 @@\n-          bool is_root = locarray->contains(ov) || exparray->contains(ov) || contains_as_owner(monarray, ov);\n+          bool is_root = locarray->contains(ov) ||\n+                         exparray->contains(ov) ||\n+                         contains_as_owner(monarray, ov) ||\n+                         contains_as_scalarized_obj(jvms, sfn, objs, ov);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -211,0 +211,3 @@\n+  bool contains_as_scalarized_obj(JVMState* jvms, MachSafePointNode* sfn,\n+                                  GrowableArray<ScopeValue*>* objs,\n+                                  ObjectValue* ov) const;\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331194\n+ * @summary Check that Reduce Allocation Merges doesn't crash when an input\n+ *          of the Phi is not the _current_ output of the Phi but said input\n+ *          needs to be rematerialized because it's used regardless of the\n+ *          Phi output.\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:CompileCommand=dontinline,*TestReduceAllocationAndNestedScalarized*::test\n+ *                   -XX:CompileCommand=compileonly,*TestReduceAllocationAndNestedScalarized*::test\n+ *                   -XX:CompileCommand=compileonly,*Picture*::*init*\n+ *                   -XX:CompileCommand=compileonly,*Point*::*init*\n+ *                   -XX:CompileCommand=exclude,*Unloaded*::*\n+ *                   -XX:+IgnoreUnrecognizedVMOptions\n+ *                   -XX:-TieredCompilation\n+ *                   -XX:-UseCompressedOops\n+ *                   -Xcomp\n+ *                   -server\n+ *                   compiler.c2.TestReduceAllocationAndNestedScalarized\n+ * @run main\/othervm compiler.c2.TestReduceAllocationAndNestedScalarized\n+ *\/\n+\n+package compiler.c2;\n+\n+public class TestReduceAllocationAndNestedScalarized {\n+    static class Picture {\n+        public Point first;\n+        public Point second;\n+    }\n+\n+    static class Point {\n+        int x;\n+    }\n+\n+    static class Unloaded {\n+    }\n+\n+    static int test(boolean cond) {\n+        Picture p = new Picture();\n+        p.first = new Point();\n+        Point p2 = p.first;\n+\n+        if (cond) p2 = new Point();\n+\n+        p.second = p2;\n+\n+        new Unloaded();\n+\n+        return p.first.x;\n+    }\n+\n+    public static void main(String[] args) {\n+        Picture pic = new Picture();\n+        Point pnt   = new Point();\n+        int res     = test(true);\n+        System.out.println(\"Result is: \" + res);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestReduceAllocationAndNestedScalarized.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"}]}