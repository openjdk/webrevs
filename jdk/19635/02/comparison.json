{"files":[{"patch":"@@ -1566,1 +1566,1 @@\n-       (scope()->wrote_final() ||\n+       (scope()->wrote_final() || scope()->wrote_stable() ||\n@@ -1744,4 +1744,0 @@\n-  if (field->is_final() && (code == Bytecodes::_putfield)) {\n-    scope()->set_wrote_final();\n-  }\n-\n@@ -1753,0 +1749,6 @@\n+    if (field->is_final()) {\n+      scope()->set_wrote_final();\n+    }\n+    if (field->is_stable()) {\n+      scope()->set_wrote_stable();\n+    }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+  _wrote_stable       = false;\n","filename":"src\/hotspot\/share\/c1\/c1_IR.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -152,0 +152,1 @@\n+  bool          _wrote_stable;                   \/\/ has written @Stable field\n@@ -190,0 +191,2 @@\n+  void          set_wrote_stable()               { _wrote_stable = true; }\n+  bool          wrote_stable() const             { return _wrote_stable; }\n","filename":"src\/hotspot\/share\/c1\/c1_IR.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -361,1 +361,1 @@\n-  Node*         _alloc_with_final;   \/\/ An allocation node with final field\n+  Node*         _alloc_with_final_or_stable; \/\/ An allocation node with final or @Stable field\n@@ -406,4 +406,4 @@\n-  Node*    alloc_with_final() const   { return _alloc_with_final; }\n-  void set_alloc_with_final(Node* n)  {\n-    assert((_alloc_with_final == nullptr) || (_alloc_with_final == n), \"different init objects?\");\n-    _alloc_with_final = n;\n+  Node*    alloc_with_final_or_stable() const   { return _alloc_with_final_or_stable; }\n+  void set_alloc_with_final_or_stable(Node* n)  {\n+    assert((_alloc_with_final_or_stable == nullptr) || (_alloc_with_final_or_stable == n), \"different init objects?\");\n+    _alloc_with_final_or_stable = n;\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -415,1 +415,1 @@\n-  _alloc_with_final = nullptr;\n+  _alloc_with_final_or_stable = nullptr;\n@@ -991,2 +991,2 @@\n-  \/\/ 1. The constructor wrote a final. The effects of all initializations\n-  \/\/    must be committed to memory before any code after the constructor\n+  \/\/ 1. The constructor wrote a final or a @Stable field. All these\n+  \/\/    initializations must be ordered before any code after the constructor\n@@ -1017,1 +1017,1 @@\n-       (wrote_final() ||\n+       (wrote_final() || wrote_stable() ||\n@@ -1020,0 +1020,1 @@\n+    Node* recorded_alloc = alloc_with_final_or_stable();\n@@ -1021,1 +1022,1 @@\n-                          alloc_with_final());\n+                          recorded_alloc);\n@@ -1026,2 +1027,2 @@\n-    if (DoEscapeAnalysis && alloc_with_final()) {\n-      AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_with_final());\n+    if (DoEscapeAnalysis && (recorded_alloc != nullptr)) {\n+      AllocateNode* alloc = AllocateNode::Ideal_allocation(recorded_alloc);\n@@ -1032,13 +1033,1 @@\n-      tty->print_cr(\" writes finals and needs a memory barrier\");\n-    }\n-  }\n-\n-  \/\/ Any method can write a @Stable field; insert memory barriers\n-  \/\/ after those also. Can't bind predecessor allocation node (if any)\n-  \/\/ with barrier because allocation doesn't always dominate\n-  \/\/ MemBarRelease.\n-  if (wrote_stable()) {\n-    _exits.insert_mem_bar(Op_MemBarRelease);\n-    if (PrintOpto && (Verbose || WizardMode)) {\n-      method()->print_name();\n-      tty->print_cr(\" writes @Stable and needs a memory barrier\");\n+      tty->print_cr(\" writes finals\/@Stable and needs a memory barrier\");\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":9,"deletions":20,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -239,1 +239,4 @@\n-    \/\/ Note the presence of writes to final non-static fields, so that we\n+    \/\/ If the field is @Stable, we can be in any method, but we only care about\n+    \/\/ constructors at this point.\n+    \/\/\n+    \/\/ Note the presence of writes to final\/@Stable non-static fields, so that we\n@@ -242,3 +245,7 @@\n-    \/\/ Any method can write a @Stable field; insert memory barriers after those also.\n-    if (field->is_final()) {\n-      set_wrote_final(true);\n+    if (field->is_final() || field->is_stable()) {\n+      if (field->is_final()) {\n+        set_wrote_final(true);\n+      }\n+      if (field->is_stable()) {\n+        set_wrote_stable(true);\n+      }\n@@ -248,2 +255,1 @@\n-        \/\/ Can't bind stable with its allocation, only record allocation for final field.\n-        set_alloc_with_final(obj);\n+        set_alloc_with_final_or_stable(obj);\n@@ -252,3 +258,0 @@\n-    if (field->is_stable()) {\n-      set_wrote_stable(true);\n-    }\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimArrayTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimArrayTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final int[] EMPTY_INTEGER = new int[] { 0 };\n+    static final int[] FULL_INTEGER = new int[] { 42 };\n+\n+    static class Carrier {\n+        @Stable\n+        int[] field;\n+\n+        @ForceInline\n+        public Carrier(int initLevel) {\n+            switch (initLevel) {\n+                case 0:\n+                    \/\/ Do nothing.\n+                    break;\n+                case 1:\n+                    field = EMPTY_INTEGER;\n+                    break;\n+                case 2:\n+                    field = FULL_INTEGER;\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown level\");\n+            }\n+        }\n+\n+        @ForceInline\n+        public void initEmpty() {\n+            field = EMPTY_INTEGER;\n+        }\n+\n+        @ForceInline\n+        public void initFull() {\n+            field = FULL_INTEGER;\n+        }\n+\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(0);\n+    static final Carrier INIT_EMPTY_CARRIER = new Carrier(1);\n+    static final Carrier INIT_FULL_CARRIER = new Carrier(2);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        int[] is = BLANK_CARRIER.field;\n+        if (is != null) {\n+            return is[0];\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testPartialFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        int[] is = INIT_EMPTY_CARRIER.field;\n+        if (is != null) {\n+            return is[0];\n+        }\n+        return 0;\n+    }\n+\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        int[] is = INIT_FULL_CARRIER.field;\n+        if (is != null) {\n+            return is[0];\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorEmptyInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(2);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodEmptyInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_EMPTY_CARRIER.initEmpty();\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodFullInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_FULL_CARRIER.initFull();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimArrayTest.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimFinalTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimFinalTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static class Carrier {\n+        @Stable\n+        final int field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            field = init ? 42 : 0;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for final fields.\n+        return BLANK_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        return INIT_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Single header+final barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Single header+final barrier.\n+        return new Carrier(true);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimFinalTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimPlainTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimPlainTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static class Carrier {\n+        @Stable\n+        int field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = 42;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = 42;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        return BLANK_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        return INIT_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodInit() {\n+        \/\/ Primitive inits have no membars.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimPlainTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimVolatileTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimVolatileTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static class Carrier {\n+        @Stable\n+        volatile int field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = 42;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = 42;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ Barriers expected for volatile fields.\n+        return BLANK_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        return INIT_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Expect only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Volatile barriers expected.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static void testMethodInit() {\n+        \/\/ Volatile barriers expected.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimVolatileTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefArrayTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefArrayTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer[] EMPTY_INTEGER = new Integer[] { null };\n+    static final Integer[] FULL_INTEGER = new Integer[] { 42 };\n+\n+    static class Carrier {\n+        @Stable\n+        Integer[] field;\n+\n+        @ForceInline\n+        public Carrier(int initLevel) {\n+            switch (initLevel) {\n+                case 0:\n+                    \/\/ Do nothing.\n+                    break;\n+                case 1:\n+                    field = EMPTY_INTEGER;\n+                    break;\n+                case 2:\n+                    field = FULL_INTEGER;\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown level\");\n+            }\n+        }\n+\n+        @ForceInline\n+        public void initEmpty() {\n+            field = EMPTY_INTEGER;\n+        }\n+\n+        @ForceInline\n+        public void initFull() {\n+            field = FULL_INTEGER;\n+        }\n+\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(0);\n+    static final Carrier INIT_EMPTY_CARRIER = new Carrier(1);\n+    static final Carrier INIT_FULL_CARRIER = new Carrier(2);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer[] is = BLANK_CARRIER.field;\n+        if (is != null) {\n+            Integer i = is[0];\n+            if (i != null) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testPartialFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer[] is = INIT_EMPTY_CARRIER.field;\n+        if (is != null) {\n+            Integer i = is[0];\n+            if (i != null) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer[] is = INIT_FULL_CARRIER.field;\n+        if (is != null) {\n+            Integer i = is[0];\n+            if (i != null) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorEmptyInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(2);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodEmptyInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_EMPTY_CARRIER.initEmpty();\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodFullInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_FULL_CARRIER.initFull();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefArrayTest.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefFinalTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefFinalTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer INTEGER = 42;\n+\n+    static class Carrier {\n+        @Stable\n+        final Integer field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            field = init ? INTEGER : null;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer i = BLANK_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer i = INIT_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorInit() {\n+        \/\/ Only the header+final barrier.\n+        return new Carrier(true);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefFinalTest.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefPlainTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefPlainTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer INTEGER = 42;\n+\n+    static class Carrier {\n+        @Stable\n+        Integer field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = INTEGER;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = INTEGER;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer i = BLANK_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer i = INIT_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefPlainTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefVolatileTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefVolatileTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer INTEGER = 42;\n+\n+    static class Carrier {\n+        @Stable\n+        volatile Integer field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = INTEGER;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = INTEGER;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ Barriers are expected for volatile field.\n+        Integer i = BLANK_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer i = INIT_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Volatile writes, expect more barriers.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static void testMethodInit() {\n+        \/\/ Barriers are expected for volatile fields.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefVolatileTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"}]}