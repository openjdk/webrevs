{"files":[{"patch":"@@ -1256,2 +1256,3 @@\n-bool LoadNode::is_instance_field_load_with_local_phi() {\n-  if (in(Memory)->is_Phi() && in(Address)->is_AddP()) {\n+bool LoadNode::is_instance_field_load_with_local_phi(Node* ctrl) {\n+  if( in(Memory)->is_Phi() && in(Memory)->in(0) == ctrl &&\n+      in(Address)->is_AddP() ) {\n@@ -1260,2 +1261,3 @@\n-    if (t_oop != nullptr &&\n-        t_oop->is_known_instance_field() &&\n+    if( t_oop != nullptr &&\n+        (t_oop->is_ptr_to_boxed_value() ||\n+         t_oop->is_known_instance_field()) &&\n@@ -1270,53 +1272,0 @@\n-bool LoadNode::is_boxed_value_load_with_local_phi(PhaseGVN* phase) {\n-  Compile* C = phase->C;\n-  Node* address = in(Address);\n-  const TypeOopPtr* t_oop = address->bottom_type()->isa_oopptr();\n-  intptr_t ignore = 0;\n-  Node* base = AddPNode::Ideal_base_and_offset(address, phase, ignore);\n-  bool base_is_phi = (base != NULL) && base->is_Phi();\n-  bool load_boxed_value = t_oop != NULL && t_oop->is_ptr_to_boxed_value()\n-                          && C->aggressive_unboxing() && (base != NULL) && (base == address->in(AddPNode::Base))\n-                          && phase->type(base)->higher_equal(TypePtr::NOTNULL);\n-  return base_is_phi && load_boxed_value;\n-}\n-\n-Node* LoadNode::phi_or_self(PhaseGVN* phase) {\n-  Node* mem = in(Memory);\n-  const TypeOopPtr* t_oop = in(Address)->bottom_type()->isa_oopptr();\n-  const Type* this_type = bottom_type();\n-\n-  if (is_instance_field_load_with_local_phi()) {\n-    Node* region = mem->in(0);\n-\n-    int this_index  = phase->C->get_alias_index(t_oop);\n-    int this_offset = t_oop->offset();\n-    int this_iid    = t_oop->instance_id();\n-    for (DUIterator_Fast imax, i = region->fast_outs(imax); i < imax; i++) {\n-      Node* phi = region->fast_out(i);\n-      if (phi->is_Phi() && phi != mem &&\n-          phi->as_Phi()->is_same_inst_field(this_type, (int)mem->_idx, this_iid, this_index, this_offset)) {\n-        return phi;\n-      }\n-    }\n-  }\n-\n-  if (is_boxed_value_load_with_local_phi(phase)) {\n-    intptr_t ignore = 0;\n-    Node* base = AddPNode::Ideal_base_and_offset(in(Address), phase, ignore);\n-    Node* region = base->in(0);\n-\n-    int this_index  = phase->C->get_alias_index(t_oop);\n-    int this_offset = t_oop->offset();\n-    int this_iid    = base->_idx;\n-    for (DUIterator_Fast imax, i = region->fast_outs(imax); i < imax; i++) {\n-      Node* phi = region->fast_out(i);\n-      if (phi->is_Phi() && phi != base &&\n-          phi->as_Phi()->is_same_inst_field(this_type, (int)base->_idx, this_iid, this_index, this_offset)) {\n-        return phi;\n-      }\n-    }\n-  }\n-\n-  return this;\n-}\n-\n@@ -1330,1 +1279,1 @@\n-  if (value) {\n+  if( value ) {\n@@ -1353,0 +1302,27 @@\n+  \/\/ Search for an existing data phi which was generated before for the same\n+  \/\/ instance's field to avoid infinite generation of phis in a loop.\n+  Node *region = mem->in(0);\n+  if (is_instance_field_load_with_local_phi(region)) {\n+    const TypeOopPtr *addr_t = in(Address)->bottom_type()->isa_oopptr();\n+    int this_index  = phase->C->get_alias_index(addr_t);\n+    int this_offset = addr_t->offset();\n+    int this_iid    = addr_t->instance_id();\n+    if (!addr_t->is_known_instance() &&\n+         addr_t->is_ptr_to_boxed_value()) {\n+      \/\/ Use _idx of address base (could be Phi node) for boxed values.\n+      intptr_t   ignore = 0;\n+      Node*      base = AddPNode::Ideal_base_and_offset(in(Address), phase, ignore);\n+      if (base == nullptr) {\n+        return this;\n+      }\n+      this_iid = base->_idx;\n+    }\n+    const Type* this_type = bottom_type();\n+    for (DUIterator_Fast imax, i = region->fast_outs(imax); i < imax; i++) {\n+      Node* phi = region->fast_out(i);\n+      if (phi->is_Phi() && phi != mem &&\n+          phi->as_Phi()->is_same_inst_field(this_type, (int)mem->_idx, this_iid, this_index, this_offset)) {\n+        return phi;\n+      }\n+    }\n+  }\n@@ -1354,1 +1330,1 @@\n-  return phi_or_self(phase);\n+  return this;\n@@ -1706,1 +1682,0 @@\n-  int mem_id = -1;\n@@ -1711,1 +1686,0 @@\n-    mem_id = mem->_idx;\n@@ -1718,1 +1692,0 @@\n-    mem_id = base->_idx;\n@@ -1727,1 +1700,0 @@\n-      mem_id = base->_idx;\n@@ -1732,1 +1704,0 @@\n-        mem_id = mem->_idx;\n@@ -1739,1 +1710,0 @@\n-    mem_id = mem->_idx;\n@@ -1753,0 +1723,5 @@\n+  \/\/ Avoid infinite split\n+  if (region != mem->in(0)) {\n+    return nullptr;\n+  }\n+\n@@ -1759,1 +1734,1 @@\n-    phi = new PhiNode(region, this_type, nullptr, mem_id, this_iid, this_index, this_offset);\n+    phi = new PhiNode(region, this_type, nullptr, mem->_idx, this_iid, this_index, this_offset);\n@@ -1761,1 +1736,1 @@\n-    phi = new PhiNode(region, this_type, nullptr, mem_id);\n+    phi = new PhiNode(region, this_type, nullptr, mem->_idx);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":42,"deletions":67,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -291,5 +291,1 @@\n-  bool is_instance_field_load_with_local_phi();\n-  bool is_boxed_value_load_with_local_phi(PhaseGVN* phase);\n-  \/\/ Search for an existing data phi which was generated before for the same\n-  \/\/ instance's field or boxed value to avoid infinite generation of phis in a loop.\n-  Node* phi_or_self(PhaseGVN* phase);\n+  bool is_instance_field_load_with_local_phi(Node* ctrl);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1416,1 +1416,1 @@\n-  if (old->is_Phi() && old->in(0) != nullptr) {\n+  if (old->is_Phi() && old->as_Phi()->type()->has_memory() && old->in(0) != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}