{"files":[{"patch":"@@ -4491,0 +4491,276 @@\n+\/\/ Compare char[] or byte[] arrays aligned to 4 bytes or substrings.\n+void C2_MacroAssembler::arrays_equals(bool is_array_equ, Register ary1,\n+                                      Register ary2, Register limit,\n+                                      Register result, Register chr,\n+                                      XMMRegister vec1, XMMRegister vec2,\n+                                      bool is_char, KRegister mask,\n+                                      bool expand_ary2) {\n+  \/\/ for expand_ary2, limit is the (smaller) size of the second array.\n+  ShortBranchVerifier sbv(this);\n+  Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_VECTORS, COMPARE_CHAR, COMPARE_BYTE;\n+\n+  assert((!expand_ary2) || ((expand_ary2) && (UseAVX == 2)),\n+         \"Expansion only implemented for AVX2\");\n+\n+  int length_offset  = arrayOopDesc::length_offset_in_bytes();\n+  int base_offset    = arrayOopDesc::base_offset_in_bytes(is_char ? T_CHAR : T_BYTE);\n+\n+  if (is_array_equ) {\n+    \/\/ Check the input args\n+    cmpoop(ary1, ary2);\n+    jcc(Assembler::equal, TRUE_LABEL);\n+\n+    \/\/ Need additional checks for arrays_equals.\n+    testptr(ary1, ary1);\n+    jcc(Assembler::zero, FALSE_LABEL);\n+    testptr(ary2, ary2);\n+    jcc(Assembler::zero, FALSE_LABEL);\n+\n+    \/\/ Check the lengths\n+    movl(limit, Address(ary1, length_offset));\n+    cmpl(limit, Address(ary2, length_offset));\n+    jcc(Assembler::notEqual, FALSE_LABEL);\n+  }\n+\n+  \/\/ count == 0\n+  testl(limit, limit);\n+  jcc(Assembler::zero, TRUE_LABEL);\n+\n+  if (is_array_equ) {\n+    \/\/ Load array address\n+    lea(ary1, Address(ary1, base_offset));\n+    lea(ary2, Address(ary2, base_offset));\n+  }\n+\n+  if (is_array_equ && is_char) {\n+    \/\/ arrays_equals when used for char[].\n+    shll(limit, 1);      \/\/ byte count != 0\n+  }\n+  movl(result, limit); \/\/ copy\n+\n+  if (UseAVX >= 2) {\n+    \/\/ With AVX2, use 32-byte vector compare\n+    Label COMPARE_WIDE_VECTORS, COMPARE_WIDE_VECTORS_16, COMPARE_TAIL, COMPARE_TAIL_16;\n+\n+    \/\/ Compare 32-byte vectors\n+    andl(result, 0x0000001f);  \/\/   tail count (in bytes)\n+    andl(limit, 0xffffffe0);   \/\/ vector count (in bytes)\n+    jcc(Assembler::zero, COMPARE_TAIL_16);\n+\n+    lea(ary1, Address(ary1, limit,\n+                      expand_ary2 ? Address::times_2 : Address::times_1));\n+    lea(ary2, Address(ary2, limit, Address::times_1));\n+    negptr(limit);\n+\n+#ifdef _LP64\n+    if ((AVX3Threshold == 0) && VM_Version::supports_avx512vlbw()) { \/\/ trying 64 bytes fast loop\n+      Label COMPARE_WIDE_VECTORS_LOOP_AVX2, COMPARE_WIDE_VECTORS_LOOP_AVX3;\n+\n+      cmpl(limit, -64);\n+      jcc(Assembler::greater, COMPARE_WIDE_VECTORS_LOOP_AVX2);\n+\n+      bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); \/\/ the hottest loop\n+\n+      evmovdquq(vec1, Address(ary1, limit, Address::times_1), Assembler::AVX_512bit);\n+      evpcmpeqb(mask, vec1, Address(ary2, limit, Address::times_1), Assembler::AVX_512bit);\n+      kortestql(mask, mask);\n+      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n+      addptr(limit, 64);  \/\/ update since we already compared at this addr\n+      cmpl(limit, -64);\n+      jccb(Assembler::lessEqual, COMPARE_WIDE_VECTORS_LOOP_AVX3);\n+\n+      \/\/ At this point we may still need to compare -limit+result bytes.\n+      \/\/ We could execute the next two instruction and just continue via non-wide path:\n+      \/\/  cmpl(limit, 0);\n+      \/\/  jcc(Assembler::equal, COMPARE_TAIL);  \/\/ true\n+      \/\/ But since we stopped at the points ary{1,2}+limit which are\n+      \/\/ not farther than 64 bytes from the ends of arrays ary{1,2}+result\n+      \/\/ (|limit| <= 32 and result < 32),\n+      \/\/ we may just compare the last 64 bytes.\n+      \/\/\n+      addptr(result, -64);   \/\/ it is safe, bc we just came from this area\n+      evmovdquq(vec1, Address(ary1, result, Address::times_1), Assembler::AVX_512bit);\n+      evpcmpeqb(mask, vec1, Address(ary2, result, Address::times_1), Assembler::AVX_512bit);\n+      kortestql(mask, mask);\n+      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n+\n+      jmp(TRUE_LABEL);\n+\n+      bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);\n+\n+    }\/\/if (VM_Version::supports_avx512vlbw())\n+#endif \/\/_LP64\n+    bind(COMPARE_WIDE_VECTORS);\n+    vmovdqu(vec1, Address(ary1, limit,\n+                          expand_ary2 ? Address::times_2 : Address::times_1));\n+    if (expand_ary2) {\n+      vpmovzxbw(vec2, Address(ary2, limit, Address::times_1),\n+                Assembler::AVX_256bit);\n+    } else {\n+      vmovdqu(vec2, Address(ary2, limit, Address::times_1));\n+    }\n+    vpxor(vec1, vec2);\n+\n+    vptest(vec1, vec1);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    addptr(limit, expand_ary2 ? 16 : 32);\n+    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n+\n+    testl(result, result);\n+    jcc(Assembler::zero, TRUE_LABEL);\n+\n+    vmovdqu(vec1,\n+            Address(ary1, result,\n+                    expand_ary2 ? Address::times_2 : Address::times_1, -32));\n+    if (expand_ary2) {\n+      vpmovzxbw(vec2, Address(ary2, result, Address::times_1, -16),\n+                Assembler::AVX_256bit);\n+    } else {\n+      vmovdqu(vec2, Address(ary2, result, Address::times_1, -32));\n+    }\n+    vpxor(vec1, vec2);\n+\n+    vptest(vec1, vec1);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    jmp(TRUE_LABEL);\n+\n+    bind(COMPARE_TAIL_16); \/\/ limit is zero\n+    movl(limit, result);\n+\n+    \/\/ Compare 16-byte chunks\n+    andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n+    andl(limit, 0xfffffff0);   \/\/ vector count (in bytes)\n+    jcc(Assembler::zero, COMPARE_TAIL);\n+\n+    lea(ary1, Address(ary1, limit, expand_ary2 ? Address::times_2 : Address::times_1));\n+    lea(ary2, Address(ary2, limit, Address::times_1));\n+    negptr(limit);\n+\n+    bind(COMPARE_WIDE_VECTORS_16);\n+    movdqu(vec1, Address(ary1, limit,\n+                         expand_ary2 ? Address::times_2 : Address::times_1));\n+    if (expand_ary2) {\n+      vpmovzxbw(vec2, Address(ary2, limit, Address::times_1),\n+                Assembler::AVX_128bit);\n+    } else {\n+      movdqu(vec2, Address(ary2, limit, Address::times_1));\n+    }\n+    vpxor(vec1, vec2);\n+\n+    vptest(vec1, vec1);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    addptr(limit, expand_ary2 ? 8 : 16);\n+    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS_16);\n+\n+    bind(COMPARE_TAIL); \/\/ limit is zero\n+    movl(limit, result);\n+    \/\/ Fallthru to tail compare\n+  } else if (UseSSE42Intrinsics) {\n+    \/\/ With SSE4.2, use double quad vector compare\n+    Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n+\n+    \/\/ Compare 16-byte vectors\n+    andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n+    andl(limit, 0xfffffff0);   \/\/ vector count (in bytes)\n+    jcc(Assembler::zero, COMPARE_TAIL);\n+\n+    lea(ary1, Address(ary1, limit, Address::times_1));\n+    lea(ary2, Address(ary2, limit, Address::times_1));\n+    negptr(limit);\n+\n+    bind(COMPARE_WIDE_VECTORS);\n+    movdqu(vec1, Address(ary1, limit, Address::times_1));\n+    movdqu(vec2, Address(ary2, limit, Address::times_1));\n+    pxor(vec1, vec2);\n+\n+    ptest(vec1, vec1);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    addptr(limit, 16);\n+    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n+\n+    testl(result, result);\n+    jcc(Assembler::zero, TRUE_LABEL);\n+\n+    movdqu(vec1, Address(ary1, result, Address::times_1, -16));\n+    movdqu(vec2, Address(ary2, result, Address::times_1, -16));\n+    pxor(vec1, vec2);\n+\n+    ptest(vec1, vec1);\n+    jccb(Assembler::notZero, FALSE_LABEL);\n+    jmpb(TRUE_LABEL);\n+\n+    bind(COMPARE_TAIL); \/\/ limit is zero\n+    movl(limit, result);\n+    \/\/ Fallthru to tail compare\n+  }\n+\n+  \/\/ Compare 4-byte vectors\n+  if (expand_ary2) {\n+    testl(result, result);\n+    jccb(Assembler::zero, TRUE_LABEL);\n+  } else {\n+    andl(limit, 0xfffffffc); \/\/ vector count (in bytes)\n+    jccb(Assembler::zero, COMPARE_CHAR);\n+  }\n+\n+  lea(ary1, Address(ary1, limit, expand_ary2 ? Address::times_2 : Address::times_1));\n+  lea(ary2, Address(ary2, limit, Address::times_1));\n+  negptr(limit);\n+\n+  bind(COMPARE_VECTORS);\n+  if (expand_ary2) {\n+    \/\/ There are no \"vector\" operations for bytes to shorts\n+    movzbl(chr, Address(ary2, limit, Address::times_1));\n+    cmpw(Address(ary1, limit, Address::times_2), chr);\n+    jccb(Assembler::notEqual, FALSE_LABEL);\n+    addptr(limit, 1);\n+    jcc(Assembler::notZero, COMPARE_VECTORS);\n+    jmp(TRUE_LABEL);\n+  } else {\n+    movl(chr, Address(ary1, limit,\n+                      expand_ary2 ? Address::times_2 : Address::times_1));\n+    cmpl(chr, Address(ary2, limit, Address::times_1));\n+    jccb(Assembler::notEqual, FALSE_LABEL);\n+    addptr(limit, 4);\n+    jcc(Assembler::notZero, COMPARE_VECTORS);\n+  }\n+\n+  \/\/ Compare trailing char (final 2 bytes), if any\n+  bind(COMPARE_CHAR);\n+  testl(result, 0x2);   \/\/ tail  char\n+  jccb(Assembler::zero, COMPARE_BYTE);\n+  load_unsigned_short(chr, Address(ary1, 0));\n+  load_unsigned_short(limit, Address(ary2, 0));\n+  cmpl(chr, limit);\n+  jccb(Assembler::notEqual, FALSE_LABEL);\n+\n+  if (is_array_equ && is_char) {\n+    bind(COMPARE_BYTE);\n+  } else {\n+    lea(ary1, Address(ary1, expand_ary2 ? 4 : 2));\n+    lea(ary2, Address(ary2, 2));\n+\n+    bind(COMPARE_BYTE);\n+    testl(result, 0x1);   \/\/ tail  byte\n+    jccb(Assembler::zero, TRUE_LABEL);\n+    load_unsigned_byte(chr, Address(ary1, 0));\n+    load_unsigned_byte(limit, Address(ary2, 0));\n+    cmpl(chr, limit);\n+    jccb(Assembler::notEqual, FALSE_LABEL);\n+  }\n+  bind(TRUE_LABEL);\n+  movl(result, 1);   \/\/ return true\n+  jmpb(DONE);\n+\n+  bind(FALSE_LABEL);\n+  xorl(result, result); \/\/ return false\n+\n+  \/\/ That's it\n+  bind(DONE);\n+  if (UseAVX >= 2) {\n+    \/\/ clean upper bits of YMM registers\n+    vpxor(vec1, vec1);\n+    vpxor(vec2, vec2);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":276,"deletions":0,"binary":false,"changes":276,"status":"modified"},{"patch":"@@ -293,0 +293,6 @@\n+  \/\/ Compare char[] or byte[] arrays.\n+  void arrays_equals(bool is_array_equ, Register ary1, Register ary2,\n+                     Register limit, Register result, Register chr,\n+                     XMMRegister vec1, XMMRegister vec2, bool is_char,\n+                     KRegister mask = knoreg, bool expand_ary2 = false);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -10381,276 +10381,0 @@\n-\n-\/\/ Compare char[] or byte[] arrays aligned to 4 bytes or substrings.\n-void MacroAssembler::arrays_equals(bool is_array_equ, Register ary1,\n-                                   Register ary2, Register limit,\n-                                   Register result, Register chr,\n-                                   XMMRegister vec1, XMMRegister vec2,\n-                                   bool is_char, KRegister mask,\n-                                   bool expand_ary2) {\n-  \/\/ for expand_ary2, limit is the (smaller) size of the second array.\n-  ShortBranchVerifier sbv(this);\n-  Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_VECTORS, COMPARE_CHAR, COMPARE_BYTE;\n-\n-  assert((!expand_ary2) || ((expand_ary2) && (UseAVX == 2)),\n-         \"Expansion only implemented for AVX2\");\n-\n-  int length_offset  = arrayOopDesc::length_offset_in_bytes();\n-  int base_offset    = arrayOopDesc::base_offset_in_bytes(is_char ? T_CHAR : T_BYTE);\n-\n-  if (is_array_equ) {\n-    \/\/ Check the input args\n-    cmpoop(ary1, ary2);\n-    jcc(Assembler::equal, TRUE_LABEL);\n-\n-    \/\/ Need additional checks for arrays_equals.\n-    testptr(ary1, ary1);\n-    jcc(Assembler::zero, FALSE_LABEL);\n-    testptr(ary2, ary2);\n-    jcc(Assembler::zero, FALSE_LABEL);\n-\n-    \/\/ Check the lengths\n-    movl(limit, Address(ary1, length_offset));\n-    cmpl(limit, Address(ary2, length_offset));\n-    jcc(Assembler::notEqual, FALSE_LABEL);\n-  }\n-\n-  \/\/ count == 0\n-  testl(limit, limit);\n-  jcc(Assembler::zero, TRUE_LABEL);\n-\n-  if (is_array_equ) {\n-    \/\/ Load array address\n-    lea(ary1, Address(ary1, base_offset));\n-    lea(ary2, Address(ary2, base_offset));\n-  }\n-\n-  if (is_array_equ && is_char) {\n-    \/\/ arrays_equals when used for char[].\n-    shll(limit, 1);      \/\/ byte count != 0\n-  }\n-  movl(result, limit); \/\/ copy\n-\n-  if (UseAVX >= 2) {\n-    \/\/ With AVX2, use 32-byte vector compare\n-    Label COMPARE_WIDE_VECTORS, COMPARE_WIDE_VECTORS_16, COMPARE_TAIL, COMPARE_TAIL_16;\n-\n-    \/\/ Compare 32-byte vectors\n-    andl(result, 0x0000001f);  \/\/   tail count (in bytes)\n-    andl(limit, 0xffffffe0);   \/\/ vector count (in bytes)\n-    jcc(Assembler::zero, COMPARE_TAIL_16);\n-\n-    lea(ary1, Address(ary1, limit,\n-                      expand_ary2 ? Address::times_2 : Address::times_1));\n-    lea(ary2, Address(ary2, limit, Address::times_1));\n-    negptr(limit);\n-\n-#ifdef _LP64\n-    if ((AVX3Threshold == 0) && VM_Version::supports_avx512vlbw()) { \/\/ trying 64 bytes fast loop\n-      Label COMPARE_WIDE_VECTORS_LOOP_AVX2, COMPARE_WIDE_VECTORS_LOOP_AVX3;\n-\n-      cmpl(limit, -64);\n-      jcc(Assembler::greater, COMPARE_WIDE_VECTORS_LOOP_AVX2);\n-\n-      bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); \/\/ the hottest loop\n-\n-      evmovdquq(vec1, Address(ary1, limit, Address::times_1), Assembler::AVX_512bit);\n-      evpcmpeqb(mask, vec1, Address(ary2, limit, Address::times_1), Assembler::AVX_512bit);\n-      kortestql(mask, mask);\n-      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n-      addptr(limit, 64);  \/\/ update since we already compared at this addr\n-      cmpl(limit, -64);\n-      jccb(Assembler::lessEqual, COMPARE_WIDE_VECTORS_LOOP_AVX3);\n-\n-      \/\/ At this point we may still need to compare -limit+result bytes.\n-      \/\/ We could execute the next two instruction and just continue via non-wide path:\n-      \/\/  cmpl(limit, 0);\n-      \/\/  jcc(Assembler::equal, COMPARE_TAIL);  \/\/ true\n-      \/\/ But since we stopped at the points ary{1,2}+limit which are\n-      \/\/ not farther than 64 bytes from the ends of arrays ary{1,2}+result\n-      \/\/ (|limit| <= 32 and result < 32),\n-      \/\/ we may just compare the last 64 bytes.\n-      \/\/\n-      addptr(result, -64);   \/\/ it is safe, bc we just came from this area\n-      evmovdquq(vec1, Address(ary1, result, Address::times_1), Assembler::AVX_512bit);\n-      evpcmpeqb(mask, vec1, Address(ary2, result, Address::times_1), Assembler::AVX_512bit);\n-      kortestql(mask, mask);\n-      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n-\n-      jmp(TRUE_LABEL);\n-\n-      bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);\n-\n-    }\/\/if (VM_Version::supports_avx512vlbw())\n-#endif \/\/_LP64\n-    bind(COMPARE_WIDE_VECTORS);\n-    vmovdqu(vec1, Address(ary1, limit,\n-                          expand_ary2 ? Address::times_2 : Address::times_1));\n-    if (expand_ary2) {\n-      vpmovzxbw(vec2, Address(ary2, limit, Address::times_1),\n-                Assembler::AVX_256bit);\n-    } else {\n-      vmovdqu(vec2, Address(ary2, limit, Address::times_1));\n-    }\n-    vpxor(vec1, vec2);\n-\n-    vptest(vec1, vec1);\n-    jcc(Assembler::notZero, FALSE_LABEL);\n-    addptr(limit, expand_ary2 ? 16 : 32);\n-    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n-\n-    testl(result, result);\n-    jcc(Assembler::zero, TRUE_LABEL);\n-\n-    vmovdqu(vec1,\n-            Address(ary1, result,\n-                    expand_ary2 ? Address::times_2 : Address::times_1, -32));\n-    if (expand_ary2) {\n-      vpmovzxbw(vec2, Address(ary2, result, Address::times_1, -16),\n-                Assembler::AVX_256bit);\n-    } else {\n-      vmovdqu(vec2, Address(ary2, result, Address::times_1, -32));\n-    }\n-    vpxor(vec1, vec2);\n-\n-    vptest(vec1, vec1);\n-    jcc(Assembler::notZero, FALSE_LABEL);\n-    jmp(TRUE_LABEL);\n-\n-    bind(COMPARE_TAIL_16); \/\/ limit is zero\n-    movl(limit, result);\n-\n-    \/\/ Compare 16-byte chunks\n-    andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n-    andl(limit, 0xfffffff0);   \/\/ vector count (in bytes)\n-    jcc(Assembler::zero, COMPARE_TAIL);\n-\n-    lea(ary1, Address(ary1, limit, expand_ary2 ? Address::times_2 : Address::times_1));\n-    lea(ary2, Address(ary2, limit, Address::times_1));\n-    negptr(limit);\n-\n-    bind(COMPARE_WIDE_VECTORS_16);\n-    movdqu(vec1, Address(ary1, limit,\n-                         expand_ary2 ? Address::times_2 : Address::times_1));\n-    if (expand_ary2) {\n-      vpmovzxbw(vec2, Address(ary2, limit, Address::times_1),\n-                Assembler::AVX_128bit);\n-    } else {\n-      movdqu(vec2, Address(ary2, limit, Address::times_1));\n-    }\n-    vpxor(vec1, vec2);\n-\n-    vptest(vec1, vec1);\n-    jcc(Assembler::notZero, FALSE_LABEL);\n-    addptr(limit, expand_ary2 ? 8 : 16);\n-    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS_16);\n-\n-    bind(COMPARE_TAIL); \/\/ limit is zero\n-    movl(limit, result);\n-    \/\/ Fallthru to tail compare\n-  } else if (UseSSE42Intrinsics) {\n-    \/\/ With SSE4.2, use double quad vector compare\n-    Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n-\n-    \/\/ Compare 16-byte vectors\n-    andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n-    andl(limit, 0xfffffff0);   \/\/ vector count (in bytes)\n-    jcc(Assembler::zero, COMPARE_TAIL);\n-\n-    lea(ary1, Address(ary1, limit, Address::times_1));\n-    lea(ary2, Address(ary2, limit, Address::times_1));\n-    negptr(limit);\n-\n-    bind(COMPARE_WIDE_VECTORS);\n-    movdqu(vec1, Address(ary1, limit, Address::times_1));\n-    movdqu(vec2, Address(ary2, limit, Address::times_1));\n-    pxor(vec1, vec2);\n-\n-    ptest(vec1, vec1);\n-    jcc(Assembler::notZero, FALSE_LABEL);\n-    addptr(limit, 16);\n-    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n-\n-    testl(result, result);\n-    jcc(Assembler::zero, TRUE_LABEL);\n-\n-    movdqu(vec1, Address(ary1, result, Address::times_1, -16));\n-    movdqu(vec2, Address(ary2, result, Address::times_1, -16));\n-    pxor(vec1, vec2);\n-\n-    ptest(vec1, vec1);\n-    jccb(Assembler::notZero, FALSE_LABEL);\n-    jmpb(TRUE_LABEL);\n-\n-    bind(COMPARE_TAIL); \/\/ limit is zero\n-    movl(limit, result);\n-    \/\/ Fallthru to tail compare\n-  }\n-\n-  \/\/ Compare 4-byte vectors\n-  if (expand_ary2) {\n-    testl(result, result);\n-    jccb(Assembler::zero, TRUE_LABEL);\n-  } else {\n-    andl(limit, 0xfffffffc); \/\/ vector count (in bytes)\n-    jccb(Assembler::zero, COMPARE_CHAR);\n-  }\n-\n-  lea(ary1, Address(ary1, limit, expand_ary2 ? Address::times_2 : Address::times_1));\n-  lea(ary2, Address(ary2, limit, Address::times_1));\n-  negptr(limit);\n-\n-  bind(COMPARE_VECTORS);\n-  if (expand_ary2) {\n-    \/\/ There are no \"vector\" operations for bytes to shorts\n-    movzbl(chr, Address(ary2, limit, Address::times_1));\n-    cmpw(Address(ary1, limit, Address::times_2), chr);\n-    jccb(Assembler::notEqual, FALSE_LABEL);\n-    addptr(limit, 1);\n-    jcc(Assembler::notZero, COMPARE_VECTORS);\n-    jmp(TRUE_LABEL);\n-  } else {\n-    movl(chr, Address(ary1, limit,\n-                      expand_ary2 ? Address::times_2 : Address::times_1));\n-    cmpl(chr, Address(ary2, limit, Address::times_1));\n-    jccb(Assembler::notEqual, FALSE_LABEL);\n-    addptr(limit, 4);\n-    jcc(Assembler::notZero, COMPARE_VECTORS);\n-  }\n-\n-  \/\/ Compare trailing char (final 2 bytes), if any\n-  bind(COMPARE_CHAR);\n-  testl(result, 0x2);   \/\/ tail  char\n-  jccb(Assembler::zero, COMPARE_BYTE);\n-  load_unsigned_short(chr, Address(ary1, 0));\n-  load_unsigned_short(limit, Address(ary2, 0));\n-  cmpl(chr, limit);\n-  jccb(Assembler::notEqual, FALSE_LABEL);\n-\n-  if (is_array_equ && is_char) {\n-    bind(COMPARE_BYTE);\n-  } else {\n-    lea(ary1, Address(ary1, expand_ary2 ? 4 : 2));\n-    lea(ary2, Address(ary2, 2));\n-\n-    bind(COMPARE_BYTE);\n-    testl(result, 0x1);   \/\/ tail  byte\n-    jccb(Assembler::zero, TRUE_LABEL);\n-    load_unsigned_byte(chr, Address(ary1, 0));\n-    load_unsigned_byte(limit, Address(ary2, 0));\n-    cmpl(chr, limit);\n-    jccb(Assembler::notEqual, FALSE_LABEL);\n-  }\n-  bind(TRUE_LABEL);\n-  movl(result, 1);   \/\/ return true\n-  jmpb(DONE);\n-\n-  bind(FALSE_LABEL);\n-  xorl(result, result); \/\/ return false\n-\n-  \/\/ That's it\n-  bind(DONE);\n-  if (UseAVX >= 2) {\n-    \/\/ clean upper bits of YMM registers\n-    vpxor(vec1, vec1);\n-    vpxor(vec2, vec2);\n-  }\n-}\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":276,"binary":false,"changes":276,"status":"modified"},{"patch":"@@ -249,6 +249,0 @@\n-  \/\/ Compare char[] or byte[] arrays.\n-  void arrays_equals(bool is_array_equ, Register ary1, Register ary2,\n-                     Register limit, Register result, Register chr,\n-                     XMMRegister vec1, XMMRegister vec2, bool is_char,\n-                     KRegister mask = knoreg, bool expand_ary2 = false);\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"}]}