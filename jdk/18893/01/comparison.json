{"files":[{"patch":"@@ -1761,0 +1761,16 @@\n+void Assembler::cmpb(Address dst, Register reg) {\n+  assert(reg->has_byte_register(), \"must have byte register\");\n+  InstructionMark im(this);\n+  prefix(dst, reg, true);\n+  emit_int8((unsigned char)0x38);\n+  emit_operand(reg, dst, 0);\n+}\n+\n+void Assembler::cmpb(Register reg, Address dst) {\n+  assert(reg->has_byte_register(), \"must have byte register\");\n+  InstructionMark im(this);\n+  prefix(dst, reg, true);\n+  emit_int8((unsigned char)0x3a);\n+  emit_operand(reg, dst, 0);\n+}\n+\n@@ -1792,0 +1808,7 @@\n+void Assembler::cmpl(Address dst,  Register reg) {\n+  InstructionMark im(this);\n+  prefix(dst, reg);\n+  emit_int8(0x39);\n+  emit_operand(reg, dst, 0);\n+}\n+\n@@ -1807,0 +1830,8 @@\n+void Assembler::cmpw(Address dst, Register reg) {\n+  InstructionMark im(this);\n+  emit_int8(0x66);\n+  prefix(dst, reg);\n+  emit_int8((unsigned char)0x39);\n+  emit_operand(reg, dst, 1);\n+}\n+\n@@ -4428,0 +4459,9 @@\n+void Assembler::vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() : VM_Version::supports_avx2(), \"\");\n+  assert(vector_len <= AVX_256bit, \"evex encoding is different - has k register as dest\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(src2, src1->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x74);\n+  emit_operand(dst, src2, 0);\n+}\n+\n@@ -4534,0 +4574,10 @@\n+\/\/ In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst\n+void Assembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() : VM_Version::supports_avx2(), \"\");\n+  assert(vector_len <= AVX_256bit, \"evex encoding is different - has k register as dest\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x75);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -7651,0 +7701,8 @@\n+void Assembler::vpminub(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_avx512bw()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0xDA, (0xC0 | encode));\n+}\n+\n@@ -12276,0 +12334,7 @@\n+void Assembler::bzhil(Register dst, Register src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"bit manipulation instructions not supported\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0xF5, (0xC0 | encode));\n+}\n+\n@@ -13170,0 +13235,4 @@\n+void Assembler::cdqe() {\n+  emit_int16(REX_W, (unsigned char)0x98);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -1097,0 +1097,1 @@\n+  void cdqe();\n@@ -1112,0 +1113,2 @@\n+  void cmpb(Address dst, Register reg);\n+  void cmpb(Register reg, Address dst);\n@@ -1118,0 +1121,1 @@\n+  void cmpl(Address dst,  Register reg);\n@@ -1126,0 +1130,1 @@\n+  void cmpw(Address dst, Register reg);\n@@ -1805,0 +1810,1 @@\n+  void vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n@@ -1819,0 +1825,1 @@\n+  void vpcmpeqw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n@@ -2309,0 +2316,1 @@\n+  void bzhil(Register dst, Register src1, Register src2);\n@@ -2584,0 +2592,1 @@\n+  void vpminub(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4492,3 +4492,7 @@\n-void C2_MacroAssembler::arrays_equals(bool is_array_equ, Register ary1, Register ary2,\n-                                      Register limit, Register result, Register chr,\n-                                      XMMRegister vec1, XMMRegister vec2, bool is_char, KRegister mask) {\n+void C2_MacroAssembler::arrays_equals(bool is_array_equ, Register ary1,\n+                                      Register ary2, Register limit,\n+                                      Register result, Register chr,\n+                                      XMMRegister vec1, XMMRegister vec2,\n+                                      bool is_char, KRegister mask,\n+                                      bool expand_ary2) {\n+  \/\/ for expand_ary2, limit is the (smaller) size of the second array.\n@@ -4498,0 +4502,3 @@\n+  assert((!expand_ary2) || ((expand_ary2) && (UseAVX == 2)),\n+         \"Expansion only implemented for AVX2\");\n+\n@@ -4536,1 +4543,1 @@\n-    Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n+    Label COMPARE_WIDE_VECTORS, COMPARE_WIDE_VECTORS_16, COMPARE_TAIL, COMPARE_TAIL_16;\n@@ -4541,1 +4548,1 @@\n-    jcc(Assembler::zero, COMPARE_TAIL);\n+    jcc(Assembler::zero, COMPARE_TAIL_16);\n@@ -4543,1 +4550,2 @@\n-    lea(ary1, Address(ary1, limit, Address::times_1));\n+    lea(ary1, Address(ary1, limit,\n+                      expand_ary2 ? Address::times_2 : Address::times_1));\n@@ -4586,2 +4594,8 @@\n-    vmovdqu(vec1, Address(ary1, limit, Address::times_1));\n-    vmovdqu(vec2, Address(ary2, limit, Address::times_1));\n+    vmovdqu(vec1, Address(ary1, limit,\n+                          expand_ary2 ? Address::times_2 : Address::times_1));\n+    if (expand_ary2) {\n+      vpmovzxbw(vec2, Address(ary2, limit, Address::times_1),\n+                Assembler::AVX_256bit);\n+    } else {\n+      vmovdqu(vec2, Address(ary2, limit, Address::times_1));\n+    }\n@@ -4592,1 +4606,1 @@\n-    addptr(limit, 32);\n+    addptr(limit, expand_ary2 ? 16 : 32);\n@@ -4598,2 +4612,9 @@\n-    vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));\n-    vmovdqu(vec2, Address(ary2, result, Address::times_1, -32));\n+    vmovdqu(vec1,\n+            Address(ary1, result,\n+                    expand_ary2 ? Address::times_2 : Address::times_1, -32));\n+    if (expand_ary2) {\n+      vpmovzxbw(vec2, Address(ary2, result, Address::times_1, -16),\n+                Assembler::AVX_256bit);\n+    } else {\n+      vmovdqu(vec2, Address(ary2, result, Address::times_1, -32));\n+    }\n@@ -4603,2 +4624,30 @@\n-    jccb(Assembler::notZero, FALSE_LABEL);\n-    jmpb(TRUE_LABEL);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    jmp(TRUE_LABEL);\n+\n+    bind(COMPARE_TAIL_16); \/\/ limit is zero\n+    movl(limit, result);\n+\n+    \/\/ Compare 16-byte chunks\n+    andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n+    andl(limit, 0xfffffff0);   \/\/ vector count (in bytes)\n+    jcc(Assembler::zero, COMPARE_TAIL);\n+\n+    lea(ary1, Address(ary1, limit, expand_ary2 ? Address::times_2 : Address::times_1));\n+    lea(ary2, Address(ary2, limit, Address::times_1));\n+    negptr(limit);\n+\n+    bind(COMPARE_WIDE_VECTORS_16);\n+    movdqu(vec1, Address(ary1, limit,\n+                         expand_ary2 ? Address::times_2 : Address::times_1));\n+    if (expand_ary2) {\n+      vpmovzxbw(vec2, Address(ary2, limit, Address::times_1),\n+                Assembler::AVX_128bit);\n+    } else {\n+      movdqu(vec2, Address(ary2, limit, Address::times_1));\n+    }\n+    vpxor(vec1, vec2);\n+\n+    vptest(vec1, vec1);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    addptr(limit, expand_ary2 ? 8 : 16);\n+    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS_16);\n@@ -4649,2 +4698,7 @@\n-  andl(limit, 0xfffffffc); \/\/ vector count (in bytes)\n-  jccb(Assembler::zero, COMPARE_CHAR);\n+  if (expand_ary2) {\n+    testl(result, result);\n+    jccb(Assembler::zero, TRUE_LABEL);\n+  } else {\n+    andl(limit, 0xfffffffc); \/\/ vector count (in bytes)\n+    jccb(Assembler::zero, COMPARE_CHAR);\n+  }\n@@ -4652,1 +4706,1 @@\n-  lea(ary1, Address(ary1, limit, Address::times_1));\n+  lea(ary1, Address(ary1, limit, expand_ary2 ? Address::times_2 : Address::times_1));\n@@ -4657,5 +4711,16 @@\n-  movl(chr, Address(ary1, limit, Address::times_1));\n-  cmpl(chr, Address(ary2, limit, Address::times_1));\n-  jccb(Assembler::notEqual, FALSE_LABEL);\n-  addptr(limit, 4);\n-  jcc(Assembler::notZero, COMPARE_VECTORS);\n+  if (expand_ary2) {\n+    \/\/ There are no \"vector\" operations for bytes to shorts\n+    movzbl(chr, Address(ary2, limit, Address::times_1));\n+    cmpw(Address(ary1, limit, Address::times_2), chr);\n+    jccb(Assembler::notEqual, FALSE_LABEL);\n+    addptr(limit, 1);\n+    jcc(Assembler::notZero, COMPARE_VECTORS);\n+    jmp(TRUE_LABEL);\n+  } else {\n+    movl(chr, Address(ary1, limit,\n+                      expand_ary2 ? Address::times_2 : Address::times_1));\n+    cmpl(chr, Address(ary2, limit, Address::times_1));\n+    jccb(Assembler::notEqual, FALSE_LABEL);\n+    addptr(limit, 4);\n+    jcc(Assembler::notZero, COMPARE_VECTORS);\n+  }\n@@ -4675,1 +4740,1 @@\n-    lea(ary1, Address(ary1, 2));\n+    lea(ary1, Address(ary1, expand_ary2 ? 4 : 2));\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":87,"deletions":22,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -292,0 +292,1 @@\n+\n@@ -295,1 +296,2 @@\n-                     XMMRegister vec1, XMMRegister vec2, bool is_char, KRegister mask = knoreg);\n+                     XMMRegister vec1, XMMRegister vec2, bool is_char,\n+                     KRegister mask = knoreg, bool expand_ary2 = false);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3573,0 +3573,4 @@\n+void MacroAssembler::vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {\n+  Assembler::vpcmpeqb(dst, src1, src2, vector_len);\n+}\n+\n@@ -3578,0 +3582,5 @@\n+void MacroAssembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(((dst->encoding() < 16 && nds->encoding() < 16) || VM_Version::supports_avx512vlbw()),\"XMM register should be 0-15\");\n+  Assembler::vpcmpeqw(dst, nds, src, vector_len);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -958,0 +958,68 @@\n+  \/\/ Adding more natural conditional jump instructions\n+  void ALWAYSINLINE jo(Label& L, bool maybe_short = true) { jcc(Assembler::overflow, L, maybe_short); }\n+  void ALWAYSINLINE jno(Label& L, bool maybe_short = true) { jcc(Assembler::noOverflow, L, maybe_short); }\n+  void ALWAYSINLINE js(Label& L, bool maybe_short = true) { jcc(Assembler::positive, L, maybe_short); }\n+  void ALWAYSINLINE jns(Label& L, bool maybe_short = true) { jcc(Assembler::negative, L, maybe_short); }\n+  void ALWAYSINLINE je(Label& L, bool maybe_short = true) { jcc(Assembler::equal, L, maybe_short); }\n+  void ALWAYSINLINE jz(Label& L, bool maybe_short = true) { jcc(Assembler::zero, L, maybe_short); }\n+  void ALWAYSINLINE jne(Label& L, bool maybe_short = true) { jcc(Assembler::notEqual, L, maybe_short); }\n+  void ALWAYSINLINE jnz(Label& L, bool maybe_short = true) { jcc(Assembler::notZero, L, maybe_short); }\n+  void ALWAYSINLINE jb(Label& L, bool maybe_short = true) { jcc(Assembler::below, L, maybe_short); }\n+  void ALWAYSINLINE jnae(Label& L, bool maybe_short = true) { jcc(Assembler::below, L, maybe_short); }\n+  void ALWAYSINLINE jc(Label& L, bool maybe_short = true) { jcc(Assembler::carrySet, L, maybe_short); }\n+  void ALWAYSINLINE jnb(Label& L, bool maybe_short = true) { jcc(Assembler::aboveEqual, L, maybe_short); }\n+  void ALWAYSINLINE jae(Label& L, bool maybe_short = true) { jcc(Assembler::aboveEqual, L, maybe_short); }\n+  void ALWAYSINLINE jnc(Label& L, bool maybe_short = true) { jcc(Assembler::carryClear, L, maybe_short); }\n+  void ALWAYSINLINE jbe(Label& L, bool maybe_short = true) { jcc(Assembler::belowEqual, L, maybe_short); }\n+  void ALWAYSINLINE jna(Label& L, bool maybe_short = true) { jcc(Assembler::belowEqual, L, maybe_short); }\n+  void ALWAYSINLINE ja(Label& L, bool maybe_short = true) { jcc(Assembler::above, L, maybe_short); }\n+  void ALWAYSINLINE jnbe(Label& L, bool maybe_short = true) { jcc(Assembler::above, L, maybe_short); }\n+  void ALWAYSINLINE jl(Label& L, bool maybe_short = true) { jcc(Assembler::less, L, maybe_short); }\n+  void ALWAYSINLINE jnge(Label& L, bool maybe_short = true) { jcc(Assembler::less, L, maybe_short); }\n+  void ALWAYSINLINE jge(Label& L, bool maybe_short = true) { jcc(Assembler::greaterEqual, L, maybe_short); }\n+  void ALWAYSINLINE jnl(Label& L, bool maybe_short = true) { jcc(Assembler::greaterEqual, L, maybe_short); }\n+  void ALWAYSINLINE jle(Label& L, bool maybe_short = true) { jcc(Assembler::lessEqual, L, maybe_short); }\n+  void ALWAYSINLINE jng(Label& L, bool maybe_short = true) { jcc(Assembler::lessEqual, L, maybe_short); }\n+  void ALWAYSINLINE jg(Label& L, bool maybe_short = true) { jcc(Assembler::greater, L, maybe_short); }\n+  void ALWAYSINLINE jnle(Label& L, bool maybe_short = true) { jcc(Assembler::greater, L, maybe_short); }\n+  void ALWAYSINLINE jp(Label& L, bool maybe_short = true) { jcc(Assembler::parity, L, maybe_short); }\n+  void ALWAYSINLINE jpe(Label& L, bool maybe_short = true) { jcc(Assembler::parity, L, maybe_short); }\n+  void ALWAYSINLINE jnp(Label& L, bool maybe_short = true) { jcc(Assembler::noParity, L, maybe_short); }\n+  void ALWAYSINLINE jpo(Label& L, bool maybe_short = true) { jcc(Assembler::noParity, L, maybe_short); }\n+\/\/ * No condition for this *  void ALWAYSINLINE jcxz(Label& L, bool maybe_short = true) { jcc(Assembler::cxz, L, maybe_short); }\n+\/\/ * No condition for this *  void ALWAYSINLINE jecxz(Label& L, bool maybe_short = true) { jcc(Assembler::cxz, L, maybe_short); }\n+\n+\/\/ Short versions of the above\n+  void ALWAYSINLINE jo_b(Label& L) { jccb(Assembler::overflow, L); }\n+  void ALWAYSINLINE jno_b(Label& L) { jccb(Assembler::noOverflow, L); }\n+  void ALWAYSINLINE js_b(Label& L) { jccb(Assembler::positive, L); }\n+  void ALWAYSINLINE jns_b(Label& L) { jccb(Assembler::negative, L); }\n+  void ALWAYSINLINE je_b(Label& L) { jccb(Assembler::equal, L); }\n+  void ALWAYSINLINE jz_b(Label& L) { jccb(Assembler::zero, L); }\n+  void ALWAYSINLINE jne_b(Label& L) { jccb(Assembler::notEqual, L); }\n+  void ALWAYSINLINE jnz_b(Label& L) { jccb(Assembler::notZero, L); }\n+  void ALWAYSINLINE jb_b(Label& L) { jccb(Assembler::below, L); }\n+  void ALWAYSINLINE jnae_b(Label& L) { jccb(Assembler::below, L); }\n+  void ALWAYSINLINE jc_b(Label& L) { jccb(Assembler::carrySet, L); }\n+  void ALWAYSINLINE jnb_b(Label& L) { jccb(Assembler::aboveEqual, L); }\n+  void ALWAYSINLINE jae_b(Label& L) { jccb(Assembler::aboveEqual, L); }\n+  void ALWAYSINLINE jnc_b(Label& L) { jccb(Assembler::carryClear, L); }\n+  void ALWAYSINLINE jbe_b(Label& L) { jccb(Assembler::belowEqual, L); }\n+  void ALWAYSINLINE jna_b(Label& L) { jccb(Assembler::belowEqual, L); }\n+  void ALWAYSINLINE ja_b(Label& L) { jccb(Assembler::above, L); }\n+  void ALWAYSINLINE jnbe_b(Label& L) { jccb(Assembler::above, L); }\n+  void ALWAYSINLINE jl_b(Label& L) { jccb(Assembler::less, L); }\n+  void ALWAYSINLINE jnge_b(Label& L) { jccb(Assembler::less, L); }\n+  void ALWAYSINLINE jge_b(Label& L) { jccb(Assembler::greaterEqual, L); }\n+  void ALWAYSINLINE jnl_b(Label& L) { jccb(Assembler::greaterEqual, L); }\n+  void ALWAYSINLINE jle_b(Label& L) { jccb(Assembler::lessEqual, L); }\n+  void ALWAYSINLINE jng_b(Label& L) { jccb(Assembler::lessEqual, L); }\n+  void ALWAYSINLINE jg_b(Label& L) { jccb(Assembler::greater, L); }\n+  void ALWAYSINLINE jnle_b(Label& L) { jccb(Assembler::greater, L); }\n+  void ALWAYSINLINE jp_b(Label& L) { jccb(Assembler::parity, L); }\n+  void ALWAYSINLINE jpe_b(Label& L) { jccb(Assembler::parity, L); }\n+  void ALWAYSINLINE jnp_b(Label& L) { jccb(Assembler::noParity, L); }\n+  void ALWAYSINLINE jpo_b(Label& L) { jccb(Assembler::noParity, L); }\n+\/\/ * No condition for this *  void ALWAYSINLINE jcxz_b(Label& L) { jccb(Assembler::cxz, L); }\n+\/\/ * No condition for this *  void ALWAYSINLINE jecxz_b(Label& L) { jccb(Assembler::cxz, L); }\n+\n@@ -1392,0 +1460,1 @@\n+  void vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n@@ -1393,0 +1462,1 @@\n+  void vpcmpeqw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"}]}