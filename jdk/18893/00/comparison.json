{"files":[{"patch":"@@ -1761,0 +1761,16 @@\n+void Assembler::cmpb(Address dst, Register reg) {\n+  assert(reg->has_byte_register(), \"must have byte register\");\n+  InstructionMark im(this);\n+  prefix(dst, reg, true);\n+  emit_int8((unsigned char)0x38);\n+  emit_operand(reg, dst, 0);\n+}\n+\n+void Assembler::cmpb(Register reg, Address dst) {\n+  assert(reg->has_byte_register(), \"must have byte register\");\n+  InstructionMark im(this);\n+  prefix(dst, reg, true);\n+  emit_int8((unsigned char)0x3a);\n+  emit_operand(reg, dst, 0);\n+}\n+\n@@ -1792,0 +1808,7 @@\n+void Assembler::cmpl(Address dst,  Register reg) {\n+  InstructionMark im(this);\n+  prefix(dst, reg);\n+  emit_int8(0x39);\n+  emit_operand(reg, dst, 0);\n+}\n+\n@@ -1807,0 +1830,8 @@\n+void Assembler::cmpw(Address dst, Register reg) {\n+  InstructionMark im(this);\n+  emit_int8(0x66);\n+  prefix(dst, reg);\n+  emit_int8((unsigned char)0x39);\n+  emit_operand(reg, dst, 1);\n+}\n+\n@@ -4428,0 +4459,9 @@\n+void Assembler::vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() : VM_Version::supports_avx2(), \"\");\n+  assert(vector_len <= AVX_256bit, \"evex encoding is different - has k register as dest\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(src2, src1->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x74);\n+  emit_operand(dst, src2, 0);\n+}\n+\n@@ -4534,0 +4574,10 @@\n+\/\/ In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst\n+void Assembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() : VM_Version::supports_avx2(), \"\");\n+  assert(vector_len <= AVX_256bit, \"evex encoding is different - has k register as dest\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x75);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -7651,0 +7701,8 @@\n+void Assembler::vpminub(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_avx512bw()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0xDA, (0xC0 | encode));\n+}\n+\n@@ -12276,0 +12334,7 @@\n+void Assembler::bzhil(Register dst, Register src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"bit manipulation instructions not supported\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0xF5, (0xC0 | encode));\n+}\n+\n@@ -13170,0 +13235,4 @@\n+void Assembler::cdqe() {\n+  emit_int16(REX_W, (unsigned char)0x98);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -1097,0 +1097,1 @@\n+  void cdqe();\n@@ -1112,0 +1113,2 @@\n+  void cmpb(Address dst, Register reg);\n+  void cmpb(Register reg, Address dst);\n@@ -1118,0 +1121,1 @@\n+  void cmpl(Address dst,  Register reg);\n@@ -1126,0 +1130,1 @@\n+  void cmpw(Address dst, Register reg);\n@@ -1805,0 +1810,1 @@\n+  void vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n@@ -1819,0 +1825,1 @@\n+  void vpcmpeqw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n@@ -2309,0 +2316,1 @@\n+  void bzhil(Register dst, Register src1, Register src2);\n@@ -2584,0 +2592,1 @@\n+  void vpminub(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4491,211 +4491,0 @@\n-\/\/ Compare char[] or byte[] arrays aligned to 4 bytes or substrings.\n-void C2_MacroAssembler::arrays_equals(bool is_array_equ, Register ary1, Register ary2,\n-                                      Register limit, Register result, Register chr,\n-                                      XMMRegister vec1, XMMRegister vec2, bool is_char, KRegister mask) {\n-  ShortBranchVerifier sbv(this);\n-  Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_VECTORS, COMPARE_CHAR, COMPARE_BYTE;\n-\n-  int length_offset  = arrayOopDesc::length_offset_in_bytes();\n-  int base_offset    = arrayOopDesc::base_offset_in_bytes(is_char ? T_CHAR : T_BYTE);\n-\n-  if (is_array_equ) {\n-    \/\/ Check the input args\n-    cmpoop(ary1, ary2);\n-    jcc(Assembler::equal, TRUE_LABEL);\n-\n-    \/\/ Need additional checks for arrays_equals.\n-    testptr(ary1, ary1);\n-    jcc(Assembler::zero, FALSE_LABEL);\n-    testptr(ary2, ary2);\n-    jcc(Assembler::zero, FALSE_LABEL);\n-\n-    \/\/ Check the lengths\n-    movl(limit, Address(ary1, length_offset));\n-    cmpl(limit, Address(ary2, length_offset));\n-    jcc(Assembler::notEqual, FALSE_LABEL);\n-  }\n-\n-  \/\/ count == 0\n-  testl(limit, limit);\n-  jcc(Assembler::zero, TRUE_LABEL);\n-\n-  if (is_array_equ) {\n-    \/\/ Load array address\n-    lea(ary1, Address(ary1, base_offset));\n-    lea(ary2, Address(ary2, base_offset));\n-  }\n-\n-  if (is_array_equ && is_char) {\n-    \/\/ arrays_equals when used for char[].\n-    shll(limit, 1);      \/\/ byte count != 0\n-  }\n-  movl(result, limit); \/\/ copy\n-\n-  if (UseAVX >= 2) {\n-    \/\/ With AVX2, use 32-byte vector compare\n-    Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n-\n-    \/\/ Compare 32-byte vectors\n-    andl(result, 0x0000001f);  \/\/   tail count (in bytes)\n-    andl(limit, 0xffffffe0);   \/\/ vector count (in bytes)\n-    jcc(Assembler::zero, COMPARE_TAIL);\n-\n-    lea(ary1, Address(ary1, limit, Address::times_1));\n-    lea(ary2, Address(ary2, limit, Address::times_1));\n-    negptr(limit);\n-\n-#ifdef _LP64\n-    if ((AVX3Threshold == 0) && VM_Version::supports_avx512vlbw()) { \/\/ trying 64 bytes fast loop\n-      Label COMPARE_WIDE_VECTORS_LOOP_AVX2, COMPARE_WIDE_VECTORS_LOOP_AVX3;\n-\n-      cmpl(limit, -64);\n-      jcc(Assembler::greater, COMPARE_WIDE_VECTORS_LOOP_AVX2);\n-\n-      bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); \/\/ the hottest loop\n-\n-      evmovdquq(vec1, Address(ary1, limit, Address::times_1), Assembler::AVX_512bit);\n-      evpcmpeqb(mask, vec1, Address(ary2, limit, Address::times_1), Assembler::AVX_512bit);\n-      kortestql(mask, mask);\n-      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n-      addptr(limit, 64);  \/\/ update since we already compared at this addr\n-      cmpl(limit, -64);\n-      jccb(Assembler::lessEqual, COMPARE_WIDE_VECTORS_LOOP_AVX3);\n-\n-      \/\/ At this point we may still need to compare -limit+result bytes.\n-      \/\/ We could execute the next two instruction and just continue via non-wide path:\n-      \/\/  cmpl(limit, 0);\n-      \/\/  jcc(Assembler::equal, COMPARE_TAIL);  \/\/ true\n-      \/\/ But since we stopped at the points ary{1,2}+limit which are\n-      \/\/ not farther than 64 bytes from the ends of arrays ary{1,2}+result\n-      \/\/ (|limit| <= 32 and result < 32),\n-      \/\/ we may just compare the last 64 bytes.\n-      \/\/\n-      addptr(result, -64);   \/\/ it is safe, bc we just came from this area\n-      evmovdquq(vec1, Address(ary1, result, Address::times_1), Assembler::AVX_512bit);\n-      evpcmpeqb(mask, vec1, Address(ary2, result, Address::times_1), Assembler::AVX_512bit);\n-      kortestql(mask, mask);\n-      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n-\n-      jmp(TRUE_LABEL);\n-\n-      bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);\n-\n-    }\/\/if (VM_Version::supports_avx512vlbw())\n-#endif \/\/_LP64\n-    bind(COMPARE_WIDE_VECTORS);\n-    vmovdqu(vec1, Address(ary1, limit, Address::times_1));\n-    vmovdqu(vec2, Address(ary2, limit, Address::times_1));\n-    vpxor(vec1, vec2);\n-\n-    vptest(vec1, vec1);\n-    jcc(Assembler::notZero, FALSE_LABEL);\n-    addptr(limit, 32);\n-    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n-\n-    testl(result, result);\n-    jcc(Assembler::zero, TRUE_LABEL);\n-\n-    vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));\n-    vmovdqu(vec2, Address(ary2, result, Address::times_1, -32));\n-    vpxor(vec1, vec2);\n-\n-    vptest(vec1, vec1);\n-    jccb(Assembler::notZero, FALSE_LABEL);\n-    jmpb(TRUE_LABEL);\n-\n-    bind(COMPARE_TAIL); \/\/ limit is zero\n-    movl(limit, result);\n-    \/\/ Fallthru to tail compare\n-  } else if (UseSSE42Intrinsics) {\n-    \/\/ With SSE4.2, use double quad vector compare\n-    Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n-\n-    \/\/ Compare 16-byte vectors\n-    andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n-    andl(limit, 0xfffffff0);   \/\/ vector count (in bytes)\n-    jcc(Assembler::zero, COMPARE_TAIL);\n-\n-    lea(ary1, Address(ary1, limit, Address::times_1));\n-    lea(ary2, Address(ary2, limit, Address::times_1));\n-    negptr(limit);\n-\n-    bind(COMPARE_WIDE_VECTORS);\n-    movdqu(vec1, Address(ary1, limit, Address::times_1));\n-    movdqu(vec2, Address(ary2, limit, Address::times_1));\n-    pxor(vec1, vec2);\n-\n-    ptest(vec1, vec1);\n-    jcc(Assembler::notZero, FALSE_LABEL);\n-    addptr(limit, 16);\n-    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n-\n-    testl(result, result);\n-    jcc(Assembler::zero, TRUE_LABEL);\n-\n-    movdqu(vec1, Address(ary1, result, Address::times_1, -16));\n-    movdqu(vec2, Address(ary2, result, Address::times_1, -16));\n-    pxor(vec1, vec2);\n-\n-    ptest(vec1, vec1);\n-    jccb(Assembler::notZero, FALSE_LABEL);\n-    jmpb(TRUE_LABEL);\n-\n-    bind(COMPARE_TAIL); \/\/ limit is zero\n-    movl(limit, result);\n-    \/\/ Fallthru to tail compare\n-  }\n-\n-  \/\/ Compare 4-byte vectors\n-  andl(limit, 0xfffffffc); \/\/ vector count (in bytes)\n-  jccb(Assembler::zero, COMPARE_CHAR);\n-\n-  lea(ary1, Address(ary1, limit, Address::times_1));\n-  lea(ary2, Address(ary2, limit, Address::times_1));\n-  negptr(limit);\n-\n-  bind(COMPARE_VECTORS);\n-  movl(chr, Address(ary1, limit, Address::times_1));\n-  cmpl(chr, Address(ary2, limit, Address::times_1));\n-  jccb(Assembler::notEqual, FALSE_LABEL);\n-  addptr(limit, 4);\n-  jcc(Assembler::notZero, COMPARE_VECTORS);\n-\n-  \/\/ Compare trailing char (final 2 bytes), if any\n-  bind(COMPARE_CHAR);\n-  testl(result, 0x2);   \/\/ tail  char\n-  jccb(Assembler::zero, COMPARE_BYTE);\n-  load_unsigned_short(chr, Address(ary1, 0));\n-  load_unsigned_short(limit, Address(ary2, 0));\n-  cmpl(chr, limit);\n-  jccb(Assembler::notEqual, FALSE_LABEL);\n-\n-  if (is_array_equ && is_char) {\n-    bind(COMPARE_BYTE);\n-  } else {\n-    lea(ary1, Address(ary1, 2));\n-    lea(ary2, Address(ary2, 2));\n-\n-    bind(COMPARE_BYTE);\n-    testl(result, 0x1);   \/\/ tail  byte\n-    jccb(Assembler::zero, TRUE_LABEL);\n-    load_unsigned_byte(chr, Address(ary1, 0));\n-    load_unsigned_byte(limit, Address(ary2, 0));\n-    cmpl(chr, limit);\n-    jccb(Assembler::notEqual, FALSE_LABEL);\n-  }\n-  bind(TRUE_LABEL);\n-  movl(result, 1);   \/\/ return true\n-  jmpb(DONE);\n-\n-  bind(FALSE_LABEL);\n-  xorl(result, result); \/\/ return false\n-\n-  \/\/ That's it\n-  bind(DONE);\n-  if (UseAVX >= 2) {\n-    \/\/ clean upper bits of YMM registers\n-    vpxor(vec1, vec1);\n-    vpxor(vec2, vec2);\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":0,"deletions":211,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -292,4 +292,0 @@\n-  \/\/ Compare char[] or byte[] arrays.\n-  void arrays_equals(bool is_array_equ, Register ary1, Register ary2,\n-                     Register limit, Register result, Register chr,\n-                     XMMRegister vec1, XMMRegister vec2, bool is_char, KRegister mask = knoreg);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3573,0 +3573,4 @@\n+void MacroAssembler::vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {\n+  Assembler::vpcmpeqb(dst, src1, src2, vector_len);\n+}\n+\n@@ -3578,0 +3582,5 @@\n+void MacroAssembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(((dst->encoding() < 16 && nds->encoding() < 16) || VM_Version::supports_avx512vlbw()),\"XMM register should be 0-15\");\n+  Assembler::vpcmpeqw(dst, nds, src, vector_len);\n+}\n+\n@@ -10372,0 +10381,276 @@\n+\n+\/\/ Compare char[] or byte[] arrays aligned to 4 bytes or substrings.\n+void MacroAssembler::arrays_equals(bool is_array_equ, Register ary1,\n+                                   Register ary2, Register limit,\n+                                   Register result, Register chr,\n+                                   XMMRegister vec1, XMMRegister vec2,\n+                                   bool is_char, KRegister mask,\n+                                   bool expand_ary2) {\n+  \/\/ for expand_ary2, limit is the (smaller) size of the second array.\n+  ShortBranchVerifier sbv(this);\n+  Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_VECTORS, COMPARE_CHAR, COMPARE_BYTE;\n+\n+  assert((!expand_ary2) || ((expand_ary2) && (UseAVX == 2)),\n+         \"Expansion only implemented for AVX2\");\n+\n+  int length_offset  = arrayOopDesc::length_offset_in_bytes();\n+  int base_offset    = arrayOopDesc::base_offset_in_bytes(is_char ? T_CHAR : T_BYTE);\n+\n+  if (is_array_equ) {\n+    \/\/ Check the input args\n+    cmpoop(ary1, ary2);\n+    jcc(Assembler::equal, TRUE_LABEL);\n+\n+    \/\/ Need additional checks for arrays_equals.\n+    testptr(ary1, ary1);\n+    jcc(Assembler::zero, FALSE_LABEL);\n+    testptr(ary2, ary2);\n+    jcc(Assembler::zero, FALSE_LABEL);\n+\n+    \/\/ Check the lengths\n+    movl(limit, Address(ary1, length_offset));\n+    cmpl(limit, Address(ary2, length_offset));\n+    jcc(Assembler::notEqual, FALSE_LABEL);\n+  }\n+\n+  \/\/ count == 0\n+  testl(limit, limit);\n+  jcc(Assembler::zero, TRUE_LABEL);\n+\n+  if (is_array_equ) {\n+    \/\/ Load array address\n+    lea(ary1, Address(ary1, base_offset));\n+    lea(ary2, Address(ary2, base_offset));\n+  }\n+\n+  if (is_array_equ && is_char) {\n+    \/\/ arrays_equals when used for char[].\n+    shll(limit, 1);      \/\/ byte count != 0\n+  }\n+  movl(result, limit); \/\/ copy\n+\n+  if (UseAVX >= 2) {\n+    \/\/ With AVX2, use 32-byte vector compare\n+    Label COMPARE_WIDE_VECTORS, COMPARE_WIDE_VECTORS_16, COMPARE_TAIL, COMPARE_TAIL_16;\n+\n+    \/\/ Compare 32-byte vectors\n+    andl(result, 0x0000001f);  \/\/   tail count (in bytes)\n+    andl(limit, 0xffffffe0);   \/\/ vector count (in bytes)\n+    jcc(Assembler::zero, COMPARE_TAIL_16);\n+\n+    lea(ary1, Address(ary1, limit,\n+                      expand_ary2 ? Address::times_2 : Address::times_1));\n+    lea(ary2, Address(ary2, limit, Address::times_1));\n+    negptr(limit);\n+\n+#ifdef _LP64\n+    if ((AVX3Threshold == 0) && VM_Version::supports_avx512vlbw()) { \/\/ trying 64 bytes fast loop\n+      Label COMPARE_WIDE_VECTORS_LOOP_AVX2, COMPARE_WIDE_VECTORS_LOOP_AVX3;\n+\n+      cmpl(limit, -64);\n+      jcc(Assembler::greater, COMPARE_WIDE_VECTORS_LOOP_AVX2);\n+\n+      bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); \/\/ the hottest loop\n+\n+      evmovdquq(vec1, Address(ary1, limit, Address::times_1), Assembler::AVX_512bit);\n+      evpcmpeqb(mask, vec1, Address(ary2, limit, Address::times_1), Assembler::AVX_512bit);\n+      kortestql(mask, mask);\n+      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n+      addptr(limit, 64);  \/\/ update since we already compared at this addr\n+      cmpl(limit, -64);\n+      jccb(Assembler::lessEqual, COMPARE_WIDE_VECTORS_LOOP_AVX3);\n+\n+      \/\/ At this point we may still need to compare -limit+result bytes.\n+      \/\/ We could execute the next two instruction and just continue via non-wide path:\n+      \/\/  cmpl(limit, 0);\n+      \/\/  jcc(Assembler::equal, COMPARE_TAIL);  \/\/ true\n+      \/\/ But since we stopped at the points ary{1,2}+limit which are\n+      \/\/ not farther than 64 bytes from the ends of arrays ary{1,2}+result\n+      \/\/ (|limit| <= 32 and result < 32),\n+      \/\/ we may just compare the last 64 bytes.\n+      \/\/\n+      addptr(result, -64);   \/\/ it is safe, bc we just came from this area\n+      evmovdquq(vec1, Address(ary1, result, Address::times_1), Assembler::AVX_512bit);\n+      evpcmpeqb(mask, vec1, Address(ary2, result, Address::times_1), Assembler::AVX_512bit);\n+      kortestql(mask, mask);\n+      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n+\n+      jmp(TRUE_LABEL);\n+\n+      bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);\n+\n+    }\/\/if (VM_Version::supports_avx512vlbw())\n+#endif \/\/_LP64\n+    bind(COMPARE_WIDE_VECTORS);\n+    vmovdqu(vec1, Address(ary1, limit,\n+                          expand_ary2 ? Address::times_2 : Address::times_1));\n+    if (expand_ary2) {\n+      vpmovzxbw(vec2, Address(ary2, limit, Address::times_1),\n+                Assembler::AVX_256bit);\n+    } else {\n+      vmovdqu(vec2, Address(ary2, limit, Address::times_1));\n+    }\n+    vpxor(vec1, vec2);\n+\n+    vptest(vec1, vec1);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    addptr(limit, expand_ary2 ? 16 : 32);\n+    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n+\n+    testl(result, result);\n+    jcc(Assembler::zero, TRUE_LABEL);\n+\n+    vmovdqu(vec1,\n+            Address(ary1, result,\n+                    expand_ary2 ? Address::times_2 : Address::times_1, -32));\n+    if (expand_ary2) {\n+      vpmovzxbw(vec2, Address(ary2, result, Address::times_1, -16),\n+                Assembler::AVX_256bit);\n+    } else {\n+      vmovdqu(vec2, Address(ary2, result, Address::times_1, -32));\n+    }\n+    vpxor(vec1, vec2);\n+\n+    vptest(vec1, vec1);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    jmp(TRUE_LABEL);\n+\n+    bind(COMPARE_TAIL_16); \/\/ limit is zero\n+    movl(limit, result);\n+\n+    \/\/ Compare 16-byte chunks\n+    andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n+    andl(limit, 0xfffffff0);   \/\/ vector count (in bytes)\n+    jcc(Assembler::zero, COMPARE_TAIL);\n+\n+    lea(ary1, Address(ary1, limit, expand_ary2 ? Address::times_2 : Address::times_1));\n+    lea(ary2, Address(ary2, limit, Address::times_1));\n+    negptr(limit);\n+\n+    bind(COMPARE_WIDE_VECTORS_16);\n+    movdqu(vec1, Address(ary1, limit,\n+                         expand_ary2 ? Address::times_2 : Address::times_1));\n+    if (expand_ary2) {\n+      vpmovzxbw(vec2, Address(ary2, limit, Address::times_1),\n+                Assembler::AVX_128bit);\n+    } else {\n+      movdqu(vec2, Address(ary2, limit, Address::times_1));\n+    }\n+    vpxor(vec1, vec2);\n+\n+    vptest(vec1, vec1);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    addptr(limit, expand_ary2 ? 8 : 16);\n+    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS_16);\n+\n+    bind(COMPARE_TAIL); \/\/ limit is zero\n+    movl(limit, result);\n+    \/\/ Fallthru to tail compare\n+  } else if (UseSSE42Intrinsics) {\n+    \/\/ With SSE4.2, use double quad vector compare\n+    Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n+\n+    \/\/ Compare 16-byte vectors\n+    andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n+    andl(limit, 0xfffffff0);   \/\/ vector count (in bytes)\n+    jcc(Assembler::zero, COMPARE_TAIL);\n+\n+    lea(ary1, Address(ary1, limit, Address::times_1));\n+    lea(ary2, Address(ary2, limit, Address::times_1));\n+    negptr(limit);\n+\n+    bind(COMPARE_WIDE_VECTORS);\n+    movdqu(vec1, Address(ary1, limit, Address::times_1));\n+    movdqu(vec2, Address(ary2, limit, Address::times_1));\n+    pxor(vec1, vec2);\n+\n+    ptest(vec1, vec1);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    addptr(limit, 16);\n+    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n+\n+    testl(result, result);\n+    jcc(Assembler::zero, TRUE_LABEL);\n+\n+    movdqu(vec1, Address(ary1, result, Address::times_1, -16));\n+    movdqu(vec2, Address(ary2, result, Address::times_1, -16));\n+    pxor(vec1, vec2);\n+\n+    ptest(vec1, vec1);\n+    jccb(Assembler::notZero, FALSE_LABEL);\n+    jmpb(TRUE_LABEL);\n+\n+    bind(COMPARE_TAIL); \/\/ limit is zero\n+    movl(limit, result);\n+    \/\/ Fallthru to tail compare\n+  }\n+\n+  \/\/ Compare 4-byte vectors\n+  if (expand_ary2) {\n+    testl(result, result);\n+    jccb(Assembler::zero, TRUE_LABEL);\n+  } else {\n+    andl(limit, 0xfffffffc); \/\/ vector count (in bytes)\n+    jccb(Assembler::zero, COMPARE_CHAR);\n+  }\n+\n+  lea(ary1, Address(ary1, limit, expand_ary2 ? Address::times_2 : Address::times_1));\n+  lea(ary2, Address(ary2, limit, Address::times_1));\n+  negptr(limit);\n+\n+  bind(COMPARE_VECTORS);\n+  if (expand_ary2) {\n+    \/\/ There are no \"vector\" operations for bytes to shorts\n+    movzbl(chr, Address(ary2, limit, Address::times_1));\n+    cmpw(Address(ary1, limit, Address::times_2), chr);\n+    jccb(Assembler::notEqual, FALSE_LABEL);\n+    addptr(limit, 1);\n+    jcc(Assembler::notZero, COMPARE_VECTORS);\n+    jmp(TRUE_LABEL);\n+  } else {\n+    movl(chr, Address(ary1, limit,\n+                      expand_ary2 ? Address::times_2 : Address::times_1));\n+    cmpl(chr, Address(ary2, limit, Address::times_1));\n+    jccb(Assembler::notEqual, FALSE_LABEL);\n+    addptr(limit, 4);\n+    jcc(Assembler::notZero, COMPARE_VECTORS);\n+  }\n+\n+  \/\/ Compare trailing char (final 2 bytes), if any\n+  bind(COMPARE_CHAR);\n+  testl(result, 0x2);   \/\/ tail  char\n+  jccb(Assembler::zero, COMPARE_BYTE);\n+  load_unsigned_short(chr, Address(ary1, 0));\n+  load_unsigned_short(limit, Address(ary2, 0));\n+  cmpl(chr, limit);\n+  jccb(Assembler::notEqual, FALSE_LABEL);\n+\n+  if (is_array_equ && is_char) {\n+    bind(COMPARE_BYTE);\n+  } else {\n+    lea(ary1, Address(ary1, expand_ary2 ? 4 : 2));\n+    lea(ary2, Address(ary2, 2));\n+\n+    bind(COMPARE_BYTE);\n+    testl(result, 0x1);   \/\/ tail  byte\n+    jccb(Assembler::zero, TRUE_LABEL);\n+    load_unsigned_byte(chr, Address(ary1, 0));\n+    load_unsigned_byte(limit, Address(ary2, 0));\n+    cmpl(chr, limit);\n+    jccb(Assembler::notEqual, FALSE_LABEL);\n+  }\n+  bind(TRUE_LABEL);\n+  movl(result, 1);   \/\/ return true\n+  jmpb(DONE);\n+\n+  bind(FALSE_LABEL);\n+  xorl(result, result); \/\/ return false\n+\n+  \/\/ That's it\n+  bind(DONE);\n+  if (UseAVX >= 2) {\n+    \/\/ clean upper bits of YMM registers\n+    vpxor(vec1, vec1);\n+    vpxor(vec2, vec2);\n+  }\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":285,"deletions":0,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -249,0 +249,6 @@\n+  \/\/ Compare char[] or byte[] arrays.\n+  void arrays_equals(bool is_array_equ, Register ary1, Register ary2,\n+                     Register limit, Register result, Register chr,\n+                     XMMRegister vec1, XMMRegister vec2, bool is_char,\n+                     KRegister mask = knoreg, bool expand_ary2 = false);\n+\n@@ -958,0 +964,68 @@\n+  \/\/ Adding more natural conditional jump instructions\n+  void ALWAYSINLINE jo(Label& L, bool maybe_short = true) { jcc(Assembler::overflow, L, maybe_short); }\n+  void ALWAYSINLINE jno(Label& L, bool maybe_short = true) { jcc(Assembler::noOverflow, L, maybe_short); }\n+  void ALWAYSINLINE js(Label& L, bool maybe_short = true) { jcc(Assembler::positive, L, maybe_short); }\n+  void ALWAYSINLINE jns(Label& L, bool maybe_short = true) { jcc(Assembler::negative, L, maybe_short); }\n+  void ALWAYSINLINE je(Label& L, bool maybe_short = true) { jcc(Assembler::equal, L, maybe_short); }\n+  void ALWAYSINLINE jz(Label& L, bool maybe_short = true) { jcc(Assembler::zero, L, maybe_short); }\n+  void ALWAYSINLINE jne(Label& L, bool maybe_short = true) { jcc(Assembler::notEqual, L, maybe_short); }\n+  void ALWAYSINLINE jnz(Label& L, bool maybe_short = true) { jcc(Assembler::notZero, L, maybe_short); }\n+  void ALWAYSINLINE jb(Label& L, bool maybe_short = true) { jcc(Assembler::below, L, maybe_short); }\n+  void ALWAYSINLINE jnae(Label& L, bool maybe_short = true) { jcc(Assembler::below, L, maybe_short); }\n+  void ALWAYSINLINE jc(Label& L, bool maybe_short = true) { jcc(Assembler::carrySet, L, maybe_short); }\n+  void ALWAYSINLINE jnb(Label& L, bool maybe_short = true) { jcc(Assembler::aboveEqual, L, maybe_short); }\n+  void ALWAYSINLINE jae(Label& L, bool maybe_short = true) { jcc(Assembler::aboveEqual, L, maybe_short); }\n+  void ALWAYSINLINE jnc(Label& L, bool maybe_short = true) { jcc(Assembler::carryClear, L, maybe_short); }\n+  void ALWAYSINLINE jbe(Label& L, bool maybe_short = true) { jcc(Assembler::belowEqual, L, maybe_short); }\n+  void ALWAYSINLINE jna(Label& L, bool maybe_short = true) { jcc(Assembler::belowEqual, L, maybe_short); }\n+  void ALWAYSINLINE ja(Label& L, bool maybe_short = true) { jcc(Assembler::above, L, maybe_short); }\n+  void ALWAYSINLINE jnbe(Label& L, bool maybe_short = true) { jcc(Assembler::above, L, maybe_short); }\n+  void ALWAYSINLINE jl(Label& L, bool maybe_short = true) { jcc(Assembler::less, L, maybe_short); }\n+  void ALWAYSINLINE jnge(Label& L, bool maybe_short = true) { jcc(Assembler::less, L, maybe_short); }\n+  void ALWAYSINLINE jge(Label& L, bool maybe_short = true) { jcc(Assembler::greaterEqual, L, maybe_short); }\n+  void ALWAYSINLINE jnl(Label& L, bool maybe_short = true) { jcc(Assembler::greaterEqual, L, maybe_short); }\n+  void ALWAYSINLINE jle(Label& L, bool maybe_short = true) { jcc(Assembler::lessEqual, L, maybe_short); }\n+  void ALWAYSINLINE jng(Label& L, bool maybe_short = true) { jcc(Assembler::lessEqual, L, maybe_short); }\n+  void ALWAYSINLINE jg(Label& L, bool maybe_short = true) { jcc(Assembler::greater, L, maybe_short); }\n+  void ALWAYSINLINE jnle(Label& L, bool maybe_short = true) { jcc(Assembler::greater, L, maybe_short); }\n+  void ALWAYSINLINE jp(Label& L, bool maybe_short = true) { jcc(Assembler::parity, L, maybe_short); }\n+  void ALWAYSINLINE jpe(Label& L, bool maybe_short = true) { jcc(Assembler::parity, L, maybe_short); }\n+  void ALWAYSINLINE jnp(Label& L, bool maybe_short = true) { jcc(Assembler::noParity, L, maybe_short); }\n+  void ALWAYSINLINE jpo(Label& L, bool maybe_short = true) { jcc(Assembler::noParity, L, maybe_short); }\n+\/\/ * No condition for this *  void ALWAYSINLINE jcxz(Label& L, bool maybe_short = true) { jcc(Assembler::cxz, L, maybe_short); }\n+\/\/ * No condition for this *  void ALWAYSINLINE jecxz(Label& L, bool maybe_short = true) { jcc(Assembler::cxz, L, maybe_short); }\n+\n+\/\/ Short versions of the above\n+  void ALWAYSINLINE jo_b(Label& L) { jccb(Assembler::overflow, L); }\n+  void ALWAYSINLINE jno_b(Label& L) { jccb(Assembler::noOverflow, L); }\n+  void ALWAYSINLINE js_b(Label& L) { jccb(Assembler::positive, L); }\n+  void ALWAYSINLINE jns_b(Label& L) { jccb(Assembler::negative, L); }\n+  void ALWAYSINLINE je_b(Label& L) { jccb(Assembler::equal, L); }\n+  void ALWAYSINLINE jz_b(Label& L) { jccb(Assembler::zero, L); }\n+  void ALWAYSINLINE jne_b(Label& L) { jccb(Assembler::notEqual, L); }\n+  void ALWAYSINLINE jnz_b(Label& L) { jccb(Assembler::notZero, L); }\n+  void ALWAYSINLINE jb_b(Label& L) { jccb(Assembler::below, L); }\n+  void ALWAYSINLINE jnae_b(Label& L) { jccb(Assembler::below, L); }\n+  void ALWAYSINLINE jc_b(Label& L) { jccb(Assembler::carrySet, L); }\n+  void ALWAYSINLINE jnb_b(Label& L) { jccb(Assembler::aboveEqual, L); }\n+  void ALWAYSINLINE jae_b(Label& L) { jccb(Assembler::aboveEqual, L); }\n+  void ALWAYSINLINE jnc_b(Label& L) { jccb(Assembler::carryClear, L); }\n+  void ALWAYSINLINE jbe_b(Label& L) { jccb(Assembler::belowEqual, L); }\n+  void ALWAYSINLINE jna_b(Label& L) { jccb(Assembler::belowEqual, L); }\n+  void ALWAYSINLINE ja_b(Label& L) { jccb(Assembler::above, L); }\n+  void ALWAYSINLINE jnbe_b(Label& L) { jccb(Assembler::above, L); }\n+  void ALWAYSINLINE jl_b(Label& L) { jccb(Assembler::less, L); }\n+  void ALWAYSINLINE jnge_b(Label& L) { jccb(Assembler::less, L); }\n+  void ALWAYSINLINE jge_b(Label& L) { jccb(Assembler::greaterEqual, L); }\n+  void ALWAYSINLINE jnl_b(Label& L) { jccb(Assembler::greaterEqual, L); }\n+  void ALWAYSINLINE jle_b(Label& L) { jccb(Assembler::lessEqual, L); }\n+  void ALWAYSINLINE jng_b(Label& L) { jccb(Assembler::lessEqual, L); }\n+  void ALWAYSINLINE jg_b(Label& L) { jccb(Assembler::greater, L); }\n+  void ALWAYSINLINE jnle_b(Label& L) { jccb(Assembler::greater, L); }\n+  void ALWAYSINLINE jp_b(Label& L) { jccb(Assembler::parity, L); }\n+  void ALWAYSINLINE jpe_b(Label& L) { jccb(Assembler::parity, L); }\n+  void ALWAYSINLINE jnp_b(Label& L) { jccb(Assembler::noParity, L); }\n+  void ALWAYSINLINE jpo_b(Label& L) { jccb(Assembler::noParity, L); }\n+\/\/ * No condition for this *  void ALWAYSINLINE jcxz_b(Label& L) { jccb(Assembler::cxz, L); }\n+\/\/ * No condition for this *  void ALWAYSINLINE jecxz_b(Label& L) { jccb(Assembler::cxz, L); }\n+\n@@ -1392,0 +1466,1 @@\n+  void vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n@@ -1393,0 +1468,1 @@\n+  void vpcmpeqw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"}]}