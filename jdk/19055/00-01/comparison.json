{"files":[{"patch":"@@ -31,2 +31,0 @@\n-import java.io.InputStream;\n-import java.io.IOException;\n@@ -34,0 +32,3 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n@@ -36,1 +37,1 @@\n-import java.nio.file.Files;\n+import java.util.Optional;\n@@ -50,0 +51,13 @@\n+\n+    private static final Optional<Path> MOUNT_NS;\n+\n+    static {\n+        Path mountNs = null;\n+        try {\n+            mountNs = Files.readSymbolicLink(Path.of(\"\/proc\/self\/ns\/mnt\"));\n+        } catch (IOException ioe) {\n+        } finally {\n+            MOUNT_NS = Optional.ofNullable(mountNs);\n+        }\n+    }\n+\n@@ -51,0 +65,1 @@\n+\n@@ -65,0 +80,2 @@\n+        Path targetProcessTmpDir = findTargetProcessTmpDirectory(pid);\n+\n@@ -71,1 +88,1 @@\n-        File socket_file = findSocketFile(pid, ns_pid);\n+        File socket_file = findSocketFile(targetProcessTmpDir, ns_pid);\n@@ -75,1 +92,1 @@\n-            File f = createAttachFile(pid, ns_pid).getCanonicalFile();\n+            File f = createAttachFile(pid, ns_pid, targetProcessTmpDir).getCanonicalFile();\n@@ -213,3 +230,2 @@\n-    private File findSocketFile(int pid, int ns_pid) throws IOException {\n-        String root = findTargetProcessTmpDirectory(pid, ns_pid);\n-        return new File(root, \".java_pid\" + ns_pid);\n+    private File findSocketFile(Path targetProcessTmpDirectory, int ns_pid) {\n+        return targetProcessTmpDirectory.resolve(\".java_pid\" + ns_pid).toFile();\n@@ -222,1 +238,1 @@\n-    private File createAttachFile(int pid, int ns_pid) throws IOException {\n+    private File createAttachFile(int pid, int ns_pid, Path targetProcessTmpDirectory) throws IOException {\n@@ -230,2 +246,1 @@\n-            String root = findTargetProcessTmpDirectory(pid, ns_pid);\n-            f = new File(root, fn);\n+            f = targetProcessTmpDirectory.resolve(fn).toFile();\n@@ -237,3 +252,4 @@\n-    private String findTargetProcessTmpDirectory(int pid, int ns_pid) throws IOException {\n-        \/\/ We need to handle at least 4 different scenarios:\n-        \/\/ 1. Caller and target processes share PID namespace and root filesystem (host to host).\n+    private Path findTargetProcessTmpDirectory(int pid) {\n+        \/\/ We need to handle at least 4 different cases:\n+        \/\/ 1. Caller and target processes share PID namespace and root filesystem (host to host or container to\n+        \/\/    container with both \/tmp mounted between containers).\n@@ -245,10 +261,13 @@\n-        \/\/ Hence, we start out by trying to access the target process' \/tmp folder through \/proc\/<pid>\/root\/tmp. This\n-        \/\/ works in all cases except case 2. Even though both the caller and target process runs as the same user,\n-        \/\/ access to the \/proc\/<pid>\/root symlink is governed by ptrace access mode PTRACE_MODE_READ_FSCREDS, and if\n-        \/\/ if the target process has elevated privileges set by setcap access is denied (see JDK-8226919).\n-        \/\/ If \/proc\/<pid>\/root is not readable, we fall back to trying \/tmp.\n-\n-        String root;\n-        String procRootDirectory = \"\/proc\/\" + pid + \"\/root\";\n-        if (Files.isReadable(Path.of(procRootDirectory))) {\n-            root = procRootDirectory + \"\/\" + tmpdir;\n+        \/\/ Hence, we start out by comparing mount namespaces. If they match, we know for sure that reading from and\n+        \/\/ writing to \/tmp will work. If not, we check if we can access the target process' \/tmp folder through\n+        \/\/ \/proc\/<pid>\/root\/tmp. This works in all cases except case 2. Even though both the caller and target process\n+        \/\/ are running as the same user, access to the \/proc\/<pid>\/root symlink is governed by ptrace access mode\n+        \/\/ PTRACE_MODE_READ_FSCREDS, and if the target process has elevated privileges set by setcap, access is denied\n+        \/\/ (see JDK-8226919). If \/proc\/<pid>\/root is not readable, as a last resort we fall back to trying \/tmp.\n+\n+        Optional<Path> targetMountNs = Optional.empty();\n+\n+        try {\n+            targetMountNs = Optional.ofNullable(Files.readSymbolicLink(Path.of(\"\/proc\", Integer.toString(pid), \"ns\", \"mnt\")));\n+        } catch (IOException _) {\n+            \/\/ do nothing...\n@@ -256,8 +275,0 @@\n-        else {\n-            if (pid != ns_pid) {\n-                \/\/ Case 4, there is no point in trying \/tmp because if different PID namespaces surely means different\n-                \/\/ root filesystems too.\n-                throw new IOException(\n-                        String.format(\"Unable to access root directory %s \" +\n-                          \"of target process %d\", procRootDirectory, pid));\n-            }\n@@ -265,1 +276,5 @@\n-            root = tmpdir;\n+        final boolean sameMountNs = MOUNT_NS.isPresent() && targetMountNs.isPresent() && MOUNT_NS.equals(targetMountNs);\n+\n+        if (sameMountNs) {\n+            \/\/ Cases 1 and 3\n+            return Path.of(tmpdir);\n@@ -267,1 +282,10 @@\n-        return root;\n+\n+        Path procRootDirectory = Path.of(\"\/proc\", Integer.toString(pid), \"root\" );\n+        if (Files.isReadable(procRootDirectory)) {\n+            \/\/ Case 4\n+            return Path.of(procRootDirectory.toString(), tmpdir);\n+        }\n+\n+        \/\/ Case 2, and cases where no matching process is running or the attacher process is running as a non-privileged\n+        \/\/ user and the target process is running as another user than the attacher.\n+        return Path.of(tmpdir);\n@@ -287,1 +311,1 @@\n-    private int getNamespacePid(int pid) throws AttachNotSupportedException, IOException {\n+    private int getNamespacePid(int pid) throws AttachNotSupportedException {\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":59,"deletions":35,"binary":false,"changes":94,"status":"modified"}]}