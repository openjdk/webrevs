{"files":[{"patch":"@@ -31,2 +31,0 @@\n-import java.io.InputStream;\n-import java.io.IOException;\n@@ -34,0 +32,3 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n@@ -36,1 +37,1 @@\n-import java.nio.file.Files;\n+import java.util.Optional;\n@@ -49,1 +50,23 @@\n-    private static final String tmpdir = \"\/tmp\";\n+    private static final Path TMPDIR = Path.of(\"\/tmp\");\n+\n+    private static final Path PROC     = Path.of(\"\/proc\");\n+    private static final Path NS_MNT   = Path.of(\"ns\/mnt\");\n+    private static final Path NS_PID   = Path.of(\"ns\/pid\");\n+    private static final Path SELF     = PROC.resolve(\"self\");\n+    private static final Path STATUS   = Path.of(\"status\");\n+    private static final Path ROOT_TMP = Path.of(\"root\/tmp\");\n+\n+    private static final Optional<Path> SELF_MNT_NS;\n+\n+    static {\n+        Path nsPath = null;\n+\n+        try {\n+            nsPath = Files.readSymbolicLink(SELF.resolve(NS_MNT));\n+        } catch (IOException _) {\n+            \/\/ do nothing\n+        } finally {\n+            SELF_MNT_NS = Optional.ofNullable(nsPath);\n+        }\n+    }\n+\n@@ -51,0 +74,1 @@\n+\n@@ -54,2 +78,1 @@\n-    VirtualMachineImpl(AttachProvider provider, String vmid)\n-        throws AttachNotSupportedException, IOException\n+    VirtualMachineImpl(AttachProvider provider, String vmid) throws AttachNotSupportedException, IOException\n@@ -66,1 +89,1 @@\n-        int ns_pid = getNamespacePid(pid);\n+        final long ns_pid = getNamespacePid(pid);\n@@ -71,1 +94,1 @@\n-        File socket_file = findSocketFile(pid, ns_pid);\n+        final File socket_file = findSocketFile(pid, ns_pid);\n@@ -213,3 +236,2 @@\n-    private File findSocketFile(int pid, int ns_pid) throws IOException {\n-        String root = findTargetProcessTmpDirectory(pid, ns_pid);\n-        return new File(root, \".java_pid\" + ns_pid);\n+    private File findSocketFile(long pid, long ns_pid) throws AttachNotSupportedException, IOException {\n+        return new File(findTargetProcessTmpDirectory(pid, ns_pid), \".java_pid\" + ns_pid);\n@@ -222,4 +244,4 @@\n-    private File createAttachFile(int pid, int ns_pid) throws IOException {\n-        String fn = \".attach_pid\" + ns_pid;\n-        String path = \"\/proc\/\" + pid + \"\/cwd\/\" + fn;\n-        File f = new File(path);\n+    private File createAttachFile(long pid, long ns_pid) throws AttachNotSupportedException, IOException {\n+        Path fn   = Path.of(\".attach_pid\" + ns_pid);\n+        Path path = PROC.resolve(Path.of(Long.toString(pid), \"cwd\")).resolve(fn);\n+        File f    = new File(path.toString());\n@@ -229,3 +251,2 @@\n-        } catch (IOException x) {\n-            String root = findTargetProcessTmpDirectory(pid, ns_pid);\n-            f = new File(root, fn);\n+        } catch (IOException _) {\n+            f = new File(findTargetProcessTmpDirectory(pid, ns_pid), fn.toString());\n@@ -237,12 +258,42 @@\n-    private String findTargetProcessTmpDirectory(int pid, int ns_pid) throws IOException {\n-        String root;\n-        if (pid != ns_pid) {\n-            \/\/ A process may not exist in the same mount namespace as the caller, e.g.\n-            \/\/ if we are trying to attach to a JVM process inside a container.\n-            \/\/ Instead, attach relative to the target root filesystem as exposed by\n-            \/\/ procfs regardless of namespaces.\n-            String procRootDirectory = \"\/proc\/\" + pid + \"\/root\";\n-            if (!Files.isReadable(Path.of(procRootDirectory))) {\n-                throw new IOException(\n-                        String.format(\"Unable to access root directory %s \" +\n-                          \"of target process %d\", procRootDirectory, pid));\n+    private String findTargetProcessTmpDirectory(long pid, long ns_pid) throws AttachNotSupportedException, IOException {\n+        \/\/ We need to handle at least 4 different cases:\n+        \/\/ 1. Caller and target processes share PID namespace and root filesystem (host to host or container to\n+        \/\/    container with both \/tmp mounted between containers).\n+        \/\/ 2. Caller and target processes share PID namespace and root filesystem but the target process has elevated\n+        \/\/    privileges (host to host).\n+        \/\/ 3. Caller and target processes share PID namespace but NOT root filesystem (container to container).\n+        \/\/ 4. Caller and target processes share neither PID namespace nor root filesystem (host to container).\n+\n+        Optional<ProcessHandle> target = ProcessHandle.of(pid);\n+        Optional<ProcessHandle> ph = target;\n+        long nsPid = ns_pid;\n+        Optional<Path> prevPidNS = Optional.empty();\n+\n+        while (ph.isPresent()) {\n+            final var curPid = ph.get().pid();\n+\n+            final var procPidPath = PROC.resolve(Long.toString(curPid));\n+\n+            Optional<Path> targetMountNS = Optional.empty();\n+\n+            try {\n+                targetMountNS = Optional.ofNullable(Files.readSymbolicLink(procPidPath.resolve(NS_MNT))); \/\/ attempt to read the target's mnt ns id...\n+            } catch (\n+                    IOException _) { \/\/ if we fail to read the target's mnt ns id then we either don't have access or it no longer exists!\n+                if (!Files.exists(procPidPath)) {\n+                    throw new IOException(String.format(\"unable to attach, %s non-existent! process: %d terminated\", procPidPath, pid));\n+                }\n+\n+                \/\/ ok so if we get here we have failed to read the target's mnt ns, but the target process still exists ... we do not have privileges to read its procfs\n+            }\n+\n+            final var sameMountNS = SELF_MNT_NS.isPresent() && SELF_MNT_NS.equals(targetMountNS); \/\/ will be false  if we did not read the target's mnt ns\n+\n+            if (sameMountNS) {\n+                return TMPDIR.toString(); \/\/ we share TMPDIR in common!\n+            } else {\n+                final var procPidRootTmp = procPidPath.resolve(ROOT_TMP);\n+\n+                if (Files.isReadable(procPidRootTmp)) {\n+                    return procPidRootTmp.toString(); \/\/ not in the same mnt ns but tmp is accessible via \/proc...\n+                }\n@@ -251,1 +302,33 @@\n-            root = procRootDirectory + \"\/\" + tmpdir;\n+            \/\/ let's attempt to obtain the pid NS... best efforts to avoid crossing pid ns boundaries (as with a container)\n+\n+            Optional<Path> curPidNS = Optional.empty();\n+\n+            try {\n+                curPidNS = Optional.ofNullable(Files.readSymbolicLink(procPidPath.resolve(NS_PID))); \/\/ attempt to read the target's mnt ns id...\n+            } catch (IOException _) { \/\/ if we fail to read the target's pid ns id then we either don't have access or it no longer exists!\n+                if (!Files.exists(procPidPath)) {\n+                    throw new IOException(String.format(\"unable to attach, %s non-existent! process: %d terminated\", procPidPath, pid));\n+                }\n+\n+                \/\/ ok so if we get here we have failed to read the target's pid ns, but the target process still exists ... we do not have privileges to read its procfs\n+            }\n+\n+            \/\/ recurse \"up\" the process hierarchy... if appropriate\n+\n+            final var havePidNSes = prevPidNS.isPresent() && curPidNS.isPresent();\n+\n+            final var ppid = ph.get().parent();\n+\n+            if (ppid.isPresent() && (havePidNSes && curPidNS.equals(prevPidNS)) || (!havePidNSes && nsPid > 1)) {\n+                ph = ppid;\n+\n+                nsPid = getNamespacePid(ph.get().pid()); \/\/ get the ns pid of the parent...\n+\n+                prevPidNS = curPidNS;\n+            } else {\n+                ph = Optional.empty();\n+            }\n+        }\n+\n+        if (target.orElseThrow(AttachNotSupportedException::new).isAlive()) {\n+            return TMPDIR.toString(); \/\/ fallback...\n@@ -253,1 +336,1 @@\n-            root = tmpdir;\n+            throw new IOException(String.format(\"unable to attach, process: %d terminated\", pid));\n@@ -255,1 +338,0 @@\n-        return root;\n@@ -275,1 +357,1 @@\n-    private int getNamespacePid(int pid) throws AttachNotSupportedException, IOException {\n+    private long getNamespacePid(long pid) throws AttachNotSupportedException, IOException {\n@@ -278,1 +360,1 @@\n-        String statusFile = \"\/proc\/\" + pid + \"\/status\";\n+        final var statusFile = PROC.resolve(Long.toString(pid)).resolve(STATUS).toString();\n@@ -294,2 +376,1 @@\n-                    int ns_pid = Integer.parseInt(parts[parts.length - 1]);\n-                    return ns_pid;\n+                    return Long.parseLong(parts[parts.length - 1]);\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":118,"deletions":37,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n@@ -44,0 +47,2 @@\n+import java.util.Collections;\n+import java.util.EnumSet;\n@@ -45,0 +50,1 @@\n+import java.util.Optional;\n@@ -47,0 +53,1 @@\n+import java.util.regex.Pattern;\n@@ -63,0 +70,25 @@\n+    private static final String UID = \"uid\";\n+    private static final String GID = \"gid\";\n+\n+    private static final Pattern ID_PATTERN = Pattern.compile(\"uid=(?<\" + UID + \">\\\\d+)\\\\([^\\\\)]+\\\\)\\\\s+gid=(?<\" + GID + \">\\\\d+).*\");\n+\n+    private static final Optional<String> USER = ProcessHandle.current().info().user().map(\n+            user -> {\n+                try (var br = new BufferedReader(new InputStreamReader(new ProcessBuilder(\"id\", user).start().getInputStream()))) {\n+                    for (final var line : br.lines().toList()) {\n+                        final var m = ID_PATTERN.matcher(line);\n+\n+                        if (m.matches()) {\n+                            return \"--user=\" + m.group(UID) + \":\" + m.group(GID);\n+                        }\n+                    }\n+                } catch (IOException e) {\n+                    \/\/ do nothing...\n+                }\n+\n+                return null;\n+            }\n+    );\n+\n+    private static final String NET_BIND_SERVICE = \"--cap-add=NET_BIND_SERVICE\";\n+\n@@ -71,16 +103,19 @@\n-            \/\/ Start the loop process in the \"main\" container, then run test cases\n-            \/\/ using a sidecar container.\n-            MainContainer mainContainer = new MainContainer();\n-            mainContainer.start();\n-            mainContainer.waitForMainMethodStart(TIME_TO_WAIT_FOR_MAIN_METHOD_START);\n-\n-            long mainProcPid = testCase01();\n-\n-            \/\/ Excluding the test case below until JDK-8228850 is fixed\n-            \/\/ JDK-8228850: jhsdb jinfo fails with ClassCastException:\n-            \/\/ s.j.h.oops.TypeArray cannot be cast to s.j.h.oops.Instance\n-            \/\/ mainContainer.assertIsAlive();\n-            \/\/ testCase02(mainProcPid);\n-\n-            mainContainer.assertIsAlive();\n-            testCase03(mainProcPid);\n+            for (final boolean elevated : USER.isPresent() ? new Boolean[] { false, true } : new Boolean[] { false }) {\n+                \/\/ Start the loop process in the \"main\" container, then run test cases\n+                \/\/ using a sidecar container.\n+                MainContainer mainContainer = new MainContainer();\n+                mainContainer.start(elevated);\n+                mainContainer.waitForMainMethodStart(TIME_TO_WAIT_FOR_MAIN_METHOD_START);\n+\n+                for (AttachStrategy attachStrategy : EnumSet.allOf(AttachStrategy.class)) {\n+                    long mainProcPid = testCase01(attachStrategy, elevated);\n+\n+                    \/\/ Excluding the test case below until JDK-8228850 is fixed\n+                    \/\/ JDK-8228850: jhsdb jinfo fails with ClassCastException:\n+                    \/\/ s.j.h.oops.TypeArray cannot be cast to s.j.h.oops.Instance\n+                    \/\/ mainContainer.assertIsAlive();\n+                    \/\/ testCase02(mainProcPid, attachStrategy, elevated);\n+\n+                    mainContainer.assertIsAlive();\n+                    testCase03(mainProcPid, attachStrategy, elevated);\n+                }\n@@ -88,1 +123,2 @@\n-            mainContainer.waitForAndCheck(TIME_TO_RUN_MAIN_PROCESS * 1000);\n+                mainContainer.waitForAndCheck(TIME_TO_RUN_MAIN_PROCESS * 1000);\n+            }\n@@ -96,2 +132,2 @@\n-    private static long testCase01() throws Exception {\n-        OutputAnalyzer out = runSideCar(MAIN_CONTAINER_NAME, \"\/jdk\/bin\/jcmd\", \"-l\")\n+    private static long testCase01(AttachStrategy attachStrategy, boolean elevated) throws Exception {\n+        OutputAnalyzer out = runSideCar(MAIN_CONTAINER_NAME, attachStrategy, elevated, \"\/jdk\/bin\/jcmd\", \"-l\")\n@@ -102,1 +138,1 @@\n-            throw new RuntimeException(\"Could not find specified process\");\n+            throw new RuntimeException(attachStrategy + \": Could not find specified process\");\n@@ -109,2 +145,2 @@\n-    private static void testCase02(long pid) throws Exception {\n-        runSideCar(MAIN_CONTAINER_NAME, \"\/jdk\/bin\/jhsdb\", \"jinfo\", \"--pid\", \"\" + pid)\n+    private static void testCase02(long pid, AttachStrategy attachStrategy, boolean elevated) throws Exception {\n+        runSideCar(MAIN_CONTAINER_NAME, attachStrategy, elevated, \"\/jdk\/bin\/jhsdb\", \"jinfo\", \"--pid\", \"\" + pid)\n@@ -118,2 +154,2 @@\n-    private static void testCase03(long pid) throws Exception {\n-        runSideCar(MAIN_CONTAINER_NAME, \"\/jdk\/bin\/jcmd\", \"\" + pid, \"help\")\n+    private static void testCase03(long pid, AttachStrategy attachStrategy, boolean elevated) throws Exception {\n+        runSideCar(MAIN_CONTAINER_NAME, attachStrategy, elevated, \"\/jdk\/bin\/jcmd\", \"\" + pid, \"help\")\n@@ -122,1 +158,1 @@\n-        runSideCar(MAIN_CONTAINER_NAME, \"\/jdk\/bin\/jcmd\", \"\" + pid, \"JFR.start\")\n+        runSideCar(MAIN_CONTAINER_NAME, attachStrategy, elevated, \"\/jdk\/bin\/jcmd\", \"\" + pid, \"JFR.start\")\n@@ -130,6 +166,8 @@\n-    \/\/ buffers in \/tmp directory (hsperfdata_<user>). Thus, in sidecar\n-    \/\/ we mount \/tmp via --volumes-from from the main container.\n-    private static OutputAnalyzer runSideCar(String mainContainerName, String whatToRun,\n-                                             String... args) throws Exception {\n-        List<String> cmd = new ArrayList<>();\n-        String[] command = new String[] {\n+    \/\/ buffers in \/tmp directory (hsperfdata_<user>). Thus, in the sidecar\n+    \/\/ we have two options:\n+    \/\/ 1. mount \/tmp from the main container using --volumes-from.\n+    \/\/ 2. access \/tmp from the main container via \/proc\/<pid>\/root\/tmp.\n+    private static OutputAnalyzer runSideCar(String mainContainerName, AttachStrategy attachStrategy, boolean elevated,  String whatToRun, String... args) throws Exception {\n+        System.out.println(\"Attach strategy \" + attachStrategy);\n+\n+        List<String> initialCommands = List.of(\n@@ -139,3 +177,6 @@\n-            \"--pid=container:\" + mainContainerName,\n-            \"--volumes-from\", mainContainerName,\n-            IMAGE_NAME, whatToRun\n+            \"--pid=container:\" + mainContainerName\n+        );\n+\n+        List<String> attachStrategyCommands = switch (attachStrategy) {\n+            case TMP_MOUNTED_INTO_SIDECAR -> List.of(\"--volumes-from\", mainContainerName);\n+            case ACCESS_TMP_VIA_PROC_ROOT -> List.of();\n@@ -144,1 +185,11 @@\n-        cmd.addAll(Arrays.asList(command));\n+        List<String> elevatedOpts = elevated && USER.isPresent() ? List.of(NET_BIND_SERVICE, USER.get()) : Collections.emptyList();\n+\n+        List<String> imageAndCommand = List.of(\n+            IMAGE_NAME, whatToRun\n+        );\n+\n+        List<String> cmd = new ArrayList<>();\n+        cmd.addAll(initialCommands);\n+        cmd.addAll(elevatedOpts);\n+        cmd.addAll(attachStrategyCommands);\n+        cmd.addAll(imageAndCommand);\n@@ -191,1 +242,1 @@\n-        public Process start() throws Exception {\n+        public Process start(final boolean elevated) throws Exception {\n@@ -194,0 +245,6 @@\n+\n+            if (elevated && USER.isPresent()) {\n+                opts.addDockerOpts(USER.get());\n+                opts.addDockerOpts(NET_BIND_SERVICE);\n+            }\n+\n@@ -244,1 +301,1 @@\n-                    System.out.println(\"IllegalThreadStateException occured when calling exitValue()\");\n+                    System.out.println(\"IllegalThreadStateException occurred when calling exitValue()\");\n@@ -256,0 +313,4 @@\n+    private enum AttachStrategy {\n+        TMP_MOUNTED_INTO_SIDECAR,\n+        ACCESS_TMP_VIA_PROC_ROOT\n+    }\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJcmdWithSideCar.java","additions":98,"deletions":37,"binary":false,"changes":135,"status":"modified"}]}