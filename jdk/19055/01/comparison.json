{"files":[{"patch":"@@ -31,2 +31,0 @@\n-import java.io.InputStream;\n-import java.io.IOException;\n@@ -34,0 +32,3 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n@@ -36,1 +37,1 @@\n-import java.nio.file.Files;\n+import java.util.Optional;\n@@ -50,0 +51,13 @@\n+\n+    private static final Optional<Path> MOUNT_NS;\n+\n+    static {\n+        Path mountNs = null;\n+        try {\n+            mountNs = Files.readSymbolicLink(Path.of(\"\/proc\/self\/ns\/mnt\"));\n+        } catch (IOException ioe) {\n+        } finally {\n+            MOUNT_NS = Optional.ofNullable(mountNs);\n+        }\n+    }\n+\n@@ -51,0 +65,1 @@\n+\n@@ -65,0 +80,2 @@\n+        Path targetProcessTmpDir = findTargetProcessTmpDirectory(pid);\n+\n@@ -71,1 +88,1 @@\n-        File socket_file = findSocketFile(pid, ns_pid);\n+        File socket_file = findSocketFile(targetProcessTmpDir, ns_pid);\n@@ -75,1 +92,1 @@\n-            File f = createAttachFile(pid, ns_pid).getCanonicalFile();\n+            File f = createAttachFile(pid, ns_pid, targetProcessTmpDir).getCanonicalFile();\n@@ -213,3 +230,2 @@\n-    private File findSocketFile(int pid, int ns_pid) throws IOException {\n-        String root = findTargetProcessTmpDirectory(pid, ns_pid);\n-        return new File(root, \".java_pid\" + ns_pid);\n+    private File findSocketFile(Path targetProcessTmpDirectory, int ns_pid) {\n+        return targetProcessTmpDirectory.resolve(\".java_pid\" + ns_pid).toFile();\n@@ -222,1 +238,1 @@\n-    private File createAttachFile(int pid, int ns_pid) throws IOException {\n+    private File createAttachFile(int pid, int ns_pid, Path targetProcessTmpDirectory) throws IOException {\n@@ -230,2 +246,1 @@\n-            String root = findTargetProcessTmpDirectory(pid, ns_pid);\n-            f = new File(root, fn);\n+            f = targetProcessTmpDirectory.resolve(fn).toFile();\n@@ -237,13 +252,17 @@\n-    private String findTargetProcessTmpDirectory(int pid, int ns_pid) throws IOException {\n-        String root;\n-        if (pid != ns_pid) {\n-            \/\/ A process may not exist in the same mount namespace as the caller, e.g.\n-            \/\/ if we are trying to attach to a JVM process inside a container.\n-            \/\/ Instead, attach relative to the target root filesystem as exposed by\n-            \/\/ procfs regardless of namespaces.\n-            String procRootDirectory = \"\/proc\/\" + pid + \"\/root\";\n-            if (!Files.isReadable(Path.of(procRootDirectory))) {\n-                throw new IOException(\n-                        String.format(\"Unable to access root directory %s \" +\n-                          \"of target process %d\", procRootDirectory, pid));\n-            }\n+    private Path findTargetProcessTmpDirectory(int pid) {\n+        \/\/ We need to handle at least 4 different cases:\n+        \/\/ 1. Caller and target processes share PID namespace and root filesystem (host to host or container to\n+        \/\/    container with both \/tmp mounted between containers).\n+        \/\/ 2. Caller and target processes share PID namespace and root filesystem but the target process has elevated\n+        \/\/    privileges (host to host).\n+        \/\/ 3. Caller and target processes share PID namespace but NOT root filesystem (container to container).\n+        \/\/ 4. Caller and target processes share neither PID namespace nor root filesystem (host to container).\n+        \/\/\n+        \/\/ Hence, we start out by comparing mount namespaces. If they match, we know for sure that reading from and\n+        \/\/ writing to \/tmp will work. If not, we check if we can access the target process' \/tmp folder through\n+        \/\/ \/proc\/<pid>\/root\/tmp. This works in all cases except case 2. Even though both the caller and target process\n+        \/\/ are running as the same user, access to the \/proc\/<pid>\/root symlink is governed by ptrace access mode\n+        \/\/ PTRACE_MODE_READ_FSCREDS, and if the target process has elevated privileges set by setcap, access is denied\n+        \/\/ (see JDK-8226919). If \/proc\/<pid>\/root is not readable, as a last resort we fall back to trying \/tmp.\n+\n+        Optional<Path> targetMountNs = Optional.empty();\n@@ -251,3 +270,4 @@\n-            root = procRootDirectory + \"\/\" + tmpdir;\n-        } else {\n-            root = tmpdir;\n+        try {\n+            targetMountNs = Optional.ofNullable(Files.readSymbolicLink(Path.of(\"\/proc\", Integer.toString(pid), \"ns\", \"mnt\")));\n+        } catch (IOException _) {\n+            \/\/ do nothing...\n@@ -255,1 +275,17 @@\n-        return root;\n+\n+        final boolean sameMountNs = MOUNT_NS.isPresent() && targetMountNs.isPresent() && MOUNT_NS.equals(targetMountNs);\n+\n+        if (sameMountNs) {\n+            \/\/ Cases 1 and 3\n+            return Path.of(tmpdir);\n+        }\n+\n+        Path procRootDirectory = Path.of(\"\/proc\", Integer.toString(pid), \"root\" );\n+        if (Files.isReadable(procRootDirectory)) {\n+            \/\/ Case 4\n+            return Path.of(procRootDirectory.toString(), tmpdir);\n+        }\n+\n+        \/\/ Case 2, and cases where no matching process is running or the attacher process is running as a non-privileged\n+        \/\/ user and the target process is running as another user than the attacher.\n+        return Path.of(tmpdir);\n@@ -275,1 +311,1 @@\n-    private int getNamespacePid(int pid) throws AttachNotSupportedException, IOException {\n+    private int getNamespacePid(int pid) throws AttachNotSupportedException {\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":65,"deletions":29,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import java.util.EnumSet;\n@@ -77,1 +78,2 @@\n-            long mainProcPid = testCase01();\n+            for (AttachStrategy attachStrategy : EnumSet.allOf(AttachStrategy.class)) {\n+                long mainProcPid = testCase01(attachStrategy);\n@@ -79,5 +81,5 @@\n-            \/\/ Excluding the test case below until JDK-8228850 is fixed\n-            \/\/ JDK-8228850: jhsdb jinfo fails with ClassCastException:\n-            \/\/ s.j.h.oops.TypeArray cannot be cast to s.j.h.oops.Instance\n-            \/\/ mainContainer.assertIsAlive();\n-            \/\/ testCase02(mainProcPid);\n+                \/\/ Excluding the test case below until JDK-8228850 is fixed\n+                \/\/ JDK-8228850: jhsdb jinfo fails with ClassCastException:\n+                \/\/ s.j.h.oops.TypeArray cannot be cast to s.j.h.oops.Instance\n+                \/\/ mainContainer.assertIsAlive();\n+                \/\/ testCase02(mainProcPid, attachStrategy);\n@@ -85,2 +87,3 @@\n-            mainContainer.assertIsAlive();\n-            testCase03(mainProcPid);\n+                mainContainer.assertIsAlive();\n+                testCase03(mainProcPid, attachStrategy);\n+            }\n@@ -96,2 +99,2 @@\n-    private static long testCase01() throws Exception {\n-        OutputAnalyzer out = runSideCar(MAIN_CONTAINER_NAME, \"\/jdk\/bin\/jcmd\", \"-l\")\n+    private static long testCase01(AttachStrategy attachStrategy) throws Exception {\n+        OutputAnalyzer out = runSideCar(MAIN_CONTAINER_NAME, attachStrategy, \"\/jdk\/bin\/jcmd\", \"-l\")\n@@ -102,1 +105,1 @@\n-            throw new RuntimeException(\"Could not find specified process\");\n+            throw new RuntimeException(attachStrategy + \": Could not find specified process\");\n@@ -109,2 +112,2 @@\n-    private static void testCase02(long pid) throws Exception {\n-        runSideCar(MAIN_CONTAINER_NAME, \"\/jdk\/bin\/jhsdb\", \"jinfo\", \"--pid\", \"\" + pid)\n+    private static void testCase02(long pid, AttachStrategy attachStrategy) throws Exception {\n+        runSideCar(MAIN_CONTAINER_NAME, attachStrategy, \"\/jdk\/bin\/jhsdb\", \"jinfo\", \"--pid\", \"\" + pid)\n@@ -118,2 +121,2 @@\n-    private static void testCase03(long pid) throws Exception {\n-        runSideCar(MAIN_CONTAINER_NAME, \"\/jdk\/bin\/jcmd\", \"\" + pid, \"help\")\n+    private static void testCase03(long pid, AttachStrategy attachStrategy) throws Exception {\n+        runSideCar(MAIN_CONTAINER_NAME, attachStrategy, \"\/jdk\/bin\/jcmd\", \"\" + pid, \"help\")\n@@ -122,1 +125,1 @@\n-        runSideCar(MAIN_CONTAINER_NAME, \"\/jdk\/bin\/jcmd\", \"\" + pid, \"JFR.start\")\n+        runSideCar(MAIN_CONTAINER_NAME, attachStrategy, \"\/jdk\/bin\/jcmd\", \"\" + pid, \"JFR.start\")\n@@ -130,3 +133,5 @@\n-    \/\/ buffers in \/tmp directory (hsperfdata_<user>). Thus, in sidecar\n-    \/\/ we mount \/tmp via --volumes-from from the main container.\n-    private static OutputAnalyzer runSideCar(String mainContainerName, String whatToRun,\n+    \/\/ buffers in \/tmp directory (hsperfdata_<user>). Thus, in the sidecar\n+    \/\/ we have two options:\n+    \/\/ 1. mount \/tmp from the main container using --volumes-from.\n+    \/\/ 2. access \/tmp from the main container via \/proc\/<pid>\/root\/tmp.\n+    private static OutputAnalyzer runSideCar(String mainContainerName, AttachStrategy attachStrategy, String whatToRun,\n@@ -134,2 +139,3 @@\n-        List<String> cmd = new ArrayList<>();\n-        String[] command = new String[] {\n+        System.out.println(\"Attach strategy \" + attachStrategy);\n+\n+        List<String> initialCommands = List.of(\n@@ -139,3 +145,6 @@\n-            \"--pid=container:\" + mainContainerName,\n-            \"--volumes-from\", mainContainerName,\n-            IMAGE_NAME, whatToRun\n+            \"--pid=container:\" + mainContainerName\n+        );\n+\n+        List<String> attachStrategyCommands = switch (attachStrategy) {\n+            case TMP_MOUNTED_INTO_SIDECAR -> List.of(\"--volumes-from\", mainContainerName);\n+            case ACCESS_TMP_VIA_PROC_ROOT -> List.of();\n@@ -144,1 +153,8 @@\n-        cmd.addAll(Arrays.asList(command));\n+        List<String> imageAndCommand = List.of(\n+            IMAGE_NAME, whatToRun\n+        );\n+\n+        List<String> cmd = new ArrayList<>();\n+        cmd.addAll(initialCommands);\n+        cmd.addAll(attachStrategyCommands);\n+        cmd.addAll(imageAndCommand);\n@@ -244,1 +260,1 @@\n-                    System.out.println(\"IllegalThreadStateException occured when calling exitValue()\");\n+                    System.out.println(\"IllegalThreadStateException occurred when calling exitValue()\");\n@@ -256,0 +272,4 @@\n+    private enum AttachStrategy {\n+        TMP_MOUNTED_INTO_SIDECAR,\n+        ACCESS_TMP_VIA_PROC_ROOT\n+    }\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJcmdWithSideCar.java","additions":46,"deletions":26,"binary":false,"changes":72,"status":"modified"}]}