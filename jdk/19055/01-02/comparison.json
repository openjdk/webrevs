{"files":[{"patch":"@@ -50,1 +50,1 @@\n-    private static final String tmpdir = \"\/tmp\";\n+    private static final Path TMPDIR = Path.of(\"\/tmp\");\n@@ -52,1 +52,8 @@\n-    private static final Optional<Path> MOUNT_NS;\n+    private static final Path PROC     = Path.of(\"\/proc\");\n+    private static final Path NS_MNT   = Path.of(\"ns\/mnt\");\n+    private static final Path NS_PID   = Path.of(\"ns\/pid\");\n+    private static final Path SELF     = PROC.resolve(\"self\");\n+    private static final Path STATUS   = Path.of(\"status\");\n+    private static final Path ROOT_TMP = Path.of(\"root\/tmp\");\n+\n+    private static final Optional<Path> SELF_MNT_NS;\n@@ -55,1 +62,2 @@\n-        Path mountNs = null;\n+        Path nsPath = null;\n+\n@@ -57,2 +65,3 @@\n-            mountNs = Files.readSymbolicLink(Path.of(\"\/proc\/self\/ns\/mnt\"));\n-        } catch (IOException ioe) {\n+            nsPath = Files.readSymbolicLink(SELF.resolve(NS_MNT));\n+        } catch (IOException _) {\n+            \/\/ do nothing\n@@ -60,1 +69,1 @@\n-            MOUNT_NS = Optional.ofNullable(mountNs);\n+            SELF_MNT_NS = Optional.ofNullable(nsPath);\n@@ -69,2 +78,1 @@\n-    VirtualMachineImpl(AttachProvider provider, String vmid)\n-        throws AttachNotSupportedException, IOException\n+    VirtualMachineImpl(AttachProvider provider, String vmid) throws AttachNotSupportedException, IOException\n@@ -80,2 +88,0 @@\n-        Path targetProcessTmpDir = findTargetProcessTmpDirectory(pid);\n-\n@@ -83,1 +89,1 @@\n-        int ns_pid = getNamespacePid(pid);\n+        final long ns_pid = getNamespacePid(pid);\n@@ -88,1 +94,1 @@\n-        File socket_file = findSocketFile(targetProcessTmpDir, ns_pid);\n+        final File socket_file = findSocketFile(pid, ns_pid);\n@@ -92,1 +98,1 @@\n-            File f = createAttachFile(pid, ns_pid, targetProcessTmpDir).getCanonicalFile();\n+            File f = createAttachFile(pid, ns_pid).getCanonicalFile();\n@@ -230,2 +236,2 @@\n-    private File findSocketFile(Path targetProcessTmpDirectory, int ns_pid) {\n-        return targetProcessTmpDirectory.resolve(\".java_pid\" + ns_pid).toFile();\n+    private File findSocketFile(long pid, long ns_pid) throws AttachNotSupportedException, IOException {\n+        return new File(findTargetProcessTmpDirectory(pid, ns_pid), \".java_pid\" + ns_pid);\n@@ -238,4 +244,4 @@\n-    private File createAttachFile(int pid, int ns_pid, Path targetProcessTmpDirectory) throws IOException {\n-        String fn = \".attach_pid\" + ns_pid;\n-        String path = \"\/proc\/\" + pid + \"\/cwd\/\" + fn;\n-        File f = new File(path);\n+    private File createAttachFile(long pid, long ns_pid) throws AttachNotSupportedException, IOException {\n+        Path fn   = Path.of(\".attach_pid\" + ns_pid);\n+        Path path = PROC.resolve(Path.of(Long.toString(pid), \"cwd\")).resolve(fn);\n+        File f    = new File(path.toString());\n@@ -245,2 +251,2 @@\n-        } catch (IOException x) {\n-            f = targetProcessTmpDirectory.resolve(fn).toFile();\n+        } catch (IOException _) {\n+            f = new File(findTargetProcessTmpDirectory(pid, ns_pid), fn.toString());\n@@ -252,1 +258,1 @@\n-    private Path findTargetProcessTmpDirectory(int pid) {\n+    private String findTargetProcessTmpDirectory(long pid, long ns_pid) throws AttachNotSupportedException, IOException {\n@@ -260,7 +266,0 @@\n-        \/\/\n-        \/\/ Hence, we start out by comparing mount namespaces. If they match, we know for sure that reading from and\n-        \/\/ writing to \/tmp will work. If not, we check if we can access the target process' \/tmp folder through\n-        \/\/ \/proc\/<pid>\/root\/tmp. This works in all cases except case 2. Even though both the caller and target process\n-        \/\/ are running as the same user, access to the \/proc\/<pid>\/root symlink is governed by ptrace access mode\n-        \/\/ PTRACE_MODE_READ_FSCREDS, and if the target process has elevated privileges set by setcap, access is denied\n-        \/\/ (see JDK-8226919). If \/proc\/<pid>\/root is not readable, as a last resort we fall back to trying \/tmp.\n@@ -268,1 +267,4 @@\n-        Optional<Path> targetMountNs = Optional.empty();\n+        Optional<ProcessHandle> target = ProcessHandle.of(pid);\n+        Optional<ProcessHandle> ph = target;\n+        long nsPid = ns_pid;\n+        Optional<Path> prevPidNS = Optional.empty();\n@@ -270,5 +272,2 @@\n-        try {\n-            targetMountNs = Optional.ofNullable(Files.readSymbolicLink(Path.of(\"\/proc\", Integer.toString(pid), \"ns\", \"mnt\")));\n-        } catch (IOException _) {\n-            \/\/ do nothing...\n-        }\n+        while (ph.isPresent()) {\n+            final var curPid = ph.get().pid();\n@@ -276,1 +275,1 @@\n-        final boolean sameMountNs = MOUNT_NS.isPresent() && targetMountNs.isPresent() && MOUNT_NS.equals(targetMountNs);\n+            final var procPidPath = PROC.resolve(Long.toString(curPid));\n@@ -278,4 +277,19 @@\n-        if (sameMountNs) {\n-            \/\/ Cases 1 and 3\n-            return Path.of(tmpdir);\n-        }\n+            Optional<Path> targetMountNS = Optional.empty();\n+\n+            try {\n+                targetMountNS = Optional.ofNullable(Files.readSymbolicLink(procPidPath.resolve(NS_MNT))); \/\/ attempt to read the target's mnt ns id...\n+            } catch (\n+                    IOException _) { \/\/ if we fail to read the target's mnt ns id then we either don't have access or it no longer exists!\n+                if (!Files.exists(procPidPath)) {\n+                    throw new IOException(String.format(\"unable to attach, %s non-existent! process: %d terminated\", procPidPath, pid));\n+                }\n+\n+                \/\/ ok so if we get here we have failed to read the target's mnt ns, but the target process still exists ... we do not have privileges to read its procfs\n+            }\n+\n+            final var sameMountNS = SELF_MNT_NS.isPresent() && SELF_MNT_NS.equals(targetMountNS); \/\/ will be false  if we did not read the target's mnt ns\n+\n+            if (sameMountNS) {\n+                return TMPDIR.toString(); \/\/ we share TMPDIR in common!\n+            } else {\n+                final var procPidRootTmp = procPidPath.resolve(ROOT_TMP);\n@@ -283,4 +297,34 @@\n-        Path procRootDirectory = Path.of(\"\/proc\", Integer.toString(pid), \"root\" );\n-        if (Files.isReadable(procRootDirectory)) {\n-            \/\/ Case 4\n-            return Path.of(procRootDirectory.toString(), tmpdir);\n+                if (Files.isReadable(procPidRootTmp)) {\n+                    return procPidRootTmp.toString(); \/\/ not in the same mnt ns but tmp is accessible via \/proc...\n+                }\n+            }\n+\n+            \/\/ let's attempt to obtain the pid NS... best efforts to avoid crossing pid ns boundaries (as with a container)\n+\n+            Optional<Path> curPidNS = Optional.empty();\n+\n+            try {\n+                curPidNS = Optional.ofNullable(Files.readSymbolicLink(procPidPath.resolve(NS_PID))); \/\/ attempt to read the target's mnt ns id...\n+            } catch (IOException _) { \/\/ if we fail to read the target's pid ns id then we either don't have access or it no longer exists!\n+                if (!Files.exists(procPidPath)) {\n+                    throw new IOException(String.format(\"unable to attach, %s non-existent! process: %d terminated\", procPidPath, pid));\n+                }\n+\n+                \/\/ ok so if we get here we have failed to read the target's pid ns, but the target process still exists ... we do not have privileges to read its procfs\n+            }\n+\n+            \/\/ recurse \"up\" the process hierarchy... if appropriate\n+\n+            final var havePidNSes = prevPidNS.isPresent() && curPidNS.isPresent();\n+\n+            final var ppid = ph.get().parent();\n+\n+            if (ppid.isPresent() && (havePidNSes && curPidNS.equals(prevPidNS)) || (!havePidNSes && nsPid > 1)) {\n+                ph = ppid;\n+\n+                nsPid = getNamespacePid(ph.get().pid()); \/\/ get the ns pid of the parent...\n+\n+                prevPidNS = curPidNS;\n+            } else {\n+                ph = Optional.empty();\n+            }\n@@ -289,3 +333,5 @@\n-        \/\/ Case 2, and cases where no matching process is running or the attacher process is running as a non-privileged\n-        \/\/ user and the target process is running as another user than the attacher.\n-        return Path.of(tmpdir);\n+        if (target.orElseThrow(AttachNotSupportedException::new).isAlive()) {\n+            return TMPDIR.toString(); \/\/ fallback...\n+        } else {\n+            throw new IOException(String.format(\"unable to attach, process: %d terminated\", pid));\n+        }\n@@ -311,1 +357,1 @@\n-    private int getNamespacePid(int pid) throws AttachNotSupportedException {\n+    private long getNamespacePid(long pid) throws AttachNotSupportedException, IOException {\n@@ -314,1 +360,1 @@\n-        String statusFile = \"\/proc\/\" + pid + \"\/status\";\n+        final var statusFile = PROC.resolve(Long.toString(pid)).resolve(STATUS).toString();\n@@ -330,2 +376,1 @@\n-                    int ns_pid = Integer.parseInt(parts[parts.length - 1]);\n-                    return ns_pid;\n+                    return Long.parseLong(parts[parts.length - 1]);\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":96,"deletions":51,"binary":false,"changes":147,"status":"modified"}]}