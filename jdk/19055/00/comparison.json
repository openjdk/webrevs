{"files":[{"patch":"@@ -238,0 +238,13 @@\n+        \/\/ We need to handle at least 4 different scenarios:\n+        \/\/ 1. Caller and target processes share PID namespace and root filesystem (host to host).\n+        \/\/ 2. Caller and target processes share PID namespace and root filesystem but the target process has elevated\n+        \/\/    privileges (host to host).\n+        \/\/ 3. Caller and target processes share PID namespace but NOT root filesystem (container to container).\n+        \/\/ 4. Caller and target processes share neither PID namespace nor root filesystem (host to container).\n+        \/\/\n+        \/\/ Hence, we start out by trying to access the target process' \/tmp folder through \/proc\/<pid>\/root\/tmp. This\n+        \/\/ works in all cases except case 2. Even though both the caller and target process runs as the same user,\n+        \/\/ access to the \/proc\/<pid>\/root symlink is governed by ptrace access mode PTRACE_MODE_READ_FSCREDS, and if\n+        \/\/ if the target process has elevated privileges set by setcap access is denied (see JDK-8226919).\n+        \/\/ If \/proc\/<pid>\/root is not readable, we fall back to trying \/tmp.\n+\n@@ -239,7 +252,8 @@\n-        if (pid != ns_pid) {\n-            \/\/ A process may not exist in the same mount namespace as the caller, e.g.\n-            \/\/ if we are trying to attach to a JVM process inside a container.\n-            \/\/ Instead, attach relative to the target root filesystem as exposed by\n-            \/\/ procfs regardless of namespaces.\n-            String procRootDirectory = \"\/proc\/\" + pid + \"\/root\";\n-            if (!Files.isReadable(Path.of(procRootDirectory))) {\n+        String procRootDirectory = \"\/proc\/\" + pid + \"\/root\";\n+        if (Files.isReadable(Path.of(procRootDirectory))) {\n+            root = procRootDirectory + \"\/\" + tmpdir;\n+        }\n+        else {\n+            if (pid != ns_pid) {\n+                \/\/ Case 4, there is no point in trying \/tmp because if different PID namespaces surely means different\n+                \/\/ root filesystems too.\n@@ -251,2 +265,0 @@\n-            root = procRootDirectory + \"\/\" + tmpdir;\n-        } else {\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import java.util.EnumSet;\n@@ -77,1 +78,2 @@\n-            long mainProcPid = testCase01();\n+            for (AttachStrategy attachStrategy : EnumSet.allOf(AttachStrategy.class)) {\n+                long mainProcPid = testCase01(attachStrategy);\n@@ -79,5 +81,5 @@\n-            \/\/ Excluding the test case below until JDK-8228850 is fixed\n-            \/\/ JDK-8228850: jhsdb jinfo fails with ClassCastException:\n-            \/\/ s.j.h.oops.TypeArray cannot be cast to s.j.h.oops.Instance\n-            \/\/ mainContainer.assertIsAlive();\n-            \/\/ testCase02(mainProcPid);\n+                \/\/ Excluding the test case below until JDK-8228850 is fixed\n+                \/\/ JDK-8228850: jhsdb jinfo fails with ClassCastException:\n+                \/\/ s.j.h.oops.TypeArray cannot be cast to s.j.h.oops.Instance\n+                \/\/ mainContainer.assertIsAlive();\n+                \/\/ testCase02(mainProcPid, attachStrategy);\n@@ -85,2 +87,3 @@\n-            mainContainer.assertIsAlive();\n-            testCase03(mainProcPid);\n+                mainContainer.assertIsAlive();\n+                testCase03(mainProcPid, attachStrategy);\n+            }\n@@ -96,2 +99,2 @@\n-    private static long testCase01() throws Exception {\n-        OutputAnalyzer out = runSideCar(MAIN_CONTAINER_NAME, \"\/jdk\/bin\/jcmd\", \"-l\")\n+    private static long testCase01(AttachStrategy attachStrategy) throws Exception {\n+        OutputAnalyzer out = runSideCar(MAIN_CONTAINER_NAME, attachStrategy, \"\/jdk\/bin\/jcmd\", \"-l\")\n@@ -102,1 +105,1 @@\n-            throw new RuntimeException(\"Could not find specified process\");\n+            throw new RuntimeException(attachStrategy + \": Could not find specified process\");\n@@ -109,2 +112,2 @@\n-    private static void testCase02(long pid) throws Exception {\n-        runSideCar(MAIN_CONTAINER_NAME, \"\/jdk\/bin\/jhsdb\", \"jinfo\", \"--pid\", \"\" + pid)\n+    private static void testCase02(long pid, AttachStrategy attachStrategy) throws Exception {\n+        runSideCar(MAIN_CONTAINER_NAME, attachStrategy, \"\/jdk\/bin\/jhsdb\", \"jinfo\", \"--pid\", \"\" + pid)\n@@ -118,2 +121,2 @@\n-    private static void testCase03(long pid) throws Exception {\n-        runSideCar(MAIN_CONTAINER_NAME, \"\/jdk\/bin\/jcmd\", \"\" + pid, \"help\")\n+    private static void testCase03(long pid, AttachStrategy attachStrategy) throws Exception {\n+        runSideCar(MAIN_CONTAINER_NAME, attachStrategy, \"\/jdk\/bin\/jcmd\", \"\" + pid, \"help\")\n@@ -122,1 +125,1 @@\n-        runSideCar(MAIN_CONTAINER_NAME, \"\/jdk\/bin\/jcmd\", \"\" + pid, \"JFR.start\")\n+        runSideCar(MAIN_CONTAINER_NAME, attachStrategy, \"\/jdk\/bin\/jcmd\", \"\" + pid, \"JFR.start\")\n@@ -130,3 +133,5 @@\n-    \/\/ buffers in \/tmp directory (hsperfdata_<user>). Thus, in sidecar\n-    \/\/ we mount \/tmp via --volumes-from from the main container.\n-    private static OutputAnalyzer runSideCar(String mainContainerName, String whatToRun,\n+    \/\/ buffers in \/tmp directory (hsperfdata_<user>). Thus, in the sidecar\n+    \/\/ we have two options:\n+    \/\/ 1. mount \/tmp from the main container using --volumes-from.\n+    \/\/ 2. access \/tmp from the main container via \/proc\/<pid>\/root\/tmp.\n+    private static OutputAnalyzer runSideCar(String mainContainerName, AttachStrategy attachStrategy, String whatToRun,\n@@ -134,2 +139,3 @@\n-        List<String> cmd = new ArrayList<>();\n-        String[] command = new String[] {\n+        System.out.println(\"Attach strategy \" + attachStrategy);\n+\n+        List<String> initialCommands = List.of(\n@@ -139,3 +145,6 @@\n-            \"--pid=container:\" + mainContainerName,\n-            \"--volumes-from\", mainContainerName,\n-            IMAGE_NAME, whatToRun\n+            \"--pid=container:\" + mainContainerName\n+        );\n+\n+        List<String> attachStrategyCommands = switch (attachStrategy) {\n+            case TMP_MOUNTED_INTO_SIDECAR -> List.of(\"--volumes-from\", mainContainerName);\n+            case ACCESS_TMP_VIA_PROC_ROOT -> List.of();\n@@ -144,1 +153,8 @@\n-        cmd.addAll(Arrays.asList(command));\n+        List<String> imageAndCommand = List.of(\n+            IMAGE_NAME, whatToRun\n+        );\n+\n+        List<String> cmd = new ArrayList<>();\n+        cmd.addAll(initialCommands);\n+        cmd.addAll(attachStrategyCommands);\n+        cmd.addAll(imageAndCommand);\n@@ -244,1 +260,1 @@\n-                    System.out.println(\"IllegalThreadStateException occured when calling exitValue()\");\n+                    System.out.println(\"IllegalThreadStateException occurred when calling exitValue()\");\n@@ -256,0 +272,4 @@\n+    private enum AttachStrategy {\n+        TMP_MOUNTED_INTO_SIDECAR,\n+        ACCESS_TMP_VIA_PROC_ROOT\n+    }\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJcmdWithSideCar.java","additions":46,"deletions":26,"binary":false,"changes":72,"status":"modified"}]}