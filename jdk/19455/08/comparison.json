{"files":[{"patch":"@@ -3519,75 +3519,0 @@\n-bool os::committed_in_range(address start, size_t size, address& committed_start, size_t& committed_size) {\n-  int mincore_return_value;\n-  const size_t stripe = 1024;  \/\/ query this many pages each time\n-  unsigned char vec[stripe + 1];\n-  \/\/ set a guard\n-  vec[stripe] = 'X';\n-\n-  const size_t page_sz = os::vm_page_size();\n-  uintx pages = size \/ page_sz;\n-\n-  assert(is_aligned(start, page_sz), \"Start address must be page aligned\");\n-  assert(is_aligned(size, page_sz), \"Size must be page aligned\");\n-\n-  committed_start = nullptr;\n-\n-  int loops = checked_cast<int>((pages + stripe - 1) \/ stripe);\n-  int committed_pages = 0;\n-  address loop_base = start;\n-  bool found_range = false;\n-\n-  for (int index = 0; index < loops && !found_range; index ++) {\n-    assert(pages > 0, \"Nothing to do\");\n-    uintx pages_to_query = (pages >= stripe) ? stripe : pages;\n-    pages -= pages_to_query;\n-\n-    \/\/ Get stable read\n-    while ((mincore_return_value = mincore(loop_base, pages_to_query * page_sz, vec)) == -1 && errno == EAGAIN);\n-\n-    \/\/ During shutdown, some memory goes away without properly notifying NMT,\n-    \/\/ E.g. ConcurrentGCThread\/WatcherThread can exit without deleting thread object.\n-    \/\/ Bailout and return as not committed for now.\n-    if (mincore_return_value == -1 && errno == ENOMEM) {\n-      return false;\n-    }\n-\n-    \/\/ If mincore is not supported.\n-    if (mincore_return_value == -1 && errno == ENOSYS) {\n-      return false;\n-    }\n-\n-    assert(vec[stripe] == 'X', \"overflow guard\");\n-    assert(mincore_return_value == 0, \"Range must be valid\");\n-    \/\/ Process this stripe\n-    for (uintx vecIdx = 0; vecIdx < pages_to_query; vecIdx ++) {\n-      if ((vec[vecIdx] & 0x01) == 0) { \/\/ not committed\n-        \/\/ End of current contiguous region\n-        if (committed_start != nullptr) {\n-          found_range = true;\n-          break;\n-        }\n-      } else { \/\/ committed\n-        \/\/ Start of region\n-        if (committed_start == nullptr) {\n-          committed_start = loop_base + page_sz * vecIdx;\n-        }\n-        committed_pages ++;\n-      }\n-    }\n-\n-    loop_base += pages_to_query * page_sz;\n-  }\n-\n-  if (committed_start != nullptr) {\n-    assert(committed_pages > 0, \"Must have committed region\");\n-    assert(committed_pages <= int(size \/ page_sz), \"Can not commit more than it has\");\n-    assert(committed_start >= start && committed_start < start + size, \"Out of range\");\n-    committed_size = page_sz * committed_pages;\n-    return true;\n-  } else {\n-    assert(committed_pages == 0, \"Should not have committed region\");\n-    return false;\n-  }\n-}\n-\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":75,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -96,0 +96,3 @@\n+\/* Input\/Output types for mincore(2) *\/\n+typedef LINUX_ONLY(unsigned) char mincore_vec_t;\n+\n@@ -149,0 +152,88 @@\n+bool os::committed_in_range(address start, size_t size, address& committed_start, size_t& committed_size) {\n+\n+#ifdef _AIX\n+  committed_start = start;\n+  committed_size = size;\n+  return true;\n+#else\n+\n+  int mincore_return_value;\n+  constexpr size_t stripe = 1024;  \/\/ query this many pages each time\n+  mincore_vec_t vec [stripe + 1];\n+\n+  \/\/ set a guard\n+  DEBUG_ONLY(vec[stripe] = 'X');\n+\n+  size_t page_sz = os::vm_page_size();\n+  uintx pages = size \/ page_sz;\n+\n+  assert(is_aligned(start, page_sz), \"Start address must be page aligned\");\n+  assert(is_aligned(size, page_sz), \"Size must be page aligned\");\n+\n+  committed_start = nullptr;\n+\n+  int loops = checked_cast<int>((pages + stripe - 1) \/ stripe);\n+  int committed_pages = 0;\n+  address loop_base = start;\n+  bool found_range = false;\n+\n+  for (int index = 0; index < loops && !found_range; index ++) {\n+    assert(pages > 0, \"Nothing to do\");\n+    uintx pages_to_query = (pages >= stripe) ? stripe : pages;\n+    pages -= pages_to_query;\n+\n+    \/\/ Get stable read\n+    int fail_count = 0;\n+    while ((mincore_return_value = mincore(loop_base, pages_to_query * page_sz, vec)) == -1 && errno == EAGAIN){\n+      if (++fail_count == 1000){\n+        return false;\n+      }\n+    }\n+\n+    \/\/ During shutdown, some memory goes away without properly notifying NMT,\n+    \/\/ E.g. ConcurrentGCThread\/WatcherThread can exit without deleting thread object.\n+    \/\/ Bailout and return as not committed for now.\n+    if (mincore_return_value == -1 && errno == ENOMEM) {\n+      return false;\n+    }\n+\n+    \/\/ If mincore is not supported.\n+    if (mincore_return_value == -1 && errno == ENOSYS) {\n+      return false;\n+    }\n+\n+    assert(vec[stripe] == 'X', \"overflow guard\");\n+    assert(mincore_return_value == 0, \"Range must be valid\");\n+    \/\/ Process this stripe\n+    for (uintx vecIdx = 0; vecIdx < pages_to_query; vecIdx ++) {\n+      if ((vec[vecIdx] & 0x01) == 0) { \/\/ not committed\n+        \/\/ End of current contiguous region\n+        if (committed_start != nullptr) {\n+          found_range = true;\n+          break;\n+        }\n+      } else { \/\/ committed\n+        \/\/ Start of region\n+        if (committed_start == nullptr) {\n+          committed_start = loop_base + page_sz * vecIdx;\n+        }\n+        committed_pages ++;\n+      }\n+    }\n+\n+    loop_base += pages_to_query * page_sz;\n+  }\n+\n+  if (committed_start != nullptr) {\n+    assert(committed_pages > 0, \"Must have committed region\");\n+    assert(committed_pages <= int(size \/ page_sz), \"Can not commit more than it has\");\n+    assert(committed_start >= start && committed_start < start + size, \"Out of range\");\n+    committed_size = page_sz * committed_pages;\n+    return true;\n+  } else {\n+    assert(committed_pages == 0, \"Should not have committed region\");\n+    return false;\n+  }\n+#endif\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -275,7 +275,0 @@\n-#if !defined(LINUX) && !defined(_WINDOWS)\n-bool os::committed_in_range(address start, size_t size, address& committed_start, size_t& committed_size) {\n-  committed_start = start;\n-  committed_size = size;\n-  return true;\n-}\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -199,0 +199,36 @@\n+\n+  static void test_committed_in_range(size_t num_pages, size_t pages_to_touch) {\n+    bool result;\n+    size_t committed_size;\n+    address committed_start;\n+    size_t index;\n+\n+    const size_t page_sz = os::vm_page_size();\n+    const size_t size = num_pages * page_sz;\n+\n+    char* base = os::reserve_memory(size, !ExecMem, mtTest);\n+    ASSERT_NE(base, (char*)nullptr);\n+\n+    result = os::commit_memory(base, size, !ExecMem);\n+    ASSERT_TRUE(result);\n+\n+    result = os::committed_in_range((address)base, size, committed_start, committed_size);\n+    ASSERT_FALSE(result);\n+\n+    \/\/ Touch pages\n+    for (index = 0; index < pages_to_touch; index ++) {\n+      base[index * page_sz] = 'a';\n+    }\n+\n+    result = os::committed_in_range((address)base, size, committed_start, committed_size);\n+    ASSERT_TRUE(result);\n+    ASSERT_EQ(pages_to_touch * page_sz, committed_size);\n+    ASSERT_EQ(committed_start, (address)base);\n+\n+    os::uncommit_memory(base, size, false);\n+\n+    result = os::committed_in_range((address)base, size, committed_start, committed_size);\n+    ASSERT_FALSE(result);\n+\n+    os::release_memory(base, size);\n+  }\n@@ -217,0 +253,7 @@\n+\n+#if !defined(_WINDOWS) && !defined(_AIX)\n+TEST_VM(CommittedVirtualMemory, test_committed_in_range){\n+  CommittedVirtualMemoryTest::test_committed_in_range(1024, 1024);\n+  CommittedVirtualMemoryTest::test_committed_in_range(2, 1);\n+}\n+#endif\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,3 @@\n+import static jdk.test.lib.Platform.isLinux;\n+import static jdk.test.lib.Platform.isWindows;\n+\n@@ -36,1 +39,1 @@\n- * @test\n+ * @test id=preTouch\n@@ -42,1 +45,11 @@\n- * @run driver TestAlwaysPreTouchStacks\n+ * @run driver TestAlwaysPreTouchStacks preTouch\n+ *\/\n+\n+\/*\n+ * @test id=noPreTouch\n+ * @summary Test that only touched committed memory is reported as thread stack usage.\n+ * @requires os.family != \"aix\"\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver TestAlwaysPreTouchStacks noPreTouch\n@@ -93,0 +106,8 @@\n+            boolean preTouch;\n+            if (args.length == 1 && args[0].equals(\"noPreTouch\")){\n+                preTouch = false;\n+            } else if (args.length == 1 && args[0].equals(\"preTouch\")){\n+                preTouch = true;\n+            } else {\n+                throw new RuntimeException(\"Invalid test input. Must be 'preTouch' or 'noPreTouch'.\");\n+            }\n@@ -97,1 +118,0 @@\n-                    \"-XX:+AlwaysPreTouchStacks\",\n@@ -99,0 +119,3 @@\n+            if (preTouch){\n+                vmArgs.add(\"-XX:+AlwaysPreTouchStacks\");\n+            }\n@@ -113,2 +136,2 @@\n-            \/\/ We want to see, in the final NMT printout, a committed thread stack size very close to reserved\n-            \/\/ stack size. Like this:\n+            \/\/ If using -XX:+AlwaysPreTouchStacks, we want to see, in the final NMT printout,\n+            \/\/ a committed thread stack size very close to reserved stack size. Like this:\n@@ -138,1 +161,1 @@\n-                    if ((double)committed < ((double)reserved * 0.75)) {\n+                    if (preTouch && (double)committed < ((double)reserved * 0.75)) {\n@@ -140,0 +163,2 @@\n+                    } else if (!preTouch && (double)committed > ((double)reserved * 0.50)){\n+                        throw new RuntimeException(\"Expected a lower ratio between stack committed and reserved.\");\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestAlwaysPreTouchStacks.java","additions":32,"deletions":7,"binary":false,"changes":39,"status":"modified"}]}