{"files":[{"patch":"@@ -3516,75 +3516,0 @@\n-bool os::committed_in_range(address start, size_t size, address& committed_start, size_t& committed_size) {\n-  int mincore_return_value;\n-  const size_t stripe = 1024;  \/\/ query this many pages each time\n-  unsigned char vec[stripe + 1];\n-  \/\/ set a guard\n-  vec[stripe] = 'X';\n-\n-  const size_t page_sz = os::vm_page_size();\n-  uintx pages = size \/ page_sz;\n-\n-  assert(is_aligned(start, page_sz), \"Start address must be page aligned\");\n-  assert(is_aligned(size, page_sz), \"Size must be page aligned\");\n-\n-  committed_start = nullptr;\n-\n-  int loops = checked_cast<int>((pages + stripe - 1) \/ stripe);\n-  int committed_pages = 0;\n-  address loop_base = start;\n-  bool found_range = false;\n-\n-  for (int index = 0; index < loops && !found_range; index ++) {\n-    assert(pages > 0, \"Nothing to do\");\n-    uintx pages_to_query = (pages >= stripe) ? stripe : pages;\n-    pages -= pages_to_query;\n-\n-    \/\/ Get stable read\n-    while ((mincore_return_value = mincore(loop_base, pages_to_query * page_sz, vec)) == -1 && errno == EAGAIN);\n-\n-    \/\/ During shutdown, some memory goes away without properly notifying NMT,\n-    \/\/ E.g. ConcurrentGCThread\/WatcherThread can exit without deleting thread object.\n-    \/\/ Bailout and return as not committed for now.\n-    if (mincore_return_value == -1 && errno == ENOMEM) {\n-      return false;\n-    }\n-\n-    \/\/ If mincore is not supported.\n-    if (mincore_return_value == -1 && errno == ENOSYS) {\n-      return false;\n-    }\n-\n-    assert(vec[stripe] == 'X', \"overflow guard\");\n-    assert(mincore_return_value == 0, \"Range must be valid\");\n-    \/\/ Process this stripe\n-    for (uintx vecIdx = 0; vecIdx < pages_to_query; vecIdx ++) {\n-      if ((vec[vecIdx] & 0x01) == 0) { \/\/ not committed\n-        \/\/ End of current contiguous region\n-        if (committed_start != nullptr) {\n-          found_range = true;\n-          break;\n-        }\n-      } else { \/\/ committed\n-        \/\/ Start of region\n-        if (committed_start == nullptr) {\n-          committed_start = loop_base + page_sz * vecIdx;\n-        }\n-        committed_pages ++;\n-      }\n-    }\n-\n-    loop_base += pages_to_query * page_sz;\n-  }\n-\n-  if (committed_start != nullptr) {\n-    assert(committed_pages > 0, \"Must have committed region\");\n-    assert(committed_pages <= int(size \/ page_sz), \"Can not commit more than it has\");\n-    assert(committed_start >= start && committed_start < start + size, \"Out of range\");\n-    committed_size = page_sz * committed_pages;\n-    return true;\n-  } else {\n-    assert(committed_pages == 0, \"Should not have committed region\");\n-    return false;\n-  }\n-}\n-\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":75,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -96,0 +96,3 @@\n+\/* Input\/Output types for mincore(2) *\/\n+typedef LINUX_ONLY(unsigned) char mincore_vec_t;\n+\n@@ -149,0 +152,81 @@\n+bool os::committed_in_range(address start, size_t size, address& committed_start, size_t& committed_size) {\n+  int mincore_return_value;\n+  const size_t stripe = 1024;  \/\/ query this many pages each time\n+  mincore_vec_t* vec = (mincore_vec_t*) malloc(stripe + 1, mtInternal);\n+\n+  if (vec == NULL) {\n+    return false;\n+  }\n+\n+  \/\/ set a guard\n+  vec[stripe] = 'X';\n+  size_t page_sz = NOT_AIX(os::vm_page_size()) AIX_ONLY(sysconf(_SC_PAGESIZE));\n+  uintx pages = size \/ page_sz;\n+\n+  assert(is_aligned(start, page_sz), \"Start address must be page aligned\");\n+  assert(is_aligned(size, page_sz), \"Size must be page aligned\");\n+\n+  committed_start = nullptr;\n+\n+  int loops = checked_cast<int>((pages + stripe - 1) \/ stripe);\n+  int committed_pages = 0;\n+  address loop_base = start;\n+  bool found_range = false;\n+\n+  for (int index = 0; index < loops && !found_range; index ++) {\n+    assert(pages > 0, \"Nothing to do\");\n+    uintx pages_to_query = (pages >= stripe) ? stripe : pages;\n+    pages -= pages_to_query;\n+\n+    \/\/ Get stable read\n+    while ((mincore_return_value = mincore(AIX_ONLY((char*)) loop_base, pages_to_query * page_sz, vec)) == -1 && errno == EAGAIN);\n+\n+    \/\/ During shutdown, some memory goes away without properly notifying NMT,\n+    \/\/ E.g. ConcurrentGCThread\/WatcherThread can exit without deleting thread object.\n+    \/\/ Bailout and return as not committed for now.\n+    if (mincore_return_value == -1 && errno == ENOMEM) {\n+      os::free(vec);\n+      return false;\n+    }\n+\n+    \/\/ If mincore is not supported.\n+    if (mincore_return_value == -1 && errno == ENOSYS) {\n+      os::free(vec);\n+      return false;\n+    }\n+\n+    assert(vec[stripe] == 'X', \"overflow guard\");\n+    assert(mincore_return_value == 0, \"Range must be valid\");\n+    \/\/ Process this stripe\n+    for (uintx vecIdx = 0; vecIdx < pages_to_query; vecIdx ++) {\n+      if ((vec[vecIdx] & 0x01) == 0) { \/\/ not committed\n+        \/\/ End of current contiguous region\n+        if (committed_start != nullptr) {\n+          found_range = true;\n+          break;\n+        }\n+      } else { \/\/ committed\n+        \/\/ Start of region\n+        if (committed_start == nullptr) {\n+          committed_start = loop_base + page_sz * vecIdx;\n+        }\n+        committed_pages ++;\n+      }\n+    }\n+\n+    loop_base += pages_to_query * page_sz;\n+  }\n+  os::free(vec);\n+\n+  if (committed_start != nullptr) {\n+    assert(committed_pages > 0, \"Must have committed region\");\n+    assert(committed_pages <= int(size \/ page_sz), \"Can not commit more than it has\");\n+    assert(committed_start >= start && committed_start < start + size, \"Out of range\");\n+    committed_size = page_sz * committed_pages;\n+    return true;\n+  } else {\n+    assert(committed_pages == 0, \"Should not have committed region\");\n+    return false;\n+  }\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -265,7 +265,0 @@\n-#if !defined(LINUX) && !defined(_WINDOWS)\n-bool os::committed_in_range(address start, size_t size, address& committed_start, size_t& committed_size) {\n-  committed_start = start;\n-  committed_size = size;\n-  return true;\n-}\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -217,0 +217,67 @@\n+\n+#ifndef _WINDOWS\n+TEST_VM(CommittedVirtualMemory, test_full_committed_in_range){\n+  bool   result;\n+  size_t committed_size;\n+  address committed_start;\n+  size_t index;\n+\n+  const size_t page_sz = os::vm_page_size();\n+  const size_t num_pages = 1024;\n+  const size_t size = num_pages * page_sz;\n+  char* base = os::reserve_memory(size, !ExecMem, mtTest);\n+  ASSERT_NE(base, (char*)nullptr);\n+  result = os::commit_memory(base, size, !ExecMem);\n+\n+  ASSERT_TRUE(result);\n+\n+  result = os::committed_in_range((address)base, size, committed_start, committed_size);\n+  ASSERT_FALSE(result);\n+\n+  \/\/ Touch all pages\n+  for (index = 0; index < num_pages; index ++) {\n+  *(base + index * page_sz) = 'a';\n+  }\n+\n+  result = os::committed_in_range((address)base, size, committed_start, committed_size);\n+  ASSERT_TRUE(result);\n+  ASSERT_EQ(num_pages * page_sz, committed_size);\n+  ASSERT_EQ(committed_start, (address)base);\n+\n+  os::uncommit_memory(base, size, false);\n+\n+  result = os::committed_in_range((address)base, size, committed_start, committed_size);\n+  ASSERT_FALSE(result);\n+}\n+\n+TEST_VM(CommittedVirtualMemory, test_partial_committed_in_range){\n+  bool   result;\n+  size_t committed_size;\n+  address committed_start;\n+\n+  const size_t page_sz = os::vm_page_size();\n+  const size_t num_pages = 2;\n+  const size_t size = num_pages * page_sz;\n+  char* base = os::reserve_memory(size, !ExecMem, mtTest);\n+  ASSERT_NE(base, (char*)nullptr);\n+  result = os::commit_memory(base, size, !ExecMem);\n+\n+  ASSERT_TRUE(result);\n+\n+  \/\/ Test whole range\n+  result = os::committed_in_range((address)base, size, committed_start, committed_size);\n+  ASSERT_FALSE(result);\n+\n+\n+  \/\/ touch first page\n+  *base = 'a';\n+\n+  \/\/ Test whole range\n+  result = os::committed_in_range((address)base, size, committed_start, committed_size);\n+  ASSERT_TRUE(result);\n+  ASSERT_EQ(page_sz, committed_size); \/\/ Only one page touched\n+  ASSERT_EQ(committed_start, (address)base);\n+\n+  os::release_memory(base, size);\n+}\n+#endif\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n@@ -34,0 +37,3 @@\n+import static jdk.test.lib.Platform.isLinux;\n+import static jdk.test.lib.Platform.isWindows;\n+\n@@ -35,1 +41,1 @@\n- * @test\n+ * @test id=preTouch\n@@ -37,1 +43,0 @@\n- * @requires os.family != \"aix\"\n@@ -41,1 +46,10 @@\n- * @run driver TestAlwaysPreTouchStacks\n+ * @run driver TestAlwaysPreTouchStacks preTouch\n+ *\/\n+\n+\/*\n+ * @test id=noPreTouch\n+ * @summary Test that only touched committed memory is reported as thread stack usage.\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver TestAlwaysPreTouchStacks noPreTouch\n@@ -92,2 +106,2 @@\n-\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            boolean noPreTouch = args.length == 1 && args[0].equals(\"noPreTouch\");\n+            List<String> options = new LinkedList<>(Arrays.asList(\n@@ -96,4 +110,13 @@\n-                    \"-XX:+AlwaysPreTouchStacks\",\n-                    \"-XX:NativeMemoryTracking=summary\", \"-XX:+PrintNMTStatistics\",\n-                    \"TestAlwaysPreTouchStacks\",\n-                    \"test\");\n+                    \"-XX:NativeMemoryTracking=summary\", \"-XX:+PrintNMTStatistics\"));\n+            if (!noPreTouch){\n+                options.add(\"-XX:+AlwaysPreTouchStacks\");\n+            }\n+\n+            if (isLinux()) {\n+                options.add( \"-XX:-UseMadvPopulateWrite\");\n+            }\n+\n+            options.add(\"TestAlwaysPreTouchStacks\");\n+            options.add(\"test\");\n+\n+            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(options);\n@@ -109,2 +132,2 @@\n-            \/\/ We want to see, in the final NMT printout, a committed thread stack size very close to reserved\n-            \/\/ stack size. Like this:\n+            \/\/ If using -XX:+AlwaysPreTouchStacks, we want to see, in the final NMT printout,\n+            \/\/ a committed thread stack size very close to reserved stack size. Like this:\n@@ -134,1 +157,1 @@\n-                    if ((double)committed < ((double)reserved * 0.75)) {\n+                    if (!noPreTouch && (double)committed < ((double)reserved * 0.75)) {\n@@ -136,0 +159,2 @@\n+                    } else if (noPreTouch && (double)committed > ((double)reserved * 0.50)){\n+                        throw new RuntimeException(\"Expected a lower ratio between stack committed and reserved.\");\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestAlwaysPreTouchStacks.java","additions":37,"deletions":12,"binary":false,"changes":49,"status":"modified"}]}