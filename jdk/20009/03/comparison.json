{"files":[{"patch":"@@ -694,3 +694,1 @@\n-  BasicType longer_bt = longer_type_for_conversion(s1);\n-  if (Matcher::max_vector_size_auto_vectorization(bt1) < 2 ||\n-      (longer_bt != T_ILLEGAL && Matcher::max_vector_size_auto_vectorization(longer_bt) < 2)) {\n+  if (Matcher::max_vector_size_auto_vectorization(bt1) < 2) {\n@@ -2445,21 +2443,0 @@\n-BasicType SuperWord::longer_type_for_conversion(Node* n) const {\n-  if (!(VectorNode::is_convert_opcode(n->Opcode()) ||\n-        VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(n->Opcode())) ||\n-      !in_bb(n->in(1))) {\n-    return T_ILLEGAL;\n-  }\n-  assert(in_bb(n), \"must be in the bb\");\n-  BasicType src_t = velt_basic_type(n->in(1));\n-  BasicType dst_t = velt_basic_type(n);\n-  \/\/ Do not use superword for non-primitives.\n-  \/\/ Superword does not support casting involving unsigned types.\n-  if (!is_java_primitive(src_t) || is_unsigned_subword_type(src_t) ||\n-      !is_java_primitive(dst_t) || is_unsigned_subword_type(dst_t)) {\n-    return T_ILLEGAL;\n-  }\n-  int src_size = type2aelembytes(src_t);\n-  int dst_size = type2aelembytes(dst_t);\n-  return src_size == dst_size ? T_ILLEGAL\n-                              : (src_size > dst_size ? src_t : dst_t);\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -626,3 +626,0 @@\n-  \/\/ Return the longer type for vectorizable type-conversion node or illegal type for other nodes.\n-  BasicType longer_type_for_conversion(Node* n) const;\n-\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}