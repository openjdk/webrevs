{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.net.ProtocolException;\n@@ -49,0 +50,1 @@\n+import static jdk.internal.net.http.common.Utils.readContentLength;\n@@ -275,1 +277,2 @@\n-     * Read up to MAX_IGNORE bytes discarding\n+     * Reads the body, if it is present and less than {@value MAX_IGNORE} bytes.\n+     * Otherwise, just the connection is closed.\n@@ -278,2 +281,17 @@\n-        int clen = (int)headers.firstValueAsLong(\"Content-Length\").orElse(-1);\n-        if (clen == -1 || clen > MAX_IGNORE) {\n+\n+        \/\/ Read the `Content-Length` header\n+        long clen;\n+        try {\n+            clen = readContentLength(headers, \"\", -1);\n+        } catch (ProtocolException pe) {\n+            return MinimalFuture.failedFuture(pe);\n+        }\n+\n+        \/\/ Read the body, if it is present and less than `MAX_IGNORE` bytes.\n+        \/\/\n+        \/\/ We proceed with reading the body even when `Content-Length: 0` to\n+        \/\/ ensure that the happy path is taken, and upon success, the connection\n+        \/\/ is returned back to the pool.\n+        if (clen != -1 && clen <= MAX_IGNORE) {\n+            return readBody(discarding(), !request.isWebSocket(), executor);\n+        } else {\n@@ -282,2 +300,0 @@\n-        } else {\n-            return readBody(discarding(), !request.isWebSocket(), executor);\n@@ -285,0 +301,1 @@\n+\n@@ -314,2 +331,9 @@\n-        long clen0 = headers.firstValueAsLong(\"Content-Length\").orElse(-1L);\n-        final long clen = fixupContentLen(clen0);\n+        \/\/ Read the content length\n+        long clen;\n+        try {\n+            long clen0 = readContentLength(headers, \"\", -1);\n+            clen = fixupContentLen(clen0);\n+        } catch (ProtocolException pe) {\n+            cf.completeExceptionally(pe);\n+            return cf;\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Response.java","additions":31,"deletions":7,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -84,0 +84,2 @@\n+\n+import static jdk.internal.net.http.common.Utils.readContentLength;\n@@ -1284,1 +1286,4 @@\n-        long clen = promiseHeaders.firstValueAsLong(\"Content-Length\").orElse(-1);\n+\n+        \/\/ Read & validate `Content-Length`\n+        long clen = readContentLength(\n+                promiseHeaders, \"illegal push headers for pushId=%s: \".formatted(pushId), -1);\n@@ -1286,1 +1291,1 @@\n-            throw new ProtocolException(\"push headers contain non-zero Content-Length for pushId=\" + pushId);\n+            throw new ProtocolException(\"push headers contain non-zero \\\"Content-Length\\\" for pushId=\" + pushId);\n@@ -1288,0 +1293,1 @@\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http3ExchangeImpl.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.util.OptionalLong;\n@@ -61,0 +60,2 @@\n+import static jdk.internal.net.http.common.Utils.readContentLength;\n+import static jdk.internal.net.http.common.Utils.readStatusCode;\n@@ -609,1 +610,0 @@\n-         boolean finalResponse = false;\n@@ -611,4 +611,2 @@\n-             responseCode = (int) responseHeaders\n-                     .firstValueAsLong(\":status\")\n-                     .orElseThrow(() -> new IOException(\"no statuscode in response\"));\n-         } catch (IOException | NumberFormatException exception) {\n+             responseCode = readStatusCode(responseHeaders, \"\");\n+         } catch (ProtocolException pe) {\n@@ -618,5 +616,1 @@\n-             cancelImpl(exception, Http3Error.H3_MESSAGE_ERROR);\n-             return;\n-         }\n-         if (responseCode < 100 || responseCode > 999) {\n-             cancelImpl(new IOException(\"Unexpected :status header value\"), Http3Error.H3_MESSAGE_ERROR);\n+             cancelImpl(pe, Http3Error.H3_MESSAGE_ERROR);\n@@ -626,0 +620,1 @@\n+         boolean finalResponse = false;\n@@ -630,1 +625,0 @@\n-             assert responseCode >= 100 && responseCode <= 200 : \"unexpected responseCode: \" + responseCode;\n@@ -656,13 +650,14 @@\n-         try {\n-             OptionalLong cl = responseHeaders.firstValueAsLong(\"content-length\");\n-             if (finalResponse && cl.isPresent()) {\n-                 long cll = cl.getAsLong();\n-                 if (cll < 0) {\n-                     cancelImpl(new IOException(\"Invalid content-length value \"+cll), Http3Error.H3_MESSAGE_ERROR);\n-                     return;\n-                 }\n-                 if (!(exchange.request().method().equalsIgnoreCase(\"HEAD\") || responseCode == HTTP_NOT_MODIFIED)) {\n-                     \/\/ HEAD response and 304 response might have a content-length header,\n-                     \/\/ but it carries no meaning\n-                     contentLength = cll;\n-                 }\n+         if (finalResponse) {\n+             long cl;\n+             try {\n+                 cl = readContentLength(responseHeaders, \"\", -1);\n+             } catch (ProtocolException pe) {\n+                 cancelImpl(pe, Http3Error.H3_MESSAGE_ERROR);\n+                 return;\n+             }\n+             if (cl != -1 &&\n+                     !(exchange.request().method().equalsIgnoreCase(\"HEAD\") ||\n+                             responseCode == HTTP_NOT_MODIFIED)) {\n+                 \/\/ HEAD response and 304 response might have a content-length header,\n+                 \/\/ but it carries no meaning\n+                 contentLength = cl;\n@@ -670,3 +665,0 @@\n-         } catch (NumberFormatException nfe) {\n-             cancelImpl(nfe, Http3Error.H3_MESSAGE_ERROR);\n-             return;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http3Stream.java","additions":20,"deletions":28,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.IOError;\n@@ -32,0 +31,1 @@\n+import java.net.ProtocolException;\n@@ -34,0 +34,1 @@\n+import java.net.http.HttpHeaders;\n@@ -51,1 +52,0 @@\n-import java.net.http.HttpHeaders;\n@@ -66,0 +66,1 @@\n+import static jdk.internal.net.http.common.Utils.readContentLength;\n@@ -362,7 +363,16 @@\n-    private boolean bodyIsPresent(Response r) {\n-        HttpHeaders headers = r.headers();\n-        if (headers.firstValueAsLong(\"Content-length\").orElse(0L) != 0L)\n-            return true;\n-        if (headers.firstValue(\"Transfer-encoding\").isPresent())\n-            return true;\n-        return false;\n+    private void ensureNoBody(HttpHeaders headers) throws ProtocolException {\n+\n+        \/\/ Check `Content-Length`\n+        var contentLength = readContentLength(headers, \"\", 0);\n+        if (contentLength > 0) {\n+            throw new ProtocolException(\n+                    \"Unexpected \\\"Content-Length\\\" header in a 204 response: \" + contentLength);\n+        }\n+\n+        \/\/ Check `Transfer-Encoding`\n+        var transferEncoding = headers.firstValue(\"Transfer-Encoding\");\n+        if (transferEncoding.isPresent()) {\n+            throw new ProtocolException(\n+                    \"Unexpected \\\"Transfer-Encoding\\\" header in a 204 response: \" + transferEncoding.get());\n+        }\n+\n@@ -407,7 +417,7 @@\n-                            if (bodyIsPresent(r)) {\n-                                IOException ioe = new IOException(\n-                                    \"unexpected content length header with 204 response\");\n-                                exch.cancel(ioe);\n-                                return MinimalFuture.failedFuture(ioe);\n-                            } else\n-                                return handleNoBody(r, exch);\n+                            try {\n+                                ensureNoBody(r.headers);\n+                            } catch (ProtocolException pe) {\n+                                exch.cancel(pe);\n+                                return MinimalFuture.failedFuture(pe);\n+                            }\n+                            return handleNoBody(r, exch);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/MultiExchange.java","additions":26,"deletions":16,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+import static jdk.internal.net.http.common.Utils.readStatusCode;\n@@ -618,1 +619,1 @@\n-    protected void handleResponse(HeaderFrame hf) throws IOException {\n+    protected void handleResponse(HeaderFrame hf) {\n@@ -623,7 +624,3 @@\n-                responseCode = (int) responseHeaders\n-                        .firstValueAsLong(\":status\")\n-                        .orElseThrow(() -> new ProtocolException(String.format(\n-                                \"Stream %s PROTOCOL_ERROR: no status code in response\",\n-                                streamid)));\n-            } catch (ProtocolException cause) {\n-                cancelImpl(cause, ResetFrame.PROTOCOL_ERROR);\n+                responseCode = readStatusCode(responseHeaders, \"Stream %s PROTOCOL_ERROR: \".formatted(streamid));\n+            } catch (ProtocolException pe) {\n+                cancelImpl(pe, ResetFrame.PROTOCOL_ERROR);\n@@ -663,6 +660,0 @@\n-            \/* TODO: review if needs to be removed\n-               the value is not used, but in case `content-length` doesn't parse as\n-               long, there will be NumberFormatException. If left as is, make sure\n-               code up the stack handles NFE correctly. *\/\n-            responseHeaders.firstValueAsLong(\"content-length\");\n-\n@@ -1758,6 +1749,10 @@\n-                responseCode = (int)responseHeaders\n-                    .firstValueAsLong(\":status\")\n-                    .orElse(-1);\n-\n-                if (responseCode == -1) {\n-                    cancelImpl(new ProtocolException(\"No status code\"), ResetFrame.PROTOCOL_ERROR);\n+                try {\n+                    responseCode = readStatusCode(responseHeaders, \"\");\n+                    if (responseCode >= 100 && responseCode < 200) {\n+                        String protocolErrorMsg = checkInterimResponseCountExceeded();\n+                        if (protocolErrorMsg != null) {\n+                            throw new ProtocolException(protocolErrorMsg);\n+                        }\n+                    }\n+                } catch (ProtocolException pe) {\n+                    cancelImpl(pe, ResetFrame.PROTOCOL_ERROR);\n@@ -1766,7 +1761,0 @@\n-                } else if (responseCode >= 100 && responseCode < 200) {\n-                    String protocolErrorMsg = checkInterimResponseCountExceeded();\n-                    if (protocolErrorMsg != null) {\n-                        cancelImpl(new ProtocolException(protocolErrorMsg), ResetFrame.PROTOCOL_ERROR);\n-                        rspHeadersConsumer.reset();\n-                        return;\n-                    }\n@@ -1781,6 +1769,0 @@\n-                \/* TODO: review if needs to be removed\n-                   the value is not used, but in case `content-length` doesn't parse\n-                   as long, there will be NumberFormatException. If left as is, make\n-                   sure code up the stack handles NFE correctly. *\/\n-                responseHeaders.firstValueAsLong(\"content-length\");\n-\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":15,"deletions":33,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.net.ProtocolException;\n@@ -1348,0 +1349,41 @@\n+    public static int readStatusCode(HttpHeaders headers, String errorPrefix) throws ProtocolException {\n+        var s = headers.firstValue(\":status\").orElse(null);\n+        if (s == null) {\n+            throw new ProtocolException(errorPrefix + \"missing status code\");\n+        }\n+        Throwable t = null;\n+        int i = 0;\n+        try {\n+            i = Integer.parseInt(s);\n+        } catch (NumberFormatException nfe) {\n+            t = nfe;\n+        }\n+        if (t != null || i < 100 || i > 999) {\n+            var pe = new ProtocolException(errorPrefix + \"invalid status code: \" + s);\n+            pe.initCause(t);\n+            throw pe;\n+        }\n+        return i;\n+    }\n+\n+    public static long readContentLength(HttpHeaders headers, String errorPrefix, long defaultIfMissing) throws ProtocolException {\n+        var k = \"Content-Length\";\n+        var s = headers.firstValue(k).orElse(null);\n+        if (s == null) {\n+            return defaultIfMissing;\n+        }\n+        Throwable t = null;\n+        long i = 0;\n+        try {\n+            i = Long.parseLong(s);\n+        } catch (NumberFormatException nfe) {\n+            t = nfe;\n+        }\n+        if (t != null || i < 0) {\n+            var pe = new ProtocolException(\"%sinvalid \\\"%s\\\": %s\".formatted(errorPrefix, k, s));\n+            pe.initCause(t);\n+            throw pe;\n+        }\n+        return i;\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.httpclient.test.lib.quic.QuicServerConnection;\n@@ -27,2 +26,2 @@\n-import jdk.internal.net.http.http3.Http3Error;\n-import jdk.internal.net.http.quic.TerminationCause;\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n@@ -32,5 +31,4 @@\n-import jdk.test.lib.Utils;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -39,0 +37,1 @@\n+import java.io.IOException;\n@@ -40,2 +39,1 @@\n-import java.net.URI;\n-import java.net.URISyntaxException;\n+import java.net.ProtocolException;\n@@ -48,3 +46,2 @@\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BooleanSupplier;\n@@ -52,1 +49,1 @@\n-import static java.net.http.HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n@@ -54,1 +51,5 @@\n-import static org.testng.Assert.*;\n+import static java.net.http.HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -58,9 +59,5 @@\n- * @summary Verifies that the HTTP client correctly handles malformed responses\n- * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n- * @library ..\/access\n- * @build jdk.test.lib.net.SimpleSSLContext\n- *        jdk.httpclient.test.lib.common.HttpServerAdapters\n- * @build java.net.http\/jdk.internal.net.http.Http3ConnectionAccess\n- * @run testng\/othervm\n- *              -Djdk.internal.httpclient.debug=true\n- *              -Djdk.httpclient.HttpClient.log=requests,responses,errors H3MalformedResponseTest\n+ * @bug 8369595\n+ * @summary Verifies that the HTTP\/3 malformed responses are correctly handled\n+ * @library \/test\/jdk\/java\/net\/httpclient\/lib\n+ *          \/test\/lib\n+ * @run junit ${test.main.class}\n@@ -68,1 +65,0 @@\n-public class H3MalformedResponseTest implements HttpServerAdapters {\n@@ -70,3 +66,121 @@\n-    private SSLContext sslContext;\n-    private QuicStandaloneServer server;\n-    private String requestURIBase;\n+\/\/\/ Verifies that the HTTP\/3 malformed responses are correctly handled.\n+\/\/\/\n+\/\/\/ ### HTTP\/3 `HEADERS` frame & QPACK Field Section encoding crash course\n+\/\/\/\n+\/\/\/ Consider an HTTP\/3 `HEADERS` frame that carries:\n+\/\/\/\n+\/\/\/ ```\n+\/\/\/ :status: 200\n+\/\/\/ content-length: 2\n+\/\/\/ ```\n+\/\/\/\n+\/\/\/ This will be encoded as the following byte sequence:\n+\/\/\/\n+\/\/\/ ```\n+\/\/\/ 01 06 00 00 D9 54 01 32\n+\/\/\/ ```\n+\/\/\/\n+\/\/\/ Let's start with decoding the HTTP\/3 frame:\n+\/\/\/\n+\/\/\/ - `01`: Frame Type (`01` denotes `HEADERS``)\n+\/\/\/\n+\/\/\/ - `06`: Payload length (6 bytes)\n+\/\/\/\n+\/\/\/ Figured this is a `HEADERS` frame containing 6 bytes: `00 00 D9 54 01 32`.\n+\/\/\/ Let's decode the QPACK Field Section\n+\/\/\/\n+\/\/\/ - `00`: Required Insert Count (0)\n+\/\/\/\n+\/\/\/ - `00`: Base (0)\n+\/\/\/\n+\/\/\/ - `D9`:\n+\/\/\/   QPACK has a static table (indexed from 0) and `:status: 200` is at the\n+\/\/\/   static-table index 25.\n+\/\/\/\n+\/\/\/   ```\n+\/\/\/   D9 = <1101 1001>\n+\/\/\/      = <1> (Indexed Field Line)\n+\/\/\/      + <1> (Static Table)\n+\/\/\/      + <01 1001> (entry index = 25)\n+\/\/\/   ```\n+\/\/\/\n+\/\/\/ - `54 01 32`:\n+\/\/\/   `content-length: 2` can be encoded as a *literal field line with name\n+\/\/\/   reference* using the static name `content-length` (static index 4) and\n+\/\/\/   the literal value `2`.\n+\/\/\/\n+\/\/\/   ```\n+\/\/\/   54 01 32 = <0101 0100 0000 0001 0011 0010>\n+\/\/\/            = <0> (Literal Field Line)\n+\/\/\/            + <1> (Name Reference)\n+\/\/\/            + <0100> (entry index = 4)\n+\/\/\/            + <0000 0001> (value length = 1 byte)\n+\/\/\/            + <0011 0010> (value = ASCII \"2\" = 0x32 = 50)\n+\/\/\/   ```\n+\/\/\/\n+\/\/\/ Note that the `value length` field (i.e., `0000 0001`) follows a variable\n+\/\/\/ coding scheme:\n+\/\/\/\n+\/\/\/ | Prefix                | Total size | Payload size | Max value     |\n+\/\/\/ | --------------------- | ---------- | ------------ | ------------- |\n+\/\/\/ | `00xx xxxx`           | 1 byte     | 6 bits       | 63            |\n+\/\/\/ | `01xx xxxx xxxx xxxx` | 2 bytes    | 14 bits      | 16,383        |\n+\/\/\/ | `10xx xxx…`           | 4 bytes    | 30 bits      | 1,073,741,823 |\n+\/\/\/ | `11xx xxx…`           | 8 bytes    | 62 bits      | 4.61e18       |\n+class H3MalformedResponseTest {\n+\n+    private static final String CLASS_NAME = H3MalformedResponseTest.class.getSimpleName();\n+\n+    private static final Logger LOGGER = Utils.getDebugLogger(CLASS_NAME::toString, Utils.DEBUG);\n+\n+    private static SSLContext SSL_CONTEXT;\n+\n+    private static QuicStandaloneServer SERVER;\n+\n+    private static HttpRequest REQUEST;\n+\n+    @BeforeAll\n+    static void setUp() throws Exception {\n+\n+        \/\/ Obtain an `SSLContext`\n+        SSL_CONTEXT = new SimpleSSLContext().get();\n+        assertNotNull(SSL_CONTEXT);\n+\n+        \/\/ Create and start the server\n+        SERVER = QuicStandaloneServer.newBuilder()\n+                .availableVersions(new QuicVersion[]{QuicVersion.QUIC_V1})\n+                .sslContext(SSL_CONTEXT)\n+                .alpn(\"h3\")\n+                .build();\n+        SERVER.start();\n+        LOGGER.log(\"Server is started at {}\", SERVER.getAddress());\n+\n+        \/\/ Create the request\n+        var requestURI = URIBuilder.newBuilder()\n+                .scheme(\"https\")\n+                .loopback()\n+                .port(SERVER.getAddress().getPort())\n+                .path(\"\/\" + CLASS_NAME)\n+                .build();\n+        REQUEST = HttpRequest.newBuilder(requestURI)\n+                .version(Version.HTTP_3)\n+                .setOption(H3_DISCOVERY, HTTP_3_URI_ONLY)\n+                .build();\n+\n+    }\n+\n+    @AfterAll\n+    static void tearDown() {\n+        close(\"server\", SERVER);\n+    }\n+\n+    private static void close(String name, AutoCloseable closeable) {\n+        if (closeable != null) {\n+            LOGGER.log(\"Closing {}\", name);\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                LOGGER.log(\"Could not close \" + name, e);\n+            }\n+        }\n+    }\n@@ -74,4 +188,3 @@\n-    \/\/ These responses are malformed and should not be accepted by the client,\n-    \/\/ but they should not cause connection closure\n-    @DataProvider\n-    public static Object[][] malformedResponse() {\n+    \/\/\/ Malformed responses that should not be accepted by the client, but\n+    \/\/\/ should neither cause the connection to get closed.\n+    static Object[][] malformedResponsesPreservingConnection() {\n@@ -79,17 +192,27 @@\n-                new Object[] {\"empty\", HexFormat.of().parseHex(\n-                        \"\"\n-                )},\n-                new Object[] {\"non-final response\", HexFormat.of().parseHex(\n-                        \"01040000\"+ \/\/ headers, length 4, section prefix\n-                                \"ff00\" \/\/ :status:100\n-                )},\n-                new Object[] {\"uppercase header name\", HexFormat.of().parseHex(\n-                        \"01090000\"+ \/\/ headers, length 9, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"234147450130\"+ \/\/ AGE:0\n-                                \"000100\" \/\/ data, 1 byte\n-                )},\n-                new Object[] {\"content too long\", HexFormat.of().parseHex(\n-                        \"01040000\"+ \/\/ headers, length 4, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"c4\"+ \/\/ content-length:0\n+                {\"empty\", IOException.class, parseHex(\"\")},\n+                {\"non-final response\", IOException.class, parseHex(\n+                        \"01040000\", \/\/ headers, length 4, section prefix\n+                        \"ff00\" \/\/ :status:100\n+                )},\n+                {\"uppercase header name\", ProtocolException.class, parseHex(\n+                        \"01090000\", \/\/ headers, length 9, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"234147450130\", \/\/ AGE:0\n+                        \"000100\" \/\/ data, 1 byte\n+                )},\n+                {\"content too long\", IOException.class, parseHex(\n+                        \"01040000\", \/\/ headers, length 4, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"c4\", \/\/ content-length:0\n+                        \"000100\" \/\/ data, 1 byte\n+                )},\n+                {\"content too short\", IOException.class, parseHex(\n+                        \"01060000\", \/\/ headers, length 6, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"540132\", \/\/ content-length:2\n+                        \"000100\" \/\/ data, 1 byte\n+                )},\n+                {\"text in content-length\", ProtocolException.class, parseHex(\n+                        \"01060000\" + \/\/ headers, length 6, section prefix\n+                                \"d9\" + \/\/ :status:200\n+                                \"540161\" + \/\/ content-length:a\n@@ -98,16 +221,4 @@\n-                new Object[] {\"content too short\", HexFormat.of().parseHex(\n-                        \"01060000\"+ \/\/ headers, length 6, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"540132\"+ \/\/ content-length:2\n-                                \"000100\" \/\/ data, 1 byte\n-                )},\n-                new Object[] {\"text in content-length\", HexFormat.of().parseHex(\n-                        \"01060000\"+ \/\/ headers, length 6, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"540161\"+ \/\/ content-length:a\n-                                \"000100\" \/\/ data, 1 byte\n-                )},\n-                new Object[] {\"connection: close\", HexFormat.of().parseHex(\n-                        \"01150000\"+ \/\/ headers, length 21, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"2703636F6E6E656374696F6E05636C6F7365\"+ \/\/ connection:close\n+                {\"connection: close\", ProtocolException.class, parseHex(\n+                        \"01150000\", \/\/ headers, length 21, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"2703636F6E6E656374696F6E05636C6F7365\" + \/\/ connection:close\n@@ -117,37 +228,37 @@\n-                new Object[] {\":method in response\", HexFormat.of().parseHex(\n-                        \"01040000\"+ \/\/ headers, length 4, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"d1\"+ \/\/ :method:get\n-                                \"000100\" \/\/ data, 1 byte\n-                )},\n-                new Object[] {\":authority in response\", HexFormat.of().parseHex(\n-                        \"01100000\"+ \/\/ headers, length 16, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"508b089d5c0b8170dc702fbce7\"+ \/\/ :authority\n-                                \"000100\" \/\/ data, 1 byte\n-                )},\n-                new Object[] {\":path in response\", HexFormat.of().parseHex(\n-                        \"010a0000\"+ \/\/ headers, length 10, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"51856272d141ff\"+ \/\/ :path\n-                                \"000100\" \/\/ data, 1 byte\n-                )},\n-                new Object[] {\":scheme in response\", HexFormat.of().parseHex(\n-                        \"01040000\"+ \/\/ headers, length 4, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"d7\"+ \/\/ :scheme:https\n-                                \"000100\" \/\/ data, 1 byte\n-                )},\n-                new Object[] {\"undefined pseudo-header\", HexFormat.of().parseHex(\n-                        \"01080000\"+ \/\/ headers, length 8, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"223A6D0130\"+ \/\/ :m:0\n-                                \"000100\" \/\/ data, 1 byte\n-                )},\n-                new Object[] {\"pseudo-header after regular\", HexFormat.of().parseHex(\n-                        \"011a0000\"+ \/\/ headers, length 26, section prefix\n-                                \"5f5094ca3ee35a74a6b589418b5258132b1aa496ca8747\"+ \/\/user-agent\n-                                \"d9\"+ \/\/ :status:200\n-                                \"000100\" \/\/ data, 1 byte\n-                )},\n-                new Object[] {\"trailer\", HexFormat.of().parseHex(\n+                {\":method in response\", ProtocolException.class, parseHex(\n+                        \"01040000\", \/\/ headers, length 4, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"d1\", \/\/ :method:get\n+                        \"000100\" \/\/ data, 1 byte\n+                )},\n+                {\":authority in response\", ProtocolException.class, parseHex(\n+                        \"01100000\", \/\/ headers, length 16, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"508b089d5c0b8170dc702fbce7\", \/\/ :authority\n+                        \"000100\" \/\/ data, 1 byte\n+                )},\n+                {\":path in response\", ProtocolException.class, parseHex(\n+                        \"010a0000\", \/\/ headers, length 10, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"51856272d141ff\", \/\/ :path\n+                        \"000100\" \/\/ data, 1 byte\n+                )},\n+                {\":scheme in response\", ProtocolException.class, parseHex(\n+                        \"01040000\", \/\/ headers, length 4, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"d7\", \/\/ :scheme:https\n+                        \"000100\" \/\/ data, 1 byte\n+                )},\n+                {\"undefined pseudo-header\", ProtocolException.class, parseHex(\n+                        \"01080000\", \/\/ headers, length 8, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"223A6D0130\", \/\/ :m:0\n+                        \"000100\" \/\/ data, 1 byte\n+                )},\n+                {\"pseudo-header after regular\", ProtocolException.class, parseHex(\n+                        \"011a0000\", \/\/ headers, length 26, section prefix\n+                        \"5f5094ca3ee35a74a6b589418b5258132b1aa496ca8747\", \/\/user-agent\n+                        \"d9\", \/\/ :status:200\n+                        \"000100\" \/\/ data, 1 byte\n+                )},\n+                {\"trailer\", IOException.class, parseHex(\n@@ -156,3 +267,3 @@\n-                new Object[] {\"trailer+data\", HexFormat.of().parseHex(\n-                        \"01020000\"+ \/\/ headers, length 2, section prefix\n-                                \"000100\" \/\/ data, 1 byte\n+                {\"trailer+data\", IOException.class, parseHex(\n+                        \"01020000\", \/\/ headers, length 2, section prefix\n+                        \"000100\" \/\/ data, 1 byte\n@@ -161,23 +272,23 @@\n-                new Object[] {\"invalid character in field value 00\", HexFormat.of().parseHex(\n-                        \"01060000\"+ \/\/ headers, length 6, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"570100\"+ \/\/ etag:\\0\n-                                \"000100\" \/\/ data, 1 byte\n-                )},\n-                new Object[] {\"invalid character in field value 0a\", HexFormat.of().parseHex(\n-                        \"01060000\"+ \/\/ headers, length 6, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"57010a\"+ \/\/ etag:\\n\n-                                \"000100\" \/\/ data, 1 byte\n-                )},\n-                new Object[] {\"invalid character in field value 0d\", HexFormat.of().parseHex(\n-                        \"01060000\"+ \/\/ headers, length 6, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"57010d\"+ \/\/ etag:\\r\n-                                \"000100\" \/\/ data, 1 byte\n-                )},\n-                new Object[] {\"invalid character in field value 7f\", HexFormat.of().parseHex(\n-                        \"01060000\"+ \/\/ headers, length 6, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"57017f\"+ \/\/ etag: 0x7f\n-                                \"000100\" \/\/ data, 1 byte\n+                {\"invalid character in field value 00\", ProtocolException.class, parseHex(\n+                        \"01060000\", \/\/ headers, length 6, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"570100\", \/\/ etag:\\0\n+                        \"000100\" \/\/ data, 1 byte\n+                )},\n+                {\"invalid character in field value 0a\", ProtocolException.class, parseHex(\n+                        \"01060000\", \/\/ headers, length 6, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"57010a\", \/\/ etag:\\n\n+                        \"000100\" \/\/ data, 1 byte\n+                )},\n+                {\"invalid character in field value 0d\", ProtocolException.class, parseHex(\n+                        \"01060000\", \/\/ headers, length 6, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"57010d\", \/\/ etag:\\r\n+                        \"000100\" \/\/ data, 1 byte\n+                )},\n+                {\"invalid character in field value 7f\", ProtocolException.class, parseHex(\n+                        \"01060000\", \/\/ headers, length 6, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"57017f\", \/\/ etag: 0x7f\n+                        \"000100\" \/\/ data, 1 byte\n@@ -188,4 +299,3 @@\n-    \/\/ These responses are malformed and should not be accepted by the client.\n-    \/\/ They might or might not cause connection closure (H3_FRAME_UNEXPECTED)\n-    @DataProvider\n-    public static Object[][] malformedResponse2() {\n+    \/\/\/ Malformed responses that should not be accepted by the client.\n+    \/\/\/ They might or might not cause the connection to get closed (`H3_FRAME_UNEXPECTED`).\n+    static Object[][] malformedResponses() {\n@@ -194,50 +304,50 @@\n-                new Object[] {\"100+data\", HexFormat.of().parseHex(\n-                        \"01040000\"+ \/\/ headers, length 4, section prefix\n-                                \"ff00\"+ \/\/ :status:100\n-                                \"000100\" \/\/ data, 1 byte\n-                )},\n-                new Object[] {\"100+data+200\", HexFormat.of().parseHex(\n-                        \"01040000\"+ \/\/ headers, length 4, section prefix\n-                                \"ff00\"+ \/\/ :status:100\n-                                \"000100\"+ \/\/ data, 1 byte\n-                                \"01030000\"+ \/\/ headers, length 3, section prefix\n-                                \"d9\" \/\/ :status:200\n-                )},\n-                new Object[] {\"200+data+200\", HexFormat.of().parseHex(\n-                        \"01030000\"+ \/\/ headers, length 3, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"000100\"+ \/\/ data, 1 byte\n-                                \"01030000\"+ \/\/ headers, length 3, section prefix\n-                                \"d9\" \/\/ :status:200\n-                )},\n-                new Object[] {\"200+data+100\", HexFormat.of().parseHex(\n-                        \"01030000\"+ \/\/ headers, length 3, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"000100\"+ \/\/ data, 1 byte\n-                                \"01040000\"+ \/\/ headers, length 4, section prefix\n-                                \"ff00\" \/\/ :status:100\n-                )},\n-                new Object[] {\"200+data+trailers+data\", HexFormat.of().parseHex(\n-                        \"01030000\"+ \/\/ headers, length 3, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"000100\"+ \/\/ data, 1 byte\n-                                \"01020000\"+ \/\/ trailers, length 2, section prefix\n-                                \"000100\" \/\/ data, 1 byte\n-                )},\n-                new Object[] {\"200+trailers+data\", HexFormat.of().parseHex(\n-                        \"01030000\"+ \/\/ headers, length 3, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"01020000\"+ \/\/ trailers, length 2, section prefix\n-                                \"000100\" \/\/ data, 1 byte\n-                )},\n-                new Object[] {\"200+200\", HexFormat.of().parseHex(\n-                        \"01030000\"+ \/\/ headers, length 3, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"01030000\"+ \/\/ headers, length 3, section prefix\n-                                \"d9\" \/\/ :status:200\n-                )},\n-                new Object[] {\"200+100\", HexFormat.of().parseHex(\n-                        \"01030000\"+ \/\/ headers, length 3, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"01040000\"+ \/\/ headers, length 4, section prefix\n-                                \"ff00\" \/\/ :status:100\n+                {\"100+data\", IOException.class, parseHex(\n+                        \"01040000\", \/\/ headers, length 4, section prefix\n+                        \"ff00\", \/\/ :status:100\n+                        \"000100\" \/\/ data, 1 byte\n+                )},\n+                {\"100+data+200\", IOException.class, parseHex(\n+                        \"01040000\", \/\/ headers, length 4, section prefix\n+                        \"ff00\", \/\/ :status:100\n+                        \"000100\", \/\/ data, 1 byte\n+                        \"01030000\", \/\/ headers, length 3, section prefix\n+                        \"d9\" \/\/ :status:200\n+                )},\n+                {\"200+data+200\", IOException.class, parseHex(\n+                        \"01030000\", \/\/ headers, length 3, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"000100\", \/\/ data, 1 byte\n+                        \"01030000\", \/\/ headers, length 3, section prefix\n+                        \"d9\" \/\/ :status:200\n+                )},\n+                {\"200+data+100\", IOException.class, parseHex(\n+                        \"01030000\", \/\/ headers, length 3, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"000100\", \/\/ data, 1 byte\n+                        \"01040000\", \/\/ headers, length 4, section prefix\n+                        \"ff00\" \/\/ :status:100\n+                )},\n+                {\"200+data+trailers+data\", ProtocolException.class, parseHex(\n+                        \"01030000\", \/\/ headers, length 3, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"000100\", \/\/ data, 1 byte\n+                        \"01020000\", \/\/ trailers, length 2, section prefix\n+                        \"000100\" \/\/ data, 1 byte\n+                )},\n+                {\"200+trailers+data\", IOException.class, parseHex(\n+                        \"01030000\", \/\/ headers, length 3, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"01020000\", \/\/ trailers, length 2, section prefix\n+                        \"000100\" \/\/ data, 1 byte\n+                )},\n+                {\"200+200\", IOException.class, parseHex(\n+                        \"01030000\", \/\/ headers, length 3, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"01030000\", \/\/ headers, length 3, section prefix\n+                        \"d9\" \/\/ :status:200\n+                )},\n+                {\"200+100\", IOException.class, parseHex(\n+                        \"01030000\", \/\/ headers, length 3, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"01040000\", \/\/ headers, length 4, section prefix\n+                        \"ff00\" \/\/ :status:100\n@@ -248,2 +358,2 @@\n-    @DataProvider\n-    public static Object[][] wellformedResponse() {\n+    \/\/\/ Well-formed responses that should be accepted by the client.\n+    static Object[][] wellFormedResponses() {\n@@ -251,45 +361,45 @@\n-                new Object[] {\"100+200+data+reserved\", HexFormat.of().parseHex(\n-                        \"01040000\"+ \/\/ headers, length 4, section prefix\n-                                \"ff00\"+ \/\/ :status:100\n-                        \"01030000\"+ \/\/ headers, length 3, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"000100\"+ \/\/ data, 1 byte\n-                                \"210100\" \/\/ reserved, 1 byte\n-                )},\n-                new Object[] {\"200+data+reserved\", HexFormat.of().parseHex(\n-                        \"01030000\"+ \/\/ headers, length 3, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"000100\"+ \/\/ data, 1 byte\n-                                \"210100\" \/\/ reserved, 1 byte\n-                )},\n-                new Object[] {\"200+data\", HexFormat.of().parseHex(\n-                        \"01030000\"+ \/\/ headers, length 3, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"000100\" \/\/ data, 1 byte\n-                )},\n-                new Object[] {\"200+user-agent+data\", HexFormat.of().parseHex(\n-                        \"011a0000\"+ \/\/ headers, length 26, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"5f5094ca3ee35a74a6b589418b5258132b1aa496ca8747\"+ \/\/user-agent\n-                                \"000100\" \/\/ data, 1 byte\n-                )},\n-                new Object[] {\"200\", HexFormat.of().parseHex(\n-                        \"01030000\"+ \/\/ headers, length 3, section prefix\n-                                \"d9\" \/\/ :status:200\n-                )},\n-                new Object[] {\"200+data+data\", HexFormat.of().parseHex(\n-                        \"01030000\"+ \/\/ headers, length 3, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"000100\"+ \/\/ data, 1 byte\n-                                \"000100\" \/\/ data, 1 byte\n-                )},\n-                new Object[] {\"200+data+trailers\", HexFormat.of().parseHex(\n-                        \"01030000\"+ \/\/ headers, length 3, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"000100\"+ \/\/ data, 1 byte\n-                                \"01020000\" \/\/ trailers, length 2, section prefix\n-                )},\n-                new Object[] {\"200+trailers\", HexFormat.of().parseHex(\n-                        \"01030000\"+ \/\/ headers, length 3, section prefix\n-                                \"d9\"+ \/\/ :status:200\n-                                \"01020000\" \/\/ trailers, length 2, section prefix\n+                {\"100+200+data+reserved\", parseHex(\n+                        \"01040000\", \/\/ headers, length 4, section prefix\n+                        \"ff00\", \/\/ :status:100\n+                        \"01030000\", \/\/ headers, length 3, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"000100\", \/\/ data, 1 byte\n+                        \"210100\" \/\/ reserved, 1 byte\n+                )},\n+                {\"200+data+reserved\", parseHex(\n+                        \"01030000\", \/\/ headers, length 3, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"000100\", \/\/ data, 1 byte\n+                        \"210100\" \/\/ reserved, 1 byte\n+                )},\n+                {\"200+data\", parseHex(\n+                        \"01030000\", \/\/ headers, length 3, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"000100\" \/\/ data, 1 byte\n+                )},\n+                {\"200+user-agent+data\", parseHex(\n+                        \"011a0000\", \/\/ headers, length 26, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"5f5094ca3ee35a74a6b589418b5258132b1aa496ca8747\", \/\/user-agent\n+                        \"000100\" \/\/ data, 1 byte\n+                )},\n+                {\"200\", parseHex(\n+                        \"01030000\", \/\/ headers, length 3, section prefix\n+                        \"d9\" \/\/ :status:200\n+                )},\n+                {\"200+data+data\", parseHex(\n+                        \"01030000\", \/\/ headers, length 3, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"000100\", \/\/ data, 1 byte\n+                        \"000100\" \/\/ data, 1 byte\n+                )},\n+                {\"200+data+trailers\", parseHex(\n+                        \"01030000\", \/\/ headers, length 3, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"000100\", \/\/ data, 1 byte\n+                        \"01020000\" \/\/ trailers, length 2, section prefix\n+                )},\n+                {\"200+trailers\", parseHex(\n+                        \"01030000\", \/\/ headers, length 3, section prefix\n+                        \"d9\", \/\/ :status:200\n+                        \"01020000\" \/\/ trailers, length 2, section prefix\n@@ -300,22 +410,4 @@\n-    @BeforeClass\n-    public void beforeClass() throws Exception {\n-        sslContext = new SimpleSSLContext().get();\n-        if (sslContext == null) {\n-            throw new AssertionError(\"Unexpected null sslContext\");\n-        }\n-        server = QuicStandaloneServer.newBuilder()\n-                .availableVersions(new QuicVersion[]{QuicVersion.QUIC_V1})\n-                .sslContext(sslContext)\n-                .alpn(\"h3\")\n-                .build();\n-        server.start();\n-        System.out.println(\"Server started at \" + server.getAddress());\n-        requestURIBase = URIBuilder.newBuilder().scheme(\"https\").loopback()\n-                .port(server.getAddress().getPort()).build().toString();\n-    }\n-\n-    @AfterClass\n-    public void afterClass() throws Exception {\n-        if (server != null) {\n-            System.out.println(\"Stopping server \" + server.getAddress());\n-            server.close();\n+    private static byte[] parseHex(String... strings) {\n+        var buffer = new StringBuilder();\n+        for (String string : strings) {\n+            buffer.append(string);\n@@ -323,0 +415,1 @@\n+        return HexFormat.of().parseHex(buffer.toString());\n@@ -325,23 +418,8 @@\n-    \/**\n-     * Server sends a well-formed response\n-     *\/\n-    @Test(dataProvider = \"wellformedResponse\")\n-    public void testWellFormedResponse(String desc, byte[] response) throws Exception {\n-        CompletableFuture<TerminationCause> errorCF = new CompletableFuture<>();\n-        server.addHandler((c,s)-> {\n-            try (OutputStream outputStream = s.outputStream()) {\n-                outputStream.write(response);\n-            }\n-            \/\/ verify that the connection stays open\n-            completeUponTermination(c, errorCF);\n-        });\n-        HttpClient client = getHttpClient();\n-        try {\n-            HttpRequest request = getRequest();\n-            final HttpResponse<Void> response1 = client.send(\n-                    request,\n-                    BodyHandlers.discarding());\n-            assertEquals(response1.statusCode(), 200);\n-            assertFalse(errorCF.isDone(), \"Expected the connection to be open\");\n-        } finally {\n-            client.shutdownNow();\n+    @ParameterizedTest\n+    @MethodSource(\"wellFormedResponses\")\n+    void testWellFormedResponse(String desc, byte[] serverResponseBytes) throws Exception {\n+        var connectionTerminated = configureServerResponse(serverResponseBytes);\n+        try (var client = createClient()) {\n+            final HttpResponse<Void> response = client.send(REQUEST, BodyHandlers.discarding());\n+            assertEquals(200, response.statusCode());\n+            assertFalse(connectionTerminated.getAsBoolean(), \"Expected the connection to be open\");\n@@ -351,27 +429,11 @@\n-\n-    \/**\n-     * Server sends a malformed response that should not close connection\n-     *\/\n-    @Test(dataProvider = \"malformedResponse\")\n-    public void testMalformedResponse(String desc, byte[] response) throws Exception {\n-        CompletableFuture<TerminationCause> errorCF = new CompletableFuture<>();\n-        server.addHandler((c,s)-> {\n-            try (OutputStream outputStream = s.outputStream()) {\n-                outputStream.write(response);\n-            }\n-            \/\/ verify that the connection stays open\n-            completeUponTermination(c, errorCF);\n-        });\n-        HttpClient client = getHttpClient();\n-        try {\n-            HttpRequest request = getRequest();\n-            final HttpResponse<Void> response1 = client.send(\n-                            request,\n-                            BodyHandlers.discarding());\n-            fail(\"Expected the request to fail, got \" + response1);\n-        } catch (Exception e) {\n-            System.out.println(\"Got expected exception: \" +e);\n-            e.printStackTrace();\n-            assertFalse(errorCF.isDone(), \"Expected the connection to be open\");\n-        } finally {\n-            client.shutdownNow();\n+    @ParameterizedTest\n+    @MethodSource(\"malformedResponsesPreservingConnection\")\n+    void testMalformedResponsePreservingConnection(\n+            String desc,\n+            Class<? extends Exception> exceptionClass,\n+            byte[] serverResponseBytes) {\n+        var connectionTerminated = configureServerResponse(serverResponseBytes);\n+        try (var client = createClient()) {\n+            var exception = assertThrows(exceptionClass, () -> client.send(REQUEST, BodyHandlers.discarding()));\n+            LOGGER.log(\"Got expected exception for: \" + desc, exception);\n+            assertFalse(connectionTerminated.getAsBoolean(), \"Expected the connection to be open\");\n@@ -381,22 +443,10 @@\n-    \/**\n-     * Server sends a malformed response that might close connection\n-     *\/\n-    @Test(dataProvider = \"malformedResponse2\")\n-    public void testMalformedResponse2(String desc, byte[] response) throws Exception {\n-        server.addHandler((c,s)-> {\n-            try (OutputStream outputStream = s.outputStream()) {\n-                outputStream.write(response);\n-            }\n-        });\n-        HttpClient client = getHttpClient();\n-        try {\n-            HttpRequest request = getRequest();\n-            final HttpResponse<Void> response1 = client.send(\n-                            request,\n-                            BodyHandlers.discarding());\n-            fail(\"Expected the request to fail, got \" + response1);\n-        } catch (Exception e) {\n-            System.out.println(\"Got expected exception: \" +e);\n-            e.printStackTrace();\n-        } finally {\n-            client.shutdownNow();\n+    @ParameterizedTest\n+    @MethodSource(\"malformedResponses\")\n+    void testMalformedResponse(\n+            String desc,\n+            Class<? extends Exception> exceptionClass,\n+            byte[] serverResponseBytes) {\n+        configureServerResponse(serverResponseBytes);\n+        try (var client = createClient()) {\n+            var exception = assertThrows(exceptionClass, () -> client.send(REQUEST, BodyHandlers.discarding()));\n+            LOGGER.log(\"Got expected exception for: \" + desc, exception);\n@@ -406,11 +456,3 @@\n-    private HttpRequest getRequest() throws URISyntaxException {\n-        final URI reqURI = new URI(requestURIBase + \"\/hello\");\n-        final HttpRequest.Builder reqBuilder = HttpRequest.newBuilder(reqURI)\n-                .version(Version.HTTP_3)\n-                .setOption(H3_DISCOVERY, HTTP_3_URI_ONLY);\n-        return reqBuilder.build();\n-    }\n-\n-    private HttpClient getHttpClient() {\n-        final HttpClient client = newClientBuilderForH3()\n-                .proxy(HttpClient.Builder.NO_PROXY)\n+    private static HttpClient createClient() {\n+        return HttpServerAdapters.createClientBuilderForH3()\n+                .proxy(NO_PROXY)\n@@ -418,2 +460,2 @@\n-                .sslContext(sslContext).build();\n-        return client;\n+                .sslContext(SSL_CONTEXT)\n+                .build();\n@@ -422,2 +464,12 @@\n-    private static String toHexString(final Http3Error error) {\n-        return error.name() + \"(0x\" + Long.toHexString(error.code()) + \")\";\n+    private static BooleanSupplier configureServerResponse(byte[] serverResponseBytes) {\n+        var connectionTerminated = new AtomicBoolean();\n+        SERVER.addHandler((c, s)-> {\n+            try (OutputStream outputStream = s.outputStream()) {\n+                outputStream.write(serverResponseBytes);\n+            }\n+            c.futureTerminationCause().handle((_, _) -> {\n+                connectionTerminated.set(true);\n+                return true;\n+            });\n+        });\n+        return connectionTerminated::get;\n@@ -426,5 +478,0 @@\n-    private static void completeUponTermination(final QuicServerConnection serverConnection,\n-                                                final CompletableFuture<TerminationCause> cf) {\n-        serverConnection.futureTerminationCause().handle(\n-                (r,t) -> t != null ? cf.completeExceptionally(t) : cf.complete(r));\n-    }\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/H3MalformedResponseTest.java","additions":390,"deletions":343,"binary":false,"changes":733,"status":"modified"}]}