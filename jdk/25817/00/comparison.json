{"files":[{"patch":"@@ -81,0 +81,11 @@\n+    \/**\n+     * Return true if the operating system supports pending signals. If a signal is sent\n+     * to a thread but cannot be delivered immediately then it will be delivered when the\n+     * thread is in the appropriate state.\n+     *\/\n+    static boolean supportPendingSignals() {\n+        return supportPendingSignals0();\n+    }\n+\n+    private static native boolean supportPendingSignals0();\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/NativeThread.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+    private static final boolean SUPPORTS_PENDING_SIGNALS = NativeThread.supportPendingSignals();\n@@ -38,3 +39,1 @@\n-    @Override\n-    void implPreClose(FileDescriptor fd, long reader, long writer) throws IOException {\n-        preClose0(fd);\n+    private void signalThreads(long reader, long writer) {\n@@ -47,0 +46,11 @@\n+    @Override\n+    void implPreClose(FileDescriptor fd, long reader, long writer) throws IOException {\n+        if (SUPPORTS_PENDING_SIGNALS) {\n+            signalThreads(reader, writer);\n+        }\n+        preClose0(fd);\n+        if (!SUPPORTS_PENDING_SIGNALS) {\n+            signalThreads(reader, writer);\n+        }\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixDispatcher.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -91,0 +91,9 @@\n+\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_ch_NativeThread_supportPendingSignals0(JNIEnv *env, jclass cl) {\n+#if defined(_AIX)\n+    return JNI_TRUE;\n+#else\n+    return JNI_FALSE;\n+#endif\n+}\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/NativeThread.c","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}