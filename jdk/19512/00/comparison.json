{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+  class TestSupport;  \/\/ Unit test support\n","filename":"src\/hotspot\/share\/utilities\/defaultStream.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -84,1 +84,3 @@\n-\/\/ Return a pointer to the formatted string.\n+\/\/ Return a pointer to the formatted string. Optimise for\n+\/\/ strings without format specifiers, or only \"%s\". See\n+\/\/ comments in the header file for more details.\n@@ -91,2 +93,8 @@\n-  const char* result;\n-  if (add_cr)  buflen--;\n+  const char* result;  \/\/ The string to return. May not be the buffer.\n+  size_t required_len = 0; \/\/ The length of buffer needed to avoid truncation\n+                           \/\/ (excluding space for the nul terminator).\n+\n+  if (add_cr) { \/\/ Ensure space for CR even if truncation occurs.\n+    buflen--;\n+  }\n+\n@@ -97,1 +105,4 @@\n-    if (add_cr && result_len >= buflen)  result_len = buflen-1;  \/\/ truncate\n+    if (add_cr && result_len >= buflen) { \/\/ truncate\n+      required_len = result_len + 1;\n+      result_len = buflen - 1;\n+    }\n@@ -102,1 +113,4 @@\n-    if (add_cr && result_len >= buflen)  result_len = buflen-1;  \/\/ truncate\n+    if (add_cr && result_len >= buflen) { \/\/ truncate\n+      required_len = result_len + 1;\n+      result_len = buflen - 1;\n+    }\n@@ -104,2 +118,2 @@\n-    int required_len = os::vsnprintf(buffer, buflen, format, ap);\n-    assert(required_len >= 0, \"vsnprintf encoding error\");\n+    int required_buffer_len = os::vsnprintf(buffer, buflen, format, ap);\n+    assert(required_buffer_len >= 0, \"vsnprintf encoding error\");\n@@ -107,1 +121,2 @@\n-    if ((size_t)required_len < buflen) {\n+    required_len = required_buffer_len;\n+    if (required_len < buflen) {\n@@ -109,3 +124,1 @@\n-    } else {\n-      DEBUG_ONLY(warning(\"outputStream::do_vsnprintf output truncated -- buffer length is %d bytes but %d bytes are needed.\",\n-                         add_cr ? (int)buflen + 1 : (int)buflen, add_cr ? required_len + 2 : required_len + 1);)\n+    } else { \/\/ truncation\n@@ -116,1 +129,1 @@\n-    if (result != buffer) {\n+    if (result != buffer) { \/\/ Need to copy to add CR\n@@ -119,0 +132,2 @@\n+    } else {\n+      required_len++;\n@@ -123,0 +138,7 @@\n+#ifdef ASSERT\n+  if (required_len > result_len) {\n+    warning(\"outputStream::do_vsnprintf output truncated -- buffer length is \" SIZE_FORMAT\n+            \" bytes but \" SIZE_FORMAT \" bytes are needed.\",\n+            add_cr ? buflen + 1 : buflen, required_len + 1);\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":34,"deletions":12,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -44,1 +44,3 @@\n-\/\/ -XX:+DisplayVMOutputToStderr\n+\/\/ -XX:+DisplayVMOutputToStderr.\n+\/\/\n+\n@@ -59,0 +61,14 @@\n+\n+  \/\/ Nominally processes the given format string and the supplied arguments\n+  \/\/ to produce a formatted string using the supplied buffer. The formatted\n+  \/\/ string (in the buffer) is returned, and the outgoing `result_len` set\n+  \/\/ to the size of the returned string.\n+  \/\/\n+  \/\/ If the format string is a plain string (no format specifiers)\n+  \/\/ or idiomatically it is \"%s\" to print a supplied argument string, then\n+  \/\/ the buffer is ignored, we return the string directly and set `result_len` to its\n+  \/\/ length. However, if `add_cr` is true then we have to copy the string\n+  \/\/ into the buffer and we risk truncation. The `result_len` is always set to the length\n+  \/\/ of the returned string.\n+  \/\/\n+  \/\/ In a debug build, if truncation occurs a VM warning is issued.\n@@ -94,0 +110,4 @@\n+   \/\/ Note that (v)print_cr forces the use of internal buffering to allow\n+   \/\/ appending of the \"cr\". This can lead to truncation if the buffer is\n+   \/\/ too small.\n+\n@@ -98,4 +118,4 @@\n-   void print_raw(const char* str)            { write(str, strlen(str)); }\n-   void print_raw(const char* str, size_t len)   { write(str,         len); }\n-   void print_raw_cr(const char* str)         { write(str, strlen(str)); cr(); }\n-   void print_raw_cr(const char* str, size_t len){ write(str,         len); cr(); }\n+   void print_raw(const char* str) { write(str, strlen(str)); }\n+   void print_raw(const char* str, size_t len) { write(str, len); }\n+   void print_raw_cr(const char* str) { write(str, strlen(str)); cr(); }\n+   void print_raw_cr(const char* str, size_t len){ write(str, len); cr(); }\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"utilities\/defaultStream.hpp\"\n@@ -126,0 +127,2 @@\n+\/\/ Test helper for do_vsnprintf\n+class defaultStream::TestSupport : AllStatic {\n@@ -127,0 +130,6 @@\n+  \/\/ Shared constants and variables for all subtests.\n+  static const size_t buflen = 11;\n+  static char buffer[buflen];\n+  static const size_t max_len = buflen - 1;\n+  static size_t result_len;\n+  static const char* result;\n@@ -128,0 +137,159 @@\n+  static void reset() {\n+    result_len = 0;\n+    result = nullptr;\n+    buffer[0] = '\\0';\n+  }\n+\n+  static const char* test(char* buf, size_t len, bool add_cr,\n+                          size_t& rlen, const char* format, ...) {\n+    va_list ap;\n+    va_start(ap, format);\n+    const char* res = tty->do_vsnprintf(buf, len, format, ap, add_cr, rlen);\n+    va_end(ap);\n+    return res;\n+  }\n+\n+ public:\n+  \/\/ Case set 1: constant string with no format specifiers\n+  static void test_constant_string() {\n+    reset();\n+    \/\/ Case 1-1: no cr, no truncation, excess capacity\n+    {\n+      const char* str = \"012345678\";\n+      size_t initial_len = strlen(str);\n+      ASSERT_TRUE(initial_len < max_len);\n+      result = defaultStream::TestSupport::test(&buffer[0], buflen, false, result_len, str);\n+      ASSERT_EQ(result, str);\n+      ASSERT_EQ(strlen(result), result_len);\n+    }\n+    reset();\n+    \/\/ Case 1-2: no cr, no truncation, exact capacity\n+    {\n+      const char* str = \"0123456789\";\n+      size_t initial_len = strlen(str);\n+      ASSERT_EQ(initial_len, max_len);\n+      result = defaultStream::TestSupport::test(&buffer[0], buflen, false, result_len, str);\n+      ASSERT_EQ(result, str);\n+      ASSERT_EQ(strlen(result), result_len);\n+    }\n+    reset();\n+    \/\/ Case 1-3: no cr, no truncation, exceeds capacity\n+    {\n+      const char* str = \"0123456789A\";\n+      size_t initial_len = strlen(str);\n+      ASSERT_TRUE(initial_len > max_len);\n+      result = defaultStream::TestSupport::test(&buffer[0], buflen, false, result_len, str);\n+      ASSERT_EQ(result, str);\n+      ASSERT_EQ(strlen(result), result_len);\n+      ASSERT_EQ(result_len, initial_len);\n+    }\n+    reset();\n+    \/\/ Case 1-4: add cr, no truncation, excess capacity\n+    {\n+      const char* str = \"01234567\";\n+      size_t initial_len = strlen(str);\n+      ASSERT_TRUE(initial_len < max_len);\n+      result = defaultStream::TestSupport::test(&buffer[0], buflen, true, result_len, str);\n+      ASSERT_EQ(result, buffer);\n+      ASSERT_EQ(strlen(result), result_len);\n+      ASSERT_EQ(result_len, initial_len + 1);\n+      ASSERT_TRUE(result_len <= max_len);\n+    }\n+    reset();\n+    \/\/ Case 1-5: add cr, no truncation, exact capacity\n+    {\n+      const char* str = \"012345678\";\n+      size_t initial_len = strlen(str);\n+      ASSERT_TRUE(initial_len < max_len);\n+      result = defaultStream::TestSupport::test(&buffer[0], buflen, true, result_len, str);\n+      ASSERT_EQ(result, buffer);\n+      ASSERT_EQ(strlen(result), result_len);\n+      ASSERT_EQ(result_len, initial_len + 1);\n+      ASSERT_TRUE(result_len <= max_len);\n+    }\n+    reset();\n+    \/\/ Case 1-6: add cr, truncation\n+    {\n+      const char* str = \"0123456789\";\n+      size_t initial_len = strlen(str);\n+      ASSERT_EQ(initial_len, max_len);\n+      ::printf(\"Truncation warning expected: requires %d\\n\", (int)(initial_len + 1 + 1));\n+      result = defaultStream::TestSupport::test(&buffer[0], buflen, true, result_len, str);\n+      ASSERT_EQ(result, buffer);\n+      ASSERT_EQ(strlen(result), result_len);\n+      ASSERT_EQ(result_len, initial_len);\n+      ASSERT_TRUE(result_len <= max_len);\n+    }\n+  }\n+\n+  \/\/ Case set 2: \"%s\" string\n+  static void test_percent_s_string() {\n+    reset();\n+    \/\/ Case 2-1: no cr, no truncation, excess capacity\n+    {\n+      const char* str = \"012345678\";\n+      size_t initial_len = strlen(str);\n+      ASSERT_TRUE(initial_len < max_len);\n+      result = defaultStream::TestSupport::test(&buffer[0], buflen, false, result_len, \"%s\", str);\n+      ASSERT_EQ(result, str);\n+      ASSERT_EQ(strlen(result), result_len);\n+    }\n+    reset();\n+    \/\/ Case 2-2: no cr, no truncation, exact capacity\n+    {\n+      const char* str = \"0123456789\";\n+      size_t initial_len = strlen(str);\n+      ASSERT_EQ(initial_len, max_len);\n+      result = defaultStream::TestSupport::test(&buffer[0], buflen, false, result_len, \"%s\", str);\n+      ASSERT_EQ(result, str);\n+      ASSERT_EQ(strlen(result), result_len);\n+    }\n+    reset();\n+    \/\/ Case 2-3: no cr, no truncation, exceeds capacity\n+    {\n+      const char* str = \"0123456789A\";\n+      size_t initial_len = strlen(str);\n+      ASSERT_TRUE(initial_len > max_len);\n+      result = defaultStream::TestSupport::test(&buffer[0], buflen, false, result_len, \"%s\", str);\n+      ASSERT_EQ(result, str);\n+      ASSERT_EQ(strlen(result), result_len);\n+      ASSERT_EQ(result_len, initial_len);\n+    }\n+    reset();\n+    \/\/ Case 2-4: add cr, no truncation, excess capacity\n+    {\n+      const char* str = \"01234567\";\n+      size_t initial_len = strlen(str);\n+      ASSERT_TRUE(initial_len < max_len);\n+      result = defaultStream::TestSupport::test(&buffer[0], buflen, true, result_len, \"%s\", str);\n+      ASSERT_EQ(result, buffer);\n+      ASSERT_EQ(strlen(result), result_len);\n+      ASSERT_EQ(result_len, initial_len + 1);\n+      ASSERT_TRUE(result_len <= max_len);\n+    }\n+    reset();\n+    \/\/ Case 2-5: add cr, no truncation, exact capacity\n+    {\n+      const char* str = \"012345678\";\n+      size_t initial_len = strlen(str);\n+      ASSERT_TRUE(initial_len < max_len);\n+      result = defaultStream::TestSupport::test(&buffer[0], buflen, true, result_len, \"%s\", str);\n+      ASSERT_EQ(result, buffer);\n+      ASSERT_EQ(strlen(result), result_len);\n+      ASSERT_EQ(result_len, initial_len + 1);\n+      ASSERT_TRUE(result_len <= max_len);\n+    }\n+    reset();\n+    \/\/ Case 2-6: add cr, truncation\n+    {\n+      const char* str = \"0123456789\";\n+      size_t initial_len = strlen(str);\n+      ASSERT_EQ(initial_len, max_len);\n+      ::printf(\"Truncation warning expected: requires %d\\n\", (int)(initial_len + 1 + 1));\n+      result = defaultStream::TestSupport::test(&buffer[0], buflen, true, result_len, \"%s\", str);\n+      ASSERT_EQ(result, buffer);\n+      ASSERT_EQ(strlen(result), result_len);\n+      ASSERT_EQ(result_len, initial_len);\n+      ASSERT_TRUE(result_len <= max_len);\n+    }\n+  }\n@@ -129,0 +297,83 @@\n+  \/\/ Case set 3: \" %s\" string - the space means we avoid the pass-through optimization and use vsnprintf\n+  static void test_general_string() {\n+    reset();\n+    \/\/ Case 3-1: no cr, no truncation, excess capacity\n+    {\n+      const char* str = \"01234567\";\n+      size_t initial_len = strlen(str) + 1;\n+      ASSERT_TRUE(initial_len < max_len);\n+      result = defaultStream::TestSupport::test(&buffer[0], buflen, false, result_len, \" %s\", str);\n+      ASSERT_EQ(result, buffer);\n+      ASSERT_EQ(strlen(result), result_len);\n+    }\n+    reset();\n+    \/\/ Case 3-2: no cr, no truncation, exact capacity\n+    {\n+      const char* str = \"012345678\";\n+      size_t initial_len = strlen(str) + 1;\n+      ASSERT_EQ(initial_len, max_len);\n+      result = defaultStream::TestSupport::test(&buffer[0], buflen, false, result_len, \" %s\", str);\n+      ASSERT_EQ(result, buffer);\n+      ASSERT_EQ(strlen(result), result_len);\n+    }\n+    reset();\n+    \/\/ Case 3-3: no cr, truncation\n+    {\n+      const char* str = \"0123456789\";\n+      size_t initial_len = strlen(str) + 1;\n+      ASSERT_TRUE(initial_len > max_len);\n+      ::printf(\"Truncation warning expected: requires %d\\n\", (int)(initial_len + 1));\n+      result = defaultStream::TestSupport::test(&buffer[0], buflen, false, result_len, \" %s\", str);\n+      ASSERT_EQ(result, buffer);\n+      ASSERT_EQ(strlen(result), result_len);\n+    }\n+    reset();\n+    \/\/ Case 3-4: add cr, no truncation, excess capacity\n+    {\n+      const char* str = \"0123456\";\n+      size_t initial_len = strlen(str) + 1;\n+      ASSERT_TRUE(initial_len < max_len);\n+      result = defaultStream::TestSupport::test(&buffer[0], buflen, true, result_len, \" %s\", str);\n+      ASSERT_EQ(result, buffer);\n+      ASSERT_EQ(strlen(result), result_len);\n+      ASSERT_EQ(result_len, initial_len + 1);\n+      ASSERT_TRUE(result_len <= max_len);\n+    }\n+    reset();\n+    \/\/ Case 3-5: add cr, no truncation, exact capacity\n+    {\n+      const char* str = \"01234567\";\n+      size_t initial_len = strlen(str) + 1;\n+      ASSERT_TRUE(initial_len < max_len);\n+      result = defaultStream::TestSupport::test(&buffer[0], buflen, true, result_len, \" %s\", str);\n+      ASSERT_EQ(result, buffer);\n+      ASSERT_EQ(strlen(result), result_len);\n+      ASSERT_EQ(result_len, initial_len + 1);\n+      ASSERT_TRUE(result_len <= max_len);\n+    }\n+    reset();\n+    \/\/ Case 3-6: add cr, truncation\n+    {\n+      const char* str = \"012345678\";\n+      size_t initial_len = strlen(str) + 1;\n+      ASSERT_EQ(initial_len, max_len);\n+      ::printf(\"Truncation warning expected: requires %d\\n\", (int)(initial_len + 1 + 1));\n+      result = defaultStream::TestSupport::test(&buffer[0], buflen, true, result_len, \" %s\", str);\n+      ASSERT_EQ(result, buffer);\n+      ASSERT_EQ(strlen(result), result_len);\n+      ASSERT_EQ(result_len, initial_len);\n+      ASSERT_TRUE(result_len <= max_len);\n+    }\n+  }\n+\n+};\n+\n+char defaultStream::TestSupport::buffer[defaultStream::TestSupport::buflen];\n+size_t defaultStream::TestSupport::result_len = 0;\n+const char* defaultStream::TestSupport::result = nullptr;\n+\n+TEST_VM(ostream, do_vsnprintf_buffering) {\n+  defaultStream::TestSupport::test_constant_string();\n+  defaultStream::TestSupport::test_percent_s_string();\n+  defaultStream::TestSupport::test_general_string();\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_ostream.cpp","additions":252,"deletions":1,"binary":false,"changes":253,"status":"modified"}]}