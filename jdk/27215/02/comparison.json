{"files":[{"patch":"@@ -101,1 +101,1 @@\n-  fprintf(fp_hpp, \"#define RM_SIZE %d\\n\", RegisterForm::RegMask_Size());\n+  fprintf(fp_hpp, \"#define RM_SIZE_IN_INTS %d\\n\", RegisterForm::RegMask_Size());\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1580,2 +1580,2 @@\n-    \/\/ capture allstackedness flag before mask is hacked\n-    const int is_allstack = lrg->mask().is_AllStack();\n+    \/\/ capture infinitestackedness flag before mask is hacked\n+    const int is_infinite = lrg->mask().is_infinite();\n@@ -1632,1 +1632,1 @@\n-    \/\/assert(is_allstack == lrg->mask().is_AllStack(), \"nbrs must not change AllStackedness\");\n+    \/\/assert(is_infinite == lrg->mask().is_infinite(), \"nbrs must not change InfiniteStackedness\");\n@@ -1643,1 +1643,1 @@\n-    \/\/ If we fail to color and the AllStack flag is set, trigger\n+    \/\/ If we fail to color and the infinite flag is set, trigger\n@@ -1645,1 +1645,1 @@\n-    if(!OptoReg::is_valid(OptoReg::add(reg,-chunk)) && is_allstack) {\n+    if(!OptoReg::is_valid(OptoReg::add(reg,-chunk)) && is_infinite) {\n@@ -1711,1 +1711,1 @@\n-      assert( !orig_mask.is_AllStack(), \"All Stack does not spill\" );\n+      assert( !orig_mask.is_infinite(), \"infinite does not spill\" );\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  static const uint AllStack_size = 0xFFFFF; \/\/ This mask size is used to tell that the mask of this LRG supports stack positions\n+  static const uint InfiniteStack_size = 0xFFFFF; \/\/ This mask size is used to tell that the mask of this LRG supports stack positions\n@@ -86,1 +86,1 @@\n-    assert(!_mask.is_AllStack() || (_mask.is_AllStack() && lo_degree()), \"_eff_degree can't be bigger than AllStack_size - _num_regs if the mask supports stack registers\");\n+    assert(!_mask.is_infinite() || (_mask.is_infinite() && lo_degree()), \"_eff_degree can't be bigger than InfiniteStack_size - _num_regs if the mask supports stack registers\");\n@@ -93,1 +93,1 @@\n-    assert(!_mask.is_AllStack() || (_mask.is_AllStack() && lo_degree()), \"_eff_degree can't be bigger than AllStack_size - _num_regs if the mask supports stack registers\");\n+    assert(!_mask.is_infinite() || (_mask.is_infinite() && lo_degree()), \"_eff_degree can't be bigger than InfiniteStack_size - _num_regs if the mask supports stack registers\");\n@@ -108,1 +108,1 @@\n-  int compute_mask_size() const { return _mask.is_AllStack() ? AllStack_size : _mask.Size(); }\n+  int compute_mask_size() const { return _mask.is_infinite() ? InfiniteStack_size : _mask.Size(); }\n@@ -110,1 +110,1 @@\n-    assert((size == (int)AllStack_size) || (size == (int)_mask.Size()), \"\");\n+    assert((size == (int)InfiniteStack_size) || (size == (int)_mask.Size()), \"\");\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -584,1 +584,1 @@\n-          if( !lrgs(lidx).mask().is_AllStack() ) {\n+          if( !lrgs(lidx).mask().is_infinite() ) {\n@@ -701,1 +701,1 @@\n-  if (UseFPUForSpilling && rm.is_AllStack() ) {\n+  if (UseFPUForSpilling && rm.is_infinite() ) {\n@@ -710,1 +710,1 @@\n-  if( rm.is_AllStack() ) rm_size += 1000000;\n+  if( rm.is_infinite() ) rm_size += 1000000;\n","filename":"src\/hotspot\/share\/opto\/coalesce.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -751,1 +751,1 @@\n-        interfering_lrg.set_mask_size(interfering_lrg.mask().is_AllStack() ? LRG::AllStack_size : old_size - 1);\n+        interfering_lrg.set_mask_size(interfering_lrg.mask().is_infinite() ? LRG::AllStack_size : old_size - 1);\n","filename":"src\/hotspot\/share\/opto\/ifg.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-        if (!lrg.mask().is_AllStack()) {\n+        if (!lrg.mask().is_infinite()) {\n@@ -201,1 +201,1 @@\n-          if (!lrg.mask().is_AllStack()) {\n+          if (!lrg.mask().is_infinite()) {\n","filename":"src\/hotspot\/share\/opto\/indexSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -560,1 +560,1 @@\n-  C->FIRST_STACK_mask().set_AllStack();\n+  C->FIRST_STACK_mask().set_infinite();\n@@ -566,1 +566,1 @@\n-  assert(aligned_stack_mask.is_AllStack(), \"should be infinite stack\");\n+  assert(aligned_stack_mask.is_infinite(), \"should be infinite stack\");\n@@ -623,1 +623,1 @@\n-     assert(aligned_stack_mask.is_AllStack(), \"should be infinite stack\");\n+     assert(aligned_stack_mask.is_infinite(), \"should be infinite stack\");\n@@ -638,1 +638,1 @@\n-     assert(aligned_stack_mask.is_AllStack(), \"should be infinite stack\");\n+     assert(aligned_stack_mask.is_infinite(), \"should be infinite stack\");\n@@ -653,1 +653,1 @@\n-     assert(aligned_stack_mask.is_AllStack(), \"should be infinite stack\");\n+     assert(aligned_stack_mask.is_infinite(), \"should be infinite stack\");\n@@ -673,1 +673,1 @@\n-      assert(scalable_stack_mask.is_AllStack(), \"should be infinite stack\");\n+      assert(scalable_stack_mask.is_infinite(), \"should be infinite stack\");\n@@ -687,1 +687,1 @@\n-     assert(scalable_stack_mask.is_AllStack(), \"should be infinite stack\");\n+     assert(scalable_stack_mask.is_infinite(), \"should be infinite stack\");\n@@ -1001,1 +1001,1 @@\n-  STACK_ONLY_mask.set_AllStack();\n+  STACK_ONLY_mask.set_infinite();\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-                                                   : (use_mask.is_AllStack() != 0));\n+                                                   : (use_mask.is_infinite() != 0));\n","filename":"src\/hotspot\/share\/opto\/postaloc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -523,1 +523,1 @@\n-      assert(!lrgs(bidx).mask().is_AllStack(),\"AllStack should color\");\n+      assert(!lrgs(bidx).mask().is_infinite(),\"Infinite mask should color\");\n@@ -1040,1 +1040,1 @@\n-            if( !umask.is_AllStack() &&\n+            if( !umask.is_infinite() &&\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_word[i];\n@@ -125,1 +125,1 @@\n-    _RM_UP[i] = bits;\n+    _rm_word[i] = bits;\n@@ -138,1 +138,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_word[i];\n@@ -154,1 +154,1 @@\n-  if (is_AllStack()) return false;\n+  if (is_infinite()) return false;\n@@ -157,1 +157,1 @@\n-    uintptr_t v = _RM_UP[i];\n+    uintptr_t v = _rm_word[i];\n@@ -166,1 +166,1 @@\n-        if (_RM_UP[i] != 0) {\n+        if (_rm_word[i] != 0) {\n@@ -180,1 +180,1 @@\n-  if (is_AllStack()) return false;\n+  if (is_infinite()) return false;\n@@ -184,2 +184,2 @@\n-    if (_RM_UP[i] != 0) {               \/\/ Found some bits\n-      unsigned int bit_index = find_lowest_bit(_RM_UP[i]);\n+    if (_rm_word[i] != 0) {               \/\/ Found some bits\n+      unsigned int bit_index = find_lowest_bit(_rm_word[i]);\n@@ -188,1 +188,1 @@\n-        if ((bit | (bit << 1U)) != _RM_UP[i]) {\n+        if ((bit | (bit << 1U)) != _rm_word[i]) {\n@@ -192,1 +192,1 @@\n-        assert(is_power_of_2(_RM_UP[i]), \"invariant\");\n+        assert(is_power_of_2(_rm_word[i]), \"invariant\");\n@@ -194,1 +194,1 @@\n-        if (i > _hwm || _RM_UP[i] != 1) {\n+        if (i > _hwm || _rm_word[i] != 1) {\n@@ -201,1 +201,1 @@\n-        if (_RM_UP[i] != 0) {\n+        if (_rm_word[i] != 0) {\n@@ -247,1 +247,1 @@\n-    if (_RM_UP[i]) {                \/\/ Found some bits\n+    if (_rm_word[i]) {                \/\/ Found some bits\n@@ -249,1 +249,1 @@\n-      return OptoReg::Name((i<<_LogWordBits) + find_lowest_bit(_RM_UP[i]) + (size - 1));\n+      return OptoReg::Name((i<<_LogWordBits) + find_lowest_bit(_rm_word[i]) + (size - 1));\n@@ -263,1 +263,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_word[i];\n@@ -278,1 +278,1 @@\n-    _RM_UP[i] = sets;\n+    _rm_word[i] = sets;\n@@ -291,1 +291,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_word[i];\n@@ -307,1 +307,1 @@\n-    _RM_UP[i] = sets;\n+    _rm_word[i] = sets;\n@@ -320,1 +320,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_word[i];\n@@ -343,1 +343,1 @@\n-  if (is_AllStack()) return false;\n+  if (is_infinite()) return false;\n@@ -347,2 +347,2 @@\n-    if (_RM_UP[i] != 0) {       \/\/ Found some bits\n-      unsigned bit_index = find_lowest_bit(_RM_UP[i]);\n+    if (_rm_word[i] != 0) {       \/\/ Found some bits\n+      unsigned bit_index = find_lowest_bit(_rm_word[i]);\n@@ -353,1 +353,1 @@\n-        if (set != _RM_UP[i]) {\n+        if (set != _rm_word[i]) {\n@@ -358,1 +358,1 @@\n-        if ((all & ~(bit-1)) != _RM_UP[i]) {\n+        if ((all & ~(bit-1)) != _rm_word[i]) {\n@@ -364,1 +364,1 @@\n-        if (i > _hwm || _RM_UP[i] != set) {\n+        if (i > _hwm || _rm_word[i] != set) {\n@@ -371,1 +371,1 @@\n-        if (_RM_UP[i] != 0) {\n+        if (_rm_word[i] != 0) {\n@@ -386,1 +386,1 @@\n-  if (is_AllStack())\n+  if (is_infinite())\n@@ -400,1 +400,1 @@\n-    sum += population_count(_RM_UP[i]);\n+    sum += population_count(_rm_word[i]);\n@@ -448,1 +448,1 @@\n-    if (is_AllStack()) st->print(\"...\");\n+    if (is_infinite()) st->print(\"...\");\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-\/\/ The ADLC defines 2 macros, RM_SIZE and FORALL_BODY.\n-\/\/ RM_SIZE is the size of a register mask in 32-bit words.\n+\/\/ The ADLC defines 2 macros, RM_SIZE_IN_INTS and FORALL_BODY.\n+\/\/ RM_SIZE_IN_INTS is the size of a register mask in 32-bit words.\n@@ -62,2 +62,2 @@\n-  \/\/ The RM_SIZE is aligned to 64-bit - assert that this holds\n-  LP64_ONLY(STATIC_ASSERT(is_aligned(RM_SIZE, 2)));\n+  \/\/ RM_SIZE_IN_INTS is aligned to 64-bit - assert that this holds\n+  LP64_ONLY(STATIC_ASSERT(is_aligned(RM_SIZE_IN_INTS, 2)));\n@@ -67,2 +67,3 @@\n-  static const unsigned int _RM_SIZE     = LP64_ONLY(RM_SIZE >> 1) NOT_LP64(RM_SIZE);\n-  static const unsigned int _RM_MAX      = _RM_SIZE - 1U;\n+  static const unsigned int _RM_SIZE_IN_WORDS =\n+      LP64_ONLY(RM_SIZE_IN_INTS >> 1) NOT_LP64(RM_SIZE_IN_INTS);\n+  static const unsigned int _RM_WORD_MAX_INDEX = _RM_SIZE_IN_WORDS - 1U;\n@@ -76,2 +77,2 @@\n-    int       _RM_I[RM_SIZE];\n-    uintptr_t _RM_UP[_RM_SIZE];\n+    int       _rm_int[RM_SIZE_IN_INTS];\n+    uintptr_t _rm_word[_RM_SIZE_IN_WORDS];\n@@ -88,1 +89,1 @@\n-  enum { CHUNK_SIZE = _RM_SIZE * BitsPerWord };\n+  enum { CHUNK_SIZE = _RM_SIZE_IN_WORDS * BitsPerWord };\n@@ -120,1 +121,1 @@\n-#   define BODY(I) _RM_I[I] = a##I;\n+#   define BODY(I) _rm_int[I] = a##I;\n@@ -123,1 +124,1 @@\n-#   define BODY(I) _RM_I[I ^ 1] = a##I;\n+#   define BODY(I) _rm_int[I ^ 1] = a##I;\n@@ -128,3 +129,3 @@\n-    _hwm = _RM_MAX;\n-    while (_hwm > 0      && _RM_UP[_hwm] == 0) _hwm--;\n-    while ((_lwm < _hwm) && _RM_UP[_lwm] == 0) _lwm++;\n+    _hwm = _RM_WORD_MAX_INDEX;\n+    while (_hwm > 0      && _rm_word[_hwm] == 0) _hwm--;\n+    while ((_lwm < _hwm) && _rm_word[_lwm] == 0) _lwm++;\n@@ -138,2 +139,2 @@\n-    for (unsigned i = 0; i < _RM_SIZE; i++) {\n-      _RM_UP[i] = rm->_RM_UP[i];\n+    for (unsigned i = 0; i < _RM_SIZE_IN_WORDS; i++) {\n+      _rm_word[i] = rm->_rm_word[i];\n@@ -145,1 +146,1 @@\n-  RegMask() : _RM_UP(), _lwm(_RM_MAX), _hwm(0) {\n+  RegMask() : _rm_word(), _lwm(_RM_WORD_MAX_INDEX), _hwm(0) {\n@@ -159,1 +160,1 @@\n-    return _RM_UP[r >> _LogWordBits] & (uintptr_t(1) << (r & _WordBitMask));\n+    return _rm_word[r >> _LogWordBits] & (uintptr_t(1) << (r & _WordBitMask));\n@@ -165,2 +166,2 @@\n-  bool is_AllStack() const {\n-    return (_RM_UP[_RM_MAX] & (uintptr_t(1) << _WordBitMask)) != 0;\n+  bool is_infinite() const {\n+    return (_rm_word[_RM_WORD_MAX_INDEX] & (uintptr_t(1) << _WordBitMask)) != 0;\n@@ -169,2 +170,2 @@\n-  void set_AllStack() {\n-    _RM_UP[_RM_MAX] |= (uintptr_t(1) << _WordBitMask);\n+  void set_infinite() {\n+    _rm_word[_RM_WORD_MAX_INDEX] |= (uintptr_t(1) << _WordBitMask);\n@@ -178,1 +179,1 @@\n-      tmp |= _RM_UP[i];\n+      tmp |= _rm_word[i];\n@@ -187,1 +188,1 @@\n-      uintptr_t bits = _RM_UP[i];\n+      uintptr_t bits = _rm_word[i];\n@@ -201,1 +202,1 @@\n-      uintptr_t bits = _RM_UP[--i];\n+      uintptr_t bits = _rm_word[--i];\n@@ -216,2 +217,2 @@\n-    assert(_hwm < _RM_SIZE, \"_hwm out of range: %d\", _hwm);\n-    assert(_lwm < _RM_SIZE, \"_lwm out of range: %d\", _lwm);\n+    assert(_hwm < _RM_SIZE_IN_WORDS, \"_hwm out of range: %d\", _hwm);\n+    assert(_lwm < _RM_SIZE_IN_WORDS, \"_lwm out of range: %d\", _lwm);\n@@ -219,1 +220,1 @@\n-      assert(_RM_UP[i] == 0, \"_lwm too high: %d regs at: %d\", _lwm, i);\n+      assert(_rm_word[i] == 0, \"_lwm too high: %d regs at: %d\", _lwm, i);\n@@ -221,2 +222,2 @@\n-    for (unsigned i = _hwm + 1; i < _RM_SIZE; i++) {\n-      assert(_RM_UP[i] == 0, \"_hwm too low: %d regs at: %d\", _hwm, i);\n+    for (unsigned i = _hwm + 1; i < _RM_SIZE_IN_WORDS; i++) {\n+      assert(_rm_word[i] == 0, \"_hwm too low: %d regs at: %d\", _hwm, i);\n@@ -270,1 +271,1 @@\n-      result |= _RM_UP[i] & rm._RM_UP[i];\n+      result |= _rm_word[i] & rm._rm_word[i];\n@@ -281,1 +282,1 @@\n-    _lwm = _RM_MAX;\n+    _lwm = _RM_WORD_MAX_INDEX;\n@@ -283,1 +284,1 @@\n-    memset(_RM_UP, 0, sizeof(uintptr_t) * _RM_SIZE);\n+    memset(_rm_word, 0, sizeof(uintptr_t) * _RM_SIZE_IN_WORDS);\n@@ -290,2 +291,2 @@\n-    _hwm = _RM_MAX;\n-    memset(_RM_UP, 0xFF, sizeof(uintptr_t) * _RM_SIZE);\n+    _hwm = _RM_WORD_MAX_INDEX;\n+    memset(_rm_word, 0xFF, sizeof(uintptr_t) * _RM_SIZE_IN_WORDS);\n@@ -305,1 +306,1 @@\n-    _RM_UP[index] |= (uintptr_t(1) << (r & _WordBitMask));\n+    _rm_word[index] |= (uintptr_t(1) << (r & _WordBitMask));\n@@ -313,1 +314,1 @@\n-    _RM_UP[r >> _LogWordBits] &= ~(uintptr_t(1) << (r & _WordBitMask));\n+    _rm_word[r >> _LogWordBits] &= ~(uintptr_t(1) << (r & _WordBitMask));\n@@ -323,1 +324,1 @@\n-      _RM_UP[i] |= rm._RM_UP[i];\n+      _rm_word[i] |= rm._rm_word[i];\n@@ -334,1 +335,1 @@\n-      _RM_UP[i] &= rm._RM_UP[i];\n+      _rm_word[i] &= rm._rm_word[i];\n@@ -348,1 +349,1 @@\n-      _RM_UP[i] &= ~rm._RM_UP[i];\n+      _rm_word[i] &= ~rm._rm_word[i];\n@@ -418,1 +419,1 @@\n-      _current_bits = _rm._RM_UP[_next_index++];\n+      _current_bits = _rm._rm_word[_next_index++];\n@@ -438,1 +439,1 @@\n-#undef RM_SIZE\n+#undef RM_SIZE_IN_INTS\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":44,"deletions":43,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    ASSERT_TRUE(!rm.is_AllStack());\n+    ASSERT_TRUE(!rm.is_infinite());\n@@ -87,2 +87,2 @@\n-  \/\/ Set_All sets AllStack bit\n-  ASSERT_TRUE(rm.is_AllStack());\n+  \/\/ Set_All sets the infinite bit\n+  ASSERT_TRUE(rm.is_infinite());\n@@ -138,1 +138,1 @@\n-  ASSERT_TRUE(rm1.is_AllStack());\n+  ASSERT_TRUE(rm1.is_infinite());\n@@ -154,2 +154,2 @@\n-  \/\/ AllStack bit does not count as a bound register\n-  rm.set_AllStack();\n+  \/\/ The infinite bit does not count as a bound register\n+  rm.set_infinite();\n@@ -171,1 +171,1 @@\n-  \/\/ A pair with the AllStack bit does not count as a bound pair\n+  \/\/ A pair with the infinite bit does not count as a bound pair\n@@ -190,1 +190,1 @@\n-    \/\/ A set with the AllStack bit does not count as a bound set\n+    \/\/ A set with the infinite bit does not count as a bound set\n@@ -197,1 +197,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/gtest\/opto\/test_regmask.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}