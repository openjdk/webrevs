{"files":[{"patch":"@@ -101,1 +101,1 @@\n-  fprintf(fp_hpp, \"#define RM_SIZE %d\\n\", RegisterForm::RegMask_Size());\n+  fprintf(fp_hpp, \"#define RM_SIZE_IN_INTS %d\\n\", RegisterForm::RegMask_Size());\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1580,2 +1580,2 @@\n-    \/\/ capture allstackedness flag before mask is hacked\n-    const int is_allstack = lrg->mask().is_AllStack();\n+    \/\/ capture infinitestackedness flag before mask is hacked\n+    const int is_infinite_stack = lrg->mask().is_infinite_stack();\n@@ -1632,1 +1632,1 @@\n-    \/\/assert(is_allstack == lrg->mask().is_AllStack(), \"nbrs must not change AllStackedness\");\n+    \/\/assert(is_infinite_stack == lrg->mask().is_infinite_stack(), \"nbrs must not change InfiniteStackedness\");\n@@ -1643,1 +1643,1 @@\n-    \/\/ If we fail to color and the AllStack flag is set, trigger\n+    \/\/ If we fail to color and the infinite flag is set, trigger\n@@ -1645,1 +1645,1 @@\n-    if(!OptoReg::is_valid(OptoReg::add(reg,-chunk)) && is_allstack) {\n+    if (!OptoReg::is_valid(OptoReg::add(reg, -chunk)) && is_infinite_stack) {\n@@ -1654,1 +1654,1 @@\n-    else if( OptoReg::is_valid(reg)) {\n+    else if (OptoReg::is_valid(reg)) {\n@@ -1711,1 +1711,1 @@\n-      assert( !orig_mask.is_AllStack(), \"All Stack does not spill\" );\n+      assert( !orig_mask.is_infinite_stack(), \"infinite stack does not spill\" );\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  static const uint AllStack_size = 0xFFFFF; \/\/ This mask size is used to tell that the mask of this LRG supports stack positions\n+  static const uint INFINITE_STACK_SIZE = 0xFFFFF; \/\/ This mask size is used to tell that the mask of this LRG supports stack positions\n@@ -86,1 +86,1 @@\n-    assert(!_mask.is_AllStack() || (_mask.is_AllStack() && lo_degree()), \"_eff_degree can't be bigger than AllStack_size - _num_regs if the mask supports stack registers\");\n+    assert(!_mask.is_infinite_stack() || (_mask.is_infinite_stack() && lo_degree()), \"_eff_degree can't be bigger than INFINITE_STACK_SIZE - _num_regs if the mask supports stack registers\");\n@@ -93,1 +93,1 @@\n-    assert(!_mask.is_AllStack() || (_mask.is_AllStack() && lo_degree()), \"_eff_degree can't be bigger than AllStack_size - _num_regs if the mask supports stack registers\");\n+    assert(!_mask.is_infinite_stack() || (_mask.is_infinite_stack() && lo_degree()), \"_eff_degree can't be bigger than INFINITE_STACK_SIZE - _num_regs if the mask supports stack registers\");\n@@ -108,1 +108,1 @@\n-  int compute_mask_size() const { return _mask.is_AllStack() ? AllStack_size : _mask.Size(); }\n+  int compute_mask_size() const { return _mask.is_infinite_stack() ? INFINITE_STACK_SIZE : _mask.Size(); }\n@@ -110,1 +110,1 @@\n-    assert((size == (int)AllStack_size) || (size == (int)_mask.Size()), \"\");\n+    assert((size == (int)INFINITE_STACK_SIZE) || (size == (int)_mask.Size()), \"\");\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -584,1 +584,1 @@\n-          if( !lrgs(lidx).mask().is_AllStack() ) {\n+          if( !lrgs(lidx).mask().is_infinite_stack() ) {\n@@ -701,1 +701,1 @@\n-  if (UseFPUForSpilling && rm.is_AllStack() ) {\n+  if (UseFPUForSpilling && rm.is_infinite_stack()) {\n@@ -710,1 +710,3 @@\n-  if( rm.is_AllStack() ) rm_size += 1000000;\n+  if (rm.is_infinite_stack()) {\n+    rm_size += 1000000;\n+  }\n","filename":"src\/hotspot\/share\/opto\/coalesce.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -751,1 +751,1 @@\n-        interfering_lrg.set_mask_size(interfering_lrg.mask().is_AllStack() ? LRG::AllStack_size : old_size - 1);\n+        interfering_lrg.set_mask_size(interfering_lrg.mask().is_infinite_stack() ? LRG::INFINITE_STACK_SIZE : old_size - 1);\n","filename":"src\/hotspot\/share\/opto\/ifg.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-        if (!lrg.mask().is_AllStack()) {\n+        if (!lrg.mask().is_infinite_stack()) {\n@@ -201,1 +201,1 @@\n-          if (!lrg.mask().is_AllStack()) {\n+          if (!lrg.mask().is_infinite_stack()) {\n","filename":"src\/hotspot\/share\/opto\/indexSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -560,1 +560,1 @@\n-  C->FIRST_STACK_mask().set_AllStack();\n+  C->FIRST_STACK_mask().set_infinite();\n@@ -566,1 +566,1 @@\n-  assert(aligned_stack_mask.is_AllStack(), \"should be infinite stack\");\n+  assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n@@ -623,1 +623,1 @@\n-     assert(aligned_stack_mask.is_AllStack(), \"should be infinite stack\");\n+     assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n@@ -638,1 +638,1 @@\n-     assert(aligned_stack_mask.is_AllStack(), \"should be infinite stack\");\n+     assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n@@ -653,1 +653,1 @@\n-     assert(aligned_stack_mask.is_AllStack(), \"should be infinite stack\");\n+     assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n@@ -673,1 +673,1 @@\n-      assert(scalable_stack_mask.is_AllStack(), \"should be infinite stack\");\n+      assert(scalable_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n@@ -687,1 +687,1 @@\n-     assert(scalable_stack_mask.is_AllStack(), \"should be infinite stack\");\n+     assert(scalable_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n@@ -1001,1 +1001,1 @@\n-  STACK_ONLY_mask.set_AllStack();\n+  STACK_ONLY_mask.set_infinite();\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -176,2 +176,2 @@\n-  bool can_use = ( RegMask::can_represent(def_reg) ? (use_mask.Member(def_reg) != 0)\n-                                                   : (use_mask.is_AllStack() != 0));\n+  bool can_use = (RegMask::can_represent(def_reg) ? (use_mask.Member(def_reg) != 0)\n+                                                  : (use_mask.is_infinite_stack() != 0));\n","filename":"src\/hotspot\/share\/opto\/postaloc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -523,1 +523,1 @@\n-      assert(!lrgs(bidx).mask().is_AllStack(),\"AllStack should color\");\n+      assert(!lrgs(bidx).mask().is_infinite_stack(), \"Infinite stack mask should color\");\n@@ -1040,1 +1040,1 @@\n-            if( !umask.is_AllStack() &&\n+            if (!umask.is_infinite_stack() &&\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_word[i];\n@@ -125,1 +125,1 @@\n-    _RM_UP[i] = bits;\n+    _rm_word[i] = bits;\n@@ -138,1 +138,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_word[i];\n@@ -154,1 +154,3 @@\n-  if (is_AllStack()) return false;\n+  if (is_infinite_stack()) {\n+    return false;\n+  }\n@@ -157,1 +159,1 @@\n-    uintptr_t v = _RM_UP[i];\n+    uintptr_t v = _rm_word[i];\n@@ -166,1 +168,1 @@\n-        if (_RM_UP[i] != 0) {\n+        if (_rm_word[i] != 0) {\n@@ -180,1 +182,3 @@\n-  if (is_AllStack()) return false;\n+  if (is_infinite_stack()) {\n+    return false;\n+  }\n@@ -184,3 +188,3 @@\n-    if (_RM_UP[i] != 0) {               \/\/ Found some bits\n-      unsigned int bit_index = find_lowest_bit(_RM_UP[i]);\n-      if (bit_index != _WordBitMask) {   \/\/ Bit pair stays in same word?\n+    if (_rm_word[i] != 0) {               \/\/ Found some bits\n+      unsigned int bit_index = find_lowest_bit(_rm_word[i]);\n+      if (bit_index != WORD_BIT_MASK) {   \/\/ Bit pair stays in same word?\n@@ -188,1 +192,1 @@\n-        if ((bit | (bit << 1U)) != _RM_UP[i]) {\n+        if ((bit | (bit << 1U)) != _rm_word[i]) {\n@@ -192,1 +196,1 @@\n-        assert(is_power_of_2(_RM_UP[i]), \"invariant\");\n+        assert(is_power_of_2(_rm_word[i]), \"invariant\");\n@@ -194,1 +198,1 @@\n-        if (i > _hwm || _RM_UP[i] != 1) {\n+        if (i > _hwm || _rm_word[i] != 1) {\n@@ -201,1 +205,1 @@\n-        if (_RM_UP[i] != 0) {\n+        if (_rm_word[i] != 0) {\n@@ -247,1 +251,1 @@\n-    if (_RM_UP[i]) {                \/\/ Found some bits\n+    if (_rm_word[i]) {                \/\/ Found some bits\n@@ -249,1 +253,1 @@\n-      return OptoReg::Name((i<<_LogWordBits) + find_lowest_bit(_RM_UP[i]) + (size - 1));\n+      return OptoReg::Name((i << LogBitsPerWord) + find_lowest_bit(_rm_word[i]) + (size - 1));\n@@ -263,1 +267,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_word[i];\n@@ -278,1 +282,1 @@\n-    _RM_UP[i] = sets;\n+    _rm_word[i] = sets;\n@@ -291,1 +295,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_word[i];\n@@ -307,1 +311,1 @@\n-    _RM_UP[i] = sets;\n+    _rm_word[i] = sets;\n@@ -320,1 +324,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_word[i];\n@@ -343,1 +347,3 @@\n-  if (is_AllStack()) return false;\n+  if (is_infinite_stack()) {\n+    return false;\n+  }\n@@ -347,2 +353,2 @@\n-    if (_RM_UP[i] != 0) {       \/\/ Found some bits\n-      unsigned bit_index = find_lowest_bit(_RM_UP[i]);\n+    if (_rm_word[i] != 0) {       \/\/ Found some bits\n+      unsigned bit_index = find_lowest_bit(_rm_word[i]);\n@@ -353,1 +359,1 @@\n-        if (set != _RM_UP[i]) {\n+        if (set != _rm_word[i]) {\n@@ -358,1 +364,1 @@\n-        if ((all & ~(bit-1)) != _RM_UP[i]) {\n+        if ((all & ~(bit - 1)) != _rm_word[i]) {\n@@ -364,1 +370,1 @@\n-        if (i > _hwm || _RM_UP[i] != set) {\n+        if (i > _hwm || _rm_word[i] != set) {\n@@ -371,1 +377,1 @@\n-        if (_RM_UP[i] != 0) {\n+        if (_rm_word[i] != 0) {\n@@ -386,1 +392,1 @@\n-  if (is_AllStack())\n+  if (is_infinite_stack()) {\n@@ -388,0 +394,1 @@\n+  }\n@@ -400,1 +407,1 @@\n-    sum += population_count(_RM_UP[i]);\n+    sum += population_count(_rm_word[i]);\n@@ -448,1 +455,3 @@\n-    if (is_AllStack()) st->print(\"...\");\n+    if (is_infinite_stack()) {\n+      st->print(\"...\");\n+    }\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":40,"deletions":31,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-\/\/ The ADLC defines 2 macros, RM_SIZE and FORALL_BODY.\n-\/\/ RM_SIZE is the size of a register mask in 32-bit words.\n+\/\/ The ADLC defines 2 macros, RM_SIZE_IN_INTS and FORALL_BODY.\n+\/\/ RM_SIZE_IN_INTS is the size of a register mask in 32-bit words.\n@@ -62,2 +62,2 @@\n-  \/\/ The RM_SIZE is aligned to 64-bit - assert that this holds\n-  LP64_ONLY(STATIC_ASSERT(is_aligned(RM_SIZE, 2)));\n+  \/\/ RM_SIZE_IN_INTS is aligned to 64-bit - assert that this holds\n+  LP64_ONLY(STATIC_ASSERT(is_aligned(RM_SIZE_IN_INTS, 2)));\n@@ -65,4 +65,4 @@\n-  static const unsigned int _WordBitMask = BitsPerWord - 1U;\n-  static const unsigned int _LogWordBits = LogBitsPerWord;\n-  static const unsigned int _RM_SIZE     = LP64_ONLY(RM_SIZE >> 1) NOT_LP64(RM_SIZE);\n-  static const unsigned int _RM_MAX      = _RM_SIZE - 1U;\n+  static const unsigned int WORD_BIT_MASK = BitsPerWord - 1U;\n+  static const unsigned int RM_SIZE_IN_WORDS =\n+      LP64_ONLY(RM_SIZE_IN_INTS >> 1) NOT_LP64(RM_SIZE_IN_INTS);\n+  static const unsigned int RM_WORD_MAX_INDEX = RM_SIZE_IN_WORDS - 1U;\n@@ -76,2 +76,2 @@\n-    int       _RM_I[RM_SIZE];\n-    uintptr_t _RM_UP[_RM_SIZE];\n+    int _rm_int[RM_SIZE_IN_INTS];\n+    uintptr_t _rm_word[RM_SIZE_IN_WORDS];\n@@ -88,1 +88,1 @@\n-  enum { CHUNK_SIZE = _RM_SIZE * BitsPerWord };\n+  enum { CHUNK_SIZE = RM_SIZE_IN_WORDS * BitsPerWord };\n@@ -120,1 +120,1 @@\n-#   define BODY(I) _RM_I[I] = a##I;\n+#   define BODY(I) _rm_int[I] = a##I;\n@@ -123,1 +123,1 @@\n-#   define BODY(I) _RM_I[I ^ 1] = a##I;\n+#   define BODY(I) _rm_int[I ^ 1] = a##I;\n@@ -128,3 +128,7 @@\n-    _hwm = _RM_MAX;\n-    while (_hwm > 0      && _RM_UP[_hwm] == 0) _hwm--;\n-    while ((_lwm < _hwm) && _RM_UP[_lwm] == 0) _lwm++;\n+    _hwm = RM_WORD_MAX_INDEX;\n+    while (_hwm > 0 && _rm_word[_hwm] == 0) {\n+      _hwm--;\n+    }\n+    while ((_lwm < _hwm) && _rm_word[_lwm] == 0) {\n+      _lwm++;\n+    }\n@@ -138,2 +142,2 @@\n-    for (unsigned i = 0; i < _RM_SIZE; i++) {\n-      _RM_UP[i] = rm->_RM_UP[i];\n+    for (unsigned i = 0; i < RM_SIZE_IN_WORDS; i++) {\n+      _rm_word[i] = rm->_rm_word[i];\n@@ -145,1 +149,1 @@\n-  RegMask() : _RM_UP(), _lwm(_RM_MAX), _hwm(0) {\n+  RegMask() : _rm_word(), _lwm(RM_WORD_MAX_INDEX), _hwm(0) {\n@@ -159,1 +163,1 @@\n-    return _RM_UP[r >> _LogWordBits] & (uintptr_t(1) << (r & _WordBitMask));\n+    return _rm_word[r >> LogBitsPerWord] & (uintptr_t(1) << (r & WORD_BIT_MASK));\n@@ -165,2 +169,2 @@\n-  bool is_AllStack() const {\n-    return (_RM_UP[_RM_MAX] & (uintptr_t(1) << _WordBitMask)) != 0;\n+  bool is_infinite_stack() const {\n+    return (_rm_word[RM_WORD_MAX_INDEX] & (uintptr_t(1) << WORD_BIT_MASK)) != 0;\n@@ -169,2 +173,2 @@\n-  void set_AllStack() {\n-    _RM_UP[_RM_MAX] |= (uintptr_t(1) << _WordBitMask);\n+  void set_infinite() {\n+    _rm_word[RM_WORD_MAX_INDEX] |= (uintptr_t(1) << WORD_BIT_MASK);\n@@ -178,1 +182,1 @@\n-      tmp |= _RM_UP[i];\n+      tmp |= _rm_word[i];\n@@ -187,1 +191,1 @@\n-      uintptr_t bits = _RM_UP[i];\n+      uintptr_t bits = _rm_word[i];\n@@ -189,1 +193,1 @@\n-        return OptoReg::Name((i << _LogWordBits) + find_lowest_bit(bits));\n+        return OptoReg::Name((i << LogBitsPerWord) + find_lowest_bit(bits));\n@@ -201,1 +205,1 @@\n-      uintptr_t bits = _RM_UP[--i];\n+      uintptr_t bits = _rm_word[--i];\n@@ -203,1 +207,1 @@\n-        return OptoReg::Name((i << _LogWordBits) + find_highest_bit(bits));\n+        return OptoReg::Name((i << LogBitsPerWord) + find_highest_bit(bits));\n@@ -216,2 +220,2 @@\n-    assert(_hwm < _RM_SIZE, \"_hwm out of range: %d\", _hwm);\n-    assert(_lwm < _RM_SIZE, \"_lwm out of range: %d\", _lwm);\n+    assert(_hwm < RM_SIZE_IN_WORDS, \"_hwm out of range: %d\", _hwm);\n+    assert(_lwm < RM_SIZE_IN_WORDS, \"_lwm out of range: %d\", _lwm);\n@@ -219,1 +223,1 @@\n-      assert(_RM_UP[i] == 0, \"_lwm too high: %d regs at: %d\", _lwm, i);\n+      assert(_rm_word[i] == 0, \"_lwm too high: %d regs at: %d\", _lwm, i);\n@@ -221,2 +225,2 @@\n-    for (unsigned i = _hwm + 1; i < _RM_SIZE; i++) {\n-      assert(_RM_UP[i] == 0, \"_hwm too low: %d regs at: %d\", _hwm, i);\n+    for (unsigned i = _hwm + 1; i < RM_SIZE_IN_WORDS; i++) {\n+      assert(_rm_word[i] == 0, \"_hwm too low: %d regs at: %d\", _hwm, i);\n@@ -270,1 +274,1 @@\n-      result |= _RM_UP[i] & rm._RM_UP[i];\n+      result |= _rm_word[i] & rm._rm_word[i];\n@@ -281,1 +285,1 @@\n-    _lwm = _RM_MAX;\n+    _lwm = RM_WORD_MAX_INDEX;\n@@ -283,1 +287,1 @@\n-    memset(_RM_UP, 0, sizeof(uintptr_t) * _RM_SIZE);\n+    memset(_rm_word, 0, sizeof(uintptr_t) * RM_SIZE_IN_WORDS);\n@@ -290,2 +294,2 @@\n-    _hwm = _RM_MAX;\n-    memset(_RM_UP, 0xFF, sizeof(uintptr_t) * _RM_SIZE);\n+    _hwm = RM_WORD_MAX_INDEX;\n+    memset(_rm_word, 0xFF, sizeof(uintptr_t) * RM_SIZE_IN_WORDS);\n@@ -302,1 +306,1 @@\n-    unsigned index = r >> _LogWordBits;\n+    unsigned index = r >> LogBitsPerWord;\n@@ -305,1 +309,1 @@\n-    _RM_UP[index] |= (uintptr_t(1) << (r & _WordBitMask));\n+    _rm_word[index] |= (uintptr_t(1) << (r & WORD_BIT_MASK));\n@@ -313,1 +317,1 @@\n-    _RM_UP[r >> _LogWordBits] &= ~(uintptr_t(1) << (r & _WordBitMask));\n+    _rm_word[r >> LogBitsPerWord] &= ~(uintptr_t(1) << (r & WORD_BIT_MASK));\n@@ -323,1 +327,1 @@\n-      _RM_UP[i] |= rm._RM_UP[i];\n+      _rm_word[i] |= rm._rm_word[i];\n@@ -334,1 +338,1 @@\n-      _RM_UP[i] &= rm._RM_UP[i];\n+      _rm_word[i] &= rm._rm_word[i];\n@@ -348,1 +352,1 @@\n-      _RM_UP[i] &= ~rm._RM_UP[i];\n+      _rm_word[i] &= ~rm._rm_word[i];\n@@ -418,1 +422,1 @@\n-      _current_bits = _rm._RM_UP[_next_index++];\n+      _current_bits = _rm._rm_word[_next_index++];\n@@ -426,1 +430,1 @@\n-        _reg = OptoReg::Name(((_next_index - 1) << RegMask::_LogWordBits) + next_bit);\n+        _reg = OptoReg::Name(((_next_index - 1) << LogBitsPerWord) + next_bit);\n@@ -438,1 +442,1 @@\n-#undef RM_SIZE\n+#undef RM_SIZE_IN_INTS\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":53,"deletions":49,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    ASSERT_TRUE(!rm.is_AllStack());\n+    ASSERT_TRUE(!rm.is_infinite_stack());\n@@ -87,2 +87,2 @@\n-  \/\/ Set_All sets AllStack bit\n-  ASSERT_TRUE(rm.is_AllStack());\n+  \/\/ Set_All sets the infinite bit\n+  ASSERT_TRUE(rm.is_infinite_stack());\n@@ -138,1 +138,1 @@\n-  ASSERT_TRUE(rm1.is_AllStack());\n+  ASSERT_TRUE(rm1.is_infinite_stack());\n@@ -154,2 +154,2 @@\n-  \/\/ AllStack bit does not count as a bound register\n-  rm.set_AllStack();\n+  \/\/ The infinite bit does not count as a bound register\n+  rm.set_infinite();\n@@ -171,1 +171,1 @@\n-  \/\/ A pair with the AllStack bit does not count as a bound pair\n+  \/\/ A pair with the infinite bit does not count as a bound pair\n@@ -190,1 +190,1 @@\n-    \/\/ A set with the AllStack bit does not count as a bound set\n+    \/\/ A set with the infinite bit does not count as a bound set\n@@ -197,1 +197,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/gtest\/opto\/test_regmask.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}