{"files":[{"patch":"@@ -2987,0 +2987,3 @@\n+  if (_store->is_unsafe_access()) {\n+    return nullptr;\n+  }\n@@ -3020,0 +3023,1 @@\n+  assert(!_store->is_unsafe_access(), \"no unsafe accesses\");\n@@ -3024,1 +3028,2 @@\n-      other_store->adr_type()->isa_aryptr() == nullptr) {\n+      other_store->adr_type()->isa_aryptr() == nullptr ||\n+      other_store->is_unsafe_access()) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -512,2 +512,3 @@\n-    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    \/\/ Disabled by JDK-8335390, to be enabled again by JDK-8335392.\n+    \/\/ @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+    \/\/     applyIf = {\"UseUnalignedAccesses\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335390\n+ * @summary Test merge stores for some Unsafe store address patterns.\n+ * @modules java.base\/jdk.internal.misc\n+ * @requires vm.bits == 64\n+ * @requires os.maxMemory > 8G\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.c2.TestMergeStoresUnsafeArrayPointer::test*\n+ *                   -Xbatch\n+ *                   -Xmx8g\n+ *                   compiler.c2.TestMergeStoresUnsafeArrayPointer\n+ * @run main\/othervm -Xmx8g\n+ *                   compiler.c2.TestMergeStoresUnsafeArrayPointer\n+ *\/\n+\n+package compiler.c2;\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestMergeStoresUnsafeArrayPointer {\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    \/\/ We allocate a big int array of length:\n+    static final int SIZE = (1 << 30) + 100;\n+\n+    \/\/ This gives us a memory region of 4x as many bytes:\n+    static final long BYTE_SIZE = 4L * SIZE; \/\/ = 1L << 32 + 400L\n+\n+    \/\/ We set an \"anchor\" in the middle of this memory region, in bytes:\n+    static final long ANCHOR = BYTE_SIZE \/ 2;\n+\n+    static int four = 4;\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"Allocate big array of SIZE = \" + SIZE);\n+        int[] big = new int[SIZE];\n+\n+        \/\/ Each test is executed a few times, so that we can see the difference between\n+        \/\/ interpreter and compiler.\n+        int errors = 0;\n+\n+        long val = 0;\n+        System.out.println(\"test1\");\n+        for (int i = 0; i < 100_000; i++) {\n+            testClear(big);\n+            test1(big, ANCHOR);\n+            long sum = testSum(big);\n+            if (i == 0) {\n+                val = sum;\n+            } else {\n+                if (sum != val) {\n+                    System.out.println(\"ERROR: test1 had wrong value: \" + val + \" != \" + sum);\n+                    errors++;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        val = 0;\n+        System.out.println(\"test2\");\n+        for (int i = 0; i < 100_000; i++) {\n+            testClear(big);\n+            test2(big, ANCHOR);\n+            long sum = testSum(big);\n+            if (i == 0) {\n+                val = sum;\n+            } else {\n+                if (sum != val) {\n+                    System.out.println(\"ERROR: test2 had wrong value: \" + val + \" != \" + sum);\n+                    errors++;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (errors > 0) {\n+            throw new RuntimeException(\"ERRORS: \" + errors);\n+        }\n+        System.out.println(\"PASSED\");\n+    }\n+\n+    \/\/ Only clear and sum over relevant parts of array to make the test fast.\n+    static void testClear(int[] a) {\n+        for (int j = 0               ; j <              100; j++) { a[j] = j; }\n+        for (int j = a.length\/2 - 100; j < a.length\/2 + 100; j++) { a[j] = j; }\n+        for (int j = a.length   - 100; j < a.length   +   0; j++) { a[j] = j; }\n+    }\n+\n+    static long testSum(int[] a) {\n+        long sum = 0;\n+        for (int j = 0               ; j <              100; j++) { sum += a[j]; }\n+        for (int j = a.length\/2 - 100; j < a.length\/2 + 100; j++) { sum += a[j]; }\n+        for (int j = a.length   - 100; j < a.length   +   0; j++) { sum += a[j]; }\n+        return sum;\n+    }\n+\n+    \/\/ Reference: expected to merge.\n+    static void test1(int[] a, long anchor) {\n+        long base = UNSAFE.ARRAY_INT_BASE_OFFSET + anchor;\n+        UNSAFE.putInt(a, base + 0, 0x42424242);\n+        UNSAFE.putInt(a, base + 4, 0x66666666);\n+    }\n+\n+    \/\/ Test: if MergeStores is applied this can lead to wrong results\n+    static void test2(int[] a, long anchor) {\n+        long base = UNSAFE.ARRAY_INT_BASE_OFFSET + ANCHOR;\n+        UNSAFE.putInt(a, base + 0                 + (long)(four + Integer.MAX_VALUE), 0x42424242);\n+        UNSAFE.putInt(a, base + Integer.MAX_VALUE + (long)(four + 4                ), 0x66666666);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStoresUnsafeArrayPointer.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"}]}