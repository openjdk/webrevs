{"files":[{"patch":"@@ -0,0 +1,294 @@\n+\/*\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.imageio.plugins.jpeg;\n+\n+import com.sun.imageio.plugins.tiff.TIFFImageReader;\n+\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageReader;\n+import javax.imageio.stream.ImageInputStream;\n+import javax.imageio.stream.MemoryCacheImageInputStream;\n+import java.awt.image.BufferedImage;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteOrder;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * An Exif (Exchangeable Image File Format) APP1 (Application-Specific)\n+ * marker segment. This implementation only supports reading thumbnails\n+ * and the image creation time.\n+ *\/\n+class ExifMarkerSegment extends MarkerSegment {\n+\n+    static class ImageFileDirectory implements Cloneable {\n+        static class Entry implements Cloneable {\n+            final int tagNumber, dataFormat;\n+            final long componentCount, fieldValue;\n+\n+            Entry(ImageInputStream in) throws IOException {\n+                tagNumber = in.readUnsignedShort();\n+                dataFormat = in.readUnsignedShort();\n+                componentCount = in.readUnsignedInt();\n+                fieldValue = in.readUnsignedInt();\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return \"Entry[ tagNumber: \" + tagNumber +\n+                        \", dataFormat: \" + dataFormat +\n+                        \", componentCount: \" + componentCount +\n+                        \", fieldValue: \" + fieldValue + \"]\";\n+            }\n+        }\n+        static final int[] bytesPerComponent = new int[] {1, 1, 1, 2, 4, 8, 1};\n+\n+        Map<Integer, Entry> entriesByTag = new LinkedHashMap<>();\n+        long nextIFD;\n+\n+        ImageFileDirectory(ImageInputStream in, long pos) throws IOException {\n+            in.seek(pos);\n+            int entryCount = in.readUnsignedShort();\n+            for (int a = 0; a < entryCount; a++) {\n+                Entry e = new Entry(in);\n+                entriesByTag.put(e.tagNumber, e);\n+            }\n+\n+            \/\/ The next 4 bytes SHOULD be the position of the next IFD.\n+\n+            \/\/ However in rare cases: the position of the next IFD header is missing. We can detect\n+            \/\/ this by checking to see if any of the IFD entries we just read appear where the\n+            \/\/ next IFD position *should* be:\n+\n+            long streamPos = in.getStreamPosition();\n+            for (Entry e : entriesByTag.values()) {\n+                int byteLength = e.dataFormat < bytesPerComponent.length ?\n+                        (int) (e.componentCount * bytesPerComponent[e.dataFormat]) :\n+                        \/\/ this is an unknown data format, so let's just assume its 1 byte\n+                        1;\n+                if (byteLength > 4) {\n+                    long valuePos = e.fieldValue;\n+                    if (valuePos <= streamPos) {\n+                        nextIFD = 0;\n+                        return;\n+                    }\n+                }\n+            }\n+\n+            nextIFD = in.readUnsignedInt();\n+        }\n+\n+        int getTagValueAsInt(int tagID) {\n+            ImageFileDirectory.Entry e = entriesByTag.get(tagID);\n+            if (e == null) {\n+                return NO_VALUE;\n+            }\n+            return (int) e.fieldValue;\n+        }\n+    }\n+\n+    private static final int NO_VALUE = -1;\n+\n+    private static final int TIFF_BIG_ENDIAN = 0x4d4d;\n+    private static final int TIFF_MAGIC = 42;\n+    private static final int TIFF_TYPE_SHORT = 3;\n+    private static final int TAG_IMAGE_WIDTH = 256;\n+    private static final int TAG_IMAGE_HEIGHT = 257;\n+    private static final int TAG_DATE_TIME = 306;\n+    private static final int TAG_JPEG_INTERCHANGE_FORMAT = 513;\n+    private static final int TAG_JPEG_INTERCHANGE_FORMAT_LENGTH = 514;\n+\n+    int thumbnailPos = -1;\n+    int thumbnailLength = -1;\n+    boolean isThumbnailJPEG;\n+\n+    int thumbnailWidth = -1;\n+    int thumbnailHeight = -1;\n+\n+    final long firstIFDOffset;\n+    final List<ImageFileDirectory> imageFileDirectories = new LinkedList<>();\n+\n+    ExifMarkerSegment(MarkerSegment originalSegment) throws IOException {\n+        super(originalSegment.tag);\n+        this.length = originalSegment.length;\n+        this.data = originalSegment.data;\n+\n+        ByteArrayInputStream in = new ByteArrayInputStream(data, 6, data.length - 6);\n+\n+        \/\/ we aren't actually going to read anything as an image yet, but ImageInputStream\n+        \/\/ has useful helper methods:\n+        ImageInputStream input = new MemoryCacheImageInputStream(in);\n+        input.setByteOrder(input.readUnsignedShort() == TIFF_BIG_ENDIAN ?\n+                ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN);\n+        if (input.readUnsignedShort() != TIFF_MAGIC) {\n+            throw new IllegalArgumentException(\"Bad magic number\");\n+        }\n+\n+        firstIFDOffset = input.readUnsignedInt();\n+        ImageFileDirectory ifd1 = null;\n+        ImageFileDirectory ifd2 = null;\n+        if (firstIFDOffset != 0) {\n+            ifd1 = new ImageFileDirectory(input, firstIFDOffset);\n+            imageFileDirectories.add(ifd1);\n+\n+            long secondIFDOffset = ifd1.nextIFD;\n+            if (secondIFDOffset != 0) {\n+                ifd2 = new ImageFileDirectory(input, secondIFDOffset);\n+                imageFileDirectories.add(ifd2);\n+            }\n+        }\n+\n+        if (ifd2 != null) {\n+            \/\/ the thumbnail should always be described in the 2nd IFD (if it exists at all)\n+\n+            thumbnailPos = ifd2.getTagValueAsInt(TAG_JPEG_INTERCHANGE_FORMAT);\n+            thumbnailLength = ifd2.getTagValueAsInt(TAG_JPEG_INTERCHANGE_FORMAT_LENGTH);\n+            if (thumbnailPos != NO_VALUE && thumbnailLength != NO_VALUE) {\n+                \/\/ The `compression` tag (259) should also help inform whether we read this\n+                \/\/ image as a JPEG or TIFF. But in reality this is tricky: the docs say\n+                \/\/ the value for a JPEG encoding is 0x0006, but the `jdk_8160327-plastic-wrap.jpg`\n+                \/\/ file shows it can also sometimes be 0x60000. I've also observed it to be\n+                \/\/ undefined, 0x0007, or several variations of 0x????0006. Similarly the same\n+                \/\/ tag should be 0x0001 for TIFFs, but I also observed a case where it as 0x10000.\n+                isThumbnailJPEG = true;\n+            } else {\n+                thumbnailWidth = ifd2.getTagValueAsInt(TAG_IMAGE_WIDTH);\n+                thumbnailHeight = ifd2.getTagValueAsInt(TAG_IMAGE_HEIGHT);\n+                thumbnailPos = 0;\n+                thumbnailLength = data.length - 6;\n+                isThumbnailJPEG = false;\n+            }\n+        }\n+    }\n+\n+    LocalDateTime getImageCreationTime() {\n+        LocalDateTime imageCreationTime = null;\n+\n+        if (!imageFileDirectories.isEmpty()) {\n+            ImageFileDirectory ifd = imageFileDirectories.get(0);\n+            int dateTimeOffset = ifd.getTagValueAsInt(TAG_DATE_TIME);\n+            if (dateTimeOffset != NO_VALUE) {\n+                try {\n+                    String dateTime = new String(data, dateTimeOffset + 6, 19, StandardCharsets.US_ASCII);\n+                    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"uuuu:MM:dd HH:mm:ss\");\n+                    imageCreationTime = LocalDateTime.parse(dateTime, formatter);\n+                } catch(Exception e) {\n+                    \/\/ intentionally empty\n+                }\n+            }\n+        }\n+\n+        return imageCreationTime;\n+    }\n+\n+    @Override\n+    void print() {\n+        printTag(\"Exif APP1\");\n+        for (int a = 0; a < imageFileDirectories.size(); a++) {\n+            System.out.println(\"ImageFileDirectory #\" + a + \", offset = \" + firstIFDOffset);\n+            int entryCtr = 0;\n+            for (ImageFileDirectory.Entry entry : imageFileDirectories.get(a).entriesByTag.values()) {\n+                System.out.println(\"Entry #\" + (entryCtr++) + \": \" + entry.toString());\n+            }\n+            System.out.println(\"next directory: \" + imageFileDirectories.get(a).nextIFD);\n+        }\n+    }\n+\n+    int getNumThumbnails() {\n+        return thumbnailPos >= 0 && thumbnailLength > 0 ? 1 : 0;\n+    }\n+\n+    int getThumbnailWidth() throws IOException {\n+        \/\/ this should only be called if there is a thumbnail\n+\n+        if (thumbnailWidth == -1) {\n+            populateJPEGThumbnailDimensions();\n+        }\n+        return thumbnailWidth;\n+    }\n+\n+    int getThumbnailHeight() throws IOException {\n+        \/\/ this should only be called if there is a thumbnail\n+\n+        if (thumbnailHeight == -1) {\n+            populateJPEGThumbnailDimensions();\n+        }\n+        return thumbnailHeight;\n+    }\n+\n+    \/**\n+     * Use a JPEGImageReader to identify the size of the thumbnail. This\n+     * populates the `thumbnailWidth` and `thumbnailHeight` fields.\n+     *\/\n+    private void populateJPEGThumbnailDimensions() throws IOException {\n+        \/\/ this method will never be invoked for TIFF thumbnails, because TIFF\n+        \/\/ thumbnails clearly define their thumbnail size via IFD entries.\n+        JPEGImageReader reader = new JPEGImageReader(null);\n+        try {\n+            reader.setInput(ImageIO.createImageInputStream(new ByteArrayInputStream(\n+                    data, thumbnailPos + 6, thumbnailLength)));\n+            thumbnailWidth = reader.getWidth(0);\n+            thumbnailHeight = reader.getHeight(0);\n+        } finally {\n+            reader.dispose();\n+        }\n+    }\n+\n+    BufferedImage getThumbnail(JPEGImageReader callbackReader) throws IOException {\n+        \/\/ this should only be called if there is a thumbnail\n+\n+        callbackReader.thumbnailStarted(0);\n+        ImageReader thumbReader;\n+        int imageIndex = 0;\n+        if (isThumbnailJPEG) {\n+            thumbReader = new JPEGImageReader(null);\n+            imageIndex = 0;\n+        } else {\n+            thumbReader = new TIFFImageReader(null);\n+            imageIndex = 1;\n+        }\n+        try {\n+            InputStream byteIn = new ByteArrayInputStream(data, thumbnailPos + 6, thumbnailLength);\n+            ImageInputStream input = new MemoryCacheImageInputStream(byteIn);\n+            thumbReader.setInput(input);\n+            thumbReader.addIIOReadProgressListener(new JFIFMarkerSegment.JFIFThumbJPEG.ThumbnailReadListener(callbackReader));\n+            BufferedImage thumbnailImage = thumbReader.read(imageIndex);\n+            thumbnailWidth = thumbnailImage.getWidth();\n+            thumbnailHeight = thumbnailImage.getHeight();\n+            callbackReader.thumbnailComplete();\n+            return thumbnailImage;\n+        } finally {\n+            thumbReader.dispose();\n+        }\n+    }\n+}\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/ExifMarkerSegment.java","additions":294,"deletions":0,"binary":false,"changes":294,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1237,1 +1237,1 @@\n-        private static class ThumbnailReadListener\n+        static class ThumbnailReadListener\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JFIFMarkerSegment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1639,0 +1639,7 @@\n+    private int getNumJFIFThumbnails(JFIFMarkerSegment jfif) throws IOException {\n+        if (jfif == null) {\n+            return 0;\n+        }\n+        return ((jfif.thumb == null) ? 0 : 1) + jfif.extSegments.size();\n+    }\n+\n@@ -1646,1 +1653,2 @@\n-            \/\/ Now check the jfif segments\n+\n+            \/\/ Check the jfif segments\n@@ -1648,6 +1656,10 @@\n-                (JFIFMarkerSegment) imageMetadata.findMarkerSegment\n-                (JFIFMarkerSegment.class, true);\n-            int retval = 0;\n-            if (jfif != null) {\n-                retval = (jfif.thumb == null) ? 0 : 1;\n-                retval += jfif.extSegments.size();\n+                    (JFIFMarkerSegment) imageMetadata.findMarkerSegment\n+                            (JFIFMarkerSegment.class, true);\n+            int numThumbnails = getNumJFIFThumbnails(jfif);\n+\n+            \/\/ Check the Exif segment\n+            ExifMarkerSegment exifMarkerSegment =\n+                    (ExifMarkerSegment) imageMetadata.findMarkerSegment\n+                            (ExifMarkerSegment.class, true);\n+            if (exifMarkerSegment != null) {\n+                numThumbnails += exifMarkerSegment.getNumThumbnails();\n@@ -1655,1 +1667,2 @@\n-            return retval;\n+\n+            return numThumbnails;\n@@ -1672,1 +1685,2 @@\n-            \/\/ Now we know that there is a jfif segment\n+\n+            \/\/ Check the JFIF segment\n@@ -1676,1 +1690,11 @@\n-            return  jfif.getThumbnailWidth(thumbnailIndex);\n+\n+            int numJFIFThumbnails = getNumJFIFThumbnails(jfif);\n+            if (thumbnailIndex < numJFIFThumbnails) {\n+                return jfif.getThumbnailWidth(thumbnailIndex);\n+            }\n+\n+            \/\/ Check the Exif segment\n+            ExifMarkerSegment exifMarkerSegment =\n+                    (ExifMarkerSegment) imageMetadata.findMarkerSegment\n+                            (ExifMarkerSegment.class, true);\n+            return exifMarkerSegment.getThumbnailWidth();\n@@ -1693,1 +1717,2 @@\n-            \/\/ Now we know that there is a jfif segment\n+\n+            \/\/ Check the JFIF segment\n@@ -1695,3 +1720,13 @@\n-                (JFIFMarkerSegment) imageMetadata.findMarkerSegment\n-                (JFIFMarkerSegment.class, true);\n-            return  jfif.getThumbnailHeight(thumbnailIndex);\n+                    (JFIFMarkerSegment) imageMetadata.findMarkerSegment\n+                            (JFIFMarkerSegment.class, true);\n+\n+            int numJFIFThumbnails = getNumJFIFThumbnails(jfif);\n+            if (thumbnailIndex < numJFIFThumbnails) {\n+                return jfif.getThumbnailHeight(thumbnailIndex);\n+            }\n+\n+            \/\/ Check the Exif segment\n+            ExifMarkerSegment exifMarkerSegment =\n+                    (ExifMarkerSegment) imageMetadata.findMarkerSegment\n+                            (ExifMarkerSegment.class, true);\n+            return exifMarkerSegment.getThumbnailHeight();\n@@ -1715,1 +1750,2 @@\n-            \/\/ Now we know that there is a jfif segment and that iis is good\n+\n+            \/\/ Check the JFIF segment\n@@ -1717,3 +1753,12 @@\n-                (JFIFMarkerSegment) imageMetadata.findMarkerSegment\n-                (JFIFMarkerSegment.class, true);\n-            return  jfif.getThumbnail(iis, thumbnailIndex, this);\n+                    (JFIFMarkerSegment) imageMetadata.findMarkerSegment\n+                            (JFIFMarkerSegment.class, true);\n+            int numJFIFThumbnails = getNumJFIFThumbnails(jfif);\n+            if (thumbnailIndex < numJFIFThumbnails) {\n+                return jfif.getThumbnail(iis, thumbnailIndex, this);\n+            }\n+\n+            \/\/ Check the Exif segment\n+            ExifMarkerSegment exifMarkerSegment =\n+                    (ExifMarkerSegment) imageMetadata.findMarkerSegment\n+                            (ExifMarkerSegment.class, true);\n+            return exifMarkerSegment.getThumbnail(this);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JPEGImageReader.java","additions":64,"deletions":19,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.time.LocalDateTime;\n@@ -255,0 +256,18 @@\n+            case JPEG.APP1:\n+                newGuy = new MarkerSegment(buffer);\n+                newGuy.loadData(buffer);\n+\n+                if (newGuy.data.length > 5 &&\n+                        newGuy.data[0] == 'E' &&\n+                        newGuy.data[1] == 'x' &&\n+                        newGuy.data[2] == 'i' &&\n+                        newGuy.data[3] == 'f' &&\n+                        newGuy.data[4] == 0) {\n+                    try {\n+                        newGuy = new ExifMarkerSegment(newGuy);\n+                    } catch(Exception e) {\n+                        \/\/ This is intentionally empty.\n+                        \/\/ Now we fallback to keeping the generic MarkerSegment\n+                    }\n+                }\n+                break;\n@@ -1010,0 +1029,29 @@\n+    @Override\n+    protected IIOMetadataNode getStandardDocumentNode() {\n+        IIOMetadataNode doc = null;\n+\n+        ExifMarkerSegment exifMarkerSegment =\n+                (ExifMarkerSegment) findMarkerSegment\n+                        (ExifMarkerSegment.class, true);\n+\n+        if (exifMarkerSegment != null) {\n+            \/\/ If there is an Exif marker segment get the image creation time.\n+            LocalDateTime ict = exifMarkerSegment.getImageCreationTime();\n+            if (ict != null) {\n+                doc = new IIOMetadataNode(\"Document\");\n+                IIOMetadataNode dateTime = new IIOMetadataNode(\"ImageCreationTime\");\n+                dateTime.setAttribute(\"year\", String.valueOf(ict.getYear()));\n+                dateTime.setAttribute(\"month\", String.valueOf(ict.getMonthValue()));\n+                dateTime.setAttribute(\"day\", String.valueOf(ict.getDayOfMonth()));\n+                dateTime.setAttribute(\"hour\", String.valueOf(ict.getHour()));\n+                dateTime.setAttribute(\"minute\", String.valueOf(ict.getMinute()));\n+                dateTime.setAttribute(\"second\", String.valueOf(ict.getSecond()));\n+                doc.appendChild(dateTime);\n+            }\n+        } else {\n+            doc = super.getStandardDocumentNode();\n+        }\n+\n+        return doc;\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JPEGMetadata.java","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,289 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8160327\n+ * @summary Test verifies thumbnails are read from sample JPEG images\n+ *          that are encoded using Exif file format.\n+ * @run     main JpegExifThumbnailTest\n+ *\/\n+\n+\n+import org.w3c.dom.Node;\n+\n+import java.awt.Dimension;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageReader;\n+import javax.imageio.event.IIOReadProgressListener;\n+import javax.imageio.metadata.IIOMetadata;\n+import javax.imageio.metadata.IIOMetadataFormatImpl;\n+import javax.imageio.stream.ImageInputStream;\n+\n+public class JpegExifThumbnailTest {\n+\n+    private static void assertBoolean(boolean b, String errorMsg) {\n+        if (!b) {\n+            throw new Error(errorMsg);\n+        }\n+    }\n+\n+    private static void assertEquals(int expected, int observed) {\n+        if (expected != observed) {\n+            throw new Error(\"expected \" + expected + \", but observed \" + observed);\n+        }\n+    }\n+\n+    private static void assertEquals(Node node, String attributeName, int expectedAttributeValue) {\n+        String s = node.getAttributes().getNamedItem(attributeName).getNodeValue();\n+        if (!Integer.toString(expectedAttributeValue).equals(s))\n+            throw new Error(\"expected \\\"\" + attributeName + \"\\\" to be \" + expectedAttributeValue + \", but observed \" + s);\n+    }\n+\n+    static class MyListener implements IIOReadProgressListener {\n+\n+        boolean thumbnailStarted = false;\n+        boolean thumbnailCompleted = false;\n+        float thumbnailPercent = -1;\n+\n+        @Override\n+        public void sequenceStarted(ImageReader source, int minIndex) {\n+            throw new Error(\"sequenceStarted should not be called\");\n+        }\n+\n+        @Override\n+        public void sequenceComplete(ImageReader source) {\n+            throw new Error(\"sequenceComplete should not be called\");\n+        }\n+\n+        @Override\n+        public void imageStarted(ImageReader source, int imageIndex) {\n+            throw new Error(\"imageStarted should not be called\");\n+        }\n+\n+        @Override\n+        public void imageProgress(ImageReader source, float percentageDone) {\n+            throw new Error(\"imageProgress should not be called\");\n+        }\n+\n+        @Override\n+        public void imageComplete(ImageReader source) {\n+            throw new Error(\"imageComplete should not be called\");\n+        }\n+\n+        @Override\n+        public void thumbnailStarted(ImageReader source, int imageIndex, int thumbnailIndex) {\n+            if (thumbnailStarted || thumbnailCompleted || thumbnailPercent >= 0)\n+                throw new Error();\n+            thumbnailStarted = true;\n+        }\n+\n+        @Override\n+        public void thumbnailProgress(ImageReader source, float percentageDone) {\n+            if (!thumbnailStarted || thumbnailCompleted || thumbnailPercent >= percentageDone)\n+                throw new Error();\n+            thumbnailPercent = percentageDone;\n+        }\n+\n+        @Override\n+        public void thumbnailComplete(ImageReader source) {\n+            if (!thumbnailStarted || thumbnailCompleted)\n+                throw new Error();\n+            thumbnailCompleted = true;\n+        }\n+\n+        @Override\n+        public void readAborted(ImageReader source) {\n+            throw new Error(\"readAborted should not be called\");\n+        }\n+    }\n+\n+    public static void main (String[] args) throws IOException {\n+        \/\/ all the timestamps were verified in a 3rd party app (such as Preview on Mac)\n+\n+        \/\/ this is little endian, and uses a compression type 0x00000006\n+        new JpegExifThumbnailTest(\"SV650.jpg\",\n+                2015,6,24,10,3,55,\n+                new Dimension(160, 120)).run();\n+\n+        \/\/ this is big endian, and uses a compression type 0x00010000\n+        new JpegExifThumbnailTest(\"exif-rgb-thumbnail-sony-d700.jpg\",\n+                1998,12,1,14,22,36,\n+                new Dimension(80, 60)).run();\n+\n+        \/\/ This includes a JFIF thumbnail and an EXIF thumbnail.\n+        new JpegExifThumbnailTest(\"jfif_and_exif.jpg\",\n+                2025,2,21,1,14,51,\n+                new Dimension(150, 200),\n+                new Dimension(120, 160)).run();\n+\n+        \/\/ this includes Exif data, but the `compression` tag is 0x60000 instead of 0x6,\n+        \/\/ also it doesn't include any date\n+        new JpegExifThumbnailTest(\"plastic-wrap.jpg\",\n+                -1, -1, -1, -1, -1, -1,\n+                new Dimension(200, 132)).run();\n+\n+        \/\/ here the timestamp doesn't match our parser, so we'll ignore it\n+        new JpegExifThumbnailTest(\"bad-timestamp.jpg\",\n+                -1, -1, -1, -1, -1, -1).run();\n+\n+        \/\/ this ImageFileDirectory doesn't terminate like it should. We need to\n+        \/\/ not fail with an EOFException in this case:\n+        new JpegExifThumbnailTest(\"unusual-ImageFileDirectory.jpeg\",\n+                2007, 11, 10, 21, 23, 4).run();\n+\n+        \/\/ This file is a replica of SV650.jpg, except the 14th byte was changed\n+        \/\/ so ExifMarkerSegment's constructor throws a \"Bad magic number\" exception.\n+        \/\/ The expected behavior here is: we do NOT catch an exception, because internally\n+        \/\/ JPEGMetaData just recorded a generic MarkerSegment instead of an ExifMarkerSegment\n+        new JpegExifThumbnailTest(\"corrupt-magic-number.jpg\",\n+                -1, -1, -1, -1, -1, -1).run();\n+\n+        \/\/ This file is set up so ImageFileDirectory X points to Y,\n+        \/\/ then Y points back to X. An early draft of the ExifMarkerSegment\n+        \/\/ class would get stuck parsing this loop. (After a few minutes this\n+        \/\/ would probably fail with an OutOfMemoryError as the list of IFDs\n+        \/\/ grew too large.)\n+        \/\/ The expected behavior here is to stop after reading 2 IFDs, and\n+        \/\/ otherwise read the JPEG as usual\n+        new JpegExifThumbnailTest(\"malicious_looping_IFD.jpg\",\n+                2025, 2, 16, 15, 48, 34,\n+                new Dimension(60, 80)).run();\n+    }\n+\n+    final String filename;\n+    final Dimension[] thumbnailSizes;\n+    final int year, month, day, hour, minute, second;\n+\n+    JpegExifThumbnailTest(String filename,\n+                          int year, int month, int day,\n+                          int hour, int minute, int second,\n+                          Dimension... thumbnailSizes) {\n+        this.filename = filename;\n+        this.thumbnailSizes = thumbnailSizes;\n+        this.year = year;\n+        this.month = month;\n+        this.day = day;\n+        this.hour = hour;\n+        this.minute = minute;\n+        this.second = second;\n+    }\n+\n+    public void run() throws IOException {\n+        String sep = System.getProperty(\"file.separator\");\n+        String dir = System.getProperty(\"test.src\", \".\");\n+        String filePath = dir+sep+filename;\n+        File file = new File(filePath);\n+\n+        if (!file.exists())\n+            throw new IOException(\"missing test file: \" + file.getPath());\n+        System.out.println(\"Testing \" + file.getPath());\n+\n+        ImageReader reader = getJPEGImageReader();\n+        ImageInputStream stream = ImageIO.createImageInputStream(file);\n+        reader.setInput(stream);\n+\n+        int thumbnailCount = reader.getNumThumbnails(0);\n+        if (thumbnailCount != thumbnailSizes.length)\n+            throw new Error(\"expected \" + thumbnailSizes.length + \" thumbnails, but observed \" + thumbnailCount);\n+\n+        for (int a = 0; a < thumbnailSizes.length; a++) {\n+            MyListener listener = new MyListener();\n+            reader.addIIOReadProgressListener(listener);\n+            try {\n+                int w = reader.getThumbnailWidth(0, a);\n+                int h = reader.getThumbnailHeight(0, a);\n+                System.out.println(\"\\tthumbnail: \" + w + \"x\" + h);\n+                assertEquals(thumbnailSizes[a].width, w);\n+                assertEquals(thumbnailSizes[a].height, h);\n+\n+                BufferedImage bi = reader.readThumbnail(0, a);\n+                assertEquals(thumbnailSizes[a].width, bi.getWidth());\n+                assertEquals(thumbnailSizes[a].height, bi.getHeight());\n+\n+                assertBoolean(listener.thumbnailStarted, \"the IIOReadProgressListener was not notified that the thumbnail started\");\n+                assertBoolean(listener.thumbnailCompleted, \"the IIOReadProgressListener was not notified that the thumbnail completed\");\n+            } finally {\n+                reader.removeIIOReadProgressListener(listener);\n+            }\n+        }\n+\n+        IIOMetadata metadata = reader.getImageMetadata(0);\n+        Node root = metadata.getAsTree(IIOMetadataFormatImpl.standardMetadataFormatName);\n+        Node docNode = findChild(root, \"Document\");\n+        Node timeNode = findChild(docNode, \"ImageCreationTime\");\n+\n+        if (timeNode == null) {\n+            \/\/ this is OK, it means there's no ImageCreationTime\n+            assertEquals(-1, year);\n+            assertEquals(-1, month);\n+            assertEquals(-1, day);\n+            assertEquals(-1, hour);\n+            assertEquals(-1, minute);\n+            assertEquals(-1, second);\n+        } else {\n+            StringBuilder sb = new StringBuilder();\n+            for (int b = 0; b < timeNode.getAttributes().getLength(); b++) {\n+                sb.append(timeNode.getAttributes().item(b).getNodeName() + \"=\" +\n+                        timeNode.getAttributes().item(b).getNodeValue() + \" \");\n+            }\n+            System.out.println(\"\\tImageCreationTime: \" + sb.toString().trim());\n+\n+            assertEquals(timeNode, \"year\", year);\n+            assertEquals(timeNode, \"month\", month);\n+            assertEquals(timeNode, \"day\", day);\n+            assertEquals(timeNode, \"hour\", hour);\n+            assertEquals(timeNode, \"minute\", minute);\n+            assertEquals(timeNode, \"second\", second);\n+        }\n+    }\n+\n+    private static Node findChild(Node node, String nodeName) {\n+        if (node == null) {\n+            return null;\n+        }\n+        Node child = node.getFirstChild();\n+        while (child != null) {\n+            if (child.getNodeName().equals(nodeName))\n+                return child;\n+            child = child.getNextSibling();\n+        }\n+        return null;\n+    }\n+\n+    private static ImageReader getJPEGImageReader() {\n+        Iterator<ImageReader> readers = ImageIO.getImageReadersByFormatName(\"jpeg\");\n+        ImageReader reader;\n+        while(readers.hasNext()) {\n+            reader = readers.next();\n+            if(reader.canReadRaster()) {\n+                return reader;\n+            }\n+        }\n+        return null;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/javax\/imageio\/plugins\/jpeg\/JpegExifThumbnail\/JpegExifThumbnailTest.java","additions":289,"deletions":0,"binary":false,"changes":289,"status":"added"},{"filename":"test\/jdk\/javax\/imageio\/plugins\/jpeg\/JpegExifThumbnail\/SV650.jpg","binary":true,"status":"added"},{"filename":"test\/jdk\/javax\/imageio\/plugins\/jpeg\/JpegExifThumbnail\/bad-timestamp.jpg","binary":true,"status":"added"},{"filename":"test\/jdk\/javax\/imageio\/plugins\/jpeg\/JpegExifThumbnail\/corrupt-magic-number.jpg","binary":true,"status":"added"},{"filename":"test\/jdk\/javax\/imageio\/plugins\/jpeg\/JpegExifThumbnail\/exif-rgb-thumbnail-sony-d700.jpg","binary":true,"status":"added"},{"filename":"test\/jdk\/javax\/imageio\/plugins\/jpeg\/JpegExifThumbnail\/jfif_and_exif.jpg","binary":true,"status":"added"},{"filename":"test\/jdk\/javax\/imageio\/plugins\/jpeg\/JpegExifThumbnail\/malicious_looping_IFD.jpg","binary":true,"status":"added"},{"filename":"test\/jdk\/javax\/imageio\/plugins\/jpeg\/JpegExifThumbnail\/plastic-wrap.jpg","binary":true,"status":"added"},{"filename":"test\/jdk\/javax\/imageio\/plugins\/jpeg\/JpegExifThumbnail\/unusual-ImageFileDirectory.jpeg","binary":true,"status":"added"}]}