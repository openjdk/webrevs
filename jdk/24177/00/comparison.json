{"files":[{"patch":"@@ -76,3 +76,0 @@\n-  \/\/ reads a request from the given connected socket\n-  static AixAttachOperation* read_request(int s);\n-\n@@ -80,6 +77,0 @@\n-  enum {\n-    ATTACH_PROTOCOL_VER = 1                     \/\/ protocol version\n-  };\n-  enum {\n-    ATTACH_ERROR_BADVERSION     = 101           \/\/ error codes\n-  };\n@@ -110,3 +101,0 @@\n-  \/\/ write the given buffer to a socket\n-  static int write_fully(int s, char* buf, size_t len);\n-\n@@ -116,0 +104,39 @@\n+class SocketChannel : public AttachOperation::RequestReader, public AttachOperation::ReplyWriter {\n+private:\n+  int _socket;\n+public:\n+  SocketChannel(int socket) : _socket(socket) {}\n+  ~SocketChannel() {\n+    close();\n+  }\n+\n+  bool opened() const {\n+    return _socket != -1;\n+  }\n+\n+  void close() {\n+    if (opened()) {\n+      ::shutdown(_socket, 2);\n+      ::close(_socket);\n+      _socket = -1;\n+    }\n+  }\n+\n+  \/\/ RequestReader\n+  int read(void* buffer, int size) override {\n+    ssize_t n;\n+    RESTARTABLE(::read(_socket, buffer, (size_t)size), n);\n+    return checked_cast<int>(n);\n+  }\n+\n+  \/\/ ReplyWriter\n+  int write(const void* buffer, int size) override {\n+    ssize_t n;\n+    RESTARTABLE(::write(_socket, buffer, size), n);\n+    return checked_cast<int>(n);\n+  }\n+\n+  void flush() override {\n+  }\n+};\n+\n@@ -119,1 +146,1 @@\n-  int _socket;\n+  SocketChannel _socket_channel;\n@@ -122,1 +149,1 @@\n-  void complete(jint res, bufferedStream* st);\n+  AixAttachOperation(int socket) : AttachOperation(), _socket_channel(socket) {}\n@@ -124,2 +151,1 @@\n-  void set_socket(int s)                                { _socket = s; }\n-  int socket() const                                    { return _socket; }\n+  void complete(jint res, bufferedStream* st) override;\n@@ -127,2 +153,6 @@\n-  AixAttachOperation(char* name) : AttachOperation(name) {\n-    set_socket(-1);\n+  ReplyWriter* get_reply_writer() override {\n+    return &_socket_channel;\n+  }\n+\n+  bool read_request() {\n+    return _socket_channel.read_request(this, &_socket_channel);\n@@ -140,28 +170,0 @@\n-\/\/ Supporting class to help split a buffer into individual components\n-class ArgumentIterator : public StackObj {\n- private:\n-  char* _pos;\n-  char* _end;\n- public:\n-  ArgumentIterator(char* arg_buffer, size_t arg_size) {\n-    _pos = arg_buffer;\n-    _end = _pos + arg_size - 1;\n-  }\n-  char* next() {\n-    if (*_pos == '\\0') {\n-      \/\/ advance the iterator if possible (null arguments)\n-      if (_pos < _end) {\n-        _pos += 1;\n-      }\n-      return nullptr;\n-    }\n-    char* res = _pos;\n-    char* next_pos = strchr(_pos, '\\0');\n-    if (next_pos < _end)  {\n-      next_pos++;\n-    }\n-    _pos = next_pos;\n-    return res;\n-  }\n-};\n-\n@@ -261,100 +263,0 @@\n-\/\/ Given a socket that is connected to a peer we read the request and\n-\/\/ create an AttachOperation. As the socket is blocking there is potential\n-\/\/ for a denial-of-service if the peer does not response. However this happens\n-\/\/ after the peer credentials have been checked and in the worst case it just\n-\/\/ means that the attach listener thread is blocked.\n-\/\/\n-AixAttachOperation* AixAttachListener::read_request(int s) {\n-  char ver_str[8];\n-  os::snprintf_checked(ver_str, sizeof(ver_str), \"%d\", ATTACH_PROTOCOL_VER);\n-\n-  \/\/ The request is a sequence of strings so we first figure out the\n-  \/\/ expected count and the maximum possible length of the request.\n-  \/\/ The request is:\n-  \/\/   <ver>0<cmd>0<arg>0<arg>0<arg>0\n-  \/\/ where <ver> is the protocol version (1), <cmd> is the command\n-  \/\/ name (\"load\", \"datadump\", ...), and <arg> is an argument\n-  int expected_str_count = 2 + AttachOperation::arg_count_max;\n-  const size_t max_len = (sizeof(ver_str) + 1) + (AttachOperation::name_length_max + 1) +\n-    AttachOperation::arg_count_max*(AttachOperation::arg_length_max + 1);\n-\n-  char buf[max_len];\n-  int str_count = 0;\n-\n-  \/\/ Read until all (expected) strings have been read, the buffer is\n-  \/\/ full, or EOF.\n-\n-  size_t off = 0;\n-  size_t left = max_len;\n-\n-  do {\n-    ssize_t n;\n-    \/\/ Don't block on interrupts because this will\n-    \/\/ hang in the clean-up when shutting down.\n-    n = read(s, buf+off, left);\n-    assert(n <= checked_cast<ssize_t>(left), \"buffer was too small, impossible!\");\n-    buf[max_len - 1] = '\\0';\n-    if (n == -1) {\n-      return nullptr;      \/\/ reset by peer or other error\n-    }\n-    if (n == 0) {\n-      break;\n-    }\n-    for (int i=0; i<n; i++) {\n-      if (buf[off+i] == 0) {\n-        \/\/ EOS found\n-        str_count++;\n-\n-        \/\/ The first string is <ver> so check it now to\n-        \/\/ check for protocol mismatch\n-        if (str_count == 1) {\n-          if ((strlen(buf) != strlen(ver_str)) ||\n-              (atoi(buf) != ATTACH_PROTOCOL_VER)) {\n-            char msg[32];\n-            os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", ATTACH_ERROR_BADVERSION);\n-            write_fully(s, msg, strlen(msg));\n-            return nullptr;\n-          }\n-        }\n-      }\n-    }\n-    off += n;\n-    left -= n;\n-  } while (left > 0 && str_count < expected_str_count);\n-\n-  if (str_count != expected_str_count) {\n-    return nullptr;        \/\/ incomplete request\n-  }\n-\n-  \/\/ parse request\n-\n-  ArgumentIterator args(buf, (max_len)-left);\n-\n-  \/\/ version already checked\n-  char* v = args.next();\n-\n-  char* name = args.next();\n-  if (name == nullptr || strlen(name) > AttachOperation::name_length_max) {\n-    return nullptr;\n-  }\n-\n-  AixAttachOperation* op = new AixAttachOperation(name);\n-\n-  for (int i=0; i<AttachOperation::arg_count_max; i++) {\n-    char* arg = args.next();\n-    if (arg == nullptr) {\n-      op->set_arg(i, nullptr);\n-    } else {\n-      if (strlen(arg) > AttachOperation::arg_length_max) {\n-        delete op;\n-        return nullptr;\n-      }\n-      op->set_arg(i, arg);\n-    }\n-  }\n-\n-  op->set_socket(s);\n-  return op;\n-}\n-\n-\n@@ -405,3 +307,3 @@\n-    AixAttachOperation* op = read_request(s);\n-    if (op == nullptr) {\n-      ::close(s);\n+    AixAttachOperation* op = new AixAttachOperation(s);\n+    if (!op->read_request()) {\n+      delete op;\n@@ -415,15 +317,0 @@\n-\/\/ write the given buffer to the socket\n-int AixAttachListener::write_fully(int s, char* buf, size_t len) {\n-  do {\n-    ssize_t n = ::write(s, buf, len);\n-    if (n == -1) {\n-      if (errno != EINTR) return -1;\n-    } else {\n-      buf += n;\n-      len -= n;\n-    }\n-  }\n-  while (len > 0);\n-  return 0;\n-}\n-\n@@ -439,18 +326,0 @@\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n-\n-  \/\/ write operation result\n-  char msg[32];\n-  os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", result);\n-  int rc = AixAttachListener::write_fully(this->socket(), msg, strlen(msg));\n-\n-  \/\/ write any result data\n-  if (rc == 0) {\n-    \/\/ Shutdown the socket in the cleanup function to enable more than\n-    \/\/ one agent attach in a sequence (see comments to listener_cleanup()).\n-    AixAttachListener::write_fully(this->socket(), (char*) st->base(), st->size());\n-  }\n-\n-  \/\/ done\n-  ::close(this->socket());\n-\n@@ -496,0 +365,1 @@\n+  AttachListener::set_supported_version(ATTACH_API_V2);\n","filename":"src\/hotspot\/os\/aix\/attachListener_aix.cpp","additions":52,"deletions":182,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    private OperationProperties props = new OperationProperties(VERSION_1);\n@@ -113,5 +114,12 @@\n-        int s = socket();\n-        try {\n-            connect(s, socket_path);\n-        } finally {\n-            close(s);\n+        if (isAPIv2Enabled()) {\n+             props = getDefaultProps();\n+         } else {\n+             \/\/ Check that we can connect to the process\n+             \/\/ - this ensures we throw the permission denied error now rather than\n+             \/\/ later when we attempt to enqueue a command.\n+             int s = socket();\n+             try {\n+                 connect(s, socket_path);\n+             } finally {\n+                 close(s);\n+             }\n@@ -132,3 +140,0 @@\n-    \/\/ protocol version\n-    private static final String PROTOCOL_VERSION = \"1\";\n-\n@@ -139,1 +144,0 @@\n-        assert args.length <= 3;                \/\/ includes null\n@@ -165,10 +169,2 @@\n-            writeString(s, PROTOCOL_VERSION);\n-            writeString(s, cmd);\n-\n-            for (int i = 0; i < 3; i++) {\n-                if (i < args.length && args[i] != null) {\n-                    writeString(s, (String)args[i]);\n-                } else {\n-                    writeString(s, \"\");\n-                }\n-            }\n+            SocketOutputStream writer = new SocketOutputStream(s);\n+            writeCommand(writer, props, cmd, args);\n@@ -190,0 +186,11 @@\n+    private static class SocketOutputStream implements AttachOutputStream {\n+         private int fd;\n+         public SocketOutputStream(int fd) {\n+             this.fd = fd;\n+         }\n+         @Override\n+         public void write(byte[] buffer, int offset, int length) throws IOException {\n+             VirtualMachineImpl.write(fd, buffer, offset, length);\n+         }\n+     }\n+\n@@ -226,15 +233,0 @@\n-    \/*\n-     * Write\/sends the given to the target VM. String is transmitted in\n-     * UTF-8 encoding.\n-     *\/\n-    private void writeString(int fd, String s) throws IOException {\n-        if (s.length() > 0) {\n-            byte[] b = s.getBytes(UTF_8);\n-            VirtualMachineImpl.write(fd, b, 0, b.length);\n-        }\n-        byte b[] = new byte[1];\n-        b[0] = 0;\n-        write(fd, b, 0, 1);\n-    }\n-\n-\n","filename":"src\/jdk.attach\/aix\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":26,"deletions":34,"binary":false,"changes":60,"status":"modified"}]}