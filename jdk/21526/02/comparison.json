{"files":[{"patch":"@@ -64,0 +64,7 @@\n+\n+    \/**\n+     * {@return whether this class entry describes the same class as the provided symbol}\n+     *\n+     * @param symbol the symbol to compare to\n+     *\/\n+    boolean equalsSymbol(ClassDesc symbol);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ClassEntry.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-                    && i.owner().asInternalName().equals(\"Foo\")\n+                    && i.owner().equalsSymbol(CD_Foo)\n@@ -310,1 +310,1 @@\n-                                                  if (e instanceof InvokeInstruction i && i.owner().asInternalName().equals(\"Foo\")\n+                                                  if (e instanceof InvokeInstruction i && i.owner().equalsSymbol(CD_Foo)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/snippet-files\/PackageSnippets.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -385,0 +385,32 @@\n+        \/**\n+         * Returns if this utf8 entry's content equals a substring\n+         * of {@code s} obtained as {@code s.substring(start, end - start)}.\n+         * This check avoids a substring allocation.\n+         *\/\n+        public boolean equalsRegion(String s, int start, int end) {\n+            \/\/ start and end values trusted\n+            if (state == State.RAW)\n+                inflate();\n+            int len = charLen;\n+            if (len != end - start)\n+                return false;\n+\n+            var sv = stringValue;\n+            if (sv != null) {\n+                return sv.regionMatches(0, s, start, len);\n+            }\n+\n+            var chars = this.chars;\n+            if (chars != null) {\n+                for (int i = 0; i < len; i++)\n+                    if (chars[i] != s.charAt(start + i))\n+                        return false;\n+            } else {\n+                var bytes = this.rawBytes;\n+                for (int i = 0; i < len; i++)\n+                    if (bytes[offset + i] != s.charAt(start + i))\n+                        return false;\n+            }\n+            return true;\n+        }\n+\n@@ -441,0 +473,12 @@\n+\n+        \/**\n+         * Compares this utf8's content with given\n+         * descriptor. Caches this descriptor if matches.\n+         *\/\n+        boolean equalsArrayClassDescriptor(ClassDesc sym) {\n+            if (equalsString(sym.descriptorString())) {\n+                typeSym = sym;\n+                return true;\n+            }\n+            return false;\n+        }\n@@ -549,0 +593,36 @@\n+        @Override\n+        public boolean equalsSymbol(ClassDesc symbol) {\n+            if (symbol.isPrimitive()) \/\/ implicit null check\n+                return false;\n+\n+            var mySym = this.sym;\n+            if (mySym != null)\n+                return mySym.equals(symbol);\n+\n+            \/\/ Note: for a ClassEntry read from bytes, it will not get a symbol until\n+            \/\/ it matches a ClassDesc. So the huge block below will be called multiple times.\n+            boolean equals;\n+            if (isArrayDescriptor(ref1)) {\n+                if (!symbol.isArray())\n+                    return false;\n+\n+                \/\/ fetch upstream symbol first\n+                if (ref1.typeSym instanceof ClassDesc upstreamSym) {\n+                    \/\/ skip the regular cache process; upstream symbol always reusable\n+                    this.sym = upstreamSym;\n+                    return upstreamSym.equals(symbol);\n+                }\n+\n+                equals = ref1.equalsArrayClassDescriptor(symbol); \/\/ ref1 caches compatible symbol\n+            } else {\n+                if (!symbol.isClassOrInterface())\n+                    return false;\n+                var desc = symbol.descriptorString();\n+                equals = ref1.equalsRegion(desc, 1, desc.length() - 1);\n+            }\n+\n+            if (equals)\n+                this.sym = symbol;\n+            return equals;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.constant.ConstantUtils;\n@@ -172,1 +173,1 @@\n-               && thisClass().asInternalName().equals(\"module-info\")\n+               && thisClass().equalsSymbol(ConstantUtils.CD_module_info)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-        else if ((flags & ClassFile.ACC_MODULE) == 0 && !\"java\/lang\/Object\".equals(thisClassEntry.asInternalName()))\n+        else if ((flags & ClassFile.ACC_MODULE) == 0 && !thisClassEntry.equalsSymbol(ConstantDescs.CD_Object))\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8304031 8338406 8338546\n+ * @bug 8304031 8338406 8338546 8342206\n@@ -33,0 +33,1 @@\n+import java.lang.classfile.constantpool.ClassEntry;\n@@ -45,0 +46,1 @@\n+import jdk.internal.classfile.impl.Util;\n@@ -49,0 +51,1 @@\n+import org.junit.jupiter.params.provider.Arguments;\n@@ -168,0 +171,45 @@\n+\n+    @Test\n+    void testClassEntryEqualsSymbolContract() {\n+        var cp = ConstantPoolBuilder.of();\n+        var ce = cp.classEntry(CD_Object);\n+        assertThrows(NullPointerException.class, () -> ce.equalsSymbol(null));\n+    }\n+\n+    static Stream<Arguments> equalsSymbolProvider() {\n+        var cp = ConstantPoolBuilder.of();\n+        return Stream.of(\n+                Arguments.of(true, cp.classEntry(CD_Object), CD_Object),\n+                Arguments.of(true, cp.classEntry(CD_Object.arrayType()), CD_Object.arrayType()),\n+                Arguments.of(true, cp.classEntry(cp.utf8Entry(CD_Object.arrayType())), CD_Object.arrayType()),\n+                Arguments.of(true, cp.classEntry(cp.utf8Entry(\"java\/lang\/Thread\")), ClassDesc.of(\"java.lang.Thread\")),\n+                Arguments.of(true, cp.classEntry(cp.utf8Entry(\"[[Ljava\/lang\/invoke\/MethodHandle;\")), ClassDesc.of(\"java.lang.invoke.MethodHandle\").arrayType(2)),\n+                Arguments.of(false, cp.classEntry(CD_Object), CD_String),\n+                Arguments.of(false, cp.classEntry(cp.utf8Entry(\"\")), CD_Object),\n+                Arguments.of(false, cp.classEntry(cp.utf8Entry(\"&*$#@;;))\")), CD_String),\n+                Arguments.of(false, cp.classEntry(cp.utf8Entry(\"[&*$#@;;))\")), CD_String.arrayType()),\n+                Arguments.of(false, cp.classEntry(CD_Object.arrayType()), CD_String.arrayType()),\n+                Arguments.of(false, cp.classEntry(cp.utf8Entry(\"Ljava\/lang\/Object;\")), CD_String.arrayType()),\n+                Arguments.of(false, cp.classEntry(cp.utf8Entry(\"java\/lang\/Object\")), CD_String.arrayType()),\n+                Arguments.of(false, cp.classEntry(cp.utf8Entry(\"Ljava\/lang\/Object;\")), CD_String),\n+                Arguments.of(false, cp.classEntry(CD_Object), CD_int)\n+        );\n+    }\n+\n+    @MethodSource(\"equalsSymbolProvider\")\n+    @ParameterizedTest\n+    void testClassEntryEqualsSymbolCase(boolean result, ClassEntry ce, ClassDesc cd) {\n+        boolean noCache = accessCachedClassDesc(ce) == null;\n+        assertEquals(result, ce.equalsSymbol(cd));\n+        if (noCache) {\n+            assertEquals(result, accessCachedClassDesc(ce) != null, () -> \"cache presence after test with result \" + result);\n+            if (result && cd.isArray()) {\n+                \/\/ Reuse cache from utf8\n+                assertSame(accessCachedClassDesc(ce), Util.fieldTypeSymbol(ce.name()));\n+            }\n+        }\n+    }\n+\n+    static ClassDesc accessCachedClassDesc(ClassEntry ce) {\n+        return ((AbstractPoolEntry.ClassEntryImpl) ce).sym;\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/ConstantDescSymbolsTest.java","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"}]}