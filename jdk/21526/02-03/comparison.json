{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -390,1 +391,1 @@\n-        public boolean equalsRegion(String s, int start, int end) {\n+        public boolean equalsArrayRegion(String s, int start, int end) {\n@@ -398,5 +399,0 @@\n-            var sv = stringValue;\n-            if (sv != null) {\n-                return sv.regionMatches(0, s, start, len);\n-            }\n-\n@@ -618,1 +614,1 @@\n-                if (!symbol.isClassOrInterface())\n+                if (!(symbol instanceof ClassOrInterfaceDescImpl classOrInterface))\n@@ -620,2 +616,22 @@\n-                var desc = symbol.descriptorString();\n-                equals = ref1.equalsRegion(desc, 1, desc.length() - 1);\n+\n+                \/\/ Check internal name first if possible\n+                var internalNameCache = classOrInterface.internalNameCache();\n+\n+                if (internalNameCache != null) {\n+                    \/\/ propagates compatible string representation\n+                    equals = ref1.equalsString(internalNameCache);\n+                } else {\n+                    var utf8StringCache = ref1.stringValue;\n+                    var desc = symbol.descriptorString();\n+                    if (utf8StringCache != null) {\n+                        equals = utf8StringCache.length() + 2 == desc.length() &&\n+                                desc.regionMatches(1, utf8StringCache, 0, utf8StringCache.length());\n+                        if (equals) {\n+                            \/\/ propagate compatible string representation\n+                            classOrInterface.propagateInternalName(utf8StringCache);\n+                        }\n+                    } else {\n+                        \/\/ both objects not initialized\n+                        equals = ref1.equalsArrayRegion(desc, 1, desc.length() - 1);\n+                    }\n+                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    private @Stable String internalName;\n+    private @Stable String cachedInternalName;\n@@ -63,0 +63,9 @@\n+    public String internalNameCache() {\n+        return this.cachedInternalName;\n+    }\n+\n+    public void propagateInternalName(String str) {\n+        assert dropFirstAndLastChar(descriptor).equals(str);\n+        this.cachedInternalName = str;\n+    }\n+\n@@ -64,1 +73,1 @@\n-        var internalName = this.internalName;\n+        var internalName = this.cachedInternalName;\n@@ -66,1 +75,1 @@\n-            this.internalName = internalName = dropFirstAndLastChar(descriptor);\n+            this.cachedInternalName = internalName = dropFirstAndLastChar(descriptor);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ClassOrInterfaceDescImpl.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -84,1 +84,3 @@\n-        return ClassOrInterfaceDescImpl.ofValidated(concat(\"L\", internalName, \";\"));\n+        var ret = ClassOrInterfaceDescImpl.ofValidated(concat(\"L\", internalName, \";\"));\n+        ret.propagateInternalName(internalName);\n+        return ret;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *          java.base\/jdk.internal.classfile.impl\n+ *          java.base\/jdk.internal.classfile.impl:+open\n@@ -35,0 +35,1 @@\n+import java.lang.classfile.constantpool.Utf8Entry;\n@@ -39,0 +40,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -47,0 +49,1 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -213,0 +216,77 @@\n+    @Test\n+    void testClassEntryEqualsSymbolCacheState() {\n+        var internalName = \"test\/MyClass\";\n+        var altInternalName = \"test\/YourClass\";\n+        var descriptorString = \"L\" + internalName + \";\";\n+        var altDescriptorString = \"L\" + altInternalName + \";\";\n+\n+        var bytes = ClassFile.of().build(ClassDesc.ofInternalName(internalName), _ -> {});\n+\n+        \/\/ 1. Both unexpanded\n+        \/\/ 1.1 matches\n+        {\n+            var cd = ClassDesc.ofDescriptor(descriptorString);\n+            var ce = ClassFile.of().parse(bytes).thisClass();\n+\n+            assertNull(accessCachedInternalName(cd));\n+            assertNull(accessCachedClassDesc(ce));\n+            assertNull(accessCachedString(ce.name()));\n+\n+            assertTrue(ce.equalsSymbol(cd));\n+\n+            assertNull(accessCachedInternalName(cd));\n+            assertSame(cd, accessCachedClassDesc(ce));\n+            assertNull(accessCachedString(ce.name()));\n+        }\n+        \/\/ 1.2 no match\n+        {\n+            var cd = ClassDesc.ofDescriptor(altDescriptorString);\n+            var ce = ClassFile.of().parse(bytes).thisClass();\n+\n+            assertNull(accessCachedInternalName(cd));\n+            assertNull(accessCachedClassDesc(ce));\n+            assertNull(accessCachedString(ce.name()));\n+\n+            assertFalse(ce.equalsSymbol(cd));\n+\n+            assertNull(accessCachedInternalName(cd));\n+            assertNull(accessCachedClassDesc(ce));\n+            assertNull(accessCachedString(ce.name()));\n+        }\n+\n+        \/\/ 2. ClassDesc expanded\n+        \/\/ 2.1 matches\n+        {\n+            var cd = ClassDesc.ofInternalName(internalName);\n+            var ce = ClassFile.of().parse(bytes).thisClass();\n+\n+            assertSame(internalName, accessCachedInternalName(cd));\n+            assertNull(accessCachedClassDesc(ce));\n+            assertNull(accessCachedString(ce.name()));\n+\n+            assertTrue(ce.equalsSymbol(cd));\n+\n+            assertSame(internalName, accessCachedInternalName(cd));\n+            assertSame(cd, accessCachedClassDesc(ce));\n+            assertSame(internalName, accessCachedString(ce.name()));\n+        }\n+        \/\/ 2.2 no match\n+        {\n+            var cd = ClassDesc.ofInternalName(altInternalName);\n+            var ce = ClassFile.of().parse(bytes).thisClass();\n+\n+            assertSame(altInternalName, accessCachedInternalName(cd));\n+            assertNull(accessCachedClassDesc(ce));\n+            assertNull(accessCachedString(ce.name()));\n+\n+            assertFalse(ce.equalsSymbol(cd));\n+\n+            assertSame(altInternalName, accessCachedInternalName(cd));\n+            assertNull(accessCachedClassDesc(ce));\n+            assertNull(accessCachedString(ce.name()));\n+        }\n+\n+        \/\/ We only push internal name in few scenarios, not tested yet\n+    }\n+\n+    \/\/ Support infrastructure\n@@ -216,0 +296,28 @@\n+\n+    static String accessCachedInternalName(ClassDesc cd) {\n+        return ((ClassOrInterfaceDescImpl) cd).internalNameCache();\n+    }\n+\n+    static String accessCachedString(Utf8Entry utf8) {\n+        var utf8Impl = (AbstractPoolEntry.Utf8EntryImpl) utf8;\n+        try {\n+            return (String) STRING_VALUE_GETTER.invokeExact(utf8Impl);\n+        } catch (Throwable e) {\n+            if (e instanceof Error er)\n+                throw er;\n+            throw (RuntimeException) e;\n+        }\n+    }\n+\n+    static final MethodHandle STRING_VALUE_GETTER;\n+\n+    static {\n+        MethodHandle getter;\n+        try {\n+            var lookup = MethodHandles.privateLookupIn(AbstractPoolEntry.Utf8EntryImpl.class, MethodHandles.lookup());\n+            getter = lookup.findGetter(AbstractPoolEntry.Utf8EntryImpl.class, \"stringValue\", String.class);\n+        } catch (IllegalAccessException | NoSuchFieldException ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+        STRING_VALUE_GETTER = getter;\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/ConstantDescSymbolsTest.java","additions":109,"deletions":1,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+    java.base\/jdk.internal.constant \\\n","filename":"test\/jdk\/jdk\/classfile\/TEST.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,3 +37,0 @@\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n-\n@@ -44,1 +41,0 @@\n-import jdk.internal.constant.ConstantUtils;\n","filename":"test\/jdk\/jdk\/classfile\/UtilTest.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}