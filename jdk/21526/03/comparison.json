{"files":[{"patch":"@@ -64,0 +64,7 @@\n+\n+    \/**\n+     * {@return whether this class entry describes the same class as the provided symbol}\n+     *\n+     * @param symbol the symbol to compare to\n+     *\/\n+    boolean equalsSymbol(ClassDesc symbol);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ClassEntry.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-                    && i.owner().asInternalName().equals(\"Foo\")\n+                    && i.owner().equalsSymbol(CD_Foo)\n@@ -310,1 +310,1 @@\n-                                                  if (e instanceof InvokeInstruction i && i.owner().asInternalName().equals(\"Foo\")\n+                                                  if (e instanceof InvokeInstruction i && i.owner().equalsSymbol(CD_Foo)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/snippet-files\/PackageSnippets.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -385,0 +386,27 @@\n+        \/**\n+         * Returns if this utf8 entry's content equals a substring\n+         * of {@code s} obtained as {@code s.substring(start, end - start)}.\n+         * This check avoids a substring allocation.\n+         *\/\n+        public boolean equalsArrayRegion(String s, int start, int end) {\n+            \/\/ start and end values trusted\n+            if (state == State.RAW)\n+                inflate();\n+            int len = charLen;\n+            if (len != end - start)\n+                return false;\n+\n+            var chars = this.chars;\n+            if (chars != null) {\n+                for (int i = 0; i < len; i++)\n+                    if (chars[i] != s.charAt(start + i))\n+                        return false;\n+            } else {\n+                var bytes = this.rawBytes;\n+                for (int i = 0; i < len; i++)\n+                    if (bytes[offset + i] != s.charAt(start + i))\n+                        return false;\n+            }\n+            return true;\n+        }\n+\n@@ -441,0 +469,12 @@\n+\n+        \/**\n+         * Compares this utf8's content with given\n+         * descriptor. Caches this descriptor if matches.\n+         *\/\n+        boolean equalsArrayClassDescriptor(ClassDesc sym) {\n+            if (equalsString(sym.descriptorString())) {\n+                typeSym = sym;\n+                return true;\n+            }\n+            return false;\n+        }\n@@ -549,0 +589,56 @@\n+        @Override\n+        public boolean equalsSymbol(ClassDesc symbol) {\n+            if (symbol.isPrimitive()) \/\/ implicit null check\n+                return false;\n+\n+            var mySym = this.sym;\n+            if (mySym != null)\n+                return mySym.equals(symbol);\n+\n+            \/\/ Note: for a ClassEntry read from bytes, it will not get a symbol until\n+            \/\/ it matches a ClassDesc. So the huge block below will be called multiple times.\n+            boolean equals;\n+            if (isArrayDescriptor(ref1)) {\n+                if (!symbol.isArray())\n+                    return false;\n+\n+                \/\/ fetch upstream symbol first\n+                if (ref1.typeSym instanceof ClassDesc upstreamSym) {\n+                    \/\/ skip the regular cache process; upstream symbol always reusable\n+                    this.sym = upstreamSym;\n+                    return upstreamSym.equals(symbol);\n+                }\n+\n+                equals = ref1.equalsArrayClassDescriptor(symbol); \/\/ ref1 caches compatible symbol\n+            } else {\n+                if (!(symbol instanceof ClassOrInterfaceDescImpl classOrInterface))\n+                    return false;\n+\n+                \/\/ Check internal name first if possible\n+                var internalNameCache = classOrInterface.internalNameCache();\n+\n+                if (internalNameCache != null) {\n+                    \/\/ propagates compatible string representation\n+                    equals = ref1.equalsString(internalNameCache);\n+                } else {\n+                    var utf8StringCache = ref1.stringValue;\n+                    var desc = symbol.descriptorString();\n+                    if (utf8StringCache != null) {\n+                        equals = utf8StringCache.length() + 2 == desc.length() &&\n+                                desc.regionMatches(1, utf8StringCache, 0, utf8StringCache.length());\n+                        if (equals) {\n+                            \/\/ propagate compatible string representation\n+                            classOrInterface.propagateInternalName(utf8StringCache);\n+                        }\n+                    } else {\n+                        \/\/ both objects not initialized\n+                        equals = ref1.equalsArrayRegion(desc, 1, desc.length() - 1);\n+                    }\n+                }\n+            }\n+\n+            if (equals)\n+                this.sym = symbol;\n+            return equals;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.constant.ConstantUtils;\n@@ -172,1 +173,1 @@\n-               && thisClass().asInternalName().equals(\"module-info\")\n+               && thisClass().equalsSymbol(ConstantUtils.CD_module_info)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-        else if ((flags & ClassFile.ACC_MODULE) == 0 && !\"java\/lang\/Object\".equals(thisClassEntry.asInternalName()))\n+        else if ((flags & ClassFile.ACC_MODULE) == 0 && !thisClassEntry.equalsSymbol(ConstantDescs.CD_Object))\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    private @Stable String internalName;\n+    private @Stable String cachedInternalName;\n@@ -63,0 +63,9 @@\n+    public String internalNameCache() {\n+        return this.cachedInternalName;\n+    }\n+\n+    public void propagateInternalName(String str) {\n+        assert dropFirstAndLastChar(descriptor).equals(str);\n+        this.cachedInternalName = str;\n+    }\n+\n@@ -64,1 +73,1 @@\n-        var internalName = this.internalName;\n+        var internalName = this.cachedInternalName;\n@@ -66,1 +75,1 @@\n-            this.internalName = internalName = dropFirstAndLastChar(descriptor);\n+            this.cachedInternalName = internalName = dropFirstAndLastChar(descriptor);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ClassOrInterfaceDescImpl.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -84,1 +84,3 @@\n-        return ClassOrInterfaceDescImpl.ofValidated(concat(\"L\", internalName, \";\"));\n+        var ret = ClassOrInterfaceDescImpl.ofValidated(concat(\"L\", internalName, \";\"));\n+        ret.propagateInternalName(internalName);\n+        return ret;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8304031 8338406 8338546\n+ * @bug 8304031 8338406 8338546 8342206\n@@ -29,1 +29,1 @@\n- *          java.base\/jdk.internal.classfile.impl\n+ *          java.base\/jdk.internal.classfile.impl:+open\n@@ -33,0 +33,1 @@\n+import java.lang.classfile.constantpool.ClassEntry;\n@@ -34,0 +35,1 @@\n+import java.lang.classfile.constantpool.Utf8Entry;\n@@ -38,0 +40,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -45,0 +48,2 @@\n+import jdk.internal.classfile.impl.Util;\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -49,0 +54,1 @@\n+import org.junit.jupiter.params.provider.Arguments;\n@@ -168,0 +174,150 @@\n+\n+    @Test\n+    void testClassEntryEqualsSymbolContract() {\n+        var cp = ConstantPoolBuilder.of();\n+        var ce = cp.classEntry(CD_Object);\n+        assertThrows(NullPointerException.class, () -> ce.equalsSymbol(null));\n+    }\n+\n+    static Stream<Arguments> equalsSymbolProvider() {\n+        var cp = ConstantPoolBuilder.of();\n+        return Stream.of(\n+                Arguments.of(true, cp.classEntry(CD_Object), CD_Object),\n+                Arguments.of(true, cp.classEntry(CD_Object.arrayType()), CD_Object.arrayType()),\n+                Arguments.of(true, cp.classEntry(cp.utf8Entry(CD_Object.arrayType())), CD_Object.arrayType()),\n+                Arguments.of(true, cp.classEntry(cp.utf8Entry(\"java\/lang\/Thread\")), ClassDesc.of(\"java.lang.Thread\")),\n+                Arguments.of(true, cp.classEntry(cp.utf8Entry(\"[[Ljava\/lang\/invoke\/MethodHandle;\")), ClassDesc.of(\"java.lang.invoke.MethodHandle\").arrayType(2)),\n+                Arguments.of(false, cp.classEntry(CD_Object), CD_String),\n+                Arguments.of(false, cp.classEntry(cp.utf8Entry(\"\")), CD_Object),\n+                Arguments.of(false, cp.classEntry(cp.utf8Entry(\"&*$#@;;))\")), CD_String),\n+                Arguments.of(false, cp.classEntry(cp.utf8Entry(\"[&*$#@;;))\")), CD_String.arrayType()),\n+                Arguments.of(false, cp.classEntry(CD_Object.arrayType()), CD_String.arrayType()),\n+                Arguments.of(false, cp.classEntry(cp.utf8Entry(\"Ljava\/lang\/Object;\")), CD_String.arrayType()),\n+                Arguments.of(false, cp.classEntry(cp.utf8Entry(\"java\/lang\/Object\")), CD_String.arrayType()),\n+                Arguments.of(false, cp.classEntry(cp.utf8Entry(\"Ljava\/lang\/Object;\")), CD_String),\n+                Arguments.of(false, cp.classEntry(CD_Object), CD_int)\n+        );\n+    }\n+\n+    @MethodSource(\"equalsSymbolProvider\")\n+    @ParameterizedTest\n+    void testClassEntryEqualsSymbolCase(boolean result, ClassEntry ce, ClassDesc cd) {\n+        boolean noCache = accessCachedClassDesc(ce) == null;\n+        assertEquals(result, ce.equalsSymbol(cd));\n+        if (noCache) {\n+            assertEquals(result, accessCachedClassDesc(ce) != null, () -> \"cache presence after test with result \" + result);\n+            if (result && cd.isArray()) {\n+                \/\/ Reuse cache from utf8\n+                assertSame(accessCachedClassDesc(ce), Util.fieldTypeSymbol(ce.name()));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void testClassEntryEqualsSymbolCacheState() {\n+        var internalName = \"test\/MyClass\";\n+        var altInternalName = \"test\/YourClass\";\n+        var descriptorString = \"L\" + internalName + \";\";\n+        var altDescriptorString = \"L\" + altInternalName + \";\";\n+\n+        var bytes = ClassFile.of().build(ClassDesc.ofInternalName(internalName), _ -> {});\n+\n+        \/\/ 1. Both unexpanded\n+        \/\/ 1.1 matches\n+        {\n+            var cd = ClassDesc.ofDescriptor(descriptorString);\n+            var ce = ClassFile.of().parse(bytes).thisClass();\n+\n+            assertNull(accessCachedInternalName(cd));\n+            assertNull(accessCachedClassDesc(ce));\n+            assertNull(accessCachedString(ce.name()));\n+\n+            assertTrue(ce.equalsSymbol(cd));\n+\n+            assertNull(accessCachedInternalName(cd));\n+            assertSame(cd, accessCachedClassDesc(ce));\n+            assertNull(accessCachedString(ce.name()));\n+        }\n+        \/\/ 1.2 no match\n+        {\n+            var cd = ClassDesc.ofDescriptor(altDescriptorString);\n+            var ce = ClassFile.of().parse(bytes).thisClass();\n+\n+            assertNull(accessCachedInternalName(cd));\n+            assertNull(accessCachedClassDesc(ce));\n+            assertNull(accessCachedString(ce.name()));\n+\n+            assertFalse(ce.equalsSymbol(cd));\n+\n+            assertNull(accessCachedInternalName(cd));\n+            assertNull(accessCachedClassDesc(ce));\n+            assertNull(accessCachedString(ce.name()));\n+        }\n+\n+        \/\/ 2. ClassDesc expanded\n+        \/\/ 2.1 matches\n+        {\n+            var cd = ClassDesc.ofInternalName(internalName);\n+            var ce = ClassFile.of().parse(bytes).thisClass();\n+\n+            assertSame(internalName, accessCachedInternalName(cd));\n+            assertNull(accessCachedClassDesc(ce));\n+            assertNull(accessCachedString(ce.name()));\n+\n+            assertTrue(ce.equalsSymbol(cd));\n+\n+            assertSame(internalName, accessCachedInternalName(cd));\n+            assertSame(cd, accessCachedClassDesc(ce));\n+            assertSame(internalName, accessCachedString(ce.name()));\n+        }\n+        \/\/ 2.2 no match\n+        {\n+            var cd = ClassDesc.ofInternalName(altInternalName);\n+            var ce = ClassFile.of().parse(bytes).thisClass();\n+\n+            assertSame(altInternalName, accessCachedInternalName(cd));\n+            assertNull(accessCachedClassDesc(ce));\n+            assertNull(accessCachedString(ce.name()));\n+\n+            assertFalse(ce.equalsSymbol(cd));\n+\n+            assertSame(altInternalName, accessCachedInternalName(cd));\n+            assertNull(accessCachedClassDesc(ce));\n+            assertNull(accessCachedString(ce.name()));\n+        }\n+\n+        \/\/ We only push internal name in few scenarios, not tested yet\n+    }\n+\n+    \/\/ Support infrastructure\n+    static ClassDesc accessCachedClassDesc(ClassEntry ce) {\n+        return ((AbstractPoolEntry.ClassEntryImpl) ce).sym;\n+    }\n+\n+    static String accessCachedInternalName(ClassDesc cd) {\n+        return ((ClassOrInterfaceDescImpl) cd).internalNameCache();\n+    }\n+\n+    static String accessCachedString(Utf8Entry utf8) {\n+        var utf8Impl = (AbstractPoolEntry.Utf8EntryImpl) utf8;\n+        try {\n+            return (String) STRING_VALUE_GETTER.invokeExact(utf8Impl);\n+        } catch (Throwable e) {\n+            if (e instanceof Error er)\n+                throw er;\n+            throw (RuntimeException) e;\n+        }\n+    }\n+\n+    static final MethodHandle STRING_VALUE_GETTER;\n+\n+    static {\n+        MethodHandle getter;\n+        try {\n+            var lookup = MethodHandles.privateLookupIn(AbstractPoolEntry.Utf8EntryImpl.class, MethodHandles.lookup());\n+            getter = lookup.findGetter(AbstractPoolEntry.Utf8EntryImpl.class, \"stringValue\", String.class);\n+        } catch (IllegalAccessException | NoSuchFieldException ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+        STRING_VALUE_GETTER = getter;\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/ConstantDescSymbolsTest.java","additions":158,"deletions":2,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+    java.base\/jdk.internal.constant \\\n","filename":"test\/jdk\/jdk\/classfile\/TEST.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,3 +37,0 @@\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n-\n@@ -44,1 +41,0 @@\n-import jdk.internal.constant.ConstantUtils;\n","filename":"test\/jdk\/jdk\/classfile\/UtilTest.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}