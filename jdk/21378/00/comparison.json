{"files":[{"patch":"@@ -1242,1 +1242,1 @@\n-            long headerSize = (long)CENHDR + nlen + clen + elen;\n+            int headerSize = CENHDR + nlen + clen + elen;\n@@ -1247,1 +1247,1 @@\n-            if (headerSize > 0xFFFF || pos + headerSize > cen.length) {\n+            if (headerSize > 0xFFFF || pos > cen.length - headerSize) {\n@@ -1771,2 +1771,0 @@\n-            int entryPos = CENHDR;\n-            int limit = cen.length;\n@@ -1774,1 +1772,1 @@\n-            while (entryPos <= limit) {\n+            while (pos <= cen.length - CENHDR) {\n@@ -1779,1 +1777,1 @@\n-                    initCEN(countCENHeaders(cen, limit));\n+                    initCEN(countCENHeaders(cen));\n@@ -1783,0 +1781,1 @@\n+                int entryPos = pos + CENHDR;\n@@ -1813,1 +1812,0 @@\n-                entryPos = pos + CENHDR;\n@@ -2037,1 +2035,0 @@\n-         * Will not throw, even if the ZIP file is corrupt.\n@@ -2040,1 +2037,1 @@\n-         * @param size number of bytes in central directory\n+         * @throws ZipException if a CEN header exceeds the length of the CEN array\n@@ -2042,1 +2039,1 @@\n-        private static int countCENHeaders(byte[] cen, int size) {\n+        private static int countCENHeaders(byte[] cen) throws ZipException {\n@@ -2044,3 +2041,6 @@\n-            for (int p = 0;\n-                 p + CENHDR <= size;\n-                 p += CENHDR + CENNAM(cen, p) + CENEXT(cen, p) + CENCOM(cen, p))\n+            for (int p = 0; p <= cen.length - CENHDR;) {\n+                int headerSize = CENHDR + CENNAM(cen, p) + CENEXT(cen, p) + CENCOM(cen, p);\n+                if (p > cen.length - headerSize) {\n+                    zerror(\"invalid CEN header (bad header size)\");\n+                }\n+                p += headerSize;\n@@ -2048,0 +2048,1 @@\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8341595\n+ * @modules java.base\/jdk.internal.util\n+ * @summary Verify that ZipFile can read from a ZIP file with a maximally large CEN size\n+ * @run junit\/othervm -Xmx2500M CenSizeMaximum\n+ *\/\n+\n+import jdk.internal.util.ArraysSupport;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class CenSizeMaximum {\n+\n+    \/\/ Maximum allowed CEN size allowed by the ZipFile implementation\n+    static final int MAX_CEN_SIZE = ArraysSupport.SOFT_MAX_ARRAY_LENGTH;\n+\n+    \/**\n+     * From the APPNOTE.txt specification:\n+     *    4.4.10 file name length: (2 bytes)\n+     *    4.4.11 extra field length: (2 bytes)\n+     *    4.4.12 file comment length: (2 bytes)\n+     *\n+     *        The length of the file name, extra field, and comment\n+     *        fields respectively.  The combined length of any\n+     *        directory record and these three fields SHOULD NOT\n+     *        generally exceed 65,535 bytes.\n+     *.\n+     * Create a maximum extra field which does not exceed 65,535 bytes\n+     *\/\n+    static final int MAX_EXTRA_FIELD_SIZE = 65_535 - ZipFile.CENHDR;\n+\n+    \/\/ Tag for the 'unknown' field type, specified in APPNOTE.txt 'Third party mappings'\n+    static final short UNKNOWN_ZIP_TAG = (short) 0x9902;\n+\n+    \/\/ The size of one CEN header, including the name and the extra field\n+    static final int CEN_HEADER_SIZE = ZipFile.CENHDR + MAX_EXTRA_FIELD_SIZE;\n+\n+    \/\/ The size of the extra data field header (tag id + data block length)\n+    static final int EXTRA_FIELD_HEADER_SIZE = 2 * Short.BYTES;\n+\n+    \/\/ Zip file to create for testing\n+    private Path hugeZipFile = Path.of(\"cen-size-on-limit.zip\");\n+\n+    \/**\n+     * Clean up ZIP file created in this test\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        \/\/Files.deleteIfExists(hugeZipFile);\n+    }\n+\n+    \/**\n+     * Validates that ZipFile opens a ZIP file with a CEN size close\n+     * to the {@link #MAX_CEN_SIZE} implementation limit.\n+     *\n+     * @throws IOException if an unexpected IO error occurs\n+     *\/\n+    @Test\n+    public void maximumCenSize() throws IOException {\n+        int numCenHeaders = zipWithWithExactCenSize(MAX_CEN_SIZE, true, false);\n+        try (var zf = new ZipFile(hugeZipFile.toFile())) {\n+            assertEquals(numCenHeaders, zf.size());\n+        }\n+    }\n+\n+    \/**\n+     * Validates that ZipFile rejects a ZIP where the last CEN record\n+     * overflows the CEN size and the END header CENTOT field is smaller\n+     * than the actual number of headers\n+     *\n+     * @throws IOException if an unexpected IO error occurs\n+     *\/\n+    @Test\n+    public void lastCENHeaderBadSize() throws IOException {\n+        int numCenHeaders = zipWithWithExactCenSize(1024, true, true);\n+        ZipException zipException = assertThrows(ZipException.class, () -> {\n+            try (var zf = new ZipFile(hugeZipFile.toFile())) {\n+                assertEquals(numCenHeaders, zf.size());\n+            }\n+        });\n+        assertEquals(\"invalid CEN header (bad header size)\", zipException.getMessage());\n+\n+    }\n+\n+    \/**\n+     * Produce a ZIP file with an exact CEN size. To minimize the number of CEN headers\n+     * written, maximally large, empty extra data blocks are written sparsely.\n+     *\n+     * @param cenSize the exact CEN size of the ZIP file to produce\n+     * @param invalidateEndTotal whether to decrement the END header's TOT field by one\n+     * @return the number of CEN headers produced\n+     * @throws IOException if an unexpected IO error occurs\n+     *\/\n+    private int zipWithWithExactCenSize(long cenSize, boolean invalidateEndTotal, boolean overflowLastCEN)\n+            throws IOException {\n+        \/\/ Sanity check\n+        assertTrue(cenSize <= MAX_CEN_SIZE);\n+\n+        \/\/ The number of CEN headers we need to write\n+        int numCenHeaders = (int) (cenSize \/ CEN_HEADER_SIZE) + 1;\n+        \/\/ Size if all extra data fields were of maximum size\n+        long overSized = numCenHeaders * (long) CEN_HEADER_SIZE;\n+        \/\/ Length to trim from the first CEN's extra data\n+        int negativPadding = (int) (overSized - cenSize);\n+        int firstExtraSize = MAX_EXTRA_FIELD_SIZE - negativPadding;\n+\n+        \/\/ Sanity check\n+        long computedCenSize = (numCenHeaders -1L ) * CEN_HEADER_SIZE + ZipEntry.CENHDR + firstExtraSize;\n+        assertEquals(computedCenSize, cenSize);\n+\n+        \/\/ A CEN header, followed by the four-bytes extra data header\n+        ByteBuffer cenHeader = createCENHeader();\n+        \/\/ An END header\n+        ByteBuffer endHeader = createENDHeader();\n+        \/\/ Update the END header\n+        if (invalidateEndTotal) {\n+            \/\/ To trigger countCENHeaders\n+            endHeader.putShort(ZipEntry.ENDTOT, (short) (numCenHeaders -1 & 0xFFFF));\n+        } else {\n+            endHeader.putShort(ZipEntry.ENDTOT, (short) (numCenHeaders & 0xFFFF));\n+        }\n+        \/\/ Update CEN size and offset fields\n+        endHeader.putInt(ZipEntry.ENDSIZ, (int) (cenSize & 0xFFFFFFFFL));\n+        endHeader.putInt(ZipEntry.ENDOFF, 0);\n+\n+        \/\/ When creating a sparse file, the file must not already exit\n+        Files.deleteIfExists(hugeZipFile);\n+\n+        \/\/ Open a FileChannel for writing a sparse file\n+        EnumSet<StandardOpenOption> options = EnumSet.of(StandardOpenOption.CREATE_NEW,\n+                StandardOpenOption.WRITE,\n+                StandardOpenOption.SPARSE);\n+\n+        try (FileChannel channel = FileChannel.open(hugeZipFile, options)) {\n+            \/\/ Write CEN headers\n+            for (int i = 0; i < numCenHeaders; i++) {\n+                \/\/ The first CEN header has trimmed extra data\n+                int extraSize = i == 0 ? firstExtraSize : MAX_EXTRA_FIELD_SIZE;\n+                if (overflowLastCEN && i == numCenHeaders - 1) {\n+                    \/\/ make last CEN header overflow the CEN size\n+                    cenHeader.putShort(ZipEntry.CENNAM, Short.MAX_VALUE);\n+                }\n+                \/\/ update elen field\n+                cenHeader.putShort(ZipEntry.CENEXT, (short) (extraSize & 0xFFFF));\n+                \/\/ update data block len of the extra field header\n+                short dlen = (short) ((extraSize - EXTRA_FIELD_HEADER_SIZE) & 0xFFFF);\n+                cenHeader.putShort(ZipEntry.CENHDR + Short.BYTES, dlen);\n+                \/\/ Write the CEN header plus the four-byte extra header\n+                channel.write(cenHeader.rewind());\n+                \/\/ Sparse \"write\" of the extra data block\n+                channel.position(channel.position() + extraSize - EXTRA_FIELD_HEADER_SIZE);\n+            }\n+            \/\/ Sanity check\n+            assertEquals(cenSize,  channel.position());\n+            \/\/ Write the END header\n+            channel.write(endHeader.rewind());\n+        }\n+        return numCenHeaders;\n+    }\n+\n+    \/\/ Creates a ByteBuffer representing a CEN header with a trailing extra field header\n+    private ByteBuffer createCENHeader() throws IOException {\n+        byte[] bytes = smallZipfile();\n+        ByteBuffer buf = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN);\n+        int endOff = bytes.length - ZipEntry.ENDHDR;\n+        int cenSize = buf.getInt(endOff + ZipEntry.ENDSIZ);\n+        int cenOff = buf.getInt(endOff + ZipEntry.ENDOFF);\n+        return ByteBuffer.wrap(\n+                Arrays.copyOfRange(bytes, cenOff, cenOff + ZipEntry.CENHDR + EXTRA_FIELD_HEADER_SIZE)\n+        ).order(ByteOrder.LITTLE_ENDIAN);\n+    }\n+\n+    \/\/ Creates a ByteBuffer representing an END header\n+    private ByteBuffer createENDHeader() throws IOException {\n+        byte[] bytes = smallZipfile();\n+        ByteBuffer buf = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN);\n+        int endOff = bytes.length - ZipEntry.ENDHDR;\n+        return ByteBuffer.wrap(\n+                        Arrays.copyOfRange(bytes, endOff, endOff + ZipEntry.ENDHDR)\n+        ).order(ByteOrder.LITTLE_ENDIAN);\n+    }\n+\n+    \/\/ Create a byte array with a minimal ZIP file\n+    private static byte[] smallZipfile() throws IOException {\n+        var out = new ByteArrayOutputStream();\n+        try (var zo = new ZipOutputStream(out)) {\n+            ZipEntry entry = new ZipEntry(\"\");\n+            entry.setExtra(makeDummyExtraField());\n+            zo.putNextEntry(entry);\n+        }\n+        return out.toByteArray();\n+    }\n+\n+    \/\/ Create a minimally sized extra field\n+    private static byte[] makeDummyExtraField() {\n+        byte[] extra = new byte[EXTRA_FIELD_HEADER_SIZE];\n+        \/\/ Little-endian ByteBuffer for updating the header fields\n+        ByteBuffer buffer = ByteBuffer.wrap(extra).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        \/\/ We use the 'unknown' tag, specified in APPNOTE.TXT, 4.6.1 Third party mappings'\n+        buffer.putShort(UNKNOWN_ZIP_TAG);\n+\n+        \/\/ Size of the actual (empty) data\n+        buffer.putShort((short) 0);\n+        return extra;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CenSizeMaximum.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"}]}