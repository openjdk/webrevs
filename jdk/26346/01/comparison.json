{"files":[{"patch":"@@ -2993,1 +2993,1 @@\n-  if (index < 0 || index > iklass->total_fields_count()) {\n+  if (index < 0 || index >= iklass->total_fields_count()) {\n@@ -3003,1 +3003,1 @@\n-  InstanceKlass* iklass = check_field(klass, index, JVMCIENV);\n+  InstanceKlass* iklass = check_field(klass, index, JVMCI_CHECK_NULL);\n@@ -3005,0 +3005,4 @@\n+  if (fd.is_injected()) {\n+    JVMCI_THROW_MSG_NULL(IllegalArgumentException,\n+        err_msg(\"Cannot get Field for injected %s.%s\", klass->external_name(), fd.name()->as_C_string()));\n+  }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+  bool is_injected()              const    { return field_flags().is_injected(); }\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -778,2 +778,2 @@\n-        if (type instanceof HotSpotResolvedJavaType && reflection instanceof HotSpotJDKReflection) {\n-            return ((HotSpotJDKReflection) reflection).getMirror((HotSpotResolvedJavaType) type);\n+        if (type instanceof HotSpotResolvedJavaType hType && reflection instanceof HotSpotJDKReflection) {\n+            return ((HotSpotJDKReflection) reflection).getMirror(hType);\n@@ -793,2 +793,2 @@\n-        if (method instanceof HotSpotResolvedJavaMethodImpl && reflection instanceof HotSpotJDKReflection) {\n-            return HotSpotJDKReflection.getMethod((HotSpotResolvedJavaMethodImpl) method);\n+        if (!method.isClassInitializer() && method instanceof HotSpotResolvedJavaMethodImpl hMethod && reflection instanceof HotSpotJDKReflection) {\n+            return HotSpotJDKReflection.getMethod(hMethod);\n@@ -808,2 +808,2 @@\n-        if (field instanceof HotSpotResolvedJavaFieldImpl && reflection instanceof HotSpotJDKReflection) {\n-            return HotSpotJDKReflection.getField((HotSpotResolvedJavaFieldImpl) field);\n+        if (!field.isInternal() && field instanceof HotSpotResolvedJavaFieldImpl hField && reflection instanceof HotSpotJDKReflection) {\n+            return HotSpotJDKReflection.getField(hField);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -300,0 +300,10 @@\n+    @Override\n+    public ResolvedJavaMethod[] getDeclaredConstructors(boolean forceLink) {\n+        return new ResolvedJavaMethod[0];\n+    }\n+\n+    @Override\n+    public ResolvedJavaMethod[] getDeclaredMethods(boolean forceLink) {\n+        return new ResolvedJavaMethod[0];\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedPrimitiveType.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaField.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n@@ -107,0 +108,1 @@\n+import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;\n@@ -113,0 +115,1 @@\n+    private static final HotSpotJVMCIRuntime runtime = HotSpotJVMCIRuntime.runtime();\n@@ -117,0 +120,7 @@\n+    @Test\n+    public void getMirrorTest() {\n+        for (ResolvedJavaType type : javaTypes) {\n+            assertEquals(type.toClassName(), runtime.getMirror(type).getName());\n+        }\n+    }\n+\n@@ -938,0 +948,3 @@\n+    \/**\n+     * Replicates the semantics of jdk.internal.reflect.Reflection#fieldFilterMap.\n+     *\/\n@@ -974,1 +987,7 @@\n-                    if (field.isInternal() || isHiddenFromReflection(field)) {\n+                    var mirror = runtime.getMirror(field);\n+                    if (field.isInternal()) {\n+                        assertNull(field.toString(), mirror);\n+                        continue;\n+                    }\n+                    assertNotNull(field.toString(), mirror);\n+                    if (isHiddenFromReflection(field)) {\n@@ -1005,0 +1024,2 @@\n+                var mirror = runtime.getMirror(rf);\n+                assertNotNull(rf.toString(), mirror);\n@@ -1028,0 +1049,22 @@\n+            for (ResolvedJavaMethod method : actual) {\n+                assertNotNull(method.toString(), runtime.getMirror(method));\n+            }\n+            assertEquals(expected, actual);\n+        }\n+    }\n+\n+    @Test\n+    public void getDeclaredConstructorsTest() {\n+        for (Class<?> c : classes) {\n+            ResolvedJavaType type = metaAccess.lookupJavaType(c);\n+            Constructor<?>[] raw = c.getDeclaredConstructors();\n+            Set<ResolvedJavaMethod> expected = new HashSet<>();\n+            for (Constructor<?> m : raw) {\n+                ResolvedJavaMethod resolvedMethod = metaAccess.lookupJavaMethod(m);\n+                assertNotNull(resolvedMethod);\n+                expected.add(resolvedMethod);\n+            }\n+            Set<ResolvedJavaMethod> actual = new HashSet<>(Arrays.asList(type.getDeclaredConstructors()));\n+            for (ResolvedJavaMethod method : actual) {\n+                assertNotNull(runtime.getMirror(method));\n+            }\n@@ -1241,1 +1284,0 @@\n-        \"getDeclaredConstructors\",\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":44,"deletions":2,"binary":false,"changes":46,"status":"modified"}]}