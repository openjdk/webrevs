{"files":[{"patch":"@@ -1188,0 +1188,1 @@\n+  assert(Thread::current()->is_VM_thread(), \"Must be the VM thread\");\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,3 +31,3 @@\n-    final static int NUMBER_OF_ENTERER_THREADS = 4;\n-    final static int NUMBER_OF_WAITER_THREADS  = 4;\n-    final static int NUMBER_OF_THREADS = NUMBER_OF_ENTERER_THREADS + NUMBER_OF_WAITER_THREADS;\n+    final static int NUMBER_OF_ENTERING_THREADS = 4;\n+    final static int NUMBER_OF_WAITING_THREADS  = 4;\n+    final static int NUMBER_OF_THREADS = NUMBER_OF_ENTERING_THREADS + NUMBER_OF_WAITING_THREADS;\n@@ -47,0 +47,1 @@\n+    static TestThread thr[] = new TestThread[NUMBER_OF_THREADS];\n@@ -52,2 +53,12 @@\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n+    \/* Scenario #1:\n+     * - non-zero entering threads\n+     * - zero re-entering threads\n+     * - zero threads waiting to be notified\n+     *\/\n+    static void test1() throws Error {\n+        synchronized (lockCheck) {\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter: 0\n+            \/\/ count of threads waiting to re-enter: 0\n+            \/\/ count of threads waiting to be notified: 0\n+            check(lockCheck, Thread.currentThread(), 1, 0, 0);\n@@ -55,2 +66,21 @@\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n+            for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n+                thr[i] = new EnteringThread();\n+                thr[i].start();\n+                \/\/ this EnteringThread has to be blocked on the lockCheck enter\n+                thr[i].waitReady();\n+            }\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n+            \/\/ count of threads waiting to re-enter:    0\n+            \/\/ count of threads waiting to be notified: 0\n+            check(lockCheck, Thread.currentThread(), 1,\n+                  NUMBER_OF_ENTERING_THREADS,\n+                  0 \/* count of threads waiting to be notified: 0 *\/);\n+        }\n+        for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n+            try {\n+                thr[i].join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected \" + e);\n+            }\n+        }\n@@ -59,3 +89,11 @@\n-    public static int run(String args[], PrintStream out) {\n-        check(lockCheck, null, 0, 0, 0);\n-\n+    \/* Scenario #2:\n+     * - non-zero entering threads\n+     * - zero re-entering threads\n+     * - non-zero waiting to be notified\n+     *\/\n+    static void test2() throws Error {\n+        for (int i = NUMBER_OF_ENTERING_THREADS; i < NUMBER_OF_THREADS; i++) {\n+            thr[i] = new WaitingThread();\n+            thr[i].start();\n+            thr[i].waitReady(); \/\/ the WaitingThread has to wait to be notified in a lockCheck.wait()\n+        }\n@@ -63,1 +101,14 @@\n-            check(lockCheck, Thread.currentThread(), 1, 0, 0);\n+            for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n+                thr[i] = new EnteringThread();\n+                thr[i].start();\n+                thr[i].waitReady(); \/\/ the EnteringThread has to block on monitor enter\n+            }\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n+            \/\/ count of threads waiting to re-enter:    0\n+            \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n+            check(lockCheck, Thread.currentThread(), 1,\n+                  NUMBER_OF_ENTERING_THREADS,\n+                  NUMBER_OF_WAITING_THREADS);\n+\n+            lockCheck.notifyAll();\n@@ -65,0 +116,8 @@\n+        for (int i = 0; i < NUMBER_OF_THREADS; i++) {\n+            try {\n+                thr[i].join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected \" + e);\n+            }\n+        }\n+    }\n@@ -66,3 +125,14 @@\n-        TestThread thr[] = new TestThread[NUMBER_OF_THREADS];\n-        for (int i = NUMBER_OF_ENTERER_THREADS; i < NUMBER_OF_THREADS; i++) {\n-            thr[i] = new WaiterThread();\n+    \/* Scenario #3:\n+     * Initially we have:\n+     * - zero entering threads\n+     * - zero re-entering threads\n+     * - non-zero threads waiting to be notified\n+     *\n+     * The threads waiting to be notified are being notified one-by-one\n+     * until all threads are blocked on re-entering the monitor.\n+     * The numbers of entering\/re-entering and waiting threads are checked\n+     * for correctness after each notification.\n+     *\/\n+    static void test3() throws Error {\n+        for (int i = NUMBER_OF_ENTERING_THREADS; i < NUMBER_OF_THREADS; i++) {\n+            thr[i] = new WaitingThread();\n@@ -70,1 +140,1 @@\n-            \/\/ the WaiterThread has to wait to be notified in a lockCheck.wait()\n+            \/\/ the WaitingThread has to wait to be notified in a lockCheck.wait()\n@@ -74,2 +144,10 @@\n-            for (int i = 0; i < NUMBER_OF_ENTERER_THREADS; i++) {\n-                thr[i] = new EntererThread();\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter:       0\n+            \/\/ count of threads waiting to re-enter:    0\n+            \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n+            check(lockCheck, Thread.currentThread(), 1,\n+                  0, \/\/ number of threads waiting to enter or re-enter\n+                  NUMBER_OF_WAITING_THREADS);\n+\n+            for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n+                thr[i] = new EnteringThread();\n@@ -77,1 +155,1 @@\n-                \/\/ the EntererThread has to be blocked on the lockCheck enter\n+                \/\/ this EnteringThread has to be blocked on the lockCheck enter\n@@ -80,0 +158,5 @@\n+\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n+            \/\/ count of threads waiting to re-enter:    0\n+            \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n@@ -81,3 +164,4 @@\n-                  NUMBER_OF_ENTERER_THREADS,\n-                  NUMBER_OF_WAITER_THREADS);\n-            for (int i = 0; i < NUMBER_OF_WAITER_THREADS; i++) {\n+                  NUMBER_OF_ENTERING_THREADS,\n+                  NUMBER_OF_WAITING_THREADS);\n+\n+            for (int i = 0; i < NUMBER_OF_WAITING_THREADS; i++) {\n@@ -85,1 +169,6 @@\n-                \/\/ now the notified WaiterThread has to be blocked on the lockCheck re-enter\n+                \/\/ now the notified WaitingThread has to be blocked on the lockCheck re-enter\n+\n+                \/\/ entry count: 1\n+                \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n+                \/\/ count of threads waiting to re-enter:    i + 1\n+                \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS - i - 1\n@@ -87,2 +176,2 @@\n-                      NUMBER_OF_ENTERER_THREADS + i + 1,\n-                      NUMBER_OF_WAITER_THREADS  - i - 1);\n+                      NUMBER_OF_ENTERING_THREADS + i + 1,\n+                      NUMBER_OF_WAITING_THREADS  - i - 1);\n@@ -98,0 +187,16 @@\n+    }\n+\n+    public static void main(String args[]) {\n+        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n+\n+        \/\/ produce JCK-like exit status.\n+        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n+    }\n+\n+    public static int run(String args[], PrintStream out) {\n+        check(lockCheck, null, 0, 0, 0);\n+\n+        test1();\n+        test2();\n+        test3();\n+\n@@ -115,1 +220,1 @@\n-    static class EntererThread extends TestThread {\n+    static class EnteringThread extends TestThread {\n@@ -123,1 +228,1 @@\n-    static class WaiterThread extends TestThread {\n+    static class WaitingThread extends TestThread {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003.java","additions":131,"deletions":26,"binary":false,"changes":157,"status":"modified"}]}