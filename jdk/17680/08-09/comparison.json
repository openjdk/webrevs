{"files":[{"patch":"@@ -192,10 +192,0 @@\n-\/\/ If there is a virtual thread mounted then return vthread() oop.\n-\/\/ Otherwise, return threadObj().\n-oop JavaThread::vthread_or_thread() const {\n-    oop result = vthread();\n-    if (result == nullptr) {\n-      result = threadObj();\n-    }\n-    return result;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -527,1 +527,0 @@\n-  oop vthread_or_thread() const;\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"prims\/jvmtiEnvBase.hpp\"\n@@ -1184,1 +1185,1 @@\n-\/\/ Get count Java threads that are waiting to enter the specified monitor.\n+\/\/ Get count Java threads that are waiting to enter or re-enter the specified monitor.\n@@ -1199,4 +1200,7 @@\n-    if (pending == monitor ||\n-        (waiting == monitor && JavaThreadStatus::BLOCKED_ON_MONITOR_ENTER ==\n-         java_lang_Thread::get_thread_status(p->vthread_or_thread()))\n-    ) {  \/\/ found a match\n+    oop thread_oop = JvmtiEnvBase::get_vthread_or_thread_oop(p);\n+    bool is_virtual = java_lang_VirtualThread::is_instance(thread_oop);\n+    jint state = is_virtual ? JvmtiEnvBase::get_vthread_state(thread_oop, p)\n+                            : JvmtiEnvBase::get_thread_state(thread_oop, p);\n+    if (pending == monitor || (waiting == monitor &&\n+        (state & JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER))\n+    ) { \/\/ found a match\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,249 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/GetObjectMonitorUsage\/ObjectMonitorUsage.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test checks if JVMTI function GetObjectMonitorUsage returns\n+ *     the expected values for the owner, entry_count, water_count\n+ *     fields of JVMTI_monitor_info. The tescases are the following:\n+ *       - unowned object without any waitings\n+ *       - owned object without any waitings\n+ *       - unowned object with waitings through Object.wait()\n+ *       - unowned object has been waiting\n+ * COMMENTS\n+ *     Fixed according to 4669812 bug.\n+ *     Ported from JVMDI test nsk\/jvmdi\/GetMonitorInfo\/getmoninfo003.\n+ * @requires vm.jvmti\n+ * @compile ObjectMonitorUsage.java\n+ * @run main\/othervm\/native -agentlib:ObjectMonitorUsage ObjectMonitorUsage\n+ *\/\n+\n+public class ObjectMonitorUsage {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+    final static int NUMBER_OF_ENTERING_THREADS = 4;\n+    final static int NUMBER_OF_WAITING_THREADS  = 4;\n+    final static int NUMBER_OF_THREADS = NUMBER_OF_ENTERING_THREADS + NUMBER_OF_WAITING_THREADS;\n+\n+    static Object lockCheck = new Object();\n+    static Thread thr[] = new Thread[NUMBER_OF_THREADS];\n+\n+    native static int getRes();\n+    native static void check(Object obj, Thread owner,\n+                             int entryCount, int waiterCount, int notifyWaiterCount);\n+\n+    static Thread startTask(TestTask task, boolean isVirtual) {\n+        Thread thread = isVirtual ? Thread.ofVirtual().start(task)\n+                                  : Thread.ofPlatform().start(task);\n+        task.waitReady();\n+        return thread;\n+    }\n+\n+    \/* Scenario #1:\n+     * - non-zero entering threads\n+     * - zero re-entering threads\n+     * - zero threads waiting to be notified\n+     *\/\n+    static void test1(boolean isVirtual) throws Error {\n+        synchronized (lockCheck) {\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter: 0\n+            \/\/ count of threads waiting to re-enter: 0\n+            \/\/ count of threads waiting to be notified: 0\n+            check(lockCheck, Thread.currentThread(), 1, 0, 0);\n+\n+            for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n+                \/\/ this EnteringTask has to be blocked on the lockCheck enter\n+                thr[i] = startTask(new EnteringTask(), isVirtual);\n+            }\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n+            \/\/ count of threads waiting to re-enter:    0\n+            \/\/ count of threads waiting to be notified: 0\n+            check(lockCheck, Thread.currentThread(), 1,\n+                  NUMBER_OF_ENTERING_THREADS,\n+                  0 \/* count of threads waiting to be notified: 0 *\/);\n+        }\n+        for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n+            try {\n+                thr[i].join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected \" + e);\n+            }\n+        }\n+    }\n+\n+    \/* Scenario #2:\n+     * - non-zero entering threads\n+     * - zero re-entering threads\n+     * - non-zero waiting to be notified\n+     *\/\n+    static void test2(boolean isVirtual) throws Error {\n+        for (int i = NUMBER_OF_ENTERING_THREADS; i < NUMBER_OF_THREADS; i++) {\n+            \/\/ the WaitingTask has to wait to be notified in a lockCheck.wait()\n+            thr[i] = startTask(new WaitingTask(), isVirtual);\n+        }\n+        synchronized (lockCheck) {\n+            for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n+                \/\/ this EnteringTask has to be blocked on the lockCheck enter\n+                thr[i] = startTask(new EnteringTask(), isVirtual);\n+            }\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n+            \/\/ count of threads waiting to re-enter:    0\n+            \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n+            check(lockCheck, Thread.currentThread(), 1,\n+                  NUMBER_OF_ENTERING_THREADS,\n+                  NUMBER_OF_WAITING_THREADS);\n+\n+            lockCheck.notifyAll();\n+        }\n+        for (int i = 0; i < NUMBER_OF_THREADS; i++) {\n+            try {\n+                thr[i].join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected \" + e);\n+            }\n+        }\n+    }\n+\n+    \/* Scenario #3:\n+     * Initially we have:\n+     * - zero entering threads\n+     * - zero re-entering threads\n+     * - non-zero threads waiting to be notified\n+     *\n+     * The threads waiting to be notified are being notified one-by-one\n+     * until all threads are blocked on re-entering the monitor.\n+     * The numbers of entering\/re-entering and waiting threads are checked\n+     * for correctness after each notification.\n+     *\/\n+    static void test3(boolean isVirtual) throws Error {\n+        for (int i = NUMBER_OF_ENTERING_THREADS; i < NUMBER_OF_THREADS; i++) {\n+            \/\/ the WaitingTask has to wait to be notified in a lockCheck.wait()\n+            thr[i] = startTask(new WaitingTask(), isVirtual);\n+        }\n+        synchronized (lockCheck) {\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter:       0\n+            \/\/ count of threads waiting to re-enter:    0\n+            \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n+            check(lockCheck, Thread.currentThread(), 1,\n+                  0, \/\/ number of threads waiting to enter or re-enter\n+                  NUMBER_OF_WAITING_THREADS);\n+\n+            for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n+                \/\/ this EnteringTask has to be blocked on the lockCheck enter\n+                thr[i] = startTask(new EnteringTask(), isVirtual);\n+            }\n+\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n+            \/\/ count of threads waiting to re-enter:    0\n+            \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n+            check(lockCheck, Thread.currentThread(), 1,\n+                  NUMBER_OF_ENTERING_THREADS,\n+                  NUMBER_OF_WAITING_THREADS);\n+\n+            for (int i = 0; i < NUMBER_OF_WAITING_THREADS; i++) {\n+                lockCheck.notify();\n+                \/\/ now the notified WaitingTask has to be blocked on the lockCheck re-enter\n+\n+                \/\/ entry count: 1\n+                \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n+                \/\/ count of threads waiting to re-enter:    i + 1\n+                \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS - i - 1\n+                check(lockCheck, Thread.currentThread(), 1,\n+                      NUMBER_OF_ENTERING_THREADS + i + 1,\n+                      NUMBER_OF_WAITING_THREADS  - i - 1);\n+            }\n+        }\n+        for (int i = 0; i < NUMBER_OF_THREADS; i++) {\n+            try {\n+                thr[i].join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected \" + e);\n+            }\n+        }\n+    }\n+\n+    public static void main(String args[]) {\n+        check(lockCheck, null, 0, 0, 0);\n+\n+        \/\/ test platform threads\n+        test1(false);\n+        test2(false);\n+        test3(false);\n+\n+        \/\/ test virtual threads\n+        test1(false);\n+        test2(false);\n+        test3(false);\n+\n+        check(lockCheck, null, 0, 0, 0);\n+        if (getRes() > 0) {\n+            throw new RuntimeException(\"Failed status returned from the agent\");\n+        }\n+    }\n+\n+    static abstract class TestTask implements Runnable {\n+        public volatile boolean ready = false;\n+        public abstract void run();\n+\n+        public void waitReady() {\n+            try {\n+                while (!ready) {\n+                    Thread.sleep(10);\n+                }\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected \" + e);\n+            }\n+        }\n+    }\n+\n+    static class EnteringTask extends TestTask {\n+        public void run() {\n+            ready = true;\n+            synchronized (lockCheck) {\n+            }\n+        }\n+    }\n+\n+    static class WaitingTask extends TestTask {\n+         public void run() {\n+            synchronized (lockCheck) {\n+                try {\n+                    ready = true;\n+                    lockCheck.wait();\n+                } catch (InterruptedException e) {\n+                    throw new Error(\"Unexpected \" + e);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetObjectMonitorUsage\/ObjectMonitorUsage.java","additions":249,"deletions":0,"binary":false,"changes":249,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+static jvmtiEnv *jvmti = nullptr;\n+static jvmtiCapabilities caps;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static int count = 0;\n+\n+jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jint res;\n+  jvmtiError err;\n+\n+  if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == nullptr) {\n+    LOG(\"Wrong result of a valid call to GetEnv !\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+        TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+        TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+        TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (!caps.can_get_monitor_info) {\n+    LOG(\"Warning: GetObjectMonitorUsage is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_ObjectMonitorUsage_check(JNIEnv *env,\n+        jclass cls, jobject obj, jthread owner,\n+        jint entryCount, jint waiterCount, jint notifyWaiterCount) {\n+  jvmtiError err;\n+  jvmtiMonitorUsage inf;\n+  jvmtiThreadInfo tinf;\n+  int j;\n+\n+  count++;\n+\n+  err = jvmti->GetObjectMonitorUsage(obj, &inf);\n+  if (err == JVMTI_ERROR_MUST_POSSESS_CAPABILITY && !caps.can_get_monitor_info) {\n+    return; \/* Ok, it's expected *\/\n+  } else if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"(GetMonitorInfo#%d) unexpected error: %s (%d)\\n\",\n+        count, TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    if (inf.owner == nullptr) {\n+      LOG(\">>> [%2d]    owner: none (0x0)\\n\", count);\n+    } else {\n+      err = jvmti->GetThreadInfo(inf.owner, &tinf);\n+      LOG(\">>> [%2d]    owner: %s (0x%p)\\n\",\n+          count, tinf.name, inf.owner);\n+    }\n+    LOG(\">>>   entry_count: %d\\n\", inf.entry_count);\n+    LOG(\">>>  waiter_count: %d\\n\", inf.waiter_count);\n+    if (inf.waiter_count > 0) {\n+        LOG(\">>>       waiters:\\n\");\n+        for (j = 0; j < inf.waiter_count; j++) {\n+          err = jvmti->GetThreadInfo(inf.waiters[j], &tinf);\n+          LOG(\">>>                %2d: %s (0x%p)\\n\",\n+              j, tinf.name, inf.waiters[j]);\n+        }\n+    }\n+  }\n+\n+  if (!env->IsSameObject(owner, inf.owner)) {\n+    LOG(\"(%d) unexpected owner: 0x%p\\n\", count, inf.owner);\n+    result = STATUS_FAILED;\n+  }\n+\n+  if (inf.entry_count != entryCount) {\n+    LOG(\"(%d) entry_count expected: %d, actually: %d\\n\",\n+        count, entryCount, inf.entry_count);\n+    result = STATUS_FAILED;\n+  }\n+\n+  if (inf.waiter_count != waiterCount) {\n+    LOG(\"(%d) waiter_count expected: %d, actually: %d\\n\",\n+        count, waiterCount, inf.waiter_count);\n+    result = STATUS_FAILED;\n+  }\n+\n+  if (inf.notify_waiter_count != notifyWaiterCount) {\n+    LOG(\"(%d) notify_waiter_count expected: %d, actually: %d\\n\",\n+        count, notifyWaiterCount, inf.notify_waiter_count);\n+    result = STATUS_FAILED;\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_ObjectMonitorUsage_getRes(JNIEnv *env, jclass cls) {\n+  return result;\n+}\n+\n+} \/\/ exnern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetObjectMonitorUsage\/libObjectMonitorUsage.cpp","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"}]}