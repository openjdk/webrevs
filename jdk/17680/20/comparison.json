{"files":[{"patch":"@@ -1482,0 +1482,3 @@\n+  ResourceMark rm(current_thread);\n+  GrowableArray<JavaThread*>* wantList = nullptr;\n+\n@@ -1488,2 +1491,2 @@\n-    ret.waiter_count = nWant + nWait;\n-    ret.notify_waiter_count = nWait;\n+    wantList =  Threads::get_pending_threads(tlh.list(), nWant + nWait, (address)mon);\n+    nWant = wantList->length();\n@@ -1492,2 +1495,0 @@\n-    ret.waiter_count = 0;\n-    ret.notify_waiter_count = 0;\n@@ -1496,0 +1497,17 @@\n+  if (mon != nullptr) {\n+    ObjectWaiter *waiter = mon->first_waiter();\n+    for (int i = 0; i < nWait; i++) {\n+      if (waiter == nullptr || (i != 0 && waiter == mon->first_waiter())) {\n+        \/\/ robustness: the waiting list has gotten smaller\n+        \/\/ The nWait count we got from the mon->waiters() may include the re-entering\n+        \/\/ the monitor threads after being notified. Here we are correcting the actual\n+        \/\/ number of the waiting threads by excluding those re-entering the monitor.\n+        nWait = i;\n+        break;\n+      }\n+      waiter = mon->next_waiter(waiter);\n+    }\n+  }\n+  ret.waiter_count = nWant;\n+  ret.notify_waiter_count = nWait;\n+\n@@ -1513,2 +1531,1 @@\n-    \/\/ Number of waiters may actually be less than the waiter count.\n-    \/\/ So null out memory so that unused memory will be null.\n+    \/\/ null out memory for robustness\n@@ -1518,17 +1535,8 @@\n-    if (ret.waiter_count > 0) {\n-      \/\/ we have contending and\/or waiting threads\n-      if (nWant > 0) {\n-        \/\/ we have contending threads\n-        ResourceMark rm(current_thread);\n-        \/\/ get_pending_threads returns only java thread so we do not need to\n-        \/\/ check for non java threads.\n-        GrowableArray<JavaThread*>* wantList = Threads::get_pending_threads(tlh.list(), nWant, (address)mon);\n-        if (wantList->length() < nWant) {\n-          \/\/ robustness: the pending list has gotten smaller\n-          nWant = wantList->length();\n-        }\n-        for (int i = 0; i < nWant; i++) {\n-          JavaThread *pending_thread = wantList->at(i);\n-          Handle th(current_thread, get_vthread_or_thread_oop(pending_thread));\n-          ret.waiters[i] = (jthread)jni_reference(calling_thread, th);\n-        }\n+    if (ret.waiter_count > 0) { \/\/ we have contending threads waiting to enter\/re-enter the monitor\n+      \/\/ identify threads waiting to enter and re-enter the monitor\n+      \/\/ get_pending_threads returns only java thread so we do not need to\n+      \/\/ check for non java threads.\n+      for (int i = 0; i < nWant; i++) {\n+        JavaThread *pending_thread = wantList->at(i);\n+        Handle th(current_thread, get_vthread_or_thread_oop(pending_thread));\n+        ret.waiters[i] = (jthread)jni_reference(calling_thread, th);\n@@ -1536,21 +1544,12 @@\n-      if (nWait > 0) {\n-        \/\/ we have threads in Object.wait()\n-        int offset = nWant;  \/\/ add after any contending threads\n-        ObjectWaiter *waiter = mon->first_waiter();\n-        for (int i = 0, j = 0; i < nWait; i++) {\n-          if (waiter == nullptr) {\n-            \/\/ robustness: the waiting list has gotten smaller\n-            nWait = j;\n-            break;\n-          }\n-          JavaThread *w = mon->thread_of_waiter(waiter);\n-          if (w != nullptr) {\n-            \/\/ If the thread was found on the ObjectWaiter list, then\n-            \/\/ it has not been notified. This thread can't change the\n-            \/\/ state of the monitor so it doesn't need to be suspended.\n-            Handle th(current_thread, get_vthread_or_thread_oop(w));\n-            ret.waiters[offset + j] = (jthread)jni_reference(calling_thread, th);\n-            ret.notify_waiters[j++] = (jthread)jni_reference(calling_thread, th);\n-          }\n-          waiter = mon->next_waiter(waiter);\n-        }\n+    }\n+    if (ret.notify_waiter_count > 0) { \/\/ we have threads waiting to be notified in Object.wait()\n+      ObjectWaiter *waiter = mon->first_waiter();\n+      for (int i = 0; i < nWait; i++) {\n+        JavaThread *w = mon->thread_of_waiter(waiter);\n+        assert(w != nullptr, \"DBG: sanity check\");\n+        \/\/ If the thread was found on the ObjectWaiter list, then\n+        \/\/ it has not been notified. This thread can't change the\n+        \/\/ state of the monitor so it doesn't need to be suspended.\n+        Handle th(current_thread, get_vthread_or_thread_oop(w));\n+        ret.notify_waiters[i] = (jthread)jni_reference(calling_thread, th);\n+        waiter = mon->next_waiter(waiter);\n@@ -1558,5 +1557,1 @@\n-    } \/\/ ThreadsListHandle is destroyed here.\n-\n-    \/\/ Adjust count. nWant and nWait count values may be less than original.\n-    ret.waiter_count = nWant + nWait;\n-    ret.notify_waiter_count = nWait;\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":44,"deletions":49,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"prims\/jvmtiEnvBase.hpp\"\n@@ -1184,1 +1185,2 @@\n-\/\/ Get count Java threads that are waiting to enter the specified monitor.\n+#if INCLUDE_JVMTI\n+\/\/ Get count Java threads that are waiting to enter or re-enter the specified monitor.\n@@ -1188,0 +1190,1 @@\n+  assert(Thread::current()->is_VM_thread(), \"Must be the VM thread\");\n@@ -1197,1 +1200,8 @@\n-    if (pending == monitor) {             \/\/ found a match\n+    address waiting = (address)p->current_waiting_monitor();\n+    oop thread_oop = JvmtiEnvBase::get_vthread_or_thread_oop(p);\n+    bool is_virtual = java_lang_VirtualThread::is_instance(thread_oop);\n+    jint state = is_virtual ? JvmtiEnvBase::get_vthread_state(thread_oop, p)\n+                            : JvmtiEnvBase::get_thread_state(thread_oop, p);\n+    if (pending == monitor || (waiting == monitor &&\n+        (state & JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER))\n+    ) { \/\/ found a match\n@@ -1205,1 +1215,1 @@\n-\n+#endif \/\/ INCLUDE_JVMTI\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-  \/\/ Get Java threads that are waiting to enter a monitor.\n+  \/\/ Get count Java threads that are waiting to enter or re-enter the specified monitor.\n","filename":"src\/hotspot\/share\/runtime\/threads.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1622,2 +1622,2 @@\n-            (Repeat waiters \"The number of threads that are waiting for the monitor \"\n-                            \"0 if there is no current owner\"\n+            (Repeat waiters \"The total number of threads that are waiting to enter or re-enter \"\n+                            \"the monitor, or waiting to be notified by the monitor.\"\n","filename":"src\/java.se\/share\/data\/jdwp\/jdwp.spec","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -222,1 +222,1 @@\n-            (void)outStream_writeInt(out, info.waiter_count);\n+            (void)outStream_writeInt(out, info.waiter_count + info.notify_waiter_count);\n@@ -226,0 +226,3 @@\n+            for (i = 0; i < info.notify_waiter_count; i++) {\n+                (void)outStream_writeObjectRef(env, out, info.notify_waiters[i]);\n+            }\n@@ -230,0 +233,2 @@\n+        if (info.notify_waiters != NULL )\n+            jvmtiDeallocate(info.notify_waiters);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/ObjectReferenceImpl.c","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -972,1 +972,0 @@\n-  vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003\/TestDescription.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.quick-groups","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,326 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8247972\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003\n+ * DESCRIPTION\n+ *     The test checks if the JVMTI function GetObjectMonitorUsage returns\n+ *     the expected values for the owner, entry_count, water_count\n+ *     fields of JVMTI_monitor_info.\n+ *     The testcases are the following:\n+ *       - unowned object without any waitings\n+ *       - unowned object with waitings to be notified\n+ *       - owned object without any waitings\n+ *       - owned object with N waitings to enter the monitor\n+ *       - owned object with N waitings to be notified\n+ *       - owned object with N waitings to enter, from 0 to N waitings to re-enter,\n+ *         from N to 0 waitings to be notified\n+ *       - all the above scenarios are executed with platform and virtual threads\n+ * @requires vm.continuations\n+ * @requires vm.jvmti\n+ * @run main\/othervm\/native\n+ *     -Djdk.virtualThreadScheduler.parallelism=10\n+ *     -agentlib:ObjectMonitorUsage ObjectMonitorUsage\n+ *\/\n+\n+public class ObjectMonitorUsage {\n+    final static int NUMBER_OF_ENTERING_THREADS = 4;\n+    final static int NUMBER_OF_WAITING_THREADS  = 4;\n+    final static int NUMBER_OF_THREADS = NUMBER_OF_ENTERING_THREADS + NUMBER_OF_WAITING_THREADS;\n+\n+    static Object lockCheck = new Object();\n+\n+    native static int getRes();\n+    native static int waitsToEnter();\n+    native static int setTestedMonitor(Object monitor);\n+    native static void check(Object obj, Thread owner,\n+                             int entryCount, int waiterCount, int notifyWaiterCount);\n+\n+    static void log(String msg) {\n+        System.out.println(msg);\n+    }\n+\n+    static String vtag(boolean isVirtual) {\n+        return isVirtual ? \"virtual\" : \"platform\";\n+    }\n+\n+    static void sleep(long millis) {\n+        try {\n+            Thread.sleep(millis);\n+        } catch (InterruptedException e) {\n+            \/\/ ignore\n+        }\n+    }\n+\n+    static Thread startTask(int idx, TestTask task, boolean isVirtual, String kind) {\n+        Thread thread = isVirtual ? Thread.ofVirtual().name(kind + \"VT\" + idx).start(task)\n+                                  : Thread.ofPlatform().name(kind + \"PT\" + idx).start(task);\n+        task.waitReady();\n+        return thread;\n+    }\n+\n+    static Thread[] startWaitingThreads(boolean isVirtual) {\n+        Thread[] threads = new Thread[NUMBER_OF_WAITING_THREADS];\n+        for (int i = 0; i < NUMBER_OF_WAITING_THREADS; i++) {\n+            \/\/ the WaitingTask has to wait to be notified in lockCheck.wait()\n+            threads[i] = startTask(i, new WaitingTask(), isVirtual, \"Waiting\");\n+        }\n+        return threads;\n+    }\n+\n+    static Thread[] startEnteringThreads(boolean isVirtual) {\n+        Thread[] threads = new Thread[NUMBER_OF_ENTERING_THREADS];\n+        for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n+            \/\/ the EnteringTask has to be blocked at the lockCheck enter\n+            threads[i] = startTask(i, new EnteringTask(), isVirtual, \"Entering\");\n+        }\n+        while (waitsToEnter() < NUMBER_OF_ENTERING_THREADS) {\n+            sleep(1);\n+        }\n+        return threads;\n+    }\n+\n+    static void joinThreads(Thread[] threads) {\n+        try {\n+            for (Thread t : threads) {\n+                t.join();\n+            }\n+        } catch (InterruptedException e) {\n+            throw new Error(\"Unexpected \" + e);\n+        }\n+    }\n+\n+    \/* Scenario #0:\n+     * - owning:         0\n+     * - entering:       0\n+     * - re-entering:    0\n+     * - to be notified: N\n+     *\/\n+    static void test0(boolean isVirtual) {\n+        String vtag = vtag(isVirtual);\n+        log(\"\\n###test0: started \" + vtag);\n+\n+        Thread[] wThreads = startWaitingThreads(isVirtual);\n+\n+        \/\/ entry count: 0\n+        \/\/ count of threads waiting to enter:       0\n+        \/\/ count of threads waiting to re-enter:    0\n+        \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n+        check(lockCheck, null, 0, \/\/ no owner thread\n+              0, \/\/ count of threads waiting to enter: 0\n+              NUMBER_OF_ENTERING_THREADS);\n+\n+        synchronized (lockCheck) {\n+            lockCheck.notifyAll();\n+        }\n+        joinThreads(wThreads);\n+        log(\"###test0: finished \" + vtag);\n+    }\n+\n+    \/* Scenario #1:\n+     * - owning:         1\n+     * - entering:       N\n+     * - re-entering:    0\n+     * - to be notified: 0\n+     *\/\n+    static void test1(boolean isVirtual) {\n+        String vtag = vtag(isVirtual);\n+        log(\"\\n###test1: started \" + vtag);\n+\n+        setTestedMonitor(lockCheck);\n+        Thread[] eThreads = null;\n+\n+        synchronized (lockCheck) {\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter: 0\n+            \/\/ count of threads waiting to re-enter: 0\n+            \/\/ count of threads waiting to be notified: 0\n+            check(lockCheck, Thread.currentThread(), 1, 0, 0);\n+\n+            eThreads = startEnteringThreads(isVirtual);\n+\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n+            \/\/ count of threads waiting to re-enter:    0\n+            \/\/ count of threads waiting to be notified: 0\n+            check(lockCheck, Thread.currentThread(), 1,\n+                  NUMBER_OF_ENTERING_THREADS,\n+                  0 \/* count of threads waiting to be notified: 0 *\/);\n+\n+        }\n+        setTestedMonitor(null);\n+        joinThreads(eThreads);\n+        log(\"###test1: finished \" + vtag);\n+    }\n+\n+    \/* Scenario #2:\n+     * - owning:         1\n+     * - entering:       N\n+     * - re-entering:    0\n+     * - to be notified: N\n+     *\/\n+    static void test2(boolean isVirtual) throws Error {\n+        String vtag = vtag(isVirtual);\n+        log(\"\\n###test2: started \" + vtag);\n+\n+        setTestedMonitor(lockCheck);\n+        Thread[] wThreads = startWaitingThreads(isVirtual);\n+        Thread[] eThreads = null;\n+\n+        synchronized (lockCheck) {\n+            eThreads = startEnteringThreads(isVirtual);\n+\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n+            \/\/ count of threads waiting to re-enter:    0\n+            \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n+            check(lockCheck, Thread.currentThread(), 1,\n+                  NUMBER_OF_ENTERING_THREADS,\n+                  NUMBER_OF_WAITING_THREADS);\n+\n+            lockCheck.notifyAll();\n+        }\n+        setTestedMonitor(null);\n+        joinThreads(wThreads);\n+        joinThreads(eThreads);\n+        log(\"###test2: finished \" + vtag);\n+    }\n+\n+    \/* Scenario #3:\n+     * Initially we have:\n+     * - owning:         1\n+     * - entering:       0\n+     * - re-entering:    0\n+     * - to be notified: N\n+     *\n+     * The threads waiting to be notified are being notified one-by-one\n+     * until all threads are blocked on re-entering the monitor.\n+     * The numbers of entering\/re-entering and waiting threads are checked\n+     * for correctness after each notification.\n+     *\/\n+    static void test3(boolean isVirtual) throws Error {\n+        String vtag = vtag(isVirtual);\n+        log(\"\\n###test3: started \" + vtag);\n+\n+        setTestedMonitor(lockCheck);\n+        Thread[] wThreads = startWaitingThreads(isVirtual);\n+        Thread[] eThreads = null;\n+\n+        synchronized (lockCheck) {\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter:       0\n+            \/\/ count of threads waiting to re-enter:    0\n+            \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n+            check(lockCheck, Thread.currentThread(), 1,\n+                  0, \/\/ number of threads waiting to enter or re-enter\n+                  NUMBER_OF_WAITING_THREADS);\n+\n+            eThreads = startEnteringThreads(isVirtual);\n+\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n+            \/\/ count of threads waiting to re-enter:    0\n+            \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n+            check(lockCheck, Thread.currentThread(), 1,\n+                  NUMBER_OF_ENTERING_THREADS,\n+                  NUMBER_OF_WAITING_THREADS);\n+\n+            for (int i = 0; i < NUMBER_OF_WAITING_THREADS; i++) {\n+                lockCheck.notify(); \/\/ notify waiting threads one by one\n+                \/\/ now the notified WaitingTask has to be blocked on the lockCheck re-enter\n+\n+                \/\/ entry count: 1\n+                \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n+                \/\/ count of threads waiting to re-enter:    i + 1\n+                \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS - i - 1\n+                check(lockCheck, Thread.currentThread(), 1,\n+                      NUMBER_OF_ENTERING_THREADS + i + 1,\n+                      NUMBER_OF_WAITING_THREADS  - i - 1);\n+            }\n+        }\n+        setTestedMonitor(null);\n+        joinThreads(wThreads);\n+        joinThreads(eThreads);\n+        log(\"###test3: finished \" + vtag);\n+    }\n+\n+    static void test(boolean isVirtual) {\n+        test0(isVirtual);\n+        test1(isVirtual);\n+        test2(isVirtual);\n+        test3(isVirtual);\n+    }\n+\n+    public static void main(String args[]) {\n+        log(\"\\n###main: started\\n\");\n+        check(lockCheck, null, 0, 0, 0);\n+\n+        test(false); \/\/ test platform threads\n+        test(true);  \/\/ test virtual threads\n+\n+        check(lockCheck, null, 0, 0, 0);\n+        if (getRes() > 0) {\n+            throw new RuntimeException(\"Failed status returned from the agent\");\n+        }\n+        log(\"\\n###main: finished\\n\");\n+    }\n+\n+    static abstract class TestTask implements Runnable {\n+        public volatile boolean ready = false;\n+        public abstract void run();\n+\n+        public void waitReady() {\n+            try {\n+                while (!ready) {\n+                    Thread.sleep(10);\n+                }\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected \" + e);\n+            }\n+        }\n+    }\n+\n+    static class EnteringTask extends TestTask {\n+        public void run() {\n+            ready = true;\n+            synchronized (lockCheck) {\n+            }\n+        }\n+    }\n+\n+    static class WaitingTask extends TestTask {\n+         public void run() {\n+            synchronized (lockCheck) {\n+                try {\n+                    ready = true;\n+                    lockCheck.wait();\n+                } catch (InterruptedException e) {\n+                    throw new Error(\"Unexpected \" + e);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/ObjectMonitorUsage\/ObjectMonitorUsage.java","additions":326,"deletions":0,"binary":false,"changes":326,"status":"added"},{"patch":"@@ -0,0 +1,219 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.hpp\"\n+\n+extern \"C\" {\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+static jvmtiEnv *jvmti = nullptr;\n+static jrawMonitorID event_lock = nullptr;\n+static jint result = PASSED;\n+static int check_idx = 0;\n+static int waits_to_enter = 0;\n+static jobject tested_monitor = nullptr;\n+\n+static bool is_tested_monitor(JNIEnv *jni, jobject monitor) {\n+  if (tested_monitor == nullptr) {\n+    return false; \/\/ tested_monitor was not set yet\n+  }\n+  return jni->IsSameObject(monitor, tested_monitor) == JNI_TRUE;\n+}\n+\n+JNIEXPORT void JNICALL\n+MonitorContendedEnter(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread, jobject monitor) {\n+  RawMonitorLocker rml(jvmti, jni, event_lock);\n+  if (is_tested_monitor(jni, monitor)) {\n+    waits_to_enter++;\n+  }\n+}\n+\n+JNIEXPORT void JNICALL\n+MonitorContendedEntered(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread, jobject monitor) {\n+  RawMonitorLocker rml(jvmti, jni, event_lock);\n+  if (is_tested_monitor(jni, monitor)) {\n+    waits_to_enter--;\n+  }\n+}\n+\n+\n+jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jint res;\n+  jvmtiError err;\n+  jvmtiCapabilities caps;\n+  jvmtiEventCallbacks callbacks;\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == nullptr) {\n+    LOG(\"Wrong result of a valid call to GetEnv !\\n\");\n+    return JNI_ERR;\n+  }\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  check_jvmti_error(err, \"Agent_Initialize: error in JVMTI GetPotentialCapabilities\");\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  check_jvmti_error(err, \"Agent_Initialize: error in JVMTI AddCapabilities\");\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  check_jvmti_error(err, \"Agent_Initialize: error in JVMTI GetCapabilities\");\n+\n+  if (!caps.can_get_monitor_info) {\n+    LOG(\"Warning: GetObjectMonitorUsage is not implemented\\n\");\n+  }\n+  if (!caps.can_generate_monitor_events) {\n+    LOG(\"Warning: Monitor events are not implemented\\n\");\n+    return JNI_ERR;\n+  }\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.MonitorContendedEnter   = &MonitorContendedEnter;\n+  callbacks.MonitorContendedEntered = &MonitorContendedEntered;\n+\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(jvmtiEventCallbacks));\n+  check_jvmti_error(err, \"Agent_Initialize: error in JVMTI SetEventCallbacks\");\n+\n+  event_lock = create_raw_monitor(jvmti, \"Events Monitor\");\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+static void print_monitor_info(JNIEnv *jni, jvmtiMonitorUsage &inf) {\n+  jvmtiError err;\n+  jvmtiThreadInfo tinf;\n+\n+  LOG(\">>> [%d]\\n\", check_idx);\n+  if (inf.owner == nullptr) {\n+    LOG(\">>>          owner:               none (0x0)\\n\");\n+  } else {\n+    err = jvmti->GetThreadInfo(inf.owner, &tinf);\n+    check_jvmti_status(jni, err, \"error in JVMTI GetThreadInfo\");\n+    LOG(\">>>          owner:               %s (0x%p)\\n\",\n+        tinf.name, inf.owner);\n+    deallocate(jvmti, jni, tinf.name);\n+  }\n+  LOG(\">>>          entry_count:         %d\\n\", inf.entry_count);\n+  LOG(\">>>          waiter_count:        %d\\n\", inf.waiter_count);\n+  LOG(\">>>          notify_waiter_count: %d\\n\", inf.notify_waiter_count);\n+\n+  if (inf.waiter_count > 0) {\n+    LOG(\">>>  waiters:\\n\");\n+    for (int j = 0; j < inf.waiter_count; j++) {\n+      err = jvmti->GetThreadInfo(inf.waiters[j], &tinf);\n+      check_jvmti_status(jni, err, \"error in JVMTI GetThreadInfo\");\n+      LOG(\">>>                %2d: %s (0x%p)\\n\",\n+          j, tinf.name, inf.waiters[j]);\n+      deallocate(jvmti, jni, tinf.name);\n+    }\n+  }\n+  if (inf.notify_waiter_count > 0) {\n+    LOG(\">>>  notify_waiters:\\n\");\n+    for (int j = 0; j < inf.notify_waiter_count; j++) {\n+      err = jvmti->GetThreadInfo(inf.notify_waiters[j], &tinf);\n+      check_jvmti_status(jni, err, \"error in JVMTI GetThreadInfo\");\n+      LOG(\">>>                %2d: %s (0x%p)\\n\",\n+          j, tinf.name, inf.notify_waiters[j]);\n+      deallocate(jvmti, jni, tinf.name);\n+    }\n+  }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_ObjectMonitorUsage_check(JNIEnv *jni, jclass cls, jobject obj, jthread owner,\n+        jint entryCount, jint waiterCount, jint notifyWaiterCount) {\n+  jvmtiError err;\n+  jvmtiMonitorUsage inf;\n+\n+  check_idx++;\n+\n+  err = jvmti->GetObjectMonitorUsage(obj, &inf);\n+  check_jvmti_status(jni, err, \"error in JVMTI GetObjectMonitorUsage\");\n+\n+  print_monitor_info(jni, inf);\n+\n+  if (!jni->IsSameObject(owner, inf.owner)) {\n+    LOG(\"(%d) unexpected owner: 0x%p\\n\", check_idx, inf.owner);\n+    result = STATUS_FAILED;\n+  }\n+  if (inf.entry_count != entryCount) {\n+    LOG(\"(%d) entry_count expected: %d, actually: %d\\n\",\n+        check_idx, entryCount, inf.entry_count);\n+    result = STATUS_FAILED;\n+  }\n+  if (inf.waiter_count != waiterCount) {\n+    LOG(\"(%d) waiter_count expected: %d, actually: %d\\n\",\n+        check_idx, waiterCount, inf.waiter_count);\n+    result = STATUS_FAILED;\n+  }\n+  if (inf.notify_waiter_count != notifyWaiterCount) {\n+    LOG(\"(%d) notify_waiter_count expected: %d, actually: %d\\n\",\n+        check_idx, notifyWaiterCount, inf.notify_waiter_count);\n+    result = STATUS_FAILED;\n+  }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_ObjectMonitorUsage_setTestedMonitor(JNIEnv *jni, jclass cls, jobject monitor) {\n+  jvmtiError err;\n+  jvmtiEventMode event_mode = (monitor != nullptr) ? JVMTI_ENABLE : JVMTI_DISABLE;\n+\n+  RawMonitorLocker rml(jvmti, jni, event_lock);\n+\n+  if (tested_monitor != nullptr) {\n+    jni->DeleteGlobalRef(tested_monitor);\n+  }\n+  tested_monitor = (monitor != nullptr) ? jni->NewGlobalRef(monitor) : nullptr;\n+  waits_to_enter = 0;\n+\n+  err = jvmti->SetEventNotificationMode(event_mode, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, nullptr);\n+  check_jvmti_status(jni, err, \"setTestedMonitor: error in JVMTI SetEventNotificationMode #1\");\n+\n+  err = jvmti->SetEventNotificationMode(event_mode, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, nullptr);\n+  check_jvmti_status(jni, err, \"setTestedMonitor: error in JVMTI SetEventNotificationMode #2\");\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_ObjectMonitorUsage_waitsToEnter(JNIEnv *jni, jclass cls) {\n+  RawMonitorLocker rml(jvmti, jni, event_lock);\n+  return waits_to_enter;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_ObjectMonitorUsage_getRes(JNIEnv *jni, jclass cls) {\n+  return result;\n+}\n+\n+} \/\/ exnern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/ObjectMonitorUsage\/libObjectMonitorUsage.cpp","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+    final static boolean ADD_DELAYS_FOR_RACES = false;\n@@ -44,1 +45,3 @@\n-    native static void check(int i, Object o, Thread owner, int ec, int wc);\n+    native static void check(int index, Object syncObject, Thread owner, int entryCount,\n+                             Thread waiterThread, int waiterCount,\n+                             Thread notifyWaiterThread, int notifyWaiterCount);\n@@ -53,0 +56,1 @@\n+        Thread mainThread = Thread.currentThread();\n@@ -58,1 +62,1 @@\n-            runn[i] = new objmonusage001a(i, syncObject[i]);\n+            runn[i] = new objmonusage001a(mainThread, i, syncObject[i]);\n@@ -70,0 +74,23 @@\n+\n+                \/\/ Check #2:\n+                \/\/ - owner == main:\n+                \/\/       main thread owns the monitor and worker thread\n+                \/\/       is in wait() and is not notified\n+                \/\/ - entry_count == 1:\n+                \/\/       main thread reentered 1 time\n+                \/\/ - waiter_count == 0:\n+                \/\/       main thread has already reentered the monitor and worker thread\n+                \/\/       is in wait() and is not notified so it is not waiting to reenter\n+                \/\/       the monitor\n+                \/\/ - waiter_thread == null:\n+                \/\/       no thread is waiting to reenter the monitor\n+                \/\/ - notify_waiter_count == 1:\n+                \/\/       worker thread is in wait() and is not notified\n+                \/\/ - notify_waiter_thread == runn[i]:\n+                \/\/       worker thread is in wait() and is not notified\n+                \/\/\n+                \/\/ This is a stable verification point because the worker thread is in wait()\n+                \/\/ and is not notified and the main thread is doing the verification.\n+                \/\/\n+                check(NUMBER_OF_THREADS + i, syncObject[i], mainThread, 1,\n+                      null, 0, runn[i], 1);\n@@ -71,1 +98,23 @@\n-            check(NUMBER_OF_THREADS + i, syncObject[i], null, 0, 1);\n+\n+            \/\/ Check #3:\n+            \/\/ - owner == null:\n+            \/\/       main thread does not own the monitor and worker thread is in\n+            \/\/       wait() and is not notified so there is no owner\n+            \/\/ - entry_count == 0:\n+            \/\/       no owner so entry_count is 0\n+            \/\/ - waiter_count == 0:\n+            \/\/       main thread is not trying to enter the monitor and worker thread\n+            \/\/       is in wait() and is not notified so it is not waiting to reenter\n+            \/\/       the monitor\n+            \/\/ - waiter_thread == null:\n+            \/\/       no thread is waiting to reenter the monitor\n+            \/\/ - notify_waiter_count == 1:\n+            \/\/       worker thread is in wait() and is not notified\n+            \/\/ - notify_waiter_thread == runn[i]:\n+            \/\/       worker thread is in wait() and is not notified\n+            \/\/\n+            \/\/ This is a stable verification point because the worker thread is in wait()\n+            \/\/ and is not notified and the main thread is doing the verification.\n+            \/\/\n+            check((NUMBER_OF_THREADS * 2) + i, syncObject[i], null, 0,\n+                  null, 0, runn[i], 1);\n@@ -90,0 +139,1 @@\n+    Thread mainThread;\n@@ -91,1 +141,1 @@\n-    int ind;\n+    int index;\n@@ -93,2 +143,3 @@\n-    public objmonusage001a(int i, Object s) {\n-        ind = i;\n+    public objmonusage001a(Thread mt, int i, Object s) {\n+        mainThread = mt;\n+        index = i;\n@@ -100,1 +151,20 @@\n-            objmonusage001.check(ind, syncObject, this, 1, 1);\n+            \/\/ Check #1:\n+            \/\/ - owner == this_thread:\n+            \/\/       this worker thread is owner\n+            \/\/ - entry_count == 1:\n+            \/\/       worker thread entered 1 time\n+            \/\/ - waiter_count == 0:\n+            \/\/       main thread is in wait() and is not notified so it is not\n+            \/\/       waiting to reenter the monitor\n+            \/\/ - waiter_thread == null:\n+            \/\/       no thread is waiting to reenter the monitor\n+            \/\/ - notify_waiter_count == 1:\n+            \/\/        main thread is in wait() and is not notified\n+            \/\/ - notify_waiter_thread == mainThread:\n+            \/\/       main thread is in wait() and is not notified\n+            \/\/\n+            \/\/ This is a stable verification point because the main thread is in wait()\n+            \/\/ and is not notified and this worker thread is doing the verification.\n+            \/\/\n+            objmonusage001.check(index, syncObject, this, 1,\n+                                 null, 0, mainThread, 1);\n@@ -102,0 +172,1 @@\n+\n@@ -104,0 +175,4 @@\n+\n+                if (objmonusage001.ADD_DELAYS_FOR_RACES) {\n+                    Thread.sleep(1000);\n+                }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage001.java","additions":83,"deletions":8,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,8 @@\n- *     The test exercises JVMTI function GetObjectMonitorUsage.\n+ *     The test exercises JVMTI function GetObjectMonitorUsage. The main\n+ *     thread uses a monitor to do coordinated launches of work threads.\n+ *     Each worker thread verifies expected GetObjectMonitorUsage values\n+ *     when it gets going and the main thread also verifies expected\n+ *     GetObjectMonitorUsage values once the worker thread returns\n+ *     control flow to the main thread. The test scenario is repeated\n+ *     for a fixed number of threads.\n+ *\n@@ -39,1 +46,1 @@\n- * @run main\/othervm\/native -agentlib:objmonusage001 nsk.jvmti.GetObjectMonitorUsage.objmonusage001\n+ * @run main\/othervm\/native -agentlib:objmonusage001=printdump nsk.jvmti.GetObjectMonitorUsage.objmonusage001\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage001\/TestDescription.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -97,1 +97,3 @@\n-        jthread owner, jint entryCount, jint waiterCount) {\n+        jthread owner, jint entryCount,\n+        jthread waiterThread, jint waiterCount,\n+        jthread notifyWaiterThread, jint notifyWaiterCount) {\n@@ -103,1 +105,1 @@\n-    if (result == STATUS_FAILED) {\n+    if (result == STATUS_FAILED && printdump != JNI_TRUE) {\n@@ -155,1 +157,1 @@\n-        printf(\"(%d) entry_count expected: %d, actually: %d\\n\",\n+        printf(\"FAILED: (%d) entry_count expected: %d, actually: %d\\n\",\n@@ -161,1 +163,1 @@\n-        printf(\"(%d) waiter_count expected: %d, actually: %d\\n\",\n+        printf(\"FAILED: (%d) waiter_count expected: %d, actually: %d\\n\",\n@@ -165,0 +167,22 @@\n+\n+    if (inf.waiters != nullptr &&\n+        !env->IsSameObject(waiterThread, inf.waiters[0])) {\n+        jvmti->GetThreadInfo(inf.waiters[0], &tinf);\n+        printf(\"FAILED: (%d) unexpected waiterThread: %s (0x%p)\\n\", i,\n+               tinf.name, inf.waiters[0]);\n+        result = STATUS_FAILED;\n+    }\n+\n+    if (inf.notify_waiter_count != notifyWaiterCount) {\n+        printf(\"FAILED: (%d) notify_waiter_count expected: %d, actually: %d\\n\",\n+               i, notifyWaiterCount, inf.notify_waiter_count);\n+        result = STATUS_FAILED;\n+    }\n+\n+    if (inf.notify_waiters != nullptr &&\n+        !env->IsSameObject(notifyWaiterThread, inf.notify_waiters[0])) {\n+        jvmti->GetThreadInfo(inf.notify_waiters[0], &tinf);\n+        printf(\"FAILED: (%d) unexpected waiterThread: %s (0x%p)\\n\", i,\n+               tinf.name, inf.notify_waiters[0]);\n+        result = STATUS_FAILED;\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage001\/objmonusage001.cpp","additions":28,"deletions":4,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetObjectMonitorUsage;\n-\n-import java.io.PrintStream;\n-\n-public class objmonusage003 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-    final static int NUMBER_OF_THREADS = 16;\n-    final static int WAIT_TIME = 100;\n-    volatile static boolean waiterInLockCheck = false;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"objmonusage003\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load objmonusage003 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    static Object lockStart = new Object();\n-    static Object lockCheck = new Object();\n-\n-    native static int getRes();\n-    native static void check(Object obj, Thread owner,\n-                             int entryCount, int waiterCount);\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        check(lockCheck, null, 0, 0);\n-\n-        synchronized (lockCheck) {\n-            check(lockCheck, Thread.currentThread(), 1, 0);\n-        }\n-\n-        WaiterThread thr[] = new WaiterThread[NUMBER_OF_THREADS];\n-        for (int i = 0; i < NUMBER_OF_THREADS; i++) {\n-            thr[i] = new WaiterThread();\n-            synchronized (lockStart) {\n-                thr[i].start();\n-                try {\n-                    lockStart.wait();\n-                } catch (InterruptedException e) {\n-                    throw new Error(\"Unexpected \" + e);\n-                }\n-            }\n-            synchronized (lockCheck) {\n-                while (!waiterInLockCheck) {\n-                    try {\n-                        lockCheck.wait(WAIT_TIME);\n-                    } catch (InterruptedException e) {\n-                        throw new Error(\"Unexpected \" + e);\n-                    }\n-                }\n-                waiterInLockCheck = false;\n-            }\n-            check(lockCheck, null, 0, i + 1);\n-        }\n-\n-        synchronized (lockCheck) {\n-            lockCheck.notifyAll();\n-        }\n-\n-        for (int i = 0; i < NUMBER_OF_THREADS; i++) {\n-            try {\n-                thr[i].join();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected \" + e);\n-            }\n-        }\n-\n-        check(lockCheck, null, 0, 0);\n-        return getRes();\n-    }\n-\n-    static class WaiterThread extends Thread {\n-        public synchronized void run() {\n-            synchronized (lockStart) {\n-                lockStart.notify();\n-            }\n-            synchronized (lockCheck) {\n-                try {\n-                    waiterInLockCheck = true;\n-                    lockCheck.wait();\n-                } catch (InterruptedException e) {\n-                    throw new Error(\"Unexpected \" + e);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test checks if JVMTI function GetObjectMonitorUsage returns\n- *     the expected values for the owner, entry_count, water_count\n- *     fields of JVMTI_monitor_info. The tescases are the following:\n- *       - unowned object without any waitings\n- *       - owned object without any waitings\n- *       - unowned object with waitings through Object.wait()\n- *       - unowned object has been waiting\n- * COMMENTS\n- *     Fixed according to 4669812 bug.\n- *     Ported from JVMDI test nsk\/jvmdi\/GetMonitorInfo\/getmoninfo003.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:objmonusage003 nsk.jvmti.GetObjectMonitorUsage.objmonusage003\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003\/TestDescription.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"objmonusage003.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003\/libobjmonusage003.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.hpp\"\n-#include \"JVMTITools.hpp\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti = nullptr;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static int count = 0;\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_objmonusage003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_objmonusage003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_objmonusage003(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-    jvmtiError err;\n-\n-    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == nullptr) {\n-        printf(\"Wrong result of a valid call to GetEnv !\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (!caps.can_get_monitor_info) {\n-        printf(\"Warning: GetObjectMonitorUsage is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetObjectMonitorUsage_objmonusage003_check(JNIEnv *env,\n-        jclass cls, jobject obj, jthread owner,\n-        jint entryCount, jint waiterCount) {\n-    jvmtiError err;\n-    jvmtiMonitorUsage inf;\n-    jvmtiThreadInfo tinf;\n-    int j;\n-\n-    count++;\n-\n-    err = jvmti->GetObjectMonitorUsage(obj, &inf);\n-    if (err == JVMTI_ERROR_MUST_POSSESS_CAPABILITY &&\n-            !caps.can_get_monitor_info) {\n-        \/* Ok, it's expected *\/\n-        return;\n-    } else if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMonitorInfo#%d) unexpected error: %s (%d)\\n\",\n-               count, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        if (inf.owner == nullptr) {\n-            printf(\">>> [%2d]    owner: none (0x0)\\n\", count);\n-        } else {\n-            err = jvmti->GetThreadInfo(inf.owner, &tinf);\n-            printf(\">>> [%2d]    owner: %s (0x%p)\\n\",\n-                   count, tinf.name, inf.owner);\n-        }\n-        printf(\">>>   entry_count: %d\\n\", inf.entry_count);\n-        printf(\">>>  waiter_count: %d\\n\", inf.waiter_count);\n-        if (inf.waiter_count > 0) {\n-            printf(\">>>       waiters:\\n\");\n-            for (j = 0; j < inf.waiter_count; j++) {\n-                err = jvmti->GetThreadInfo(inf.waiters[j], &tinf);\n-                printf(\">>>                %2d: %s (0x%p)\\n\",\n-                       j, tinf.name, inf.waiters[j]);\n-            }\n-        }\n-    }\n-\n-    if (!env->IsSameObject(owner, inf.owner)) {\n-        printf(\"(%d) unexpected owner: 0x%p\\n\", count, inf.owner);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (inf.entry_count != entryCount) {\n-        printf(\"(%d) entry_count expected: %d, actually: %d\\n\",\n-               count, entryCount, inf.entry_count);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (inf.waiter_count != waiterCount) {\n-        printf(\"(%d) waiter_count expected: %d, actually: %d\\n\",\n-               count, waiterCount, inf.waiter_count);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetObjectMonitorUsage_objmonusage003_getRes(JNIEnv *env, jclass cls) {\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003\/objmonusage003.cpp","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"}]}