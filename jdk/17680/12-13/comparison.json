{"files":[{"patch":"@@ -972,1 +972,0 @@\n-  vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003\/TestDescription.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.quick-groups","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,249 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8247972\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003\n- * DESCRIPTION\n- *     The test checks if JVMTI function GetObjectMonitorUsage returns\n- *     the expected values for the owner, entry_count, water_count\n- *     fields of JVMTI_monitor_info. The tescases are the following:\n- *       - unowned object without any waitings\n- *       - owned object without any waitings\n- *       - owned object with N waitings to enter the monitor\n- *       - owned object with N waitings to be notified\n- *       - owned object with N waitings to enter, from 0 to N waitings to re-enter,\n- *         from N to 0 waitings to be notified\n- *       - unowned object with waitings through Object.wait()\n- *       - all the above is checked for both platform and virtual threads\n- * @requires vm.jvmti\n- * @compile ObjectMonitorUsage.java\n- * @run main\/othervm\/native -agentlib:ObjectMonitorUsage ObjectMonitorUsage\n- *\/\n-\n-public class ObjectMonitorUsage {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-    final static int NUMBER_OF_ENTERING_THREADS = 4;\n-    final static int NUMBER_OF_WAITING_THREADS  = 4;\n-    final static int NUMBER_OF_THREADS = NUMBER_OF_ENTERING_THREADS + NUMBER_OF_WAITING_THREADS;\n-\n-    static Object lockCheck = new Object();\n-    static Thread[] thr = new Thread[NUMBER_OF_THREADS];\n-\n-    native static int getRes();\n-    native static void check(Object obj, Thread owner,\n-                             int entryCount, int waiterCount, int notifyWaiterCount);\n-\n-    static Thread startTask(TestTask task, boolean isVirtual) {\n-        Thread thread = isVirtual ? Thread.ofVirtual().start(task)\n-                                  : Thread.ofPlatform().start(task);\n-        task.waitReady();\n-        return thread;\n-    }\n-\n-    \/* Scenario #1:\n-     * - non-zero entering threads\n-     * - zero re-entering threads\n-     * - zero threads waiting to be notified\n-     *\/\n-    static void test1(boolean isVirtual) throws Error {\n-        synchronized (lockCheck) {\n-            \/\/ entry count: 1\n-            \/\/ count of threads waiting to enter: 0\n-            \/\/ count of threads waiting to re-enter: 0\n-            \/\/ count of threads waiting to be notified: 0\n-            check(lockCheck, Thread.currentThread(), 1, 0, 0);\n-\n-            for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n-                \/\/ this EnteringTask has to be blocked on the lockCheck enter\n-                thr[i] = startTask(new EnteringTask(), isVirtual);\n-            }\n-            \/\/ entry count: 1\n-            \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n-            \/\/ count of threads waiting to re-enter:    0\n-            \/\/ count of threads waiting to be notified: 0\n-            check(lockCheck, Thread.currentThread(), 1,\n-                  NUMBER_OF_ENTERING_THREADS,\n-                  0 \/* count of threads waiting to be notified: 0 *\/);\n-        }\n-        for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n-            try {\n-                thr[i].join();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected \" + e);\n-            }\n-        }\n-    }\n-\n-    \/* Scenario #2:\n-     * - non-zero entering threads\n-     * - zero re-entering threads\n-     * - non-zero waiting to be notified\n-     *\/\n-    static void test2(boolean isVirtual) throws Error {\n-        for (int i = NUMBER_OF_ENTERING_THREADS; i < NUMBER_OF_THREADS; i++) {\n-            \/\/ the WaitingTask has to wait to be notified in a lockCheck.wait()\n-            thr[i] = startTask(new WaitingTask(), isVirtual);\n-        }\n-        synchronized (lockCheck) {\n-            for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n-                \/\/ this EnteringTask has to be blocked on the lockCheck enter\n-                thr[i] = startTask(new EnteringTask(), isVirtual);\n-            }\n-            \/\/ entry count: 1\n-            \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n-            \/\/ count of threads waiting to re-enter:    0\n-            \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n-            check(lockCheck, Thread.currentThread(), 1,\n-                  NUMBER_OF_ENTERING_THREADS,\n-                  NUMBER_OF_WAITING_THREADS);\n-\n-            lockCheck.notifyAll();\n-        }\n-        for (int i = 0; i < NUMBER_OF_THREADS; i++) {\n-            try {\n-                thr[i].join();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected \" + e);\n-            }\n-        }\n-    }\n-\n-    \/* Scenario #3:\n-     * Initially we have:\n-     * - zero entering threads\n-     * - zero re-entering threads\n-     * - non-zero threads waiting to be notified\n-     *\n-     * The threads waiting to be notified are being notified one-by-one\n-     * until all threads are blocked on re-entering the monitor.\n-     * The numbers of entering\/re-entering and waiting threads are checked\n-     * for correctness after each notification.\n-     *\/\n-    static void test3(boolean isVirtual) throws Error {\n-        for (int i = NUMBER_OF_ENTERING_THREADS; i < NUMBER_OF_THREADS; i++) {\n-            \/\/ the WaitingTask has to wait to be notified in a lockCheck.wait()\n-            thr[i] = startTask(new WaitingTask(), isVirtual);\n-        }\n-        synchronized (lockCheck) {\n-            \/\/ entry count: 1\n-            \/\/ count of threads waiting to enter:       0\n-            \/\/ count of threads waiting to re-enter:    0\n-            \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n-            check(lockCheck, Thread.currentThread(), 1,\n-                  0, \/\/ number of threads waiting to enter or re-enter\n-                  NUMBER_OF_WAITING_THREADS);\n-\n-            for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n-                \/\/ this EnteringTask has to be blocked on the lockCheck enter\n-                thr[i] = startTask(new EnteringTask(), isVirtual);\n-            }\n-\n-            \/\/ entry count: 1\n-            \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n-            \/\/ count of threads waiting to re-enter:    0\n-            \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n-            check(lockCheck, Thread.currentThread(), 1,\n-                  NUMBER_OF_ENTERING_THREADS,\n-                  NUMBER_OF_WAITING_THREADS);\n-\n-            for (int i = 0; i < NUMBER_OF_WAITING_THREADS; i++) {\n-                lockCheck.notify();\n-                \/\/ now the notified WaitingTask has to be blocked on the lockCheck re-enter\n-\n-                \/\/ entry count: 1\n-                \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n-                \/\/ count of threads waiting to re-enter:    i + 1\n-                \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS - i - 1\n-                check(lockCheck, Thread.currentThread(), 1,\n-                      NUMBER_OF_ENTERING_THREADS + i + 1,\n-                      NUMBER_OF_WAITING_THREADS  - i - 1);\n-            }\n-        }\n-        for (int i = 0; i < NUMBER_OF_THREADS; i++) {\n-            try {\n-                thr[i].join();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected \" + e);\n-            }\n-        }\n-    }\n-\n-    public static void main(String args[]) {\n-        check(lockCheck, null, 0, 0, 0);\n-\n-        \/\/ test platform threads\n-        test1(false);\n-        test2(false);\n-        test3(false);\n-\n-        \/\/ test virtual threads\n-        test1(false);\n-        test2(false);\n-        test3(false);\n-\n-        check(lockCheck, null, 0, 0, 0);\n-        if (getRes() > 0) {\n-            throw new RuntimeException(\"Failed status returned from the agent\");\n-        }\n-    }\n-\n-    static abstract class TestTask implements Runnable {\n-        public volatile boolean ready = false;\n-        public abstract void run();\n-\n-        public void waitReady() {\n-            try {\n-                while (!ready) {\n-                    Thread.sleep(10);\n-                }\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected \" + e);\n-            }\n-        }\n-    }\n-\n-    static class EnteringTask extends TestTask {\n-        public void run() {\n-            ready = true;\n-            synchronized (lockCheck) {\n-            }\n-        }\n-    }\n-\n-    static class WaitingTask extends TestTask {\n-         public void run() {\n-            synchronized (lockCheck) {\n-                try {\n-                    ready = true;\n-                    lockCheck.wait();\n-                } catch (InterruptedException e) {\n-                    throw new Error(\"Unexpected \" + e);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetObjectMonitorUsage\/ObjectMonitorUsage.java","additions":0,"deletions":249,"binary":false,"changes":249,"status":"deleted"},{"patch":"@@ -1,162 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"jvmti_common.h\"\n-\n-extern \"C\" {\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti = nullptr;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static int count = 0;\n-\n-jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-  jint res;\n-  jvmtiError err;\n-\n-  if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n-    printdump = JNI_TRUE;\n-  }\n-\n-  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-  if (res != JNI_OK || jvmti == nullptr) {\n-    LOG(\"Wrong result of a valid call to GetEnv !\\n\");\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->GetPotentialCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    LOG(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-        TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->AddCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    LOG(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-        TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->GetCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    LOG(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-        TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  if (!caps.can_get_monitor_info) {\n-    LOG(\"Warning: GetObjectMonitorUsage is not implemented\\n\");\n-  }\n-\n-  return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n-  return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n-  return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_ObjectMonitorUsage_check(JNIEnv *env,\n-        jclass cls, jobject obj, jthread owner,\n-        jint entryCount, jint waiterCount, jint notifyWaiterCount) {\n-  jvmtiError err;\n-  jvmtiMonitorUsage inf;\n-  jvmtiThreadInfo tinf;\n-  int j;\n-\n-  count++;\n-\n-  err = jvmti->GetObjectMonitorUsage(obj, &inf);\n-  if (err == JVMTI_ERROR_MUST_POSSESS_CAPABILITY && !caps.can_get_monitor_info) {\n-    return; \/* Ok, it's expected *\/\n-  } else if (err != JVMTI_ERROR_NONE) {\n-    LOG(\"(GetMonitorInfo#%d) unexpected error: %s (%d)\\n\",\n-        count, TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-\n-  if (printdump == JNI_TRUE) {\n-    if (inf.owner == nullptr) {\n-      LOG(\">>> [%2d]    owner: none (0x0)\\n\", count);\n-    } else {\n-      err = jvmti->GetThreadInfo(inf.owner, &tinf);\n-      LOG(\">>> [%2d]    owner: %s (0x%p)\\n\",\n-          count, tinf.name, inf.owner);\n-    }\n-    LOG(\">>>   entry_count: %d\\n\", inf.entry_count);\n-    LOG(\">>>  waiter_count: %d\\n\", inf.waiter_count);\n-    if (inf.waiter_count > 0) {\n-        LOG(\">>>       waiters:\\n\");\n-        for (j = 0; j < inf.waiter_count; j++) {\n-          err = jvmti->GetThreadInfo(inf.waiters[j], &tinf);\n-          LOG(\">>>                %2d: %s (0x%p)\\n\",\n-              j, tinf.name, inf.waiters[j]);\n-        }\n-    }\n-  }\n-\n-  if (!env->IsSameObject(owner, inf.owner)) {\n-    LOG(\"(%d) unexpected owner: 0x%p\\n\", count, inf.owner);\n-    result = STATUS_FAILED;\n-  }\n-\n-  if (inf.entry_count != entryCount) {\n-    LOG(\"(%d) entry_count expected: %d, actually: %d\\n\",\n-        count, entryCount, inf.entry_count);\n-    result = STATUS_FAILED;\n-  }\n-\n-  if (inf.waiter_count != waiterCount) {\n-    LOG(\"(%d) waiter_count expected: %d, actually: %d\\n\",\n-        count, waiterCount, inf.waiter_count);\n-    result = STATUS_FAILED;\n-  }\n-\n-  if (inf.notify_waiter_count != notifyWaiterCount) {\n-    LOG(\"(%d) notify_waiter_count expected: %d, actually: %d\\n\",\n-        count, notifyWaiterCount, inf.notify_waiter_count);\n-    result = STATUS_FAILED;\n-  }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_ObjectMonitorUsage_getRes(JNIEnv *env, jclass cls) {\n-  return result;\n-}\n-\n-} \/\/ exnern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetObjectMonitorUsage\/libObjectMonitorUsage.cpp","additions":0,"deletions":162,"binary":false,"changes":162,"status":"deleted"},{"patch":"@@ -0,0 +1,310 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8247972\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003\n+ * DESCRIPTION\n+ *     The test checks if the JVMTI function GetObjectMonitorUsage returns\n+ *     the expected values for the owner, entry_count, water_count\n+ *     fields of JVMTI_monitor_info.\n+ *     The testcases are the following:\n+ *       - unowned object without any waitings\n+ *       - unowned object with waitings to be notified\n+ *       - owned object without any waitings\n+ *       - owned object with N waitings to enter the monitor\n+ *       - owned object with N waitings to be notified\n+ *       - owned object with N waitings to enter, from 0 to N waitings to re-enter,\n+ *         from N to 0 waitings to be notified\n+ *       - all the above scenarios are executed with platform and virtual threads\n+ * @requires vm.jvmti\n+ * @run main\/othervm\/native -agentlib:ObjectMonitorUsage ObjectMonitorUsage\n+ *\/\n+\n+public class ObjectMonitorUsage {\n+\n+    final static int NUMBER_OF_ENTERING_THREADS = 4;\n+    final static int NUMBER_OF_WAITING_THREADS  = 4;\n+    final static int NUMBER_OF_THREADS = NUMBER_OF_ENTERING_THREADS + NUMBER_OF_WAITING_THREADS;\n+\n+    static Object lockCheck = new Object();\n+    static Thread[] thr = new Thread[NUMBER_OF_THREADS];\n+\n+    native static int getRes();\n+    native static void check(Object obj, Thread owner,\n+                             int entryCount, int waiterCount, int notifyWaiterCount);\n+\n+    static void log(String msg) {\n+        System.out.println(msg);\n+    }\n+\n+    static String vtag(boolean isVirtual) {\n+        return isVirtual ? \"virtual\" : \"platform\";\n+    }\n+\n+    static Thread startTask(int idx, TestTask task, boolean isVirtual, String kind) {\n+        Thread thread = isVirtual ? Thread.ofVirtual().name(kind + \"VT\" + idx).start(task)\n+                                  : Thread.ofPlatform().name(kind + \"PT\" + idx).start(task);\n+        task.waitReady();\n+        return thread;\n+    }\n+\n+    \/* Scenario #0:\n+     * - owning:         0\n+     * - entering:       0\n+     * - re-entering:    0\n+     * - to be notified: N\n+     *\/\n+    static void test0(boolean isVirtual) {\n+        String vtag = vtag(isVirtual);\n+        log(\"\\n###test0: started \" + vtag);\n+\n+        for (int i = 0; i < NUMBER_OF_WAITING_THREADS; i++) {\n+            \/\/ the WaitingTask has to wait to be notified in a lockCheck.wait()\n+            thr[i] = startTask(i, new WaitingTask(), isVirtual, \"Waiting\");\n+        }\n+        \/\/ entry count: 0\n+        \/\/ count of threads waiting to enter:       0\n+        \/\/ count of threads waiting to re-enter:    0\n+        \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n+        check(lockCheck, null, 0, \/\/ no owner thread\n+              0, \/\/ count of threads waiting to enter: 0\n+              NUMBER_OF_ENTERING_THREADS);\n+\n+        synchronized (lockCheck) {\n+            lockCheck.notifyAll();\n+        }\n+        for (int i = 0; i < NUMBER_OF_WAITING_THREADS; i++) {\n+            try {\n+                thr[i].join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected \" + e);\n+            }\n+        }\n+        log(\"###test0: finished \" + vtag);\n+    }\n+\n+    \/* Scenario #1:\n+     * - owning:         1\n+     * - entering:       N\n+     * - re-entering:    0\n+     * - to be notified: 0\n+     *\/\n+    static void test1(boolean isVirtual) {\n+        String vtag = vtag(isVirtual);\n+        log(\"\\n###test1: started \" + vtag);\n+\n+        synchronized (lockCheck) {\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter: 0\n+            \/\/ count of threads waiting to re-enter: 0\n+            \/\/ count of threads waiting to be notified: 0\n+            check(lockCheck, Thread.currentThread(), 1, 0, 0);\n+\n+            for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n+                \/\/ this EnteringTask has to be blocked on the lockCheck enter\n+                thr[i] = startTask(i, new EnteringTask(), isVirtual, \"Entering\");\n+            }\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n+            \/\/ count of threads waiting to re-enter:    0\n+            \/\/ count of threads waiting to be notified: 0\n+            check(lockCheck, Thread.currentThread(), 1,\n+                  NUMBER_OF_ENTERING_THREADS,\n+                  0 \/* count of threads waiting to be notified: 0 *\/);\n+        }\n+        for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n+            try {\n+                thr[i].join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected \" + e);\n+            }\n+        }\n+        log(\"###test1: finished \" + vtag);\n+    }\n+\n+    \/* Scenario #2:\n+     * - owning:         1\n+     * - entering:       N\n+     * - re-entering:    0\n+     * - to be notified: N\n+     *\/\n+    static void test2(boolean isVirtual) throws Error {\n+        String vtag = vtag(isVirtual);\n+        log(\"\\n###test2: started \" + vtag);\n+\n+        for (int i = 0; i < NUMBER_OF_WAITING_THREADS; i++) {\n+            \/\/ the WaitingTask has to wait to be notified in a lockCheck.wait()\n+            thr[i] = startTask(i, new WaitingTask(), isVirtual, \"Waiting\");\n+        }\n+        synchronized (lockCheck) {\n+            for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n+                \/\/ this EnteringTask has to be blocked on the lockCheck enter\n+                thr[NUMBER_OF_WAITING_THREADS + i] = startTask(i, new EnteringTask(), isVirtual, \"Entering\");\n+            }\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n+            \/\/ count of threads waiting to re-enter:    0\n+            \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n+            check(lockCheck, Thread.currentThread(), 1,\n+                  NUMBER_OF_ENTERING_THREADS,\n+                  NUMBER_OF_WAITING_THREADS);\n+\n+            lockCheck.notifyAll();\n+        }\n+        for (int i = 0; i < NUMBER_OF_THREADS; i++) {\n+            try {\n+                thr[i].join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected \" + e);\n+            }\n+        }\n+        log(\"###test2: finished \" + vtag);\n+    }\n+\n+    \/* Scenario #3:\n+     * Initially we have:\n+     * - owning:         1\n+     * - entering:       0\n+     * - re-entering:    0\n+     * - to be notified: N\n+     *\n+     * The threads waiting to be notified are being notified one-by-one\n+     * until all threads are blocked on re-entering the monitor.\n+     * The numbers of entering\/re-entering and waiting threads are checked\n+     * for correctness after each notification.\n+     *\/\n+    static void test3(boolean isVirtual) throws Error {\n+        String vtag = vtag(isVirtual);\n+        log(\"\\n###test3: started \" + vtag);\n+\n+        for (int i = 0; i < NUMBER_OF_WAITING_THREADS; i++) {\n+            \/\/ the WaitingTask has to wait to be notified in a lockCheck.wait()\n+            thr[i] = startTask(i, new WaitingTask(), isVirtual, \"Waiting\");\n+        }\n+        synchronized (lockCheck) {\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter:       0\n+            \/\/ count of threads waiting to re-enter:    0\n+            \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n+            check(lockCheck, Thread.currentThread(), 1,\n+                  0, \/\/ number of threads waiting to enter or re-enter\n+                  NUMBER_OF_WAITING_THREADS);\n+\n+            for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n+                \/\/ this EnteringTask has to be blocked on the lockCheck enter\n+                thr[NUMBER_OF_WAITING_THREADS + i] = startTask(i, new EnteringTask(), isVirtual, \"Entering\");\n+            }\n+\n+            \/\/ entry count: 1\n+            \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n+            \/\/ count of threads waiting to re-enter:    0\n+            \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n+            check(lockCheck, Thread.currentThread(), 1,\n+                  NUMBER_OF_ENTERING_THREADS,\n+                  NUMBER_OF_WAITING_THREADS);\n+\n+            for (int i = 0; i < NUMBER_OF_WAITING_THREADS; i++) {\n+                lockCheck.notify();\n+                \/\/ now the notified WaitingTask has to be blocked on the lockCheck re-enter\n+\n+                \/\/ entry count: 1\n+                \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n+                \/\/ count of threads waiting to re-enter:    i + 1\n+                \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS - i - 1\n+                check(lockCheck, Thread.currentThread(), 1,\n+                      NUMBER_OF_ENTERING_THREADS + i + 1,\n+                      NUMBER_OF_WAITING_THREADS  - i - 1);\n+            }\n+        }\n+        for (int i = 0; i < NUMBER_OF_THREADS; i++) {\n+            try {\n+                thr[i].join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected \" + e);\n+            }\n+        }\n+        log(\"###test3: finished \" + vtag);\n+    }\n+\n+    public static void main(String args[]) {\n+        log(\"\\n###main: started\\n\");\n+        check(lockCheck, null, 0, 0, 0);\n+\n+        \/\/ test platform threads\n+        test0(false);\n+        test1(false);\n+        test2(false);\n+        test3(false);\n+\n+        \/\/ test virtual threads\n+        test0(true);\n+        test1(true);\n+        test2(true);\n+        test3(true);\n+\n+        check(lockCheck, null, 0, 0, 0);\n+        if (getRes() > 0) {\n+            throw new RuntimeException(\"Failed status returned from the agent\");\n+        }\n+        log(\"\\n###main: finished\\n\");\n+    }\n+\n+    static abstract class TestTask implements Runnable {\n+        public volatile boolean ready = false;\n+        public abstract void run();\n+\n+        public void waitReady() {\n+            try {\n+                while (!ready) {\n+                    Thread.sleep(10);\n+                }\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected \" + e);\n+            }\n+        }\n+    }\n+\n+    static class EnteringTask extends TestTask {\n+        public void run() {\n+            ready = true;\n+            synchronized (lockCheck) {\n+            }\n+        }\n+    }\n+\n+    static class WaitingTask extends TestTask {\n+         public void run() {\n+            synchronized (lockCheck) {\n+                try {\n+                    ready = true;\n+                    lockCheck.wait();\n+                } catch (InterruptedException e) {\n+                    throw new Error(\"Unexpected \" + e);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/ObjectMonitorUsage\/ObjectMonitorUsage.java","additions":310,"deletions":0,"binary":false,"changes":310,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+static jvmtiEnv *jvmti = nullptr;\n+static jvmtiCapabilities caps;\n+static jint result = PASSED;\n+static int check_idx = 0;\n+\n+jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jint res;\n+  jvmtiError err;\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == nullptr) {\n+    LOG(\"Wrong result of a valid call to GetEnv !\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+        TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+        TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+        TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (!caps.can_get_monitor_info) {\n+    LOG(\"Warning: GetObjectMonitorUsage is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_ObjectMonitorUsage_check(JNIEnv *jni, jclass cls, jobject obj, jthread owner,\n+        jint entryCount, jint waiterCount, jint notifyWaiterCount) {\n+  jvmtiError err;\n+  jvmtiMonitorUsage inf;\n+  jvmtiThreadInfo tinf;\n+\n+  check_idx++;\n+\n+  err = jvmti->GetObjectMonitorUsage(obj, &inf);\n+  check_jvmti_status(jni, err, \"error in JVMTI GetObjectMonitorUsage\");\n+\n+  if (inf.owner == nullptr) {\n+    LOG(\">>> [%2d]    owner: none (0x0)\\n\", check_idx);\n+  } else {\n+    err = jvmti->GetThreadInfo(inf.owner, &tinf);\n+    check_jvmti_status(jni, err, \"error in JVMTI GetThreadInfo\");\n+    LOG(\">>> [%2d]    owner: %s (0x%p)\\n\",\n+        check_idx, tinf.name, inf.owner);\n+  }\n+  LOG(\">>>   entry_count: %d\\n\", inf.entry_count);\n+  LOG(\">>>  waiter_count: %d\\n\", inf.waiter_count);\n+  if (inf.waiter_count > 0) {\n+    LOG(\">>>       waiters:\\n\");\n+    for (int j = 0; j < inf.waiter_count; j++) {\n+      err = jvmti->GetThreadInfo(inf.waiters[j], &tinf);\n+      check_jvmti_status(jni, err, \"error in JVMTI GetThreadInfo\");\n+      LOG(\">>>                %2d: %s (0x%p)\\n\",\n+          j, tinf.name, inf.waiters[j]);\n+    }\n+  }\n+  if (!jni->IsSameObject(owner, inf.owner)) {\n+    LOG(\"(%d) unexpected owner: 0x%p\\n\", check_idx, inf.owner);\n+    result = STATUS_FAILED;\n+  }\n+  if (inf.entry_count != entryCount) {\n+    LOG(\"(%d) entry_count expected: %d, actually: %d\\n\",\n+        check_idx, entryCount, inf.entry_count);\n+    result = STATUS_FAILED;\n+  }\n+  if (inf.waiter_count != waiterCount) {\n+    LOG(\"(%d) waiter_count expected: %d, actually: %d\\n\",\n+        check_idx, waiterCount, inf.waiter_count);\n+    result = STATUS_FAILED;\n+  }\n+  if (inf.notify_waiter_count != notifyWaiterCount) {\n+    LOG(\"(%d) notify_waiter_count expected: %d, actually: %d\\n\",\n+        check_idx, notifyWaiterCount, inf.notify_waiter_count);\n+    result = STATUS_FAILED;\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_ObjectMonitorUsage_getRes(JNIEnv *jni, jclass cls) {\n+  return result;\n+}\n+\n+} \/\/ exnern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/ObjectMonitorUsage\/libObjectMonitorUsage.cpp","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -1,240 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetObjectMonitorUsage;\n-\n-import java.io.PrintStream;\n-\n-public class objmonusage003 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-    final static int NUMBER_OF_ENTERING_THREADS = 4;\n-    final static int NUMBER_OF_WAITING_THREADS  = 4;\n-    final static int NUMBER_OF_THREADS = NUMBER_OF_ENTERING_THREADS + NUMBER_OF_WAITING_THREADS;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"objmonusage003\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load objmonusage003 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    static Object lockCheck = new Object();\n-    static TestThread thr[] = new TestThread[NUMBER_OF_THREADS];\n-\n-    native static int getRes();\n-    native static void check(Object obj, Thread owner,\n-                             int entryCount, int waiterCount, int notifyWaiterCount);\n-\n-    \/* Scenario #1:\n-     * - non-zero entering threads\n-     * - zero re-entering threads\n-     * - zero threads waiting to be notified\n-     *\/\n-    static void test1() throws Error {\n-        synchronized (lockCheck) {\n-            \/\/ entry count: 1\n-            \/\/ count of threads waiting to enter: 0\n-            \/\/ count of threads waiting to re-enter: 0\n-            \/\/ count of threads waiting to be notified: 0\n-            check(lockCheck, Thread.currentThread(), 1, 0, 0);\n-\n-            for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n-                thr[i] = new EnteringThread();\n-                thr[i].start();\n-                \/\/ this EnteringThread has to be blocked on the lockCheck enter\n-                thr[i].waitReady();\n-            }\n-            \/\/ entry count: 1\n-            \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n-            \/\/ count of threads waiting to re-enter:    0\n-            \/\/ count of threads waiting to be notified: 0\n-            check(lockCheck, Thread.currentThread(), 1,\n-                  NUMBER_OF_ENTERING_THREADS,\n-                  0 \/* count of threads waiting to be notified: 0 *\/);\n-        }\n-        for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n-            try {\n-                thr[i].join();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected \" + e);\n-            }\n-        }\n-    }\n-\n-    \/* Scenario #2:\n-     * - non-zero entering threads\n-     * - zero re-entering threads\n-     * - non-zero waiting to be notified\n-     *\/\n-    static void test2() throws Error {\n-        for (int i = NUMBER_OF_ENTERING_THREADS; i < NUMBER_OF_THREADS; i++) {\n-            thr[i] = new WaitingThread();\n-            thr[i].start();\n-            thr[i].waitReady(); \/\/ the WaitingThread has to wait to be notified in a lockCheck.wait()\n-        }\n-        synchronized (lockCheck) {\n-            for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n-                thr[i] = new EnteringThread();\n-                thr[i].start();\n-                thr[i].waitReady(); \/\/ the EnteringThread has to block on monitor enter\n-            }\n-            \/\/ entry count: 1\n-            \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n-            \/\/ count of threads waiting to re-enter:    0\n-            \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n-            check(lockCheck, Thread.currentThread(), 1,\n-                  NUMBER_OF_ENTERING_THREADS,\n-                  NUMBER_OF_WAITING_THREADS);\n-\n-            lockCheck.notifyAll();\n-        }\n-        for (int i = 0; i < NUMBER_OF_THREADS; i++) {\n-            try {\n-                thr[i].join();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected \" + e);\n-            }\n-        }\n-    }\n-\n-    \/* Scenario #3:\n-     * Initially we have:\n-     * - zero entering threads\n-     * - zero re-entering threads\n-     * - non-zero threads waiting to be notified\n-     *\n-     * The threads waiting to be notified are being notified one-by-one\n-     * until all threads are blocked on re-entering the monitor.\n-     * The numbers of entering\/re-entering and waiting threads are checked\n-     * for correctness after each notification.\n-     *\/\n-    static void test3() throws Error {\n-        for (int i = NUMBER_OF_ENTERING_THREADS; i < NUMBER_OF_THREADS; i++) {\n-            thr[i] = new WaitingThread();\n-            thr[i].start();\n-            \/\/ the WaitingThread has to wait to be notified in a lockCheck.wait()\n-            thr[i].waitReady();\n-        }\n-        synchronized (lockCheck) {\n-            \/\/ entry count: 1\n-            \/\/ count of threads waiting to enter:       0\n-            \/\/ count of threads waiting to re-enter:    0\n-            \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n-            check(lockCheck, Thread.currentThread(), 1,\n-                  0, \/\/ number of threads waiting to enter or re-enter\n-                  NUMBER_OF_WAITING_THREADS);\n-\n-            for (int i = 0; i < NUMBER_OF_ENTERING_THREADS; i++) {\n-                thr[i] = new EnteringThread();\n-                thr[i].start();\n-                \/\/ this EnteringThread has to be blocked on the lockCheck enter\n-                thr[i].waitReady();\n-            }\n-\n-            \/\/ entry count: 1\n-            \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n-            \/\/ count of threads waiting to re-enter:    0\n-            \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS\n-            check(lockCheck, Thread.currentThread(), 1,\n-                  NUMBER_OF_ENTERING_THREADS,\n-                  NUMBER_OF_WAITING_THREADS);\n-\n-            for (int i = 0; i < NUMBER_OF_WAITING_THREADS; i++) {\n-                lockCheck.notify();\n-                \/\/ now the notified WaitingThread has to be blocked on the lockCheck re-enter\n-\n-                \/\/ entry count: 1\n-                \/\/ count of threads waiting to enter:       NUMBER_OF_ENTERING_THREADS\n-                \/\/ count of threads waiting to re-enter:    i + 1\n-                \/\/ count of threads waiting to be notified: NUMBER_OF_WAITING_THREADS - i - 1\n-                check(lockCheck, Thread.currentThread(), 1,\n-                      NUMBER_OF_ENTERING_THREADS + i + 1,\n-                      NUMBER_OF_WAITING_THREADS  - i - 1);\n-            }\n-        }\n-        for (int i = 0; i < NUMBER_OF_THREADS; i++) {\n-            try {\n-                thr[i].join();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected \" + e);\n-            }\n-        }\n-    }\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        check(lockCheck, null, 0, 0, 0);\n-\n-        test1();\n-        test2();\n-        test3();\n-\n-        check(lockCheck, null, 0, 0, 0);\n-        return getRes();\n-    }\n-\n-    static class TestThread extends Thread {\n-        public volatile boolean ready = false;\n-        public void waitReady() {\n-            try {\n-                while (!ready) {\n-                    Thread.sleep(10);\n-                }\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected \" + e);\n-            }\n-        }\n-    }\n-\n-    static class EnteringThread extends TestThread {\n-        public void run() {\n-            ready = true;\n-            synchronized (lockCheck) {\n-            }\n-        }\n-    }\n-\n-    static class WaitingThread extends TestThread {\n-         public void run() {\n-            synchronized (lockCheck) {\n-                try {\n-                    ready = true;\n-                    lockCheck.wait();\n-                } catch (InterruptedException e) {\n-                    throw new Error(\"Unexpected \" + e);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003.java","additions":0,"deletions":240,"binary":false,"changes":240,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test checks if JVMTI function GetObjectMonitorUsage returns\n- *     the expected values for the owner, entry_count, water_count\n- *     fields of JVMTI_monitor_info. The tescases are the following:\n- *       - unowned object without any waitings\n- *       - owned object without any waitings\n- *       - unowned object with waitings through Object.wait()\n- *       - unowned object has been waiting\n- * COMMENTS\n- *     Fixed according to 4669812 bug.\n- *     Ported from JVMDI test nsk\/jvmdi\/GetMonitorInfo\/getmoninfo003.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:objmonusage003 nsk.jvmti.GetObjectMonitorUsage.objmonusage003\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003\/TestDescription.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"objmonusage003.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003\/libobjmonusage003.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,167 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti = nullptr;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static int count = 0;\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_objmonusage003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_objmonusage003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_objmonusage003(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-    jvmtiError err;\n-\n-    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == nullptr) {\n-        printf(\"Wrong result of a valid call to GetEnv !\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (!caps.can_get_monitor_info) {\n-        printf(\"Warning: GetObjectMonitorUsage is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetObjectMonitorUsage_objmonusage003_check(JNIEnv *env,\n-        jclass cls, jobject obj, jthread owner,\n-        jint entryCount, jint waiterCount, jint notifyWaiterCount) {\n-    jvmtiError err;\n-    jvmtiMonitorUsage inf;\n-    jvmtiThreadInfo tinf;\n-    int j;\n-\n-    count++;\n-\n-    err = jvmti->GetObjectMonitorUsage(obj, &inf);\n-    if (err == JVMTI_ERROR_MUST_POSSESS_CAPABILITY &&\n-            !caps.can_get_monitor_info) {\n-        \/* Ok, it's expected *\/\n-        return;\n-    } else if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMonitorInfo#%d) unexpected error: %s (%d)\\n\",\n-               count, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        if (inf.owner == nullptr) {\n-            printf(\">>> [%2d]    owner: none (0x0)\\n\", count);\n-        } else {\n-            err = jvmti->GetThreadInfo(inf.owner, &tinf);\n-            printf(\">>> [%2d]    owner: %s (0x%p)\\n\",\n-                   count, tinf.name, inf.owner);\n-        }\n-        printf(\">>>   entry_count: %d\\n\", inf.entry_count);\n-        printf(\">>>  waiter_count: %d\\n\", inf.waiter_count);\n-        if (inf.waiter_count > 0) {\n-            printf(\">>>       waiters:\\n\");\n-            for (j = 0; j < inf.waiter_count; j++) {\n-                err = jvmti->GetThreadInfo(inf.waiters[j], &tinf);\n-                printf(\">>>                %2d: %s (0x%p)\\n\",\n-                       j, tinf.name, inf.waiters[j]);\n-            }\n-        }\n-    }\n-\n-    if (!env->IsSameObject(owner, inf.owner)) {\n-        printf(\"(%d) unexpected owner: 0x%p\\n\", count, inf.owner);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (inf.entry_count != entryCount) {\n-        printf(\"(%d) entry_count expected: %d, actually: %d\\n\",\n-               count, entryCount, inf.entry_count);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (inf.waiter_count != waiterCount) {\n-        printf(\"(%d) waiter_count expected: %d, actually: %d\\n\",\n-               count, waiterCount, inf.waiter_count);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (inf.notify_waiter_count != notifyWaiterCount) {\n-        printf(\"(%d) notify_waiter_count expected: %d, actually: %d\\n\",\n-               count, notifyWaiterCount, inf.notify_waiter_count);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetObjectMonitorUsage_objmonusage003_getRes(JNIEnv *env, jclass cls) {\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003\/objmonusage003.cpp","additions":0,"deletions":167,"binary":false,"changes":167,"status":"deleted"}]}