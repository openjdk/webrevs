{"files":[{"patch":"@@ -1488,2 +1488,0 @@\n-    ret.waiter_count = nWant + nWait;\n-    ret.notify_waiter_count = nWait;\n@@ -1492,2 +1490,0 @@\n-    ret.waiter_count = 0;\n-    ret.notify_waiter_count = 0;\n@@ -1496,0 +1492,18 @@\n+  ResourceMark rm(current_thread);\n+  GrowableArray<JavaThread*>* wantList = Threads::get_pending_threads(tlh.list(), nWant + nWait, (address)mon);\n+  nWant = wantList->length();\n+\n+  if (mon != nullptr) {\n+    ObjectWaiter *waiter = mon->first_waiter();\n+    for (int i = 0; i < nWait; i++) {\n+      if (waiter == nullptr || (i != 0 && waiter == mon->first_waiter())) {\n+        \/\/ robustness: the waiting list has gotten smaller\n+        nWait = i;\n+        break;\n+      }\n+      waiter = mon->next_waiter(waiter);\n+    }\n+  }\n+  ret.waiter_count = nWant;\n+  ret.notify_waiter_count = nWait;\n+\n@@ -1513,2 +1527,1 @@\n-    \/\/ Number of waiters may actually be less than the waiter count.\n-    \/\/ So null out memory so that unused memory will be null.\n+    \/\/ null out memory for robustness\n@@ -1518,17 +1531,8 @@\n-    if (ret.waiter_count > 0) {\n-      \/\/ we have contending and\/or waiting threads\n-      if (nWant > 0) {\n-        \/\/ we have contending threads\n-        ResourceMark rm(current_thread);\n-        \/\/ get_pending_threads returns only java thread so we do not need to\n-        \/\/ check for non java threads.\n-        GrowableArray<JavaThread*>* wantList = Threads::get_pending_threads(tlh.list(), nWant, (address)mon);\n-        if (wantList->length() < nWant) {\n-          \/\/ robustness: the pending list has gotten smaller\n-          nWant = wantList->length();\n-        }\n-        for (int i = 0; i < nWant; i++) {\n-          JavaThread *pending_thread = wantList->at(i);\n-          Handle th(current_thread, get_vthread_or_thread_oop(pending_thread));\n-          ret.waiters[i] = (jthread)jni_reference(calling_thread, th);\n-        }\n+    if (ret.waiter_count > 0) { \/\/ we have contending threads waiting to enter\/re-enter the monitor\n+      \/\/ identify threads waiting to enter and re-enter the monitor\n+      \/\/ get_pending_threads returns only java thread so we do not need to\n+      \/\/ check for non java threads.\n+      for (int i = 0; i < nWant; i++) {\n+        JavaThread *pending_thread = wantList->at(i);\n+        Handle th(current_thread, get_vthread_or_thread_oop(pending_thread));\n+        ret.waiters[i] = (jthread)jni_reference(calling_thread, th);\n@@ -1536,21 +1540,12 @@\n-      if (nWait > 0) {\n-        \/\/ we have threads in Object.wait()\n-        int offset = nWant;  \/\/ add after any contending threads\n-        ObjectWaiter *waiter = mon->first_waiter();\n-        for (int i = 0, j = 0; i < nWait; i++) {\n-          if (waiter == nullptr) {\n-            \/\/ robustness: the waiting list has gotten smaller\n-            nWait = j;\n-            break;\n-          }\n-          JavaThread *w = mon->thread_of_waiter(waiter);\n-          if (w != nullptr) {\n-            \/\/ If the thread was found on the ObjectWaiter list, then\n-            \/\/ it has not been notified. This thread can't change the\n-            \/\/ state of the monitor so it doesn't need to be suspended.\n-            Handle th(current_thread, get_vthread_or_thread_oop(w));\n-            ret.waiters[offset + j] = (jthread)jni_reference(calling_thread, th);\n-            ret.notify_waiters[j++] = (jthread)jni_reference(calling_thread, th);\n-          }\n-          waiter = mon->next_waiter(waiter);\n-        }\n+    }\n+    if (ret.notify_waiter_count > 0) { \/\/ we have threads waiting to be notified in Object.wait()\n+      ObjectWaiter *waiter = mon->first_waiter();\n+      for (int i = 0; i < nWait; i++) {\n+        JavaThread *w = mon->thread_of_waiter(waiter);\n+        assert(w != nullptr, \"DBG: sanity check\");\n+        \/\/ If the thread was found on the ObjectWaiter list, then\n+        \/\/ it has not been notified. This thread can't change the\n+        \/\/ state of the monitor so it doesn't need to be suspended.\n+        Handle th(current_thread, get_vthread_or_thread_oop(w));\n+        ret.notify_waiters[i] = (jthread)jni_reference(calling_thread, th);\n+        waiter = mon->next_waiter(waiter);\n@@ -1558,5 +1553,1 @@\n-    } \/\/ ThreadsListHandle is destroyed here.\n-\n-    \/\/ Adjust count. nWant and nWait count values may be less than original.\n-    ret.waiter_count = nWant + nWait;\n-    ret.notify_waiter_count = nWait;\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":40,"deletions":49,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -192,0 +192,10 @@\n+\/\/ If there is a virtual thread mounted then return vthread() oop.\n+\/\/ Otherwise, return threadObj().\n+oop JavaThread::vthread_or_thread() const {\n+    oop result = vthread();\n+    if (result == nullptr) {\n+      result = threadObj();\n+    }\n+    return result;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -527,0 +527,1 @@\n+  oop vthread_or_thread() const;\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1197,1 +1197,5 @@\n-    if (pending == monitor) {             \/\/ found a match\n+    address waiting = (address)p->current_waiting_monitor();\n+    if (pending == monitor ||\n+        (waiting == monitor && JavaThreadStatus::BLOCKED_ON_MONITOR_ENTER ==\n+         java_lang_Thread::get_thread_status(p->vthread_or_thread()))\n+    ) {  \/\/ found a match\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -222,1 +222,1 @@\n-            (void)outStream_writeInt(out, info.waiter_count);\n+            (void)outStream_writeInt(out, info.waiter_count + info.notify_waiter_count);\n@@ -226,0 +226,3 @@\n+            for (i = 0; i < info.notify_waiter_count; i++) {\n+                (void)outStream_writeObjectRef(env, out, info.notify_waiters[i]);\n+            }\n@@ -230,0 +233,2 @@\n+        if (info.notify_waiters != NULL )\n+            jvmtiDeallocate(info.notify_waiters);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/ObjectReferenceImpl.c","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+    final static boolean ADD_DELAYS_FOR_RACES = false;\n+    final static boolean CHECK_FOR_BAD_RESULTS = false;\n@@ -44,1 +46,15 @@\n-    native static void check(int i, Object o, Thread owner, int ec, int wc);\n+    native static void check(int index, Object syncObject, Thread owner, int entryCount,\n+                             Thread waiterThread, int waiterCount,\n+                             Thread notifyWaiterThread, int notifyWaiterCount);\n+\n+    static void verify(int index, Object syncObject, Thread owner, int entryCount,\n+                       Thread waiterThread, int waiterCount,\n+                       Thread notifyWaiterThread, int notifyWaiterCount) {\n+        if (CHECK_FOR_BAD_RESULTS) {\n+            check(index, syncObject, owner, entryCount,\n+                  waiterThread, waiterCount, notifyWaiterThread, notifyWaiterCount);\n+        } else {\n+            check(index, syncObject, owner, entryCount,\n+                  null, 0, notifyWaiterThread, notifyWaiterCount);\n+        }\n+    }\n@@ -53,0 +69,1 @@\n+        Thread mainThread = Thread.currentThread();\n@@ -58,1 +75,1 @@\n-            runn[i] = new objmonusage001a(i, syncObject[i]);\n+            runn[i] = new objmonusage001a(mainThread, i, syncObject[i]);\n@@ -70,0 +87,23 @@\n+\n+                \/\/ verify2:\n+                \/\/ - owner == main:\n+                \/\/       main thread owns the monitor and worker thread\n+                \/\/       is in wait() and is not notified\n+                \/\/ - entry_count == 1:\n+                \/\/       main thread reentered 1 time\n+                \/\/ - waiter_count == 0:\n+                \/\/       main thread has already reentered the monitor and worker thread\n+                \/\/       is in wait() and is not notified so it is not waiting to reenter\n+                \/\/       the monitor\n+                \/\/ - waiter_thread == null:\n+                \/\/       no thread is waiting to reenter the monitor\n+                \/\/ - notify_waiter_count == 1:\n+                \/\/       worker thread is in wait() and is not notified\n+                \/\/ - notify_waiter_thread == runn[i]:\n+                \/\/       worker thread is in wait() and is not notified\n+                \/\/          \n+                \/\/ This is a stable verification point because the worker thread is in wait()\n+                \/\/ and is not notified and the main thread is doing the verification.\n+                \/\/\n+                verify(NUMBER_OF_THREADS + i, syncObject[i], mainThread, 1,\n+                       runn[i], 1, runn[i], 1);\n@@ -71,1 +111,23 @@\n-            check(NUMBER_OF_THREADS + i, syncObject[i], null, 0, 1);\n+\n+            \/\/ verify-3:\n+            \/\/ - owner == null:\n+            \/\/       main thread does not own the monitor and worker thread is in\n+            \/\/       wait() and is not notified so there is no owner\n+            \/\/ - entry_count == 0:\n+            \/\/       no owner so entry_count is 0\n+            \/\/ - waiter_count == 0:\n+            \/\/       main thread is not trying to enter the monitor and worker thread\n+            \/\/       is in wait() and is not notified so it is not waiting to reenter\n+            \/\/       the monitor\n+            \/\/ - waiter_thread == null:\n+            \/\/       no thread is waiting to reenter the monitor\n+            \/\/ - notify_waiter_count == 1:\n+            \/\/       worker thread is in wait() and is not notified\n+            \/\/ - notify_waiter_thread == runn[i]:\n+            \/\/       worker thread is in wait() and is not notified\n+            \/\/\n+            \/\/ This is a stable verification point because the worker thread is in wait()\n+            \/\/ and is not notified and the main thread is doing the verification.\n+            \/\/\n+            verify((NUMBER_OF_THREADS * 2) + i, syncObject[i], null, 0,\n+                   runn[i], 1, runn[i], 1);\n@@ -90,0 +152,1 @@\n+    Thread mainThread;\n@@ -91,1 +154,1 @@\n-    int ind;\n+    int index;\n@@ -93,2 +156,3 @@\n-    public objmonusage001a(int i, Object s) {\n-        ind = i;\n+    public objmonusage001a(Thread mt, int i, Object s) {\n+        mainThread = mt;\n+        index = i;\n@@ -100,1 +164,20 @@\n-            objmonusage001.check(ind, syncObject, this, 1, 1);\n+            \/\/ verify-1:\n+            \/\/ - owner == this_thread:\n+            \/\/       this worker thread is owner\n+            \/\/ - entry_count == 1:\n+            \/\/       worker thread entered 1 time\n+            \/\/ - waiter_count == 0:\n+            \/\/       main thread is in wait() and is not notified so it is not\n+            \/\/       waiting to reenter the monitor\n+            \/\/ - waiter_thread == null:\n+            \/\/       no thread is waiting to reenter the monitor\n+            \/\/ - notify_waiter_count == 1:\n+            \/\/        main thread is in wait() and is not notified\n+            \/\/ - notify_waiter_thread == mainThread:\n+            \/\/       main thread is in wait() and is not notified\n+            \/\/\n+            \/\/ This is a stable verification point because the main thread is in wait()\n+            \/\/ and is not notified and this worker thread is doing the verification.\n+            \/\/\n+            objmonusage001.verify(index, syncObject, this, 1,\n+                                  mainThread, 1, mainThread, 1);\n@@ -102,0 +185,1 @@\n+\n@@ -104,0 +188,4 @@\n+\n+                if (objmonusage001.ADD_DELAYS_FOR_RACES) {\n+                    Thread.sleep(1000);\n+                }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage001.java","additions":96,"deletions":8,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,8 @@\n- *     The test exercises JVMTI function GetObjectMonitorUsage.\n+ *     The test exercises JVMTI function GetObjectMonitorUsage. The main\n+ *     thread uses a monitor to do coordinated launches of work threads.\n+ *     Each worker thread verifies expected GetObjectMonitorUsage values\n+ *     when it gets going and the main thread also verifies expected\n+ *     GetObjectMonitorUsage values once the worker thread returns\n+ *     control flow to the main thread. The test scenario is repeated\n+ *     for a fixed number of threads.\n+ *\n@@ -39,1 +46,1 @@\n- * @run main\/othervm\/native -agentlib:objmonusage001 nsk.jvmti.GetObjectMonitorUsage.objmonusage001\n+ * @run main\/othervm\/native -agentlib:objmonusage001=printdump nsk.jvmti.GetObjectMonitorUsage.objmonusage001\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage001\/TestDescription.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -97,1 +97,3 @@\n-        jthread owner, jint entryCount, jint waiterCount) {\n+        jthread owner, jint entryCount,\n+        jthread waiterThread, jint waiterCount,\n+        jthread notifyWaiterThread, jint notifyWaiterCount) {\n@@ -103,1 +105,1 @@\n-    if (result == STATUS_FAILED) {\n+    if (result == STATUS_FAILED && printdump != JNI_TRUE) {\n@@ -155,1 +157,1 @@\n-        printf(\"(%d) entry_count expected: %d, actually: %d\\n\",\n+        printf(\"FAILED: (%d) entry_count expected: %d, actually: %d\\n\",\n@@ -161,1 +163,1 @@\n-        printf(\"(%d) waiter_count expected: %d, actually: %d\\n\",\n+        printf(\"FAILED: (%d) waiter_count expected: %d, actually: %d\\n\",\n@@ -165,0 +167,22 @@\n+\n+    if (inf.waiters != nullptr &&\n+        !env->IsSameObject(waiterThread, inf.waiters[0])) {\n+        jvmti->GetThreadInfo(inf.waiters[0], &tinf);\n+        printf(\"FAILED: (%d) unexpected waiterThread: %s (0x%p)\\n\", i,\n+               tinf.name, inf.waiters[0]);\n+        result = STATUS_FAILED;\n+    }\n+\n+    if (inf.notify_waiter_count != notifyWaiterCount) {\n+        printf(\"FAILED: (%d) notify_waiter_count expected: %d, actually: %d\\n\",\n+               i, notifyWaiterCount, inf.notify_waiter_count);\n+        result = STATUS_FAILED;\n+    }\n+\n+    if (inf.notify_waiters != nullptr &&\n+        !env->IsSameObject(notifyWaiterThread, inf.notify_waiters[0])) {\n+        jvmti->GetThreadInfo(inf.notify_waiters[0], &tinf);\n+        printf(\"FAILED: (%d) unexpected waiterThread: %s (0x%p)\\n\", i,\n+               tinf.name, inf.notify_waiters[0]);\n+        result = STATUS_FAILED;\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage001\/objmonusage001.cpp","additions":28,"deletions":4,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,3 @@\n-    final static int NUMBER_OF_THREADS = 16;\n-    final static int WAIT_TIME = 100;\n-    volatile static boolean waiterInLockCheck = false;\n+    final static int NUMBER_OF_ENTERER_THREADS = 4;\n+    final static int NUMBER_OF_WAITER_THREADS  = 4;\n+    final static int NUMBER_OF_THREADS = NUMBER_OF_ENTERER_THREADS + NUMBER_OF_WAITER_THREADS;\n@@ -46,1 +46,0 @@\n-    static Object lockStart = new Object();\n@@ -51,1 +50,1 @@\n-                             int entryCount, int waiterCount);\n+                             int entryCount, int waiterCount, int notifyWaiterCount);\n@@ -61,1 +60,1 @@\n-        check(lockCheck, null, 0, 0);\n+        check(lockCheck, null, 0, 0, 0);\n@@ -64,1 +63,1 @@\n-            check(lockCheck, Thread.currentThread(), 1, 0);\n+            check(lockCheck, Thread.currentThread(), 1, 0, 0);\n@@ -67,2 +66,2 @@\n-        WaiterThread thr[] = new WaiterThread[NUMBER_OF_THREADS];\n-        for (int i = 0; i < NUMBER_OF_THREADS; i++) {\n+        TestThread thr[] = new TestThread[NUMBER_OF_THREADS];\n+        for (int i = NUMBER_OF_ENTERER_THREADS; i < NUMBER_OF_THREADS; i++) {\n@@ -70,1 +69,7 @@\n-            synchronized (lockStart) {\n+            thr[i].start();\n+            \/\/ the WaiterThread has to wait to be notified in a lockCheck.wait()\n+            thr[i].waitReady();\n+        }\n+        synchronized (lockCheck) {\n+            for (int i = 0; i < NUMBER_OF_ENTERER_THREADS; i++) {\n+                thr[i] = new EntererThread();\n@@ -72,5 +77,2 @@\n-                try {\n-                    lockStart.wait();\n-                } catch (InterruptedException e) {\n-                    throw new Error(\"Unexpected \" + e);\n-                }\n+                \/\/ the EntererThread has to be blocked on the lockCheck enter\n+                thr[i].waitReady();\n@@ -78,9 +80,9 @@\n-            synchronized (lockCheck) {\n-                while (!waiterInLockCheck) {\n-                    try {\n-                        lockCheck.wait(WAIT_TIME);\n-                    } catch (InterruptedException e) {\n-                        throw new Error(\"Unexpected \" + e);\n-                    }\n-                }\n-                waiterInLockCheck = false;\n+            check(lockCheck, Thread.currentThread(), 1,\n+                  NUMBER_OF_ENTERER_THREADS,\n+                  NUMBER_OF_WAITER_THREADS);\n+            for (int i = 0; i < NUMBER_OF_WAITER_THREADS; i++) {\n+                lockCheck.notify();\n+                \/\/ now the notified WaiterThread has to be blocked on the lockCheck re-enter\n+                check(lockCheck, Thread.currentThread(), 1,\n+                      NUMBER_OF_ENTERER_THREADS + i + 1,\n+                      NUMBER_OF_WAITER_THREADS  - i - 1);\n@@ -88,5 +90,0 @@\n-            check(lockCheck, null, 0, i + 1);\n-        }\n-\n-        synchronized (lockCheck) {\n-            lockCheck.notifyAll();\n@@ -94,1 +91,0 @@\n-\n@@ -102,2 +98,1 @@\n-\n-        check(lockCheck, null, 0, 0);\n+        check(lockCheck, null, 0, 0, 0);\n@@ -107,4 +102,9 @@\n-    static class WaiterThread extends Thread {\n-        public synchronized void run() {\n-            synchronized (lockStart) {\n-                lockStart.notify();\n+    static class TestThread extends Thread {\n+        public volatile boolean ready = false;\n+        public void waitReady() {\n+            try {\n+                while (!ready) {\n+                    Thread.sleep(10);\n+                }\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected \" + e);\n@@ -112,0 +112,13 @@\n+        }\n+    }\n+\n+    static class EntererThread extends TestThread {\n+        public void run() {\n+            ready = true;\n+            synchronized (lockCheck) {\n+            }\n+        }\n+    }\n+\n+    static class WaiterThread extends TestThread {\n+         public void run() {\n@@ -114,1 +127,1 @@\n-                    waiterInLockCheck = true;\n+                    ready = true;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003.java","additions":51,"deletions":38,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-        jint entryCount, jint waiterCount) {\n+        jint entryCount, jint waiterCount, jint notifyWaiterCount) {\n@@ -154,0 +154,6 @@\n+\n+    if (inf.notify_waiter_count != notifyWaiterCount) {\n+        printf(\"(%d) notify_waiter_count expected: %d, actually: %d\\n\",\n+               count, notifyWaiterCount, inf.notify_waiter_count);\n+        result = STATUS_FAILED;\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003\/objmonusage003.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"}]}