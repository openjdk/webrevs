{"files":[{"patch":"@@ -1488,2 +1488,0 @@\n-    ret.waiter_count = nWant + nWait;\n-    ret.notify_waiter_count = nWait;\n@@ -1492,2 +1490,0 @@\n-    ret.waiter_count = 0;\n-    ret.notify_waiter_count = 0;\n@@ -1496,0 +1492,18 @@\n+  ResourceMark rm(current_thread);\n+  GrowableArray<JavaThread*>* wantList = Threads::get_pending_threads(tlh.list(), nWant + nWait, (address)mon);\n+  nWant = wantList->length();\n+\n+  if (mon != nullptr) {\n+    ObjectWaiter *waiter = mon->first_waiter();\n+    for (int i = 0; i < nWait; i++) {\n+      if (waiter == nullptr || (i != 0 && waiter == mon->first_waiter())) {\n+        \/\/ robustness: the waiting list has gotten smaller\n+        nWait = i;\n+        break;\n+      }\n+      waiter = mon->next_waiter(waiter);\n+    }\n+  }\n+  ret.waiter_count = nWant;\n+  ret.notify_waiter_count = nWait;\n+\n@@ -1513,2 +1527,1 @@\n-    \/\/ Number of waiters may actually be less than the waiter count.\n-    \/\/ So null out memory so that unused memory will be null.\n+    \/\/ null out memory for robustness\n@@ -1518,17 +1531,8 @@\n-    if (ret.waiter_count > 0) {\n-      \/\/ we have contending and\/or waiting threads\n-      if (nWant > 0) {\n-        \/\/ we have contending threads\n-        ResourceMark rm(current_thread);\n-        \/\/ get_pending_threads returns only java thread so we do not need to\n-        \/\/ check for non java threads.\n-        GrowableArray<JavaThread*>* wantList = Threads::get_pending_threads(tlh.list(), nWant, (address)mon);\n-        if (wantList->length() < nWant) {\n-          \/\/ robustness: the pending list has gotten smaller\n-          nWant = wantList->length();\n-        }\n-        for (int i = 0; i < nWant; i++) {\n-          JavaThread *pending_thread = wantList->at(i);\n-          Handle th(current_thread, get_vthread_or_thread_oop(pending_thread));\n-          ret.waiters[i] = (jthread)jni_reference(calling_thread, th);\n-        }\n+    if (ret.waiter_count > 0) { \/\/ we have contending threads waiting to enter\/re-enter the monitor\n+      \/\/ identify threads waiting to enter and re-enter the monitor\n+      \/\/ get_pending_threads returns only java thread so we do not need to\n+      \/\/ check for non java threads.\n+      for (int i = 0; i < nWant; i++) {\n+        JavaThread *pending_thread = wantList->at(i);\n+        Handle th(current_thread, get_vthread_or_thread_oop(pending_thread));\n+        ret.waiters[i] = (jthread)jni_reference(calling_thread, th);\n@@ -1536,21 +1540,12 @@\n-      if (nWait > 0) {\n-        \/\/ we have threads in Object.wait()\n-        int offset = nWant;  \/\/ add after any contending threads\n-        ObjectWaiter *waiter = mon->first_waiter();\n-        for (int i = 0, j = 0; i < nWait; i++) {\n-          if (waiter == nullptr) {\n-            \/\/ robustness: the waiting list has gotten smaller\n-            nWait = j;\n-            break;\n-          }\n-          JavaThread *w = mon->thread_of_waiter(waiter);\n-          if (w != nullptr) {\n-            \/\/ If the thread was found on the ObjectWaiter list, then\n-            \/\/ it has not been notified. This thread can't change the\n-            \/\/ state of the monitor so it doesn't need to be suspended.\n-            Handle th(current_thread, get_vthread_or_thread_oop(w));\n-            ret.waiters[offset + j] = (jthread)jni_reference(calling_thread, th);\n-            ret.notify_waiters[j++] = (jthread)jni_reference(calling_thread, th);\n-          }\n-          waiter = mon->next_waiter(waiter);\n-        }\n+    }\n+    if (ret.notify_waiter_count > 0) { \/\/ we have threads waiting to be notified in Object.wait()\n+      ObjectWaiter *waiter = mon->first_waiter();\n+      for (int i = 0; i < nWait; i++) {\n+        JavaThread *w = mon->thread_of_waiter(waiter);\n+        assert(w != nullptr, \"DBG: sanity check\");\n+        \/\/ If the thread was found on the ObjectWaiter list, then\n+        \/\/ it has not been notified. This thread can't change the\n+        \/\/ state of the monitor so it doesn't need to be suspended.\n+        Handle th(current_thread, get_vthread_or_thread_oop(w));\n+        ret.notify_waiters[i] = (jthread)jni_reference(calling_thread, th);\n+        waiter = mon->next_waiter(waiter);\n@@ -1558,5 +1553,1 @@\n-    } \/\/ ThreadsListHandle is destroyed here.\n-\n-    \/\/ Adjust count. nWant and nWait count values may be less than original.\n-    ret.waiter_count = nWant + nWait;\n-    ret.notify_waiter_count = nWait;\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":40,"deletions":49,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -192,0 +192,10 @@\n+\/\/ If there is a virtual thread mounted then return vthread() oop.\n+\/\/ Otherwise, return threadObj().\n+oop JavaThread::vthread_or_thread() const {\n+    oop result = vthread();\n+    if (result == nullptr) {\n+      result = threadObj();\n+    }\n+    return result;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -527,0 +527,1 @@\n+  oop vthread_or_thread() const;\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1197,1 +1197,5 @@\n-    if (pending == monitor) {             \/\/ found a match\n+    address waiting = (address)p->current_waiting_monitor();\n+    if (pending == monitor ||\n+        (waiting == monitor && JavaThreadStatus::BLOCKED_ON_MONITOR_ENTER ==\n+         java_lang_Thread::get_thread_status(p->vthread_or_thread()))\n+    ) {  \/\/ found a match\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -222,1 +222,1 @@\n-            (void)outStream_writeInt(out, info.waiter_count);\n+            (void)outStream_writeInt(out, info.waiter_count + info.notify_waiter_count);\n@@ -226,0 +226,3 @@\n+            for (i = 0; i < info.notify_waiter_count; i++) {\n+                (void)outStream_writeObjectRef(env, out, info.notify_waiters[i]);\n+            }\n@@ -230,0 +233,2 @@\n+        if (info.notify_waiters != NULL )\n+            jvmtiDeallocate(info.notify_waiters);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/ObjectReferenceImpl.c","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,2 @@\n-    native static void check(int i, Object o, Thread owner, int ec, int wc);\n+    native static void check(int i, Object o, Thread owner,\n+                             int entryCount, int notifyWaiterCount);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage001.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-        jthread owner, jint entryCount, jint waiterCount) {\n+        jthread owner, jint entryCount, jint notifyWaiterCount) {\n@@ -160,3 +160,3 @@\n-    if (inf.waiter_count != waiterCount) {\n-        printf(\"(%d) waiter_count expected: %d, actually: %d\\n\",\n-               i, waiterCount, inf.waiter_count);\n+    if (inf.notify_waiter_count != notifyWaiterCount) {\n+        printf(\"(%d) notify_waiter_count expected: %d, actually: %d\\n\",\n+               i, notifyWaiterCount, inf.notify_waiter_count);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage001\/objmonusage001.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,3 @@\n-    final static int NUMBER_OF_THREADS = 16;\n-    final static int WAIT_TIME = 100;\n-    volatile static boolean waiterInLockCheck = false;\n+    final static int NUMBER_OF_ENTERER_THREADS = 4;\n+    final static int NUMBER_OF_WAITER_THREADS  = 4;\n+    final static int NUMBER_OF_THREADS = NUMBER_OF_ENTERER_THREADS + NUMBER_OF_WAITER_THREADS;\n@@ -46,1 +46,0 @@\n-    static Object lockStart = new Object();\n@@ -51,1 +50,1 @@\n-                             int entryCount, int waiterCount);\n+                             int entryCount, int waiterCount, int notifyWaiterCount);\n@@ -61,1 +60,1 @@\n-        check(lockCheck, null, 0, 0);\n+        check(lockCheck, null, 0, 0, 0);\n@@ -64,1 +63,1 @@\n-            check(lockCheck, Thread.currentThread(), 1, 0);\n+            check(lockCheck, Thread.currentThread(), 1, 0, 0);\n@@ -67,2 +66,2 @@\n-        WaiterThread thr[] = new WaiterThread[NUMBER_OF_THREADS];\n-        for (int i = 0; i < NUMBER_OF_THREADS; i++) {\n+        TestThread thr[] = new TestThread[NUMBER_OF_THREADS];\n+        for (int i = NUMBER_OF_ENTERER_THREADS; i < NUMBER_OF_THREADS; i++) {\n@@ -70,1 +69,7 @@\n-            synchronized (lockStart) {\n+            thr[i].start();\n+            \/\/ the WaiterThread has to wait to be notified in a lockCheck.wait()\n+            thr[i].waitReady();\n+        }\n+        synchronized (lockCheck) {\n+            for (int i = 0; i < NUMBER_OF_ENTERER_THREADS; i++) {\n+                thr[i] = new EntererThread();\n@@ -72,5 +77,2 @@\n-                try {\n-                    lockStart.wait();\n-                } catch (InterruptedException e) {\n-                    throw new Error(\"Unexpected \" + e);\n-                }\n+                \/\/ the EntererThread has to be blocked on the lockCheck enter\n+                thr[i].waitReady();\n@@ -78,9 +80,9 @@\n-            synchronized (lockCheck) {\n-                while (!waiterInLockCheck) {\n-                    try {\n-                        lockCheck.wait(WAIT_TIME);\n-                    } catch (InterruptedException e) {\n-                        throw new Error(\"Unexpected \" + e);\n-                    }\n-                }\n-                waiterInLockCheck = false;\n+            check(lockCheck, Thread.currentThread(), 1,\n+                  NUMBER_OF_ENTERER_THREADS,\n+                  NUMBER_OF_WAITER_THREADS);\n+            for (int i = 0; i < NUMBER_OF_WAITER_THREADS; i++) {\n+                lockCheck.notify();\n+                \/\/ now the notified WaiterThread has to be blocked on the lockCheck re-enter\n+                check(lockCheck, Thread.currentThread(), 1,\n+                      NUMBER_OF_ENTERER_THREADS + i + 1,\n+                      NUMBER_OF_WAITER_THREADS  - i - 1);\n@@ -88,5 +90,0 @@\n-            check(lockCheck, null, 0, i + 1);\n-        }\n-\n-        synchronized (lockCheck) {\n-            lockCheck.notifyAll();\n@@ -94,1 +91,0 @@\n-\n@@ -102,2 +98,1 @@\n-\n-        check(lockCheck, null, 0, 0);\n+        check(lockCheck, null, 0, 0, 0);\n@@ -107,4 +102,9 @@\n-    static class WaiterThread extends Thread {\n-        public synchronized void run() {\n-            synchronized (lockStart) {\n-                lockStart.notify();\n+    static class TestThread extends Thread {\n+        public volatile boolean ready = false;\n+        public void waitReady() {\n+            try {\n+                while (!ready) {\n+                    Thread.sleep(10);\n+                }\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected \" + e);\n@@ -112,0 +112,13 @@\n+        }\n+    }\n+\n+    static class EntererThread extends TestThread {\n+        public void run() {\n+            ready = true;\n+            synchronized (lockCheck) {\n+            }\n+        }\n+    }\n+\n+    static class WaiterThread extends TestThread {\n+         public void run() {\n@@ -114,1 +127,1 @@\n-                    waiterInLockCheck = true;\n+                    ready = true;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003.java","additions":51,"deletions":38,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-        jint entryCount, jint waiterCount) {\n+        jint entryCount, jint waiterCount, jint notifyWaiterCount) {\n@@ -154,0 +154,6 @@\n+\n+    if (inf.notify_waiter_count != notifyWaiterCount) {\n+        printf(\"(%d) notify_waiter_count expected: %d, actually: %d\\n\",\n+               count, notifyWaiterCount, inf.notify_waiter_count);\n+        result = STATUS_FAILED;\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003\/objmonusage003.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"}]}