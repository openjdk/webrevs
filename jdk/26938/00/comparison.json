{"files":[{"patch":"@@ -96,0 +96,44 @@\n+void MethodHandles::verify_method(MacroAssembler* _masm, Register method, vmIntrinsics::ID iid) {\n+  BLOCK_COMMENT(\"verify_method {\");\n+  __ verify_method_ptr(method);\n+  if (VerifyMethodHandles) {\n+    Label L_ok;\n+    const Register method_holder = t1;\n+    __ load_method_holder(method_holder, method);\n+    switch (iid) {\n+      case vmIntrinsicID::_invokeBasic:\n+        \/\/ Require compiled LambdaForm class to be fully initialized.\n+        __ lbu(t0, Address(method_holder, InstanceKlass::init_state_offset()));\n+        __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n+        __ mv(t1, InstanceKlass::fully_initialized);\n+        __ beq(t0, t1, L_ok);\n+        break;\n+      case vmIntrinsicID::_linkToStatic:\n+        __ clinit_barrier(method_holder, t0, &L_ok);\n+        break;\n+\n+      case vmIntrinsicID::_linkToVirtual:\n+      case vmIntrinsicID::_linkToSpecial:\n+      case vmIntrinsicID::_linkToInterface:\n+        \/\/ Class initialization check is too strong here. Just ensure that class initialization has been initiated.\n+        __ lbu(t0, Address(method_holder, InstanceKlass::init_state_offset()));\n+        __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n+        __ mv(t1, InstanceKlass::being_initialized);\n+        __ bge(t0, t1, L_ok);\n+\n+        \/\/ init_state check failed, but it may be an abstract interface method\n+        __ lhu(t0, Address(method, Method::access_flags_offset()));\n+        __ test_bit(t1, t0, exact_log2(JVM_ACC_ABSTRACT));\n+        __ bnez(t1, L_ok);\n+        break;\n+\n+      default:\n+        fatal(\"unexpected intrinsic %d: %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n+    }\n+\n+    \/\/ Method holder init state check failed for a concrete method.\n+    __ stop(\"Method holder klass is not initialized\");\n+    __ BIND(L_ok);\n+  }\n+  BLOCK_COMMENT(\"} verify_method\");\n+}\n@@ -99,1 +143,1 @@\n-                                            bool for_compiler_entry) {\n+                                            bool for_compiler_entry, vmIntrinsics::ID iid) {\n@@ -103,1 +147,1 @@\n-  __ verify_method_ptr(method);\n+  verify_method(_masm, method, iid);\n@@ -161,1 +205,1 @@\n-  jump_from_method_handle(_masm, method_temp, temp2, for_compiler_entry);\n+  jump_from_method_handle(_masm, method_temp, temp2, for_compiler_entry, vmIntrinsics::_invokeBasic);\n@@ -440,2 +484,1 @@\n-    __ verify_method_ptr(xmethod);\n-    jump_from_method_handle(_masm, xmethod, temp1, for_compiler_entry);\n+    jump_from_method_handle(_masm, xmethod, temp1, for_compiler_entry, iid);\n","filename":"src\/hotspot\/cpu\/riscv\/methodHandles_riscv.cpp","additions":48,"deletions":5,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+  static void verify_method(MacroAssembler* _masm, Register method, vmIntrinsics::ID iid) NOT_DEBUG_RETURN;\n+\n@@ -52,1 +54,1 @@\n-                                      bool for_compiler_entry);\n+                                      bool for_compiler_entry, vmIntrinsics::ID iid);\n","filename":"src\/hotspot\/cpu\/riscv\/methodHandles_riscv.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}