{"files":[{"patch":"@@ -529,1 +529,1 @@\n-      vm_exit_during_initialization(\"At least one of AOTCacheOutput and AOTConfiguration must be specified when using -XX:AOTMode=record\");\n+    vm_exit_during_initialization(\"At least one of AOTCacheOutput and AOTConfiguration must be specified when using -XX:AOTMode=record\");\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -293,1 +293,1 @@\n-  FileMapInfo(const char* full_apth, bool is_static);\n+  FileMapInfo(const char* full_path, bool is_static);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -634,3 +634,2 @@\n-\/\/ return the \"scratch\" version that represents the same type T.\n-\/\/ Note that if java_mirror will be returned if it's already a\n-\/\/ scratch mirror.\n+\/\/ return the \"scratch\" version that represents the same type T. Note\n+\/\/ that java_mirror will be returned if the mirror is already a scratch mirror.\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -560,9 +560,8 @@\n-    if (CDSConfig::is_using_archive() &&\n-        HeapShared::is_archived_heap_in_use() &&\n-        _basic_type_mirrors[T_INT].resolve() != nullptr) {\n-      \/\/ check that all basic type mirrors are mapped also\n-      for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n-        if (!is_reference_type((BasicType)i)) {\n-          oop m = _basic_type_mirrors[i].resolve();\n-          assert(m != nullptr, \"archived mirrors should not be null\");\n-        }\n+  if (CDSConfig::is_using_archive() &&\n+      HeapShared::is_archived_heap_in_use() &&\n+      _basic_type_mirrors[T_INT].resolve() != nullptr) {\n+    \/\/ check that all basic type mirrors are mapped also\n+    for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+      if (!is_reference_type((BasicType)i)) {\n+        oop m = _basic_type_mirrors[i].resolve();\n+        assert(m != nullptr, \"archived mirrors should not be null\");\n@@ -570,2 +569,3 @@\n-    } else\n-      \/\/ _basic_type_mirrors[T_INT], etc, are null if not using an archived heap\n+    }\n+  } else\n+    \/\/ _basic_type_mirrors[T_INT], etc, are null if not using an archived heap\n@@ -573,8 +573,6 @@\n-    {\n-      for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n-        BasicType bt = (BasicType)i;\n-        if (!is_reference_type(bt)) {\n-          oop m = java_lang_Class::create_basic_type_mirror(type2name(bt), bt, CHECK);\n-          _basic_type_mirrors[i] = OopHandle(vm_global(), m);\n-        }\n-        CDS_JAVA_HEAP_ONLY(_archived_basic_type_mirror_indices[i] = -1);\n+  {\n+    for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+      BasicType bt = (BasicType)i;\n+      if (!is_reference_type(bt)) {\n+        oop m = java_lang_Class::create_basic_type_mirror(type2name(bt), bt, CHECK);\n+        _basic_type_mirrors[i] = OopHandle(vm_global(), m);\n@@ -582,0 +580,1 @@\n+      CDS_JAVA_HEAP_ONLY(_archived_basic_type_mirror_indices[i] = -1);\n@@ -583,3 +582,4 @@\n-    if (CDSConfig::is_dumping_heap()) {\n-      HeapShared::init_scratch_objects_for_basic_type_mirrors(CHECK);\n-    }\n+  }\n+  if (CDSConfig::is_dumping_heap()) {\n+    HeapShared::init_scratch_objects_for_basic_type_mirrors(CHECK);\n+  }\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"}]}