{"files":[{"patch":"@@ -798,2 +798,2 @@\n-#define DLR_ZOPC    (unsigned  int)(185 << 24 | 151 << 16)\n-#define DLGR_ZOPC   (unsigned  int)(185 << 24 | 135 << 16)\n+#define DLR_ZOPC    (unsigned  int)(0xb997 << 16)\n+#define DLGR_ZOPC   (unsigned  int)(0xb987 << 16)\n@@ -2260,0 +2260,2 @@\n+  inline void z_dlr(  Register r1, Register r2);      \/\/ div  r1 = r1 \/ r2               ; int64\/int32 needs reg pair!\n+  inline void z_dlgr( Register r1, Register r2);      \/\/ div  r1 = r1 \/ r2               ; int128\/int64 needs reg pair!\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -627,0 +627,2 @@\n+inline void Assembler::z_dlr(  Register r1, Register r2) { emit_32( DLR_ZOPC   | regt(r1, 24, 32) | reg(r2, 28, 32)); }\n+inline void Assembler::z_dlgr( Register r1, Register r2) { emit_32( DLGR_ZOPC  | regt(r1, 24, 32) | reg(r2, 28, 32)); }\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6256,0 +6256,23 @@\n+\/\/ Unsigned Integer Register Division\n+\/\/ NOTE: z_dlr requires even-odd pair. remainder will be in even register(r4) & quotient will be stored in odd register(r5)\n+\/\/ for dividend, upper 32bits will be in r4 and lower 32bits will be in r5 register.\n+instruct udivI_reg_reg(roddRegI r5_rodd_dst, iRegI src2, revenRegI r4_reven_tmp, flagsReg cr) %{\n+  match(Set r5_rodd_dst (UDivI r5_rodd_dst src2));\n+  effect(TEMP r4_reven_tmp, KILL cr);\n+  \/\/ TODO: size(4);\n+  format %{ \"UDIV $r5_rodd_dst, $r5_rodd_dst,$src2\" %}\n+  ins_encode %{\n+    Register b = $src2$$Register;\n+    Register r4_reven_tmp = $r4_reven_tmp$$Register;\n+    Register r5_rodd_dst  = $r5_rodd_dst$$Register;\n+    assert_different_registers(r4_reven_tmp, r5_rodd_dst, b);\n+    assert(r4_reven_tmp->successor() == r5_rodd_dst, \"even-odd pair required for the instruction\");\n+\n+    __ block_comment(\"unsigned_div_int {\");\n+    __ z_lhi(r4_reven_tmp, 0); \/\/ make upper 32bits 0\n+    __ z_dlr(r4_reven_tmp, b);\n+    __ block_comment(\"} unsigned_div_int\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n@@ -6312,0 +6335,22 @@\n+\/\/ Register Unsigned Long Division\n+\/\/ NOTE: z_dlgr requires even-odd pair. remainder will be in even register(r4) & quotient will be stored in odd register(r5)\n+\/\/ for dividend, upper 64bits will be in r4 and lower 64bits will be in r5 register.\n+instruct udivL_reg_reg(roddRegL r5_rodd_dst, iRegL src, revenRegL r4_reven_tmp, flagsReg cr) %{\n+  match(Set r5_rodd_dst (UDivL r5_rodd_dst src));\n+  effect(TEMP r4_reven_tmp, KILL cr);\n+  ins_cost(DEFAULT_COST);\n+  \/\/ TODO: size(4);\n+  format %{ \"UDIVG $r5_rodd_dst, $r5_rodd_dst, $src\" %}\n+  ins_encode %{\n+    Register b            = $src$$Register;\n+    Register r5_rodd_dst  = $r5_rodd_dst$$Register;\n+    Register r4_reven_tmp = $r4_reven_tmp$$Register;\n+    assert_different_registers(r5_rodd_dst, r4_reven_tmp, b);\n+    __ block_comment(\"unsigned_div_long {\");\n+    __ z_lghi(r4_reven_tmp, 0); \/\/ make upper 64bits 0\n+    __ z_dlgr(r4_reven_tmp, b);\n+    __ block_comment(\"} unsigned_div_long\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n@@ -6377,0 +6422,25 @@\n+\/\/ Register Unsigned Integer Remainder\n+\/\/ NOTE: z_dlr requires even-odd pair. remainder will be in even register(r4) & quotient will be stored in odd register(r5)\n+\/\/ for dividend, upper 32bits will be in r4 and lower 32bits will be in r5 register.\n+instruct umodI_reg_reg(revenRegI r4_reven_dst, iRegI src2, roddRegI r5_rodd_tmp, flagsReg cr) %{\n+  match(Set r4_reven_dst (UModI r4_reven_dst src2));\n+  effect(TEMP r5_rodd_tmp, KILL cr);\n+  ins_cost(DEFAULT_COST);\n+  \/\/ TODO: s390 port size(VARIABLE_SIZE);\n+  format %{ \"UMOD   $r4_reven_dst,$r4_reven_dst,$src2\" %}\n+  ins_encode %{\n+    Register b            = $src2$$Register;\n+    Register r4_reven_dst = $r4_reven_dst$$Register;\n+    Register r5_rodd_tmp  = $r5_rodd_tmp$$Register;\n+    assert_different_registers(r4_reven_dst, r5_rodd_tmp, b);\n+    assert(r4_reven_dst->successor() == r5_rodd_tmp, \"must be an even-odd pair\");\n+\n+    __ block_comment(\"unsigned_mod_integer {\");\n+    __ z_lr(r5_rodd_tmp, r4_reven_dst); \/\/ load lower 32bits in odd register\n+    __ z_lhi(r4_reven_dst, 0);          \/\/ make upper 32bits 0\n+    __ z_dlr(r4_reven_dst, b);\n+    __ block_comment(\"} unsigned_mod_integer\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n@@ -6440,0 +6510,25 @@\n+\/\/ Register Unsigned Long Remainder\n+\/\/ NOTE: z_dlgr requires even-odd pair. remainder will be in even register(r4) & quotient will be stored in odd register(r5)\n+\/\/ for dividend, upper 64bits will be in r4 and lower 64bits will be in r5 register.\n+instruct umodL_reg_reg(revenRegL r4_reven_dst, roddRegL r5_rodd_tmp, iRegL src2, flagsReg cr) %{\n+  match(Set r4_reven_dst (UModL r4_reven_dst src2));\n+  effect(TEMP r5_rodd_tmp, KILL cr);\n+  ins_cost(DEFAULT_COST);\n+  \/\/ TODO: s390 port size(VARIABLE_SIZE);\n+  format %{ \"UMODG   $r4_reven_dst,$r4_reven_dst,$src2\" %}\n+  ins_encode %{\n+    Register b            = $src2$$Register;\n+    Register r4_reven_dst = $r4_reven_dst$$Register;\n+    Register r5_rodd_tmp  = $r5_rodd_tmp$$Register;\n+    assert_different_registers(r4_reven_dst, r5_rodd_tmp, b);\n+    assert(r4_reven_dst->successor() == r5_rodd_tmp, \"instruction requires an even-odd pair\" );\n+\n+    __ block_comment(\"unsigned_mod_long {\");\n+    __ z_lgr(r5_rodd_tmp, r4_reven_dst); \/\/ load lower 64bits in even register\n+    __ z_lghi(r4_reven_dst, 0);          \/\/ make upper 64bits 0\n+    __ z_dlgr(r4_reven_dst, b);\n+    __ block_comment(\"} unsigned_mod_long\");\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":95,"deletions":0,"binary":false,"changes":95,"status":"modified"}]}