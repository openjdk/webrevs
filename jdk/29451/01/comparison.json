{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-                        new DwarfConstraint(0, \"Java_TestDwarf_crashNativeDivByZero\", \"libTestDwarf.c\", 59));\n+                        new DwarfConstraint(0, \"Java_TestDwarf_crashNativeDivByZero\", \"libTestDwarf.c\", 62));\n@@ -113,2 +113,10 @@\n-                        new DwarfConstraint(0, \"foo\", \"libTestDwarf.c\", 42),\n-                        new DwarfConstraint(1, \"Java_TestDwarf_crashNativeMultipleMethods\", \"libTestDwarf.c\", 70));\n+                        new DwarfConstraint(0, \"foo\", \"libTestDwarf.c\", 45),\n+                        new DwarfConstraint(1, \"Java_TestDwarf_crashNativeMultipleMethods\", \"libTestDwarf.c\", 73));\n+        }\n+        \/\/ Null pointer dereferences exhibit different behaviour depending on if GCC or Clang is used.\n+        \/\/ When using GCC, the VM will crash gracefully and generate a hs_err which can be parsed.\n+        \/\/ On the contrary, with Clang the process exits immediately without hs_err.\n+        \/\/ Since runAndCheck needs an hs_err file, we have to skip this subtest.\n+        if (!isUsingClang()) {\n+            runAndCheck(new Flags(TestDwarf.class.getCanonicalName(), \"nativeDereferenceNull\"),\n+                        new DwarfConstraint(0, \"dereference_null\", \"libTestDwarfHelper.h\", 49));\n@@ -116,2 +124,0 @@\n-        runAndCheck(new Flags(TestDwarf.class.getCanonicalName(), \"nativeDereferenceNull\"),\n-                    new DwarfConstraint(0, \"dereference_null\", \"libTestDwarfHelper.h\", 46));\n@@ -243,0 +249,1 @@\n+    private static native boolean isUsingClang();\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TestDwarf.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,4 @@\n-\/\/ Just big enough by doing some random things such that it is not inlined.\n+\/\/ Explicitly don't inline: foo is large enough that GCC won't inline it, but Clang might.\n+#if !defined(_MSC_VER)\n+__attribute__((noinline))\n+#endif\n@@ -79,0 +82,9 @@\n+\/\/ Need to tell if Clang was used to build libTestDwarf.\n+JNIEXPORT jboolean JNICALL Java_TestDwarf_isUsingClang(JNIEnv* env, jobject obj) {\n+#if defined(__clang__)\n+    return JNI_TRUE;\n+#else\n+    return JNI_FALSE;\n+#endif\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/libTestDwarf.c","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,3 @@\n+#if !defined(_MSC_VER)\n+__attribute__((noinline))\n+#endif\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/libTestDwarfHelper.h","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}