{"files":[{"patch":"@@ -892,0 +892,1 @@\n+    @ForceInline\n@@ -897,0 +898,1 @@\n+    @ForceInline\n@@ -903,0 +905,1 @@\n+    @ForceInline\n@@ -909,0 +912,1 @@\n+    @ForceInline\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.util.ByteArrayLittleEndian;\n@@ -53,0 +52,1 @@\n+    private static final long LONG_MASK = ~7L; \/\/ The last three bits are zero\n@@ -78,1 +78,1 @@\n-            for (; offset < limit; offset += 8) {\n+            for (; offset < limit; offset += Long.BYTES) {\n@@ -83,1 +83,1 @@\n-            if (remaining >= 4) {\n+            if (remaining >= Integer.BYTES) {\n@@ -85,2 +85,2 @@\n-                offset += 4;\n-                remaining -= 4;\n+                offset += Integer.BYTES;\n+                remaining -= Integer.BYTES;\n@@ -89,1 +89,1 @@\n-            if (remaining >= 2) {\n+            if (remaining >= Short.BYTES) {\n@@ -91,2 +91,2 @@\n-                offset += 2;\n-                remaining -= 2;\n+                offset += Short.BYTES;\n+                remaining -= Short.BYTES;\n@@ -126,1 +126,1 @@\n-            final int limit = (int) (size & (NATIVE_THRESHOLD_COPY - 8));\n+            final int limit = (int) (size & (NATIVE_THRESHOLD_COPY - Long.BYTES));\n@@ -128,1 +128,1 @@\n-            for (; offset < limit; offset += 8) {\n+            for (; offset < limit; offset += Long.BYTES) {\n@@ -134,1 +134,1 @@\n-            if (remaining >= 4) {\n+            if (remaining >= Integer.BYTES) {\n@@ -137,2 +137,2 @@\n-                offset += 4;\n-                remaining -= 4;\n+                offset += Integer.BYTES;\n+                remaining -= Integer.BYTES;\n@@ -141,1 +141,1 @@\n-            if (remaining >= 2) {\n+            if (remaining >= Short.BYTES) {\n@@ -144,2 +144,2 @@\n-                offset += 2;\n-                remaining -=2;\n+                offset += Short.BYTES;\n+                remaining -= Short.BYTES;\n@@ -205,1 +205,1 @@\n-        final long longBytes = length & ((1L << 62) - 8);\n+        final long longBytes = length & LONG_MASK;\n@@ -207,1 +207,1 @@\n-        for (; fromOffset < limit; fromOffset += 8) {\n+        for (; fromOffset < limit; fromOffset += Long.BYTES) {\n@@ -221,1 +221,1 @@\n-        if (remaining >= 4) {\n+        if (remaining >= Integer.BYTES) {\n@@ -228,2 +228,2 @@\n-            fromOffset += 4;\n-            remaining -= 4;\n+            fromOffset += Integer.BYTES;\n+            remaining -= Integer.BYTES;\n@@ -232,1 +232,1 @@\n-        if (remaining >= 2) {\n+        if (remaining >= Short.BYTES) {\n@@ -237,2 +237,2 @@\n-            fromOffset += 2;\n-            remaining -= 2;\n+            fromOffset += Short.BYTES;\n+            remaining -= Short.BYTES;\n@@ -291,1 +291,1 @@\n-        for (; offset < limit; offset += 8) {\n+        for (; offset < limit; offset += Long.BYTES) {\n@@ -301,1 +301,1 @@\n-        if (remaining >= 4) {\n+        if (remaining >= Integer.BYTES) {\n@@ -307,2 +307,2 @@\n-            offset += 4;\n-            remaining -= 4;\n+            offset += Integer.BYTES;\n+            remaining -= Integer.BYTES;\n@@ -311,1 +311,1 @@\n-        if (remaining >= 2) {\n+        if (remaining >= Short.BYTES) {\n@@ -317,2 +317,2 @@\n-            offset += 2;\n-            remaining -= 2;\n+            offset += Short.BYTES;\n+            remaining -= Short.BYTES;\n@@ -381,0 +381,192 @@\n+    \/\/private static final HexFormat HF = HexFormat.ofDelimiter(\" \");\n+\n+    \/**\n+     * {@return the shortest distance beginning at the provided {@code fromOffset}\n+     *          to the encountering of a zero byte in the provided {@code segment}\n+     *          checking bytes before the {@code toOffset}}\n+     * <p>\n+     * The method is using a heuristic method to determine if a long word contains a\n+     * zero byte. The method might have false positives but never false negatives.\n+     * <p>\n+     * This method is inspired by the `glibc\/string\/strlen.c` implementation\n+     *\n+     * @param segment    to examine\n+     * @param fromOffset from where examination shall begin (inclusive)\n+     * @param toOffset   to where examination shall end (exclusive)\n+     * @throws IllegalArgumentException if the examined region contains no zero bytes\n+     *                                  within a length that can be accepted by a String\n+     *\/\n+    @ForceInline\n+    public static int strlenByte(final AbstractMemorySegmentImpl segment,\n+                                 final long fromOffset,\n+                                 final long toOffset) {\n+        final long length = toOffset - fromOffset;\n+        segment.checkBounds(fromOffset, length);\n+        if (length == 0) {\n+            \/\/ The state has to be checked explicitly for zero-length segments\n+            segment.scope.checkValidState();\n+            throw stringTooLarge(segment, fromOffset, toOffset);\n+        }\n+        final long longBytes = length & LONG_MASK;\n+        final long longLimit = fromOffset + longBytes;\n+        long offset = fromOffset;\n+        for (; offset < longLimit; offset += Long.BYTES) {\n+            long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (mightContainZeroByte(val)) {\n+                for (int j = 0; j < Long.BYTES; j++) {\n+                    if (SCOPED_MEMORY_ACCESS.getByte(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset + j) == 0) {\n+                        return requireWithinArraySize(offset + j - fromOffset, segment, fromOffset, toOffset);\n+                    }\n+                }\n+            }\n+        }\n+        \/\/ Handle the tail\n+        for (; offset < toOffset; offset++) {\n+            byte val = SCOPED_MEMORY_ACCESS.getByte(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset);\n+            if (val == 0) {\n+                return requireWithinArraySize(offset - fromOffset, segment, fromOffset, toOffset);\n+            }\n+        }\n+        throw nullNotFound(segment, fromOffset, toOffset);\n+    }\n+\n+    @ForceInline\n+    public static int strlenShort(final AbstractMemorySegmentImpl segment,\n+                                  final long fromOffset,\n+                                  final long toOffset) {\n+        final long length = toOffset - fromOffset;\n+        segment.checkBounds(fromOffset, length);\n+        if (length == 0) {\n+            segment.scope.checkValidState();\n+            throw stringTooLarge(segment, fromOffset, toOffset);\n+        }\n+        final long longBytes = length & LONG_MASK;\n+        final long longLimit = fromOffset + longBytes;\n+        long offset = fromOffset;\n+        for (; offset < longLimit; offset += Long.BYTES) {\n+            long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (mightContainZeroShort(val)) {\n+                for (int j = 0; j < Long.BYTES; j += Short.BYTES) {\n+                    if (SCOPED_MEMORY_ACCESS.getShortUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset + j, !Architecture.isLittleEndian()) == 0) {\n+                        return requireWithinArraySize(offset + j - fromOffset, segment, fromOffset, toOffset);\n+                    }\n+                }\n+            }\n+        }\n+        \/\/ Handle the tail\n+        \/\/ Prevent over scanning as we step by 2\n+        final long endScan = toOffset & ~1; \/\/ The last bit is zero\n+        for (; offset < endScan; offset += Short.BYTES) {\n+            short val = SCOPED_MEMORY_ACCESS.getShortUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (val == 0) {\n+                return requireWithinArraySize(offset - fromOffset, segment, fromOffset, toOffset);\n+            }\n+        }\n+        throw nullNotFound(segment, fromOffset, toOffset);\n+    }\n+\n+    @ForceInline\n+    public static int strlenInt(final AbstractMemorySegmentImpl segment,\n+                                final long fromOffset,\n+                                final long toOffset) {\n+        final long length = toOffset - fromOffset;\n+        segment.checkBounds(fromOffset, length);\n+        if (length == 0) {\n+            segment.scope.checkValidState();\n+            throw stringTooLarge(segment, fromOffset, toOffset);\n+        }\n+        final long longBytes = length & LONG_MASK;\n+        final long longLimit = fromOffset + longBytes;\n+        long offset = fromOffset;\n+        for (; offset < longLimit; offset += Long.BYTES) {\n+            long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (mightContainZeroShort(val)) {\n+                for (int j = 0; j < Long.BYTES; j += Integer.BYTES) {\n+                    if (SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset + j, !Architecture.isLittleEndian()) == 0) {\n+                        return requireWithinArraySize(offset + j - fromOffset, segment, fromOffset, toOffset);\n+                    }\n+                }\n+            }\n+        }\n+        \/\/ Handle the tail\n+        \/\/ Prevent over scanning as we step by 4\n+        final long endScan = toOffset & ~3; \/\/ The last two bit are zero\n+        for (; offset < endScan; offset += Integer.BYTES) {\n+            int val = SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (val == 0) {\n+                return requireWithinArraySize(offset - fromOffset, segment, fromOffset, toOffset);\n+            }\n+        }\n+        throw nullNotFound(segment, fromOffset, toOffset);\n+    }\n+\n+\n+\/*    \/\/ The gain of using `long` wide operations for `int` is lower than for the two other\n+    \/\/ `byte` and `short` variants so, there is only a simpler method for `int`s\n+    @ForceInline\n+    public static int strlenInt(AbstractMemorySegmentImpl segment, long fromOffset, long toOffset) {\n+        long length = Math.min(toOffset - fromOffset, ArraysSupport.SOFT_MAX_ARRAY_LENGTH) & ~3;\n+        for (int offset = 0; offset < length; offset += Integer.BYTES) {\n+            \/\/ We are guaranteed to be aligned here so, we can use unaligned access.\n+            int val = SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (val == 0) {\n+                return offset;\n+            }\n+        }\n+        throw nullNotFound(segment, fromOffset, toOffset);\n+    }*\/\n+\n+    \/*\n+    Bits 63 and N * 8 (N = 1..7) of this number are zero.  Call these bits\n+    the \"holes\".  Note that there is a hole just to the left of\n+    each byte, with an extra at the end:\n+\n+    bits:  01111110 11111110 11111110 11111110 11111110 11111110 11111110 11111111\n+    bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF GGGGGGGG HHHHHHHH\n+\n+    The 1-bits make sure that carries propagate to the next 0-bit.\n+    The 0-bits provide holes for carries to fall into.\n+    *\/\n+    private static final long HIMAGIC_FOR_BYTES = 0x8080_8080_8080_8080L;\n+    private static final long LOMAGIC_FOR_BYTES = 0x0101_0101_0101_0101L;\n+\n+    private static boolean mightContainZeroByte(long l) {\n+        return ((l - LOMAGIC_FOR_BYTES) & (~l) & HIMAGIC_FOR_BYTES) != 0;\n+    }\n+\n+    private static final long HIMAGIC_FOR_SHORTS = 0x8000_8000_8000_8000L;\n+    private static final long LOMAGIC_FOR_SHORTS = 0x0001_0001_0001_0001L;\n+\n+    static boolean mightContainZeroShort(long l) {\n+        return ((l - LOMAGIC_FOR_SHORTS) & (~l) & HIMAGIC_FOR_SHORTS) != 0;\n+    }\n+\n+\n+    private static int requireWithinArraySize(long size,\n+                                              AbstractMemorySegmentImpl segment,\n+                                              long fromOffset,\n+                                              long toOffset) {\n+        if (size > ArraysSupport.SOFT_MAX_ARRAY_LENGTH) {\n+            throw stringTooLarge(segment, fromOffset, toOffset);\n+        }\n+        return (int) size;\n+    }\n+\n+    private static IllegalArgumentException stringTooLarge(AbstractMemorySegmentImpl segment,\n+                                                           long fromOffset,\n+                                                           long toOffset) {\n+        return new IllegalArgumentException(\"String too large: \" + exceptionInfo(segment, fromOffset, toOffset));\n+    }\n+\n+    private static IndexOutOfBoundsException nullNotFound(AbstractMemorySegmentImpl segment,\n+                                                          long fromOffset,\n+                                                          long toOffset) {\n+        return new IndexOutOfBoundsException(\"No null terminator found: \" + exceptionInfo(segment, fromOffset, toOffset));\n+    }\n+\n+    private static String exceptionInfo(AbstractMemorySegmentImpl segment,\n+                                        long fromOffset,\n+                                        long toOffset) {\n+        return segment + \" using region [\" + fromOffset + \", \" + toOffset + \")\";\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":223,"deletions":31,"binary":false,"changes":254,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.util.ArraysSupport;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -47,1 +46,2 @@\n-    public static String read(MemorySegment segment, long offset, Charset charset) {\n+    @ForceInline\n+    public static String read(AbstractMemorySegmentImpl segment, long offset, Charset charset) {\n@@ -55,1 +55,2 @@\n-    public static void write(MemorySegment segment, long offset, Charset charset, String string) {\n+    @ForceInline\n+    public static void write(AbstractMemorySegmentImpl segment, long offset, Charset charset, String string) {\n@@ -63,4 +64,5 @@\n-    private static String readByte(MemorySegment segment, long offset, Charset charset) {\n-        long len = chunkedStrlenByte(segment, offset);\n-        byte[] bytes = new byte[(int)len];\n-        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+    @ForceInline\n+    private static String readByte(AbstractMemorySegmentImpl segment, long offset, Charset charset) {\n+        final int len = SegmentBulkOperations.strlenByte(segment, offset, segment.byteSize());\n+        final byte[] bytes = new byte[len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, len);\n@@ -70,1 +72,2 @@\n-    private static void writeByte(MemorySegment segment, long offset, Charset charset, String string) {\n+    @ForceInline\n+    private static void writeByte(AbstractMemorySegmentImpl segment, long offset, Charset charset, String string) {\n@@ -75,4 +78,5 @@\n-    private static String readShort(MemorySegment segment, long offset, Charset charset) {\n-        long len = chunkedStrlenShort(segment, offset);\n-        byte[] bytes = new byte[(int)len];\n-        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+    @ForceInline\n+    private static String readShort(AbstractMemorySegmentImpl segment, long offset, Charset charset) {\n+        int len = SegmentBulkOperations.strlenShort(segment, offset, segment.byteSize());\n+        byte[] bytes = new byte[len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, len);\n@@ -82,1 +86,2 @@\n-    private static void writeShort(MemorySegment segment, long offset, Charset charset, String string) {\n+    @ForceInline\n+    private static void writeShort(AbstractMemorySegmentImpl segment, long offset, Charset charset, String string) {\n@@ -87,4 +92,5 @@\n-    private static String readInt(MemorySegment segment, long offset, Charset charset) {\n-        long len = strlenInt(segment, offset);\n-        byte[] bytes = new byte[(int)len];\n-        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+    @ForceInline\n+    private static String readInt(AbstractMemorySegmentImpl segment, long offset, Charset charset) {\n+        int len = SegmentBulkOperations.strlenInt(segment, offset, segment.byteSize());\n+        byte[] bytes = new byte[len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, len);\n@@ -94,1 +100,2 @@\n-    private static void writeInt(MemorySegment segment, long offset, Charset charset, String string) {\n+    @ForceInline\n+    private static void writeInt(AbstractMemorySegmentImpl segment, long offset, Charset charset, String string) {\n@@ -99,174 +106,0 @@\n-    \/**\n-     * {@return the shortest distance beginning at the provided {@code start}\n-     *  to the encountering of a zero byte in the provided {@code segment}}\n-     * <p>\n-     * The method divides the region of interest into three distinct regions:\n-     * <ul>\n-     *     <li>head (access made on a byte-by-byte basis) (if any)<\/li>\n-     *     <li>body (access made with eight bytes at a time at physically 64-bit-aligned memory) (if any)<\/li>\n-     *     <li>tail (access made on a byte-by-byte basis) (if any)<\/li>\n-     * <\/ul>\n-     * <p>\n-     * The body is using a heuristic method to determine if a long word\n-     * contains a zero byte. The method might have false positives but\n-     * never false negatives.\n-     * <p>\n-     * This method is inspired by the `glibc\/string\/strlen.c` implementation\n-     *\n-     * @param segment to examine\n-     * @param start   from where examination shall begin\n-     * @throws IllegalArgumentException if the examined region contains no zero bytes\n-     *                                  within a length that can be accepted by a String\n-     *\/\n-    public static int chunkedStrlenByte(MemorySegment segment, long start) {\n-\n-        \/\/ Handle the first unaligned \"head\" bytes separately\n-        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n-\n-        int offset = 0;\n-        for (; offset < headCount; offset++) {\n-            byte curr = segment.get(JAVA_BYTE, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-\n-        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n-        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n-\n-        for (; offset < bodyCount; offset += Long.BYTES) {\n-            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n-            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n-            \/\/ Is this a candidate?\n-            if (mightContainZeroByte(curr)) {\n-                for (int j = 0; j < 8; j++) {\n-                    if (segment.get(JAVA_BYTE, start + offset + j) == 0) {\n-                        return offset + j;\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ Handle the \"tail\"\n-        return requireWithinArraySize((long) offset + strlenByte(segment, start + offset));\n-    }\n-\n-    \/* Bits 63 and N * 8 (N = 1..7) of this number are zero.  Call these bits\n-       the \"holes\".  Note that there is a hole just to the left of\n-       each byte, with an extra at the end:\n-\n-       bits:  01111110 11111110 11111110 11111110 11111110 11111110 11111110 11111111\n-       bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF GGGGGGGG HHHHHHHH\n-\n-       The 1-bits make sure that carries propagate to the next 0-bit.\n-       The 0-bits provide holes for carries to fall into.\n-    *\/\n-    private static final long HIMAGIC_FOR_BYTES = 0x8080_8080_8080_8080L;\n-    private static final long LOMAGIC_FOR_BYTES = 0x0101_0101_0101_0101L;\n-\n-    static boolean mightContainZeroByte(long l) {\n-        return ((l - LOMAGIC_FOR_BYTES) & (~l) & HIMAGIC_FOR_BYTES) != 0;\n-    }\n-\n-    private static final long HIMAGIC_FOR_SHORTS = 0x8000_8000_8000_8000L;\n-    private static final long LOMAGIC_FOR_SHORTS = 0x0001_0001_0001_0001L;\n-\n-    static boolean mightContainZeroShort(long l) {\n-        return ((l - LOMAGIC_FOR_SHORTS) & (~l) & HIMAGIC_FOR_SHORTS) != 0;\n-    }\n-\n-    static int requireWithinArraySize(long size) {\n-        if (size > ArraysSupport.SOFT_MAX_ARRAY_LENGTH) {\n-            throw newIaeStringTooLarge();\n-        }\n-        return (int) size;\n-    }\n-\n-    static int bodyCount(long remaining) {\n-        return (int) Math.min(\n-                \/\/ Make sure we do not wrap around\n-                Integer.MAX_VALUE - Long.BYTES,\n-                \/\/ Remaining bytes to consider\n-                remaining)\n-                & -Long.BYTES; \/\/ Mask 0xFFFFFFF8\n-    }\n-\n-    private static int strlenByte(MemorySegment segment, long start) {\n-        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += 1) {\n-            byte curr = segment.get(JAVA_BYTE, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-        throw newIaeStringTooLarge();\n-    }\n-\n-    \/**\n-     * {@return the shortest distance beginning at the provided {@code start}\n-     *  to the encountering of a zero short in the provided {@code segment}}\n-     * <p>\n-     * Note: The inspected region must be short aligned.\n-     *\n-     * @see #chunkedStrlenByte(MemorySegment, long) for more information\n-     *\n-     * @param segment to examine\n-     * @param start   from where examination shall begin\n-     * @throws IllegalArgumentException if the examined region contains no zero shorts\n-     *                                  within a length that can be accepted by a String\n-     *\/\n-    public static int chunkedStrlenShort(MemorySegment segment, long start) {\n-\n-        \/\/ Handle the first unaligned \"head\" bytes separately\n-        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n-\n-        int offset = 0;\n-        for (; offset < headCount; offset += Short.BYTES) {\n-            short curr = segment.get(JAVA_SHORT_UNALIGNED, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-\n-        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n-        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n-\n-        for (; offset < bodyCount; offset += Long.BYTES) {\n-            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n-            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n-            \/\/ Is this a candidate?\n-            if (mightContainZeroShort(curr)) {\n-                for (int j = 0; j < Long.BYTES; j += Short.BYTES) {\n-                    if (segment.get(JAVA_SHORT_UNALIGNED, start + offset + j) == 0) {\n-                        return offset + j;\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ Handle the \"tail\"\n-        return requireWithinArraySize((long) offset + strlenShort(segment, start + offset));\n-    }\n-\n-    private static int strlenShort(MemorySegment segment, long start) {\n-        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Short.BYTES) {\n-            short curr = segment.get(JAVA_SHORT_UNALIGNED, start + offset);\n-            if (curr == (short)0) {\n-                return offset;\n-            }\n-        }\n-        throw newIaeStringTooLarge();\n-    }\n-\n-    \/\/ The gain of using `long` wide operations for `int` is lower than for the two other `byte` and `short` variants\n-    \/\/ so, there is only one method for ints.\n-    public static int strlenInt(MemorySegment segment, long start) {\n-        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Integer.BYTES) {\n-            \/\/ We are guaranteed to be aligned here so, we can use unaligned access.\n-            int curr = segment.get(JAVA_INT_UNALIGNED, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-        throw newIaeStringTooLarge();\n-    }\n-\n@@ -326,5 +159,0 @@\n-\n-    private static IllegalArgumentException newIaeStringTooLarge() {\n-        return new IllegalArgumentException(\"String too large\");\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":26,"deletions":198,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.util.HexFormat;\n@@ -42,0 +43,2 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.SegmentBulkOperations;\n@@ -90,1 +93,0 @@\n-\n@@ -201,0 +203,1 @@\n+                        String expected = testString.substring(i);\n@@ -202,1 +205,1 @@\n-                        assertEquals(actual, testString.substring(i));\n+                        assertEquals(actual, expected);\n@@ -274,1 +277,1 @@\n-                        int actual = StringSupport.chunkedStrlenByte(segment, j);\n+                        int actual = SegmentBulkOperations.strlenByte((AbstractMemorySegmentImpl) segment, j, segment.byteSize());\n@@ -298,1 +301,1 @@\n-                        int actual = StringSupport.chunkedStrlenShort(segment, j * Short.BYTES);\n+                        int actual = SegmentBulkOperations.strlenShort((AbstractMemorySegmentImpl) segment, j * Short.BYTES, segment.byteSize());\n@@ -322,1 +325,1 @@\n-                        int actual = StringSupport.strlenInt(segment, j * Integer.BYTES);\n+                        int actual = SegmentBulkOperations.strlenInt((AbstractMemorySegmentImpl) segment, j * Integer.BYTES, segment.byteSize());\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.SegmentBulkOperations;\n@@ -53,1 +55,2 @@\n-@Fork(value = 3, jvmArgs = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\", \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+@Fork(value = 3, jvmArgs = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\",\n+                            \"--enable-native-access=ALL-UNNAMED\"})\n@@ -56,4 +59,4 @@\n-    private MemorySegment singleByteSegment;\n-    private MemorySegment singleByteSegmentMisaligned;\n-    private MemorySegment doubleByteSegment;\n-    private MemorySegment quadByteSegment;\n+    private AbstractMemorySegmentImpl singleByteSegment;\n+    private AbstractMemorySegmentImpl singleByteSegmentMisaligned;\n+    private AbstractMemorySegmentImpl doubleByteSegment;\n+    private AbstractMemorySegmentImpl quadByteSegment;\n@@ -67,4 +70,3 @@\n-        singleByteSegment = arena.allocate((size + 1L) * Byte.BYTES);\n-        singleByteSegmentMisaligned = arena.allocate((size + 1L) * Byte.BYTES);\n-        doubleByteSegment = arena.allocate((size + 1L) * Short.BYTES);\n-        quadByteSegment = arena.allocate((size + 1L) * Integer.BYTES);\n+        singleByteSegment = (AbstractMemorySegmentImpl) arena.allocate((size + 1L) * Byte.BYTES);\n+        doubleByteSegment = (AbstractMemorySegmentImpl) arena.allocate((size + 1L) * Short.BYTES);\n+        quadByteSegment = (AbstractMemorySegmentImpl) arena.allocate((size + 1L) * Integer.BYTES);\n@@ -81,1 +83,1 @@\n-        singleByteSegmentMisaligned = arena.allocate(singleByteSegment.byteSize() + 1).\n+        singleByteSegmentMisaligned = (AbstractMemorySegmentImpl) arena.allocate(singleByteSegment.byteSize() + 1).\n@@ -108,1 +110,1 @@\n-        return chunkedStrlenByte(singleByteSegment, 0);\n+        return SegmentBulkOperations.strlenByte(singleByteSegment, 0, singleByteSegment.byteSize());\n@@ -113,1 +115,1 @@\n-        return chunkedStrlenByte(singleByteSegmentMisaligned, 0);\n+        return SegmentBulkOperations.strlenByte(singleByteSegmentMisaligned, 0, singleByteSegment.byteSize());\n@@ -118,1 +120,1 @@\n-        return chunkedStrlenShort(doubleByteSegment, 0);\n+        return SegmentBulkOperations.strlenShort(doubleByteSegment, 0, doubleByteSegment.byteSize());\n@@ -123,1 +125,1 @@\n-        return strlenInt(quadByteSegment, 0);\n+        return SegmentBulkOperations.strlenInt(quadByteSegment, 0, quadByteSegment.byteSize());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/InternalStrLen.java","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"}]}