{"files":[{"patch":"@@ -381,192 +381,0 @@\n-    \/\/private static final HexFormat HF = HexFormat.ofDelimiter(\" \");\n-\n-    \/**\n-     * {@return the shortest distance beginning at the provided {@code fromOffset}\n-     *          to the encountering of a zero byte in the provided {@code segment}\n-     *          checking bytes before the {@code toOffset}}\n-     * <p>\n-     * The method is using a heuristic method to determine if a long word contains a\n-     * zero byte. The method might have false positives but never false negatives.\n-     * <p>\n-     * This method is inspired by the `glibc\/string\/strlen.c` implementation\n-     *\n-     * @param segment    to examine\n-     * @param fromOffset from where examination shall begin (inclusive)\n-     * @param toOffset   to where examination shall end (exclusive)\n-     * @throws IllegalArgumentException if the examined region contains no zero bytes\n-     *                                  within a length that can be accepted by a String\n-     *\/\n-    @ForceInline\n-    public static int strlenByte(final AbstractMemorySegmentImpl segment,\n-                                 final long fromOffset,\n-                                 final long toOffset) {\n-        final long length = toOffset - fromOffset;\n-        segment.checkBounds(fromOffset, length);\n-        if (length == 0) {\n-            \/\/ The state has to be checked explicitly for zero-length segments\n-            segment.scope.checkValidState();\n-            throw stringTooLarge(segment, fromOffset, toOffset);\n-        }\n-        final long longBytes = length & LONG_MASK;\n-        final long longLimit = fromOffset + longBytes;\n-        long offset = fromOffset;\n-        for (; offset < longLimit; offset += Long.BYTES) {\n-            long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n-            if (mightContainZeroByte(val)) {\n-                for (int j = 0; j < Long.BYTES; j++) {\n-                    if (SCOPED_MEMORY_ACCESS.getByte(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset + j) == 0) {\n-                        return requireWithinArraySize(offset + j - fromOffset, segment, fromOffset, toOffset);\n-                    }\n-                }\n-            }\n-        }\n-        \/\/ Handle the tail\n-        for (; offset < toOffset; offset++) {\n-            byte val = SCOPED_MEMORY_ACCESS.getByte(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset);\n-            if (val == 0) {\n-                return requireWithinArraySize(offset - fromOffset, segment, fromOffset, toOffset);\n-            }\n-        }\n-        throw nullNotFound(segment, fromOffset, toOffset);\n-    }\n-\n-    @ForceInline\n-    public static int strlenShort(final AbstractMemorySegmentImpl segment,\n-                                  final long fromOffset,\n-                                  final long toOffset) {\n-        final long length = toOffset - fromOffset;\n-        segment.checkBounds(fromOffset, length);\n-        if (length == 0) {\n-            segment.scope.checkValidState();\n-            throw stringTooLarge(segment, fromOffset, toOffset);\n-        }\n-        final long longBytes = length & LONG_MASK;\n-        final long longLimit = fromOffset + longBytes;\n-        long offset = fromOffset;\n-        for (; offset < longLimit; offset += Long.BYTES) {\n-            long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n-            if (mightContainZeroShort(val)) {\n-                for (int j = 0; j < Long.BYTES; j += Short.BYTES) {\n-                    if (SCOPED_MEMORY_ACCESS.getShortUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset + j, !Architecture.isLittleEndian()) == 0) {\n-                        return requireWithinArraySize(offset + j - fromOffset, segment, fromOffset, toOffset);\n-                    }\n-                }\n-            }\n-        }\n-        \/\/ Handle the tail\n-        \/\/ Prevent over scanning as we step by 2\n-        final long endScan = toOffset & ~1; \/\/ The last bit is zero\n-        for (; offset < endScan; offset += Short.BYTES) {\n-            short val = SCOPED_MEMORY_ACCESS.getShortUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n-            if (val == 0) {\n-                return requireWithinArraySize(offset - fromOffset, segment, fromOffset, toOffset);\n-            }\n-        }\n-        throw nullNotFound(segment, fromOffset, toOffset);\n-    }\n-\n-    @ForceInline\n-    public static int strlenInt(final AbstractMemorySegmentImpl segment,\n-                                final long fromOffset,\n-                                final long toOffset) {\n-        final long length = toOffset - fromOffset;\n-        segment.checkBounds(fromOffset, length);\n-        if (length == 0) {\n-            segment.scope.checkValidState();\n-            throw stringTooLarge(segment, fromOffset, toOffset);\n-        }\n-        final long longBytes = length & LONG_MASK;\n-        final long longLimit = fromOffset + longBytes;\n-        long offset = fromOffset;\n-        for (; offset < longLimit; offset += Long.BYTES) {\n-            long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n-            if (mightContainZeroShort(val)) {\n-                for (int j = 0; j < Long.BYTES; j += Integer.BYTES) {\n-                    if (SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset + j, !Architecture.isLittleEndian()) == 0) {\n-                        return requireWithinArraySize(offset + j - fromOffset, segment, fromOffset, toOffset);\n-                    }\n-                }\n-            }\n-        }\n-        \/\/ Handle the tail\n-        \/\/ Prevent over scanning as we step by 4\n-        final long endScan = toOffset & ~3; \/\/ The last two bit are zero\n-        for (; offset < endScan; offset += Integer.BYTES) {\n-            int val = SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n-            if (val == 0) {\n-                return requireWithinArraySize(offset - fromOffset, segment, fromOffset, toOffset);\n-            }\n-        }\n-        throw nullNotFound(segment, fromOffset, toOffset);\n-    }\n-\n-\n-\/*    \/\/ The gain of using `long` wide operations for `int` is lower than for the two other\n-    \/\/ `byte` and `short` variants so, there is only a simpler method for `int`s\n-    @ForceInline\n-    public static int strlenInt(AbstractMemorySegmentImpl segment, long fromOffset, long toOffset) {\n-        long length = Math.min(toOffset - fromOffset, ArraysSupport.SOFT_MAX_ARRAY_LENGTH) & ~3;\n-        for (int offset = 0; offset < length; offset += Integer.BYTES) {\n-            \/\/ We are guaranteed to be aligned here so, we can use unaligned access.\n-            int val = SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n-            if (val == 0) {\n-                return offset;\n-            }\n-        }\n-        throw nullNotFound(segment, fromOffset, toOffset);\n-    }*\/\n-\n-    \/*\n-    Bits 63 and N * 8 (N = 1..7) of this number are zero.  Call these bits\n-    the \"holes\".  Note that there is a hole just to the left of\n-    each byte, with an extra at the end:\n-\n-    bits:  01111110 11111110 11111110 11111110 11111110 11111110 11111110 11111111\n-    bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF GGGGGGGG HHHHHHHH\n-\n-    The 1-bits make sure that carries propagate to the next 0-bit.\n-    The 0-bits provide holes for carries to fall into.\n-    *\/\n-    private static final long HIMAGIC_FOR_BYTES = 0x8080_8080_8080_8080L;\n-    private static final long LOMAGIC_FOR_BYTES = 0x0101_0101_0101_0101L;\n-\n-    private static boolean mightContainZeroByte(long l) {\n-        return ((l - LOMAGIC_FOR_BYTES) & (~l) & HIMAGIC_FOR_BYTES) != 0;\n-    }\n-\n-    private static final long HIMAGIC_FOR_SHORTS = 0x8000_8000_8000_8000L;\n-    private static final long LOMAGIC_FOR_SHORTS = 0x0001_0001_0001_0001L;\n-\n-    static boolean mightContainZeroShort(long l) {\n-        return ((l - LOMAGIC_FOR_SHORTS) & (~l) & HIMAGIC_FOR_SHORTS) != 0;\n-    }\n-\n-\n-    private static int requireWithinArraySize(long size,\n-                                              AbstractMemorySegmentImpl segment,\n-                                              long fromOffset,\n-                                              long toOffset) {\n-        if (size > ArraysSupport.SOFT_MAX_ARRAY_LENGTH) {\n-            throw stringTooLarge(segment, fromOffset, toOffset);\n-        }\n-        return (int) size;\n-    }\n-\n-    private static IllegalArgumentException stringTooLarge(AbstractMemorySegmentImpl segment,\n-                                                           long fromOffset,\n-                                                           long toOffset) {\n-        return new IllegalArgumentException(\"String too large: \" + exceptionInfo(segment, fromOffset, toOffset));\n-    }\n-\n-    private static IndexOutOfBoundsException nullNotFound(AbstractMemorySegmentImpl segment,\n-                                                          long fromOffset,\n-                                                          long toOffset) {\n-        return new IndexOutOfBoundsException(\"No null terminator found: \" + exceptionInfo(segment, fromOffset, toOffset));\n-    }\n-\n-    private static String exceptionInfo(AbstractMemorySegmentImpl segment,\n-                                        long fromOffset,\n-                                        long toOffset) {\n-        return segment + \" using region [\" + fromOffset + \", \" + toOffset + \")\";\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":0,"deletions":192,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.util.Architecture;\n+import jdk.internal.util.ArraysSupport;\n@@ -42,1 +45,3 @@\n-    static final JavaLangAccess JAVA_LANG_ACCESS = SharedSecrets.getJavaLangAccess();\n+    private static final JavaLangAccess JAVA_LANG_ACCESS = SharedSecrets.getJavaLangAccess();\n+    private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+    private static final long LONG_MASK = ~7L; \/\/ The last three bits are zero\n@@ -66,1 +71,1 @@\n-        final int len = SegmentBulkOperations.strlenByte(segment, offset, segment.byteSize());\n+        final int len = strlenByte(segment, offset, segment.byteSize());\n@@ -80,1 +85,1 @@\n-        int len = SegmentBulkOperations.strlenShort(segment, offset, segment.byteSize());\n+        int len = strlenShort(segment, offset, segment.byteSize());\n@@ -94,1 +99,1 @@\n-        int len = SegmentBulkOperations.strlenInt(segment, offset, segment.byteSize());\n+        int len = strlenInt(segment, offset, segment.byteSize());\n@@ -106,0 +111,174 @@\n+    \/**\n+     * {@return the shortest distance beginning at the provided {@code fromOffset}\n+     *          to the encountering of a zero byte in the provided {@code segment}\n+     *          checking bytes before the {@code toOffset}}\n+     * <p>\n+     * The method is using a heuristic method to determine if a long word contains a\n+     * zero byte. The method might have false positives but never false negatives.\n+     * <p>\n+     * This method is inspired by the `glibc\/string\/strlen.c` implementation\n+     *\n+     * @param segment    to examine\n+     * @param fromOffset from where examination shall begin (inclusive)\n+     * @param toOffset   to where examination shall end (exclusive)\n+     * @throws IllegalArgumentException if the examined region contains no zero bytes\n+     *                                  within a length that can be accepted by a String\n+     *\/\n+    @ForceInline\n+    public static int strlenByte(final AbstractMemorySegmentImpl segment,\n+                                 final long fromOffset,\n+                                 final long toOffset) {\n+        final long length = toOffset - fromOffset;\n+        segment.checkBounds(fromOffset, length);\n+        if (length == 0) {\n+            \/\/ The state has to be checked explicitly for zero-length segments\n+            segment.scope.checkValidState();\n+            throw stringTooLarge(segment, fromOffset, toOffset);\n+        }\n+        final long longBytes = length & LONG_MASK;\n+        final long longLimit = fromOffset + longBytes;\n+        long offset = fromOffset;\n+        for (; offset < longLimit; offset += Long.BYTES) {\n+            long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (mightContainZeroByte(val)) {\n+                for (int j = 0; j < Long.BYTES; j++) {\n+                    if (SCOPED_MEMORY_ACCESS.getByte(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset + j) == 0) {\n+                        return requireWithinArraySize(offset + j - fromOffset, segment, fromOffset, toOffset);\n+                    }\n+                }\n+            }\n+        }\n+        \/\/ Handle the tail\n+        for (; offset < toOffset; offset++) {\n+            byte val = SCOPED_MEMORY_ACCESS.getByte(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset);\n+            if (val == 0) {\n+                return requireWithinArraySize(offset - fromOffset, segment, fromOffset, toOffset);\n+            }\n+        }\n+        throw nullNotFound(segment, fromOffset, toOffset);\n+    }\n+\n+    @ForceInline\n+    public static int strlenShort(final AbstractMemorySegmentImpl segment,\n+                                  final long fromOffset,\n+                                  final long toOffset) {\n+        final long length = toOffset - fromOffset;\n+        segment.checkBounds(fromOffset, length);\n+        if (length == 0) {\n+            segment.scope.checkValidState();\n+            throw stringTooLarge(segment, fromOffset, toOffset);\n+        }\n+        final long longBytes = length & LONG_MASK;\n+        final long longLimit = fromOffset + longBytes;\n+        long offset = fromOffset;\n+        for (; offset < longLimit; offset += Long.BYTES) {\n+            long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (mightContainZeroShort(val)) {\n+                for (int j = 0; j < Long.BYTES; j += Short.BYTES) {\n+                    if (SCOPED_MEMORY_ACCESS.getShortUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset + j, !Architecture.isLittleEndian()) == 0) {\n+                        return requireWithinArraySize(offset + j - fromOffset, segment, fromOffset, toOffset);\n+                    }\n+                }\n+            }\n+        }\n+        \/\/ Handle the tail\n+        \/\/ Prevent over scanning as we step by 2\n+        final long endScan = toOffset & ~1; \/\/ The last bit is zero\n+        for (; offset < endScan; offset += Short.BYTES) {\n+            short val = SCOPED_MEMORY_ACCESS.getShortUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (val == 0) {\n+                return requireWithinArraySize(offset - fromOffset, segment, fromOffset, toOffset);\n+            }\n+        }\n+        throw nullNotFound(segment, fromOffset, toOffset);\n+    }\n+\n+    @ForceInline\n+    public static int strlenInt(final AbstractMemorySegmentImpl segment,\n+                                final long fromOffset,\n+                                final long toOffset) {\n+        final long length = toOffset - fromOffset;\n+        segment.checkBounds(fromOffset, length);\n+        if (length == 0) {\n+            segment.scope.checkValidState();\n+            throw stringTooLarge(segment, fromOffset, toOffset);\n+        }\n+        final long longBytes = length & LONG_MASK;\n+        final long longLimit = fromOffset + longBytes;\n+        long offset = fromOffset;\n+        for (; offset < longLimit; offset += Long.BYTES) {\n+            long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (mightContainZeroShort(val)) {\n+                for (int j = 0; j < Long.BYTES; j += Integer.BYTES) {\n+                    if (SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset + j, !Architecture.isLittleEndian()) == 0) {\n+                        return requireWithinArraySize(offset + j - fromOffset, segment, fromOffset, toOffset);\n+                    }\n+                }\n+            }\n+        }\n+        \/\/ Handle the tail\n+        \/\/ Prevent over scanning as we step by 4\n+        final long endScan = toOffset & ~3; \/\/ The last two bit are zero\n+        for (; offset < endScan; offset += Integer.BYTES) {\n+            int val = SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (val == 0) {\n+                return requireWithinArraySize(offset - fromOffset, segment, fromOffset, toOffset);\n+            }\n+        }\n+        throw nullNotFound(segment, fromOffset, toOffset);\n+    }\n+\n+    \/*\n+    Bits 63 and N * 8 (N = 1..7) of this number are zero.  Call these bits\n+    the \"holes\".  Note that there is a hole just to the left of\n+    each byte, with an extra at the end:\n+\n+    bits:  01111110 11111110 11111110 11111110 11111110 11111110 11111110 11111111\n+    bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF GGGGGGGG HHHHHHHH\n+\n+    The 1-bits make sure that carries propagate to the next 0-bit.\n+    The 0-bits provide holes for carries to fall into.\n+    *\/\n+    private static final long HIMAGIC_FOR_BYTES = 0x8080_8080_8080_8080L;\n+    private static final long LOMAGIC_FOR_BYTES = 0x0101_0101_0101_0101L;\n+\n+    private static boolean mightContainZeroByte(long l) {\n+        return ((l - LOMAGIC_FOR_BYTES) & (~l) & HIMAGIC_FOR_BYTES) != 0;\n+    }\n+\n+    private static final long HIMAGIC_FOR_SHORTS = 0x8000_8000_8000_8000L;\n+    private static final long LOMAGIC_FOR_SHORTS = 0x0001_0001_0001_0001L;\n+\n+    static boolean mightContainZeroShort(long l) {\n+        return ((l - LOMAGIC_FOR_SHORTS) & (~l) & HIMAGIC_FOR_SHORTS) != 0;\n+    }\n+\n+\n+    private static int requireWithinArraySize(long size,\n+                                              AbstractMemorySegmentImpl segment,\n+                                              long fromOffset,\n+                                              long toOffset) {\n+        if (size > ArraysSupport.SOFT_MAX_ARRAY_LENGTH) {\n+            throw stringTooLarge(segment, fromOffset, toOffset);\n+        }\n+        return (int) size;\n+    }\n+\n+    private static IllegalArgumentException stringTooLarge(AbstractMemorySegmentImpl segment,\n+                                                           long fromOffset,\n+                                                           long toOffset) {\n+        return new IllegalArgumentException(\"String too large: \" + exceptionInfo(segment, fromOffset, toOffset));\n+    }\n+\n+    private static IndexOutOfBoundsException nullNotFound(AbstractMemorySegmentImpl segment,\n+                                                          long fromOffset,\n+                                                          long toOffset) {\n+        return new IndexOutOfBoundsException(\"No null terminator found: \" + exceptionInfo(segment, fromOffset, toOffset));\n+    }\n+\n+    private static String exceptionInfo(AbstractMemorySegmentImpl segment,\n+                                        long fromOffset,\n+                                        long toOffset) {\n+        return segment + \" using region [\" + fromOffset + \", \" + toOffset + \")\";\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":183,"deletions":4,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-                        int actual = SegmentBulkOperations.strlenByte((AbstractMemorySegmentImpl) segment, j, segment.byteSize());\n+                        int actual = StringSupport.strlenByte((AbstractMemorySegmentImpl) segment, j, segment.byteSize());\n@@ -301,1 +301,1 @@\n-                        int actual = SegmentBulkOperations.strlenShort((AbstractMemorySegmentImpl) segment, j * Short.BYTES, segment.byteSize());\n+                        int actual = StringSupport.strlenShort((AbstractMemorySegmentImpl) segment, j * Short.BYTES, segment.byteSize());\n@@ -325,1 +325,1 @@\n-                        int actual = SegmentBulkOperations.strlenInt((AbstractMemorySegmentImpl) segment, j * Integer.BYTES, segment.byteSize());\n+                        int actual = StringSupport.strlenInt((AbstractMemorySegmentImpl) segment, j * Integer.BYTES, segment.byteSize());\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.foreign.StringSupport;\n@@ -110,1 +111,1 @@\n-        return SegmentBulkOperations.strlenByte(singleByteSegment, 0, singleByteSegment.byteSize());\n+        return StringSupport.strlenByte(singleByteSegment, 0, singleByteSegment.byteSize());\n@@ -115,1 +116,1 @@\n-        return SegmentBulkOperations.strlenByte(singleByteSegmentMisaligned, 0, singleByteSegment.byteSize());\n+        return StringSupport.strlenByte(singleByteSegmentMisaligned, 0, singleByteSegment.byteSize());\n@@ -120,1 +121,1 @@\n-        return SegmentBulkOperations.strlenShort(doubleByteSegment, 0, doubleByteSegment.byteSize());\n+        return StringSupport.strlenShort(doubleByteSegment, 0, doubleByteSegment.byteSize());\n@@ -125,1 +126,1 @@\n-        return SegmentBulkOperations.strlenInt(quadByteSegment, 0, quadByteSegment.byteSize());\n+        return StringSupport.strlenInt(quadByteSegment, 0, quadByteSegment.byteSize());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/InternalStrLen.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}