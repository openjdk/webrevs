{"files":[{"patch":"@@ -892,0 +892,1 @@\n+    @ForceInline\n@@ -897,0 +898,1 @@\n+    @ForceInline\n@@ -903,0 +905,1 @@\n+    @ForceInline\n@@ -909,0 +912,1 @@\n+    @ForceInline\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.util.ByteArrayLittleEndian;\n@@ -53,0 +52,1 @@\n+    private static final long LONG_MASK = ~7L; \/\/ The last three bits are zero\n@@ -78,1 +78,1 @@\n-            for (; offset < limit; offset += 8) {\n+            for (; offset < limit; offset += Long.BYTES) {\n@@ -83,1 +83,1 @@\n-            if (remaining >= 4) {\n+            if (remaining >= Integer.BYTES) {\n@@ -85,2 +85,2 @@\n-                offset += 4;\n-                remaining -= 4;\n+                offset += Integer.BYTES;\n+                remaining -= Integer.BYTES;\n@@ -89,1 +89,1 @@\n-            if (remaining >= 2) {\n+            if (remaining >= Short.BYTES) {\n@@ -91,2 +91,2 @@\n-                offset += 2;\n-                remaining -= 2;\n+                offset += Short.BYTES;\n+                remaining -= Short.BYTES;\n@@ -126,1 +126,1 @@\n-            final int limit = (int) (size & (NATIVE_THRESHOLD_COPY - 8));\n+            final int limit = (int) (size & (NATIVE_THRESHOLD_COPY - Long.BYTES));\n@@ -128,1 +128,1 @@\n-            for (; offset < limit; offset += 8) {\n+            for (; offset < limit; offset += Long.BYTES) {\n@@ -134,1 +134,1 @@\n-            if (remaining >= 4) {\n+            if (remaining >= Integer.BYTES) {\n@@ -137,2 +137,2 @@\n-                offset += 4;\n-                remaining -= 4;\n+                offset += Integer.BYTES;\n+                remaining -= Integer.BYTES;\n@@ -141,1 +141,1 @@\n-            if (remaining >= 2) {\n+            if (remaining >= Short.BYTES) {\n@@ -144,2 +144,2 @@\n-                offset += 2;\n-                remaining -=2;\n+                offset += Short.BYTES;\n+                remaining -= Short.BYTES;\n@@ -205,1 +205,1 @@\n-        final long longBytes = length & ((1L << 62) - 8);\n+        final long longBytes = length & LONG_MASK;\n@@ -207,1 +207,1 @@\n-        for (; fromOffset < limit; fromOffset += 8) {\n+        for (; fromOffset < limit; fromOffset += Long.BYTES) {\n@@ -221,1 +221,1 @@\n-        if (remaining >= 4) {\n+        if (remaining >= Integer.BYTES) {\n@@ -228,2 +228,2 @@\n-            fromOffset += 4;\n-            remaining -= 4;\n+            fromOffset += Integer.BYTES;\n+            remaining -= Integer.BYTES;\n@@ -232,1 +232,1 @@\n-        if (remaining >= 2) {\n+        if (remaining >= Short.BYTES) {\n@@ -237,2 +237,2 @@\n-            fromOffset += 2;\n-            remaining -= 2;\n+            fromOffset += Short.BYTES;\n+            remaining -= Short.BYTES;\n@@ -291,1 +291,1 @@\n-        for (; offset < limit; offset += 8) {\n+        for (; offset < limit; offset += Long.BYTES) {\n@@ -301,1 +301,1 @@\n-        if (remaining >= 4) {\n+        if (remaining >= Integer.BYTES) {\n@@ -307,2 +307,2 @@\n-            offset += 4;\n-            remaining -= 4;\n+            offset += Integer.BYTES;\n+            remaining -= Integer.BYTES;\n@@ -311,1 +311,1 @@\n-        if (remaining >= 2) {\n+        if (remaining >= Short.BYTES) {\n@@ -317,2 +317,2 @@\n-            offset += 2;\n-            remaining -= 2;\n+            offset += Short.BYTES;\n+            remaining -= Short.BYTES;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.util.Architecture;\n@@ -32,0 +33,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -43,1 +45,3 @@\n-    static final JavaLangAccess JAVA_LANG_ACCESS = SharedSecrets.getJavaLangAccess();\n+    private static final JavaLangAccess JAVA_LANG_ACCESS = SharedSecrets.getJavaLangAccess();\n+    private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+    private static final long LONG_MASK = ~7L; \/\/ The last three bits are zero\n@@ -47,1 +51,2 @@\n-    public static String read(MemorySegment segment, long offset, Charset charset) {\n+    @ForceInline\n+    public static String read(AbstractMemorySegmentImpl segment, long offset, Charset charset) {\n@@ -55,1 +60,2 @@\n-    public static void write(MemorySegment segment, long offset, Charset charset, String string) {\n+    @ForceInline\n+    public static void write(AbstractMemorySegmentImpl segment, long offset, Charset charset, String string) {\n@@ -63,4 +69,5 @@\n-    private static String readByte(MemorySegment segment, long offset, Charset charset) {\n-        long len = chunkedStrlenByte(segment, offset);\n-        byte[] bytes = new byte[(int)len];\n-        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+    @ForceInline\n+    private static String readByte(AbstractMemorySegmentImpl segment, long offset, Charset charset) {\n+        final int len = strlenByte(segment, offset, segment.byteSize());\n+        final byte[] bytes = new byte[len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, len);\n@@ -70,1 +77,2 @@\n-    private static void writeByte(MemorySegment segment, long offset, Charset charset, String string) {\n+    @ForceInline\n+    private static void writeByte(AbstractMemorySegmentImpl segment, long offset, Charset charset, String string) {\n@@ -75,4 +83,5 @@\n-    private static String readShort(MemorySegment segment, long offset, Charset charset) {\n-        long len = chunkedStrlenShort(segment, offset);\n-        byte[] bytes = new byte[(int)len];\n-        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+    @ForceInline\n+    private static String readShort(AbstractMemorySegmentImpl segment, long offset, Charset charset) {\n+        int len = strlenShort(segment, offset, segment.byteSize());\n+        byte[] bytes = new byte[len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, len);\n@@ -82,1 +91,2 @@\n-    private static void writeShort(MemorySegment segment, long offset, Charset charset, String string) {\n+    @ForceInline\n+    private static void writeShort(AbstractMemorySegmentImpl segment, long offset, Charset charset, String string) {\n@@ -87,4 +97,5 @@\n-    private static String readInt(MemorySegment segment, long offset, Charset charset) {\n-        long len = strlenInt(segment, offset);\n-        byte[] bytes = new byte[(int)len];\n-        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+    @ForceInline\n+    private static String readInt(AbstractMemorySegmentImpl segment, long offset, Charset charset) {\n+        int len = strlenInt(segment, offset, segment.byteSize());\n+        byte[] bytes = new byte[len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, len);\n@@ -94,1 +105,2 @@\n-    private static void writeInt(MemorySegment segment, long offset, Charset charset, String string) {\n+    @ForceInline\n+    private static void writeInt(AbstractMemorySegmentImpl segment, long offset, Charset charset, String string) {\n@@ -100,2 +112,3 @@\n-     * {@return the shortest distance beginning at the provided {@code start}\n-     *  to the encountering of a zero byte in the provided {@code segment}}\n+     * {@return the shortest distance beginning at the provided {@code fromOffset}\n+     *          to the encountering of a zero byte in the provided {@code segment}\n+     *          checking bytes before the {@code toOffset}}\n@@ -103,10 +116,2 @@\n-     * The method divides the region of interest into three distinct regions:\n-     * <ul>\n-     *     <li>head (access made on a byte-by-byte basis) (if any)<\/li>\n-     *     <li>body (access made with eight bytes at a time at physically 64-bit-aligned memory) (if any)<\/li>\n-     *     <li>tail (access made on a byte-by-byte basis) (if any)<\/li>\n-     * <\/ul>\n-     * <p>\n-     * The body is using a heuristic method to determine if a long word\n-     * contains a zero byte. The method might have false positives but\n-     * never false negatives.\n+     * The method is using a heuristic method to determine if a long word contains a\n+     * zero byte. The method might have false positives but never false negatives.\n@@ -116,2 +121,3 @@\n-     * @param segment to examine\n-     * @param start   from where examination shall begin\n+     * @param segment    to examine\n+     * @param fromOffset from where examination shall begin (inclusive)\n+     * @param toOffset   to where examination shall end (exclusive)\n@@ -121,10 +127,29 @@\n-    public static int chunkedStrlenByte(MemorySegment segment, long start) {\n-\n-        \/\/ Handle the first unaligned \"head\" bytes separately\n-        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n-\n-        int offset = 0;\n-        for (; offset < headCount; offset++) {\n-            byte curr = segment.get(JAVA_BYTE, start + offset);\n-            if (curr == 0) {\n-                return offset;\n+    @ForceInline\n+    public static int strlenByte(final AbstractMemorySegmentImpl segment,\n+                                 final long fromOffset,\n+                                 final long toOffset) {\n+        final long length = toOffset - fromOffset;\n+        segment.checkBounds(fromOffset, length);\n+        if (length == 0) {\n+            \/\/ The state has to be checked explicitly for zero-length segments\n+            segment.scope.checkValidState();\n+            throw stringTooLarge(segment, fromOffset, toOffset);\n+        }\n+        final long longBytes = length & LONG_MASK;\n+        final long longLimit = fromOffset + longBytes;\n+        long offset = fromOffset;\n+        for (; offset < longLimit; offset += Long.BYTES) {\n+            long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (mightContainZeroByte(val)) {\n+                for (int j = 0; j < Long.BYTES; j++) {\n+                    if (SCOPED_MEMORY_ACCESS.getByte(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset + j) == 0) {\n+                        return requireWithinArraySize(offset + j - fromOffset, segment, fromOffset, toOffset);\n+                    }\n+                }\n+            }\n+        }\n+        \/\/ Handle the tail\n+        for (; offset < toOffset; offset++) {\n+            byte val = SCOPED_MEMORY_ACCESS.getByte(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset);\n+            if (val == 0) {\n+                return requireWithinArraySize(offset - fromOffset, segment, fromOffset, toOffset);\n@@ -133,0 +158,2 @@\n+        throw nullNotFound(segment, fromOffset, toOffset);\n+    }\n@@ -134,11 +161,19 @@\n-        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n-        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n-\n-        for (; offset < bodyCount; offset += Long.BYTES) {\n-            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n-            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n-            \/\/ Is this a candidate?\n-            if (mightContainZeroByte(curr)) {\n-                for (int j = 0; j < 8; j++) {\n-                    if (segment.get(JAVA_BYTE, start + offset + j) == 0) {\n-                        return offset + j;\n+    @ForceInline\n+    public static int strlenShort(final AbstractMemorySegmentImpl segment,\n+                                  final long fromOffset,\n+                                  final long toOffset) {\n+        final long length = toOffset - fromOffset;\n+        segment.checkBounds(fromOffset, length);\n+        if (length == 0) {\n+            segment.scope.checkValidState();\n+            throw stringTooLarge(segment, fromOffset, toOffset);\n+        }\n+        final long longBytes = length & LONG_MASK;\n+        final long longLimit = fromOffset + longBytes;\n+        long offset = fromOffset;\n+        for (; offset < longLimit; offset += Long.BYTES) {\n+            long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (mightContainZeroShort(val)) {\n+                for (int j = 0; j < Long.BYTES; j += Short.BYTES) {\n+                    if (SCOPED_MEMORY_ACCESS.getShortUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset + j, !Architecture.isLittleEndian()) == 0) {\n+                        return requireWithinArraySize(offset + j - fromOffset, segment, fromOffset, toOffset);\n@@ -149,0 +184,11 @@\n+        \/\/ Handle the tail\n+        \/\/ Prevent over scanning as we step by 2\n+        final long endScan = toOffset & ~1; \/\/ The last bit is zero\n+        for (; offset < endScan; offset += Short.BYTES) {\n+            short val = SCOPED_MEMORY_ACCESS.getShortUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (val == 0) {\n+                return requireWithinArraySize(offset - fromOffset, segment, fromOffset, toOffset);\n+            }\n+        }\n+        throw nullNotFound(segment, fromOffset, toOffset);\n+    }\n@@ -150,2 +196,33 @@\n-        \/\/ Handle the \"tail\"\n-        return requireWithinArraySize((long) offset + strlenByte(segment, start + offset));\n+    @ForceInline\n+    public static int strlenInt(final AbstractMemorySegmentImpl segment,\n+                                final long fromOffset,\n+                                final long toOffset) {\n+        final long length = toOffset - fromOffset;\n+        segment.checkBounds(fromOffset, length);\n+        if (length == 0) {\n+            segment.scope.checkValidState();\n+            throw stringTooLarge(segment, fromOffset, toOffset);\n+        }\n+        final long longBytes = length & LONG_MASK;\n+        final long longLimit = fromOffset + longBytes;\n+        long offset = fromOffset;\n+        for (; offset < longLimit; offset += Long.BYTES) {\n+            long val = SCOPED_MEMORY_ACCESS.getLongUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (mightContainZeroShort(val)) {\n+                for (int j = 0; j < Long.BYTES; j += Integer.BYTES) {\n+                    if (SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset + j, !Architecture.isLittleEndian()) == 0) {\n+                        return requireWithinArraySize(offset + j - fromOffset, segment, fromOffset, toOffset);\n+                    }\n+                }\n+            }\n+        }\n+        \/\/ Handle the tail\n+        \/\/ Prevent over scanning as we step by 4\n+        final long endScan = toOffset & ~3; \/\/ The last two bit are zero\n+        for (; offset < endScan; offset += Integer.BYTES) {\n+            int val = SCOPED_MEMORY_ACCESS.getIntUnaligned(segment.sessionImpl(), segment.unsafeGetBase(), segment.unsafeGetOffset() + offset, !Architecture.isLittleEndian());\n+            if (val == 0) {\n+                return requireWithinArraySize(offset - fromOffset, segment, fromOffset, toOffset);\n+            }\n+        }\n+        throw nullNotFound(segment, fromOffset, toOffset);\n@@ -154,3 +231,4 @@\n-    \/* Bits 63 and N * 8 (N = 1..7) of this number are zero.  Call these bits\n-       the \"holes\".  Note that there is a hole just to the left of\n-       each byte, with an extra at the end:\n+    \/*\n+    Bits 63 and N * 8 (N = 1..7) of this number are zero.  Call these bits\n+    the \"holes\".  Note that there is a hole just to the left of\n+    each byte, with an extra at the end:\n@@ -158,2 +236,2 @@\n-       bits:  01111110 11111110 11111110 11111110 11111110 11111110 11111110 11111111\n-       bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF GGGGGGGG HHHHHHHH\n+    bits:  01111110 11111110 11111110 11111110 11111110 11111110 11111110 11111111\n+    bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF GGGGGGGG HHHHHHHH\n@@ -161,2 +239,2 @@\n-       The 1-bits make sure that carries propagate to the next 0-bit.\n-       The 0-bits provide holes for carries to fall into.\n+    The 1-bits make sure that carries propagate to the next 0-bit.\n+    The 0-bits provide holes for carries to fall into.\n@@ -167,1 +245,1 @@\n-    static boolean mightContainZeroByte(long l) {\n+    private static boolean mightContainZeroByte(long l) {\n@@ -178,1 +256,5 @@\n-    static int requireWithinArraySize(long size) {\n+\n+    private static int requireWithinArraySize(long size,\n+                                              AbstractMemorySegmentImpl segment,\n+                                              long fromOffset,\n+                                              long toOffset) {\n@@ -180,1 +262,1 @@\n-            throw newIaeStringTooLarge();\n+            throw stringTooLarge(segment, fromOffset, toOffset);\n@@ -185,7 +267,4 @@\n-    static int bodyCount(long remaining) {\n-        return (int) Math.min(\n-                \/\/ Make sure we do not wrap around\n-                Integer.MAX_VALUE - Long.BYTES,\n-                \/\/ Remaining bytes to consider\n-                remaining)\n-                & -Long.BYTES; \/\/ Mask 0xFFFFFFF8\n+    private static IllegalArgumentException stringTooLarge(AbstractMemorySegmentImpl segment,\n+                                                           long fromOffset,\n+                                                           long toOffset) {\n+        return new IllegalArgumentException(\"String too large: \" + exceptionInfo(segment, fromOffset, toOffset));\n@@ -194,8 +273,4 @@\n-    private static int strlenByte(MemorySegment segment, long start) {\n-        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += 1) {\n-            byte curr = segment.get(JAVA_BYTE, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-        throw newIaeStringTooLarge();\n+    private static IndexOutOfBoundsException nullNotFound(AbstractMemorySegmentImpl segment,\n+                                                          long fromOffset,\n+                                                          long toOffset) {\n+        return new IndexOutOfBoundsException(\"No null terminator found: \" + exceptionInfo(segment, fromOffset, toOffset));\n@@ -204,67 +279,4 @@\n-    \/**\n-     * {@return the shortest distance beginning at the provided {@code start}\n-     *  to the encountering of a zero short in the provided {@code segment}}\n-     * <p>\n-     * Note: The inspected region must be short aligned.\n-     *\n-     * @see #chunkedStrlenByte(MemorySegment, long) for more information\n-     *\n-     * @param segment to examine\n-     * @param start   from where examination shall begin\n-     * @throws IllegalArgumentException if the examined region contains no zero shorts\n-     *                                  within a length that can be accepted by a String\n-     *\/\n-    public static int chunkedStrlenShort(MemorySegment segment, long start) {\n-\n-        \/\/ Handle the first unaligned \"head\" bytes separately\n-        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n-\n-        int offset = 0;\n-        for (; offset < headCount; offset += Short.BYTES) {\n-            short curr = segment.get(JAVA_SHORT_UNALIGNED, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-\n-        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n-        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n-\n-        for (; offset < bodyCount; offset += Long.BYTES) {\n-            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n-            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n-            \/\/ Is this a candidate?\n-            if (mightContainZeroShort(curr)) {\n-                for (int j = 0; j < Long.BYTES; j += Short.BYTES) {\n-                    if (segment.get(JAVA_SHORT_UNALIGNED, start + offset + j) == 0) {\n-                        return offset + j;\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ Handle the \"tail\"\n-        return requireWithinArraySize((long) offset + strlenShort(segment, start + offset));\n-    }\n-\n-    private static int strlenShort(MemorySegment segment, long start) {\n-        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Short.BYTES) {\n-            short curr = segment.get(JAVA_SHORT_UNALIGNED, start + offset);\n-            if (curr == (short)0) {\n-                return offset;\n-            }\n-        }\n-        throw newIaeStringTooLarge();\n-    }\n-\n-    \/\/ The gain of using `long` wide operations for `int` is lower than for the two other `byte` and `short` variants\n-    \/\/ so, there is only one method for ints.\n-    public static int strlenInt(MemorySegment segment, long start) {\n-        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Integer.BYTES) {\n-            \/\/ We are guaranteed to be aligned here so, we can use unaligned access.\n-            int curr = segment.get(JAVA_INT_UNALIGNED, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-        throw newIaeStringTooLarge();\n+    private static String exceptionInfo(AbstractMemorySegmentImpl segment,\n+                                        long fromOffset,\n+                                        long toOffset) {\n+        return segment + \" using region [\" + fromOffset + \", \" + toOffset + \")\";\n@@ -326,5 +338,0 @@\n-\n-    private static IllegalArgumentException newIaeStringTooLarge() {\n-        return new IllegalArgumentException(\"String too large\");\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":160,"deletions":153,"binary":false,"changes":313,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -90,1 +91,0 @@\n-\n@@ -201,0 +201,1 @@\n+                        String expected = testString.substring(i);\n@@ -202,1 +203,1 @@\n-                        assertEquals(actual, testString.substring(i));\n+                        assertEquals(actual, expected);\n@@ -252,0 +253,26 @@\n+    \/\/ This test ensures that we do not address outside the segment even though there\n+    \/\/ are odd bytes at the end.\n+    @Test(dataProvider = \"strings\")\n+    public void offBoundaryTrailingBytes(String testString) {\n+        if (testString.length() < 3 || !containsOnlyRegularCharacters(testString)) {\n+            return;\n+        }\n+        for (var charset : standardCharsets()) {\n+            for (var arena: arenas()) {\n+                try (arena) {\n+                    MemorySegment strSegment = arena.allocateFrom(testString, charset);\n+                    \/\/ Add an odd byte at the end\n+                    MemorySegment inSegment = arena.allocate(strSegment.byteSize() + 1);\n+                    \/\/ Make sure there are no null-terminators so that we will try to scan\n+                    \/\/ the entire segment.\n+                    inSegment.fill((byte) 1);\n+                    for (int i = 0; i < 4; i++) {\n+                        final int offset = i;\n+                        var e = expectThrows(IndexOutOfBoundsException.class, () -> inSegment.getString(offset, charset));\n+                        assertTrue(e.getMessage().contains(\"No null terminator found\"));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -274,1 +301,1 @@\n-                        int actual = StringSupport.chunkedStrlenByte(segment, j);\n+                        int actual = StringSupport.strlenByte((AbstractMemorySegmentImpl) segment, j, segment.byteSize());\n@@ -298,1 +325,1 @@\n-                        int actual = StringSupport.chunkedStrlenShort(segment, j * Short.BYTES);\n+                        int actual = StringSupport.strlenShort((AbstractMemorySegmentImpl) segment, j * Short.BYTES, segment.byteSize());\n@@ -322,1 +349,1 @@\n-                        int actual = StringSupport.strlenInt(segment, j * Integer.BYTES);\n+                        int actual = StringSupport.strlenInt((AbstractMemorySegmentImpl) segment, j * Integer.BYTES, segment.byteSize());\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":33,"deletions":6,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.StringSupport;\n@@ -46,1 +48,0 @@\n-import static jdk.internal.foreign.StringSupport.*;\n@@ -53,1 +54,2 @@\n-@Fork(value = 3, jvmArgs = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\", \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+@Fork(value = 3, jvmArgs = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\",\n+                            \"--enable-native-access=ALL-UNNAMED\"})\n@@ -56,4 +58,4 @@\n-    private MemorySegment singleByteSegment;\n-    private MemorySegment singleByteSegmentMisaligned;\n-    private MemorySegment doubleByteSegment;\n-    private MemorySegment quadByteSegment;\n+    private AbstractMemorySegmentImpl singleByteSegment;\n+    private AbstractMemorySegmentImpl singleByteSegmentMisaligned;\n+    private AbstractMemorySegmentImpl doubleByteSegment;\n+    private AbstractMemorySegmentImpl quadByteSegment;\n@@ -67,4 +69,3 @@\n-        singleByteSegment = arena.allocate((size + 1L) * Byte.BYTES);\n-        singleByteSegmentMisaligned = arena.allocate((size + 1L) * Byte.BYTES);\n-        doubleByteSegment = arena.allocate((size + 1L) * Short.BYTES);\n-        quadByteSegment = arena.allocate((size + 1L) * Integer.BYTES);\n+        singleByteSegment = (AbstractMemorySegmentImpl) arena.allocate((size + 1L) * Byte.BYTES);\n+        doubleByteSegment = (AbstractMemorySegmentImpl) arena.allocate((size + 1L) * Short.BYTES);\n+        quadByteSegment = (AbstractMemorySegmentImpl) arena.allocate((size + 1L) * Integer.BYTES);\n@@ -81,1 +82,1 @@\n-        singleByteSegmentMisaligned = arena.allocate(singleByteSegment.byteSize() + 1).\n+        singleByteSegmentMisaligned = (AbstractMemorySegmentImpl) arena.allocate(singleByteSegment.byteSize() + 1).\n@@ -108,1 +109,1 @@\n-        return chunkedStrlenByte(singleByteSegment, 0);\n+        return StringSupport.strlenByte(singleByteSegment, 0, singleByteSegment.byteSize());\n@@ -113,1 +114,1 @@\n-        return chunkedStrlenByte(singleByteSegmentMisaligned, 0);\n+        return StringSupport.strlenByte(singleByteSegmentMisaligned, 0, singleByteSegment.byteSize());\n@@ -118,1 +119,1 @@\n-        return chunkedStrlenShort(doubleByteSegment, 0);\n+        return StringSupport.strlenShort(doubleByteSegment, 0, doubleByteSegment.byteSize());\n@@ -123,1 +124,1 @@\n-        return strlenInt(quadByteSegment, 0);\n+        return StringSupport.strlenInt(quadByteSegment, 0, quadByteSegment.byteSize());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/InternalStrLen.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"}]}