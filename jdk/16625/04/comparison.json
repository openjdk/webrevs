{"files":[{"patch":"@@ -206,1 +206,0 @@\n-JVM_SupportsCX8\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1514,1 +1514,0 @@\n-  assert(VM_Version::supports_cx8(), \"wrong machine\");\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-  _supports_cx8 = true;\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1388,1 +1388,0 @@\n-    assert(VM_Version::supports_cx8(), \"wrong machine\");\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -131,0 +131,4 @@\n+  \/\/ Future cleanup: if SUPPORTS_NATIVE_CX8 is defined then we should not need\n+  \/\/ any alternative solutions. At present this allows for the theoretical\n+  \/\/ possibility of building for ARMv7 and then running on ARMv5 or 6. If that\n+  \/\/ is impossible then the ARM port folk should clean this up.\n@@ -132,0 +136,1 @@\n+#ifndef SUPPORTS_NATIVE_CX8\n@@ -135,0 +140,1 @@\n+#endif\n@@ -281,1 +287,1 @@\n-  assert(_supports_cx8 && _supports_atomic_getset4 && _supports_atomic_getadd4\n+  assert(supports_cx8() && _supports_atomic_getset4 && _supports_atomic_getadd4\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm_32.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -203,4 +203,0 @@\n-  \/\/ PPC64 supports 8-byte compare-exchange operations (see Atomic::cmpxchg)\n-  \/\/ and 'atomic long memory ops' (see Unsafe_GetLongVolatile).\n-  _supports_cx8 = true;\n-\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1254,1 +1254,0 @@\n-  assert(VM_Version::supports_cx8(), \"wrong machine\");\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-  _supports_cx8 = true;\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2673,1 +2673,0 @@\n-    assert(VM_Version::supports_cx8(), \"wrong machine\");\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -290,5 +290,0 @@\n-  \/\/ z\/Architecture supports 8-byte compare-exchange operations\n-  \/\/ (see Atomic::cmpxchg)\n-  \/\/ and 'atomic long memory ops' (see Unsafe_GetLongVolatile).\n-  _supports_cx8 = true;\n-\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1932,1 +1932,1 @@\n-  if (LP64_ONLY(false &&) op->code() == lir_cas_long && VM_Version::supports_cx8()) {\n+  if (LP64_ONLY(false &&) op->code() == lir_cas_long) {\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-  predicate(VM_Version::supports_cx8());\n@@ -98,1 +97,0 @@\n-  predicate(VM_Version::supports_cx8());\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoah_x86_64.ad","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -819,1 +819,0 @@\n-  _supports_cx8 = supports_cmpxchg8();\n@@ -3239,1 +3238,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -646,1 +646,0 @@\n-  static bool supports_cmpxchg8()     { return (_features & CPU_CX8) != 0; }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1513,3 +1513,0 @@\n-      if (!VM_Version::supports_cx8()) {\n-        return false;\n-      }\n@@ -10122,2 +10119,0 @@\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7284,1 +7284,0 @@\n-  predicate(VM_Version::supports_cx8());\n@@ -7353,1 +7352,0 @@\n-  predicate(VM_Version::supports_cx8());\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7177,1 +7177,1 @@\n-  predicate(VM_Version::supports_cx8() && n->as_LoadStore()->barrier_data() == 0);\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -7200,1 +7200,0 @@\n-  predicate(VM_Version::supports_cx8());\n@@ -7361,1 +7360,0 @@\n-  predicate(VM_Version::supports_cx8());\n@@ -7395,1 +7393,1 @@\n-  predicate(VM_Version::supports_cx8() && n->as_LoadStore()->barrier_data() == 0);\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,0 +148,1 @@\n+#ifndef SUPPORTS_NATIVE_CX8\n@@ -153,1 +154,1 @@\n-\n+#endif\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -156,1 +156,0 @@\n-  assert(VM_Version::supports_cx8(), \"Atomic compare and exchange int64_t not supported on this architecture!\");\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/atomic_linux_arm.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -113,1 +113,0 @@\n-    if (!VM_Version::supports_cx8()) return false;\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -784,6 +784,0 @@\n-\/*\n- * java.util.concurrent.atomic.AtomicLong\n- *\/\n-JNIEXPORT jboolean JNICALL\n-JVM_SupportsCX8(void);\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"runtime\/vm_version.hpp\"\n@@ -43,1 +42,0 @@\n-  assert(VM_Version::supports_cx8(), \"invariant\");\n@@ -297,1 +295,0 @@\n-\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"runtime\/vm_version.hpp\"\n@@ -39,1 +38,0 @@\n-  assert(VM_Version::supports_cx8(), \"unsupported\");\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrAllocation.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-\/\/ this utility could be useful for non cx8 platforms\n-\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSpinlockHelper.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/vm_version.hpp\"\n@@ -37,48 +36,0 @@\n-  \/\/ VM_Version::supports_cx8() is a surrogate for 'supports atomic long memory ops'.\n-  \/\/\n-  \/\/ On platforms which do not support atomic compare-and-swap of jlong (8 byte)\n-  \/\/ values we have to use a lock-based scheme to enforce atomicity. This has to be\n-  \/\/ applied to all Unsafe operations that set the value of a jlong field. Even so\n-  \/\/ the compareAndSwapLong operation will not be atomic with respect to direct stores\n-  \/\/ to the field from Java code. It is important therefore that any Java code that\n-  \/\/ utilizes these Unsafe jlong operations does not perform direct stores. To permit\n-  \/\/ direct loads of the field from Java code we must also use Atomic::store within the\n-  \/\/ locked regions. And for good measure, in case there are direct stores, we also\n-  \/\/ employ Atomic::load within those regions. Note that the field in question must be\n-  \/\/ volatile and so must have atomic load\/store accesses applied at the Java level.\n-  \/\/\n-  \/\/ The locking scheme could utilize a range of strategies for controlling the locking\n-  \/\/ granularity: from a lock per-field through to a single global lock. The latter is\n-  \/\/ the simplest and is used for the current implementation. Note that the Java object\n-  \/\/ that contains the field, can not, in general, be used for locking. To do so can lead\n-  \/\/ to deadlocks as we may introduce locking into what appears to the Java code to be a\n-  \/\/ lock-free path.\n-  \/\/\n-  \/\/ As all the locked-regions are very short and themselves non-blocking we can treat\n-  \/\/ them as leaf routines and elide safepoint checks (ie we don't perform any thread\n-  \/\/ state transitions even when blocking for the lock). Note that if we do choose to\n-  \/\/ add safepoint checks and thread state transitions, we must ensure that we calculate\n-  \/\/ the address of the field _after_ we have acquired the lock, else the object may have\n-  \/\/ been moved by the GC\n-\n-#ifndef SUPPORTS_NATIVE_CX8\n-\n-  \/\/ This is intentionally in the cpp file rather than the .inline.hpp file. It seems\n-  \/\/ desirable to trade faster JDK build times (not propagating vm_version.hpp)\n-  \/\/ for slightly worse runtime atomic jlong performance on 32 bit machines with\n-  \/\/ support for 64 bit atomics.\n-  bool wide_atomic_needs_locking() {\n-    return !VM_Version::supports_cx8();\n-  }\n-\n-  AccessLocker::AccessLocker() {\n-    assert(!VM_Version::supports_cx8(), \"why else?\");\n-    UnsafeJlong_lock->lock_without_safepoint_check();\n-  }\n-\n-  AccessLocker::~AccessLocker() {\n-    UnsafeJlong_lock->unlock();\n-  }\n-\n-#endif\n-\n","filename":"src\/hotspot\/share\/oops\/accessBackend.cpp","additions":0,"deletions":49,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -84,9 +84,0 @@\n-  \/\/ This metafunction returns whether it is possible for a type T to require\n-  \/\/ locking to support wide atomics or not.\n-  template <typename T>\n-#ifdef SUPPORTS_NATIVE_CX8\n-  struct PossiblyLockedAccess: public std::false_type {};\n-#else\n-  struct PossiblyLockedAccess: public std::integral_constant<bool, (sizeof(T) > 4)> {};\n-#endif\n-\n@@ -143,7 +134,0 @@\n-  class AccessLocker {\n-  public:\n-    AccessLocker();\n-    ~AccessLocker();\n-  };\n-  bool wide_atomic_needs_locking();\n-\n@@ -284,28 +268,0 @@\n-  \/\/ The following *_locked mechanisms serve the purpose of handling atomic operations\n-  \/\/ that are larger than a machine can handle, and then possibly opt for using\n-  \/\/ a slower path using a mutex to perform the operation.\n-\n-  template <DecoratorSet ds, typename T>\n-  static inline typename EnableIf<\n-    !AccessInternal::PossiblyLockedAccess<T>::value, T>::type\n-  atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value) {\n-    return atomic_cmpxchg_internal<ds>(addr, compare_value, new_value);\n-  }\n-\n-  template <DecoratorSet ds, typename T>\n-  static typename EnableIf<\n-    AccessInternal::PossiblyLockedAccess<T>::value, T>::type\n-  atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value);\n-\n-  template <DecoratorSet ds, typename T>\n-  static inline typename EnableIf<\n-    !AccessInternal::PossiblyLockedAccess<T>::value, T>::type\n-  atomic_xchg_maybe_locked(void* addr, T new_value) {\n-    return atomic_xchg_internal<ds>(addr, new_value);\n-  }\n-\n-  template <DecoratorSet ds, typename T>\n-  static typename EnableIf<\n-    AccessInternal::PossiblyLockedAccess<T>::value, T>::type\n-  atomic_xchg_maybe_locked(void* addr, T new_value);\n-\n@@ -325,1 +281,1 @@\n-    return atomic_cmpxchg_maybe_locked<decorators>(addr, compare_value, new_value);\n+    return atomic_cmpxchg_internal<decorators>(addr, compare_value, new_value);\n@@ -330,1 +286,1 @@\n-    return atomic_xchg_maybe_locked<decorators>(addr, new_value);\n+    return atomic_xchg_internal<decorators>(addr, new_value);\n","filename":"src\/hotspot\/share\/oops\/accessBackend.hpp","additions":2,"deletions":46,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -217,38 +217,0 @@\n-\/\/ For platforms that do not have native support for wide atomics,\n-\/\/ we can emulate the atomicity using a lock. So here we check\n-\/\/ whether that is necessary or not.\n-\n-template <DecoratorSet ds>\n-template <DecoratorSet decorators, typename T>\n-inline typename EnableIf<\n-  AccessInternal::PossiblyLockedAccess<T>::value, T>::type\n-RawAccessBarrier<ds>::atomic_xchg_maybe_locked(void* addr, T new_value) {\n-  if (!AccessInternal::wide_atomic_needs_locking()) {\n-    return atomic_xchg_internal<ds>(addr, new_value);\n-  } else {\n-    AccessInternal::AccessLocker access_lock;\n-    volatile T* p = reinterpret_cast<volatile T*>(addr);\n-    T old_val = RawAccess<>::load(p);\n-    RawAccess<>::store(p, new_value);\n-    return old_val;\n-  }\n-}\n-\n-template <DecoratorSet ds>\n-template <DecoratorSet decorators, typename T>\n-inline typename EnableIf<\n-  AccessInternal::PossiblyLockedAccess<T>::value, T>::type\n-RawAccessBarrier<ds>::atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value) {\n-  if (!AccessInternal::wide_atomic_needs_locking()) {\n-    return atomic_cmpxchg_internal<ds>(addr, compare_value, new_value);\n-  } else {\n-    AccessInternal::AccessLocker access_lock;\n-    volatile T* p = reinterpret_cast<volatile T*>(addr);\n-    T old_val = RawAccess<>::load(p);\n-    if (old_val == compare_value) {\n-      RawAccess<>::store(p, new_value);\n-    }\n-    return old_val;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/accessBackend.inline.hpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -3589,6 +3589,0 @@\n-\/\/ Atomic \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-JVM_LEAF(jboolean, JVM_SupportsCX8())\n-  return VM_Version::supports_cx8();\n-JVM_END\n-\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#ifndef SUPPORTS_NATIVE_CX8\n@@ -39,0 +40,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#ifndef SUPPORTS_NATIVE_CX8\n@@ -63,0 +64,1 @@\n+#endif\n@@ -136,0 +138,2 @@\n+  \/\/ Required to be true but still dynamically checked at runtime\n+  \/\/ for platforms that don't set SUPPORTS_NATIVE_CX8\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,5 +58,7 @@\n-  \/\/ Atomic operations on int64 types are not available on all 32-bit\n-  \/\/ platforms. If atomic ops on int64 are defined here they must only\n-  \/\/ be used from code that verifies they are available at runtime and\n-  \/\/ can provide an alternative action if not - see supports_cx8() for\n-  \/\/ a means to test availability.\n+  \/\/ Atomic operations on int64 types are required to be available on\n+  \/\/ all platforms. At a minimum a 64-bit cmpxchg must be available\n+  \/\/ from which other atomic operations can be constructed if needed.\n+  \/\/ The legacy `Abstract_VMVersion::supports_cx8()` function used to\n+  \/\/ indicate if this support existed, allowing for alternative lock-\n+  \/\/ based mechanism to be used. But today this function is required\n+  \/\/ to return true and in the future will be removed entirely.\n","filename":"src\/hotspot\/share\/runtime\/atomic.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -126,3 +126,0 @@\n-#ifndef SUPPORTS_NATIVE_CX8\n-Mutex*   UnsafeJlong_lock             = nullptr;\n-#endif\n@@ -301,4 +298,0 @@\n-#ifndef SUPPORTS_NATIVE_CX8\n-  MUTEX_DEFN(UnsafeJlong_lock                , PaddedMutex  , nosafepoint);\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -139,4 +139,0 @@\n-#ifndef SUPPORTS_NATIVE_CX8\n-extern Mutex*   UnsafeJlong_lock;                \/\/ provides Unsafe atomic updates to jlongs on platforms that don't support cx8\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-\n+  guarantee(VM_Version::supports_cx8(), \"Support for 64-bit atomic operations in required in this release\");\n","filename":"src\/hotspot\/share\/runtime\/vm_version.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,14 +58,0 @@\n-    \/**\n-     * Records whether the underlying JVM supports lockless\n-     * compareAndSet for longs. While the intrinsic compareAndSetLong\n-     * method works in either case, some constructions should be\n-     * handled at Java level to avoid locking user-visible locks.\n-     *\/\n-    static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8();\n-\n-    \/**\n-     * Returns whether underlying JVM supports lockless CompareAndSet\n-     * for longs. Called only once and cached in VM_SUPPORTS_LONG_CAS.\n-     *\/\n-    private static native boolean VMSupportsCS8();\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicLong.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -93,4 +93,1 @@\n-        if (AtomicLong.VM_SUPPORTS_LONG_CAS)\n-            return new CASUpdater<U>(tclass, fieldName, caller);\n-        else\n-            return new LockedUpdater<U>(tclass, fieldName, caller);\n+        return new CASUpdater<U>(tclass, fieldName, caller);\n@@ -518,120 +515,0 @@\n-    private static final class LockedUpdater<T> extends AtomicLongFieldUpdater<T> {\n-        private static final Unsafe U = Unsafe.getUnsafe();\n-        private final long offset;\n-        \/**\n-         * if field is protected, the subclass constructing updater, else\n-         * the same as tclass\n-         *\/\n-        private final Class<?> cclass;\n-        \/** class holding the field *\/\n-        private final Class<T> tclass;\n-\n-        @SuppressWarnings(\"removal\")\n-        LockedUpdater(final Class<T> tclass, final String fieldName,\n-                      final Class<?> caller) {\n-            final Field field;\n-            final int modifiers;\n-            try {\n-                field = AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<Field>() {\n-                        public Field run() throws NoSuchFieldException {\n-                            return tclass.getDeclaredField(fieldName);\n-                        }\n-                    });\n-                modifiers = field.getModifiers();\n-                sun.reflect.misc.ReflectUtil.ensureMemberAccess(\n-                    caller, tclass, null, modifiers);\n-                ClassLoader cl = tclass.getClassLoader();\n-                ClassLoader ccl = caller.getClassLoader();\n-                if ((ccl != null) && (ccl != cl) &&\n-                    ((cl == null) || !isAncestor(cl, ccl))) {\n-                    sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);\n-                }\n-            } catch (PrivilegedActionException pae) {\n-                throw new RuntimeException(pae.getException());\n-            } catch (Exception ex) {\n-                throw new RuntimeException(ex);\n-            }\n-\n-            if (field.getType() != long.class)\n-                throw new IllegalArgumentException(\"Must be long type\");\n-\n-            if (!Modifier.isVolatile(modifiers))\n-                throw new IllegalArgumentException(\"Must be volatile type\");\n-\n-            \/\/ Access to protected field members is restricted to receivers only\n-            \/\/ of the accessing class, or one of its subclasses, and the\n-            \/\/ accessing class must in turn be a subclass (or package sibling)\n-            \/\/ of the protected member's defining class.\n-            \/\/ If the updater refers to a protected field of a declaring class\n-            \/\/ outside the current package, the receiver argument will be\n-            \/\/ narrowed to the type of the accessing class.\n-            this.cclass = (Modifier.isProtected(modifiers) &&\n-                           tclass.isAssignableFrom(caller) &&\n-                           !isSamePackage(tclass, caller))\n-                          ? caller : tclass;\n-            this.tclass = tclass;\n-            this.offset = U.objectFieldOffset(field);\n-        }\n-\n-        \/**\n-         * Checks that target argument is instance of cclass.  On\n-         * failure, throws cause.\n-         *\/\n-        private final void accessCheck(T obj) {\n-            if (!cclass.isInstance(obj))\n-                throw accessCheckException(obj);\n-        }\n-\n-        \/**\n-         * Returns access exception if accessCheck failed due to\n-         * protected access, else ClassCastException.\n-         *\/\n-        private final RuntimeException accessCheckException(T obj) {\n-            if (cclass == tclass)\n-                return new ClassCastException();\n-            else\n-                return new RuntimeException(\n-                    new IllegalAccessException(\n-                        \"Class \" +\n-                        cclass.getName() +\n-                        \" can not access a protected member of class \" +\n-                        tclass.getName() +\n-                        \" using an instance of \" +\n-                        obj.getClass().getName()));\n-        }\n-\n-        public final boolean compareAndSet(T obj, long expect, long update) {\n-            accessCheck(obj);\n-            synchronized (this) {\n-                long v = U.getLong(obj, offset);\n-                if (v != expect)\n-                    return false;\n-                U.putLong(obj, offset, update);\n-                return true;\n-            }\n-        }\n-\n-        public final boolean weakCompareAndSet(T obj, long expect, long update) {\n-            return compareAndSet(obj, expect, update);\n-        }\n-\n-        public final void set(T obj, long newValue) {\n-            accessCheck(obj);\n-            synchronized (this) {\n-                U.putLong(obj, offset, newValue);\n-            }\n-        }\n-\n-        public final void lazySet(T obj, long newValue) {\n-            set(obj, newValue);\n-        }\n-\n-        public final long get(T obj) {\n-            accessCheck(obj);\n-            synchronized (this) {\n-                return U.getLong(obj, offset);\n-            }\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicLongFieldUpdater.java","additions":1,"deletions":124,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <jni.h>\n-#include <jvm.h>\n-#include \"java_util_concurrent_atomic_AtomicLong.h\"\n-\n-JNIEXPORT jboolean JNICALL\n-Java_java_util_concurrent_atomic_AtomicLong_VMSupportsCS8(JNIEnv *env, jclass cls)\n-{\n-    return JVM_SupportsCX8();\n-}\n","filename":"src\/java.base\/share\/native\/libjava\/AtomicLong.c","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -63,3 +63,0 @@\n-  \/\/ Check if 64-bit atomics are available on the machine.\n-  if (!VM_Version::supports_cx8()) return;\n-\n@@ -112,3 +109,0 @@\n-  \/\/ Check if 64-bit atomics are available on the machine.\n-  if (!VM_Version::supports_cx8()) return;\n-\n@@ -352,3 +346,0 @@\n-  \/\/ Check if 64-bit atomics are available on the machine.\n-  if (!VM_Version::supports_cx8()) return;\n-\n@@ -359,3 +350,0 @@\n-  \/\/ Check if 64-bit atomics are available on the machine.\n-  if (!VM_Version::supports_cx8()) return;\n-\n","filename":"test\/hotspot\/gtest\/runtime\/test_atomic.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4992443 4994819\n- * @modules java.base\/java.util.concurrent.atomic:open\n- * @run main VMSupportsCS8\n- * @summary Checks that the value of VMSupportsCS8 matches system properties.\n- *\/\n-\n-import java.lang.reflect.Field;\n-\n-public class VMSupportsCS8 {\n-    public static void main(String[] args) throws Exception {\n-        String isalist = System.getProperty(\"sun.cpu.isalist\");\n-        if (isalist != null && isalist.matches\n-            (\".*\\\\b(pentium_pro|ia64|amd64).*\")\n-            ||\n-            System.getProperty(\"os.arch\").matches\n-            (\".*\\\\b(ia64|amd64).*\")) {\n-\n-            System.out.println(\"This system is known to have hardware CS8\");\n-\n-            Class klass = Class.forName(\"java.util.concurrent.atomic.AtomicLong\");\n-            Field field = klass.getDeclaredField(\"VM_SUPPORTS_LONG_CAS\");\n-            field.setAccessible(true);\n-            boolean VMSupportsCS8 = field.getBoolean(null);\n-            if (! VMSupportsCS8)\n-                throw new Exception(\"Unexpected value for VMSupportsCS8\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/concurrent\/atomic\/VMSupportsCS8.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"}]}