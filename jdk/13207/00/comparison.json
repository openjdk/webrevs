{"files":[{"patch":"@@ -4647,2 +4647,1 @@\n-\/\/ Build a verify-only PhaseIdealLoop, and see that it agrees with me.\n-static int fail;                \/\/ debug only, so its multi-thread dont care\n+\/\/ Build a verify-only PhaseIdealLoop, and see that it agrees with \"this\".\n@@ -4650,1 +4649,0 @@\n-  int old_progress = C->major_progress();\n@@ -4652,0 +4650,2 @@\n+  int old_progress = C->major_progress();\n+\n@@ -4653,1 +4653,0 @@\n-  VectorSet visited;\n@@ -4655,2 +4654,3 @@\n-  fail = 0;\n-  verify_compare(C->root(), &loop_verify, visited);\n+  \/\/ Verify ctrl and idom of every node.\n+  int fail = 0;\n+  verify_nodes(C->root(), &loop_verify, fail);\n@@ -4658,1 +4658,2 @@\n-  \/\/ Verify loop structure is the same\n+\n+  \/\/ Verify loop-tree.\n@@ -4660,2 +4661,2 @@\n-  \/\/ Reset major-progress.  It was cleared by creating a verify version of\n-  \/\/ PhaseIdealLoop.\n+\n+  \/\/ Major progress was cleared by creating a verify version of PhaseIdealLoop.\n@@ -4665,7 +4666,29 @@\n-\/\/------------------------------verify_compare---------------------------------\n-\/\/ Make sure me and the given PhaseIdealLoop agree on key data structures\n-void PhaseIdealLoop::verify_compare( Node *n, const PhaseIdealLoop *loop_verify, VectorSet &visited ) const {\n-  if( !n ) return;\n-  if( visited.test_set( n->_idx ) ) return;\n-  if( !_nodes[n->_idx] ) {      \/\/ Unreachable\n-    assert( !loop_verify->_nodes[n->_idx], \"both should be unreachable\" );\n+\/\/------------------------------verify_nodes-----------------------------\n+\/\/ Perform a BFS starting at n, through all inputs.\n+\/\/ Call verify_node on all nodes of BFS traversal.\n+void PhaseIdealLoop::verify_nodes(Node* root, const PhaseIdealLoop* loop_verify, int &fail) const {\n+  Unique_Node_List worklist;\n+  worklist.push(root);\n+  for (uint i = 0; i < worklist.size() && fail < 10; i++) {\n+    Node* n = worklist.at(i);\n+    \/\/ process node\n+    verify_node(n, loop_verify, fail);\n+    \/\/ visit inputs\n+    for(uint j = 0; j < n->req(); j++) {\n+      if (n->in(j) != nullptr) {\n+        worklist.push(n->in(j));\n+      }\n+    }\n+  }\n+}\n+\n+\/\/------------------------------verify_node---------------------------------\n+\/\/ Compare \"this\" and \"loop_verify\".\n+\/\/  (1) Verify \"_nodes\": control and loop membership.\n+\/\/  (2) Verify dominator structure (IDOM).\n+void PhaseIdealLoop::verify_node(Node* n, const PhaseIdealLoop* loop_verify, int &fail) const {\n+  uint i = n->_idx;\n+  \/\/ The loop-tree was built from def to use. The verification happens from def to use.\n+  \/\/ We may thus find nodes during verification that are not in the loop-tree.\n+  if(_nodes[i] == nullptr) {\n+    assert(loop_verify->_nodes[i] == nullptr, \"both should be unreachable\");\n@@ -4675,3 +4698,9 @@\n-  uint i;\n-  for( i = 0; i < n->req(); i++ )\n-    verify_compare( n->in(i), loop_verify, visited );\n+  \/\/ Check everything stored in \"_nodes\".\n+  \/\/  (1) has_ctrl -> check lowest bit. 1 -> data node. 0 -> ctrl node.\n+  \/\/  (2) has_ctrl true: get_ctrl_no_update returns ctrl of data node.\n+  \/\/  (3) has_ctrl false: get_loop_idx returns IdealLoopTree for ctrl node.\n+  if (n->is_CFG() == has_ctrl(n)) {\n+    tty->print(\"Exactly one should be true: %d for is_CFG, %d for has_ctrl.\", n->is_CFG(), has_ctrl(n));\n+    n->dump();\n+    fail++;\n+  }\n@@ -4679,3 +4708,15 @@\n-  \/\/ Check the '_nodes' block\/loop structure\n-  i = n->_idx;\n-  if( has_ctrl(n) ) {           \/\/ We have control; verify has loop or ctrl\n+  if (has_ctrl(n) != loop_verify->has_ctrl(n)) {\n+    tty->print(\"Mismatch has_ctrl: %d for this, %d for verify.\", has_ctrl(n), loop_verify->has_ctrl(n));\n+    n->dump();\n+    fail++;\n+  } else if (has_ctrl(n)) {\n+    assert(loop_verify->has_ctrl(n), \"sanity\");\n+    \/\/ n is a data node.\n+    \/\/ Verify that it ctrl is the same.\n+\n+    \/\/ Broken part of VerifyLoopOptimizations (A)\n+    \/\/ Reason:\n+    \/\/   BUG, wrong control set for example in\n+    \/\/   PhaseIdealLoop::split_if_with_blocks\n+    \/\/   at \"set_ctrl(x, new_ctrl);\"\n+    \/*\n@@ -4698,12 +4739,12 @@\n-  } else {                    \/\/ We have a loop\n-    IdealLoopTree *us = get_loop_idx(n);\n-    if( loop_verify->has_ctrl(n) ) {\n-      tty->print(\"Mismatched loop setting for: \");\n-      n->dump();\n-      if( fail++ > 10 ) return;\n-      tty->print(\"We have it as: \");\n-      us->dump();\n-      tty->print(\"Verify thinks: \");\n-      loop_verify->get_ctrl_no_update(n)->dump();\n-      tty->cr();\n-    } else if (!C->major_progress()) {\n+    *\/\n+  } else {\n+    assert(!loop_verify->has_ctrl(n), \"sanity\");\n+    \/\/ n is a ctrl node.\n+    \/\/ Verify that not has_ctrl, and that get_loop_idx is the same.\n+\n+    \/\/ Broken part of VerifyLoopOptimizations (B)\n+    \/\/ Reason:\n+    \/\/   NeverBranch node for example is added to loop outside its scope.\n+    \/\/   Once we run build_loop_tree again, it is added to the correct loop.\n+    \/*\n+    if (!C->major_progress()) {\n@@ -4712,0 +4753,1 @@\n+      IdealLoopTree *us = get_loop_idx(n);\n@@ -4724,0 +4766,1 @@\n+    *\/\n@@ -4726,3 +4769,6 @@\n-  \/\/ Check for immediate dominators being equal\n-  if( i >= _idom_size ) {\n-    if( !n->is_CFG() ) return;\n+  \/\/ Verify IDOM for all CFG nodes (except root).\n+  if (!n->is_CFG() || n->is_Root()) {\n+    return;\n+  }\n+\n+  if (i >= _idom_size) {\n@@ -4731,0 +4777,1 @@\n+    fail++;\n@@ -4733,2 +4780,0 @@\n-  if( !n->is_CFG() ) return;\n-  if( n == C->root() ) return; \/\/ No IDOM here\n@@ -4736,1 +4781,6 @@\n-  assert(n->_idx == i, \"sanity\");\n+  \/\/ Broken part of VerifyLoopOptimizations (C)\n+  \/\/ Reason:\n+  \/\/   Idom not always set correctly, for example BUG in\n+  \/\/   PhaseIdealLoop::create_new_if_for_predicate\n+  \/\/   at \"set_idom(rgn, nrdom, dom_depth(rgn));\"\n+  \/*\n@@ -4748,1 +4798,1 @@\n-\n+  *\/\n@@ -4752,2 +4802,2 @@\n-\/\/ Verify that tree structures match.  Because the CFG can change, siblings\n-\/\/ within the loop tree can be reordered.  We attempt to deal with that by\n+\/\/ Verify that tree structures match. Because the CFG can change, siblings\n+\/\/ within the loop tree can be reordered. We attempt to deal with that by\n@@ -4755,2 +4805,2 @@\n-void IdealLoopTree::verify_tree(IdealLoopTree *loop, const IdealLoopTree *parent) const {\n-  assert( _parent == parent, \"Badly formed loop tree\" );\n+void IdealLoopTree::verify_tree(IdealLoopTree* loop, const IdealLoopTree* parent) const {\n+  assert(_parent == parent, \"Badly formed loop tree\");\n@@ -4758,3 +4808,4 @@\n-  \/\/ Siblings not in same order?  Attempt to re-order.\n-  if( _head != loop->_head ) {\n-    \/\/ Find _next pointer to update\n+  \/\/ If \"this\" and \"loop\" are not the same sibling of \"parent\", reorder the siblings.\n+  if (_head != loop->_head) {\n+    tty->print_cr(\"reorder loop tree\");\n+    \/\/ Find _next pointer to update (where \"loop\" is attached)\n@@ -4762,1 +4813,1 @@\n-    while( *pp != loop )\n+    while (*pp != loop) {\n@@ -4764,1 +4815,2 @@\n-    \/\/ Find proper sibling to be next\n+    }\n+    \/\/ Find proper sibling to be next (where \"loop\" will be attached)\n@@ -4766,1 +4818,1 @@\n-    while( (*nn) && (*nn)->_head != _head )\n+    while ((*nn) != nullptr && (*nn)->_head != _head) {\n@@ -4768,0 +4820,1 @@\n+    }\n@@ -4770,12 +4823,11 @@\n-    if( !(*nn) ) {\n-      \/\/ Annoyingly, irreducible loops can pick different headers\n-      \/\/ after a major_progress operation, so the rest of the loop\n-      \/\/ tree cannot be matched.\n-      if (_irreducible && Compile::current()->major_progress())  return;\n-      assert( 0, \"failed to match loop tree\" );\n-    }\n-\n-    \/\/ Move (*nn) to (*pp)\n-    IdealLoopTree *hit = *nn;\n-    *nn = hit->_next;\n-    hit->_next = loop;\n+    if ((*nn) == nullptr) {\n+      \/\/ Annoyingly, irreducible loops can pick different headers (any of the entries)\n+      \/\/ after a major_progress operation, so the rest of the loop tree cannot be matched.\n+      assert(_irreducible && Compile::current()->major_progress(), \"failed to match loop tree\");\n+      return;\n+    }\n+\n+    \/\/ Swap (*nn) and (*pp)\n+    IdealLoopTree* tmp = *nn;\n+    *nn = tmp->_next;\n+    tmp->_next = loop;\n@@ -4783,2 +4835,1 @@\n-    loop = hit;\n-    \/\/ Now try again to verify\n+    loop = tmp;\n@@ -4787,1 +4838,9 @@\n-  assert( _head  == loop->_head , \"mismatched loop head\" );\n+  \/\/ After reordering, \"this\" and \"loop\" match.\n+  assert(_head == loop->_head, \"mismatched loop head\");\n+\n+  \/\/ Broken part of VerifyLoopOptimizations (D)\n+  \/\/ Reason:\n+  \/\/   split_if has to update the _tail, if it is modified. But that is done by\n+  \/\/   checking to what loop the iff belongs to. That info can be wrong, and then\n+  \/\/   we do not update the _tail correctly.\n+  \/*\n@@ -4792,0 +4851,1 @@\n+  *\/\n@@ -4793,2 +4853,1 @@\n-  \/\/ Counted loops that are guarded should be able to find their guards\n-  if( _head->is_CountedLoop() && _head->as_CountedLoop()->is_main_loop() ) {\n+  if (_head->is_CountedLoop()) {\n@@ -4796,19 +4855,0 @@\n-    Node *init = cl->init_trip();\n-    Node *ctrl = cl->in(LoopNode::EntryControl);\n-    assert( ctrl->Opcode() == Op_IfTrue || ctrl->Opcode() == Op_IfFalse, \"\" );\n-    Node *iff  = ctrl->in(0);\n-    assert( iff->Opcode() == Op_If, \"\" );\n-    Node *bol  = iff->in(1);\n-    assert( bol->Opcode() == Op_Bool, \"\" );\n-    Node *cmp  = bol->in(1);\n-    assert( cmp->Opcode() == Op_CmpI, \"\" );\n-    Node *add  = cmp->in(1);\n-    Node *opaq;\n-    if( add->Opcode() == Op_Opaque1 ) {\n-      opaq = add;\n-    } else {\n-      assert( add->Opcode() == Op_AddI || add->Opcode() == Op_ConI , \"\" );\n-      assert( add == init, \"\" );\n-      opaq = cmp->in(2);\n-    }\n-    assert( opaq->Opcode() == Op_Opaque1, \"\" );\n@@ -4816,0 +4856,5 @@\n+    Node* ctrl     = cl->init_control();\n+    Node* back     = cl->back_control();\n+    assert(ctrl != nullptr && ctrl->is_CFG(), \"sane loop in-ctrl\");\n+    assert(back != nullptr && back->is_CFG(), \"sane loop backedge\");\n+    Node* loopexit = cl->loopexit(); \/\/ assert implied\n@@ -4818,2 +4863,6 @@\n-  if (_child != nullptr)  _child->verify_tree(loop->_child, this);\n-  if (_next  != nullptr)  _next ->verify_tree(loop->_next,  parent);\n+  \/\/ Broken part of VerifyLoopOptimizations (E)\n+  \/\/ Reason:\n+  \/\/   PhaseIdealLoop::split_thru_region creates new nodes for loop that are not added\n+  \/\/   to the loop body. Or maybe they are not added to the correct loop.\n+  \/\/   at \"Node* x = n->clone();\"\n+  \/*\n@@ -4862,1 +4911,1 @@\n-}\n+  *\/\n@@ -4864,0 +4913,8 @@\n+  \/\/ Recurse to children and siblings\n+  if (_child != nullptr) {\n+    _child->verify_tree(loop->_child, this);\n+  }\n+  if (_next != nullptr) {\n+    _next->verify_tree(loop->_next, parent);\n+  }\n+}\n@@ -6018,0 +6075,4 @@\n+  \/\/ Broken part of VerifyLoopOptimizations (F)\n+  \/\/ Reason:\n+  \/\/   _verify_me->get_ctrl_no_update(n) seems to return wrong result\n+  \/*\n@@ -6030,0 +6091,1 @@\n+  *\/\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":152,"deletions":90,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -794,1 +794,1 @@\n-  void verify_tree(IdealLoopTree *loop, const IdealLoopTree *parent) const;\n+  void verify_tree(IdealLoopTree* loop, const IdealLoopTree* parent) const;\n@@ -1701,1 +1701,2 @@\n-  void verify_compare(Node* n, const PhaseIdealLoop* loop_verify, VectorSet &visited) const;\n+  void verify_nodes(Node* root, const PhaseIdealLoop* loop_verify, int &fail) const;\n+  void verify_node(Node* n, const PhaseIdealLoop* loop_verify, int &fail) const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}