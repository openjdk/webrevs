{"files":[{"patch":"@@ -290,1 +290,1 @@\n-      heap->service_uncommit(shrink_before, shrink_until);\n+      heap->maybe_uncommit(shrink_before, shrink_until);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -757,4 +757,22 @@\n-void ShenandoahHeap::entry_uncommit(double shrink_before, size_t shrink_until) {\n-  static const char *msg = \"Concurrent uncommit\";\n-  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_uncommit, true \/* log_heap_usage *\/);\n-  EventMark em(\"%s\", msg);\n+void ShenandoahHeap::maybe_uncommit(double shrink_before, size_t shrink_until) {\n+  assert (ShenandoahUncommit, \"should be enabled\");\n+\n+  \/\/ Determine if there is work to do. This avoids taking heap lock if there is\n+  \/\/ no work available, avoids spamming logs with superfluous logging messages,\n+  \/\/ and minimises the amount of work while locks are taken.\n+\n+  if (committed() <= shrink_until) return;\n+\n+  bool has_work = false;\n+  for (size_t i = 0; i < num_regions(); i++) {\n+    ShenandoahHeapRegion* r = get_region(i);\n+    if (r->is_empty_committed() && (r->empty_time() < shrink_before)) {\n+      has_work = true;\n+      break;\n+    }\n+  }\n+\n+  if (has_work) {\n+    static const char* msg = \"Concurrent uncommit\";\n+    ShenandoahConcurrentPhase gcPhase(msg, ShenandoahPhaseTimings::conc_uncommit, true \/* log_heap_usage *\/);\n+    EventMark em(\"%s\", msg);\n@@ -762,1 +780,2 @@\n-  op_uncommit(shrink_before, shrink_until);\n+    op_uncommit(shrink_before, shrink_until);\n+  }\n@@ -795,23 +814,0 @@\n-void ShenandoahHeap::service_uncommit(double shrink_before, size_t shrink_until) {\n-  assert (ShenandoahUncommit, \"should be enabled\");\n-\n-  \/\/ Determine if there is work to do. This avoids taking heap lock if there is\n-  \/\/ no work available, avoids spamming logs with superfluous logging messages,\n-  \/\/ and minimises the amount of work while locks are taken.\n-\n-  if (committed() <= shrink_until) return;\n-\n-  bool has_work = false;\n-  for (size_t i = 0; i < num_regions(); i++) {\n-    ShenandoahHeapRegion* r = get_region(i);\n-    if (r->is_empty_committed() && (r->empty_time() < shrink_before)) {\n-      has_work = true;\n-      break;\n-    }\n-  }\n-\n-  if (has_work) {\n-    entry_uncommit(shrink_before, shrink_until);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":24,"deletions":28,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -367,2 +367,3 @@\n-  \/\/ Elastic heap support\n-  void entry_uncommit(double shrink_before, size_t shrink_until);\n+  \/\/ These will uncommit empty regions if heap::committed > shrink_until\n+  \/\/ and there exists at least one region which was made empty before shrink_before.\n+  void maybe_uncommit(double shrink_before, size_t shrink_until);\n@@ -370,1 +371,0 @@\n-  void service_uncommit(double shrink_before, size_t shrink_until);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}