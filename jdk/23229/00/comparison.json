{"files":[{"patch":"@@ -42,0 +42,8 @@\n+\/*\n+ * @test id=byte-array-AlignVector\n+ * @bug 8329273 8348263\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteArray AlignVector\n+ *\/\n+\n@@ -66,0 +74,8 @@\n+\/*\n+ * @test id=int-array-AlignVector\n+ * @bug 8329273 8348263\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment IntArray AlignVector\n+ *\/\n+\n@@ -74,0 +90,8 @@\n+\/*\n+ * @test id=long-array-AlignVector\n+ * @bug 8329273 8348263\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment LongArray AlignVector\n+ *\/\n+\n@@ -114,0 +138,8 @@\n+\/*\n+ * @test id=native-AlignVector\n+ * @bug 8329273 8348263\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native AlignVector\n+ *\/\n+\n@@ -143,0 +175,3 @@\n+        if (args.length > 1 && args[1].equals(\"AlignVector\")) {\n+            framework.addFlags(\"-XX:+AlignVector\");\n+        }\n@@ -559,0 +594,1 @@\n+        applyIf = {\"AlignVector\", \"false\"},\n@@ -575,0 +611,1 @@\n+        applyIf = {\"AlignVector\", \"false\"},\n@@ -708,8 +745,6 @@\n-    \/\/@IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n-    \/\/              IRNode.ADD_VI,        \"> 0\",\n-    \/\/              IRNode.STORE_VECTOR,  \"> 0\"},\n-    \/\/    applyIfPlatform = {\"64-bit\", \"true\"},\n-    \/\/    applyIf = {\"AlignVector\", \"false\"},\n-    \/\/    applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n-    \/\/ FAILS: for native memory. I think it is because of invariants, but need investigation.\n-    \/\/        The long -> int loop conversion introduces extra invariants.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n@@ -726,8 +761,6 @@\n-    \/\/@IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n-    \/\/              IRNode.ADD_VI,        \"> 0\",\n-    \/\/              IRNode.STORE_VECTOR,  \"> 0\"},\n-    \/\/    applyIfPlatform = {\"64-bit\", \"true\"},\n-    \/\/    applyIf = {\"AlignVector\", \"false\"},\n-    \/\/    applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n-    \/\/ FAILS: for native memory. I think it is because of invariants, but need investigation.\n-    \/\/        The long -> int loop conversion introduces extra invariants.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment.java","additions":49,"deletions":16,"binary":false,"changes":65,"status":"modified"}]}