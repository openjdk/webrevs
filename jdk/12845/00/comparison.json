{"files":[{"patch":"@@ -103,1 +103,1 @@\n-DISABLED_WARNINGS_microsoft := 4624 4244 4291 4146 4127\n+DISABLED_WARNINGS_microsoft := 4624 4244 4291 4146 4127 4722\n","filename":"make\/hotspot\/lib\/CompileJvm.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-#include \"runtime\/flags\/flagSetting.hpp\"\n@@ -406,1 +405,1 @@\n-  FlagSetting fs(Debugging, true);\n+  DebuggingContext debugging{};\n@@ -835,1 +834,1 @@\n-  FlagSetting fs(Debugging, true);\n+  DebuggingContext debugging{};\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -631,1 +631,3 @@\n-    if (Debugging || VMError::is_error_reported())  return nullptr;\n+    if (DebuggingContext::is_enabled() || VMError::is_error_reported()) {\n+      return nullptr;\n+    }\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -212,1 +212,1 @@\n-    if (VMError::is_error_reported() || Debugging) {\n+    if (VMError::is_error_reported() || DebuggingContext::is_enabled()) {\n","filename":"src\/hotspot\/share\/oops\/accessBackend.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -379,0 +379,3 @@\n+  \/\/ Don't complain if running a debugging command.\n+  if (DebuggingContext::is_enabled()) return;\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+  if (DebuggingContext::is_enabled()) return;\n@@ -184,0 +185,1 @@\n+  if (DebuggingContext::is_enabled()) return;\n@@ -193,0 +195,1 @@\n+  if (DebuggingContext::is_enabled()) return;\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -79,2 +79,13 @@\n-\/\/ Set to suppress secondary error reporting.\n-bool Debugging = false;\n+bool DebuggingContext::_enabled = false;\n+\n+DebuggingContext::DebuggingContext() {\n+  \/\/ Not an assert, since asserts are disabled by DebuggingContext.\n+  if (is_enabled()) {\n+    fatal(\"Multiple Debugging contexts\");\n+  }\n+  _enabled = true;\n+}\n+\n+DebuggingContext::~DebuggingContext() {\n+  _enabled = false;\n+}\n@@ -169,1 +180,0 @@\n-  if (Debugging) return;\n@@ -191,1 +201,0 @@\n-  if (Debugging) return;\n@@ -211,1 +220,0 @@\n-  if (Debugging) return;\n@@ -281,2 +289,2 @@\n-  ResourceMark rm;\n-  bool debug_save;\n+  ResourceMark _rm;\n+  DebuggingContext _debugging;\n@@ -286,2 +294,0 @@\n-    debug_save = Debugging;\n-    Debugging = true;\n@@ -295,1 +301,0 @@\n-    Debugging = debug_save;\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,92 @@\n+\/\/ The DebuggingContext class provides a mechanism for temporarily disabling\n+\/\/ asserts and various consistency checks.  Ordinarily that would be a really\n+\/\/ bad idea, but it's essential for some of the debugging commands provided by\n+\/\/ HotSpot.  (See the Command class in debug.cpp.) These commands are intended\n+\/\/ to be invoked from the debugger while the program is otherwise stopped.\n+\/\/ The commands may invoke operations while the program is in a state where\n+\/\/ those operations are not normally permitted, with the state checked by an\n+\/\/ assert.  We want the debugging commands to bypass those checks.\n+class DebuggingContext {\n+  static bool _enabled;\n+\n+public:\n+  DebuggingContext();\n+  ~DebuggingContext();\n+  \/\/ Asserts and other code use this to determine whether to bypass checks\n+  \/\/ that would otherwise lead to program termination.\n+  static bool is_enabled() { return _enabled; }\n+};\n+\n+\/\/ VMASSERT_CHECK_PASSED(P) provides the mechanism by which DebuggingContext\n+\/\/ disables asserts.  It returns true if P is true or DebuggingContext is\n+\/\/ enabled.  Assertion failure is reported if it returns false, terminating\n+\/\/ the program.\n+\/\/\n+\/\/ The DebuggingContext check being enabled isn't placed inside the report\n+\/\/ function, as that would prevent the report function from being noreturn.\n+\/\/ The report function should be noreturn so there isn't a control path to the\n+\/\/ assertion's continuation that has P being false.  Otherwise, the compiler\n+\/\/ might logically split the continuation to include that path explicitly,\n+\/\/ possibly leading to discovering (and warning about) invalid code.  For\n+\/\/ example, if P := x != nullptr, and the continuation contains a dereference\n+\/\/ of x, the compiler might warn because there is a control path (!P -> report\n+\/\/ -> continuation) where that dereference is known to be invalid.  (Of\n+\/\/ course, if execution actually took that path things would go wrong, but\n+\/\/ that's the risk the DebuggingContext mechanism takes.)\n+\/\/\n+\/\/ Similarly, the check for enabled DebuggingContext shouldn't follow P.\n+\/\/ Having this macro expand to `P || DebuggingContext::is_enabled()` has the\n+\/\/ same problem of a control path through !P to the assertion's continuation.\n+\/\/\n+\/\/ But it can't be just `DebuggingContext::is_enabled() || P` either.  That\n+\/\/ prevents the compiler from inferring based on P that it is true in the\n+\/\/ continuation.  But it also prevents the use of assertions in constexpr\n+\/\/ contexts, since that expression is not constexpr.\n+\/\/\n+\/\/ We could accomodate constexpr usage with std::is_constant_evaluated() (from\n+\/\/ C++20). Unfortunately, we don't currently support C++20.  However, most\n+\/\/ supported compilers have implemented it, and that implementation uses a\n+\/\/ compiler intrinsic that we can use directly without otherwise using C++20.\n+\/\/\n+\/\/ Note that if we could use std::is_constant_evaluated() then we could just\n+\/\/ use this definition for DebuggingContext::is_enabled:\n+\/\/   static constexpr bool is_enabled() {\n+\/\/     return !std::is_constant_evaluated() && _enabled;\n+\/\/   }\n+\/\/ The idea being that we are definitely not executing for debugging if doing\n+\/\/ constant evaluation in the compiler. We don't do something like that now,\n+\/\/ because we need a fallback when we don't have any mechanism for detecting\n+\/\/ constant evaluation.\n+#if defined(TARGET_COMPILER_gcc) || defined(TARGET_COMPILER_xlc)\n+\n+\/\/ gcc10 added both __has_builtin and __builtin_is_constant_evaluated.\n+\/\/ clang has had __has_builtin for a long time, so likely also in xlclang++.\n+\/\/ Similarly, clang has had __builtin_is_constant_evaluated for a long time.\n+\n+#ifdef __has_builtin\n+#if __has_builtin(__builtin_is_constant_evaluated)\n+#define VMASSERT_CHECK_PASSED(p) \\\n+  ((! __builtin_is_constant_evaluated() && DebuggingContext::is_enabled()) || (p))\n+#endif\n+#endif\n+\n+#elif defined(TARGET_COMPILER_visCPP)\n+\n+\/\/ std::is_constant_evaluated() and it's associated intrinsic are available in\n+\/\/ VS 2019 16.5.  The minimum supported version of VS 2019 is already past\n+\/\/ that, so we can rely on the intrinsic being available.\n+#define VMASSERT_CHECK_PASSED(p) \\\n+  ((! __builtin_is_constant_evaluated() && DebuggingContext::is_enabled()) || (p))\n+\n+#endif \/\/ End dispatch on TARGET_COMPILER_xxx\n+\n+\/\/ If we don't have a way to detect constant evaluation, then fall back to the\n+\/\/ less than ideal form of the check, and hope it works.  This succeeds at\n+\/\/ least for gcc.  The support needed to use the above definition was added in\n+\/\/ gcc10. The problems arising from analyzing the failed P case don't seem to\n+\/\/ appear until gcc12.  An alternative is to not provide DebuggingContext\n+\/\/ support for such a configuration.\n+#ifndef VMASSERT_CHECK_PASSED\n+#define VMASSERT_CHECK_PASSED(p) ((p) || DebuggingContext::is_enabled())\n+#endif\n+\n@@ -59,1 +151,1 @@\n-  if (!(p)) {                                                                  \\\n+  if (! VMASSERT_CHECK_PASSED(p)) {                                            \\\n@@ -62,1 +154,0 @@\n-    BREAKPOINT;                                                                \\\n@@ -85,1 +176,1 @@\n-  if (!(p)) {                                                                  \\\n+  if (! VMASSERT_CHECK_PASSED(p)) {                                            \\\n@@ -89,1 +180,0 @@\n-    BREAKPOINT;                                                                \\\n@@ -92,1 +182,1 @@\n-#endif\n+#endif \/\/ ASSERT\n@@ -100,0 +190,1 @@\n+\/\/ guarantee is not subject to DebuggingContext bypass.\n@@ -105,1 +196,0 @@\n-    BREAKPOINT;                                                                   \\\n@@ -113,1 +203,0 @@\n-  BREAKPOINT;                                                                     \\\n@@ -120,1 +209,0 @@\n-  BREAKPOINT;                                                                     \\\n@@ -127,1 +215,0 @@\n-  BREAKPOINT;                                                                     \\\n@@ -134,1 +221,0 @@\n-  BREAKPOINT;                                                                     \\\n@@ -141,1 +227,0 @@\n-  BREAKPOINT;                                                                     \\\n@@ -160,4 +245,0 @@\n-\/\/ Set to suppress secondary error reporting.\n-\/\/ Really should have a qualified name or something.\n-extern bool Debugging;\n-\n@@ -165,0 +246,1 @@\n+[[noreturn]]\n@@ -166,0 +248,3 @@\n+\n+[[noreturn]]\n+ATTRIBUTE_PRINTF(4, 5)\n@@ -167,1 +252,3 @@\n-                     const char* detail_fmt, ...) ATTRIBUTE_PRINTF(4, 5);\n+                     const char* detail_fmt, ...);\n+\n+[[noreturn]]\n@@ -170,1 +257,7 @@\n-void report_fatal(VMErrorType error_type, const char* file, int line, const char* detail_fmt, ...) ATTRIBUTE_PRINTF(4, 5);\n+\n+[[noreturn]]\n+ATTRIBUTE_PRINTF(4, 5)\n+void report_fatal(VMErrorType error_type, const char* file, int line, const char* detail_fmt, ...);\n+\n+[[noreturn]]\n+ATTRIBUTE_PRINTF(5, 6)\n@@ -172,4 +265,7 @@\n-                             const char* detail_fmt, ...) ATTRIBUTE_PRINTF(5, 6);\n-void report_should_not_call(const char* file, int line);\n-void report_should_not_reach_here(const char* file, int line);\n-void report_unimplemented(const char* file, int line);\n+                             const char* detail_fmt, ...);\n+\n+[[noreturn]] void report_should_not_call(const char* file, int line);\n+[[noreturn]] void report_should_not_reach_here(const char* file, int line);\n+[[noreturn]] void report_unimplemented(const char* file, int line);\n+\n+\/\/ NOT [[noreturn]]\n@@ -178,1 +274,2 @@\n-void warning(const char* format, ...) ATTRIBUTE_PRINTF(1, 2);\n+ATTRIBUTE_PRINTF(1, 2)\n+void warning(const char* format, ...);\n","filename":"src\/hotspot\/share\/utilities\/debug.hpp","additions":120,"deletions":23,"binary":false,"changes":143,"status":"modified"}]}