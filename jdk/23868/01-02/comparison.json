{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import com.sun.source.doctree.EndElementTree;\n@@ -37,0 +38,3 @@\n+import com.sun.source.doctree.LiteralTree;\n+import com.sun.source.doctree.StartElementTree;\n+import com.sun.source.doctree.TextTree;\n@@ -39,0 +43,1 @@\n+import com.sun.source.util.SimpleDocTreeVisitor;\n@@ -129,3 +134,2 @@\n-    \/** Used for whitespace normalization in pre\/code\/literal tags. *\/\n-    private boolean canStripSpace = false;\n-    private boolean inPreElement = false;\n+    \/** Used to skip whitespace normalization for comments that don't need it *\/\n+    private boolean hasPreElement = false;\n@@ -210,1 +214,0 @@\n-        canStripSpace = canStripLeadingSpace(c);\n@@ -219,1 +222,1 @@\n-        List<DCTree> body = content(Phase.BODY);\n+        List<DCTree> body = normalizeWhitespace(content(Phase.BODY));\n@@ -265,1 +268,1 @@\n-        return content(Phase.BODY);\n+        return normalizeWhitespace(content(Phase.BODY));\n@@ -319,1 +322,1 @@\n-                        case TEXT -> entity(trees, phase == Phase.BODY);\n+                        case TEXT -> entity(trees);\n@@ -347,1 +350,1 @@\n-                                            addPendingText(trees, lastNonWhite, true);\n+                                            addPendingText(trees, lastNonWhite);\n@@ -354,1 +357,1 @@\n-                            addPendingText(trees, bp - 1, phase == Phase.BODY);\n+                            addPendingText(trees, bp - 1);\n@@ -372,1 +375,1 @@\n-                        case BODY -> inlineTag(trees, true);\n+                        case BODY -> inlineTag(trees);\n@@ -374,1 +377,1 @@\n-                            if (!inlineTag(trees, false)) {\n+                            if (!inlineTag(trees)) {\n@@ -385,1 +388,1 @@\n-                            addPendingText(trees, bp - 1, false);\n+                            addPendingText(trees, bp - 1);\n@@ -403,1 +406,1 @@\n-                            addPendingText(trees, bp - 1, phase == Phase.BODY);\n+                            addPendingText(trees, bp - 1);\n@@ -411,1 +414,1 @@\n-                            addPendingText(trees, lastNonWhite, true);\n+                            addPendingText(trees, lastNonWhite);\n@@ -415,1 +418,1 @@\n-                        addPendingText(trees, bp - 1, phase == Phase.BODY);\n+                        addPendingText(trees, bp - 1);\n@@ -482,1 +485,1 @@\n-            addPendingText(trees, lastNonWhite, phase == Phase.BODY);\n+            addPendingText(trees, lastNonWhite);\n@@ -589,1 +592,0 @@\n-     * @param inBlockContent whether we are currently parsing block content\n@@ -592,1 +594,1 @@\n-    protected boolean inlineTag(ListBuffer<DCTree> list, boolean inBlockContent) {\n+    protected boolean inlineTag(ListBuffer<DCTree> list) {\n@@ -602,1 +604,1 @@\n-                addPendingText(list, bp - 1, inBlockContent);\n+                addPendingText(list, bp - 1);\n@@ -609,1 +611,1 @@\n-                addPendingText(list, bp - 2, inBlockContent);\n+                addPendingText(list, bp - 2);\n@@ -701,2 +703,1 @@\n-                        return m.at(pos).newTextTree(newString(pos, bp,\n-                                whitespacePolicy == WhitespaceRetentionPolicy.REMOVE_FIRST_SPACE));\n+                        return m.at(pos).newTextTree(newString(pos, bp));\n@@ -874,1 +875,1 @@\n-    protected void entity(ListBuffer<DCTree> list, boolean inBlockContent) {\n+    protected void entity(ListBuffer<DCTree> list) {\n@@ -876,1 +877,1 @@\n-        addPendingText(list, bp - 1, inBlockContent);\n+        addPendingText(list, bp - 1);\n@@ -1065,1 +1066,1 @@\n-                        inPreElement = true;\n+                        hasPreElement = true;\n@@ -1077,3 +1078,0 @@\n-                    if (\"pre\".equalsIgnoreCase(name.toString())) {\n-                        inPreElement = false;\n-                    }\n@@ -1182,1 +1180,1 @@\n-                    addPendingText(v, bp - 1, DocTree.Kind.TEXT, false);\n+                    addPendingText(v, bp - 1, DocTree.Kind.TEXT);\n@@ -1190,1 +1188,1 @@\n-                    addPendingText(v, bp - 1, DocTree.Kind.TEXT, false);\n+                    addPendingText(v, bp - 1, DocTree.Kind.TEXT);\n@@ -1204,2 +1202,2 @@\n-            case '&' -> entity(list, false);\n-            case '{' -> inlineTag(list, false);\n+            case '&' -> entity(list);\n+            case '{' -> inlineTag(list);\n@@ -1210,2 +1208,2 @@\n-    protected void addPendingText(ListBuffer<DCTree> list, int textEnd, boolean inBlockContent) {\n-        addPendingText(list, textEnd, textKind, inBlockContent);\n+    protected void addPendingText(ListBuffer<DCTree> list, int textEnd) {\n+        addPendingText(list, textEnd, textKind);\n@@ -1214,1 +1212,1 @@\n-    protected void addPendingText(ListBuffer<DCTree> list, int textEnd, DocTree.Kind kind, boolean inBlockContent) {\n+    protected void addPendingText(ListBuffer<DCTree> list, int textEnd, DocTree.Kind kind) {\n@@ -1219,1 +1217,1 @@\n-                            list.add(m.at(textStart).newTextTree(newString(textStart, textEnd + 1, inBlockContent)));\n+                            list.add(m.at(textStart).newTextTree(newString(textStart, textEnd + 1)));\n@@ -1221,2 +1219,1 @@\n-                            list.add(m.at(textStart).newRawTextTree(DocTree.Kind.MARKDOWN,\n-                                    newString(textStart, textEnd + 1)));\n+                            list.add(m.at(textStart).newRawTextTree(DocTree.Kind.MARKDOWN, newString(textStart, textEnd + 1)));\n@@ -1224,1 +1221,1 @@\n-                            throw new IllegalArgumentException(kind.toString());\n+                        throw new IllegalArgumentException(kind.toString());\n@@ -1820,46 +1817,0 @@\n-    \/**\n-     * Check if this is a traditional doc comment where every non-emtpy line past\n-     * the first newline character has at least one leading space. This suggests\n-     * that indentation is incidental and should be removed in preformatted text.\n-     *\/\n-    boolean canStripLeadingSpace(String comment) {\n-        if (textKind == DocTree.Kind.MARKDOWN || isHtmlFile) {\n-            return false;\n-        }\n-        for (int i = 0; i < comment.length() - 1; i++) {\n-            if (comment.charAt(i) == '\\n') {\n-                char c = comment.charAt(i + 1);\n-                if (c != '\\n' && c != ' ') {\n-                    return false;\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Variant of newString that optionally skips a leading space in each line.\n-     *\n-     * @param start position of first character of string\n-     * @param end position of character beyond last character to be included\n-     * @param stripLeadingSpace whether leading space may be stripped\n-     *\/\n-    String newString(int start, int end, boolean stripLeadingSpace) {\n-        if (stripLeadingSpace && canStripSpace && inPreElement) {\n-            StringBuilder sb = new StringBuilder(end - start);\n-            int pos = start;\n-            \/\/ The parser will never call this with a strippable space at buf[start].\n-            for (int i = start; i < end - 1; i++) {\n-                if (buf[i] == '\\n' && buf[i + 1] == ' ') {\n-                    sb.append(buf, pos, ++i - pos);\n-                    pos = i + 1;\n-                }\n-            }\n-            if (pos < end) {\n-                sb.append(buf, pos, end - pos);\n-            }\n-            return sb.toString();\n-        }\n-        return newString(start, end);\n-    }\n-\n@@ -1917,0 +1868,179 @@\n+    \/*\n+     * Check if every newline character in the doc comment is followed by at least\n+     * one space character, which suggests that indentation is incidental and should be\n+     * removed in preformatted text.\n+     *\/\n+    private boolean canStripLeadingSpace() {\n+        for (int i = 0; i < buf.length - 2; i++) {\n+            if (buf[i] == '\\n') {\n+                char c = buf[i + 1];\n+                if (c != '\\n' && c != ' ') {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/*\n+     * This method performs whitespace normalization of preformatted text in parsed comments.\n+     * Two kinds of normalization are carried out on top-level text and bodies of\n+     * {@code}\/{@literal} tags inside <pre>...<\/pre> tags:\n+     *\n+     *  - Removal of one leading space following each line break. This is commonly\n+     *    caused by doc comment formatting conventions and parsing rules, and results\n+     *    in unintentional indentation and a trailing blank line in rendered <pre> content.\n+     *\n+     *  - Removal of a single line break after a <code> or {@code tag at the beginning\n+     *    of <pre> content. Browsers ignore a leading line break immediately following\n+     *    the <pre> tag, but not after a <code> tag or other whitespace. This causes\n+     *    a leading blank line in the rendered <pre> content.\n+     *\n+     * Normalization is only performed on traditional doc comments since they are uniquely\n+     * affected by these problems (Markdown comments already come stripped from leading\n+     * whitespace). Leading spaces are only removed if all line breaks in the comment are\n+     * followed by a space character. Both steps are performed independently of each other.\n+     *\/\n+    private List<DCTree> normalizeWhitespace(List<DCTree> list) {\n+\n+        \/\/ Do nothing if comment is not eligible for whitespace normalization.\n+        if (!hasPreElement || textKind == DocTree.Kind.MARKDOWN || isHtmlFile) {\n+            return list;\n+        }\n+\n+        final var stripLeadingSpace = canStripLeadingSpace();\n+\n+        \/\/ Context for whitespace normalization visitor\n+        class NormalizationContext {\n+            int pos = 0;                \/\/ current position in doctree list\n+            int currentPre = -1;        \/\/ position of active pre start tag\n+            int strippableNewline = -1; \/\/ marker for strippable leading space\n+\n+            \/\/ Are we currently inside a <pre> element?\n+            boolean inPre() {\n+                return currentPre > -1;\n+            }\n+            \/\/ Is this the first element following a <pre> start tag?\n+            boolean firstInPre() {\n+                return inPre() && currentPre == pos - 1;\n+            }\n+            \/\/ Does the current doctree have leading newline that should be stripped?\n+            boolean stripLeadingNewline() {\n+                return strippableNewline == pos;\n+            }\n+        }\n+\n+        var normalized = new ListBuffer<DCTree>();\n+        var visitor = new SimpleDocTreeVisitor<DCTree, NormalizationContext>() {\n+\n+            private DCText normalizePreContent(DCText text, NormalizationContext cx) {\n+                var body = text.getBody();\n+\n+                if (stripLeadingSpace && body.contains(\"\\n \")) {\n+                    \/\/ Remove a single leading space following each newline character.\n+                    body = body.replace(\"\\n \", \"\\n\");\n+                }\n+                if (cx.stripLeadingNewline()) {\n+                    \/\/ Remove a leading newline if this text has been marked for it.\n+                    assert(body.startsWith(\"\\n\"));\n+                    body = body.substring(1);\n+                }\n+\n+                return body == text.getBody() ? text : m.at(text.pos).newTextTree(body);\n+            }\n+\n+            private DCText normalizeStartOfPreContent(DCText text, NormalizationContext cx) {\n+                \/\/ Check if <pre> content starts with one or more space characters, followed by\n+                \/\/ {@code}, {@literal} or <code> with leading newline in its content. If so,\n+                \/\/ drop the space(s) and mark the newline for removal to avoid a blank leading line.\n+                if (cx.pos < list.length() - 1 && text.getBody().matches(\" +\")) {\n+                    var next = list.get(cx.pos + 1);\n+                    if (next instanceof LiteralTree literal\n+                            && literal.getBody().getBody().startsWith(\"\\n\")) {\n+                        \/\/ <pre> {@code\\n\n+                        cx.strippableNewline = cx.pos + 1;\n+                        return null;\n+\n+                    } else if (cx.pos < list.length() - 2\n+                            && next instanceof StartElementTree elem\n+                            && elem.getName().toString().equalsIgnoreCase(\"code\")\n+                            && list.get(cx.pos + 2) instanceof DCText code\n+                            && code.getBody().startsWith(\"\\n\")) {\n+                        \/\/ <pre> <code>\\n\n+                        cx.strippableNewline = cx.pos + 2;\n+                        return null;\n+                    }\n+                }\n+                \/\/ Do normal pre content normalization.\n+                return normalizePreContent(text, cx);\n+            }\n+\n+            @Override\n+            public DCTree visitText(TextTree text, NormalizationContext cx) {\n+                if (cx.inPre()) {\n+                    return cx.firstInPre()\n+                            ? normalizeStartOfPreContent((DCText) text, cx)\n+                            : normalizePreContent((DCText) text, cx);\n+                }\n+                return (DCTree) text;\n+            }\n+\n+            @Override\n+            public DCTree visitLiteral(LiteralTree literal, NormalizationContext cx) {\n+                if (cx.inPre()) {\n+                    if (cx.firstInPre() && literal.getBody().getBody().startsWith(\"\\n\")) {\n+                        \/\/ <pre>{@code\\n\n+                        cx.strippableNewline = cx.pos;\n+                    }\n+                    var normalized = normalizePreContent((DCText) literal.getBody(), cx);\n+                    if (normalized != literal.getBody()) {\n+                        m.at(((DCTree) literal).pos);\n+                        return literal.getKind() == DocTree.Kind.CODE\n+                                ? m.newCodeTree(normalized)\n+                                : m.newLiteralTree(normalized);\n+                    }\n+                }\n+                return (DCTree) literal;\n+            }\n+\n+            @Override\n+            public DCTree visitStartElement(StartElementTree node, NormalizationContext cx) {\n+                if (node.getName().toString().equalsIgnoreCase(\"pre\")) {\n+                    cx.currentPre = cx.pos;\n+                } else if (cx.firstInPre() && node.getName().toString().equalsIgnoreCase(\"code\")) {\n+                    if (cx.pos < list.length() - 1\n+                            && list.get(cx.pos + 1) instanceof DCText code\n+                            && code.getBody().startsWith(\"\\n\")) {\n+                        \/\/ <pre><code>\\n\n+                        cx.strippableNewline = cx.pos + 1;\n+                    }\n+                }\n+                return (DCTree) node;\n+            }\n+\n+            @Override\n+            public DCTree visitEndElement(EndElementTree node, NormalizationContext cx) {\n+                if (node.getName().toString().equalsIgnoreCase(\"pre\")) {\n+                    cx.currentPre = -1;\n+                }\n+                return (DCTree) node;\n+            }\n+\n+            @Override\n+            protected DCTree defaultAction(DocTree node, NormalizationContext context) {\n+                return (DCTree) node;\n+            }\n+        };\n+\n+        var cx = new NormalizationContext();\n+        for (var tree : list) {\n+            var visited = visitor.visit(tree, cx);\n+            if (visited != null) {\n+                normalized.add(visited);\n+            }\n+            cx.pos++;\n+        }\n+\n+        return normalized.toList();\n+    }\n+\n@@ -2266,1 +2396,1 @@\n-                                addPendingText(v, bp - 1, DocTree.Kind.TEXT, false);\n+                                addPendingText(v, bp - 1, DocTree.Kind.TEXT);\n@@ -2275,1 +2405,1 @@\n-                                addPendingText(v, bp - 1, DocTree.Kind.TEXT, false);\n+                                addPendingText(v, bp - 1, DocTree.Kind.TEXT);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":217,"deletions":87,"binary":false,"changes":304,"status":"modified"},{"patch":"@@ -73,2 +73,1 @@\n-                     Example:  <pre><code>\n-                      line 0 @Override\n+                     Example:  <pre><code>  line 0 @Override\n@@ -83,2 +82,1 @@\n-                     Example:  <pre>\n-                      line 0 @Override\n+                     Example:  <pre>  line 0 @Override\n@@ -93,2 +91,1 @@\n-                     Example:  <pre>\n-                      line 0 @Override\n+                     Example:  <pre>  line 0 @Override\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLiteralCodeInPre\/TestLiteralCodeInPre.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-    Literal[CODE, pos:6, |____@Override|____void_m()_{_}|]\n+    Literal[CODE, pos:6, ____@Override|____void_m()_{_}|]\n@@ -151,1 +151,1 @@\n-    Literal[CODE, pos:5, |____@Override|____void_m()_{_}|]\n+    Literal[CODE, pos:5, ____@Override|____void_m()_{_}|]\n@@ -173,1 +173,1 @@\n-    Literal[CODE, pos:5, |____@Override|____void_m()_{_}|]\n+    Literal[CODE, pos:5, ____@Override|____void_m()_{_}|]\n@@ -194,1 +194,1 @@\n-    Literal[CODE, pos:7, |_____@Override|_____void_m()_{_}|_]\n+    Literal[CODE, pos:7, _____@Override|_____void_m()_{_}|_]\n","filename":"test\/langtools\/tools\/javac\/doctree\/CodeTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1029,6 +1029,0 @@\n-            if (normalizeTags && !isLineComment) {\n-                \/\/ Whitespace normalization within <pre> tags: remove single space from every new line\n-                var p = Pattern.compile(\"(<pre>)(.*)(<\/pre>)\", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n-                s2 = p.matcher(s2).replaceAll(\n-                        r -> r.group(1) + r.group(2).replaceAll(\"\\\\n \", \"\\n\") + r.group(3));\n-            }\n@@ -1047,1 +1041,1 @@\n-            return sb.toString()\n+            s2 = sb.toString()\n@@ -1050,0 +1044,16 @@\n+            return normalizePreContent(s2, isLineComment, normalizeTags);\n+        }\n+\n+        String normalizePreContent(String s, boolean isLineComment, boolean normalizeTags) {\n+            String s2 = s;\n+            if (!isLineComment) {\n+                if (normalizeTags) {\n+                    \/\/ Whitespace normalization within <pre> tags: remove single space after every newline\n+                    var p = Pattern.compile(\"(<pre>)(.*)(<\/pre>)\", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n+                    s2 = p.matcher(s2).replaceAll(\n+                            r -> r.group(1) + r.group(2).replaceAll(\"\\\\n \", \"\\n\") + r.group(3));\n+                }\n+                \/\/ Remove leading newline after {@code at the beginning of <pre> content.\n+                s2 = s2.replaceAll(\"<pre>\\\\{@code\\\\n\", \"<pre>{@code\");\n+            }\n+            return s2;\n","filename":"test\/langtools\/tools\/javac\/doctree\/DocCommentTester.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"}]}