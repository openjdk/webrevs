{"files":[{"patch":"@@ -75,13 +75,0 @@\n-size_t CompactHashtableWriter::estimate_size(int num_entries) {\n-  int num_buckets = calculate_num_buckets(num_entries);\n-  size_t bucket_bytes = ArchiveBuilder::ro_array_bytesize<u4>(num_buckets + 1);\n-\n-  \/\/ In worst case, we have no VALUE_ONLY_BUCKET_TYPE, so each entry takes 2 slots\n-  int entries_space = 2 * num_entries;\n-  size_t entry_bytes = ArchiveBuilder::ro_array_bytesize<u4>(entries_space);\n-\n-  return bucket_bytes\n-       + entry_bytes\n-       + SimpleCompactHashtable::calculate_header_size();\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -137,2 +137,0 @@\n-\n-  static size_t estimate_size(int num_entries);\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,1 +210,0 @@\n-  void update_oops_in_archived_module(int root_oop_index);\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -708,7 +708,0 @@\n-size_t SymbolTable::estimate_size_for_archive() {\n-  if (_items_count > (size_t)max_jint) {\n-    fatal(\"Too many symbols to be archived: %zu\", _items_count);\n-  }\n-  return CompactHashtableWriter::estimate_size(int(_items_count));\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -164,1 +164,0 @@\n-  static size_t estimate_size_for_archive() NOT_CDS_RETURN_(0);\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1226,39 +1226,0 @@\n-class EstimateSizeForArchive : StackObj {\n-  size_t _shared_class_info_size;\n-  int _num_builtin_klasses;\n-  int _num_unregistered_klasses;\n-\n-public:\n-  EstimateSizeForArchive() {\n-    _shared_class_info_size = 0;\n-    _num_builtin_klasses = 0;\n-    _num_unregistered_klasses = 0;\n-  }\n-\n-  void do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n-    if (!info.is_excluded()) {\n-      size_t byte_size = info.runtime_info_bytesize();\n-      _shared_class_info_size += align_up(byte_size, SharedSpaceObjectAlignment);\n-    }\n-  }\n-\n-  size_t total() {\n-    return _shared_class_info_size;\n-  }\n-};\n-\n-size_t SystemDictionaryShared::estimate_size_for_archive() {\n-  EstimateSizeForArchive est;\n-  _dumptime_table->iterate_all_live_classes(&est);\n-  size_t total_size = est.total() +\n-    CompactHashtableWriter::estimate_size(_dumptime_table->count_of(true)) +\n-    CompactHashtableWriter::estimate_size(_dumptime_table->count_of(false));\n-\n-  size_t bytesize = align_up(sizeof(RunTimeLambdaProxyClassInfo), SharedSpaceObjectAlignment);\n-  total_size +=\n-      (bytesize * _dumptime_lambda_proxy_class_dictionary->_count) +\n-      CompactHashtableWriter::estimate_size(_dumptime_lambda_proxy_class_dictionary->_count);\n-\n-  return total_size;\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":0,"deletions":39,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -297,1 +297,0 @@\n-  static size_t estimate_size_for_archive();\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}