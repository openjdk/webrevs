{"files":[{"patch":"@@ -1627,1 +1627,2 @@\n-  _irreducible_entry = false;\n+  _irreducible_loop_head = false;\n+  _irreducible_loop_secondary_entry = false;\n@@ -1845,0 +1846,34 @@\n+\/\/ Analogous to PhaseIdealLoop::is_in_irreducible_loop\n+bool ciTypeFlow::Block::is_in_irreducible_loop() const {\n+  if (!outer()->has_irreducible_entry()) {\n+    return false; \/\/ No irreducible loop in method.\n+  }\n+  Loop* lp = loop(); \/\/ Innermost loop containing block.\n+  if (lp == nullptr) {\n+    assert(!is_post_visited(), \"must have enclosing loop once post-visited\");\n+    return false; \/\/ Not yet processed, so we do not know, yet.\n+  }\n+  \/\/ Walk all the way up the loop-tree, search for an irreducible loop.\n+  do {\n+    if (lp->is_irreducible()) {\n+      return true; \/\/ We are in irreducible loop.\n+    }\n+    if (lp->head()->pre_order() == 0) {\n+      return false; \/\/ Found root loop, terminate.\n+    }\n+    lp = lp->parent();\n+  } while (lp != nullptr);\n+  \/\/ We have \"lp->parent() == nullptr\", which happens only for infinite loops,\n+  \/\/ where no parent is attached to the loop. We did not find any irreducible\n+  \/\/ loop from this block out to lp. Thus lp only has one entry, and no exit\n+  \/\/ (it is infinite and reducible). We can always rewrite an infinite loop\n+  \/\/ that is nested inside other loops:\n+  \/\/ while(condition) { infinite_loop; }\n+  \/\/ with an equivalent program where the infinite loop is an outermost loop\n+  \/\/ that is not nested in any loop:\n+  \/\/ while(condition) { break; } infinite_loop;\n+  \/\/ Thus, we can understand lp as an outermost loop, and can terminate and\n+  \/\/ conclude: this block is in no irreducible loop.\n+  return false;\n+}\n+\n@@ -1889,1 +1924,3 @@\n-  if (is_irreducible_entry()) st->print(\" irred\");\n+  if (is_in_irreducible_loop()) st->print(\" in_irred\");\n+  if (is_irreducible_loop_head()) st->print(\" irred_head\");\n+  if (is_irreducible_loop_secondary_entry()) st->print(\" irred_entry\");\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -538,2 +538,5 @@\n-    \/\/ This block is entry to irreducible loop.\n-    bool                             _irreducible_entry;\n+    \/\/ This block is a loop head of an irreducible loop.\n+    bool                             _irreducible_loop_head;\n+\n+    \/\/ This block is a secondary entry to an irreducible loop (entry but not head).\n+    bool                             _irreducible_loop_secondary_entry;\n@@ -690,2 +693,5 @@\n-    void   set_irreducible_entry(bool c) { _irreducible_entry = c; }\n-    bool   is_irreducible_entry() const  { return _irreducible_entry; }\n+    bool   is_in_irreducible_loop() const;\n+    void   set_irreducible_loop_head()   { _irreducible_loop_head = true; }\n+    bool   is_irreducible_loop_head() const { return _irreducible_loop_head; }\n+    void   set_irreducible_loop_secondary_entry() { _irreducible_loop_secondary_entry = true; }\n+    bool   is_irreducible_loop_secondary_entry() const { return _irreducible_loop_secondary_entry; }\n@@ -758,1 +764,2 @@\n-      entry->set_irreducible_entry(true);\n+      head()->set_irreducible_loop_head();\n+      entry->set_irreducible_loop_secondary_entry();\n@@ -882,1 +889,1 @@\n-  Loop* loop_tree_root()              { return _loop_tree_root; }\n+  Loop* loop_tree_root() const        { return _loop_tree_root; }\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.hpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -438,0 +438,13 @@\n+void RegionNode::set_loop_status(RegionNode::LoopStatus status) {\n+  assert(status != RegionNode::LoopStatus::NeverIrreducibleEntry, \"do not set this\");\n+  assert(loop_status() == RegionNode::LoopStatus::NeverIrreducibleEntry, \"why set our status again?\");\n+  _loop_status = status;\n+}\n+\n+#ifdef ASSERT\n+void RegionNode::verify_can_be_irreducible_entry() const {\n+  assert(loop_status() == RegionNode::LoopStatus::MaybeIrreducibleEntry, \"must be marked irreducible\");\n+  assert(!is_Loop(), \"LoopNode cannot be irreducible loop entry\");\n+}\n+#endif \/\/ASSERT\n+\n@@ -525,0 +538,1 @@\n+  bool found_top = false; \/\/ irreducible loops need to check reachability if we find TOP\n@@ -548,0 +562,1 @@\n+        found_top = true;\n@@ -583,1 +598,14 @@\n-  if (can_reshape && cnt == 1) {\n+  if (can_reshape && found_top && loop_status() == RegionNode::LoopStatus::MaybeIrreducibleEntry) {\n+    \/\/ Is it a dead irreducible loop?\n+    \/\/ If an irreducible loop loses one of the multiple entries\n+    \/\/ that went into the loop head, or any secondary entries,\n+    \/\/ we need to verify if the irreducible loop is still reachable,\n+    \/\/ as the special logic in is_unreachable_region only works\n+    \/\/ for reducible loops.\n+    if (is_unreachable_from_root(phase)) {\n+      \/\/ The irreducible loop is dead - must remove it\n+      PhaseIterGVN* igvn = phase->is_IterGVN();\n+      remove_unreachable_subgraph(igvn);\n+      return nullptr;\n+    }\n+  } else if (can_reshape && cnt == 1) {\n@@ -593,3 +621,0 @@\n-      \/\/ This region and therefore all nodes on the input control path(s) are unreachable\n-      \/\/ from root. To avoid incomplete removal of unreachable subgraphs, walk up the CFG\n-      \/\/ and aggressively replace all nodes by top.\n@@ -597,39 +622,2 @@\n-      Node* top = phase->C->top();\n-      ResourceMark rm;\n-      Node_List nstack;\n-      VectorSet visited;\n-      nstack.push(this);\n-      visited.set(_idx);\n-      while (nstack.size() != 0) {\n-        Node* n = nstack.pop();\n-        for (uint i = 0; i < n->req(); ++i) {\n-          Node* m = n->in(i);\n-          assert(m != (Node*)phase->C->root(), \"Should be unreachable from root\");\n-          if (m != NULL && m->is_CFG() && !visited.test_set(m->_idx)) {\n-            nstack.push(m);\n-          }\n-        }\n-        if (n->is_Region()) {\n-          \/\/ Eagerly replace phis with top to avoid regionless phis.\n-          n->set_req(0, NULL);\n-          bool progress = true;\n-          uint max = n->outcnt();\n-          DUIterator j;\n-          while (progress) {\n-            progress = false;\n-            for (j = n->outs(); n->has_out(j); j++) {\n-              Node* u = n->out(j);\n-              if (u->is_Phi()) {\n-                igvn->replace_node(u, top);\n-                if (max != n->outcnt()) {\n-                  progress = true;\n-                  j = n->refresh_out_pos(j);\n-                  max = n->outcnt();\n-                }\n-              }\n-            }\n-          }\n-        }\n-        igvn->replace_node(n, top);\n-      }\n-      return NULL;\n+      remove_unreachable_subgraph(igvn);\n+      return nullptr;\n@@ -807,0 +795,53 @@\n+\/\/--------------------------remove_unreachable_subgraph----------------------\n+\/\/ This region and therefore all nodes on the input control path(s) are unreachable\n+\/\/ from root. To avoid incomplete removal of unreachable subgraphs, walk up the CFG\n+\/\/ and aggressively replace all nodes by top.\n+\/\/ If a control node \"def\" with a single control output \"use\" has its single output\n+\/\/ \"use\" replaced with top, then \"use\" removes itself. This has the consequence that\n+\/\/ when we visit \"use\", it already has all inputs removed. They are lost and we cannot\n+\/\/ traverse them. This is why we fist find all unreachable nodes, and then remove\n+\/\/ them in a second step.\n+void RegionNode::remove_unreachable_subgraph(PhaseIterGVN* igvn) {\n+  Node* top = igvn->C->top();\n+  ResourceMark rm;\n+  Unique_Node_List unreachable; \/\/ visit each only once\n+  unreachable.push(this);\n+  \/\/ Recursively find all control inputs.\n+  for (uint i = 0; i < unreachable.size(); i++) {\n+    Node* n = unreachable.at(i);\n+    for (uint i = 0; i < n->req(); ++i) {\n+      Node* m = n->in(i);\n+      assert(m == nullptr || !m->is_Root(), \"Should be unreachable from root\");\n+      if (m != nullptr && m->is_CFG()) {\n+        unreachable.push(m);\n+      }\n+    }\n+  }\n+  \/\/ Remove all unreachable nodes.\n+  for (uint i = 0; i < unreachable.size(); i++) {\n+    Node* n = unreachable.at(i);\n+    if (n->is_Region()) {\n+      \/\/ Eagerly replace phis with top to avoid regionless phis.\n+      n->set_req(0, nullptr);\n+      bool progress = true;\n+      uint max = n->outcnt();\n+      DUIterator j;\n+      while (progress) {\n+        progress = false;\n+        for (j = n->outs(); n->has_out(j); j++) {\n+          Node* u = n->out(j);\n+          if (u->is_Phi()) {\n+            igvn->replace_node(u, top);\n+            if (max != n->outcnt()) {\n+              progress = true;\n+              j = n->refresh_out_pos(j);\n+              max = n->outcnt();\n+            }\n+          }\n+        }\n+      }\n+    }\n+    igvn->replace_node(n, top);\n+  }\n+}\n+\n@@ -955,0 +996,16 @@\n+#ifndef PRODUCT\n+void RegionNode::dump_spec(outputStream* st) const {\n+  Node::dump_spec(st);\n+  switch (loop_status()) {\n+  case RegionNode::LoopStatus::MaybeIrreducibleEntry:\n+    st->print(\"#irreducible \");\n+    break;\n+  case RegionNode::LoopStatus::Reducible:\n+    st->print(\"#reducible \");\n+    break;\n+  case RegionNode::LoopStatus::NeverIrreducibleEntry:\n+    break; \/\/ nothing\n+  }\n+}\n+#endif\n+\n@@ -1357,0 +1414,3 @@\n+  if (must_wait_for_region_in_irreducible_loop(phase)) {\n+    return this;\n+  }\n@@ -1704,0 +1764,12 @@\n+  \/\/ This optimization tries to find two or more inputs of phi with the same constant value\n+  \/\/ It then splits them into a separate Phi, and according Region. If this is a loop-entry,\n+  \/\/ and the loop entry has multiple fall-in edges, and some of those fall-in edges have that\n+  \/\/ constant, and others not, we may split the fall-in edges into separate Phi's, and create\n+  \/\/ an irreducible loop. For reducible loops, this never seems to happen, as the multiple\n+  \/\/ fall-in edges are already merged before the loop head during parsing. But with irreducible\n+  \/\/ loops present the order or merging during parsing can sometimes prevent this.\n+  if (phase->C->has_irreducible_loop()) {\n+    \/\/ Avoid this optimization if any irreducible loops are present. Else we may create\n+    \/\/ an irreducible loop that we do not detect.\n+    return nullptr;\n+  }\n@@ -1898,0 +1970,25 @@\n+\/\/ If the Phi's Region is in an irreducible loop, and the Region\n+\/\/ has had an input removed, but not yet transformed, it could be\n+\/\/ that the Region (and this Phi) are not reachable from Root.\n+\/\/ If we allow the Phi to collapse before the Region, this may lead\n+\/\/ to dead-loop data. Wait for the Region to check for reachability,\n+\/\/ and potentially remove the dead code.\n+bool PhiNode::must_wait_for_region_in_irreducible_loop(PhaseGVN* phase) const {\n+  RegionNode* region = in(0)->as_Region();\n+  if (region->loop_status() == RegionNode::LoopStatus::MaybeIrreducibleEntry) {\n+    Node* top = phase->C->top();\n+    for (uint j = 1; j < req(); j++) {\n+      Node* rc = region->in(j); \/\/ for each control input\n+      if (rc == nullptr || phase->type(rc) == Type::TOP) {\n+        \/\/ Region is missing a control input\n+        Node* n = in(j);\n+        if (n != nullptr && n != top) {\n+          \/\/ Phi still has its input, so region just lost its input\n+          return true;\n+        }\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -1917,0 +2014,4 @@\n+  if (must_wait_for_region_in_irreducible_loop(phase)) {\n+    return nullptr;\n+  }\n+\n@@ -2034,1 +2135,1 @@\n-    if (ident != uin && !ident->is_top()) {\n+    if (ident != uin && !ident->is_top() && !must_wait_for_region_in_irreducible_loop(phase)) {\n@@ -2042,1 +2143,2 @@\n-    assert(ident == uin || ident->is_top(), \"Identity must clean this up\");\n+    \/\/ Identity may not return the expected uin, if it has to wait for the region, in irreducible case\n+    assert(ident == uin || ident->is_top() || must_wait_for_region_in_irreducible_loop(phase), \"Identity must clean this up\");\n@@ -2496,1 +2598,5 @@\n-  assert(cached_vbox != NULL, \"sanity\");\n+  if (cached_vbox == nullptr) {\n+    \/\/ We have a Phi dead-loop (no data-input). Phi nodes are considered safe,\n+    \/\/ so just avoid this optimization.\n+    return nullptr;\n+  }\n@@ -2737,0 +2843,4 @@\n+  if (phase->type(in(0)->in(0)) == Type::TOP) {\n+    assert(in(0)->is_CatchProj(), \"control is CatchProj\");\n+    return phase->C->top(); \/\/ dead code\n+  }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":156,"deletions":46,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -68,0 +68,12 @@\n+public:\n+  enum LoopStatus {\n+    \/\/ No guarantee: the region may be an irreducible loop entry, thus we have to\n+    \/\/ be careful when removing entry control to it.\n+    MaybeIrreducibleEntry,\n+    \/\/ Limited guarantee: this region may be (nested) inside an irreducible loop,\n+    \/\/ but it will never be an irreducible loop entry.\n+    NeverIrreducibleEntry,\n+    \/\/ Strong guarantee: this region is not (nested) inside an irreducible loop.\n+    Reducible,\n+  };\n+\n@@ -70,0 +82,1 @@\n+  LoopStatus _loop_status;\n@@ -79,1 +92,5 @@\n-  RegionNode(uint required) : Node(required), _is_unreachable_region(false) {\n+  RegionNode(uint required)\n+    : Node(required),\n+      _is_unreachable_region(false),\n+      _loop_status(LoopStatus::NeverIrreducibleEntry)\n+  {\n@@ -98,0 +115,4 @@\n+  LoopStatus loop_status() const { return _loop_status; };\n+  void set_loop_status(LoopStatus status);\n+  DEBUG_ONLY(void verify_can_be_irreducible_entry() const;)\n+\n@@ -108,0 +129,1 @@\n+  void remove_unreachable_subgraph(PhaseIterGVN* igvn);\n@@ -111,0 +133,1 @@\n+  NOT_PRODUCT(virtual void dump_spec(outputStream* st) const;)\n@@ -154,0 +177,2 @@\n+  bool must_wait_for_region_in_irreducible_loop(PhaseGVN* phase) const;\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+  RegionNode::dump_spec(st);\n@@ -3140,1 +3141,1 @@\n-  Node *landing_pad = new RegionNode( fall_in_cnt+1 );\n+  RegionNode* landing_pad = new RegionNode(fall_in_cnt + 1);\n@@ -3142,0 +3143,2 @@\n+  \/\/ If _head was irreducible loop entry, landing_pad may now be too\n+  landing_pad->set_loop_status(_head->as_Region()->loop_status());\n@@ -4630,4 +4633,0 @@\n-\n-  \/\/ disable assert until issue with split_flow_path is resolved (6742111)\n-  \/\/ assert(!_has_irreducible_loops || C->parsed_irreducible_loop() || C->is_osr_compilation(),\n-  \/\/        \"shouldn't introduce irreducible loops\");\n@@ -5059,0 +5058,1 @@\n+  DEBUG_ONLY(verify_regions_in_irreducible_loops();)\n@@ -5153,4 +5153,9 @@\n-    \/\/ Weeny check for irreducible.  This child was already visited (this\n-    \/\/ IS the post-work phase).  Is this child's loop header post-visited\n-    \/\/ as well?  If so, then I found another entry into the loop.\n-    if (!_verify_only) {\n+    if (is_postvisited(l->_head)) {\n+      \/\/ We are currently visiting l, but its head has already been post-visited.\n+      \/\/ l is irreducible: we just found a second entry m.\n+      _has_irreducible_loops = true;\n+      RegionNode* secondary_entry = m->as_Region();\n+      DEBUG_ONLY(secondary_entry->verify_can_be_irreducible_entry();)\n+\n+      \/\/ Walk up the loop-tree, mark all loops that are already post-visited as irreducible\n+      \/\/ Since m is a secondary entry to them all.\n@@ -5158,1 +5163,0 @@\n-        \/\/ found irreducible\n@@ -5160,0 +5164,2 @@\n+        RegionNode* head = l->_head->as_Region();\n+        DEBUG_ONLY(head->verify_can_be_irreducible_entry();)\n@@ -5161,1 +5167,0 @@\n-        _has_irreducible_loops = true;\n@@ -5164,0 +5169,6 @@\n+#ifndef PRODUCT\n+          if (TraceLoopOpts) {\n+            tty->print_cr(\"bailout: unhandled CFG: infinite irreducible loop\");\n+            m->dump();\n+          }\n+#endif\n@@ -5168,0 +5179,2 @@\n+    }\n+    if (!_verify_only) {\n@@ -5235,0 +5248,68 @@\n+#ifdef ASSERT\n+\/\/--------------------------verify_regions_in_irreducible_loops----------------\n+\/\/ Iterate down from Root through CFG, verify for every region:\n+\/\/ if it is in an irreducible loop it must be marked as such\n+void PhaseIdealLoop::verify_regions_in_irreducible_loops() {\n+  ResourceMark rm;\n+  if (!_has_irreducible_loops) {\n+    \/\/ last build_loop_tree has not found any irreducible loops\n+    \/\/ hence no region has to be marked is_in_irreduible_loop\n+    return;\n+  }\n+\n+  RootNode* root = C->root();\n+  Unique_Node_List worklist; \/\/ visit all nodes once\n+  worklist.push(root);\n+  bool failure = false;\n+  for (uint i = 0; i < worklist.size(); i++) {\n+    Node* n = worklist.at(i);\n+    if (n->is_Region()) {\n+      RegionNode* region = n->as_Region();\n+      if (is_in_irreducible_loop(region) &&\n+          region->loop_status() == RegionNode::LoopStatus::Reducible) {\n+        failure = true;\n+        tty->print(\"irreducible! \");\n+        region->dump();\n+      }\n+    }\n+    for (DUIterator_Fast jmax, j = n->fast_outs(jmax); j < jmax; j++) {\n+      Node* use = n->fast_out(j);\n+      if (use->is_CFG()) {\n+        worklist.push(use); \/\/ push if was not pushed before\n+      }\n+    }\n+  }\n+  assert(!failure, \"region in irreducible loop was marked as reducible\");\n+}\n+\n+\/\/---------------------------is_in_irreducible_loop-------------------------\n+\/\/ Analogous to ciTypeFlow::Block::is_in_irreducible_loop\n+bool PhaseIdealLoop::is_in_irreducible_loop(RegionNode* region) {\n+  if (!_has_irreducible_loops) {\n+    return false; \/\/ no irreducible loop in graph\n+  }\n+  IdealLoopTree* l = get_loop(region); \/\/ l: innermost loop that contains region\n+  do {\n+    if (l->_irreducible) {\n+      return true; \/\/ found it\n+    }\n+    if (l == _ltree_root) {\n+      return false; \/\/ reached root, terimnate\n+    }\n+    l = l->_parent;\n+  } while (l != nullptr);\n+  assert(region->is_in_infinite_subgraph(), \"must be in infinite subgraph\");\n+  \/\/ We have \"l->_parent == nullptr\", which happens only for infinite loops,\n+  \/\/ where no parent is attached to the loop. We did not find any irreducible\n+  \/\/ loop from this block out to lp. Thus lp only has one entry, and no exit\n+  \/\/ (it is infinite and reducible). We can always rewrite an infinite loop\n+  \/\/ that is nested inside other loops:\n+  \/\/ while(condition) { infinite_loop; }\n+  \/\/ with an equivalent program where the infinite loop is an outermost loop\n+  \/\/ that is not nested in any loop:\n+  \/\/ while(condition) { break; } infinite_loop;\n+  \/\/ Thus, we can understand lp as an outermost loop, and can terminate and\n+  \/\/ conclude: this block is in no irreducible loop.\n+  return false;\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":92,"deletions":11,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -1067,0 +1067,6 @@\n+#ifdef ASSERT\n+  \/\/ verify that regions in irreducible loops are marked is_in_irreducible_loop\n+  void verify_regions_in_irreducible_loops();\n+  bool is_in_irreducible_loop(RegionNode* region);\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -190,0 +190,2 @@\n+      } else if (proj_in->is_top()) {\n+        break; \/\/ dead code\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -225,0 +225,23 @@\n+    bool is_in_irreducible_loop() const {\n+      return flow()->is_in_irreducible_loop();\n+    }\n+    bool is_irreducible_loop_entry() const {\n+      return flow()->is_irreducible_loop_head() || flow()->is_irreducible_loop_secondary_entry();\n+    }\n+    void copy_irreducible_status_to(RegionNode* region, const JVMState* jvms) {\n+      assert(!is_irreducible_loop_entry() || is_in_irreducible_loop(), \"entry is part of irreducible loop\");\n+      if (is_in_irreducible_loop()) {\n+        \/\/ The block is in an irreducible loop of this method, so it is possible that this\n+        \/\/ region becomes an irreducible loop entry. (no guarantee)\n+        region->set_loop_status(RegionNode::LoopStatus::MaybeIrreducibleEntry);\n+      } else if (jvms->caller() != nullptr) {\n+        \/\/ The block is not in an irreducible loop of this method, hence it cannot ever\n+        \/\/ be the entry of an irreducible loop. But it may be inside an irreducible loop\n+        \/\/ of a caller of this inlined method. (limited guarantee)\n+        assert(region->loop_status() == RegionNode::LoopStatus::NeverIrreducibleEntry, \"status not changed\");\n+      } else {\n+        \/\/ The block is not in an irreducible loop of this method, and there is no outer\n+        \/\/ method. This region will never be in an irreducible loop (strong guarantee)\n+        region->set_loop_status(RegionNode::LoopStatus::Reducible);\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -682,0 +682,1 @@\n+          block->copy_irreducible_status_to(r, jvms());\n@@ -1503,1 +1504,6 @@\n-    if (b->is_loop_head()) tty->print(\"  lphd\");\n+    if (b->is_loop_head()) {\n+      tty->print(\"  lphd\");\n+    }\n+    if (b->is_irreducible_loop_entry()) {\n+      tty->print(\"  irreducible\");\n+    }\n@@ -1692,0 +1698,1 @@\n+      target->copy_irreducible_status_to(r, jvms());\n@@ -1729,1 +1736,1 @@\n-      if (!block()->flow()->is_irreducible_entry()) {\n+      if (!block()->flow()->is_irreducible_loop_secondary_entry()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -942,1 +942,1 @@\n-    if (!no_dead_loop) n->dump(3);\n+    if (!no_dead_loop) n->dump_bfs(100,0,\"#\");\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,1496 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class TestDeadIrreducibleLoops\n+{\n+    public Method \"<init>\":\"()V\"\n+    stack 2 locals 1\n+    {\n+        aload_0;\n+        invokespecial  Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    static Method test_001:\"(IIII)I\"\n+    stack 20 locals 20\n+    {\n+        \/\/ Irreducible loop with 3 Regions, 2 are entries, 1 is not entry\n+        iconst_0;\n+        istore 10;\n+\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, skip all code\n+\n+        iload_1;\n+        ifeq ENTRY1; \/\/ irreducible entry\n+        goto ENTRY2;\n+\n+    ENTRY1:\n+        \/\/ 43 Region - irreducible-entry\n+        iload 3;\n+        ifeq L1;\n+        iinc 10, 1;\n+    ENTRY2:\n+        \/\/ 44 Region - irreducible-entry\n+        iinc 10, 2;\n+    L1:\n+        \/\/ 60 Region - irreducible (but not entry)\n+        \/\/ can be loop-head, if build_loop_tree\n+        \/\/ first reaches ENTRY2\n+        iinc 10, 4;\n+        iload_2;\n+        ifeq ENTRY1; \/\/ loop-end\n+\n+    LEND:\n+        iload 10;\n+        ireturn;\n+    }\n+\n+    static Method test_002:\"(I)V\"\n+    stack 10 locals 10\n+    {\n+        \/\/ split_fall_in splits up an irreducible-entry Region\n+        iconst_0;\n+        istore     1;\n+        iload      0;\n+        ifle L2;\n+    L1:\n+        \/\/ bci:8\n+        \/\/ 30  Region (tagged irreducible at parsing)\n+        iload      0;\n+        ifne L3;\n+    L2:\n+        \/\/ bci:13\n+        \/\/ 29  Region (tagged irreducible at parsing)\n+        \/\/ 100 Region\n+        \/\/ 129 Region (produced in split_fall_in, must be tagged irreducible)\n+        \/\/ 134 Loop\n+        goto L1;\n+    L3:\n+        iload      1;\n+        ifgt L1;\n+        return;\n+    }\n+\n+    static Method test_003:\"(I)I\"\n+    stack 5 locals 25\n+    {\n+        \/\/ Cut off both entries to irreducible loop at the same time:\n+        \/\/ LOOP_y (empty_loop) collapses -> cut off both entries to irreducible LOOP_3\n+        \/\/ LOOP_3 should be removed during IGVN\n+        iconst_m1;\n+        istore           12;\n+        \n+        \/\/ empty loop, where var[20] counts to 0\n+        \/\/ and var[21] counts to 10001\n+        ldc              10001;\n+        istore           20;\n+        iconst_0;\n+        istore           21;\n+    LOOP_Y:\n+        iinc             20, -1;\n+        iinc             21, 1;\n+        iload            20;\n+        ifgt             LOOP_Y;\n+\n+        \/\/ once the empty_loop above collapses, we see this is true\n+        iload            21;\n+        ldc              10001;\n+        if_icmpeq        LEND;\n+\n+        iload_0;\n+        ldc              1;\n+        iand;\n+        ifeq             LOOP_3c; \/\/ second entry\n+\n+        \/\/ first entry\n+    LOOP_3a:\n+        iinc             12, 11;\n+        iload            12;\n+        ifge             LOOP_3c; \/\/ skip\n+    LOOP_3b:\n+        iinc             12, 7;\n+    LOOP_3c:\n+        iinc             12, 3;\n+        iload            12;\n+        ldc              1001;\n+        if_icmpne        LOOP_3a; \/\/ loop\n+    LEND:\n+        iload            12;\n+        ireturn;\n+    }\n+\n+    static Method test_004:\"(Ljava\/lang\/Object;)Ljava\/lang\/Object;\"\n+    stack 10 locals 10\n+    {\n+        \/\/ When we detect irreducible loops, we add more Phi nodes\n+        \/\/ This test generates dead code, where we create a dead-loop\n+        \/\/ of Phi nodes. Phi nodes are considered dead-loop safe,\n+        \/\/ so they should be handled gracefully.\n+        \/\/ This is a regression test for the faulty \"sanity\" assert\n+        \/\/ in PhiNode::merge_through_phi. Instead of asserting,\n+        \/\/ we now just abort the optimization.\n+        iconst_1;\n+        istore      5;\n+    LOOP:\n+        iconst_0;\n+        ifge        HEAD;\n+        goto        LOOP;\n+    HEAD:\n+        iload       5;\n+        ifge        LCMP;\n+        iload       5;\n+        iflt        L29;\n+    L30:\n+        iload       5;\n+        iflt        BOTTOM;\n+    L29:\n+        iload       5;\n+        ifeq        L30;\n+    BOTTOM:\n+        goto        HEAD;\n+    LCMP:\n+        aload_0;\n+        areturn;\n+    }\n+\n+    static Method test_005:\"(II)V\"\n+    stack 20 locals 20\n+    {\n+        \/\/ Triggers compile bailout: bad CFG: both infinite and irreducible\n+\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid infinte loop below\n+\n+        iconst_0;\n+        istore 10;\n+\n+        iload_1;\n+        ifeq ENTRY2;\n+\n+    ENTRY1:\n+        iinc 10, 1;\n+    ENTRY2:\n+        iinc 10, 2;\n+        goto ENTRY1; \/\/ backedge\n+        \n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_006:\"(I)I\"\n+    stack 5 locals 25\n+    {\n+        \/\/ check that disconnected irreducible loop collapses instantly\n+        \/\/ and does not create data dead-loop with iinc \/ AddI\n+        iconst_m1;\n+        istore           12;\n+\n+        \/\/ empty loop, where var[20] counts to 0\n+        \/\/ and var[21] counts to 10001\n+        ldc              10001;\n+        istore           20;\n+        iconst_0;\n+        istore           21;\n+    LOOP_Y:\n+        iinc             20, -1;\n+        iinc             21, 1;\n+        iload            20;\n+        ifgt             LOOP_Y;\n+\n+        \/\/ once the empty_loop above collapses, we see this is true\n+        iload            21;\n+        ldc              10001;\n+        if_icmpeq        LEND;\n+\n+        \/\/ second entry\n+        iload_0;\n+        ldc              1;\n+        iand;\n+        ifgt             LOOP_3d;\n+        \n+        \/\/ first entry\n+    LOOP_3a:\n+        iload            12;\n+        ifge             LOOP_3d;\n+    LOOP_3b:\n+        iload_0; \/\/ eventually, we get TOP and things die from the inside out\n+        ldc              2;\n+        if_icmplt        LOOP_3b;\n+        iinc             12, 1; \/\/ the problematic AddI\n+        goto             LOOP_3a;\n+    LOOP_3d:\n+        iload            12;\n+        ldc              1001;\n+        if_icmpne        LOOP_3a;\n+    LEND:\n+        iload_0;\n+        ireturn;\n+    }\n+\n+    static Method test_007:\"(III)V\"\n+    stack 20 locals 40\n+    {\n+        \/\/ Irreducible entry Regions lose all loop-internal control\n+        \/\/ Once empty_loop collapses, we never loop-back to\n+        \/\/ ENTRY1 nor ENTRY2. SKIP1 and SKIP2 become the new\n+        \/\/ irreducible loop entries.\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+        \/\/ empty loop, where var[20] counts to 0\n+        \/\/ and var[21] counts to 10001\n+        ldc              10001;\n+        istore           20;\n+        iconst_0;\n+        istore           21;\n+    EMPTY_LOOP:\n+        iinc             20, -1;\n+        iinc             21, 1;\n+        iload            20;\n+        ifgt             EMPTY_LOOP;\n+\n+        iconst_0;\n+        istore 30; \/\/ x = 0\n+\n+        iload_1;\n+        ifeq ENTRY1;\n+        goto ENTRY2; \/\/ the order here is arbitrary\n+\n+    ENTRY1:\n+        iinc 30, 1; \/\/ x += 1\n+\n+    SKIP1:\n+        ldc 10001;\n+        iload 21;\n+        if_icmpeq SKIP2; \/\/ always true after empty_loop collapses\n+\n+    ENTRY2:\n+        iinc 30, 32; \/\/ x += 2\n+\n+    SKIP2:\n+        iload_2;\n+        ifeq LEND; \/\/ loop-exit\n+\n+        ldc 10001;\n+        iload 21;\n+        if_icmpeq SKIP1; \/\/ always true after empty_loop collapses\n+\n+        goto ENTRY1; \/\/ backedge\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_008:\"(III)V\"\n+    stack 20 locals 20\n+    {\n+        \/\/ Same as test_008, but ENTRY1 and ENTRY2 already\n+        \/\/ lose internal loop control during parsing,\n+        \/\/ and SKIP1 and SKIP2 are new entry Regions.\n+\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, skip code below\n+\n+        iconst_0;\n+        istore 10; \/\/ x = 0\n+\n+        iload_1;\n+        ifeq ENTRY2;\n+        goto ENTRY1; \/\/ the order here is arbitrary\n+\n+    ENTRY1:\n+        iinc 10, 1; \/\/ x += 1\n+\n+    SKIP1:\n+        iconst_0;\n+        ifeq SKIP2; \/\/ always true\n+\n+    ENTRY2:\n+        iinc 10, 32; \/\/ x += 2\n+\n+    SKIP2:\n+        iload_2;\n+        ifeq LEND; \/\/ loop-exit\n+\n+        iconst_0;\n+        ifeq SKIP1; \/\/ always true\n+\n+        goto ENTRY1; \/\/ backedge\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_009:\"(IIIIIII)V\"\n+    stack 20 locals 40\n+    {\n+        \/\/ same as test_007, except extra ifs in ENTRY1 and ENTRY2\n+        \/\/ once ENTRY1 and ENTRY2 lose \"backedges\",\n+        \/\/ the ELSE1 and ELSE2 sections are no longer in the irreducible loop\n+        \/\/ and SKIP1 and SKIP2 become the new loop entries\n+        iload 0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+        \/\/ empty loop, where var[20] counts to 0\n+        \/\/ and var[21] counts to 10001\n+        ldc              10001;\n+        istore           20;\n+        iconst_0;\n+        istore           21;\n+    EMPTY_LOOP:\n+        iinc             20, -1;\n+        iinc             21, 1;\n+        iload            20;\n+        ifgt             EMPTY_LOOP;\n+\n+        iconst_0;\n+        istore 30; \/\/ x = 0\n+\n+        iload 1;\n+        ifeq ENTRY1;\n+        goto ENTRY2; \/\/ the order here is arbitrary\n+\n+    ENTRY1:\n+        iinc 30, 1; \/\/ x += 1\n+        iload 2;\n+        ifeq ELSE1;\n+\n+        iinc 30, 2; \/\/ x += 2\n+        iload 3;\n+        ifeq ELSE1;\n+\n+        iinc 30, 4; \/\/ x += 4\n+\n+    ELSE1:\n+        iinc 30, 8; \/\/ x += 8\n+\n+    SKIP1:\n+        ldc 10001;\n+        iload 21;\n+        if_icmpeq SKIP2; \/\/ always true after empty_loop collapses\n+\n+    ENTRY2:\n+        iinc 30, 16; \/\/ x += 16\n+        iload 4;\n+        ifeq ELSE2;\n+\n+        iinc 30, 32; \/\/ x += 32\n+        iload 5;\n+        ifeq ELSE2;\n+\n+        iinc 30, 64; \/\/ x += 64\n+\n+    ELSE2:\n+        iinc 30, 128; \/\/ x += 128\n+\n+    SKIP2:\n+        iload 6;\n+        ifeq LEND; \/\/ loop-exit\n+\n+        ldc 10001;\n+        iload 21;\n+        if_icmpeq SKIP1; \/\/ always true after empty_loop collapses\n+\n+        goto ENTRY1; \/\/ backedge\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_010:\"(IIIII)V\"\n+    stack 10 locals 5\n+    {\n+    \/\/ outer: irreducible, inner: reducible loop\n+    \/\/ ENTRY1 is loop-head for both\n+    \/\/ test that is_in_irreducible_loop walks up to outermost loop with that loop-head\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+        iload 4;\n+        ifeq SYMMETRY;\n+\n+        iload_1;\n+        ifeq ENTRY1;\n+        goto ENTRY2;\n+\n+    ENTRY1:\n+        \/\/ loop-head\n+        iload_2;\n+        ifeq ENTRY1; \/\/ backedge of reducible loop (inner)\n+    ENTRY2:\n+        \/\/ second-entry block\n+        iload_3;\n+        ifeq LEND;\n+        goto ENTRY1; \/\/ backedge of irreducible loop (outer)\n+\n+    SYMMETRY: \/\/ same as ENTRY1 \/ ENTRY2\n+        iload_1;\n+        ifeq ENTRY4; \/\/ but these are swapped\n+        goto ENTRY3;\n+\n+    ENTRY3:\n+        \/\/ loop-head\n+        iload_2;\n+        ifeq ENTRY3; \/\/ backedge of reducible loop (inner)\n+    ENTRY4:\n+        \/\/ second-entry block\n+        iload_3;\n+        ifeq LEND;\n+        goto ENTRY3; \/\/ backedge of irreducible loop (outer)\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_011:\"(IIIII)V\"\n+    stack 20 locals 20\n+    {\n+    \/\/ If we define irreducible-entry as the Block \/ Region\n+    \/\/ that is either the head of the (outermost) irreducible loop,\n+    \/\/ or the location where we found a secondary entry to the loop,\n+    \/\/ we find that this definition depends on the order of the\n+    \/\/ DF traversal.\n+    \/\/ (backtrack, edge 0 -> 29, normal forward edge)\n+    \/\/ \n+    \/\/ bci-order 1:\n+    \/\/ 0, 29, 4, 11, 24 (backedge to 11), 16, 21 (backedge to 11),\n+    \/\/ 8 (second entry to 16, make 11 irreducible loop head)\n+    \/\/ \n+    \/\/ bci-order 2:\n+    \/\/ 0, 4, 8, 16, 21, 11 (backedge to 16), 24 (backedge to 11), 29\n+    \/\/ (backtrack, find edge from 16 -> 24, second entry to 24,\n+    \/\/  16 is irreducible loop head)\n+    \/\/ (backtrack, find edge from 4 -> 11, second entry to 11,\n+    \/\/  16 is again irreducible loop head)\n+    \/\/ (backtrack, edge 0 -> 29, normal forward edge)\n+    \/\/ \n+    \/\/ Note: in order 2, bci:24 is a entry, but not for order 1.\n+    \/\/ This makes asserts that check the consistency of entries\n+    \/\/ difficult, if not impossible.\n+\n+    \/\/ bci: 0\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+    \/\/ bci: 4\n+        iload_1;\n+        ifeq ENTRY1;\n+    \/\/ bci: 8\n+        goto ENTRY2;\n+\n+    ENTRY1:\n+    \/\/ bci: 11\n+        iload            2;\n+        ifeq             BOTTOM;\n+    ENTRY2:\n+    \/\/ bci: 16\n+        iload            3;\n+        ifeq             BOTTOM;\n+    \/\/ bci: 21\n+        goto             ENTRY1;\n+\n+    BOTTOM:\n+    \/\/ bci: 24\n+        iload            4;\n+        ifeq             ENTRY1;\n+ \n+    LEND:\n+    \/\/ bci: 29\n+        return;\n+    }\n+\n+    static Method test_012a:\"(IIIIIIII)V\"\n+    stack 20 locals 20\n+    {\n+    \/\/ reducible loop inside irreducible loop\n+    \/\/ block numbers give order that leads to only\n+    \/\/ ENTRY1 and ENTRY2 being irreducible loop entries\n+\n+        \/\/ block 0\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+        \/\/ block 2\n+        iload_1;\n+        ifeq ENTRY1;\n+        \/\/ block 12\n+        goto ENTRY2;\n+\n+    ENTRY1:\n+        \/\/ block 3\n+        iload            2;\n+        ifeq             BOTTOM1;\n+        \/\/ block 8\n+        goto             ENTRY2;\n+    ENTRY2:\n+        \/\/ block 9\n+        iload            3;\n+        ifeq             BOTTOM1;\n+        \/\/ block 10\n+        iload            7;\n+        ifeq             LEND;\n+        \/\/ block 11\n+        goto             ENTRY1;\n+\n+    BOTTOM1:\n+        \/\/ region must be marked as irreducible\n+        \/\/ it is loop-head of irreducible loop, but also\n+        \/\/ itself in the irreducible loop that surrounds it\n+        \/\/ there is also a traversal that makes this a\n+        \/\/ irreducible loop entry:\n+        \/\/ 0, 2, 12, 9, 10, 11, 3, 8 (-> backedge to 9)\n+        \/\/ 4 (-> backedge to 3), 5, 7 (->backedge to 4),\n+        \/\/ 1, 6 (-> backedge to 5, -> backedge to 3) ... backtrack all the way to 9\n+        \/\/ -> irreducible entry edge to 4\n+        \/\/ Since this kind of block \/ region can be an irreducible loop\n+        \/\/ entry, we should mark the block \/ region as in the irreducible loop\n+        \/\/ this block is split\n+        \/\/ block 4 (in: 3 7 9, out: 5 3)\n+        \/\/ block 6 (in: 5, out: 5 3)\n+        iload            4;\n+        ifeq ENTRY1;\n+    BOTTOM2:\n+        \/\/ block 5\n+        iload            5;\n+        ifeq             BOTTOM1;\n+        \/\/ block 7\n+        iload            6;\n+        ifeq             BOTTOM1;\n+ \n+    LEND:\n+        \/\/ block 1\n+        return;\n+    }\n+\n+    static Method test_012b:\"(IIIII)V\"\n+    stack 20 locals 20\n+    {\n+    \/\/ reducible loop inside irreducible loop\n+    \/\/ this nested loop is an infinite loop (no exit)\n+\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+        iload_1;\n+        ifeq ENTRY1;\n+        goto ENTRY2;\n+\n+    ENTRY1:\n+        iload            2;\n+        ifeq             BOTTOM;\n+        goto             ENTRY2;\n+    ENTRY2:\n+        iload            3;\n+        ifeq             BOTTOM;\n+        goto             ENTRY1;\n+\n+    BOTTOM:\n+        \/\/ this must still be marked as in irreducible loop from above,\n+        \/\/ even though it is the head of a reducible loop\n+        iload            4;\n+        ifeq ENTRY1;\n+        goto BOTTOM; \/\/ reducible loop\n+ \n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_013:\"(IIIIIIIII)V\"\n+    stack 20 locals 40\n+    {\n+    \/\/ Irreducible loop ENTRY1 \/ ENTRY2, eventually collapses\n+    \/\/ Reducible loops LOOP1 \/ LOOP2 inside irreducible loop\n+    \/\/ Irreducible loop BOTTOM, with backedge to ENTRY1 (eventually collapses)\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+        \/\/ empty loop\n+        ldc              10001;\n+        istore           20;\n+        iconst_0;\n+        istore           21;\n+    EMPTY_LOOP:\n+        iinc             20, -1;\n+        iinc             21, 1;\n+        iload            21;\n+        ldc              10001;\n+        if_icmplt        EMPTY_LOOP;\n+        \/\/ var[20] == 0\n+\n+        iconst_1;\n+        istore           30; \/\/ for LOOP1, LOOP2\n+\n+        iload_1;\n+        ifeq ENTRY1;\n+        goto ENTRY2;\n+\n+    ENTRY1:\n+        iload            20;\n+        ifeq             LOOP1;\n+        goto             ENTRY2; \/\/ removed by empty_loop\n+    ENTRY2:\n+        iload            20;\n+        ifeq             LOOP2;\n+        goto             ENTRY1; \/\/ removed by empty_loop\n+\n+    LOOP1:\n+        iload            30;\n+        ldc              2;\n+        imul;\n+        istore           30;\n+        iload            30;\n+        ldc              10000;\n+        if_icmple        LOOP1;\n+        goto             BOTTOM1;\n+    LOOP2:\n+        iload            30;\n+        ldc              2;\n+        imul;\n+        istore           30;\n+        iload            30;\n+        ldc              10000;\n+        if_icmple        LOOP2;\n+        goto             BOTTOM2;\n+\n+    BOTTOM1:\n+        iload            3;\n+        ifeq             BOTTOM2;\n+        iload            4;\n+        ifeq             BOTTOM3;\n+        iload            20;\n+        ifne             ENTRY1; \/\/ removed by empty_loop\n+        goto LEND;\n+    BOTTOM2:\n+        iload            5;\n+        ifeq             BOTTOM3;\n+        iload            6;\n+        ifeq             BOTTOM1;\n+        goto LEND;\n+    BOTTOM3:\n+        iload            7;\n+        ifeq             BOTTOM1;\n+        iload            8;\n+        ifeq             BOTTOM2;\n+        goto LEND;\n+ \n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_014a:\"(III)V\"\n+    stack 20 locals 40\n+    {\n+    \/\/ Irreducible loop that becomes normal loop\n+    \/\/ and is then removed as empty loop (#2)\n+    \/\/ which finally takes out ENTRY3 \/ ENTRY4\n+    \/\/ \n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+        \/\/ empty_loop #1\n+        ldc              10001;\n+        istore           20;\n+        iconst_0;\n+        istore           21;\n+    EMPTY_LOOP:\n+        iinc             20, -1;\n+        iinc             21, 1;\n+        iload            21;\n+        ldc              10001;\n+        if_icmplt        EMPTY_LOOP;\n+        \/\/ var[20] == 0 \/\/ empty_loop (#1)\n+\n+        \/\/ variables for ENTRY1 \/ ENTRY2\n+        \/\/ when path to ENTRY2 collapses,\n+        \/\/ the loop becomes reducible and\n+        \/\/ can be removed as empty_loop (#2)\n+        iconst_0;\n+        istore           30;\n+        ldc              20002;\n+        istore           31;\n+\n+        iload            20;\n+        ifeq ENTRY1;\n+        goto ENTRY2; \/\/ removed by empty_loop (#1)\n+\n+    ENTRY1:\n+        iinc             30, 1;\n+    ENTRY2:\n+        iinc             31, -1;\n+        iload            30;\n+        ldc              20002;\n+        if_icmplt        ENTRY1;\n+        \/\/ var[31] == 0 \/\/ empty_loop (#2)\n+\n+        iload            31;\n+        ifeq             LEND; \/\/ always taken due to empty_loop (#2)\n+\n+        iload_1;\n+        ifeq ENTRY3;\n+        goto ENTRY4;\n+\n+        \/\/ irreducible loop at the end\n+        \/\/ expected to be removed after empty_loop (#2) collapses\n+    ENTRY3:\n+        iload_2;\n+        ifeq LEND;\n+    ENTRY4:\n+        goto ENTRY3;\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_014b:\"(III)V\"\n+    stack 200 locals 200\n+    {\n+    \/\/ Sequence of these loops:\n+    \/\/ Irreducible with 2 entries.\n+    \/\/ One entry collapses, turning the irreducible loop\n+    \/\/ into an empty_loop. This collapses one entry of\n+    \/\/ the next loop. This cascades until all loops are\n+    \/\/ removed.\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+        \/\/ setting up all variables for the loops below\n+        iconst_0;\n+        istore           100;\n+        ldc              10001;\n+        istore           101;\n+        iconst_0;\n+        istore           102;\n+        ldc              10001;\n+        istore           103;\n+        iconst_0;\n+        istore           104;\n+        ldc              10001;\n+        istore           105;\n+        iconst_0;\n+        istore           106;\n+        ldc              10001;\n+        istore           107;\n+        iconst_0;\n+        istore           108;\n+        ldc              10001;\n+        istore           109;\n+        iconst_0;\n+        istore           110;\n+        ldc              10001;\n+        istore           111;\n+        iconst_0;\n+        istore           112;\n+        ldc              10001;\n+        istore           113;\n+        iconst_0;\n+        istore           114;\n+        ldc              10001;\n+        istore           115;\n+\n+        iconst_0; \/\/ collapse during parsing\n+        ifeq ENTRY00;\n+        goto ENTRY01;\n+    ENTRY00:\n+        iinc             100, 1;\n+    ENTRY01:\n+        iinc             101, -1;\n+        iload            100;\n+        ldc              10001;\n+        if_icmplt        ENTRY00;\n+        \/\/ var[101] == 0 \/\/ empty_loop (#1)\n+\n+        iload            101; \/\/ from last empty_loop\n+        ifeq ENTRY02;\n+        goto ENTRY03;\n+    ENTRY02:\n+        iinc             102, 1;\n+    ENTRY03:\n+        iinc             103, -1;\n+        iload            102;\n+        ldc              10001;\n+        if_icmplt        ENTRY02;\n+        \/\/ var[103] == 0 \/\/ empty_loop (#2)\n+\n+        iload            103; \/\/ from last empty_loop\n+        ifeq ENTRY04;\n+        goto ENTRY05;\n+    ENTRY04:\n+        iinc             104, 1;\n+    ENTRY05:\n+        iinc             105, -1;\n+        iload            104;\n+        ldc              10001;\n+        if_icmplt        ENTRY04;\n+        \/\/ var[105] == 0 \/\/ empty_loop (#3)\n+\n+        iload            105; \/\/ from last empty_loop\n+        ifeq ENTRY06;\n+        goto ENTRY07;\n+    ENTRY06:\n+        iinc             106, 1;\n+    ENTRY07:\n+        iinc             107, -1;\n+        iload            106;\n+        ldc              10001;\n+        if_icmplt        ENTRY06;\n+        \/\/ var[107] == 0 \/\/ empty_loop (#4)\n+\n+        iload            107; \/\/ from last empty_loop\n+        ifeq ENTRY08;\n+        goto ENTRY09;\n+    ENTRY08:\n+        iinc             108, 1;\n+    ENTRY09:\n+        iinc             109, -1;\n+        iload            108;\n+        ldc              10001;\n+        if_icmplt        ENTRY08;\n+        \/\/ var[109] == 0 \/\/ empty_loop (#5)\n+\n+        iload            109; \/\/ from last empty_loop\n+        ifeq ENTRY10;\n+        goto ENTRY11;\n+    ENTRY10:\n+        iinc             110, 1;\n+    ENTRY11:\n+        iinc             111, -1;\n+        iload            110;\n+        ldc              10001;\n+        if_icmplt        ENTRY10;\n+        \/\/ var[111] == 0 \/\/ empty_loop (#6)\n+\n+        iload            111; \/\/ from last empty_loop\n+        ifeq ENTRY12;\n+        goto ENTRY13;\n+    ENTRY12:\n+        iinc             112, 1;\n+    ENTRY13:\n+        iinc             113, -1;\n+        iload            112;\n+        ldc              10001;\n+        if_icmplt        ENTRY12;\n+        \/\/ var[113] == 0 \/\/ empty_loop (#7)\n+\n+        iload            113; \/\/ from last empty_loop\n+        ifeq ENTRY14;\n+        goto ENTRY15;\n+    ENTRY14:\n+        iinc             114, 1;\n+    ENTRY15:\n+        iinc             115, -1;\n+        iload            114;\n+        ldc              10001;\n+        if_icmplt        ENTRY14;\n+        \/\/ var[115] == 0 \/\/ empty_loop (#8)\n+\n+        \/\/ final loop, removed after last empty_loop collapses\n+        iload            115;\n+        ifeq             LEND;\n+        iload_1;\n+        ifeq ENTRY3;\n+        goto ENTRY4;\n+    ENTRY3:\n+        iload_2;\n+        ifeq LEND;\n+    ENTRY4:\n+        goto ENTRY3;\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_015a:\"(I)I\"\n+    stack 20 locals 40\n+    {\n+    \/\/ Irreducible loop that loses second entry already during parsing\n+    \/\/ and later becomes counted loop\n+        iconst_0;\n+        istore           30;\n+        iconst_1;\n+        istore           31;\n+\n+        ldc              0;\n+        ifeq ENTRY1;\n+        goto ENTRY2; \/\/ removed during parsing\n+\n+    ENTRY1:\n+        iinc             30, 1; \/\/ trip count\n+    ENTRY2:\n+        iload            31;\n+        ldc              3; \/\/ compute pow(3,x)\n+        imul;\n+        istore           31;\n+        iload            30;\n+        iload            0;\n+        if_icmplt        ENTRY1;\n+\n+    LEND:\n+        iload            31;\n+        ireturn;\n+    }\n+\n+    static Method test_015b:\"(I)I\"\n+    stack 20 locals 40\n+    {\n+    \/\/ Similar as test_015a, but the irreducible loop only loses the\n+    \/\/ second entry during loop-opts (empty_loop), and the now\n+    \/\/ reducible loop does not become a CountedLoop any more.\n+        iconst_0;\n+        istore           30;\n+        iconst_1;\n+        istore           31;\n+\n+        \/\/ empty_loop\n+        ldc              10001;\n+        istore           20;\n+        iconst_0;\n+        istore           21;\n+    EMPTY_LOOP:\n+        iinc             20, -1;\n+        iinc             21, 1;\n+        iload            21;\n+        ldc              10001;\n+        if_icmplt        EMPTY_LOOP;\n+        \/\/ var[20] == 0 \/\/ empty_loop (#1)\n+\n+        iload            20;\n+        ifeq ENTRY1;\n+        goto ENTRY2; \/\/ removed by empty_loop\n+\n+    ENTRY1:\n+        iinc             30, 1; \/\/ trip count\n+    ENTRY2:\n+        iload            31;\n+        ldc              3; \/\/ compute pow(3,x)\n+        imul;\n+        istore           31;\n+        iload            30;\n+        iload            0;\n+        if_icmplt        ENTRY1;\n+\n+    LEND:\n+        iload            31;\n+        ireturn;\n+    }\n+\n+    static Method test_016:\"(III)V\"\n+    stack 200 locals 300\n+    {\n+    \/\/ Similar to test_014b.\n+    \/\/ Same sequence of irreducible loops collapsing to\n+    \/\/ empty_loops, collapsing and cascading to the next\n+    \/\/ loop.\n+    \/\/ In addition: each of the the loops in that sequence\n+    \/\/ controls an entry to a final big irreducible loop,\n+    \/\/ which slowly collapses, losing entry after entry.\n+        iload_0;\n+        ifeq LEND; \/\/ runtime check, avoid code below\n+\n+        \/\/ setting up all variables for the loops below\n+        iconst_0;\n+        istore           100;\n+        ldc              10001;\n+        istore           101;\n+        iconst_0;\n+        istore           102;\n+        ldc              10001;\n+        istore           103;\n+        iconst_0;\n+        istore           104;\n+        ldc              10001;\n+        istore           105;\n+        iconst_0;\n+        istore           106;\n+        ldc              10001;\n+        istore           107;\n+        iconst_0;\n+        istore           108;\n+        ldc              10001;\n+        istore           109;\n+        iconst_0;\n+        istore           110;\n+        ldc              10001;\n+        istore           111;\n+        iconst_0;\n+        istore           112;\n+        ldc              10001;\n+        istore           113;\n+        iconst_0;\n+        istore           114;\n+        ldc              10001;\n+        istore           115;\n+\n+        iconst_0; \/\/ collapse during parsing\n+        ifeq ENTRY00;\n+        goto ENTRY01;\n+    ENTRY00:\n+        iinc             100, 1;\n+    ENTRY01:\n+        iinc             101, -1;\n+        iload            100;\n+        ldc              10001;\n+        if_icmplt        ENTRY00;\n+        \/\/ var[101] == 0 \/\/ empty_loop (#1)\n+\n+        iload            101; \/\/ from last empty_loop\n+        ifeq ENTRY02;\n+        goto ENTRY03;\n+    ENTRY02:\n+        iinc             102, 1;\n+    ENTRY03:\n+        iinc             103, -1;\n+        iload            102;\n+        ldc              10001;\n+        if_icmplt        ENTRY02;\n+        \/\/ var[103] == 0 \/\/ empty_loop (#2)\n+\n+        iload            103; \/\/ from last empty_loop\n+        ifeq ENTRY04;\n+        goto ENTRY05;\n+    ENTRY04:\n+        iinc             104, 1;\n+    ENTRY05:\n+        iinc             105, -1;\n+        iload            104;\n+        ldc              10001;\n+        if_icmplt        ENTRY04;\n+        \/\/ var[105] == 0 \/\/ empty_loop (#3)\n+\n+        iload            105; \/\/ from last empty_loop\n+        ifeq ENTRY06;\n+        goto ENTRY07;\n+    ENTRY06:\n+        iinc             106, 1;\n+    ENTRY07:\n+        iinc             107, -1;\n+        iload            106;\n+        ldc              10001;\n+        if_icmplt        ENTRY06;\n+        \/\/ var[107] == 0 \/\/ empty_loop (#4)\n+\n+        iload            107; \/\/ from last empty_loop\n+        ifeq ENTRY08;\n+        goto ENTRY09;\n+    ENTRY08:\n+        iinc             108, 1;\n+    ENTRY09:\n+        iinc             109, -1;\n+        iload            108;\n+        ldc              10001;\n+        if_icmplt        ENTRY08;\n+        \/\/ var[109] == 0 \/\/ empty_loop (#5)\n+\n+        iload            109; \/\/ from last empty_loop\n+        ifeq ENTRY10;\n+        goto ENTRY11;\n+    ENTRY10:\n+        iinc             110, 1;\n+    ENTRY11:\n+        iinc             111, -1;\n+        iload            110;\n+        ldc              10001;\n+        if_icmplt        ENTRY10;\n+        \/\/ var[111] == 0 \/\/ empty_loop (#6)\n+\n+        iload            111; \/\/ from last empty_loop\n+        ifeq ENTRY12;\n+        goto ENTRY13;\n+    ENTRY12:\n+        iinc             112, 1;\n+    ENTRY13:\n+        iinc             113, -1;\n+        iload            112;\n+        ldc              10001;\n+        if_icmplt        ENTRY12;\n+        \/\/ var[113] == 0 \/\/ empty_loop (#7)\n+\n+        iload            113; \/\/ from last empty_loop\n+        ifeq ENTRY14;\n+        goto ENTRY15;\n+    ENTRY14:\n+        iinc             114, 1;\n+    ENTRY15:\n+        iinc             115, -1;\n+        iload            114;\n+        ldc              10001;\n+        if_icmplt        ENTRY14;\n+        \/\/ var[115] == 0 \/\/ empty_loop (#8)\n+\n+        \/\/ final loop, every empty_loop from above\n+        \/\/ controls one of the entries\n+        iconst_0;\n+        istore           200;\n+        iload            101;\n+        ifne             BOTTOM1;\n+        iload            103;\n+        ifne             BOTTOM2;\n+        iload            105;\n+        ifne             BOTTOM3;\n+        iload            107;\n+        ifne             BOTTOM4;\n+        iload            109;\n+        ifne             BOTTOM5;\n+        iload            111;\n+        ifne             BOTTOM6;\n+        iload            113;\n+        ifne             BOTTOM7;\n+        iload            115;\n+        ifeq             LEND;\n+        \/\/ finally cut off completely\n+        \/\/ trigger irreducible loop removal\n+        iload            1;\n+        ifeq             BOTTOM8;\n+        goto             BOTTOM0;\n+\n+    BOTTOM0:\n+        iinc             200, 1;\n+    BOTTOM1:\n+        iinc             200, 2;\n+    BOTTOM2:\n+        iinc             200, 4;\n+    BOTTOM3:\n+        iinc             200, 8;\n+    BOTTOM4:\n+        iinc             200, 16;\n+    BOTTOM5:\n+        iinc             200, 32;\n+    BOTTOM6:\n+        iinc             200, 64;\n+    BOTTOM7:\n+        iinc             200, 128;\n+    BOTTOM8:\n+        iload            200;\n+        ldc              30003;\n+        if_icmpgt        LEND;\n+        goto BOTTOM1;\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_017:\"(III)V\"\n+    stack 20 locals 20\n+    {\n+        \/\/ Triggers partial_peel and strip-mining for a loop\n+        \/\/ where the head was marked is_in_irreducible_loop\n+\n+        iload 2;\n+        ifeq  LEND; \/\/ skip code\n+\n+        iload      1;\n+        ifgt L2;\n+    L1:\n+        nop;\n+    L2:\n+        iinc       1, 1;\n+        iload      1;\n+        ifgt L1;\n+        iload      0;\n+        ifne LEND;\n+        goto L2;\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_018:\"(I)V\"\n+    stack 20 locals 20\n+    {\n+    \/\/ ciTypeFlow: infinite loop has no parent loop\n+        iload_0;\n+        ifeq LEND; \/\/ skip code\n+    LOOP:\n+        goto LOOP; \/\/ infinite loop\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_019:\"(IIII)V\"\n+    stack 20 locals 20\n+    {\n+    \/\/ may triggers split_flow_path, because of that aconst_null\n+\n+        iload_0;\n+        ifeq LEND; \/\/ skip code\n+\n+        aconst_null; \/\/ this has a strange side-effect\n+        goto LOOP3;\n+\n+    LOOP1:\n+        nop;\n+    LOOP2:\n+        iload      1;\n+        ifne LOOP1;\n+    LOOP3:\n+        iload      2;\n+        ifge LOOP2;\n+    LOOP4:\n+        iload      3;\n+        ifle LOOP1;\n+        iconst_m1;\n+        iflt LOOP2;\n+        goto LOOP4;\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_020:\"(IIIII)V\"\n+    stack 20 locals 40\n+    {\n+    \/\/ Get infinite loop at some point that has no NeverBranch node\n+        iload_0;\n+        ifeq LEND; \/\/ skip\n+\n+        iconst_0;\n+        istore     20;\n+    LOOP1:\n+        iload      1;\n+        ifeq LOOP3;\n+    LOOP2:\n+        iconst_0;\n+        ifne LEND;\n+    LOOP3:\n+        iload      20;\n+        istore     30; \/\/ old\n+        iload      2;\n+        iflt LOOP4;\n+        iconst_1;\n+        istore     20; \/\/ overwrite new\n+        iload      30;\n+        iload      3;\n+        if_icmpgt LOOP1;\n+        goto LOOP3;\n+    LOOP4:\n+        iload      4;\n+        iflt LOOP2;\n+        goto LOOP4;\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_021:\"(IIIIII)V\"\n+    stack 20 locals 20\n+    {\n+    \/\/ Produces a graph where one node is originally located inside\n+    \/\/ a reducible loop, but later that loop collapses, and exposes\n+    \/\/ the node to the outerloop, which is irreducible.\n+        iload_0;\n+        ifeq LEND; \/\/ skip\n+\n+    L1:\n+        iload      1;\n+        ifgt MERGE;\n+    L2:\n+        iload      2;\n+        ifge MERGE;\n+        goto L1;\n+\n+    MERGE:\n+        nop;\n+    LOOP:\n+        iload      3;\n+        ifle L2;\n+        iconst_0; \/\/ always true\n+        ifeq LOOP;\n+        iconst_0; \/\/ always true\n+        ifeq LOOP;\n+    INFTY:\n+        goto INFTY; \/\/ infinite loop\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_022a:\"(IIII)V\"\n+    stack 20 locals 10\n+    {\n+        \/\/ see test_022b for explanation\n+        iload_0;\n+        ifeq LEND;\n+\n+        aconst_null;\n+        astore     9;\n+        iconst_1;\n+        ifeq ENTRY1; \/\/ eventually collapses\n+        goto ENTRY2;\n+    ENTRY1:\n+        iconst_0;\n+        ifeq LOOP;\n+    ENTRY2:\n+        iload      1;\n+        ifge LOOP;\n+        goto ENTRY1;\n+\n+    LOOP:\n+        \/\/ head is split -> new irreducible loop\n+        aload      9;\n+        pop;\n+        iconst_0;\n+        iflt LOOP;\n+        aconst_null;\n+        astore     9;\n+        iload      2;\n+        ifeq LEND;\n+        goto LOOP;\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_022b:\"(II)V\"\n+    stack 20 locals 20\n+    {\n+    \/\/ Triggered split_flow_path for a reducible loop that had multiple fall-in\n+    \/\/ edges. The fall-in edges were split over two Phis\/Regions, creating a new\n+    \/\/ undetected irreducible loop. This only seems to happen when there are other\n+    \/\/ irreducible loops present, as it changes the merge-order during parsing.\n+    \/\/ If there are only reducible loops present, we merge the fall-in in a region\n+    \/\/ prior to the loop-head, as far as I understand.\n+        iload_0;\n+        ifeq LEND; \/\/ skip\n+\n+        aconst_null;\n+        astore     9;\n+        iload      1;\n+        ifeq OTHER;\n+    LOOP:\n+        iconst_0; \n+        iflt LEND; \/\/ false - old exit?\n+        aload      9;\n+        pop;\n+        iconst_0;\n+        ifne LOOP; \/\/ false\n+        goto LOOP;\n+ \n+    OTHER:\n+        iconst_m1;\n+        ifeq ENTRY1; \/\/ false\n+        goto ENTRY2; \n+    ENTRY1:\n+        iconst_0;\n+        ifeq LOOP; \/\/ true\n+    ENTRY2:\n+        goto ENTRY1;\n+\n+    LEND:\n+        return;\n+    }\n+\n+    static Method test_023:\"(I)V\"\n+    stack 20 locals 20\n+    {\n+        iload_0;\n+        ifeq LEND;\n+\n+        iconst_0;  \n+        istore     7;\n+        iconst_0;\n+        ifne L4;\n+    L2:\n+        nop;\n+    L4:\n+        iload      7;\n+        ifeq L12;\n+    L12:\n+        iconst_0;\n+        ifeq L2;\n+        goto L12;\n+\n+    LEND:\n+        return;\n+    }   \n+\n+    static Method test_024_inline:\"(I)I\"\n+    stack 20 locals 10\n+    {\n+        iload_0;\n+        ldc 3;\n+        irem;\n+        ifeq SKIP; \/\/ if (v % 3 == 0)\n+\n+        \/\/ (v % 5)\n+        iload_0;\n+        ldc 5;\n+        irem;\n+        istore_0;\n+        goto LEND;\n+\n+    SKIP:\n+        \/\/ (v % 7)\n+        iload_0;\n+        ldc 7;\n+        irem;\n+        istore_0;\n+        goto LEND;\n+\n+    LEND:\n+        iload_0;\n+        ireturn;\n+    }\n+\n+    static Method test_024:\"()I\"\n+    stack 20 locals 10\n+    {\n+    \/\/ Outer loop, irreducible inside, and inline call\n+    \/\/ Test that regions in inline are also handled as\n+    \/\/ they are nested in the irreducible loop\n+        iconst_0;\n+        istore 1; \/\/ i = 0\n+        iconst_0;\n+        istore 3; \/\/ x = 0\n+\n+    LOOP:\n+        iconst_0;\n+        istore 2; \/\/ j = 0\n+        iload 1;\n+        ldc 2;\n+        irem;\n+        ifeq ENTRY1; \/\/ if (i % 2 == 0)\n+        goto ENTRY2;\n+\n+    ENTRY1:\n+        iinc 2, 1; \/\/ j++\n+    ENTRY2:\n+        iload 2;\n+        invokestatic Method test_024_inline:\"(I)I\";\n+        iload 3;\n+        iadd;\n+        istore 3;\n+        iload 2;\n+        ldc 1000;\n+        if_icmplt ENTRY1; \/\/ while (j < 1000)\n+\n+        iinc 1, 1; \/\/ i++\n+        iload 1;\n+        ldc 10000;\n+        if_icmplt LOOP; \/\/ while (i < 10000)\n+\n+    LEND:\n+        iload 3;\n+        ireturn;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestDeadIrreducibleLoops.jasm","additions":1496,"deletions":0,"binary":false,"changes":1496,"status":"added"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8280126\n+ * @compile TestDeadIrreducibleLoops.jasm\n+ * @summary Irreducible loops have many entries, only when the last entry loses\n+ *          control from the outside does the loop die, and have to disappear.\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,TestDeadIrreducibleLoopsMain::test*\n+ *      -XX:CompileCommand=compileonly,TestDeadIrreducibleLoops::test*\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN\n+ *      TestDeadIrreducibleLoopsMain\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8280126\n+ * @compile TestDeadIrreducibleLoops.jasm\n+ * @summary Irreducible loops have many entries, only when the last entry loses\n+ *          control from the outside does the loop die, and have to disappear.\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,TestDeadIrreducibleLoopsMain::test*\n+ *      -XX:CompileCommand=compileonly,TestDeadIrreducibleLoops::test*\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN\n+ *      -XX:PerMethodTrapLimit=0\n+ *      TestDeadIrreducibleLoopsMain\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8280126\n+ * @compile TestDeadIrreducibleLoops.jasm\n+ * @summary Irreducible loops have many entries, only when the last entry loses\n+ *          control from the outside does the loop die, and have to disappear.\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,TestDeadIrreducibleLoopsMain::test*\n+ *      -XX:CompileCommand=compileonly,TestDeadIrreducibleLoops::test*\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN\n+ *      -Xcomp -XX:-TieredCompilation\n+ *      TestDeadIrreducibleLoopsMain\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8280126\n+ * @compile TestDeadIrreducibleLoops.jasm\n+ * @summary Irreducible loops have many entries, only when the last entry loses\n+ *          control from the outside does the loop die, and have to disappear.\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,TestDeadIrreducibleLoopsMain::test*\n+ *      -XX:CompileCommand=compileonly,TestDeadIrreducibleLoops::test*\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN\n+ *      -Xcomp -XX:-TieredCompilation\n+ *      -XX:PerMethodTrapLimit=0\n+ *      TestDeadIrreducibleLoopsMain\n+ *\/\n+\n+\/\/ Note: if this test fails intermittently, then use -XX:RepeatCompilation=1000\n+\/\/ The tests are run in no particular order. If an earlier test fails, a later one\n+\/\/ may fail too and be easier to debug.\n+\n+public class TestDeadIrreducibleLoopsMain {\n+   static public void main(String[] args) {\n+        TestDeadIrreducibleLoops t = new TestDeadIrreducibleLoops();\n+        test_000(false, false);\n+        t.test_001(0, 0, 0, 0);\n+        t.test_002(-1);\n+        t.test_003(255);\n+        t.test_004(\"I am an object\\n\");\n+        t.test_005(0, 0);\n+        t.test_006(0);\n+        t.test_007(0, 0, 0);\n+        t.test_008(0, 0, 0);\n+        t.test_009(0, 0, 0, 0, 0, 0, 0);\n+        t.test_010(0, 0, 0, 0, 0);\n+        t.test_011(0, 0, 0, 0, 0);\n+        t.test_012a(0, 0, 0, 0, 0, 0, 0, 0);\n+        t.test_012b(0, 0, 0, 0, 0);\n+        t.test_013(0, 0, 0, 0, 0, 0, 0, 0, 0);\n+        t.test_014a(0, 0, 0);\n+        t.test_014b(0, 0, 0);\n+        int x = t.test_015a(123);\n+        int y = t.test_015b(123);\n+        assert x == y: \"pow(3,x)\";\n+        t.test_016(0, 0, 0);\n+        t.test_017(0, 0, 0);\n+        t.test_018(0);\n+        t.test_019(0, 0, 0, 0);\n+        t.test_020(0, 0, 0, 0, 0);\n+        t.test_021(0, 0, 0, 0, 0, 0);\n+        t.test_022a(0, 0, 0, 0);\n+        t.test_022b(0, 0);\n+        t.test_023(0);\n+        t.test_024();\n+        test_025a(false);\n+        test_025b(false, false);\n+    }\n+\n+    public static float test_000(boolean flag1, boolean flag2) {\n+        float ret = 1.0f;\n+        int x = 0;\n+        LOOP1:\n+        for (int i = 1; i < 1000000; i *= 2) { \/\/ about 20 iterations\n+            if (i % 5 != 0) { \/\/ SKIP1\n+                LOOP2:\n+                for (int j = 1; j < 1000000; j *= 2) { \/\/ about 20 iterations\n+                    if (j % 5 != 0) { \/\/ SKIP2\n+                        if (x == 0) { \/\/ eventually always false -> continue statements float out of loop\n+                            ret *= 1.0001;\n+                            if (j > 100) {\n+                                LOOP3:\n+                                for (float m = 1.0f; m < 30000.0f; m *= 1.0001f) {\n+                                    \/\/ OSR starts here - should do more than 100k iterations\n+                                    ret *= 0.99999f;\n+                                }\n+                                x = 1;\n+                            }\n+                            int y = 77;\n+                            for (int e = 0; e < 77; e++) {\n+                                y -= x; \/\/ empty_loop, once we know that x == 1\n+                            }\n+                            if (y == 0) {\n+                                \/\/ always true after OSR -> cut off ENTRY1 and ENTRY2\n+                                return ret;\n+                            }\n+                            ret += 0.01;\n+                            if (ret > 20000) {\n+                                ret = 7.0f;\n+                                continue LOOP1; \/\/ ENTRY1\n+                            }\n+                            \/\/ back to LOOP2 -> ENTRY2\n+                        } \/\/ end if (x == 0)\n+                    } \/\/ end SKIP2\n+                } \/\/ end LOOP2\n+            } \/\/ end SKIP1\n+        } \/\/ end LOOP1\n+        return ret;\n+    }\n+\n+    static float test_025a(boolean flag) {\n+        \/\/ Based on test_000, but much simplified.\n+        \/\/ Irreducible loop with OSR. Inlining in irreducible loop.\n+        float ret = 3.0f;\n+        LOOP1:\n+        for (long i = 1; i < 1000_000_000_000L; i *= 2) {\n+            ret = test_025_inline(ret); \/\/ inline region\n+            LOOP2:\n+            for (long j = 1; j < 1000_000_000_000L; j *= 2) {\n+                for (int e = 0; e < 77; e++) {}\n+                if (flag) {\n+                    continue LOOP1; \/\/ ENTRY1\n+                }\n+                \/\/ back to LOOP2 -> ENTRY2\n+            } \/\/ end LOOP2\n+        } \/\/ end LOOP1\n+        return ret;\n+    }\n+\n+    static float test_025b(boolean flag1, boolean flag2) {\n+        \/\/ Based on test_000.\n+        \/\/ Irreducible loop with OSR. Inlining in irreducible loop.\n+        float ret = 1.0f;\n+        int x = 0;\n+        LOOP1:\n+        for (long i = 1; i < 1000_000_000_000L; i *= 2) {\n+            ret = test_025_inline(ret);\n+            if (i % 5 != 0) { \/\/ SKIP1\n+                LOOP2:\n+                for (long j = 1; j < 1000_000_000_000L; j *= 2) {\n+                    if (j % 5 != 0) { \/\/ SKIP2\n+                        if (x == 0) { \/\/ eventually always false -> continue statements float out of loop\n+                            ret *= 1.0001;\n+                            if (i > 1000_000_000L) {\n+                                LOOP3:\n+                                for (float m = 1.0f; m < 30000.0f; m *= 1.0001f) {\n+                                    \/\/ OSR starts here - should do more than 100k iterations\n+                                    ret *= 0.99999f;\n+                                }\n+                                x = 1;\n+                            }\n+                            int y = 77;\n+                            for (int e = 0; e < 77; e++) {\n+                                y -= x; \/\/ empty_loop, once we know that x == 1\n+                            }\n+                            if (y == 0) {\n+                                \/\/ always true after OSR -> cut off ENTRY1 and ENTRY2\n+                                return ret;\n+                            }\n+                            ret += 0.01;\n+                            if (ret > 20000) {\n+                                ret = 7.0f;\n+                                continue LOOP1; \/\/ ENTRY1\n+                            }\n+                            \/\/ back to LOOP2 -> ENTRY2\n+                        } \/\/ end if (x == 0)\n+                    } \/\/ end SKIP2\n+                } \/\/ end LOOP2\n+            } \/\/ end SKIP1\n+        } \/\/ end LOOP1\n+        return ret;\n+    }\n+\n+    static float test_025_inline(float x) {\n+        if (x >= 1.0f) {\n+          x *= 0.5f;\n+        } else {\n+          x *= 2.0f;\n+        }\n+        \/\/ Region to merge the if\n+        return x;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestDeadIrreducibleLoopsMain.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"}]}