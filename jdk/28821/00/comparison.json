{"files":[{"patch":"@@ -3846,0 +3846,2 @@\n+            \/\/ If the local class is defined inside a static method, and the instance creation expression\n+            \/\/ occurs in that same method, the creation occurs (technically) inside a static context, but that's ok.\n@@ -3850,0 +3852,2 @@\n+            } else if (isStatic(env1) || env1.enclClass.sym.isStatic()) {\n+                staticOnly = true;\n@@ -3851,1 +3855,0 @@\n-            if (isStatic(env1)) staticOnly = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8373570\n+ * @summary Javac stack overflow on method-local class with nested record referring to enclosing type\n+ * @compile\/fail\/ref=NewLocalNotInInner.out -XDrawDiagnostics NewLocalNotInInner.java\n+ *\/\n+class NewLocalNotInInner {\n+    void m() {\n+        class Local {\n+            static class Foo {\n+                void m() {\n+                    new Local(); \/\/ error\n+                }\n+            }\n+        }\n+    }\n+\n+    void m_anon() {\n+        class Local {\n+            static class Foo {\n+                void m() {\n+                    new Local() { }; \/\/ error\n+                }\n+            }\n+        }\n+    }\n+\n+    void m_record() {\n+        class Local {\n+            record Foo() {\n+                void m() {\n+                    new Local(); \/\/ error\n+                }\n+            }\n+        }\n+    }\n+\n+    void m_intf() {\n+        class Local {\n+            interface Foo {\n+                default void m() {\n+                    new Local(); \/\/ error\n+                }\n+            }\n+        }\n+    }\n+\n+    void sup() {\n+        class Local {\n+            static class Foo {\n+                void m() {\n+                    class Sub extends Local { }; \/\/ error\n+                    new Sub();\n+                }\n+            }\n+        }\n+    }\n+\n+    static void staticLocal() {\n+        class Local { }\n+        new Local(); \/\/ ok\n+    }\n+\n+    static void staticLocalFromAnon() {\n+        class Local { }\n+        new Object() {\n+            Local local() {\n+                return new Local(); \/\/ ok\n+            }\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/NewLocalNotInInner.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+NewLocalNotInInner.java:12:21: compiler.err.local.cant.be.inst.static: kindname.class, Local\n+NewLocalNotInInner.java:22:21: compiler.err.local.cant.be.inst.static: kindname.class, Local\n+NewLocalNotInInner.java:32:21: compiler.err.local.cant.be.inst.static: kindname.class, Local\n+NewLocalNotInInner.java:42:21: compiler.err.local.cant.be.inst.static: kindname.class, Local\n+NewLocalNotInInner.java:52:21: compiler.err.local.cant.be.inst.static: kindname.class, Local\n+5 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/NewLocalNotInInner.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"}]}