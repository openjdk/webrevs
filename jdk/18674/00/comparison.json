{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -590,1 +590,2 @@\n-    INSTANT_SECONDS(\"InstantSeconds\", SECONDS, FOREVER, ValueRange.of(Long.MIN_VALUE, Long.MAX_VALUE)),\n+    \/\/ ValueRange matches the min and max epoch second supported by java.time.Instant\n+    INSTANT_SECONDS(\"InstantSeconds\", SECONDS, FOREVER, ValueRange.of(-31557014167219200L, 31556889864403199L)),\n","filename":"src\/java.base\/share\/classes\/java\/time\/temporal\/ChronoField.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,0 +100,1 @@\n+import java.time.Instant;\n@@ -266,0 +267,10 @@\n+\n+    \/\/ verify the minimum and maximum values of ChronoField.INSTANT_SECONDS\n+    \/\/ matches the minimum and maximum supported epoch second by Instant.\n+    @Test\n+    public void testMinMaxInstantSeconds() {\n+        assertEquals(ChronoField.INSTANT_SECONDS.range().getMinimum(),\n+                Instant.MIN.getLong(ChronoField.INSTANT_SECONDS));\n+        assertEquals(ChronoField.INSTANT_SECONDS.range().getMaximum(),\n+                Instant.MAX.getLong(ChronoField.INSTANT_SECONDS));\n+    }\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/temporal\/TCKChronoField.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"}]}