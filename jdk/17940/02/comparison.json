{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,0 +93,3 @@\n+     * @deprecated It is recommended that the SSL parameters be configured and\n+     * read through the use of {@link SSLParameters}.\n+     *\n@@ -95,0 +98,2 @@\n+     *\n+     * @see #setSSLParameters(SSLParameters)\n@@ -96,0 +101,1 @@\n+    @Deprecated(since = \"23\")\n@@ -103,0 +109,4 @@\n+     * @deprecated It is recommended that the SSL parameters be configured and\n+     * read through the use of {@link SSLParameters}. Use\n+     * {@link SSLParameters#setCipherSuites(String[])} instead.\n+     *\n@@ -104,0 +114,2 @@\n+     *\n+     * @see #setSSLParameters(SSLParameters)\n@@ -105,0 +117,1 @@\n+    @Deprecated(since = \"23\")\n@@ -113,0 +126,3 @@\n+     * @deprecated It is recommended that the SSL parameters be configured and\n+     * read through the use of {@link SSLParameters}.\n+     *\n@@ -115,0 +131,2 @@\n+     *\n+     * @see #setSSLParameters(SSLParameters)\n@@ -116,0 +134,1 @@\n+    @Deprecated(since = \"23\")\n@@ -123,0 +142,4 @@\n+     * @deprecated It is recommended that the SSL parameters be configured and\n+     * read through the use of {@link SSLParameters}. Use\n+     * {@link SSLParameters#setProtocols(String[])} instead.\n+     *\n@@ -124,0 +147,2 @@\n+     *\n+     * @see #setSSLParameters(SSLParameters)\n@@ -125,0 +150,1 @@\n+    @Deprecated(since = \"23\")\n@@ -132,0 +158,3 @@\n+     * @deprecated It is recommended that the SSL parameters be configured and\n+     * read through the use of {@link SSLParameters}.\n+     *\n@@ -133,0 +162,2 @@\n+     *\n+     * @see #setSSLParameters(SSLParameters)\n@@ -134,0 +165,1 @@\n+    @Deprecated(since = \"23\")\n@@ -142,0 +174,4 @@\n+     * @deprecated It is recommended that the SSL parameters be configured and\n+     * read through the use of {@link SSLParameters}. Use\n+     * {@link SSLParameters#setWantClientAuth(boolean)} instead.\n+     *\n@@ -143,0 +179,2 @@\n+     *\n+     * @see #setSSLParameters(SSLParameters)\n@@ -144,0 +182,1 @@\n+    @Deprecated(since = \"23\")\n@@ -146,0 +185,1 @@\n+        this.needClientAuth = false;\n@@ -151,0 +191,3 @@\n+     * @deprecated It is recommended that the SSL parameters be configured and\n+     * read through the use of {@link SSLParameters}.\n+     *\n@@ -152,0 +195,2 @@\n+     *\n+     * @see #setSSLParameters(SSLParameters)\n@@ -153,0 +198,1 @@\n+    @Deprecated(since = \"23\")\n@@ -161,0 +207,4 @@\n+     * @deprecated It is recommended that the SSL parameters be configured and\n+     * read through the use of {@link SSLParameters}. Use\n+     * {@link SSLParameters#setNeedClientAuth(boolean)} instead.\n+     *\n@@ -162,0 +212,2 @@\n+     *\n+     * @see #setSSLParameters(SSLParameters)\n@@ -163,0 +215,1 @@\n+    @Deprecated(since = \"23\")\n@@ -165,0 +218,1 @@\n+        this.wantClientAuth = false;\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/HttpsParameters.java","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,0 +69,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -88,2 +89,5 @@\n-                engine.setNeedClientAuth (params.getNeedClientAuth());\n-                engine.setWantClientAuth (params.getWantClientAuth());\n+                if (params.getNeedClientAuth()) {\n+                    engine.setNeedClientAuth(true);\n+                } else if (params.getWantClientAuth()) {\n+                    engine.setWantClientAuth(true);\n+                }\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/SSLStreams.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,374 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsParameters;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n+ * @test\n+ * @bug 8326381\n+ * @summary verifies that the setNeedClientAuth() and setWantClientAuth()\n+ *          methods on HttpsParameters class work as expected\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext jdk.test.lib.net.URIBuilder\n+ * @run junit HttpsParametersClientAuthTest\n+ *\/\n+public class HttpsParametersClientAuthTest {\n+\n+    private static final AtomicInteger TID = new AtomicInteger();\n+    private static final ThreadFactory SRV_THREAD_FACTORY = (r) -> {\n+        final Thread t = new Thread(r);\n+        t.setDaemon(true);\n+        t.setName(\"server-thread-\" + TID.incrementAndGet());\n+        return t;\n+    };\n+\n+    \/**\n+     * verifies default values of {@link HttpsParameters#setNeedClientAuth(boolean)}\n+     * and {@link HttpsParameters#setWantClientAuth(boolean)} methods\n+     *\/\n+    @Test\n+    public void testDefaultClientAuth() throws Exception {\n+        \/\/ test default values\n+        HttpsParameters defaultParams = new Params();\n+        assertFalse(defaultParams.getNeedClientAuth(),\n+                \"needClientAuth was expected to be false but wasn't\");\n+        assertFalse(defaultParams.getWantClientAuth(),\n+                \"wantClientAuth was expected to be false but wasn't\");\n+    }\n+\n+    \/**\n+     * sets {@link HttpsParameters#setNeedClientAuth(boolean)} to true and verifies\n+     * that subsequent calls to {@link HttpsParameters#getNeedClientAuth()} returns\n+     * true and {@link HttpsParameters#getWantClientAuth()} returns false\n+     *\/\n+    @Test\n+    public void testNeedClientAuth() throws Exception {\n+        HttpsParameters needClientAuthParams = new Params();\n+        \/\/ first set wantClientAuth = true to verify that it later gets reset\n+        needClientAuthParams.setWantClientAuth(true);\n+        \/\/ needClientAuth = true and thus wantClientAuth = false\n+        needClientAuthParams.setNeedClientAuth(true);\n+        assertTrue(needClientAuthParams.getNeedClientAuth(),\n+                \"needClientAuth was expected to be true but wasn't\");\n+        assertFalse(needClientAuthParams.getWantClientAuth(),\n+                \"wantClientAuth was expected to be false but wasn't\");\n+    }\n+\n+    \/**\n+     * sets {@link HttpsParameters#setWantClientAuth(boolean)} to true and verifies\n+     * that subsequent calls to {@link HttpsParameters#getWantClientAuth()} returns\n+     * true and {@link HttpsParameters#getNeedClientAuth()} returns false\n+     *\/\n+    @Test\n+    public void testWantClientAuth() throws Exception {\n+        HttpsParameters wantClientAuthParams = new Params();\n+        \/\/ first set needClientAuth = true to verify that it later gets reset\n+        wantClientAuthParams.setNeedClientAuth(true);\n+        \/\/ wantClientAuth = true and thus needClientAuth = false\n+        wantClientAuthParams.setWantClientAuth(true);\n+        assertTrue(wantClientAuthParams.getWantClientAuth(),\n+                \"wantClientAuth was expected to be true but wasn't\");\n+        assertFalse(wantClientAuthParams.getNeedClientAuth(),\n+                \"needClientAuth was expected to be false but wasn't\");\n+    }\n+\n+    \/**\n+     * Starts a {@link HttpsServer} by\n+     * {@linkplain HttpsParameters#setNeedClientAuth(boolean) setting needClientAuth} as\n+     * {@code true}. The client is then configured either to present the client certificates\n+     * during the TLS handshake or configured not to present them. In the case where the\n+     * client presents the client certificates, the HTTP request issued by the client is\n+     * expected to pass. In the other case where the client doesn't present the certificates,\n+     * the test verifies that the HTTP request fails due to a connection error\n+     * (caused by TLS handshake failure)\n+     *\n+     * @param presentClientCerts true if the client should present certificates\n+     *                           during TLS handshake, false otherwise\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testServerNeedClientAuth(final boolean presentClientCerts) throws Exception {\n+        \/\/ SSLContext which contains both the key and the trust material and will be used\n+        \/\/ by the server\n+        final SSLContext serverSSLCtx = new SimpleSSLContext().get();\n+        assertNotNull(serverSSLCtx, \"could not create SSLContext\");\n+        final HttpsConfigurator configurator = new HttpsConfigurator(serverSSLCtx) {\n+            @Override\n+            public void configure(final HttpsParameters params) {\n+                \/\/ we intentionally don't call params.setSSLParameters()\n+                \/\/ and instead call params.setNeedClientAuth()\n+                params.setNeedClientAuth(true); \/\/ \"require\" the client to present certs\n+            }\n+        };\n+        try (final ExecutorService executor = Executors.newCachedThreadPool(SRV_THREAD_FACTORY)) {\n+            final HttpsServer server = createHttpsServer(executor, configurator);\n+            server.start();\n+            System.out.println(\"started server at \" + server.getAddress());\n+            try {\n+                final HttpClient.Builder builder = createClientBuilder();\n+                \/\/ if the client is expected to present client certificates, then\n+                \/\/ we construct a SSLContext which has both key and trust material.\n+                \/\/ otherwise we construct a SSLContext that only has trust material\n+                \/\/ and thus won't present certificates during TLS handshake\n+                final SSLContext clientSSLCtx = presentClientCerts\n+                        ? serverSSLCtx : onlyTrustStoreContext();\n+                \/\/ construct the client using the SSLContext\n+                try (final HttpClient client = builder.sslContext(clientSSLCtx)\n+                        .build()) {\n+                    \/\/ issue a request\n+                    final URI reqURI = URIBuilder.newBuilder()\n+                            .scheme(\"https\")\n+                            .host(server.getAddress().getAddress())\n+                            .port(server.getAddress().getPort())\n+                            .path(\"\/\")\n+                            .build();\n+                    System.out.println(\"issuing request to \" + reqURI);\n+                    final HttpResponse<Void> resp;\n+                    try {\n+                        resp = client.send(HttpRequest.newBuilder(reqURI).build(),\n+                                BodyHandlers.discarding());\n+                        if (!presentClientCerts) {\n+                            \/\/ request was expected to fail since the server was configured to force\n+                            \/\/ the client to present the client cert, but the client didn't\n+                            \/\/ present any\n+                            fail(\"request was expected to fail, but didn't\");\n+                        }\n+                        assertEquals(200, resp.statusCode(), \"unexpected response code\");\n+                    } catch (IOException ioe) {\n+                        if (presentClientCerts) {\n+                            \/\/ wasn't expected to fail, just let the exception propagate\n+                            throw ioe;\n+                        }\n+                        \/\/ verify it failed due to right reason\n+                        Throwable cause = ioe;\n+                        while (cause != null) {\n+                            \/\/ either of SocketException or SSLHandshakeException are OK\n+                            if (cause instanceof SocketException se) {\n+                                final String msg = se.getMessage();\n+                                assertTrue(msg != null && msg.contains(\"Connection reset\"),\n+                                        \"unexpected message in SocketException: \" + msg);\n+                                System.out.println(\"received the expected exception: \" + se);\n+                                break;\n+                            } else if (cause instanceof SSLHandshakeException she) {\n+                                final String msg = she.getMessage();\n+                                assertTrue(msg != null && msg.contains(\"bad_certificate\"),\n+                                        \"unexpected message in SSLHandshakeException: \" + msg);\n+                                System.out.println(\"received the expected exception: \" + she);\n+                                break;\n+                            }\n+                            cause = cause.getCause();\n+                        }\n+                        if (cause == null) {\n+                            \/\/ didn't find expected exception, rethrow original exception\n+                            throw ioe;\n+                        }\n+                    }\n+                }\n+            } finally {\n+                System.out.println(\"Stopping server at \" + server.getAddress());\n+                server.stop(0 \/* delay *\/);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Starts a {@link HttpsServer} by\n+     * {@linkplain HttpsParameters#setWantClientAuth(boolean) setting wantClientAuth} as\n+     * {@code true}. The client is then configured to either present the client certificates\n+     * during the TLS handshake or configured not to present them. In both these cases the\n+     * HTTP request issued by the client is expected to pass.\n+     *\n+     * @param presentClientCerts true if the client should present certificates\n+     *                           during TLS handshake, false otherwise\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testServerWantClientAuth(final boolean presentClientCerts) throws Exception {\n+        \/\/ SSLContext which contains both the key and the trust material and will be used\n+        \/\/ by the server\n+        final SSLContext serverSSLCtx = new SimpleSSLContext().get();\n+        assertNotNull(serverSSLCtx, \"could not create SSLContext\");\n+        final HttpsConfigurator configurator = new HttpsConfigurator(serverSSLCtx) {\n+            @Override\n+            public void configure(final HttpsParameters params) {\n+                \/\/ we intentionally don't call params.setSSLParameters()\n+                \/\/ and instead call params.setWantClientAuth()\n+                params.setWantClientAuth(true); \/\/ \"request\" the client to present certs\n+            }\n+        };\n+        try (final ExecutorService executor = Executors.newCachedThreadPool(SRV_THREAD_FACTORY)) {\n+            final HttpsServer server = createHttpsServer(executor, configurator);\n+            server.start();\n+            System.out.println(\"started server at \" + server.getAddress());\n+            try {\n+                final HttpClient.Builder builder = createClientBuilder();\n+                \/\/ if the client is expected to present client certificates, then\n+                \/\/ we construct a SSLContext which has both key and trust material.\n+                \/\/ otherwise we construct a SSLContext that only has trust material\n+                \/\/ and thus won't present certificates during TLS handshake\n+                final SSLContext clientSSLCtx = presentClientCerts\n+                        ? serverSSLCtx : onlyTrustStoreContext();\n+                \/\/ construct the client using the SSLContext\n+                try (final HttpClient client = builder.sslContext(clientSSLCtx)\n+                        .build()) {\n+                    \/\/ issue a request\n+                    final URI reqURI = URIBuilder.newBuilder()\n+                            .scheme(\"https\")\n+                            .host(server.getAddress().getAddress())\n+                            .port(server.getAddress().getPort())\n+                            .path(\"\/\")\n+                            .build();\n+                    System.out.println(\"issuing request to \" + reqURI);\n+                    final HttpResponse<Void> resp = client.send(\n+                            HttpRequest.newBuilder(reqURI).build(), BodyHandlers.discarding());\n+                    assertEquals(200, resp.statusCode(), \"unexpected response code\");\n+                }\n+            } finally {\n+                System.out.println(\"Stopping server at \" + server.getAddress());\n+                server.stop(0 \/* delay *\/);\n+            }\n+        }\n+    }\n+\n+    private static HttpsServer createHttpsServer(final Executor executor,\n+                                                 final HttpsConfigurator configurator)\n+            throws IOException {\n+        final InetAddress loopback = InetAddress.getLoopbackAddress();\n+        final HttpsServer server = HttpsServer.create(\n+                new InetSocketAddress(loopback, 0), 0 \/* backlog *\/);\n+        server.setExecutor(executor);\n+        server.setHttpsConfigurator(configurator);\n+        server.createContext(\"\/\", new AllOKHandler());\n+        return server;\n+    }\n+\n+    private static HttpClient.Builder createClientBuilder() {\n+        return HttpClient.newBuilder().version(HTTP_1_1)\n+                .proxy(NO_PROXY);\n+    }\n+\n+    \/**\n+     * Creates and returns a {@link SSLContext} which only has trust material\n+     * and doesn't have any test specific keys.\n+     *\/\n+    private static SSLContext onlyTrustStoreContext() throws IOException {\n+        final SimpleSSLContext trustStoreOnly = new SimpleSSLContext() {\n+            @Override\n+            protected SSLContext init(final InputStream i, final String protocol)\n+                    throws IOException {\n+                try {\n+                    final char[] passphrase = \"passphrase\".toCharArray();\n+                    final KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+                    ks.load(i, passphrase);\n+                    final TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n+                    tmf.init(ks);\n+                    final SSLContext ctx = SSLContext.getInstance(protocol);\n+                    \/\/ initialize with only trust managers\n+                    ctx.init(null, tmf.getTrustManagers(), null);\n+                    return ctx;\n+                } catch (KeyManagementException | KeyStoreException | CertificateException |\n+                         NoSuchAlgorithmException e) {\n+                    throw new IOException(e.getMessage());\n+                }\n+            }\n+        };\n+        final SSLContext ctx = trustStoreOnly.get();\n+        assertNotNull(ctx, \"could not create a SSLContext\");\n+        return ctx;\n+    }\n+\n+    \/\/ no-op implementations of the abstract methods of HttpsParameters\n+    private static final class Params extends HttpsParameters {\n+\n+        @Override\n+        public HttpsConfigurator getHttpsConfigurator() {\n+            \/\/ no-op\n+            return null;\n+        }\n+\n+        @Override\n+        public InetSocketAddress getClientAddress() {\n+            \/\/ no-op\n+            return null;\n+        }\n+\n+        @Override\n+        public void setSSLParameters(SSLParameters params) {\n+            \/\/ no-op\n+        }\n+    }\n+\n+    \/\/ A HttpHandler which just returns 200 response code\n+    private static final class AllOKHandler implements HttpHandler {\n+\n+        private static final int NO_RESPONSE_BODY = -1;\n+\n+        @Override\n+        public void handle(final HttpExchange exchange) throws IOException {\n+            System.out.println(\"responding to request: \" + exchange.getRequestURI());\n+            exchange.sendResponseHeaders(200, NO_RESPONSE_BODY);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/HttpsParametersClientAuthTest.java","additions":374,"deletions":0,"binary":false,"changes":374,"status":"added"},{"patch":"@@ -73,1 +73,1 @@\n-                                    init(fis, proto);\n+                                    ssl = init(fis, proto);\n@@ -107,1 +107,1 @@\n-            init(fis, \"TLS\");\n+            ssl = init(fis, \"TLS\");\n@@ -111,1 +111,5 @@\n-    private void init(InputStream i, String protocol) throws IOException {\n+    protected SSLContext init(InputStream i, String protocol) throws IOException {\n+        return doInit(i, protocol);\n+    }\n+\n+    private static SSLContext doInit(InputStream i, String protocol) throws IOException {\n@@ -123,2 +127,3 @@\n-            ssl = SSLContext.getInstance(protocol);\n-            ssl.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+            SSLContext ctx = SSLContext.getInstance(protocol);\n+            ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+            return ctx;\n","filename":"test\/lib\/jdk\/test\/lib\/net\/SimpleSSLContext.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"}]}