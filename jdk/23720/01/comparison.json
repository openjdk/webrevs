{"files":[{"patch":"@@ -45,0 +45,11 @@\n+  ifeq ($$($1_Type), Boolean)\n+    $1_type := boolean\n+    $1_BoxType := $$($1_Type)\n+\n+    $1_rawType := $$($1_type)\n+    $1_RawType := $$($1_Type)\n+    $1_RawBoxType := $$($1_BoxType)\n+\n+    $1_ARGS += -KCAS\n+  endif\n+\n@@ -53,0 +64,1 @@\n+    $1_ARGS += -KCAS\n@@ -63,0 +75,2 @@\n+\n+    $1_ARGS += -KCAS\n@@ -73,0 +87,2 @@\n+\n+    $1_ARGS += -KCAS\n@@ -85,2 +101,0 @@\n-    $1_ARGS += -KAtomicAdd\n-    $1_ARGS += -KBitwise\n@@ -99,2 +113,0 @@\n-    $1_ARGS += -KAtomicAdd\n-    $1_ARGS += -KBitwise\n@@ -136,1 +148,1 @@\n-  ifneq ($$(findstring $$($1_Type), Byte Short Char), )\n+  ifneq ($$(findstring $$($1_Type), Boolean Byte Short Char), )\n@@ -144,1 +156,1 @@\n-SCOPE_MEMORY_ACCESS_TYPES := Byte Short Char Int Long Float Double\n+SCOPE_MEMORY_ACCESS_TYPES := Boolean Byte Short Char Int Long Float Double\n","filename":"make\/modules\/java.base\/gensrc\/GensrcScopedMemoryAccess.gmk","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -171,0 +171,2 @@\n+# TODO decide if CAS\/Bitwise\/AtomicAdd should be enabled for subints\n+# Remove comments # before $1_ARGS += below to enable them\n@@ -177,0 +179,14 @@\n+  ifeq ($$($1_Type), Boolean)\n+    $1_type := boolean\n+    $1_BoxType := $$($1_Type)\n+\n+    $1_rawType := $$($1_type)\n+    $1_RawType := $$($1_Type)\n+    $1_RawBoxType := $$($1_BoxType)\n+\n+    $1_ARGS += -Kbyte\n+    # $1_ARGS += -KCAS\n+    # $1_ARGS += -KBitwise\n+    $1_ARGS += -KShorterThanInt\n+  endif\n+\n@@ -186,0 +202,4 @@\n+    # $1_ARGS += -KCAS\n+    # $1_ARGS += -KAtomicAdd\n+    # $1_ARGS += -KBitwise\n+    $1_ARGS += -KShorterThanInt\n@@ -195,0 +215,5 @@\n+\n+    # $1_ARGS += -KCAS\n+    # $1_ARGS += -KAtomicAdd\n+    # $1_ARGS += -KBitwise\n+    $1_ARGS += -KShorterThanInt\n@@ -204,0 +229,5 @@\n+\n+    # $1_ARGS += -KCAS\n+    # $1_ARGS += -KAtomicAdd\n+    # $1_ARGS += -KBitwise\n+    $1_ARGS += -KShorterThanInt\n@@ -280,1 +310,1 @@\n-VARHANDLES_MEMORY_SEGMENT_TYPES := Byte Short Char Int Long Float Double\n+VARHANDLES_MEMORY_SEGMENT_TYPES := Boolean Byte Short Char Int Long Float Double\n","filename":"make\/modules\/java.base\/gensrc\/GensrcVarHandles.gmk","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -1555,2 +1556,2 @@\n-            public VarHandle memorySegmentViewHandle(Class<?> carrier, long alignmentMask, ByteOrder order) {\n-                return VarHandles.memorySegmentViewHandle(carrier, alignmentMask, order);\n+            public VarHandle memorySegmentViewHandle(Class<?> carrier, MemoryLayout enclosing, long alignmentMask, ByteOrder order, boolean noStride, long offset) {\n+                return VarHandles.memorySegmentViewHandle(carrier, enclosing, alignmentMask, noStride, offset, order);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.invoke;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.util.Objects;\n+\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * A var handle that accesses primitive values in a memory segment.\n+ *\/\n+final class SegmentVarHandle extends VarHandle {\n+\n+    \/\/ Common implementation fields for the VarForms\n+    static final boolean BE = MethodHandleStatics.UNSAFE.isBigEndian();\n+    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n+    \/** endianness **\/\n+    final boolean be;\n+    \/** The layout the accessed segment must be compatible with. *\/\n+    final MemoryLayout enclosing;\n+    \/** The fixed offset value, if exists. vform decides if the fixed offset is used. *\/\n+    final long offset;\n+\n+    SegmentVarHandle(VarForm form, boolean be, MemoryLayout enclosing, long offset, boolean exact) {\n+        super(form, exact);\n+        this.be = be;\n+        this.enclosing = enclosing;\n+        this.offset = offset;\n+    }\n+\n+    @Override\n+    final MethodType accessModeTypeUncached(VarHandle.AccessType accessType) {\n+        var getType = vform.methodType_table[0]; \/\/ erased, but our value type is erase-compatible\n+        return getType.parameterCount() == 2\n+                ? accessType.accessModeType(MemorySegment.class, getType.returnType(), long.class)\n+                : accessType.accessModeType(MemorySegment.class, getType.returnType(), long.class, long.class);\n+    }\n+\n+    @Override\n+    public SegmentVarHandle withInvokeExactBehavior() {\n+        return hasInvokeExactBehavior() ?\n+                this :\n+                new SegmentVarHandle(vform, be, enclosing, offset, true);\n+    }\n+\n+    @Override\n+    public SegmentVarHandle withInvokeBehavior() {\n+        return !hasInvokeExactBehavior() ?\n+                this :\n+                new SegmentVarHandle(vform, be, enclosing, offset, false);\n+    }\n+\n+    \/\/ Common implementation methods for the VarForms\n+\n+    @ForceInline\n+    static long offset(AbstractMemorySegmentImpl bb, long base, long offset) {\n+        long segment_base = bb.unsafeGetOffset();\n+        return segment_base + base + offset;\n+    }\n+\n+    @ForceInline\n+    AbstractMemorySegmentImpl checkSegment(Object obb, long base, boolean ro) {\n+        AbstractMemorySegmentImpl oo = (AbstractMemorySegmentImpl) Objects.requireNonNull(obb);\n+        oo.checkEnclosingLayout(base, this.enclosing, ro);\n+        return oo;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/SegmentVarHandle.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n@@ -46,0 +47,1 @@\n+    \/\/ implClass must be initialized when the member names are accessed!\n@@ -66,0 +68,9 @@\n+    VarForm(Class<?> implClass, VarForm methodTypeSource) {\n+        this.implClass = implClass;\n+        \/\/ reuse initMethodTypes result from methodTypeSource\n+        this.methodType_table = methodTypeSource.methodType_table;\n+        this.methodType_V_table = methodTypeSource.methodType_V_table;\n+        this.memberName_table = new MemberName[VarHandle.AccessMode.COUNT];\n+        assert assertMethodTypeTableInitialized() : implClass;\n+    }\n+\n@@ -106,0 +117,9 @@\n+    private boolean assertMethodTypeTableInitialized() {\n+        if (methodType_table == null)\n+            return false;\n+        for (int i = 0; i < VarHandle.AccessType.COUNT; i++) {\n+            assert methodType_table[i] != null : implClass + \" \" + VarHandle.AccessType.values()[i];\n+        }\n+        return true;\n+    }\n+\n@@ -140,0 +160,1 @@\n+        assert !UNSAFE.shouldBeInitialized(implClass) : implClass;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarForm.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -475,2 +475,1 @@\n-     permits IndirectVarHandle, LazyInitializingVarHandle,\n-             VarHandleSegmentViewBase,\n+     permits IndirectVarHandle, LazyInitializingVarHandle, SegmentVarHandle,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-    static final void guard_LL_V(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard_L_I(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -53,3 +53,1 @@\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            return (int) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n@@ -58,1 +56,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n@@ -65,1 +63,1 @@\n-    static final boolean guard_LLL_Z(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final long guard_L_J(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -68,1 +66,1 @@\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            return (long) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n@@ -71,1 +69,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n@@ -78,1 +76,1 @@\n-    static final Object guard_LLL_L(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_L_F(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -81,2 +79,1 @@\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n+            return (float) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n@@ -85,1 +82,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n@@ -92,1 +89,1 @@\n-    static final Object guard_LL_L(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_L_D(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -95,1 +92,14 @@\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            return (double) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final Object guard__L(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            Object r = MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n@@ -99,1 +109,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n@@ -106,1 +116,1 @@\n-    static final int guard_L_I(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard__I(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -109,1 +119,1 @@\n-            return (int) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+            return (int) MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n@@ -112,1 +122,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n@@ -119,1 +129,1 @@\n-    static final void guard_LI_V(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final long guard__J(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -122,3 +132,1 @@\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            return (long) MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n@@ -127,1 +135,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n@@ -134,1 +142,1 @@\n-    static final boolean guard_LII_Z(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard__F(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -137,1 +145,1 @@\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            return (float) MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n@@ -140,1 +148,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n@@ -147,1 +155,1 @@\n-    static final int guard_LII_I(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard__D(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -150,1 +158,1 @@\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            return (double) MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n@@ -153,1 +161,15 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final Object guard_LI_L(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            return ad.returnType.cast(r);\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -173,1 +195,1 @@\n-    static final long guard_L_J(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final long guard_LI_J(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -176,1 +198,1 @@\n-            return (long) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n@@ -179,1 +201,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -186,1 +208,1 @@\n-    static final void guard_LJ_V(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_LI_F(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -189,3 +211,1 @@\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n@@ -194,1 +214,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -201,1 +221,1 @@\n-    static final boolean guard_LJJ_Z(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_LI_D(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -204,1 +224,1 @@\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n@@ -207,1 +227,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -214,1 +234,1 @@\n-    static final long guard_LJJ_J(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final Object guard_LJ_L(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -217,1 +237,2 @@\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            return ad.returnType.cast(r);\n@@ -220,1 +241,14 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final int guard_LJ_I(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -240,1 +274,1 @@\n-    static final float guard_L_F(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_LJ_F(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -243,1 +277,1 @@\n-            return (float) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n@@ -246,1 +280,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -253,1 +287,1 @@\n-    static final void guard_LF_V(VarHandle handle, Object arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_LJ_D(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -256,3 +290,1 @@\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n@@ -261,1 +293,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -268,1 +300,1 @@\n-    static final boolean guard_LFF_Z(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final Object guard_LJJ_L(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -271,1 +303,2 @@\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            return ad.returnType.cast(r);\n@@ -274,1 +307,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -281,1 +314,27 @@\n-    static final float guard_LFF_F(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard_LJJ_I(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final long guard_LJJ_J(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final float guard_LJJ_F(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -294,1 +353,1 @@\n-    static final float guard_LF_F(VarHandle handle, Object arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_LJJ_D(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -297,1 +356,1 @@\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n@@ -300,1 +359,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -307,1 +366,1 @@\n-    static final double guard_L_D(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LL_V(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -310,1 +369,3 @@\n-            return (double) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n@@ -313,1 +374,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -320,1 +381,1 @@\n-    static final void guard_LD_V(VarHandle handle, Object arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LI_V(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -335,1 +396,1 @@\n-    static final boolean guard_LDD_Z(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LJ_V(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -338,1 +399,3 @@\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n@@ -341,1 +404,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -348,1 +411,1 @@\n-    static final double guard_LDD_D(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LF_V(VarHandle handle, Object arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -351,1 +414,3 @@\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n@@ -354,1 +419,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -361,1 +426,1 @@\n-    static final double guard_LD_D(VarHandle handle, Object arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LD_V(VarHandle handle, Object arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -364,1 +429,3 @@\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n@@ -367,1 +434,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -374,1 +441,1 @@\n-    static final Object guard__L(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_L_V(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -377,2 +444,3 @@\n-            Object r = MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n+            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n@@ -381,1 +449,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n@@ -388,1 +456,1 @@\n-    static final void guard_L_V(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_I_V(VarHandle handle, int arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -403,1 +471,1 @@\n-    static final boolean guard_LL_Z(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_J_V(VarHandle handle, long arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -406,1 +474,3 @@\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n@@ -409,1 +479,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n@@ -416,1 +486,1 @@\n-    static final int guard__I(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_F_V(VarHandle handle, float arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -419,1 +489,3 @@\n-            return (int) MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n+            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n@@ -422,1 +494,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n@@ -429,1 +501,1 @@\n-    static final void guard_I_V(VarHandle handle, int arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_D_V(VarHandle handle, double arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -444,1 +516,1 @@\n-    static final boolean guard_II_Z(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LIL_V(VarHandle handle, Object arg0, int arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -447,1 +519,3 @@\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n@@ -450,1 +524,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -457,1 +531,1 @@\n-    static final int guard_II_I(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LII_V(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -460,1 +534,3 @@\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n@@ -463,1 +539,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -470,1 +546,456 @@\n-    static final int guard_I_I(VarHandle handle, int arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final void guard_LIJ_V(VarHandle handle, Object arg0, int arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final void guard_LIF_V(VarHandle handle, Object arg0, int arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final void guard_LID_V(VarHandle handle, Object arg0, int arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final void guard_LJL_V(VarHandle handle, Object arg0, long arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final void guard_LJI_V(VarHandle handle, Object arg0, long arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final void guard_LJJ_V(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final void guard_LJF_V(VarHandle handle, Object arg0, long arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final void guard_LJD_V(VarHandle handle, Object arg0, long arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final void guard_LJJL_V(VarHandle handle, Object arg0, long arg1, long arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final void guard_LJJI_V(VarHandle handle, Object arg0, long arg1, long arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final void guard_LJJJ_V(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final void guard_LJJF_V(VarHandle handle, Object arg0, long arg1, long arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final void guard_LJJD_V(VarHandle handle, Object arg0, long arg1, long arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_LLL_Z(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_LII_Z(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_LJJ_Z(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_LFF_Z(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_LDD_Z(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_LL_Z(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_II_Z(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_JJ_Z(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_FF_Z(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_DD_Z(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_LILL_Z(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_LIII_Z(VarHandle handle, Object arg0, int arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_LIJJ_Z(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_LIFF_Z(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_LIDD_Z(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_LJLL_Z(VarHandle handle, Object arg0, long arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_LJII_Z(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_LJJJ_Z(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_LJFF_Z(VarHandle handle, Object arg0, long arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_LJDD_Z(VarHandle handle, Object arg0, long arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+        } else {\n+            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+        }\n+    }\n+\n+    @ForceInline\n+    @LambdaForm.Compiled\n+    @Hidden\n+    static final boolean guard_LJJLL_Z(VarHandle handle, Object arg0, long arg1, long arg2, Object arg3, Object arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -473,1 +1004,1 @@\n-            return (int) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n@@ -476,1 +1007,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n@@ -483,1 +1014,1 @@\n-    static final long guard__J(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_LJJII_Z(VarHandle handle, Object arg0, long arg1, long arg2, int arg3, int arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -486,1 +1017,1 @@\n-            return (long) MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n@@ -489,1 +1020,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n@@ -496,1 +1027,1 @@\n-    static final void guard_J_V(VarHandle handle, long arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_LJJJJ_Z(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, long arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -499,3 +1030,1 @@\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n@@ -504,1 +1033,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n@@ -511,1 +1040,1 @@\n-    static final boolean guard_JJ_Z(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_LJJFF_Z(VarHandle handle, Object arg0, long arg1, long arg2, float arg3, float arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -514,1 +1043,1 @@\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n@@ -517,1 +1046,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n@@ -524,1 +1053,1 @@\n-    static final long guard_JJ_J(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final boolean guard_LJJDD_Z(VarHandle handle, Object arg0, long arg1, long arg2, double arg3, double arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -527,1 +1056,1 @@\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n@@ -530,1 +1059,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n@@ -537,1 +1066,1 @@\n-    static final long guard_J_J(VarHandle handle, long arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final Object guard_LLL_L(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -540,1 +1069,2 @@\n-            return (long) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            return ad.returnType.cast(r);\n@@ -543,1 +1073,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -550,1 +1080,1 @@\n-    static final float guard__F(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard_LII_I(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -553,1 +1083,1 @@\n-            return (float) MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n+            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n@@ -556,1 +1086,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -563,1 +1093,1 @@\n-    static final void guard_F_V(VarHandle handle, float arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_LFF_F(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -566,3 +1096,1 @@\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n@@ -571,1 +1099,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -578,1 +1106,1 @@\n-    static final boolean guard_FF_Z(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_LDD_D(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -581,1 +1109,1 @@\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n@@ -584,1 +1112,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -591,1 +1119,1 @@\n-    static final float guard_FF_F(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final Object guard_LL_L(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -594,1 +1122,2 @@\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            return ad.returnType.cast(r);\n@@ -597,1 +1126,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -604,1 +1133,1 @@\n-    static final float guard_F_F(VarHandle handle, float arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard_II_I(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -607,1 +1136,1 @@\n-            return (float) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n@@ -610,1 +1139,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -617,1 +1146,1 @@\n-    static final double guard__D(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final long guard_JJ_J(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -620,1 +1149,1 @@\n-            return (double) MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n+            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n@@ -623,1 +1152,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -630,1 +1159,1 @@\n-    static final void guard_D_V(VarHandle handle, double arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_FF_F(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -633,3 +1162,1 @@\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n@@ -638,1 +1165,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -645,1 +1172,1 @@\n-    static final boolean guard_DD_Z(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_DD_D(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -648,1 +1175,1 @@\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n@@ -651,1 +1178,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -658,1 +1185,1 @@\n-    static final double guard_DD_D(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final Object guard_LILL_L(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -661,1 +1188,2 @@\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+            return ad.returnType.cast(r);\n@@ -664,1 +1192,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -671,1 +1199,1 @@\n-    static final double guard_D_D(VarHandle handle, double arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard_LIII_I(VarHandle handle, Object arg0, int arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -674,1 +1202,1 @@\n-            return (double) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n+            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n@@ -677,1 +1205,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -684,1 +1212,1 @@\n-    static final Object guard_LI_L(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final long guard_LIJJ_J(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -687,2 +1215,1 @@\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n+            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n@@ -691,1 +1218,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -698,1 +1225,1 @@\n-    static final void guard_LIL_V(VarHandle handle, Object arg0, int arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_LIFF_F(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -701,3 +1228,1 @@\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n@@ -706,1 +1231,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -713,1 +1238,1 @@\n-    static final boolean guard_LILL_Z(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_LIDD_D(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -716,1 +1241,1 @@\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n@@ -719,1 +1244,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -726,1 +1251,1 @@\n-    static final Object guard_LILL_L(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final Object guard_LJLL_L(VarHandle handle, Object arg0, long arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -740,1 +1265,1 @@\n-    static final Object guard_LIL_L(VarHandle handle, Object arg0, int arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard_LJII_I(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -743,2 +1268,1 @@\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n+            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n@@ -747,1 +1271,1 @@\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -754,1 +1278,1 @@\n-    static final void guard_LII_V(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final long guard_LJJJ_J(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -757,3 +1281,1 @@\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n@@ -762,1 +1284,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -769,1 +1291,1 @@\n-    static final boolean guard_LIII_Z(VarHandle handle, Object arg0, int arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_LJFF_F(VarHandle handle, Object arg0, long arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -772,1 +1294,1 @@\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n@@ -775,1 +1297,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -782,1 +1304,1 @@\n-    static final int guard_LIII_I(VarHandle handle, Object arg0, int arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_LJDD_D(VarHandle handle, Object arg0, long arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -785,1 +1307,1 @@\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n@@ -788,1 +1310,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -795,1 +1317,1 @@\n-    static final long guard_LI_J(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final Object guard_LJJLL_L(VarHandle handle, Object arg0, long arg1, long arg2, Object arg3, Object arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -798,1 +1320,2 @@\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n+            return ad.returnType.cast(r);\n@@ -801,1 +1324,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n@@ -808,1 +1331,1 @@\n-    static final void guard_LIJ_V(VarHandle handle, Object arg0, int arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard_LJJII_I(VarHandle handle, Object arg0, long arg1, long arg2, int arg3, int arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -811,3 +1334,1 @@\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n@@ -816,1 +1337,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n@@ -823,1 +1344,1 @@\n-    static final boolean guard_LIJJ_Z(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final long guard_LJJJJ_J(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, long arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -826,1 +1347,1 @@\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n@@ -829,1 +1350,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n@@ -836,1 +1357,1 @@\n-    static final long guard_LIJJ_J(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_LJJFF_F(VarHandle handle, Object arg0, long arg1, long arg2, float arg3, float arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -839,1 +1360,1 @@\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n@@ -842,1 +1363,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n@@ -849,1 +1370,1 @@\n-    static final long guard_LIJ_J(VarHandle handle, Object arg0, int arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_LJJDD_D(VarHandle handle, Object arg0, long arg1, long arg2, double arg3, double arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -852,1 +1373,1 @@\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n@@ -855,1 +1376,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n@@ -862,1 +1383,1 @@\n-    static final float guard_LI_F(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_LF_F(VarHandle handle, Object arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -875,1 +1396,1 @@\n-    static final void guard_LIF_V(VarHandle handle, Object arg0, int arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_LD_D(VarHandle handle, Object arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -878,3 +1399,1 @@\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n@@ -883,1 +1402,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n@@ -890,1 +1409,1 @@\n-    static final boolean guard_LIFF_Z(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard_I_I(VarHandle handle, int arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -893,1 +1412,1 @@\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+            return (int) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n@@ -896,1 +1415,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n@@ -903,1 +1422,1 @@\n-    static final float guard_LIFF_F(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final long guard_J_J(VarHandle handle, long arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -906,1 +1425,1 @@\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+            return (long) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n@@ -909,1 +1428,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n@@ -916,1 +1435,1 @@\n-    static final float guard_LIF_F(VarHandle handle, Object arg0, int arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_F_F(VarHandle handle, float arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -919,1 +1438,1 @@\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            return (float) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n@@ -922,1 +1441,1 @@\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n@@ -929,1 +1448,1 @@\n-    static final double guard_LI_D(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_D_D(VarHandle handle, double arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -932,1 +1451,1 @@\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            return (double) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n@@ -935,1 +1454,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n@@ -942,1 +1461,1 @@\n-    static final void guard_LID_V(VarHandle handle, Object arg0, int arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final Object guard_LIL_L(VarHandle handle, Object arg0, int arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -945,3 +1464,2 @@\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            return ad.returnType.cast(r);\n@@ -950,1 +1468,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -957,1 +1475,1 @@\n-    static final boolean guard_LIDD_Z(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final long guard_LIJ_J(VarHandle handle, Object arg0, int arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -960,1 +1478,1 @@\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n@@ -963,1 +1481,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -970,1 +1488,1 @@\n-    static final double guard_LIDD_D(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_LIF_F(VarHandle handle, Object arg0, int arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -973,1 +1491,1 @@\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n@@ -976,1 +1494,1 @@\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -996,1 +1514,1 @@\n-    static final int guard_LJ_I(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final Object guard_LJL_L(VarHandle handle, Object arg0, long arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -999,1 +1517,2 @@\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n+            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            return ad.returnType.cast(r);\n@@ -1002,1 +1521,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -1009,1 +1528,1 @@\n-    static final void guard_LJI_V(VarHandle handle, Object arg0, long arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard_LJI_I(VarHandle handle, Object arg0, long arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -1012,3 +1531,1 @@\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n@@ -1017,1 +1534,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -1024,1 +1541,1 @@\n-    static final boolean guard_LJII_Z(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_LJF_F(VarHandle handle, Object arg0, long arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -1027,1 +1544,1 @@\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n@@ -1030,1 +1547,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -1037,1 +1554,1 @@\n-    static final int guard_LJII_I(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_LJD_D(VarHandle handle, Object arg0, long arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -1040,1 +1557,1 @@\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n@@ -1043,1 +1560,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n@@ -1050,1 +1567,1 @@\n-    static final int guard_LJI_I(VarHandle handle, Object arg0, long arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final Object guard_LJJL_L(VarHandle handle, Object arg0, long arg1, long arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -1053,1 +1570,2 @@\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+            return ad.returnType.cast(r);\n@@ -1056,1 +1574,1 @@\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -1063,1 +1581,1 @@\n-    static final void guard_LJJ_V(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final int guard_LJJI_I(VarHandle handle, Object arg0, long arg1, long arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -1066,3 +1584,1 @@\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n+            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n@@ -1071,1 +1587,1 @@\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n+            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -1078,1 +1594,1 @@\n-    static final boolean guard_LJJJ_Z(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final float guard_LJJF_F(VarHandle handle, Object arg0, long arg1, long arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -1081,1 +1597,1 @@\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n@@ -1084,1 +1600,1 @@\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n@@ -1091,1 +1607,1 @@\n-    static final long guard_LJJJ_J(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n+    static final double guard_LJJD_D(VarHandle handle, Object arg0, long arg1, long arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n@@ -1094,1 +1610,1 @@\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n+            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n@@ -1097,1 +1613,1 @@\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n+            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleGuards.java","additions":762,"deletions":246,"binary":false,"changes":1008,"status":"modified"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.invoke;\n-\n-\/**\n- * Base class for memory segment var handle view implementations.\n- *\/\n-abstract sealed class VarHandleSegmentViewBase extends VarHandle permits\n-        VarHandleSegmentAsBytes,\n-        VarHandleSegmentAsChars,\n-        VarHandleSegmentAsDoubles,\n-        VarHandleSegmentAsFloats,\n-        VarHandleSegmentAsInts,\n-        VarHandleSegmentAsLongs,\n-        VarHandleSegmentAsShorts {\n-\n-    \/** endianness **\/\n-    final boolean be;\n-\n-    \/** alignment constraint (in bytes, expressed as a bit mask) **\/\n-    final long alignmentMask;\n-\n-    VarHandleSegmentViewBase(VarForm form, boolean be, long alignmentMask, boolean exact) {\n-        super(form, exact);\n-        this.be = be;\n-        this.alignmentMask = alignmentMask;\n-    }\n-\n-    static UnsupportedOperationException newUnsupportedAccessModeForAlignment(long alignment) {\n-        return new UnsupportedOperationException(\"Unsupported access mode for alignment: \" + alignment);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleSegmentViewBase.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -294,2 +295,3 @@\n-     * Creates a memory segment view var handle.\n-     *\n+     * Creates a memory segment view var handle accessing a {@code carrier} element. It has access coordinates\n+     * {@code (MS, long)} if {@code noStride}, {@code (MS, long, (unchecked) long)} otherwise.\n+     * <p>\n@@ -297,4 +299,5 @@\n-     * and a {@code long} as second argument (the offset into the segment).\n-     *\n-     * Note: the returned var handle does not perform any size or alignment check. It is up to clients\n-     * to adapt the returned var handle and insert the appropriate checks.\n+     * and a {@code long} as second argument (the offset into the segment). Both arguments are checked.\n+     * <p>\n+     * If {@code noStride == false}, the resulting var handle will take a third unchecked additional\n+     * offset instead of the given fixed {@code offset}, and caller must ensure that passed additional offset,\n+     * either to the handle (such as computing through method handles) or as fixed {@code offset} here, is valid.\n@@ -302,4 +305,7 @@\n-     * @param carrier the Java carrier type.\n-     * @param alignmentMask alignment requirement to be checked upon access. In bytes. Expressed as a mask.\n-     * @param byteOrder the byte order.\n-     * @return the created VarHandle.\n+     * @param carrier the Java carrier type of the element\n+     * @param enclosing the enclosing layout to perform bound and alignment checks against\n+     * @param alignmentMask alignment of this accessed element in the enclosing layout\n+     * @param noStride if access path to this element has no stride; we can use fixed offset if there is none\n+     * @param offset the fixed offset, if there is no strides\n+     * @param byteOrder the byte order\n+     * @return the created var handle\n@@ -307,3 +313,3 @@\n-    static VarHandle memorySegmentViewHandle(Class<?> carrier, long alignmentMask,\n-                                             ByteOrder byteOrder) {\n-        if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {\n+    static VarHandle memorySegmentViewHandle(Class<?> carrier, MemoryLayout enclosing, long alignmentMask,\n+                                             boolean noStride, long offset, ByteOrder byteOrder) {\n+        if (!carrier.isPrimitive() || carrier == void.class) {\n@@ -315,0 +321,2 @@\n+        \/\/ All carrier types must persist across MethodType erasure\n+        VarForm form;\n@@ -316,1 +324,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsBytes(be, alignmentMask, exact));\n+            form = VarHandleSegmentAsBytes.selectForm(alignmentMask, noStride);\n@@ -318,1 +326,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsChars(be, alignmentMask, exact));\n+            form = VarHandleSegmentAsChars.selectForm(alignmentMask, noStride);\n@@ -320,1 +328,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsShorts(be, alignmentMask, exact));\n+            form = VarHandleSegmentAsShorts.selectForm(alignmentMask, noStride);\n@@ -322,1 +330,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsInts(be, alignmentMask, exact));\n+            form = VarHandleSegmentAsInts.selectForm(alignmentMask, noStride);\n@@ -324,1 +332,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsFloats(be, alignmentMask, exact));\n+            form = VarHandleSegmentAsFloats.selectForm(alignmentMask, noStride);\n@@ -326,1 +334,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsLongs(be, alignmentMask, exact));\n+            form = VarHandleSegmentAsLongs.selectForm(alignmentMask, noStride);\n@@ -328,1 +336,3 @@\n-            return maybeAdapt(new VarHandleSegmentAsDoubles(be, alignmentMask, exact));\n+            form = VarHandleSegmentAsDoubles.selectForm(alignmentMask, noStride);\n+        } else if (carrier == boolean.class) {\n+            form = VarHandleSegmentAsBooleans.selectForm(alignmentMask, noStride);\n@@ -332,0 +342,2 @@\n+\n+        return maybeAdapt(new SegmentVarHandle(form, be, enclosing, offset, exact));\n@@ -727,1 +739,1 @@\n-\/\/        record HandleType(Class<?> receiver, Class<?> value, Class<?>... intermediates) {\n+\/\/        record HandleType(Class<?> receiver, Class<?>... intermediates) {\n@@ -747,11 +759,6 @@\n-\/\/            Stream<HandleType> hts = Stream.of(\n-\/\/                    \/\/ Object->Object\n-\/\/                    new HandleType(Object.class, Object.class),\n-\/\/                    \/\/ Object->int\n-\/\/                    new HandleType(Object.class, int.class),\n-\/\/                    \/\/ Object->long\n-\/\/                    new HandleType(Object.class, long.class),\n-\/\/                    \/\/ Object->float\n-\/\/                    new HandleType(Object.class, float.class),\n-\/\/                    \/\/ Object->double\n-\/\/                    new HandleType(Object.class, double.class),\n+\/\/            List<HandleType> hts = List.of(\n+\/\/                    \/\/ Object->T\n+\/\/                    new HandleType(Object.class),\n+\/\/\n+\/\/                    \/\/ <static>->T\n+\/\/                    new HandleType(null),\n@@ -759,10 +766,2 @@\n-\/\/                    \/\/ <static>->Object\n-\/\/                    new HandleType(null, Object.class),\n-\/\/                    \/\/ <static>->int\n-\/\/                    new HandleType(null, int.class),\n-\/\/                    \/\/ <static>->long\n-\/\/                    new HandleType(null, long.class),\n-\/\/                    \/\/ <static>->float\n-\/\/                    new HandleType(null, float.class),\n-\/\/                    \/\/ <static>->double\n-\/\/                    new HandleType(null, double.class),\n+\/\/                    \/\/ Array[index]->T\n+\/\/                    new HandleType(Object.class, int.class),\n@@ -770,10 +769,2 @@\n-\/\/                    \/\/ Array[int]->Object\n-\/\/                    new HandleType(Object.class, Object.class, int.class),\n-\/\/                    \/\/ Array[int]->int\n-\/\/                    new HandleType(Object.class, int.class, int.class),\n-\/\/                    \/\/ Array[int]->long\n-\/\/                    new HandleType(Object.class, long.class, int.class),\n-\/\/                    \/\/ Array[int]->float\n-\/\/                    new HandleType(Object.class, float.class, int.class),\n-\/\/                    \/\/ Array[int]->double\n-\/\/                    new HandleType(Object.class, double.class, int.class),\n+\/\/                    \/\/ MS[base]->T\n+\/\/                    new HandleType(Object.class, long.class),\n@@ -781,3 +772,1 @@\n-\/\/                    \/\/ Array[long]->int\n-\/\/                    new HandleType(Object.class, int.class, long.class),\n-\/\/                    \/\/ Array[long]->long\n+\/\/                    \/\/ MS[base][offset]->T\n@@ -787,2 +776,8 @@\n-\/\/            hts.flatMap(ht -> Stream.of(VarHandleTemplate.class.getMethods()).\n-\/\/                    map(m -> generateMethodType(m, ht.receiver, ht.value, ht.intermediates))).\n+\/\/            Stream.of(VarHandleTemplate.class.getMethods()).<MethodType>\n+\/\/                    mapMulti((m, sink) -> {\n+\/\/                        for (var ht : hts) {\n+\/\/                            for (var bt : LambdaForm.BasicType.ARG_TYPES) {\n+\/\/                                sink.accept(generateMethodType(m, ht.receiver, bt.btClass, ht.intermediates));\n+\/\/                            }\n+\/\/                        }\n+\/\/                    }).\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":52,"deletions":57,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.misc.ScopedMemoryAccess;\n@@ -32,1 +30,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -34,1 +31,0 @@\n-import java.lang.ref.Reference;\n@@ -36,3 +32,1 @@\n-import java.util.Objects;\n-\n-import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n+import static java.lang.invoke.SegmentVarHandle.*;\n@@ -42,5 +36,1 @@\n-final class VarHandleSegmentAs$Type$s extends VarHandleSegmentViewBase {\n-\n-    static final boolean BE = UNSAFE.isBigEndian();\n-\n-    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+final class VarHandleSegmentAs$Type$s {\n@@ -48,0 +38,1 @@\n+#if[!byte]\n@@ -50,4 +41,9 @@\n-    static final VarForm FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, MemoryLayout.class, long.class, long.class);\n-\n-    VarHandleSegmentAs$Type$s(boolean be, long alignmentMask, boolean exact) {\n-        super(FORM, be, alignmentMask, exact);\n+#end[byte]\n+    static VarForm selectForm(long alignmentMask, boolean noStride) {\n+#if[byte]\n+        return noStride ? Unaligned.FORM : Unaligned.OFFSET_FORM;\n+#else[byte]\n+        return (alignmentMask & NON_PLAIN_ACCESS_MIN_ALIGN_MASK) != NON_PLAIN_ACCESS_MIN_ALIGN_MASK ?\n+                (noStride ? Unaligned.FORM : Unaligned.OFFSET_FORM) :\n+                (noStride ? Aligned.FORM : Aligned.OFFSET_FORM);\n+#end[byte]\n@@ -56,4 +52,1 @@\n-    @Override\n-    final MethodType accessModeTypeUncached(VarHandle.AccessType accessType) {\n-        return accessType.accessModeType(MemorySegment.class, $type$.class, MemoryLayout.class, long.class, long.class);\n-    }\n+    static {#if[byte]?final:sealed} class Unaligned {\n@@ -61,6 +54,2 @@\n-    @Override\n-    public VarHandleSegmentAs$Type$s withInvokeExactBehavior() {\n-        return hasInvokeExactBehavior() ?\n-                this :\n-                new VarHandleSegmentAs$Type$s(be, alignmentMask, true);\n-    }\n+        static final VarForm FORM = new VarForm(Unaligned.class, MemorySegment.class, $type$.class, long.class);\n+        static final VarForm OFFSET_FORM = new VarForm(Unaligned.class, MemorySegment.class, $type$.class, long.class, long.class);\n@@ -68,6 +57,1 @@\n-    @Override\n-    public VarHandleSegmentAs$Type$s withInvokeBehavior() {\n-        return !hasInvokeExactBehavior() ?\n-                this :\n-                new VarHandleSegmentAs$Type$s(be, alignmentMask, false);\n-    }\n+        Unaligned() { throw new AssertionError(); }\n@@ -75,6 +59,4 @@\n-#if[floatingPoint]\n-    @ForceInline\n-    static $rawType$ convEndian(boolean big, $type$ v) {\n-        $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);\n-        return big == BE ? rv : $RawBoxType$.reverseBytes(rv);\n-    }\n+        @ForceInline\n+        static $type$ get(VarHandle ob, Object obb, long base) {\n+            return get(ob, obb, base, ((SegmentVarHandle) ob).offset);\n+        }\n@@ -82,5 +64,10 @@\n-    @ForceInline\n-    static $type$ convEndian(boolean big, $rawType$ rv) {\n-        rv = big == BE ? rv : $RawBoxType$.reverseBytes(rv);\n-        return $Type$.$rawType$BitsTo$Type$(rv);\n-    }\n+        @ForceInline\n+        static $type$ get(VarHandle ob, Object obb, long base, long offset) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, true);\n+#if[floatingPoint]\n+            $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, offset),\n+                    handle.be);\n+            return $Type$.$rawType$BitsTo$Type$(rawValue);\n@@ -89,4 +76,3 @@\n-    @ForceInline\n-    static $type$ convEndian(boolean big, $type$ n) {\n-        return n;\n-    }\n+            return SCOPED_MEMORY_ACCESS.get$Type$(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, offset));\n@@ -94,4 +80,4 @@\n-    @ForceInline\n-    static $type$ convEndian(boolean big, $type$ n) {\n-        return big == BE ? n : $BoxType$.reverseBytes(n);\n-    }\n+            return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, offset),\n+                    handle.be);\n@@ -100,12 +86,0 @@\n-\n-    @ForceInline\n-    static AbstractMemorySegmentImpl checkSegment(Object obb, Object encl, long base, boolean ro) {\n-        AbstractMemorySegmentImpl oo = (AbstractMemorySegmentImpl)Objects.requireNonNull(obb);\n-        oo.checkEnclosingLayout(base, (MemoryLayout)encl, ro);\n-        return oo;\n-    }\n-\n-    @ForceInline\n-    static long offsetNonPlain(AbstractMemorySegmentImpl bb, long base, long offset, long alignmentMask) {\n-        if ((alignmentMask & NON_PLAIN_ACCESS_MIN_ALIGN_MASK) != NON_PLAIN_ACCESS_MIN_ALIGN_MASK) {\n-            throw VarHandleSegmentViewBase.newUnsupportedAccessModeForAlignment(alignmentMask + 1);\n@@ -113,2 +87,0 @@\n-        return offsetPlain(bb, base, offset);\n-    }\n@@ -116,5 +88,4 @@\n-    @ForceInline\n-    static long offsetPlain(AbstractMemorySegmentImpl bb, long base, long offset) {\n-        long segment_base = bb.unsafeGetOffset();\n-        return segment_base + base + offset;\n-    }\n+        @ForceInline\n+        static void set(VarHandle ob, Object obb, long base, $type$ value) {\n+            set(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n+        }\n@@ -122,4 +93,4 @@\n-    @ForceInline\n-    static $type$ get(VarHandle ob, Object obb, Object encl, long base, long offset) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n+        @ForceInline\n+        static void set(VarHandle ob, Object obb, long base, long offset, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -127,5 +98,5 @@\n-        $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetPlain(bb, base, offset),\n-                handle.be);\n-        return $Type$.$rawType$BitsTo$Type$(rawValue);\n+            SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, offset),\n+                    $Type$.$type$ToRaw$RawType$Bits(value),\n+                    handle.be);\n@@ -134,3 +105,4 @@\n-        return SCOPED_MEMORY_ACCESS.get$Type$(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetPlain(bb, base, offset));\n+            SCOPED_MEMORY_ACCESS.put$Type$(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, offset),\n+                    value);\n@@ -138,4 +110,5 @@\n-        return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetPlain(bb, base, offset),\n-                handle.be);\n+            SCOPED_MEMORY_ACCESS.put$Type$Unaligned(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, offset),\n+                    value,\n+                    handle.be);\n@@ -144,0 +117,2 @@\n+        }\n+#if[!byte]\n@@ -146,4 +121,8 @@\n-    @ForceInline\n-    static void set(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n+    static final class Aligned extends Unaligned {\n+\n+        static final VarForm FORM = new VarForm(Aligned.class, Unaligned.FORM);\n+        static final VarForm OFFSET_FORM = new VarForm(Aligned.class, Unaligned.OFFSET_FORM);\n+\n+        Aligned() { throw new AssertionError(); }\n+#end[byte]\n+\n@@ -151,5 +130,11 @@\n-        SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetPlain(bb, base, offset),\n-                $Type$.$type$ToRaw$RawType$Bits(value),\n-                handle.be);\n+        @ForceInline\n+        static $rawType$ convEndian(boolean big, $type$ v) {\n+            $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);\n+            return big == BE ? rv : $RawBoxType$.reverseBytes(rv);\n+        }\n+\n+        @ForceInline\n+        static $type$ convEndian(boolean big, $rawType$ rv) {\n+            rv = big == BE ? rv : $RawBoxType$.reverseBytes(rv);\n+            return $Type$.$rawType$BitsTo$Type$(rv);\n+        }\n@@ -158,4 +143,4 @@\n-        SCOPED_MEMORY_ACCESS.put$Type$(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetPlain(bb, base, offset),\n-                value);\n+        @ForceInline\n+        static $type$ convEndian(boolean big, $type$ n) {\n+            return n;\n+        }\n@@ -163,5 +148,4 @@\n-        SCOPED_MEMORY_ACCESS.put$Type$Unaligned(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetPlain(bb, base, offset),\n-                value,\n-                handle.be);\n+        @ForceInline\n+        static $type$ convEndian(boolean big, $type$ n) {\n+            return big == BE ? n : $BoxType$.reverseBytes(n);\n+        }\n@@ -170,1 +154,0 @@\n-    }\n@@ -172,9 +155,4 @@\n-    @ForceInline\n-    static $type$ getVolatile(VarHandle ob, Object obb, Object encl, long base, long offset) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n-        return convEndian(handle.be,\n-                          SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n-                                  offsetNonPlain(bb, base, offset, handle.alignmentMask)));\n-    }\n+        @ForceInline\n+        static $type$ getVolatile(VarHandle ob, Object obb, long base) {\n+            return getVolatile(ob, obb, base, ((SegmentVarHandle) ob).offset);\n+        }\n@@ -182,9 +160,9 @@\n-    @ForceInline\n-    static void setVolatile(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        SCOPED_MEMORY_ACCESS.put$RawType$Volatile(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                convEndian(handle.be, value));\n-    }\n+        @ForceInline\n+        static $type$ getVolatile(VarHandle ob, Object obb, long base, long offset) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, true);\n+            return convEndian(handle.be,\n+                              SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),\n+                                      bb.unsafeGetBase(),\n+                                      offset(bb, base, offset)));\n+        }\n@@ -192,9 +170,4 @@\n-    @ForceInline\n-    static $type$ getAcquire(VarHandle ob, Object obb, Object encl, long base, long offset) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n-        return convEndian(handle.be,\n-                          SCOPED_MEMORY_ACCESS.get$RawType$Acquire(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n-                                  offsetNonPlain(bb, base, offset, handle.alignmentMask)));\n-    }\n+        @ForceInline\n+        static void setVolatile(VarHandle ob, Object obb, long base, $type$ value) {\n+            setVolatile(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n+        }\n@@ -202,9 +175,9 @@\n-    @ForceInline\n-    static void setRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        SCOPED_MEMORY_ACCESS.put$RawType$Release(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                convEndian(handle.be, value));\n-    }\n+        @ForceInline\n+        static void setVolatile(VarHandle ob, Object obb, long base, long offset, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+            SCOPED_MEMORY_ACCESS.put$RawType$Volatile(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, offset),\n+                    convEndian(handle.be, value));\n+        }\n@@ -212,9 +185,4 @@\n-    @ForceInline\n-    static $type$ getOpaque(VarHandle ob, Object obb, Object encl, long base, long offset) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n-        return convEndian(handle.be,\n-                          SCOPED_MEMORY_ACCESS.get$RawType$Opaque(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n-                                  offsetNonPlain(bb, base, offset, handle.alignmentMask)));\n-    }\n+        @ForceInline\n+        static $type$ getAcquire(VarHandle ob, Object obb, long base) {\n+            return getAcquire(ob, obb, base, ((SegmentVarHandle) ob).offset);\n+        }\n@@ -222,9 +190,54 @@\n-    @ForceInline\n-    static void setOpaque(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        SCOPED_MEMORY_ACCESS.put$RawType$Opaque(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                convEndian(handle.be, value));\n-    }\n+        @ForceInline\n+        static $type$ getAcquire(VarHandle ob, Object obb, long base, long offset) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, true);\n+            return convEndian(handle.be,\n+                              SCOPED_MEMORY_ACCESS.get$RawType$Acquire(bb.sessionImpl(),\n+                                      bb.unsafeGetBase(),\n+                                      offset(bb, base, offset)));\n+        }\n+\n+        @ForceInline\n+        static void setRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+            setRelease(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n+        }\n+\n+        @ForceInline\n+        static void setRelease(VarHandle ob, Object obb, long base, long offset, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+            SCOPED_MEMORY_ACCESS.put$RawType$Release(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, offset),\n+                    convEndian(handle.be, value));\n+        }\n+\n+        @ForceInline\n+        static $type$ getOpaque(VarHandle ob, Object obb, long base) {\n+            return getOpaque(ob, obb, base, ((SegmentVarHandle) ob).offset);\n+        }\n+\n+        @ForceInline\n+        static $type$ getOpaque(VarHandle ob, Object obb, long base, long offset) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, true);\n+            return convEndian(handle.be,\n+                              SCOPED_MEMORY_ACCESS.get$RawType$Opaque(bb.sessionImpl(),\n+                                      bb.unsafeGetBase(),\n+                                      offset(bb, base, offset)));\n+        }\n+\n+        @ForceInline\n+        static void setOpaque(VarHandle ob, Object obb, long base, $type$ value) {\n+            setOpaque(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n+        }\n+\n+        @ForceInline\n+        static void setOpaque(VarHandle ob, Object obb, long base, long offset, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+            SCOPED_MEMORY_ACCESS.put$RawType$Opaque(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, offset),\n+                    convEndian(handle.be, value));\n+        }\n@@ -233,9 +246,4 @@\n-    @ForceInline\n-    static boolean compareAndSet(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                convEndian(handle.be, expected), convEndian(handle.be, value));\n-    }\n+        @ForceInline\n+        static boolean compareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+            return compareAndSet(ob, obb, base, ((SegmentVarHandle) ob).offset, expected, value);\n+        }\n@@ -243,10 +251,9 @@\n-    @ForceInline\n-    static $type$ compareAndExchange(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        return convEndian(handle.be,\n-                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n-                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                                  convEndian(handle.be, expected), convEndian(handle.be, value)));\n-    }\n+        @ForceInline\n+        static boolean compareAndSet(VarHandle ob, Object obb, long base, long offset, $type$ expected, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+            return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, offset),\n+                    convEndian(handle.be, expected), convEndian(handle.be, value));\n+        }\n@@ -254,10 +261,4 @@\n-    @ForceInline\n-    static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        return convEndian(handle.be,\n-                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n-                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                                  convEndian(handle.be, expected), convEndian(handle.be, value)));\n-    }\n+        @ForceInline\n+        static $type$ compareAndExchange(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+            return compareAndExchange(ob, obb, base, ((SegmentVarHandle) ob).offset, expected, value);\n+        }\n@@ -265,10 +266,10 @@\n-    @ForceInline\n-    static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        return convEndian(handle.be,\n-                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n-                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                                  convEndian(handle.be, expected), convEndian(handle.be, value)));\n-    }\n+        @ForceInline\n+        static $type$ compareAndExchange(VarHandle ob, Object obb, long base, long offset, $type$ expected, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+            return convEndian(handle.be,\n+                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(bb.sessionImpl(),\n+                                      bb.unsafeGetBase(),\n+                                      offset(bb, base, offset),\n+                                      convEndian(handle.be, expected), convEndian(handle.be, value)));\n+        }\n@@ -276,9 +277,4 @@\n-    @ForceInline\n-    static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                convEndian(handle.be, expected), convEndian(handle.be, value));\n-    }\n+        @ForceInline\n+        static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+            return compareAndExchangeAcquire(ob, obb, base, ((SegmentVarHandle) ob).offset, expected, value);\n+        }\n@@ -286,9 +282,10 @@\n-    @ForceInline\n-    static boolean weakCompareAndSet(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                convEndian(handle.be, expected), convEndian(handle.be, value));\n-    }\n+        @ForceInline\n+        static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, long base, long offset, $type$ expected, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+            return convEndian(handle.be,\n+                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(bb.sessionImpl(),\n+                                      bb.unsafeGetBase(),\n+                                      offset(bb, base, offset),\n+                                      convEndian(handle.be, expected), convEndian(handle.be, value)));\n+        }\n@@ -296,9 +293,4 @@\n-    @ForceInline\n-    static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                convEndian(handle.be, expected), convEndian(handle.be, value));\n-    }\n+        @ForceInline\n+        static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+            return compareAndExchangeRelease(ob, obb, base, ((SegmentVarHandle) ob).offset, expected, value);\n+        }\n@@ -306,9 +298,10 @@\n-    @ForceInline\n-    static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                convEndian(handle.be, expected), convEndian(handle.be, value));\n-    }\n+        @ForceInline\n+        static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, long base, long offset, $type$ expected, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+            return convEndian(handle.be,\n+                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(bb.sessionImpl(),\n+                                      bb.unsafeGetBase(),\n+                                      offset(bb, base, offset),\n+                                      convEndian(handle.be, expected), convEndian(handle.be, value)));\n+        }\n@@ -316,10 +309,4 @@\n-    @ForceInline\n-    static $type$ getAndSet(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        return convEndian(handle.be,\n-                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n-                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                                  convEndian(handle.be, value)));\n-    }\n+        @ForceInline\n+        static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+            return weakCompareAndSetPlain(ob, obb, base, ((SegmentVarHandle) ob).offset, expected, value);\n+        }\n@@ -327,10 +314,9 @@\n-    @ForceInline\n-    static $type$ getAndSetAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        return convEndian(handle.be,\n-                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n-                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                                  convEndian(handle.be, value)));\n-    }\n+        @ForceInline\n+        static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, long base, long offset, $type$ expected, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, offset),\n+                    convEndian(handle.be, expected), convEndian(handle.be, value));\n+        }\n@@ -338,12 +324,4 @@\n-    @ForceInline\n-    static $type$ getAndSetRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        return convEndian(handle.be,\n-                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n-                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                                  convEndian(handle.be, value)));\n-    }\n-#end[CAS]\n-#if[AtomicAdd]\n+        @ForceInline\n+        static boolean weakCompareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+            return weakCompareAndSet(ob, obb, base, ((SegmentVarHandle) ob).offset, expected, value);\n+        }\n@@ -351,6 +329,5 @@\n-    @ForceInline\n-    static $type$ getAndAdd(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ delta) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(bb.sessionImpl(),\n+        @ForceInline\n+        static boolean weakCompareAndSet(VarHandle ob, Object obb, long base, long offset, $type$ expected, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),\n@@ -358,4 +335,7 @@\n-                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                    delta);\n-        } else {\n-            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), delta);\n+                    offset(bb, base, offset),\n+                    convEndian(handle.be, expected), convEndian(handle.be, value));\n+        }\n+\n+        @ForceInline\n+        static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+            return weakCompareAndSetAcquire(ob, obb, base, ((SegmentVarHandle) ob).offset, expected, value);\n@@ -363,1 +343,0 @@\n-    }\n@@ -365,6 +344,5 @@\n-    @ForceInline\n-    static $type$ getAndAddAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ delta) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(bb.sessionImpl(),\n+        @ForceInline\n+        static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, long base, long offset, $type$ expected, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(bb.sessionImpl(),\n@@ -372,4 +350,7 @@\n-                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                    delta);\n-        } else {\n-            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), delta);\n+                    offset(bb, base, offset),\n+                    convEndian(handle.be, expected), convEndian(handle.be, value));\n+        }\n+\n+        @ForceInline\n+        static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+            return weakCompareAndSetRelease(ob, obb, base, ((SegmentVarHandle) ob).offset, expected, value);\n@@ -377,1 +358,0 @@\n-    }\n@@ -379,6 +359,5 @@\n-    @ForceInline\n-    static $type$ getAndAddRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ delta) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(bb.sessionImpl(),\n+        @ForceInline\n+        static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, long base, long offset, $type$ expected, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(bb.sessionImpl(),\n@@ -386,4 +365,2 @@\n-                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                    delta);\n-        } else {\n-            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), delta);\n+                    offset(bb, base, offset),\n+                    convEndian(handle.be, expected), convEndian(handle.be, value));\n@@ -391,1 +368,0 @@\n-    }\n@@ -393,11 +369,132 @@\n-    @ForceInline\n-    static $type$ getAndAddConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ delta) {\n-        $type$ nativeExpectedValue, expectedValue;\n-        Object base = bb.unsafeGetBase();\n-        do {\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n-            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n-                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));\n-        return expectedValue;\n-    }\n+        @ForceInline\n+        static $type$ getAndSet(VarHandle ob, Object obb, long base, $type$ value) {\n+            return getAndSet(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n+        }\n+\n+        @ForceInline\n+        static $type$ getAndSet(VarHandle ob, Object obb, long base, long offset, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+            return convEndian(handle.be,\n+                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$(bb.sessionImpl(),\n+                                      bb.unsafeGetBase(),\n+                                      offset(bb, base, offset),\n+                                      convEndian(handle.be, value)));\n+        }\n+\n+        @ForceInline\n+        static $type$ getAndSetAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+            return getAndSetAcquire(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n+        }\n+\n+        @ForceInline\n+        static $type$ getAndSetAcquire(VarHandle ob, Object obb, long base, long offset, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+            return convEndian(handle.be,\n+                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(bb.sessionImpl(),\n+                                      bb.unsafeGetBase(),\n+                                      offset(bb, base, offset),\n+                                      convEndian(handle.be, value)));\n+        }\n+\n+        @ForceInline\n+        static $type$ getAndSetRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+            return getAndSetRelease(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n+        }\n+\n+        @ForceInline\n+        static $type$ getAndSetRelease(VarHandle ob, Object obb, long base, long offset, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+            return convEndian(handle.be,\n+                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(bb.sessionImpl(),\n+                                      bb.unsafeGetBase(),\n+                                      offset(bb, base, offset),\n+                                      convEndian(handle.be, value)));\n+        }\n+#end[CAS]\n+#if[AtomicAdd]\n+\n+        @ForceInline\n+        static $type$ getAndAdd(VarHandle ob, Object obb, long base, $type$ value) {\n+            return getAndAdd(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n+        }\n+\n+        @ForceInline\n+        static $type$ getAndAdd(VarHandle ob, Object obb, long base, long offset, $type$ delta) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+#if[!byte]\n+            if (handle.be == BE) {\n+#end[byte]\n+                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(bb.sessionImpl(),\n+                        bb.unsafeGetBase(),\n+                        offset(bb, base, offset),\n+                        delta);\n+#if[!byte]\n+            } else {\n+                return getAndAddConvEndianWithCAS(bb, offset(bb, base, offset), delta);\n+            }\n+#end[byte]\n+        }\n+\n+        @ForceInline\n+        static $type$ getAndAddAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+            return getAndAddAcquire(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n+        }\n+\n+        @ForceInline\n+        static $type$ getAndAddAcquire(VarHandle ob, Object obb, long base, long offset, $type$ delta) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+#if[!byte]\n+            if (handle.be == BE) {\n+#end[byte]\n+                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(bb.sessionImpl(),\n+                        bb.unsafeGetBase(),\n+                        offset(bb, base, offset),\n+                        delta);\n+#if[!byte]\n+            } else {\n+                return getAndAddConvEndianWithCAS(bb, offset(bb, base, offset), delta);\n+            }\n+#end[byte]\n+        }\n+\n+        @ForceInline\n+        static $type$ getAndAddRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+            return getAndAddRelease(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n+        }\n+\n+        @ForceInline\n+        static $type$ getAndAddRelease(VarHandle ob, Object obb, long base, long offset, $type$ delta) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+#if[!byte]\n+            if (handle.be == BE) {\n+#end[byte]\n+                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(bb.sessionImpl(),\n+                        bb.unsafeGetBase(),\n+                        offset(bb, base, offset),\n+                        delta);\n+#if[!byte]\n+            } else {\n+                return getAndAddConvEndianWithCAS(bb, offset(bb, base, offset), delta);\n+            }\n+#end[byte]\n+        }\n+#if[!byte]\n+\n+        @ForceInline\n+        static $type$ getAndAddConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ delta) {\n+            $type$ nativeExpectedValue, expectedValue;\n+            Object base = bb.unsafeGetBase();\n+            do {\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+                expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);\n+            } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+                    nativeExpectedValue, $RawBoxType$.reverseBytes({#if[ShorterThanInt]?($type$) }(expectedValue + delta))));\n+            return expectedValue;\n+        }\n+#end[byte]\n@@ -407,11 +504,3 @@\n-    @ForceInline\n-    static $type$ getAndBitwiseOr(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                    value);\n-        } else {\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n+        @ForceInline\n+        static $type$ getAndBitwiseOr(VarHandle ob, Object obb, long base, $type$ value) {\n+            return getAndBitwiseOr(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -419,1 +508,0 @@\n-    }\n@@ -421,11 +509,16 @@\n-    @ForceInline\n-    static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                    value);\n-        } else {\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n+        @ForceInline\n+        static $type$ getAndBitwiseOr(VarHandle ob, Object obb, long base, long offset, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+#if[!byte]\n+            if (handle.be == BE) {\n+#end[byte]\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(bb.sessionImpl(),\n+                        bb.unsafeGetBase(),\n+                        offset(bb, base, offset),\n+                        value);\n+#if[!byte]\n+            } else {\n+                return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, offset), value);\n+            }\n+#end[byte]\n@@ -433,1 +526,0 @@\n-    }\n@@ -435,11 +527,3 @@\n-    @ForceInline\n-    static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                    value);\n-        } else {\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n+        @ForceInline\n+        static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+            return getAndBitwiseOrRelease(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -447,1 +531,0 @@\n-    }\n@@ -449,11 +532,17 @@\n-    @ForceInline\n-    static $type$ getAndBitwiseOrConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ value) {\n-        $type$ nativeExpectedValue, expectedValue;\n-        Object base = bb.unsafeGetBase();\n-        do {\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n-            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n-                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));\n-        return expectedValue;\n-    }\n+        @ForceInline\n+        static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, long base, long offset, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+#if[!byte]\n+            if (handle.be == BE) {\n+#end[byte]\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(bb.sessionImpl(),\n+                        bb.unsafeGetBase(),\n+                        offset(bb, base, offset),\n+                        value);\n+#if[!byte]\n+            } else {\n+                return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, offset), value);\n+            }\n+#end[byte]\n+        }\n@@ -461,11 +550,3 @@\n-    @ForceInline\n-    static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                    value);\n-        } else {\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n+        @ForceInline\n+        static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+            return getAndBitwiseOrAcquire(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -473,1 +554,0 @@\n-    }\n@@ -475,11 +555,16 @@\n-    @ForceInline\n-    static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                    value);\n-        } else {\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n+        @ForceInline\n+        static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, long base, long offset, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+#if[!byte]\n+            if (handle.be == BE) {\n+#end[byte]\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(bb.sessionImpl(),\n+                        bb.unsafeGetBase(),\n+                        offset(bb, base, offset),\n+                        value);\n+#if[!byte]\n+            } else {\n+                return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, offset), value);\n+            }\n+#end[byte]\n@@ -487,1 +572,14 @@\n-    }\n+#if[!byte]\n+\n+        @ForceInline\n+        static $type$ getAndBitwiseOrConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ value) {\n+            $type$ nativeExpectedValue, expectedValue;\n+            Object base = bb.unsafeGetBase();\n+            do {\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+                expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);\n+            } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+                    nativeExpectedValue, $RawBoxType$.reverseBytes({#if[ShorterThanInt]?($type$) }(expectedValue | value))));\n+            return expectedValue;\n+        }\n+#end[byte]\n@@ -489,11 +587,3 @@\n-    @ForceInline\n-    static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                    value);\n-        } else {\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n+        @ForceInline\n+        static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, long base, $type$ value) {\n+            return getAndBitwiseAnd(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -501,1 +591,0 @@\n-    }\n@@ -503,11 +592,17 @@\n-    @ForceInline\n-    static $type$ getAndBitwiseAndConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ value) {\n-        $type$ nativeExpectedValue, expectedValue;\n-        Object base = bb.unsafeGetBase();\n-        do {\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n-            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n-                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue & value)));\n-        return expectedValue;\n-    }\n+        @ForceInline\n+        static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, long base, long offset, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+#if[!byte]\n+            if (handle.be == BE) {\n+#end[byte]\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(bb.sessionImpl(),\n+                        bb.unsafeGetBase(),\n+                        offset(bb, base, offset),\n+                        value);\n+#if[!byte]\n+            } else {\n+                return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, offset), value);\n+            }\n+#end[byte]\n+        }\n@@ -515,0 +610,4 @@\n+        @ForceInline\n+        static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+            return getAndBitwiseAndRelease(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n+        }\n@@ -516,11 +615,16 @@\n-    @ForceInline\n-    static $type$ getAndBitwiseXor(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                    value);\n-        } else {\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n+        @ForceInline\n+        static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, long base, long offset, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+#if[!byte]\n+            if (handle.be == BE) {\n+#end[byte]\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(bb.sessionImpl(),\n+                        bb.unsafeGetBase(),\n+                        offset(bb, base, offset),\n+                        value);\n+#if[!byte]\n+            } else {\n+                return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, offset), value);\n+            }\n+#end[byte]\n@@ -528,1 +632,0 @@\n-    }\n@@ -530,11 +633,3 @@\n-    @ForceInline\n-    static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                    value);\n-        } else {\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n+        @ForceInline\n+        static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+            return getAndBitwiseAndAcquire(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -542,1 +637,0 @@\n-    }\n@@ -544,11 +638,17 @@\n-    @ForceInline\n-    static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n-        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n-                    value);\n-        } else {\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n+\n+        @ForceInline\n+        static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, long base, long offset, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+#if[!byte]\n+            if (handle.be == BE) {\n+#end[byte]\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(bb.sessionImpl(),\n+                        bb.unsafeGetBase(),\n+                        offset(bb, base, offset),\n+                        value);\n+#if[!byte]\n+            } else {\n+                return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, offset), value);\n+            }\n+#end[byte]\n@@ -556,1 +656,14 @@\n-    }\n+#if[!byte]\n+\n+        @ForceInline\n+        static $type$ getAndBitwiseAndConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ value) {\n+            $type$ nativeExpectedValue, expectedValue;\n+            Object base = bb.unsafeGetBase();\n+            do {\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+                expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);\n+            } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+                    nativeExpectedValue, $RawBoxType$.reverseBytes({#if[ShorterThanInt]?($type$) }(expectedValue & value))));\n+            return expectedValue;\n+        }\n+#end[byte]\n@@ -558,11 +671,82 @@\n-    @ForceInline\n-    static $type$ getAndBitwiseXorConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ value) {\n-        $type$ nativeExpectedValue, expectedValue;\n-        Object base = bb.unsafeGetBase();\n-        do {\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n-            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n-                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));\n-        return expectedValue;\n-    }\n+        @ForceInline\n+        static $type$ getAndBitwiseXor(VarHandle ob, Object obb, long base, $type$ value) {\n+            return getAndBitwiseXor(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n+        }\n+\n+        @ForceInline\n+        static $type$ getAndBitwiseXor(VarHandle ob, Object obb, long base, long offset, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+#if[!byte]\n+            if (handle.be == BE) {\n+#end[byte]\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(bb.sessionImpl(),\n+                        bb.unsafeGetBase(),\n+                        offset(bb, base, offset),\n+                        value);\n+#if[!byte]\n+            } else {\n+                return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, offset), value);\n+            }\n+#end[byte]\n+        }\n+\n+        @ForceInline\n+        static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+            return getAndBitwiseXorRelease(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n+        }\n+\n+        @ForceInline\n+        static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, long base, long offset, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+#if[!byte]\n+            if (handle.be == BE) {\n+#end[byte]\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(bb.sessionImpl(),\n+                        bb.unsafeGetBase(),\n+                        offset(bb, base, offset),\n+                        value);\n+#if[!byte]\n+            } else {\n+                return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, offset), value);\n+            }\n+#end[byte]\n+        }\n+\n+        @ForceInline\n+        static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+            return getAndBitwiseXorAcquire(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n+        }\n+\n+        @ForceInline\n+        static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, long base, long offset, $type$ value) {\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n+#if[!byte]\n+            if (handle.be == BE) {\n+#end[byte]\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(bb.sessionImpl(),\n+                        bb.unsafeGetBase(),\n+                        offset(bb, base, offset),\n+                        value);\n+#if[!byte]\n+            } else {\n+                return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, offset), value);\n+            }\n+#end[byte]\n+        }\n+#if[!byte]\n+\n+        @ForceInline\n+        static $type$ getAndBitwiseXorConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ value) {\n+            $type$ nativeExpectedValue, expectedValue;\n+            Object base = bb.unsafeGetBase();\n+            do {\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+                expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);\n+            } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+                    nativeExpectedValue, $RawBoxType$.reverseBytes({#if[ShorterThanInt]?($type$) }(expectedValue ^ value))));\n+            return expectedValue;\n+        }\n+#end[byte]\n@@ -570,0 +754,1 @@\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":637,"deletions":452,"binary":false,"changes":1089,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -31,1 +32,0 @@\n-import java.lang.invoke.MethodHandles.Lookup;\n@@ -78,1 +78,1 @@\n-    VarHandle memorySegmentViewHandle(Class<?> carrier, long alignmentMask, ByteOrder order);\n+    VarHandle memorySegmentViewHandle(Class<?> carrier, MemoryLayout enclosing, long alignmentMask, ByteOrder order, boolean noStride, long offset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+    public static final MemoryLayout.PathElement[] EMPTY_PATH_ELEMENTS = new MemoryLayout.PathElement[0];\n@@ -208,4 +209,5 @@\n-        VarHandle handle = Utils.makeRawSegmentViewVarHandle(valueLayout);              \/\/ (MS, ML, long, long)\n-        handle = MethodHandles.insertCoordinates(handle, 1, rootLayout());          \/\/ (MS, long, long)\n-        if (strides.length > 0) {\n-            MethodHandle offsetAdapter = offsetHandle();\n+        boolean noStride = strides.length == 0;\n+        \/\/ (MS, long, long) if any stride, (MS, long) if no stride\n+        VarHandle handle = Utils.makeRawSegmentViewVarHandle(rootLayout(), valueLayout, noStride, offset);\n+        if (!noStride) {\n+            MethodHandle offsetAdapter = offsetHandle();  \/\/ Adapter performs the bound checks\n@@ -214,3 +216,0 @@\n-        } else {\n-            \/\/ simpler adaptation\n-            handle = MethodHandles.insertCoordinates(handle, 2, offset);            \/\/ (MS, long)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -33,0 +34,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -49,0 +51,1 @@\n+import java.util.function.Function;\n@@ -59,21 +62,37 @@\n-    private static final MethodHandle BYTE_TO_BOOL;\n-    private static final MethodHandle BOOL_TO_BYTE;\n-    private static final MethodHandle ADDRESS_TO_LONG;\n-    private static final MethodHandle LONG_TO_ADDRESS_TARGET;\n-    private static final MethodHandle LONG_TO_ADDRESS_NO_TARGET;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            BYTE_TO_BOOL = lookup.findStatic(Utils.class, \"byteToBoolean\",\n-                    MethodType.methodType(boolean.class, byte.class));\n-            BOOL_TO_BYTE = lookup.findStatic(Utils.class, \"booleanToByte\",\n-                    MethodType.methodType(byte.class, boolean.class));\n-            ADDRESS_TO_LONG = lookup.findStatic(SharedUtils.class, \"unboxSegment\",\n-                    MethodType.methodType(long.class, MemorySegment.class));\n-            LONG_TO_ADDRESS_TARGET = lookup.findStatic(Utils.class, \"longToAddress\",\n-                    MethodType.methodType(MemorySegment.class, long.class, AddressLayout.class));\n-            LONG_TO_ADDRESS_NO_TARGET = lookup.findStatic(Utils.class, \"longToAddress\",\n-                    MethodType.methodType(MemorySegment.class, long.class));\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n+    private static final int\n+            FILTER_ADDRESS_TO_LONG = 0,\n+            FILTER_LONG_TO_POINTER = 1,\n+            FILTER_LONG_TO_SEGMENT_WITH_LAYOUT = 2,\n+            FILTER_LIMIT = 3;\n+    private static final @Stable MethodHandle[] VH_FILTERS = new MethodHandle[FILTER_LIMIT];\n+\n+    private static MethodHandle filterHandle(int index) {\n+        var ret = VH_FILTERS[index];\n+        if (ret != null)\n+            return ret;\n+        return computeFilterHandle(index);\n+    }\n+\n+    private static MethodHandle computeFilterHandle(int index) {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        MethodHandle handle;\n+        if (Unsafe.getUnsafe().addressSize() == 8) {\n+            handle = switch (index) {\n+                case FILTER_ADDRESS_TO_LONG -> MhUtil.findStatic(lookup, SharedUtils.class, \"unboxSegment\",\n+                        MethodType.methodType(long.class, MemorySegment.class));\n+                case FILTER_LONG_TO_SEGMENT_WITH_LAYOUT -> MhUtil.findStatic(lookup, \"longToAddress\",\n+                        MethodType.methodType(MemorySegment.class, long.class, AddressLayout.class));\n+                case FILTER_LONG_TO_POINTER -> MhUtil.findStatic(lookup, \"longToAddress\",\n+                        MethodType.methodType(MemorySegment.class, long.class));\n+                default -> throw new IllegalArgumentException(String.valueOf(index));\n+            };\n+        } else {\n+            handle = switch (index) {\n+                case FILTER_ADDRESS_TO_LONG -> MhUtil.findStatic(lookup, SharedUtils.class, \"unboxSegment32\",\n+                        MethodType.methodType(int.class, MemorySegment.class));\n+                case FILTER_LONG_TO_SEGMENT_WITH_LAYOUT -> MhUtil.findStatic(lookup, \"longToAddress\",\n+                        MethodType.methodType(MemorySegment.class, int.class, AddressLayout.class));\n+                case FILTER_LONG_TO_POINTER -> MhUtil.findStatic(lookup, \"longToAddress\",\n+                        MethodType.methodType(MemorySegment.class, int.class));\n+                default -> throw new IllegalArgumentException(String.valueOf(index));\n+            };\n@@ -81,0 +100,1 @@\n+        return VH_FILTERS[index] = handle;\n@@ -93,2 +113,3 @@\n-     * This method returns a <em>raw var handle<\/em>, that is, a var handle that does not perform any size\n-     * or alignment checks. Such checks are added (using adaptation) by {@link LayoutPath#dereferenceHandle()}.\n+     * This method returns a var handle that takes a memory segment and offset (MS, long). If it has strides, it also\n+     * takes a raw offset (MS, long, long), which the var handle does not perform any size or alignment checks against.\n+     * Such checks are added (using adaptation) by {@link LayoutPath#dereferenceHandle()}.\n@@ -99,2 +120,2 @@\n-     * is then provided by this method: after all, var handles constructed by {@link MemoryLayout#varHandle(PathElement...)}\n-     * will be obtained by adapting some raw var handle generated by this method.\n+     * is then provided by this method, so different value layouts with same effects can reuse var handle instances.\n+     * (The 2nd layer may be redundant in the long run)\n@@ -102,2 +123,5 @@\n-     * @param layout the value layout for which a raw memory segment var handle is to be created.\n-     * @return a raw memory segment var handle.\n+     * @param enclosing the enclosing context of the value layout\n+     * @param layout the value layout for which a raw memory segment var handle is to be created\n+     * @param noStride if there is no stride, the VH uses the fixed offset instead of taking an offset\n+     * @param offset the offset in case there is no stride\n+     * @return a raw memory segment var handle\n@@ -105,3 +129,13 @@\n-    public static VarHandle makeRawSegmentViewVarHandle(ValueLayout layout) {\n-        final class VarHandleCache {\n-            private static final Map<ValueLayout, VarHandle> HANDLE_MAP = new ConcurrentHashMap<>();\n+    public static VarHandle makeRawSegmentViewVarHandle(MemoryLayout enclosing, ValueLayout layout, boolean noStride, long offset) {\n+        if (enclosing instanceof ValueLayout direct) {\n+            assert direct.equals(layout) && noStride && offset == 0;\n+            record VarHandleCache() implements Function<ValueLayout, VarHandle> {\n+                private static final Map<ValueLayout, VarHandle> HANDLE_MAP = new ConcurrentHashMap<>();\n+                private static final VarHandleCache INSTANCE = new VarHandleCache();\n+\n+                @Override\n+                public VarHandle apply(ValueLayout valueLayout) {\n+                    return Utils.makeRawSegmentViewVarHandleInternal(valueLayout, valueLayout, true, 0);\n+                }\n+            }\n+            return VarHandleCache.HANDLE_MAP.computeIfAbsent(direct.withoutName(), VarHandleCache.INSTANCE);\n@@ -109,2 +143,1 @@\n-        return VarHandleCache.HANDLE_MAP\n-                .computeIfAbsent(layout.withoutName(), Utils::makeRawSegmentViewVarHandleInternal);\n+        return makeRawSegmentViewVarHandleInternal(enclosing, layout, noStride, offset);\n@@ -113,1 +146,1 @@\n-    private static VarHandle makeRawSegmentViewVarHandleInternal(ValueLayout layout) {\n+    private static VarHandle makeRawSegmentViewVarHandleInternal(MemoryLayout enclosing, ValueLayout layout, boolean noStride, long offset) {\n@@ -121,2 +154,0 @@\n-        } else if (layout.carrier() == boolean.class) {\n-            baseCarrier = byte.class;\n@@ -126,1 +157,1 @@\n-                layout.byteAlignment() - 1, layout.order());\n+                enclosing, layout.byteAlignment() - 1, layout.order(), noStride, offset);\n@@ -128,3 +159,1 @@\n-        if (layout.carrier() == boolean.class) {\n-            handle = MethodHandles.filterValue(handle, BOOL_TO_BYTE, BYTE_TO_BOOL);\n-        } else if (layout instanceof AddressLayout addressLayout) {\n+        if (layout instanceof AddressLayout addressLayout) {\n@@ -132,3 +161,3 @@\n-                    MethodHandles.insertArguments(LONG_TO_ADDRESS_TARGET, 1, addressLayout) :\n-                    LONG_TO_ADDRESS_NO_TARGET;\n-            handle = MethodHandles.filterValue(handle, ADDRESS_TO_LONG, longToAddressAdapter);\n+                    MethodHandles.insertArguments(filterHandle(FILTER_LONG_TO_SEGMENT_WITH_LAYOUT), 1, addressLayout) :\n+                    filterHandle(FILTER_LONG_TO_POINTER);\n+            handle = MethodHandles.filterValue(handle, filterHandle(FILTER_ADDRESS_TO_LONG), longToAddressAdapter);\n@@ -152,0 +181,6 @@\n+    \/\/ 32 bit\n+    @ForceInline\n+    public static MemorySegment longToAddress(int addr) {\n+        return longToAddress(addr, 0, 1);\n+    }\n+\n@@ -157,0 +192,6 @@\n+    \/\/ 32 bit\n+    @ForceInline\n+    public static MemorySegment longToAddress(int addr, AddressLayout layout) {\n+        return longToAddress(addr, pointeeByteSize(layout), pointeeByteAlign(layout));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":83,"deletions":42,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -324,0 +324,1 @@\n+    @ForceInline\n@@ -329,0 +330,5 @@\n+    @ForceInline\n+    public static int unboxSegment32(MemorySegment segment) {\n+        return (int) unboxSegment(segment);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.LayoutPath;\n@@ -41,1 +42,0 @@\n-import java.util.Map;\n@@ -44,1 +44,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -162,2 +161,5 @@\n-            final class VarHandleCache {\n-                private static final Map<ValueLayout, VarHandle> HANDLE_MAP = new ConcurrentHashMap<>();\n+            var vh = handle;\n+            if (vh == null) {\n+                vh = varHandleInternal(LayoutPath.EMPTY_PATH_ELEMENTS);\n+                \/\/ benign race stable field store is safe because VarHandle is thread safe\n+                handle = vh;\n@@ -165,10 +167,1 @@\n-            if (handle == null) {\n-                \/\/ this store to stable field is safe, because return value of 'makeMemoryAccessVarHandle' has stable identity\n-                handle = VarHandleCache.HANDLE_MAP.computeIfAbsent(self().withoutName(), _ -> varHandleInternal());\n-            }\n-            return handle;\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        final V self() {\n-            return (V) this;\n+            return vh;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,3 @@\n+ * Some methods take no receiver argument. In these cases, the receiver is the\n+ * lookup class.\n+ * <p>\n@@ -66,0 +69,5 @@\n+    public static MethodHandle findVirtual(MethodHandles.Lookup lookup,\n+                                           String name,\n+                                           MethodType type) {\n+        return findVirtual(lookup, lookup.lookupClass(), name, type);\n+    }\n@@ -78,0 +86,17 @@\n+    public static MethodHandle findStatic(MethodHandles.Lookup lookup,\n+                                          String name,\n+                                          MethodType type) {\n+        return findStatic(lookup, lookup.lookupClass(), name, type);\n+    }\n+\n+    public static MethodHandle findStatic(MethodHandles.Lookup lookup,\n+                                          Class<?> refc,\n+                                          String name,\n+                                          MethodType type) {\n+        try {\n+            return lookup.findStatic(refc, name, type);\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/invoke\/MhUtil.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-public class ScopedMemoryAccess {\n+public final class ScopedMemoryAccess {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+        assertEquals(varHandle.isAccessModeSupported(mode), compatible);\n","filename":"test\/jdk\/java\/foreign\/TestAccessModes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}