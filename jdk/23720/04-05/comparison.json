{"files":[{"patch":"@@ -171,2 +171,0 @@\n-# TODO decide if CAS\/Bitwise\/AtomicAdd should be enabled for subints\n-# Remove comments # before $1_ARGS += below to enable them\n@@ -188,2 +186,0 @@\n-    # $1_ARGS += -KCAS\n-    # $1_ARGS += -KBitwise\n@@ -202,3 +198,0 @@\n-    # $1_ARGS += -KCAS\n-    # $1_ARGS += -KAtomicAdd\n-    # $1_ARGS += -KBitwise\n@@ -216,3 +209,0 @@\n-    # $1_ARGS += -KCAS\n-    # $1_ARGS += -KAtomicAdd\n-    # $1_ARGS += -KBitwise\n@@ -230,3 +220,0 @@\n-    # $1_ARGS += -KCAS\n-    # $1_ARGS += -KAtomicAdd\n-    # $1_ARGS += -KBitwise\n","filename":"make\/modules\/java.base\/gensrc\/GensrcVarHandles.gmk","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    \/** The fixed offset value, if exists. vform decides if the fixed offset is used. *\/\n+    \/** The offset value, if is constant. vform decides if offset is constant or variable. *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/SegmentVarHandle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-     * {@code (MS, long)} if {@code noStride}, {@code (MS, long, (unchecked) long)} otherwise.\n+     * {@code (MS, long)} if {@code constantOffset}, {@code (MS, long, (validated) long)} otherwise.\n@@ -301,1 +301,1 @@\n-     * If {@code noStride == false}, the resulting var handle will take a third unchecked additional\n+     * If {@code constantOffset == false}, the resulting var handle will take a third pre-validated additional\n@@ -309,1 +309,1 @@\n-     * @param offset the constant offset, if there is one\n+     * @param offset the offset value, if the offset is constant\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-        return constantOffset ? CONSTANT_OFFSET_FORM : TAKE_OFFSET_FORM;\n+        return constantOffset ? CONSTANT_OFFSET_FORM : VARIABLE_OFFSET_FORM;\n@@ -47,2 +47,2 @@\n-                (constantOffset ? CONSTANT_OFFSET_FORM : TAKE_OFFSET_FORM) :\n-                (constantOffset ? VarHandleSegmentAs$Type$sAligned.CONSTANT_OFFSET_FORM : VarHandleSegmentAs$Type$sAligned.TAKE_OFFSET_FORM);\n+                (constantOffset ? CONSTANT_OFFSET_FORM : VARIABLE_OFFSET_FORM) :\n+                (constantOffset ? VarHandleSegmentAs$Type$sAligned.CONSTANT_OFFSET_FORM : VarHandleSegmentAs$Type$sAligned.VARIABLE_OFFSET_FORM);\n@@ -53,1 +53,1 @@\n-    static final VarForm TAKE_OFFSET_FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, long.class, long.class);\n+    static final VarForm VARIABLE_OFFSET_FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, long.class, long.class);\n@@ -123,1 +123,1 @@\n-    static final VarForm TAKE_OFFSET_FORM = new VarForm(VarHandleSegmentAs$Type$sAligned.class, VarHandleSegmentAs$Type$s.TAKE_OFFSET_FORM);\n+    static final VarForm VARIABLE_OFFSET_FORM = new VarForm(VarHandleSegmentAs$Type$sAligned.class, VarHandleSegmentAs$Type$s.VARIABLE_OFFSET_FORM);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-        \/\/ (MS, long, long) if non-constant offset, (MS, long) if constant offset\n+        \/\/ (MS, long, long) if variable offset, (MS, long) if constant offset\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,3 +98,7 @@\n-     * This method returns a var handle that takes a memory segment and offset (MS, long). If it has strides, it also\n-     * takes a raw offset (MS, long, long), which the var handle does not perform any size or alignment checks against.\n-     * Such checks are added (using adaptation) by {@link LayoutPath#dereferenceHandle()}.\n+     * This method returns a var handle that accesses a target layout in an enclosing layout, taking the memory offset\n+     * and the base offset of the enclosing layout in the segment.\n+     * <p>\n+     * If the offset of the target layout in the enclosing layout is constant, the coordinates are (MS, long).\n+     * If the offset of the target layout in the enclosing layout is variable, the coordinates are (MS, long, long).\n+     * The trailing long is a pre-validated, variable extra offset, which the var handle does not perform any size or\n+     * alignment checks against. Such checks are added (using adaptation) by {@link LayoutPath#dereferenceHandle()}.\n@@ -110,1 +114,1 @@\n-     * @param constantOffset if the VH uses a constant offset instead of taking an offset\n+     * @param constantOffset if the VH carries a constant offset instead of taking a variable offset\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"}]}