{"files":[{"patch":"@@ -2,2 +2,2 @@\n- *  Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n@@ -5,5 +5,5 @@\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n@@ -11,5 +11,5 @@\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n@@ -17,7 +17,3 @@\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n@@ -25,0 +21,3 @@\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n@@ -31,1 +30,0 @@\n-import jdk.internal.invoke.MhUtil;\n@@ -34,1 +32,0 @@\n-import jdk.internal.vm.annotation.Stable;\n@@ -39,1 +36,0 @@\n-import java.lang.foreign.MemoryLayout.PathElement;\n@@ -62,13 +58,4 @@\n-    private static final int\n-            FILTER_ADDRESS_TO_LONG = 0,\n-            FILTER_LONG_TO_POINTER = 1,\n-            FILTER_LONG_TO_SEGMENT_WITH_LAYOUT = 2,\n-            FILTER_LIMIT = 3;\n-    private static final @Stable MethodHandle[] VH_FILTERS = new MethodHandle[FILTER_LIMIT];\n-\n-    private static MethodHandle filterHandle(int index) {\n-        var ret = VH_FILTERS[index];\n-        if (ret != null)\n-            return ret;\n-        return computeFilterHandle(index);\n-    }\n+    private static final Class<?> ADDRESS_CARRIER_TYPE;\n+    private static final MethodHandle LONG_TO_CARRIER;\n+    private static final MethodHandle LONG_TO_ADDRESS_TARGET;\n+    private static final MethodHandle LONG_TO_ADDRESS_NO_TARGET;\n@@ -76,1 +63,1 @@\n-    private static MethodHandle computeFilterHandle(int index) {\n+    static {\n@@ -78,1 +65,2 @@\n-        MethodHandle handle;\n+        String unboxSegmentName;\n+        Class<?> rawAddressType;\n@@ -80,9 +68,2 @@\n-            handle = switch (index) {\n-                case FILTER_ADDRESS_TO_LONG -> MhUtil.findStatic(lookup, SharedUtils.class, \"unboxSegment\",\n-                        MethodType.methodType(long.class, MemorySegment.class));\n-                case FILTER_LONG_TO_SEGMENT_WITH_LAYOUT -> MhUtil.findStatic(lookup, \"longToAddress\",\n-                        MethodType.methodType(MemorySegment.class, long.class, AddressLayout.class));\n-                case FILTER_LONG_TO_POINTER -> MhUtil.findStatic(lookup, \"longToAddress\",\n-                        MethodType.methodType(MemorySegment.class, long.class));\n-                default -> throw new IllegalArgumentException(String.valueOf(index));\n-            };\n+            unboxSegmentName = \"unboxSegment\";\n+            rawAddressType = long.class;\n@@ -90,9 +71,14 @@\n-            handle = switch (index) {\n-                case FILTER_ADDRESS_TO_LONG -> MhUtil.findStatic(lookup, SharedUtils.class, \"unboxSegment32\",\n-                        MethodType.methodType(int.class, MemorySegment.class));\n-                case FILTER_LONG_TO_SEGMENT_WITH_LAYOUT -> MhUtil.findStatic(lookup, \"longToAddress\",\n-                        MethodType.methodType(MemorySegment.class, int.class, AddressLayout.class));\n-                case FILTER_LONG_TO_POINTER -> MhUtil.findStatic(lookup, \"longToAddress\",\n-                        MethodType.methodType(MemorySegment.class, int.class));\n-                default -> throw new IllegalArgumentException(String.valueOf(index));\n-            };\n+            assert Unsafe.getUnsafe().addressSize() == 4 : Unsafe.getUnsafe().addressSize();\n+            unboxSegmentName = \"unboxSegment32\";\n+            rawAddressType = int.class;\n+        }\n+        ADDRESS_CARRIER_TYPE = rawAddressType;\n+        try {\n+            LONG_TO_CARRIER = lookup.findStatic(SharedUtils.class, unboxSegmentName,\n+                    MethodType.methodType(rawAddressType, MemorySegment.class));\n+            LONG_TO_ADDRESS_TARGET = lookup.findStatic(Utils.class, \"longToAddress\",\n+                    MethodType.methodType(MemorySegment.class, rawAddressType, AddressLayout.class));\n+            LONG_TO_ADDRESS_NO_TARGET = lookup.findStatic(Utils.class, \"longToAddress\",\n+                    MethodType.methodType(MemorySegment.class, rawAddressType));\n+        } catch (Throwable ex) {\n+            throw new ExceptionInInitializerError(ex);\n@@ -100,1 +86,0 @@\n-        return VH_FILTERS[index] = handle;\n@@ -149,5 +134,1 @@\n-            baseCarrier = switch ((int) ValueLayout.ADDRESS.byteSize()) {\n-                case Long.BYTES -> long.class;\n-                case Integer.BYTES -> int.class;\n-                default -> throw new UnsupportedOperationException(\"Unsupported address layout\");\n-            };\n+            baseCarrier = ADDRESS_CARRIER_TYPE;\n@@ -161,3 +142,3 @@\n-                    MethodHandles.insertArguments(filterHandle(FILTER_LONG_TO_SEGMENT_WITH_LAYOUT), 1, addressLayout) :\n-                    filterHandle(FILTER_LONG_TO_POINTER);\n-            handle = MethodHandles.filterValue(handle, filterHandle(FILTER_ADDRESS_TO_LONG), longToAddressAdapter);\n+                    MethodHandles.insertArguments(LONG_TO_ADDRESS_TARGET, 1, addressLayout) :\n+                    LONG_TO_ADDRESS_NO_TARGET;\n+            handle = MethodHandles.filterValue(handle, LONG_TO_CARRIER, longToAddressAdapter);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":45,"deletions":64,"binary":false,"changes":109,"status":"modified"}]}