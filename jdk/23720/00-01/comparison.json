{"files":[{"patch":"@@ -172,0 +172,1 @@\n+# Remove comments # before $1_ARGS += below to enable them\n@@ -187,2 +188,2 @@\n-    #$1_ARGS += -KCAS\n-    #$1_ARGS += -KBitwise\n+    # $1_ARGS += -KCAS\n+    # $1_ARGS += -KBitwise\n@@ -201,3 +202,3 @@\n-    #$1_ARGS += -KCAS\n-    #$1_ARGS += -KAtomicAdd\n-    #$1_ARGS += -KBitwise\n+    # $1_ARGS += -KCAS\n+    # $1_ARGS += -KAtomicAdd\n+    # $1_ARGS += -KBitwise\n@@ -215,3 +216,3 @@\n-    #$1_ARGS += -KCAS\n-    #$1_ARGS += -KAtomicAdd\n-    #$1_ARGS += -KBitwise\n+    # $1_ARGS += -KCAS\n+    # $1_ARGS += -KAtomicAdd\n+    # $1_ARGS += -KBitwise\n@@ -229,3 +230,3 @@\n-    #$1_ARGS += -KCAS\n-    #$1_ARGS += -KAtomicAdd\n-    #$1_ARGS += -KBitwise\n+    # $1_ARGS += -KCAS\n+    # $1_ARGS += -KAtomicAdd\n+    # $1_ARGS += -KBitwise\n","filename":"make\/modules\/java.base\/gensrc\/GensrcVarHandles.gmk","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1556,2 +1556,2 @@\n-            public VarHandle memorySegmentViewHandle(Class<?> carrier, MemoryLayout enclosing, long alignmentMask, ByteOrder order, boolean fixedOffset, long offset) {\n-                return VarHandles.memorySegmentViewHandle(carrier, enclosing, alignmentMask, fixedOffset, offset, order);\n+            public VarHandle memorySegmentViewHandle(Class<?> carrier, MemoryLayout enclosing, long alignmentMask, ByteOrder order, boolean noStride, long offset) {\n+                return VarHandles.memorySegmentViewHandle(carrier, enclosing, alignmentMask, noStride, offset, order);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.invoke;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.util.Objects;\n+\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * A var handle that accesses primitive values in a memory segment.\n+ *\/\n+final class SegmentVarHandle extends VarHandle {\n+\n+    \/\/ Common implementation fields for the VarForms\n+    static final boolean BE = MethodHandleStatics.UNSAFE.isBigEndian();\n+    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n+    \/** endianness **\/\n+    final boolean be;\n+    \/** The layout the accessed segment must be compatible with. *\/\n+    final MemoryLayout enclosing;\n+    \/** The fixed offset value, if exists. vform decides if the fixed offset is used. *\/\n+    final long offset;\n+\n+    SegmentVarHandle(VarForm form, boolean be, MemoryLayout enclosing, long offset, boolean exact) {\n+        super(form, exact);\n+        this.be = be;\n+        this.enclosing = enclosing;\n+        this.offset = offset;\n+    }\n+\n+    @Override\n+    final MethodType accessModeTypeUncached(VarHandle.AccessType accessType) {\n+        var getType = vform.methodType_table[0]; \/\/ erased, but our value type is erase-compatible\n+        return getType.parameterCount() == 2\n+                ? accessType.accessModeType(MemorySegment.class, getType.returnType(), long.class)\n+                : accessType.accessModeType(MemorySegment.class, getType.returnType(), long.class, long.class);\n+    }\n+\n+    @Override\n+    public SegmentVarHandle withInvokeExactBehavior() {\n+        return hasInvokeExactBehavior() ?\n+                this :\n+                new SegmentVarHandle(vform, be, enclosing, offset, true);\n+    }\n+\n+    @Override\n+    public SegmentVarHandle withInvokeBehavior() {\n+        return !hasInvokeExactBehavior() ?\n+                this :\n+                new SegmentVarHandle(vform, be, enclosing, offset, false);\n+    }\n+\n+    \/\/ Common implementation methods for the VarForms\n+\n+    @ForceInline\n+    static long offset(AbstractMemorySegmentImpl bb, long base, long offset) {\n+        long segment_base = bb.unsafeGetOffset();\n+        return segment_base + base + offset;\n+    }\n+\n+    @ForceInline\n+    AbstractMemorySegmentImpl checkSegment(Object obb, long base, boolean ro) {\n+        AbstractMemorySegmentImpl oo = (AbstractMemorySegmentImpl) Objects.requireNonNull(obb);\n+        oo.checkEnclosingLayout(base, this.enclosing, ro);\n+        return oo;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/SegmentVarHandle.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-        \/\/ methodTypeSource already called initMethodTypes\n+        \/\/ reuse initMethodTypes result from methodTypeSource\n@@ -74,0 +74,1 @@\n+        assert assertMethodTypeTableInitialized() : implClass;\n@@ -116,0 +117,9 @@\n+    private boolean assertMethodTypeTableInitialized() {\n+        if (methodType_table == null)\n+            return false;\n+        for (int i = 0; i < VarHandle.AccessType.COUNT; i++) {\n+            assert methodType_table[i] != null : implClass + \" \" + VarHandle.AccessType.values()[i];\n+        }\n+        return true;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarForm.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -475,2 +475,1 @@\n-     permits IndirectVarHandle, LazyInitializingVarHandle,\n-             VarHandleSegmentViewBase,\n+     permits IndirectVarHandle, LazyInitializingVarHandle, SegmentVarHandle,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.invoke;\n-\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-\n-\/**\n- * Base class for memory segment var handle view implementations.\n- *\/\n-final class VarHandleSegmentViewBase extends VarHandle {\n-\n-    \/** endianness **\/\n-    final boolean be;\n-    \/** The layout the accessed segment must be compatible with. *\/\n-    final MemoryLayout enclosing;\n-    \/** The fixed offset value, if exists *\/\n-    final long offset;\n-\n-    VarHandleSegmentViewBase(VarForm form, boolean be, MemoryLayout enclosing, long offset, boolean exact) {\n-        super(form, exact);\n-        this.be = be;\n-        this.enclosing = enclosing;\n-        this.offset = offset;\n-    }\n-\n-    @Override\n-    final MethodType accessModeTypeUncached(VarHandle.AccessType accessType) {\n-        var getType = vform.methodType_table[0]; \/\/ erased, but our value type is erase-compatible\n-        return getType.parameterCount() == 2\n-                ? accessType.accessModeType(MemorySegment.class, getType.returnType(), long.class)\n-                : accessType.accessModeType(MemorySegment.class, getType.returnType(), long.class, long.class);\n-    }\n-\n-    @Override\n-    public VarHandleSegmentViewBase withInvokeExactBehavior() {\n-        return hasInvokeExactBehavior() ?\n-                this :\n-                new VarHandleSegmentViewBase(vform, be, enclosing, offset, true);\n-    }\n-\n-    @Override\n-    public VarHandleSegmentViewBase withInvokeBehavior() {\n-        return !hasInvokeExactBehavior() ?\n-                this :\n-                new VarHandleSegmentViewBase(vform, be, enclosing, offset, false);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleSegmentViewBase.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -295,2 +295,3 @@\n-     * Creates a memory segment view var handle.\n-     *\n+     * Creates a memory segment view var handle accessing a {@code carrier} element. It has access coordinates\n+     * {@code (MS, long)} if {@code noStride}, {@code (MS, long, (unchecked) long)} otherwise.\n+     * <p>\n@@ -298,4 +299,5 @@\n-     * and a {@code long} as second argument (the offset into the segment).\n-     *\n-     * Note: the returned var handle does not perform any size or alignment check. It is up to clients\n-     * to adapt the returned var handle and insert the appropriate checks.\n+     * and a {@code long} as second argument (the offset into the segment). Both arguments are checked.\n+     * <p>\n+     * If {@code noStride == false}, the resulting var handle will take a third unchecked additional\n+     * offset instead of the given fixed {@code offset}, and caller must ensure that passed additional offset,\n+     * either to the handle (such as computing through method handles) or as fixed {@code offset} here, is valid.\n@@ -303,4 +305,7 @@\n-     * @param carrier the Java carrier type.\n-     * @param alignmentMask alignment requirement to be checked upon access. In bytes. Expressed as a mask.\n-     * @param byteOrder the byte order.\n-     * @return the created VarHandle.\n+     * @param carrier the Java carrier type of the element\n+     * @param enclosing the enclosing layout to perform bound and alignment checks against\n+     * @param alignmentMask alignment of this accessed element in the enclosing layout\n+     * @param noStride if access path to this element has no stride; we can use fixed offset if there is none\n+     * @param offset the fixed offset, if there is no strides\n+     * @param byteOrder the byte order\n+     * @return the created var handle\n@@ -309,1 +314,1 @@\n-                                             boolean fixedOffset, long offset, ByteOrder byteOrder) {\n+                                             boolean noStride, long offset, ByteOrder byteOrder) {\n@@ -319,1 +324,1 @@\n-            form = VarHandleSegmentAsBytes.selectForm(alignmentMask, fixedOffset);\n+            form = VarHandleSegmentAsBytes.selectForm(alignmentMask, noStride);\n@@ -321,1 +326,1 @@\n-            form = VarHandleSegmentAsChars.selectForm(alignmentMask, fixedOffset);\n+            form = VarHandleSegmentAsChars.selectForm(alignmentMask, noStride);\n@@ -323,1 +328,1 @@\n-            form = VarHandleSegmentAsShorts.selectForm(alignmentMask, fixedOffset);\n+            form = VarHandleSegmentAsShorts.selectForm(alignmentMask, noStride);\n@@ -325,1 +330,1 @@\n-            form = VarHandleSegmentAsInts.selectForm(alignmentMask, fixedOffset);\n+            form = VarHandleSegmentAsInts.selectForm(alignmentMask, noStride);\n@@ -327,1 +332,1 @@\n-            form = VarHandleSegmentAsFloats.selectForm(alignmentMask, fixedOffset);\n+            form = VarHandleSegmentAsFloats.selectForm(alignmentMask, noStride);\n@@ -329,1 +334,1 @@\n-            form = VarHandleSegmentAsLongs.selectForm(alignmentMask, fixedOffset);\n+            form = VarHandleSegmentAsLongs.selectForm(alignmentMask, noStride);\n@@ -331,1 +336,1 @@\n-            form = VarHandleSegmentAsDoubles.selectForm(alignmentMask, fixedOffset);\n+            form = VarHandleSegmentAsDoubles.selectForm(alignmentMask, noStride);\n@@ -333,1 +338,1 @@\n-            form = VarHandleSegmentAsBooleans.selectForm(alignmentMask, fixedOffset);\n+            form = VarHandleSegmentAsBooleans.selectForm(alignmentMask, noStride);\n@@ -338,1 +343,1 @@\n-        return maybeAdapt(new VarHandleSegmentViewBase(form, be, enclosing, offset, exact));\n+        return maybeAdapt(new SegmentVarHandle(form, be, enclosing, offset, exact));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":25,"deletions":20,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.misc.ScopedMemoryAccess;\n@@ -32,1 +30,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -34,1 +31,0 @@\n-import java.lang.ref.Reference;\n@@ -36,3 +32,1 @@\n-import java.util.Objects;\n-\n-import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n+import static java.lang.invoke.SegmentVarHandle.*;\n@@ -48,1 +42,1 @@\n-    static VarForm selectForm(long alignmentMask, boolean fixedOffset) {\n+    static VarForm selectForm(long alignmentMask, boolean noStride) {\n@@ -50,1 +44,1 @@\n-        return fixedOffset ? Unaligned.FORM : Unaligned.OFFSET_FORM;\n+        return noStride ? Unaligned.FORM : Unaligned.OFFSET_FORM;\n@@ -53,2 +47,2 @@\n-                (fixedOffset ? Unaligned.FORM : Unaligned.OFFSET_FORM) :\n-                (fixedOffset ? Aligned.FORM : Aligned.OFFSET_FORM);\n+                (noStride ? Unaligned.FORM : Unaligned.OFFSET_FORM) :\n+                (noStride ? Aligned.FORM : Aligned.OFFSET_FORM);\n@@ -60,6 +54,0 @@\n-#if[!byte]\n-        static final boolean BE = UNSAFE.isBigEndian();\n-\n-#end[byte]\n-        static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n-\n@@ -71,13 +59,0 @@\n-        @ForceInline\n-        static long offset(AbstractMemorySegmentImpl bb, long base, long offset) {\n-            long segment_base = bb.unsafeGetOffset();\n-            return segment_base + base + offset;\n-        }\n-\n-        @ForceInline\n-        static AbstractMemorySegmentImpl checkSegment(Object obb, VarHandleSegmentViewBase handle, long base, boolean ro) {\n-            AbstractMemorySegmentImpl oo = (AbstractMemorySegmentImpl)Objects.requireNonNull(obb);\n-            oo.checkEnclosingLayout(base, handle.enclosing, ro);\n-            return oo;\n-        }\n-\n@@ -86,1 +61,1 @@\n-            return get(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset);\n+            return get(ob, obb, base, ((SegmentVarHandle) ob).offset);\n@@ -91,2 +66,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, true);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, true);\n@@ -115,1 +90,1 @@\n-            set(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, value);\n+            set(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -120,2 +95,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -182,1 +157,1 @@\n-            return getVolatile(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset);\n+            return getVolatile(ob, obb, base, ((SegmentVarHandle) ob).offset);\n@@ -187,2 +162,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, true);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, true);\n@@ -197,1 +172,1 @@\n-            setVolatile(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, value);\n+            setVolatile(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -202,2 +177,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -212,1 +187,1 @@\n-            return getAcquire(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset);\n+            return getAcquire(ob, obb, base, ((SegmentVarHandle) ob).offset);\n@@ -217,2 +192,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, true);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, true);\n@@ -227,1 +202,1 @@\n-            setRelease(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, value);\n+            setRelease(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -232,2 +207,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -242,1 +217,1 @@\n-            return getOpaque(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset);\n+            return getOpaque(ob, obb, base, ((SegmentVarHandle) ob).offset);\n@@ -247,2 +222,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, true);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, true);\n@@ -257,1 +232,1 @@\n-            setOpaque(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, value);\n+            setOpaque(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -262,2 +237,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -273,1 +248,1 @@\n-            return compareAndSet(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, expected, value);\n+            return compareAndSet(ob, obb, base, ((SegmentVarHandle) ob).offset, expected, value);\n@@ -278,2 +253,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -288,1 +263,1 @@\n-            return compareAndExchange(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, expected, value);\n+            return compareAndExchange(ob, obb, base, ((SegmentVarHandle) ob).offset, expected, value);\n@@ -293,2 +268,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -304,1 +279,1 @@\n-            return compareAndExchangeAcquire(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, expected, value);\n+            return compareAndExchangeAcquire(ob, obb, base, ((SegmentVarHandle) ob).offset, expected, value);\n@@ -309,2 +284,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -320,1 +295,1 @@\n-            return compareAndExchangeRelease(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, expected, value);\n+            return compareAndExchangeRelease(ob, obb, base, ((SegmentVarHandle) ob).offset, expected, value);\n@@ -325,2 +300,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -336,1 +311,1 @@\n-            return weakCompareAndSetPlain(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, expected, value);\n+            return weakCompareAndSetPlain(ob, obb, base, ((SegmentVarHandle) ob).offset, expected, value);\n@@ -341,2 +316,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -351,1 +326,1 @@\n-            return weakCompareAndSet(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, expected, value);\n+            return weakCompareAndSet(ob, obb, base, ((SegmentVarHandle) ob).offset, expected, value);\n@@ -356,2 +331,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -366,1 +341,1 @@\n-            return weakCompareAndSetAcquire(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, expected, value);\n+            return weakCompareAndSetAcquire(ob, obb, base, ((SegmentVarHandle) ob).offset, expected, value);\n@@ -371,2 +346,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -381,1 +356,1 @@\n-            return weakCompareAndSetRelease(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, expected, value);\n+            return weakCompareAndSetRelease(ob, obb, base, ((SegmentVarHandle) ob).offset, expected, value);\n@@ -386,2 +361,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -396,1 +371,1 @@\n-            return getAndSet(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, value);\n+            return getAndSet(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -401,2 +376,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -412,1 +387,1 @@\n-            return getAndSetAcquire(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, value);\n+            return getAndSetAcquire(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -417,2 +392,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -428,1 +403,1 @@\n-            return getAndSetRelease(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, value);\n+            return getAndSetRelease(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -433,2 +408,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -446,1 +421,1 @@\n-            return getAndAdd(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, value);\n+            return getAndAdd(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -451,2 +426,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -469,1 +444,1 @@\n-            return getAndAddAcquire(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, value);\n+            return getAndAddAcquire(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -474,2 +449,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -492,1 +467,1 @@\n-            return getAndAddRelease(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, value);\n+            return getAndAddRelease(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -497,2 +472,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -531,1 +506,1 @@\n-            return getAndBitwiseOr(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, value);\n+            return getAndBitwiseOr(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -536,2 +511,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -554,1 +529,1 @@\n-            return getAndBitwiseOrRelease(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, value);\n+            return getAndBitwiseOrRelease(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -559,2 +534,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -577,1 +552,1 @@\n-            return getAndBitwiseOrAcquire(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, value);\n+            return getAndBitwiseOrAcquire(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -582,2 +557,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -614,1 +589,1 @@\n-            return getAndBitwiseAnd(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, value);\n+            return getAndBitwiseAnd(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -619,2 +594,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -637,1 +612,1 @@\n-            return getAndBitwiseAndRelease(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, value);\n+            return getAndBitwiseAndRelease(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -642,2 +617,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -660,1 +635,1 @@\n-            return getAndBitwiseAndAcquire(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, value);\n+            return getAndBitwiseAndAcquire(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -666,2 +641,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -698,1 +673,1 @@\n-            return getAndBitwiseXor(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, value);\n+            return getAndBitwiseXor(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -703,2 +678,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -721,1 +696,1 @@\n-            return getAndBitwiseXorRelease(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, value);\n+            return getAndBitwiseXorRelease(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -726,2 +701,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n@@ -744,1 +719,1 @@\n-            return getAndBitwiseXorAcquire(ob, obb, base, ((VarHandleSegmentViewBase) ob).offset, value);\n+            return getAndBitwiseXorAcquire(ob, obb, base, ((SegmentVarHandle) ob).offset, value);\n@@ -749,2 +724,2 @@\n-            VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n-            AbstractMemorySegmentImpl bb = checkSegment(obb, handle, base, false);\n+            SegmentVarHandle handle = (SegmentVarHandle)ob;\n+            AbstractMemorySegmentImpl bb = handle.checkSegment(obb, base, false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":99,"deletions":124,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-    VarHandle memorySegmentViewHandle(Class<?> carrier, MemoryLayout enclosing, long alignmentMask, ByteOrder order, boolean fixedOffset, long offset);\n+    VarHandle memorySegmentViewHandle(Class<?> carrier, MemoryLayout enclosing, long alignmentMask, ByteOrder order, boolean noStride, long offset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -209,4 +209,5 @@\n-        \/\/ (MS, long, long) if has strides, (MS, long) if no stride\n-        VarHandle handle = Utils.makeRawSegmentViewVarHandle(rootLayout(), valueLayout, strides.length == 0, offset);\n-        if (strides.length > 0) {\n-            MethodHandle offsetAdapter = offsetHandle();\n+        boolean noStride = strides.length == 0;\n+        \/\/ (MS, long, long) if any stride, (MS, long) if no stride\n+        VarHandle handle = Utils.makeRawSegmentViewVarHandle(rootLayout(), valueLayout, noStride, offset);\n+        if (!noStride) {\n+            MethodHandle offsetAdapter = offsetHandle();  \/\/ Adapter performs the bound checks\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -78,17 +78,23 @@\n-        return VH_FILTERS[index] = Unsafe.getUnsafe().addressSize() != 4 ? switch (index) {\n-            case FILTER_ADDRESS_TO_LONG -> MhUtil.findStatic(lookup, SharedUtils.class, \"unboxSegment\",\n-                            MethodType.methodType(long.class, MemorySegment.class));\n-            case FILTER_LONG_TO_SEGMENT_WITH_LAYOUT -> MhUtil.findStatic(lookup, \"longToAddress\",\n-                            MethodType.methodType(MemorySegment.class, long.class, AddressLayout.class));\n-            case FILTER_LONG_TO_POINTER -> MhUtil.findStatic(lookup, \"longToAddress\",\n-                            MethodType.methodType(MemorySegment.class, long.class));\n-            default -> throw new IllegalArgumentException(String.valueOf(index));\n-        } : switch (index) {\n-            case FILTER_ADDRESS_TO_LONG -> MhUtil.findStatic(lookup, SharedUtils.class, \"unboxSegment32\",\n-                            MethodType.methodType(int.class, MemorySegment.class));\n-            case FILTER_LONG_TO_SEGMENT_WITH_LAYOUT -> MhUtil.findStatic(lookup, \"longToAddress\",\n-                            MethodType.methodType(MemorySegment.class, int.class, AddressLayout.class));\n-            case FILTER_LONG_TO_POINTER -> MhUtil.findStatic(lookup, \"longToAddress\",\n-                            MethodType.methodType(MemorySegment.class, int.class));\n-            default -> throw new IllegalArgumentException(String.valueOf(index));\n-        };\n+        MethodHandle handle;\n+        if (Unsafe.getUnsafe().addressSize() == 8) {\n+            handle = switch (index) {\n+                case FILTER_ADDRESS_TO_LONG -> MhUtil.findStatic(lookup, SharedUtils.class, \"unboxSegment\",\n+                        MethodType.methodType(long.class, MemorySegment.class));\n+                case FILTER_LONG_TO_SEGMENT_WITH_LAYOUT -> MhUtil.findStatic(lookup, \"longToAddress\",\n+                        MethodType.methodType(MemorySegment.class, long.class, AddressLayout.class));\n+                case FILTER_LONG_TO_POINTER -> MhUtil.findStatic(lookup, \"longToAddress\",\n+                        MethodType.methodType(MemorySegment.class, long.class));\n+                default -> throw new IllegalArgumentException(String.valueOf(index));\n+            };\n+        } else {\n+            handle = switch (index) {\n+                case FILTER_ADDRESS_TO_LONG -> MhUtil.findStatic(lookup, SharedUtils.class, \"unboxSegment32\",\n+                        MethodType.methodType(int.class, MemorySegment.class));\n+                case FILTER_LONG_TO_SEGMENT_WITH_LAYOUT -> MhUtil.findStatic(lookup, \"longToAddress\",\n+                        MethodType.methodType(MemorySegment.class, int.class, AddressLayout.class));\n+                case FILTER_LONG_TO_POINTER -> MhUtil.findStatic(lookup, \"longToAddress\",\n+                        MethodType.methodType(MemorySegment.class, int.class));\n+                default -> throw new IllegalArgumentException(String.valueOf(index));\n+            };\n+        }\n+        return VH_FILTERS[index] = handle;\n@@ -107,2 +113,3 @@\n-     * This method returns a <em>raw var handle<\/em>, that is, a var handle that does not perform any size\n-     * or alignment checks. Such checks are added (using adaptation) by {@link LayoutPath#dereferenceHandle()}.\n+     * This method returns a var handle that takes a memory segment and offset (MS, long). If it has strides, it also\n+     * takes a raw offset (MS, long, long), which the var handle does not perform any size or alignment checks against.\n+     * Such checks are added (using adaptation) by {@link LayoutPath#dereferenceHandle()}.\n@@ -113,2 +120,2 @@\n-     * is then provided by this method: after all, var handles constructed by {@link MemoryLayout#varHandle(PathElement...)}\n-     * will be obtained by adapting some raw var handle generated by this method.\n+     * is then provided by this method, so different value layouts with same effects can reuse var handle instances.\n+     * (The 2nd layer may be redundant in the long run)\n@@ -116,2 +123,5 @@\n-     * @param layout the value layout for which a raw memory segment var handle is to be created.\n-     * @return a raw memory segment var handle.\n+     * @param enclosing the enclosing context of the value layout\n+     * @param layout the value layout for which a raw memory segment var handle is to be created\n+     * @param noStride if there is no stride, the VH uses the fixed offset instead of taking an offset\n+     * @param offset the offset in case there is no stride\n+     * @return a raw memory segment var handle\n@@ -119,1 +129,1 @@\n-    public static VarHandle makeRawSegmentViewVarHandle(MemoryLayout enclosing, ValueLayout layout, boolean fixedOffset, long offset) {\n+    public static VarHandle makeRawSegmentViewVarHandle(MemoryLayout enclosing, ValueLayout layout, boolean noStride, long offset) {\n@@ -121,1 +131,1 @@\n-            assert direct.equals(layout) && fixedOffset && offset == 0;\n+            assert direct.equals(layout) && noStride && offset == 0;\n@@ -133,1 +143,1 @@\n-        return makeRawSegmentViewVarHandleInternal(enclosing, layout, fixedOffset, offset);\n+        return makeRawSegmentViewVarHandleInternal(enclosing, layout, noStride, offset);\n@@ -136,1 +146,1 @@\n-    private static VarHandle makeRawSegmentViewVarHandleInternal(MemoryLayout enclosing, ValueLayout layout, boolean fixedOffset, long offset) {\n+    private static VarHandle makeRawSegmentViewVarHandleInternal(MemoryLayout enclosing, ValueLayout layout, boolean noStride, long offset) {\n@@ -147,1 +157,1 @@\n-                enclosing, layout.byteAlignment() - 1, layout.order(), fixedOffset, offset);\n+                enclosing, layout.byteAlignment() - 1, layout.order(), noStride, offset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":38,"deletions":28,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n-import java.util.Map;\n@@ -45,2 +44,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.function.Function;\n@@ -164,8 +161,5 @@\n-            record VarHandleCache() implements Function<AbstractValueLayout<?>, VarHandle> {\n-                private static final Map<AbstractValueLayout<?>, VarHandle> HANDLE_MAP = new ConcurrentHashMap<>();\n-                private static final VarHandleCache INSTANCE = new VarHandleCache();\n-\n-                @Override\n-                public VarHandle apply(AbstractValueLayout<?> abstractValueLayout) {\n-                    return abstractValueLayout.varHandleInternal(LayoutPath.EMPTY_PATH_ELEMENTS);\n-                }\n+            var vh = handle;\n+            if (vh == null) {\n+                vh = varHandleInternal(LayoutPath.EMPTY_PATH_ELEMENTS);\n+                \/\/ benign race stable field store is safe because VarHandle is thread safe\n+                handle = vh;\n@@ -173,5 +167,1 @@\n-            if (handle == null) {\n-                \/\/ this store to stable field is safe, because return value of 'makeMemoryAccessVarHandle' has stable identity\n-                handle = VarHandleCache.HANDLE_MAP.computeIfAbsent(withoutName(), VarHandleCache.INSTANCE);\n-            }\n-            return handle;\n+            return vh;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,3 @@\n+ * Some methods take no receiver argument. In these cases, the receiver is the\n+ * lookup class.\n+ * <p>\n@@ -66,0 +69,5 @@\n+    public static MethodHandle findVirtual(MethodHandles.Lookup lookup,\n+                                           String name,\n+                                           MethodType type) {\n+        return findVirtual(lookup, lookup.lookupClass(), name, type);\n+    }\n@@ -78,0 +86,6 @@\n+    public static MethodHandle findStatic(MethodHandles.Lookup lookup,\n+                                          String name,\n+                                          MethodType type) {\n+        return findStatic(lookup, lookup.lookupClass(), name, type);\n+    }\n+\n@@ -89,6 +103,0 @@\n-    public static MethodHandle findStatic(MethodHandles.Lookup lookup,\n-                                          String name,\n-                                          MethodType type) {\n-        return findStatic(lookup, lookup.lookupClass(), name, type);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/invoke\/MhUtil.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"}]}