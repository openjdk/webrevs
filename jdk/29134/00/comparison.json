{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2485,0 +2485,5 @@\n+  \/\/ Since casts specifically change the type of a node, stay on the safe side and do not truncate them.\n+  if (in->is_ConstraintCast()) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -482,0 +482,26 @@\n+    @Test\n+    @IR(counts = { IRNode.CAST_II, \">0\" })\n+    @Warmup(0)\n+    public Object[] testCastII() {\n+        byte[] bytes = new byte[400];\n+        intField = 6;\n+        int i = 0;\n+        int j = 1;\n+\n+        do {\n+            bytes[j] = (byte) i;\n+            int k = 1;\n+\n+            do {\n+                i <<= intField;\n+                i += (k ^ i);\n+                i -= j;\n+\n+                for (int u = 1; 1 > u; u++) {\n+                }\n+            } while (++k < 8);\n+        } while (++j < 191);\n+\n+        return new Object[] { bytes };\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestSubwordTruncation.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"}]}