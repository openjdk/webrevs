{"files":[{"patch":"@@ -393,0 +393,1 @@\n+  GrowableArray<oop> lock_order{0};\n@@ -404,0 +405,5 @@\n+      if (LockingMode == LM_LIGHTWEIGHT && !realloc_failures) {\n+        for (MonitorInfo* mi : *monitors) {\n+          lock_order.push(mi->owner());\n+        }\n+      }\n@@ -434,0 +440,5 @@\n+#ifndef PRODUCT\n+  if (LockingMode == LM_LIGHTWEIGHT && !realloc_failures) {\n+    deoptee_thread->lock_stack().verify_consistent_lock_order(lock_order, exec_mode != Deoptimization::Unpack_none);\n+  }\n+#endif \/\/ !PRODUCT\n@@ -1645,1 +1656,1 @@\n-        if (LockingMode == LM_LIGHTWEIGHT && exec_mode == Unpack_none) {\n+        if (LockingMode == LM_LIGHTWEIGHT) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -38,0 +39,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -39,0 +41,2 @@\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -100,0 +104,52 @@\n+\n+void LockStack::verify_consistent_lock_order(GrowableArray<oop>& lock_order, bool leaf_frame) const {\n+  int top_index = to_index(_top);\n+  int lock_index = lock_order.length();\n+\n+  if (!leaf_frame) {\n+    \/\/ If the lock_order is not from the leaf frame we must search\n+    \/\/ for the top_index which fits with the most recent fast_locked\n+    \/\/ objects in the lock stack.\n+    while (lock_index-- > 0) {\n+      const oop obj = lock_order.at(lock_index);\n+      if (contains(obj)) {\n+        for (int index = 0; index < top_index; index++) {\n+          if (_base[index] == obj) {\n+            \/\/ Found top index\n+            top_index = index + 1;\n+            break;\n+          }\n+        }\n+\n+        if (VM_Version::supports_recursive_lightweight_locking()) {\n+          \/\/ With recursive looks there may be more of the same object\n+          while (lock_index-- > 0 && lock_order.at(lock_index) == obj) {\n+            top_index++;\n+          }\n+          assert(top_index <= to_index(_top), \"too many obj in lock_order\");\n+        }\n+\n+        break;\n+      }\n+    }\n+\n+    lock_index = lock_order.length();\n+  }\n+\n+  while (lock_index-- > 0) {\n+    const oop obj = lock_order.at(lock_index);\n+    const markWord mark = obj->mark_acquire();\n+    assert(obj->is_locked(), \"must be locked\");\n+    if (top_index > 0 && obj == _base[top_index - 1]) {\n+      assert(mark.is_fast_locked() || mark.monitor()->is_owner_anonymous(),\n+             \"must be fast_locked or inflated by other thread\");\n+      top_index--;\n+    } else {\n+      assert(!mark.is_fast_locked(), \"must be inflated\");\n+      assert(mark.monitor()->owner_raw() == get_thread() ||\n+             (!leaf_frame && get_thread()->current_waiting_monitor() == mark.monitor()),\n+             \"must be owned by (or waited on by) thread\");\n+      assert(!contains(obj), \"must not be on lock_stack\");\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+template<typename>\n+class GrowableArray;\n@@ -122,0 +124,3 @@\n+\n+  \/\/ Verify Lock Stack consistent with lock order\n+  void verify_consistent_lock_order(GrowableArray<oop>& lock_order, bool leaf_frame) const PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8329757\n+ * @summary Deoptimization with nested eliminated and not eliminated locks\n+ *          caused reordered lock stacks. This can be handled by the interpreter\n+ *          but when a frame is migrated back to compiled code via OSR the C2\n+ *          assumption about balanced monitorenter-monitorexit is broken.\n+ *\n+ * @requires vm.compMode != \"Xint\"\n+ *\n+ * @run main\/othervm compiler.escapeAnalysis.Test8329757\n+ *\/\n+\n+package compiler.escapeAnalysis;\n+\n+public class Test8329757 {\n+\n+    int a = 400;\n+    Double ddd;\n+\n+    void q() {\n+        int e;\n+        synchronized (new Double(1.1f)) {\n+        int[] f = new int[a];\n+        synchronized (Test8329757.class) {\n+            for (int d = 4; d < 127; d++) {\n+            e = 13;\n+            do switch (d * 5) {\n+                case 0:\n+                case 42:\n+                case 29:\n+                e = d;\n+                default:\n+                f[1] = e;\n+            } while (--e > 0);\n+            }\n+        }\n+        }\n+    }\n+\n+    void n() {\n+        for (int j = 6; j < 274; ++j) q();\n+    }\n+\n+    public static void main(String[] args) {\n+        Test8329757 r = new Test8329757();\n+        for (int i = 0; i < 1000; i++) r.n();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/Test8329757.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}