{"files":[{"patch":"@@ -444,1 +444,1 @@\n-  TEST_VM(os, release_multi_mappings) {\n+TEST_VM(os, release_multi_mappings) {\n@@ -452,2 +452,20 @@\n-  const size_t stripe_len = 4 * M;\n-  const int num_stripes = 4;\n+  \/\/ What we do:\n+  \/\/ A) we reserve 6 small segments (stripes) adjacent to each other. We commit\n+  \/\/    them with alternating permissions to prevent the kernel from folding them into\n+  \/\/    a single segment.\n+  \/\/    -stripe-stripe-stripe-stripe-stripe-stripe-\n+  \/\/ B) we release the middle four stripes with a single os::release_memory call. This\n+  \/\/    tests that os::release_memory indeed works across multiple segments created with\n+  \/\/    multiple os::reserve calls.\n+  \/\/    -stripe-___________________________-stripe-\n+  \/\/ C) Into the now vacated address range between the first and the last stripe, we\n+  \/\/    re-reserve a new memory range. We expect this to work as a proof that the address\n+  \/\/    range was really released by the single release call (B).\n+  \/\/\n+  \/\/ Note that this is inherently racy. Between (B) and (C), some other thread may have\n+  \/\/  reserved something into the hole in the meantime. Therefore we keep that range small and\n+  \/\/  entrenched between the first and last stripe, which reduces the chance of some concurrent\n+  \/\/  thread grabbing that memory.\n+\n+  const size_t stripe_len = os::vm_allocation_granularity();\n+  const int num_stripes = 6;\n@@ -461,1 +479,3 @@\n-  \/\/ .. release it...\n+  \/\/ .. release the middle stripes...\n+  address p_middle_stripes = p + stripe_len;\n+  const size_t middle_stripe_len = (num_stripes - 2) * stripe_len;\n@@ -463,3 +483,2 @@\n-    \/\/ On Windows, use UseNUMAInterleaving=1 which makes\n-    \/\/  os::release_memory accept multi-map-ranges.\n-    \/\/  Otherwise we would assert (see below for death test).\n+    \/\/ On Windows, temporarily switch on UseNUMAInterleaving to allow release_memory to release\n+    \/\/  multiple mappings in one go (otherwise we assert, which we test too, see death test below).\n@@ -467,1 +486,1 @@\n-    ASSERT_TRUE(os::release_memory((char*)p, total_range_len));\n+    ASSERT_TRUE(os::release_memory((char*)p_middle_stripes, middle_stripe_len));\n@@ -471,3 +490,3 @@\n-  \/\/ re-reserve it. This should work unless release failed.\n-  address p2 = (address)os::attempt_reserve_memory_at((char*)p, total_range_len);\n-  ASSERT_EQ(p2, p);\n+  \/\/ ...re-reserve the middle stripes. This should work unless release silently failed.\n+  address p2 = (address)os::attempt_reserve_memory_at((char*)p_middle_stripes, middle_stripe_len);\n+  ASSERT_EQ(p2, p_middle_stripes);\n@@ -476,1 +495,5 @@\n-  ASSERT_TRUE(os::release_memory((char*)p, total_range_len));\n+  \/\/ Clean up. Release all mappings.\n+  {\n+    WINDOWS_ONLY(NUMASwitcher b(true);) \/\/ allow release_memory to release multiple regions\n+    ASSERT_TRUE(os::release_memory((char*)p, total_range_len));\n+  }\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":35,"deletions":12,"binary":false,"changes":47,"status":"modified"}]}