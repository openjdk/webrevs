{"files":[{"patch":"@@ -340,1 +340,1 @@\n-    stack->print_on(out);\n+    _stackprinter.print_stack(stack);\n@@ -377,1 +377,1 @@\n-    stack->print_on(out);\n+    _stackprinter.print_stack(stack);\n@@ -431,1 +431,1 @@\n-    INDENT_BY(4, stack->print_on(out);)\n+    INDENT_BY(4, _stackprinter.print_stack(stack);)\n@@ -872,1 +872,1 @@\n-  stack->print_on(out);\n+  _stackprinter.print_stack(stack);\n@@ -907,1 +907,1 @@\n-  stack->print_on(out);\n+  _stackprinter.print_stack(stack);\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/nativeCallStack.hpp\"\n@@ -152,1 +153,1 @@\n-\n+  NativeCallStackPrinter _stackprinter;\n@@ -156,1 +157,1 @@\n-     _baseline(baseline) { }\n+     _baseline(baseline), _stackprinter(output) { }\n@@ -232,0 +233,1 @@\n+  NativeCallStackPrinter _stackprinter;\n@@ -235,1 +237,2 @@\n-    MemSummaryDiffReporter(early_baseline, current_baseline, output, scale) { }\n+    MemSummaryDiffReporter(early_baseline, current_baseline, output, scale),\n+    _stackprinter(output) { }\n","filename":"src\/hotspot\/share\/nmt\/memReporter.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -682,0 +682,1 @@\n+  NativeCallStackPrinter      _stackprinter;\n@@ -684,1 +685,1 @@\n-    _p((address)p), _st(st) { }\n+    _p((address)p), _st(st), _stackprinter(st) { }\n@@ -691,1 +692,1 @@\n-        rgn->call_stack()->print_on(_st);\n+        _stackprinter.print_stack(rgn->call_stack());\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,38 @@\n+\n+void NativeCallStack::print_frame(outputStream* out, address pc) const {\n+  char    buf[1024];\n+  int     offset;\n+  int     line;\n+  const bool pc_in_VM = os::address_is_in_vm(pc);\n+  out->print(\"[\" PTR_FORMAT \"]\", p2i(pc));\n+  \/\/ Print function and library; shorten library name to just its last component\n+  \/\/ for brevity, and omit it completely for libjvm.so\n+  bool function_printed = false;\n+  if (os::dll_address_to_function_name(pc, buf, sizeof(buf), &offset)) {\n+    out->print(\"%s+0x%x\", buf, offset);\n+    function_printed = true;\n+    if (Decoder::get_source_info(pc, buf, sizeof(buf), &line, false)) {\n+      \/\/ For intra-vm functions, we omit the full path\n+      const char* s = buf;\n+      if (pc_in_VM) {\n+        s = strrchr(s, os::file_separator()[0]);\n+        s = (s != nullptr) ? s + 1 : buf;\n+      }\n+      out->print(\"   (%s:%d)\", s, line);\n+    }\n+  }\n+  if ((!function_printed || !pc_in_VM) &&\n+      os::dll_address_to_library_name(pc, buf, sizeof(buf), &offset)) {\n+    const char* libname = strrchr(buf, os::file_separator()[0]);\n+    if (libname != nullptr) {\n+      libname++;\n+    } else {\n+      libname = buf;\n+    }\n+    out->print(\" in %s\", libname);\n+    if (!function_printed) {\n+      out->print(\"+0x%x\", offset);\n+    }\n+  }\n+}\n+\n@@ -80,27 +118,6 @@\n-  if (is_empty()) {\n-    out->print(\"[BOOTSTRAP]\");\n-  } else {\n-    for (int frame = 0; frame < NMT_TrackingStackDepth; frame ++) {\n-      pc = get_frame(frame);\n-      if (pc == nullptr) break;\n-      out->print(\"[\" PTR_FORMAT \"]\", p2i(pc));\n-      \/\/ Print function and library; shorten library name to just its last component\n-      \/\/ for brevity, and omit it completely for libjvm.so\n-      bool function_printed = false;\n-      if (os::dll_address_to_function_name(pc, buf, sizeof(buf), &offset)) {\n-        out->print(\"%s+0x%x\", buf, offset);\n-        function_printed = true;\n-      }\n-      if ((!function_printed || !os::address_is_in_vm(pc)) &&\n-          os::dll_address_to_library_name(pc, buf, sizeof(buf), &offset)) {\n-        const char* libname = strrchr(buf, os::file_separator()[0]);\n-        if (libname != nullptr) {\n-          libname++;\n-        } else {\n-          libname = buf;\n-        }\n-        out->print(\" in %s\", libname);\n-        if (!function_printed) {\n-          out->print(\"+0x%x\", offset);\n-        }\n-      }\n+  int     line;\n+  for (int i = 0; i < NMT_TrackingStackDepth && _stack[i] != nullptr; i++) {\n+    print_frame(out, _stack[i]);\n+  }\n+  out->cr();\n+}\n@@ -108,3 +125,1 @@\n-      \/\/ Note: we deliberately omit printing source information here. NativeCallStack::print_on()\n-      \/\/ can be called thousands of times as part of NMT detail reporting, and source printing\n-      \/\/ can slow down reporting by a factor of 5 or more depending on platform (see JDK-8296931).\n+NativeCallStackPrinter::NativeCallStackPrinter(outputStream* out) : _out(out) {}\n@@ -112,1 +127,15 @@\n-      out->cr();\n+void NativeCallStackPrinter::print_stack(const NativeCallStack* stack) const {\n+  for (int i = 0; i < NMT_TrackingStackDepth; i++) {\n+    const address pc = stack->get_frame(i);\n+\n+    if (pc != nullptr) {\n+      \/\/ cached?\n+      bool created = false;\n+      Entry* const cached_value = _cache.put_if_absent(pc, &created);\n+      if (!created) {\n+        _out->print_raw_cr(cached_value->text);\n+      } else {\n+        stringStream ss(cached_value->text, sizeof(cached_value->text));\n+        stack->print_frame(&ss, pc);\n+        _out->print_raw_cr(cached_value->text);\n+      }\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.cpp","additions":61,"deletions":32,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/resourceHash.hpp\"\n@@ -126,0 +127,1 @@\n+  void print_frame(outputStream* out, address pc) const;\n@@ -131,0 +133,11 @@\n+\/\/ When printing many instances of NativeCallStack that may share many PC addresses,\n+\/\/ a NativeCallStackPrinter improves performance by caching printed frames by address.\n+class NativeCallStackPrinter {\n+  struct Entry { char text[1024]; };\n+  mutable ResourceHashtable<address, Entry, 293, AnyObj::C_HEAP, mtNMT> _cache;\n+  outputStream* const _out;\n+public:\n+  NativeCallStackPrinter(outputStream* out);\n+  void print_stack(const NativeCallStack* stack) const;\n+};\n+\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,2 @@\n+    private static final boolean expectSourceInformation = Platform.isLinux() || Platform.isWindows();\n+\n@@ -124,2 +126,3 @@\n-            if (Platform.isWindows() || Platform.isARM()) {\n-                return; \/\/ we are done\n+            if (!Platform.isWindows() && !Platform.isARM()) {\n+                output.reportDiagnosticSummary();\n+                throw new RuntimeException(\"Expected symbol missing from output: \" + expectedSymbol);\n@@ -127,2 +130,0 @@\n-            output.reportDiagnosticSummary();\n-            throw new RuntimeException(\"Expected symbol missing from output: \" + expectedSymbol);\n@@ -133,9 +134,11 @@\n-        if (okToHaveAllocateHeap) {\n-            System.out.print(stackTraceAllocateHeap);\n-            if (stackTraceMatches(stackTraceAllocateHeap, output)) {\n-                return;\n-            }\n-        } else {\n-            System.out.print(stackTraceDefault);\n-            if (stackTraceMatches(stackTraceDefault, output)) {\n-                return;\n+        String toMatch = okToHaveAllocateHeap ? stackTraceAllocateHeap : stackTraceDefault;\n+        if (!stackTraceMatches(toMatch, output)) {\n+            output.reportDiagnosticSummary();\n+            throw new RuntimeException(\"Expected stack trace missing from output\");\n+        }\n+\n+        System.out.println(\"Looking for source information:\");\n+        if (expectSourceInformation) {\n+            if (!stackTraceMatches(\".*moduleEntry.cpp.*\", output)) {\n+                output.reportDiagnosticSummary();\n+                throw new RuntimeException(\"Expected source information missing from output\");\n@@ -144,3 +147,0 @@\n-        \/\/ Failed to match so dump all the output\n-        output.reportDiagnosticSummary();\n-        throw new RuntimeException(\"Expected stack trace missing from output\");\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/CheckForProperDetailStackTrace.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"}]}