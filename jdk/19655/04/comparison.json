{"files":[{"patch":"@@ -340,1 +340,1 @@\n-    stack->print_on(out);\n+    _stackprinter.print_stack(stack);\n@@ -377,1 +377,1 @@\n-    stack->print_on(out);\n+    _stackprinter.print_stack(stack);\n@@ -431,1 +431,1 @@\n-    INDENT_BY(4, stack->print_on(out);)\n+    INDENT_BY(4, _stackprinter.print_stack(stack);)\n@@ -872,1 +872,1 @@\n-  stack->print_on(out);\n+  _stackprinter.print_stack(stack);\n@@ -907,1 +907,1 @@\n-  stack->print_on(out);\n+  _stackprinter.print_stack(stack);\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"nmt\/nativeCallStackPrinter.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"utilities\/nativeCallStack.hpp\"\n@@ -152,1 +154,1 @@\n-\n+  NativeCallStackPrinter _stackprinter;\n@@ -156,1 +158,1 @@\n-     _baseline(baseline) { }\n+     _baseline(baseline), _stackprinter(output) { }\n@@ -232,0 +234,1 @@\n+  NativeCallStackPrinter _stackprinter;\n@@ -235,1 +238,2 @@\n-    MemSummaryDiffReporter(early_baseline, current_baseline, output, scale) { }\n+    MemSummaryDiffReporter(early_baseline, current_baseline, output, scale),\n+    _stackprinter(output) { }\n","filename":"src\/hotspot\/share\/nmt\/memReporter.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"nmt\/nativeCallStackPrinter.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/nativeCallStack.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+NativeCallStackPrinter::NativeCallStackPrinter(outputStream* out) :\n+    _text_storage(mtNMT, Arena::Tag::tag_other, 128 * K), _out(out)\n+{}\n+\n+void NativeCallStackPrinter::print_stack(const NativeCallStack* stack) const {\n+  for (int i = 0; i < NMT_TrackingStackDepth; i++) {\n+    const address pc = stack->get_frame(i);\n+    if (pc != nullptr) {\n+      bool created = false;\n+      const char** cached_frame_text = _cache.put_if_absent(pc, &created);\n+      if (created) {\n+        stringStream ss(4 * K);\n+        stack->print_frame(&ss, pc);\n+        const size_t len = strlen(ss.base());\n+        char* store = NEW_ARENA_ARRAY(&_text_storage, char, len + 1);\n+        strcpy(store, ss.base());\n+        (*cached_frame_text) = store;\n+      }\n+      _out->print_raw_cr(*cached_frame_text);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/nmt\/nativeCallStackPrinter.cpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_NMT_NATIVECALLSTACKPRINTER_HPP\n+#define SHARE_NMT_NATIVECALLSTACKPRINTER_HPP\n+\n+#include \"memory\/arena.hpp\"\n+#include \"nmt\/memflags.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class outputStream;\n+class NativeCallStack;\n+\n+\/\/ This is a text cache for NativeCallStack frames by PC. When printing tons of\n+\/\/ NativeCallStack instances (e.g. during NMT detail reports), printing through\n+\/\/ this printer speeds up frame description resolution by quite a bit.\n+class NativeCallStackPrinter {\n+  \/\/ Cache-related data are mutable to be able to use NativeCallStackPrinter as\n+  \/\/ inline member in classes with const printing methods.\n+  mutable Arena _text_storage;\n+  mutable ResourceHashtable<address, const char*, 293, AnyObj::C_HEAP, mtNMT> _cache;\n+  outputStream* const _out;\n+public:\n+  NativeCallStackPrinter(outputStream* out);\n+  void print_stack(const NativeCallStack* stack) const;\n+};\n+\n+#endif \/\/ SHARE_NMT_NATIVECALLSTACKPRINTER_HPP\n","filename":"src\/hotspot\/share\/nmt\/nativeCallStackPrinter.hpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"nmt\/nativeCallStackPrinter.hpp\"\n@@ -682,0 +683,1 @@\n+  NativeCallStackPrinter      _stackprinter;\n@@ -684,1 +686,1 @@\n-    _p((address)p), _st(st) { }\n+    _p((address)p), _st(st), _stackprinter(st) { }\n@@ -691,1 +693,1 @@\n-        rgn->call_stack()->print_on(_st);\n+        _stackprinter.print_stack(rgn->call_stack());\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,3 +75,2 @@\n-void NativeCallStack::print_on(outputStream* out) const {\n-  DEBUG_ONLY(assert_not_fake();)\n-  address pc;\n+\n+void NativeCallStack::print_frame(outputStream* out, address pc) const {\n@@ -80,26 +79,15 @@\n-  if (is_empty()) {\n-    out->print(\"[BOOTSTRAP]\");\n-  } else {\n-    for (int frame = 0; frame < NMT_TrackingStackDepth; frame ++) {\n-      pc = get_frame(frame);\n-      if (pc == nullptr) break;\n-      out->print(\"[\" PTR_FORMAT \"]\", p2i(pc));\n-      \/\/ Print function and library; shorten library name to just its last component\n-      \/\/ for brevity, and omit it completely for libjvm.so\n-      bool function_printed = false;\n-      if (os::dll_address_to_function_name(pc, buf, sizeof(buf), &offset)) {\n-        out->print(\"%s+0x%x\", buf, offset);\n-        function_printed = true;\n-      }\n-      if ((!function_printed || !os::address_is_in_vm(pc)) &&\n-          os::dll_address_to_library_name(pc, buf, sizeof(buf), &offset)) {\n-        const char* libname = strrchr(buf, os::file_separator()[0]);\n-        if (libname != nullptr) {\n-          libname++;\n-        } else {\n-          libname = buf;\n-        }\n-        out->print(\" in %s\", libname);\n-        if (!function_printed) {\n-          out->print(\"+0x%x\", offset);\n-        }\n+  int     line;\n+  const bool pc_in_VM = os::address_is_in_vm(pc);\n+  out->print(\"[\" PTR_FORMAT \"]\", p2i(pc));\n+  \/\/ Print function and library; shorten library name to just its last component\n+  \/\/ for brevity, and omit it completely for libjvm.so\n+  bool function_printed = false;\n+  if (os::dll_address_to_function_name(pc, buf, sizeof(buf), &offset)) {\n+    out->print(\"%s+0x%x\", buf, offset);\n+    function_printed = true;\n+    if (Decoder::get_source_info(pc, buf, sizeof(buf), &line, false)) {\n+      \/\/ For intra-vm functions, we omit the full path\n+      const char* s = buf;\n+      if (pc_in_VM) {\n+        s = strrchr(s, os::file_separator()[0]);\n+        s = (s != nullptr) ? s + 1 : buf;\n@@ -107,6 +95,14 @@\n-\n-      \/\/ Note: we deliberately omit printing source information here. NativeCallStack::print_on()\n-      \/\/ can be called thousands of times as part of NMT detail reporting, and source printing\n-      \/\/ can slow down reporting by a factor of 5 or more depending on platform (see JDK-8296931).\n-\n-      out->cr();\n+      out->print(\"   (%s:%d)\", s, line);\n+    }\n+  }\n+  if ((!function_printed || !pc_in_VM) &&\n+      os::dll_address_to_library_name(pc, buf, sizeof(buf), &offset)) {\n+    const char* libname = strrchr(buf, os::file_separator()[0]);\n+    if (libname != nullptr) {\n+      libname++;\n+    } else {\n+      libname = buf;\n+    }\n+    out->print(\" in %s\", libname);\n+    if (!function_printed) {\n+      out->print(\"+0x%x\", offset);\n@@ -116,0 +112,8 @@\n+\n+void NativeCallStack::print_on(outputStream* out) const {\n+  DEBUG_ONLY(assert_not_fake();)\n+  for (int i = 0; i < NMT_TrackingStackDepth && _stack[i] != nullptr; i++) {\n+    print_frame(out, _stack[i]);\n+  }\n+  out->cr();\n+}\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.cpp","additions":40,"deletions":36,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/resourceHash.hpp\"\n@@ -126,0 +127,1 @@\n+  void print_frame(outputStream* out, address pc) const;\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,2 @@\n+    private static final boolean expectSourceInformation = Platform.isLinux() || Platform.isWindows();\n+\n@@ -124,2 +126,3 @@\n-            if (Platform.isWindows() || Platform.isARM()) {\n-                return; \/\/ we are done\n+            if (!Platform.isWindows() && !Platform.isARM()) {\n+                output.reportDiagnosticSummary();\n+                throw new RuntimeException(\"Expected symbol missing from output: \" + expectedSymbol);\n@@ -127,2 +130,0 @@\n-            output.reportDiagnosticSummary();\n-            throw new RuntimeException(\"Expected symbol missing from output: \" + expectedSymbol);\n@@ -133,9 +134,11 @@\n-        if (okToHaveAllocateHeap) {\n-            System.out.print(stackTraceAllocateHeap);\n-            if (stackTraceMatches(stackTraceAllocateHeap, output)) {\n-                return;\n-            }\n-        } else {\n-            System.out.print(stackTraceDefault);\n-            if (stackTraceMatches(stackTraceDefault, output)) {\n-                return;\n+        String toMatch = okToHaveAllocateHeap ? stackTraceAllocateHeap : stackTraceDefault;\n+        if (!stackTraceMatches(toMatch, output)) {\n+            output.reportDiagnosticSummary();\n+            throw new RuntimeException(\"Expected stack trace missing from output\");\n+        }\n+\n+        System.out.println(\"Looking for source information:\");\n+        if (expectSourceInformation) {\n+            if (!stackTraceMatches(\".*moduleEntry.cpp.*\", output)) {\n+                output.reportDiagnosticSummary();\n+                throw new RuntimeException(\"Expected source information missing from output\");\n@@ -144,3 +147,0 @@\n-        \/\/ Failed to match so dump all the output\n-        output.reportDiagnosticSummary();\n-        throw new RuntimeException(\"Expected stack trace missing from output\");\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/CheckForProperDetailStackTrace.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"}]}