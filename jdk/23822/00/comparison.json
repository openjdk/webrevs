{"files":[{"patch":"@@ -27,0 +27,2 @@\n+#include <utilities\/globalDefinitions.hpp>\n+\n@@ -42,0 +44,4 @@\n+\n+  \/\/ Returns a count that is max_count or larger and upholds the requirements\n+  \/\/ for using the ZIndexDistributor strategy specfied by ZIndexDistributorStrategy\n+  static size_t get_count(size_t max_count);\n","filename":"src\/hotspot\/share\/gc\/z\/zIndexDistributor.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -38,0 +39,1 @@\n+  static const int StripeCount = MemSize \/ ZCacheLineSize;\n@@ -39,1 +41,1 @@\n-  const int _max_index;\n+  const int _count;\n@@ -54,2 +56,2 @@\n-  ZIndexDistributorStriped(int max_index)\n-    : _max_index(max_index),\n+  ZIndexDistributorStriped(int count)\n+    : _count(count),\n@@ -63,2 +65,1 @@\n-    const int count = MemSize \/ ZCacheLineSize;\n-    const int stripe_max = _max_index \/ count;\n+    const int stripe_max = _count \/ StripeCount;\n@@ -67,1 +68,1 @@\n-    for (int i; (i = claim_stripe()) < count;) {\n+    for (int i; (i = claim_stripe()) < StripeCount;) {\n@@ -76,1 +77,1 @@\n-    for (int i = 0; i < count; i++) {\n+    for (int i = 0; i < StripeCount; i++) {\n@@ -84,0 +85,5 @@\n+\n+  static size_t get_count(size_t max_count) {\n+    \/\/ Must be multiple of the StripeCount\n+    return align_up(max_count, StripeCount);\n+  }\n@@ -293,0 +299,6 @@\n+\n+  static size_t get_count(size_t max_count) {\n+    \/\/ Must be at least claim_level_size(ClaimLevels) and a power of two\n+    const size_t min_count = claim_level_size(ClaimLevels);\n+    return round_up_power_of_2(MAX2(max_count, min_count));\n+  }\n@@ -331,0 +343,13 @@\n+inline size_t ZIndexDistributor::get_count(size_t max_count) {\n+  size_t required_count;\n+  switch (ZIndexDistributorStrategy) {\n+  case 0: required_count = ZIndexDistributorClaimTree::get_count(max_count); break;\n+  case 1: required_count = ZIndexDistributorStriped::get_count(max_count); break;\n+  default: fatal(\"Unknown ZIndexDistributorStrategy\");\n+  };\n+\n+  assert(max_count <= required_count, \"unsupported max_count: %zu\", max_count);\n+\n+  return required_count;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zIndexDistributor.inline.hpp","additions":32,"deletions":7,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -103,0 +103,12 @@\n+zoffset_end ZMemoryManager::peak_high_address_end() const {\n+  ZLocker<ZLock> locker(&_lock);\n+\n+  const ZMemory* const area = _freelist.last();\n+  if (area != nullptr) {\n+    return area->end();\n+  }\n+\n+  \/\/ Out of memory\n+  return zoffset_end(UINTPTR_MAX);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zMemory.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+  zoffset_end peak_high_address_end() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zMemory.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/z\/zIndexDistributor.inline.hpp\"\n@@ -31,0 +32,8 @@\n+static size_t get_max_offset_for_map() {\n+  \/\/ The page table has (ZAddressOffsetMax >> ZGranuleSizeShift) slots\n+  const size_t max_count = ZAddressOffsetMax >> ZGranuleSizeShift;\n+  const size_t required_count = ZIndexDistributor::get_count(max_count);\n+\n+  return required_count << ZGranuleSizeShift;\n+}\n+\n@@ -32,1 +41,1 @@\n-  : _map(ZAddressOffsetMax) {}\n+  : _map(get_max_offset_for_map()) {}\n","filename":"src\/hotspot\/share\/gc\/z\/zPageTable.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -48,0 +48,2 @@\n+  int count() const;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPageTable.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,9 @@\n+#include <limits>\n+\n+inline int ZPageTable::count() const {\n+  const size_t size = _map._size;\n+  assert(size <= std::numeric_limits<int>::max(), \"Invalid page table size\");\n+\n+  return static_cast<int>(size);\n+}\n+\n@@ -67,1 +76,1 @@\n-    _index_distributor(int(ZAddressOffsetMax >> ZGranuleSizeShift)) {}\n+    _index_distributor(table->count()) {}\n","filename":"src\/hotspot\/share\/gc\/z\/zPageTable.inline.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -51,0 +51,3 @@\n+  \/\/ Set ZAddressOffsetMax to the highest address end available after reservation\n+  ZAddressOffsetMax = untype(highest_available_address_end());\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zVirtualMemory.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  zoffset_end highest_available_address_end() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zVirtualMemory.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,0 +68,4 @@\n+inline zoffset_end ZVirtualMemoryManager::highest_available_address_end() const {\n+  return _manager.peak_high_address_end();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zVirtualMemory.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}