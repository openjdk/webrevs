{"files":[{"patch":"@@ -41,0 +41,1 @@\n+import jdk.internal.foreign.layout.LayoutTransformers;\n@@ -256,1 +257,0 @@\n-    @SuppressWarnings(\"restricted\")\n@@ -260,9 +260,1 @@\n-        return switch (ml) {\n-            case StructLayout sl -> MemoryLayout.structLayout(stripNames(sl.memberLayouts()));\n-            case UnionLayout ul -> MemoryLayout.unionLayout(stripNames(ul.memberLayouts()));\n-            case SequenceLayout sl -> MemoryLayout.sequenceLayout(sl.elementCount(), stripNames(sl.elementLayout()));\n-            case AddressLayout al -> al.targetLayout()\n-                    .map(tl -> al.withoutName().withTargetLayout(stripNames(tl))) \/\/ restricted\n-                    .orElseGet(al::withoutName);\n-            default -> ml.withoutName(); \/\/ ValueLayout and PaddingLayout\n-        };\n+        return LayoutTransformers.removeNames().apply(ml);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.foreign.layout;\n+\n+import jdk.internal.ValueBased;\n+\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.UnionLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+\/**\n+ * A JDK-internal utility class that provides useful layout transformations.\n+ *\/\n+public final class LayoutTransformers {\n+\n+    private LayoutTransformers() {}\n+\n+    \/**\n+     * {@return a function that recursively will remove all member names in memory layouts}\n+     *\/\n+    public static Function<MemoryLayout, MemoryLayout> removeNames() {\n+        return LayoutTransformerImpl.REMOVE_NAMES::deepTransform;\n+    }\n+\n+    \/**\n+     * {@return a transformer that recursively will set byte ordering to the provided\n+     * {@code byteOrder}}\n+     *\/\n+    public static Function<MemoryLayout, MemoryLayout> setByteOrder(ByteOrder byteOrder) {\n+        return LayoutTransformerImpl.setByteOrder(byteOrder)::deepTransform;\n+    }\n+\n+    \/\/ Internal classes\n+\n+    \/**\n+     * A layout transformer that can be used to apply functions on selected types\n+     * of memory layouts.\n+     * <p>\n+     * A layout transformer can be used to convert byte ordering for all sub-members\n+     * or remove all names, for example.\n+     *\n+     * @param <T> the type of MemoryLayout for which transformation is to be made\n+     *\/\n+    sealed interface LayoutTransformer<T extends MemoryLayout>\n+            permits LayoutTransformerImpl {\n+\n+        \/**\n+         * {@return a transformed version of the provided {@code layout}}.\n+         * @param layout to transform\n+         *\/\n+        MemoryLayout transform(T layout);\n+\n+        \/**\n+         * {@return a transformed version of the provided {@code layout} by recursively\n+         * applying this transformer (breadth first) on all sub-members}\n+         * @param layout to transform\n+         *\/\n+        MemoryLayout deepTransform(MemoryLayout layout);\n+\n+        \/**\n+         * {@return a layout transformer that transforms layouts of the given {@code type}\n+         * using the provided {@code transformation}}\n+         * @param type to transform\n+         * @param transformation to apply\n+         * @param <T> the type of memory layout to transform\n+         *\/\n+        static <T extends MemoryLayout>\n+        LayoutTransformer<T> of(Class<T> type,\n+                                Function<? super T, ? extends MemoryLayout> transformation) {\n+            Objects.requireNonNull(type);\n+            Objects.requireNonNull(type);\n+            return LayoutTransformerImpl.of(type, transformation);\n+        }\n+\n+        \/**\n+         * {@return a transformer that will remove all member names in memory layouts}\n+         *\/\n+        static LayoutTransformer<MemoryLayout> removeName() {\n+            return LayoutTransformerImpl.REMOVE_NAMES;\n+        }\n+\n+        \/**\n+         * {@return a transformer that will set member byte ordering to the provided\n+         * {@code byteOrder}}\n+         *\/\n+        static LayoutTransformer<ValueLayout> setByteOrder(ByteOrder byteOrder) {\n+            return LayoutTransformerImpl.setByteOrder(byteOrder);\n+        }\n+\n+    }\n+\n+    @ValueBased\n+    static final class LayoutTransformerImpl<T extends MemoryLayout>\n+            implements LayoutTransformer<T> {\n+\n+        private final Class<T> type;\n+        private final Function<? super T, ? extends MemoryLayout> op;\n+\n+        private LayoutTransformerImpl(Class<T> type,\n+                                      Function<? super T, ? extends MemoryLayout> op) {\n+            this.type = type;\n+            this.op = op;\n+        }\n+\n+        @Override\n+        public MemoryLayout transform(T layout) {\n+            Objects.requireNonNull(layout);\n+            return op.apply(layout);\n+        }\n+\n+        @Override\n+        public MemoryLayout deepTransform(MemoryLayout layout) {\n+            Objects.requireNonNull(layout);\n+\n+            \/\/ Breadth first\n+            MemoryLayout outer = transformFlat(this, layout);\n+\n+            \/\/ Handle element transformation\n+            return switch (outer) {\n+                case SequenceLayout sl -> MemoryLayout.sequenceLayout(sl.elementCount(), deepTransform(sl.elementLayout()));\n+                case StructLayout sl   -> MemoryLayout.structLayout(applyRecursively(sl));\n+                case UnionLayout gl    -> MemoryLayout.unionLayout(applyRecursively(gl));\n+                default -> outer;\n+            };\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getClass().getSimpleName() + \"[\" + op + \"]\";\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(type, op);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof LayoutTransformerImpl<?> other &&\n+                    type.equals(other.type) &&\n+                    op.equals(other.op);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private static <T extends MemoryLayout> MemoryLayout transformFlat(LayoutTransformer<T> transformer, MemoryLayout l) {\n+            LayoutTransformerImpl<T> t = (LayoutTransformerImpl<T>) transformer;\n+            return switch (t.type) {\n+                case Class<?> c when c.equals(MemoryLayout.class) ->\n+                        ((LayoutTransformerImpl<MemoryLayout>)t).transform(l);\n+                case Class<?> c when c.equals(SequenceLayout.class) &&\n+                        l instanceof SequenceLayout sl ->\n+                        ((LayoutTransformerImpl<SequenceLayout>)t).transform(sl);\n+                case Class<?> c when c.equals(GroupLayout.class) &&\n+                        l instanceof GroupLayout gl ->\n+                        ((LayoutTransformerImpl<GroupLayout>)t).transform(gl);\n+                case Class<?> c when c.equals(StructLayout.class) &&\n+                        l instanceof StructLayout se ->\n+                        ((LayoutTransformerImpl<StructLayout>)t).transform(se);\n+                case Class<?> c when c.equals(UnionLayout.class) &&\n+                        l instanceof UnionLayout uel ->\n+                        ((LayoutTransformerImpl<UnionLayout>)t).transform(uel);\n+                case Class<?> c when c.equals(PaddingLayout.class) &&\n+                        l instanceof PaddingLayout pl ->\n+                        ((LayoutTransformerImpl<PaddingLayout>)t).transform(pl);\n+                case Class<?> c when c.equals(ValueLayout.class) &&\n+                        l instanceof ValueLayout vl ->\n+                        ((LayoutTransformerImpl<ValueLayout>)t).transform(vl);\n+                case Class<?> c when c.equals(ValueLayout.OfBoolean.class) &&\n+                        l instanceof ValueLayout.OfBoolean bl ->\n+                        ((LayoutTransformerImpl<ValueLayout.OfBoolean>)t).transform(bl);\n+                case Class<?> c when c.equals(ValueLayout.OfByte.class) &&\n+                        l instanceof ValueLayout.OfByte by ->\n+                        ((LayoutTransformerImpl<ValueLayout.OfByte>)t).transform(by);\n+                case Class<?> c when c.equals(ValueLayout.OfChar.class) &&\n+                        l instanceof ValueLayout.OfChar ch ->\n+                        ((LayoutTransformerImpl<ValueLayout.OfChar>)t).transform(ch);\n+                case Class<?> c when c.equals(ValueLayout.OfShort.class) &&\n+                        l instanceof ValueLayout.OfShort sh ->\n+                        ((LayoutTransformerImpl<ValueLayout.OfShort>)t).transform(sh);\n+                case Class<?> c when c.equals(ValueLayout.OfInt.class) &&\n+                        l instanceof ValueLayout.OfInt in ->\n+                        ((LayoutTransformerImpl<ValueLayout.OfInt>)t).transform(in);\n+                case Class<?> c when c.equals(ValueLayout.OfLong.class) &&\n+                        l instanceof ValueLayout.OfLong lo ->\n+                        ((LayoutTransformerImpl<ValueLayout.OfLong>)t).transform(lo);\n+                case Class<?> c when c.equals(ValueLayout.OfFloat.class) &&\n+                        l instanceof ValueLayout.OfFloat fl ->\n+                        ((LayoutTransformerImpl<ValueLayout.OfFloat>)t).transform(fl);\n+                case Class<?> c when c.equals(ValueLayout.OfDouble.class) &&\n+                        l instanceof ValueLayout.OfDouble db ->\n+                        ((LayoutTransformerImpl<ValueLayout.OfDouble>)t).transform(db);\n+                case Class<?> c when c.equals(AddressLayout.class) &&\n+                        l instanceof AddressLayout ad ->\n+                        ((LayoutTransformerImpl<AddressLayout>)t).transform(ad);\n+                \/\/ No transformation\n+                default -> l;\n+            };\n+        }\n+\n+        private MemoryLayout[] applyRecursively(GroupLayout groupLayout) {\n+            return groupLayout.memberLayouts().stream()\n+                    .map(this::deepTransform)\n+                    .toArray(MemoryLayout[]::new);\n+        }\n+\n+        static final LayoutTransformer<MemoryLayout> REMOVE_NAMES =\n+                LayoutTransformer.of(MemoryLayout.class, LayoutTransformerImpl::removeMemberName);\n+\n+        @SuppressWarnings(\"restricted\")\n+        private static MemoryLayout removeMemberName(MemoryLayout vl) {\n+            return switch (vl) {\n+                case AddressLayout al -> al.targetLayout()\n+                        .map(tl -> al.withoutName().withTargetLayout(REMOVE_NAMES.deepTransform(tl))) \/\/ restricted\n+                        .orElseGet(al::withoutName);\n+                default -> vl.withoutName();\n+            };\n+        }\n+\n+        static LayoutTransformer<ValueLayout> setByteOrder(ByteOrder byteOrder) {\n+            return LayoutTransformer.of(ValueLayout.class, vl -> vl.withOrder(byteOrder));\n+        }\n+\n+        static <T extends MemoryLayout> LayoutTransformer<T> of(Class<T> type,\n+                                                                Function<? super T, ? extends MemoryLayout> op) {\n+            return new LayoutTransformerImpl<>(type, op);\n+        }\n+\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/LayoutTransformers.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.foreign.layout\n+ * @run junit TestLayoutTransformations\n+ *\/\n+\n+import jdk.internal.foreign.layout.LayoutTransformers;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+final class TestLayoutTransformations {\n+\n+    @Test\n+    void single() {\n+        ValueLayout.OfInt intLayout = JAVA_INT.withName(\"someName\");\n+        var actual = LayoutTransformers.removeNames().apply(intLayout);\n+        assertEquals(JAVA_INT, actual);\n+    }\n+\n+    @Test\n+    void structOfValueLayouts() {\n+        MemoryLayout layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"x\").withOrder(ByteOrder.LITTLE_ENDIAN),\n+                JAVA_INT.withName(\"Y\").withOrder(ByteOrder.LITTLE_ENDIAN)\n+        );\n+\n+        MemoryLayout expected = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"x\").withOrder(ByteOrder.BIG_ENDIAN),\n+                JAVA_INT.withName(\"Y\").withOrder(ByteOrder.BIG_ENDIAN)\n+        );\n+        var actual = LayoutTransformers.setByteOrder(ByteOrder.BIG_ENDIAN).apply(layout);\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"restricted\")\n+    void removeNames() {\n+        MemoryLayout layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"x\"),\n+                JAVA_INT.withName(\"y\"),\n+                MemoryLayout.sequenceLayout(8, JAVA_INT.withName(\"array_element\")),\n+                ADDRESS.withTargetLayout(MemoryLayout.unionLayout(JAVA_INT.withName(\"u1\"), JAVA_FLOAT.withName(\"u2\")).withName(\"union\")).withName(\"address\")\n+        ).withName(\"struct\");\n+\n+        MemoryLayout expected = MemoryLayout.structLayout(\n+                JAVA_INT,\n+                JAVA_INT,\n+                MemoryLayout.sequenceLayout(8, JAVA_INT),\n+                ADDRESS.withTargetLayout(MemoryLayout.unionLayout(JAVA_INT, JAVA_FLOAT))\n+        );\n+\n+        var transformer = LayoutTransformers.removeNames();\n+        var actual = transformer.apply(layout);\n+        assertEquals(expected, actual);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestLayoutTransformations.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"}]}