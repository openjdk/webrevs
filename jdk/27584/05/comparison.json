{"files":[{"patch":"@@ -2184,0 +2184,5 @@\n+  \/\/ The last java frame might be compiled in 2 cases:\n+  \/\/ 1) Field events and interp_only mode are not enabled for this thread.\n+  \/\/ This method is called from any thread. The thread filtering is done later.\n+  \/\/ 2) The same JNI call is stll executing after event was enabled.\n+  \/\/ In this case the last frame is only marked for deoptimization but still remains compiled.\n@@ -2206,4 +2211,10 @@\n-  post_field_access(thread,\n-                    thread->last_frame().interpreter_frame_method(),\n-                    thread->last_frame().interpreter_frame_bcp(),\n-                    klass, h_obj, fieldID);\n+\n+  RegisterMap reg_map(thread,\n+                      RegisterMap::UpdateMap::skip,\n+                      RegisterMap::ProcessFrames::skip,\n+                      RegisterMap::WalkContinuation::skip);\n+  javaVFrame *jvf = thread->last_java_vframe(&reg_map);\n+  Method* method = jvf->method();\n+  address address = jvf->method()->code_base();\n+\n+  post_field_access(thread, method, address, klass, h_obj, fieldID);\n@@ -2270,0 +2281,5 @@\n+  \/\/ The last java frame might be compiled in 2 cases:\n+  \/\/ 1) Field events and interp_only mode are not enabled for this thread.\n+  \/\/ This method is called from any thread. The thread filtering is done later.\n+  \/\/ 2) The same JNI call is stll executing after event was enabled.\n+  \/\/ In this case the last frame is only marked for deoptimization but still remains compiled.\n@@ -2293,3 +2309,10 @@\n-  post_field_modification(thread,\n-                          thread->last_frame().interpreter_frame_method(),\n-                          thread->last_frame().interpreter_frame_bcp(),\n+\n+  RegisterMap reg_map(thread,\n+                      RegisterMap::UpdateMap::skip,\n+                      RegisterMap::ProcessFrames::skip,\n+                      RegisterMap::WalkContinuation::skip);\n+  javaVFrame *jvf = thread->last_java_vframe(&reg_map);\n+  Method* method = jvf->method();\n+  address address = jvf->method()->code_base();\n+\n+  post_field_modification(thread, method, address,\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test verifies that field access\/modification events are correctly posted from JNI.\n+ * @bug 8224852\n+ * @run main\/othervm\/native -agentlib:FieldsEventsFromJNI FieldsEventsFromJNI\n+ *\/\n+public class FieldsEventsFromJNI {\n+\n+    private String accessField = \"accessFieldValue\";\n+    private String modifyField = \"modifyFieldValue\";\n+\n+    private native void enableEventsAndAccessField(boolean isEventExpected, Thread eventThread);\n+    private native void enableEventsAndModifyField(boolean isEventExpected, Thread eventThread);\n+\n+    void javaMethod(boolean isEventExpected, Thread eventThread) {\n+        enableEventsAndAccessField(isEventExpected, eventThread);\n+        enableEventsAndModifyField(isEventExpected, eventThread);\n+    }\n+\n+    final static Object lock = new Object();\n+    volatile static boolean isAnotherThreadStarted = false;\n+\n+    public static void main(String[] args) throws InterruptedException {\n+        System.loadLibrary(\"FieldsEventsFromJNI\");\n+        FieldsEventsFromJNI c = new FieldsEventsFromJNI();\n+        \/\/ anotherThread doesn't access fields, it is needed only to\n+        \/\/ enable notification somewhere.\n+        Thread anotherThread = new Thread(() -> {\n+            isAnotherThreadStarted = true;\n+            synchronized(lock) {\n+                lock.notify();\n+            }\n+            while(!Thread.currentThread().isInterrupted()) {\n+                Thread.yield();\n+            }\n+        });\n+        synchronized(lock) {\n+            anotherThread.start();\n+            while(!isAnotherThreadStarted) {\n+                lock.wait();\n+            }\n+        }\n+        \/\/ Enable events while the thread is in the same JNI call.\n+        c.javaMethod(true, Thread.currentThread());\n+        \/\/ Verify that field access from JNI doesn't fail if events are\n+        \/\/ not enaled on this thread.\n+        c.javaMethod(false, anotherThread);\n+        anotherThread.interrupt();\n+        anotherThread.join();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/FieldsEventsFromJNI\/FieldsEventsFromJNI.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <inttypes.h>\n+\n+#include \"jvmti.h\"\n+#include \"jni.h\"\n+#include \"jvmti_common.hpp\"\n+\n+jvmtiEnv* jvmti_env;\n+\n+static int access_cnt = 0;\n+static int modify_cnt = 0;\n+\n+static void JNICALL\n+cbFieldAccess(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread, jmethodID method,\n+              jlocation location, jclass field_klass, jobject object, jfieldID field) {\n+  char* m_name = get_method_name(jvmti, jni, method);\n+  LOG(\"The field access triggered from method '%s'\\n\", m_name);\n+  if (strcmp(m_name, \"enableEventsAndAccessField\") != 0) {\n+    fatal(jni, \"The method's name is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, m_name);\n+\n+  LOG(\"The location is %\" PRId64 \"\\n\", (int64_t)location);\n+  if (location != 0) {\n+    fatal(jni, \"The method's location should be 0 for jni call.\");\n+  }\n+\n+  char* f_name = get_field_name(jvmti, jni, field_klass, field);\n+  LOG(\"The field name '%s'\\n\", f_name);\n+  if (strcmp(f_name, \"accessField\") != 0) {\n+    fatal(jni, \"The access field is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, f_name);\n+\n+  char* obj_class_name = get_object_class_name(jvmti, jni, object);\n+  LOG(\"The object class '%s'\\n\", obj_class_name);\n+  if (strcmp(obj_class_name, \"LFieldsEventsFromJNI;\") != 0) {\n+    fatal(jni, \"The fields's class name is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, obj_class_name);\n+\n+  access_cnt++;\n+}\n+\n+static void JNICALL\n+cbFieldModification(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread, jmethodID method,\n+                    jlocation location, jclass field_klass, jobject object, jfieldID field,\n+                    char signature_type, jvalue new_value) {\n+  char* m_name = get_method_name(jvmti, jni, method);\n+  LOG(\"The field modification triggered from method '%s'\\n\", m_name);\n+  if (strcmp(m_name, \"enableEventsAndModifyField\") != 0) {\n+    fatal(jni, \"The method's name is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, m_name);\n+\n+  LOG(\"The location is %\" PRId64 \"\\n\", (int64_t)location);\n+  if (location != 0) {\n+    fatal(jni, \"The method's location should be 0 for jni call.\");\n+  }\n+\n+  char* f_name = get_field_name(jvmti, jni, field_klass, field);\n+  LOG(\"The field name '%s'\\n\", f_name);\n+  if (strcmp(f_name, \"modifyField\") != 0) {\n+    fatal(jni, \"The access field is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, f_name);\n+\n+  char* obj_class_name = get_object_class_name(jvmti, jni, object);\n+  LOG(\"The object class '%s'\\n\", obj_class_name);\n+  if (strcmp(obj_class_name, \"LFieldsEventsFromJNI;\") != 0) {\n+    fatal(jni, \"The fields's class name is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, obj_class_name);\n+\n+  modify_cnt++;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  jvmtiEnv *jvmti = nullptr;\n+  jint res = vm->GetEnv((void **) &jvmti, JVMTI_VERSION_21);\n+  if (res != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jvmtiCapabilities capabilities;\n+  (void) memset(&capabilities, 0, sizeof (capabilities));\n+  capabilities.can_generate_field_access_events = true;\n+  capabilities.can_generate_field_modification_events = true;\n+  err = jvmti->AddCapabilities(&capabilities);\n+  check_jvmti_error(err, \"AddCapabilities\");\n+  jvmtiEventCallbacks callbacks;\n+  (void) memset(&callbacks, 0, sizeof (callbacks));\n+  callbacks.FieldAccess = &cbFieldAccess;\n+  callbacks.FieldModification = &cbFieldModification;\n+  err = jvmti->SetEventCallbacks(&callbacks, (int) sizeof (jvmtiEventCallbacks));\n+  check_jvmti_error(err, \"SetEventCallbacks\");\n+  jvmti_env = jvmti;\n+  return JNI_OK;\n+}\n+\n+extern \"C\" {\n+JNIEXPORT void JNICALL\n+Java_FieldsEventsFromJNI_enableEventsAndAccessField(\n+    JNIEnv *jni, jobject self, jboolean isEventExpected, jthread eventThread) {\n+\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+\n+  jclass cls = jni->GetObjectClass(self);\n+  if (cls == nullptr) {\n+    fatal(jni, \"No class found\");\n+  }\n+  jfieldID fieldToRead = jni->GetFieldID(cls, \"accessField\", \"Ljava\/lang\/String;\");\n+  if (fieldToRead == nullptr) {\n+    fatal(jni, \"No field found\");\n+  }\n+\n+  \/\/ Set watch and access field without returning to calling java code\n+  access_cnt = 0;\n+  err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_ACCESS, eventThread);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+  err = jvmti_env->SetFieldAccessWatch(cls, fieldToRead);\n+  check_jvmti_error(err, \"SetFieldAccessWatch\");\n+\n+  jstring jname = (jstring)jni->GetObjectField(self, fieldToRead);\n+\n+  err = jvmti_env->ClearFieldAccessWatch(cls, fieldToRead);\n+  check_jvmti_error(err, \"ClearFieldAccessWatch\");\n+  err = jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_FIELD_ACCESS, eventThread);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+\n+  const char* name_str = jni->GetStringUTFChars(jname, nullptr);\n+  LOG(\"The field %s\\n\", name_str);\n+  if (strcmp(name_str, \"accessFieldValue\") != 0) {\n+    fatal(jni, \"The field value is incorrect.\");\n+  }\n+\n+  if (access_cnt != isEventExpected) {\n+    fatal(jni, \"The field access count is incorrect.\");\n+  }\n+  jni->ReleaseStringUTFChars(jname, name_str);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_FieldsEventsFromJNI_enableEventsAndModifyField(\n+    JNIEnv *jni, jobject self, jboolean isEventExpected, jthread eventThread) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jclass cls = jni->GetObjectClass(self);\n+  if (cls == nullptr) {\n+    fatal(jni, \"No class found\");\n+  }\n+  jfieldID fieldToModify = jni->GetFieldID(cls, \"modifyField\", \"Ljava\/lang\/String;\");\n+  if (fieldToModify == nullptr) {\n+    fatal(jni, \"No field found\");\n+  }\n+\n+  modify_cnt = 0;\n+  err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_MODIFICATION, eventThread);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+  err = jvmti_env->SetFieldModificationWatch(cls, fieldToModify);\n+  check_jvmti_error(err, \"SetFieldAccessWatch\");\n+  jstring jval = jni->NewStringUTF(\"newValue\");\n+\n+  jni->SetObjectField(self, fieldToModify, jval);\n+\n+  err = jvmti_env->ClearFieldModificationWatch(cls, fieldToModify);\n+  check_jvmti_error(err, \"ClearFieldAccessWatch\");\n+  err = jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_FIELD_MODIFICATION, eventThread);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+\n+  if (modify_cnt != isEventExpected) {\n+    fatal(jni, \"The field access count should be 1.\");\n+  }\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/FieldsEventsFromJNI\/libFieldsEventsFromJNI.cpp","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -327,0 +327,18 @@\n+static char*\n+get_field_name(jvmtiEnv *jvmti, JNIEnv* jni, jclass field_class, jfieldID field) {\n+  char* name = nullptr;\n+  jvmtiError err = jvmti->GetFieldName(field_class, field, &name, nullptr, nullptr);\n+  check_jvmti_status(jni, err, \"get_field_name: error in JVMTI GetFieldName call\");\n+  return name;\n+}\n+\n+static char*\n+get_object_class_name(jvmtiEnv *jvmti, JNIEnv* jni, jobject object) {\n+  char *obj_class_name = nullptr;\n+  jclass object_class = jni->GetObjectClass(object);\n+  jvmtiError err = jvmti->GetClassSignature(object_class, &obj_class_name, nullptr);\n+  check_jvmti_error(err, \"GetClassSignature\");\n+  jni->DeleteLocalRef(object_class);\n+  return obj_class_name;\n+}\n+\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/jvmti_common.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"}]}