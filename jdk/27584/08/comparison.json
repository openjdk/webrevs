{"files":[{"patch":"@@ -2184,0 +2184,5 @@\n+  \/\/ The last java frame might be compiled in 2 cases:\n+  \/\/ 1) Field events and interp_only mode are not enabled for this thread.\n+  \/\/ This method is called from any thread. The thread filtering is done later.\n+  \/\/ 2) The same JNI call is stll executing after event was enabled.\n+  \/\/ In this case the last frame is only marked for deoptimization but still remains compiled.\n@@ -2206,4 +2211,10 @@\n-  post_field_access(thread,\n-                    thread->last_frame().interpreter_frame_method(),\n-                    thread->last_frame().interpreter_frame_bcp(),\n-                    klass, h_obj, fieldID);\n+\n+  RegisterMap reg_map(thread,\n+                      RegisterMap::UpdateMap::skip,\n+                      RegisterMap::ProcessFrames::skip,\n+                      RegisterMap::WalkContinuation::skip);\n+  javaVFrame *jvf = thread->last_java_vframe(&reg_map);\n+  Method* method = jvf->method();\n+  address address = jvf->method()->code_base();\n+\n+  post_field_access(thread, method, address, klass, h_obj, fieldID);\n@@ -2270,0 +2281,5 @@\n+  \/\/ The last java frame might be compiled in 2 cases:\n+  \/\/ 1) Field events and interp_only mode are not enabled for this thread.\n+  \/\/ This method is called from any thread. The thread filtering is done later.\n+  \/\/ 2) The same JNI call is stll executing after event was enabled.\n+  \/\/ In this case the last frame is only marked for deoptimization but still remains compiled.\n@@ -2293,3 +2309,10 @@\n-  post_field_modification(thread,\n-                          thread->last_frame().interpreter_frame_method(),\n-                          thread->last_frame().interpreter_frame_bcp(),\n+\n+  RegisterMap reg_map(thread,\n+                      RegisterMap::UpdateMap::skip,\n+                      RegisterMap::ProcessFrames::skip,\n+                      RegisterMap::WalkContinuation::skip);\n+  javaVFrame *jvf = thread->last_java_vframe(&reg_map);\n+  Method* method = jvf->method();\n+  address address = jvf->method()->code_base();\n+\n+  post_field_modification(thread, method, address,\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test verifies that field access\/modification events are correctly posted from JNI.\n+ * @bug 8224852\n+ * @run main\/othervm\/native -agentlib:FieldEventsFromJNI FieldEventsFromJNI\n+ *\/\n+public class FieldEventsFromJNI {\n+\n+    private String accessField = \"accessFieldValue\";\n+    private String modifyField = \"modifyFieldValue\";\n+\n+    private native void enableEventsAndAccessField(int numOfEventsExpected, Thread eventThread);\n+    private native void enableEventsAndModifyField(int numOfEventsExpected, Thread eventThread);\n+\n+    void javaMethod(int numOfEventsExpected, Thread eventThread) {\n+        enableEventsAndAccessField(numOfEventsExpected, eventThread);\n+        enableEventsAndModifyField(numOfEventsExpected, eventThread);\n+    }\n+\n+    final static Object lock = new Object();\n+    volatile static boolean isAnotherThreadStarted = false;\n+\n+    public static void main(String[] args) throws InterruptedException {\n+        System.loadLibrary(\"FieldEventsFromJNI\");\n+        \/\/ anotherThread doesn't access fields, it is needed only to\n+        \/\/ enable notification somewhere.\n+        Thread anotherThread = new Thread(() -> {\n+            isAnotherThreadStarted = true;\n+            synchronized(lock) {\n+                lock.notify();\n+            }\n+            while(!Thread.currentThread().isInterrupted()) {\n+                Thread.yield();\n+            }\n+        });\n+        synchronized(lock) {\n+            anotherThread.start();\n+            while (!isAnotherThreadStarted) {\n+                lock.wait();\n+            }\n+        }\n+\n+        FieldEventsFromJNI testObject = new FieldEventsFromJNI();\n+        \/\/ Enable events while the thread is in the same JNI call.\n+        testObject.javaMethod(1, Thread.currentThread());\n+        \/\/ Verify that field access from JNI doesn't fail if events are\n+        \/\/ not enaled on this thread.\n+        testObject.javaMethod(0, anotherThread);\n+        anotherThread.interrupt();\n+        anotherThread.join();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/FieldEventsFromJNI\/FieldEventsFromJNI.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <inttypes.h>\n+#include <atomic>\n+\n+#include \"jvmti.h\"\n+#include \"jni.h\"\n+#include \"jvmti_common.hpp\"\n+\n+jvmtiEnv* jvmti_env;\n+\n+\/\/ The event counters are used to check events from different threads.\n+static std::atomic<jint> access_cnt{0};\n+static std::atomic<jint> modify_cnt{0};\n+\n+\n+static const char* TEST_CLASS_NAME    = \"LFieldEventsFromJNI;\";\n+\n+static const char* ACCESS_FIELD_NAME  = \"accessField\";\n+static const char* ACCESS_METHOD_NAME = \"enableEventsAndAccessField\";\n+static const char* MODIFY_FIELD_NAME  = \"modifyField\";\n+static const char* MODIFY_METHOD_NAME = \"enableEventsAndModifyField\";\n+\n+\n+static void JNICALL\n+cbFieldAccess(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread, jmethodID method,\n+              jlocation location, jclass field_klass, jobject object, jfieldID field) {\n+  char* m_name = get_method_name(jvmti, jni, method);\n+  LOG(\"The field access triggered from method '%s'\\n\", m_name);\n+  if (strcmp(m_name, ACCESS_METHOD_NAME) != 0) {\n+    fatal(jni, \"The method's name is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, m_name);\n+\n+  LOG(\"The location is %\" PRId64 \"\\n\", (int64_t)location);\n+  if (location != 0) {\n+    fatal(jni, \"The method's location should be 0 for jni call.\");\n+  }\n+\n+  char* f_name = get_field_name(jvmti, jni, field_klass, field);\n+  LOG(\"The field name '%s'\\n\", f_name);\n+  if (strcmp(f_name, ACCESS_FIELD_NAME) != 0) {\n+    fatal(jni, \"The access field is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, f_name);\n+\n+  char* obj_class_name = get_object_class_name(jvmti, jni, object);\n+  LOG(\"The object class '%s'\\n\", obj_class_name);\n+  if (strcmp(obj_class_name, TEST_CLASS_NAME) != 0) {\n+    fatal(jni, \"The fields's class name is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, obj_class_name);\n+\n+  access_cnt++;\n+}\n+\n+static void JNICALL\n+cbFieldModification(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread, jmethodID method,\n+                    jlocation location, jclass field_klass, jobject object, jfieldID field,\n+                    char signature_type, jvalue new_value) {\n+  char* m_name = get_method_name(jvmti, jni, method);\n+  LOG(\"The field modification triggered from method '%s'\\n\", m_name);\n+  if (strcmp(m_name, MODIFY_METHOD_NAME) != 0) {\n+    fatal(jni, \"The method's name is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, m_name);\n+\n+  LOG(\"The location is %\" PRId64 \"\\n\", (int64_t)location);\n+  if (location != 0) {\n+    fatal(jni, \"The method's location should be 0 for jni call.\");\n+  }\n+\n+  char* f_name = get_field_name(jvmti, jni, field_klass, field);\n+  LOG(\"The field name '%s'\\n\", f_name);\n+  if (strcmp(f_name, MODIFY_FIELD_NAME) != 0) {\n+    fatal(jni, \"The access field is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, f_name);\n+\n+  char* obj_class_name = get_object_class_name(jvmti, jni, object);\n+  LOG(\"The object class '%s'\\n\", obj_class_name);\n+  if (strcmp(obj_class_name, TEST_CLASS_NAME) != 0) {\n+    fatal(jni, \"The fields's class name is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, obj_class_name);\n+\n+  modify_cnt++;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  jvmtiEnv *jvmti = nullptr;\n+  jint res = vm->GetEnv((void **)&jvmti, JVMTI_VERSION_21);\n+  if (res != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jvmtiCapabilities capabilities;\n+  (void)memset(&capabilities, 0, sizeof (capabilities));\n+  capabilities.can_generate_field_access_events = true;\n+  capabilities.can_generate_field_modification_events = true;\n+  err = jvmti->AddCapabilities(&capabilities);\n+  check_jvmti_error(err, \"AddCapabilities\");\n+  jvmtiEventCallbacks callbacks;\n+  (void)memset(&callbacks, 0, sizeof (callbacks));\n+  callbacks.FieldAccess = &cbFieldAccess;\n+  callbacks.FieldModification = &cbFieldModification;\n+  err = jvmti->SetEventCallbacks(&callbacks, (int)sizeof (jvmtiEventCallbacks));\n+  check_jvmti_error(err, \"SetEventCallbacks\");\n+  jvmti_env = jvmti;\n+  return JNI_OK;\n+}\n+\n+extern \"C\" {\n+JNIEXPORT void JNICALL\n+Java_FieldEventsFromJNI_enableEventsAndAccessField(\n+    JNIEnv *jni, jobject self, jint numOfEventsExpected, jthread eventThread) {\n+\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+\n+  jclass cls = jni->GetObjectClass(self);\n+  if (cls == nullptr) {\n+    fatal(jni, \"No class found\");\n+  }\n+  jfieldID fieldToRead = jni->GetFieldID(cls, ACCESS_FIELD_NAME, \"Ljava\/lang\/String;\");\n+  if (fieldToRead == nullptr) {\n+    fatal(jni, \"No field found\");\n+  }\n+\n+  \/\/ Set watch and access field without returning to calling java code\n+  access_cnt = 0;\n+  err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_ACCESS, eventThread);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+  err = jvmti_env->SetFieldAccessWatch(cls, fieldToRead);\n+  check_jvmti_error(err, \"SetFieldAccessWatch\");\n+\n+  jstring jvalue = (jstring)jni->GetObjectField(self, fieldToRead);\n+\n+  err = jvmti_env->ClearFieldAccessWatch(cls, fieldToRead);\n+  check_jvmti_error(err, \"ClearFieldAccessWatch\");\n+  err = jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_FIELD_ACCESS, eventThread);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+\n+  const char* value_str = jni->GetStringUTFChars(jvalue, nullptr);\n+\n+  if (access_cnt != numOfEventsExpected) {\n+    char buffer[100];\n+    snprintf(buffer, sizeof(buffer),\n+        \"Incorrect field access count: %d. Should be %d.\",\n+        (int)access_cnt, numOfEventsExpected);\n+    fatal(jni, buffer);\n+  }\n+  jni->ReleaseStringUTFChars(jvalue, value_str);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_FieldEventsFromJNI_enableEventsAndModifyField(\n+    JNIEnv *jni, jobject self, jint numOfEventsExpected, jthread eventThread) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jclass cls = jni->GetObjectClass(self);\n+  if (cls == nullptr) {\n+    fatal(jni, \"No class found\");\n+  }\n+  jfieldID fieldToModify = jni->GetFieldID(cls, MODIFY_FIELD_NAME, \"Ljava\/lang\/String;\");\n+  if (fieldToModify == nullptr) {\n+    fatal(jni, \"No field found\");\n+  }\n+\n+  modify_cnt = 0;\n+  err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_MODIFICATION, eventThread);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+  err = jvmti_env->SetFieldModificationWatch(cls, fieldToModify);\n+  check_jvmti_error(err, \"SetFieldAccessWatch\");\n+  jstring jvalue = jni->NewStringUTF(\"newValue\");\n+\n+  jni->SetObjectField(self, fieldToModify, jvalue);\n+\n+  err = jvmti_env->ClearFieldModificationWatch(cls, fieldToModify);\n+  check_jvmti_error(err, \"ClearFieldAccessWatch\");\n+  err = jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_FIELD_MODIFICATION, eventThread);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+\n+  if (modify_cnt != numOfEventsExpected) {\n+    char buffer[100];\n+    snprintf(buffer, sizeof(buffer),\n+        \"Incorrect field modification count: %d. Should be %d.\",\n+        (int)modify_cnt, numOfEventsExpected);\n+    fatal(jni, buffer);\n+  }\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/FieldEventsFromJNI\/libFieldEventsFromJNI.cpp","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"},{"patch":"@@ -327,0 +327,18 @@\n+static char*\n+get_field_name(jvmtiEnv *jvmti, JNIEnv* jni, jclass field_class, jfieldID field) {\n+  char* name = nullptr;\n+  jvmtiError err = jvmti->GetFieldName(field_class, field, &name, nullptr, nullptr);\n+  check_jvmti_status(jni, err, \"get_field_name: error in JVMTI GetFieldName call\");\n+  return name;\n+}\n+\n+static char*\n+get_object_class_name(jvmtiEnv *jvmti, JNIEnv* jni, jobject object) {\n+  char *obj_class_name = nullptr;\n+  jclass object_class = jni->GetObjectClass(object);\n+  jvmtiError err = jvmti->GetClassSignature(object_class, &obj_class_name, nullptr);\n+  check_jvmti_error(err, \"GetClassSignature\");\n+  jni->DeleteLocalRef(object_class);\n+  return obj_class_name;\n+}\n+\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/jvmti_common.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"}]}