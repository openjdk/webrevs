{"files":[{"patch":"@@ -2184,0 +2184,4 @@\n+  \/\/ The last java frame might be compiled if the event was enabled while the thread was in JNI.\n+  \/\/ In this case the frame is only marked for deoptimization but still remains compiled.\n+  \/\/ Also, the last frame might be compiled if events were not enabled for\n+  \/\/ this thread. The thread filtering is done later.\n@@ -2206,4 +2210,19 @@\n-  post_field_access(thread,\n-                    thread->last_frame().interpreter_frame_method(),\n-                    thread->last_frame().interpreter_frame_bcp(),\n-                    klass, h_obj, fieldID);\n+\n+\n+  frame last_frame = thread->last_frame();\n+  Method *method;\n+  address address;\n+\n+  if (last_frame.is_interpreted_frame()) {\n+    method = last_frame.interpreter_frame_method();\n+    address = last_frame.interpreter_frame_bcp();\n+  } else {\n+    RegisterMap reg_map(thread,\n+                        RegisterMap::UpdateMap::skip,\n+                        RegisterMap::ProcessFrames::skip,\n+                        RegisterMap::WalkContinuation::skip);\n+    javaVFrame *jvf = thread->last_java_vframe(&reg_map);\n+    method = jvf->method();\n+    address = jvf->method()->code_base();\n+  }\n+  post_field_access(thread, method, address, klass, h_obj, fieldID);\n@@ -2270,0 +2289,5 @@\n+  \/\/ The last java frame might be compiled if the event was enabled while the thread was in JNI.\n+  \/\/ In this case the frame is only marked for deoptimization but still remains compiled.\n+  \/\/ Also, the last frame might be compiled if events were not enabled for\n+  \/\/ this thread. The thread filtering is done later.\n+\n@@ -2293,3 +2317,19 @@\n-  post_field_modification(thread,\n-                          thread->last_frame().interpreter_frame_method(),\n-                          thread->last_frame().interpreter_frame_bcp(),\n+\n+  frame last_frame = thread->last_frame();\n+  Method *method;\n+  address address;\n+\n+  if (last_frame.is_interpreted_frame()) {\n+    method = last_frame.interpreter_frame_method();\n+    address = last_frame.interpreter_frame_bcp();\n+  } else {\n+    RegisterMap reg_map(thread,\n+                        RegisterMap::UpdateMap::skip,\n+                        RegisterMap::ProcessFrames::skip,\n+                        RegisterMap::WalkContinuation::skip);\n+    javaVFrame *jvf = thread->last_java_vframe(&reg_map);\n+    method = jvf->method();\n+    address = jvf->method()->code_base();\n+  }\n+\n+  post_field_modification(thread, method, address,\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":47,"deletions":7,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test verifies that field access\/modification events are correctly posted from JNI.\n+ * @bug 8224852\n+ * @run main\/othervm\/native -agentlib:JvmtiFieldEventsFromJNI TestFieldsEventsFromJNI\n+ * @run main\/othervm\/native -agentlib:JvmtiFieldEventsFromJNI -Xcomp TestFieldsEventsFromJNI\n+ *\/\n+public class TestFieldsEventsFromJNI {\n+\n+    private String accessField = \"accessFieldValue\";\n+    private String modifyField = \"modifyFieldValue\";\n+\n+    private native void enableEventsAndAccessField(boolean isEventExpected, Thread eventThread);\n+    private native void enableEventsAndModifyField(boolean isEventExpected, Thread eventThread);\n+\n+    void javaMethod(boolean isEventExpected, Thread eventThread) {\n+        enableEventsAndAccessField(isEventExpected, eventThread);\n+        enableEventsAndModifyField(isEventExpected, eventThread);\n+    }\n+\n+    final static Object lock = new Object();\n+    volatile static boolean isAnotherThreadStarted = false;\n+\n+    public static void main(String[] args) throws InterruptedException {\n+        System.loadLibrary(\"JvmtiFieldEventsFromJNI\");\n+        TestFieldsEventsFromJNI c = new TestFieldsEventsFromJNI();\n+        \/\/ anotherThread doesn't access fields, it is needed only to\n+        \/\/ enable notification somewhere.\n+        Thread anotherThread = new Thread(() -> {\n+            isAnotherThreadStarted = true;\n+            synchronized(lock) {\n+                lock.notify();\n+            }\n+            while(!Thread.currentThread().isInterrupted()) {\n+                Thread.yield();\n+            }\n+        });\n+        synchronized(lock) {\n+            anotherThread.start();\n+            while(!isAnotherThreadStarted) {\n+                lock.wait();\n+            }\n+        }\n+        \/\/ Enable events while the thread is in the same JNI call.\n+        c.javaMethod(true, Thread.currentThread());\n+        \/\/ Verify that field access from JNI doesn't fail if events are\n+        \/\/ not enaled on this thread.\n+        c.javaMethod(false, anotherThread);\n+        anotherThread.interrupt();\n+        anotherThread.join();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/FieldEventsFromJNI\/TestFieldsEventsFromJNI.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <inttypes.h>\n+\n+#include \"jvmti.h\"\n+#include \"jni.h\"\n+#include \"jvmti_common.hpp\"\n+\n+jvmtiEnv* jvmti_env;\n+\n+static int access_cnt = 0;\n+static int modify_cnt = 0;\n+\n+static char*\n+get_object_class_name(jvmtiEnv *jvmti, JNIEnv* jni, jobject object) {\n+  char *obj_class_name = nullptr;\n+  jclass object_class = jni->GetObjectClass(object);\n+  jvmtiError err = jvmti->GetClassSignature(object_class, &obj_class_name, nullptr);\n+  check_jvmti_error(err, \"GetClassSignature\");\n+  jni->DeleteLocalRef(object_class);\n+  return obj_class_name;\n+}\n+\n+static void JNICALL\n+cbFieldAccess(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread, jmethodID method,\n+              jlocation location, jclass field_klass, jobject object, jfieldID field) {\n+  char* m_name = get_method_name(jvmti, jni, method);\n+  LOG(\"The field access triggered from method '%s'\\n\", m_name);\n+  if (strcmp(m_name, \"enableEventsAndAccessField\") != 0) {\n+    fatal(jni, \"The method's name is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, m_name);\n+\n+\n+  LOG(\"The location is %\" PRId64 \"\\n\", (int64_t)location);\n+  if (location != 0) {\n+    fatal(jni, \"The method's location should be 0 for jni call.\");\n+  }\n+\n+  char* f_name = get_field_name(jvmti, jni, field_klass, field);\n+  LOG(\"The field name '%s'\\n\", f_name);\n+  if (strcmp(f_name, \"accessField\") != 0) {\n+    fatal(jni, \"The access field is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, f_name);\n+\n+\n+  char* obj_class_name = get_object_class_name(jvmti, jni, object);\n+  LOG(\"The object class '%s'\\n\", obj_class_name);\n+  if (strcmp(obj_class_name, \"LTestFieldsEventsFromJNI;\") != 0) {\n+    fatal(jni, \"The fields's class name is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, obj_class_name);\n+\n+  access_cnt++;\n+}\n+\n+static void JNICALL\n+cbFieldModification(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread, jmethodID method,\n+                    jlocation location, jclass field_klass, jobject object, jfieldID field,\n+                    char signature_type, jvalue new_value) {\n+  char* m_name = get_method_name(jvmti, jni, method);\n+  LOG(\"The field modification triggered from method '%s'\\n\", m_name);\n+  if (strcmp(m_name, \"enableEventsAndModifyField\") != 0) {\n+    fatal(jni, \"The method's name is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, m_name);\n+\n+  LOG(\"The location is %\" PRId64 \"\\n\", (int64_t)location);\n+  if (location != 0) {\n+    fatal(jni, \"The method's location should be 0 for jni call.\");\n+  }\n+\n+  char* f_name = get_field_name(jvmti, jni, field_klass, field);\n+  LOG(\"The field name '%s'\\n\", f_name);\n+  if (strcmp(f_name, \"modifyField\") != 0) {\n+    fatal(jni, \"The access field is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, f_name);\n+\n+\n+  char* obj_class_name = get_object_class_name(jvmti, jni, object);\n+  LOG(\"The object class '%s'\\n\", obj_class_name);\n+  if (strcmp(obj_class_name, \"LTestFieldsEventsFromJNI;\") != 0) {\n+    fatal(jni, \"The fields's class name is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, obj_class_name);\n+\n+  modify_cnt++;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  jvmtiEnv *jvmti = nullptr;\n+  jint res = vm->GetEnv((void **) &jvmti, JVMTI_VERSION_21);\n+  if (res != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jvmtiCapabilities capabilities;\n+  (void) memset(&capabilities, 0, sizeof (capabilities));\n+  capabilities.can_generate_field_access_events = true;\n+  capabilities.can_generate_field_modification_events = true;\n+  err = jvmti->AddCapabilities(&capabilities);\n+  check_jvmti_error(err, \"AddCapabilities\");\n+  jvmtiEventCallbacks callbacks;\n+  (void) memset(&callbacks, 0, sizeof (callbacks));\n+  callbacks.FieldAccess = &cbFieldAccess;\n+  callbacks.FieldModification = &cbFieldModification;\n+  err = jvmti->SetEventCallbacks(&callbacks, (int) sizeof (jvmtiEventCallbacks));\n+  check_jvmti_error(err, \"SetEventCallbacks\");\n+  jvmti_env = jvmti;\n+  return JNI_OK;\n+}\n+\n+\n+extern \"C\" {\n+JNIEXPORT void JNICALL\n+Java_TestFieldsEventsFromJNI_enableEventsAndAccessField(\n+    JNIEnv *jni, jobject self, jboolean isEventExpected, jthread eventThread) {\n+\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+\n+  jclass cls = jni->GetObjectClass(self);\n+  if (cls == nullptr) {\n+    fatal(jni, \"No class found\");\n+  }\n+  jfieldID fieldToRead = jni->GetFieldID(cls, \"accessField\", \"Ljava\/lang\/String;\");\n+  if (fieldToRead == nullptr) {\n+    fatal(jni, \"No field found\");\n+  }\n+\n+  \/\/ Set watch and access field without returning to calling java code\n+  access_cnt = 0;\n+  err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_ACCESS, eventThread);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+  err = jvmti_env->SetFieldAccessWatch(cls, fieldToRead);\n+  check_jvmti_error(err, \"SetFieldAccessWatch\");\n+\n+  jstring jname = (jstring)jni->GetObjectField(self, fieldToRead);\n+\n+  err = jvmti_env->ClearFieldAccessWatch(cls, fieldToRead);\n+  check_jvmti_error(err, \"ClearFieldAccessWatch\");\n+  err = jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_FIELD_ACCESS, eventThread);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+\n+  const char* name_str = jni->GetStringUTFChars(jname, nullptr);\n+  LOG(\"The field %s\\n\", name_str);\n+  if (strcmp(name_str, \"accessFieldValue\") != 0) {\n+    fatal(jni, \"The field value is incorrect.\");\n+  }\n+\n+  if (access_cnt != isEventExpected) {\n+    fatal(jni, \"The field access count is incorrect.\");\n+  }\n+  jni->ReleaseStringUTFChars(jname, name_str);\n+}\n+\n+\n+JNIEXPORT void JNICALL\n+Java_TestFieldsEventsFromJNI_enableEventsAndModifyField(\n+    JNIEnv *jni, jobject self, jboolean isEventExpected, jthread eventThread) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jclass cls = jni->GetObjectClass(self);\n+  if (cls == nullptr) {\n+    fatal(jni, \"No class found\");\n+  }\n+  jfieldID fieldToModify = jni->GetFieldID(cls, \"modifyField\", \"Ljava\/lang\/String;\");\n+  if (fieldToModify == nullptr) {\n+    fatal(jni, \"No field found\");\n+  }\n+\n+  modify_cnt = 0;\n+  err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_MODIFICATION, eventThread);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+  err = jvmti_env->SetFieldModificationWatch(cls, fieldToModify);\n+  check_jvmti_error(err, \"SetFieldAccessWatch\");\n+  jstring jval = jni->NewStringUTF(\"newValue\");\n+\n+  jni->SetObjectField(self, fieldToModify, jval);\n+\n+  err = jvmti_env->ClearFieldModificationWatch(cls, fieldToModify);\n+  check_jvmti_error(err, \"ClearFieldAccessWatch\");\n+  err = jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_FIELD_MODIFICATION, eventThread);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+\n+  if (modify_cnt != isEventExpected) {\n+    fatal(jni, \"The field access count should be 1.\");\n+  }\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/FieldEventsFromJNI\/libJvmtiFieldEventsFromJNI.cpp","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"},{"patch":"@@ -327,0 +327,12 @@\n+static char*\n+get_field_name(jvmtiEnv *jvmti, JNIEnv* jni, jclass field_class, jfieldID field) {\n+  char* name = nullptr;\n+  char* signature = nullptr;\n+  char* generic = nullptr;\n+  jvmtiError err = jvmti->GetFieldName(field_class, field, &name, &signature, &generic);\n+  check_jvmti_status(jni, err, \"get_field_name: error in JVMTI GetFieldName call\");\n+  deallocate(jvmti,jni, signature);\n+  deallocate(jvmti,jni, generic);\n+  return name;\n+}\n+\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/jvmti_common.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}