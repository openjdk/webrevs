{"files":[{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.util.Arrays;\n+import java.security.*;\n+import java.security.spec.*;\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+import static com.sun.crypto.provider.KWUtil.*;\n+\n+\/**\n+ * This class implement the AES KeyWrap mode of operation as defined in\n+ * <a href=https:\/\/nvlpubs.nist.gov\/nistpubs\/SpecialPublications\/NIST.SP.800-38F.pdf>\n+ * \"Recommendation for Block Cipher Modes of Operation: Methods for Key Wrapping\"<\/a>\n+ * and represents AES cipher in KW mode.\n+ *\/\n+class AESKeyWrap extends FeedbackCipher {\n+\n+    \/\/ default integrity check value (icv) if iv is not supplied\n+    private static final byte[] ICV1 = {\n+        (byte) 0xA6, (byte) 0xA6, (byte) 0xA6, (byte) 0xA6,\n+        (byte) 0xA6, (byte) 0xA6, (byte) 0xA6, (byte) 0xA6\n+    };\n+\n+    AESKeyWrap() {\n+        super(new AESCrypt());\n+    }\n+\n+    \/**\n+     * Gets the name of this feedback mode.\n+     *\n+     * @return the string <code>KW<\/code>\n+     *\/\n+    @Override\n+    String getFeedback() {\n+        return \"KW\";\n+    }\n+\n+    \/**\n+     * Save the current content of this cipher.\n+     *\/\n+    @Override\n+    void save() {\n+        throw new UnsupportedOperationException(\"save not supported\");\n+    };\n+\n+    \/**\n+     * Restores the content of this cipher to the previous saved one.\n+     *\/\n+    @Override\n+    void restore() {\n+        throw new UnsupportedOperationException(\"restore not supported\");\n+    };\n+\n+    \/**\n+     * Initializes the cipher in the specified mode with the given key\n+     * and iv.\n+     *\n+     * @param decrypting flag indicating encryption or decryption\n+     * @param algorithm the algorithm name\n+     * @param key the key\n+     * @param iv the iv\n+     *\n+     * @exception InvalidKeyException if the given key is inappropriate for\n+     * initializing this cipher\n+     * @exception InvalidAlgorithmParameterException if the given iv is\n+     * non-null and not the right length\n+     *\/\n+    @Override\n+    void init(boolean decrypting, String algorithm, byte[] key, byte[] iv)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        if (key == null) {\n+            throw new InvalidKeyException(\"Invalid null key\");\n+        }\n+        if (iv != null && iv.length != ICV1.length) {\n+            throw new InvalidAlgorithmParameterException(\"Invalid IV\");\n+        }\n+        embeddedCipher.init(decrypting, algorithm, key);\n+        \/\/ iv is retrieved from IvParameterSpec.getIV() which is already cloned\n+        this.iv = (iv == null? ICV1 : iv);\n+    }\n+\n+    \/**\n+     * Resets the iv to its original value.\n+     * This is used when doFinal is called in the Cipher class, so that the\n+     * cipher can be reused (with its original iv).\n+     *\/\n+    @Override\n+    void reset() {\n+        throw new UnsupportedOperationException(\"reset not supported\");\n+    };\n+\n+\n+    \/\/ no support for multi-part encryption\n+    @Override\n+    int encrypt(byte[] pt, int ptOfs, int ptLen, byte[] ct, int ctOfs) {\n+        throw new UnsupportedOperationException(\"multi-part not supported\");\n+    };\n+\n+    \/\/ no support for multi-part decryption\n+    @Override\n+    int decrypt(byte[] ct, int ctOfs, int ctLen, byte[] pt, int ptOfs) {\n+        throw new UnsupportedOperationException(\"multi-part not supported\");\n+    };\n+\n+    \/**\n+     * Performs single-part encryption operation.\n+     *\n+     * <p>The input <code>pt<\/code>, starting at <code>ptOfs<\/code>\n+     * and ending at <code>(ptOfs+ptLen-1)<\/code>, is encrypted.\n+     * The result is stored in <code>ct<\/code>, starting at <code>ctOfs<\/code>.\n+     *\n+     * <p>The subclass that implements Cipher should ensure that\n+     * <code>init<\/code> has been called before this method is called.\n+     *\n+     * @param pt the input buffer with the data to be encrypted\n+     * @param ptOfs the offset in <code>pt<\/code>\n+     * @param ptLen the length of the input data\n+     * @param ct the buffer for the encryption result\n+     * @param ctOfs the offset in <code>ct<\/code>\n+     * @return the number of bytes placed into <code>ct<\/code>\n+     *\/\n+    @Override\n+    int encryptFinal(byte[] pt, int dummy1, int ptLen, byte[] dummy3,\n+            int dummy4) throws IllegalBlockSizeException {\n+        \/\/ adjust the min value since pt contains the first semi-block\n+        if (ptLen < (BLKSIZE + SEMI_BLKSIZE) || (ptLen % SEMI_BLKSIZE) != 0) {\n+            throw new IllegalBlockSizeException(\"data should\" +\n+                \" be at least 16 bytes and multiples of 8\");\n+        }\n+        \/\/ assert ptOfs == 0; ct == pt; ctOfs == 0;\n+        W(pt, ptLen, embeddedCipher);\n+        return ptLen;\n+    }\n+\n+    \/**\n+     * Performs single-part decryption operation.\n+     *\n+     * <p>The input <code>ct<\/code>, starting at <code>ctOfs<\/code>\n+     * and ending at <code>(ctOfs+ctLen-1)<\/code>, is decrypted.\n+     * The result is stored in <code>pt<\/code>, starting at\n+     * <code>ptOfs<\/code>.\n+     *\n+     * <p>The subclass that implements Cipher should ensure that\n+     * <code>init<\/code> has been called before this method is called.\n+     *\n+     * @param ct the input buffer with the data to be decrypted\n+     * @param ctOfs the offset in <code>ct<\/code>\n+     * @param ctLen the length of the input data\n+     * @param pt the buffer for the decryption result\n+     * @param ptOfs the offset in <code>pt<\/code>\n+     * @return the number of bytes placed into <code>pt<\/code>\n+     *\/\n+    @Override\n+    int decryptFinal(byte[] ct, int dummy1, int ctLen, byte[] dummy3,\n+            int dummy4) throws IllegalBlockSizeException {\n+        \/\/ assert ctOfs == 0; ctLen == ct.length; pt == ct; ptOfs == 0\n+        if (ctLen < (BLKSIZE + SEMI_BLKSIZE) || (ctLen % SEMI_BLKSIZE) != 0) {\n+            throw new IllegalBlockSizeException\n+                (\"data should be at least 24 bytes and multiples of 8\");\n+        }\n+        byte[] ivOut = new byte[ICV1.length];\n+        W_INV(ct, ctLen, ivOut, embeddedCipher);\n+        ctLen -= SEMI_BLKSIZE;\n+\n+        \/\/ check against icv and fail if not match\n+        if (!Arrays.equals(ivOut, 0, ICV1.length, this.iv, 0, ICV1.length)) {\n+            throw new IllegalBlockSizeException(\"Integrity check failed\");\n+        }\n+        return ctLen;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESKeyWrap.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.util.Arrays;\n+import java.security.*;\n+import java.security.spec.*;\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+import static com.sun.crypto.provider.KWUtil.*;\n+\n+\/**\n+ * This class implement the AES KeyWrap With Padding mode of operation as\n+ * defined in\n+ * <a href=https:\/\/nvlpubs.nist.gov\/nistpubs\/SpecialPublications\/NIST.SP.800-38F.pdf>\n+ * \"Recommendation for Block Cipher Modes of Operation: Methods for Key Wrapping\"<\/a>\n+ * and represents AES cipher in KWP mode.\n+ *\/\n+class AESKeyWrapPadded extends FeedbackCipher {\n+\n+    \/\/ default integrity check value (icv) if iv is not supplied\n+    private static final byte[] ICV2 = {\n+        (byte) 0xA6, (byte) 0x59, (byte) 0x59, (byte) 0xA6,\n+    };\n+\n+    private static final byte[] PAD_BLK = new byte[SEMI_BLKSIZE - 1];\n+\n+    \/\/ generate internal 8-byte iv based on icv and input length\n+    private static byte[] generateIV(byte[] icv, int inLen) {\n+        if (icv.length != ICV2.length) throw new RuntimeException(\"Invalid iv\");\n+        byte[] newIv = Arrays.copyOf(icv, SEMI_BLKSIZE);\n+        newIv[4] = (byte) ((inLen >>> 24) & 0xFF);\n+        newIv[5] = (byte) ((inLen >>> 16) & 0xFF);\n+        newIv[6] = (byte) ((inLen >>> 8) & 0xFF);\n+        newIv[7] = (byte) (inLen & 0xFF);\n+        return newIv;\n+    }\n+\n+    \/\/ validate the recovered internal iv against icv and return the\n+    \/\/ expected input length\n+    private static int validateIV(byte[] ivAndLen, byte[] icv)\n+            throws IllegalBlockSizeException {\n+        \/\/ check against icv and fail if not match\n+        if (!Arrays.equals(ivAndLen, 0, ICV2.length, icv, 0, ICV2.length)) {\n+            throw new IllegalBlockSizeException(\"Integrity check failed\");\n+        }\n+        int outLen = ivAndLen[4];\n+\n+        for (int k = 5; k < SEMI_BLKSIZE; k++) {\n+            if (outLen != 0) {\n+                outLen <<= SEMI_BLKSIZE;\n+            }\n+            outLen |= ivAndLen[k] & 0xFF;\n+        }\n+        return outLen;\n+    }\n+\n+    AESKeyWrapPadded() {\n+        super(new AESCrypt());\n+    }\n+\n+    \/**\n+     * Gets the name of this feedback mode.\n+     *\n+     * @return the string <code>KW<\/code>\n+     *\/\n+    @Override\n+    String getFeedback() {\n+        return \"KWP\";\n+    }\n+\n+    \/**\n+     * Save the current content of this cipher.\n+     *\/\n+    @Override\n+    void save() {\n+        throw new UnsupportedOperationException(\"save not supported\");\n+    };\n+\n+    \/**\n+     * Restores the content of this cipher to the previous saved one.\n+     *\/\n+    @Override\n+    void restore() {\n+        throw new UnsupportedOperationException(\"restore not supported\");\n+    };\n+\n+    \/**\n+     * Initializes the cipher in the specified mode with the given key\n+     * and iv.\n+     *\n+     * @param decrypting flag indicating encryption or decryption\n+     * @param algorithm the algorithm name\n+     * @param key the key\n+     * @param iv the iv\n+     *\n+     * @exception InvalidKeyException if the given key is inappropriate for\n+     * initializing this cipher\n+     * @exception InvalidAlgorithmParameterException if the given iv is\n+     * non-null and not the right length\n+     *\/\n+    @Override\n+    void init(boolean decrypting, String algorithm, byte[] key, byte[] iv)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        if (key == null) {\n+            throw new InvalidKeyException(\"Invalid null key\");\n+        }\n+        if (iv != null && iv.length != ICV2.length) {\n+            throw new InvalidAlgorithmParameterException(\"Invalid IV length\");\n+        }\n+        embeddedCipher.init(decrypting, algorithm, key);\n+        \/\/ iv is retrieved from IvParameterSpec.getIV() which is already cloned\n+        this.iv = (iv == null? ICV2 : iv);\n+    }\n+\n+    \/**\n+     * Resets the iv to its original value.\n+     * This is used when doFinal is called in the Cipher class, so that the\n+     * cipher can be reused (with its original iv).\n+     *\/\n+    @Override\n+    void reset() {\n+        throw new UnsupportedOperationException(\"reset not supported\");\n+    };\n+\n+    \/\/ no support for multi-part encryption\n+    @Override\n+    int encrypt(byte[] pt, int ptOfs, int ptLen, byte[] ct, int ctOfs) {\n+        throw new UnsupportedOperationException(\"multi-part not supported\");\n+    };\n+\n+    \/\/ no support for multi-part decryption\n+    @Override\n+    int decrypt(byte[] ct, int ctOfs, int ctLen, byte[] pt, int ptOfs) {\n+        throw new UnsupportedOperationException(\"multi-part not supported\");\n+    };\n+\n+    \/**\n+     * Performs single-part encryption operation.\n+     *\n+     * <p>The input <code>pt<\/code>, starting at <code>ptOfs<\/code>\n+     * and ending at <code>(ptOfs+ptLen-1)<\/code>, is encrypted.\n+     * The result is stored in <code>ct<\/code>, starting at <code>ctOfs<\/code>.\n+     *\n+     * <p>The subclass that implements Cipher should ensure that\n+     * <code>init<\/code> has been called before this method is called.\n+     *\n+     * @param pt the input buffer with the data to be encrypted\n+     * @param ptOfs the offset in <code>pt<\/code>\n+     * @param ptLen the length of the input data\n+     * @param ct the buffer for the encryption result\n+     * @param ctOfs the offset in <code>ct<\/code>\n+     * @return the number of bytes placed into <code>ct<\/code>\n+     *\/\n+    @Override\n+    int encryptFinal(byte[] pt, int dummy1, int ptLen, byte[] dummy3,\n+            int dummy4) throws IllegalBlockSizeException {\n+        \/\/ assert ptOfs == 0; ptLen == pt.length; ct == pt; ctOfs == 0\n+        int actualLen = ptLen - SEMI_BLKSIZE;\n+        if (actualLen < 1) {\n+            throw new IllegalBlockSizeException\n+                (\"data should have at least 1 byte\");\n+        }\n+        \/\/ overwrite the ZERO4 place holder with actual input length\n+        pt[4] = (byte) ((actualLen >>> 24) & 0xFF);\n+        pt[5] = (byte) ((actualLen >>> 16) & 0xFF);\n+        pt[6] = (byte) ((actualLen >>> 8) & 0xFF);\n+        pt[7] = (byte) (actualLen & 0xFF);\n+\n+        if (ptLen % SEMI_BLKSIZE != 0) {\n+            int rem = SEMI_BLKSIZE - (ptLen % SEMI_BLKSIZE);\n+            System.arraycopy(PAD_BLK, 0, pt, ptLen, rem);\n+            ptLen += rem;\n+        }\n+        if (ptLen <= BLKSIZE) {\n+            embeddedCipher.encryptBlock(pt, 0, pt, 0);\n+        } else {\n+            W(pt, ptLen, embeddedCipher);\n+        }\n+        return ptLen;\n+    }\n+\n+    \/**\n+     * Performs single-part decryption operation.\n+     *\n+     * <p>The input <code>ct<\/code>, starting at <code>ctOfs<\/code>\n+     * and ending at <code>(ctOfs+ctLen-1)<\/code>, is decrypted.\n+     * The result is stored in <code>pt<\/code>, starting at <code>ptOfs<\/code>.\n+     *\n+     * <p>The subclass that implements Cipher should ensure that\n+     * <code>init<\/code> has been called before this method is called.\n+     *\n+     * @param ct the input buffer with the data to be decrypted\n+     * @param ctOfs the offset in <code>ct<\/code>\n+     * @param ctLen the length of the input data\n+     * @param pt the buffer for the decryption result\n+     * @param ptOfs the offset in <code>pt<\/code>\n+     * @return the number of bytes placed into <code>pt<\/code>\n+     *\/\n+    @Override\n+    int decryptFinal(byte[] ct, int dummy1, int ctLen, byte[] dummy3,\n+            int dummy4) throws IllegalBlockSizeException {\n+        \/\/ assert ctOfs == 0; ctLen == ct.length; pt == ct; ptOfs == 0\n+        if (ctLen < BLKSIZE || ctLen % SEMI_BLKSIZE != 0) {\n+            throw new IllegalBlockSizeException\n+                (\"data should be at least 16 bytes and multiples of 8\");\n+        }\n+\n+        \/\/ We cannot directly use 'out' as we don't know whether there\n+        \/\/ are padding bytes\n+        byte[] ivAndLen = new byte[SEMI_BLKSIZE];\n+        if (ctLen == BLKSIZE) {\n+            embeddedCipher.decryptBlock(ct, 0, ct, 0);\n+            System.arraycopy(ct, 0, ivAndLen, 0, SEMI_BLKSIZE);\n+            System.arraycopy(ct, SEMI_BLKSIZE, ct, 0, SEMI_BLKSIZE);\n+        } else {\n+            W_INV(ct, ctLen, ivAndLen, embeddedCipher);\n+        }\n+        ctLen -= SEMI_BLKSIZE;\n+\n+        int outLen = validateIV(ivAndLen, this.iv);\n+        \/\/ check padding bytes\n+        int padLen = ctLen - outLen;\n+        for (int k = padLen; k > 0; k--) {\n+            if (ct[ctLen - k] != 0) {\n+                throw new IllegalBlockSizeException(\"KWP Pad check failed\");\n+            }\n+        }\n+        return outLen;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESKeyWrapPadded.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -1,511 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.crypto.provider;\n-\n-import java.util.Arrays;\n-import java.security.*;\n-import java.security.spec.*;\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n-\n-\/**\n- * This class implements the AES KeyWrap algorithm as defined\n- * in <a href=http:\/\/www.w3.org\/TR\/xmlenc-core\/#sec-Alg-SymmetricKeyWrap>\n- * \"XML Encryption Syntax and Processing\" section 5.6.3 \"AES Key Wrap\".\n- * Note: only <code>ECB<\/code> mode and <code>NoPadding<\/code> padding\n- * can be used for this algorithm.\n- *\n- * @author Valerie Peng\n- *\n- *\n- * @see AESCipher\n- *\/\n-abstract class AESWrapCipher extends CipherSpi {\n-    public static final class General extends AESWrapCipher {\n-        public General() {\n-            super(-1);\n-        }\n-    }\n-    public static final class AES128 extends AESWrapCipher {\n-        public AES128() {\n-            super(16);\n-        }\n-    }\n-    public static final class AES192 extends AESWrapCipher {\n-        public AES192() {\n-            super(24);\n-        }\n-    }\n-    public static final class AES256 extends AESWrapCipher {\n-        public AES256() {\n-            super(32);\n-        }\n-    }\n-    private static final byte[] IV = {\n-        (byte) 0xA6, (byte) 0xA6, (byte) 0xA6, (byte) 0xA6,\n-        (byte) 0xA6, (byte) 0xA6, (byte) 0xA6, (byte) 0xA6\n-    };\n-\n-    private static final int blksize = AESConstants.AES_BLOCK_SIZE;\n-\n-    \/*\n-     * internal cipher object which does the real work.\n-     *\/\n-    private AESCrypt cipher;\n-\n-    \/*\n-     * are we encrypting or decrypting?\n-     *\/\n-    private boolean decrypting = false;\n-\n-    \/*\n-     * needed to support AES oids which associates a fixed key size\n-     * to the cipher object.\n-     *\/\n-    private final int fixedKeySize; \/\/ in bytes, -1 if no restriction\n-\n-    \/**\n-     * Creates an instance of AES KeyWrap cipher with default\n-     * mode, i.e. \"ECB\" and padding scheme, i.e. \"NoPadding\".\n-     *\/\n-    public AESWrapCipher(int keySize) {\n-        cipher = new AESCrypt();\n-        fixedKeySize = keySize;\n-\n-    }\n-\n-    \/**\n-     * Sets the mode of this cipher. Only \"ECB\" mode is accepted for this\n-     * cipher.\n-     *\n-     * @param mode the cipher mode\n-     *\n-     * @exception NoSuchAlgorithmException if the requested cipher mode\n-     * is not \"ECB\".\n-     *\/\n-    protected void engineSetMode(String mode)\n-        throws NoSuchAlgorithmException {\n-        if (!mode.equalsIgnoreCase(\"ECB\")) {\n-            throw new NoSuchAlgorithmException(mode + \" cannot be used\");\n-        }\n-    }\n-\n-    \/**\n-     * Sets the padding mechanism of this cipher. Only \"NoPadding\" schmem\n-     * is accepted for this cipher.\n-     *\n-     * @param padding the padding mechanism\n-     *\n-     * @exception NoSuchPaddingException if the requested padding mechanism\n-     * is not \"NoPadding\".\n-     *\/\n-    protected void engineSetPadding(String padding)\n-        throws NoSuchPaddingException {\n-        if (!padding.equalsIgnoreCase(\"NoPadding\")) {\n-            throw new NoSuchPaddingException(padding + \" cannot be used\");\n-        }\n-    }\n-\n-    \/**\n-     * Returns the block size (in bytes). i.e. 16 bytes.\n-     *\n-     * @return the block size (in bytes), i.e. 16 bytes.\n-     *\/\n-    protected int engineGetBlockSize() {\n-        return blksize;\n-    }\n-\n-    \/**\n-     * Returns the length in bytes that an output buffer would need to be\n-     * given the input length <code>inputLen<\/code> (in bytes).\n-     *\n-     * <p>The actual output length of the next <code>update<\/code> or\n-     * <code>doFinal<\/code> call may be smaller than the length returned\n-     * by this method.\n-     *\n-     * @param inputLen the input length (in bytes)\n-     *\n-     * @return the required output buffer size (in bytes)\n-     *\/\n-    protected int engineGetOutputSize(int inputLen) {\n-        \/\/ can only return an upper-limit if not initialized yet.\n-        int result = 0;\n-        if (decrypting) {\n-            result = inputLen - 8;\n-        } else {\n-            result = Math.addExact(inputLen, 8);\n-        }\n-        return (result < 0? 0:result);\n-    }\n-\n-    \/**\n-     * Returns the initialization vector (IV) which is null for this cipher.\n-     *\n-     * @return null for this cipher.\n-     *\/\n-    protected byte[] engineGetIV() {\n-        return null;\n-    }\n-\n-    \/**\n-     * Initializes this cipher with a key and a source of randomness.\n-     *\n-     * <p>The cipher only supports the following two operation modes:<b>\n-     * Cipher.WRAP_MODE, and <b>\n-     * Cipher.UNWRAP_MODE.\n-     * <p>For modes other than the above two, UnsupportedOperationException\n-     * will be thrown.\n-     *\n-     * @param opmode the operation mode of this cipher. Only\n-     * <code>WRAP_MODE<\/code> or <code>UNWRAP_MODE<\/code>) are accepted.\n-     * @param key the secret key.\n-     * @param random the source of randomness.\n-     *\n-     * @exception InvalidKeyException if the given key is inappropriate for\n-     * initializing this cipher.\n-     *\/\n-    protected void engineInit(int opmode, Key key, SecureRandom random)\n-        throws InvalidKeyException {\n-        if (opmode == Cipher.WRAP_MODE) {\n-            decrypting = false;\n-        } else if (opmode == Cipher.UNWRAP_MODE) {\n-            decrypting = true;\n-        } else {\n-            throw new UnsupportedOperationException(\"This cipher can \" +\n-                \"only be used for key wrapping and unwrapping\");\n-        }\n-        AESCipher.checkKeySize(key, fixedKeySize);\n-        cipher.init(decrypting, key.getAlgorithm(), key.getEncoded());\n-    }\n-\n-    \/**\n-     * Initializes this cipher with a key, a set of algorithm parameters,\n-     * and a source of randomness.\n-     *\n-     * <p>The cipher only supports the following two operation modes:<b>\n-     * Cipher.WRAP_MODE, and <b>\n-     * Cipher.UNWRAP_MODE.\n-     * <p>For modes other than the above two, UnsupportedOperationException\n-     * will be thrown.\n-     *\n-     * @param opmode the operation mode of this cipher. Only\n-     * <code>WRAP_MODE<\/code> or <code>UNWRAP_MODE<\/code>) are accepted.\n-     * @param key the secret key.\n-     * @param params the algorithm parameters; must be null for this cipher.\n-     * @param random the source of randomness.\n-     *\n-     * @exception InvalidKeyException if the given key is inappropriate for\n-     * initializing this cipher\n-     * @exception InvalidAlgorithmParameterException if the given algorithm\n-     * parameters is not null.\n-     *\/\n-    protected void engineInit(int opmode, Key key,\n-                              AlgorithmParameterSpec params,\n-                              SecureRandom random)\n-        throws InvalidKeyException, InvalidAlgorithmParameterException {\n-        if (params != null) {\n-            throw new InvalidAlgorithmParameterException(\"This cipher \" +\n-                \"does not accept any parameters\");\n-        }\n-        engineInit(opmode, key, random);\n-    }\n-\n-    \/**\n-     * Initializes this cipher with a key, a set of algorithm parameters,\n-     * and a source of randomness.\n-     *\n-     * <p>The cipher only supports the following two operation modes:<b>\n-     * Cipher.WRAP_MODE, and <b>\n-     * Cipher.UNWRAP_MODE.\n-     * <p>For modes other than the above two, UnsupportedOperationException\n-     * will be thrown.\n-     *\n-     * @param opmode the operation mode of this cipher. Only\n-     * <code>WRAP_MODE<\/code> or <code>UNWRAP_MODE<\/code>) are accepted.\n-     * @param key the secret key.\n-     * @param params the algorithm parameters; must be null for this cipher.\n-     * @param random the source of randomness.\n-     *\n-     * @exception InvalidKeyException if the given key is inappropriate.\n-     * @exception InvalidAlgorithmParameterException if the given algorithm\n-     * parameters is not null.\n-     *\/\n-    protected void engineInit(int opmode, Key key,\n-                              AlgorithmParameters params,\n-                              SecureRandom random)\n-        throws InvalidKeyException, InvalidAlgorithmParameterException {\n-        if (params != null) {\n-            throw new InvalidAlgorithmParameterException(\"This cipher \" +\n-                \"does not accept any parameters\");\n-        }\n-        engineInit(opmode, key, random);\n-    }\n-\n-    \/**\n-     * This operation is not supported by this cipher.\n-     * Since it's impossible to initialize this cipher given the\n-     * current Cipher.engineInit(...) implementation,\n-     * IllegalStateException will always be thrown upon invocation.\n-     *\n-     * @param in the input buffer.\n-     * @param inOffset the offset in <code>in<\/code> where the input\n-     * starts.\n-     * @param inLen the input length.\n-     *\n-     * @return n\/a.\n-     *\n-     * @exception IllegalStateException upon invocation of this method.\n-     *\/\n-    protected byte[] engineUpdate(byte[] in, int inOffset, int inLen) {\n-        throw new IllegalStateException(\"Cipher has not been initialized\");\n-    }\n-\n-    \/**\n-     * This operation is not supported by this cipher.\n-     * Since it's impossible to initialize this cipher given the\n-     * current Cipher.engineInit(...) implementation,\n-     * IllegalStateException will always be thrown upon invocation.\n-     *\n-     * @param in the input buffer.\n-     * @param inOffset the offset in <code>in<\/code> where the input\n-     * starts.\n-     * @param inLen the input length.\n-     * @param out the buffer for the result.\n-     * @param outOffset the offset in <code>out<\/code> where the result\n-     * is stored.\n-     *\n-     * @return n\/a.\n-     *\n-     * @exception IllegalStateException upon invocation of this method.\n-     *\/\n-    protected int engineUpdate(byte[] in, int inOffset, int inLen,\n-                               byte[] out, int outOffset)\n-        throws ShortBufferException {\n-        throw new IllegalStateException(\"Cipher has not been initialized\");\n-    }\n-\n-    \/**\n-     * This operation is not supported by this cipher.\n-     * Since it's impossible to initialize this cipher given the\n-     * current Cipher.engineInit(...) implementation,\n-     * IllegalStateException will always be thrown upon invocation.\n-     *\n-     * @param input the input buffer\n-     * @param inputOffset the offset in <code>in<\/code> where the input\n-     * starts\n-     * @param inputLen the input length.\n-     *\n-     * @return n\/a.\n-     *\n-     * @exception IllegalStateException upon invocation of this method.\n-     *\/\n-    protected byte[] engineDoFinal(byte[] input, int inputOffset,\n-                                   int inputLen)\n-        throws IllegalBlockSizeException, BadPaddingException {\n-        throw new IllegalStateException(\"Cipher has not been initialized\");\n-    }\n-\n-    \/**\n-     * This operation is not supported by this cipher.\n-     * Since it's impossible to initialize this cipher given the\n-     * current Cipher.engineInit(...) implementation,\n-     * IllegalStateException will always be thrown upon invocation.\n-     *\n-     * @param in the input buffer.\n-     * @param inOffset the offset in <code>in<\/code> where the input\n-     * starts.\n-     * @param inLen the input length.\n-     * @param out the buffer for the result.\n-     * @param outOffset the ofset in <code>out<\/code> where the result\n-     * is stored.\n-     *\n-     * @return n\/a.\n-     *\n-     * @exception IllegalStateException upon invocation of this method.\n-     *\/\n-    protected int engineDoFinal(byte[] in, int inOffset, int inLen,\n-                                byte[] out, int outOffset)\n-        throws IllegalBlockSizeException, ShortBufferException,\n-               BadPaddingException {\n-        throw new IllegalStateException(\"Cipher has not been initialized\");\n-    }\n-\n-    \/**\n-     * Returns the parameters used with this cipher which is always null\n-     * for this cipher.\n-     *\n-     * @return null since this cipher does not use any parameters.\n-     *\/\n-    protected AlgorithmParameters engineGetParameters() {\n-        return null;\n-    }\n-\n-    \/**\n-     * Returns the key size of the given key object in number of bits.\n-     *\n-     * @param key the key object.\n-     *\n-     * @return the \"effective\" key size of the given key object.\n-     *\n-     * @exception InvalidKeyException if <code>key<\/code> is invalid.\n-     *\/\n-    protected int engineGetKeySize(Key key) throws InvalidKeyException {\n-        byte[] encoded = key.getEncoded();\n-        if (!AESCrypt.isKeySizeValid(encoded.length)) {\n-            throw new InvalidKeyException(\"Invalid key length: \" +\n-                                          encoded.length + \" bytes\");\n-        }\n-        return Math.multiplyExact(encoded.length, 8);\n-    }\n-\n-    \/**\n-     * Wrap a key.\n-     *\n-     * @param key the key to be wrapped.\n-     *\n-     * @return the wrapped key.\n-     *\n-     * @exception IllegalBlockSizeException if this cipher is a block\n-     * cipher, no padding has been requested, and the length of the\n-     * encoding of the key to be wrapped is not a\n-     * multiple of the block size.\n-     *\n-     * @exception InvalidKeyException if it is impossible or unsafe to\n-     * wrap the key with this cipher (e.g., a hardware protected key is\n-     * being passed to a software only cipher).\n-     *\/\n-    protected byte[] engineWrap(Key key)\n-        throws IllegalBlockSizeException, InvalidKeyException {\n-        byte[] keyVal = key.getEncoded();\n-        if ((keyVal == null) || (keyVal.length == 0)) {\n-            throw new InvalidKeyException(\"Cannot get an encoding of \" +\n-                                          \"the key to be wrapped\");\n-        }\n-        byte[] out = new byte[Math.addExact(keyVal.length, 8)];\n-\n-        if (keyVal.length == 8) {\n-            System.arraycopy(IV, 0, out, 0, IV.length);\n-            System.arraycopy(keyVal, 0, out, IV.length, 8);\n-            cipher.encryptBlock(out, 0, out, 0);\n-        } else {\n-            if (keyVal.length % 8 != 0) {\n-                throw new IllegalBlockSizeException(\"length of the \" +\n-                    \"to be wrapped key should be multiples of 8 bytes\");\n-            }\n-            System.arraycopy(IV, 0, out, 0, IV.length);\n-            System.arraycopy(keyVal, 0, out, IV.length, keyVal.length);\n-            int N = keyVal.length\/8;\n-            byte[] buffer = new byte[blksize];\n-            for (int j = 0; j < 6; j++) {\n-                for (int i = 1; i <= N; i++) {\n-                    int T = i + j*N;\n-                    System.arraycopy(out, 0, buffer, 0, IV.length);\n-                    System.arraycopy(out, i*8, buffer, IV.length, 8);\n-                    cipher.encryptBlock(buffer, 0, buffer, 0);\n-                    for (int k = 1; T != 0; k++) {\n-                        byte v = (byte) T;\n-                        buffer[IV.length - k] ^= v;\n-                        T >>>= 8;\n-                    }\n-                    System.arraycopy(buffer, 0, out, 0, IV.length);\n-                    System.arraycopy(buffer, 8, out, 8*i, 8);\n-                }\n-            }\n-        }\n-        return out;\n-    }\n-\n-    \/**\n-     * Unwrap a previously wrapped key.\n-     *\n-     * @param wrappedKey the key to be unwrapped.\n-     *\n-     * @param wrappedKeyAlgorithm the algorithm the wrapped key is for.\n-     *\n-     * @param wrappedKeyType the type of the wrapped key.\n-     * This is one of <code>Cipher.SECRET_KEY<\/code>,\n-     * <code>Cipher.PRIVATE_KEY<\/code>, or <code>Cipher.PUBLIC_KEY<\/code>.\n-     *\n-     * @return the unwrapped key.\n-     *\n-     * @exception NoSuchAlgorithmException if no installed providers\n-     * can create keys of type <code>wrappedKeyType<\/code> for the\n-     * <code>wrappedKeyAlgorithm<\/code>.\n-     *\n-     * @exception InvalidKeyException if <code>wrappedKey<\/code> does not\n-     * represent a wrapped key of type <code>wrappedKeyType<\/code> for\n-     * the <code>wrappedKeyAlgorithm<\/code>.\n-     *\/\n-    protected Key engineUnwrap(byte[] wrappedKey,\n-                               String wrappedKeyAlgorithm,\n-                               int wrappedKeyType)\n-        throws InvalidKeyException, NoSuchAlgorithmException {\n-        int wrappedKeyLen = wrappedKey.length;\n-        \/\/ ensure the wrappedKey length is multiples of 8 bytes and non-zero\n-        if (wrappedKeyLen == 0) {\n-            throw new InvalidKeyException(\"The wrapped key is empty\");\n-        }\n-        if (wrappedKeyLen % 8 != 0) {\n-            throw new InvalidKeyException\n-                (\"The wrapped key has invalid key length\");\n-        }\n-        byte[] out = new byte[wrappedKeyLen - 8];\n-        byte[] buffer = new byte[blksize];\n-        if (wrappedKeyLen == 16) {\n-            cipher.decryptBlock(wrappedKey, 0, buffer, 0);\n-            for (int i = 0; i < IV.length; i++) {\n-                if (IV[i] != buffer[i]) {\n-                    throw new InvalidKeyException(\"Integrity check failed\");\n-                }\n-            }\n-            System.arraycopy(buffer, IV.length, out, 0, out.length);\n-        } else {\n-            System.arraycopy(wrappedKey, 0, buffer, 0, IV.length);\n-            System.arraycopy(wrappedKey, IV.length, out, 0, out.length);\n-            int N = out.length\/8;\n-            for (int j = 5; j >= 0; j--) {\n-                for (int i = N; i > 0; i--) {\n-                    int T = i + j*N;\n-                    System.arraycopy(out, 8*(i-1), buffer, IV.length, 8);\n-                    for (int k = 1; T != 0; k++) {\n-                        byte v = (byte) T;\n-                        buffer[IV.length - k] ^= v;\n-                        T >>>= 8;\n-                    }\n-                    cipher.decryptBlock(buffer, 0, buffer, 0);\n-                    System.arraycopy(buffer, IV.length, out, 8*(i-1), 8);\n-                }\n-            }\n-            for (int i = 0; i < IV.length; i++) {\n-                if (IV[i] != buffer[i]) {\n-                    throw new InvalidKeyException(\"Integrity check failed\");\n-                }\n-            }\n-        }\n-        return ConstructKeys.constructKey(out, wrappedKeyAlgorithm,\n-                                          wrappedKeyType);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESWrapCipher.java","additions":0,"deletions":511,"binary":false,"changes":511,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-\n+import java.util.Arrays;\n@@ -61,3 +61,2 @@\n-                                              String encodedKeyAlgorithm)\n-        throws InvalidKeyException, NoSuchAlgorithmException\n-    {\n+            String encodedKeyAlgorithm)\n+            throws InvalidKeyException, NoSuchAlgorithmException {\n@@ -65,1 +64,0 @@\n-\n@@ -112,3 +110,2 @@\n-                                                String encodedKeyAlgorithm)\n-        throws InvalidKeyException, NoSuchAlgorithmException\n-    {\n+            String encodedKeyAlgorithm)\n+            throws InvalidKeyException, NoSuchAlgorithmException {\n@@ -163,3 +160,2 @@\n-                                              String encodedKeyAlgorithm)\n-    {\n-        return (new SecretKeySpec(encodedKey, encodedKeyAlgorithm));\n+            int ofs, int len, String encodedKeyAlgorithm) {\n+        return (new SecretKeySpec(encodedKey, ofs, len, encodedKeyAlgorithm));\n@@ -169,3 +165,1 @@\n-                                  int keyType)\n-        throws InvalidKeyException, NoSuchAlgorithmException {\n-        Key result = null;\n+            int keyType) throws InvalidKeyException, NoSuchAlgorithmException {\n@@ -174,3 +168,2 @@\n-            result = ConstructKeys.constructSecretKey(encoding,\n-                                                      keyAlgorithm);\n-            break;\n+            return ConstructKeys.constructSecretKey(encoding, 0,\n+                    encoding.length, keyAlgorithm);\n@@ -178,3 +171,1 @@\n-            result = ConstructKeys.constructPrivateKey(encoding,\n-                                                       keyAlgorithm);\n-            break;\n+            return ConstructKeys.constructPrivateKey(encoding, keyAlgorithm);\n@@ -182,3 +173,23 @@\n-            result = ConstructKeys.constructPublicKey(encoding,\n-                                                      keyAlgorithm);\n-            break;\n+            return ConstructKeys.constructPublicKey(encoding, keyAlgorithm);\n+        default:\n+            throw new RuntimeException(\"Unsupported key type\");\n+        }\n+    }\n+\n+    static final Key constructKey(byte[] encoding, int ofs, int len,\n+            String keyAlgorithm, int keyType)\n+            throws InvalidKeyException, NoSuchAlgorithmException {\n+        if (keyType == Cipher.SECRET_KEY) {\n+            return ConstructKeys.constructSecretKey(encoding, ofs, len,\n+                    keyAlgorithm);\n+        } else {\n+            if (ofs == 0 && len == encoding.length) {\n+                return constructKey(encoding, keyAlgorithm, keyType);\n+            } else {\n+                byte[] encoding2 = Arrays.copyOfRange(encoding, ofs, ofs + len);\n+                try {\n+                    return constructKey(encoding2, keyAlgorithm, keyType);\n+                } finally {\n+                    Arrays.fill(encoding2, (byte)0);\n+                }\n+            }\n@@ -186,1 +197,0 @@\n-        return result;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ConstructKeys.java","additions":35,"deletions":25,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.io.*;\n+import java.security.AlgorithmParametersSpi;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+\n+\/**\n+ * This class implements the parameter (IV) used with the AES algorithm in\n+ * KWP mode. IV is defined in the standards as follows:\n+ *\n+ * <pre>\n+ * IV ::= OCTET STRING  -- 4 octets\n+ * <\/pre>\n+ *\n+ *\/\n+\n+public final class KWPParameters extends AlgorithmParametersSpi {\n+\n+    private BlockCipherParamsCore core;\n+\n+    public KWPParameters() {\n+        \/\/ same length as AESKeyWrapPadded.ICV2\n+        core = new BlockCipherParamsCore(4);\n+    }\n+    protected void engineInit(AlgorithmParameterSpec paramSpec)\n+        throws InvalidParameterSpecException {\n+        core.init(paramSpec);\n+    }\n+\n+    protected void engineInit(byte[] encoded)\n+        throws IOException {\n+        core.init(encoded);\n+    }\n+\n+    protected void engineInit(byte[] encoded, String decodingMethod)\n+        throws IOException {\n+        core.init(encoded, decodingMethod);\n+    }\n+\n+    protected <T extends AlgorithmParameterSpec>\n+        T engineGetParameterSpec(Class<T> paramSpec)\n+        throws InvalidParameterSpecException {\n+        if (AlgorithmParameterSpec.class.isAssignableFrom(paramSpec)) {\n+            return core.getParameterSpec(paramSpec);\n+        } else {\n+            throw new InvalidParameterSpecException\n+                (\"Inappropriate parameter Specification\");\n+        }\n+    }\n+\n+    protected byte[] engineGetEncoded() throws IOException {\n+        return core.getEncoded();\n+    }\n+\n+    protected byte[] engineGetEncoded(String encodingMethod)\n+        throws IOException {\n+        return core.getEncoded();\n+    }\n+\n+    protected String engineToString() {\n+        return core.toString();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KWPParameters.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.io.*;\n+import java.security.AlgorithmParametersSpi;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+\n+\/**\n+ * This class implements the parameter (IV) used with the AES algorithm in\n+ * KW mode. IV is defined in the standards as follows:\n+ *\n+ * <pre>\n+ * IV ::= OCTET STRING  -- 8 octets\n+ * <\/pre>\n+ *\n+ *\/\n+\n+public final class KWParameters extends AlgorithmParametersSpi {\n+\n+    private BlockCipherParamsCore core;\n+\n+    public KWParameters() {\n+        core = new BlockCipherParamsCore(8); \/\/ same length as AESKeyWrap.ICV1\n+    }\n+    protected void engineInit(AlgorithmParameterSpec paramSpec)\n+        throws InvalidParameterSpecException {\n+        core.init(paramSpec);\n+    }\n+\n+    protected void engineInit(byte[] encoded)\n+        throws IOException {\n+        core.init(encoded);\n+    }\n+\n+    protected void engineInit(byte[] encoded, String decodingMethod)\n+        throws IOException {\n+        core.init(encoded, decodingMethod);\n+    }\n+\n+    protected <T extends AlgorithmParameterSpec>\n+        T engineGetParameterSpec(Class<T> paramSpec)\n+        throws InvalidParameterSpecException {\n+        if (AlgorithmParameterSpec.class.isAssignableFrom(paramSpec)) {\n+            return core.getParameterSpec(paramSpec);\n+        } else {\n+            throw new InvalidParameterSpecException\n+                (\"Inappropriate parameter Specification\");\n+        }\n+    }\n+\n+    protected byte[] engineGetEncoded() throws IOException {\n+        return core.getEncoded();\n+    }\n+\n+    protected byte[] engineGetEncoded(String encodingMethod)\n+        throws IOException {\n+        return core.getEncoded();\n+    }\n+\n+    protected String engineToString() {\n+        return core.toString();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KWParameters.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.util.Arrays;\n+import java.security.*;\n+import java.security.spec.*;\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+\n+\/**\n+ * This class acts as the base class for AES KeyWrap algorithms as defined\n+ * in <a href=https:\/\/nvlpubs.nist.gov\/nistpubs\/SpecialPublications\/NIST.SP.800-38F.pdf>\n+ * \"Recommendation for Block Cipher Modes of Operation: Methods for Key Wrapping\"\n+ *\/\n+class KWUtil {\n+\n+    static final int BLKSIZE = 16;\n+    static final int SEMI_BLKSIZE = BLKSIZE >> 1;\n+\n+    \/*\n+     * The wrapping function W as defined in section 6.1 of NIST SP 800-38F as\n+     * well as sec 2.2.1 of RFC 3394.\n+     * @param in input bytes\n+     * @param inLen length of the to-be-processed bytes\n+     * @param cipher the initialized cipher object used\n+     *\/\n+    static final void W(byte[] in, int inLen, SymmetricCipher cipher) {\n+        \/\/ assert (inLen % SEMI_BLKSIZE == 0) {\n+        int n = inLen \/ SEMI_BLKSIZE - 1;\n+\n+        byte[] buffer = new byte[BLKSIZE];\n+        byte[] out = in; \/\/ in-place\n+        for (int j = 0; j < 6; j++) {\n+            for (int i = 1; i <= n; i++) {\n+                int T = i + j*n;\n+                System.arraycopy(out, 0, buffer, 0, SEMI_BLKSIZE);\n+                System.arraycopy(out, i << 3, buffer, SEMI_BLKSIZE, 8);\n+                cipher.encryptBlock(buffer, 0, buffer, 0);\n+                for (int k = 1; T != 0; k++) {\n+                    byte v = (byte) T;\n+                    buffer[SEMI_BLKSIZE - k] ^= v;\n+                    T >>>= SEMI_BLKSIZE;\n+                }\n+                System.arraycopy(buffer, 0, out, 0, SEMI_BLKSIZE);\n+                System.arraycopy(buffer, SEMI_BLKSIZE, out, i << 3,\n+                        SEMI_BLKSIZE);\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * The unwrapping function W^-1 as defined in section 6.1 of NIST SP\n+     * 800-38F as well as sec 2.2.2 of RFC 3394.\n+     * - separated out the initial value from the remaining recovered data\n+     * - no output buffer argument since we cannot write out the recovered\n+     *   data until the initial value and padding bytes are verified.\n+     * @param in input bytes, i.e. the to-be-processed data\n+     * @param inLen length of the to-be-processed bytes\n+     * @param ivOut buffer for holding the recovered ICV semiblock\n+     * @param cipher the initialized cipher object used\n+     *\/\n+    static final void W_INV(byte[] in, int inLen, byte[] ivOut,\n+            SymmetricCipher cipher) {\n+        int outLen = inLen - SEMI_BLKSIZE;\n+        \/\/ assert inLen?\n+        \/\/ assert (ivOut.length == SEMI_BLKSIZE)\n+\n+        byte[] buffer = new byte[BLKSIZE];\n+        System.arraycopy(in, 0, buffer, 0, SEMI_BLKSIZE);\n+        System.arraycopy(in, SEMI_BLKSIZE, in, 0, inLen - SEMI_BLKSIZE);\n+        int n = (inLen - SEMI_BLKSIZE) \/ SEMI_BLKSIZE;\n+\n+        for (int j = 5; j >= 0; j--) {\n+            for (int i = n; i > 0; i--) {\n+                int T = i + n*j;\n+                int idx = (i-1) << 3;\n+                System.arraycopy(in, idx, buffer, SEMI_BLKSIZE, SEMI_BLKSIZE);\n+                for (int k = 1; T != 0; k++) {\n+                    byte v = (byte) T;\n+                    buffer[SEMI_BLKSIZE - k] ^= v;\n+                    T >>>= SEMI_BLKSIZE;\n+                }\n+                cipher.decryptBlock(buffer, 0, buffer, 0);\n+                System.arraycopy(buffer, SEMI_BLKSIZE, in, idx, SEMI_BLKSIZE);\n+            }\n+        }\n+        System.arraycopy(buffer, 0, ivOut, 0, SEMI_BLKSIZE);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KWUtil.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,753 @@\n+\/*\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.util.Arrays;\n+import java.security.*;\n+import java.security.spec.*;\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+import static com.sun.crypto.provider.KWUtil.*;\n+\n+\/**\n+ * This class is the impl class for AES KeyWrap algorithms as defined in\n+ * <a href=https:\/\/nvlpubs.nist.gov\/nistpubs\/SpecialPublications\/NIST.SP.800-38F.pdf>\n+ * \"Recommendation for Block Cipher Modes of Operation: Methods for Key Wrapping\"\n+ *\/\n+abstract class KeyWrapCipher extends CipherSpi {\n+\n+    \/\/ for AESWrap + AES\/KW\/NoPadding\n+    public static final class AES_KW_NoPadding extends KeyWrapCipher {\n+        public AES_KW_NoPadding() {\n+            super(new AESKeyWrap(), null, -1);\n+        }\n+    }\n+\n+    \/\/ for AESWrap_128 + AES_128\/KW\/NoPadding\n+    public static final class AES128_KW_NoPadding extends KeyWrapCipher {\n+        public AES128_KW_NoPadding() {\n+            super(new AESKeyWrap(), null, 16);\n+        }\n+    }\n+\n+    \/\/ for AESWrap_192 + AES_192\/KW\/NoPadding\n+    public static final class AES192_KW_NoPadding extends KeyWrapCipher {\n+        public AES192_KW_NoPadding() {\n+            super(new AESKeyWrap(), null, 24);\n+        }\n+    }\n+\n+    \/\/ for AESWrap_256 + AES_256\/KW\/NoPadding\n+    public static final class AES256_KW_NoPadding extends KeyWrapCipher {\n+        public AES256_KW_NoPadding() {\n+            super(new AESKeyWrap(), null, 32);\n+        }\n+    }\n+\n+    \/\/ for AES\/KW\/NoPadding\n+    public static final class AES_KW_PKCS5Padding extends KeyWrapCipher {\n+        public AES_KW_PKCS5Padding() {\n+            super(new AESKeyWrap(), new PKCS5Padding(16), -1);\n+        }\n+    }\n+\n+    \/\/ for AES_128\/KW\/NoPadding\n+    public static final class AES128_KW_PKCS5Padding extends KeyWrapCipher {\n+        public AES128_KW_PKCS5Padding() {\n+            super(new AESKeyWrap(), new PKCS5Padding(16), 16);\n+        }\n+    }\n+\n+    \/\/ for AES_192\/KW\/NoPadding\n+    public static final class AES192_KW_PKCS5Padding extends KeyWrapCipher {\n+        public AES192_KW_PKCS5Padding() {\n+            super(new AESKeyWrap(), new PKCS5Padding(16), 24);\n+        }\n+    }\n+\n+    \/\/ for AES_256\/KW\/NoPadding\n+    public static final class AES256_KW_PKCS5Padding extends KeyWrapCipher {\n+        public AES256_KW_PKCS5Padding() {\n+            super(new AESKeyWrap(), new PKCS5Padding(16), 32);\n+        }\n+    }\n+\n+    \/\/ for AES\/KWP\/NoPadding\n+    public static final class AES_KWP_NoPadding extends KeyWrapCipher {\n+        public AES_KWP_NoPadding() {\n+            super(new AESKeyWrapPadded(), null, -1);\n+        }\n+    }\n+\n+    \/\/ for AES_128\/KWP\/NoPadding\n+    public static final class AES128_KWP_NoPadding extends KeyWrapCipher {\n+        public AES128_KWP_NoPadding() {\n+            super(new AESKeyWrapPadded(), null, 16);\n+        }\n+    }\n+\n+    \/\/ for AES_192\/KWP\/NoPadding\n+    public static final class AES192_KWP_NoPadding extends KeyWrapCipher {\n+        public AES192_KWP_NoPadding() {\n+            super(new AESKeyWrapPadded(), null, 24);\n+        }\n+    }\n+\n+    \/\/ for AES_256\/KWP\/NoPadding\n+    public static final class AES256_KWP_NoPadding extends KeyWrapCipher {\n+        public AES256_KWP_NoPadding() {\n+            super(new AESKeyWrapPadded(), null, 32);\n+        }\n+    }\n+\n+    \/\/ place holder for AESKeyWrapPadded\n+    private static final byte[] ZERO4 = new byte[4];\n+\n+    \/\/ validate the input length, resize and store the specified bytes into\n+    \/\/ internal 'dataBuf' and updates 'dataIdx' accordingly\n+    \/\/ NOTE: if 'in' == null, this method will ensure that dataBuf has enough\n+    \/\/ capacity for 'inLen' bytes but will attempt to copy bytes from 'in'\n+    private void store(byte[] in, int inOfs, int inLen) {\n+        \/\/ In NIST SP 800-38F, KWP input size is limited to be no longer\n+        \/\/ than 2^32 bytes. Otherwise, the length cannot be encoded in 32 bits\n+        \/\/ However, given the current spec requirement that recovered text\n+        \/\/ can only be returned after successful tag verification, we are\n+        \/\/ bound by limiting the data size to the size limit of java byte array,\n+        \/\/ e.g. Integer.MAX_VALUE, since all data are returned by doFinal().\n+        int remain = Integer.MAX_VALUE - dataIdx;\n+        if (inLen > remain) {\n+            throw new ProviderException(\"SunJCE provider can only take \" +\n+                remain + \" more bytes\");\n+        }\n+\n+        \/\/ re-size dataBuf to the smallest (n * BLKSIZE) + SEMI_BLKSIZE)\n+        if (dataBuf.length - dataIdx < inLen) {\n+            int newSize = Math.addExact(dataIdx, inLen);\n+            int lastBlk = (dataIdx + inLen - SEMI_BLKSIZE) % BLKSIZE;\n+            if (lastBlk != 0 || padding != null) {\n+                newSize = Math.addExact(newSize, BLKSIZE - lastBlk);\n+            }\n+            dataBuf = Arrays.copyOf(dataBuf, newSize);\n+        }\n+\n+        if (in != null) {\n+            System.arraycopy(in, inOfs, dataBuf, dataIdx, inLen);\n+            dataIdx += inLen;\n+        }\n+    }\n+\n+    \/\/ internal cipher object which does the real work.\n+    private final FeedbackCipher cipher;\n+\n+    \/\/ internal padding object; null if NoPadding\n+    private final Padding padding;\n+\n+    \/\/ encrypting or decrypting?\n+    protected boolean decrypting = false;\n+\n+    \/*\n+     * needed to support oids which associates a fixed key size\n+     * to the cipher object.\n+     *\/\n+    private final int fixedKeySize; \/\/ in bytes, -1 if no restriction\n+\n+    \/\/ data buffering used for encrypt, decrypt and unwrap calls\n+    \/\/ must use store() to store data into dataBuf as it will resize if needed\n+    private byte[] dataBuf;\n+    private int dataIdx;\n+\n+    \/**\n+     * Creates an instance of KeyWrap cipher using the specified\n+     * symmetric cipher whose block size must be 128-bit, and\n+     * the supported mode and padding scheme.\n+     *\/\n+    public KeyWrapCipher(FeedbackCipher cipher, Padding padding, int keySize) {\n+        this.cipher = cipher;\n+        this.padding = padding;\n+        this.fixedKeySize = keySize;\n+        this.dataBuf = new byte[40];\n+        this.dataIdx = 0;\n+    }\n+\n+    \/**\n+     * Sets the mode of this cipher. Must match the mode specified in\n+     * the constructor.\n+     *\n+     * @param mode the cipher mode\n+     *\n+     * @exception NoSuchAlgorithmException if the requested cipher mode\n+     * does not match the supported mode\n+     *\/\n+    @Override\n+    protected void engineSetMode(String mode) throws NoSuchAlgorithmException {\n+        if (mode != null && !cipher.getFeedback().equalsIgnoreCase(mode)) {\n+            throw new NoSuchAlgorithmException(mode + \" cannot be used\");\n+        }\n+    }\n+\n+    \/**\n+     * Sets the padding mechanism of this cipher. Currently, only\n+     * \"NoPadding\" scheme is accepted for this cipher.\n+     *\n+     * @param padding the padding mechanism\n+     *\n+     * @exception NoSuchPaddingException if the requested padding mechanism\n+     * does not match the supported padding scheme\n+     *\/\n+    @Override\n+    protected void engineSetPadding(String padding)\n+            throws NoSuchPaddingException {\n+        if ((this.padding == null && !\"NoPadding\".equalsIgnoreCase(padding)) ||\n+                this.padding instanceof PKCS5Padding &&\n+                \"PKCS5Padding\".equalsIgnoreCase(padding)) {\n+            throw new NoSuchPaddingException();\n+        }\n+    }\n+\n+    \/**\n+     * Returns the block size (in bytes). i.e. 16 bytes.\n+     *\n+     * @return the block size (in bytes), i.e. 16 bytes.\n+     *\/\n+    @Override\n+    protected int engineGetBlockSize() {\n+        return cipher.getBlockSize();\n+    }\n+\n+    \/**\n+     * Returns the length in bytes that an output buffer would need to be\n+     * given the input length <code>inLen<\/code> (in bytes).\n+     *\n+     * <p>The actual output length of the next <code>update<\/code> or\n+     * <code>doFinal<\/code> call may be smaller than the length returned\n+     * by this method.\n+     *\n+     * @param inLen the input length (in bytes)\n+     *\n+     * @return the required output buffer size (in bytes)\n+     *\/\n+    protected int engineGetOutputSize(int inLen) {\n+        int result = inLen;\n+        int buffered = dataIdx - SEMI_BLKSIZE;\n+        if (buffered > 0) {\n+            result = Math.addExact(result, buffered);\n+        }\n+        if (!decrypting) {\n+            \/\/ calculate padding length first\n+            if (padding != null) {\n+                result = Math.addExact(result, padding.padLength(result));\n+            } else if (cipher instanceof AESKeyWrapPadded) {\n+                int n = result % SEMI_BLKSIZE;\n+                if (n != 0) {\n+                    result = Math.addExact(result, SEMI_BLKSIZE - n);\n+                }\n+            }\n+            \/\/ then add the first semiblock\n+            result = Math.addExact(result, SEMI_BLKSIZE);\n+        } else {\n+            result -= SEMI_BLKSIZE;\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Returns the initialization vector (IV).\n+     *\n+     * @return the user-specified iv or null if default iv is used.\n+     *\/\n+    @Override\n+    protected byte[] engineGetIV() {\n+        return cipher.getIV().clone();\n+    }\n+\n+    \/\/ write the IV semi-block into the specified buf\n+    private int writeIvSemiBlock(byte[] buf) {\n+        byte[] iv = cipher.getIV();\n+        if (buf == dataBuf) {\n+            store(iv, 0, iv.length);\n+            if (cipher instanceof AESKeyWrapPadded) {\n+                \/\/ write ZERO4 as place holder for now\n+                store(ZERO4, 0, 4);\n+            }\n+        } else {\n+            System.arraycopy(iv, 0, buf, 0, iv.length);\n+            if (cipher instanceof AESKeyWrapPadded) {\n+                \/\/ write ZERO4 as place holder for now\n+                System.arraycopy(ZERO4, 0, dataBuf, iv.length, 4);\n+            }\n+        }\n+        return SEMI_BLKSIZE;\n+    }\n+\n+    \/\/ actual impl for various engineInit(...) methods\n+    private void implInit(int opmode, Key key, byte[] iv, SecureRandom random)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        decrypting = (opmode == Cipher.DECRYPT_MODE ||\n+                opmode == Cipher.UNWRAP_MODE);\n+        byte[] keyBytes = key.getEncoded();\n+        if (keyBytes == null) {\n+            throw new InvalidKeyException(\"Null key\");\n+        }\n+        try {\n+            cipher.init(decrypting, key.getAlgorithm(), keyBytes, iv);\n+            dataIdx = 0;\n+        } finally {\n+            Arrays.fill(keyBytes, (byte) 0);\n+        }\n+    }\n+\n+    \/**\n+     * Initializes this cipher with a key and a source of randomness.\n+     *\n+     * @param opmode the operation mode of this cipher.\n+     * @param key the secret key.\n+     * @param random the source of randomness.\n+     *\n+     * @exception InvalidKeyException if the given key is inappropriate for\n+     * initializing this cipher.\n+     *\/\n+    @Override\n+    protected void engineInit(int opmode, Key key, SecureRandom random)\n+        throws InvalidKeyException {\n+        try {\n+            implInit(opmode, key, (byte[])null, random);\n+        } catch (InvalidAlgorithmParameterException iae) {\n+            \/\/ should never happen\n+            throw new AssertionError();\n+        }\n+    }\n+\n+    \/**\n+     * Initializes this cipher with a key, a set of algorithm parameters,\n+     * and a source of randomness.\n+     *\n+     * @param opmode the operation mode of this cipher.\n+     * @param key the secret key.\n+     * @param params the algorithm parameters; if not null, must be of type\n+     * IvParameterSpec\n+     * @param random the source of randomness.\n+     *\n+     * @exception InvalidKeyException if the given key is inappropriate for\n+     * initializing this cipher\n+     * @exception InvalidAlgorithmParameterException if the given algorithm\n+     * parameters is invalid.\n+     *\/\n+    @Override\n+    protected void engineInit(int opmode, Key key,\n+            AlgorithmParameterSpec params, SecureRandom random)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        if (params != null && !(params instanceof IvParameterSpec)) {\n+            throw new InvalidAlgorithmParameterException(\n+                \"Only IvParameterSpec is accepted\");\n+        }\n+        byte[] iv = (params == null? null : ((IvParameterSpec)params).getIV());\n+        implInit(opmode, key, iv, random);\n+    }\n+\n+    \/**\n+     * Initializes this cipher with a key, a set of algorithm parameters,\n+     * and a source of randomness.\n+     *\n+     * @param opmode the operation mode of this cipher.\n+     * @param key the secret key.\n+     * @param params the algorithm parameters; if not null, must be able to\n+     * be converted to IvParameterSpec.\n+     * @param random the source of randomness.\n+     *\n+     * @exception InvalidKeyException if the given key is inappropriate.\n+     * @exception InvalidAlgorithmParameterException if the given algorithm\n+     * parameters is invalid.\n+     *\/\n+    @Override\n+    protected void engineInit(int opmode, Key key, AlgorithmParameters params,\n+            SecureRandom random) throws InvalidKeyException,\n+            InvalidAlgorithmParameterException {\n+        byte[] iv = null;\n+        if (params != null) {\n+            try {\n+                AlgorithmParameterSpec spec =\n+                        params.getParameterSpec(IvParameterSpec.class);\n+                iv = ((IvParameterSpec)spec).getIV();\n+            } catch (InvalidParameterSpecException ispe) {\n+                throw new InvalidAlgorithmParameterException(\n+                    \"Only IvParameterSpec is accepted\");\n+            }\n+        }\n+        try {\n+            implInit(opmode, key, iv, random);\n+        } catch (IllegalArgumentException iae) {\n+            throw new InvalidAlgorithmParameterException(iae.getMessage());\n+        }\n+    }\n+\n+    \/**\n+     * See CipherSpi.engineUpdate(...) - buffers data internally as\n+     * only single part operation is supported.\n+     *\n+     * @param in the input buffer.\n+     * @param inOffset the offset in <code>in<\/code> where the input\n+     * starts.\n+     * @param inLen the input length.\n+     *\n+     * @return null.\n+     *\/\n+    @Override\n+    protected byte[] engineUpdate(byte[] in, int inOffset, int inLen) {\n+        if (!decrypting && dataIdx == 0) {\n+            writeIvSemiBlock(dataBuf);\n+        }\n+        store(in, inOffset, inLen);\n+        return null;\n+    }\n+\n+    \/**\n+     * See CipherSpi.engineUpdate(...) - buffers data internally as\n+     * only single part operation is supported.\n+     *\n+     * @param in the input buffer.\n+     * @param inOffset the offset in <code>in<\/code> where the input\n+     * starts.\n+     * @param inLen the input length.\n+     * @param out the buffer for the result.\n+     * @param outOffset the offset in <code>out<\/code> where the result\n+     * is stored.\n+     *\n+     * @return n\/a.\n+     *\n+     * @exception IllegalStateException upon invocation of this method.\n+     *\/\n+    @Override\n+    protected int engineUpdate(byte[] in, int inOffset, int inLen,\n+            byte[] out, int outOffset) throws ShortBufferException {\n+\n+        if (!decrypting && dataIdx == 0) {\n+            writeIvSemiBlock(dataBuf);\n+        }\n+\n+        store(in, inOffset, inLen);\n+        return 0;\n+    }\n+\n+    \/**\n+     * See CipherSpi.engineDoFinal(...)\n+     *\n+     * @param input the input buffer\n+     * @param inputOffset the offset in <code>in<\/code> where the input\n+     * starts\n+     * @param inputLen the input length.\n+     *\n+     * @return n\/a.\n+     *\n+     * @exception IllegalStateException upon invocation of this method.\n+     *\/\n+    @Override\n+    protected byte[] engineDoFinal(byte[] in, int inOfs, int inLen)\n+            throws IllegalBlockSizeException, BadPaddingException {\n+        if (!decrypting && dataIdx == 0) {\n+            writeIvSemiBlock(dataBuf);\n+        }\n+\n+        if (inLen > 0) {\n+            store(in, inOfs, inLen);\n+        }\n+\n+        \/\/ if enc, add padding\n+        if (!decrypting) {\n+            int actualLen = dataIdx - SEMI_BLKSIZE;\n+            if (padding != null) {\n+                int paddingLen = padding.padLength(actualLen);\n+                \/\/ check and re-size dataBuf if needed\n+                store(null, 0, paddingLen);\n+                try {\n+                    padding.padWithLen(dataBuf, dataIdx, paddingLen);\n+                    dataIdx += paddingLen;\n+                } catch (ShortBufferException sbe) {\n+                    \/\/ should never happen\n+                    throw new AssertionError();\n+                }\n+            }\n+        }\n+        try {\n+            int outLen;\n+            if (decrypting) {\n+                outLen = cipher.decryptFinal(dataBuf, 0, dataIdx, null, -1);\n+                \/\/ unpad if padding is used\n+                if (padding != null) {\n+                    int padIdx = padding.unpad(dataBuf, 0, outLen);\n+                    if (padIdx <= 0) {\n+                        throw new BadPaddingException(\"Bad Padding: \" + padIdx);\n+                    }\n+                    outLen = padIdx;\n+                }\n+            } else {\n+                outLen = cipher.encryptFinal(dataBuf, 0, dataIdx, null, -1);\n+            }\n+            return Arrays.copyOf(dataBuf, outLen);\n+        } catch (ShortBufferException sbe) {\n+            \/\/ should never happen\n+            throw new AssertionError();\n+        } finally {\n+            \/\/ reset dataBuf for subsequent operations\n+            dataIdx = 0;\n+        }\n+    }\n+\n+    \/**\n+     * See CipherSpi.doFinal(...)\n+     *\n+     * @param in the input buffer.\n+     * @param inOffset the offset in <code>in<\/code> where the input\n+     * starts.\n+     * @param inLen the input length.\n+     * @param out the buffer for the result.\n+     * @param outOffset the ofset in <code>out<\/code> where the result\n+     * is stored.\n+     *\n+     * @return n\/a.\n+     *\n+     * @exception IllegalStateException upon invocation of this method.\n+     *\/\n+    protected int engineDoFinal(byte[] in, int inOfs, int inLen,\n+            byte[] out, int outOfs) throws IllegalBlockSizeException,\n+            ShortBufferException, BadPaddingException {\n+\n+        int estOutLen = engineGetOutputSize(inLen);\n+        if (out.length - outOfs < estOutLen) {\n+            throw new ShortBufferException(\"Need at least \" + estOutLen);\n+        }\n+\n+        if (!decrypting && dataIdx == 0) {\n+            writeIvSemiBlock(dataBuf);\n+        }\n+\n+        if (inLen > 0) {\n+            store(in, inOfs, inLen);\n+        }\n+\n+        \/\/ if enc, add padding\n+        if (!decrypting) {\n+            int actualLen = dataIdx - SEMI_BLKSIZE;\n+            if (padding != null) {\n+                int paddingLen = padding.padLength(actualLen);\n+                \/\/ check and re-size dataBuf if needed\n+                store(null, 0, paddingLen);\n+                try {\n+                    padding.padWithLen(dataBuf, dataIdx, paddingLen);\n+                    dataIdx += paddingLen;\n+                } catch (ShortBufferException sbe) {\n+                    \/\/ should never happen\n+                    throw new AssertionError();\n+                }\n+            }\n+        }\n+        try {\n+            int outLen;\n+            if (decrypting) {\n+                outLen = cipher.decryptFinal(dataBuf, 0, dataIdx, null, -1);\n+                \/\/ unpad if padding is used\n+                if (padding != null) {\n+                    int padIdx = padding.unpad(dataBuf, 0, outLen);\n+                    if (padIdx <= 0) {\n+                        throw new BadPaddingException(\"Bad Padding: \" + padIdx);\n+                    }\n+                    outLen = padIdx;\n+                }\n+            } else {\n+                outLen = cipher.encryptFinal(dataBuf, 0, dataIdx, null, -1);\n+            }\n+            \/\/ only write out the result after verification succeeds\n+            System.arraycopy(dataBuf, 0, out, outOfs, outLen);\n+            return outLen;\n+        } catch (ShortBufferException sbe) {\n+            \/\/ should never happen\n+            throw new AssertionError();\n+        } finally {\n+            \/\/ reset dataBuf for subsequent operations\n+            dataIdx = 0;\n+        }\n+    }\n+\n+    \/**\n+     * Returns the parameters used with this cipher.\n+     *\n+     * @return AlgorithmParameters object containing IV.\n+     *\/\n+    @Override\n+    protected AlgorithmParameters engineGetParameters() {\n+        AlgorithmParameters params = null;\n+\n+        byte[] iv = cipher.getIV();\n+        String algo = \"AES\/\" + cipher.getFeedback() + \"\/NoPadding\";\n+        try {\n+            params = AlgorithmParameters.getInstance(algo,\n+                    SunJCE.getInstance());\n+            params.init(new IvParameterSpec(iv));\n+        } catch (NoSuchAlgorithmException | InvalidParameterSpecException e) {\n+            \/\/ should never happen\n+            throw new AssertionError();\n+        }\n+        return params;\n+    }\n+\n+    \/**\n+     * Returns the key size of the given key object in number of bits.\n+     *\n+     * @param key the key object.\n+     *\n+     * @return the \"effective\" key size of the given key object.\n+     *\n+     * @exception InvalidKeyException if <code>key<\/code> is invalid.\n+     *\/\n+    protected int engineGetKeySize(Key key) throws InvalidKeyException {\n+        byte[] encoded = key.getEncoded();\n+        if (encoded == null)  {\n+            throw new InvalidKeyException(\"Cannot decide key length\");\n+        }\n+\n+        \/\/ only need length\n+        Arrays.fill(encoded, (byte) 0);\n+        int keyLen = encoded.length;\n+        if (!key.getAlgorithm().equalsIgnoreCase(\"AES\") ||\n+            !AESCrypt.isKeySizeValid(keyLen) ||\n+            (fixedKeySize != -1 && fixedKeySize != keyLen)) {\n+            throw new InvalidKeyException(\"Invalid key length: \" +\n+                    keyLen + \" bytes\");\n+        }\n+        return Math.multiplyExact(keyLen, 8);\n+    }\n+\n+    \/**\n+     * Wrap a key.\n+     *\n+     * @param key the key to be wrapped.\n+     *\n+     * @return the wrapped key.\n+     *\n+     * @exception IllegalBlockSizeException if this cipher is a block\n+     * cipher, no padding has been requested, and the length of the\n+     * encoding of the key to be wrapped is not a\n+     * multiple of the block size.\n+     *\n+     * @exception InvalidKeyException if it is impossible or unsafe to\n+     * wrap the key with this cipher (e.g., a hardware protected key is\n+     * being passed to a software only cipher).\n+     *\/\n+    @Override\n+    protected byte[] engineWrap(Key key)\n+            throws IllegalBlockSizeException, InvalidKeyException {\n+\n+        byte[] encoded = key.getEncoded();\n+        if ((encoded == null) || (encoded.length == 0)) {\n+            throw new InvalidKeyException(\"Cannot get an encoding of \" +\n+                                          \"the key to be wrapped\");\n+        }\n+        int keyLen = encoded.length;\n+        \/\/ output size is known, allocate output buffer\n+        byte[] out = new byte[engineGetOutputSize(keyLen)];\n+\n+        int outOfs = writeIvSemiBlock(out);\n+        System.arraycopy(encoded, 0, out, outOfs, keyLen);\n+        outOfs += keyLen;\n+\n+        \/\/ discard key data\n+        Arrays.fill(encoded, (byte) 0);\n+\n+        \/\/ add padding\n+        if (padding != null) {\n+            int actualLen = outOfs - SEMI_BLKSIZE;\n+            int paddingLen = padding.padLength(actualLen);\n+\n+            try {\n+                padding.padWithLen(out, outOfs, paddingLen);\n+                outOfs += paddingLen;\n+            } catch (ShortBufferException sbe) {\n+                \/\/ should never happen\n+                throw new AssertionError();\n+            }\n+        }\n+        try {\n+            int outLen = cipher.encryptFinal(out, 0, outOfs, null, -1);\n+            \/\/ assert outLen == out.length\n+            return out;\n+        } catch (ShortBufferException sbe) {\n+            \/\/ should never happen\n+            throw new AssertionError();\n+        }\n+    }\n+\n+    \/**\n+     * Unwrap a previously wrapped key.\n+     *\n+     * @param wrappedKey the key to be unwrapped.\n+     *\n+     * @param wrappedKeyAlgorithm the algorithm the wrapped key is for.\n+     *\n+     * @param wrappedKeyType the type of the wrapped key.\n+     * This is one of <code>Cipher.SECRET_KEY<\/code>,\n+     * <code>Cipher.PRIVATE_KEY<\/code>, or <code>Cipher.PUBLIC_KEY<\/code>.\n+     *\n+     * @return the unwrapped key.\n+     *\n+     * @exception NoSuchAlgorithmException if no installed providers\n+     * can create keys of type <code>wrappedKeyType<\/code> for the\n+     * <code>wrappedKeyAlgorithm<\/code>.\n+     *\n+     * @exception InvalidKeyException if <code>wrappedKey<\/code> does not\n+     * represent a wrapped key of type <code>wrappedKeyType<\/code> for\n+     * the <code>wrappedKeyAlgorithm<\/code>.\n+     *\/\n+    @Override\n+    protected Key engineUnwrap(byte[] wrappedKey, String wrappedKeyAlgorithm,\n+            int wrappedKeyType) throws InvalidKeyException,\n+            NoSuchAlgorithmException {\n+\n+        store(wrappedKey, 0, wrappedKey.length);\n+\n+        int outLen = 0;\n+        try {\n+            outLen = cipher.decryptFinal(dataBuf, 0, dataIdx, null, -1);\n+            \/\/ unpad if padding is used\n+            if (padding != null) {\n+                int padIdx = padding.unpad(dataBuf, 0, outLen);\n+                if (padIdx <= 0) {\n+                    throw new BadPaddingException(\"Bad Padding: \" + padIdx);\n+                }\n+                outLen = padIdx;\n+            }\n+            return ConstructKeys.constructKey(dataBuf, 0, outLen,\n+                    wrappedKeyAlgorithm, wrappedKeyType);\n+        } catch (ShortBufferException sbe) {\n+            \/\/ should never happen\n+            throw new AssertionError();\n+        } catch (IllegalBlockSizeException | BadPaddingException e) {\n+            throw new InvalidKeyException(e);\n+        } finally {\n+            Arrays.fill(dataBuf, 0, outLen, (byte) 0);\n+            \/\/ reset dataBuf for subsequent operations\n+            dataIdx = 0;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyWrapCipher.java","additions":753,"deletions":0,"binary":false,"changes":753,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -194,0 +194,10 @@\n+        psA(\"Cipher\", \"AES\/KW\/NoPadding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES_KW_NoPadding\",\n+                attrs);\n+        ps(\"Cipher\", \"AES\/KW\/PKCS5Padding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES_KW_PKCS5Padding\",\n+                null, attrs);\n+        ps(\"Cipher\", \"AES\/KWP\/NoPadding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES_KWP_NoPadding\",\n+                null, attrs);\n+\n@@ -209,0 +219,9 @@\n+        psA(\"Cipher\", \"AES_128\/KW\/NoPadding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES128_KW_NoPadding\",\n+                attrs);\n+        ps(\"Cipher\", \"AES_128\/KW\/PKCS5Padding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES128_KW_PKCS5Padding\",\n+                null, attrs);\n+        psA(\"Cipher\", \"AES_128\/KWP\/NoPadding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES128_KWP_NoPadding\",\n+                attrs);\n@@ -225,0 +244,9 @@\n+        psA(\"Cipher\", \"AES_192\/KW\/NoPadding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES192_KW_NoPadding\",\n+                attrs);\n+        ps(\"Cipher\", \"AES_192\/KW\/PKCS5Padding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES192_KW_PKCS5Padding\",\n+                null, attrs);\n+        psA(\"Cipher\", \"AES_192\/KWP\/NoPadding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES192_KWP_NoPadding\",\n+                attrs);\n@@ -241,0 +269,9 @@\n+        psA(\"Cipher\", \"AES_256\/KW\/NoPadding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES256_KW_NoPadding\",\n+                attrs);\n+        ps(\"Cipher\", \"AES_256\/KW\/PKCS5Padding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES256_KW_PKCS5Padding\",\n+                null, attrs);\n+        psA(\"Cipher\", \"AES_256\/KWP\/NoPadding\",\n+                \"com.sun.crypto.provider.KeyWrapCipher$AES256_KWP_NoPadding\",\n+                attrs);\n@@ -255,11 +292,0 @@\n-        ps(\"Cipher\", \"AESWrap\", \"com.sun.crypto.provider.AESWrapCipher$General\",\n-                null, attrs);\n-        psA(\"Cipher\", \"AESWrap_128\",\n-                \"com.sun.crypto.provider.AESWrapCipher$AES128\",\n-                attrs);\n-        psA(\"Cipher\", \"AESWrap_192\",\n-                \"com.sun.crypto.provider.AESWrapCipher$AES192\",\n-                attrs);\n-        psA(\"Cipher\", \"AESWrap_256\",\n-                \"com.sun.crypto.provider.AESWrapCipher$AES256\",\n-                attrs);\n@@ -499,0 +525,7 @@\n+        ps(\"AlgorithmParameters\", \"AES\/KW\/NoPadding\",\n+                \"com.sun.crypto.provider.KWParameters\",\n+                List.of(\"AES\/KW\/PKCS5Padding\", \"AESWrap\"), null);\n+\n+        ps(\"AlgorithmParameters\", \"AES\/KWP\/NoPadding\",\n+                \"com.sun.crypto.provider.KWPParameters\");\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":45,"deletions":12,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,2 @@\n-    AESWRAP_128(\"2.16.840.1.101.3.4.1.5\"),\n+    AES_128$KW$NoPadding(\"2.16.840.1.101.3.4.1.5\", \"AES_128\/KW\/NoPadding\",\n+            \"AESWrap_128\"),\n@@ -121,0 +122,2 @@\n+    AES_128$KWP$NoPadding(\"2.16.840.1.101.3.4.1.8\", \"AES_128\/KWP\/NoPadding\"),\n+\n@@ -125,1 +128,2 @@\n-    AESWRAP_192(\"2.16.840.1.101.3.4.1.25\"),\n+    AES_192$KW$NoPadding(\"2.16.840.1.101.3.4.1.25\", \"AES_192\/KW\/NoPadding\",\n+            \"AESWrap_192\"),\n@@ -127,0 +131,2 @@\n+    AES_192$KWP$NoPadding(\"2.16.840.1.101.3.4.1.28\", \"AES_192\/KWP\/NoPadding\"),\n+\n@@ -131,1 +137,2 @@\n-    AESWRAP_256(\"2.16.840.1.101.3.4.1.45\"),\n+    AES_256$KW$NoPadding(\"2.16.840.1.101.3.4.1.45\", \"AES_256\/KW\/NoPadding\",\n+            \"AESWrap_256\"),\n@@ -133,0 +140,1 @@\n+    AES_256$KWP$NoPadding(\"2.16.840.1.101.3.4.1.48\", \"AES_256\/KWP\/NoPadding\"),\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -226,0 +226,2 @@\n+\n+        store(\"AES\/KW\/NoPadding\", null, \"AESWrap\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SecurityProviderConstants.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,4 +26,4 @@\n- * @bug 5008156\n- * @run main NISTWrapKAT\n- * @summary Verify that the \"AESWrap\" key wrap cipher work as\n- * expected using NIST test vectors.\n+ * @bug 5008156 8248268\n+ * @run testng NISTWrapKAT\n+ * @summary Verify that the AES-Key-Wrap and AES-Key-Wrap-Pad ciphers\n+ * work as expected using NIST test vectors.\n@@ -38,0 +38,3 @@\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.testng.Assert;\n@@ -45,2 +48,2 @@\n-\n-    private static String AES128_128 =\n+    \/\/ from RFC 3394 sec4\n+    private static String KW_AES128_128 =\n@@ -48,1 +51,1 @@\n-    private static String AES192_128 =\n+    private static String KW_AES192_128 =\n@@ -50,1 +53,1 @@\n-    private static String AES192_192 =\n+    private static String KW_AES192_192 =\n@@ -52,1 +55,1 @@\n-    private static String AES256_128 =\n+    private static String KW_AES256_128 =\n@@ -54,1 +57,1 @@\n-    private static String AES256_192 =\n+    private static String KW_AES256_192 =\n@@ -56,1 +59,1 @@\n-    private static String AES256_256 =\n+    private static String KW_AES256_256 =\n@@ -59,7 +62,17 @@\n-    public static void testKeyWrap(int keyLen, int dataLen,\n-                                   String expected) throws Exception {\n-        System.out.println(\"Testing AESWrap Cipher with \" +\n-            dataLen + \"-byte data with \" + 8*keyLen + \"-bit key\");\n-        Cipher c = Cipher.getInstance(\"AESWrap\", \"SunJCE\");\n-        byte[] keyVal = new byte[keyLen];\n-        byte[] dataVal = new byte[dataLen];\n+    private static String KWP_AES128_56 = \"1B1D4BC2A90B1FA389412B3D40FECB20\";\n+    private static String KWP_AES128_112 =\n+            \"EA0BFDE8AF063E8918E811A05D2A4C23A367B45315716B5B\";\n+    private static String KWP_AES192_56 = \"87CE2C5C2D7196E09381056B319D91E9\";\n+    private static String KWP_AES192_112 =\n+            \"900484950F84EB6ED74CE81DCDACA26E72BB29D4A6F7AC74\";\n+    private static String KWP_AES192_168 =\n+            \"A402348F1956DB968FDDFD8976420F9DDEB7183CF16B91B0AEB74CAB196C343E\";\n+    private static String KWP_AES256_56 = \"809BB1864A18938529E97EFCD9544E9A\";\n+    private static String KWP_AES256_112 =\n+            \"C68168173F141E6D5767611574A941259090DA78D7DF9DF7\";\n+    private static String KWP_AES256_168 =\n+            \"308D49692B5F8CF638D54BB4B985633504237329964C76EBB3F669870A708DBC\";\n+    private static String KWP_AES256_224 =\n+            \"0942747DB07032A3F04CDB2E7DE1CBA038F92BC355393AE9A0E4AE8C901912AC3D3AF0F16D240607\";\n+     \/\/ from RFC 5649 sec6\n+     private static String KEK2 = \"5840DF6E29B02AF1AB493B705BF16EA1AE8338F4DCC176A8\";\n@@ -67,2 +80,8 @@\n-        \/\/ setup the key encryption key and the to-be-wrapped key\n-        BigInteger temp = new BigInteger(KEK.substring(0, keyLen*2), 16);\n+    private static byte[] toBytes(String hex, int hexLen) {\n+        if (hexLen < hex.length()) {\n+            hex = hex.substring(0, hexLen);\n+        } else {\n+            hexLen = hex.length();\n+        }\n+        int outLen = hexLen >> 1;\n+        BigInteger temp = new BigInteger(hex, 16);\n@@ -70,6 +89,60 @@\n-        System.arraycopy(val, 0, keyVal, keyVal.length-val.length,\n-                         val.length);\n-        temp = new BigInteger(DATA.substring(0, dataLen*2), 16);\n-        val = temp.toByteArray();\n-        System.arraycopy(val, 0, dataVal, dataVal.length-val.length,\n-                         val.length);\n+        if (val.length == outLen) {\n+            return val;\n+        } else {\n+            byte[] out = new byte[outLen];\n+            if (val.length < outLen) {\n+                \/\/ enlarge\n+                System.arraycopy(val, 0, out, outLen - val.length, val.length);\n+            } else {\n+                \/\/ truncate\n+                System.arraycopy(val, val.length - outLen, out, 0, outLen);\n+            }\n+            return out;\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] testData() {\n+        return new Object[][] {\n+            { \"AESWrap\", KEK, 16, DATA, 16, KW_AES128_128 },\n+            { \"AESWrap\", KEK, 24, DATA, 16, KW_AES192_128 },\n+            { \"AESWrap\", KEK, 24, DATA, 24, KW_AES192_192 },\n+            { \"AESWrap\", KEK, 32, DATA, 16, KW_AES256_128 },\n+            { \"AESWrap\", KEK, 32, DATA, 24, KW_AES256_192 },\n+            { \"AESWrap\", KEK, 32, DATA, 32, KW_AES256_256 },\n+            { \"AES\/KW\/NoPadding\", KEK, 16, DATA, 16, KW_AES128_128 },\n+            { \"AES\/KW\/NoPadding\", KEK, 24, DATA, 16, KW_AES192_128 },\n+            { \"AES\/KW\/NoPadding\", KEK, 24, DATA, 24, KW_AES192_192 },\n+            { \"AES\/KW\/NoPadding\", KEK, 32, DATA, 16, KW_AES256_128 },\n+            { \"AES\/KW\/NoPadding\", KEK, 32, DATA, 24, KW_AES256_192 },\n+            { \"AES\/KW\/NoPadding\", KEK, 32, DATA, 32, KW_AES256_256 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 16, DATA, 7, KWP_AES128_56 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 16, DATA, 14, KWP_AES128_112 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 24, DATA, 7, KWP_AES192_56 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 24, DATA, 14, KWP_AES192_112 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 24, DATA, 21, KWP_AES192_168 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 32, DATA, 7, KWP_AES256_56 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 32, DATA, 14, KWP_AES256_112 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 32, DATA, 21, KWP_AES256_168 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 32, DATA, 28, KWP_AES256_224 },\n+            { \"AES\/KWP\/NoPadding\", KEK2, 24, \"466F7250617369\", 7,\n+              \"AFBEB0F07DFBF5419200F2CCB50BB24F\" },\n+            { \"AES\/KWP\/NoPadding\", KEK2, 24,\n+              \"C37B7E6492584340BED12207808941155068F738\", 20,\n+              \"138BDEAA9B8FA7FC61F97742E72248EE5AE6AE5360D1AE6A5F54F373FA543B6A\" },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"testData\")\n+    public void testKeyWrap(String algo, String key, int keyLen,\n+            String data, int dataLen, String expected) throws Exception {\n+        System.out.println(\"Testing \" +  algo + \" Cipher with wrapping \" +\n+            dataLen + \"-byte key with \" + 8*keyLen + \"-bit KEK\");\n+        int allowed = Cipher.getMaxAllowedKeyLength(\"AES\");\n+        if (keyLen > allowed) {\n+            System.out.println(\"=> skip, exceeds max allowed size \" + allowed);\n+            return;\n+        }\n+        Cipher c = Cipher.getInstance(algo, \"SunJCE\");\n+        byte[] keyVal = toBytes(key, keyLen << 1);\n+        byte[] dataVal = toBytes(data, dataLen << 1);\n@@ -83,7 +156,4 @@\n-        byte[] expectedVal = new BigInteger(expected, 16).toByteArray();\n-        \/\/ need to add offset since BigInteger may pad \"0x00\" in the beginning\n-        int offset = expectedVal.length - wrapped.length;\n-        for (int i=0; i<wrapped.length; i++) {\n-            if (wrapped[i] != expectedVal[offset + i]) {\n-                throw new Exception(\"Wrap failed; got different result\");\n-            }\n+        byte[] expectedVal = toBytes(expected, expected.length());\n+\n+        if (!Arrays.equals(wrapped, expectedVal)) {\n+            throw new Exception(\"Wrap failed; got different result\");\n@@ -100,4 +170,5 @@\n-    public static void main(String[] argv) throws Exception {\n-        testKeyWrap(16, 16, AES128_128);\n-        \/\/ only run the tests on longer key lengths if unlimited version\n-        \/\/ of JCE jurisdiction policy files are installed\n+    @Test(dataProvider = \"testData\")\n+    public void testEnc(String algo, String key, int keyLen, String data, int dataLen, String expected)\n+            throws Exception {\n+        System.out.println(\"Testing \" +  algo + \" Cipher with enc \" +\n+            dataLen + \"-byte data with \" + 8*keyLen + \"-bit KEK\");\n@@ -105,3 +176,3 @@\n-        if (allowed >= 24*8) {\n-            testKeyWrap(24, 16, AES192_128);\n-            testKeyWrap(24, 24, AES192_192);\n+        if (keyLen > allowed) {\n+            System.out.println(\"=> skip, exceeds max allowed size \" + allowed);\n+            return;\n@@ -109,4 +180,27 @@\n-        if (allowed >= 32*8) {\n-            testKeyWrap(32, 16, AES256_128);\n-            testKeyWrap(32, 24, AES256_192);\n-            testKeyWrap(32, 32, AES256_256);\n+        Cipher c = Cipher.getInstance(algo, \"SunJCE\");\n+\n+        byte[] keyVal = toBytes(key, keyLen << 1);\n+        byte[] dataVal = toBytes(data, dataLen << 1);\n+\n+        SecretKey cipherKey = new SecretKeySpec(keyVal, \"AES\");\n+        c.init(Cipher.ENCRYPT_MODE, cipherKey);\n+\n+        \/\/ first test encryption with known values\n+        byte[] ct11 = c.update(dataVal);\n+        byte[] ct12 = c.doFinal();\n+        byte[] ct2 = c.doFinal(dataVal);\n+        byte[] expectedVal = toBytes(expected, expected.length());\n+\n+        if (ct11 != null || !Arrays.equals(ct12, ct2) ||\n+            !Arrays.equals(ct2, expectedVal)) {\n+            throw new Exception(\"Encryption failed; got different result\");\n+        }\n+\n+        \/\/ then test decryption and compare with the initial values\n+        c.init(Cipher.DECRYPT_MODE, cipherKey);\n+        byte[] pt11 = c.update(ct12);\n+        byte[] pt12 = c.doFinal();\n+        byte[] pt2 = c.doFinal(ct2);\n+        if (pt11 != null || !Arrays.equals(pt12, pt2) ||\n+            !Arrays.equals(pt2, dataVal)) {\n+            throw new Exception(\"Decryption failed; got different result\");\n@@ -114,1 +208,0 @@\n-        System.out.println(\"All Tests Passed\");\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/KeyWrap\/NISTWrapKAT.java","additions":139,"deletions":46,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8248268\n+ * @summary Verify general properties of the AES\/KW\/NoPadding,\n+ *     AES\/KW\/PKCS5Padding, and AES\/KWP\/NoPadding.\n+ * @run main TestGeneral\n+ *\/\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.security.Key;\n+import java.security.InvalidAlgorithmParameterException;\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+\n+public class TestGeneral {\n+\n+    private static final SecretKey KEY = new SecretKeySpec(new byte[16], \"AES\");;\n+    private static final int KW_IV_LEN = 8;\n+    private static final int KWP_IV_LEN = 4;\n+    private static final int MAX_KW_PKCS5PAD_LEN = 16; \/\/ 1-16\n+    private static final int MAX_KWP_PAD_LEN = 7; \/\/ 0...7\n+\n+    public static void testEnc(Cipher c, byte[] in, int inLen, int ivLen,\n+            int maxPadLen) throws Exception {\n+\n+        System.out.println(\"input len: \" + inLen);\n+        c.init(Cipher.ENCRYPT_MODE, KEY, new IvParameterSpec(in, 0, ivLen));\n+\n+        int estOutLen = c.getOutputSize(inLen);\n+\n+        byte[] out = c.doFinal(in, 0, inLen);\n+\n+        \/\/ for encryption output, the estimate should match the actual\n+        if (estOutLen != out.length) {\n+            System.out.println(\"=> estimated: \" + estOutLen);\n+            System.out.println(\"=> actual enc out length: \" + out.length);\n+            throw new RuntimeException(\"Failed enc output len check\");\n+        }\n+\n+        \/\/ encryption outout should always be multiple of 8 and at least 8-byte\n+        \/\/ longer than input\n+        if ((out.length % 8 != 0) || (out.length - inLen < 8)) {\n+            throw new RuntimeException(\"Invalid length of encrypted data: \" +\n+                out.length);\n+        }\n+\n+        c.init(Cipher.DECRYPT_MODE, KEY, new IvParameterSpec(in, 0, ivLen));\n+        estOutLen = c.getOutputSize(out.length);\n+\n+        byte[] in2 = c.doFinal(out);\n+\n+        \/\/ for decryption output, the estimate should match the actual for\n+        \/\/ AES\/KW\/NoPadding and slightly larger than the actual for the rest\n+        if (estOutLen < in2.length || (estOutLen - in2.length) > maxPadLen) {\n+            System.out.println(\"=> estimated: \" + estOutLen);\n+            System.out.println(\"=> actual dec out length: \" + in2.length);\n+            throw new RuntimeException(\"Failed dec output len check\");\n+        }\n+\n+        if (!Arrays.equals(in, 0, inLen, in2, 0, inLen)) {\n+            throw new RuntimeException(\"Failed decrypted data check\");\n+        }\n+    }\n+\n+    public static void testWrap(Cipher c, byte[] in, int inLen, int ivLen,\n+            int maxPadLen) throws Exception {\n+\n+        System.out.println(\"key len: \" + inLen);\n+        c.init(Cipher.WRAP_MODE, KEY, new IvParameterSpec(in, 0, ivLen));\n+\n+        int estOutLen = c.getOutputSize(inLen);\n+\n+        byte[] out = c.wrap(new SecretKeySpec(in, 0, inLen, \"Any\"));\n+\n+        \/\/ for encryption output, the estimate should match the actual\n+        if (estOutLen != out.length) {\n+            System.out.println(\"=> estimated: \" + estOutLen);\n+            System.out.println(\"=> actual wrap out length: \" + out.length);\n+            throw new RuntimeException(\"Failed wrap output len check\");\n+        }\n+\n+        \/\/ encryption outout should always be multiple of 8 and at least 8-byte\n+        \/\/ longer than input\n+        if ((out.length % 8 != 0) || (out.length - inLen < 8)) {\n+            throw new RuntimeException(\"Invalid length of encrypted data: \" +\n+                out.length);\n+        }\n+        c.init(Cipher.UNWRAP_MODE, KEY, new IvParameterSpec(in, 0, ivLen));\n+        estOutLen = c.getOutputSize(out.length);\n+\n+        Key key2 = c.unwrap(out, \"Any\", Cipher.SECRET_KEY);\n+\n+        if (!(key2 instanceof SecretKey)) {\n+            throw new RuntimeException(\"Failed unwrap output type check\");\n+        }\n+\n+        byte[] in2 = key2.getEncoded();\n+        \/\/ for decryption output, the estimate should match the actual for\n+        \/\/ AES\/KW\/NoPadding and slightly larger than the actual for the rest\n+        if (estOutLen < in2.length || (estOutLen - in2.length) > maxPadLen) {\n+            System.out.println(\"=> estimated: \" + estOutLen);\n+            System.out.println(\"=> actual unwrap out length: \" + in2.length);\n+            throw new RuntimeException(\"Failed unwrap output len check\");\n+        }\n+\n+        if (inLen != in2.length ||\n+                !Arrays.equals(in, 0, inLen, in2, 0, inLen)) {\n+            throw new RuntimeException(\"Failed unwrap data check\");\n+        }\n+    }\n+\n+    public static void testIv(Cipher c) throws Exception {\n+        c.init(Cipher.ENCRYPT_MODE, KEY);\n+        byte[] defIv = c.getIV();\n+        \/\/ try init w\/ an iv w\/ different length\n+        try {\n+            c.init(Cipher.ENCRYPT_MODE, KEY, new IvParameterSpec(defIv, 0,\n+                defIv.length\/2));\n+        } catch (InvalidAlgorithmParameterException iape) {\n+            System.out.println(\"Invalid IV rejected as expected\");\n+        }\n+        Arrays.fill(defIv, (byte) 0xFF);\n+        c.init(Cipher.ENCRYPT_MODE, KEY, new IvParameterSpec(defIv));\n+        byte[] newIv = c.getIV();\n+        if (!Arrays.equals(newIv, defIv)) {\n+            throw new RuntimeException(\"Failed iv check\");\n+        }\n+    }\n+\n+    public static void main(String[] argv) throws Exception {\n+        \/\/ test all possible pad lengths, i.e. 1 - 16\n+        byte[] data = new byte[128];\n+        new Random().nextBytes(data);\n+\n+        String ALGO = \"AES\/KW\/PKCS5Padding\";\n+        System.out.println(\"Testing \" + ALGO);\n+        Cipher c = Cipher.getInstance(ALGO, \"SunJCE\");\n+        for (int i = 0; i < MAX_KW_PKCS5PAD_LEN; i++) {\n+            testEnc(c, data, data.length - i, KW_IV_LEN, MAX_KW_PKCS5PAD_LEN);\n+            testWrap(c, data, data.length - i, KW_IV_LEN, MAX_KW_PKCS5PAD_LEN);\n+        }\n+        testIv(c);\n+\n+        ALGO = \"AES\/KW\/NoPadding\";\n+        System.out.println(\"Testing \" + ALGO);\n+        c = Cipher.getInstance(ALGO, \"SunJCE\");\n+        testEnc(c, data, data.length, KW_IV_LEN, 0);\n+        testEnc(c, data, data.length >> 1, KW_IV_LEN, 0);\n+        testWrap(c, data, data.length, KW_IV_LEN, 0);\n+        testWrap(c, data, data.length >> 1, KW_IV_LEN, 0);\n+        testIv(c);\n+\n+        ALGO = \"AES\/KWP\/NoPadding\";\n+        System.out.println(\"Testing \" + ALGO);\n+        c = Cipher.getInstance(ALGO, \"SunJCE\");\n+        for (int i = 0; i < MAX_KWP_PAD_LEN; i++) {\n+            testEnc(c, data, data.length - i, KWP_IV_LEN, MAX_KWP_PAD_LEN);\n+            testWrap(c, data, data.length - i, KWP_IV_LEN, MAX_KWP_PAD_LEN);\n+        }\n+        testIv(c);\n+\n+        System.out.println(\"All Tests Passed\");\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/KeyWrap\/TestGeneral.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n- * @bug 8075286\n- * @summary Test the AESWrap algorithm OIDs in JDK.\n+ * @bug 8075286 8248268\n+ * @summary Test the AES-Key-Wrap and AES-Key-Wrap-Pad algorithm OIDs in JDK.\n@@ -52,3 +52,9 @@\n-            new DataTuple(\"2.16.840.1.101.3.4.1.5\", \"AESWrap_128\", 128),\n-            new DataTuple(\"2.16.840.1.101.3.4.1.25\", \"AESWrap_192\", 192),\n-            new DataTuple(\"2.16.840.1.101.3.4.1.45\", \"AESWrap_256\", 256));\n+            new DataTuple(\"2.16.840.1.101.3.4.1.5\", \"AESWrap_128\"),\n+            new DataTuple(\"2.16.840.1.101.3.4.1.25\", \"AESWrap_192\"),\n+            new DataTuple(\"2.16.840.1.101.3.4.1.45\", \"AESWrap_256\"),\n+            new DataTuple(\"2.16.840.1.101.3.4.1.5\", \"AES_128\/KW\/NoPadding\"),\n+            new DataTuple(\"2.16.840.1.101.3.4.1.25\", \"AES_192\/KW\/NoPadding\"),\n+            new DataTuple(\"2.16.840.1.101.3.4.1.45\", \"AES_256\/KW\/NoPadding\"),\n+            new DataTuple(\"2.16.840.1.101.3.4.1.8\", \"AES_128\/KWP\/NoPadding\"),\n+            new DataTuple(\"2.16.840.1.101.3.4.1.28\", \"AES_192\/KWP\/NoPadding\"),\n+            new DataTuple(\"2.16.840.1.101.3.4.1.48\", \"AES_256\/KWP\/NoPadding\"));\n@@ -148,1 +154,1 @@\n-        private DataTuple(String oid, String algorithm, int keyLength) {\n+        private DataTuple(String oid, String algorithm) {\n@@ -151,1 +157,6 @@\n-            this.keyLength = keyLength;\n+            this.keyLength = switch (oid) {\n+                case \"2.16.840.1.101.3.4.1.5\", \"2.16.840.1.101.3.4.1.8\"->128;\n+                case \"2.16.840.1.101.3.4.1.25\", \"2.16.840.1.101.3.4.1.28\"->192;\n+                case \"2.16.840.1.101.3.4.1.45\", \"2.16.840.1.101.3.4.1.48\"->256;\n+                default->throw new RuntimeException(\"Unrecognized oid: \" + oid);\n+            };\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/NSASuiteB\/TestAESWrapOids.java","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto.full;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+import java.security.Key;\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidParameterSpecException;\n+\n+\n+public class AESKeyWrapBench extends CryptoBase {\n+\n+    @Param({\"AES\/KW\/NoPadding\" , \"AES\/KW\/PKCS5Padding\", \"AES\/KWP\/NoPadding\"})\n+    private String algorithm;\n+\n+    @Param({\"128\"})\n+    private int keyLength;\n+\n+    @Param({\"16\", \"24\"})\n+    private int dataSize;\n+\n+    SecretKeySpec toBeWrappedKey;\n+    byte[] wrappedKey;\n+    private Cipher encryptCipher;\n+    private Cipher decryptCipher;\n+    SecretKeySpec ks;\n+\n+    @Setup\n+    public void setup() throws NoSuchAlgorithmException, NoSuchPaddingException,\n+            InvalidKeyException, IllegalBlockSizeException {\n+        setupProvider();\n+\n+        byte[] keystring = fillSecureRandom(new byte[keyLength \/ 8]);\n+        ks = new SecretKeySpec(keystring, \"AES\");\n+        encryptCipher = makeCipher(prov, algorithm);\n+        encryptCipher.init(Cipher.WRAP_MODE, ks);\n+        decryptCipher = makeCipher(prov, algorithm);\n+        decryptCipher.init(Cipher.UNWRAP_MODE, ks);\n+        byte[] data = fillRandom(new byte[dataSize]);\n+        toBeWrappedKey = new SecretKeySpec(data, \"Custom\");\n+        wrappedKey = encryptCipher.wrap(toBeWrappedKey);\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public byte[] wrap() throws InvalidKeyException, IllegalBlockSizeException {\n+        return encryptCipher.wrap(toBeWrappedKey);\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Key unwrap() throws InvalidKeyException, NoSuchAlgorithmException {\n+        return decryptCipher.unwrap(wrappedKey, \"Custom\", Cipher.SECRET_KEY);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/AESKeyWrapBench.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}