{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,1 +390,1 @@\n-#define CHECK_EXCEPTION_FAIL() \\\n+#define CHECK_EXCEPTION_CONTINUE_OR_FAIL() \\\n@@ -392,1 +392,2 @@\n-        if ((*env)->ExceptionOccurred(env)) { \\\n+        jobject pendingException = (*env)->ExceptionOccurred(env); \\\n+        if (pendingException) { \\\n@@ -394,12 +395,11 @@\n-            return 0; \\\n-        } \\\n-    } while (JNI_FALSE)\n-\n-\n-#define CHECK_EXCEPTION_NULL_FAIL(mainObject) \\\n-    do { \\\n-        if ((*env)->ExceptionOccurred(env)) { \\\n-            (*env)->ExceptionClear(env); \\\n-            return 0; \\\n-        } else if (mainObject == NULL) { \\\n-            return 0; \\\n+            jclass pendingExceptionClass = \\\n+                (*env)->GetObjectClass(env, pendingException); \\\n+            jclass noSuchMethodErrorClass = \\\n+                FindBootStrapClass(env, \"java\/lang\/NoSuchMethodError\"); \\\n+            if ((*env)->IsSameObject(env, pendingExceptionClass, \\\n+                                     noSuchMethodErrorClass)) { \\\n+                return 1; \\\n+            } else { \\\n+                (*env)->Throw(env, pendingException); \\\n+                return 0; \\\n+            } \\\n@@ -410,2 +410,3 @@\n- * Invoke a static main with arguments. Returns 1 (true) if successful otherwise\n- * processes the pending exception from GetStaticMethodID and returns 0 (false).\n+ * Invoke a static main with arguments. Returns 1 (true) if processing should\n+ * continue with another main variant, returns 0 (false) otherwise. An exception\n+ * may be pending in either case.\n@@ -417,1 +418,1 @@\n-    CHECK_EXCEPTION_FAIL();\n+    CHECK_EXCEPTION_CONTINUE_OR_FAIL();\n@@ -419,1 +420,1 @@\n-    return 1;\n+    return 0;\n@@ -423,2 +424,3 @@\n- * Invoke an instance main with arguments. Returns 1 (true) if successful otherwise\n- * processes the pending exception from GetMethodID and returns 0 (false).\n+ * Invoke an instance main with arguments. Returns 1 (true) if processing should\n+ * continue with another main variant, returns 0 (false) otherwise. An exception\n+ * may be pending in either case.\n@@ -428,4 +430,0 @@\n-    jmethodID constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n-    CHECK_EXCEPTION_FAIL();\n-    jobject mainObject = (*env)->NewObject(env, mainClass, constructor);\n-    CHECK_EXCEPTION_NULL_FAIL(mainObject);\n@@ -434,1 +432,10 @@\n-    CHECK_EXCEPTION_FAIL();\n+    CHECK_EXCEPTION_CONTINUE_OR_FAIL();\n+    jmethodID constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n+    CHECK_EXCEPTION_CONTINUE_OR_FAIL();\n+    jobject mainObject = (*env)->NewObject(env, mainClass, constructor);\n+    if (mainObject == NULL) {\n+        \/\/ new instance construction failed, don't call the main method,\n+        \/\/ and don't continue with the next variant;\n+        \/\/ leave any exception pending, so that it is visible to the caller:\n+        return 0;\n+    }\n@@ -436,1 +443,1 @@\n-    return 1;\n+    return 0;\n@@ -440,2 +447,3 @@\n- * Invoke a static main without arguments. Returns 1 (true) if successful otherwise\n- * processes the pending exception from GetStaticMethodID and returns 0 (false).\n+ * Invoke a static main without arguments.  Returns 1 (true) if processing should\n+ * continue with another main variant, returns 0 (false) otherwise. An exception\n+ * may be pending in either case.\n@@ -447,1 +455,1 @@\n-    CHECK_EXCEPTION_FAIL();\n+    CHECK_EXCEPTION_CONTINUE_OR_FAIL();\n@@ -449,1 +457,1 @@\n-    return 1;\n+    return 0;\n@@ -453,2 +461,3 @@\n- * Invoke an instance main without arguments. Returns 1 (true) if successful otherwise\n- * processes the pending exception from GetMethodID and returns 0 (false).\n+ * Invoke an instance main without arguments.  Returns 1 (true) if processing should\n+ * continue with another main variant, returns 0 (false) otherwise. An exception\n+ * may be pending in either case.\n@@ -458,4 +467,0 @@\n-    jmethodID constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n-    CHECK_EXCEPTION_FAIL();\n-    jobject mainObject = (*env)->NewObject(env, mainClass, constructor);\n-    CHECK_EXCEPTION_NULL_FAIL(mainObject);\n@@ -464,1 +469,10 @@\n-    CHECK_EXCEPTION_FAIL();\n+    CHECK_EXCEPTION_CONTINUE_OR_FAIL();\n+    jmethodID constructor = (*env)->GetMethodID(env, mainClass, \"<init>\", \"()V\");\n+    CHECK_EXCEPTION_CONTINUE_OR_FAIL();\n+    jobject mainObject = (*env)->NewObject(env, mainClass, constructor);\n+    if (mainObject == NULL) {\n+        \/\/ new instance construction failed, don't call the main method,\n+        \/\/ and don't continue with the next variant;\n+        \/\/ leave any exception pending, so that it is visible to the caller:\n+        return 0;\n+    }\n@@ -466,1 +480,1 @@\n-    return 1;\n+    return 0;\n@@ -623,4 +637,4 @@\n-    if (!invokeStaticMainWithArgs(env, mainClass, mainArgs) &&\n-        !invokeInstanceMainWithArgs(env, mainClass, mainArgs) &&\n-        !invokeStaticMainWithoutArgs(env, mainClass) &&\n-        !invokeInstanceMainWithoutArgs(env, mainClass)) {\n+    if (invokeStaticMainWithArgs(env, mainClass, mainArgs) &&\n+        invokeInstanceMainWithArgs(env, mainClass, mainArgs) &&\n+        invokeStaticMainWithoutArgs(env, mainClass) &&\n+        invokeInstanceMainWithoutArgs(env, mainClass)) {\n@@ -1564,0 +1578,1 @@\n+\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":58,"deletions":43,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,3 @@\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n@@ -28,1 +31,2 @@\n- * @summary test execution priority of main methods\n+ * @bug 8329420\n+ * @summary test execution priority and behavior of main methods\n@@ -178,1 +182,1 @@\n-    public static void main(String... args) throws Exception {\n+    private static void testMethodOrder() throws Exception {\n@@ -180,8 +184,14 @@\n-            Files.writeString(Path.of(\"MainClass.java\"), source);\n-            var version = System.getProperty(\"java.specification.version\");\n-            var tr = doExec(javaCmd, \"--enable-preview\", \"--source\", version, \"MainClass.java\");\n-            if (!tr.isOK()) {\n-                System.err.println(source);\n-                System.err.println(tr);\n-                throw new AssertionError();\n-            }\n+            performTest(source, true, tr -> {\n+                if (!tr.isOK()) {\n+                    System.err.println(source);\n+                    System.err.println(tr);\n+                    throw new AssertionError();\n+                }\n+            });\n+        }\n+    }\n+\n+    record TestCase(String sourceCode, boolean enablePreview, List<String> expectedOutput) {\n+\n+        public TestCase(String sourceCode, List<String> expectedOutput) {\n+            this(sourceCode, true, expectedOutput);\n@@ -189,0 +199,169 @@\n+\n+    }\n+\n+    private static final TestCase[] EXECUTION_ORDER = new TestCase[] {\n+        new TestCase(\"\"\"\n+                     public class MainClass {\n+                         public MainClass() {\n+                             System.out.println(\"Constructor called!\");\n+                         }\n+                         public static void main() {\n+                             System.out.println(\"main called!\");\n+                         }\n+                     }\n+                     \"\"\",\n+                     List.of(\"main called!\")),\n+        new TestCase(\"\"\"\n+                     public class MainClass {\n+                         public MainClass() {\n+                             System.out.println(\"Constructor called!\");\n+                         }\n+                         public void main() {\n+                             System.out.println(\"main called!\");\n+                         }\n+                     }\n+                     \"\"\",\n+                     List.of(\"Constructor called!\", \"main called!\"))\n+    };\n+\n+    private static void testExecutionOrder() throws Exception {\n+        for (TestCase testCase : EXECUTION_ORDER) {\n+            performTest(testCase.sourceCode, testCase.enablePreview(), tr -> {\n+                if (!Objects.equals(testCase.expectedOutput, tr.testOutput)) {\n+                    throw new AssertionError(\"Unexpected output, \" +\n+                                             \"expected: \" + testCase.expectedOutput +\n+                                             \", actual: \" + tr.testOutput);\n+                }\n+            });\n+        }\n+    }\n+\n+    private static final TestCase[] EXECUTION_ERRORS = new TestCase[] {\n+        new TestCase(\"\"\"\n+                     public class MainClass {\n+                         public MainClass() {\n+                             System.out.println(\"Constructor called!\");\n+                             if (true) throw new Error();\n+                         }\n+                         public void main(String... args) {\n+                             System.out.println(\"main called!\");\n+                         }\n+                     }\n+                     \"\"\",\n+                     List.of(\"Constructor called!\",\n+                             \"Exception in thread \\\"main\\\" java.lang.Error\",\n+                             \"\\tat MainClass.<init>(MainClass.java:4)\")),\n+        new TestCase(\"\"\"\n+                     public class MainClass {\n+                         public MainClass() {\n+                             System.out.println(\"Constructor called!\");\n+                             if (true) throw new Error();\n+                         }\n+                         public void main() {\n+                             System.out.println(\"main called!\");\n+                         }\n+                     }\n+                     \"\"\",\n+                     List.of(\"Constructor called!\",\n+                             \"Exception in thread \\\"main\\\" java.lang.Error\",\n+                             \"\\tat MainClass.<init>(MainClass.java:4)\")),\n+        new TestCase(\"\"\"\n+                     public class MainClass {\n+                         static int idx;\n+                         public MainClass() {\n+                             System.out.println(\"Constructor called!\");\n+                             if (idx++ == 0) throw new Error();\n+                         }\n+                         public void main(String... args) {\n+                             System.out.println(\"main called!\");\n+                         }\n+                         public void main() {\n+                             System.out.println(\"main called!\");\n+                         }\n+                     }\n+                     \"\"\",\n+                     List.of(\"Constructor called!\",\n+                             \"Exception in thread \\\"main\\\" java.lang.Error\",\n+                             \"\\tat MainClass.<init>(MainClass.java:5)\")),\n+        new TestCase(\"\"\"\n+                     public class MainClass {\n+                         static {\n+                             System.out.println(\"static init called!\");\n+                             if (true) throw new Error();\n+                         }\n+                         public static void main(String... args) {\n+                             System.out.println(\"main called!\");\n+                         }\n+                     }\n+                     \"\"\",\n+                     false,\n+                     List.of(\"static init called!\",\n+                             \"Exception in thread \\\"main\\\" java.lang.Error\",\n+                             \"\\tat MainClass.<clinit>(MainClass.java:4)\")),\n+        new TestCase(\"\"\"\n+                     public class MainClass {\n+                         static {\n+                             System.out.println(\"static init called!\");\n+                             if (true) throw new Error();\n+                         }\n+                         public static void main(String... args) {\n+                             System.out.println(\"main called!\");\n+                         }\n+                     }\n+                     \"\"\",\n+                     true,\n+                     List.of(\"static init called!\",\n+                             \"Exception in thread \\\"main\\\" java.lang.Error\",\n+                             \"\\tat MainClass.<clinit>(MainClass.java:4)\")),\n+        new TestCase(\"\"\"\n+                     public class MainClass {\n+                         static {\n+                             System.out.println(\"static init called!\");\n+                             if (true) throw new Error();\n+                         }\n+                         public void main(String... args) {\n+                             System.out.println(\"main called!\");\n+                         }\n+                     }\n+                     \"\"\",\n+                     true,\n+                     List.of(\"static init called!\",\n+                             \"Exception in thread \\\"main\\\" java.lang.Error\",\n+                             \"\\tat MainClass.<clinit>(MainClass.java:4)\")),\n+    };\n+\n+    private static void testExecutionErrors() throws Exception {\n+        for (TestCase testCase : EXECUTION_ERRORS) {\n+            performTest(testCase.sourceCode, testCase.enablePreview(), tr -> {\n+                for (int i = 0; i < testCase.expectedOutput.size(); i++) {\n+                    if (i >= tr.testOutput.size() ||\n+                        !Objects.equals(testCase.expectedOutput.get(i),\n+                                    tr.testOutput.get(i))) {\n+                        throw new AssertionError(\"Unexpected output, \" +\n+                                                 \"expected: \" + testCase.expectedOutput +\n+                                                 \", actual: \" + tr.testOutput +\n+                                                 \", failed comparison at index: \" + i);\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void performTest(String source, boolean enablePreview, Consumer<TestResult> validator) throws Exception {\n+        Path mainClass = Path.of(\"MainClass.java\");\n+        Files.writeString(mainClass, source);\n+        var version = System.getProperty(\"java.specification.version\");\n+        var previewRuntime = enablePreview ? \"--enable-preview\" : \"-DtestNoPreview\";\n+        var previewCompile = enablePreview ? \"--enable-preview\" : \"-XDtestNoPreview\";\n+        var trSource = doExec(javaCmd, previewRuntime, \"--source\", version, \"MainClass.java\");\n+        validator.accept(trSource);\n+        compile(previewCompile, \"--source\", version, \"MainClass.java\");\n+        String cp = mainClass.toAbsolutePath().getParent().toString();\n+        var trCompile = doExec(javaCmd, previewRuntime, \"--class-path\", cp, \"MainClass\");\n+        validator.accept(trCompile);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        testMethodOrder();\n+        testExecutionOrder();\n+        testExecutionErrors();\n","filename":"test\/jdk\/tools\/launcher\/InstanceMainTest.java","additions":190,"deletions":11,"binary":false,"changes":201,"status":"modified"}]}