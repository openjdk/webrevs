{"files":[{"patch":"@@ -1091,0 +1091,12 @@\n+  \/\/ Transform is legal, but check for profit.  Avoid breaking 'i2s'\n+  \/\/ and 'i2b' patterns which typically fold into 'StoreC\/StoreB'.\n+  if (add1_op == Op_Sub(bt) && (bt != T_INT || con < 16)) {    \/\/ Left input is a sub?\n+    \/\/ Left input is a sub from a constant?\n+    const TypeInteger* t11 = phase->type(add1->in(1))->isa_integer(bt);\n+    if (t11 != nullptr && t11->is_con()) {\n+      \/\/ Compute X << con0\n+      Node* lsh = phase->transform(LShiftNode::make(add1->in(2), in(2), bt));\n+      \/\/ Compute X<<con0 - (con1<<con0)\n+      return SubNode::make(phase->integercon(java_shift_left(t11->get_con_as_long(bt), con, bt), bt), lsh, bt);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+            \"testShiftOfSubConstant\",\n@@ -125,0 +126,1 @@\n+        Asserts.assertEQ(((1 - a) << 1) + 1, testShiftOfSubConstant(a));\n@@ -362,1 +364,1 @@\n-    public void testStoreShort(int x) {\n+    public void testStoreShort1(int x) {\n@@ -369,1 +371,1 @@\n-    public void testStoreByte(int x) {\n+    public void testStoreByte1(int x) {\n@@ -373,0 +375,28 @@\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\"} , failOn = { IRNode.LSHIFT_I, IRNode.RSHIFT_I } )\n+    @Arguments( values = { Argument.NUMBER_42 })\n+    public void testStoreShort2(int x) {\n+        shortField = (short)(x + 1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\"} , failOn = { IRNode.LSHIFT_I, IRNode.RSHIFT_I } )\n+    @Arguments( values = { Argument.NUMBER_42 })\n+    public void testStoreByte2(int x) {\n+        byteField = (byte)(x + 1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.SUB_I, \"1\"} , failOn = { IRNode.LSHIFT_I, IRNode.RSHIFT_I } )\n+    @Arguments( values = { Argument.NUMBER_42 })\n+    public void testStoreShort3(int x) {\n+        shortField = (short)(1 - x);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.SUB_I, \"1\"} , failOn = { IRNode.LSHIFT_I, IRNode.RSHIFT_I } )\n+    @Arguments( values = { Argument.NUMBER_42 })\n+    public void testStoreByte3(int x) {\n+        byteField = (byte)(1 - x);\n+    }\n+\n@@ -412,0 +442,6 @@\n+\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\",  IRNode.SUB_I, \"1\" }, failOn =  { IRNode.ADD_I })\n+    public int testShiftOfSubConstant(int x) {\n+        return ((1 - x) << 1) + 1;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftINodeIdealizationTests.java","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+            \"testShiftOfSubConstant\",\n@@ -121,0 +122,1 @@\n+        Asserts.assertEQ(((1L - a) << 1) + 1, testShiftOfSubConstant(a));\n@@ -361,0 +363,6 @@\n+\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\",  IRNode.SUB_L, \"1\" }, failOn =  { IRNode.ADD_L })\n+    public long testShiftOfSubConstant(long x) {\n+        return ((1 - x) << 1) + 1;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftLNodeIdealizationTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.loopopts.superword;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n-\n-import compiler.lib.ir_framework.*;\n-\n-\/*\n- * @test\n- * @bug 8324751\n- * @summary Reported issue: JDK-8359688: C2 SuperWord: missing RCE with MemorySegment\n- *          The examples are generated from TestAliasingFuzzer.java\n- *          So if you see something change here, you may want to investigate if we\n- *          can also tighten up the IR rules there.\n- * @library \/test\/lib \/\n- * @run driver compiler.loopopts.superword.TestMemorySegment_8359688\n- *\/\n-\n-\n-public class TestMemorySegment_8359688 {\n-\n-    public static MemorySegment b = MemorySegment.ofArray(new long[4 * 30_000]);\n-\n-    public static void main(String[] args) {\n-        TestFramework f = new TestFramework();\n-        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n-        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n-                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n-                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n-                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n-        f.start();\n-    }\n-\n-    @Setup\n-    static Object[] setup() {\n-        return new Object[] { b, 0, 5_000, 0 };\n-    }\n-\n-    @Test\n-    @Arguments(setup = \"setup\")\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\",\n-                  IRNode.REPLICATE_L,  \"= 0\",\n-                  \".*multiversion.*\",  \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES, there is no aliasing\n-        phase = CompilePhase.PRINT_IDEAL,\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Does not manage to remove all RangeChecks -> no vectorization\n-    \/\/ If you see this IR rule fail: investigate JDK-8359688, possibly close it and fix this IR rule!\n-    \/\/ Also: consider renaming the file to something more descriptive: what have you fixed with this?\n-    \/\/ And: you may now be able to tighten IR rules in TestAliasingFuzzer.java\n-    public static void test1(MemorySegment b, int ivLo, int ivHi, int invar) {\n-        for (int i = ivLo; i < ivHi; i++) {\n-            b.setAtIndex(ValueLayout.JAVA_LONG_UNALIGNED, 30_000L - (long)i + (long)invar, 42);\n-            \/\/                                                    ^ subtraction here\n-        }\n-    }\n-\n-    @Test\n-    @Arguments(setup = \"setup\")\n-    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n-                  IRNode.REPLICATE_L,  \"> 0\",\n-                  \".*multiversion.*\",  \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES, there is no aliasing\n-        phase = CompilePhase.PRINT_IDEAL,\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Is fully RFE'd and vectorized\n-    public static void test2(MemorySegment b, int ivLo, int ivHi, int invar) {\n-        for (int i = ivLo; i < ivHi; i++) {\n-            b.setAtIndex(ValueLayout.JAVA_LONG_UNALIGNED, 1_000L + 1L * i + (long)invar, 42);\n-            \/\/                                                   ^ addition here\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_8359688.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8324751 8369435\n+ * @summary Reported issue: JDK-8359688: C2 SuperWord: missing RCE with MemorySegment\n+ *          The examples are generated from TestAliasingFuzzer.java\n+ *          So if you see something change here, you may want to investigate if we\n+ *          can also tighten up the IR rules there.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment_SubOfShift\n+ *\/\n+\n+\n+public class TestMemorySegment_SubOfShift {\n+\n+    public static MemorySegment b = MemorySegment.ofArray(new long[4 * 30_000]);\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Setup\n+    static Object[] setup() {\n+        return new Object[] { b, 0, 5_000, 0 };\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.REPLICATE_L,  \"= 1\",\n+                  \".*multiversion.*\",  \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES, there is no aliasing\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    public static void test1(MemorySegment b, int ivLo, int ivHi, int invar) {\n+        for (int i = ivLo; i < ivHi; i++) {\n+            b.setAtIndex(ValueLayout.JAVA_LONG_UNALIGNED, 30_000L - (long)i + (long)invar, 42);\n+            \/\/                                                    ^ subtraction here\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.REPLICATE_L,  \"> 0\",\n+                  \".*multiversion.*\",  \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES, there is no aliasing\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Is fully RFE'd and vectorized\n+    public static void test2(MemorySegment b, int ivLo, int ivHi, int invar) {\n+        for (int i = ivLo; i < ivHi; i++) {\n+            b.setAtIndex(ValueLayout.JAVA_LONG_UNALIGNED, 1_000L + 1L * i + (long)invar, 42);\n+            \/\/                                                   ^ addition here\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_SubOfShift.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"}]}