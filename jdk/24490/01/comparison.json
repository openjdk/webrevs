{"files":[{"patch":"@@ -2159,0 +2159,28 @@\n+void C2_MacroAssembler::enc_cmove_cmp_fp(int cmpFlag, FloatRegister op1, FloatRegister op2, Register dst, Register src, bool is_single) {\n+  int op_select = cmpFlag & (~unsigned_branch_mask);\n+\n+  switch (op_select) {\n+    case BoolTest::eq:\n+      cmov_cmp_fp_eq(op1, op2, dst, src, is_single);\n+      break;\n+    case BoolTest::ne:\n+      cmov_cmp_fp_ne(op1, op2, dst, src, is_single);\n+      break;\n+    case BoolTest::le:\n+      cmov_cmp_fp_le(op1, op2, dst, src, is_single);\n+      break;\n+    case BoolTest::ge:\n+      cmov_cmp_fp_ge(op1, op2, dst, src, is_single);\n+      break;\n+    case BoolTest::lt:\n+      cmov_cmp_fp_lt(op1, op2, dst, src, is_single);\n+      break;\n+    case BoolTest::gt:\n+      cmov_cmp_fp_gt(op1, op2, dst, src, is_single);\n+      break;\n+    default:\n+      assert(false, \"unsupported compare condition\");\n+      ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -132,0 +132,4 @@\n+  void enc_cmove_cmp_fp(int cmpFlag,\n+                        FloatRegister op1, FloatRegister op2,\n+                        Register dst, Register src, bool is_single);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-define_pd_global(intx, ConditionalMoveLimit,         0);\n+define_pd_global(intx, ConditionalMoveLimit,         3);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_globals_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1270,0 +1270,131 @@\n+\/\/ ----------- cmove, compare float -----------\n+\n+\/\/ Move src to dst only if cmp1 == cmp2,\n+\/\/ otherwise leave dst unchanged, including the case where one of them is NaN.\n+\/\/ Clarification:\n+\/\/   java code      :  cmp1 != cmp2 ? dst : src\n+\/\/   transformed to :  CMove dst, (cmp1 eq cmp2), dst, src\n+void MacroAssembler::cmov_cmp_fp_eq(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single) {\n+  if (UseZicond) {\n+    if (is_single) {\n+      feq_s(t0, cmp1, cmp2);\n+    } else {\n+      feq_d(t0, cmp1, cmp2);\n+    }\n+    czero_nez(dst, dst, t0);\n+    czero_eqz(t0 , src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  if (is_single) {\n+    \/\/ jump if cmp1 != cmp2, including the case of NaN\n+    \/\/ not jump (i.e. move src to dst) if cmp1 == cmp2\n+    float_bne(cmp1, cmp2, no_set);\n+  } else {\n+    double_bne(cmp1, cmp2, no_set);\n+  }\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+\/\/ Keep dst unchanged only if cmp1 == cmp2,\n+\/\/ otherwise move src to dst, including the case where one of them is NaN.\n+\/\/ Clarification:\n+\/\/   java code      :  cmp1 == cmp2 ? dst : src\n+\/\/   transformed to :  CMove dst, (cmp1 ne cmp2), dst, src\n+void MacroAssembler::cmov_cmp_fp_ne(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single) {\n+  if (UseZicond) {\n+    if (is_single) {\n+      feq_s(t0, cmp1, cmp2);\n+    } else {\n+      feq_d(t0, cmp1, cmp2);\n+    }\n+    czero_eqz(dst, dst, t0);\n+    czero_nez(t0 , src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  if (is_single) {\n+    \/\/ jump if cmp1 == cmp2\n+    \/\/ not jump (i.e. move src to dst) if cmp1 != cmp2, including the case of NaN\n+    float_beq(cmp1, cmp2, no_set);\n+  } else {\n+    double_beq(cmp1, cmp2, no_set);\n+  }\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+\/\/ When cmp1 <= cmp2 or any of them is NaN then dst = src, otherwise, dst = dst\n+\/\/ Clarification:\n+\/\/   java code      :  cmp2 < cmp1 ? dst : src\n+\/\/   transformed to :  CMove dst, (cmp1 le cmp2), dst, src\n+void MacroAssembler::cmov_cmp_fp_le(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single) {\n+  if (UseZicond) {\n+    if (is_single) {\n+      flt_s(t0, cmp2, cmp1);\n+    } else {\n+      flt_d(t0, cmp2, cmp1);\n+    }\n+    czero_eqz(dst, dst, t0);\n+    czero_nez(t0 , src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  if (is_single) {\n+    \/\/ jump if cmp1 > cmp2\n+    \/\/ not jump (i.e. move src to dst) if cmp1 <= cmp2 or either is NaN\n+    float_bgt(cmp1, cmp2, no_set);\n+  } else {\n+    double_bgt(cmp1, cmp2, no_set);\n+  }\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+\/\/ Clarification:\n+\/\/   java code      :  cmp1 > cmp2 ? dst : src\n+\/\/   transformed to :  CMove dst, (cmp1 le cmp2), dst, src\n+\/\/ So, cmov_le_fp is invoked instead this method.\n+void MacroAssembler::cmov_cmp_fp_ge(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single) {\n+  Unimplemented();\n+}\n+\n+\/\/ When cmp1 < cmp2 or any of them is NaN then dst = src, otherwise, dst = dst\n+\/\/ Clarification:\n+\/\/   java code      :  cmp2 <= cmp1 ? dst : src\n+\/\/   transformed to :  CMove dst, (cmp1 lt cmp2), dst, src\n+void MacroAssembler::cmov_cmp_fp_lt(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single) {\n+  if (UseZicond) {\n+    if (is_single) {\n+      fle_s(t0, cmp2, cmp1);\n+    } else {\n+      fle_d(t0, cmp2, cmp1);\n+    }\n+    czero_eqz(dst, dst, t0);\n+    czero_nez(t0 , src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  if (is_single) {\n+    \/\/ jump if cmp1 >= cmp2\n+    \/\/ not jump (i.e. move src to dst) if cmp1 < cmp2 or either is NaN\n+    float_bge(cmp1, cmp2, no_set);\n+  } else {\n+    double_bge(cmp1, cmp2, no_set);\n+  }\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+\/\/ Clarification:\n+\/\/   java code      :  cmp2 <= cmp1 ? dst : src\n+\/\/   transformed to :  CMove dst, (cmp1 lt cmp2), dst, src\n+void MacroAssembler::cmov_cmp_fp_gt(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":131,"deletions":0,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -660,0 +660,7 @@\n+  void cmov_cmp_fp_eq(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single);\n+  void cmov_cmp_fp_ne(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single);\n+  void cmov_cmp_fp_le(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single);\n+  void cmov_cmp_fp_ge(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single);\n+  void cmov_cmp_fp_lt(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single);\n+  void cmov_cmp_fp_gt(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1936,0 +1936,6 @@\n+\n+    case Op_CMoveF:\n+    case Op_CMoveD:\n+    case Op_CMoveP:\n+    case Op_CMoveN:\n+      return false;\n@@ -9943,0 +9949,3 @@\n+\n+\/\/ --------- CMoveI ---------\n+\n@@ -9948,1 +9957,1 @@\n-    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpI\\n\\t\"\n+    \"CMoveI $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpI\\n\\t\"\n@@ -9965,1 +9974,1 @@\n-    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpU\\n\\t\"\n+    \"CMoveI $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpU\\n\\t\"\n@@ -9982,1 +9991,1 @@\n-    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpL\\n\\t\"\n+    \"CMoveI $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpL\\n\\t\"\n@@ -9999,1 +10008,1 @@\n-    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpUL\\n\\t\"\n+    \"CMoveI $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpUL\\n\\t\"\n@@ -10011,0 +10020,34 @@\n+instruct cmovI_cmpF(iRegINoSp dst, iRegI src, fRegF op1, fRegF op2, cmpOp cop) %{\n+  match(Set dst (CMoveI (Binary cop (CmpF op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveI $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpF\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_cmp_fp($cop$$cmpcode,\n+                        as_FloatRegister($op1$$reg), as_FloatRegister($op2$$reg),\n+                        as_Register($dst$$reg), as_Register($src$$reg), true \/* is_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct cmovI_cmpD(iRegINoSp dst, iRegI src, fRegD op1, fRegD op2, cmpOp cop) %{\n+  match(Set dst (CMoveI (Binary cop (CmpD op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveI $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpD\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_cmp_fp($cop$$cmpcode | C2_MacroAssembler::double_branch_mask,\n+                        as_FloatRegister($op1$$reg), as_FloatRegister($op2$$reg),\n+                        as_Register($dst$$reg), as_Register($src$$reg), false \/* is_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n@@ -10016,1 +10059,1 @@\n-    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpN\\n\\t\"\n+    \"CMoveI $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpN\\n\\t\"\n@@ -10033,1 +10076,1 @@\n-    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpP\\n\\t\"\n+    \"CMoveI $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpP\\n\\t\"\n@@ -10045,0 +10088,2 @@\n+\/\/ --------- CMoveL ---------\n+\n@@ -10050,1 +10095,1 @@\n-    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpL\\n\\t\"\n+    \"CMoveL $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpL\\n\\t\"\n@@ -10067,1 +10112,1 @@\n-    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpUL\\n\\t\"\n+    \"CMoveL $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpUL\\n\\t\"\n@@ -10084,1 +10129,1 @@\n-    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpI\\n\\t\"\n+    \"CMoveL $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpI\\n\\t\"\n@@ -10101,1 +10146,1 @@\n-    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpU\\n\\t\"\n+    \"CMoveL $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpU\\n\\t\"\n@@ -10113,0 +10158,34 @@\n+instruct cmovL_cmpF(iRegLNoSp dst, iRegL src, fRegF op1, fRegF op2, cmpOp cop) %{\n+  match(Set dst (CMoveL (Binary cop (CmpF op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveL $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpF\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_cmp_fp($cop$$cmpcode,\n+                        as_FloatRegister($op1$$reg), as_FloatRegister($op2$$reg),\n+                        as_Register($dst$$reg), as_Register($src$$reg), true \/* is_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct cmovL_cmpD(iRegLNoSp dst, iRegL src, fRegD op1, fRegD op2, cmpOp cop) %{\n+  match(Set dst (CMoveL (Binary cop (CmpD op1 op2)) (Binary dst src)));\n+  ins_cost(ALU_COST + BRANCH_COST);\n+\n+  format %{\n+    \"CMoveL $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpD\\n\\t\"\n+  %}\n+\n+  ins_encode %{\n+    __ enc_cmove_cmp_fp($cop$$cmpcode | C2_MacroAssembler::double_branch_mask,\n+                        as_FloatRegister($op1$$reg), as_FloatRegister($op2$$reg),\n+                        as_Register($dst$$reg), as_Register($src$$reg), false \/* is_single *\/);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n@@ -10118,1 +10197,1 @@\n-    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpN\\n\\t\"\n+    \"CMoveL $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpN\\n\\t\"\n@@ -10135,1 +10214,1 @@\n-    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpP\\n\\t\"\n+    \"CMoveL $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpP\\n\\t\"\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":91,"deletions":12,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -251,8 +251,0 @@\n-  if (UseCMoveUnconditionally) {\n-    FLAG_SET_DEFAULT(UseCMoveUnconditionally, false);\n-  }\n-\n-  if (ConditionalMoveLimit > 0) {\n-    FLAG_SET_DEFAULT(ConditionalMoveLimit, 0);\n-  }\n-\n@@ -465,0 +457,5 @@\n+\n+  if (FLAG_IS_DEFAULT(UseZicond)) {\n+    FLAG_SET_DEFAULT(UseZicond, false);\n+    warning(\"UseZicond is turned off automatically. Turn it on with -XX:+UseZicond explicitly.\");\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -45,0 +45,8 @@\n+    \/\/ These IR checks do not apply on riscv64, as riscv64 supports Conv2B, e.g. for `return x == 0`,\n+    \/\/ the graph looks like:\n+    \/\/      Return (XorI (Conv2B ConI(#int: 1)))\n+    \/\/ On other platforms, e.g. x86_64 which does not supports Conv2B, the graph looks like:\n+    \/\/      Return (CMoveI (Bool (CompI (Param1 ConI(#int: 0))) ConI(#int: 1) ConI(#int: 0)))\n+    \/\/ On riscv64, current graph is more efficient than `CMoveI`, as it\n+    \/\/      1. generates less code\n+    \/\/      2. even when zicond is not supported, it does not introduce branches.\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestConv2BExpansion.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n- * @requires os.arch != \"riscv64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestFPComparison.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n- * @requires os.arch != \"riscv64\"\n@@ -231,1 +230,1 @@\n-        applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+        applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\", \"rvv\", \"true\"},\n@@ -265,1 +264,1 @@\n-        applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+        applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\", \"rvv\", \"true\"},\n@@ -300,1 +299,1 @@\n-        applyIfCPUFeatureOr = { \"avx512\", \"true\" },\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\", \"rvv\", \"true\" },\n@@ -335,1 +334,1 @@\n-        applyIfCPUFeatureOr = { \"avx512\", \"true\" },\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\", \"rvv\", \"true\" },\n@@ -369,1 +368,1 @@\n-    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\", \"rvv\", \"true\"},\n@@ -404,1 +403,1 @@\n-    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\", \"rvv\", \"true\"},\n@@ -439,1 +438,1 @@\n-    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\", \"rvv\", \"true\"},\n@@ -474,1 +473,1 @@\n-    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\", \"rvv\", \"true\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestIfMinMax.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2025, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.random.RandomGenerator;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+public class ClassComparison {\n+    static final int INVOCATIONS = 1024;\n+\n+    Class[] c1;\n+    Class[] c2;\n+    int[] res;\n+    long[] resLong;\n+    Object[] resObject;\n+    Object ro1;\n+    Object ro2;\n+    Object[] resClass;\n+    Class rc1;\n+    Class rc2;\n+\n+    @Setup\n+    public void setup() {\n+        var random = RandomGenerator.getDefault();\n+        c1 = new Class[INVOCATIONS];\n+        c2 = new Class[INVOCATIONS];\n+        res = new int[INVOCATIONS];\n+        resLong = new long[INVOCATIONS];\n+        resObject = new Object[INVOCATIONS];\n+        ro1 = new Object();\n+        ro2 = new Object();\n+        resClass = new Class[INVOCATIONS];\n+        rc1 = Float.class;\n+        rc2 = Double.class;\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            c1[i] = random.nextBoolean() ? Float.class : Double.class;\n+        }\n+        List<Class> list = Arrays.asList(c1);\n+        Collections.shuffle(list);\n+        list.toArray(c2);\n+    }\n+\n+    @Benchmark\n+    public void equalClass() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (c1[i] == c2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualClass() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (c1[i] != c2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    public void equalClassResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (c1[i] == c2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualClassResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (c1[i] != c2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ClassComparison.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import org.openjdk.jmh.infra.Blackhole;\n@@ -44,0 +45,7 @@\n+    long[] resLong;\n+    Object[] resObject;\n+    Object ro1;\n+    Object ro2;\n+    Class[] resClass;\n+    Class rc1;\n+    Class rc2;\n@@ -53,0 +61,7 @@\n+        resLong = new long[INVOCATIONS];\n+        resObject = new Object[INVOCATIONS];\n+        ro1 = new Object();\n+        ro2 = new Object();\n+        resClass = new Class[INVOCATIONS];\n+        rc1 = Float.class;\n+        rc2 = Double.class;\n@@ -82,1 +97,1 @@\n-            res[i] = Float.isNaN(f1[i]) ? 1 : 0;\n+            res[i] = Float.isNaN(f1[i]) ? 1 : 2;\n@@ -89,1 +104,1 @@\n-            res[i] = Double.isNaN(d1[i]) ? 1 : 0;\n+            res[i] = Double.isNaN(d1[i]) ? 1 : 2;\n@@ -96,1 +111,1 @@\n-            res[i] = Float.isInfinite(f1[i]) ? 1 : 0;\n+            res[i] = Float.isInfinite(f1[i]) ? 1 : 2;\n@@ -103,1 +118,1 @@\n-            res[i] = Double.isInfinite(d1[i]) ? 1 : 0;\n+            res[i] = Double.isInfinite(d1[i]) ? 1 : 2;\n@@ -110,1 +125,1 @@\n-            res[i] = Float.isFinite(f1[i]) ? 1 : 0;\n+            res[i] = Float.isFinite(f1[i]) ? 1 : 2;\n@@ -117,1 +132,1 @@\n-            res[i] = Double.isFinite(d1[i]) ? 1 : 0;\n+            res[i] = Double.isFinite(d1[i]) ? 1 : 2;\n@@ -124,1 +139,1 @@\n-            res[i] = (f1[i] == f2[i]) ? 1 : 0;\n+            res[i] = (f1[i] == f2[i]) ? 1 : 2;\n@@ -131,1 +146,129 @@\n-            res[i] = (d1[i] == d2[i]) ? 1 : 0;\n+            res[i] = (d1[i] == d2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (f1[i] < f2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (d1[i] < d2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (f1[i] <= f2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (d1[i] <= d2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (f1[i] > f2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (d1[i] > d2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (f1[i] >= f2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (d1[i] >= d2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    \/\/ --------- result: long ---------\n+\n+    @Benchmark\n+    public void equalFloatResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (f1[i] == f2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void equalDoubleResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (d1[i] == d2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessFloatResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (f1[i] < f2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessDoubleResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (d1[i] < d2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualFloatResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (f1[i] <= f2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualDoubleResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (d1[i] <= d2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterFloatResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (f1[i] > f2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterDoubleResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (d1[i] > d2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualFloatResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (f1[i] >= f2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualDoubleResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (d1[i] >= d2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/FPComparison.java","additions":151,"deletions":8,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2025, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.random.RandomGenerator;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+public class IntegerComparison {\n+    static final int INVOCATIONS = 1024;\n+\n+    int[] i1;\n+    int[] i2;\n+    int[] res;\n+    long[] resLong;\n+    Object[] resObject;\n+    Object ro1;\n+    Object ro2;\n+    Object[] resClass;\n+    Class rc1;\n+    Class rc2;\n+\n+    @Setup\n+    public void setup() {\n+        var random = RandomGenerator.getDefault();\n+        i1 = new int[INVOCATIONS];\n+        i2 = new int[INVOCATIONS];\n+        res = new int[INVOCATIONS];\n+        resLong = new long[INVOCATIONS];\n+        resObject = new Object[INVOCATIONS];\n+        ro1 = new Object();\n+        ro2 = new Object();\n+        resClass = new Class[INVOCATIONS];\n+        rc1 = Float.class;\n+        rc2 = Double.class;\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            i1[i] = random.nextInt(INVOCATIONS);\n+            i2[i] = random.nextInt(INVOCATIONS);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void equalInteger() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (i1[i] == i2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualInteger() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (i1[i] != i2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessInteger() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (i1[i] < i2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualInteger() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (i1[i] <= i2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterInteger() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (i1[i] > i2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualInteger() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (i1[i] >= i2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    \/\/ --------- result: long ---------\n+\n+    public void equalIntegerResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (i1[i] == i2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualIntegerResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (i1[i] != i2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    public void lessIntegerResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (i1[i] < i2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualIntegerResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (i1[i] <= i2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    public void greaterIntegerResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (i1[i] > i2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualIntegerResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (i1[i] >= i2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/IntegerComparison.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2025, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.random.RandomGenerator;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+public class LongComparison {\n+    static final int INVOCATIONS = 1024;\n+\n+    long[] l1;\n+    long[] l2;\n+    int[] res;\n+    long[] resLong;\n+    Object[] resObject;\n+    Object ro1;\n+    Object ro2;\n+    Object[] resClass;\n+    Class rc1;\n+    Class rc2;\n+\n+    @Setup\n+    public void setup() {\n+        var random = RandomGenerator.getDefault();\n+        l1 = new long[INVOCATIONS];\n+        l2 = new long[INVOCATIONS];\n+        res = new int[INVOCATIONS];\n+        resLong = new long[INVOCATIONS];\n+        resObject = new Object[INVOCATIONS];\n+        ro1 = new Object();\n+        ro2 = new Object();\n+        resClass = new Class[INVOCATIONS];\n+        rc1 = Float.class;\n+        rc2 = Double.class;\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            l1[i] = random.nextLong(INVOCATIONS);\n+            l2[i] = random.nextLong(INVOCATIONS);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void equalLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (l1[i] == l2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (l1[i] != l2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (l1[i] < l2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (l1[i] <= l2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (l1[i] > l2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (l1[i] >= l2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    \/\/ --------- result: long ---------\n+\n+    public void equalLongResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (l1[i] == l2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualLongResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (l1[i] != l2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    public void lessLongResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (l1[i] < l2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void lessEqualLongResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (l1[i] <= l2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    public void greaterLongResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (l1[i] > l2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void greaterEqualLongResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (l1[i] >= l2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/LongComparison.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2025, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.random.RandomGenerator;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+public class PointerComparison {\n+    static final int INVOCATIONS = 1024;\n+\n+    Object[] o1;\n+    Object[] o2;\n+    int[] res;\n+    long[] resLong;\n+    Object[] resObject;\n+    Object ro1;\n+    Object ro2;\n+    Object[] resClass;\n+    Class rc1;\n+    Class rc2;\n+\n+    @Setup\n+    public void setup() {\n+        var random = RandomGenerator.getDefault();\n+        o1 = new Object[INVOCATIONS];\n+        o2 = new Object[INVOCATIONS];\n+        res = new int[INVOCATIONS];\n+        resLong = new long[INVOCATIONS];\n+        resObject = new Object[INVOCATIONS];\n+        ro1 = new Object();\n+        ro2 = new Object();\n+        resClass = new Class[INVOCATIONS];\n+        rc1 = Float.class;\n+        rc2 = Double.class;\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            o1[i] = new Object();\n+        }\n+        List<Object> list = Arrays.asList(o1);\n+        Collections.shuffle(list);\n+        list.toArray(o2);\n+    }\n+\n+    @Benchmark\n+    public void equalObject() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (o1[i] == o2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualObject() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (o1[i] != o2[i]) ? 1 : 2;\n+        }\n+    }\n+\n+    public void equalObjectResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (o1[i] == o2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void notEqualObjectResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (o1[i] != o2[i]) ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/PointerComparison.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"}]}