{"files":[{"patch":"@@ -139,2 +139,2 @@\n-          \/\/ They are not suitable for auto-vectorization because the implementations cannot\n-          \/\/ guarantee strict ordering.\n+          \/\/ They are not suitable for auto-vectorization because the result would not conform\n+          \/\/ to the JLS, Section Evaluation Order.\n@@ -2863,3 +2863,2 @@\n-  \/\/ Non-strictly ordered floating-point add reduction for vector length of 64-bit. As an\n-  \/\/ example, this rule can be reached from the VectorAPI (which allows for non-strictly ordered\n-  \/\/ add reduction).\n+  \/\/ Non-strictly ordered floating-point add reduction for a 64-bits-long vector. This rule is\n+  \/\/ intended for the VectorAPI (which allows for non-strictly ordered add reduction).\n@@ -2878,3 +2877,2 @@\n-  \/\/ Non-strictly ordered floating-point add reduction for vector length of 128-bit. As an\n-  \/\/ example, this rule can be reached from the VectorAPI (which allows for non-strictly ordered\n-  \/\/ add reduction).\n+  \/\/ Non-strictly ordered floating-point add reduction for 128-bits-long vector. This rule is\n+  \/\/ intended for the VectorAPI (which allows for non-strictly ordered add reduction).\n@@ -2895,2 +2893,2 @@\n-\/\/ 1. Non strictly-ordered AddReductionVF when vector size > 128-bit. For example -\n-\/\/    AddReductionVF generated by Vector API. For vector size > 128-bit, it is more\n+\/\/ 1. Non strictly-ordered AddReductionVF when vector size > 128-bits. For example -\n+\/\/    AddReductionVF generated by Vector API. For vector size > 128-bits, it is more\n@@ -2918,3 +2916,2 @@\n-  \/\/ Non-strictly ordered floating-point add reduction for doubles. As an\n-  \/\/ example, this rule can be reached from the VectorAPI (which allows for\n-  \/\/ non-strictly ordered add reduction).\n+  \/\/ Non-strictly ordered floating-point add reduction for doubles. This rule is\n+  \/\/ intended for the VectorAPI (which allows for non-strictly ordered add reduction).\n@@ -2934,2 +2931,2 @@\n-\/\/ 1. Non strictly-ordered AddReductionVD when vector size > 128-bit. For example -\n-\/\/    AddReductionVD generated by Vector API. For vector size > 128-bit, it is more\n+\/\/ 1. Non strictly-ordered AddReductionVD when vector size > 128-bits. For example -\n+\/\/    AddReductionVD generated by Vector API. For vector size > 128-bits, it is more\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -129,2 +129,2 @@\n-          \/\/ They are not suitable for auto-vectorization because the implementations cannot\n-          \/\/ guarantee strict ordering.\n+          \/\/ They are not suitable for auto-vectorization because the result would not conform\n+          \/\/ to the JLS, Section Evaluation Order.\n@@ -1753,3 +1753,2 @@\n-  \/\/ Non-strictly ordered floating-point add reduction for vector length of 64-bit. As an\n-  \/\/ example, this rule can be reached from the VectorAPI (which allows for non-strictly ordered\n-  \/\/ add reduction).\n+  \/\/ Non-strictly ordered floating-point add reduction for a 64-bits-long vector. This rule is\n+  \/\/ intended for the VectorAPI (which allows for non-strictly ordered add reduction).\n@@ -1768,3 +1767,2 @@\n-  \/\/ Non-strictly ordered floating-point add reduction for vector length of 128-bit. As an\n-  \/\/ example, this rule can be reached from the VectorAPI (which allows for non-strictly ordered\n-  \/\/ add reduction).\n+  \/\/ Non-strictly ordered floating-point add reduction for 128-bits-long vector. This rule is\n+  \/\/ intended for the VectorAPI (which allows for non-strictly ordered add reduction).\n@@ -1788,2 +1786,2 @@\n-\/\/ 1. Non strictly-ordered AddReductionV$1 when vector size > 128-bit. For example -\n-\/\/    AddReductionV$1 generated by Vector API. For vector size > 128-bit, it is more\n+\/\/ 1. Non strictly-ordered AddReductionV$1 when vector size > 128-bits. For example -\n+\/\/    AddReductionV$1 generated by Vector API. For vector size > 128-bits, it is more\n@@ -1813,3 +1811,2 @@\n-  \/\/ Non-strictly ordered floating-point add reduction for doubles. As an\n-  \/\/ example, this rule can be reached from the VectorAPI (which allows for\n-  \/\/ non-strictly ordered add reduction).\n+  \/\/ Non-strictly ordered floating-point add reduction for doubles. This rule is\n+  \/\/ intended for the VectorAPI (which allows for non-strictly ordered add reduction).\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -243,0 +243,10 @@\n+\n+  #ifndef PRODUCT\n+  void dump_spec(outputStream *st) const {\n+    if (requires_strict_order()) {\n+      st->print(\"requires_strict_order\");\n+    } else {\n+      st->print(\"no_strict_order\");\n+    }\n+  }\n+  #endif\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8320725\n+ * @summary Ensure strictly ordered AddReductionVF\/VD nodes are generated on SVE machines\n+ * while being disabled on Neon\n+ * @requires os.arch == \"aarch64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestVectorFPReduction\n+ *\/\n+\n+public class TestVectorFPReduction {\n+\n+    final private static int SIZE = 1024;\n+\n+    private static double[] da = new double[SIZE];\n+    private static double[] db = new double[SIZE];\n+    private static float[] fa = new float[SIZE];\n+    private static float[] fb = new float[SIZE];\n+    private static float fresult;\n+    private static double dresult;\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseSVE\", \"0\"}, failOn = {IRNode.ADD_REDUCTION_VF})\n+    @IR(applyIf = {\"UseSVE\", \">0\"}, counts = {\"requires_strict_order\", \">=1\", IRNode.ADD_REDUCTION_VF, \">=1\"},\n+        failOn = {\"no_strict_order\"}, phase = CompilePhase.PRINT_IDEAL)\n+    private static void testAddReductionVF() {\n+        float result = 1;\n+        for(int i = 0; i < SIZE; i++) {\n+            result += (fa[i] + fb[i]);\n+        }\n+        fresult += result;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseSVE\", \"0\"}, failOn = {IRNode.ADD_REDUCTION_VD})\n+    @IR(applyIf = {\"UseSVE\", \">0\"}, counts = {\"requires_strict_order\", \">=1\", IRNode.ADD_REDUCTION_VD, \">=1\"},\n+        failOn = {\"no_strict_order\"}, phase = CompilePhase.PRINT_IDEAL)\n+    private static void testAddReductionVD() {\n+        double result = 1;\n+        for(int i = 0; i < SIZE; i++) {\n+            result += (da[i] + db[i]);\n+        }\n+        dresult += result;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseSVE\", \"0\"}, failOn = {IRNode.MUL_REDUCTION_VF})\n+    @IR(applyIf = {\"UseSVE\", \">0\"}, counts = {\"requires_strict_order\", \">=1\", IRNode.MUL_REDUCTION_VF, \">=1\"},\n+        failOn = {\"no_strict_order\"}, phase = CompilePhase.PRINT_IDEAL)\n+    private static void testMulReductionVF() {\n+        float result = 1;\n+        for(int i = 0; i < SIZE; i++) {\n+            result *= (fa[i] + fb[i]);\n+        }\n+        fresult += result;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseSVE\", \"0\"}, failOn = {IRNode.MUL_REDUCTION_VD})\n+    @IR(applyIf = {\"UseSVE\", \">0\"}, counts = {\"requires_strict_order\", \">=1\", IRNode.MUL_REDUCTION_VD, \">=1\"},\n+        failOn = {\"no_strict_order\"}, phase = CompilePhase.PRINT_IDEAL)\n+    private static void testMulReductionVD() {\n+        double result = 1;\n+        for(int i = 0; i < SIZE; i++) {\n+            result *= (da[i] + db[i]);\n+        }\n+        dresult += result;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorFPReduction.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import java.util.Random;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @test\n+ * @bug 8320725\n+ * @library \/test\/lib \/\n+ * @requires os.arch == \"aarch64\"\n+ * @summary Verify non-strictly ordered AddReductionVF\/VD and MulReductionVF\/VD\n+ * nodes are generated for float and double types in VectorAPI\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.TestVectorAddMulReduction\n+ *\/\n+\n+public class TestVectorAddMulReduction {\n+\n+    private static final int SIZE = 1024;\n+    private static final Random RD = Utils.getRandomInstance();\n+\n+    private static float [] fa;\n+    private static float fres;\n+    private static double [] da;\n+    private static double dres;\n+\n+    static {\n+        fa = new float[SIZE];\n+        da = new double[SIZE];\n+        fres = 1;\n+        dres = 1;\n+        for (int i = 0; i < SIZE; i++) {\n+            fa[i] = RD.nextFloat();\n+            da[i] = RD.nextDouble();\n+        }\n+    }\n+\n+    \/\/ Test add reduction operation for floats\n+    @ForceInline\n+    public static void testFloatAddKernel(VectorSpecies SPECIES, float [] f) {\n+        for (int i = 0; i < SPECIES.loopBound(f.length); i += SPECIES.length()) {\n+            var av = FloatVector.fromArray(SPECIES, f, i);\n+            fres += av.reduceLanes(VectorOperators.ADD);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"MaxVectorSize\", \">=8\"}, counts = {IRNode.ADD_REDUCTION_VF, \">=1\", \"no_strict_order\", \">=1\"},\n+        failOn = {\"requires_strict_order\"}, phase = CompilePhase.PRINT_IDEAL)\n+    public static void testFloatAdd_64() {\n+        testFloatAddKernel(FloatVector.SPECIES_64, fa);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"MaxVectorSize\", \">=16\"}, counts = {IRNode.ADD_REDUCTION_VF, \">=1\", \"no_strict_order\", \">=1\"},\n+        failOn = {\"requires_strict_order\"}, phase = CompilePhase.PRINT_IDEAL)\n+    public static void testFloatAdd_128() {\n+        testFloatAddKernel(FloatVector.SPECIES_128, fa);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"MaxVectorSize\", \">=32\"}, counts = {IRNode.ADD_REDUCTION_VF, \">=1\", \"no_strict_order\", \">=1\"},\n+        failOn = {\"requires_strict_order\"}, phase = CompilePhase.PRINT_IDEAL)\n+    public static void testFloatAdd_256() {\n+        testFloatAddKernel(FloatVector.SPECIES_256, fa);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"MaxVectorSize\", \">=64\"}, counts = {IRNode.ADD_REDUCTION_VF, \">=1\", \"no_strict_order\", \">=1\"},\n+        failOn = {\"requires_strict_order\"}, phase = CompilePhase.PRINT_IDEAL)\n+    public static void testFloatAdd_512() {\n+        testFloatAddKernel(FloatVector.SPECIES_512, fa);\n+    }\n+\n+    \/\/ Test add reduction operation for doubles\n+    @ForceInline\n+    public static void testDoubleAddKernel(VectorSpecies SPECIES, double [] d) {\n+        for (int i = 0; i < SPECIES.loopBound(d.length); i += SPECIES.length()) {\n+            var av = DoubleVector.fromArray(SPECIES, d, i);\n+            dres += av.reduceLanes(VectorOperators.ADD);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"MaxVectorSize\", \">=16\"}, counts = {IRNode.ADD_REDUCTION_VD, \">=1\", \"no_strict_order\", \">=1\"},\n+        failOn = {\"requires_strict_order\"}, phase = CompilePhase.PRINT_IDEAL)\n+    public static void testDoubleAdd_128() {\n+        testDoubleAddKernel(DoubleVector.SPECIES_128, da);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"MaxVectorSize\", \">=32\"}, counts = {IRNode.ADD_REDUCTION_VD, \">=1\", \"no_strict_order\", \">=1\"},\n+        failOn = {\"requires_strict_order\"}, phase = CompilePhase.PRINT_IDEAL)\n+    public static void testDoubleAdd_256() {\n+        testDoubleAddKernel(DoubleVector.SPECIES_256, da);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"MaxVectorSize\", \">=64\"}, counts = {IRNode.ADD_REDUCTION_VD, \">=1\", \"no_strict_order\", \">=1\"},\n+        failOn = {\"requires_strict_order\"}, phase = CompilePhase.PRINT_IDEAL)\n+    public static void testDoubleAdd_512() {\n+        testDoubleAddKernel(DoubleVector.SPECIES_512, da);\n+    }\n+\n+    \/\/ Test mul reduction operation for floats\n+    \/\/ On aarch64, there are no direct vector mul reduction instructions for float\/double mul reduction\n+    \/\/ and scalar instructions are emitted for 64-bit\/128-bit vectors. Thus MulReductionVF\/VD nodes are generated\n+    \/\/ only for vector length of 8B\/16B on vectorAPI.\n+    @ForceInline\n+    public static void testFloatMulKernel(VectorSpecies SPECIES, float [] f) {\n+        for (int i = 0; i < SPECIES.loopBound(f.length); i += SPECIES.length()) {\n+            var av = FloatVector.fromArray(SPECIES, f, i);\n+            fres += av.reduceLanes(VectorOperators.MUL);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"MaxVectorSize\", \">=8\"}, counts = {IRNode.MUL_REDUCTION_VF, \">=1\", \"no_strict_order\", \">=1\"},\n+        failOn = {\"requires_strict_order\"}, phase = CompilePhase.PRINT_IDEAL)\n+    public static void testFloatMul_64() {\n+        testFloatMulKernel(FloatVector.SPECIES_64, fa);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"MaxVectorSize\", \">=16\"}, counts = {IRNode.MUL_REDUCTION_VF, \">=1\", \"no_strict_order\", \">=1\"},\n+        failOn = {\"requires_strict_order\"}, phase = CompilePhase.PRINT_IDEAL)\n+    public static void testFloatMul_128() {\n+        testFloatMulKernel(FloatVector.SPECIES_128, fa);\n+    }\n+\n+    \/\/ Test mul reduction operation for doubles\n+    @ForceInline\n+    public static void testDoubleMulKernel(VectorSpecies SPECIES, double [] d) {\n+        for (int i = 0; i < SPECIES.loopBound(d.length); i += SPECIES.length()) {\n+            var av = DoubleVector.fromArray(SPECIES, d, i);\n+            dres += av.reduceLanes(VectorOperators.MUL);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"MaxVectorSize\", \">=16\"}, counts = {IRNode.MUL_REDUCTION_VD, \">=1\", \"no_strict_order\", \">=1\"},\n+        failOn = {\"requires_strict_order\"}, phase = CompilePhase.PRINT_IDEAL)\n+    public static void testDoubleMul_128() {\n+        testDoubleMulKernel(DoubleVector.SPECIES_128, da);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n+                                   \"--add-modules=jdk.incubator.vector\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorAddMulReduction.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"}]}