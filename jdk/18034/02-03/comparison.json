{"files":[{"patch":"@@ -139,2 +139,2 @@\n-          \/\/ They are not suitable for auto-vectorization because they are non-associative\n-          \/\/ and their Neon implementations cannot guarantee strict ordering.\n+          \/\/ They are not suitable for auto-vectorization because the implementations cannot\n+          \/\/ guarantee strict ordering.\n@@ -2858,1 +2858,4 @@\n-  predicate(Matcher::vector_length(n->in(2)) == 2 && n->as_Reduction()->is_associative());\n+  \/\/ Non-strictly ordered floating-point add reduction for vector length of 64-bit. As an\n+  \/\/ example, this rule can be reached from the VectorAPI (which allows for non-strictly ordered\n+  \/\/ add reduction).\n+  predicate(Matcher::vector_length(n->in(2)) == 2 && !n->as_Reduction()->requires_strict_order());\n@@ -2870,1 +2873,4 @@\n-  predicate(Matcher::vector_length(n->in(2)) == 4 && n->as_Reduction()->is_associative());\n+  \/\/ Non-strictly ordered floating-point add reduction for vector length of 128-bit. As an\n+  \/\/ example, this rule can be reached from the VectorAPI (which allows for non-strictly ordered\n+  \/\/ add reduction).\n+  predicate(Matcher::vector_length(n->in(2)) == 4 && !n->as_Reduction()->requires_strict_order());\n@@ -2884,3 +2890,5 @@\n-\/\/ 1. Associative (or non-strictly ordered) AddReductionVF when vector size > 128-bit.\n-\/\/    Such nodes can only be generated by Vector API.\n-\/\/ 2. Non-associative (or strictly ordered) AddReductionVF, which can only be generated by\n+\/\/ 1. Non strictly-ordered AddReductionVF when vector size > 128-bit. For example -\n+\/\/    AddReductionVF generated by Vector API. For vector size > 128-bit, it is more\n+\/\/    beneficial performance-wise to generate direct SVE instruction even if it is\n+\/\/    strictly ordered.\n+\/\/ 2. Strictly-ordered AddReductionVF. For example - AddReductionVF generated by\n@@ -2890,1 +2898,1 @@\n-            !n->as_Reduction()->is_associative());\n+            n->as_Reduction()->requires_strict_order());\n@@ -2904,1 +2912,4 @@\n-  predicate(n->as_Reduction()->is_associative());\n+  \/\/ Non-strictly ordered floating-point add reduction for doubles. As an\n+  \/\/ example, this rule can be reached from the VectorAPI (which allows for\n+  \/\/ non-strictly ordered add reduction).\n+  predicate(!n->as_Reduction()->requires_strict_order());\n@@ -2917,3 +2928,5 @@\n-\/\/ 1. Associative (or non-strictly ordered) AddReductionVD when vector size > 128-bit.\n-\/\/    Such nodes can only be generated by Vector API.\n-\/\/ 2. Non-associative (or strictly ordered) AddReductionVD, which can only be generated by\n+\/\/ 1. Non strictly-ordered AddReductionVD when vector size > 128-bit. For example -\n+\/\/    AddReductionVD generated by Vector API. For vector size > 128-bit, it is more\n+\/\/    beneficial performance-wise to generate direct SVE instruction even if it is\n+\/\/    strictly ordered.\n+\/\/ 2. Strictly-ordered AddReductionVD. For example - AddReductionVD generated by\n@@ -2923,1 +2936,1 @@\n-            !n->as_Reduction()->is_associative());\n+            n->as_Reduction()->requires_strict_order());\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":26,"deletions":13,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -129,2 +129,2 @@\n-          \/\/ They are not suitable for auto-vectorization because they are non-associative\n-          \/\/ and their Neon implementations cannot guarantee strict ordering.\n+          \/\/ They are not suitable for auto-vectorization because the implementations cannot\n+          \/\/ guarantee strict ordering.\n@@ -1752,1 +1752,4 @@\n-  predicate(Matcher::vector_length(n->in(2)) == 2 && n->as_Reduction()->is_associative());\n+  \/\/ Non-strictly ordered floating-point add reduction for vector length of 64-bit. As an\n+  \/\/ example, this rule can be reached from the VectorAPI (which allows for non-strictly ordered\n+  \/\/ add reduction).\n+  predicate(Matcher::vector_length(n->in(2)) == 2 && !n->as_Reduction()->requires_strict_order());\n@@ -1764,1 +1767,4 @@\n-  predicate(Matcher::vector_length(n->in(2)) == 4 && n->as_Reduction()->is_associative());\n+  \/\/ Non-strictly ordered floating-point add reduction for vector length of 128-bit. As an\n+  \/\/ example, this rule can be reached from the VectorAPI (which allows for non-strictly ordered\n+  \/\/ add reduction).\n+  predicate(Matcher::vector_length(n->in(2)) == 4 && !n->as_Reduction()->requires_strict_order());\n@@ -1781,3 +1787,5 @@\n-\/\/ 1. Associative (or non-strictly ordered) AddReductionV$1 when vector size > 128-bit.\n-\/\/    Such nodes can only be generated by Vector API.\n-\/\/ 2. Non-associative (or strictly ordered) AddReductionV$1, which can only be generated by\n+\/\/ 1. Non strictly-ordered AddReductionV$1 when vector size > 128-bit. For example -\n+\/\/    AddReductionV$1 generated by Vector API. For vector size > 128-bit, it is more\n+\/\/    beneficial performance-wise to generate direct SVE instruction even if it is\n+\/\/    strictly ordered.\n+\/\/ 2. Strictly-ordered AddReductionV$1. For example - AddReductionV$1 generated by\n@@ -1787,1 +1795,1 @@\n-            !n->as_Reduction()->is_associative());\n+            n->as_Reduction()->requires_strict_order());\n@@ -1803,1 +1811,4 @@\n-  predicate(n->as_Reduction()->is_associative());\n+  \/\/ Non-strictly ordered floating-point add reduction for doubles. As an\n+  \/\/ example, this rule can be reached from the VectorAPI (which allows for\n+  \/\/ non-strictly ordered add reduction).\n+  predicate(!n->as_Reduction()->requires_strict_order());\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1445,1 +1445,1 @@\n-  \/\/ Move UnorderedReduction out of loop if possible\n+  \/\/ Move an unordered Reduction out of loop if possible\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4306,0 +4306,1 @@\n+\/\/ Returns true if the Reduction node is unordered.\n@@ -4307,1 +4308,1 @@\n-  return n->is_Reduction() && n->as_Reduction()->is_associative();\n+  return n->is_Reduction() && !n->as_Reduction()->requires_strict_order();\n@@ -4315,0 +4316,3 @@\n+\/\/ Note: UnorderedReduction represents a ReductionNode which does not require\n+\/\/ calculating in strict order.\n+\/\/\n@@ -4356,5 +4360,2 @@\n-\/\/ reordering of operations (for example float addition is non-associative\n-\/\/ and requires calculations to be in strict order).\n-\/\/\n-\/\/ Unordered reduction refers to the ReductionNode which does not require\n-\/\/ calculating in strict order or is associative in nature.\n+\/\/ reordering of operations (for example float addition\/multiplication require\n+\/\/ strict order).\n@@ -4364,1 +4365,1 @@\n-  \/\/ Find all Phi nodes with UnorderedReduction on backedge.\n+  \/\/ Find all Phi nodes with an unordered Reduction on backedge.\n@@ -4368,1 +4369,1 @@\n-    \/\/ We have a phi with a single use, and a UnorderedReduction on the backedge.\n+    \/\/ We have a phi with a single use, and an unordered Reduction on the backedge.\n@@ -4374,1 +4375,1 @@\n-    assert(last_ur->is_associative(), \"must be\");\n+    assert(!last_ur->requires_strict_order(), \"must be\");\n@@ -4391,2 +4392,2 @@\n-    \/\/ Traverse up the chain of UnorderedReductions, checking that it loops back to\n-    \/\/ the phi. Check that all UnorderedReductions only have a single use, except for\n+    \/\/ Traverse up the chain of unordered Reductions, checking that it loops back to\n+    \/\/ the phi. Check that all unordered Reductions only have a single use, except for\n@@ -4398,1 +4399,1 @@\n-      assert(current->is_associative(), \"sanity\");\n+      assert(!current->requires_strict_order(), \"sanity\");\n@@ -4415,1 +4416,1 @@\n-      \/\/ Expect single use of UnorderedReduction, except for last_ur.\n+      \/\/ Expect single use of an unordered Reduction, except for last_ur.\n@@ -4433,1 +4434,1 @@\n-      \/\/ Expect another UnorderedReduction or phi as the scalar input.\n+      \/\/ Expect another unordered Reduction or phi as the scalar input.\n@@ -4437,1 +4438,1 @@\n-        \/\/ Move up the UnorderedReduction chain.\n+        \/\/ Move up the unordered Reduction chain.\n@@ -4439,1 +4440,1 @@\n-        assert(current->is_associative(), \"must be\");\n+        assert(!current->requires_strict_order(), \"must be\");\n@@ -4463,1 +4464,1 @@\n-    VectorNode::trace_new_vector(identity_vector, \"UnorderedReduction\");\n+    VectorNode::trace_new_vector(identity_vector, \"Unordered Reduction\");\n@@ -4472,1 +4473,1 @@\n-    \/\/ Traverse down the chain of UnorderedReductions, and replace them with vector_accumulators.\n+    \/\/ Traverse down the chain of unordered Reductions, and replace them with vector_accumulators.\n@@ -4481,1 +4482,1 @@\n-      VectorNode::trace_new_vector(vector_accumulator, \"UnorderedReduction\");\n+      VectorNode::trace_new_vector(vector_accumulator, \"Unordered Reduction\");\n@@ -4486,1 +4487,1 @@\n-      assert(current->is_associative(), \"must be\");\n+      assert(!current->requires_strict_order(), \"must be\");\n@@ -4503,1 +4504,1 @@\n-    VectorNode::trace_new_vector(post_loop_reduction, \"UnorderedReduction\");\n+    VectorNode::trace_new_vector(post_loop_reduction, \"Unordered Reduction\");\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1746,1 +1746,3 @@\n-  value = ReductionNode::make(opc, nullptr, init, value, elem_bt, \/* is_associative *\/ true);\n+  \/\/ Make an unordered Reduction node. This affects only AddReductionVF\/VD and MulReductionVF\/VD,\n+  \/\/ as these operations are allowed to be associative (not requiring strict order) in VectorAPI.\n+  value = ReductionNode::make(opc, nullptr, init, value, elem_bt, \/* requires_strict_order *\/ false);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1321,1 +1321,1 @@\n-                                   bool is_associative) {\n+                                   bool requires_strict_order) {\n@@ -1331,2 +1331,2 @@\n-  case Op_AddReductionVF: return new AddReductionVFNode(ctrl, n1, n2, is_associative);\n-  case Op_AddReductionVD: return new AddReductionVDNode(ctrl, n1, n2, is_associative);\n+  case Op_AddReductionVF: return new AddReductionVFNode(ctrl, n1, n2, requires_strict_order);\n+  case Op_AddReductionVD: return new AddReductionVDNode(ctrl, n1, n2, requires_strict_order);\n@@ -1335,2 +1335,2 @@\n-  case Op_MulReductionVF: return new MulReductionVFNode(ctrl, n1, n2);\n-  case Op_MulReductionVD: return new MulReductionVDNode(ctrl, n1, n2);\n+  case Op_MulReductionVF: return new MulReductionVFNode(ctrl, n1, n2, requires_strict_order);\n+  case Op_MulReductionVD: return new MulReductionVDNode(ctrl, n1, n2, requires_strict_order);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -209,2 +209,2 @@\n-                             \/\/ Currently, this only effects floating-point add reductions.\n-                             bool is_associative = false);\n+                             \/\/ This only effects floating-point add and mul reductions.\n+                             bool requires_strict_order = true);\n@@ -234,4 +234,4 @@\n-  \/\/ AddReductionVF\/D and MulReductionVF\/D require strict-ordering\n-  \/\/ in auto-vectorization. Currently, Vector API allows\n-  \/\/ AddReductionVF\/VD to be associative (no need of strict ordering)\n-  \/\/ which can benefit some platforms.\n+  \/\/ AddReductionVF\/D and MulReductionVF\/D require strict ordering\n+  \/\/ in auto-vectorization. Vector API can generate AddReductionVF\/D\n+  \/\/ and MulReductionVF\/VD without strict ordering, which can benefit\n+  \/\/ some platforms.\n@@ -239,3 +239,3 @@\n-  \/\/ Other reductions are associative (do not need strict ordering).\n-  virtual bool is_associative() const {\n-    return true;\n+  \/\/ Other reductions don't need strict ordering.\n+  virtual bool requires_strict_order() const {\n+    return false;\n@@ -265,6 +265,5 @@\n-  \/\/ True if add reduction of floats is associative.\n-  \/\/ The value is true when add reduction for floats is generated through VectorAPI\n-  \/\/ as VectorAPI allows it to be associative (no strict ordering). The value is false\n-  \/\/ when it is auto-vectorized as auto-vectorization mandates the operation to be\n-  \/\/ non-associative (strictly ordered).\n-  bool _is_associative;\n+  \/\/ True if add reduction operation for floats requires strict ordering.\n+  \/\/ As an example - The value is true when add reduction for floats is auto-vectorized\n+  \/\/ as auto-vectorization mandates strict ordering but the value is false when this node\n+  \/\/ is generated through VectorAPI as VectorAPI does not impose any such rules on ordering.\n+  const bool _requires_strict_order;\n@@ -272,2 +271,3 @@\n-  AddReductionVFNode(Node *ctrl, Node* in1, Node* in2, bool is_associative) :\n-    ReductionNode(ctrl, in1, in2), _is_associative(is_associative) {}\n+  \/\/_requires_strict_order is set to true by default as mandated by auto-vectorization\n+  AddReductionVFNode(Node *ctrl, Node* in1, Node* in2, bool requires_strict_order = true) :\n+    ReductionNode(ctrl, in1, in2), _requires_strict_order(requires_strict_order) {}\n@@ -277,1 +277,1 @@\n-  virtual bool is_associative() const { return _is_associative; }\n+  virtual bool requires_strict_order() const { return _requires_strict_order; }\n@@ -279,1 +279,1 @@\n-  virtual uint hash() const { return Node::hash() + _is_associative; }\n+  virtual uint hash() const { return Node::hash() + _requires_strict_order; }\n@@ -282,1 +282,1 @@\n-    return Node::cmp(n) && _is_associative == ((ReductionNode&)n).is_associative();\n+    return Node::cmp(n) && _requires_strict_order == ((ReductionNode&)n).requires_strict_order();\n@@ -292,6 +292,5 @@\n-  \/\/ True if add reduction of doubles is associative.\n-  \/\/ The value is true when add reduction for doubles is generated through VectorAPI\n-  \/\/ as VectorAPI allows it to be associative (no strict ordering). The value is false\n-  \/\/ when it is auto-vectorized as auto-vectorization mandates the operation to be\n-  \/\/ non-associative (strictly ordered).\n-  bool _is_associative;\n+  \/\/ True if add reduction operation for doubles requires strict ordering.\n+  \/\/ As an example - The value is true when add reduction for doubles is auto-vectorized\n+  \/\/ as auto-vectorization mandates strict ordering but the value is false when this node\n+  \/\/ is generated through VectorAPI as VectorAPI does not impose any such rules on ordering.\n+  const bool _requires_strict_order;\n@@ -299,2 +298,3 @@\n-  AddReductionVDNode(Node *ctrl, Node* in1, Node* in2, bool is_associative) :\n-    ReductionNode(ctrl, in1, in2), _is_associative(is_associative) {}\n+  \/\/_requires_strict_order is set to true by default as mandated by auto-vectorization\n+  AddReductionVDNode(Node *ctrl, Node* in1, Node* in2, bool requires_strict_order = true) :\n+    ReductionNode(ctrl, in1, in2), _requires_strict_order(requires_strict_order) {}\n@@ -304,1 +304,1 @@\n-  virtual bool is_associative() const { return _is_associative; }\n+  virtual bool requires_strict_order() const { return _requires_strict_order; }\n@@ -306,1 +306,1 @@\n-  virtual uint hash() const { return Node::hash() + _is_associative; }\n+  virtual uint hash() const { return Node::hash() + _requires_strict_order; }\n@@ -309,1 +309,1 @@\n-    return Node::cmp(n) && _is_associative == ((ReductionNode&)n).is_associative();\n+    return Node::cmp(n) && _requires_strict_order == ((ReductionNode&)n).requires_strict_order();\n@@ -464,0 +464,5 @@\n+  \/\/ True if mul reduction operation for floats requires strict ordering.\n+  \/\/ As an example - The value is true when mul reduction for floats is auto-vectorized\n+  \/\/ as auto-vectorization mandates strict ordering but the value is false when this node\n+  \/\/ is generated through VectorAPI as VectorAPI does not impose any such rules on ordering.\n+  const bool _requires_strict_order;\n@@ -465,1 +470,4 @@\n-  MulReductionVFNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  \/\/_requires_strict_order is set to true by default as mandated by auto-vectorization\n+  MulReductionVFNode(Node *ctrl, Node* in1, Node* in2, bool requires_strict_order = true) :\n+    ReductionNode(ctrl, in1, in2), _requires_strict_order(requires_strict_order) {}\n+\n@@ -468,2 +476,9 @@\n-  \/\/ Since no real case can benefit from the operation being associative, return false currently.\n-  virtual bool is_associative() const { return false; }\n+  virtual bool requires_strict_order() const { return _requires_strict_order; }\n+\n+  virtual uint hash() const { return Node::hash() + _requires_strict_order; }\n+\n+  virtual bool cmp(const Node& n) const {\n+    return Node::cmp(n) && _requires_strict_order == ((ReductionNode&)n).requires_strict_order();\n+  }\n+\n+  virtual uint size_of() const { return sizeof(*this); }\n@@ -475,0 +490,5 @@\n+  \/\/ True if mul reduction operation for doubles requires strict ordering.\n+  \/\/ As an example - The value is true when mul reduction for doubles is auto-vectorized\n+  \/\/ as auto-vectorization mandates strict ordering but the value is false when this node\n+  \/\/ is generated through VectorAPI as VectorAPI does not impose any such rules on ordering.\n+  const bool _requires_strict_order;\n@@ -476,1 +496,4 @@\n-  MulReductionVDNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  \/\/_requires_strict_order is set to true by default as mandated by auto-vectorization\n+  MulReductionVDNode(Node *ctrl, Node* in1, Node* in2, bool requires_strict_order = true) :\n+    ReductionNode(ctrl, in1, in2), _requires_strict_order(requires_strict_order) {}\n+\n@@ -479,2 +502,9 @@\n-  \/\/ Since no real case can benefit from the operation being associative, return false currently.\n-  virtual bool is_associative() const { return false; }\n+  virtual bool requires_strict_order() const { return _requires_strict_order; }\n+\n+  virtual uint hash() const { return Node::hash() + _requires_strict_order; }\n+\n+  virtual bool cmp(const Node& n) const {\n+    return Node::cmp(n) && _requires_strict_order == ((ReductionNode&)n).requires_strict_order();\n+  }\n+\n+  virtual uint size_of() const { return sizeof(*this); }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":67,"deletions":37,"binary":false,"changes":104,"status":"modified"}]}