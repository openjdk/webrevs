{"files":[{"patch":"@@ -139,2 +139,2 @@\n-          \/\/ They are not suitable for auto-vectorization because the implementations cannot\n-          \/\/ guarantee strict ordering.\n+          \/\/ They are not suitable for auto-vectorization because they are non-associative\n+          \/\/ and their Neon implementations cannot guarantee strict ordering.\n@@ -2858,1 +2858,1 @@\n-  predicate(Matcher::vector_length(n->in(2)) == 2 && !n->as_Reduction()->requires_strict_order());\n+  predicate(Matcher::vector_length(n->in(2)) == 2 && n->as_Reduction()->is_associative());\n@@ -2870,1 +2870,1 @@\n-  predicate(Matcher::vector_length(n->in(2)) == 4 && !n->as_Reduction()->requires_strict_order());\n+  predicate(Matcher::vector_length(n->in(2)) == 4 && n->as_Reduction()->is_associative());\n@@ -2884,3 +2884,3 @@\n-\/\/ 1. Non strictly-ordered AddReductionVF when vector size > 128-bit. Such\n-\/\/    nodes can only be generated by Vector API.\n-\/\/ 2. Strictly-ordered AddReductionVF, which can only be generated by\n+\/\/ 1. Associative (or non-strictly ordered) AddReductionVF when vector size > 128-bit.\n+\/\/    Such nodes can only be generated by Vector API.\n+\/\/ 2. Non-associative (or strictly ordered) AddReductionVF, which can only be generated by\n@@ -2890,1 +2890,1 @@\n-            n->as_Reduction()->requires_strict_order());\n+            !n->as_Reduction()->is_associative());\n@@ -2904,1 +2904,1 @@\n-  predicate(!n->as_Reduction()->requires_strict_order());\n+  predicate(n->as_Reduction()->is_associative());\n@@ -2917,3 +2917,3 @@\n-\/\/ 1. Non strictly-ordered AddReductionVD when vector size > 128-bit. Such\n-\/\/    nodes can only be generated by Vector API.\n-\/\/ 2. Strictly-ordered AddReductionVD, which can only be generated by\n+\/\/ 1. Associative (or non-strictly ordered) AddReductionVD when vector size > 128-bit.\n+\/\/    Such nodes can only be generated by Vector API.\n+\/\/ 2. Non-associative (or strictly ordered) AddReductionVD, which can only be generated by\n@@ -2923,1 +2923,1 @@\n-            n->as_Reduction()->requires_strict_order());\n+            !n->as_Reduction()->is_associative());\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -129,2 +129,2 @@\n-          \/\/ They are not suitable for auto-vectorization because the implementations cannot\n-          \/\/ guarantee strict ordering.\n+          \/\/ They are not suitable for auto-vectorization because they are non-associative\n+          \/\/ and their Neon implementations cannot guarantee strict ordering.\n@@ -1752,1 +1752,1 @@\n-  predicate(Matcher::vector_length(n->in(2)) == 2 && !n->as_Reduction()->requires_strict_order());\n+  predicate(Matcher::vector_length(n->in(2)) == 2 && n->as_Reduction()->is_associative());\n@@ -1764,1 +1764,1 @@\n-  predicate(Matcher::vector_length(n->in(2)) == 4 && !n->as_Reduction()->requires_strict_order());\n+  predicate(Matcher::vector_length(n->in(2)) == 4 && n->as_Reduction()->is_associative());\n@@ -1781,3 +1781,3 @@\n-\/\/ 1. Non strictly-ordered AddReductionV$1 when vector size > 128-bit. Such\n-\/\/    nodes can only be generated by Vector API.\n-\/\/ 2. Strictly-ordered AddReductionV$1, which can only be generated by\n+\/\/ 1. Associative (or non-strictly ordered) AddReductionV$1 when vector size > 128-bit.\n+\/\/    Such nodes can only be generated by Vector API.\n+\/\/ 2. Non-associative (or strictly ordered) AddReductionV$1, which can only be generated by\n@@ -1787,1 +1787,1 @@\n-            n->as_Reduction()->requires_strict_order());\n+            !n->as_Reduction()->is_associative());\n@@ -1803,1 +1803,1 @@\n-  predicate(!n->as_Reduction()->requires_strict_order());\n+  predicate(n->as_Reduction()->is_associative());\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4307,1 +4307,1 @@\n-  return n->is_Reduction() && !n->as_Reduction()->requires_strict_order();\n+  return n->is_Reduction() && n->as_Reduction()->is_associative();\n@@ -4356,2 +4356,2 @@\n-\/\/ reordering of operations (for example float addition requires strict\n-\/\/ order).\n+\/\/ reordering of operations (for example float addition is non-associative\n+\/\/ and requires calculations to be in strict order).\n@@ -4359,2 +4359,2 @@\n-\/\/ UnorderedReduction represents ReductionNode which does not require\n-\/\/ calculating in strict order.\n+\/\/ Unordered reduction refers to the ReductionNode which does not require\n+\/\/ calculating in strict order or is associative in nature.\n@@ -4374,1 +4374,1 @@\n-    assert(!last_ur->requires_strict_order(), \"must be\");\n+    assert(last_ur->is_associative(), \"must be\");\n@@ -4398,1 +4398,1 @@\n-      assert(!current->requires_strict_order(), \"sanity\");\n+      assert(current->is_associative(), \"sanity\");\n@@ -4439,1 +4439,1 @@\n-        assert(!current->requires_strict_order(), \"must be\");\n+        assert(current->is_associative(), \"must be\");\n@@ -4486,1 +4486,1 @@\n-      assert(!current->requires_strict_order(), \"must be\");\n+      assert(current->is_associative(), \"must be\");\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1746,1 +1746,1 @@\n-  value = ReductionNode::make(opc, nullptr, init, value, elem_bt, \/* requires_strict_order *\/ false);\n+  value = ReductionNode::make(opc, nullptr, init, value, elem_bt, \/* is_associative *\/ true);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1321,1 +1321,1 @@\n-                                   bool requires_strict_order) {\n+                                   bool is_associative) {\n@@ -1331,2 +1331,2 @@\n-  case Op_AddReductionVF: return new AddReductionVFNode(ctrl, n1, n2, requires_strict_order);\n-  case Op_AddReductionVD: return new AddReductionVDNode(ctrl, n1, n2, requires_strict_order);\n+  case Op_AddReductionVF: return new AddReductionVFNode(ctrl, n1, n2, is_associative);\n+  case Op_AddReductionVD: return new AddReductionVDNode(ctrl, n1, n2, is_associative);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-                             bool requires_strict_order = true);\n+                             bool is_associative = false);\n@@ -233,1 +233,1 @@\n-  \/\/ Floating-point addition and multiply are non-associative, so\n+  \/\/ Floating-point addition and multiplication are non-associative, so\n@@ -235,3 +235,3 @@\n-  \/\/ in auto-vectorization. Currently, Vector API can generate\n-  \/\/ AddReductionVF\/D without strict-ordering, which can benefit some\n-  \/\/ platforms.\n+  \/\/ in auto-vectorization. Currently, Vector API allows\n+  \/\/ AddReductionVF\/VD to be associative (no need of strict ordering)\n+  \/\/ which can benefit some platforms.\n@@ -239,3 +239,3 @@\n-  \/\/ Other reductions don't need strict-ordering.\n-  virtual bool requires_strict_order() const {\n-    return false;\n+  \/\/ Other reductions are associative (do not need strict ordering).\n+  virtual bool is_associative() const {\n+    return true;\n@@ -265,5 +265,6 @@\n-  \/\/ True if add reduction operation for floats requires strict ordering.\n-  \/\/ The value is true when add reduction for floats is auto-vectorized as auto-vectorization\n-  \/\/ mandates strict ordering but the value is false when this node is generated through VectorAPI\n-  \/\/ as VectorAPI does not impose any such rules on ordering.\n-  bool _requires_strict_order;\n+  \/\/ True if add reduction of floats is associative.\n+  \/\/ The value is true when add reduction for floats is generated through VectorAPI\n+  \/\/ as VectorAPI allows it to be associative (no strict ordering). The value is false\n+  \/\/ when it is auto-vectorized as auto-vectorization mandates the operation to be\n+  \/\/ non-associative (strictly ordered).\n+  bool _is_associative;\n@@ -271,2 +272,2 @@\n-  AddReductionVFNode(Node *ctrl, Node* in1, Node* in2, bool requires_strict_order) :\n-    ReductionNode(ctrl, in1, in2), _requires_strict_order(requires_strict_order) {}\n+  AddReductionVFNode(Node *ctrl, Node* in1, Node* in2, bool is_associative) :\n+    ReductionNode(ctrl, in1, in2), _is_associative(is_associative) {}\n@@ -276,1 +277,1 @@\n-  virtual bool requires_strict_order() const { return _requires_strict_order; }\n+  virtual bool is_associative() const { return _is_associative; }\n@@ -278,1 +279,1 @@\n-  virtual uint hash() const { return Node::hash() + _requires_strict_order; }\n+  virtual uint hash() const { return Node::hash() + _is_associative; }\n@@ -281,1 +282,1 @@\n-    return Node::cmp(n) && _requires_strict_order == ((ReductionNode&)n).requires_strict_order();\n+    return Node::cmp(n) && _is_associative == ((ReductionNode&)n).is_associative();\n@@ -291,5 +292,6 @@\n-  \/\/ True if add reduction operation for doubles requires strict ordering.\n-  \/\/ The value is true when add reduction for doubles is auto-vectorized as auto-vectorization\n-  \/\/ mandates strict ordering but the value is false when this node is generated through VectorAPI\n-  \/\/ as VectorAPI does not impose any such rules on ordering.\n-  bool _requires_strict_order;\n+  \/\/ True if add reduction of doubles is associative.\n+  \/\/ The value is true when add reduction for doubles is generated through VectorAPI\n+  \/\/ as VectorAPI allows it to be associative (no strict ordering). The value is false\n+  \/\/ when it is auto-vectorized as auto-vectorization mandates the operation to be\n+  \/\/ non-associative (strictly ordered).\n+  bool _is_associative;\n@@ -297,2 +299,2 @@\n-  AddReductionVDNode(Node *ctrl, Node* in1, Node* in2, bool requires_strict_order) :\n-    ReductionNode(ctrl, in1, in2), _requires_strict_order(requires_strict_order) {}\n+  AddReductionVDNode(Node *ctrl, Node* in1, Node* in2, bool is_associative) :\n+    ReductionNode(ctrl, in1, in2), _is_associative(is_associative) {}\n@@ -302,1 +304,1 @@\n-  virtual bool requires_strict_order() const { return _requires_strict_order; }\n+  virtual bool is_associative() const { return _is_associative; }\n@@ -304,1 +306,1 @@\n-  virtual uint hash() const { return Node::hash() + _requires_strict_order; }\n+  virtual uint hash() const { return Node::hash() + _is_associative; }\n@@ -307,1 +309,1 @@\n-    return Node::cmp(n) && _requires_strict_order == ((ReductionNode&)n).requires_strict_order();\n+    return Node::cmp(n) && _is_associative == ((ReductionNode&)n).is_associative();\n@@ -466,2 +468,2 @@\n-  \/\/ Since no real case can benefit from the ordering, return true currently.\n-  virtual bool requires_strict_order() const { return true; }\n+  \/\/ Since no real case can benefit from the operation being associative, return false currently.\n+  virtual bool is_associative() const { return false; }\n@@ -477,2 +479,2 @@\n-  \/\/ Since no real case can benefit from the ordering, return true currently.\n-  virtual bool requires_strict_order() const { return true; }\n+  \/\/ Since no real case can benefit from the operation being associative, return false currently.\n+  virtual bool is_associative() const { return false; }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":34,"deletions":32,"binary":false,"changes":66,"status":"modified"}]}