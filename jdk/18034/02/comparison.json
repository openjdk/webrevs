{"files":[{"patch":"@@ -3,1 +3,1 @@\n-\/\/ Copyright (c) 2020, 2023, Arm Limited. All rights reserved.\n+\/\/ Copyright (c) 2020, 2024, Arm Limited. All rights reserved.\n@@ -138,3 +138,3 @@\n-          \/\/ The vector implementation of Op_AddReductionVD\/F is for the Vector API only.\n-          \/\/ It is not suitable for auto-vectorization because it does not add the elements\n-          \/\/ in the same order as sequential code, and FP addition is non-associative.\n+          \/\/ The implementations of Op_AddReductionVD\/F in Neon are for the Vector API only.\n+          \/\/ They are not suitable for auto-vectorization because they are non-associative\n+          \/\/ and their Neon implementations cannot guarantee strict ordering.\n@@ -2857,3 +2857,0 @@\n-\/\/ Floating-point addition is not associative, so the rules for AddReductionVF\n-\/\/ on NEON can't be used to auto-vectorize floating-point reduce-add.\n-\/\/ Currently, on NEON, AddReductionVF is only generated by Vector API.\n@@ -2861,1 +2858,1 @@\n-  predicate(UseSVE == 0 && Matcher::vector_length(n->in(2)) == 2);\n+  predicate(Matcher::vector_length(n->in(2)) == 2 && n->as_Reduction()->is_associative());\n@@ -2873,1 +2870,1 @@\n-  predicate(UseSVE == 0 && Matcher::vector_length(n->in(2)) == 4);\n+  predicate(Matcher::vector_length(n->in(2)) == 4 && n->as_Reduction()->is_associative());\n@@ -2885,0 +2882,6 @@\n+\/\/ This rule calculates the reduction result in strict order. Two cases will\n+\/\/ reach here:\n+\/\/ 1. Associative (or non-strictly ordered) AddReductionVF when vector size > 128-bit.\n+\/\/    Such nodes can only be generated by Vector API.\n+\/\/ 2. Non-associative (or strictly ordered) AddReductionVF, which can only be generated by\n+\/\/    auto-vectorization on SVE machine.\n@@ -2886,1 +2889,2 @@\n-  predicate(UseSVE > 0);\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))) ||\n+            !n->as_Reduction()->is_associative());\n@@ -2890,0 +2894,1 @@\n+    assert(UseSVE > 0, \"must be sve\");\n@@ -2898,5 +2903,2 @@\n-\/\/ Floating-point addition is not associative, so the rule for AddReductionVD\n-\/\/ on NEON can't be used to auto-vectorize floating-point reduce-add.\n-\/\/ Currently, on NEON, AddReductionVD is only generated by Vector API.\n-instruct reduce_addD_neon(vRegD dst, vRegD dsrc, vReg vsrc) %{\n-  predicate(UseSVE == 0);\n+instruct reduce_add2D_neon(vRegD dst, vRegD dsrc, vReg vsrc) %{\n+  predicate(n->as_Reduction()->is_associative());\n@@ -2905,1 +2907,1 @@\n-  format %{ \"reduce_addD_neon $dst, $dsrc, $vsrc\\t# 2D\" %}\n+  format %{ \"reduce_add2D_neon $dst, $dsrc, $vsrc\\t# 2D\" %}\n@@ -2913,0 +2915,6 @@\n+\/\/ This rule calculates the reduction result in strict order. Two cases will\n+\/\/ reach here:\n+\/\/ 1. Associative (or non-strictly ordered) AddReductionVD when vector size > 128-bit.\n+\/\/    Such nodes can only be generated by Vector API.\n+\/\/ 2. Non-associative (or strictly ordered) AddReductionVD, which can only be generated by\n+\/\/    auto-vectorization on SVE machine.\n@@ -2914,1 +2922,2 @@\n-  predicate(UseSVE > 0);\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))) ||\n+            !n->as_Reduction()->is_associative());\n@@ -2918,0 +2927,1 @@\n+    assert(UseSVE > 0, \"must be sve\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-\/\/ Copyright (c) 2020, 2023, Arm Limited. All rights reserved.\n+\/\/ Copyright (c) 2020, 2024, Arm Limited. All rights reserved.\n@@ -128,3 +128,3 @@\n-          \/\/ The vector implementation of Op_AddReductionVD\/F is for the Vector API only.\n-          \/\/ It is not suitable for auto-vectorization because it does not add the elements\n-          \/\/ in the same order as sequential code, and FP addition is non-associative.\n+          \/\/ The implementations of Op_AddReductionVD\/F in Neon are for the Vector API only.\n+          \/\/ They are not suitable for auto-vectorization because they are non-associative\n+          \/\/ and their Neon implementations cannot guarantee strict ordering.\n@@ -1751,3 +1751,0 @@\n-\/\/ Floating-point addition is not associative, so the rules for AddReductionVF\n-\/\/ on NEON can't be used to auto-vectorize floating-point reduce-add.\n-\/\/ Currently, on NEON, AddReductionVF is only generated by Vector API.\n@@ -1755,1 +1752,1 @@\n-  predicate(UseSVE == 0 && Matcher::vector_length(n->in(2)) == 2);\n+  predicate(Matcher::vector_length(n->in(2)) == 2 && n->as_Reduction()->is_associative());\n@@ -1767,1 +1764,1 @@\n-  predicate(UseSVE == 0 && Matcher::vector_length(n->in(2)) == 4);\n+  predicate(Matcher::vector_length(n->in(2)) == 4 && n->as_Reduction()->is_associative());\n@@ -1782,0 +1779,6 @@\n+\/\/ This rule calculates the reduction result in strict order. Two cases will\n+\/\/ reach here:\n+\/\/ 1. Associative (or non-strictly ordered) AddReductionV$1 when vector size > 128-bit.\n+\/\/    Such nodes can only be generated by Vector API.\n+\/\/ 2. Non-associative (or strictly ordered) AddReductionV$1, which can only be generated by\n+\/\/    auto-vectorization on SVE machine.\n@@ -1783,1 +1786,2 @@\n-  predicate(UseSVE > 0);\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(2))) ||\n+            !n->as_Reduction()->is_associative());\n@@ -1787,0 +1791,1 @@\n+    assert(UseSVE > 0, \"must be sve\");\n@@ -1797,5 +1802,2 @@\n-\/\/ Floating-point addition is not associative, so the rule for AddReductionVD\n-\/\/ on NEON can't be used to auto-vectorize floating-point reduce-add.\n-\/\/ Currently, on NEON, AddReductionVD is only generated by Vector API.\n-instruct reduce_addD_neon(vRegD dst, vRegD dsrc, vReg vsrc) %{\n-  predicate(UseSVE == 0);\n+instruct reduce_add2D_neon(vRegD dst, vRegD dsrc, vReg vsrc) %{\n+  predicate(n->as_Reduction()->is_associative());\n@@ -1804,1 +1806,1 @@\n-  format %{ \"reduce_addD_neon $dst, $dsrc, $vsrc\\t# 2D\" %}\n+  format %{ \"reduce_add2D_neon $dst, $dsrc, $vsrc\\t# 2D\" %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -4306,0 +4306,4 @@\n+static bool is_unordered_reduction(Node* n) {\n+  return n->is_Reduction() && n->as_Reduction()->is_associative();\n+}\n+\n@@ -4350,0 +4354,1 @@\n+\/\/\n@@ -4351,1 +4356,5 @@\n-\/\/ reordering of operations (for example float addition).\n+\/\/ reordering of operations (for example float addition is non-associative\n+\/\/ and requires calculations to be in strict order).\n+\/\/\n+\/\/ Unordered reduction refers to the ReductionNode which does not require\n+\/\/ calculating in strict order or is associative in nature.\n@@ -4360,1 +4369,1 @@\n-    if (!phi->is_Phi() || phi->outcnt() != 1 || !phi->in(2)->is_UnorderedReduction()) {\n+    if (!phi->is_Phi() || phi->outcnt() != 1 || !is_unordered_reduction(phi->in(2))) {\n@@ -4364,1 +4373,2 @@\n-    UnorderedReductionNode* last_ur = phi->in(2)->as_UnorderedReduction();\n+    ReductionNode* last_ur = phi->in(2)->as_Reduction();\n+    assert(last_ur->is_associative(), \"must be\");\n@@ -4385,2 +4395,2 @@\n-    UnorderedReductionNode* current = last_ur;\n-    UnorderedReductionNode* first_ur = nullptr;\n+    ReductionNode* current = last_ur;\n+    ReductionNode* first_ur = nullptr;\n@@ -4388,1 +4398,1 @@\n-      assert(current->is_UnorderedReduction(), \"sanity\");\n+      assert(current->is_associative(), \"sanity\");\n@@ -4425,1 +4435,1 @@\n-      if (scalar_input->is_UnorderedReduction() &&\n+      if (is_unordered_reduction(scalar_input) &&\n@@ -4428,1 +4438,2 @@\n-        current = scalar_input->as_UnorderedReduction();\n+        current = scalar_input->as_Reduction();\n+        assert(current->is_associative(), \"must be\");\n@@ -4474,1 +4485,2 @@\n-      current = vector_accumulator->unique_out()->as_UnorderedReduction();\n+      current = vector_accumulator->unique_out()->as_Reduction();\n+      assert(current->is_associative(), \"must be\");\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -173,1 +173,0 @@\n-class UnorderedReductionNode;\n@@ -731,1 +730,0 @@\n-          DEFINE_CLASS_ID(UnorderedReduction, Reduction, 0)\n@@ -974,1 +972,0 @@\n-  DEFINE_CLASS_QUERY(UnorderedReduction)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1738,14 +1738,6 @@\n-  Node* value = nullptr;\n-  if (mask == nullptr) {\n-    assert(!is_masked_op, \"Masked op needs the mask value never null\");\n-    value = ReductionNode::make(opc, nullptr, init, opd, elem_bt);\n-  } else {\n-    if (use_predicate) {\n-      value = ReductionNode::make(opc, nullptr, init, opd, elem_bt);\n-      value->add_req(mask);\n-      value->add_flag(Node::Flag_is_predicated_vector);\n-    } else {\n-      Node* reduce_identity = gvn().transform(VectorNode::scalar2vector(init, num_elem, Type::get_const_basic_type(elem_bt)));\n-      value = gvn().transform(new VectorBlendNode(reduce_identity, opd, mask));\n-      value = ReductionNode::make(opc, nullptr, init, value, elem_bt);\n-    }\n+  Node* value = opd;\n+\n+  if (mask != nullptr && !use_predicate) {\n+    Node* reduce_identity = gvn().transform(VectorNode::scalar2vector(init,\n+          num_elem, Type::get_const_basic_type(elem_bt)));\n+    value = gvn().transform(new VectorBlendNode(reduce_identity, value, mask));\n@@ -1753,0 +1745,8 @@\n+\n+  value = ReductionNode::make(opc, nullptr, init, value, elem_bt, \/* is_associative *\/ true);\n+\n+  if (mask != nullptr && use_predicate) {\n+    value->add_req(mask);\n+    value->add_flag(Node::Flag_is_predicated_vector);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1320,1 +1320,2 @@\n-ReductionNode* ReductionNode::make(int opc, Node *ctrl, Node* n1, Node* n2, BasicType bt) {\n+ReductionNode* ReductionNode::make(int opc, Node *ctrl, Node* n1, Node* n2, BasicType bt,\n+                                   bool is_associative) {\n@@ -1330,2 +1331,2 @@\n-  case Op_AddReductionVF: return new AddReductionVFNode(ctrl, n1, n2);\n-  case Op_AddReductionVD: return new AddReductionVDNode(ctrl, n1, n2);\n+  case Op_AddReductionVF: return new AddReductionVFNode(ctrl, n1, n2, is_associative);\n+  case Op_AddReductionVD: return new AddReductionVDNode(ctrl, n1, n2, is_associative);\n@@ -1336,5 +1337,5 @@\n-  case Op_MinReductionV:  return new MinReductionVNode(ctrl, n1, n2);\n-  case Op_MaxReductionV:  return new MaxReductionVNode(ctrl, n1, n2);\n-  case Op_AndReductionV:  return new AndReductionVNode(ctrl, n1, n2);\n-  case Op_OrReductionV:   return new OrReductionVNode(ctrl, n1, n2);\n-  case Op_XorReductionV:  return new XorReductionVNode(ctrl, n1, n2);\n+  case Op_MinReductionV:  return new MinReductionVNode (ctrl, n1, n2);\n+  case Op_MaxReductionV:  return new MaxReductionVNode (ctrl, n1, n2);\n+  case Op_AndReductionV:  return new AndReductionVNode (ctrl, n1, n2);\n+  case Op_OrReductionV:   return new OrReductionVNode  (ctrl, n1, n2);\n+  case Op_XorReductionV:  return new XorReductionVNode (ctrl, n1, n2);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -208,1 +208,3 @@\n-  static ReductionNode* make(int opc, Node* ctrl, Node* in1, Node* in2, BasicType bt);\n+  static ReductionNode* make(int opc, Node* ctrl, Node* in1, Node* in2, BasicType bt,\n+                             \/\/ Currently, this only effects floating-point add reductions.\n+                             bool is_associative = false);\n@@ -230,1 +232,0 @@\n-};\n@@ -232,6 +233,9 @@\n-\/\/---------------------------UnorderedReductionNode-------------------------------------\n-\/\/ Order of reduction does not matter. Example int add. Not true for float add.\n-class UnorderedReductionNode : public ReductionNode {\n-public:\n-  UnorderedReductionNode(Node * ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {\n-    init_class_id(Class_UnorderedReduction);\n+  \/\/ Floating-point addition and multiplication are non-associative, so\n+  \/\/ AddReductionVF\/D and MulReductionVF\/D require strict-ordering\n+  \/\/ in auto-vectorization. Currently, Vector API allows\n+  \/\/ AddReductionVF\/VD to be associative (no need of strict ordering)\n+  \/\/ which can benefit some platforms.\n+  \/\/\n+  \/\/ Other reductions are associative (do not need strict ordering).\n+  virtual bool is_associative() const {\n+    return true;\n@@ -243,1 +247,1 @@\n-class AddReductionVINode : public UnorderedReductionNode {\n+class AddReductionVINode : public ReductionNode {\n@@ -245,1 +249,1 @@\n-  AddReductionVINode(Node * ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n+  AddReductionVINode(Node * ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n@@ -251,1 +255,1 @@\n-class AddReductionVLNode : public UnorderedReductionNode {\n+class AddReductionVLNode : public ReductionNode {\n@@ -253,1 +257,1 @@\n-  AddReductionVLNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n+  AddReductionVLNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n@@ -260,0 +264,7 @@\n+private:\n+  \/\/ True if add reduction of floats is associative.\n+  \/\/ The value is true when add reduction for floats is generated through VectorAPI\n+  \/\/ as VectorAPI allows it to be associative (no strict ordering). The value is false\n+  \/\/ when it is auto-vectorized as auto-vectorization mandates the operation to be\n+  \/\/ non-associative (strictly ordered).\n+  bool _is_associative;\n@@ -261,1 +272,3 @@\n-  AddReductionVFNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  AddReductionVFNode(Node *ctrl, Node* in1, Node* in2, bool is_associative) :\n+    ReductionNode(ctrl, in1, in2), _is_associative(is_associative) {}\n+\n@@ -263,0 +276,10 @@\n+\n+  virtual bool is_associative() const { return _is_associative; }\n+\n+  virtual uint hash() const { return Node::hash() + _is_associative; }\n+\n+  virtual bool cmp(const Node& n) const {\n+    return Node::cmp(n) && _is_associative == ((ReductionNode&)n).is_associative();\n+  }\n+\n+  virtual uint size_of() const { return sizeof(*this); }\n@@ -268,0 +291,7 @@\n+private:\n+  \/\/ True if add reduction of doubles is associative.\n+  \/\/ The value is true when add reduction for doubles is generated through VectorAPI\n+  \/\/ as VectorAPI allows it to be associative (no strict ordering). The value is false\n+  \/\/ when it is auto-vectorized as auto-vectorization mandates the operation to be\n+  \/\/ non-associative (strictly ordered).\n+  bool _is_associative;\n@@ -269,1 +299,3 @@\n-  AddReductionVDNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  AddReductionVDNode(Node *ctrl, Node* in1, Node* in2, bool is_associative) :\n+    ReductionNode(ctrl, in1, in2), _is_associative(is_associative) {}\n+\n@@ -271,0 +303,10 @@\n+\n+  virtual bool is_associative() const { return _is_associative; }\n+\n+  virtual uint hash() const { return Node::hash() + _is_associative; }\n+\n+  virtual bool cmp(const Node& n) const {\n+    return Node::cmp(n) && _is_associative == ((ReductionNode&)n).is_associative();\n+  }\n+\n+  virtual uint size_of() const { return sizeof(*this); }\n@@ -405,1 +447,1 @@\n-class MulReductionVINode : public UnorderedReductionNode {\n+class MulReductionVINode : public ReductionNode {\n@@ -407,1 +449,1 @@\n-  MulReductionVINode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n+  MulReductionVINode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n@@ -413,1 +455,1 @@\n-class MulReductionVLNode : public UnorderedReductionNode {\n+class MulReductionVLNode : public ReductionNode {\n@@ -415,1 +457,1 @@\n-  MulReductionVLNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n+  MulReductionVLNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n@@ -425,0 +467,3 @@\n+\n+  \/\/ Since no real case can benefit from the operation being associative, return false currently.\n+  virtual bool is_associative() const { return false; }\n@@ -433,0 +478,3 @@\n+\n+  \/\/ Since no real case can benefit from the operation being associative, return false currently.\n+  virtual bool is_associative() const { return false; }\n@@ -758,1 +806,1 @@\n-class AndReductionVNode : public UnorderedReductionNode {\n+class AndReductionVNode : public ReductionNode {\n@@ -760,1 +808,1 @@\n-  AndReductionVNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n+  AndReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n@@ -775,1 +823,1 @@\n-class OrReductionVNode : public UnorderedReductionNode {\n+class OrReductionVNode : public ReductionNode {\n@@ -777,1 +825,1 @@\n-  OrReductionVNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n+  OrReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n@@ -792,1 +840,1 @@\n-class XorReductionVNode : public UnorderedReductionNode {\n+class XorReductionVNode : public ReductionNode {\n@@ -794,1 +842,1 @@\n-  XorReductionVNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n+  XorReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n@@ -800,1 +848,1 @@\n-class MinReductionVNode : public UnorderedReductionNode {\n+class MinReductionVNode : public ReductionNode {\n@@ -802,1 +850,1 @@\n-  MinReductionVNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n+  MinReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n@@ -808,1 +856,1 @@\n-class MaxReductionVNode : public UnorderedReductionNode {\n+class MaxReductionVNode : public ReductionNode {\n@@ -810,1 +858,1 @@\n-  MaxReductionVNode(Node *ctrl, Node* in1, Node* in2) : UnorderedReductionNode(ctrl, in1, in2) {}\n+  MaxReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":76,"deletions":28,"binary":false,"changes":104,"status":"modified"}]}