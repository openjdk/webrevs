{"files":[{"patch":"@@ -83,2 +83,0 @@\n-compiler\/c2\/aarch64\/TestStaticCallStub.java 8359963 linux-aarch64,macosx-aarch64\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,8 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n@@ -27,3 +35,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.*;\n@@ -46,2 +51,189 @@\n-    static String[] nearStaticCallOpcodeSeq = {\"isb\", \"mov\", \"movk\", \"movk\", \"b\"};\n-    static String[] farStaticCallOpcodeSeq = {\"isb\", \"mov\", \"movk\", \"movk\", \"mov\", \"movk\", \"movk\", \"br\"};\n+    private static class InstructionList extends ArrayList<Instruction> {\n+        public InstructionList(List<Instruction> instructions) {\n+            super(instructions);\n+        }\n+\n+        public boolean matches(List<String> codes) {\n+            if (size() != codes.size()) {\n+                return false;\n+            }\n+\n+            return IntStream.range(0, size()).allMatch(i -> get(i).matches(codes.get(i)));\n+        }\n+    }\n+\n+    private static abstract class Instruction {\n+        private static final List<Instruction> registry = new ArrayList<>();\n+\n+        protected static void register(Instruction inst) {\n+            registry.add(inst);\n+        }\n+\n+        private static String reverseEndian(String encoding) {\n+            if (encoding.length() != 8) {\n+                throw new IllegalArgumentException(\"Input must be 8 hex characters long.\");\n+            }\n+\n+            return new StringBuilder()\n+                    .append(encoding, 6, 8)\n+                    .append(encoding, 4, 6)\n+                    .append(encoding, 2, 4)\n+                    .append(encoding, 0, 2)\n+                    .toString();\n+        }\n+\n+        public final boolean matches(int encoding) {\n+            return (encoding & mask()) == value();\n+        }\n+\n+        public final boolean matches(String encoding) {\n+            String cleaned = encoding.replaceAll(\"\\\\s+\", \"\");\n+\n+            if (cleaned.matches(\"^[0-9a-fA-F]{8}$\")) {\n+                return matches((int) Long.parseLong(reverseEndian(cleaned), 16));\n+            }\n+\n+            return cleaned.equals(opcode());\n+        }\n+\n+        protected abstract int mask();\n+\n+        protected abstract int value();\n+\n+        protected abstract String opcode();\n+    }\n+\n+    private static class B extends Instruction {\n+        public static final B INSTANCE = new B();\n+\n+        static {\n+            Instruction.register(INSTANCE);\n+        }\n+\n+        public static final B get() {\n+            return INSTANCE;\n+        }\n+\n+        protected final int mask() {\n+            return 0b1111_1100_0000_0000_0000_0000_0000_0000;\n+        }\n+\n+        protected final int value() {\n+            return 0b0001_0100_0000_0000_0000_0000_0000_0000;\n+        }\n+\n+        protected final String opcode() {\n+            return \"b\";\n+        }\n+    }\n+\n+    private static class BR extends Instruction {\n+        public static final BR INSTANCE = new BR();\n+\n+        public static final BR get() {\n+            return INSTANCE;\n+        }\n+\n+        protected final int mask() {\n+            return 0b1111_1111_1111_1111_1111_1100_0001_1111;\n+        }\n+\n+        protected final int value() {\n+            return 0b1101_0110_0001_1111_0000_0000_0000_0000;\n+        }\n+\n+        protected final String opcode() {\n+            return \"br\";\n+        }\n+    };\n+\n+    private static class ISB extends Instruction {\n+        public static final ISB INSTANCE = new ISB();\n+\n+        static {\n+            Instruction.register(INSTANCE);\n+        }\n+\n+        public static final ISB get() {\n+            return INSTANCE;\n+        }\n+\n+        protected final int mask() {\n+            return 0b1111_1111_1111_1111_1111_0000_1111_1111;\n+        }\n+\n+        protected final int value() {\n+            return 0b1101_0101_0000_0011_0011_0000_1101_1111;\n+        }\n+\n+        protected final String opcode() {\n+            return \"isb\";\n+        }\n+    }\n+\n+    private static class MOVK extends Instruction {\n+        public static final MOVK INSTANCE = new MOVK();\n+\n+        static {\n+            Instruction.register(INSTANCE);\n+        }\n+\n+        public static final MOVK get() {\n+            return INSTANCE;\n+        }\n+\n+        protected final int mask() {\n+            return 0b1111_1111_1000_0000_0000_0000_0000_0000;\n+        }\n+\n+        protected final int value() {\n+            return 0b1111_0010_1000_0000_0000_0000_0000_0000;\n+        }\n+\n+        protected final String opcode() {\n+            return \"movk\";\n+        }\n+    }\n+\n+    private static class MOVZ extends Instruction {\n+        public static final MOVZ INSTANCE = new MOVZ();\n+\n+        static {\n+            Instruction.register(INSTANCE);\n+        }\n+\n+        public static final MOVZ get() {\n+            return INSTANCE;\n+        }\n+\n+        protected final int mask() {\n+            return 0b1111_1111_1000_0000_0000_0000_0000_0000;\n+        }\n+\n+        protected final int value() {\n+            return 0b1101_0010_1000_0000_0000_0000_0000_0000;\n+        }\n+\n+        protected final String opcode() {\n+            return \"mov\"; \/\/ this is not a typo\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            \/\/ Main VM: fork VM with options\n+            runVM(true);\n+            runVM(false);\n+            return;\n+        }\n+        if (args.length > 0) {\n+            \/\/ We are in a forked VM. Just exit\n+            System.out.println(\"Ok\");\n+        }\n+    }\n+\n+    static List<String> extractOpcodeOrBytecodes(String line) {\n+        int colonIndex = line.indexOf(':');\n+        if (colonIndex != -1) {\n+            line = line.substring(colonIndex + 1).trim();\n+        }\n@@ -49,2 +241,0 @@\n-    static String extractOpcode(String line) {\n-        line = line.trim();\n@@ -56,0 +246,4 @@\n+        if (line.isBlank()) {\n+            return Collections.emptyList();\n+        }\n+\n@@ -57,2 +251,11 @@\n-        if (words.length > 1) {\n-            return words[1];\n+        if (words.length > 0) {\n+            String opcode = words[0];\n+            \/\/ Does this look like a bytecode instead?\n+            if (opcode.matches(\"^[0-9a-fA-F]{4}$\")) {\n+                List<String> retval = Arrays.stream(line.split(\"\\\\|\"))\n+                        .map(String::trim)\n+                        .collect(Collectors.toList());\n+                return retval;\n+            }\n+\n+            return new ArrayList<>(Arrays.asList(opcode));\n@@ -61,1 +264,1 @@\n-        return \"\";\n+        return Collections.emptyList();\n@@ -64,2 +267,2 @@\n-    static List<String> extractOpcodesN(ListIterator<String> itr, int n) {\n-        List<String> extractedOpcodes = new ArrayList<>();\n+    static List<String> extractCodesN(ListIterator<String> itr, int n) {\n+        List<String> extracted = new ArrayList<>();\n@@ -67,5 +270,3 @@\n-        while (itr.hasNext() && extractedOpcodes.size() < n) {\n-            String opcode = extractOpcode(itr.next());\n-            if (!opcode.isEmpty()) {\n-                extractedOpcodes.add(opcode);\n-            }\n+        while (itr.hasNext() && extracted.size() < n) {\n+            int left = n - extracted.size();\n+            extractOpcodeOrBytecodes(itr.next()).stream().limit(left).forEach(extracted::add);\n@@ -74,1 +275,1 @@\n-        return extractedOpcodes;\n+        return extracted;\n@@ -78,1 +279,3 @@\n-        List<String> extractedOpcodes = extractOpcodesN(itr, nearStaticCallOpcodeSeq.length);\n+        InstructionList nearStaticCallInstList = new InstructionList(\n+                Arrays.asList(ISB.get(), MOVZ.get(), MOVK.get(), MOVK.get(), B.get()));\n+        List<String> codes = extractCodesN(itr, nearStaticCallInstList.size());\n@@ -80,2 +283,3 @@\n-        if (!Arrays.asList(nearStaticCallOpcodeSeq).equals(extractedOpcodes)) {\n-            throw new RuntimeException(\"for code cache < 250MB the static call stub is expected to be implemented using near branch\");\n+        if (!nearStaticCallInstList.matches(codes)) {\n+            throw new RuntimeException(\n+                    \"for code cache < 250MB the static call stub is expected to be implemented using near branch\");\n@@ -88,1 +292,3 @@\n-        List<String> extractedOpcodes = extractOpcodesN(itr, farStaticCallOpcodeSeq.length);\n+        InstructionList farStaticCallInstList = new InstructionList(Arrays.asList(ISB.get(), MOVZ.get(), MOVK.get(),\n+                MOVK.get(), MOVZ.get(), MOVK.get(), MOVK.get(), BR.get()));\n+        List<String> codes = extractCodesN(itr, farStaticCallInstList.size());\n@@ -90,2 +296,3 @@\n-        if (!Arrays.asList(farStaticCallOpcodeSeq).equals(extractedOpcodes)) {\n-            throw new RuntimeException(\"for code cache > 250MB the static call stub is expected to be implemented using far branch\");\n+        if (!farStaticCallInstList.matches(codes)) {\n+            throw new RuntimeException(\n+                    \"for code cache > 250MB the static call stub is expected to be implemented using far branch\");\n@@ -100,10 +307,9 @@\n-            \"-XX:-Inline\",\n-            \"-Xcomp\",\n-            \"-Xbatch\",\n-            \"-XX:+TieredCompilation\",\n-            \"-XX:+SegmentedCodeCache\",\n-            \"-XX:ReservedCodeCacheSize=\" + (bigCodeCache ? \"256M\" : \"200M\"),\n-            \"-XX:+UnlockDiagnosticVMOptions\",\n-            \"-XX:CompileCommand=option,\" + className + \"::main,bool,PrintAssembly,true\",\n-            className};\n-\n+                \"-XX:-Inline\",\n+                \"-Xcomp\",\n+                \"-Xbatch\",\n+                \"-XX:+TieredCompilation\",\n+                \"-XX:+SegmentedCodeCache\",\n+                \"-XX:ReservedCodeCacheSize=\" + (bigCodeCache ? \"256M\" : \"200M\"),\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:CompileCommand=option,\" + className + \"::main,bool,PrintAssembly,true\",\n+                className };\n@@ -113,0 +319,1 @@\n+        System.out.println(output.getOutput());\n@@ -130,13 +337,0 @@\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length == 0) {\n-            \/\/ Main VM: fork VM with options\n-            runVM(true);\n-            runVM(false);\n-            return;\n-        }\n-        if (args.length > 0) {\n-            \/\/ We are in a forked VM. Just exit\n-            System.out.println(\"Ok\");\n-        }\n-    }\n@@ -144,1 +338,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestStaticCallStub.java","additions":241,"deletions":48,"binary":false,"changes":289,"status":"modified"}]}