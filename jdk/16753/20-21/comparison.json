{"files":[{"patch":"@@ -4646,1 +4646,1 @@\n-    vpxor(vec1, vec2);\n+    pxor(vec1, vec2);\n@@ -4648,1 +4648,1 @@\n-    vptest(vec1, vec1);\n+    ptest(vec1, vec1);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -141,2 +141,1 @@\n-                                           Register haystack, Register hsLen, Register needleLen,\n-                                           Register eq_mask, Register rTmp, Register rTmp2,\n+                                           Register haystack, Register needleLen, Register eq_mask,\n@@ -720,1 +719,1 @@\n-    __ jne_b(L_checkRangeAndReturn);\n+    __ jne(L_checkRangeAndReturn);\n@@ -1127,2 +1126,1 @@\n-                                           Register haystack, Register hsLen, Register needleLen,\n-                                           Register eq_mask, Register rTmp, Register rTmp2,\n+                                           Register haystack, Register needleLen, Register eq_mask,\n@@ -1133,1 +1131,1 @@\n-  assert_different_registers(eq_mask, haystack, needleLen, rTmp, hsLen, nMinusK, rTmp2);\n+  assert_different_registers(eq_mask, haystack, needleLen, nMinusK);\n@@ -1138,1 +1136,0 @@\n-  const Register shiftVal = rTmp2;\n@@ -1144,4 +1141,1 @@\n-#undef lastCompare\n-#define lastCompare rTmp\n-\n-  \/\/ Set up lambdas for performing correct-sized comparisons\n+  \/\/ Set up lambdas for performing correctly-sized comparisons\n@@ -1183,48 +1177,0 @@\n-    \/\/ Need special handling for the case where there's not enough room\n-    \/\/ to read 32 bytes of haystack at the kth position\n-    __ cmpq(nMinusK, 32);\n-    __ jae(L_OKtoCompareFull);\n-\n-    \/\/ If n-k less than 32, comparing the last byte of the needle will result\n-    \/\/ in reading past the end of the haystack.  Account for this here.\n-    __ leaq(lastCompare, Address(haystack, hsLen, Address::times_1, -32));\n-\n-       vpcmpeq(cmp_k, XMM_BYTE_K, Address(lastCompare, 0), Assembler::AVX_256bit);\n-\n-#undef lastMask\n-#undef lastCompare\n-#define lastMask rTmp\n-    __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n-\n-    \/\/ Mask off inappropriate comparisons\n-    __ movl(shiftVal, isU ? 30 : 31);\n-    __ subl(shiftVal, nMinusK);\n-    __ shrxl(lastMask, lastMask, shiftVal);\n-    __ andl(eq_mask, lastMask);\n-\n-  \/\/ If the needle is only 2 elements (at compile time) no need to compare more\n-    if (size > sizeIncr * 2) {\n-#ifdef DO_EARLY_BAILOUT\n-      __ testl(eq_mask, eq_mask);\n-      __ je(noMatch);\n-#endif\n-      __ cmpq(hsLen, isU ? 34 : 33);\n-      __ jl(L_specialCase_gt2);\n-      vpcmpeq(cmp_k, XMM_BYTE_1, Address(haystack, 1 * sizeIncr), Assembler::AVX_256bit);\n-      __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n-      __ andl(eq_mask, lastMask);\n-    }\n-\n-    __ jmpb(L_done);\n-\n-    __ bind(L_specialCase_gt2);\n-    vpcmpeq(cmp_k, XMM_BYTE_1, Address(haystack, 0), Assembler::AVX_256bit);\n-    __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n-    __ shrl(lastMask, sizeIncr);\n-    __ andl(eq_mask, lastMask);\n-\n-    __ jmp(L_done);\n-\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    __ bind(L_OKtoCompareFull);\n-\n@@ -1254,2 +1200,0 @@\n-#undef lastCompare\n-#undef lastMask\n@@ -1298,1 +1242,1 @@\n-  \/\/ Set up lambdas for performing correct-sized comparisons\n+  \/\/ Set up lambdas for performing correctly-sized comparisons\n@@ -1378,0 +1322,7 @@\n+\/\/ needle - Address of the needle\n+\/\/ haystack - Address of the haystack\n+\/\/ hsLength - The length of the haystack\n+\/\/ rTmp1 - Temporary\n+\/\/ rTmp2 - Temporary\n+\/\/ rTmp3 - Temporary\n+\/\/ rTmp4 - Temporary\n@@ -1414,1 +1365,1 @@\n-  \/\/ Set up lambdas for performing correct-sized comparisons\n+  \/\/ Set up lambdas for performing correctly-sized comparisons\n@@ -1427,0 +1378,1 @@\n+  \/\/ Assume failure\n@@ -1448,1 +1400,1 @@\n-    \/\/ Compare first byte of needle to haystack\n+    \/\/ Compare first byte of needle to haystack and mask result\n@@ -1481,0 +1433,1 @@\n+  \/\/ An equal comparison indicates completion with no match\n@@ -1485,0 +1438,2 @@\n+  \/\/ If next compare will go beyond end of haystack adjust start of read\n+  \/\/ back to last valid read position\n@@ -1493,2 +1448,2 @@\n-  compare_big_haystack_to_needle(sizeKnown, size, loop_top, hsPtrRet, hsLength, needleLen, eq_mask,\n-                                 temp2, temp3, XMM_TMP1, XMM_TMP2, XMM_TMP3, ae, _masm);\n+  compare_big_haystack_to_needle(sizeKnown, size, loop_top, hsPtrRet, needleLen, eq_mask, XMM_TMP1,\n+                                 XMM_TMP2, XMM_TMP3, ae, _masm);\n@@ -1506,0 +1461,16 @@\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Helper for loading needle elements to a register for compares\n+\/\/ Loads the proper number of bytes from the needle into needleVal\n+\/\/ based on the total size of the needle.\n+\/\/\n+\/\/ Parameters:\n+\/\/ size - The size of the needle in bytes\n+\/\/ needle - the address of the first byte of the needle\n+\/\/ needleVal - The bytes of the needle are loaded into this regiater\n+\/\/ ae - the argument encodings\n+\/\/ _masm - Current MacroAssembler instance pointer\n+\/\/\n+\/\/ Returns correctly-sized needle bytes in needleVal\n+\n@@ -1520,0 +1491,2 @@\n+  \/\/ The algorithm pre-validates that the first 2 and last elements of the needle\n+  \/\/ compare equal, so no need to re-compare those elements\n@@ -1524,1 +1497,1 @@\n-  assert((bytesLeftToCompare <= 8), \"Too many bytes left to compare\");\n+  assert((bytesLeftToCompare <= 7), \"Too many bytes left to compare\");\n@@ -1533,0 +1506,2 @@\n+  \/\/ Coordinate the offsets here with the switch in byte_compare_helper\n+  \/\/ For UTF-16 needles, needle size will always be even (4, 6, 8, and 10)\n@@ -1536,0 +1511,1 @@\n+    \/\/ Needle size of 4 and 5 bytes - safe to re-compare 2 additional bytes\n@@ -1541,0 +1517,1 @@\n+    \/\/ Needle size 6 and 7\n@@ -1546,0 +1523,1 @@\n+    \/\/ Needle size 8 and 9 bytes - safe to re-compare 2 additional bytes\n@@ -1550,1 +1528,1 @@\n-  case 8:\n+    \/\/ Needle size 10\n@@ -1559,0 +1537,21 @@\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Helper for comparing small needles to the haystack after a potential match found.\n+\/\/\n+\/\/ Parameters:\n+\/\/ size - The size of the needle in bytes\n+\/\/ L_noMatch - Label to jump to if needle does not match haystack at this location\n+\/\/ L_matchFound - Label to jump to if needle matches haystack at this location\n+\/\/ needle - the address of the first byte of the needle\n+\/\/ needleVal - The bytes of the needle to compare (see preload_needle_helper)\n+\/\/ haystack - The address of the first byte of the haystack\n+\/\/ mask - The comparison mask from comparing the first 2 and last elements of the needle\n+\/\/ foundIndex - The index within the haystack of the match\n+\/\/ tmp - A temporary register\n+\/\/ ae - the argument encodings\n+\/\/ _masm - Current MacroAssembler instance pointer\n+\/\/\n+\/\/ Branches to either L_noMatch or L_matchFound depending on the result of the comparison\n+\/\/ foundIndex will contain the index within the haystack of the match for L_matchFound\n+\n@@ -1582,0 +1581,2 @@\n+  \/\/ Getting her we already have the first two and last elements of the needle\n+  \/\/ comparing equal, so no need to compare them again\n@@ -1586,1 +1587,1 @@\n-  assert(bytesLeftToCompare <= 8, \"Too many bytes left to compare\");\n+  assert(bytesLeftToCompare <= 7, \"Too many bytes left to compare\");\n@@ -1588,0 +1589,1 @@\n+  \/\/ The needle is <= 3 elements long, so the ultimate result comes from the mask\n@@ -1598,1 +1600,1 @@\n-  \/\/ bytes of the haystack after first\/last have compared equal.\n+  \/\/ bytes of the haystack after first\/second\/last have compared equal.\n@@ -1605,0 +1607,1 @@\n+  \/\/ Coordinate this with preload_needle_helper\n@@ -1608,0 +1611,1 @@\n+    \/\/ Comparison for needle size of 4 and 5 bytes\n@@ -1615,0 +1619,1 @@\n+    \/\/ Comparison for needle size of 6 and 7 bytes\n@@ -1621,0 +1626,1 @@\n+    \/\/ Comparison for needle size of 8 and 9 bytes\n@@ -1627,1 +1633,1 @@\n-  case 8:\n+    \/\/ Comparison for needle size of 10 bytes\n@@ -1631,0 +1637,2 @@\n+  default:\n+    break;\n@@ -1651,1 +1659,10 @@\n-\/\/\n+\/\/ ae - Argument encoding\n+\/\/ haystack - The address of the haystack\n+\/\/ haystack_len - the length of the haystack in elements\n+\/\/ needle - The address of the needle\n+\/\/ needle_len - the length of the needle in elements\n+\/\/ XMM0 - Temporary xmm register\n+\/\/ XMM1 - Temporary xmm register\n+\/\/ mask - Used to hold comparison mask - must be saved\/restored\n+\/\/ tmp - Temporary register - must be saved\/restored\n+\/\/ _masm - Current MacroAssembler instance pointer\n@@ -1663,0 +1680,13 @@\n+  \/\/ Set up lambdas for performing correctly-sized comparisons\n+  std::function<void(XMMRegister dst, XMMRegister src, Address adr, int vector_len)> vpcmpeq;\n+\n+  if (isU) {\n+    vpcmpeq = [_masm](XMMRegister dst, XMMRegister src, Address adr, int vector_len) {\n+      __ vpcmpeqw(dst, src, adr, vector_len);\n+    };\n+  } else {\n+    vpcmpeq = [_masm](XMMRegister dst, XMMRegister src, Address adr, int vector_len) {\n+      __ vpcmpeqb(dst, src, adr, vector_len);\n+    };\n+  }\n+\n@@ -1693,1 +1723,2 @@\n-    __ subq(tmp, haystack_len);\n+    __ subptr(tmp, haystack_len);\n+\n@@ -1696,1 +1727,1 @@\n-      __ subq(tmp, haystack_len);\n+      __ subptr(tmp, haystack_len);\n@@ -1698,0 +1729,1 @@\n+    \/\/ Point the haystack to the stack\n@@ -1701,3 +1733,2 @@\n-  \/\/ Creates a mask of (n - k + 1) ones.  This prevents\n-  \/\/ recognizing any false-positives past the end of\n-  \/\/ the valid haystack.\n+  \/\/ Creates a mask of (n - k + 1) ones.  This prevents recognizing any false-positives\n+  \/\/ past the end of the valid haystack.\n@@ -1712,0 +1743,1 @@\n+  \/\/ Loop for each needle size from 1 to 6 bytes long.  For UU, only 3 elements.\n@@ -1720,2 +1752,2 @@\n-      __ movzbl(rax, Address(needle, needle_position));\n-      __ movdl(XMM0, rax);\n+      __ movzbl(tmp, Address(needle, needle_position));\n+      __ movdl(XMM0, tmp);\n@@ -1730,5 +1762,1 @@\n-    if (isU) {\n-      __ vpcmpeqw(XMM1, XMM0, Address(haystack, haystack_position), Assembler::AVX_256bit);\n-    } else {\n-      __ vpcmpeqb(XMM1, XMM0, Address(haystack, haystack_position), Assembler::AVX_256bit);\n-    }\n+    vpcmpeq(XMM1, XMM0, Address(haystack, haystack_position), Assembler::AVX_256bit);\n@@ -1767,5 +1795,13 @@\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/\n-  \/\/ Set up jump table entries for both small and large haystack switches.\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\n+\/\/ Set up jump table entries for both small and large haystack switches.\n+\/\/\n+\/\/ ae - Argument encoding\n+\/\/ L_error - Label to branch to if no match found\n+\/\/ L_checkRange - label to jump to when match found.  Checks validity of returned index\n+\/\/ L_fixup - Jump to here for big cases.  Return value is pointer to matching haystack byte\n+\/\/ *big_jump_table - Address of pointer to the first element of big jump table\n+\/\/ *small_jump_table - Address of pointer to the first element of small jump table\n+\/\/ _masm - Current MacroAssembler instance pointer\n@@ -1773,2 +1809,3 @@\n-static void setup_jump_tables(StrIntrinsicNode::ArgEncoding ae, Label &L_error, Label &L_checkRange, Label &L_fixup,\n-                              address *big_jump_table, address *small_jump_table, MacroAssembler *_masm) {\n+static void setup_jump_tables(StrIntrinsicNode::ArgEncoding ae, Label &L_error, Label &L_checkRange,\n+                              Label &L_fixup, address *big_jump_table, address *small_jump_table,\n+                              MacroAssembler *_masm) {\n@@ -1778,1 +1815,1 @@\n-  const XMMRegister byte_1    = XMM_BYTE_1;\n+  const XMMRegister byte_1 = XMM_BYTE_1;\n@@ -1780,1 +1817,1 @@\n-  address big_hs_jmp_table[NUMBER_OF_CASES];  \/\/ Jump table for large haystacks\n+  address big_hs_jmp_table[NUMBER_OF_CASES];    \/\/ Jump table for large haystacks\n@@ -1835,1 +1872,1 @@\n-      broadcast_additional_needles(true, i + 1, needle, noreg, rTmp, ae, _masm);\n+        broadcast_additional_needles(true, i + 1, needle, noreg, rTmp, ae, _masm);\n@@ -1837,2 +1874,2 @@\n-      compare_haystack_to_needle(true, i + 1, L_error, haystack, isU, eq_mask, noreg, rTmp,\n-                                 XMM_TMP1, XMM_TMP2, _masm);\n+        compare_haystack_to_needle(true, i + 1, L_error, haystack, isU, eq_mask, noreg, rTmp,\n+                                   XMM_TMP1, XMM_TMP2, _masm);\n@@ -1840,2 +1877,2 @@\n-      byte_compare_helper(i + 1, L_error, L_checkRange, needle, needle_val, haystack, eq_mask,\n-                          set_bit, rTmp, ae, _masm);\n+        byte_compare_helper(i + 1, L_error, L_checkRange, needle, needle_val, haystack, eq_mask,\n+                            set_bit, rTmp, ae, _masm);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_string.cpp","additions":135,"deletions":98,"binary":false,"changes":233,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -37,1 +39,1 @@\n-  static Random generator = new Random();\n+  static Random generator = Utils.getRandomInstance();\n@@ -51,5 +53,0 @@\n-  \/\/ haystack_16[0] = (char) (23 + 256);\n-  \/\/ for (int i = 1; i < 128; i++) {\n-  \/\/   haystack_16[i] = (char) (i);\n-  \/\/ }\n-\n@@ -61,1 +58,0 @@\n-  \/\/ Charset hs_charset = StandardCharsets.ISO_8859_1;\n@@ -64,1 +60,1 @@\n-  \/\/ Charset needleCharset = StandardCharsets.UTF_16;\n+\n@@ -81,3 +77,0 @@\n-  shs = \"$&),,18+-!'8)+\";\n-  endNeedle = \"8)-\";\n-  l_offset = 9;\n@@ -151,1 +144,0 @@\n-    \/\/ System.out.println(\"(1) hsndx=\" + hsndx);\n@@ -156,1 +148,0 @@\n-        \/\/ System.out.println(\"(2) hsndx_tmp=\" + hsndx_tmp + \" nndx=\" + nndx);\n","filename":"test\/jdk\/java\/lang\/StringBuffer\/IndexOf.java","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-    return dataStringHuge16.indexOf(\"B\".repeat(30) + \"X\" + \"A\".repeat(30), 74);\n+    return dataStringHuge16.indexOf(\"B\".repeat(30) + \"\\\\u01ef\" + \"A\".repeat(30), 74);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringIndexOfHuge.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}