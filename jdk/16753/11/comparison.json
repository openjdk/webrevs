{"files":[{"patch":"@@ -1760,0 +1760,16 @@\n+void Assembler::cmpb(Address dst, Register reg) {\n+  assert(reg->has_byte_register(), \"must have byte register\");\n+  InstructionMark im(this);\n+  prefix(dst, reg, true);\n+  emit_int8((unsigned char)0x38);\n+  emit_operand(reg, dst, 0);\n+}\n+\n+void Assembler::cmpb(Register reg, Address dst) {\n+  assert(reg->has_byte_register(), \"must have byte register\");\n+  InstructionMark im(this);\n+  prefix(dst, reg, true);\n+  emit_int8((unsigned char)0x3a);\n+  emit_operand(reg, dst, 0);\n+}\n+\n@@ -1791,0 +1807,7 @@\n+void Assembler::cmpl(Address dst,  Register reg) {\n+  InstructionMark im(this);\n+  prefix(dst, reg);\n+  emit_int8(0x39);\n+  emit_operand(reg, dst, 0);\n+}\n+\n@@ -1806,0 +1829,8 @@\n+void Assembler::cmpw(Address dst, Register reg) {\n+  InstructionMark im(this);\n+  emit_int8(0x66);\n+  prefix(dst, reg);\n+  emit_int8((unsigned char)0x39);\n+  emit_operand(reg, dst, 1);\n+}\n+\n@@ -4426,0 +4457,9 @@\n+void Assembler::vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() : VM_Version::supports_avx2(), \"\");\n+  assert(vector_len <= AVX_256bit, \"evex encoding is different - has k register as dest\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(src2, src1->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x74);\n+  emit_operand(dst, src2, 0);\n+}\n+\n@@ -7587,0 +7627,8 @@\n+void Assembler::vpminub(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_avx512bw()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0xDA, (0xC0 | encode));\n+}\n+\n@@ -12198,0 +12246,7 @@\n+void Assembler::bzhil(Register dst, Register src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"bit manipulation instructions not supported\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0xF5, (0xC0 | encode));\n+}\n+\n@@ -13092,0 +13147,4 @@\n+void Assembler::cdqe() {\n+  emit_int16(REX_W, (unsigned char)0x98);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -1097,0 +1097,1 @@\n+  void cdqe();\n@@ -1112,0 +1113,2 @@\n+  void cmpb(Address dst, Register reg);\n+  void cmpb(Register reg, Address dst);\n@@ -1118,0 +1121,1 @@\n+  void cmpl(Address dst,  Register reg);\n@@ -1126,0 +1130,1 @@\n+  void cmpw(Address dst, Register reg);\n@@ -1803,0 +1808,1 @@\n+  void vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n@@ -2300,0 +2306,1 @@\n+  void bzhil(Register dst, Register src1, Register src2);\n@@ -2575,0 +2582,1 @@\n+  void vpminub(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4142,211 +4142,0 @@\n-\/\/ Compare char[] or byte[] arrays aligned to 4 bytes or substrings.\n-void C2_MacroAssembler::arrays_equals(bool is_array_equ, Register ary1, Register ary2,\n-                                      Register limit, Register result, Register chr,\n-                                      XMMRegister vec1, XMMRegister vec2, bool is_char, KRegister mask) {\n-  ShortBranchVerifier sbv(this);\n-  Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_VECTORS, COMPARE_CHAR, COMPARE_BYTE;\n-\n-  int length_offset  = arrayOopDesc::length_offset_in_bytes();\n-  int base_offset    = arrayOopDesc::base_offset_in_bytes(is_char ? T_CHAR : T_BYTE);\n-\n-  if (is_array_equ) {\n-    \/\/ Check the input args\n-    cmpoop(ary1, ary2);\n-    jcc(Assembler::equal, TRUE_LABEL);\n-\n-    \/\/ Need additional checks for arrays_equals.\n-    testptr(ary1, ary1);\n-    jcc(Assembler::zero, FALSE_LABEL);\n-    testptr(ary2, ary2);\n-    jcc(Assembler::zero, FALSE_LABEL);\n-\n-    \/\/ Check the lengths\n-    movl(limit, Address(ary1, length_offset));\n-    cmpl(limit, Address(ary2, length_offset));\n-    jcc(Assembler::notEqual, FALSE_LABEL);\n-  }\n-\n-  \/\/ count == 0\n-  testl(limit, limit);\n-  jcc(Assembler::zero, TRUE_LABEL);\n-\n-  if (is_array_equ) {\n-    \/\/ Load array address\n-    lea(ary1, Address(ary1, base_offset));\n-    lea(ary2, Address(ary2, base_offset));\n-  }\n-\n-  if (is_array_equ && is_char) {\n-    \/\/ arrays_equals when used for char[].\n-    shll(limit, 1);      \/\/ byte count != 0\n-  }\n-  movl(result, limit); \/\/ copy\n-\n-  if (UseAVX >= 2) {\n-    \/\/ With AVX2, use 32-byte vector compare\n-    Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n-\n-    \/\/ Compare 32-byte vectors\n-    andl(result, 0x0000001f);  \/\/   tail count (in bytes)\n-    andl(limit, 0xffffffe0);   \/\/ vector count (in bytes)\n-    jcc(Assembler::zero, COMPARE_TAIL);\n-\n-    lea(ary1, Address(ary1, limit, Address::times_1));\n-    lea(ary2, Address(ary2, limit, Address::times_1));\n-    negptr(limit);\n-\n-#ifdef _LP64\n-    if ((AVX3Threshold == 0) && VM_Version::supports_avx512vlbw()) { \/\/ trying 64 bytes fast loop\n-      Label COMPARE_WIDE_VECTORS_LOOP_AVX2, COMPARE_WIDE_VECTORS_LOOP_AVX3;\n-\n-      cmpl(limit, -64);\n-      jcc(Assembler::greater, COMPARE_WIDE_VECTORS_LOOP_AVX2);\n-\n-      bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); \/\/ the hottest loop\n-\n-      evmovdquq(vec1, Address(ary1, limit, Address::times_1), Assembler::AVX_512bit);\n-      evpcmpeqb(mask, vec1, Address(ary2, limit, Address::times_1), Assembler::AVX_512bit);\n-      kortestql(mask, mask);\n-      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n-      addptr(limit, 64);  \/\/ update since we already compared at this addr\n-      cmpl(limit, -64);\n-      jccb(Assembler::lessEqual, COMPARE_WIDE_VECTORS_LOOP_AVX3);\n-\n-      \/\/ At this point we may still need to compare -limit+result bytes.\n-      \/\/ We could execute the next two instruction and just continue via non-wide path:\n-      \/\/  cmpl(limit, 0);\n-      \/\/  jcc(Assembler::equal, COMPARE_TAIL);  \/\/ true\n-      \/\/ But since we stopped at the points ary{1,2}+limit which are\n-      \/\/ not farther than 64 bytes from the ends of arrays ary{1,2}+result\n-      \/\/ (|limit| <= 32 and result < 32),\n-      \/\/ we may just compare the last 64 bytes.\n-      \/\/\n-      addptr(result, -64);   \/\/ it is safe, bc we just came from this area\n-      evmovdquq(vec1, Address(ary1, result, Address::times_1), Assembler::AVX_512bit);\n-      evpcmpeqb(mask, vec1, Address(ary2, result, Address::times_1), Assembler::AVX_512bit);\n-      kortestql(mask, mask);\n-      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n-\n-      jmp(TRUE_LABEL);\n-\n-      bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);\n-\n-    }\/\/if (VM_Version::supports_avx512vlbw())\n-#endif \/\/_LP64\n-    bind(COMPARE_WIDE_VECTORS);\n-    vmovdqu(vec1, Address(ary1, limit, Address::times_1));\n-    vmovdqu(vec2, Address(ary2, limit, Address::times_1));\n-    vpxor(vec1, vec2);\n-\n-    vptest(vec1, vec1);\n-    jcc(Assembler::notZero, FALSE_LABEL);\n-    addptr(limit, 32);\n-    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n-\n-    testl(result, result);\n-    jcc(Assembler::zero, TRUE_LABEL);\n-\n-    vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));\n-    vmovdqu(vec2, Address(ary2, result, Address::times_1, -32));\n-    vpxor(vec1, vec2);\n-\n-    vptest(vec1, vec1);\n-    jccb(Assembler::notZero, FALSE_LABEL);\n-    jmpb(TRUE_LABEL);\n-\n-    bind(COMPARE_TAIL); \/\/ limit is zero\n-    movl(limit, result);\n-    \/\/ Fallthru to tail compare\n-  } else if (UseSSE42Intrinsics) {\n-    \/\/ With SSE4.2, use double quad vector compare\n-    Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n-\n-    \/\/ Compare 16-byte vectors\n-    andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n-    andl(limit, 0xfffffff0);   \/\/ vector count (in bytes)\n-    jcc(Assembler::zero, COMPARE_TAIL);\n-\n-    lea(ary1, Address(ary1, limit, Address::times_1));\n-    lea(ary2, Address(ary2, limit, Address::times_1));\n-    negptr(limit);\n-\n-    bind(COMPARE_WIDE_VECTORS);\n-    movdqu(vec1, Address(ary1, limit, Address::times_1));\n-    movdqu(vec2, Address(ary2, limit, Address::times_1));\n-    pxor(vec1, vec2);\n-\n-    ptest(vec1, vec1);\n-    jcc(Assembler::notZero, FALSE_LABEL);\n-    addptr(limit, 16);\n-    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n-\n-    testl(result, result);\n-    jcc(Assembler::zero, TRUE_LABEL);\n-\n-    movdqu(vec1, Address(ary1, result, Address::times_1, -16));\n-    movdqu(vec2, Address(ary2, result, Address::times_1, -16));\n-    pxor(vec1, vec2);\n-\n-    ptest(vec1, vec1);\n-    jccb(Assembler::notZero, FALSE_LABEL);\n-    jmpb(TRUE_LABEL);\n-\n-    bind(COMPARE_TAIL); \/\/ limit is zero\n-    movl(limit, result);\n-    \/\/ Fallthru to tail compare\n-  }\n-\n-  \/\/ Compare 4-byte vectors\n-  andl(limit, 0xfffffffc); \/\/ vector count (in bytes)\n-  jccb(Assembler::zero, COMPARE_CHAR);\n-\n-  lea(ary1, Address(ary1, limit, Address::times_1));\n-  lea(ary2, Address(ary2, limit, Address::times_1));\n-  negptr(limit);\n-\n-  bind(COMPARE_VECTORS);\n-  movl(chr, Address(ary1, limit, Address::times_1));\n-  cmpl(chr, Address(ary2, limit, Address::times_1));\n-  jccb(Assembler::notEqual, FALSE_LABEL);\n-  addptr(limit, 4);\n-  jcc(Assembler::notZero, COMPARE_VECTORS);\n-\n-  \/\/ Compare trailing char (final 2 bytes), if any\n-  bind(COMPARE_CHAR);\n-  testl(result, 0x2);   \/\/ tail  char\n-  jccb(Assembler::zero, COMPARE_BYTE);\n-  load_unsigned_short(chr, Address(ary1, 0));\n-  load_unsigned_short(limit, Address(ary2, 0));\n-  cmpl(chr, limit);\n-  jccb(Assembler::notEqual, FALSE_LABEL);\n-\n-  if (is_array_equ && is_char) {\n-    bind(COMPARE_BYTE);\n-  } else {\n-    lea(ary1, Address(ary1, 2));\n-    lea(ary2, Address(ary2, 2));\n-\n-    bind(COMPARE_BYTE);\n-    testl(result, 0x1);   \/\/ tail  byte\n-    jccb(Assembler::zero, TRUE_LABEL);\n-    load_unsigned_byte(chr, Address(ary1, 0));\n-    load_unsigned_byte(limit, Address(ary2, 0));\n-    cmpl(chr, limit);\n-    jccb(Assembler::notEqual, FALSE_LABEL);\n-  }\n-  bind(TRUE_LABEL);\n-  movl(result, 1);   \/\/ return true\n-  jmpb(DONE);\n-\n-  bind(FALSE_LABEL);\n-  xorl(result, result); \/\/ return false\n-\n-  \/\/ That's it\n-  bind(DONE);\n-  if (UseAVX >= 2) {\n-    \/\/ clean upper bits of YMM registers\n-    vpxor(vec1, vec1);\n-    vpxor(vec2, vec2);\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":0,"deletions":211,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -288,4 +288,0 @@\n-  \/\/ Compare char[] or byte[] arrays.\n-  void arrays_equals(bool is_array_equ, Register ary1, Register ary2,\n-                     Register limit, Register result, Register chr,\n-                     XMMRegister vec1, XMMRegister vec2, bool is_char, KRegister mask = knoreg);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1171,0 +1171,8 @@\n+\/\/ Alignment specifying the maximum number of allowed bytes to pad.\n+\/\/ If padding > max, no padding is inserted.\n+void MacroAssembler::p2align(int modulus, int maxbytes) {\n+  if (modulus - (offset() % modulus) <= maxbytes) {\n+    align(modulus, offset());\n+  }\n+}\n+\n@@ -3538,0 +3546,4 @@\n+void MacroAssembler::vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {\n+  Assembler::vpcmpeqb(dst, src1, src2, vector_len);\n+}\n+\n@@ -9786,0 +9798,211 @@\n+\/\/ Compare char[] or byte[] arrays aligned to 4 bytes or substrings.\n+void MacroAssembler::arrays_equals(bool is_array_equ, Register ary1, Register ary2,\n+                                   Register limit, Register result, Register chr,\n+                                   XMMRegister vec1, XMMRegister vec2, bool is_char, KRegister mask) {\n+  ShortBranchVerifier sbv(this);\n+  Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_VECTORS, COMPARE_CHAR, COMPARE_BYTE;\n+\n+  int length_offset  = arrayOopDesc::length_offset_in_bytes();\n+  int base_offset    = arrayOopDesc::base_offset_in_bytes(is_char ? T_CHAR : T_BYTE);\n+\n+  if (is_array_equ) {\n+    \/\/ Check the input args\n+    cmpoop(ary1, ary2);\n+    jcc(Assembler::equal, TRUE_LABEL);\n+\n+    \/\/ Need additional checks for arrays_equals.\n+    testptr(ary1, ary1);\n+    jcc(Assembler::zero, FALSE_LABEL);\n+    testptr(ary2, ary2);\n+    jcc(Assembler::zero, FALSE_LABEL);\n+\n+    \/\/ Check the lengths\n+    movl(limit, Address(ary1, length_offset));\n+    cmpl(limit, Address(ary2, length_offset));\n+    jcc(Assembler::notEqual, FALSE_LABEL);\n+  }\n+\n+  \/\/ count == 0\n+  testl(limit, limit);\n+  jcc(Assembler::zero, TRUE_LABEL);\n+\n+  if (is_array_equ) {\n+    \/\/ Load array address\n+    lea(ary1, Address(ary1, base_offset));\n+    lea(ary2, Address(ary2, base_offset));\n+  }\n+\n+  if (is_array_equ && is_char) {\n+    \/\/ arrays_equals when used for char[].\n+    shll(limit, 1);      \/\/ byte count != 0\n+  }\n+  movl(result, limit); \/\/ copy\n+\n+  if (UseAVX >= 2) {\n+    \/\/ With AVX2, use 32-byte vector compare\n+    Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n+\n+    \/\/ Compare 32-byte vectors\n+    andl(result, 0x0000001f);  \/\/   tail count (in bytes)\n+    andl(limit, 0xffffffe0);   \/\/ vector count (in bytes)\n+    jcc(Assembler::zero, COMPARE_TAIL);\n+\n+    lea(ary1, Address(ary1, limit, Address::times_1));\n+    lea(ary2, Address(ary2, limit, Address::times_1));\n+    negptr(limit);\n+\n+#ifdef _LP64\n+    if ((AVX3Threshold == 0) && VM_Version::supports_avx512vlbw()) { \/\/ trying 64 bytes fast loop\n+      Label COMPARE_WIDE_VECTORS_LOOP_AVX2, COMPARE_WIDE_VECTORS_LOOP_AVX3;\n+\n+      cmpl(limit, -64);\n+      jcc(Assembler::greater, COMPARE_WIDE_VECTORS_LOOP_AVX2);\n+\n+      bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); \/\/ the hottest loop\n+\n+      evmovdquq(vec1, Address(ary1, limit, Address::times_1), Assembler::AVX_512bit);\n+      evpcmpeqb(mask, vec1, Address(ary2, limit, Address::times_1), Assembler::AVX_512bit);\n+      kortestql(mask, mask);\n+      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n+      addptr(limit, 64);  \/\/ update since we already compared at this addr\n+      cmpl(limit, -64);\n+      jccb(Assembler::lessEqual, COMPARE_WIDE_VECTORS_LOOP_AVX3);\n+\n+      \/\/ At this point we may still need to compare -limit+result bytes.\n+      \/\/ We could execute the next two instruction and just continue via non-wide path:\n+      \/\/  cmpl(limit, 0);\n+      \/\/  jcc(Assembler::equal, COMPARE_TAIL);  \/\/ true\n+      \/\/ But since we stopped at the points ary{1,2}+limit which are\n+      \/\/ not farther than 64 bytes from the ends of arrays ary{1,2}+result\n+      \/\/ (|limit| <= 32 and result < 32),\n+      \/\/ we may just compare the last 64 bytes.\n+      \/\/\n+      addptr(result, -64);   \/\/ it is safe, bc we just came from this area\n+      evmovdquq(vec1, Address(ary1, result, Address::times_1), Assembler::AVX_512bit);\n+      evpcmpeqb(mask, vec1, Address(ary2, result, Address::times_1), Assembler::AVX_512bit);\n+      kortestql(mask, mask);\n+      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n+\n+      jmp(TRUE_LABEL);\n+\n+      bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);\n+\n+    }\/\/if (VM_Version::supports_avx512vlbw())\n+#endif \/\/_LP64\n+    bind(COMPARE_WIDE_VECTORS);\n+    vmovdqu(vec1, Address(ary1, limit, Address::times_1));\n+    vmovdqu(vec2, Address(ary2, limit, Address::times_1));\n+    vpxor(vec1, vec2);\n+\n+    vptest(vec1, vec1);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    addptr(limit, 32);\n+    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n+\n+    testl(result, result);\n+    jcc(Assembler::zero, TRUE_LABEL);\n+\n+    vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));\n+    vmovdqu(vec2, Address(ary2, result, Address::times_1, -32));\n+    vpxor(vec1, vec2);\n+\n+    vptest(vec1, vec1);\n+    jccb(Assembler::notZero, FALSE_LABEL);\n+    jmpb(TRUE_LABEL);\n+\n+    bind(COMPARE_TAIL); \/\/ limit is zero\n+    movl(limit, result);\n+    \/\/ Fallthru to tail compare\n+  } else if (UseSSE42Intrinsics) {\n+    \/\/ With SSE4.2, use double quad vector compare\n+    Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n+\n+    \/\/ Compare 16-byte vectors\n+    andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n+    andl(limit, 0xfffffff0);   \/\/ vector count (in bytes)\n+    jcc(Assembler::zero, COMPARE_TAIL);\n+\n+    lea(ary1, Address(ary1, limit, Address::times_1));\n+    lea(ary2, Address(ary2, limit, Address::times_1));\n+    negptr(limit);\n+\n+    bind(COMPARE_WIDE_VECTORS);\n+    movdqu(vec1, Address(ary1, limit, Address::times_1));\n+    movdqu(vec2, Address(ary2, limit, Address::times_1));\n+    pxor(vec1, vec2);\n+\n+    ptest(vec1, vec1);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    addptr(limit, 16);\n+    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n+\n+    testl(result, result);\n+    jcc(Assembler::zero, TRUE_LABEL);\n+\n+    movdqu(vec1, Address(ary1, result, Address::times_1, -16));\n+    movdqu(vec2, Address(ary2, result, Address::times_1, -16));\n+    pxor(vec1, vec2);\n+\n+    ptest(vec1, vec1);\n+    jccb(Assembler::notZero, FALSE_LABEL);\n+    jmpb(TRUE_LABEL);\n+\n+    bind(COMPARE_TAIL); \/\/ limit is zero\n+    movl(limit, result);\n+    \/\/ Fallthru to tail compare\n+  }\n+\n+  \/\/ Compare 4-byte vectors\n+  andl(limit, 0xfffffffc); \/\/ vector count (in bytes)\n+  jccb(Assembler::zero, COMPARE_CHAR);\n+\n+  lea(ary1, Address(ary1, limit, Address::times_1));\n+  lea(ary2, Address(ary2, limit, Address::times_1));\n+  negptr(limit);\n+\n+  bind(COMPARE_VECTORS);\n+  movl(chr, Address(ary1, limit, Address::times_1));\n+  cmpl(chr, Address(ary2, limit, Address::times_1));\n+  jccb(Assembler::notEqual, FALSE_LABEL);\n+  addptr(limit, 4);\n+  jcc(Assembler::notZero, COMPARE_VECTORS);\n+\n+  \/\/ Compare trailing char (final 2 bytes), if any\n+  bind(COMPARE_CHAR);\n+  testl(result, 0x2);   \/\/ tail  char\n+  jccb(Assembler::zero, COMPARE_BYTE);\n+  load_unsigned_short(chr, Address(ary1, 0));\n+  load_unsigned_short(limit, Address(ary2, 0));\n+  cmpl(chr, limit);\n+  jccb(Assembler::notEqual, FALSE_LABEL);\n+\n+  if (is_array_equ && is_char) {\n+    bind(COMPARE_BYTE);\n+  } else {\n+    lea(ary1, Address(ary1, 2));\n+    lea(ary2, Address(ary2, 2));\n+\n+    bind(COMPARE_BYTE);\n+    testl(result, 0x1);   \/\/ tail  byte\n+    jccb(Assembler::zero, TRUE_LABEL);\n+    load_unsigned_byte(chr, Address(ary1, 0));\n+    load_unsigned_byte(limit, Address(ary2, 0));\n+    cmpl(chr, limit);\n+    jccb(Assembler::notEqual, FALSE_LABEL);\n+  }\n+  bind(TRUE_LABEL);\n+  movl(result, 1);   \/\/ return true\n+  jmpb(DONE);\n+\n+  bind(FALSE_LABEL);\n+  xorl(result, result); \/\/ return false\n+\n+  \/\/ That's it\n+  bind(DONE);\n+  if (UseAVX >= 2) {\n+    \/\/ clean upper bits of YMM registers\n+    vpxor(vec1, vec1);\n+    vpxor(vec2, vec2);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":223,"deletions":0,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -218,0 +218,1 @@\n+  void p2align(int modulus, int maxbytes);\n@@ -249,0 +250,5 @@\n+  \/\/ Compare char[] or byte[] arrays.\n+  void arrays_equals(bool is_array_equ, Register ary1, Register ary2,\n+                     Register limit, Register result, Register chr,\n+                     XMMRegister vec1, XMMRegister vec2, bool is_char, KRegister mask = knoreg);\n+\n@@ -916,0 +922,68 @@\n+  \/\/ Adding more natural conditional jump instructions\n+  void ALWAYSINLINE jo(Label& L, bool maybe_short = true) { jcc(Assembler::overflow, L, maybe_short); }\n+  void ALWAYSINLINE jno(Label& L, bool maybe_short = true) { jcc(Assembler::noOverflow, L, maybe_short); }\n+  void ALWAYSINLINE js(Label& L, bool maybe_short = true) { jcc(Assembler::positive, L, maybe_short); }\n+  void ALWAYSINLINE jns(Label& L, bool maybe_short = true) { jcc(Assembler::negative, L, maybe_short); }\n+  void ALWAYSINLINE je(Label& L, bool maybe_short = true) { jcc(Assembler::equal, L, maybe_short); }\n+  void ALWAYSINLINE jz(Label& L, bool maybe_short = true) { jcc(Assembler::zero, L, maybe_short); }\n+  void ALWAYSINLINE jne(Label& L, bool maybe_short = true) { jcc(Assembler::notEqual, L, maybe_short); }\n+  void ALWAYSINLINE jnz(Label& L, bool maybe_short = true) { jcc(Assembler::notZero, L, maybe_short); }\n+  void ALWAYSINLINE jb(Label& L, bool maybe_short = true) { jcc(Assembler::below, L, maybe_short); }\n+  void ALWAYSINLINE jnae(Label& L, bool maybe_short = true) { jcc(Assembler::below, L, maybe_short); }\n+  void ALWAYSINLINE jc(Label& L, bool maybe_short = true) { jcc(Assembler::carrySet, L, maybe_short); }\n+  void ALWAYSINLINE jnb(Label& L, bool maybe_short = true) { jcc(Assembler::aboveEqual, L, maybe_short); }\n+  void ALWAYSINLINE jae(Label& L, bool maybe_short = true) { jcc(Assembler::aboveEqual, L, maybe_short); }\n+  void ALWAYSINLINE jnc(Label& L, bool maybe_short = true) { jcc(Assembler::carryClear, L, maybe_short); }\n+  void ALWAYSINLINE jbe(Label& L, bool maybe_short = true) { jcc(Assembler::belowEqual, L, maybe_short); }\n+  void ALWAYSINLINE jna(Label& L, bool maybe_short = true) { jcc(Assembler::belowEqual, L, maybe_short); }\n+  void ALWAYSINLINE ja(Label& L, bool maybe_short = true) { jcc(Assembler::above, L, maybe_short); }\n+  void ALWAYSINLINE jnbe(Label& L, bool maybe_short = true) { jcc(Assembler::above, L, maybe_short); }\n+  void ALWAYSINLINE jl(Label& L, bool maybe_short = true) { jcc(Assembler::less, L, maybe_short); }\n+  void ALWAYSINLINE jnge(Label& L, bool maybe_short = true) { jcc(Assembler::less, L, maybe_short); }\n+  void ALWAYSINLINE jge(Label& L, bool maybe_short = true) { jcc(Assembler::greaterEqual, L, maybe_short); }\n+  void ALWAYSINLINE jnl(Label& L, bool maybe_short = true) { jcc(Assembler::greaterEqual, L, maybe_short); }\n+  void ALWAYSINLINE jle(Label& L, bool maybe_short = true) { jcc(Assembler::lessEqual, L, maybe_short); }\n+  void ALWAYSINLINE jng(Label& L, bool maybe_short = true) { jcc(Assembler::lessEqual, L, maybe_short); }\n+  void ALWAYSINLINE jg(Label& L, bool maybe_short = true) { jcc(Assembler::greater, L, maybe_short); }\n+  void ALWAYSINLINE jnle(Label& L, bool maybe_short = true) { jcc(Assembler::greater, L, maybe_short); }\n+  void ALWAYSINLINE jp(Label& L, bool maybe_short = true) { jcc(Assembler::parity, L, maybe_short); }\n+  void ALWAYSINLINE jpe(Label& L, bool maybe_short = true) { jcc(Assembler::parity, L, maybe_short); }\n+  void ALWAYSINLINE jnp(Label& L, bool maybe_short = true) { jcc(Assembler::noParity, L, maybe_short); }\n+  void ALWAYSINLINE jpo(Label& L, bool maybe_short = true) { jcc(Assembler::noParity, L, maybe_short); }\n+\/\/ * No condition for this *  void ALWAYSINLINE jcxz(Label& L, bool maybe_short = true) { jcc(Assembler::cxz, L, maybe_short); }\n+\/\/ * No condition for this *  void ALWAYSINLINE jecxz(Label& L, bool maybe_short = true) { jcc(Assembler::cxz, L, maybe_short); }\n+\n+\/\/ Short versions of the above\n+  void ALWAYSINLINE jo_b(Label& L) { jccb(Assembler::overflow, L); }\n+  void ALWAYSINLINE jno_b(Label& L) { jccb(Assembler::noOverflow, L); }\n+  void ALWAYSINLINE js_b(Label& L) { jccb(Assembler::positive, L); }\n+  void ALWAYSINLINE jns_b(Label& L) { jccb(Assembler::negative, L); }\n+  void ALWAYSINLINE je_b(Label& L) { jccb(Assembler::equal, L); }\n+  void ALWAYSINLINE jz_b(Label& L) { jccb(Assembler::zero, L); }\n+  void ALWAYSINLINE jne_b(Label& L) { jccb(Assembler::notEqual, L); }\n+  void ALWAYSINLINE jnz_b(Label& L) { jccb(Assembler::notZero, L); }\n+  void ALWAYSINLINE jb_b(Label& L) { jccb(Assembler::below, L); }\n+  void ALWAYSINLINE jnae_b(Label& L) { jccb(Assembler::below, L); }\n+  void ALWAYSINLINE jc_b(Label& L) { jccb(Assembler::carrySet, L); }\n+  void ALWAYSINLINE jnb_b(Label& L) { jccb(Assembler::aboveEqual, L); }\n+  void ALWAYSINLINE jae_b(Label& L) { jccb(Assembler::aboveEqual, L); }\n+  void ALWAYSINLINE jnc_b(Label& L) { jccb(Assembler::carryClear, L); }\n+  void ALWAYSINLINE jbe_b(Label& L) { jccb(Assembler::belowEqual, L); }\n+  void ALWAYSINLINE jna_b(Label& L) { jccb(Assembler::belowEqual, L); }\n+  void ALWAYSINLINE ja_b(Label& L) { jccb(Assembler::above, L); }\n+  void ALWAYSINLINE jnbe_b(Label& L) { jccb(Assembler::above, L); }\n+  void ALWAYSINLINE jl_b(Label& L) { jccb(Assembler::less, L); }\n+  void ALWAYSINLINE jnge_b(Label& L) { jccb(Assembler::less, L); }\n+  void ALWAYSINLINE jge_b(Label& L) { jccb(Assembler::greaterEqual, L); }\n+  void ALWAYSINLINE jnl_b(Label& L) { jccb(Assembler::greaterEqual, L); }\n+  void ALWAYSINLINE jle_b(Label& L) { jccb(Assembler::lessEqual, L); }\n+  void ALWAYSINLINE jng_b(Label& L) { jccb(Assembler::lessEqual, L); }\n+  void ALWAYSINLINE jg_b(Label& L) { jccb(Assembler::greater, L); }\n+  void ALWAYSINLINE jnle_b(Label& L) { jccb(Assembler::greater, L); }\n+  void ALWAYSINLINE jp_b(Label& L) { jccb(Assembler::parity, L); }\n+  void ALWAYSINLINE jpe_b(Label& L) { jccb(Assembler::parity, L); }\n+  void ALWAYSINLINE jnp_b(Label& L) { jccb(Assembler::noParity, L); }\n+  void ALWAYSINLINE jpo_b(Label& L) { jccb(Assembler::noParity, L); }\n+\/\/ * No condition for this *  void ALWAYSINLINE jcxz_b(Label& L) { jccb(Assembler::cxz, L); }\n+\/\/ * No condition for this *  void ALWAYSINLINE jecxz_b(Label& L) { jccb(Assembler::cxz, L); }\n+\n@@ -1350,0 +1424,1 @@\n+  void vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -4109,0 +4109,4 @@\n+  if ((UseAVX == 2) && EnableX86ECoreOpts && VM_Version::supports_avx2()) {\n+    StubRoutines::_string_indexof = generate_string_indexof();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -542,0 +542,3 @@\n+  void string_indexof_big_loop_helper(int size, Label& bailout, Label& loop_top);\n+  void string_indexof_small_loop_helper(int size, Label& bailout, Label& loop_top);\n+  address generate_string_indexof();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,957 @@\n+\/*\n+ * Copyright (c) 2023, Intel Corporation. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"macroAssembler_x86.hpp\"\n+#include \"precompiled.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+#include \"opto\/c2_MacroAssembler.hpp\"\n+\n+\/******************************************************************************\/\n+\/\/                     String handling intrinsics\n+\/\/                     --------------------------\n+\/\/\n+\/\/ Currently implements scheme described in http:\/\/0x80.pl\/articles\/simd-strfind.html\n+\/\/ Implementation can be found at https:\/\/github.com\/WojciechMula\/sse4-strstr\n+\/\/\n+\/\/ The general idea is as follows:\n+\/\/ 1. Broadcast the first byte of the needle to a ymm register (32 bytes)\n+\/\/ 2. Broadcast the last byte of the needle to a different ymm register\n+\/\/ 3. Compare the first-byte ymm register to the first 32 bytes of the haystack\n+\/\/ 4. Compare the last-byte register to the 32 bytes of the haystack at the (k-1)st position\n+\/\/    where k is the length of the needle\n+\/\/ 5. Logically AND the results of the comparison\n+\/\/\n+\/\/ The result of the AND yields the position within the haystack where both the first\n+\/\/ and last bytes of the needle exist in their correct relative positions.  Check the full\n+\/\/ needle value against the haystack to confirm a match.\n+\/\/\n+\/\/ This implementation uses memcmp to compare when the size of the needle is >= 32 bytes.\n+\/\/ For other needle sizes, the comparison is done with register compares to eliminate the\n+\/\/ overhead of the call (including range checks, etc.).  The size of the comparison is\n+\/\/ known, and it is also known to be safe reading the haystack for the full width of the needle.\n+\/\/\n+\/\/ The original algorithm as implemented will potentially read past the end of the haystack.\n+\/\/ This implementation protects against that.  Instead of reading as many 32-byte chunks as\n+\/\/ possible and then handling the tail, we calculate the last position of a vaild 32-byte\n+\/\/ read and adjust the starting position of the second read such that the last read will not\n+\/\/ go beyond the end of the haystack.  So the first comparison is to the first 32 bytes of the\n+\/\/ haystack, and the second is offset by an amount to make the last read legal.  The remainder of\n+\/\/ the comparisons are done incrementing by 32 bytes.\n+\/\/\n+\/\/ This will cause 16 bytes on average to be examined twice, but that is cheaper than the\n+\/\/ logic required for tail processing.\n+\/\/\n+\/******************************************************************************\/\n+\n+#define __ _masm->\n+\n+\/******************************************************************************\/\n+\/\/                     Helper for loop construct\n+\/\/                     --------------------------\n+\/\/\n+\/\/ Code:\n+\/\/\n+\/\/ template <size_t k, typename MEMCMP>\n+\/\/ size_t FORCE_INLINE avx2_strstr_memcmp_ptr(const char *s, size_t n, const char *needle, MEMCMP memcmp_fun)\n+\/\/ {\n+\/\/   char *start = (char *)s;\n+\/\/   char *end = (char *)&s[(n)]; \/\/ & ~0x1f];\n+\/\/   long long incr = (n <= 32) ? 32 : (n - k - 31) % 32;\n+\n+\/\/   const __m256i first = _mm256_set1_epi8(needle[0]);\n+\/\/   const __m256i last = _mm256_set1_epi8(needle[k - 1]);\n+\n+\/\/   while (s < end)\n+\/\/   {\n+\n+\/\/     const __m256i block_first = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(s));\n+\/\/     CHECK_BOUNDS(s, 32, start);\n+\/\/     const __m256i block_last = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(s + k - 1));\n+\/\/     CHECK_BOUNDS(s + k - 1, 32, start);\n+\n+\/\/     const __m256i eq_first = _mm256_cmpeq_epi8(first, block_first);\n+\/\/     const __m256i eq_last = _mm256_cmpeq_epi8(last, block_last);\n+\n+\/\/     uint32_t mask = _mm256_movemask_epi8(_mm256_and_si256(eq_first, eq_last));\n+\n+\/\/     while (mask != 0)\n+\/\/     {\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/  Helper code ends here, before comparing full needle\n+\/\/       const auto bitpos = bits::get_first_bit_set(mask);\n+\/\/       if (memcmp_fun(s + bitpos + 1, needle + 1, k - 2) == 0)\n+\/\/       {\n+\/\/         return s - start + bitpos;\n+\/\/       }\n+\n+\/\/       mask = bits::clear_leftmost_set(mask);\n+\/\/     }\n+\/\/     s += incr;\n+\/\/     incr = 32;\n+\/\/   }\n+\n+\/\/   return std::string::npos;\n+\/\/ }\n+\/******************************************************************************\/\n+\n+void StubGenerator::string_indexof_big_loop_helper(int size, Label& bailout, Label& loop_top) {\n+  Label temp;\n+\n+  __ movq(r11, -1);\n+  __ testq(rsi, rsi);\n+  __ jle(bailout);\n+  \/\/ Load ymm0 with copies of first byte of needle and ymm1 with copies of last byte of needle\n+  __ vpbroadcastb(xmm0, Address(r14, 0), Assembler::AVX_256bit);\n+  __ vpbroadcastb(xmm1, Address(r14, size - 1), Assembler::AVX_256bit);\n+  __ leaq(rax, Address(r14, rsi, Address::times_1));\n+  \/\/ Calculate first increment to ensure last read is exactly 32 bytes\n+  __ leal(rcx, Address(rsi, 33 - size));\n+  __ andl(rcx, 0x1f);\n+  __ cmpl(rsi, 0x21);\n+  __ movl(rdx, 0x20);\n+  __ cmovl(Assembler::aboveEqual, rdx, rcx);\n+  __ movq(rcx, rbx);\n+  __ jmpb(temp);\n+\n+  __ bind(loop_top);\n+  __ addq(rcx, rdx);\n+  __ movl(rdx, 0x20);\n+  __ cmpq(rcx, rax);\n+  __ jae(bailout);\n+\n+  __ bind(temp);\n+  \/\/ Compare first byte of needle to haystack\n+  __ vpcmpeqb(xmm2, xmm0, Address(rcx, 0), Assembler::AVX_256bit);\n+  \/\/ Compare last byte of needle to haystack at proper position\n+  __ vpcmpeqb(xmm3, xmm1, Address(rcx, size - 1), Assembler::AVX_256bit);\n+  __ vpand(xmm2, xmm3, xmm2, Assembler::AVX_256bit);\n+  __ vpmovmskb(rsi, xmm2, Assembler::AVX_256bit);\n+  __ testl(rsi, rsi);\n+  __ je_b(loop_top);\n+  \/\/ At this point, we have at least one \"match\" where first and last bytes\n+  \/\/ of the needle are found the correct distance apart.\n+}\n+\n+\/******************************************************************************\/\n+\/\/                     Helper for loop construct\n+\/\/                     --------------------------\n+\/\/\n+\/\/ Code:\n+\/\/\n+\/\/ template <size_t k, typename MEMCMP>\n+\/\/ size_t FORCE_INLINE avx2_strstr_memcmp_small(const char *s, size_t n, const char *needle, MEMCMP memcmp_fun)\n+\/\/ {\n+\/\/ #pragma nounroll\n+\/\/   for (size_t i = 0; i < n - k + 1; i++) {\n+\/\/     if (s[i] == needle[0] && s[i + k - 1] == needle[k - 1]) {\n+\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/  Helper code ends here, before comparing full needle\n+\/\/       if (!memcmp_fun(s + i + 1, needle + 1, k - 2)) {\n+\/\/         return i;\n+\/\/       }\n+\/\/     }\n+\/\/   }\n+\n+\/\/   return std::string::npos;\n+\/\/ }\n+\/******************************************************************************\/\n+\n+void StubGenerator::string_indexof_small_loop_helper(int size, Label& bailout, Label& loop_top) {\n+  Label temp;\n+\n+  __ addq(rsi, -(size - 1));\n+  __ je(bailout);\n+  __ movzbl(rcx, Address(r14, 0));\n+  __ xorq(rax, rax);\n+  __ jmpb(temp);\n+\n+  __ bind(loop_top);\n+  __ incq(rax);\n+  __ cmpq(rsi, rax);\n+  __ je(bailout);\n+\n+  __ bind(temp);\n+  __ cmpb(Address(rbx, rax, Address::times_1), rcx);\n+  __ jne(loop_top);\n+  __ movzbl(rdx, Address(rbx, rax, Address::times_1, size - 1));\n+  __ cmpb(rdx, Address(r14, size - 1));\n+  __ jne(loop_top);\n+}\n+\n+address StubGenerator::generate_string_indexof() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"stringIndexOf\");\n+  address large_hs_jmp_table[10];   \/\/ Jump table for large haystacks\n+  address small_hs_jmp_table[10];   \/\/ Jump table for small haystacks\n+  int jmp_ndx = 0;\n+  __ align(CodeEntryAlignment);\n+  address start = __ pc();\n+  __ enter();  \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/                         AVX2 code\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  if (VM_Version::supports_avx2()) {  \/\/ AVX2 version\n+    Label L_begin;\n+\n+    Label L_returnRBP, L_returnRAX, L_checkRangeAndReturn;\n+    Label L_bigCaseFixupAndReturn, L_small7_8_fixup, L_checkRangeAndReturnRCX;\n+    Label L_returnZero, L_haystackGreaterThan31, L_copyToStackDone, L_bigSwitchTop, L_copyToStack, L_smallSwitchTop;\n+    Label L_bigCaseDefault, L_smallCaseDefault;\n+\n+    address jump_table;\n+    address jump_table_1;\n+\n+    \/\/ Jump past jump table setups to get addresses of cases.\n+    __ jmp(L_begin);\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\n+    \/\/ Set up jump table entries for both small and large haystack switches.\n+\n+\/\/ Small case 1:\n+    \/\/ Unroll for speed\n+    small_hs_jmp_table[0] = __ pc();\n+    {\n+      Label L_tmp1, L_tmp2, L_tmp3, L_tmp4, L_tmp5, L_returnRDI, L_tail;\n+\n+      __ movzbl(rcx, Address(r14, 0));\n+      __ movl(rax, rbx);\n+      __ andl(rax, 0xf);\n+      __ movl(rdx, 0x10);\n+      __ subq(rdx, rax);\n+      __ cmpq(rdx, rsi);\n+      __ movq(rax, rsi);\n+      __ cmovl(Assembler::below, rax, rdx);\n+      __ testq(rax, rax);\n+      __ je_b(L_tmp1);\n+      __ xorl(rdi, rdi);\n+\n+      __ bind(L_tmp2);\n+      __ cmpb(Address(rbx, rdi, Address::times_1), rcx);\n+      __ je(L_returnRDI);\n+      __ incq(rdi);\n+      __ cmpq(rax, rdi);\n+      __ jne(L_tmp2);\n+\n+      __ bind(L_tmp1);\n+      __ cmpq(rdx, rsi);\n+      __ jae(L_returnRBP);\n+      __ movq(rdi, rsi);\n+      __ subq(rdi, rax);\n+      __ movq(rdx, rdi);\n+      __ andq(rdx, -16);\n+      __ je(L_tmp3);\n+      __ leaq(r9, Address(rdx, -1));\n+      __ movdl(xmm0, rcx);\n+      __ vpbroadcastb(xmm0, xmm0, Assembler::AVX_256bit);\n+      __ leaq(r10, Address(rbx, rax, Address::times_1));\n+      __ xorl(r8, r8);\n+\n+      __ bind(L_tmp4);\n+      __ vpcmpeqb(xmm1, xmm0, Address(r10, r8, Address::times_1), Assembler::AVX_256bit);\n+      __ vpmovmskb(r11, xmm1, Assembler::AVX_256bit);\n+      __ testl(r11, r11);\n+      __ jne(L_tail);\n+      __ addq(r8, 0x10);\n+      __ cmpq(r8, r9);\n+      __ jbe(L_tmp4);\n+\n+      __ bind(L_tmp3);\n+      __ cmpq(rdx, rdi);\n+      __ jae(L_returnRBP);\n+      __ addq(rax, rdx);\n+\n+      __ bind(L_tmp5);\n+      __ cmpb(Address(rbx, rax, Address::times_1), rcx);\n+      __ je(L_returnRAX);\n+      __ incq(rax);\n+      __ cmpq(rsi, rax);\n+      __ jne(L_tmp5);\n+      __ jmp(L_returnRBP);\n+\n+      __ bind(L_returnRDI);\n+      __ movq(rbp, rdi);\n+      __ jmp(L_returnRBP);\n+\n+      __ bind(L_tail);\n+      \/\/ Small case tail stuff\n+      __ tzcntl(rcx, r11);\n+      __ addq(rax, rcx);\n+      __ addq(rax, r8);\n+\n+      __ bind(L_returnRAX);\n+      __ movq(rbp, rax);\n+      __ jmp(L_returnRBP);\n+    }\n+\/\/ Small case 2:\n+    small_hs_jmp_table[1] = __ pc();\n+    {\n+      Label L_loopTop;\n+      string_indexof_small_loop_helper(2, L_checkRangeAndReturn, L_loopTop);\n+      __ jmp(L_returnRAX);\n+    }\n+\/\/ Small case 3:\n+    small_hs_jmp_table[2] = __ pc();\n+    {\n+      Label L_loopTop;\n+      string_indexof_small_loop_helper(3, L_checkRangeAndReturn, L_loopTop);\n+      __ movzbl(rdx, Address(rbx, rax, Address::times_1, 1));\n+      __ cmpb(rdx, Address(r14, 1));\n+      __ jne(L_loopTop);\n+      __ jmp(L_returnRAX);\n+    }\n+\/\/ Small case 4:\n+    small_hs_jmp_table[3] = __ pc();\n+    {\n+      Label L_loopTop;\n+      string_indexof_small_loop_helper(4, L_checkRangeAndReturn, L_loopTop);\n+      __ movzwl(rdx, Address(rbx, rax, Address::times_1, 1));\n+      __ cmpw(Address(r14, 1), rdx);\n+      __ jne(L_loopTop);\n+      __ jmp(L_returnRAX);\n+    }\n+\/\/ Small case 5:\n+    small_hs_jmp_table[4] = __ pc();\n+    {\n+      Label L_loopTop;\n+      string_indexof_small_loop_helper(5, L_checkRangeAndReturn, L_loopTop);\n+      __ movl(rdx, Address(rbx, rax, Address::times_1, 1));\n+      __ cmpl(rdx, Address(r14, 1));\n+      __ jne(L_loopTop);\n+      __ jmp(L_returnRAX);\n+    }\n+\/\/ Small case 6:\n+    small_hs_jmp_table[5] = __ pc();\n+    {\n+      Label L_loopTop;\n+      string_indexof_small_loop_helper(6, L_checkRangeAndReturn, L_loopTop);\n+      __ movl(rdx, Address(rbx, rax, Address::times_1, 1));\n+      __ cmpl(rdx, Address(r14, 1));\n+      __ jne(L_loopTop);\n+      __ jmp(L_returnRAX);\n+    }\n+\/\/ Small case 7:\n+    small_hs_jmp_table[6] = __ pc();\n+    {\n+      Label L_loopTop;\n+      string_indexof_small_loop_helper(7, L_checkRangeAndReturn, L_loopTop);\n+      __ movl(rdx, Address(rbx, rax, Address::times_1, 1));\n+      __ cmpl(rdx, Address(r14, 1));\n+      __ jne(L_loopTop);\n+      __ movzbl(rdx, Address(rbx, rax, Address::times_1, 5));\n+      __ cmpb(rdx, Address(r14, 5));\n+      __ jne(L_loopTop);\n+      __ jmp(L_returnRAX);\n+    }\n+\/\/ Small case 8:\n+    small_hs_jmp_table[7] = __ pc();\n+    {\n+      Label L_loopTop;\n+      string_indexof_small_loop_helper(8, L_checkRangeAndReturn, L_loopTop);\n+      __ movl(rdx, Address(rbx, rax, Address::times_1, 1));\n+      __ cmpl(rdx, Address(r14, 1));\n+      __ jne(L_loopTop);\n+      __ movzwl(rdx, Address(rbx, rax, Address::times_1, 5));\n+      __ cmpw(Address(r14, 5), rdx);\n+      __ jne(L_loopTop);\n+      __ jmp(L_returnRAX);\n+    }\n+\/\/ Small case 9:\n+    small_hs_jmp_table[8] = __ pc();\n+    {\n+      Label L_loopTop;\n+      string_indexof_small_loop_helper(9, L_checkRangeAndReturn, L_loopTop);\n+      __ movq(rdx, Address(rbx, rax, Address::times_1, 1));\n+      __ cmpq(rdx, Address(r14, 1));\n+      __ jne(L_loopTop);\n+      __ jmp(L_returnRAX);\n+    }\n+\/\/ Small case 10:\n+    small_hs_jmp_table[9] = __ pc();\n+    {\n+      Label L_loopTop;\n+      string_indexof_small_loop_helper(10, L_checkRangeAndReturn, L_loopTop);\n+      __ movq(rdx, Address(rbx, rax, Address::times_1, 1));\n+      __ cmpq(rdx, Address(r14, 1));\n+      __ jne(L_loopTop);\n+      __ jmp(L_returnRAX);\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\n+    \/\/ Large haystack (>32 bytes) switch\n+\n+\/\/ Big case 1:\n+    large_hs_jmp_table[0] = __ pc();\n+    {\n+      Label L_notInFirst32, L_found, L_loopTop;\n+      __ vpbroadcastb(xmm0, Address(r14, 0), Assembler::AVX_256bit);\n+      __ vpcmpeqb(xmm1, xmm0, Address(rbx, 0), Assembler::AVX_256bit);\n+      __ vpmovmskb(rax, xmm1, Assembler::AVX_256bit);\n+      __ testl(rax, rax);\n+      __ je_b(L_notInFirst32);\n+      __ tzcntl(r11, rax);\n+      __ jmp(L_checkRangeAndReturn);\n+\/\/ Big case 1 body:\n+      __ bind(L_notInFirst32);\n+      __ movq(rax, rsi);\n+      __ andq(rax, -32);\n+      __ andl(rsi, 0x1f);\n+      __ movq(r11, -1);\n+      __ cmpq(rsi, rax);\n+      __ jge(L_checkRangeAndReturn);\n+      __ addq(rax, rbx);\n+\n+      __ bind(L_loopTop);\n+      __ vpcmpeqb(xmm1, xmm0, Address(rbx, rsi, Address::times_1), Assembler::AVX_256bit);\n+      __ vpmovmskb(rcx, xmm1, Assembler::AVX_256bit);\n+      __ testl(rcx, rcx);\n+      __ jne_b(L_found);\n+      __ leaq(rcx, Address(rbx, rsi, Address::times_1));\n+      __ addq(rcx, 0x20);\n+      __ addq(rsi, 0x20);\n+      __ cmpq(rcx, rax);\n+      __ jb(L_loopTop);\n+      __ jmp(L_checkRangeAndReturn);\n+\n+      __ bind(L_found);\n+      __ tzcntl(r11, rcx);\n+      __ addq(r11, rsi);\n+      __ jmp(L_checkRangeAndReturn);\n+    }\n+\n+\n+\n+\/\/ Big case 2:\n+    large_hs_jmp_table[1] = __ pc();\n+    {\n+      Label L_found, L_loopTop;\n+\n+      __ movq(r11, -1);\n+      __ testq(rsi, rsi);\n+      __ jle(L_checkRangeAndReturn);\n+      __ vpbroadcastb(xmm0, Address(r14, 0), Assembler::AVX_256bit);\n+      __ vpbroadcastb(xmm1, Address(r14, 1), Assembler::AVX_256bit);\n+      __ leaq(rcx, Address(rbx, rsi, Address::times_1));\n+      __ leal(rax, Address(rsi, -1));\n+      __ andl(rax, 0x1f);\n+      __ cmpl(rsi, 0x21);\n+      __ movl(rdx, 0x20);\n+      __ cmovl(Assembler::aboveEqual, rdx, rax);\n+      __ movq(rax, rbx);\n+\n+      __ bind(L_loopTop);\n+      __ vpcmpeqb(xmm2, xmm0, Address(rax, 0), Assembler::AVX_256bit);\n+      __ vpcmpeqb(xmm3, xmm1, Address(rcx, 1), Assembler::AVX_256bit);\n+      __ vpand(xmm2, xmm3, xmm2, Assembler::AVX_256bit);\n+      __ vpmovmskb(rsi, xmm2, Assembler::AVX_256bit);\n+      __ testl(rsi, rsi);\n+      __ jne_b(L_found);\n+      __ addq(rax, rdx);\n+      __ cmpq(rax, rcx);\n+      __ jae(L_checkRangeAndReturn);\n+      __ vpcmpeqb(xmm2, xmm0, Address(rax, 0), Assembler::AVX_256bit);\n+      __ vpcmpeqb(xmm3, xmm1, Address(rax, 1), Assembler::AVX_256bit);\n+      __ vpand(xmm2, xmm3, xmm2, Assembler::AVX_256bit);\n+      __ vpmovmskb(rsi, xmm2, Assembler::AVX_256bit);\n+      __ testl(rsi, rsi);\n+      __ jne_b(L_found);\n+      __ addq(rax, 0x20);\n+      __ movl(rdx, 0x20);\n+      __ cmpq(rax, rcx);\n+      __ jb(L_loopTop);\n+      __ jmp(L_checkRangeAndReturn);\n+\n+      __ bind(L_found);\n+      __ tzcntl(rcx, rsi);\n+      __ subq(rax, rbx);\n+      __ addq(rax, rcx);\n+      __ movq(r11, rax);\n+      __ jmp(L_checkRangeAndReturn);\n+    }\n+\n+\n+\n+\/\/ Big case 3:\n+    large_hs_jmp_table[2] = __ pc();\n+    {\n+      Label L_loopTop, L_innerLoop;\n+\n+      string_indexof_big_loop_helper(3, L_checkRangeAndReturn, L_loopTop);\n+      __ movzbl(rdi, Address(r14, 1));\n+      __ align(16);\n+      __ bind(L_innerLoop);\n+      __ tzcntl(r8, rsi);\n+      __ cmpb(Address(rcx, r8, Address::times_1, 1), rdi);\n+      __ je(L_bigCaseFixupAndReturn);\n+      __ blsrl(rsi, rsi);\n+      __ jne(L_innerLoop);\n+      __ jmp(L_loopTop);\n+    }\n+\n+\n+\n+\/\/ Big case 4:\n+    large_hs_jmp_table[3] = __ pc();\n+    {\n+      Label L_loopTop, L_innerLoop;\n+\n+      string_indexof_big_loop_helper(4, L_checkRangeAndReturn, L_loopTop);\n+      __ movzwl(rdi, Address(r14, 1));\n+      __ align(16);\n+      __ bind(L_innerLoop);\n+      __ tzcntl(r8, rsi);\n+      __ cmpw(Address(rcx, r8, Address::times_1, 1), rdi);\n+      __ je(L_bigCaseFixupAndReturn);\n+      __ blsrl(rsi, rsi);\n+      __ jne(L_innerLoop);\n+      __ jmp(L_loopTop);\n+    }\n+\n+\n+\n+\/\/ Big case 5:\n+    large_hs_jmp_table[4] = __ pc();\n+    {\n+      Label L_loopTop, L_innerLoop;\n+\n+      string_indexof_big_loop_helper(5, L_checkRangeAndReturn, L_loopTop);\n+      __ movl(rdi, Address(r14, 1));\n+      __ align(16);\n+      __ bind(L_innerLoop);\n+      __ tzcntl(r8, rsi);\n+      __ cmpl(Address(rcx, r8, Address::times_1, 1), rdi);\n+      __ je(L_bigCaseFixupAndReturn);\n+      __ blsrl(rsi, rsi);\n+      __ jne(L_innerLoop);\n+      __ jmp(L_loopTop);\n+    }\n+\n+\n+\n+\/\/ Big case 6:\n+    large_hs_jmp_table[5] = __ pc();\n+    {\n+      Label L_loopTop, L_innerLoop;\n+\n+      string_indexof_big_loop_helper(6, L_checkRangeAndReturn, L_loopTop);\n+      __ movl(rdi, Address(r14, 1));\n+      __ align(16);\n+      __ bind(L_innerLoop);\n+      __ tzcntl(r8, rsi);\n+      __ cmpl(Address(rcx, r8, Address::times_1, 1), rdi);\n+      __ je(L_bigCaseFixupAndReturn);\n+      __ blsrl(rsi, rsi);\n+      __ jne(L_innerLoop);\n+      __ jmp(L_loopTop);\n+    }\n+\n+\n+\n+\/\/ Big case 7:\n+    large_hs_jmp_table[6] = __ pc();\n+    {\n+      Label L_loopTop, L_innerLoop, L_tmp;\n+\n+      string_indexof_big_loop_helper(7, L_checkRangeAndReturn, L_loopTop);\n+      __ movl(rdi, Address(r14, 1));\n+      __ jmpb(L_tmp);\n+      __ align(16);\n+      __ bind(L_innerLoop);\n+      __ blsrl(rsi, rsi);\n+      __ je(L_loopTop);\n+      __ bind(L_tmp);\n+      __ tzcntl(r8, rsi);\n+      __ cmpl(Address(rcx, r8, Address::times_1, 1), rdi);\n+      __ jne(L_innerLoop);\n+      __ movzbl(r9, Address(rcx, r8, Address::times_1, 5));\n+      __ cmpb(r9, Address(r14, 5));\n+      __ jne(L_innerLoop);\n+      __ jmp(L_small7_8_fixup);\n+    }\n+\n+\n+\n+\/\/ Big case 8:\n+    large_hs_jmp_table[7] = __ pc();\n+    {\n+      Label L_loopTop, L_innerLoop, L_tmp;\n+\n+      string_indexof_big_loop_helper(8, L_checkRangeAndReturn, L_loopTop);\n+      __ movl(rdi, Address(r14, 1));\n+      __ jmpb(L_tmp);\n+      __ align(16);\n+      __ bind(L_innerLoop);\n+      __ blsrl(rsi, rsi);\n+      __ je(L_loopTop);\n+      __ bind(L_tmp);\n+      __ tzcntl(r8, rsi);\n+      __ cmpl(Address(rcx, r8, Address::times_1, 1), rdi);\n+      __ jne(L_innerLoop);\n+      __ movzwl(r9, Address(rcx, r8, Address::times_1, 5));\n+      __ cmpw(Address(r14, 5), r9);\n+      __ jne(L_innerLoop);\n+      __ bind(L_small7_8_fixup);\n+      __ subq(rcx, rbx);\n+      __ addq(rcx, r8);\n+      __ jmp(L_checkRangeAndReturnRCX);\n+    }\n+\n+\n+\n+\/\/ Big case 9:\n+    large_hs_jmp_table[8] = __ pc();\n+    {\n+      Label L_loopTop, L_innerLoop;\n+\n+      string_indexof_big_loop_helper(9, L_checkRangeAndReturn, L_loopTop);\n+      __ movq(rdi, Address(r14, 1));\n+      __ align(16);\n+      __ bind(L_innerLoop);\n+      __ tzcntl(r8, rsi);\n+      __ cmpq(Address(rcx, r8, Address::times_1, 1), rdi);\n+      __ je(L_bigCaseFixupAndReturn);\n+      __ blsrl(rsi, rsi);\n+      __ jne(L_innerLoop);\n+      __ jmp(L_loopTop);\n+    }\n+\n+\n+\n+\/\/ Big case 10:\n+    large_hs_jmp_table[9] = __ pc();\n+    {\n+      Label L_loopTop, L_innerLoop;\n+\n+      string_indexof_big_loop_helper(10, L_checkRangeAndReturn, L_loopTop);\n+      __ movq(rdi, Address(r14, 1));\n+      __ align(16);\n+      __ bind(L_innerLoop);\n+      __ tzcntl(r8, rsi);\n+      __ cmpq(Address(rcx, r8, Address::times_1, 1), rdi);\n+      __ je(L_bigCaseFixupAndReturn);\n+      __ blsrl(rsi, rsi);\n+      __ jne(L_innerLoop);\n+      __ jmp(L_loopTop);\n+    }\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    __ align(8);\n+\n+    jump_table = __ pc();\n+\n+    for (jmp_ndx = 0; jmp_ndx < 10; jmp_ndx++) {\n+      __ emit_address(large_hs_jmp_table[jmp_ndx]);\n+    }\n+\n+    jump_table_1 = __ pc();\n+\n+    for (jmp_ndx = 0; jmp_ndx < 10; jmp_ndx++) {\n+      __ emit_address(small_hs_jmp_table[jmp_ndx]);\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\n+    \/\/ Big case default:\n+\n+    {\n+      Label L_loopTop, L_loopMid, L_innerLoop, L_found, L_bigDefaultNotFound;\n+\n+      __ bind(L_bigCaseDefault);\n+      __ movq(r11, -1);\n+      __ testq(rsi, rsi);\n+      __ jle(L_checkRangeAndReturn);\n+      __ movq(Address(rsp, 0x20), r10);\n+      __ leaq(rax, Address(rbx, rsi, Address::times_1));\n+      __ movq(Address(rsp, 0x10), rax);\n+      __ vpbroadcastb(xmm0, Address(r14, 0), Assembler::AVX_256bit);\n+      __ vmovdqu(Address(rsp, 0x50), xmm0);\n+      __ vpbroadcastb(xmm0, Address(r12, r14, Address::times_1, -1), Assembler::AVX_256bit);\n+      __ vmovdqu(Address(rsp, 0x30), xmm0);\n+      __ movl(rax, rsi);\n+      __ subl(rax, r12);\n+      __ incl(rax);\n+      __ andl(rax, 0x1f);\n+      __ cmpq(rsi, 0x21);\n+      __ movl(rcx, 0x20);\n+      __ cmovl(Assembler::aboveEqual, rcx, rax);\n+      __ incq(r14);\n+      __ movq(rax, rbx);\n+      __ movq(rbx, r14);\n+      __ leaq(r15, Address(r12, -0x2));\n+      __ movq(Address(rsp, 0x28), rax);\n+      __ jmpb(L_loopMid);\n+\n+      __ bind(L_loopTop);\n+      __ movq(rax, Address(rsp, 0x8));\n+      __ addq(rax, Address(rsp, 0x18));\n+      __ movl(rcx, 0x20);\n+      __ cmpq(rax, Address(rsp, 0x10));\n+      __ jae(L_bigDefaultNotFound);\n+\n+      __ bind(L_loopMid);\n+      __ movq(Address(rsp, 0x18), rcx);\n+      __ vmovdqu(xmm0, Address(rsp, 0x50));\n+      __ vpcmpeqb(xmm0, xmm0, Address(rax, 0), Assembler::AVX_256bit);\n+      __ vmovdqu(xmm1, Address(rsp, 0x30));\n+      __ movq(Address(rsp, 0x8), rax);\n+      __ vpcmpeqb(xmm1, xmm1, Address(rax, r12, Address::times_1, -1), Assembler::AVX_256bit);\n+      __ vpand(xmm0, xmm1, xmm0, Assembler::AVX_256bit);\n+      __ vpmovmskb(r13, xmm0, Assembler::AVX_256bit);\n+      __ testl(r13, r13);\n+      __ je(L_loopTop);\n+      __ movq(rax, Address(rsp, 0x8));\n+      __ leaq(r14, Address(rax, 0x1));\n+\n+      __ align(8);\n+      __ bind(L_innerLoop);\n+      __ tzcntl(rbp, r13);\n+      __ leaq(rdi, Address(r14, rbp, Address::times_1));\n+      __ arrays_equals(true, rdi, rbx, r15, rax, rdx, xmm0, xmm1,\n+                      false \/* char *\/, knoreg);\n+      __ testl(rax, rax);\n+      __ jne_b(L_found);\n+      __ blsrl(r13, r13);\n+      __ jne(L_innerLoop);\n+      __ jmp(L_loopTop);\n+\n+      __ bind(L_found);\n+      __ movl(rax, rbp);\n+      __ movq(r11, Address(rsp, 0x8));\n+      __ subq(r11, Address(rsp, 0x28));\n+      __ addq(r11, rax);\n+      __ movq(r10, Address(rsp, 0x20));\n+      __ jmp(L_checkRangeAndReturn);\n+\n+      \/\/ Big case default stuff\n+      __ bind(L_bigDefaultNotFound);\n+      __ movq(r10, Address(rsp, 0x20));\n+      __ movq(r11, -1);\n+      __ jmp(L_checkRangeAndReturn);\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\n+    \/\/ Small case default:\n+\n+    {\n+      Label L_loopTop, L_loopMid;\n+\n+      __ bind(L_smallCaseDefault);\n+      __ incq(rsi);\n+      __ subq(rsi, r12);\n+      __ je(L_returnRBP);\n+      __ movzbl(rcx, Address(r14, 0));\n+      __ leaq(rax, Address(r14, 0x1));\n+      __ movq(Address(rsp, 0x8), rax);\n+      __ cmpq(rsi, 0x2);\n+      __ movl(rcx, 0x1);\n+      __ cmovl(Assembler::aboveEqual, rdx, rsi);\n+      __ leaq(rax, Address(r12, -0x2));\n+      __ movq(Address(rsp, 0x50), rax);\n+      __ leaq(rsi, Address(rbx, r12, Address::times_1));\n+      __ decq(rsi);\n+      __ leaq(rax, Address(rbx, 0x1));\n+      __ movq(Address(rsp, 0x10), rax);\n+      __ xorl(r15, r15);\n+      __ movq(Address(rsp, 0x18), rdx);\n+      __ movq(Address(rsp, 0x30), rsi);\n+      __ jmpb(L_loopMid);\n+\n+      __ bind(L_loopTop);\n+      __ incq(r15);\n+      __ cmpq(rdx, r15);\n+      __ je(L_returnRBP);\n+\n+      __ bind(L_loopMid);\n+      __ cmpb(Address(rbx, r15, Address::times_1), rcx);\n+      __ jne(L_loopTop);\n+      __ movzbl(rax, Address(rsi, r15, Address::times_1));\n+      __ cmpb(Address(r14, r13, Address::times_1), rax);\n+      __ jne(L_loopTop);\n+\n+      __ movq(rax, Address(rsp, 0x10));\n+      __ leaq(rdi, Address(rax, r15, Address::times_1));\n+      __ movq(rsi, Address(rsp, 0x8));\n+      __ movq(rdx, Address(rsp, 0x50));\n+      __ arrays_equals(true, rdi, rsi, rdx, rax, r12, xmm0, xmm1,\n+                      false \/* char *\/, knoreg);\n+      __ testl(rax, rax);\n+      __ je(L_loopTop);\n+      __ movq(rbp, r15);\n+      __ jmp(L_returnRBP);\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    __ bind(L_bigCaseFixupAndReturn);\n+    __ movl(rax, r8);\n+    __ subq(rcx, rbx);\n+    __ addq(rcx, rax);\n+\n+    __ bind(L_checkRangeAndReturnRCX);\n+    __ movq(r11, rcx);\n+\n+    __ bind(L_checkRangeAndReturn);\n+    __ cmpq(r11, r10);\n+    __ movq(rbp, -1);\n+    __ cmovq(Assembler::belowEqual, rbp, r11);\n+\n+    __ bind(L_returnRBP);\n+    __ movq(rax, rbp);\n+    __ addptr(rsp, 0xf0);\n+#ifdef _WIN64\n+    __ pop(r9);\n+    __ pop(r8);\n+    __ pop(rcx);\n+    __ pop(rdi);\n+    __ pop(rsi);\n+#endif\n+    __ pop(rbp);\n+    __ pop(rbx);\n+    __ pop(r12);\n+    __ pop(r13);\n+    __ pop(r14);\n+    __ pop(r15);\n+    __ vzeroupper();\n+\n+    __ leave();  \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ ret(0);\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    __ align(16);\n+    __ bind(L_begin);\n+    __ push(r15);\n+    __ push(r14);\n+    __ push(r13);\n+    __ push(r12);\n+    __ push(rbx);\n+    __ push(rbp);\n+#ifdef _WIN64\n+    __ push(rsi);\n+    __ push(rdi);\n+    __ push(rcx);\n+    __ push(r8);\n+    __ push(r9);\n+\n+    __ movq(rdi, rcx);\n+    __ movq(rsi, rdx);\n+    __ movq(rdx, r8);\n+    __ movq(rcx, r9);\n+#endif\n+\n+    __ subptr(rsp, 0xf0);\n+    __ movq(rbp, -1);\n+    \/\/ if (n < k) {\n+    \/\/   return -1;\n+    \/\/ }\n+    __ movq(r10, rsi);\n+    __ subq(r10, rcx);\n+    __ jb(L_returnRBP);\n+    __ movq(r12, rcx);\n+    __ testq(rcx, rcx);\n+    __ je_b(L_returnZero);\n+    __ movq(r14, rdx);\n+    __ movq(rbx, rdi);\n+    __ cmpq(rsi, 0x20);\n+    __ jae_b(L_haystackGreaterThan31);\n+\n+    __ cmpq(r10, 0xb);      \/\/ ASGASG\n+    __ jae_b(L_copyToStack);\n+    \/\/ __ jmpb(L_copyToStack);\n+\n+    __ bind(L_smallSwitchTop);\n+    __ leaq(r13, Address(r12, -1));\n+    __ cmpq(r13, 0x9);\n+    __ ja(L_smallCaseDefault);\n+    __ mov64(r15, (int64_t)jump_table_1);\n+    __ jmp(Address(r15, r13, Address::times_8));\n+\n+    __ bind(L_returnZero);\n+    __ xorl(rbp, rbp);\n+    __ jmp(L_returnRBP);\n+\n+    __ bind(L_haystackGreaterThan31);\n+    __ leaq(rax, Address(r12, 0x1f));\n+    __ cmpq(rax, rsi);\n+    __ jle(L_bigSwitchTop);\n+    __ cmpq(rsi, 0x20);\n+    __ ja(L_smallSwitchTop);\n+\n+    __ cmpq(r10, 0xa);\n+    __ jbe(L_smallSwitchTop);\n+\n+    __ bind(L_copyToStack);\n+    __ leal(rdx, Address(rsi, -1));\n+    __ andl(rdx, 0x10);\n+    __ movl(rax, rsi);\n+    __ subl(rax, rdx);\n+    __ movslq(rcx, rax);\n+    __ movl(rax, 0x10);\n+    __ subl(rax, rcx);\n+    __ vmovdqu(xmm0, Address(rcx, rbx, Address::times_1, -0x10));\n+    __ vmovdqu(Address(rsp, 0x70), xmm0);\n+    __ testl(rdx, rdx);\n+    __ je_b(L_copyToStackDone);\n+\n+    __ vmovdqu(xmm0, Address(rbx, rcx, Address::times_1));\n+    __ vmovdqu(Address(rsp, 0x80), xmm0);\n+\n+    __ bind(L_copyToStackDone);\n+    __ cdqe();\n+    __ leaq(rbx, Address(rsp, rax, Address::times_1));\n+    __ addq(rbx, 0x70);\n+    __ bind(L_bigSwitchTop);\n+    __ leaq(rax, Address(r12, -1));\n+    __ cmpq(rax, 0x9);\n+    __ ja(L_bigCaseDefault);\n+    __ mov64(r15, (int64_t)jump_table);\n+    __ jmp(Address(r15, rax, Address::times_8));\n+\n+  } else {  \/\/ SSE version\n+    assert(false, \"Only supports AVX2\");\n+  }\n+\n+  return start;\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_string.cpp","additions":957,"deletions":0,"binary":false,"changes":957,"status":"added"},{"patch":"@@ -1608,0 +1608,1 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"stringIndexOf\") == 0 ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1205,7 +1205,14 @@\n-  if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {\n-    \/\/ Divide src size by 2 if String is UTF16 encoded\n-    src_count = _gvn.transform(new RShiftINode(src_count, intcon(1)));\n-  }\n-  if (ae == StrIntrinsicNode::UU) {\n-    \/\/ Divide substring size by 2 if String is UTF16 encoded\n-    tgt_count = _gvn.transform(new RShiftINode(tgt_count, intcon(1)));\n+  Node* result = nullptr;\n+  bool do_intrinsic =\n+      (StubRoutines::string_indexof() != nullptr) &&\n+      ((ae == StrIntrinsicNode::LL) || (ae == StrIntrinsicNode::UU));\n+\n+  if (!do_intrinsic) {\n+    if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {\n+      \/\/ Divide src size by 2 if String is UTF16 encoded\n+      src_count = _gvn.transform(new RShiftINode(src_count, intcon(1)));\n+    }\n+    if (ae == StrIntrinsicNode::UU) {\n+      \/\/ Divide substring size by 2 if String is UTF16 encoded\n+      tgt_count = _gvn.transform(new RShiftINode(tgt_count, intcon(1)));\n+    }\n@@ -1214,1 +1221,10 @@\n-  Node* result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count, result_rgn, result_phi, ae);\n+  if (do_intrinsic) {\n+    Node* call = make_runtime_call(RC_LEAF, OptoRuntime::string_IndexOf_Type(),\n+                                   StubRoutines::string_indexof(),\n+                                   \"stringIndexOf\", TypePtr::BOTTOM, src_start,\n+                                   src_count, tgt_start, tgt_count);\n+    result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n+  } else {\n+    result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count,\n+                               result_rgn, result_phi, ae);\n+  }\n@@ -1259,0 +1275,1 @@\n+  Node* result = nullptr;\n@@ -1260,1 +1277,9 @@\n-  Node* result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count, region, phi, ae);\n+  if ((StubRoutines::string_indexof() != nullptr) && (ae == StrIntrinsicNode::LL)) {\n+    Node* call = make_runtime_call(RC_LEAF,\n+                                   OptoRuntime::string_IndexOf_Type(),\n+                                   StubRoutines::string_indexof(), \"stringIndexOf\", TypePtr::BOTTOM,\n+                                   src_start, src_count, tgt_start, tgt_count);\n+    result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n+  } else {\n+    result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count, region, phi, ae);\n+  }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":34,"deletions":9,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1337,0 +1337,21 @@\n+\n+\/\/ String IndexOf function\n+const TypeFunc* OptoRuntime::string_IndexOf_Type() {\n+  int argcnt = 4;\n+\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ needle array\n+  fields[argp++] = TypeInt::INT;        \/\/ needle length\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ haystack array\n+  fields[argp++] = TypeInt::INT;        \/\/ haystack length\n+  assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms + 0] = TypeInt::INT; \/\/ Index of needle in haystack\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -298,0 +298,1 @@\n+  static const TypeFunc* string_IndexOf_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -147,0 +147,2 @@\n+address StubRoutines::_string_indexof =    nullptr;\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -230,0 +230,2 @@\n+  static address _string_indexof;\n+\n@@ -420,0 +422,2 @@\n+  static address string_indexof()  { return _string_indexof; }\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-    static Random generator = new Random();\n-    private static boolean failure = false;\n+  static Random generator = new Random();\n+  private static boolean failure = false;\n@@ -37,4 +37,2 @@\n-    public static void main(String[] args) throws Exception {\n-        simpleTest();\n-        compareIndexOfLastIndexOf();\n-        compareStringStringBuffer();\n+  public static void main(String[] args) throws Exception {\n+    String testName = \"IndexOf\";\n@@ -42,2 +40,2 @@\n-        if (failure)\n-           throw new RuntimeException(\"One or more BitSet failures.\");\n+    for (int i = 0; i < 20000; i++) {\n+      int foo = testName.indexOf(\"dex\");\n@@ -45,6 +43,24 @@\n-\n-    private static void report(String testName, int failCount) {\n-        System.err.println(testName+\": \" +\n-                         (failCount==0 ? \"Passed\":\"Failed(\"+failCount+\")\"));\n-        if (failCount > 0)\n-            failure = true;\n+    System.out.println(\"\");\n+    simpleTest();\n+    compareIndexOfLastIndexOf();\n+    compareStringStringBuffer();\n+    compareExhaustive();\n+\n+    if (failure)\n+      throw new RuntimeException(\"One or more BitSet failures.\");\n+  }\n+\n+  private static void report(String testName, int failCount) {\n+    System.err.println(testName + \": \" +\n+        (failCount == 0 ? \"Passed\" : \"Failed(\" + failCount + \")\"));\n+    if (failCount > 0)\n+      failure = true;\n+  }\n+\n+  private static String generateTestString(int min, int max) {\n+    StringBuffer aNewString = new StringBuffer(120);\n+    int aNewLength = getRandomIndex(min, max);\n+    for (int y = 0; y < aNewLength; y++) {\n+      int achar = generator.nextInt(30) + 30;\n+      char test = (char) (achar);\n+      aNewString.append(test);\n@@ -52,8 +68,21 @@\n-\n-    private static String generateTestString(int min, int max) {\n-        StringBuffer aNewString = new StringBuffer(120);\n-        int aNewLength = getRandomIndex(min, max);\n-        for(int y=0; y<aNewLength; y++) {\n-            int achar = generator.nextInt(30)+30;\n-            char test = (char)(achar);\n-            aNewString.append(test);\n+    return aNewString.toString();\n+  }\n+\n+  private static int getRandomIndex(int constraint1, int constraint2) {\n+    int range = constraint2 - constraint1;\n+    int x = generator.nextInt(range);\n+    return constraint1 + x;\n+  }\n+\n+  private static int naiveFind(String haystack, String needle, int offset) {\n+    int x = offset;\n+    int y = 0;\n+    int len = haystack.length() - offset;\n+    if (needle.length() == 0) return 0;\n+    if (needle.length() > len) return -1;\n+    for (x = offset; x < len - needle.length() + 1; x++) {\n+      if (haystack.charAt(x) == needle.charAt(0)) {\n+        for (y = 1; y < needle.length(); y++) {\n+          if (haystack.charAt(x + y) != needle.charAt(y)) {\n+            break;\n+          }\n@@ -61,1 +90,2 @@\n-        return aNewString.toString();\n+        if (y == needle.length()) return x;\n+      }\n@@ -63,28 +93,31 @@\n-\n-    private static int getRandomIndex(int constraint1, int constraint2) {\n-        int range = constraint2 - constraint1;\n-        int x = generator.nextInt(range);\n-        return constraint1 + x;\n-    }\n-\n-    private static void simpleTest() {\n-        int failCount = 0;\n-        String sourceString;\n-        StringBuffer sourceBuffer;\n-        String targetString;\n-\n-        for (int i=0; i<10000; i++) {\n-            do {\n-                sourceString = generateTestString(99, 100);\n-                sourceBuffer = new StringBuffer(sourceString);\n-                targetString = generateTestString(10, 11);\n-            } while (sourceString.indexOf(targetString) != -1);\n-\n-            int index1 = generator.nextInt(90) + 5;\n-            sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n-\n-            if (sourceBuffer.indexOf(targetString) != index1)\n-                failCount++;\n-            if (sourceBuffer.indexOf(targetString, 5) != index1)\n-                failCount++;\n-            if (sourceBuffer.indexOf(targetString, 99) == index1)\n+    return -1;\n+  }\n+\n+  private static void compareExhaustive() {\n+    int failCount = 0;\n+    String sourceString;\n+    String targetString;\n+    int hsLen = 97;\n+    int maxNeedleLen = hsLen;\/\/ \/ 2;\n+    int haystackLen;\n+    int needleLen;\n+    int hsBegin, nBegin;\n+\n+    for (int i = 0; i < 10000; i++) {\n+      do {\n+        sourceString = generateTestString(hsLen - 1, hsLen);\n+        targetString = generateTestString(maxNeedleLen - 1, maxNeedleLen);\n+      } while (naiveFind(sourceString, targetString, 0) != -1);\n+\n+      for (haystackLen = 0; haystackLen < hsLen; haystackLen += 7) {\n+        for (needleLen = 0; (needleLen < maxNeedleLen) && (needleLen <= haystackLen); needleLen++) {\n+          for (hsBegin = 0; (hsBegin < haystackLen - needleLen) && (hsBegin + haystackLen < hsLen); hsBegin += 3) {\n+            for (nBegin = 0; (nBegin < needleLen) && (nBegin + needleLen < maxNeedleLen); nBegin += 3) {\n+              int nResult = naiveFind(sourceString.substring(hsBegin, hsBegin + haystackLen),\n+                                      targetString.substring(nBegin, nBegin + needleLen), 0);\n+              int iResult = sourceString.substring(hsBegin, hsBegin + haystackLen).indexOf(targetString.substring(nBegin, nBegin + needleLen));\n+              if (iResult != nResult) {\n+                System.out.println(\"Source=\"+sourceString.substring(hsBegin, hsBegin + haystackLen));\n+                System.out.println(\"Target=\"+targetString.substring(nBegin, nBegin + needleLen));\n+                System.out.println(\"haystackLen=\"+haystackLen+\" neeldeLen=\"+needleLen+\" hsBegin=\"+hsBegin+\" nBegin=\"+nBegin+\n+                                   \" iResult=\"+iResult+\" nResult=\"+nResult);\n@@ -92,0 +125,3 @@\n+              }\n+            }\n+          }\n@@ -93,2 +129,1 @@\n-\n-        report(\"Basic Test                   \", failCount);\n+      }\n@@ -97,36 +132,28 @@\n-    \/\/ Note: it is possible although highly improbable that failCount will\n-    \/\/ be > 0 even if everthing is working ok\n-    private static void compareIndexOfLastIndexOf() {\n-        int failCount = 0;\n-        String sourceString;\n-        StringBuffer sourceBuffer;\n-        String targetString;\n-\n-        for (int i=0; i<10000; i++) {\n-            do {\n-                sourceString = generateTestString(99, 100);\n-                sourceBuffer = new StringBuffer(sourceString);\n-                targetString = generateTestString(10, 11);\n-            } while (sourceString.indexOf(targetString) != -1);\n-\n-            int index1 = generator.nextInt(100);\n-            sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n-\n-            \/\/ extremely remote possibility of > 1 match\n-            int matches = 0;\n-            int index2 = -1;\n-            while((index2 = sourceBuffer.indexOf(targetString,index2+1)) != -1)\n-                matches++;\n-            if (matches > 1)\n-                continue;\n-\n-            if (sourceBuffer.indexOf(targetString) !=\n-                sourceBuffer.lastIndexOf(targetString))\n-                failCount++;\n-            sourceString = sourceBuffer.toString();\n-            if (sourceString.indexOf(targetString) !=\n-                sourceString.lastIndexOf(targetString))\n-                failCount++;\n-        }\n-\n-        report(\"IndexOf vs LastIndexOf       \", failCount);\n+    report(\"Exhaustive                   \", failCount);\n+  }\n+\n+  private static void simpleTest() {\n+    int failCount = 0;\n+    String sourceString;\n+    StringBuffer sourceBuffer;\n+    String targetString;\n+\n+    for (int i = 0; i < 10000; i++) {\n+      do {\n+        sourceString = generateTestString(99, 100);\n+        sourceBuffer = new StringBuffer(sourceString);\n+        targetString = generateTestString(10, 11);\n+      } while (sourceString.indexOf(targetString) != -1);\n+\n+      int index1 = generator.nextInt(90) + 5;\n+      sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n+\n+      if ((sourceBuffer.indexOf(targetString) != index1) ||\n+          (index1 != naiveFind(sourceBuffer.toString(), targetString, 0)))\n+        failCount++;\n+      if ((sourceBuffer.indexOf(targetString, 5) != index1) ||\n+          (index1 != naiveFind(sourceBuffer.toString(), targetString, 0)))\n+        failCount++;\n+      if ((sourceBuffer.indexOf(targetString, 99) == index1) ||\n+          (index1 != naiveFind(sourceBuffer.toString(), targetString, 0)))\n+        failCount++;\n@@ -135,34 +162,35 @@\n-    private static void compareStringStringBuffer() {\n-        int failCount = 0;\n-\n-        for (int x=0; x<10000; x++) {\n-            String testString = generateTestString(1, 100);\n-            int len = testString.length();\n-\n-            StringBuffer testBuffer = new StringBuffer(len);\n-            testBuffer.append(testString);\n-            if (!testString.equals(testBuffer.toString()))\n-                throw new RuntimeException(\"Initial equality failure\");\n-\n-            int x1 = 0;\n-            int x2 = 1000;\n-            while(x2 > testString.length()) {\n-                x1 = generator.nextInt(len);\n-                x2 = generator.nextInt(100);\n-                x2 = x1 + x2;\n-            }\n-            String fragment = testString.substring(x1,x2);\n-\n-            int sAnswer = testString.indexOf(fragment);\n-            int sbAnswer = testBuffer.indexOf(fragment);\n-\n-            if (sAnswer != sbAnswer)\n-                failCount++;\n-\n-            int testIndex = getRandomIndex(-100, 100);\n-\n-            sAnswer = testString.indexOf(fragment, testIndex);\n-            sbAnswer = testBuffer.indexOf(fragment, testIndex);\n-\n-            if (sAnswer != sbAnswer)\n-                failCount++;\n+    report(\"Basic Test                   \", failCount);\n+  }\n+\n+  \/\/ Note: it is possible although highly improbable that failCount will\n+  \/\/ be > 0 even if everthing is working ok\n+  private static void compareIndexOfLastIndexOf() {\n+    int failCount = 0;\n+    String sourceString;\n+    StringBuffer sourceBuffer;\n+    String targetString;\n+\n+    for (int i = 0; i < 10000; i++) {\n+      do {\n+        sourceString = generateTestString(99, 100);\n+        sourceBuffer = new StringBuffer(sourceString);\n+        targetString = generateTestString(10, 11);\n+      } while (sourceString.indexOf(targetString) != -1);\n+\n+      int index1 = generator.nextInt(100);\n+      sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n+\n+      \/\/ extremely remote possibility of > 1 match\n+      int matches = 0;\n+      int index2 = -1;\n+      while ((index2 = sourceBuffer.indexOf(targetString, index2 + 1)) != -1)\n+        matches++;\n+      if (matches > 1)\n+        continue;\n+\n+      if (sourceBuffer.indexOf(targetString) != sourceBuffer.lastIndexOf(targetString))\n+        failCount++;\n+      sourceString = sourceBuffer.toString();\n+      if (sourceString.indexOf(targetString) != sourceString.lastIndexOf(targetString))\n+        failCount++;\n+    }\n@@ -170,2 +198,76 @@\n-            sAnswer = testString.lastIndexOf(fragment);\n-            sbAnswer = testBuffer.lastIndexOf(fragment);\n+    report(\"IndexOf vs LastIndexOf       \", failCount);\n+  }\n+\n+  private static void compareStringStringBuffer() {\n+    int failCount = 0;\n+    boolean make_new = true;\n+\n+    String fragment = null;\n+    StringBuffer testBuffer = null;\n+    String testString = null;\n+    int testIndex = 0;\n+\n+    for (int x = 0; x < 1000000; x++) {\n+      if (make_new) {\n+          testString = generateTestString(1, 100);\n+          int len = testString.length();\n+\n+          testBuffer = new StringBuffer(len);\n+          testBuffer.append(testString);\n+          if (!testString.equals(testBuffer.toString()))\n+          throw new RuntimeException(\"Initial equality failure\");\n+\n+          int x1 = 0;\n+          int x2 = 1000;\n+          while (x2 > testString.length()) {\n+          x1 = generator.nextInt(len);\n+          x2 = generator.nextInt(100);\n+          x2 = x1 + x2;\n+          }\n+          fragment = testString.substring(x1, x2);\n+      }\n+\n+      int sAnswer = testString.indexOf(fragment);\n+      int sbAnswer = testBuffer.indexOf(fragment);\n+\n+      if (sAnswer != sbAnswer) {\n+        System.err.println(\"IndexOf fragment '\" + fragment + \"' (\" + fragment.length() + \") len String = \"\n+            + testString.length() + \" len Buffer = \" + testBuffer.length());\n+        System.err.println(\"  sAnswer = \" + sAnswer + \", sbAnswer = \" + sbAnswer);\n+        System.err.println(\"  testString = '\" + testString + \"'\");\n+        System.err.println(\"  testBuffer = '\" + testBuffer + \"'\");\n+        failCount++;\n+      } else {\n+        if (sAnswer > testString.length()) {\n+          System.err.println(\n+              \"IndexOf returned value out of range; return: \" + sAnswer + \" length max: \" + testBuffer.length());\n+        }\n+      }\n+\n+      if ((fragment == \"0#:02\/62;+-\\\"\\\"0$25-5$#)1263\") && (testBuffer.length() == 94)) {\n+        String xx = \"abc\";\n+        String yy = \"abcdefg\";\n+        int sA = xx.indexOf(yy);\n+      }\n+\n+      if (make_new) testIndex = getRandomIndex(-100, 100);\n+\n+      sAnswer = testString.indexOf(fragment, testIndex);\n+      sbAnswer = testBuffer.indexOf(fragment, testIndex);\n+\n+      if (sAnswer != sbAnswer) {\n+        System.err.println(\"IndexOf fragment '\" + fragment + \"' (\" + fragment.length() + \") index = \" + testIndex\n+            + \" len String = \" + testString.length() + \" len Buffer = \" + testBuffer.length());\n+        System.err.println(\"  sAnswer = \" + sAnswer + \", sbAnswer = \" + sbAnswer);\n+        System.err.println(\"  testString = '\" + testString + \"'\");\n+        System.err.println(\"  testBuffer = '\" + testBuffer + \"'\");\n+        failCount++;\n+        make_new = false;\n+      } else {\n+        if ((sAnswer > testString.length()) || ((sAnswer != -1) && (sAnswer < testIndex) && (fragment.length() != 0))) {\n+          System.err.println(\"IndexOf returned value out of range; return: \" + sAnswer + \" length max: \"\n+              + testString.length() + \" index: \" + testIndex);\n+          System.err.println(\"IndexOf fragment '\" + fragment + \"' (\" + fragment.length() + \") index = \" + testIndex\n+              + \" len String = \" + testString.length() + \" len Buffer = \" + testBuffer.length());\n+        }\n+      }\n@@ -173,2 +275,2 @@\n-            if (sAnswer != sbAnswer)\n-                failCount++;\n+      sAnswer = testString.lastIndexOf(fragment);\n+      sbAnswer = testBuffer.lastIndexOf(fragment);\n@@ -176,1 +278,6 @@\n-            testIndex = getRandomIndex(-100, 100);\n+      if (sAnswer != sbAnswer) {\n+        System.err.println(\"lastIndexOf fragment '\" + fragment + \"' len String = \" + testString.length()\n+            + \" len Buffer = \" + testBuffer.length());\n+        System.err.println(\"  sAnswer = \" + sAnswer + \", sbAnswer = \" + sbAnswer);\n+        failCount++;\n+      }\n@@ -178,2 +285,1 @@\n-            sAnswer = testString.lastIndexOf(fragment, testIndex);\n-            sbAnswer = testBuffer.lastIndexOf(fragment, testIndex);\n+      if (make_new) testIndex = getRandomIndex(-100, 100);\n@@ -181,3 +287,2 @@\n-            if (sAnswer != sbAnswer)\n-                failCount++;\n-        }\n+      sAnswer = testString.lastIndexOf(fragment, testIndex);\n+      sbAnswer = testBuffer.lastIndexOf(fragment, testIndex);\n@@ -185,1 +290,5 @@\n-        report(\"String vs StringBuffer       \", failCount);\n+      if (sAnswer != sbAnswer) {\n+        System.err.println(\"lastIndexOf fragment '\" + fragment + \"' index = \" + testIndex + \" len String = \"\n+            + testString.length() + \" len Buffer = \" + testBuffer.length());\n+        failCount++;\n+      }\n@@ -188,0 +297,3 @@\n+    report(\"String vs StringBuffer       \", failCount);\n+  }\n+\n","filename":"test\/jdk\/java\/lang\/StringBuffer\/IndexOf.java","additions":246,"deletions":134,"binary":false,"changes":380,"status":"modified"}]}