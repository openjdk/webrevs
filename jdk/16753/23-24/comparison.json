{"files":[{"patch":"@@ -28,1 +28,1 @@\n-#include \"asm\/assembler.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n@@ -158,3 +158,0 @@\n-static void preload_needle_helper(int size, Register needle, Register needleVal,\n-                                  StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm);\n-\n@@ -886,1 +883,1 @@\n-      __ cmpq(rScratch, 0x20);\n+      __ cmpq(nMinusK, 0x20);\n@@ -1462,76 +1459,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ Helper for loading needle elements to a register for compares\n-\/\/ Loads the proper number of bytes from the needle into needleVal\n-\/\/ based on the total size of the needle.\n-\/\/\n-\/\/ Parameters:\n-\/\/ size - The size of the needle in bytes\n-\/\/ needle - the address of the first byte of the needle\n-\/\/ needleVal - The bytes of the needle are loaded into this regiater\n-\/\/ ae - the argument encodings\n-\/\/ _masm - Current MacroAssembler instance pointer\n-\/\/\n-\/\/ Returns correctly-sized needle bytes in needleVal\n-\n-static void preload_needle_helper(int size, Register needle, Register needleVal,\n-                                  StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm) {\n-  \/\/ Pre-load the value (correctly sized) of the needle for comparison purposes.\n-\n-  assert_different_registers(needle, needleVal);\n-\n-  bool isUL = (ae == StrIntrinsicNode::UL);\n-  bool isUU = (ae == StrIntrinsicNode::UU);\n-  bool isU = isUL || isUU;  \/\/ At least one is UTF-16\n-\n-  int bytesAlreadyCompared = 0;\n-  int bytesLeftToCompare = 0;\n-  int offsetOfFirstByteToCompare = 0;\n-\n-  \/\/ The algorithm pre-validates that the first 2 and last elements of the needle\n-  \/\/ compare equal, so no need to re-compare those elements\n-  bytesAlreadyCompared = isU ? 6 : 3;\n-  offsetOfFirstByteToCompare = isU ? 4 : 2;\n-\n-  bytesLeftToCompare = size - bytesAlreadyCompared;\n-  assert((bytesLeftToCompare <= 7), \"Too many bytes left to compare\");\n-\n-  if (bytesLeftToCompare <= 0) {\n-    return;\n-  }\n-\n-  \/\/ At this point, there is at least one byte of the needle that needs to be\n-  \/\/ compared to the haystack.\n-\n-  \/\/ Coordinate the offsets here with the switch in byte_compare_helper\n-  \/\/ For UTF-16 needles, needle size will always be even (4, 6, 8, and 10)\n-  switch (bytesLeftToCompare) {\n-  case 1:\n-  case 2:\n-    \/\/ Needle size of 4 and 5 bytes - safe to re-compare 2 additional bytes\n-    __ movl(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n-    break;\n-\n-  case 3:\n-  case 4:\n-    \/\/ Needle size 6 and 7\n-    __ movl(needleVal, Address(needle, offsetOfFirstByteToCompare));\n-    break;\n-\n-  case 5:\n-  case 6:\n-    \/\/ Needle size 8 and 9 bytes - safe to re-compare 2 additional bytes\n-    __ movq(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n-    break;\n-\n-  case 7:\n-    \/\/ Needle size 10\n-    __ movq(needleVal, Address(needle, offsetOfFirstByteToCompare));\n-    break;\n-\n-  default:\n-    break;\n-  }\n-}\n-\n@@ -1548,1 +1469,1 @@\n-\/\/ needleVal - The bytes of the needle to compare (see preload_needle_helper)\n+\/\/ needleVal - The bytes of the needle to compare\n@@ -1600,4 +1521,0 @@\n-  \/\/ Load in the correct sized needle value for comparison.  Used when checking\n-  \/\/ bytes of the haystack after first\/second\/last have compared equal.\n-  preload_needle_helper(size, needle, needleVal, ae, _masm);\n-\n@@ -1608,1 +1525,0 @@\n-  \/\/ Coordinate this with preload_needle_helper\n@@ -1613,0 +1529,1 @@\n+    __ movl(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n@@ -1621,0 +1538,1 @@\n+    __ movl(needleVal, Address(needle, offsetOfFirstByteToCompare));\n@@ -1628,0 +1546,1 @@\n+    __ movq(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n@@ -1635,0 +1554,1 @@\n+    __ movq(needleVal, Address(needle, offsetOfFirstByteToCompare));\n@@ -1638,0 +1558,1 @@\n+\n@@ -1667,2 +1588,2 @@\n-\/\/ mask - Used to hold comparison mask - must be saved\/restored\n-\/\/ tmp - Temporary register - must be saved\/restored\n+\/\/ mask - Used to hold comparison mask\n+\/\/ tmp - Temporary register\n@@ -1699,5 +1620,0 @@\n-  \/\/ Since this code is generated before state is saved, we need to save\/restore\n-  \/\/ the used registers.\n-  __ push(mask);\n-  __ push(tmp);\n-\n@@ -1785,2 +1701,0 @@\n-  __ pop(tmp);\n-  __ pop(mask);\n@@ -1866,1 +1780,1 @@\n-    for (int i = (isUU ? 3 : 6); i < NUMBER_OF_CASES; i++) {\n+    for (int i = 6; i < NUMBER_OF_CASES; i++) {\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_string.cpp","additions":11,"deletions":97,"binary":false,"changes":108,"status":"modified"}]}