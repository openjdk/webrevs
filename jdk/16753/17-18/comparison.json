{"files":[{"patch":"@@ -32,0 +32,1 @@\n+#include <functional>\n@@ -121,2 +122,2 @@\n-#define COPIED_HAYSTACK_STACK_OFFSET (0x0)  \/\/ MUST BE ZERO!\n-#define COPIED_HAYSTACK_STACK_SIZE (64)     \/\/ MUST BE 64!\n+#  define COPIED_HAYSTACK_STACK_OFFSET (0x0)  \/\/ MUST BE ZERO!\n+#  define COPIED_HAYSTACK_STACK_SIZE (64)     \/\/ MUST BE 64!\n@@ -124,3 +125,2 @@\n-#define EXPANDED_NEEDLE_STACK_OFFSET \\\n-  (COPIED_HAYSTACK_STACK_OFFSET + COPIED_HAYSTACK_STACK_SIZE)\n-#define EXPANDED_NEEDLE_STACK_SIZE (MAX_NEEDLE_LEN_TO_EXPAND * 2 + 32)\n+#  define EXPANDED_NEEDLE_STACK_OFFSET (COPIED_HAYSTACK_STACK_OFFSET + COPIED_HAYSTACK_STACK_SIZE)\n+#  define EXPANDED_NEEDLE_STACK_SIZE (MAX_NEEDLE_LEN_TO_EXPAND * 2 + 32)\n@@ -128,3 +128,2 @@\n-#define SAVED_HAYSTACK_STACK_OFFSET \\\n-  (EXPANDED_NEEDLE_STACK_OFFSET + EXPANDED_NEEDLE_STACK_SIZE)\n-#define SAVED_HAYSTACK_STACK_SIZE (8)\n+#  define SAVED_HAYSTACK_STACK_OFFSET (EXPANDED_NEEDLE_STACK_OFFSET + EXPANDED_NEEDLE_STACK_SIZE)\n+#  define SAVED_HAYSTACK_STACK_SIZE (8)\n@@ -132,3 +131,2 @@\n-#define SAVED_INCREMENT_STACK_OFFSET \\\n-  (SAVED_HAYSTACK_STACK_OFFSET + SAVED_HAYSTACK_STACK_SIZE)\n-#define SAVED_INCREMENT_STACK_SIZE (8)\n+#  define SAVED_INCREMENT_STACK_OFFSET (SAVED_HAYSTACK_STACK_OFFSET + SAVED_HAYSTACK_STACK_SIZE)\n+#  define SAVED_INCREMENT_STACK_SIZE (8)\n@@ -136,3 +134,2 @@\n-#define SAVED_TERM_ADDR_STACK_OFFSET \\\n-  (SAVED_INCREMENT_STACK_OFFSET + SAVED_INCREMENT_STACK_SIZE)\n-#define SAVED_TERM_ADDR_STACK_SIZE (8)\n+#  define SAVED_TERM_ADDR_STACK_OFFSET (SAVED_INCREMENT_STACK_OFFSET + SAVED_INCREMENT_STACK_SIZE)\n+#  define SAVED_TERM_ADDR_STACK_SIZE (8)\n@@ -140,4 +137,3 @@\n-#define STACK_SPACE                                          \\\n-  (COPIED_HAYSTACK_STACK_SIZE + EXPANDED_NEEDLE_STACK_SIZE + \\\n-   SAVED_HAYSTACK_STACK_SIZE + SAVED_INCREMENT_STACK_SIZE +  \\\n-   SAVED_TERM_ADDR_STACK_SIZE)\n+#  define STACK_SPACE                                                                                                  \\\n+    (COPIED_HAYSTACK_STACK_SIZE + EXPANDED_NEEDLE_STACK_SIZE + SAVED_HAYSTACK_STACK_SIZE + SAVED_INCREMENT_STACK_SIZE  \\\n+     + SAVED_TERM_ADDR_STACK_SIZE)\n@@ -149,22 +145,4 @@\n-\/\/ Helper for broadcasting needle elements to ymm registers for compares\n-\/\/\n-\/\/ For UTF-16 encoded needles, broadcast a word at the proper offset to the ymm\n-\/\/ register (case UU)\n-\/\/ For the UTF-16 encoded haystack with Latin1 encoded needle (case UL) we have\n-\/\/ to read into a temp register to zero-extend the single byte needle value, then\n-\/\/ broadcast words to the ymm register.\n-\/\/\n-\/\/ Parameters:\n-\/\/ sizeKnown - True if size known at compile time\n-\/\/ size - the size of the needle.  Pass 0 if unknown at compile time\n-\/\/ bytesToCompare - see NUMBER_OF_NEEDLE_BYTES_TO_COMPARE above\n-\/\/ needle - the address of the first byte of the needle\n-\/\/ needleLen - length of needle if !sizeKnown\n-\/\/ isUU and isUL - true if argument encoding is UU or UL, respectively\n-\/\/ _masm - Current MacroAssembler instance pointer\n-static void broadcast_additional_needles(bool sizeKnown, int size,\n-                                         int bytesToCompare, Register needle,\n-                                         Register needleLen, Register rTmp,\n-                                         bool isUU, bool isUL,\n-                                         MacroAssembler* _masm) {\n-  Label L_done;\n+\/\/ Forward declarations for helper functions\n+static void broadcast_additional_needles(bool sizeKnown, int size, int bytesToCompare, Register needle,\n+                                         Register needleLen, Register rTmp, bool isUU, bool isUL,\n+                                         MacroAssembler *_masm);\n@@ -172,1 +150,4 @@\n-  assert_different_registers(needle, needleLen, rTmp);\n+static void compare_big_haystack_to_needle(bool sizeKnown, int size, int bytesToCompare, Label &noMatch,\n+                                           Register haystack, Register hsLen, Register needleLen, bool isU,\n+                                           bool doEarlyBailout, Register eq_mask, Register rTmp, Register nMinusK,\n+                                           MacroAssembler *_masm);\n@@ -174,4 +155,3 @@\n-#undef byte_1\n-#define byte_1 XMM_BYTE_1\n-#undef byte_2\n-#define byte_2 XMM_BYTE_2\n+static void compare_haystack_to_needle(bool sizeKnown, int size, int bytesToCompare, Label &noMatch, Register haystack,\n+                                       bool isU, bool doEarlyBailout, Register eq_mask, Register needleLen,\n+                                       Register rTmp, MacroAssembler *_masm);\n@@ -179,1 +159,3 @@\n-  bool isU = (isUU || isUL);\n+static void big_case_loop_helper(bool sizeKnown, int size, Label &noMatch, Label &loop_top, Register eq_mask,\n+                                 Register hsPtrRet, Register needleLen, StrIntrinsicNode::ArgEncoding ae,\n+                                 MacroAssembler *_masm);\n@@ -181,1 +163,2 @@\n-  size = sizeKnown ? size : NUMBER_OF_CASES + 1;\n+static void preload_needle_helper(int size, Register needle, Register needleVal, StrIntrinsicNode::ArgEncoding ae,\n+                                  MacroAssembler *_masm);\n@@ -183,5 +166,3 @@\n-  if (bytesToCompare > 2) {\n-    if (!sizeKnown) {\n-      __ cmpq(needleLen, (isU ? 4 : 2));\n-      __ jl_b(L_done);\n-    }\n+static void byte_compare_helper(int size, Label &L_noMatch, Label &L_matchFound, Register needle, Register needleVal,\n+                                Register haystack, Register mask, Register foundIndex, Register tmp,\n+                                StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm);\n@@ -189,13 +170,3 @@\n-    if (size > (isU ? 4 : 2)) {\n-      \/\/ Add compare for second byte\n-      if (isUU) {\n-        __ vpbroadcastw(byte_1, Address(needle, 2), Assembler::AVX_256bit);\n-      } else if (isUL) {\n-        __ movzbl(rTmp, Address(needle, 1));\n-        __ movdl(byte_1, rTmp);\n-        \/\/ 1st byte of needle in words\n-        __ vpbroadcastw(byte_1, byte_1, Assembler::AVX_256bit);\n-      } else {\n-        __ vpbroadcastb(byte_1, Address(needle, 1), Assembler::AVX_256bit);\n-      }\n-    }\n+static void highly_optimized_short_cases(StrIntrinsicNode::ArgEncoding ae, Register haystack, Register haystack_len,\n+                                         Register needle, Register needle_len, XMMRegister XMM0, XMMRegister XMM1,\n+                                         Register mask, Register tmp, MacroAssembler *_masm);\n@@ -203,5 +174,2 @@\n-    if (bytesToCompare > 3) {\n-      if (!sizeKnown) {\n-        __ cmpq(needleLen, (isU ? 6 : 3));\n-        __ jl_b(L_done);\n-      }\n+static void setup_jump_tables(StrIntrinsicNode::ArgEncoding ae, Label &L_error, Label &L_checkRange, Label &L_fixup,\n+                              address *jump_table, address *jump_table_1, MacroAssembler *_masm);\n@@ -209,16 +177,5 @@\n-      if (size > (isU ? 6 : 3)) {\n-        \/\/ Add compare for third byte\n-        if (isUU) {\n-          __ vpbroadcastw(byte_2, Address(needle, 4), Assembler::AVX_256bit);\n-      } else if (isUL) {\n-        __ movzbl(rTmp, Address(needle, 2));\n-        __ movdl(byte_1, rTmp);\n-        \/\/ 1st byte of needle in words\n-        __ vpbroadcastw(byte_1, byte_1, Assembler::AVX_256bit);\n-        } else {\n-          __ vpbroadcastb(byte_2, Address(needle, 2), Assembler::AVX_256bit);\n-        }\n-      }\n-    }\n-    __ bind(L_done);\n-  }\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/                         Start of generator\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n@@ -226,2 +183,10 @@\n-#undef byte_1\n-#undef byte_2\n+void StubGenerator::generate_string_indexof(address *fnptrs) {\n+  assert((int) StrIntrinsicNode::LL < 4, \"Enum out of range\");\n+  assert((int) StrIntrinsicNode::UL < 4, \"Enum out of range\");\n+  assert((int) StrIntrinsicNode::UU < 4, \"Enum out of range\");\n+  generate_string_indexof_stubs(fnptrs, StrIntrinsicNode::LL);\n+  generate_string_indexof_stubs(fnptrs, StrIntrinsicNode::UL);\n+  generate_string_indexof_stubs(fnptrs, StrIntrinsicNode::UU);\n+  assert(fnptrs[StrIntrinsicNode::LL] != nullptr, \"LL not generated.\");\n+  assert(fnptrs[StrIntrinsicNode::UL] != nullptr, \"UL not generated.\");\n+  assert(fnptrs[StrIntrinsicNode::UU] != nullptr, \"UU not generated.\");\n@@ -230,29 +195,7 @@\n-\/\/ Helper for comparing needle elements to a big haystack\n-\/\/\n-\/\/ This helper compares bytes or words in the ymm registers to\n-\/\/ the proper positions within the haystack.  It will bail out early if\n-\/\/ doEarlyBailout is true, otherwise it will progressively and together\n-\/\/ the comparison results, returning the answer at the end.\n-\/\/\n-\/\/ On return, eq_mask will be set to the comparison mask value.  If no match\n-\/\/ is found, this helper will jump to noMatch.\n-\/\/\n-\/\/ Parameters:\n-\/\/ sizeKnown - True if size known at compile time\n-\/\/ size - the size of the needle.  Pass 0 if unknown at compile time\n-\/\/ bytesToCompare - see NUMBER_OF_NEEDLE_BYTES_TO_COMPARE above\n-\/\/ noMatch - label bound outside to jump to if there is no match\n-\/\/ haystack - the address of the first byte of the haystack\n-\/\/ hsLen - the sizeof the haystack\n-\/\/ isU - true if argument encoding is either UU or UL\n-\/\/ doEarlyBailout - if true, check mismatch after every comparison\n-\/\/ eq_mask - The bit mask returned that holds the result of the comparison\n-\/\/ rTmp - a temporary register\n-\/\/ nMinusK - Size of haystack minus size of needle\n-\/\/ _masm - Current MacroAssembler instance pointer\n-\/\/\n-\/\/ If (n - k) < 32, need to handle reading past end of haystack\n-static void compare_big_haystack_to_needle(bool sizeKnown,\n-    int size, int bytesToCompare, Label& noMatch, Register haystack,\n-    Register hsLen, Register needleLen, bool isU, bool doEarlyBailout, Register eq_mask,\n-    Register rTmp, Register nMinusK, MacroAssembler* _masm) {\n+void StubGenerator::generate_string_indexof_stubs(address *fnptrs, StrIntrinsicNode::ArgEncoding ae) {\n+  StubCodeMark mark(this, \"StubRoutines\", \"stringIndexOf\");\n+  bool isLL = (ae == StrIntrinsicNode::LL);\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = isUL || isUU;  \/\/ At least one is UTF-16\n+  assert(isLL || isUL || isUU, \"Encoding not recognized\");\n@@ -260,2 +203,6 @@\n-  assert_different_registers(eq_mask, haystack, needleLen, rTmp, hsLen, r10);\n-  assert(r10 == nMinusK, \"Bad register\");\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/                         AVX2 code\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  if (VM_Version::supports_avx2()) {  \/\/ AVX2 version\n@@ -263,15 +210,23 @@\n-#undef byte_0\n-#define byte_0 XMM_BYTE_0\n-#undef byte_k\n-#define byte_k XMM_BYTE_K\n-#undef byte_1\n-#define byte_1 XMM_BYTE_1\n-#undef byte_2\n-#define byte_2 XMM_BYTE_2\n-#undef cmp_0\n-#define cmp_0 XMM_TMP3\n-#undef cmp_k\n-#define cmp_k XMM_TMP4\n-#undef lastCompare\n-#define lastCompare rTmp\n-#undef lastMask\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/                         Code generation explanation:\n+    \/\/\n+    \/\/  The generator will generate code for three cases:\n+    \/\/  1. Both needle and haystack are Latin-1 (single byte) encoded (LL)\n+    \/\/  2. Both the needle and haystack are UTF-16 encoded (two bytes per character) (UU)\n+    \/\/  3. The haystack is UTF-16 encoded and the needle is Latin-1 encoded (UL)\n+    \/\/\n+    \/\/  The case of the haystack being Latin-1 and the needle being UTF-16 is short-circuited\n+    \/\/  so that we never get called in this case.\n+    \/\/\n+    \/\/  For the UL case (haystack UTF-16 and needle Latin-1), the needle will be expanded\n+    \/\/  onto the stack (for size <= MAX_NEEDLE_LEN_TO_EXPAND) and the UU code will do the work.\n+    \/\/  For UL where the needle size is > MAX_NEEDLE_LEN_TO_EXPAND, we default to a\n+    \/\/  byte-by-byte comparison (this will be rare).\n+    \/\/\n+    \/\/  Note that the code assumes MAX_NEEDLE_LEN_TO_EXPAND is >= 32.\n+    \/\/\n+    \/\/  The UU and LL cases are identical except for the loop increments and loading\n+    \/\/  of the characters into registers.  UU loads and compares words, LL - bytes.\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n@@ -279,2 +234,4 @@\n-  int sizeIncr = isU ? 2 : 1;\n-  bool needToSaveRCX = false;\n+    const Register haystack     = rdi;\n+    const Register haystack_len = rsi;\n+    const Register needle       = rdx;\n+    const Register needle_len   = rcx;\n@@ -282,2 +239,1 @@\n-  needToSaveRCX = (haystack == rcx) || (hsLen == rcx) || (eq_mask == rcx) ||\n-                  (rTmp == rcx) || (needleLen == rcx) || (nMinusK == rcx);\n+    const Register save_ndl_len = r12;\n@@ -285,1 +241,8 @@\n-  Label L_OKtoCompareFull, L_done, L_specialCase_gt2, L_specialCase_gt3;\n+    const XMMRegister byte_0    = XMM_BYTE_0;\n+    const XMMRegister byte_k    = XMM_BYTE_K;\n+    const XMMRegister byte_1    = XMM_BYTE_1;\n+    const XMMRegister byte_2    = XMM_BYTE_2;\n+    const XMMRegister xmm_tmp1  = XMM_TMP1;\n+    const XMMRegister xmm_tmp2  = XMM_TMP2;\n+    const XMMRegister xmm_tmp3  = XMM_TMP3;\n+    const XMMRegister xmm_tmp4  = XMM_TMP4;\n@@ -287,1 +250,10 @@\n-  assert(!sizeKnown || (sizeKnown && ((size > 0) && (size <= NUMBER_OF_CASES))), \"Incorrect size given\");\n+    const XMMRegister save_r12  = xmm4;\n+    const XMMRegister save_r13  = xmm5;\n+    const XMMRegister save_r14  = xmm6;\n+    const XMMRegister save_r15  = xmm7;\n+    const XMMRegister save_rbx  = xmm8;\n+    \/\/ xmm registers more valuable in inner loops...\n+    \/\/ const XMMRegister save_rsi  = xmm9;\n+    \/\/ const XMMRegister save_rdi  = xmm10;\n+    \/\/ const XMMRegister save_rcx  = xmm11;\n+    \/\/ const XMMRegister save_r8   = xmm12;\n@@ -289,4 +261,3 @@\n-  Address kThByte =\n-      sizeKnown ? Address(haystack, size - sizeIncr)\n-                : Address(haystack, needleLen, Address::times_1, -(sizeIncr));\n-  size = sizeKnown ? size : NUMBER_OF_CASES + 1;\n+    \/\/ Addresses of the two jump tables used for small needle processing\n+    address jump_table;\n+    address jump_table_1;\n@@ -294,6 +265,1 @@\n-  \/\/ Compare first byte of needle to haystack\n-  if (isU) {\n-    __ vpcmpeqw(cmp_0, byte_0, Address(haystack, 0), Assembler::AVX_256bit);\n-  } else {\n-    __ vpcmpeqb(cmp_0, byte_0, Address(haystack, 0), Assembler::AVX_256bit);\n-  }\n+    Label L_begin;\n@@ -301,5 +267,5 @@\n-  if (doEarlyBailout) {\n-    __ vpmovmskb(eq_mask, cmp_0, Assembler::AVX_256bit);\n-    __ testl(eq_mask, eq_mask);\n-    __ je(noMatch);\n-  }\n+    Label L_returnRBP, L_checkRangeAndReturn, L_returnError;\n+    Label L_bigCaseFixupAndReturn, L_checkRangeAndReturnRCX;\n+    Label L_returnZero, L_copyHaystackToStackDone, L_bigSwitchTop;\n+    Label L_bigCaseDefault, L_smallCaseDefault, L_copyHaystackToStack, L_smallSwitchTop;\n+    Label L_nextCheck, L_checksPassed, L_zeroCheckFailed;\n@@ -307,6 +273,2 @@\n-  if (size == (isU ? 2 : 1)) {\n-    __ vpmovmskb(eq_mask, cmp_0, Assembler::AVX_256bit);\n-  } else {\n-    __ cmpq(nMinusK, 32);\n-    __ jae(L_OKtoCompareFull);\n-    __ vpmovmskb(eq_mask, cmp_0, Assembler::AVX_256bit);\n+    Label L_wcharBegin, L_continue, L_wideNoExpand, L_copyDone, L_copyHigh;\n+    Label L_wideMidLoop, L_wideTopLoop, L_wideInnerLoop, L_wideFound;\n@@ -314,13 +276,5 @@\n-    \/\/ If n-k less than 32, comparing the last byte of the needle will result\n-    \/\/ in reading past the end of the haystack.  Account for this here.\n-    __ leaq(lastCompare, Address(haystack, hsLen, Address::times_1, -32));\n-#undef cmp_0\n-#undef saveRCX\n-#define saveRCX XMM_TMP3\n-    if (needToSaveRCX) {\n-      __ movdq(saveRCX, rcx);\n-    }\n-#undef shiftVal\n-#define shiftVal rcx\n-    __ movq(shiftVal, isU ? 30 : 31);\n-    __ subq(shiftVal, nMinusK);\n+    __ align(CodeEntryAlignment);\n+    fnptrs[isLL   ? StrIntrinsicNode::LL\n+           : isUU ? StrIntrinsicNode::UU\n+                  : StrIntrinsicNode::UL] = __ pc();\n+    __ enter();  \/\/ required for proper stackwalking of RuntimeStub frame\n@@ -328,17 +282,7 @@\n-    if (isU) {\n-      __ vpcmpeqw(cmp_k, byte_k, Address(lastCompare, 0),\n-                  Assembler::AVX_256bit);\n-    } else {\n-      __ vpcmpeqb(cmp_k, byte_k, Address(lastCompare, 0),\n-                  Assembler::AVX_256bit);\n-    }\n-#undef lastCompare\n-#define lastMask rTmp\n-    __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n-    __ shrq(lastMask);\n-#undef shiftVal\n-    __ andq(eq_mask, lastMask);\n-    if (needToSaveRCX) {\n-      __ movdq(rcx, saveRCX);\n-    }\n-#undef saveRCX\n+    \/\/ Check for trivial cases\n+    \/\/ needle length == 0?\n+    __ cmpq(needle_len, 0);\n+    __ jg_b(L_nextCheck);\n+    __ xorq(rax, rax);\n+    __ leave();\n+    __ ret(0);\n@@ -346,19 +290,4 @@\n-    if (bytesToCompare > 2) {\n-      if (size > (isU ? 4 : 2)) {\n-        if (doEarlyBailout) {\n-          __ testl(eq_mask, eq_mask);\n-          __ je(noMatch);\n-        }\n-        __ cmpq(hsLen, isU ? 34 : 33);\n-        __ jl(L_specialCase_gt2);\n-        if (isU) {\n-          __ vpcmpeqw(cmp_k, byte_1, Address(haystack, 2),\n-                      Assembler::AVX_256bit);\n-        } else {\n-          __ vpcmpeqb(cmp_k, byte_1, Address(haystack, 1),\n-                      Assembler::AVX_256bit);\n-        }\n-        __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n-        __ andq(eq_mask, lastMask);\n-      }\n-    }\n+    \/\/ haystack length == 0?\n+    __ bind(L_nextCheck);\n+    __ testq(haystack_len, haystack_len);\n+    __ je(L_zeroCheckFailed);\n@@ -366,20 +295,4 @@\n-    if (bytesToCompare > 3) {\n-      if (size > (isU ? 6 : 3)) {\n-        if (doEarlyBailout) {\n-          __ testl(eq_mask, eq_mask);\n-          __ je(noMatch);\n-        }\n-        __ cmpq(hsLen, isU ? 36 : 34);\n-        __ jl(L_specialCase_gt3);\n-        if (isU) {\n-          __ vpcmpeqw(cmp_k, byte_2, Address(haystack, 4),\n-                      Assembler::AVX_256bit);\n-        } else {\n-          __ vpcmpeqb(cmp_k, byte_2, Address(haystack, 2),\n-                      Assembler::AVX_256bit);\n-        }\n-        __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n-        __ andq(eq_mask, lastMask);\n-      }\n-    }\n-    __ jmpb(L_done);\n+    \/\/ haystack length >= needle length?\n+    __ movq(rax, haystack_len);\n+    __ subq(rax, needle_len);\n+    __ jge_b(L_checksPassed);\n@@ -387,10 +300,4 @@\n-    __ bind(L_specialCase_gt2);\n-    \/\/ Comparing multiple bytes and haystack length == 32\n-    if (isU) {\n-      __ vpcmpeqw(cmp_k, byte_1, Address(haystack, 0), Assembler::AVX_256bit);\n-    } else {\n-      __ vpcmpeqb(cmp_k, byte_1, Address(haystack, 0), Assembler::AVX_256bit);\n-    }\n-    __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n-    __ shrq(lastMask, isU ? 2 : 1);\n-    __ andq(eq_mask, lastMask);\n+    __ bind(L_zeroCheckFailed);\n+    __ movq(rax, -1);\n+    __ leave();\n+    __ ret(0);\n@@ -398,18 +305,1 @@\n-    if (bytesToCompare > 3) {\n-      if (size > (isU ? 6 : 3)) {\n-        if (doEarlyBailout) {\n-          __ testl(eq_mask, eq_mask);\n-          __ je(noMatch);\n-        }\n-        if (isU) {\n-          __ vpcmpeqw(cmp_k, byte_2, Address(haystack, 0),\n-                      Assembler::AVX_256bit);\n-        } else {\n-          __ vpcmpeqb(cmp_k, byte_2, Address(haystack, 0),\n-                      Assembler::AVX_256bit);\n-        }\n-        __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n-        __ shrq(lastMask, isU ? 4 : 2);\n-        __ andq(eq_mask, lastMask);\n-      }\n-    }\n+    __ bind(L_checksPassed);\n@@ -417,1 +307,5 @@\n-    __ jmp(L_done);\n+    \/\/ Check for highly-optimized ability - haystack <= 32 bytes and needle <= OPT_NEEDLE_SIZE_MAX\n+    \/\/ haystack_len is in elements, not bytes, for UTF-16\n+    __ cmpq(haystack_len, isU ? COPIED_HAYSTACK_STACK_SIZE \/ 4\n+                              : COPIED_HAYSTACK_STACK_SIZE \/ 2);\n+    __ ja(L_begin);\n@@ -419,10 +313,3 @@\n-    __ bind(L_specialCase_gt3);\n-    \/\/ Comparing multiple bytes and hs length == isU ? 34 : 33\n-    if (isU) {\n-      __ vpcmpeqw(cmp_k, byte_2, Address(haystack, 0), Assembler::AVX_256bit);\n-    } else {\n-      __ vpcmpeqb(cmp_k, byte_2, Address(haystack, 0), Assembler::AVX_256bit);\n-    }\n-    __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n-    __ shrq(lastMask, isU ? 4 : 2);\n-    __ andq(eq_mask, lastMask);\n+    \/\/ needle_len is in elements, not bytes, for UTF-16\n+    __ cmpq(needle_len, isUU ? OPT_NEEDLE_SIZE_MAX \/ 2 : OPT_NEEDLE_SIZE_MAX);\n+    __ ja(L_begin);\n@@ -430,1 +317,3 @@\n-    __ jmp(L_done);\n+    \/\/ Handle short haystack and needle specially\n+    \/\/ Generated code does not return - either found or not\n+    highly_optimized_short_cases(ae, haystack, haystack_len, needle, needle_len, xmm0, xmm1, r8, r9, _masm);\n@@ -432,0 +321,3 @@\n+    \/\/ Set up jump tables.  Used when needle size <= NUMBER_OF_CASES\n+    setup_jump_tables(ae, L_returnRBP, L_checkRangeAndReturn, L_bigCaseFixupAndReturn, &jump_table, &jump_table_1,\n+                      _masm);\n@@ -433,4 +325,3 @@\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    __ bind(L_OKtoCompareFull);\n-#define result XMM_TMP3\n-#define cmp_0 XMM_TMP3\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n@@ -438,5 +329,36 @@\n-    \/\/ Compare last byte of needle to haystack at proper position\n-    if (isU) {\n-      __ vpcmpeqw(cmp_k, byte_k, kThByte, Assembler::AVX_256bit);\n-    } else {\n-      __ vpcmpeqb(cmp_k, byte_k, kThByte, Assembler::AVX_256bit);\n+    __ bind(L_begin);\n+#ifdef PUSH_REGS\n+    __ push(r15);\n+    __ push(r14);\n+    __ push(r13);\n+    __ push(r12);\n+    __ push(rbx);\n+#else\n+    __ movdq(save_r12, r12);\n+    __ movdq(save_r13, r13);\n+    __ movdq(save_r14, r14);\n+    __ movdq(save_r15, r15);\n+    __ movdq(save_rbx, rbx);\n+#endif\n+#ifdef _WIN64\n+    __ push(rsi);\n+    __ push(rdi);\n+    __ push(rcx);\n+    __ push(r8);\n+    __ push(r9);\n+\n+    __ movq(rdi, rcx);\n+    __ movq(rsi, rdx);\n+    __ movq(rdx, r8);\n+    __ movq(rcx, r9);\n+#endif\n+\n+    __ push(rbp);\n+    __ subptr(rsp, STACK_SPACE);\n+\n+    \/\/ Assume failure\n+    __ movq(rbp, -1);\n+\n+    if (isUL) {\n+      \/\/ Branch out if doing wide chars\n+      __ jmp(L_wcharBegin);\n@@ -445,1 +367,4 @@\n-    __ vpand(result, cmp_k, cmp_0, Assembler::AVX_256bit);\n+    if (isUU) {  \/\/ Adjust sizes of hs and needle\n+      __ shlq(needle_len, 1);\n+      __ shlq(haystack_len, 1);\n+    }\n@@ -447,15 +372,17 @@\n-    if (bytesToCompare > 2) {\n-      if (size > (isU ? 4 : 2)) {\n-        if (doEarlyBailout) {\n-          __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n-          __ testl(eq_mask, eq_mask);\n-          __ je(noMatch);\n-        }\n-        if (isU) {\n-          __ vpcmpeqw(cmp_k, byte_1, Address(haystack, 2),\n-                      Assembler::AVX_256bit);\n-        } else {\n-          __ vpcmpeqb(cmp_k, byte_1, Address(haystack, 1),\n-                      Assembler::AVX_256bit);\n-        }\n-        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n+    \/\/ wide char processing comes here after expanding needle\n+    __ bind(L_continue);\n+    __ movq(r10, haystack_len);\n+    __ subq(r10, needle_len);\n+\n+    __ movq(save_ndl_len, needle_len);\n+    __ movq(r14, needle);\n+    __ movq(rbx, haystack);\n+\n+    {\n+      Label L_short;\n+\n+      \/\/ Always need needle broadcast to ymm registers\n+      if (isU) {\n+        __ vpbroadcastw(byte_0, Address(needle, 0), Assembler::AVX_256bit);\n+      } else {\n+        __ vpbroadcastb(byte_0, Address(needle, 0), Assembler::AVX_256bit);\n@@ -463,1 +390,0 @@\n-    }\n@@ -465,15 +391,7 @@\n-    if (bytesToCompare > 3) {\n-      if (size > (isU ? 6 : 3)) {\n-        if (doEarlyBailout) {\n-          __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n-          __ testl(eq_mask, eq_mask);\n-          __ je(noMatch);\n-        }\n-        if (isU) {\n-          __ vpcmpeqw(cmp_k, byte_2, Address(haystack, 4),\n-                      Assembler::AVX_256bit);\n-        } else {\n-          __ vpcmpeqb(cmp_k, byte_2, Address(haystack, 2),\n-                      Assembler::AVX_256bit);\n-        }\n-        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n+      __ cmpq(needle_len, isU ? 2 : 1);\n+      __ je_b(L_short);\n+\n+      if (isU) {\n+        __ vpbroadcastw(byte_k, Address(needle, needle_len, Address::times_1, -2), Assembler::AVX_256bit);\n+      } else {\n+        __ vpbroadcastb(byte_k, Address(needle, needle_len, Address::times_1, -1), Assembler::AVX_256bit);\n@@ -481,0 +399,2 @@\n+\n+      __ bind(L_short);\n@@ -483,2 +403,3 @@\n-    __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n-  }\n+    \/\/ Do \"big switch\" if haystack size >= 32\n+    __ cmpq(haystack_len, 0x20);\n+    __ jae_b(L_bigSwitchTop);\n@@ -486,16 +407,4 @@\n-  __ bind(L_done);\n-  __ testl(eq_mask, eq_mask);\n-  __ je(noMatch);\n-  \/\/ At this point, we have at least one \"match\" where first and last bytes\n-  \/\/ of the needle are found the correct distance apart.\n-#undef byte_0\n-#undef byte_k\n-#undef byte_1\n-#undef byte_2\n-#undef cmp_0\n-#undef cmp_k\n-#undef result\n-#undef lastCompare\n-#undef lastMask\n-#undef saveRCX\n-}\n+    \/\/ Copy the small (< 32 byte) haystack to the stack.  Allows for vector reads without page fault\n+    \/\/ Only done for small haystacks\n+    {\n+      Label L_moreThan16, L_adjustHaystack;\n@@ -503,33 +412,2 @@\n-\/\/ Helper for comparing needle elements to a small haystack\n-\/\/\n-\/\/ This helper compares bytes or words in the ymm registers to\n-\/\/ the proper positions within the haystack.  It will bail out early if\n-\/\/ doEarlyBailout is true, otherwise it will progressively and together\n-\/\/ the comparison results, returning the answer at the end.\n-\/\/\n-\/\/ On return, eq_mask will be set to the comparison mask value.  If no match\n-\/\/ is found, this helper will jump to noMatch.\n-\/\/\n-\/\/ Parameters:\n-\/\/ sizeKnown - if true, size is valid and needleLen invalid.\n-\/\/             if false, size invalid and needleLen valid.\n-\/\/ size - the size of the needle.  Pass 0 if unknown at compile time\n-\/\/ bytesToCompare - see NUMBER_OF_NEEDLE_BYTES_TO_COMPARE above\n-\/\/ noMatch - label bound outside to jump to if there is no match\n-\/\/ haystack - the address of the first byte of the haystack\n-\/\/ isU - true if argument encoding is either UU or UL\n-\/\/ doEarlyBailout - if true, check mismatch after every comparison\n-\/\/ eq_mask - The bit mask returned that holds the result of the comparison\n-\/\/ needleLen - a temporary register.  Only used if isUL true\n-\/\/ _masm - Current MacroAssembler instance pointer\n-\/\/\n-\/\/ No need to worry about reading past end of haystack since haystack\n-\/\/ has been copied to the stack\n-\/\/\n-\/\/ If !sizeKnown, needle is at least 11 bytes long\n-static void compare_haystack_to_needle(bool sizeKnown, int size,\n-                                       int bytesToCompare, Label& noMatch,\n-                                       Register haystack, bool isU,\n-                                       bool doEarlyBailout, Register eq_mask,\n-                                       Register needleLen, Register rTmp,\n-                                       MacroAssembler* _masm) {\n+      const Register index = rax;\n+      const Register haystack = rbx;\n@@ -537,1 +415,3 @@\n-  assert_different_registers(eq_mask, haystack, needleLen, rTmp, r10);\n+      __ bind(L_copyHaystackToStack);\n+      __ cmpq(haystack_len, 0x10);\n+      __ ja_b(L_moreThan16);\n@@ -539,14 +419,4 @@\n-#undef byte_0\n-#define byte_0 XMM_BYTE_0\n-#undef byte_k\n-#define byte_k XMM_BYTE_K\n-#undef byte_1\n-#define byte_1 XMM_BYTE_1\n-#undef byte_2\n-#define byte_2 XMM_BYTE_2\n-#undef cmp_0\n-#define cmp_0 XMM_TMP3\n-#undef cmp_k\n-#define cmp_k XMM_TMP4\n-#undef result\n-#define result XMM_TMP3\n+      __ movq(index, COPIED_HAYSTACK_STACK_OFFSET + 0x10);\n+      __ movdqu(xmm_tmp1, Address(haystack, haystack_len, Address::times_1, -0x10));\n+      __ movdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), xmm_tmp1);\n+      __ jmpb(L_adjustHaystack);\n@@ -554,1 +424,4 @@\n-  int sizeIncr = isU ? 2 : 1;\n+      __ bind(L_moreThan16);\n+      __ movq(index, COPIED_HAYSTACK_STACK_OFFSET + 0x20);\n+      __ vmovdqu(xmm_tmp1, Address(haystack, haystack_len, Address::times_1, -0x20));\n+      __ vmovdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), xmm_tmp1);\n@@ -556,2 +429,4 @@\n-  assert((!sizeKnown) || (((size > 0) && (size <= NUMBER_OF_CASES))),\n-         \"Incorrect size given\");\n+      __ bind(L_adjustHaystack);\n+      __ subq(index, haystack_len);\n+      __ leaq(haystack, Address(rsp, index, Address::times_1));\n+    }\n@@ -559,4 +434,7 @@\n-  Address kThByte =\n-      sizeKnown ? Address(haystack, size - sizeIncr)\n-                : Address(haystack, needleLen, Address::times_1, -(sizeIncr));\n-  size = sizeKnown ? size : NUMBER_OF_CASES + 1;\n+    \/\/ Dispatch to handlers for small needle and small haystack\n+    __ bind(L_smallSwitchTop);\n+    __ leaq(r13, Address(save_ndl_len, -1));\n+    __ cmpq(r13, NUMBER_OF_CASES - 1);\n+    __ ja(L_smallCaseDefault);\n+    __ mov64(r15, (int64_t)jump_table_1);\n+    __ jmp(Address(r15, r13, Address::times_8));\n@@ -564,7 +442,7 @@\n-  \/\/ Creates a mask of (n - k + 1) ones.  This prevents\n-  \/\/ recognizing any false-positives past the end of\n-  \/\/ the valid haystack.\n-  __ movq(rTmp, -1);\n-  __ movq(eq_mask, r10);   \/\/ Assumes r10 has n - k\n-  __ addq(eq_mask, 1);\n-  __ bzhiq(rTmp, rTmp, eq_mask);\n+    \/\/ Dispatch to handlers for small needle and large haystack\n+    __ bind(L_bigSwitchTop);\n+    __ leaq(rax, Address(save_ndl_len, -1));\n+    __ cmpq(rax, NUMBER_OF_CASES - 1);\n+    __ ja(L_bigCaseDefault);\n+    __ mov64(r15, (int64_t)jump_table);\n+    __ jmp(Address(r15, rax, Address::times_8));\n@@ -572,13 +450,1 @@\n-  \/\/ Compare first byte of needle to haystack\n-  if (isU) {\n-    __ vpcmpeqw(cmp_0, byte_0, Address(haystack, 0), Assembler::AVX_256bit);\n-  } else {\n-    __ vpcmpeqb(cmp_0, byte_0, Address(haystack, 0), Assembler::AVX_256bit);\n-  }\n-  if (size != (isU ? 2 : 1)) {\n-    \/\/ Compare last byte of needle to haystack at proper position\n-    if (isU) {\n-      __ vpcmpeqw(cmp_k, byte_k, kThByte, Assembler::AVX_256bit);\n-    } else {\n-      __ vpcmpeqb(cmp_k, byte_k, kThByte, Assembler::AVX_256bit);\n-    }\n+    __ align(CodeEntryAlignment);\n@@ -586,1 +452,5 @@\n-    __ vpand(result, cmp_k, cmp_0, Assembler::AVX_256bit);\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\n+    \/\/ Big case default:\n@@ -588,18 +458,2 @@\n-    if (bytesToCompare > 2) {\n-      if (size > (isU ? 4 : 2)) {\n-        if (doEarlyBailout) {\n-          __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n-          __ andq(eq_mask, rTmp);\n-          __ testl(eq_mask, eq_mask);\n-          __ je(noMatch);\n-        }\n-        if (isU) {\n-          __ vpcmpeqw(cmp_k, byte_1, Address(haystack, 2),\n-                      Assembler::AVX_256bit);\n-        } else {\n-          __ vpcmpeqb(cmp_k, byte_1, Address(haystack, 1),\n-                      Assembler::AVX_256bit);\n-        }\n-        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n-      }\n-    }\n+    {\n+      Label L_loopTop, L_innerLoop, L_found;\n@@ -607,19 +461,11 @@\n-    if (bytesToCompare > 3) {\n-      if (size > (isU ? 6 : 3)) {\n-        if (doEarlyBailout) {\n-          __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n-          __ andq(eq_mask, rTmp);\n-          __ testl(eq_mask, eq_mask);\n-          __ je(noMatch);\n-        }\n-        if (isU) {\n-          __ vpcmpeqw(cmp_k, byte_2, Address(haystack, 4),\n-                      Assembler::AVX_256bit);\n-        } else {\n-          __ vpcmpeqb(cmp_k, byte_2, Address(haystack, 2),\n-                      Assembler::AVX_256bit);\n-        }\n-        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n-      }\n-    }\n-  }\n+      const Register hsPtrRet = rax;\n+      const Register mask = r8;\n+      const Register index = r9;\n+      const Register firstNeedleCompare = rdx;\n+      const Register compLen = rbp;\n+      const Register haystackStart = rcx;\n+      const Register rScratch = r13;\n+      const Register needleLen = r12;\n+      const Register needle = r14;\n+      const Register haystack = rbx;\n+      const Register retval = r15;\n@@ -627,2 +473,18 @@\n-  __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n-  __ andq(eq_mask, rTmp);\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\n+      \/\/ Big case default:\n+      \/\/\n+      \/\/  rbx: haystack\n+      \/\/  rcx: k\n+      \/\/  rdx: junk\n+      \/\/  rsi: n\n+      \/\/  rdi: haystack\n+      \/\/  r10: n - k\n+      \/\/  r12: k\n+      \/\/  r13: junk\n+      \/\/  r14: needle\n+      \/\/  rbp: -1\n+      \/\/  XMM_BYTE_0 - first element of needle broadcast\n+      \/\/  XMM_BYTE_K - last element of needle broadcast\n@@ -630,12 +492,1 @@\n-  __ testl(eq_mask, eq_mask);\n-  __ je(noMatch);\n-  \/\/ At this point, we have at least one \"match\" where first and last bytes\n-  \/\/ of the needle are found the correct distance apart.\n-#undef byte_0\n-#undef byte_k\n-#undef byte_1\n-#undef byte_2\n-#undef cmp_0\n-#undef cmp_k\n-#undef result\n-}\n+      __ bind(L_bigCaseDefault);\n@@ -643,38 +494,2 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ Helper for big haystack loop construct\n-\/\/\n-\/\/ For UTF-16 encoded needles, broadcast a word at the proper offset to the ymm\n-\/\/ register (case UU)\n-\/\/ For the UTF-16 encoded haystack with Latin1 encoded needle (case UL) we have\n-\/\/ to read into a temp register to zero-extend the single byte needle value, then\n-\/\/ broadcast words to the ymm register.\n-\/\/\n-\/\/ Parameters:\n-\/\/ sizeKnown - if true, size is valid and needleLen invalid.\n-\/\/ size - the size of the needle.  Pass 0 if unknown at compile time\n-\/\/ noMatch - label bound outside to jump to if there is no match\n-\/\/ loop_top - label bound inside this helper that should be branched to\n-\/\/            for additional comparisons.\n-\/\/ eq_mask - The bit mask returned that holds the result of the comparison\n-\/\/ hsPtrRet - This will hold the place within the needle where a match is found\n-\/\/            This is modified\n-\/\/ needleLen - The length of the needle\n-\/\/ ae - Argument encoding\n-\/\/ _masm - Current MacroAssembler instance pointer\n-\/\/\n-\/\/ On entry:\n-\/\/\n-\/\/  rbx: haystack\n-\/\/  rcx: k\n-\/\/  rdx: junk\n-\/\/  rsi: n\n-\/\/  rdi: haystack\n-\/\/  r10: n - k\n-\/\/  r12: k\n-\/\/  r13: junk\n-\/\/  r14: needle\n-\/\/  rbp: -1\n-\/\/  XMM_BYTE_0 - first element of needle broadcast\n-\/\/  XMM_BYTE_K - last element of needle broadcast\n+      \/\/ Loop construct handling for big haystacks\n+      big_case_loop_helper(false, 0, L_checkRangeAndReturn, L_loopTop, mask, hsPtrRet, needleLen, ae, _masm);\n@@ -682,6 +497,5 @@\n-static void big_case_loop_helper(bool sizeKnown, int size, Label& noMatch,\n-                                 Label& loop_top, Register eq_mask,\n-                                 Register hsPtrRet, Register needleLen,\n-                                 StrIntrinsicNode::ArgEncoding ae,\n-                                 MacroAssembler* _masm) {\n-  Label temp;\n+      \/\/ big_case_loop_helper will fall through to this point if one or more potential matches are found\n+      \/\/ The mask will have a bitmask indicating the position of the potential matches within the haystack\n+      __ align(8);\n+      __ bind(L_innerLoop);\n+      __ tzcntl(index, mask);\n@@ -689,2 +503,16 @@\n-  assert_different_registers(eq_mask, hsPtrRet, needleLen, rdi, r15, rdx, rsi,\n-                             rbx, r14, r10);\n+      \/\/ Starting address in the haystack\n+      __ leaq(haystackStart,\n+              Address(hsPtrRet, index, Address::times_1,\n+                      isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2 : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n+      \/\/ Starting address of first byte of needle to compare\n+      __ leaq(firstNeedleCompare, Address(needle, isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2\n+                                                      : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n+      \/\/ Number of bytes to compare\n+      __ leaq(compLen, Address(needleLen,\n+                               isU ? -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE * 2)\n+                                   : -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE)));  \/\/ nlen - 2\n+                                                                              \/\/ elements\n+      __C2 arrays_equals(false, haystackStart, firstNeedleCompare, compLen, retval, rScratch, xmm_tmp3, xmm_tmp4,\n+                         false \/* char *\/, knoreg);\n+      __ testl(retval, retval);\n+      __ jne_b(L_found);\n@@ -692,12 +520,3 @@\n-#undef needle\n-#define needle r14\n-#undef haystack\n-#define haystack rbx\n-#undef hsLength\n-#define hsLength rsi\n-#undef last\n-#define last rdi\n-#undef temp1\n-#define temp1 r15\n-#undef temp2\n-#define temp2 rdx\n+      CLEAR_BIT(mask, index);\n+      __ jne(L_innerLoop);\n+      __ jmp(L_loopTop);\n@@ -705,4 +524,7 @@\n-  bool isLL = (ae == StrIntrinsicNode::LL);\n-  bool isUL = (ae == StrIntrinsicNode::UL);\n-  bool isUU = (ae == StrIntrinsicNode::UU);\n-  bool isU = isUL || isUU;  \/\/ At least one is UTF-16\n+      \/\/ Found exact match.  Compute offset from beginning of haystack\n+      __ bind(L_found);\n+      __ subq(hsPtrRet, haystack);\n+      __ addq(hsPtrRet, index);\n+      __ movq(r11, hsPtrRet);\n+      __ jmp(L_checkRangeAndReturn);\n+    }\n@@ -710,3 +532,22 @@\n-  assert_different_registers(eq_mask, hsPtrRet, needleLen, haystack, needle,\n-                             hsLength, last);\n-                            \/\/  hsLength, termAddr, last);\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\n+    \/\/ Small case default:\n+    \/\/\n+    \/\/  rbx: haystack\n+    \/\/  r14: needle\n+    \/\/  r13: k - 1\n+    \/\/  r12: k\n+    \/\/  r10: n - k\n+    \/\/  rbp: -1\n+    \/\/  rdi: junk\n+    \/\/  rsi: n\n+    \/\/  rdx: junk\n+    \/\/  rcx: junk\n+    \/\/  XMM_BYTE_0 - first element of needle broadcast\n+    \/\/  XMM_BYTE_K - last element of needle broadcast\n+    \/\/\n+    \/\/  Haystack always copied to stack, so 32-byte reads OK\n+    \/\/  Haystack length < 32\n+    \/\/  10 < needle length < 32\n@@ -714,4 +555,2 @@\n-  if (isU && (size & 1)) {\n-    __ emit_int8(0xcc);\n-    return;\n-  }\n+    {\n+      __ bind(L_smallCaseDefault);\n@@ -719,3 +558,1 @@\n-  broadcast_additional_needles(sizeKnown, size,\n-                               NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, needle,\n-                               needleLen, temp1, isUU, isUL, _masm);\n+      Label L_innerLoop;\n@@ -723,1 +560,7 @@\n-  __ movq(r11, -1);\n+      const Register firstNeedleCompare = rdx;\n+      const Register compLen = r9;\n+      const Register haystack = rbx;\n+      const Register mask = r8;\n+      const Register rTmp = rdi;\n+      const Register rTmp2 = r13;\n+      const Register rTmp3 = rax;\n@@ -725,11 +568,5 @@\n-  \/\/ Read 32-byte chunks at a time until the last 32-byte read would go\n-  \/\/ past the end of the haystack.  Then, set the final read to read exactly\n-  \/\/ the number of bytes in the haystack.\n-  \/\/ For example, if haystack length is 45 and needle length is 13, the compares\n-  \/\/ will read the following bytes:\n-  \/\/\n-  \/\/  First compare          Last compare\n-  \/\/   [  0 : 31]            [12 : 43]\n-  \/\/ Next compare will go past end of haystack ([32:63])\n-  \/\/ Adjust so final read is:\n-  \/\/   [  1 : 32]            [13 : 44]\n+\/\/ r14 and r12 will be re-used later in this procedure\n+#undef needle\n+#define needle r14\n+#undef needleLen\n+#define needleLen r12\n@@ -737,4 +574,2 @@\n-  __ movq(hsPtrRet, haystack);\n-  \/\/ Assume r10 is n - k\n-  __ leaq(last, Address(haystack, r10, Address::times_1, isU ? -30 : -31));\n-  __ jmpb(temp);\n+      broadcast_additional_needles(false, 0 \/* unknown *\/, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, needle, needleLen, rTmp3,\n+                                   isUU, isUL, _masm);\n@@ -742,5 +577,13 @@\n-  __ align(16);\n-  __ bind(loop_top);\n-  __ cmpq(hsPtrRet, last);\n-  __ je(noMatch);\n-  __ addq(hsPtrRet, 32);\n+      assert(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 4, \"Invalid\");\n+      assert(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE >= 2, \"Invalid\");\n+      __ leaq(firstNeedleCompare, Address(needle, isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2\n+                                                      : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n+      __ leaq(compLen, Address(needleLen,\n+                               isU ? -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE * 2)\n+                                   : -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE)));  \/\/ nlen - 2\n+                                                                              \/\/ elements\n+      \/\/  firstNeedleCompare has address of second element of needle\n+      \/\/  compLen has length of comparison to do\n+\n+      compare_haystack_to_needle(false, 0, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, L_returnRBP, haystack, isU,\n+                                 DO_EARLY_BAILOUT, mask, needleLen, rTmp3, _masm);\n@@ -748,2 +591,7 @@\n-  __ cmpq(hsPtrRet, last);\n-  __ cmovq(Assembler::aboveEqual, hsPtrRet, last);\n+\/\/ NOTE: REGISTER RE-USE for r12 and r14\n+#undef needle\n+#undef saveCompLen\n+#define saveCompLen r14\n+#undef needleLen\n+#undef saveNeedleAddress\n+#define saveNeedleAddress r12\n@@ -751,1 +599,2 @@\n-  __ bind(temp);\n+      __ movq(saveCompLen, compLen);\n+      __ movq(saveNeedleAddress, firstNeedleCompare);  \/\/ Save address of 2nd element of needle\n@@ -753,6 +602,3 @@\n-  \/\/ compare_big_haystack_to_needle will jump to loop_top until a match has been\n-  \/\/ found\n-  compare_big_haystack_to_needle(sizeKnown, size,\n-                                 NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, loop_top,\n-                                 hsPtrRet, hsLength, needleLen, isU,\n-                                 DO_EARLY_BAILOUT, eq_mask, temp2, r10, _masm);\n+      __ align(8);\n+      __ bind(L_innerLoop);\n+      __ tzcntl(r11, mask);\n@@ -760,6 +606,2 @@\n-  \/\/ At this point, we have at least one \"match\" where first and last bytes\n-  \/\/ of the needle are found the correct distance apart.\n-  \/\/\n-  \/\/ NOTE: haystack (rbx) should be preserved; hsPtrRet(rcx) is expected to\n-  \/\/    point to the haystack such that hsPtrRet[tzcntl(eq_mask)] points to\n-  \/\/    the matched string.\n+      __ leaq(rTmp, Address(haystack, r11, Address::times_1,\n+                            isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2 : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n@@ -767,8 +609,4 @@\n-#undef needle\n-#undef haystack\n-#undef hsLength\n-#undef last\n-#undef temp1\n-#undef temp2\n-#undef savedNeedleLen\n-}\n+      __C2 arrays_equals(false, rTmp, firstNeedleCompare, compLen, rTmp3, rTmp2, xmm_tmp3, xmm_tmp4, false \/* char *\/,\n+                         knoreg);\n+      __ testl(rTmp3, rTmp3);\n+      __ jne_b(L_checkRangeAndReturn);\n@@ -776,4 +614,5 @@\n-static void preload_needle_helper(int size, Register needle, Register needleVal,\n-                                  StrIntrinsicNode::ArgEncoding ae,\n-                                  MacroAssembler* _masm) {\n-  \/\/ Pre-load the value (correctly sized) of the needle for comparison purposes.\n+      __ movq(compLen, saveCompLen);\n+      __ movq(firstNeedleCompare, saveNeedleAddress);\n+      CLEAR_BIT(mask, rTmp3);\n+      __ jne(L_innerLoop);\n+      __ jmp(L_returnRBP);\n@@ -781,1 +620,3 @@\n-  assert_different_registers(needle, needleVal);\n+#undef saveCompLen\n+#undef saveNeedleAddress\n+    }\n@@ -783,4 +624,3 @@\n-  bool isLL = (ae == StrIntrinsicNode::LL);\n-  bool isUL = (ae == StrIntrinsicNode::UL);\n-  bool isUU = (ae == StrIntrinsicNode::UU);\n-  bool isU = isUL || isUU;  \/\/ At least one is UTF-16\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n@@ -788,3 +628,3 @@\n-  int bytesAlreadyCompared = 0;\n-  int bytesLeftToCompare = 0;\n-  int offsetOfFirstByteToCompare = 0;\n+    __ bind(L_returnError);\n+    __ movq(rbp, -1);\n+    __ jmpb(L_returnRBP);\n@@ -792,5 +632,3 @@\n-  bytesAlreadyCompared = isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE * 2)\n-                             : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE;\n-  offsetOfFirstByteToCompare =\n-      isU ? ((NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2)\n-      : (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1);\n+    __ bind(L_returnZero);\n+    __ xorl(rbp, rbp);\n+    __ jmpb(L_returnRBP);\n@@ -798,2 +636,4 @@\n-  bytesLeftToCompare = size - bytesAlreadyCompared;\n-  assert((bytesLeftToCompare <= 8), \"Too many bytes left to compare\");\n+    __ bind(L_bigCaseFixupAndReturn);\n+    __ movl(rax, r8);\n+    __ subq(rcx, rbx);\n+    __ addq(rcx, rax);\n@@ -801,3 +641,2 @@\n-  if (bytesLeftToCompare <= 0) {\n-    return;\n-  }\n+    __ bind(L_checkRangeAndReturnRCX);\n+    __ movq(r11, rcx);\n@@ -805,2 +644,4 @@\n-  \/\/ At this point, there is at least one byte of the needle that needs to be\n-  \/\/ compared to the haystack.\n+    __ bind(L_checkRangeAndReturn);\n+    __ cmpq(r11, r10);\n+    __ movq(rbp, -1);\n+    __ cmovq(Assembler::belowEqual, rbp, r11);\n@@ -808,29 +649,27 @@\n-  if (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 2) {\n-    switch (bytesLeftToCompare) {\n-      case 1:\n-      case 2:\n-        __ movzwl(needleVal, Address(needle, offsetOfFirstByteToCompare));\n-        break;\n-\n-      case 3:\n-      case 4:\n-        __ movl(needleVal, Address(needle, offsetOfFirstByteToCompare));\n-        break;\n-\n-      case 5:\n-        \/\/ Read one byte before start of needle, then mask it off\n-        __ movq(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n-        __ shrq(needleVal, 0x8);\n-        break;\n-\n-      case 6:\n-        __ movq(needleVal, Address(needle, (offsetOfFirstByteToCompare - 1)));\n-        break;\n-\n-      case 7:\n-      case 8:\n-        __ movq(needleVal, Address(needle, offsetOfFirstByteToCompare));\n-        break;\n-\n-      default:\n-        break;\n+    __ bind(L_returnRBP);\n+    __ movq(rax, rbp);\n+    __ addptr(rsp, STACK_SPACE);\n+    __ pop(rbp);\n+#ifdef _WIN64\n+    __ pop(r9);\n+    __ pop(r8);\n+    __ pop(rcx);\n+    __ pop(rdi);\n+    __ pop(rsi);\n+#endif\n+#ifdef PUSH_REGS\n+    __ pop(rbx);\n+    __ pop(r12);\n+    __ pop(r13);\n+    __ pop(r14);\n+    __ pop(r15);\n+#else\n+    __ movdq(r12, save_r12);\n+    __ movdq(r13, save_r13);\n+    __ movdq(r14, save_r14);\n+    __ movdq(r15, save_r15);\n+    __ movdq(rbx, save_rbx);\n+#endif\n+    \/\/ Need to return elements for UTF-16 encodings\n+    if (isU) {\n+      __ sarq(rax, 1);\n@@ -838,1 +677,1 @@\n-  }\n+    __ vzeroupper();\n@@ -840,27 +679,2 @@\n-  if (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE >= 3) {\n-    switch (bytesLeftToCompare) {\n-      case 1:\n-      case 2:\n-        __ movl(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n-        break;\n-\n-      case 3:\n-      case 4:\n-        __ movl(needleVal, Address(needle, offsetOfFirstByteToCompare));\n-        break;\n-\n-      case 5:\n-      case 6:\n-        __ movq(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n-        break;\n-\n-      case 7:\n-      case 8:\n-        __ movq(needleVal, Address(needle, offsetOfFirstByteToCompare));\n-        break;\n-\n-      default:\n-        break;\n-    }\n-  }\n-}\n+    __ leave();  \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ ret(0);\n@@ -868,10 +682,17 @@\n-static void byte_compare_helper(int size, Label& L_noMatch, Label& L_matchFound,\n-                                Register needle, Register needleVal,\n-                                Register haystack, Register mask,\n-                                Register foundIndex, Register tmp,\n-                                StrIntrinsicNode::ArgEncoding ae,\n-                                MacroAssembler* _masm) {\n-  \/\/ Compare size bytes of needle to haystack\n-  \/\/\n-  \/\/ At a minimum, the first and last bytes of needle already compare equal\n-  \/\/ to the haystack, so there is no need to compare them again.\n+    if (isUL) {\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/                         Wide char code\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\n+      \/\/ Pseudo-code:\n+      \/\/\n+      \/\/ If needle length less than MAX_NEEDLE_LEN_TO_EXPAND, read the needle\n+      \/\/ bytes from r14 and write them as words onto the stack.  Then go to the\n+      \/\/ \"regular\" code.  This is equavilent to doing a UU comparison, since the\n+      \/\/ haystack will be in UTF-16.\n+      \/\/\n+      \/\/ If the needle can't be expanded, process the same way as the default\n+      \/\/ cases above. That is, for each haystack chunk, compare the needle.\n+      __ bind(L_wcharBegin);\n@@ -879,1 +700,1 @@\n-  Label L_loopTop;\n+      Label L_top, L_finished;\n@@ -881,1 +702,4 @@\n-  assert_different_registers(needle, needleVal, haystack, mask, foundIndex, tmp);\n+      const Register haystack = rdi;\n+      const Register hsLen = rsi;\n+      const Register needle = rdx;\n+      const Register nLen = rcx;\n@@ -883,4 +707,3 @@\n-  bool isLL = (ae == StrIntrinsicNode::LL);\n-  bool isUL = (ae == StrIntrinsicNode::UL);\n-  bool isUU = (ae == StrIntrinsicNode::UU);\n-  bool isU = isUL || isUU;  \/\/ At least one is UTF-16\n+      const Register offset = rax;\n+      const Register index = rbx;\n+      const Register wr_index = r13;\n@@ -888,3 +711,1 @@\n-  int bytesAlreadyCompared = 0;\n-  int bytesLeftToCompare = 0;\n-  int offsetOfFirstByteToCompare = 0;\n+      assert(MAX_NEEDLE_LEN_TO_EXPAND >= 32, \"Small UL needles not supported\");\n@@ -892,1 +713,1 @@\n-  Label temp;\n+      __ shlq(hsLen, 1);\n@@ -894,6 +715,4 @@\n-  if (isU) {\n-    if ((size & 1) != 0) {\n-      __ emit_int8(0xcc);\n-      return;\n-    }\n-  }\n+      \/\/ __ movq(r14, hsLen);\n+      __ leaq(index, Address(nLen, nLen, Address::times_1));\n+      __ cmpq(index, hsLen);\n+      __ jg(L_returnRBP);\n@@ -901,5 +720,2 @@\n-  bytesAlreadyCompared = isU ? NUMBER_OF_NEEDLE_BYTES_TO_COMPARE * 2\n-                             : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE;\n-  offsetOfFirstByteToCompare =\n-      isU ? ((NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2)\n-          : (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1);\n+      __ cmpq(nLen, MAX_NEEDLE_LEN_TO_EXPAND);\n+      __ ja(L_wideNoExpand);\n@@ -907,2 +723,15 @@\n-  bytesLeftToCompare = size - bytesAlreadyCompared;\n-  assert(bytesLeftToCompare <= 8, \"Too many bytes left to compare\");\n+      \/\/\n+      \/\/ Reads of existing needle are 16-byte chunks\n+      \/\/ Writes to copied needle are 32-byte chunks\n+      \/\/ Don't read past the end of the existing needle\n+      \/\/\n+      \/\/ Start first read at [((ndlLen % 16) - 16) & 0xf]\n+      \/\/ outndx += 32\n+      \/\/ inndx += 16\n+      \/\/ cmp nndx, ndlLen\n+      \/\/ jae done\n+      \/\/\n+      \/\/ Final index of start of needle @((16 - (ndlLen %16)) & 0xf) << 1\n+      \/\/\n+      \/\/ Starting read for needle at -(16 - (nLen % 16))\n+      \/\/ Offset of needle in stack should be (16 - (nLen % 16)) * 2\n@@ -910,5 +739,8 @@\n-  if (bytesLeftToCompare <= 0) {\n-    __ tzcntl(foundIndex, mask);\n-    __ jmp(L_matchFound);\n-    return;\n-  }\n+      __ movq(index, needle_len);\n+      __ andq(index, 0xf);  \/\/ nLen % 16\n+      __ movq(offset, 0x10);\n+      __ subq(offset, index);  \/\/ 16 - (nLen % 16)\n+      __ movq(index, offset);\n+      __ shlq(offset, 1);  \/\/ * 2\n+      __ negq(index);      \/\/ -(16 - (nLen % 16))\n+      __ xorq(wr_index, wr_index);\n@@ -916,2 +748,10 @@\n-  \/\/ At this point, there is at least one byte of the needle that needs to be\n-  \/\/ compared to the haystack.\n+      __ bind(L_top);\n+      \/\/ load needle[low-16]\n+      __ vpmovzxbw(xmm0, Address(needle, index, Address::times_1), Assembler::AVX_256bit);\n+      \/\/ store to stack\n+      __ vmovdqu(Address(rsp, wr_index, Address::times_1, EXPANDED_NEEDLE_STACK_OFFSET), xmm0);\n+      __ addq(index, 0x10);\n+      __ cmpq(index, needle_len);\n+      __ jae(L_finished);\n+      __ addq(wr_index, 32);\n+      __ jmpb(L_top);\n@@ -919,3 +759,3 @@\n-  \/\/ Load in the correct sized needle value for comparison.  Used when checking\n-  \/\/ bytes of the haystack after first\/last have compared equal.\n-  preload_needle_helper(size, needle, needleVal, ae, _masm);\n+      __ bind(L_finished);\n+      __ leaq(needle, Address(rsp, offset, Address::times_1, EXPANDED_NEEDLE_STACK_OFFSET));\n+      __ leaq(needle_len, Address(needle_len, needle_len));\n@@ -923,3 +763,1 @@\n-  __ align(8);\n-  __ bind(L_loopTop);\n-  __ tzcntl(foundIndex, mask);  \/\/ Index of match within haystack\n+      __ jmp(L_continue);\n@@ -927,43 +765,8 @@\n-  if (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 2) {\n-    switch (bytesLeftToCompare) {\n-      case 1:\n-      case 2:\n-        __ cmpw(Address(haystack, foundIndex, Address::times_1,\n-                        offsetOfFirstByteToCompare),\n-                needleVal);\n-        __ je(L_matchFound);\n-        break;\n-\n-      case 3:\n-      case 4:\n-        __ cmpl(Address(haystack, foundIndex, Address::times_1,\n-                        offsetOfFirstByteToCompare),\n-                needleVal);\n-        __ je(L_matchFound);\n-        break;\n-\n-      case 5:\n-        \/\/ Read one byte before start of haystack, then mask it off\n-        __ movq(tmp, Address(haystack, foundIndex, Address::times_1,\n-                             offsetOfFirstByteToCompare - 2));\n-        __ shrq(tmp, 0x08);\n-        __ cmpq(needleVal, tmp);\n-        __ je(L_matchFound);\n-        break;\n-\n-      case 6:\n-        __ cmpq(Address(haystack, foundIndex, Address::times_1,\n-                        offsetOfFirstByteToCompare - 1),\n-                needleVal);\n-        __ je(L_matchFound);\n-        break;\n-\n-      case 7:\n-      case 8:\n-        __ cmpq(Address(haystack, foundIndex, Address::times_1,\n-                        offsetOfFirstByteToCompare),\n-                needleVal);\n-        __ je(L_matchFound);\n-        break;\n-    }\n-  }\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\n+      \/\/ Compare Latin-1 encoded needle against UTF-16 encoded haystack.\n+      \/\/\n+      \/\/ The needle is more than MAX_NEEDLE_LEN_TO_EXPAND bytes in length, and the haystack\n+      \/\/ is at least as big.\n@@ -971,35 +774,41 @@\n-  if (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE >= 3) {\n-    switch (bytesLeftToCompare) {\n-      case 1:\n-      case 2:\n-        __ cmpl(Address(haystack, foundIndex, Address::times_1,\n-                        offsetOfFirstByteToCompare - 2),\n-                needleVal);\n-        __ je(L_matchFound);\n-        break;\n-\n-      case 3:\n-      case 4:\n-        __ cmpl(Address(haystack, foundIndex, Address::times_1,\n-                        offsetOfFirstByteToCompare),\n-                needleVal);\n-        __ je(L_matchFound);\n-        break;\n-\n-      case 5:\n-      case 6:\n-        __ cmpq(Address(haystack, foundIndex, Address::times_1,\n-                        offsetOfFirstByteToCompare - 2),\n-                needleVal);\n-        __ je(L_matchFound);\n-        break;\n-\n-      case 7:\n-      case 8:\n-        __ cmpq(Address(haystack, foundIndex, Address::times_1,\n-                        offsetOfFirstByteToCompare),\n-                needleVal);\n-        __ je(L_matchFound);\n-        break;\n-    }\n-  }\n+      \/\/ Prepare for wchar anysize\n+      __ bind(L_wideNoExpand);\n+\n+      {\n+        Label L_loopTop, L_temp, L_innerLoop, L_found, L_compareFull;\n+        Label doCompare, topLoop;\n+\n+        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+        \/\/\n+        \/\/  rbx: haystack\n+        \/\/  rcx: k\n+        \/\/  rdx: junk\n+        \/\/  rsi: n\n+        \/\/  rdi: haystack\n+        \/\/  r10: n - k\n+        \/\/  r12: k\n+        \/\/  r13: junk\n+        \/\/  r14: needle\n+        \/\/  rbp: -1\n+        \/\/  XMM_BYTE_0 - first element of needle broadcast\n+        \/\/  XMM_BYTE_K - last element of needle broadcast\n+\n+        const Register rTmp = rax;\n+        const Register haystack = rbx;\n+        const Register saveNeedleAddress = rbx;  \/\/ NOTE re-use\n+        const Register origNeedleLen = rcx;\n+        const Register firstNeedleCompare = rdx;\n+        const Register hsLen = rsi;\n+        const Register origHsLen = rsi;  \/\/ NOTE re-use\n+        const Register rTmp2 = rdi;\n+        const Register mask = rbp;\n+        const Register rScratch = r8;\n+        const Register compLen = r9;\n+        const Register needleLen = r12;\n+        const Register hsIndex = r12;  \/\/ NOTE re-use\n+        const Register constOffset = r13;\n+        const Register needle = r14;\n+        const Register index = r14;  \/\/ NOTE re-use\n+        const Register haystackEnd = r15;\n@@ -1007,4 +816,3 @@\n-  CLEAR_BIT(mask, tmp); \/\/ Loop as long as there are other bits set\n-  __ jne(L_loopTop);\n-  __ jmp(L_noMatch);\n-}\n+        const XMMRegister cmp_0 = xmm_tmp3;\n+        const XMMRegister cmp_k = xmm_tmp4;\n+        const XMMRegister result = xmm_tmp3;\n@@ -1012,11 +820,2 @@\n-void StubGenerator::generate_string_indexof(address *fnptrs) {\n-  assert((int) StrIntrinsicNode::LL < 4, \"Enum out of range\");\n-  assert((int) StrIntrinsicNode::UL < 4, \"Enum out of range\");\n-  assert((int) StrIntrinsicNode::UU < 4, \"Enum out of range\");\n-  generate_string_indexof_stubs(fnptrs, StrIntrinsicNode::LL);\n-  generate_string_indexof_stubs(fnptrs, StrIntrinsicNode::UL);\n-  generate_string_indexof_stubs(fnptrs, StrIntrinsicNode::UU);\n-  assert(fnptrs[StrIntrinsicNode::LL] != nullptr, \"LL not generated.\");\n-  assert(fnptrs[StrIntrinsicNode::UL] != nullptr, \"UL not generated.\");\n-  assert(fnptrs[StrIntrinsicNode::UU] != nullptr, \"UU not generated.\");\n-}\n+        const XMMRegister saveCompLen = xmm_tmp2;\n+        const XMMRegister saveIndex = xmm_tmp1;\n@@ -1024,10 +823,4 @@\n-void StubGenerator::generate_string_indexof_stubs(address *fnptrs, StrIntrinsicNode::ArgEncoding ae) {\n-  StubCodeMark mark(this, \"StubRoutines\", \"stringIndexOf\");\n-  address large_hs_jmp_table[NUMBER_OF_CASES];  \/\/ Jump table for large haystacks\n-  address small_hs_jmp_table[NUMBER_OF_CASES];  \/\/ Jump table for small haystacks\n-  int jmp_ndx = 0;\n-  bool isLL = (ae == StrIntrinsicNode::LL);\n-  bool isUL = (ae == StrIntrinsicNode::UL);\n-  bool isUU = (ae == StrIntrinsicNode::UU);\n-  bool isU = isUL || isUU; \/\/ At least one is UTF-16\n-  assert(isLL || isUL || isUU, \"Encoding not recognized\");\n+        \/\/ Move registers into expected registers for rest of this routine\n+        __ movq(rbx, rdi);\n+        __ movq(r12, rcx);\n+        __ movq(r14, rdx);\n@@ -1035,0 +828,6 @@\n+        __ movq(rTmp, origNeedleLen);\n+        __ shlq(rTmp, 1);\n+        __ movq(rScratch, origHsLen);\n+        __ subq(rScratch, rTmp);\n+        __ cmpq(rScratch, 0x20);\n+        __ jl(L_compareFull);\n@@ -1036,6 +835,1 @@\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/                         AVX2 code\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  if (VM_Version::supports_avx2()) {  \/\/ AVX2 version\n+        \/\/ Now there is room for a 32-byte read for the last iteration\n@@ -1043,23 +837,5 @@\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/                         Code generation explanation:\n-  \/\/\n-  \/\/  The generator will generate code for three cases:\n-  \/\/  1. Both needle and haystack are Latin-1 (single byte) encoded (LL)\n-  \/\/  2. Both the needle and haystack are UTF-16 encoded (two bytes per character) (UU)\n-  \/\/  3. The haystack is UTF-16 encoded and the needle is Latin-1 encoded (UL)\n-  \/\/\n-  \/\/  The case of the haystack being Latin-1 and the needle being UTF-16 is short-circuited\n-  \/\/  so that we never get called in this case.\n-  \/\/\n-  \/\/  For the UL case (haystack UTF-16 and needle Latin-1), the needle will be expanded\n-  \/\/  onto the stack (for size <= MAX_NEEDLE_LEN_TO_EXPAND) and the UU code will do the work.\n-  \/\/  For UL where the needle size is > MAX_NEEDLE_LEN_TO_EXPAND, we default to a\n-  \/\/  byte-by-byte comparison (this will be rare).\n-  \/\/\n-  \/\/  Note that the code assumes MAX_NEEDLE_LEN_TO_EXPAND is >= 32.\n-  \/\/\n-  \/\/  The UU and LL cases are identical except for the loop increments and loading\n-  \/\/  of the characters into registers.  UU loads and compares words, LL - bytes.\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+        \/\/ Always need needle broadcast to ymm registers\n+        __ movzbl(rax, Address(needle));  \/\/ First byte of needle\n+        __ movdl(byte_0, rax);\n+        \/\/ 1st byte of needle in words\n+        __ vpbroadcastw(byte_0, byte_0, Assembler::AVX_256bit);\n@@ -1067,4 +843,5 @@\n-    const Register haystack     = rdi;\n-    const Register haystack_len = rsi;\n-    const Register needle       = rdx;\n-    const Register needle_len   = rcx;\n+        __ movzbl(rax, Address(needle, needle_len, Address::times_1,\n+                               -1));  \/\/ Last byte of needle\n+        __ movdl(byte_k, rax);\n+        __ vpbroadcastw(byte_k, byte_k,\n+                        Assembler::AVX_256bit);  \/\/ Last byte of needle in words\n@@ -1072,1 +849,2 @@\n-    const Register save_ndl_len = r12;\n+        \/\/ __ bind(L_bigCaseDefault);\n+        __ movq(r11, -1);\n@@ -1074,8 +852,2 @@\n-    const XMMRegister byte_0    = XMM_BYTE_0;\n-    const XMMRegister byte_k    = XMM_BYTE_K;\n-    const XMMRegister byte_1    = XMM_BYTE_1;\n-    const XMMRegister byte_2    = XMM_BYTE_2;\n-    const XMMRegister xmm_tmp1  = XMM_TMP1;\n-    const XMMRegister xmm_tmp2  = XMM_TMP2;\n-    const XMMRegister xmm_tmp3  = XMM_TMP3;\n-    const XMMRegister xmm_tmp4  = XMM_TMP4;\n+        broadcast_additional_needles(false, 0 \/* unknown *\/, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, needle, origNeedleLen,\n+                                     rax, isUU, isUL, _masm);\n@@ -1083,12 +855,1 @@\n-    const XMMRegister save_r12  = xmm4;\n-    const XMMRegister save_r13  = xmm5;\n-    const XMMRegister save_r14  = xmm6;\n-    const XMMRegister save_r15  = xmm7;\n-    const XMMRegister save_rbx  = xmm8;\n-    \/\/ xmm registers more valuable in inner loops...\n-    \/\/ const XMMRegister save_rsi  = xmm9;\n-    \/\/ const XMMRegister save_rdi  = xmm10;\n-    \/\/ const XMMRegister save_rcx  = xmm11;\n-    \/\/ const XMMRegister save_r8   = xmm12;\n-    \/\/ const XMMRegister save_r9   = xmm13;\n-    Label L_begin;\n+        __ leaq(haystackEnd, Address(haystack, hsLen, Address::times_1));\n@@ -1096,5 +857,5 @@\n-    Label L_returnRBP, L_checkRangeAndReturn, L_returnError;\n-    Label L_bigCaseFixupAndReturn, L_checkRangeAndReturnRCX;\n-    Label L_returnZero, L_copyHaystackToStackDone, L_bigSwitchTop;\n-    Label L_bigCaseDefault, L_smallCaseDefault, L_copyHaystackToStack, L_smallSwitchTop;\n-    Label L_nextCheck, L_checksPassed, L_zeroCheckFailed;\n+        assert(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 4, \"Invalid\");\n+        assert(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE >= 2, \"Invalid\");\n+        __ leaq(firstNeedleCompare, Address(needle, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n+        __ leaq(compLen, Address(needleLen,\n+                                 -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE)));  \/\/ nlen - 2 elements\n@@ -1102,2 +863,2 @@\n-    Label L_wcharBegin, L_continue, L_wideNoExpand, L_copyDone, L_copyHigh;\n-    Label L_wideMidLoop, L_wideTopLoop, L_wideInnerLoop, L_wideFound;\n+        \/\/  firstNeedleCompare has address of second element of needle\n+        \/\/  compLen has length of comparison to do\n@@ -1105,2 +866,2 @@\n-    address jump_table;\n-    address jump_table_1;\n+        \/\/ Save haystack\n+        __ movq(Address(rsp, SAVED_HAYSTACK_STACK_OFFSET), haystack);\n@@ -1108,1 +869,2 @@\n-    \/\/ Jump past jump table setups to get addresses of cases.\n+        __ movq(index, origHsLen);\n+        __ negptr(index);  \/\/ incr\n@@ -1110,6 +872,7 @@\n-    __ align(CodeEntryAlignment);\n-    fnptrs[isLL   ? StrIntrinsicNode::LL\n-           : isUU ? StrIntrinsicNode::UU\n-                  : StrIntrinsicNode::UL] =\n-        __ pc();\n-    __ enter();  \/\/ required for proper stackwalking of RuntimeStub frame\n+        \/\/ constant offset from end for full 32-byte read\n+        __ movq(constOffset, origHsLen);\n+        __ shlq(origNeedleLen, 1);\n+        __ subq(constOffset, origNeedleLen);\n+        __ andq(constOffset, 0x1f);\n+        __ negptr(constOffset);\n+        __ jmpb(L_temp);\n@@ -1117,6 +880,6 @@\n-    \/\/ Check for trivial cases\n-    __ cmpq(needle_len, 0);\n-    __ jg_b(L_nextCheck);\n-    __ xorq(rax, rax);\n-    __ leave();\n-    __ ret(0);\n+        __ bind(L_loopTop);\n+        __ addq(index, 32);\n+        __ subq(origHsLen, 32);\n+        __ jle(L_returnError);\n+        __ cmpq(index, constOffset);\n+        __ cmovq(Assembler::greater, index, constOffset);\n@@ -1124,3 +887,3 @@\n-    __ bind(L_nextCheck);\n-    __ testq(haystack_len, haystack_len);\n-    __ je(L_zeroCheckFailed);\n+        __ bind(L_temp);\n+        __ movq(hsIndex, origNeedleLen);\n+        __ addq(hsIndex, index);\n@@ -1128,3 +891,28 @@\n-    __ movq(rax, haystack_len);\n-    __ subq(rax, needle_len);\n-    __ jge_b(L_checksPassed);\n+        \/\/ Compare first byte of needle to haystack\n+        __ vpcmpeqw(cmp_0, byte_0, Address(haystackEnd, index), Assembler::AVX_256bit);\n+        \/\/ Compare last byte of needle to haystack at proper position\n+        __ vpcmpeqw(cmp_k, byte_k, Address(haystackEnd, hsIndex, Address::times_1, -2), Assembler::AVX_256bit);\n+        __ vpand(result, cmp_k, cmp_0, Assembler::AVX_256bit);\n+#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE > 2\n+#if DO_EARLY_BAILOUT > 0\n+        __ vpmovmskb(mask, result, Assembler::AVX_256bit);\n+        __ testl(mask, mask);\n+        __ je_b(L_loopTop);\n+#endif\n+        \/\/ Compare second byte of needle to haystack\n+        __ vpcmpeqw(cmp_k, byte_1, Address(haystackEnd, index, Address::times_1, 2), Assembler::AVX_256bit);\n+        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n+#endif\n+#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE > 3\n+#if DO_EARLY_BAILOUT > 0\n+        __ vpmovmskb(mask, result, Assembler::AVX_256bit);\n+        __ testl(mask, mask);\n+        __ je_b(L_loopTop);\n+#endif\n+        \/\/ Compare third byte of needle to haystack\n+        __ vpcmpeqw(cmp_k, byte_2, Address(haystackEnd, index, Address::times_1, 4), Assembler::AVX_256bit);\n+        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n+#endif\n+        __ vpmovmskb(mask, result, Assembler::AVX_256bit);\n+        __ testl(mask, mask);\n+        __ je_b(L_loopTop);\n@@ -1132,4 +920,3 @@\n-    __ bind(L_zeroCheckFailed);\n-    __ movq(rax, -1);\n-    __ leave();\n-    __ ret(0);\n+        __ align(8);\n+        __ bind(L_innerLoop);\n+        __ tzcntl(rTmp, mask);\n@@ -1137,1 +924,4 @@\n-    __ bind(L_checksPassed);\n+        __ movdq(saveIndex, rTmp);\n+        __ movdq(saveCompLen, compLen);\n+        \/\/ Save address of nth element of needle\n+        __ movq(saveNeedleAddress, firstNeedleCompare);\n@@ -1139,3 +929,14 @@\n-    \/\/ Highly optimized special-cases\n-    {\n-      Label L_noMatch, L_foundall, L_out;\n+#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 2\n+        __ leaq(rTmp2, Address(haystackEnd, index, Address::times_1, 2));\n+#endif\n+#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE == 3\n+        __ leaq(rTmp2, Address(haystackEnd, index, Address::times_1, 4));\n+#endif\n+#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE == 4\n+        __ leaq(rTmp2, Address(haystackEnd, index, Address::times_1, 6));\n+#endif\n+        __ addq(rTmp2, rTmp);\n+        __C2 arrays_equals(false, rTmp2, firstNeedleCompare, compLen, rTmp, rScratch, xmm_tmp3, xmm_tmp4,\n+                           false \/* char *\/, knoreg, true \/* expand_ary2 *\/);\n+        __ testl(rTmp, rTmp);\n+        __ jne_b(L_found);\n@@ -1143,4 +944,5 @@\n-      \/\/ Only optimize when haystack can fit on stack with room\n-      \/\/ left over for page fault prevention\n-      assert((COPIED_HAYSTACK_STACK_OFFSET == 0), \"Must be zero!\");\n-      assert((COPIED_HAYSTACK_STACK_SIZE == 64), \"Must be 64!\");\n+        __ movdq(compLen, saveCompLen);\n+        __ movq(firstNeedleCompare, saveNeedleAddress);\n+        CLEAR_BIT(mask, rTmp);\n+        __ jne(L_innerLoop);\n+        __ jmp(L_loopTop);\n@@ -1148,4 +950,7 @@\n-      \/\/ haystack_len is in elements, not bytes, for UTF-16\n-      __ cmpq(haystack_len, isU ? COPIED_HAYSTACK_STACK_SIZE \/ 4\n-                                : COPIED_HAYSTACK_STACK_SIZE \/ 2);\n-      __ ja(L_begin);\n+        __ bind(L_found);\n+        __ movdq(rTmp, saveIndex);\n+        __ leaq(rScratch, Address(haystackEnd, index, Address::times_1));\n+        __ subq(rScratch, Address(rsp, SAVED_HAYSTACK_STACK_OFFSET));\n+        __ addq(rScratch, rTmp);\n+        __ movq(r11, rScratch);\n+        __ jmp(L_checkRangeAndReturn);\n@@ -1153,3 +958,1 @@\n-      \/\/ needle_len is in elements, not bytes, for UTF-16\n-      __ cmpq(needle_len, isUU ? OPT_NEEDLE_SIZE_MAX \/ 2 : OPT_NEEDLE_SIZE_MAX);\n-      __ ja(L_begin);\n+        __ bind(L_compareFull);\n@@ -1157,31 +960,4 @@\n-      \/\/ Copy incoming haystack onto stack\n-      {\n-        Label L_adjustHaystack, L_moreThan16;\n-\n-        \/\/ Copy haystack to stack (haystack <= 32 bytes)\n-        __ subptr(rsp, COPIED_HAYSTACK_STACK_SIZE);\n-        __ cmpq(haystack_len, isU ? 0x8 : 0x10);\n-        __ ja_b(L_moreThan16);\n-\n-        __ movq(r8, COPIED_HAYSTACK_STACK_OFFSET + 0x10);\n-        __ movdqu(xmm0,\n-                  Address(haystack, haystack_len,\n-                          isU ? Address::times_2 : Address::times_1, -0x10));\n-        __ movdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), xmm0);\n-        __ jmpb(L_adjustHaystack);\n-\n-        __ bind(L_moreThan16);\n-        __ movq(r8, COPIED_HAYSTACK_STACK_OFFSET + 0x20);\n-        __ vmovdqu(xmm0,\n-                   Address(haystack, haystack_len,\n-                           isU ? Address::times_2 : Address::times_1, -0x20));\n-        __ vmovdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), xmm0);\n-\n-        __ bind(L_adjustHaystack);\n-        __ subq(r8, haystack_len);\n-        if (isU) {\n-          \/\/ For UTF-16, lengths are half\n-          __ subq(r8, haystack_len);\n-        }\n-        __ leaq(haystack, Address(rsp, r8, Address::times_1));\n-      }\n+        \/\/ rScratch has n - k.  Compare entire string word-by-word\n+        __ xorq(r11, r11);\n+        __ movq(r10, rScratch);\n+        __ jmpb(doCompare);\n@@ -1189,10 +965,4 @@\n-      \/\/ Creates a mask of (n - k + 1) ones.  This prevents\n-      \/\/ recognizing any false-positives past the end of\n-      \/\/ the valid haystack.\n-      __ movq(r8, -1);\n-      __ subq(haystack_len, needle_len);\n-      __ incq(haystack_len);\n-      if (isU) {\n-        __ shlq(haystack_len, 1);\n-      }\n-      __ bzhiq(r8, r8, haystack_len);\n+        __ bind(topLoop);\n+        __ addq(r11, 2);\n+        __ cmpq(r11, rScratch);\n+        __ jg(L_returnRBP);\n@@ -1200,16 +970,4 @@\n-      for (int size = 1; size <= OPT_NEEDLE_SIZE_MAX; size++) {\n-        \/\/ Broadcast next needle byte into ymm register\n-        int position = isUU ? (size - 1) * 2 : size - 1;\n-        if (isUU) {\n-          __ vpbroadcastw(xmm0, Address(needle, position),\n-                          Assembler::AVX_256bit);\n-        } else if (isUL) {\n-          \/\/ Expand needle\n-          __ movzbl(rax, Address(needle, position));\n-          __ movdl(xmm0, rax);\n-          \/\/ Byte of needle to words\n-          __ vpbroadcastw(xmm0, xmm0, Assembler::AVX_256bit);\n-        } else {\n-          __ vpbroadcastb(xmm0, Address(needle, position),\n-                          Assembler::AVX_256bit);\n-        }\n+        __ bind(doCompare);\n+        __ leaq(r9, Address(haystack, r11));\n+        __ leaq(r12, Address(needle, 0));\n+        __ movq(r13, origNeedleLen);\n@@ -1217,20 +975,4 @@\n-        \/\/ Compare next byte.  Keep the comparison mask in r8, which will\n-        \/\/ accumulate\n-        if (isU) {\n-          __ vpcmpeqw(xmm1, xmm0, Address(haystack, position),\n-                      Assembler::AVX_256bit);\n-        } else {\n-          __ vpcmpeqb(xmm1, xmm0, Address(haystack, position),\n-                      Assembler::AVX_256bit);\n-        }\n-        __ vpmovmskb(r9, xmm1, Assembler::AVX_256bit);\n-        __ andq(r8, r9);  \/\/ Accumulate matched bytes\n-        __ testl(r8, r8);\n-        __ je(L_noMatch);\n-\n-        if (size != OPT_NEEDLE_SIZE_MAX) {\n-          \/\/ Found a match for this needle size\n-          __ cmpq(needle_len, size);\n-          __ je(L_foundall);\n-        }\n-      }\n+        __C2 arrays_equals(false, r9, r12, r13, rax, rdx, xmm_tmp3, xmm_tmp4, false \/* char *\/, knoreg,\n+                           true \/* expand_ary2 *\/);\n+        __ testq(rax, rax);\n+        __ jz(topLoop);\n@@ -1238,4 +980,2 @@\n-      __ bind(L_foundall);\n-      __ tzcntl(rax, r8);\n-      if (isU) {\n-        __ shrq(rax, 1);\n+        \/\/ Match found\n+        __ jmp(L_checkRangeAndReturn);\n@@ -1243,0 +983,1 @@\n+    }\n@@ -1244,5 +985,3 @@\n-      __ bind(L_out);\n-      __ addptr(rsp, COPIED_HAYSTACK_STACK_SIZE);\n-      __ vzeroupper();\n-      __ leave();\n-      __ ret(0);\n+  } else {  \/\/ SSE version\n+    assert(false, \"Only supports AVX2\");\n+  }\n@@ -1250,4 +989,2 @@\n-      __ bind(L_noMatch);\n-      __ movq(rax, -1);\n-      __ jmpb(L_out);\n-    }\n+  return;\n+}\n@@ -1255,5 +992,20 @@\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\n-    \/\/ Set up jump table entries for both small and large haystack switches.\n+\/\/ Helper for broadcasting needle elements to ymm registers for compares\n+\/\/\n+\/\/ For UTF-16 encoded needles, broadcast a word at the proper offset to the ymm\n+\/\/ register (case UU)\n+\/\/ For the UTF-16 encoded haystack with Latin1 encoded needle (case UL) we have\n+\/\/ to read into a temp register to zero-extend the single byte needle value, then\n+\/\/ broadcast words to the ymm register.\n+\/\/\n+\/\/ Parameters:\n+\/\/ sizeKnown - True if size known at compile time\n+\/\/ size - the size of the needle.  Pass 0 if unknown at compile time\n+\/\/ bytesToCompare - see NUMBER_OF_NEEDLE_BYTES_TO_COMPARE above\n+\/\/ needle - the address of the first byte of the needle\n+\/\/ needleLen - length of needle if !sizeKnown\n+\/\/ isUU and isUL - true if argument encoding is UU or UL, respectively\n+\/\/ _masm - Current MacroAssembler instance pointer\n+static void broadcast_additional_needles(bool sizeKnown, int size, int bytesToCompare, Register needle,\n+                                         Register needleLen, Register rTmp, bool isUU, bool isUL,\n+                                         MacroAssembler *_masm) {\n+  Label L_done;\n@@ -1261,4 +1013,2 @@\n-    {\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-      \/\/\n-      \/\/ Small haystack (<32 bytes) switch\n+  const XMMRegister byte_1 = XMM_BYTE_1;\n+  const XMMRegister byte_2 = XMM_BYTE_2;\n@@ -1266,28 +1016,1 @@\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-      \/\/  On entry to each case of small_hs, the register state is:\n-      \/\/\n-      \/\/  rax = unused\n-      \/\/  rbx = &haystack\n-      \/\/  rcx = haystack length\n-      \/\/  rdx = &needle\n-      \/\/  rsi = haystack length\n-      \/\/  rdi = &haystack\n-      \/\/  rbp = -1\n-      \/\/  r8  = unused\n-      \/\/  r9  = unused\n-      \/\/  r10 = hs_len - needle len\n-      \/\/  r11 = unused\n-      \/\/  r12 = needle length\n-      \/\/  r13 = (needle length - 1)\n-      \/\/  r14 = &needle\n-      \/\/  r15 = unused\n-      \/\/  XMM_BYTE_0 - first element of needle, broadcast\n-      \/\/  XMM_BYTE_K - last element of needle, broadcast\n-      \/\/\n-      \/\/  The haystack is < 32 bytes\n-      \/\/\n-      \/\/ If a match is not found, branch to L_returnRBP (which will always\n-      \/\/ return -1).\n-      \/\/\n-      \/\/ If a match is found, jump to L_checkRangeAndReturn, which ensures the\n-      \/\/ matched needle is not past the end of the haystack.\n+  assert_different_registers(needle, needleLen, rTmp);\n@@ -1295,19 +1018,1 @@\n-#undef haystack\n-#define haystack rbx\n-#undef needle\n-#define needle r14\n-#undef needle_val\n-#define needle_val r8\n-#undef set_bit\n-#define set_bit r11\n-#undef eq_mask\n-#define eq_mask rsi\n-#undef rTmp\n-#define rTmp rax\n-\n-      for (int i = OPT_NEEDLE_SIZE_MAX; i < NUMBER_OF_CASES; i++) {\n-        small_hs_jmp_table[i] = __ pc();\n-        if (isU && ((i + 1) & 1)) {\n-          __ emit_int8(0xcc);\n-        } else {\n-          Label L_loopTop;\n+  bool isU = (isUU || isUL);\n@@ -1315,3 +1020,1 @@\n-          broadcast_additional_needles(true, i + 1,\n-                                       NUMBER_OF_NEEDLE_BYTES_TO_COMPARE,\n-                                       needle, noreg, rTmp, isUU, isUL, _masm);\n+  size = sizeKnown ? size : NUMBER_OF_CASES + 1;\n@@ -1319,3 +1022,5 @@\n-          compare_haystack_to_needle(true, i + 1, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE,\n-                                     L_returnRBP, haystack, isU, DO_EARLY_BAILOUT,\n-                                     eq_mask, noreg, rTmp, _masm);\n+  if (bytesToCompare > 2) {\n+    if (!sizeKnown) {\n+      __ cmpq(needleLen, (isU ? 4 : 2));\n+      __ jl_b(L_done);\n+    }\n@@ -1323,5 +1028,11 @@\n-          \/\/ small_case_helper(i + 1, L_returnRBP, ae, _masm);\n-          byte_compare_helper(i + 1, L_returnRBP, L_checkRangeAndReturn, needle,\n-                              needle_val, haystack, eq_mask, set_bit, rTmp, ae,\n-                              _masm);\n-        }\n+    if (size > (isU ? 4 : 2)) {\n+      \/\/ Add compare for second byte\n+      if (isUU) {\n+        __ vpbroadcastw(byte_1, Address(needle, 2), Assembler::AVX_256bit);\n+      } else if (isUL) {\n+        __ movzbl(rTmp, Address(needle, 1));\n+        __ movdl(byte_1, rTmp);\n+        \/\/ 1st byte of needle in words\n+        __ vpbroadcastw(byte_1, byte_1, Assembler::AVX_256bit);\n+      } else {\n+        __ vpbroadcastb(byte_1, Address(needle, 1), Assembler::AVX_256bit);\n@@ -1329,7 +1040,0 @@\n-\n-#undef haystack\n-#undef needle\n-#undef needle_val\n-#undef set_bit\n-#undef eq_mask\n-#undef rTmp\n@@ -1338,28 +1042,5 @@\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\n-    \/\/ Large haystack (>=32 bytes) switch\n-\n-    {\n-\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-      \/\/  On entry to each case of large_hs, the register state is:\n-      \/\/\n-      \/\/  rax = unused\n-      \/\/  rbx = &haystack\n-      \/\/  rcx = haystack length\n-      \/\/  rdx = &needle\n-      \/\/  rsi = haystack length\n-      \/\/  rdi = &haystack\n-      \/\/  rbp = -1\n-      \/\/  r8  = unused\n-      \/\/  r9  = unused\n-      \/\/  r10 = hs_len - needle len\n-      \/\/  r11 = unused\n-      \/\/  r12 = needle length\n-      \/\/  r13 = (needle length - 1)\n-      \/\/  r14 = &needle\n-      \/\/  r15 = unused\n-      \/\/  XMM_BYTE_0 - first element of needle, broadcast\n-      \/\/  XMM_BYTE_K - last element of needle, broadcast\n-      \/\/\n-      \/\/  The haystack is >= 32 bytes\n+    if (bytesToCompare > 3) {\n+      if (!sizeKnown) {\n+        __ cmpq(needleLen, (isU ? 6 : 3));\n+        __ jl_b(L_done);\n+      }\n@@ -1367,21 +1048,9 @@\n-#undef haystack\n-#define haystack rbx\n-#undef needle\n-#define needle r14\n-#undef needleLen\n-#define needleLen r12\n-#undef needle_val\n-#define needle_val r15\n-#undef set_bit\n-#define set_bit r8\n-#undef eq_mask\n-#define eq_mask r9\n-#undef rTmp\n-#define rTmp r13\n-#undef hs_ptr\n-#define hs_ptr rcx\n-\n-      for (int i = 0; i < NUMBER_OF_CASES; i++) {\n-        large_hs_jmp_table[i] = __ pc();\n-        if (isU && ((i + 1) & 1)) {\n-          __ emit_int8(0xcc);\n+      if (size > (isU ? 6 : 3)) {\n+        \/\/ Add compare for third byte\n+        if (isUU) {\n+          __ vpbroadcastw(byte_2, Address(needle, 4), Assembler::AVX_256bit);\n+        } else if (isUL) {\n+          __ movzbl(rTmp, Address(needle, 2));\n+          __ movdl(byte_1, rTmp);\n+          \/\/ 1st byte of needle in words\n+          __ vpbroadcastw(byte_1, byte_1, Assembler::AVX_256bit);\n@@ -1389,7 +1058,1 @@\n-          Label L_loopTop;\n-\n-          big_case_loop_helper(true, i + 1, L_checkRangeAndReturn, L_loopTop,\n-                               eq_mask, hs_ptr, needleLen, ae, _masm);\n-          byte_compare_helper(i + 1, L_loopTop, L_bigCaseFixupAndReturn, needle,\n-                              needle_val, hs_ptr, eq_mask, set_bit, rTmp, ae,\n-                              _masm);\n+          __ vpbroadcastb(byte_2, Address(needle, 2), Assembler::AVX_256bit);\n@@ -1398,9 +1061,0 @@\n-\n-#undef haystack\n-#undef needle\n-#undef needle_val\n-#undef set_bit\n-#undef eq_mask\n-#undef rTmp\n-#undef hs_ptr\n-#undef needleLen\n@@ -1408,6 +1062,3 @@\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/ JUMP TABLES\n-    __ align(8);\n+    __ bind(L_done);\n+  }\n+}\n@@ -1415,1 +1066,29 @@\n-    jump_table = __ pc();\n+\/\/ Helper for comparing needle elements to a big haystack\n+\/\/\n+\/\/ This helper compares bytes or words in the ymm registers to\n+\/\/ the proper positions within the haystack.  It will bail out early if\n+\/\/ doEarlyBailout is true, otherwise it will progressively and together\n+\/\/ the comparison results, returning the answer at the end.\n+\/\/\n+\/\/ On return, eq_mask will be set to the comparison mask value.  If no match\n+\/\/ is found, this helper will jump to noMatch.\n+\/\/\n+\/\/ Parameters:\n+\/\/ sizeKnown - True if size known at compile time\n+\/\/ size - the size of the needle.  Pass 0 if unknown at compile time\n+\/\/ bytesToCompare - see NUMBER_OF_NEEDLE_BYTES_TO_COMPARE above\n+\/\/ noMatch - label bound outside to jump to if there is no match\n+\/\/ haystack - the address of the first byte of the haystack\n+\/\/ hsLen - the sizeof the haystack\n+\/\/ isU - true if argument encoding is either UU or UL\n+\/\/ doEarlyBailout - if true, check mismatch after every comparison\n+\/\/ eq_mask - The bit mask returned that holds the result of the comparison\n+\/\/ rTmp - a temporary register\n+\/\/ nMinusK - Size of haystack minus size of needle\n+\/\/ _masm - Current MacroAssembler instance pointer\n+\/\/\n+\/\/ If (n - k) < 32, need to handle reading past end of haystack\n+static void compare_big_haystack_to_needle(bool sizeKnown, int size, int bytesToCompare, Label &noMatch,\n+                                           Register haystack, Register hsLen, Register needleLen, bool isU,\n+                                           bool doEarlyBailout, Register eq_mask, Register rTmp, Register nMinusK,\n+                                           MacroAssembler *_masm) {\n@@ -1417,3 +1096,2 @@\n-    for (jmp_ndx = 0; jmp_ndx < NUMBER_OF_CASES; jmp_ndx++) {\n-      __ emit_address(large_hs_jmp_table[jmp_ndx]);\n-    }\n+  assert_different_registers(eq_mask, haystack, needleLen, rTmp, hsLen, r10);\n+  assert(r10 == nMinusK, \"Bad register\");\n@@ -1421,1 +1099,4 @@\n-    jump_table_1 = __ pc();\n+  const XMMRegister byte_0 = XMM_BYTE_0;\n+  const XMMRegister byte_1 = XMM_BYTE_1;\n+  const XMMRegister byte_2 = XMM_BYTE_2;\n+  const XMMRegister byte_k = XMM_BYTE_K;\n@@ -1423,3 +1104,2 @@\n-    for (jmp_ndx = 0; jmp_ndx < NUMBER_OF_CASES; jmp_ndx++) {\n-      __ emit_address(small_hs_jmp_table[jmp_ndx]);\n-    }\n+  int scale = isU ? 2 : 1;\n+  std::function<void(XMMRegister dst, XMMRegister src, Address adr, int vector_len)> vpcmpeq;\n@@ -1427,1 +1107,9 @@\n-    __ align(CodeEntryAlignment);\n+  if (isU) {\n+    vpcmpeq = [_masm](XMMRegister dst, XMMRegister src, Address adr, int vector_len) {\n+      __ vpcmpeqw(dst, src, adr, vector_len);\n+    };\n+  } else {\n+    vpcmpeq = [_masm](XMMRegister dst, XMMRegister src, Address adr, int vector_len) {\n+      __ vpcmpeqb(dst, src, adr, vector_len);\n+    };\n+  }\n@@ -1429,5 +1117,7 @@\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\n-    \/\/ Big case default:\n+#undef cmp_0\n+#define cmp_0 XMM_TMP3\n+#undef cmp_k\n+#define cmp_k XMM_TMP4\n+#undef lastCompare\n+#define lastCompare rTmp\n+#undef lastMask\n@@ -1435,2 +1125,2 @@\n-    {\n-      Label L_loopTop, L_innerLoop, L_found;\n+  int sizeIncr = isU ? 2 : 1;\n+  bool needToSaveRCX = false;\n@@ -1438,18 +1128,2 @@\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-      \/\/\n-      \/\/ Big case default:\n-      \/\/\n-      \/\/  rbx: haystack\n-      \/\/  rcx: k\n-      \/\/  rdx: junk\n-      \/\/  rsi: n\n-      \/\/  rdi: haystack\n-      \/\/  r10: n - k\n-      \/\/  r12: k\n-      \/\/  r13: junk\n-      \/\/  r14: needle\n-      \/\/  rbp: -1\n-      \/\/  XMM_BYTE_0 - first element of needle broadcast\n-      \/\/  XMM_BYTE_K - last element of needle broadcast\n+  needToSaveRCX = (haystack == rcx) || (hsLen == rcx) || (eq_mask == rcx) || (rTmp == rcx) || (needleLen == rcx)\n+                  || (nMinusK == rcx);\n@@ -1457,1 +1131,1 @@\n-      __ bind(L_bigCaseDefault);\n+  Label L_OKtoCompareFull, L_done, L_specialCase_gt2, L_specialCase_gt3;\n@@ -1459,24 +1133,1 @@\n-#undef hsPtrRet\n-#define hsPtrRet rax\n-#undef mask\n-#define mask r8\n-#undef index\n-#define index r9\n-#undef firstNeedleCompare\n-#define firstNeedleCompare rdx\n-#undef compLen\n-#define compLen rbp\n-#undef haystackStart\n-#define haystackStart rcx\n-#undef rScratch\n-#define rScratch r13   \/\/ Can't use r11 here...\n-#undef needleLen\n-#define needleLen r12\n-#undef needle\n-#define needle r14\n-#undef haystack\n-#define haystack rbx\n-#undef retval\n-#define retval r15\n-        big_case_loop_helper(false, 0, L_checkRangeAndReturn, L_loopTop, mask,\n-                             hsPtrRet, needleLen, ae, _masm);\n+  assert(!sizeKnown || (sizeKnown && ((size > 0) && (size <= NUMBER_OF_CASES))), \"Incorrect size given\");\n@@ -1484,0 +1135,3 @@\n+  Address kThByte\n+      = sizeKnown ? Address(haystack, size - sizeIncr) : Address(haystack, needleLen, Address::times_1, -(sizeIncr));\n+  size = sizeKnown ? size : NUMBER_OF_CASES + 1;\n@@ -1485,3 +1139,2 @@\n-      __ align(8);\n-      __ bind(L_innerLoop);\n-      __ tzcntl(index, mask);\n+  \/\/ Compare first byte of needle to haystack\n+     vpcmpeq(cmp_0, byte_0, Address(haystack, 0), Assembler::AVX_256bit);\n@@ -1489,17 +1142,5 @@\n-      __ leaq(haystackStart,\n-              Address(hsPtrRet, index, Address::times_1,\n-                      isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2\n-                          : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n-      __ leaq(firstNeedleCompare,\n-              Address(needle, isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2\n-                                  : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n-      __ leaq(compLen,\n-              Address(needleLen,\n-                      isU ? -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE * 2)\n-                          : -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE)));  \/\/ nlen - 2\n-                                                                     \/\/ elements\n-      __C2 arrays_equals(false, haystackStart, firstNeedleCompare, compLen,\n-                         retval, rScratch, xmm_tmp3, xmm_tmp4, false \/* char *\/,\n-                         knoreg);\n-      __ testl(retval, retval);\n-      __ jne_b(L_found);\n+  if (doEarlyBailout) {\n+    __ vpmovmskb(eq_mask, cmp_0, Assembler::AVX_256bit);\n+    __ testl(eq_mask, eq_mask);\n+    __ je(noMatch);\n+  }\n@@ -1507,3 +1148,6 @@\n-      CLEAR_BIT(mask, index);\n-      __ jne(L_innerLoop);\n-      __ jmp(L_loopTop);\n+  if (size == (isU ? 2 : 1)) {\n+    __ vpmovmskb(eq_mask, cmp_0, Assembler::AVX_256bit);\n+  } else {\n+    __ cmpq(nMinusK, 32);\n+    __ jae(L_OKtoCompareFull);\n+    __ vpmovmskb(eq_mask, cmp_0, Assembler::AVX_256bit);\n@@ -1511,5 +1155,13 @@\n-      __ bind(L_found);\n-      __ subq(hsPtrRet, haystack);\n-      __ addq(hsPtrRet, index);\n-      __ movq(r11, hsPtrRet);\n-      __ jmp(L_checkRangeAndReturn);\n+    \/\/ If n-k less than 32, comparing the last byte of the needle will result\n+    \/\/ in reading past the end of the haystack.  Account for this here.\n+    __ leaq(lastCompare, Address(haystack, hsLen, Address::times_1, -32));\n+#undef cmp_0\n+#undef saveRCX\n+#define saveRCX XMM_TMP3\n+    if (needToSaveRCX) {\n+      __ movdq(saveRCX, rcx);\n+    }\n+#undef shiftVal\n+#define shiftVal rcx\n+    __ movq(shiftVal, isU ? 30 : 31);\n+    __ subq(shiftVal, nMinusK);\n@@ -1517,0 +1169,1 @@\n+       vpcmpeq(cmp_k, byte_k, Address(lastCompare, 0), Assembler::AVX_256bit);\n@@ -1518,8 +1171,8 @@\n-#undef hsPtrRet\n-#undef mask\n-#undef index\n-#undef firstNeedleCompare\n-#undef compLen\n-#undef haystackStart\n-#undef rScratch\n-#undef needleLen\n+#undef lastCompare\n+#define lastMask rTmp\n+    __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n+    __ shrq(lastMask);\n+#undef shiftVal\n+    __ andq(eq_mask, lastMask);\n+    if (needToSaveRCX) {\n+      __ movdq(rcx, saveRCX);\n@@ -1527,0 +1180,1 @@\n+#undef saveRCX\n@@ -1528,22 +1182,13 @@\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\n-    \/\/ Small case default:\n-    \/\/\n-    \/\/  rbx: haystack\n-    \/\/  r14: needle\n-    \/\/  r13: k - 1\n-    \/\/  r12: k\n-    \/\/  r10: n - k\n-    \/\/  rbp: -1\n-    \/\/  rdi: junk\n-    \/\/  rsi: n\n-    \/\/  rdx: junk\n-    \/\/  rcx: junk\n-    \/\/  XMM_BYTE_0 - first element of needle broadcast\n-    \/\/  XMM_BYTE_K - last element of needle broadcast\n-    \/\/\n-    \/\/  Haystack always copied to stack, so 32-byte reads OK\n-    \/\/  Haystack length < 32\n-    \/\/  10 < needle length < 32\n+    if (bytesToCompare > 2) {\n+      if (size > (isU ? 4 : 2)) {\n+        if (doEarlyBailout) {\n+          __ testl(eq_mask, eq_mask);\n+          __ je(noMatch);\n+        }\n+        __ cmpq(hsLen, isU ? 34 : 33);\n+        __ jl(L_specialCase_gt2);\n+           vpcmpeq(cmp_k, byte_1, Address(haystack, 1 * scale), Assembler::AVX_256bit);\n+        __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n+        __ andq(eq_mask, lastMask);\n+      }\n+    }\n@@ -1551,2 +1196,21 @@\n-    {\n-      __ bind(L_smallCaseDefault);\n+    if (bytesToCompare > 3) {\n+      if (size > (isU ? 6 : 3)) {\n+        if (doEarlyBailout) {\n+          __ testl(eq_mask, eq_mask);\n+          __ je(noMatch);\n+        }\n+        __ cmpq(hsLen, isU ? 36 : 34);\n+        __ jl(L_specialCase_gt3);\n+           vpcmpeq(cmp_k, byte_2, Address(haystack, 2 * scale), Assembler::AVX_256bit);\n+        __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n+        __ andq(eq_mask, lastMask);\n+      }\n+    }\n+    __ jmpb(L_done);\n+\n+    __ bind(L_specialCase_gt2);\n+    \/\/ Comparing multiple bytes and haystack length == 32\n+       vpcmpeq(cmp_k, byte_1, Address(haystack, 0), Assembler::AVX_256bit);\n+    __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n+    __ shrq(lastMask, isU ? 2 : 1);\n+    __ andq(eq_mask, lastMask);\n@@ -1554,1 +1218,12 @@\n-      Label L_innerLoop;\n+    if (bytesToCompare > 3) {\n+      if (size > (isU ? 6 : 3)) {\n+        if (doEarlyBailout) {\n+          __ testl(eq_mask, eq_mask);\n+          __ je(noMatch);\n+        }\n+           vpcmpeq(cmp_k, byte_2, Address(haystack, 0), Assembler::AVX_256bit);\n+        __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n+        __ shrq(lastMask, isU ? 4 : 2);\n+        __ andq(eq_mask, lastMask);\n+      }\n+    }\n@@ -1556,18 +1231,1 @@\n-#undef needle\n-#define needle r14\n-#undef needleLen\n-#define needleLen r12\n-#undef firstNeedleCompare\n-#define firstNeedleCompare rdx\n-#undef compLen\n-#define compLen r9\n-#undef haystack\n-#define haystack rbx\n-#undef mask\n-#define mask r8\n-#undef rTmp\n-#define rTmp rdi\n-#undef rTmp2\n-#define rTmp2 r13\n-#undef rTmp3\n-#define rTmp3 rax\n+    __ jmp(L_done);\n@@ -1575,9 +1233,6 @@\n-#undef cmp_0\n-#define cmp_0 XMM_TMP3\n-#undef cmp_k\n-#define cmp_k XMM_TMP4\n-#undef result\n-#define result XMM_TMP3\n-      broadcast_additional_needles(false, 0 \/* unknown *\/,\n-                                   NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, needle,\n-                                   needleLen, rTmp3, isUU, isUL, _masm);\n+    __ bind(L_specialCase_gt3);\n+    \/\/ Comparing multiple bytes and hs length == isU ? 34 : 33\n+       vpcmpeq(cmp_k, byte_2, Address(haystack, 0), Assembler::AVX_256bit);\n+    __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n+    __ shrq(lastMask, isU ? 4 : 2);\n+    __ andq(eq_mask, lastMask);\n@@ -1585,12 +1240,1 @@\n-      assert(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 4, \"Invalid\");\n-      assert(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE >= 2, \"Invalid\");\n-      __ leaq(firstNeedleCompare,\n-              Address(needle, isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2\n-                                  : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n-      __ leaq(compLen,\n-              Address(needleLen,\n-                      isU ? -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE * 2)\n-                          : -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE)));  \/\/ nlen - 2\n-                                                                     \/\/ elements\n-      \/\/  firstNeedleCompare has address of second element of needle\n-      \/\/  compLen has length of comparison to do\n+    __ jmp(L_done);\n@@ -1598,3 +1242,4 @@\n-      compare_haystack_to_needle(false, 0, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE,\n-                                L_returnRBP, haystack, isU, DO_EARLY_BAILOUT,\n-                                mask, needleLen, rTmp3, _masm);\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    __ bind(L_OKtoCompareFull);\n+#define result XMM_TMP3\n+#define cmp_0 XMM_TMP3\n@@ -1602,8 +1247,2 @@\n-#undef needle\n-#undef saveCompLen\n-#define saveCompLen r14\n-#undef needleLen\n-#undef saveNeedleAddress\n-#define saveNeedleAddress r12\n-      __ movq(saveCompLen, compLen);\n-      __ movq(saveNeedleAddress, firstNeedleCompare);  \/\/ Save address of 2nd element of needle\n+    \/\/ Compare last byte of needle to haystack at proper position\n+       vpcmpeq(cmp_k, byte_k, kThByte, Assembler::AVX_256bit);\n@@ -1611,3 +1250,1 @@\n-      __ align(8);\n-      __ bind(L_innerLoop);\n-      __ tzcntl(r11, mask);\n+    __ vpand(result, cmp_k, cmp_0, Assembler::AVX_256bit);\n@@ -1615,3 +1252,11 @@\n-      __ leaq(rTmp, Address(haystack, r11, Address::times_1,\n-                            isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2\n-                                : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n+    if (bytesToCompare > 2) {\n+      if (size > (isU ? 4 : 2)) {\n+        if (doEarlyBailout) {\n+          __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n+          __ testl(eq_mask, eq_mask);\n+          __ je(noMatch);\n+        }\n+           vpcmpeq(cmp_k, byte_1, Address(haystack, 1 * scale), Assembler::AVX_256bit);\n+        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n+      }\n+    }\n@@ -1619,4 +1264,11 @@\n-      __C2 arrays_equals(false, rTmp, firstNeedleCompare, compLen, rTmp3, rTmp2, xmm_tmp3, xmm_tmp4,\n-                       false \/* char *\/, knoreg);\n-      __ testl(rTmp3, rTmp3);\n-      __ jne_b(L_checkRangeAndReturn);\n+    if (bytesToCompare > 3) {\n+      if (size > (isU ? 6 : 3)) {\n+        if (doEarlyBailout) {\n+          __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n+          __ testl(eq_mask, eq_mask);\n+          __ je(noMatch);\n+        }\n+           vpcmpeq(cmp_k, byte_2, Address(haystack, 2 * scale), Assembler::AVX_256bit);\n+        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n+      }\n+    }\n@@ -1624,5 +1276,2 @@\n-      __ movq(compLen, saveCompLen);\n-      __ movq(firstNeedleCompare, saveNeedleAddress);\n-      CLEAR_BIT(mask, rTmp3);\n-      __ jne(L_innerLoop);\n-      __ jmp(L_returnRBP);\n+    __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n+  }\n@@ -1630,9 +1279,5 @@\n-#undef needle\n-#undef needleLen\n-#undef firstNeedleCompare\n-#undef compLen\n-#undef haystack\n-#undef mask\n-#undef rTmp\n-#undef rTmp2\n-#undef rTmp3\n+  __ bind(L_done);\n+  __ testl(eq_mask, eq_mask);\n+  __ je(noMatch);\n+  \/\/ At this point, we have at least one \"match\" where first and last bytes\n+  \/\/ of the needle are found the correct distance apart.\n@@ -1642,3 +1287,4 @@\n-#undef saveCompLen\n-#undef saveNeedleAddress\n-    }\n+#undef lastCompare\n+#undef lastMask\n+#undef saveRCX\n+}\n@@ -1646,3 +1292,30 @@\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Helper for comparing needle elements to a small haystack\n+\/\/\n+\/\/ This helper compares bytes or words in the ymm registers to\n+\/\/ the proper positions within the haystack.  It will bail out early if\n+\/\/ doEarlyBailout is true, otherwise it will progressively and together\n+\/\/ the comparison results, returning the answer at the end.\n+\/\/\n+\/\/ On return, eq_mask will be set to the comparison mask value.  If no match\n+\/\/ is found, this helper will jump to noMatch.\n+\/\/\n+\/\/ Parameters:\n+\/\/ sizeKnown - if true, size is valid and needleLen invalid.\n+\/\/             if false, size invalid and needleLen valid.\n+\/\/ size - the size of the needle.  Pass 0 if unknown at compile time\n+\/\/ bytesToCompare - see NUMBER_OF_NEEDLE_BYTES_TO_COMPARE above\n+\/\/ noMatch - label bound outside to jump to if there is no match\n+\/\/ haystack - the address of the first byte of the haystack\n+\/\/ isU - true if argument encoding is either UU or UL\n+\/\/ doEarlyBailout - if true, check mismatch after every comparison\n+\/\/ eq_mask - The bit mask returned that holds the result of the comparison\n+\/\/ needleLen - a temporary register.  Only used if isUL true\n+\/\/ _masm - Current MacroAssembler instance pointer\n+\/\/\n+\/\/ No need to worry about reading past end of haystack since haystack\n+\/\/ has been copied to the stack\n+\/\/\n+\/\/ If !sizeKnown, needle is at least 11 bytes long\n+static void compare_haystack_to_needle(bool sizeKnown, int size, int bytesToCompare, Label &noMatch, Register haystack,\n+                                       bool isU, bool doEarlyBailout, Register eq_mask, Register needleLen,\n+                                       Register rTmp, MacroAssembler *_masm) {\n@@ -1650,3 +1323,1 @@\n-    __ bind(L_returnError);\n-    __ movq(rbp, -1);\n-    __ jmpb(L_returnRBP);\n+  assert_different_registers(eq_mask, haystack, needleLen, rTmp, r10);\n@@ -1654,3 +1325,8 @@\n-    __ bind(L_returnZero);\n-    __ xorl(rbp, rbp);\n-    __ jmpb(L_returnRBP);\n+  const XMMRegister byte_0 = XMM_BYTE_0;\n+  const XMMRegister byte_1 = XMM_BYTE_1;\n+  const XMMRegister byte_2 = XMM_BYTE_2;\n+  const XMMRegister byte_k = XMM_BYTE_K;\n+  \/\/ NOTE: cmp_0 and result are the same register\n+  const XMMRegister cmp_0 = XMM_TMP3;\n+  const XMMRegister result = XMM_TMP3;\n+  const XMMRegister cmp_k = XMM_TMP4;\n@@ -1658,4 +1334,2 @@\n-    __ bind(L_bigCaseFixupAndReturn);\n-    __ movl(rax, r8);\n-    __ subq(rcx, rbx);\n-    __ addq(rcx, rax);\n+  int scale = isU ? 2 : 1;\n+  std::function<void(XMMRegister dst, XMMRegister src, Address adr, int vector_len)> vpcmpeq;\n@@ -1663,2 +1337,9 @@\n-    __ bind(L_checkRangeAndReturnRCX);\n-    __ movq(r11, rcx);\n+  if (isU) {\n+    vpcmpeq = [_masm](XMMRegister dst, XMMRegister src, Address adr, int vector_len) {\n+      __ vpcmpeqw(dst, src, adr, vector_len);\n+    };\n+  } else {\n+    vpcmpeq = [_masm](XMMRegister dst, XMMRegister src, Address adr, int vector_len) {\n+      __ vpcmpeqb(dst, src, adr, vector_len);\n+    };\n+  }\n@@ -1666,4 +1347,1 @@\n-    __ bind(L_checkRangeAndReturn);\n-    __ cmpq(r11, r10);\n-    __ movq(rbp, -1);\n-    __ cmovq(Assembler::belowEqual, rbp, r11);\n+  int sizeIncr = isU ? 2 : 1;\n@@ -1671,26 +1349,33 @@\n-    __ bind(L_returnRBP);\n-    __ movq(rax, rbp);\n-    __ addptr(rsp, STACK_SPACE);\n-    __ pop(rbp);\n-#ifdef _WIN64\n-    __ pop(r9);\n-    __ pop(r8);\n-    __ pop(rcx);\n-    __ pop(rdi);\n-    __ pop(rsi);\n-#endif\n-#ifdef PUSH_REGS\n-    __ pop(rbx);\n-    __ pop(r12);\n-    __ pop(r13);\n-    __ pop(r14);\n-    __ pop(r15);\n-#else\n-    __ movdq(r12, save_r12);\n-    __ movdq(r13, save_r13);\n-    __ movdq(r14, save_r14);\n-    __ movdq(r15, save_r15);\n-    __ movdq(rbx, save_rbx);\n-#endif\n-    if (isU) {\n-      __ sarq(rax, 1);\n+  assert((!sizeKnown) || (((size > 0) && (size <= NUMBER_OF_CASES))), \"Incorrect size given\");\n+\n+  Address kThByte\n+      = sizeKnown ? Address(haystack, size - sizeIncr) : Address(haystack, needleLen, Address::times_1, -(sizeIncr));\n+  size = sizeKnown ? size : NUMBER_OF_CASES + 1;\n+\n+  \/\/ Creates a mask of (n - k + 1) ones.  This prevents\n+  \/\/ recognizing any false-positives past the end of\n+  \/\/ the valid haystack.\n+  __ movq(rTmp, -1);\n+  __ movq(eq_mask, r10);  \/\/ Assumes r10 has n - k\n+  __ addq(eq_mask, 1);\n+  __ bzhiq(rTmp, rTmp, eq_mask);\n+\n+  \/\/ Compare first byte of needle to haystack\n+     vpcmpeq(cmp_0, byte_0, Address(haystack, 0), Assembler::AVX_256bit);\n+  if (size != (isU ? 2 : 1)) {\n+    \/\/ Compare last byte of needle to haystack at proper position\n+       vpcmpeq(cmp_k, byte_k, kThByte, Assembler::AVX_256bit);\n+\n+    __ vpand(result, cmp_k, cmp_0, Assembler::AVX_256bit);\n+\n+    if (bytesToCompare > 2) {\n+      if (size > (isU ? 4 : 2)) {\n+        if (doEarlyBailout) {\n+          __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n+          __ andq(eq_mask, rTmp);\n+          __ testl(eq_mask, eq_mask);\n+          __ je(noMatch);\n+        }\n+           vpcmpeq(cmp_k, byte_1, Address(haystack, 1 * scale), Assembler::AVX_256bit);\n+        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n+      }\n@@ -1698,1 +1383,0 @@\n-    __ vzeroupper();\n@@ -1700,2 +1384,13 @@\n-    __ leave();  \/\/ required for proper stackwalking of RuntimeStub frame\n-    __ ret(0);\n+    if (bytesToCompare > 3) {\n+      if (size > (isU ? 6 : 3)) {\n+        if (doEarlyBailout) {\n+          __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n+          __ andq(eq_mask, rTmp);\n+          __ testl(eq_mask, eq_mask);\n+          __ je(noMatch);\n+        }\n+           vpcmpeq(cmp_k, byte_2, Address(haystack, 2 * scale), Assembler::AVX_256bit);\n+        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n+      }\n+    }\n+  }\n@@ -1703,3 +1398,2 @@\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n+  __ andq(eq_mask, rTmp);\n@@ -1707,20 +1401,5 @@\n-    __ bind(L_begin);\n-#ifdef PUSH_REGS\n-    __ push(r15);\n-    __ push(r14);\n-    __ push(r13);\n-    __ push(r12);\n-    __ push(rbx);\n-#else\n-    __ movdq(save_r12, r12);\n-    __ movdq(save_r13, r13);\n-    __ movdq(save_r14, r14);\n-    __ movdq(save_r15, r15);\n-    __ movdq(save_rbx, rbx);\n-#endif\n-#ifdef _WIN64\n-    __ push(rsi);\n-    __ push(rdi);\n-    __ push(rcx);\n-    __ push(r8);\n-    __ push(r9);\n+  __ testl(eq_mask, eq_mask);\n+  __ je(noMatch);\n+  \/\/ At this point, we have at least one \"match\" where first and last bytes\n+  \/\/ of the needle are found the correct distance apart.\n+}\n@@ -1728,5 +1407,38 @@\n-    __ movq(rdi, rcx);\n-    __ movq(rsi, rdx);\n-    __ movq(rdx, r8);\n-    __ movq(rcx, r9);\n-#endif\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Helper for big haystack loop construct\n+\/\/\n+\/\/ For UTF-16 encoded needles, broadcast a word at the proper offset to the ymm\n+\/\/ register (case UU)\n+\/\/ For the UTF-16 encoded haystack with Latin1 encoded needle (case UL) we have\n+\/\/ to read into a temp register to zero-extend the single byte needle value, then\n+\/\/ broadcast words to the ymm register.\n+\/\/\n+\/\/ Parameters:\n+\/\/ sizeKnown - if true, size is valid and needleLen invalid.\n+\/\/ size - the size of the needle.  Pass 0 if unknown at compile time\n+\/\/ noMatch - label bound outside to jump to if there is no match\n+\/\/ loop_top - label bound inside this helper that should be branched to\n+\/\/            for additional comparisons.\n+\/\/ eq_mask - The bit mask returned that holds the result of the comparison\n+\/\/ hsPtrRet - This will hold the place within the needle where a match is found\n+\/\/            This is modified\n+\/\/ needleLen - The length of the needle\n+\/\/ ae - Argument encoding\n+\/\/ _masm - Current MacroAssembler instance pointer\n+\/\/\n+\/\/ On entry:\n+\/\/\n+\/\/  rbx: haystack\n+\/\/  rcx: k\n+\/\/  rdx: junk\n+\/\/  rsi: n\n+\/\/  rdi: haystack\n+\/\/  r10: n - k\n+\/\/  r12: k\n+\/\/  r13: junk\n+\/\/  r14: needle\n+\/\/  rbp: -1\n+\/\/  XMM_BYTE_0 - first element of needle broadcast\n+\/\/  XMM_BYTE_K - last element of needle broadcast\n@@ -1734,2 +1446,4 @@\n-    __ push(rbp);\n-    __ subptr(rsp, STACK_SPACE);\n+static void big_case_loop_helper(bool sizeKnown, int size, Label &noMatch, Label &loop_top, Register eq_mask,\n+                                 Register hsPtrRet, Register needleLen, StrIntrinsicNode::ArgEncoding ae,\n+                                 MacroAssembler *_masm) {\n+  Label temp;\n@@ -1737,1 +1451,1 @@\n-    __ movq(rbp, -1);\n+  assert_different_registers(eq_mask, hsPtrRet, needleLen, rdi, r15, rdx, rsi, rbx, r14, r10);\n@@ -1739,4 +1453,6 @@\n-    if (isUL) {\n-      \/\/ Branch out if doing wide chars\n-      __ jmp(L_wcharBegin);\n-    }\n+  const Register needle = r14;\n+  const Register haystack = rbx;\n+  const Register hsLength = rsi;\n+  const Register last = rdi;\n+  const Register temp1 = r15;\n+  const Register temp2 = rdx;\n@@ -1744,4 +1460,4 @@\n-    if (isUU) {  \/\/ Adjust sizes of hs and needle\n-      __ shlq(needle_len, 1);\n-      __ shlq(haystack_len, 1);\n-    }\n+  bool isLL = (ae == StrIntrinsicNode::LL);\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = isUL || isUU;  \/\/ At least one is UTF-16\n@@ -1749,4 +1465,2 @@\n-    \/\/ wide char processing comes here after expanding needle\n-    __ bind(L_continue);\n-    __ movq(r10, haystack_len);\n-    __ subq(r10, needle_len);\n+  assert_different_registers(eq_mask, hsPtrRet, needleLen, haystack, needle, hsLength, last);\n+  \/\/  hsLength, termAddr, last);\n@@ -1754,3 +1468,4 @@\n-    __ movq(save_ndl_len, needle_len);\n-    __ movq(r14, needle);\n-    __ movq(rbx, haystack);\n+  if (isU && (size & 1)) {\n+    __ emit_int8(0xcc);\n+    return;\n+  }\n@@ -1758,2 +1473,2 @@\n-    {\n-      Label L_short;\n+  broadcast_additional_needles(sizeKnown, size, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, needle, needleLen, temp1, isUU, isUL,\n+                               _masm);\n@@ -1761,6 +1476,1 @@\n-      \/\/ Always need needle broadcast to ymm registers\n-      if (isU) {\n-        __ vpbroadcastw(byte_0, Address(needle, 0), Assembler::AVX_256bit);\n-      } else {\n-        __ vpbroadcastb(byte_0, Address(needle, 0), Assembler::AVX_256bit);\n-      }\n+  __ movq(r11, -1);\n@@ -1768,2 +1478,11 @@\n-      __ cmpq(needle_len, isU ? 2 : 1);\n-      __ je_b(L_short);\n+  \/\/ Read 32-byte chunks at a time until the last 32-byte read would go\n+  \/\/ past the end of the haystack.  Then, set the final read to read exactly\n+  \/\/ the number of bytes in the haystack.\n+  \/\/ For example, if haystack length is 45 and needle length is 13, the compares\n+  \/\/ will read the following bytes:\n+  \/\/\n+  \/\/  First compare          Last compare\n+  \/\/   [  0 : 31]            [12 : 43]\n+  \/\/ Next compare will go past end of haystack ([32:63])\n+  \/\/ Adjust so final read is:\n+  \/\/   [  1 : 32]            [13 : 44]\n@@ -1771,7 +1490,4 @@\n-      if (isU) {\n-        __ vpbroadcastw(byte_k, Address(needle, needle_len, Address::times_1, -2),\n-                        Assembler::AVX_256bit);\n-      } else {\n-        __ vpbroadcastb(byte_k, Address(needle, needle_len, Address::times_1, -1),\n-                        Assembler::AVX_256bit);\n-      }\n+  __ movq(hsPtrRet, haystack);\n+  \/\/ Assume r10 is n - k\n+  __ leaq(last, Address(haystack, r10, Address::times_1, isU ? -30 : -31));\n+  __ jmpb(temp);\n@@ -1779,2 +1495,5 @@\n-      __ bind(L_short);\n-    }\n+  __ align(16);\n+  __ bind(loop_top);\n+  __ cmpq(hsPtrRet, last);\n+  __ je(noMatch);\n+  __ addq(hsPtrRet, 32);\n@@ -1782,2 +1501,2 @@\n-    __ cmpq(haystack_len, 0x20);\n-    __ jae_b(L_bigSwitchTop);\n+  __ cmpq(hsPtrRet, last);\n+  __ cmovq(Assembler::aboveEqual, hsPtrRet, last);\n@@ -1785,2 +1504,1 @@\n-    {\n-      Label L_moreThan16, L_adjustHaystack;\n+  __ bind(temp);\n@@ -1788,2 +1506,4 @@\n-      const Register index = rax;\n-      const Register haystack = rbx;\n+  \/\/ compare_big_haystack_to_needle will jump to loop_top until a match has been\n+  \/\/ found\n+  compare_big_haystack_to_needle(sizeKnown, size, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, loop_top, hsPtrRet, hsLength,\n+                                 needleLen, isU, DO_EARLY_BAILOUT, eq_mask, temp2, r10, _masm);\n@@ -1791,3 +1511,7 @@\n-      __ bind(L_copyHaystackToStack);\n-      __ cmpq(haystack_len, 0x10);\n-      __ ja_b(L_moreThan16);\n+  \/\/ At this point, we have at least one \"match\" where first and last bytes\n+  \/\/ of the needle are found the correct distance apart.\n+  \/\/\n+  \/\/ NOTE: haystack (rbx) should be preserved; hsPtrRet(rcx) is expected to\n+  \/\/    point to the haystack such that hsPtrRet[tzcntl(eq_mask)] points to\n+  \/\/    the matched string.\n+}\n@@ -1795,4 +1519,3 @@\n-      __ movq(index, COPIED_HAYSTACK_STACK_OFFSET + 0x10);\n-      __ movdqu(xmm_tmp1, Address(haystack, haystack_len, Address::times_1, -0x10));\n-      __ movdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), xmm_tmp1);\n-      __ jmpb(L_adjustHaystack);\n+static void preload_needle_helper(int size, Register needle, Register needleVal, StrIntrinsicNode::ArgEncoding ae,\n+                                  MacroAssembler *_masm) {\n+  \/\/ Pre-load the value (correctly sized) of the needle for comparison purposes.\n@@ -1800,4 +1523,1 @@\n-      __ bind(L_moreThan16);\n-      __ movq(index, COPIED_HAYSTACK_STACK_OFFSET + 0x20);\n-      __ vmovdqu(xmm_tmp1, Address(haystack, haystack_len, Address::times_1, -0x20));\n-      __ vmovdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), xmm_tmp1);\n+  assert_different_registers(needle, needleVal);\n@@ -1805,4 +1525,4 @@\n-      __ bind(L_adjustHaystack);\n-      __ subq(index, haystack_len);\n-      __ leaq(haystack, Address(rsp, index, Address::times_1));\n-    }\n+  bool isLL = (ae == StrIntrinsicNode::LL);\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = isUL || isUU;  \/\/ At least one is UTF-16\n@@ -1810,6 +1530,3 @@\n-    __ bind(L_smallSwitchTop);\n-    __ leaq(r13, Address(save_ndl_len, -1));\n-    __ cmpq(r13, NUMBER_OF_CASES - 1);\n-    __ ja(L_smallCaseDefault);\n-    __ mov64(r15, (int64_t)jump_table_1);\n-    __ jmp(Address(r15, r13, Address::times_8));\n+  int bytesAlreadyCompared = 0;\n+  int bytesLeftToCompare = 0;\n+  int offsetOfFirstByteToCompare = 0;\n@@ -1817,6 +1534,3 @@\n-    __ bind(L_bigSwitchTop);\n-    __ leaq(rax, Address(save_ndl_len, -1));\n-    __ cmpq(rax, NUMBER_OF_CASES - 1);\n-    __ ja(L_bigCaseDefault);\n-    __ mov64(r15, (int64_t)jump_table);\n-    __ jmp(Address(r15, rax, Address::times_8));\n+  bytesAlreadyCompared = isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE * 2) : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE;\n+  offsetOfFirstByteToCompare\n+      = isU ? ((NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2) : (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1);\n@@ -1824,17 +1538,2 @@\n-    if (isUL) {\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-      \/\/                         Wide char code\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-      \/\/\n-      \/\/ Pseudo-code:\n-      \/\/\n-      \/\/ If needle length less than MAX_NEEDLE_LEN_TO_EXPAND, read the needle\n-      \/\/ bytes from r14 and write them as words onto the stack.  Then go to the\n-      \/\/ \"regular\" code.  This is equavilent to doing a UU comparison, since the\n-      \/\/ haystack will be in UTF-16.\n-      \/\/\n-      \/\/ If the needle can't be expanded, process the same way as the default\n-      \/\/ cases above. That is, for each haystack chunk, compare the needle.\n-      __ bind(L_wcharBegin);\n+  bytesLeftToCompare = size - bytesAlreadyCompared;\n+  assert((bytesLeftToCompare <= 8), \"Too many bytes left to compare\");\n@@ -1842,1 +1541,3 @@\n-      Label L_top, L_finished;\n+  if (bytesLeftToCompare <= 0) {\n+    return;\n+  }\n@@ -1844,4 +1545,2 @@\n-      const Register haystack = rdi;\n-      const Register hsLen = rsi;\n-      const Register needle = rdx;\n-      const Register nLen = rcx;\n+  \/\/ At this point, there is at least one byte of the needle that needs to be\n+  \/\/ compared to the haystack.\n@@ -1849,3 +1548,31 @@\n-      const Register offset = rax;\n-      const Register index = rbx;\n-      const Register wr_index = r13;\n+  if (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 2) {\n+    switch (bytesLeftToCompare) {\n+    case 1:\n+    case 2:\n+      __ movzwl(needleVal, Address(needle, offsetOfFirstByteToCompare));\n+      break;\n+\n+    case 3:\n+    case 4:\n+      __ movl(needleVal, Address(needle, offsetOfFirstByteToCompare));\n+      break;\n+\n+    case 5:\n+      \/\/ Read one byte before start of needle, then mask it off\n+      __ movq(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n+      __ shrq(needleVal, 0x8);\n+      break;\n+\n+    case 6:\n+      __ movq(needleVal, Address(needle, (offsetOfFirstByteToCompare - 1)));\n+      break;\n+\n+    case 7:\n+    case 8:\n+      __ movq(needleVal, Address(needle, offsetOfFirstByteToCompare));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  }\n@@ -1853,1 +1580,27 @@\n-      assert(MAX_NEEDLE_LEN_TO_EXPAND >= 32, \"Small UL needles not supported\");\n+  if (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE >= 3) {\n+    switch (bytesLeftToCompare) {\n+    case 1:\n+    case 2:\n+      __ movl(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n+      break;\n+\n+    case 3:\n+    case 4:\n+      __ movl(needleVal, Address(needle, offsetOfFirstByteToCompare));\n+      break;\n+\n+    case 5:\n+    case 6:\n+      __ movq(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n+      break;\n+\n+    case 7:\n+    case 8:\n+      __ movq(needleVal, Address(needle, offsetOfFirstByteToCompare));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  }\n+}\n@@ -1855,1 +1608,7 @@\n-      __ shlq(hsLen, 1);\n+static void byte_compare_helper(int size, Label &L_noMatch, Label &L_matchFound, Register needle, Register needleVal,\n+                                Register haystack, Register mask, Register foundIndex, Register tmp,\n+                                StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm) {\n+  \/\/ Compare size bytes of needle to haystack\n+  \/\/\n+  \/\/ At a minimum, the first and last bytes of needle already compare equal\n+  \/\/ to the haystack, so there is no need to compare them again.\n@@ -1857,4 +1616,1 @@\n-      \/\/ __ movq(r14, hsLen);\n-      __ leaq(index, Address(nLen, nLen, Address::times_1));\n-      __ cmpq(index, hsLen);\n-      __ jg(L_returnRBP);\n+  Label L_loopTop;\n@@ -1862,2 +1618,1 @@\n-      __ cmpq(nLen, MAX_NEEDLE_LEN_TO_EXPAND);\n-      __ ja(L_wideNoExpand);\n+  assert_different_registers(needle, needleVal, haystack, mask, foundIndex, tmp);\n@@ -1865,15 +1620,4 @@\n-      \/\/\n-      \/\/ Reads of existing needle are 16-byte chunks\n-      \/\/ Writes to copied needle are 32-byte chunks\n-      \/\/ Don't read past the end of the existing needle\n-      \/\/\n-      \/\/ Start first read at [((ndlLen % 16) - 16) & 0xf]\n-      \/\/ outndx += 32\n-      \/\/ inndx += 16\n-      \/\/ cmp nndx, ndlLen\n-      \/\/ jae done\n-      \/\/\n-      \/\/ Final index of start of needle @((16 - (ndlLen %16)) & 0xf) << 1\n-      \/\/\n-      \/\/ Starting read for needle at -(16 - (nLen % 16))\n-      \/\/ Offset of needle in stack should be (16 - (nLen % 16)) * 2\n+  bool isLL = (ae == StrIntrinsicNode::LL);\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = isUL || isUU;  \/\/ At least one is UTF-16\n@@ -1881,8 +1625,3 @@\n-      __ movq(index, needle_len);\n-      __ andq(index, 0xf);    \/\/ nLen % 16\n-      __ movq(offset, 0x10);\n-      __ subq(offset, index); \/\/ 16 - (nLen % 16)\n-      __ movq(index, offset);\n-      __ shlq(offset, 1); \/\/ * 2\n-      __ negq(index);   \/\/ -(16 - (nLen % 16))\n-      __ xorq(wr_index, wr_index);\n+  int bytesAlreadyCompared = 0;\n+  int bytesLeftToCompare = 0;\n+  int offsetOfFirstByteToCompare = 0;\n@@ -1890,11 +1629,1 @@\n-      __ bind(L_top);\n-      __ vpmovzxbw(xmm0, Address(needle, index, Address::times_1),\n-                   Assembler::AVX_256bit);  \/\/ load needle[low-16]\n-      __ vmovdqu(Address(rsp, wr_index, Address::times_1,\n-                         EXPANDED_NEEDLE_STACK_OFFSET),\n-                        xmm0);  \/\/ store to stack\n-      __ addq(index, 0x10);\n-      __ cmpq(index, needle_len);\n-      __ jae(L_finished);\n-      __ addq(wr_index, 32);\n-      __ jmpb(L_top);\n+  Label temp;\n@@ -1902,3 +1631,6 @@\n-      __ bind(L_finished);\n-      __ leaq(needle, Address(rsp, offset, Address::times_1, EXPANDED_NEEDLE_STACK_OFFSET));\n-      __ leaq(needle_len, Address(needle_len, needle_len));\n+  if (isU) {\n+    if ((size & 1) != 0) {\n+      __ emit_int8(0xcc);\n+      return;\n+    }\n+  }\n@@ -1906,1 +1638,3 @@\n-      __ jmp(L_continue);\n+  bytesAlreadyCompared = isU ? NUMBER_OF_NEEDLE_BYTES_TO_COMPARE * 2 : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE;\n+  offsetOfFirstByteToCompare\n+      = isU ? ((NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2) : (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1);\n@@ -1908,8 +1642,2 @@\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-      \/\/\n-      \/\/ Compare Latin-1 encoded needle against UTF-16 encoded haystack.\n-      \/\/\n-      \/\/ The needle is more than MAX_NEEDLE_LEN_TO_EXPAND bytes in length, and the haystack\n-      \/\/ is at least as big.\n+  bytesLeftToCompare = size - bytesAlreadyCompared;\n+  assert(bytesLeftToCompare <= 8, \"Too many bytes left to compare\");\n@@ -1917,2 +1645,5 @@\n-      \/\/ Prepare for wchar anysize\n-      __ bind(L_wideNoExpand);\n+  if (bytesLeftToCompare <= 0) {\n+    __ tzcntl(foundIndex, mask);\n+    __ jmp(L_matchFound);\n+    return;\n+  }\n@@ -1920,3 +1651,2 @@\n-      {\n-        Label L_loopTop, L_temp, L_innerLoop, L_found, L_compareFull;\n-        Label doCompare, topLoop;\n+  \/\/ At this point, there is at least one byte of the needle that needs to be\n+  \/\/ compared to the haystack.\n@@ -1924,16 +1654,3 @@\n-        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-        \/\/\n-        \/\/  rbx: haystack\n-        \/\/  rcx: k\n-        \/\/  rdx: junk\n-        \/\/  rsi: n\n-        \/\/  rdi: haystack\n-        \/\/  r10: n - k\n-        \/\/  r12: k\n-        \/\/  r13: junk\n-        \/\/  r14: needle\n-        \/\/  rbp: -1\n-        \/\/  XMM_BYTE_0 - first element of needle broadcast\n-        \/\/  XMM_BYTE_K - last element of needle broadcast\n+  \/\/ Load in the correct sized needle value for comparison.  Used when checking\n+  \/\/ bytes of the haystack after first\/last have compared equal.\n+  preload_needle_helper(size, needle, needleVal, ae, _masm);\n@@ -1941,17 +1658,3 @@\n-        const Register rTmp = rax;\n-        const Register haystack = rbx;\n-        const Register saveNeedleAddress = rbx;  \/\/ NOTE re-use\n-        const Register origNeedleLen = rcx;\n-        const Register firstNeedleCompare = rdx;\n-        const Register hsLen = rsi;\n-        const Register origHsLen = rsi;  \/\/ NOTE re-use\n-        const Register rTmp2 = rdi;\n-        const Register mask = rbp;\n-        const Register rScratch = r8;\n-        const Register compLen = r9;\n-        const Register needleLen = r12;\n-        const Register hsIndex = r12;  \/\/ NOTE re-use\n-        const Register constOffset = r13;\n-        const Register needle = r14;\n-        const Register index = r14;  \/\/ NOTE re-use\n-        const Register haystackEnd = r15;\n+  __ align(8);\n+  __ bind(L_loopTop);\n+  __ tzcntl(foundIndex, mask);  \/\/ Index of match within haystack\n@@ -1959,3 +1662,34 @@\n-        const XMMRegister cmp_0 = xmm_tmp3;\n-        const XMMRegister cmp_k = xmm_tmp4;\n-        const XMMRegister result = xmm_tmp3;\n+  if (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 2) {\n+    switch (bytesLeftToCompare) {\n+    case 1:\n+    case 2:\n+      __ cmpw(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare), needleVal);\n+      __ je(L_matchFound);\n+      break;\n+\n+    case 3:\n+    case 4:\n+      __ cmpl(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare), needleVal);\n+      __ je(L_matchFound);\n+      break;\n+\n+    case 5:\n+      \/\/ Read one byte before start of haystack, then mask it off\n+      __ movq(tmp, Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare - 2));\n+      __ shrq(tmp, 0x08);\n+      __ cmpq(needleVal, tmp);\n+      __ je(L_matchFound);\n+      break;\n+\n+    case 6:\n+      __ cmpq(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare - 1), needleVal);\n+      __ je(L_matchFound);\n+      break;\n+\n+    case 7:\n+    case 8:\n+      __ cmpq(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare), needleVal);\n+      __ je(L_matchFound);\n+      break;\n+    }\n+  }\n@@ -1963,2 +1697,27 @@\n-        const XMMRegister saveCompLen = xmm_tmp2;\n-        const XMMRegister saveIndex = xmm_tmp1;\n+  if (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE >= 3) {\n+    switch (bytesLeftToCompare) {\n+    case 1:\n+    case 2:\n+      __ cmpl(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare - 2), needleVal);\n+      __ je(L_matchFound);\n+      break;\n+\n+    case 3:\n+    case 4:\n+      __ cmpl(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare), needleVal);\n+      __ je(L_matchFound);\n+      break;\n+\n+    case 5:\n+    case 6:\n+      __ cmpq(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare - 2), needleVal);\n+      __ je(L_matchFound);\n+      break;\n+\n+    case 7:\n+    case 8:\n+      __ cmpq(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare), needleVal);\n+      __ je(L_matchFound);\n+      break;\n+    }\n+  }\n@@ -1966,4 +1725,4 @@\n-        \/\/ Move registers into expected registers for rest of this routine\n-        __ movq(rbx, rdi);\n-        __ movq(r12, rcx);\n-        __ movq(r14, rdx);\n+  CLEAR_BIT(mask, tmp);  \/\/ Loop as long as there are other bits set\n+  __ jne(L_loopTop);\n+  __ jmp(L_noMatch);\n+}\n@@ -1971,6 +1730,18 @@\n-        __ movq(rTmp, origNeedleLen);\n-        __ shlq(rTmp, 1);\n-        __ movq(rScratch, origHsLen);\n-        __ subq(rScratch, rTmp);\n-        __ cmpq(rScratch, 0x20);\n-        __ jl(L_compareFull);\n+\/\/ highly_optimized_short_cases\n+\/\/ We can handle the cases where haystack size is <= 32 bytes and needle size <= OPT_NEEDLE_SIZE_MAX\n+\/\/ as a special case.  We first copy the haystack tpo the stack to avoid page faults.  A mask is\n+\/\/ generated with 32 - (n - k + 1) bits set that ensures matches past the end of the original\n+\/\/ haystack do not get considered during compares.\n+\/\/\n+\/\/ A vector compare for the first needle byte is done against the haystack and anded with the mask.\n+\/\/ For needle size == 1, if there's a match we found it, otherwise failure.  The 2nd position\n+\/\/ of the needle is compared starting from the 2nd position of the haystack and anded with the\n+\/\/ mask.  If needle size == 2 and a match is found, success else failure.  This continues for\n+\/\/ all needle sizes up to OPT_NEEDLE_SIZE_MAX.\n+\/\/\n+\/\/\n+static void highly_optimized_short_cases(StrIntrinsicNode::ArgEncoding ae, Register haystack, Register haystack_len,\n+                                         Register needle, Register needle_len, XMMRegister XMM0, XMMRegister XMM1,\n+                                         Register mask, Register tmp, MacroAssembler *_masm) {\n+  \/\/ Highly optimized special-cases\n+  Label L_noMatch, L_foundall, L_out;\n@@ -1978,1 +1749,4 @@\n-        \/\/ Now there is room for a 32-byte read for the last iteration\n+  bool isLL = (ae == StrIntrinsicNode::LL);\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = isUL || isUU;  \/\/ At least one is UTF-16\n@@ -1980,5 +1754,4 @@\n-        \/\/ Always need needle broadcast to ymm registers\n-        __ movzbl(rax, Address(needle));  \/\/ First byte of needle\n-        __ movdl(byte_0, rax);\n-        \/\/ 1st byte of needle in words\n-        __ vpbroadcastw(byte_0, byte_0, Assembler::AVX_256bit);\n+  \/\/ Only optimize when haystack can fit on stack with room\n+  \/\/ left over for page fault prevention\n+  assert((COPIED_HAYSTACK_STACK_OFFSET == 0), \"Must be zero!\");\n+  assert((COPIED_HAYSTACK_STACK_SIZE == 64), \"Must be 64!\");\n@@ -1986,5 +1759,3 @@\n-        __ movzbl(rax, Address(needle, needle_len, Address::times_1,\n-                               -1));  \/\/ Last byte of needle\n-        __ movdl(byte_k, rax);\n-        __ vpbroadcastw(byte_k, byte_k,\n-                        Assembler::AVX_256bit);  \/\/ Last byte of needle in words\n+  \/\/ Copy incoming haystack onto stack\n+  {\n+    Label L_adjustHaystack, L_moreThan16;\n@@ -1992,2 +1763,4 @@\n-        \/\/ __ bind(L_bigCaseDefault);\n-        __ movq(r11, -1);\n+    \/\/ Copy haystack to stack (haystack <= 32 bytes)\n+    __ subptr(rsp, COPIED_HAYSTACK_STACK_SIZE);\n+    __ cmpq(haystack_len, isU ? 0x8 : 0x10);\n+    __ ja_b(L_moreThan16);\n@@ -1995,3 +1768,4 @@\n-        broadcast_additional_needles(false, 0 \/* unknown *\/,\n-                                     NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, needle,\n-                                     origNeedleLen, rax, isUU, isUL, _masm);\n+    __ movq(tmp, COPIED_HAYSTACK_STACK_OFFSET + 0x10);\n+    __ movdqu(XMM0, Address(haystack, haystack_len, isU ? Address::times_2 : Address::times_1, -0x10));\n+    __ movdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), XMM0);\n+    __ jmpb(L_adjustHaystack);\n@@ -1999,1 +1773,4 @@\n-        __ leaq(haystackEnd, Address(haystack, hsLen, Address::times_1));\n+    __ bind(L_moreThan16);\n+    __ movq(tmp, COPIED_HAYSTACK_STACK_OFFSET + 0x20);\n+    __ vmovdqu(XMM0, Address(haystack, haystack_len, isU ? Address::times_2 : Address::times_1, -0x20));\n+    __ vmovdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), XMM0);\n@@ -2001,9 +1778,8 @@\n-        assert(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 4, \"Invalid\");\n-        assert(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE >= 2, \"Invalid\");\n-        __ leaq(firstNeedleCompare,\n-                Address(needle, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n-        __ leaq(\n-            compLen,\n-            Address(\n-                needleLen,\n-                -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE)));  \/\/ nlen - 2 elements\n+    __ bind(L_adjustHaystack);\n+    __ subq(tmp, haystack_len);\n+    if (isU) {\n+      \/\/ For UTF-16, lengths are half\n+      __ subq(tmp, haystack_len);\n+    }\n+    __ leaq(haystack, Address(rsp, tmp, Address::times_1));\n+  }\n@@ -2011,2 +1787,25 @@\n-        \/\/  firstNeedleCompare has address of second element of needle\n-        \/\/  compLen has length of comparison to do\n+  \/\/ Creates a mask of (n - k + 1) ones.  This prevents\n+  \/\/ recognizing any false-positives past the end of\n+  \/\/ the valid haystack.\n+  __ movq(mask, -1);\n+  __ subq(haystack_len, needle_len);\n+  __ incrementq(haystack_len);\n+  if (isU) {\n+    __ shlq(haystack_len, 1);\n+  }\n+  __ bzhiq(mask, mask, haystack_len);\n+\n+  for (int size = 1; size <= OPT_NEEDLE_SIZE_MAX; size++) {\n+    \/\/ Broadcast next needle byte into ymm register\n+    int position = isUU ? (size - 1) * 2 : size - 1;\n+    if (isUU) {\n+      __ vpbroadcastw(XMM0, Address(needle, position), Assembler::AVX_256bit);\n+    } else if (isUL) {\n+      \/\/ Expand needle\n+      __ movzbl(rax, Address(needle, position));\n+      __ movdl(XMM0, rax);\n+      \/\/ Byte of needle to words\n+      __ vpbroadcastw(XMM0, XMM0, Assembler::AVX_256bit);\n+    } else {\n+      __ vpbroadcastb(XMM0, Address(needle, position), Assembler::AVX_256bit);\n+    }\n@@ -2014,2 +1813,18 @@\n-        \/\/ Save haystack\n-        __ movq(Address(rsp, SAVED_HAYSTACK_STACK_OFFSET), haystack);\n+    \/\/ Compare next byte.  Keep the comparison mask in mask, which will\n+    \/\/ accumulate\n+    if (isU) {\n+      __ vpcmpeqw(XMM1, XMM0, Address(haystack, position), Assembler::AVX_256bit);\n+    } else {\n+      __ vpcmpeqb(XMM1, XMM0, Address(haystack, position), Assembler::AVX_256bit);\n+    }\n+    __ vpmovmskb(tmp, XMM1, Assembler::AVX_256bit);\n+    __ andq(mask, tmp);  \/\/ Accumulate matched bytes\n+    __ testl(mask, mask);\n+    __ je(L_noMatch);\n+\n+    if (size != OPT_NEEDLE_SIZE_MAX) {\n+      \/\/ Found a match for this needle size\n+      __ cmpq(needle_len, size);\n+      __ je(L_foundall);\n+    }\n+  }\n@@ -2017,2 +1832,2 @@\n-        __ movq(index, origHsLen);\n-        __ negptr(index);  \/\/ incr\n+  __ bind(L_foundall);\n+  __ tzcntl(rax, mask);\n@@ -2020,7 +1835,3 @@\n-        \/\/ constant offset from end for full 32-byte read\n-        __ movq(constOffset, origHsLen);\n-        __ shlq(origNeedleLen, 1);\n-        __ subq(constOffset, origNeedleLen);\n-        __ andq(constOffset, 0x1f);\n-        __ negptr(constOffset);\n-        __ jmpb(L_temp);\n+  if (isU) {\n+    __ shrq(rax, 1);\n+  }\n@@ -2028,6 +1839,5 @@\n-        __ bind(L_loopTop);\n-        __ addq(index, 32);\n-        __ subq(origHsLen, 32);\n-        __ jle(L_returnError);\n-        __ cmpq(index, constOffset);\n-        __ cmovq(Assembler::greater, index, constOffset);\n+  __ bind(L_out);\n+  __ addptr(rsp, COPIED_HAYSTACK_STACK_SIZE);\n+  __ vzeroupper();\n+  __ leave();\n+  __ ret(0);\n@@ -2035,3 +1845,4 @@\n-        __ bind(L_temp);\n-        __ movq(hsIndex, origNeedleLen);\n-        __ addq(hsIndex, index);\n+  __ bind(L_noMatch);\n+  __ movq(rax, -1);\n+  __ jmpb(L_out);\n+}\n@@ -2039,35 +1850,5 @@\n-        \/\/ Compare first byte of needle to haystack\n-        __ vpcmpeqw(cmp_0, byte_0, Address(haystackEnd, index),\n-                    Assembler::AVX_256bit);\n-        \/\/ Compare last byte of needle to haystack at proper position\n-        __ vpcmpeqw(cmp_k, byte_k,\n-                    Address(haystackEnd, hsIndex, Address::times_1, -2),\n-                    Assembler::AVX_256bit);\n-        __ vpand(result, cmp_k, cmp_0, Assembler::AVX_256bit);\n-#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE > 2\n-#if DO_EARLY_BAILOUT > 0\n-        __ vpmovmskb(mask, result, Assembler::AVX_256bit);\n-        __ testl(mask, mask);\n-        __ je_b(L_loopTop);\n-#endif\n-        \/\/ Compare second byte of needle to haystack\n-        __ vpcmpeqw(cmp_k, byte_1,\n-                    Address(haystackEnd, index, Address::times_1, 2),\n-                    Assembler::AVX_256bit);\n-        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n-#endif\n-#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE > 3\n-#if DO_EARLY_BAILOUT > 0\n-        __ vpmovmskb(mask, result, Assembler::AVX_256bit);\n-        __ testl(mask, mask);\n-        __ je_b(L_loopTop);\n-#endif\n-        \/\/ Compare third byte of needle to haystack\n-        __ vpcmpeqw(cmp_k, byte_2,\n-                    Address(haystackEnd, index, Address::times_1, 4),\n-                    Assembler::AVX_256bit);\n-        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n-#endif\n-        __ vpmovmskb(mask, result, Assembler::AVX_256bit);\n-        __ testl(mask, mask);\n-        __ je_b(L_loopTop);\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\n+  \/\/ Set up jump table entries for both small and large haystack switches.\n@@ -2075,3 +1856,6 @@\n-        __ align(8);\n-        __ bind(L_innerLoop);\n-        __ tzcntl(rTmp, mask);\n+static void setup_jump_tables(StrIntrinsicNode::ArgEncoding ae, Label &L_error, Label &L_checkRange, Label &L_fixup,\n+                              address *jump_table, address *jump_table_1, MacroAssembler *_masm) {\n+  bool isLL = (ae == StrIntrinsicNode::LL);\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = isUL || isUU;  \/\/ At least one is UTF-16\n@@ -2079,4 +1863,3 @@\n-        __ movdq(saveIndex, rTmp);\n-        __ movdq(saveCompLen, compLen);\n-        \/\/ Save address of nth element of needle\n-        __ movq(saveNeedleAddress, firstNeedleCompare);\n+  address large_hs_jmp_table[NUMBER_OF_CASES];  \/\/ Jump table for large haystacks\n+  address small_hs_jmp_table[NUMBER_OF_CASES];  \/\/ Jump table for small haystacks\n+  int jmp_ndx = 0;\n@@ -2084,15 +1867,4 @@\n-#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 2\n-        __ leaq(rTmp2, Address(haystackEnd, index, Address::times_1, 2));\n-#endif\n-#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE == 3\n-        __ leaq(rTmp2, Address(haystackEnd, index, Address::times_1, 4));\n-#endif\n-#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE == 4\n-        __ leaq(rTmp2, Address(haystackEnd, index, Address::times_1, 6));\n-#endif\n-        __ addq(rTmp2, rTmp);\n-        __C2 arrays_equals(false, rTmp2, firstNeedleCompare, compLen, rTmp,\n-                         rScratch, xmm_tmp3, xmm_tmp4, false \/* char *\/, knoreg,\n-                         true \/* expand_ary2 *\/);\n-        __ testl(rTmp, rTmp);\n-        __ jne_b(L_found);\n+  {\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\n+    \/\/ Small haystack (<32 bytes) switch\n@@ -2100,5 +1872,42 @@\n-        __ movdq(compLen, saveCompLen);\n-        __ movq(firstNeedleCompare, saveNeedleAddress);\n-        CLEAR_BIT(mask, rTmp);\n-        __ jne(L_innerLoop);\n-        __ jmp(L_loopTop);\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/  On entry to each case of small_hs, the register state is:\n+    \/\/\n+    \/\/  rax = unused\n+    \/\/  rbx = &haystack\n+    \/\/  rcx = haystack length\n+    \/\/  rdx = &needle\n+    \/\/  rsi = haystack length\n+    \/\/  rdi = &haystack\n+    \/\/  rbp = -1\n+    \/\/  r8  = unused\n+    \/\/  r9  = unused\n+    \/\/  r10 = hs_len - needle len\n+    \/\/  r11 = unused\n+    \/\/  r12 = needle length\n+    \/\/  r13 = (needle length - 1)\n+    \/\/  r14 = &needle\n+    \/\/  r15 = unused\n+    \/\/  XMM_BYTE_0 - first element of needle, broadcast\n+    \/\/  XMM_BYTE_K - last element of needle, broadcast\n+    \/\/\n+    \/\/  The haystack is < 32 bytes\n+    \/\/\n+    \/\/ If a match is not found, branch to L_returnRBP (which will always\n+    \/\/ return -1).\n+    \/\/\n+    \/\/ If a match is found, jump to L_checkRangeAndReturn, which ensures the\n+    \/\/ matched needle is not past the end of the haystack.\n+\n+    const Register haystack = rbx;\n+    const Register needle = r14;\n+    const Register needle_val = r8;\n+    const Register set_bit = r11;\n+    const Register eq_mask = rsi;\n+    const Register rTmp = rax;\n+\n+    for (int i = OPT_NEEDLE_SIZE_MAX; i < NUMBER_OF_CASES; i++) {\n+      small_hs_jmp_table[i] = __ pc();\n+      if (isU && ((i + 1) & 1)) {\n+        __ emit_int8(0xcc);\n+      } else {\n+        Label L_loopTop;\n@@ -2106,7 +1915,2 @@\n-        __ bind(L_found);\n-        __ movdq(rTmp, saveIndex);\n-        __ leaq(rScratch, Address(haystackEnd, index, Address::times_1));\n-        __ subq(rScratch, Address(rsp, SAVED_HAYSTACK_STACK_OFFSET));\n-        __ addq(rScratch, rTmp);\n-        __ movq(r11, rScratch);\n-        __ jmp(L_checkRangeAndReturn);\n+        broadcast_additional_needles(true, i + 1, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, needle, noreg, rTmp, isUU, isUL,\n+                                     _masm);\n@@ -2114,1 +1918,2 @@\n-        __ bind(L_compareFull);\n+        compare_haystack_to_needle(true, i + 1, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, L_error, haystack, isU,\n+                                   DO_EARLY_BAILOUT, eq_mask, noreg, rTmp, _masm);\n@@ -2116,4 +1921,5 @@\n-        \/\/ rScratch has n - k.  Compare entire string word-by-word\n-        __ xorq(r11, r11);\n-        __ movq(r10, rScratch);\n-        __ jmpb(doCompare);\n+        byte_compare_helper(i + 1, L_error, L_checkRange, needle, needle_val, haystack, eq_mask, set_bit,\n+                            rTmp, ae, _masm);\n+      }\n+    }\n+  }\n@@ -2121,4 +1927,3 @@\n-        __ bind(topLoop);\n-        __ addq(r11, 2);\n-        __ cmpq(r11, rScratch);\n-        __ jg(L_returnRBP);\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\n+  \/\/ Large haystack (>=32 bytes) switch\n@@ -2126,4 +1931,1 @@\n-        __ bind(doCompare);\n-        __ leaq(r9, Address(haystack, r11));\n-        __ leaq(r12, Address(needle, 0));\n-        __ movq(r13, origNeedleLen);\n+  {\n@@ -2131,4 +1933,38 @@\n-        __C2 arrays_equals(false, r9, r12, r13, rax, rdx, xmm_tmp3, xmm_tmp4,\n-                         false \/* char *\/, knoreg, true \/* expand_ary2 *\/);\n-        __ testq(rax, rax);\n-        __ jz(topLoop);\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/  On entry to each case of large_hs, the register state is:\n+    \/\/\n+    \/\/  rax = unused\n+    \/\/  rbx = &haystack\n+    \/\/  rcx = haystack length\n+    \/\/  rdx = &needle\n+    \/\/  rsi = haystack length\n+    \/\/  rdi = &haystack\n+    \/\/  rbp = -1\n+    \/\/  r8  = unused\n+    \/\/  r9  = unused\n+    \/\/  r10 = hs_len - needle len\n+    \/\/  r11 = unused\n+    \/\/  r12 = needle length\n+    \/\/  r13 = (needle length - 1)\n+    \/\/  r14 = &needle\n+    \/\/  r15 = unused\n+    \/\/  XMM_BYTE_0 - first element of needle, broadcast\n+    \/\/  XMM_BYTE_K - last element of needle, broadcast\n+    \/\/\n+    \/\/  The haystack is >= 32 bytes\n+\n+    const Register haystack = rbx;\n+    const Register needle = r14;\n+    const Register needle_len = r12;\n+    const Register needle_val = r15;\n+    const Register set_bit = r8;\n+    const Register eq_mask = r9;\n+    const Register rTmp = r13;\n+    const Register hs_ptr = rcx;\n+\n+    for (int i = 0; i < NUMBER_OF_CASES; i++) {\n+      large_hs_jmp_table[i] = __ pc();\n+      if (isU && ((i + 1) & 1)) {\n+        __ emit_int8(0xcc);\n+      } else {\n+        Label L_loopTop;\n@@ -2136,2 +1972,3 @@\n-        \/\/ Match found\n-        __ jmp(L_checkRangeAndReturn);\n+        big_case_loop_helper(true, i + 1, L_checkRange, L_loopTop, eq_mask, hs_ptr, needle_len, ae, _masm);\n+        byte_compare_helper(i + 1, L_loopTop, L_fixup, needle, needle_val, hs_ptr, eq_mask, set_bit,\n+                            rTmp, ae, _masm);\n@@ -2140,0 +1977,20 @@\n+  }\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/ JUMP TABLES\n+  __ align(8);\n+\n+  *jump_table = __ pc();\n+\n+  for (jmp_ndx = 0; jmp_ndx < NUMBER_OF_CASES; jmp_ndx++) {\n+    __ emit_address(large_hs_jmp_table[jmp_ndx]);\n+  }\n+\n+  *jump_table_1 = __ pc();\n+\n+  for (jmp_ndx = 0; jmp_ndx < NUMBER_OF_CASES; jmp_ndx++) {\n+    __ emit_address(small_hs_jmp_table[jmp_ndx]);\n+  }\n+}\n@@ -2153,7 +2010,0 @@\n-  } else {  \/\/ SSE version\n-    assert(false, \"Only supports AVX2\");\n-  }\n-\n-  return;\n-}\n-\n@@ -2162,1 +2012,1 @@\n-#endif \/\/ COMPILER2\n+#endif  \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_string.cpp","additions":1607,"deletions":1757,"binary":false,"changes":3364,"status":"modified"}]}