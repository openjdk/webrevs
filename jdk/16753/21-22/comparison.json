{"files":[{"patch":"@@ -0,0 +1,249 @@\n+\/*\n+ * Copyright (c) 2024, Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary test String indexOf() intrinsic\n+ * @run main\/othervm IndexOf\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:UseAVX=2 -XX:+UnlockDiagnosticVMOptions -XX:+EnableX86ECoreOpts IndexOf\n+ *\/\n+\n+ public class IndexOf {\n+  final int scope = 32*2+16+8;\n+  final char a, aa, b, c, d;\n+  enum Encoding {LL, UU, UL; }\n+  final Encoding ae;\n+  int failures;\n+\n+  IndexOf(Encoding _ae) {\n+      failures = 0;\n+      ae = _ae;\n+      switch (ae) {\n+          case LL:\n+              a = 'a';\n+              aa = a;\n+              b = 'b';\n+              c = 'c';\n+              d = 'd';\n+              break;\n+          case UU:\n+              a = '\\u0061';\n+              aa = a;\n+              b = '\\u0062';\n+              c = '\\u1063';\n+              d = '\\u0064';\n+              break;\n+          default: \/\/case UL:\n+              a = 'a';\n+              aa = '\\u1061';\n+              b = 'b';\n+              c = 'c';\n+              d = 'd';\n+              break;\n+      }\n+  }\n+\n+  \/\/ needle    =~ \/ab*d\/\n+  \/\/ badNeedle =~ \/ab*db*d\/\n+  interface Append {void append(int pos, char cc);}\n+  String newNeedle(int size, int badPosition) {\n+      if (size<2) {throw new RuntimeException(\"Fix testcase \"+size);}\n+\n+      StringBuilder needle = new StringBuilder(size);\n+      Append n = (int pos, char cc) -> {\n+          if (pos == badPosition)\n+              needle.append(c);\n+          else\n+              needle.append(cc);\n+      };\n+\n+      n.append(0, a);\n+      for (int i=1; i<size-1; i++) {\n+          n.append(i, b);\n+      }\n+      n.append(size-1, d);\n+\n+      return needle.toString();\n+  }\n+\n+  \/\/ haystack  =~ \/a*{needle}d*\/\n+  String newHaystack(int size, String needle, int nPosition) {\n+      if (nPosition+needle.length()>size) {throw new RuntimeException(\"Fix testcase \"+nPosition+\" \"+needle.length()+\" \"+size);}\n+      StringBuilder haystack = new StringBuilder(size);\n+      int i = 0;\n+      for (; i<nPosition; i++) {\n+          haystack.append(aa);\n+      }\n+      haystack.append(needle);\n+      i += needle.length();\n+      for (; i<size; i++) {\n+          haystack.append(d);\n+      }\n+      return haystack.toString();\n+  }\n+\n+  \/\/ haystack =~ \/a*{needle}+b*\/\n+  String newHaystackRepeat(int size, String needle, int nPosition) {\n+      if (nPosition+needle.length()>size) {throw new RuntimeException(\"Fix testcase \"+nPosition+\" \"+needle.length()+\" \"+size);}\n+      StringBuilder haystack = new StringBuilder(size);\n+      int i = 0;\n+      for (; i<nPosition; i++) {\n+          haystack.append(aa);\n+      }\n+      for (; i< nPosition+needle.length(); i += needle.length()) {\n+          haystack.append(needle);\n+      }\n+      for (; i<size; i++) {\n+          haystack.append(d);\n+      }\n+      return haystack.toString();\n+  }\n+\n+  public static void main(String[] args) {\n+      int failures = 0;\n+      for (Encoding ae : Encoding.values()) {\n+          failures += (new IndexOf(ae))\n+              .test0()\n+              .test1()\n+              .test2()\n+              .test3()\n+              .test4()\n+              .failures;\n+      }\n+      if (failures != 0) {\n+          throw new RuntimeException(\"IndexOf test failed.\");\n+      }\n+  }\n+\n+  \/\/ Need to disable checks in String.java if intrinsic is to be tested\n+  IndexOf test0() { \/\/ Test 'trivial cases'\n+      \/\/ if (0==needle_len) return haystack_off;\n+      if (3 != \"Hello\".indexOf(\"\", 3)) {\n+          System.out.println(\"FAILED: if (0==needle_len) return haystack_off\");\n+          failures++;\n+      }\n+      \/\/if (0==haystack_len) return -1;\n+      if (-1 != \"\".indexOf(\"Hello\", 3)) {\n+          System.out.println(\"FAILED: if (0==haystack_len) return -1\");\n+          failures++;\n+      }\n+      \/\/if (needle_len>haystack_len) return -1;\n+      if (-1 != \"Hello\".indexOf(\"HelloWorld\", 3)) {\n+          System.out.println(\"FAILED: if (needle_len>haystack_len) return -1\");\n+          failures++;\n+      }\n+      return this;\n+  }\n+\n+  IndexOf test1() { \/\/ Test expected to find one needle\n+      for (int nSize = 2; nSize<scope; nSize++) {\n+          String needle = newNeedle(nSize, -1);\n+          for (int hSize = nSize; hSize<scope; hSize++) {\n+              for (int i = 0; i<hSize-nSize; i++) {\n+                  String haystack = newHaystack(hSize, needle, i);\n+                  for (int j = 0; j<=i; j++) {\n+                      int found = haystack.indexOf(needle, j);\n+                      if (i != found) {\n+                          System.out.println(\"(\"+ae.name()+\")(T1) Trying needle[\"+nSize+\"] in haystack[\"+hSize+\"] at offset[\"+i+\"]\");\n+                          System.out.println(\"    FAILED: Found \" + needle + \"@\" + found + \" in \" + haystack + \" from [\"+j+\"]\");\n+                          failures++;\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+      return this;\n+  }\n+\n+  IndexOf test2() { \/\/ Test needle with one mismatched character\n+      for (int nSize = 2; nSize<scope; nSize++) {\n+          for (int hSize = nSize; hSize<scope; hSize++) {\n+              String needle = newNeedle(nSize, -1);\n+              for (int badPosition = 0; badPosition < nSize; badPosition+=1) {\n+                  String badNeedle = newNeedle(nSize, badPosition);\n+                  for (int i = 0; i<hSize-nSize; i++) {\n+                      String haystack = newHaystack(hSize, needle, i);\n+                      int found = haystack.indexOf(badNeedle, 1);\n+                      if (-1 != found) {\n+                          System.out.println(\"(\"+ae.name()+\")(T2) Trying bad needle[\"+nSize+\"][\"+badPosition+\"] in haystack[\"+hSize+\"] at offset[\"+i+\"]\");\n+                          System.out.println(\"    FAILED: False \" + found + \" \" + haystack + \"[\"+needle+\"][\"+badNeedle+\"]\");\n+                          failures++;\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+      return this;\n+  }\n+\n+  IndexOf test3() { \/\/ Test expected to find first of the repeated needles\n+      for (int nSize = 2; nSize<scope; nSize++) {\n+          String needle = newNeedle(nSize, -1);\n+          for (int hSize = nSize; hSize<scope; hSize++) {\n+              for (int i = 0; i<hSize-nSize; i++) {\n+                  String haystack = newHaystackRepeat(hSize, needle, i);\n+                  for (int j = 0; j<=i; j++) {\n+                      int found = haystack.indexOf(needle, j);\n+                      if (i != found) {\n+                          System.out.println(\"(\"+ae.name()+\")(T3) Trying repeaded needle[\"+nSize+\"] in haystack[\"+hSize+\"] at offset[\"+i+\"]\");\n+                          System.out.println(\"    FAILED: \" + found + \" \" + haystack + \"[\"+needle+\"]\");\n+                          failures++;\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+      return this;\n+  }\n+\n+  IndexOf test4() { \/\/ Test needle at unreachable offset\n+      for (int nSize = 2; nSize<scope; nSize++) {\n+          String needle = newNeedle(nSize, -1);\n+          for (int hSize = nSize; hSize<scope; hSize++) {\n+              for (int i = 0; i<hSize-nSize; i++) {\n+                  String haystack = newHaystack(hSize, needle, i);\n+                  \/\/ prefix lookup\n+                  for (int j = nSize-1; j<i+nSize; j++) {\n+                      int found = haystack.indexOf(needle, 0, j);\n+                      if (-1 != found) {\n+                          System.out.println(\"(\"+ae.name()+\")(T4) Trying needle[\"+nSize+\"] at offset [\"+i+\"] in haystack[\"+hSize+\"] upto [\"+j+\"]\");\n+                          System.out.println(\"    FAILED: False \" + found + \" \" + haystack + \"[\"+needle+\"]\");\n+                          failures++;\n+                      }\n+                  }\n+\n+                  \/\/ sufix lookup\n+                  for (int j = i+1; j<hSize; j++) {\n+                      int found = haystack.indexOf(needle, j);\n+                      if (-1 != found) {\n+                          System.out.println(\"(\"+ae.name()+\")(T4) Trying needle[\"+nSize+\"] at offset [\"+i+\"] in haystack[\"+hSize+\"] from [\"+j+\"]\");\n+                          System.out.println(\"    FAILED: False \" + found + \" \" + haystack + \"[\"+needle+\"]\");\n+                          failures++;\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+      return this;\n+  }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/String\/IndexOf.java","additions":249,"deletions":0,"binary":false,"changes":249,"status":"added"}]}