{"files":[{"patch":"@@ -1760,0 +1760,16 @@\n+void Assembler::cmpb(Address dst, Register reg) {\n+  assert(reg->has_byte_register(), \"must have byte register\");\n+  InstructionMark im(this);\n+  prefix(dst, reg, true);\n+  emit_int8((unsigned char)0x38);\n+  emit_operand(reg, dst, 0);\n+}\n+\n+void Assembler::cmpb(Register reg, Address dst) {\n+  assert(reg->has_byte_register(), \"must have byte register\");\n+  InstructionMark im(this);\n+  prefix(dst, reg, true);\n+  emit_int8((unsigned char)0x3a);\n+  emit_operand(reg, dst, 0);\n+}\n+\n@@ -1791,0 +1807,7 @@\n+void Assembler::cmpl(Address dst,  Register reg) {\n+  InstructionMark im(this);\n+  prefix(dst, reg);\n+  emit_int8(0x39);\n+  emit_operand(reg, dst, 0);\n+}\n+\n@@ -1806,0 +1829,8 @@\n+void Assembler::cmpw(Address dst, Register reg) {\n+  InstructionMark im(this);\n+  emit_int8(0x66);\n+  prefix(dst, reg);\n+  emit_int8((unsigned char)0x39);\n+  emit_operand(reg, dst, 1);\n+}\n+\n@@ -4426,0 +4457,9 @@\n+void Assembler::vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() : VM_Version::supports_avx2(), \"\");\n+  assert(vector_len <= AVX_256bit, \"evex encoding is different - has k register as dest\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(src2, src1->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x74);\n+  emit_operand(dst, src2, 0);\n+}\n+\n@@ -4532,0 +4572,10 @@\n+\/\/ In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst\n+void Assembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() : VM_Version::supports_avx2(), \"\");\n+  assert(vector_len <= AVX_256bit, \"evex encoding is different - has k register as dest\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(src, nds->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x75);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -7641,0 +7691,8 @@\n+void Assembler::vpminub(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+        (vector_len == AVX_256bit ? VM_Version::supports_avx2() : VM_Version::supports_avx512bw()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0xDA, (0xC0 | encode));\n+}\n+\n@@ -12266,0 +12324,7 @@\n+void Assembler::bzhil(Register dst, Register src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"bit manipulation instructions not supported\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0xF5, (0xC0 | encode));\n+}\n+\n@@ -13160,0 +13225,4 @@\n+void Assembler::cdqe() {\n+  emit_int16(REX_W, (unsigned char)0x98);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -1097,0 +1097,1 @@\n+  void cdqe();\n@@ -1112,0 +1113,2 @@\n+  void cmpb(Address dst, Register reg);\n+  void cmpb(Register reg, Address dst);\n@@ -1118,0 +1121,1 @@\n+  void cmpl(Address dst,  Register reg);\n@@ -1126,0 +1130,1 @@\n+  void cmpw(Address dst, Register reg);\n@@ -1803,0 +1808,1 @@\n+  void vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n@@ -1817,0 +1823,1 @@\n+  void vpcmpeqw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n@@ -2307,0 +2314,1 @@\n+  void bzhil(Register dst, Register src1, Register src2);\n@@ -2582,0 +2590,1 @@\n+  void vpminub(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4364,211 +4364,0 @@\n-\/\/ Compare char[] or byte[] arrays aligned to 4 bytes or substrings.\n-void C2_MacroAssembler::arrays_equals(bool is_array_equ, Register ary1, Register ary2,\n-                                      Register limit, Register result, Register chr,\n-                                      XMMRegister vec1, XMMRegister vec2, bool is_char, KRegister mask) {\n-  ShortBranchVerifier sbv(this);\n-  Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_VECTORS, COMPARE_CHAR, COMPARE_BYTE;\n-\n-  int length_offset  = arrayOopDesc::length_offset_in_bytes();\n-  int base_offset    = arrayOopDesc::base_offset_in_bytes(is_char ? T_CHAR : T_BYTE);\n-\n-  if (is_array_equ) {\n-    \/\/ Check the input args\n-    cmpoop(ary1, ary2);\n-    jcc(Assembler::equal, TRUE_LABEL);\n-\n-    \/\/ Need additional checks for arrays_equals.\n-    testptr(ary1, ary1);\n-    jcc(Assembler::zero, FALSE_LABEL);\n-    testptr(ary2, ary2);\n-    jcc(Assembler::zero, FALSE_LABEL);\n-\n-    \/\/ Check the lengths\n-    movl(limit, Address(ary1, length_offset));\n-    cmpl(limit, Address(ary2, length_offset));\n-    jcc(Assembler::notEqual, FALSE_LABEL);\n-  }\n-\n-  \/\/ count == 0\n-  testl(limit, limit);\n-  jcc(Assembler::zero, TRUE_LABEL);\n-\n-  if (is_array_equ) {\n-    \/\/ Load array address\n-    lea(ary1, Address(ary1, base_offset));\n-    lea(ary2, Address(ary2, base_offset));\n-  }\n-\n-  if (is_array_equ && is_char) {\n-    \/\/ arrays_equals when used for char[].\n-    shll(limit, 1);      \/\/ byte count != 0\n-  }\n-  movl(result, limit); \/\/ copy\n-\n-  if (UseAVX >= 2) {\n-    \/\/ With AVX2, use 32-byte vector compare\n-    Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n-\n-    \/\/ Compare 32-byte vectors\n-    andl(result, 0x0000001f);  \/\/   tail count (in bytes)\n-    andl(limit, 0xffffffe0);   \/\/ vector count (in bytes)\n-    jcc(Assembler::zero, COMPARE_TAIL);\n-\n-    lea(ary1, Address(ary1, limit, Address::times_1));\n-    lea(ary2, Address(ary2, limit, Address::times_1));\n-    negptr(limit);\n-\n-#ifdef _LP64\n-    if ((AVX3Threshold == 0) && VM_Version::supports_avx512vlbw()) { \/\/ trying 64 bytes fast loop\n-      Label COMPARE_WIDE_VECTORS_LOOP_AVX2, COMPARE_WIDE_VECTORS_LOOP_AVX3;\n-\n-      cmpl(limit, -64);\n-      jcc(Assembler::greater, COMPARE_WIDE_VECTORS_LOOP_AVX2);\n-\n-      bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); \/\/ the hottest loop\n-\n-      evmovdquq(vec1, Address(ary1, limit, Address::times_1), Assembler::AVX_512bit);\n-      evpcmpeqb(mask, vec1, Address(ary2, limit, Address::times_1), Assembler::AVX_512bit);\n-      kortestql(mask, mask);\n-      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n-      addptr(limit, 64);  \/\/ update since we already compared at this addr\n-      cmpl(limit, -64);\n-      jccb(Assembler::lessEqual, COMPARE_WIDE_VECTORS_LOOP_AVX3);\n-\n-      \/\/ At this point we may still need to compare -limit+result bytes.\n-      \/\/ We could execute the next two instruction and just continue via non-wide path:\n-      \/\/  cmpl(limit, 0);\n-      \/\/  jcc(Assembler::equal, COMPARE_TAIL);  \/\/ true\n-      \/\/ But since we stopped at the points ary{1,2}+limit which are\n-      \/\/ not farther than 64 bytes from the ends of arrays ary{1,2}+result\n-      \/\/ (|limit| <= 32 and result < 32),\n-      \/\/ we may just compare the last 64 bytes.\n-      \/\/\n-      addptr(result, -64);   \/\/ it is safe, bc we just came from this area\n-      evmovdquq(vec1, Address(ary1, result, Address::times_1), Assembler::AVX_512bit);\n-      evpcmpeqb(mask, vec1, Address(ary2, result, Address::times_1), Assembler::AVX_512bit);\n-      kortestql(mask, mask);\n-      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n-\n-      jmp(TRUE_LABEL);\n-\n-      bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);\n-\n-    }\/\/if (VM_Version::supports_avx512vlbw())\n-#endif \/\/_LP64\n-    bind(COMPARE_WIDE_VECTORS);\n-    vmovdqu(vec1, Address(ary1, limit, Address::times_1));\n-    vmovdqu(vec2, Address(ary2, limit, Address::times_1));\n-    vpxor(vec1, vec2);\n-\n-    vptest(vec1, vec1);\n-    jcc(Assembler::notZero, FALSE_LABEL);\n-    addptr(limit, 32);\n-    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n-\n-    testl(result, result);\n-    jcc(Assembler::zero, TRUE_LABEL);\n-\n-    vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));\n-    vmovdqu(vec2, Address(ary2, result, Address::times_1, -32));\n-    vpxor(vec1, vec2);\n-\n-    vptest(vec1, vec1);\n-    jccb(Assembler::notZero, FALSE_LABEL);\n-    jmpb(TRUE_LABEL);\n-\n-    bind(COMPARE_TAIL); \/\/ limit is zero\n-    movl(limit, result);\n-    \/\/ Fallthru to tail compare\n-  } else if (UseSSE42Intrinsics) {\n-    \/\/ With SSE4.2, use double quad vector compare\n-    Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n-\n-    \/\/ Compare 16-byte vectors\n-    andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n-    andl(limit, 0xfffffff0);   \/\/ vector count (in bytes)\n-    jcc(Assembler::zero, COMPARE_TAIL);\n-\n-    lea(ary1, Address(ary1, limit, Address::times_1));\n-    lea(ary2, Address(ary2, limit, Address::times_1));\n-    negptr(limit);\n-\n-    bind(COMPARE_WIDE_VECTORS);\n-    movdqu(vec1, Address(ary1, limit, Address::times_1));\n-    movdqu(vec2, Address(ary2, limit, Address::times_1));\n-    pxor(vec1, vec2);\n-\n-    ptest(vec1, vec1);\n-    jcc(Assembler::notZero, FALSE_LABEL);\n-    addptr(limit, 16);\n-    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n-\n-    testl(result, result);\n-    jcc(Assembler::zero, TRUE_LABEL);\n-\n-    movdqu(vec1, Address(ary1, result, Address::times_1, -16));\n-    movdqu(vec2, Address(ary2, result, Address::times_1, -16));\n-    pxor(vec1, vec2);\n-\n-    ptest(vec1, vec1);\n-    jccb(Assembler::notZero, FALSE_LABEL);\n-    jmpb(TRUE_LABEL);\n-\n-    bind(COMPARE_TAIL); \/\/ limit is zero\n-    movl(limit, result);\n-    \/\/ Fallthru to tail compare\n-  }\n-\n-  \/\/ Compare 4-byte vectors\n-  andl(limit, 0xfffffffc); \/\/ vector count (in bytes)\n-  jccb(Assembler::zero, COMPARE_CHAR);\n-\n-  lea(ary1, Address(ary1, limit, Address::times_1));\n-  lea(ary2, Address(ary2, limit, Address::times_1));\n-  negptr(limit);\n-\n-  bind(COMPARE_VECTORS);\n-  movl(chr, Address(ary1, limit, Address::times_1));\n-  cmpl(chr, Address(ary2, limit, Address::times_1));\n-  jccb(Assembler::notEqual, FALSE_LABEL);\n-  addptr(limit, 4);\n-  jcc(Assembler::notZero, COMPARE_VECTORS);\n-\n-  \/\/ Compare trailing char (final 2 bytes), if any\n-  bind(COMPARE_CHAR);\n-  testl(result, 0x2);   \/\/ tail  char\n-  jccb(Assembler::zero, COMPARE_BYTE);\n-  load_unsigned_short(chr, Address(ary1, 0));\n-  load_unsigned_short(limit, Address(ary2, 0));\n-  cmpl(chr, limit);\n-  jccb(Assembler::notEqual, FALSE_LABEL);\n-\n-  if (is_array_equ && is_char) {\n-    bind(COMPARE_BYTE);\n-  } else {\n-    lea(ary1, Address(ary1, 2));\n-    lea(ary2, Address(ary2, 2));\n-\n-    bind(COMPARE_BYTE);\n-    testl(result, 0x1);   \/\/ tail  byte\n-    jccb(Assembler::zero, TRUE_LABEL);\n-    load_unsigned_byte(chr, Address(ary1, 0));\n-    load_unsigned_byte(limit, Address(ary2, 0));\n-    cmpl(chr, limit);\n-    jccb(Assembler::notEqual, FALSE_LABEL);\n-  }\n-  bind(TRUE_LABEL);\n-  movl(result, 1);   \/\/ return true\n-  jmpb(DONE);\n-\n-  bind(FALSE_LABEL);\n-  xorl(result, result); \/\/ return false\n-\n-  \/\/ That's it\n-  bind(DONE);\n-  if (UseAVX >= 2) {\n-    \/\/ clean upper bits of YMM registers\n-    vpxor(vec1, vec1);\n-    vpxor(vec2, vec2);\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":0,"deletions":211,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -292,4 +292,0 @@\n-  \/\/ Compare char[] or byte[] arrays.\n-  void arrays_equals(bool is_array_equ, Register ary1, Register ary2,\n-                     Register limit, Register result, Register chr,\n-                     XMMRegister vec1, XMMRegister vec2, bool is_char, KRegister mask = knoreg);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1172,0 +1172,8 @@\n+\/\/ Alignment specifying the maximum number of allowed bytes to pad.\n+\/\/ If padding > max, no padding is inserted.\n+void MacroAssembler::p2align(int modulus, int maxbytes) {\n+  if (modulus - (offset() % modulus) <= maxbytes) {\n+    align(modulus, offset());\n+  }\n+}\n+\n@@ -3573,0 +3581,4 @@\n+void MacroAssembler::vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {\n+  Assembler::vpcmpeqb(dst, src1, src2, vector_len);\n+}\n+\n@@ -3578,0 +3590,5 @@\n+void MacroAssembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+  assert(((dst->encoding() < 16 && nds->encoding() < 16) || VM_Version::supports_avx512vlbw()),\"XMM register should be 0-15\");\n+  Assembler::vpcmpeqw(dst, nds, src, vector_len);\n+}\n+\n@@ -9833,0 +9850,276 @@\n+\/\/ Compare char[] or byte[] arrays aligned to 4 bytes or substrings.\n+void MacroAssembler::arrays_equals(bool is_array_equ, Register ary1,\n+                                   Register ary2, Register limit,\n+                                   Register result, Register chr,\n+                                   XMMRegister vec1, XMMRegister vec2,\n+                                   bool is_char, KRegister mask,\n+                                   bool expand_ary2) {\n+  \/\/ for expand_ary2, limit is the (smaller) size of the second array.\n+  ShortBranchVerifier sbv(this);\n+  Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_VECTORS, COMPARE_CHAR, COMPARE_BYTE;\n+\n+  assert((!expand_ary2) || ((expand_ary2) && (UseAVX == 2)),\n+         \"Expansion only implemented for AVX2\");\n+\n+  int length_offset  = arrayOopDesc::length_offset_in_bytes();\n+  int base_offset    = arrayOopDesc::base_offset_in_bytes(is_char ? T_CHAR : T_BYTE);\n+\n+  if (is_array_equ) {\n+    \/\/ Check the input args\n+    cmpoop(ary1, ary2);\n+    jcc(Assembler::equal, TRUE_LABEL);\n+\n+    \/\/ Need additional checks for arrays_equals.\n+    testptr(ary1, ary1);\n+    jcc(Assembler::zero, FALSE_LABEL);\n+    testptr(ary2, ary2);\n+    jcc(Assembler::zero, FALSE_LABEL);\n+\n+    \/\/ Check the lengths\n+    movl(limit, Address(ary1, length_offset));\n+    cmpl(limit, Address(ary2, length_offset));\n+    jcc(Assembler::notEqual, FALSE_LABEL);\n+  }\n+\n+  \/\/ count == 0\n+  testl(limit, limit);\n+  jcc(Assembler::zero, TRUE_LABEL);\n+\n+  if (is_array_equ) {\n+    \/\/ Load array address\n+    lea(ary1, Address(ary1, base_offset));\n+    lea(ary2, Address(ary2, base_offset));\n+  }\n+\n+  if (is_array_equ && is_char) {\n+    \/\/ arrays_equals when used for char[].\n+    shll(limit, 1);      \/\/ byte count != 0\n+  }\n+  movl(result, limit); \/\/ copy\n+\n+  if (UseAVX >= 2) {\n+    \/\/ With AVX2, use 32-byte vector compare\n+    Label COMPARE_WIDE_VECTORS, COMPARE_WIDE_VECTORS_16, COMPARE_TAIL, COMPARE_TAIL_16;\n+\n+    \/\/ Compare 32-byte vectors\n+    andl(result, 0x0000001f);  \/\/   tail count (in bytes)\n+    andl(limit, 0xffffffe0);   \/\/ vector count (in bytes)\n+    jcc(Assembler::zero, COMPARE_TAIL_16);\n+\n+    lea(ary1, Address(ary1, limit,\n+                      expand_ary2 ? Address::times_2 : Address::times_1));\n+    lea(ary2, Address(ary2, limit, Address::times_1));\n+    negptr(limit);\n+\n+#ifdef _LP64\n+    if ((AVX3Threshold == 0) && VM_Version::supports_avx512vlbw()) { \/\/ trying 64 bytes fast loop\n+      Label COMPARE_WIDE_VECTORS_LOOP_AVX2, COMPARE_WIDE_VECTORS_LOOP_AVX3;\n+\n+      cmpl(limit, -64);\n+      jcc(Assembler::greater, COMPARE_WIDE_VECTORS_LOOP_AVX2);\n+\n+      bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); \/\/ the hottest loop\n+\n+      evmovdquq(vec1, Address(ary1, limit, Address::times_1), Assembler::AVX_512bit);\n+      evpcmpeqb(mask, vec1, Address(ary2, limit, Address::times_1), Assembler::AVX_512bit);\n+      kortestql(mask, mask);\n+      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n+      addptr(limit, 64);  \/\/ update since we already compared at this addr\n+      cmpl(limit, -64);\n+      jccb(Assembler::lessEqual, COMPARE_WIDE_VECTORS_LOOP_AVX3);\n+\n+      \/\/ At this point we may still need to compare -limit+result bytes.\n+      \/\/ We could execute the next two instruction and just continue via non-wide path:\n+      \/\/  cmpl(limit, 0);\n+      \/\/  jcc(Assembler::equal, COMPARE_TAIL);  \/\/ true\n+      \/\/ But since we stopped at the points ary{1,2}+limit which are\n+      \/\/ not farther than 64 bytes from the ends of arrays ary{1,2}+result\n+      \/\/ (|limit| <= 32 and result < 32),\n+      \/\/ we may just compare the last 64 bytes.\n+      \/\/\n+      addptr(result, -64);   \/\/ it is safe, bc we just came from this area\n+      evmovdquq(vec1, Address(ary1, result, Address::times_1), Assembler::AVX_512bit);\n+      evpcmpeqb(mask, vec1, Address(ary2, result, Address::times_1), Assembler::AVX_512bit);\n+      kortestql(mask, mask);\n+      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n+\n+      jmp(TRUE_LABEL);\n+\n+      bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);\n+\n+    }\/\/if (VM_Version::supports_avx512vlbw())\n+#endif \/\/_LP64\n+    bind(COMPARE_WIDE_VECTORS);\n+    vmovdqu(vec1, Address(ary1, limit,\n+                          expand_ary2 ? Address::times_2 : Address::times_1));\n+    if (expand_ary2) {\n+      vpmovzxbw(vec2, Address(ary2, limit, Address::times_1),\n+                Assembler::AVX_256bit);\n+    } else {\n+      vmovdqu(vec2, Address(ary2, limit, Address::times_1));\n+    }\n+    vpxor(vec1, vec2);\n+\n+    vptest(vec1, vec1);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    addptr(limit, expand_ary2 ? 16 : 32);\n+    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n+\n+    testl(result, result);\n+    jcc(Assembler::zero, TRUE_LABEL);\n+\n+    vmovdqu(vec1,\n+            Address(ary1, result,\n+                    expand_ary2 ? Address::times_2 : Address::times_1, -32));\n+    if (expand_ary2) {\n+      vpmovzxbw(vec2, Address(ary2, result, Address::times_1, -16),\n+                Assembler::AVX_256bit);\n+    } else {\n+      vmovdqu(vec2, Address(ary2, result, Address::times_1, -32));\n+    }\n+    vpxor(vec1, vec2);\n+\n+    vptest(vec1, vec1);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    jmp(TRUE_LABEL);\n+\n+    bind(COMPARE_TAIL_16); \/\/ limit is zero\n+    movl(limit, result);\n+\n+    \/\/ Compare 16-byte chunks\n+    andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n+    andl(limit, 0xfffffff0);   \/\/ vector count (in bytes)\n+    jcc(Assembler::zero, COMPARE_TAIL);\n+\n+    lea(ary1, Address(ary1, limit, expand_ary2 ? Address::times_2 : Address::times_1));\n+    lea(ary2, Address(ary2, limit, Address::times_1));\n+    negptr(limit);\n+\n+    bind(COMPARE_WIDE_VECTORS_16);\n+    movdqu(vec1, Address(ary1, limit,\n+                         expand_ary2 ? Address::times_2 : Address::times_1));\n+    if (expand_ary2) {\n+      vpmovzxbw(vec2, Address(ary2, limit, Address::times_1),\n+                Assembler::AVX_128bit);\n+    } else {\n+      movdqu(vec2, Address(ary2, limit, Address::times_1));\n+    }\n+    vpxor(vec1, vec2);\n+\n+    vptest(vec1, vec1);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    addptr(limit, expand_ary2 ? 8 : 16);\n+    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS_16);\n+\n+    bind(COMPARE_TAIL); \/\/ limit is zero\n+    movl(limit, result);\n+    \/\/ Fallthru to tail compare\n+  } else if (UseSSE42Intrinsics) {\n+    \/\/ With SSE4.2, use double quad vector compare\n+    Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n+\n+    \/\/ Compare 16-byte vectors\n+    andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n+    andl(limit, 0xfffffff0);   \/\/ vector count (in bytes)\n+    jcc(Assembler::zero, COMPARE_TAIL);\n+\n+    lea(ary1, Address(ary1, limit, Address::times_1));\n+    lea(ary2, Address(ary2, limit, Address::times_1));\n+    negptr(limit);\n+\n+    bind(COMPARE_WIDE_VECTORS);\n+    movdqu(vec1, Address(ary1, limit, Address::times_1));\n+    movdqu(vec2, Address(ary2, limit, Address::times_1));\n+    pxor(vec1, vec2);\n+\n+    ptest(vec1, vec1);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    addptr(limit, 16);\n+    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n+\n+    testl(result, result);\n+    jcc(Assembler::zero, TRUE_LABEL);\n+\n+    movdqu(vec1, Address(ary1, result, Address::times_1, -16));\n+    movdqu(vec2, Address(ary2, result, Address::times_1, -16));\n+    pxor(vec1, vec2);\n+\n+    ptest(vec1, vec1);\n+    jccb(Assembler::notZero, FALSE_LABEL);\n+    jmpb(TRUE_LABEL);\n+\n+    bind(COMPARE_TAIL); \/\/ limit is zero\n+    movl(limit, result);\n+    \/\/ Fallthru to tail compare\n+  }\n+\n+  \/\/ Compare 4-byte vectors\n+  if (expand_ary2) {\n+    testl(result, result);\n+    jccb(Assembler::zero, TRUE_LABEL);\n+  } else {\n+    andl(limit, 0xfffffffc); \/\/ vector count (in bytes)\n+    jccb(Assembler::zero, COMPARE_CHAR);\n+  }\n+\n+  lea(ary1, Address(ary1, limit, expand_ary2 ? Address::times_2 : Address::times_1));\n+  lea(ary2, Address(ary2, limit, Address::times_1));\n+  negptr(limit);\n+\n+  bind(COMPARE_VECTORS);\n+  if (expand_ary2) {\n+    \/\/ There are no \"vector\" operations for bytes to shorts\n+    movzbl(chr, Address(ary2, limit, Address::times_1));\n+    cmpw(Address(ary1, limit, Address::times_2), chr);\n+    jccb(Assembler::notEqual, FALSE_LABEL);\n+    addptr(limit, 1);\n+    jcc(Assembler::notZero, COMPARE_VECTORS);\n+    jmp(TRUE_LABEL);\n+  } else {\n+    movl(chr, Address(ary1, limit,\n+                      expand_ary2 ? Address::times_2 : Address::times_1));\n+    cmpl(chr, Address(ary2, limit, Address::times_1));\n+    jccb(Assembler::notEqual, FALSE_LABEL);\n+    addptr(limit, 4);\n+    jcc(Assembler::notZero, COMPARE_VECTORS);\n+  }\n+\n+  \/\/ Compare trailing char (final 2 bytes), if any\n+  bind(COMPARE_CHAR);\n+  testl(result, 0x2);   \/\/ tail  char\n+  jccb(Assembler::zero, COMPARE_BYTE);\n+  load_unsigned_short(chr, Address(ary1, 0));\n+  load_unsigned_short(limit, Address(ary2, 0));\n+  cmpl(chr, limit);\n+  jccb(Assembler::notEqual, FALSE_LABEL);\n+\n+  if (is_array_equ && is_char) {\n+    bind(COMPARE_BYTE);\n+  } else {\n+    lea(ary1, Address(ary1, expand_ary2 ? 4 : 2));\n+    lea(ary2, Address(ary2, 2));\n+\n+    bind(COMPARE_BYTE);\n+    testl(result, 0x1);   \/\/ tail  byte\n+    jccb(Assembler::zero, TRUE_LABEL);\n+    load_unsigned_byte(chr, Address(ary1, 0));\n+    load_unsigned_byte(limit, Address(ary2, 0));\n+    cmpl(chr, limit);\n+    jccb(Assembler::notEqual, FALSE_LABEL);\n+  }\n+  bind(TRUE_LABEL);\n+  movl(result, 1);   \/\/ return true\n+  jmpb(DONE);\n+\n+  bind(FALSE_LABEL);\n+  xorl(result, result); \/\/ return false\n+\n+  \/\/ That's it\n+  bind(DONE);\n+  if (UseAVX >= 2) {\n+    \/\/ clean upper bits of YMM registers\n+    vpxor(vec1, vec1);\n+    vpxor(vec2, vec2);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":293,"deletions":0,"binary":false,"changes":293,"status":"modified"},{"patch":"@@ -218,0 +218,1 @@\n+  void p2align(int modulus, int maxbytes);\n@@ -249,0 +250,6 @@\n+  \/\/ Compare char[] or byte[] arrays.\n+  void arrays_equals(bool is_array_equ, Register ary1, Register ary2,\n+                     Register limit, Register result, Register chr,\n+                     XMMRegister vec1, XMMRegister vec2, bool is_char,\n+                     KRegister mask = knoreg, bool expand_ary2 = false);\n+\n@@ -918,0 +925,68 @@\n+  \/\/ Adding more natural conditional jump instructions\n+  void ALWAYSINLINE jo(Label& L, bool maybe_short = true) { jcc(Assembler::overflow, L, maybe_short); }\n+  void ALWAYSINLINE jno(Label& L, bool maybe_short = true) { jcc(Assembler::noOverflow, L, maybe_short); }\n+  void ALWAYSINLINE js(Label& L, bool maybe_short = true) { jcc(Assembler::positive, L, maybe_short); }\n+  void ALWAYSINLINE jns(Label& L, bool maybe_short = true) { jcc(Assembler::negative, L, maybe_short); }\n+  void ALWAYSINLINE je(Label& L, bool maybe_short = true) { jcc(Assembler::equal, L, maybe_short); }\n+  void ALWAYSINLINE jz(Label& L, bool maybe_short = true) { jcc(Assembler::zero, L, maybe_short); }\n+  void ALWAYSINLINE jne(Label& L, bool maybe_short = true) { jcc(Assembler::notEqual, L, maybe_short); }\n+  void ALWAYSINLINE jnz(Label& L, bool maybe_short = true) { jcc(Assembler::notZero, L, maybe_short); }\n+  void ALWAYSINLINE jb(Label& L, bool maybe_short = true) { jcc(Assembler::below, L, maybe_short); }\n+  void ALWAYSINLINE jnae(Label& L, bool maybe_short = true) { jcc(Assembler::below, L, maybe_short); }\n+  void ALWAYSINLINE jc(Label& L, bool maybe_short = true) { jcc(Assembler::carrySet, L, maybe_short); }\n+  void ALWAYSINLINE jnb(Label& L, bool maybe_short = true) { jcc(Assembler::aboveEqual, L, maybe_short); }\n+  void ALWAYSINLINE jae(Label& L, bool maybe_short = true) { jcc(Assembler::aboveEqual, L, maybe_short); }\n+  void ALWAYSINLINE jnc(Label& L, bool maybe_short = true) { jcc(Assembler::carryClear, L, maybe_short); }\n+  void ALWAYSINLINE jbe(Label& L, bool maybe_short = true) { jcc(Assembler::belowEqual, L, maybe_short); }\n+  void ALWAYSINLINE jna(Label& L, bool maybe_short = true) { jcc(Assembler::belowEqual, L, maybe_short); }\n+  void ALWAYSINLINE ja(Label& L, bool maybe_short = true) { jcc(Assembler::above, L, maybe_short); }\n+  void ALWAYSINLINE jnbe(Label& L, bool maybe_short = true) { jcc(Assembler::above, L, maybe_short); }\n+  void ALWAYSINLINE jl(Label& L, bool maybe_short = true) { jcc(Assembler::less, L, maybe_short); }\n+  void ALWAYSINLINE jnge(Label& L, bool maybe_short = true) { jcc(Assembler::less, L, maybe_short); }\n+  void ALWAYSINLINE jge(Label& L, bool maybe_short = true) { jcc(Assembler::greaterEqual, L, maybe_short); }\n+  void ALWAYSINLINE jnl(Label& L, bool maybe_short = true) { jcc(Assembler::greaterEqual, L, maybe_short); }\n+  void ALWAYSINLINE jle(Label& L, bool maybe_short = true) { jcc(Assembler::lessEqual, L, maybe_short); }\n+  void ALWAYSINLINE jng(Label& L, bool maybe_short = true) { jcc(Assembler::lessEqual, L, maybe_short); }\n+  void ALWAYSINLINE jg(Label& L, bool maybe_short = true) { jcc(Assembler::greater, L, maybe_short); }\n+  void ALWAYSINLINE jnle(Label& L, bool maybe_short = true) { jcc(Assembler::greater, L, maybe_short); }\n+  void ALWAYSINLINE jp(Label& L, bool maybe_short = true) { jcc(Assembler::parity, L, maybe_short); }\n+  void ALWAYSINLINE jpe(Label& L, bool maybe_short = true) { jcc(Assembler::parity, L, maybe_short); }\n+  void ALWAYSINLINE jnp(Label& L, bool maybe_short = true) { jcc(Assembler::noParity, L, maybe_short); }\n+  void ALWAYSINLINE jpo(Label& L, bool maybe_short = true) { jcc(Assembler::noParity, L, maybe_short); }\n+\/\/ * No condition for this *  void ALWAYSINLINE jcxz(Label& L, bool maybe_short = true) { jcc(Assembler::cxz, L, maybe_short); }\n+\/\/ * No condition for this *  void ALWAYSINLINE jecxz(Label& L, bool maybe_short = true) { jcc(Assembler::cxz, L, maybe_short); }\n+\n+\/\/ Short versions of the above\n+  void ALWAYSINLINE jo_b(Label& L) { jccb(Assembler::overflow, L); }\n+  void ALWAYSINLINE jno_b(Label& L) { jccb(Assembler::noOverflow, L); }\n+  void ALWAYSINLINE js_b(Label& L) { jccb(Assembler::positive, L); }\n+  void ALWAYSINLINE jns_b(Label& L) { jccb(Assembler::negative, L); }\n+  void ALWAYSINLINE je_b(Label& L) { jccb(Assembler::equal, L); }\n+  void ALWAYSINLINE jz_b(Label& L) { jccb(Assembler::zero, L); }\n+  void ALWAYSINLINE jne_b(Label& L) { jccb(Assembler::notEqual, L); }\n+  void ALWAYSINLINE jnz_b(Label& L) { jccb(Assembler::notZero, L); }\n+  void ALWAYSINLINE jb_b(Label& L) { jccb(Assembler::below, L); }\n+  void ALWAYSINLINE jnae_b(Label& L) { jccb(Assembler::below, L); }\n+  void ALWAYSINLINE jc_b(Label& L) { jccb(Assembler::carrySet, L); }\n+  void ALWAYSINLINE jnb_b(Label& L) { jccb(Assembler::aboveEqual, L); }\n+  void ALWAYSINLINE jae_b(Label& L) { jccb(Assembler::aboveEqual, L); }\n+  void ALWAYSINLINE jnc_b(Label& L) { jccb(Assembler::carryClear, L); }\n+  void ALWAYSINLINE jbe_b(Label& L) { jccb(Assembler::belowEqual, L); }\n+  void ALWAYSINLINE jna_b(Label& L) { jccb(Assembler::belowEqual, L); }\n+  void ALWAYSINLINE ja_b(Label& L) { jccb(Assembler::above, L); }\n+  void ALWAYSINLINE jnbe_b(Label& L) { jccb(Assembler::above, L); }\n+  void ALWAYSINLINE jl_b(Label& L) { jccb(Assembler::less, L); }\n+  void ALWAYSINLINE jnge_b(Label& L) { jccb(Assembler::less, L); }\n+  void ALWAYSINLINE jge_b(Label& L) { jccb(Assembler::greaterEqual, L); }\n+  void ALWAYSINLINE jnl_b(Label& L) { jccb(Assembler::greaterEqual, L); }\n+  void ALWAYSINLINE jle_b(Label& L) { jccb(Assembler::lessEqual, L); }\n+  void ALWAYSINLINE jng_b(Label& L) { jccb(Assembler::lessEqual, L); }\n+  void ALWAYSINLINE jg_b(Label& L) { jccb(Assembler::greater, L); }\n+  void ALWAYSINLINE jnle_b(Label& L) { jccb(Assembler::greater, L); }\n+  void ALWAYSINLINE jp_b(Label& L) { jccb(Assembler::parity, L); }\n+  void ALWAYSINLINE jpe_b(Label& L) { jccb(Assembler::parity, L); }\n+  void ALWAYSINLINE jnp_b(Label& L) { jccb(Assembler::noParity, L); }\n+  void ALWAYSINLINE jpo_b(Label& L) { jccb(Assembler::noParity, L); }\n+\/\/ * No condition for this *  void ALWAYSINLINE jcxz_b(Label& L) { jccb(Assembler::cxz, L); }\n+\/\/ * No condition for this *  void ALWAYSINLINE jecxz_b(Label& L) { jccb(Assembler::cxz, L); }\n+\n@@ -1352,0 +1427,1 @@\n+  void vpcmpeqb(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n@@ -1353,0 +1429,1 @@\n+  void vpcmpeqw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -4202,0 +4202,4 @@\n+  if ((UseAVX == 2) && EnableX86ECoreOpts && VM_Version::supports_avx2()) {\n+    generate_string_indexof(StubRoutines::_string_indexof_array);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/intrinsicnode.hpp\"\n@@ -567,0 +568,2 @@\n+  void generate_string_indexof_stubs(address *fnptrs, StrIntrinsicNode::ArgEncoding ae);\n+  void generate_string_indexof(address *fnptrs);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,2156 @@\n+\/*\n+ * Copyright (c) 2023, Intel Corporation. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"macroAssembler_x86.hpp\"\n+#include \"precompiled.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+\/******************************************************************************\/\n+\/\/                     String handling intrinsics\n+\/\/                     --------------------------\n+\/\/\n+\/\/ Currently implements scheme described in http:\/\/0x80.pl\/articles\/simd-strfind.html\n+\/\/ Implementation can be found at https:\/\/github.com\/WojciechMula\/sse4-strstr\n+\/\/\n+\/\/ The general idea is as follows:\n+\/\/ 1. Broadcast the first byte of the needle to a ymm register (32 bytes)\n+\/\/ 2. Broadcast the last byte of the needle to a different ymm register\n+\/\/ 3. Compare the first-byte ymm register to the first 32 bytes of the haystack\n+\/\/ 4. Compare the last-byte register to the 32 bytes of the haystack at the (k-1)st position\n+\/\/    where k is the length of the needle\n+\/\/ 5. Logically AND the results of the comparison\n+\/\/\n+\/\/ The result of the AND yields the position within the haystack where both the first\n+\/\/ and last bytes of the needle exist in their correct relative positions.  Check the full\n+\/\/ needle value against the haystack to confirm a match.\n+\/\/\n+\/\/ This implementation uses memcmp to compare when the size of the needle is >= 32 bytes.\n+\/\/ For other needle sizes, the comparison is done with register compares to eliminate the\n+\/\/ overhead of the call (including range checks, etc.).  The size of the comparison is\n+\/\/ known, and it is also known to be safe reading the haystack for the full width of the needle.\n+\/\/\n+\/\/ The original algorithm as implemented will potentially read past the end of the haystack.\n+\/\/ This implementation protects against that.  Instead of reading as many 32-byte chunks as\n+\/\/ possible and then handling the tail, we calculate the last position of a vaild 32-byte\n+\/\/ read and adjust the starting position of the second read such that the last read will not\n+\/\/ go beyond the end of the haystack.  So the first comparison is to the first 32 bytes of the\n+\/\/ haystack, and the second is offset by an amount to make the last read legal.  The remainder of\n+\/\/ the comparisons are done incrementing by 32 bytes.\n+\/\/\n+\/\/ This will cause 16 bytes on average to be examined twice, but that is cheaper than the\n+\/\/ logic required for tail processing.\n+\/\/\n+\/******************************************************************************\/\n+\n+#define __ _masm->\n+\n+\/\/ Register definitions for consistency\n+#define XMM_BYTE_0 xmm0\n+#define XMM_BYTE_K xmm1\n+#define XMM_BYTE_1 xmm12\n+#define XMM_BYTE_2 xmm13\n+#define XMM_TMP1 xmm15\n+#define XMM_TMP2 xmm14\n+#define XMM_TMP3 xmm2\n+#define XMM_TMP4 xmm3\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ Tuning parameters \/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Highly optimized special cases\n+\/\/ For haystack sizes <= 32 we can use vector comparisons by utilizing\n+\/\/ the stack.  We can copy the incoming haystack to the stack which\n+\/\/ will prevent having to check for reading past the end and causing\n+\/\/ potential page faults.\n+\/\/ Set this value to the largest needle size to optimize in this manner.\n+#define OPT_NEEDLE_SIZE_MAX 5\n+\n+\/\/ Number of bytes of haystack to compare for equality\n+\/\/ A value of 2 checks the first and last bytes of the needle.\n+\/\/ A value of 3 checks the first two bytes and the last byte of the needle.\n+\/\/ A value of 4 checks the first three bytes and last byte of the needle.\n+\/\/ Added for performance tuning.\n+#define NUMBER_OF_NEEDLE_BYTES_TO_COMPARE 3\n+\n+\/\/ If DO_EARLY_BAILOUT is non-zero, each element of comparison will be checked.\n+\/\/ If non-zero, all compares will be done with a final check.\n+#define DO_EARLY_BAILOUT 1\n+\n+\/\/  This macro handles clearing the bits of the mask register depending\n+\/\/  on whether we're comparing bytes or words.\n+#define CLEAR_BIT(mask, tmp) \\\n+  if (isU) {                 \\\n+    __ blsrl(tmp, mask);     \\\n+    __ blsrl(mask, tmp);     \\\n+  } else {                   \\\n+    __ blsrl(mask, mask);    \\\n+  }\n+\n+#define NUMBER_OF_CASES 10\n+\n+#undef STACK_SPACE\n+#undef MAX_NEEDLE_LEN_TO_EXPAND\n+#define MAX_NEEDLE_LEN_TO_EXPAND 0x20\n+\n+\/\/ Stack layout:\n+#define COPIED_HAYSTACK_STACK_OFFSET (0x0)  \/\/ MUST BE ZERO!\n+#define COPIED_HAYSTACK_STACK_SIZE (64)     \/\/ MUST BE 64!\n+\n+#define EXPANDED_NEEDLE_STACK_OFFSET \\\n+  (COPIED_HAYSTACK_STACK_OFFSET + COPIED_HAYSTACK_STACK_SIZE)\n+#define EXPANDED_NEEDLE_STACK_SIZE (MAX_NEEDLE_LEN_TO_EXPAND * 2 + 32)\n+\n+#define SAVED_HAYSTACK_STACK_OFFSET \\\n+  (EXPANDED_NEEDLE_STACK_OFFSET + EXPANDED_NEEDLE_STACK_SIZE)\n+#define SAVED_HAYSTACK_STACK_SIZE (8)\n+\n+#define SAVED_INCREMENT_STACK_OFFSET \\\n+  (SAVED_HAYSTACK_STACK_OFFSET + SAVED_HAYSTACK_STACK_SIZE)\n+#define SAVED_INCREMENT_STACK_SIZE (8)\n+\n+#define SAVED_TERM_ADDR_STACK_OFFSET \\\n+  (SAVED_INCREMENT_STACK_OFFSET + SAVED_INCREMENT_STACK_SIZE)\n+#define SAVED_TERM_ADDR_STACK_SIZE (8)\n+\n+#define STACK_SPACE                                          \\\n+  (COPIED_HAYSTACK_STACK_SIZE + EXPANDED_NEEDLE_STACK_SIZE + \\\n+   SAVED_HAYSTACK_STACK_SIZE + SAVED_INCREMENT_STACK_SIZE +  \\\n+   SAVED_TERM_ADDR_STACK_SIZE)\n+\n+\/\/ Define this to push registers onto stack, otherwise saved\n+\/\/ registers will be put into xmm registers.\n+#undef PUSH_REGS\n+\n+\/\/ Helper for broadcasting needle elements to ymm registers for compares\n+\/\/\n+\/\/ For UTF-16 encoded needles, broadcast a word at the proper offset to the ymm\n+\/\/ register (case UU)\n+\/\/ For the UTF-16 encoded haystack with Latin1 encoded needle (case UL) we have\n+\/\/ to read into a temp register to zero-extend the single byte needle value, then\n+\/\/ broadcast words to the ymm register.\n+\/\/\n+\/\/ Parameters:\n+\/\/ sizeKnown - True if size known at compile time\n+\/\/ size - the size of the needle.  Pass 0 if unknown at compile time\n+\/\/ bytesToCompare - see NUMBER_OF_NEEDLE_BYTES_TO_COMPARE above\n+\/\/ needle - the address of the first byte of the needle\n+\/\/ needleLen - length of needle if !sizeKnown\n+\/\/ isUU and isUL - true if argument encoding is UU or UL, respectively\n+\/\/ _masm - Current MacroAssembler instance pointer\n+static void broadcast_additional_needles(bool sizeKnown, int size,\n+                                         int bytesToCompare, Register needle,\n+                                         Register needleLen, Register rTmp,\n+                                         bool isUU, bool isUL,\n+                                         MacroAssembler* _masm) {\n+  Label L_done;\n+\n+  assert_different_registers(needle, needleLen, rTmp);\n+\n+#undef byte_1\n+#define byte_1 XMM_BYTE_1\n+#undef byte_2\n+#define byte_2 XMM_BYTE_2\n+\n+  bool isU = (isUU || isUL);\n+\n+  size = sizeKnown ? size : NUMBER_OF_CASES + 1;\n+\n+  if (bytesToCompare > 2) {\n+    if (!sizeKnown) {\n+      __ cmpq(needleLen, (isU ? 4 : 2));\n+      __ jl_b(L_done);\n+    }\n+\n+    if (size > (isU ? 4 : 2)) {\n+      \/\/ Add compare for second byte\n+      if (isUU) {\n+        __ vpbroadcastw(byte_1, Address(needle, 2), Assembler::AVX_256bit);\n+      } else if (isUL) {\n+        __ movzbl(rTmp, Address(needle, 1));\n+        __ movdl(byte_1, rTmp);\n+        \/\/ 1st byte of needle in words\n+        __ vpbroadcastw(byte_1, byte_1, Assembler::AVX_256bit);\n+      } else {\n+        __ vpbroadcastb(byte_1, Address(needle, 1), Assembler::AVX_256bit);\n+      }\n+    }\n+\n+    if (bytesToCompare > 3) {\n+      if (!sizeKnown) {\n+        __ cmpq(needleLen, (isU ? 6 : 3));\n+        __ jl_b(L_done);\n+      }\n+\n+      if (size > (isU ? 6 : 3)) {\n+        \/\/ Add compare for third byte\n+        if (isUU) {\n+          __ vpbroadcastw(byte_2, Address(needle, 4), Assembler::AVX_256bit);\n+      } else if (isUL) {\n+        __ movzbl(rTmp, Address(needle, 2));\n+        __ movdl(byte_1, rTmp);\n+        \/\/ 1st byte of needle in words\n+        __ vpbroadcastw(byte_1, byte_1, Assembler::AVX_256bit);\n+        } else {\n+          __ vpbroadcastb(byte_2, Address(needle, 2), Assembler::AVX_256bit);\n+        }\n+      }\n+    }\n+    __ bind(L_done);\n+  }\n+\n+#undef byte_1\n+#undef byte_2\n+}\n+\n+\/\/ Helper for comparing needle elements to a big haystack\n+\/\/\n+\/\/ This helper compares bytes or words in the ymm registers to\n+\/\/ the proper positions within the haystack.  It will bail out early if\n+\/\/ doEarlyBailout is true, otherwise it will progressively and together\n+\/\/ the comparison results, returning the answer at the end.\n+\/\/\n+\/\/ On return, eq_mask will be set to the comparison mask value.  If no match\n+\/\/ is found, this helper will jump to noMatch.\n+\/\/\n+\/\/ Parameters:\n+\/\/ sizeKnown - True if size known at compile time\n+\/\/ size - the size of the needle.  Pass 0 if unknown at compile time\n+\/\/ bytesToCompare - see NUMBER_OF_NEEDLE_BYTES_TO_COMPARE above\n+\/\/ noMatch - label bound outside to jump to if there is no match\n+\/\/ haystack - the address of the first byte of the haystack\n+\/\/ hsLen - the sizeof the haystack\n+\/\/ isU - true if argument encoding is either UU or UL\n+\/\/ doEarlyBailout - if true, check mismatch after every comparison\n+\/\/ eq_mask - The bit mask returned that holds the result of the comparison\n+\/\/ rTmp - a temporary register\n+\/\/ nMinusK - Size of haystack minus size of needle\n+\/\/ _masm - Current MacroAssembler instance pointer\n+\/\/\n+\/\/ If (n - k) < 32, need to handle reading past end of haystack\n+static void compare_big_haystack_to_needle(bool sizeKnown,\n+    int size, int bytesToCompare, Label& noMatch, Register haystack,\n+    Register hsLen, Register needleLen, bool isU, bool doEarlyBailout, Register eq_mask,\n+    Register rTmp, Register nMinusK, MacroAssembler* _masm) {\n+\n+  assert_different_registers(eq_mask, haystack, needleLen, rTmp, hsLen, r10);\n+  assert(r10 == nMinusK, \"Bad register\");\n+\n+#undef byte_0\n+#define byte_0 XMM_BYTE_0\n+#undef byte_k\n+#define byte_k XMM_BYTE_K\n+#undef byte_1\n+#define byte_1 XMM_BYTE_1\n+#undef byte_2\n+#define byte_2 XMM_BYTE_2\n+#undef cmp_0\n+#define cmp_0 XMM_TMP3\n+#undef cmp_k\n+#define cmp_k XMM_TMP4\n+#undef lastCompare\n+#define lastCompare rTmp\n+#undef lastMask\n+\n+  int sizeIncr = isU ? 2 : 1;\n+  bool needToSaveRCX = false;\n+\n+  needToSaveRCX = (haystack == rcx) || (hsLen == rcx) || (eq_mask == rcx) ||\n+                  (rTmp == rcx) || (needleLen == rcx) || (nMinusK == rcx);\n+\n+  Label L_OKtoCompareFull, L_done, L_specialCase_gt2, L_specialCase_gt3;\n+\n+  assert(!sizeKnown || (sizeKnown && ((size > 0) && (size <= NUMBER_OF_CASES))), \"Incorrect size given\");\n+\n+  Address kThByte =\n+      sizeKnown ? Address(haystack, size - sizeIncr)\n+                : Address(haystack, needleLen, Address::times_1, -(sizeIncr));\n+  size = sizeKnown ? size : NUMBER_OF_CASES + 1;\n+\n+  \/\/ Compare first byte of needle to haystack\n+  if (isU) {\n+    __ vpcmpeqw(cmp_0, byte_0, Address(haystack, 0), Assembler::AVX_256bit);\n+  } else {\n+    __ vpcmpeqb(cmp_0, byte_0, Address(haystack, 0), Assembler::AVX_256bit);\n+  }\n+\n+  if (doEarlyBailout) {\n+    __ vpmovmskb(eq_mask, cmp_0, Assembler::AVX_256bit);\n+    __ testl(eq_mask, eq_mask);\n+    __ je(noMatch);\n+  }\n+\n+  if (size == (isU ? 2 : 1)) {\n+    __ vpmovmskb(eq_mask, cmp_0, Assembler::AVX_256bit);\n+  } else {\n+    __ cmpq(nMinusK, 32);\n+    __ jae(L_OKtoCompareFull);\n+    __ vpmovmskb(eq_mask, cmp_0, Assembler::AVX_256bit);\n+\n+    \/\/ If n-k less than 32, comparing the last byte of the needle will result\n+    \/\/ in reading past the end of the haystack.  Account for this here.\n+    __ leaq(lastCompare, Address(haystack, hsLen, Address::times_1, -32));\n+#undef cmp_0\n+#undef saveRCX\n+#define saveRCX XMM_TMP3\n+    if (needToSaveRCX) {\n+      __ movdq(saveRCX, rcx);\n+    }\n+#undef shiftVal\n+#define shiftVal rcx\n+    __ movq(shiftVal, isU ? 30 : 31);\n+    __ subq(shiftVal, nMinusK);\n+\n+    if (isU) {\n+      __ vpcmpeqw(cmp_k, byte_k, Address(lastCompare, 0),\n+                  Assembler::AVX_256bit);\n+    } else {\n+      __ vpcmpeqb(cmp_k, byte_k, Address(lastCompare, 0),\n+                  Assembler::AVX_256bit);\n+    }\n+#undef lastCompare\n+#define lastMask rTmp\n+    __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n+    __ shrq(lastMask);\n+#undef shiftVal\n+    __ andq(eq_mask, lastMask);\n+    if (needToSaveRCX) {\n+      __ movdq(rcx, saveRCX);\n+    }\n+#undef saveRCX\n+\n+    if (bytesToCompare > 2) {\n+      if (size > (isU ? 4 : 2)) {\n+        if (doEarlyBailout) {\n+          __ testl(eq_mask, eq_mask);\n+          __ je(noMatch);\n+        }\n+        __ cmpq(hsLen, isU ? 34 : 33);\n+        __ jl(L_specialCase_gt2);\n+        if (isU) {\n+          __ vpcmpeqw(cmp_k, byte_1, Address(haystack, 2),\n+                      Assembler::AVX_256bit);\n+        } else {\n+          __ vpcmpeqb(cmp_k, byte_1, Address(haystack, 1),\n+                      Assembler::AVX_256bit);\n+        }\n+        __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n+        __ andq(eq_mask, lastMask);\n+      }\n+    }\n+\n+    if (bytesToCompare > 3) {\n+      if (size > (isU ? 6 : 3)) {\n+        if (doEarlyBailout) {\n+          __ testl(eq_mask, eq_mask);\n+          __ je(noMatch);\n+        }\n+        __ cmpq(hsLen, isU ? 36 : 34);\n+        __ jl(L_specialCase_gt3);\n+        if (isU) {\n+          __ vpcmpeqw(cmp_k, byte_2, Address(haystack, 4),\n+                      Assembler::AVX_256bit);\n+        } else {\n+          __ vpcmpeqb(cmp_k, byte_2, Address(haystack, 2),\n+                      Assembler::AVX_256bit);\n+        }\n+        __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n+        __ andq(eq_mask, lastMask);\n+      }\n+    }\n+    __ jmpb(L_done);\n+\n+    __ bind(L_specialCase_gt2);\n+    \/\/ Comparing multiple bytes and haystack length == 32\n+    if (isU) {\n+      __ vpcmpeqw(cmp_k, byte_1, Address(haystack, 0), Assembler::AVX_256bit);\n+    } else {\n+      __ vpcmpeqb(cmp_k, byte_1, Address(haystack, 0), Assembler::AVX_256bit);\n+    }\n+    __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n+    __ shrq(lastMask, isU ? 2 : 1);\n+    __ andq(eq_mask, lastMask);\n+\n+    if (bytesToCompare > 3) {\n+      if (size > (isU ? 6 : 3)) {\n+        if (doEarlyBailout) {\n+          __ testl(eq_mask, eq_mask);\n+          __ je(noMatch);\n+        }\n+        if (isU) {\n+          __ vpcmpeqw(cmp_k, byte_2, Address(haystack, 0),\n+                      Assembler::AVX_256bit);\n+        } else {\n+          __ vpcmpeqb(cmp_k, byte_2, Address(haystack, 0),\n+                      Assembler::AVX_256bit);\n+        }\n+        __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n+        __ shrq(lastMask, isU ? 4 : 2);\n+        __ andq(eq_mask, lastMask);\n+      }\n+    }\n+\n+    __ jmp(L_done);\n+\n+    __ bind(L_specialCase_gt3);\n+    \/\/ Comparing multiple bytes and hs length == isU ? 34 : 33\n+    if (isU) {\n+      __ vpcmpeqw(cmp_k, byte_2, Address(haystack, 0), Assembler::AVX_256bit);\n+    } else {\n+      __ vpcmpeqb(cmp_k, byte_2, Address(haystack, 0), Assembler::AVX_256bit);\n+    }\n+    __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n+    __ shrq(lastMask, isU ? 4 : 2);\n+    __ andq(eq_mask, lastMask);\n+\n+    __ jmp(L_done);\n+\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    __ bind(L_OKtoCompareFull);\n+#define result XMM_TMP3\n+#define cmp_0 XMM_TMP3\n+\n+    \/\/ Compare last byte of needle to haystack at proper position\n+    if (isU) {\n+      __ vpcmpeqw(cmp_k, byte_k, kThByte, Assembler::AVX_256bit);\n+    } else {\n+      __ vpcmpeqb(cmp_k, byte_k, kThByte, Assembler::AVX_256bit);\n+    }\n+\n+    __ vpand(result, cmp_k, cmp_0, Assembler::AVX_256bit);\n+\n+    if (bytesToCompare > 2) {\n+      if (size > (isU ? 4 : 2)) {\n+        if (doEarlyBailout) {\n+          __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n+          __ testl(eq_mask, eq_mask);\n+          __ je(noMatch);\n+        }\n+        if (isU) {\n+          __ vpcmpeqw(cmp_k, byte_1, Address(haystack, 2),\n+                      Assembler::AVX_256bit);\n+        } else {\n+          __ vpcmpeqb(cmp_k, byte_1, Address(haystack, 1),\n+                      Assembler::AVX_256bit);\n+        }\n+        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n+      }\n+    }\n+\n+    if (bytesToCompare > 3) {\n+      if (size > (isU ? 6 : 3)) {\n+        if (doEarlyBailout) {\n+          __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n+          __ testl(eq_mask, eq_mask);\n+          __ je(noMatch);\n+        }\n+        if (isU) {\n+          __ vpcmpeqw(cmp_k, byte_2, Address(haystack, 4),\n+                      Assembler::AVX_256bit);\n+        } else {\n+          __ vpcmpeqb(cmp_k, byte_2, Address(haystack, 2),\n+                      Assembler::AVX_256bit);\n+        }\n+        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n+      }\n+    }\n+\n+    __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n+  }\n+\n+  __ bind(L_done);\n+  __ testl(eq_mask, eq_mask);\n+  __ je(noMatch);\n+  \/\/ At this point, we have at least one \"match\" where first and last bytes\n+  \/\/ of the needle are found the correct distance apart.\n+#undef byte_0\n+#undef byte_k\n+#undef byte_1\n+#undef byte_2\n+#undef cmp_0\n+#undef cmp_k\n+#undef result\n+#undef lastCompare\n+#undef lastMask\n+#undef saveRCX\n+}\n+\n+\/\/ Helper for comparing needle elements to a small haystack\n+\/\/\n+\/\/ This helper compares bytes or words in the ymm registers to\n+\/\/ the proper positions within the haystack.  It will bail out early if\n+\/\/ doEarlyBailout is true, otherwise it will progressively and together\n+\/\/ the comparison results, returning the answer at the end.\n+\/\/\n+\/\/ On return, eq_mask will be set to the comparison mask value.  If no match\n+\/\/ is found, this helper will jump to noMatch.\n+\/\/\n+\/\/ Parameters:\n+\/\/ sizeKnown - if true, size is valid and needleLen invalid.\n+\/\/             if false, size invalid and needleLen valid.\n+\/\/ size - the size of the needle.  Pass 0 if unknown at compile time\n+\/\/ bytesToCompare - see NUMBER_OF_NEEDLE_BYTES_TO_COMPARE above\n+\/\/ noMatch - label bound outside to jump to if there is no match\n+\/\/ haystack - the address of the first byte of the haystack\n+\/\/ isU - true if argument encoding is either UU or UL\n+\/\/ doEarlyBailout - if true, check mismatch after every comparison\n+\/\/ eq_mask - The bit mask returned that holds the result of the comparison\n+\/\/ needleLen - a temporary register.  Only used if isUL true\n+\/\/ _masm - Current MacroAssembler instance pointer\n+\/\/\n+\/\/ No need to worry about reading past end of haystack since haystack\n+\/\/ has been copied to the stack\n+\/\/\n+\/\/ If !sizeKnown, needle is at least 11 bytes long\n+static void compare_haystack_to_needle(bool sizeKnown, int size,\n+                                       int bytesToCompare, Label& noMatch,\n+                                       Register haystack, bool isU,\n+                                       bool doEarlyBailout, Register eq_mask,\n+                                       Register needleLen, Register rTmp,\n+                                       MacroAssembler* _masm) {\n+\n+  assert_different_registers(eq_mask, haystack, needleLen, rTmp, r10);\n+\n+#undef byte_0\n+#define byte_0 XMM_BYTE_0\n+#undef byte_k\n+#define byte_k XMM_BYTE_K\n+#undef byte_1\n+#define byte_1 XMM_BYTE_1\n+#undef byte_2\n+#define byte_2 XMM_BYTE_2\n+#undef cmp_0\n+#define cmp_0 XMM_TMP3\n+#undef cmp_k\n+#define cmp_k XMM_TMP4\n+#undef result\n+#define result XMM_TMP3\n+\n+  int sizeIncr = isU ? 2 : 1;\n+\n+  assert((!sizeKnown) || (((size > 0) && (size <= NUMBER_OF_CASES))),\n+         \"Incorrect size given\");\n+\n+  Address kThByte =\n+      sizeKnown ? Address(haystack, size - sizeIncr)\n+                : Address(haystack, needleLen, Address::times_1, -(sizeIncr));\n+  size = sizeKnown ? size : NUMBER_OF_CASES + 1;\n+\n+  \/\/ Creates a mask of (n - k + 1) ones.  This prevents\n+  \/\/ recognizing any false-positives past the end of\n+  \/\/ the valid haystack.\n+  __ movq(rTmp, -1);\n+  __ movq(eq_mask, r10);   \/\/ Assumes r10 has n - k\n+  __ addq(eq_mask, 1);\n+  __ bzhiq(rTmp, rTmp, eq_mask);\n+\n+  \/\/ Compare first byte of needle to haystack\n+  if (isU) {\n+    __ vpcmpeqw(cmp_0, byte_0, Address(haystack, 0), Assembler::AVX_256bit);\n+  } else {\n+    __ vpcmpeqb(cmp_0, byte_0, Address(haystack, 0), Assembler::AVX_256bit);\n+  }\n+  if (size != (isU ? 2 : 1)) {\n+    \/\/ Compare last byte of needle to haystack at proper position\n+    if (isU) {\n+      __ vpcmpeqw(cmp_k, byte_k, kThByte, Assembler::AVX_256bit);\n+    } else {\n+      __ vpcmpeqb(cmp_k, byte_k, kThByte, Assembler::AVX_256bit);\n+    }\n+\n+    __ vpand(result, cmp_k, cmp_0, Assembler::AVX_256bit);\n+\n+    if (bytesToCompare > 2) {\n+      if (size > (isU ? 4 : 2)) {\n+        if (doEarlyBailout) {\n+          __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n+          __ andq(eq_mask, rTmp);\n+          __ testl(eq_mask, eq_mask);\n+          __ je(noMatch);\n+        }\n+        if (isU) {\n+          __ vpcmpeqw(cmp_k, byte_1, Address(haystack, 2),\n+                      Assembler::AVX_256bit);\n+        } else {\n+          __ vpcmpeqb(cmp_k, byte_1, Address(haystack, 1),\n+                      Assembler::AVX_256bit);\n+        }\n+        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n+      }\n+    }\n+\n+    if (bytesToCompare > 3) {\n+      if (size > (isU ? 6 : 3)) {\n+        if (doEarlyBailout) {\n+          __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n+          __ andq(eq_mask, rTmp);\n+          __ testl(eq_mask, eq_mask);\n+          __ je(noMatch);\n+        }\n+        if (isU) {\n+          __ vpcmpeqw(cmp_k, byte_2, Address(haystack, 4),\n+                      Assembler::AVX_256bit);\n+        } else {\n+          __ vpcmpeqb(cmp_k, byte_2, Address(haystack, 2),\n+                      Assembler::AVX_256bit);\n+        }\n+        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n+      }\n+    }\n+  }\n+\n+  __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n+  __ andq(eq_mask, rTmp);\n+\n+  __ testl(eq_mask, eq_mask);\n+  __ je(noMatch);\n+  \/\/ At this point, we have at least one \"match\" where first and last bytes\n+  \/\/ of the needle are found the correct distance apart.\n+#undef byte_0\n+#undef byte_k\n+#undef byte_1\n+#undef byte_2\n+#undef cmp_0\n+#undef cmp_k\n+#undef result\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Helper for big haystack loop construct\n+\/\/\n+\/\/ For UTF-16 encoded needles, broadcast a word at the proper offset to the ymm\n+\/\/ register (case UU)\n+\/\/ For the UTF-16 encoded haystack with Latin1 encoded needle (case UL) we have\n+\/\/ to read into a temp register to zero-extend the single byte needle value, then\n+\/\/ broadcast words to the ymm register.\n+\/\/\n+\/\/ Parameters:\n+\/\/ sizeKnown - if true, size is valid and needleLen invalid.\n+\/\/ size - the size of the needle.  Pass 0 if unknown at compile time\n+\/\/ noMatch - label bound outside to jump to if there is no match\n+\/\/ loop_top - label bound inside this helper that should be branched to\n+\/\/            for additional comparisons.\n+\/\/ eq_mask - The bit mask returned that holds the result of the comparison\n+\/\/ hsPtrRet - This will hold the place within the needle where a match is found\n+\/\/            This is modified\n+\/\/ needleLen - The length of the needle\n+\/\/ ae - Argument encoding\n+\/\/ _masm - Current MacroAssembler instance pointer\n+\/\/\n+\/\/ On entry:\n+\/\/\n+\/\/  rbx: haystack\n+\/\/  rcx: k\n+\/\/  rdx: junk\n+\/\/  rsi: n\n+\/\/  rdi: haystack\n+\/\/  r10: n - k\n+\/\/  r12: k\n+\/\/  r13: junk\n+\/\/  r14: needle\n+\/\/  rbp: -1\n+\/\/  XMM_BYTE_0 - first element of needle broadcast\n+\/\/  XMM_BYTE_K - last element of needle broadcast\n+\n+static void big_case_loop_helper(bool sizeKnown, int size, Label& noMatch,\n+                                 Label& loop_top, Register eq_mask,\n+                                 Register hsPtrRet, Register needleLen,\n+                                 StrIntrinsicNode::ArgEncoding ae,\n+                                 MacroAssembler* _masm) {\n+  Label temp;\n+\n+  assert_different_registers(eq_mask, hsPtrRet, needleLen, rdi, r15, rdx, rsi,\n+                             rbx, r14, r10);\n+\n+#undef needle\n+#define needle r14\n+#undef haystack\n+#define haystack rbx\n+#undef hsLength\n+#define hsLength rsi\n+#undef last\n+#define last rdi\n+#undef temp1\n+#define temp1 r15\n+#undef temp2\n+#define temp2 rdx\n+\n+  bool isLL = (ae == StrIntrinsicNode::LL);\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = isUL || isUU;  \/\/ At least one is UTF-16\n+\n+  assert_different_registers(eq_mask, hsPtrRet, needleLen, haystack, needle,\n+                             hsLength, last);\n+                            \/\/  hsLength, termAddr, last);\n+\n+  if (isU && (size & 1)) {\n+    __ emit_int8(0xcc);\n+    return;\n+  }\n+\n+  broadcast_additional_needles(sizeKnown, size,\n+                               NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, needle,\n+                               needleLen, temp1, isUU, isUL, _masm);\n+\n+  __ movq(r11, -1);\n+\n+  \/\/ Read 32-byte chunks at a time until the last 32-byte read would go\n+  \/\/ past the end of the haystack.  Then, set the final read to read exactly\n+  \/\/ the number of bytes in the haystack.\n+  \/\/ For example, if haystack length is 45 and needle length is 13, the compares\n+  \/\/ will read the following bytes:\n+  \/\/\n+  \/\/  First compare          Last compare\n+  \/\/   [  0 : 31]            [12 : 43]\n+  \/\/ Next compare will go past end of haystack ([32:63])\n+  \/\/ Adjust so final read is:\n+  \/\/   [  1 : 32]            [13 : 44]\n+\n+  __ movq(hsPtrRet, haystack);\n+  \/\/ Assume r10 is n - k\n+  __ leaq(last, Address(haystack, r10, Address::times_1, isU ? -30 : -31));\n+  __ jmpb(temp);\n+\n+  __ align(16);\n+  __ bind(loop_top);\n+  __ cmpq(hsPtrRet, last);\n+  __ je(noMatch);\n+  __ addq(hsPtrRet, 32);\n+\n+  __ cmpq(hsPtrRet, last);\n+  __ cmovq(Assembler::aboveEqual, hsPtrRet, last);\n+\n+  __ bind(temp);\n+\n+  \/\/ compare_big_haystack_to_needle will jump to loop_top until a match has been\n+  \/\/ found\n+  compare_big_haystack_to_needle(sizeKnown, size,\n+                                 NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, loop_top,\n+                                 hsPtrRet, hsLength, needleLen, isU,\n+                                 DO_EARLY_BAILOUT, eq_mask, temp2, r10, _masm);\n+\n+  \/\/ At this point, we have at least one \"match\" where first and last bytes\n+  \/\/ of the needle are found the correct distance apart.\n+  \/\/\n+  \/\/ NOTE: haystack (rbx) should be preserved; hsPtrRet(rcx) is expected to\n+  \/\/    point to the haystack such that hsPtrRet[tzcntl(eq_mask)] points to\n+  \/\/    the matched string.\n+\n+#undef needle\n+#undef haystack\n+#undef hsLength\n+#undef last\n+#undef temp1\n+#undef temp2\n+#undef savedNeedleLen\n+}\n+\n+static void preload_needle_helper(int size, Register needle, Register needleVal,\n+                                  StrIntrinsicNode::ArgEncoding ae,\n+                                  MacroAssembler* _masm) {\n+  \/\/ Pre-load the value (correctly sized) of the needle for comparison purposes.\n+\n+  assert_different_registers(needle, needleVal);\n+\n+  bool isLL = (ae == StrIntrinsicNode::LL);\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = isUL || isUU;  \/\/ At least one is UTF-16\n+\n+  int bytesAlreadyCompared = 0;\n+  int bytesLeftToCompare = 0;\n+  int offsetOfFirstByteToCompare = 0;\n+\n+  bytesAlreadyCompared = isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE * 2)\n+                             : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE;\n+  offsetOfFirstByteToCompare =\n+      isU ? ((NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2)\n+      : (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1);\n+\n+  bytesLeftToCompare = size - bytesAlreadyCompared;\n+  assert((bytesLeftToCompare <= 8), \"Too many bytes left to compare\");\n+\n+  if (bytesLeftToCompare <= 0) {\n+    return;\n+  }\n+\n+  \/\/ At this point, there is at least one byte of the needle that needs to be\n+  \/\/ compared to the haystack.\n+\n+  if (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 2) {\n+    switch (bytesLeftToCompare) {\n+      case 1:\n+      case 2:\n+        __ movzwl(needleVal, Address(needle, offsetOfFirstByteToCompare));\n+        break;\n+\n+      case 3:\n+      case 4:\n+        __ movl(needleVal, Address(needle, offsetOfFirstByteToCompare));\n+        break;\n+\n+      case 5:\n+        \/\/ Read one byte before start of needle, then mask it off\n+        __ movq(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n+        __ shrq(needleVal, 0x8);\n+        break;\n+\n+      case 6:\n+        __ movq(needleVal, Address(needle, (offsetOfFirstByteToCompare - 1)));\n+        break;\n+\n+      case 7:\n+      case 8:\n+        __ movq(needleVal, Address(needle, offsetOfFirstByteToCompare));\n+        break;\n+\n+      default:\n+        break;\n+    }\n+  }\n+\n+  if (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE >= 3) {\n+    switch (bytesLeftToCompare) {\n+      case 1:\n+      case 2:\n+        __ movl(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n+        break;\n+\n+      case 3:\n+      case 4:\n+        __ movl(needleVal, Address(needle, offsetOfFirstByteToCompare));\n+        break;\n+\n+      case 5:\n+      case 6:\n+        __ movq(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n+        break;\n+\n+      case 7:\n+      case 8:\n+        __ movq(needleVal, Address(needle, offsetOfFirstByteToCompare));\n+        break;\n+\n+      default:\n+        break;\n+    }\n+  }\n+}\n+\n+static void byte_compare_helper(int size, Label& L_noMatch, Label& L_matchFound,\n+                                Register needle, Register needleVal,\n+                                Register haystack, Register mask,\n+                                Register foundIndex, Register tmp,\n+                                StrIntrinsicNode::ArgEncoding ae,\n+                                MacroAssembler* _masm) {\n+  \/\/ Compare size bytes of needle to haystack\n+  \/\/\n+  \/\/ At a minimum, the first and last bytes of needle already compare equal\n+  \/\/ to the haystack, so there is no need to compare them again.\n+\n+  Label L_loopTop;\n+\n+  assert_different_registers(needle, needleVal, haystack, mask, foundIndex, tmp);\n+\n+  bool isLL = (ae == StrIntrinsicNode::LL);\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = isUL || isUU;  \/\/ At least one is UTF-16\n+\n+  int bytesAlreadyCompared = 0;\n+  int bytesLeftToCompare = 0;\n+  int offsetOfFirstByteToCompare = 0;\n+\n+  Label temp;\n+\n+  if (isU) {\n+    if ((size & 1) != 0) {\n+      __ emit_int8(0xcc);\n+      return;\n+    }\n+  }\n+\n+  bytesAlreadyCompared = isU ? NUMBER_OF_NEEDLE_BYTES_TO_COMPARE * 2\n+                             : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE;\n+  offsetOfFirstByteToCompare =\n+      isU ? ((NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2)\n+          : (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1);\n+\n+  bytesLeftToCompare = size - bytesAlreadyCompared;\n+  assert(bytesLeftToCompare <= 8, \"Too many bytes left to compare\");\n+\n+  if (bytesLeftToCompare <= 0) {\n+    __ tzcntl(foundIndex, mask);\n+    __ jmp(L_matchFound);\n+    return;\n+  }\n+\n+  \/\/ At this point, there is at least one byte of the needle that needs to be\n+  \/\/ compared to the haystack.\n+\n+  \/\/ Load in the correct sized needle value for comparison.  Used when checking\n+  \/\/ bytes of the haystack after first\/last have compared equal.\n+  preload_needle_helper(size, needle, needleVal, ae, _masm);\n+\n+  __ align(8);\n+  __ bind(L_loopTop);\n+  __ tzcntl(foundIndex, mask);  \/\/ Index of match within haystack\n+\n+  if (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 2) {\n+    switch (bytesLeftToCompare) {\n+      case 1:\n+      case 2:\n+        __ cmpw(Address(haystack, foundIndex, Address::times_1,\n+                        offsetOfFirstByteToCompare),\n+                needleVal);\n+        __ je(L_matchFound);\n+        break;\n+\n+      case 3:\n+      case 4:\n+        __ cmpl(Address(haystack, foundIndex, Address::times_1,\n+                        offsetOfFirstByteToCompare),\n+                needleVal);\n+        __ je(L_matchFound);\n+        break;\n+\n+      case 5:\n+        \/\/ Read one byte before start of haystack, then mask it off\n+        __ movq(tmp, Address(haystack, foundIndex, Address::times_1,\n+                             offsetOfFirstByteToCompare - 2));\n+        __ shrq(tmp, 0x08);\n+        __ cmpq(needleVal, tmp);\n+        __ je(L_matchFound);\n+        break;\n+\n+      case 6:\n+        __ cmpq(Address(haystack, foundIndex, Address::times_1,\n+                        offsetOfFirstByteToCompare - 1),\n+                needleVal);\n+        __ je(L_matchFound);\n+        break;\n+\n+      case 7:\n+      case 8:\n+        __ cmpq(Address(haystack, foundIndex, Address::times_1,\n+                        offsetOfFirstByteToCompare),\n+                needleVal);\n+        __ je(L_matchFound);\n+        break;\n+    }\n+  }\n+\n+  if (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE >= 3) {\n+    switch (bytesLeftToCompare) {\n+      case 1:\n+      case 2:\n+        __ cmpl(Address(haystack, foundIndex, Address::times_1,\n+                        offsetOfFirstByteToCompare - 2),\n+                needleVal);\n+        __ je(L_matchFound);\n+        break;\n+\n+      case 3:\n+      case 4:\n+        __ cmpl(Address(haystack, foundIndex, Address::times_1,\n+                        offsetOfFirstByteToCompare),\n+                needleVal);\n+        __ je(L_matchFound);\n+        break;\n+\n+      case 5:\n+      case 6:\n+        __ cmpq(Address(haystack, foundIndex, Address::times_1,\n+                        offsetOfFirstByteToCompare - 2),\n+                needleVal);\n+        __ je(L_matchFound);\n+        break;\n+\n+      case 7:\n+      case 8:\n+        __ cmpq(Address(haystack, foundIndex, Address::times_1,\n+                        offsetOfFirstByteToCompare),\n+                needleVal);\n+        __ je(L_matchFound);\n+        break;\n+    }\n+  }\n+\n+  CLEAR_BIT(mask, tmp); \/\/ Loop as long as there are other bits set\n+  __ jne(L_loopTop);\n+  __ jmp(L_noMatch);\n+}\n+\n+void StubGenerator::generate_string_indexof(address *fnptrs) {\n+  assert((int) StrIntrinsicNode::LL < 4, \"Enum out of range\");\n+  assert((int) StrIntrinsicNode::UL < 4, \"Enum out of range\");\n+  assert((int) StrIntrinsicNode::UU < 4, \"Enum out of range\");\n+  generate_string_indexof_stubs(fnptrs, StrIntrinsicNode::LL);\n+  generate_string_indexof_stubs(fnptrs, StrIntrinsicNode::UL);\n+  generate_string_indexof_stubs(fnptrs, StrIntrinsicNode::UU);\n+  assert(fnptrs[StrIntrinsicNode::LL] != nullptr, \"LL not generated.\");\n+  assert(fnptrs[StrIntrinsicNode::UL] != nullptr, \"UL not generated.\");\n+  assert(fnptrs[StrIntrinsicNode::UU] != nullptr, \"UU not generated.\");\n+}\n+\n+void StubGenerator::generate_string_indexof_stubs(address *fnptrs, StrIntrinsicNode::ArgEncoding ae) {\n+  StubCodeMark mark(this, \"StubRoutines\", \"stringIndexOf\");\n+  address large_hs_jmp_table[NUMBER_OF_CASES];  \/\/ Jump table for large haystacks\n+  address small_hs_jmp_table[NUMBER_OF_CASES];  \/\/ Jump table for small haystacks\n+  int jmp_ndx = 0;\n+  bool isLL = (ae == StrIntrinsicNode::LL);\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = isUL || isUU; \/\/ At least one is UTF-16\n+  assert(isLL || isUL || isUU, \"Encoding not recognized\");\n+\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/                         AVX2 code\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  if (VM_Version::supports_avx2()) {  \/\/ AVX2 version\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/                         Code generation explanation:\n+  \/\/\n+  \/\/  The generator will generate code for three cases:\n+  \/\/  1. Both needle and haystack are Latin-1 (single byte) encoded (LL)\n+  \/\/  2. Both the needle and haystack are UTF-16 encoded (two bytes per character) (UU)\n+  \/\/  3. The haystack is UTF-16 encoded and the needle is Latin-1 encoded (UL)\n+  \/\/\n+  \/\/  The case of the haystack being Latin-1 and the needle being UTF-16 is short-circuited\n+  \/\/  so that we never get called in this case.\n+  \/\/\n+  \/\/  For the UL case (haystack UTF-16 and needle Latin-1), the needle will be expanded\n+  \/\/  onto the stack (for size <= MAX_NEEDLE_LEN_TO_EXPAND) and the UU code will do the work.\n+  \/\/  For UL where the needle size is > MAX_NEEDLE_LEN_TO_EXPAND, we default to a\n+  \/\/  byte-by-byte comparison (this will be rare).\n+  \/\/\n+  \/\/  Note that the code assumes MAX_NEEDLE_LEN_TO_EXPAND is >= 32.\n+  \/\/\n+  \/\/  The UU and LL cases are identical except for the loop increments and loading\n+  \/\/  of the characters into registers.  UU loads and compares words, LL - bytes.\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    const Register haystack     = rdi;\n+    const Register haystack_len = rsi;\n+    const Register needle       = rdx;\n+    const Register needle_len   = rcx;\n+\n+    const Register save_ndl_len = r12;\n+\n+    const XMMRegister byte_0    = XMM_BYTE_0;\n+    const XMMRegister byte_k    = XMM_BYTE_K;\n+    const XMMRegister byte_1    = XMM_BYTE_1;\n+    const XMMRegister byte_2    = XMM_BYTE_2;\n+    const XMMRegister xmm_tmp1  = XMM_TMP1;\n+    const XMMRegister xmm_tmp2  = XMM_TMP2;\n+    const XMMRegister xmm_tmp3  = XMM_TMP3;\n+    const XMMRegister xmm_tmp4  = XMM_TMP4;\n+\n+    const XMMRegister save_r12  = xmm4;\n+    const XMMRegister save_r13  = xmm5;\n+    const XMMRegister save_r14  = xmm6;\n+    const XMMRegister save_r15  = xmm7;\n+    const XMMRegister save_rbx  = xmm8;\n+    \/\/ xmm registers more valuable in inner loops...\n+    \/\/ const XMMRegister save_rsi  = xmm9;\n+    \/\/ const XMMRegister save_rdi  = xmm10;\n+    \/\/ const XMMRegister save_rcx  = xmm11;\n+    \/\/ const XMMRegister save_r8   = xmm12;\n+    \/\/ const XMMRegister save_r9   = xmm13;\n+    Label L_begin;\n+\n+    Label L_returnRBP, L_checkRangeAndReturn, L_returnError;\n+    Label L_bigCaseFixupAndReturn, L_checkRangeAndReturnRCX;\n+    Label L_returnZero, L_copyHaystackToStackDone, L_bigSwitchTop;\n+    Label L_bigCaseDefault, L_smallCaseDefault, L_copyHaystackToStack, L_smallSwitchTop;\n+    Label L_nextCheck, L_checksPassed, L_zeroCheckFailed;\n+\n+    Label L_wcharBegin, L_continue, L_wideNoExpand, L_copyDone, L_copyHigh;\n+    Label L_wideMidLoop, L_wideTopLoop, L_wideInnerLoop, L_wideFound;\n+\n+    address jump_table;\n+    address jump_table_1;\n+\n+    \/\/ Jump past jump table setups to get addresses of cases.\n+\n+    __ align(CodeEntryAlignment);\n+    fnptrs[isLL   ? StrIntrinsicNode::LL\n+           : isUU ? StrIntrinsicNode::UU\n+                  : StrIntrinsicNode::UL] =\n+        __ pc();\n+    __ enter();  \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+    \/\/ Check for trivial cases\n+    __ cmpq(needle_len, 0);\n+    __ jg_b(L_nextCheck);\n+    __ xorq(rax, rax);\n+    __ leave();\n+    __ ret(0);\n+\n+    __ bind(L_nextCheck);\n+    __ testq(haystack_len, haystack_len);\n+    __ je(L_zeroCheckFailed);\n+\n+    __ movq(rax, haystack_len);\n+    __ subq(rax, needle_len);\n+    __ jge_b(L_checksPassed);\n+\n+    __ bind(L_zeroCheckFailed);\n+    __ movq(rax, -1);\n+    __ leave();\n+    __ ret(0);\n+\n+    __ bind(L_checksPassed);\n+\n+    \/\/ Highly optimized special-cases\n+    {\n+      Label L_noMatch, L_foundall, L_out;\n+\n+      \/\/ Only optimize when haystack can fit on stack with room\n+      \/\/ left over for page fault prevention\n+      assert((COPIED_HAYSTACK_STACK_OFFSET == 0), \"Must be zero!\");\n+      assert((COPIED_HAYSTACK_STACK_SIZE == 64), \"Must be 64!\");\n+\n+      \/\/ haystack_len is in elements, not bytes, for UTF-16\n+      __ cmpq(haystack_len, isU ? COPIED_HAYSTACK_STACK_SIZE \/ 4\n+                                : COPIED_HAYSTACK_STACK_SIZE \/ 2);\n+      __ ja(L_begin);\n+\n+      \/\/ needle_len is in elements, not bytes, for UTF-16\n+      __ cmpq(needle_len, isUU ? OPT_NEEDLE_SIZE_MAX \/ 2 : OPT_NEEDLE_SIZE_MAX);\n+      __ ja(L_begin);\n+\n+      \/\/ Copy incoming haystack onto stack\n+      {\n+        Label L_adjustHaystack, L_moreThan16;\n+\n+        \/\/ Copy haystack to stack (haystack <= 32 bytes)\n+        __ subptr(rsp, COPIED_HAYSTACK_STACK_SIZE);\n+        __ cmpq(haystack_len, isU ? 0x8 : 0x10);\n+        __ ja_b(L_moreThan16);\n+\n+        __ movq(r8, COPIED_HAYSTACK_STACK_OFFSET + 0x10);\n+        __ movdqu(xmm0,\n+                  Address(haystack, haystack_len,\n+                          isU ? Address::times_2 : Address::times_1, -0x10));\n+        __ movdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), xmm0);\n+        __ jmpb(L_adjustHaystack);\n+\n+        __ bind(L_moreThan16);\n+        __ movq(r8, COPIED_HAYSTACK_STACK_OFFSET + 0x20);\n+        __ vmovdqu(xmm0,\n+                   Address(haystack, haystack_len,\n+                           isU ? Address::times_2 : Address::times_1, -0x20));\n+        __ vmovdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), xmm0);\n+\n+        __ bind(L_adjustHaystack);\n+        __ subq(r8, haystack_len);\n+        if (isU) {\n+          \/\/ For UTF-16, lengths are half\n+          __ subq(r8, haystack_len);\n+        }\n+        __ leaq(haystack, Address(rsp, r8, Address::times_1));\n+      }\n+\n+      \/\/ Creates a mask of (n - k + 1) ones.  This prevents\n+      \/\/ recognizing any false-positives past the end of\n+      \/\/ the valid haystack.\n+      __ movq(r8, -1);\n+      __ subq(haystack_len, needle_len);\n+      __ incq(haystack_len);\n+      if (isU) {\n+        __ shlq(haystack_len, 1);\n+      }\n+      __ bzhiq(r8, r8, haystack_len);\n+\n+      for (int size = 1; size <= OPT_NEEDLE_SIZE_MAX; size++) {\n+        \/\/ Broadcast next needle byte into ymm register\n+        int position = isUU ? (size - 1) * 2 : size - 1;\n+        if (isUU) {\n+          __ vpbroadcastw(xmm0, Address(needle, position),\n+                          Assembler::AVX_256bit);\n+        } else if (isUL) {\n+          \/\/ Expand needle\n+          __ movzbl(rax, Address(needle, position));\n+          __ movdl(xmm0, rax);\n+          \/\/ Byte of needle to words\n+          __ vpbroadcastw(xmm0, xmm0, Assembler::AVX_256bit);\n+        } else {\n+          __ vpbroadcastb(xmm0, Address(needle, position),\n+                          Assembler::AVX_256bit);\n+        }\n+\n+        \/\/ Compare next byte.  Keep the comparison mask in r8, which will\n+        \/\/ accumulate\n+        if (isU) {\n+          __ vpcmpeqw(xmm1, xmm0, Address(haystack, position),\n+                      Assembler::AVX_256bit);\n+        } else {\n+          __ vpcmpeqb(xmm1, xmm0, Address(haystack, position),\n+                      Assembler::AVX_256bit);\n+        }\n+        __ vpmovmskb(r9, xmm1, Assembler::AVX_256bit);\n+        __ andq(r8, r9);  \/\/ Accumulate matched bytes\n+        __ testl(r8, r8);\n+        __ je(L_noMatch);\n+\n+        if (size != OPT_NEEDLE_SIZE_MAX) {\n+          \/\/ Found a match for this needle size\n+          __ cmpq(needle_len, size);\n+          __ je(L_foundall);\n+        }\n+      }\n+\n+      __ bind(L_foundall);\n+      __ tzcntl(rax, r8);\n+      if (isU) {\n+        __ shrq(rax, 1);\n+      }\n+\n+      __ bind(L_out);\n+      __ addptr(rsp, COPIED_HAYSTACK_STACK_SIZE);\n+      __ vzeroupper();\n+      __ leave();\n+      __ ret(0);\n+\n+      __ bind(L_noMatch);\n+      __ movq(rax, -1);\n+      __ jmpb(L_out);\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\n+    \/\/ Set up jump table entries for both small and large haystack switches.\n+\n+    {\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\n+      \/\/ Small haystack (<32 bytes) switch\n+\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/  On entry to each case of small_hs, the register state is:\n+      \/\/\n+      \/\/  rax = unused\n+      \/\/  rbx = &haystack\n+      \/\/  rcx = haystack length\n+      \/\/  rdx = &needle\n+      \/\/  rsi = haystack length\n+      \/\/  rdi = &haystack\n+      \/\/  rbp = -1\n+      \/\/  r8  = unused\n+      \/\/  r9  = unused\n+      \/\/  r10 = hs_len - needle len\n+      \/\/  r11 = unused\n+      \/\/  r12 = needle length\n+      \/\/  r13 = (needle length - 1)\n+      \/\/  r14 = &needle\n+      \/\/  r15 = unused\n+      \/\/  XMM_BYTE_0 - first element of needle, broadcast\n+      \/\/  XMM_BYTE_K - last element of needle, broadcast\n+      \/\/\n+      \/\/  The haystack is < 32 bytes\n+      \/\/\n+      \/\/ If a match is not found, branch to L_returnRBP (which will always\n+      \/\/ return -1).\n+      \/\/\n+      \/\/ If a match is found, jump to L_checkRangeAndReturn, which ensures the\n+      \/\/ matched needle is not past the end of the haystack.\n+\n+#undef haystack\n+#define haystack rbx\n+#undef needle\n+#define needle r14\n+#undef needle_val\n+#define needle_val r8\n+#undef set_bit\n+#define set_bit r11\n+#undef eq_mask\n+#define eq_mask rsi\n+#undef rTmp\n+#define rTmp rax\n+\n+      for (int i = OPT_NEEDLE_SIZE_MAX; i < NUMBER_OF_CASES; i++) {\n+        small_hs_jmp_table[i] = __ pc();\n+        if (isU && ((i + 1) & 1)) {\n+          __ emit_int8(0xcc);\n+        } else {\n+          Label L_loopTop;\n+\n+          broadcast_additional_needles(true, i + 1,\n+                                       NUMBER_OF_NEEDLE_BYTES_TO_COMPARE,\n+                                       needle, noreg, rTmp, isUU, isUL, _masm);\n+\n+          compare_haystack_to_needle(true, i + 1, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE,\n+                                     L_returnRBP, haystack, isU, DO_EARLY_BAILOUT,\n+                                     eq_mask, noreg, rTmp, _masm);\n+\n+          \/\/ small_case_helper(i + 1, L_returnRBP, ae, _masm);\n+          byte_compare_helper(i + 1, L_returnRBP, L_checkRangeAndReturn, needle,\n+                              needle_val, haystack, eq_mask, set_bit, rTmp, ae,\n+                              _masm);\n+        }\n+      }\n+\n+#undef haystack\n+#undef needle\n+#undef needle_val\n+#undef set_bit\n+#undef eq_mask\n+#undef rTmp\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\n+    \/\/ Large haystack (>=32 bytes) switch\n+\n+    {\n+\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/  On entry to each case of large_hs, the register state is:\n+      \/\/\n+      \/\/  rax = unused\n+      \/\/  rbx = &haystack\n+      \/\/  rcx = haystack length\n+      \/\/  rdx = &needle\n+      \/\/  rsi = haystack length\n+      \/\/  rdi = &haystack\n+      \/\/  rbp = -1\n+      \/\/  r8  = unused\n+      \/\/  r9  = unused\n+      \/\/  r10 = hs_len - needle len\n+      \/\/  r11 = unused\n+      \/\/  r12 = needle length\n+      \/\/  r13 = (needle length - 1)\n+      \/\/  r14 = &needle\n+      \/\/  r15 = unused\n+      \/\/  XMM_BYTE_0 - first element of needle, broadcast\n+      \/\/  XMM_BYTE_K - last element of needle, broadcast\n+      \/\/\n+      \/\/  The haystack is >= 32 bytes\n+\n+#undef haystack\n+#define haystack rbx\n+#undef needle\n+#define needle r14\n+#undef needleLen\n+#define needleLen r12\n+#undef needle_val\n+#define needle_val r15\n+#undef set_bit\n+#define set_bit r8\n+#undef eq_mask\n+#define eq_mask r9\n+#undef rTmp\n+#define rTmp r13\n+#undef hs_ptr\n+#define hs_ptr rcx\n+\n+      for (int i = 0; i < NUMBER_OF_CASES; i++) {\n+        large_hs_jmp_table[i] = __ pc();\n+        if (isU && ((i + 1) & 1)) {\n+          __ emit_int8(0xcc);\n+        } else {\n+          Label L_loopTop;\n+\n+          big_case_loop_helper(true, i + 1, L_checkRangeAndReturn, L_loopTop,\n+                               eq_mask, hs_ptr, needleLen, ae, _masm);\n+          byte_compare_helper(i + 1, L_loopTop, L_bigCaseFixupAndReturn, needle,\n+                              needle_val, hs_ptr, eq_mask, set_bit, rTmp, ae,\n+                              _masm);\n+        }\n+      }\n+\n+#undef haystack\n+#undef needle\n+#undef needle_val\n+#undef set_bit\n+#undef eq_mask\n+#undef rTmp\n+#undef hs_ptr\n+#undef needleLen\n+    }\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/ JUMP TABLES\n+    __ align(8);\n+\n+    jump_table = __ pc();\n+\n+    for (jmp_ndx = 0; jmp_ndx < NUMBER_OF_CASES; jmp_ndx++) {\n+      __ emit_address(large_hs_jmp_table[jmp_ndx]);\n+    }\n+\n+    jump_table_1 = __ pc();\n+\n+    for (jmp_ndx = 0; jmp_ndx < NUMBER_OF_CASES; jmp_ndx++) {\n+      __ emit_address(small_hs_jmp_table[jmp_ndx]);\n+    }\n+\n+    __ align(CodeEntryAlignment);\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\n+    \/\/ Big case default:\n+\n+    {\n+      Label L_loopTop, L_innerLoop, L_found;\n+\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\n+      \/\/ Big case default:\n+      \/\/\n+      \/\/  rbx: haystack\n+      \/\/  rcx: k\n+      \/\/  rdx: junk\n+      \/\/  rsi: n\n+      \/\/  rdi: haystack\n+      \/\/  r10: n - k\n+      \/\/  r12: k\n+      \/\/  r13: junk\n+      \/\/  r14: needle\n+      \/\/  rbp: -1\n+      \/\/  XMM_BYTE_0 - first element of needle broadcast\n+      \/\/  XMM_BYTE_K - last element of needle broadcast\n+\n+      __ bind(L_bigCaseDefault);\n+\n+#undef hsPtrRet\n+#define hsPtrRet rax\n+#undef mask\n+#define mask r8\n+#undef index\n+#define index r9\n+#undef firstNeedleCompare\n+#define firstNeedleCompare rdx\n+#undef compLen\n+#define compLen rbp\n+#undef haystackStart\n+#define haystackStart rcx\n+#undef rScratch\n+#define rScratch r13   \/\/ Can't use r11 here...\n+#undef needleLen\n+#define needleLen r12\n+#undef needle\n+#define needle r14\n+#undef haystack\n+#define haystack rbx\n+#undef retval\n+#define retval r15\n+        big_case_loop_helper(false, 0, L_checkRangeAndReturn, L_loopTop, mask,\n+                             hsPtrRet, needleLen, ae, _masm);\n+\n+\n+      __ align(8);\n+      __ bind(L_innerLoop);\n+      __ tzcntl(index, mask);\n+\n+      __ leaq(haystackStart,\n+              Address(hsPtrRet, index, Address::times_1,\n+                      isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2\n+                          : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n+      __ leaq(firstNeedleCompare,\n+              Address(needle, isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2\n+                                  : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n+      __ leaq(compLen,\n+              Address(needleLen,\n+                      isU ? -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE * 2)\n+                          : -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE)));  \/\/ nlen - 2\n+                                                                     \/\/ elements\n+      __ arrays_equals(false, haystackStart, firstNeedleCompare, compLen,\n+                       retval, rScratch, xmm_tmp3, xmm_tmp4, false \/* char *\/,\n+                       knoreg);\n+      __ testl(retval, retval);\n+      __ jne_b(L_found);\n+\n+      CLEAR_BIT(mask, index);\n+      __ jne(L_innerLoop);\n+      __ jmp(L_loopTop);\n+\n+      __ bind(L_found);\n+      __ subq(hsPtrRet, haystack);\n+      __ addq(hsPtrRet, index);\n+      __ movq(r11, hsPtrRet);\n+      __ jmp(L_checkRangeAndReturn);\n+\n+\n+#undef hsPtrRet\n+#undef mask\n+#undef index\n+#undef firstNeedleCompare\n+#undef compLen\n+#undef haystackStart\n+#undef rScratch\n+#undef needleLen\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\n+    \/\/ Small case default:\n+    \/\/\n+    \/\/  rbx: haystack\n+    \/\/  r14: needle\n+    \/\/  r13: k - 1\n+    \/\/  r12: k\n+    \/\/  r10: n - k\n+    \/\/  rbp: -1\n+    \/\/  rdi: junk\n+    \/\/  rsi: n\n+    \/\/  rdx: junk\n+    \/\/  rcx: junk\n+    \/\/  XMM_BYTE_0 - first element of needle broadcast\n+    \/\/  XMM_BYTE_K - last element of needle broadcast\n+    \/\/\n+    \/\/  Haystack always copied to stack, so 32-byte reads OK\n+    \/\/  Haystack length < 32\n+    \/\/  10 < needle length < 32\n+\n+    {\n+      __ bind(L_smallCaseDefault);\n+\n+      Label L_innerLoop;\n+\n+#undef needle\n+#define needle r14\n+#undef needleLen\n+#define needleLen r12\n+#undef firstNeedleCompare\n+#define firstNeedleCompare rdx\n+#undef compLen\n+#define compLen r9\n+#undef haystack\n+#define haystack rbx\n+#undef mask\n+#define mask r8\n+#undef rTmp\n+#define rTmp rdi\n+#undef rTmp2\n+#define rTmp2 r13\n+#undef rTmp3\n+#define rTmp3 rax\n+\n+#undef cmp_0\n+#define cmp_0 XMM_TMP3\n+#undef cmp_k\n+#define cmp_k XMM_TMP4\n+#undef result\n+#define result XMM_TMP3\n+      broadcast_additional_needles(false, 0 \/* unknown *\/,\n+                                   NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, needle,\n+                                   needleLen, rTmp3, isUU, isUL, _masm);\n+\n+      assert(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 4, \"Invalid\");\n+      assert(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE >= 2, \"Invalid\");\n+      __ leaq(firstNeedleCompare,\n+              Address(needle, isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2\n+                                  : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n+      __ leaq(compLen,\n+              Address(needleLen,\n+                      isU ? -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE * 2)\n+                          : -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE)));  \/\/ nlen - 2\n+                                                                     \/\/ elements\n+      \/\/  firstNeedleCompare has address of second element of needle\n+      \/\/  compLen has length of comparison to do\n+\n+      compare_haystack_to_needle(false, 0, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE,\n+                                L_returnRBP, haystack, isU, DO_EARLY_BAILOUT,\n+                                mask, needleLen, rTmp3, _masm);\n+\n+#undef needle\n+#undef saveCompLen\n+#define saveCompLen r14\n+#undef needleLen\n+#undef saveNeedleAddress\n+#define saveNeedleAddress r12\n+      __ movq(saveCompLen, compLen);\n+      __ movq(saveNeedleAddress, firstNeedleCompare);  \/\/ Save address of 2nd element of needle\n+\n+      __ align(8);\n+      __ bind(L_innerLoop);\n+      __ tzcntl(r11, mask);\n+\n+      __ leaq(rTmp, Address(haystack, r11, Address::times_1,\n+                            isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2\n+                                : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n+\n+      __ arrays_equals(false, rTmp, firstNeedleCompare, compLen, rTmp3, rTmp2, xmm_tmp3, xmm_tmp4,\n+                       false \/* char *\/, knoreg);\n+      __ testl(rTmp3, rTmp3);\n+      __ jne_b(L_checkRangeAndReturn);\n+\n+      __ movq(compLen, saveCompLen);\n+      __ movq(firstNeedleCompare, saveNeedleAddress);\n+      CLEAR_BIT(mask, rTmp3);\n+      __ jne(L_innerLoop);\n+      __ jmp(L_returnRBP);\n+\n+#undef needle\n+#undef needleLen\n+#undef firstNeedleCompare\n+#undef compLen\n+#undef haystack\n+#undef mask\n+#undef rTmp\n+#undef rTmp2\n+#undef rTmp3\n+#undef cmp_0\n+#undef cmp_k\n+#undef result\n+#undef saveCompLen\n+#undef saveNeedleAddress\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    __ bind(L_returnError);\n+    __ movq(rbp, -1);\n+    __ jmpb(L_returnRBP);\n+\n+    __ bind(L_returnZero);\n+    __ xorl(rbp, rbp);\n+    __ jmpb(L_returnRBP);\n+\n+    __ bind(L_bigCaseFixupAndReturn);\n+    __ movl(rax, r8);\n+    __ subq(rcx, rbx);\n+    __ addq(rcx, rax);\n+\n+    __ bind(L_checkRangeAndReturnRCX);\n+    __ movq(r11, rcx);\n+\n+    __ bind(L_checkRangeAndReturn);\n+    __ cmpq(r11, r10);\n+    __ movq(rbp, -1);\n+    __ cmovq(Assembler::belowEqual, rbp, r11);\n+\n+    __ bind(L_returnRBP);\n+    __ movq(rax, rbp);\n+    __ addptr(rsp, STACK_SPACE);\n+    __ pop(rbp);\n+#ifdef _WIN64\n+    __ pop(r9);\n+    __ pop(r8);\n+    __ pop(rcx);\n+    __ pop(rdi);\n+    __ pop(rsi);\n+#endif\n+#ifdef PUSH_REGS\n+    __ pop(rbx);\n+    __ pop(r12);\n+    __ pop(r13);\n+    __ pop(r14);\n+    __ pop(r15);\n+#else\n+    __ movdq(r12, save_r12);\n+    __ movdq(r13, save_r13);\n+    __ movdq(r14, save_r14);\n+    __ movdq(r15, save_r15);\n+    __ movdq(rbx, save_rbx);\n+#endif\n+    if (isU) {\n+      __ sarq(rax, 1);\n+    }\n+    __ vzeroupper();\n+\n+    __ leave();  \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ ret(0);\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    __ bind(L_begin);\n+#ifdef PUSH_REGS\n+    __ push(r15);\n+    __ push(r14);\n+    __ push(r13);\n+    __ push(r12);\n+    __ push(rbx);\n+#else\n+    __ movdq(save_r12, r12);\n+    __ movdq(save_r13, r13);\n+    __ movdq(save_r14, r14);\n+    __ movdq(save_r15, r15);\n+    __ movdq(save_rbx, rbx);\n+#endif\n+#ifdef _WIN64\n+    __ push(rsi);\n+    __ push(rdi);\n+    __ push(rcx);\n+    __ push(r8);\n+    __ push(r9);\n+\n+    __ movq(rdi, rcx);\n+    __ movq(rsi, rdx);\n+    __ movq(rdx, r8);\n+    __ movq(rcx, r9);\n+#endif\n+\n+    __ push(rbp);\n+    __ subptr(rsp, STACK_SPACE);\n+\n+    __ movq(rbp, -1);\n+\n+    if (isUL) {\n+      \/\/ Branch out if doing wide chars\n+      __ jmp(L_wcharBegin);\n+    }\n+\n+    if (isUU) {  \/\/ Adjust sizes of hs and needle\n+      __ shlq(needle_len, 1);\n+      __ shlq(haystack_len, 1);\n+    }\n+\n+    \/\/ wide char processing comes here after expanding needle\n+    __ bind(L_continue);\n+    __ movq(r10, haystack_len);\n+    __ subq(r10, needle_len);\n+\n+    __ movq(save_ndl_len, needle_len);\n+    __ movq(r14, needle);\n+    __ movq(rbx, haystack);\n+\n+    {\n+      Label L_short;\n+\n+      \/\/ Always need needle broadcast to ymm registers\n+      if (isU) {\n+        __ vpbroadcastw(byte_0, Address(needle, 0), Assembler::AVX_256bit);\n+      } else {\n+        __ vpbroadcastb(byte_0, Address(needle, 0), Assembler::AVX_256bit);\n+      }\n+\n+      __ cmpq(needle_len, isU ? 2 : 1);\n+      __ je_b(L_short);\n+\n+      if (isU) {\n+        __ vpbroadcastw(byte_k, Address(needle, needle_len, Address::times_1, -2),\n+                        Assembler::AVX_256bit);\n+      } else {\n+        __ vpbroadcastb(byte_k, Address(needle, needle_len, Address::times_1, -1),\n+                        Assembler::AVX_256bit);\n+      }\n+\n+      __ bind(L_short);\n+    }\n+\n+    __ cmpq(haystack_len, 0x20);\n+    __ jae_b(L_bigSwitchTop);\n+\n+    {\n+      Label L_moreThan16, L_adjustHaystack;\n+\n+      const Register index = rax;\n+      const Register haystack = rbx;\n+\n+      __ bind(L_copyHaystackToStack);\n+      __ cmpq(haystack_len, 0x10);\n+      __ ja_b(L_moreThan16);\n+\n+      __ movq(index, COPIED_HAYSTACK_STACK_OFFSET + 0x10);\n+      __ movdqu(xmm_tmp1, Address(haystack, haystack_len, Address::times_1, -0x10));\n+      __ movdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), xmm_tmp1);\n+      __ jmpb(L_adjustHaystack);\n+\n+      __ bind(L_moreThan16);\n+      __ movq(index, COPIED_HAYSTACK_STACK_OFFSET + 0x20);\n+      __ vmovdqu(xmm_tmp1, Address(haystack, haystack_len, Address::times_1, -0x20));\n+      __ vmovdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), xmm_tmp1);\n+\n+      __ bind(L_adjustHaystack);\n+      __ subq(index, haystack_len);\n+      __ leaq(haystack, Address(rsp, index, Address::times_1));\n+    }\n+\n+    __ bind(L_smallSwitchTop);\n+    __ leaq(r13, Address(save_ndl_len, -1));\n+    __ cmpq(r13, NUMBER_OF_CASES - 1);\n+    __ ja(L_smallCaseDefault);\n+    __ mov64(r15, (int64_t)jump_table_1);\n+    __ jmp(Address(r15, r13, Address::times_8));\n+\n+    __ bind(L_bigSwitchTop);\n+    __ leaq(rax, Address(save_ndl_len, -1));\n+    __ cmpq(rax, NUMBER_OF_CASES - 1);\n+    __ ja(L_bigCaseDefault);\n+    __ mov64(r15, (int64_t)jump_table);\n+    __ jmp(Address(r15, rax, Address::times_8));\n+\n+    if (isUL) {\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/                         Wide char code\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\n+      \/\/ Pseudo-code:\n+      \/\/\n+      \/\/ If needle length less than MAX_NEEDLE_LEN_TO_EXPAND, read the needle\n+      \/\/ bytes from r14 and write them as words onto the stack.  Then go to the\n+      \/\/ \"regular\" code.  This is equavilent to doing a UU comparison, since the\n+      \/\/ haystack will be in UTF-16.\n+      \/\/\n+      \/\/ If the needle can't be expanded, process the same way as the default\n+      \/\/ cases above. That is, for each haystack chunk, compare the needle.\n+      __ bind(L_wcharBegin);\n+\n+      Label L_top, L_finished;\n+\n+      const Register haystack = rdi;\n+      const Register hsLen = rsi;\n+      const Register needle = rdx;\n+      const Register nLen = rcx;\n+\n+      const Register offset = rax;\n+      const Register index = rbx;\n+      const Register wr_index = r13;\n+\n+      assert(MAX_NEEDLE_LEN_TO_EXPAND >= 32, \"Small UL needles not supported\");\n+\n+      __ shlq(hsLen, 1);\n+\n+      \/\/ __ movq(r14, hsLen);\n+      __ leaq(index, Address(nLen, nLen, Address::times_1));\n+      __ cmpq(index, hsLen);\n+      __ jg(L_returnRBP);\n+\n+      __ cmpq(nLen, MAX_NEEDLE_LEN_TO_EXPAND);\n+      __ ja(L_wideNoExpand);\n+\n+      \/\/\n+      \/\/ Reads of existing needle are 16-byte chunks\n+      \/\/ Writes to copied needle are 32-byte chunks\n+      \/\/ Don't read past the end of the existing needle\n+      \/\/\n+      \/\/ Start first read at [((ndlLen % 16) - 16) & 0xf]\n+      \/\/ outndx += 32\n+      \/\/ inndx += 16\n+      \/\/ cmp nndx, ndlLen\n+      \/\/ jae done\n+      \/\/\n+      \/\/ Final index of start of needle @((16 - (ndlLen %16)) & 0xf) << 1\n+      \/\/\n+      \/\/ Starting read for needle at -(16 - (nLen % 16))\n+      \/\/ Offset of needle in stack should be (16 - (nLen % 16)) * 2\n+\n+      __ movq(index, needle_len);\n+      __ andq(index, 0xf);    \/\/ nLen % 16\n+      __ movq(offset, 0x10);\n+      __ subq(offset, index); \/\/ 16 - (nLen % 16)\n+      __ movq(index, offset);\n+      __ shlq(offset, 1); \/\/ * 2\n+      __ negq(index);   \/\/ -(16 - (nLen % 16))\n+      __ xorq(wr_index, wr_index);\n+\n+      __ bind(L_top);\n+      __ vpmovzxbw(xmm0, Address(needle, index, Address::times_1),\n+                   Assembler::AVX_256bit);  \/\/ load needle[low-16]\n+      __ vmovdqu(Address(rsp, wr_index, Address::times_1,\n+                         EXPANDED_NEEDLE_STACK_OFFSET),\n+                        xmm0);  \/\/ store to stack\n+      __ addq(index, 0x10);\n+      __ cmpq(index, needle_len);\n+      __ jae(L_finished);\n+      __ addq(wr_index, 32);\n+      __ jmpb(L_top);\n+\n+      __ bind(L_finished);\n+      __ leaq(needle, Address(rsp, offset, Address::times_1, EXPANDED_NEEDLE_STACK_OFFSET));\n+      __ leaq(needle_len, Address(needle_len, needle_len));\n+\n+      __ jmp(L_continue);\n+\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\n+      \/\/ Compare Latin-1 encoded needle against UTF-16 encoded haystack.\n+      \/\/\n+      \/\/ The needle is more than MAX_NEEDLE_LEN_TO_EXPAND bytes in length, and the haystack\n+      \/\/ is at least as big.\n+\n+      \/\/ Prepare for wchar anysize\n+      __ bind(L_wideNoExpand);\n+\n+      {\n+        Label L_loopTop, L_temp, L_innerLoop, L_found, L_compareFull;\n+        Label doCompare, topLoop;\n+\n+        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+        \/\/\n+        \/\/  rbx: haystack\n+        \/\/  rcx: k\n+        \/\/  rdx: junk\n+        \/\/  rsi: n\n+        \/\/  rdi: haystack\n+        \/\/  r10: n - k\n+        \/\/  r12: k\n+        \/\/  r13: junk\n+        \/\/  r14: needle\n+        \/\/  rbp: -1\n+        \/\/  XMM_BYTE_0 - first element of needle broadcast\n+        \/\/  XMM_BYTE_K - last element of needle broadcast\n+\n+        const Register rTmp = rax;\n+        const Register haystack = rbx;\n+        const Register saveNeedleAddress = rbx;  \/\/ NOTE re-use\n+        const Register origNeedleLen = rcx;\n+        const Register firstNeedleCompare = rdx;\n+        const Register hsLen = rsi;\n+        const Register origHsLen = rsi;  \/\/ NOTE re-use\n+        const Register rTmp2 = rdi;\n+        const Register mask = rbp;\n+        const Register rScratch = r8;\n+        const Register compLen = r9;\n+        const Register needleLen = r12;\n+        const Register hsIndex = r12;  \/\/ NOTE re-use\n+        const Register constOffset = r13;\n+        const Register needle = r14;\n+        const Register index = r14;  \/\/ NOTE re-use\n+        const Register haystackEnd = r15;\n+\n+        const XMMRegister cmp_0 = xmm_tmp3;\n+        const XMMRegister cmp_k = xmm_tmp4;\n+        const XMMRegister result = xmm_tmp3;\n+\n+        const XMMRegister saveCompLen = xmm_tmp2;\n+        const XMMRegister saveIndex = xmm_tmp1;\n+\n+        \/\/ Move registers into expected registers for rest of this routine\n+        __ movq(rbx, rdi);\n+        __ movq(r12, rcx);\n+        __ movq(r14, rdx);\n+\n+        __ movq(rTmp, origNeedleLen);\n+        __ shlq(rTmp, 1);\n+        __ movq(rScratch, origHsLen);\n+        __ subq(rScratch, rTmp);\n+        __ cmpq(rScratch, 0x20);\n+        __ jl(L_compareFull);\n+\n+        \/\/ Now there is room for a 32-byte read for the last iteration\n+\n+        \/\/ Always need needle broadcast to ymm registers\n+        __ movzbl(rax, Address(needle));  \/\/ First byte of needle\n+        __ movdl(byte_0, rax);\n+        \/\/ 1st byte of needle in words\n+        __ vpbroadcastw(byte_0, byte_0, Assembler::AVX_256bit);\n+\n+        __ movzbl(rax, Address(needle, needle_len, Address::times_1,\n+                               -1));  \/\/ Last byte of needle\n+        __ movdl(byte_k, rax);\n+        __ vpbroadcastw(byte_k, byte_k,\n+                        Assembler::AVX_256bit);  \/\/ Last byte of needle in words\n+\n+        \/\/ __ bind(L_bigCaseDefault);\n+        __ movq(r11, -1);\n+\n+        broadcast_additional_needles(false, 0 \/* unknown *\/,\n+                                     NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, needle,\n+                                     origNeedleLen, rax, isUU, isUL, _masm);\n+\n+        __ leaq(haystackEnd, Address(haystack, hsLen, Address::times_1));\n+\n+        assert(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 4, \"Invalid\");\n+        assert(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE >= 2, \"Invalid\");\n+        __ leaq(firstNeedleCompare,\n+                Address(needle, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n+        __ leaq(\n+            compLen,\n+            Address(\n+                needleLen,\n+                -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE)));  \/\/ nlen - 2 elements\n+\n+        \/\/  firstNeedleCompare has address of second element of needle\n+        \/\/  compLen has length of comparison to do\n+\n+        \/\/ Save haystack\n+        __ movq(Address(rsp, SAVED_HAYSTACK_STACK_OFFSET), haystack);\n+\n+        __ movq(index, origHsLen);\n+        __ negptr(index);  \/\/ incr\n+\n+        \/\/ constant offset from end for full 32-byte read\n+        __ movq(constOffset, origHsLen);\n+        __ shlq(origNeedleLen, 1);\n+        __ subq(constOffset, origNeedleLen);\n+        __ andq(constOffset, 0x1f);\n+        __ negptr(constOffset);\n+        __ jmpb(L_temp);\n+\n+        __ bind(L_loopTop);\n+        __ addq(index, 32);\n+        __ subq(origHsLen, 32);\n+        __ jle(L_returnError);\n+        __ cmpq(index, constOffset);\n+        __ cmovq(Assembler::greater, index, constOffset);\n+\n+        __ bind(L_temp);\n+        __ movq(hsIndex, origNeedleLen);\n+        __ addq(hsIndex, index);\n+\n+        \/\/ Compare first byte of needle to haystack\n+        __ vpcmpeqw(cmp_0, byte_0, Address(haystackEnd, index),\n+                    Assembler::AVX_256bit);\n+        \/\/ Compare last byte of needle to haystack at proper position\n+        __ vpcmpeqw(cmp_k, byte_k,\n+                    Address(haystackEnd, hsIndex, Address::times_1, -2),\n+                    Assembler::AVX_256bit);\n+        __ vpand(result, cmp_k, cmp_0, Assembler::AVX_256bit);\n+#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE > 2\n+#if DO_EARLY_BAILOUT > 0\n+        __ vpmovmskb(mask, result, Assembler::AVX_256bit);\n+        __ testl(mask, mask);\n+        __ je_b(L_loopTop);\n+#endif\n+        \/\/ Compare second byte of needle to haystack\n+        __ vpcmpeqw(cmp_k, byte_1,\n+                    Address(haystackEnd, index, Address::times_1, 2),\n+                    Assembler::AVX_256bit);\n+        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n+#endif\n+#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE > 3\n+#if DO_EARLY_BAILOUT > 0\n+        __ vpmovmskb(mask, result, Assembler::AVX_256bit);\n+        __ testl(mask, mask);\n+        __ je_b(L_loopTop);\n+#endif\n+        \/\/ Compare third byte of needle to haystack\n+        __ vpcmpeqw(cmp_k, byte_2,\n+                    Address(haystackEnd, index, Address::times_1, 4),\n+                    Assembler::AVX_256bit);\n+        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n+#endif\n+        __ vpmovmskb(mask, result, Assembler::AVX_256bit);\n+        __ testl(mask, mask);\n+        __ je_b(L_loopTop);\n+\n+        __ align(8);\n+        __ bind(L_innerLoop);\n+        __ tzcntl(rTmp, mask);\n+\n+        __ movdq(saveIndex, rTmp);\n+        __ movdq(saveCompLen, compLen);\n+        \/\/ Save address of nth element of needle\n+        __ movq(saveNeedleAddress, firstNeedleCompare);\n+\n+#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 2\n+        __ leaq(rTmp2, Address(haystackEnd, index, Address::times_1, 2));\n+#endif\n+#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE == 3\n+        __ leaq(rTmp2, Address(haystackEnd, index, Address::times_1, 4));\n+#endif\n+#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE == 4\n+        __ leaq(rTmp2, Address(haystackEnd, index, Address::times_1, 6));\n+#endif\n+        __ addq(rTmp2, rTmp);\n+        __ arrays_equals(false, rTmp2, firstNeedleCompare, compLen, rTmp,\n+                         rScratch, xmm_tmp3, xmm_tmp4, false \/* char *\/, knoreg,\n+                         true \/* expand_ary2 *\/);\n+        __ testl(rTmp, rTmp);\n+        __ jne_b(L_found);\n+\n+        __ movdq(compLen, saveCompLen);\n+        __ movq(firstNeedleCompare, saveNeedleAddress);\n+        CLEAR_BIT(mask, rTmp);\n+        __ jne(L_innerLoop);\n+        __ jmp(L_loopTop);\n+\n+        __ bind(L_found);\n+        __ movdq(rTmp, saveIndex);\n+        __ leaq(rScratch, Address(haystackEnd, index, Address::times_1));\n+        __ subq(rScratch, Address(rsp, SAVED_HAYSTACK_STACK_OFFSET));\n+        __ addq(rScratch, rTmp);\n+        __ movq(r11, rScratch);\n+        __ jmp(L_checkRangeAndReturn);\n+\n+        __ bind(L_compareFull);\n+\n+        \/\/ rScratch has n - k.  Compare entire string word-by-word\n+        __ xorq(r11, r11);\n+        __ movq(r10, rScratch);\n+        __ jmpb(doCompare);\n+\n+        __ bind(topLoop);\n+        __ addq(r11, 2);\n+        __ cmpq(r11, rScratch);\n+        __ jg(L_returnRBP);\n+\n+        __ bind(doCompare);\n+        __ leaq(r9, Address(haystack, r11));\n+        __ leaq(r12, Address(needle, 0));\n+        __ movq(r13, origNeedleLen);\n+\n+        __ arrays_equals(false, r9, r12, r13, rax, rdx, xmm_tmp3, xmm_tmp4,\n+                         false \/* char *\/, knoreg, true \/* expand_ary2 *\/);\n+        __ testq(rax, rax);\n+        __ jz(topLoop);\n+\n+        \/\/ Match found\n+        __ jmp(L_checkRangeAndReturn);\n+      }\n+    }\n+\n+#undef STACK_SPACE\n+#undef MAX_NEEDLE_LEN_TO_EXPAND\n+#undef CLEAR_BIT\n+#undef XMM_BYTE_0\n+#undef XMM_BYTE_K\n+#undef XMM_BYTE_1\n+#undef XMM_BYTE_2\n+#undef XMM_TMP1\n+#undef XMM_TMP2\n+#undef XMM_TMP3\n+#undef XMM_TMP4\n+\n+  } else {  \/\/ SSE version\n+    assert(false, \"Only supports AVX2\");\n+  }\n+\n+  return;\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_string.cpp","additions":2156,"deletions":0,"binary":false,"changes":2156,"status":"added"},{"patch":"@@ -40,1 +40,1 @@\n-  _compiler_stubs_code_size     = 20000 LP64_ONLY(+39000) WINDOWS_ONLY(+2000),\n+  _compiler_stubs_code_size     = 20000 LP64_ONLY(+43000) WINDOWS_ONLY(+2000),\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1609,0 +1609,1 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"stringIndexOf\") == 0 ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1204,0 +1204,3 @@\n+  Node* result = nullptr;\n+  bool call_opt_stub = (StubRoutines::_string_indexof_array[ae] != nullptr);\n+\n@@ -1213,1 +1216,10 @@\n-  Node* result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count, result_rgn, result_phi, ae);\n+  if (call_opt_stub) {\n+    Node* call = make_runtime_call(RC_LEAF, OptoRuntime::string_IndexOf_Type(),\n+                                   StubRoutines::_string_indexof_array[ae],\n+                                   \"stringIndexOf\", TypePtr::BOTTOM, src_start,\n+                                   src_count, tgt_start, tgt_count);\n+    result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n+  } else {\n+    result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count,\n+                               result_rgn, result_phi, ae);\n+  }\n@@ -1225,1 +1237,1 @@\n-\/\/-----------------------------inline_string_indexOf-----------------------\n+\/\/-----------------------------inline_string_indexOfI-----------------------\n@@ -1258,0 +1270,3 @@\n+  Node* result = nullptr;\n+\n+  bool call_opt_stub = (StubRoutines::_string_indexof_array[ae] != nullptr);\n@@ -1259,1 +1274,10 @@\n-  Node* result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count, region, phi, ae);\n+  if (call_opt_stub) {\n+    Node* call = make_runtime_call(RC_LEAF, OptoRuntime::string_IndexOf_Type(),\n+                                   StubRoutines::_string_indexof_array[ae],\n+                                   \"stringIndexOf\", TypePtr::BOTTOM, src_start,\n+                                   src_count, tgt_start, tgt_count);\n+    result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n+  } else {\n+    result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count,\n+                               region, phi, ae);\n+  }\n@@ -1261,2 +1285,0 @@\n-    \/\/ The result is index relative to from_index if substring was found, -1 otherwise.\n-    \/\/ Generate code which will fold into cmove.\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":27,"deletions":5,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1339,0 +1339,21 @@\n+\n+\/\/ String IndexOf function\n+const TypeFunc* OptoRuntime::string_IndexOf_Type() {\n+  int argcnt = 4;\n+\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ haystack array\n+  fields[argp++] = TypeInt::INT;        \/\/ haystack length\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ needle array\n+  fields[argp++] = TypeInt::INT;        \/\/ needle length\n+  assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms + 0] = TypeInt::INT; \/\/ Index of needle in haystack\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -298,0 +298,1 @@\n+  static const TypeFunc* string_IndexOf_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -147,0 +147,2 @@\n+address StubRoutines::_string_indexof_array[4]   =    { nullptr };\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -231,0 +231,2 @@\n+  static address _string_indexof_array[4];\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,1370 @@\n+\/*\n+ * Copyright (c) 2000, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 4162796 4162796\n+ * @summary Test indexOf and lastIndexOf\n+ * @key randomness\n+ *\/\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Random;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.nio.charset.Charset;\n+import java.lang.Math;\n+\n+\/\/ @ECoreIndexOf(singleThreaded=true)\n+public class ECoreIndexOf {\n+\n+  static Random generator;\n+  private static boolean failure = false;\n+  static char[] haystack = new char[128];\n+  static char[] haystack_16 = new char[128];\n+\n+  static boolean verbose = false;\n+  static boolean success = true;\n+\n+  static Map<Charset, String> titles = new HashMap<Charset, String>();\n+  static Random rng = new Random(1999);\n+\n+  public static void main(String[] args) throws Exception {\n+    int foo = 0;\n+    String testName = \"ECoreIndexOf\";\n+\n+    generator = new Random();\n+    long seed = generator.nextLong();\/\/-5291521104060046276L;\n+    generator.setSeed(seed);\n+    System.out.println(\"Seed set to \"+ seed);\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/  WARM-UP \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    for (int i = 0; i < 20000; i++) {\n+      char c = 65;\n+      char c16 = 0x1ed;\n+      StringBuffer sb = new StringBuffer(\"a\");\n+      StringBuffer sb16 = new StringBuffer(\"\\u01fe\");\n+\n+      foo += indexOfKernel(\"\\u01fe\", \"a\");\n+      foo += indexOfKernel(\"\\u01fe\", \"a\", 0);\n+      foo += indexOfKernel(\"\\u01fe\", \"\\u01ff\");\n+      foo += indexOfKernel(\"\\u01fe\", \"\\u01ff\", 0);\n+      foo += indexOfKernel(\"a\", \"a\");\n+      foo += indexOfKernel(\"a\", \"a\", 0);\n+      foo += indexOfKernel(\"a\", \"\\u01ff\");\n+      foo += indexOfKernel(\"a\", \"\\u01ff\", 0);\n+\n+      foo += indexOfKernel(\"\\u01fe\", c);\n+      foo += indexOfKernel(\"\\u01fe\", c, 0);\n+      foo += indexOfKernel(\"\\u01fe\", c16);\n+      foo += indexOfKernel(\"\\u01fe\", c16, 0);\n+      foo += indexOfKernel(\"a\", c);\n+      foo += indexOfKernel(\"a\", c, 0);\n+      foo += indexOfKernel(\"a\", c16);\n+      foo += indexOfKernel(\"a\", c16, 0);\n+\n+      foo += indexOfKernel(sb16, c);\n+      foo += indexOfKernel(sb16, c, 0);\n+      foo += indexOfKernel(sb16, c16);\n+      foo += indexOfKernel(sb16, c16, 0);\n+      foo += indexOfKernel(sb, c);\n+      foo += indexOfKernel(sb, c, 0);\n+      foo += indexOfKernel(sb, c16);\n+      foo += indexOfKernel(sb, c16, 0);\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    String[] decorators = {\"\", \" (same char)\"};\n+    Charset[] charSets = {StandardCharsets.ISO_8859_1, StandardCharsets.UTF_16};\n+    boolean[] truefalse = {true, false};\n+\n+    titles.put(StandardCharsets.ISO_8859_1, \"L\");\n+    titles.put(StandardCharsets.UTF_16, \"U\");\n+\n+    for (int xxy = 0; xxy < 2; xxy++) { \/\/ Run at least twice to ensure stub called\n+\n+      for (int i = 0; i < 128; i++) {\n+        haystack[i] = (char) i;\n+      }\n+\n+      haystack_16[0] = '\\u0000'; \/\/ (char) (23 + 256);\n+      for (int i = 1; i < 128; i++) {\n+        haystack_16[i] = (char) (i);\n+      }\n+\n+      simpleTest();\n+      compareIndexOfLastIndexOf();\n+      compareStringStringBuffer();\n+      StringIndexof();\n+      StringIndexofChar();\n+      StringIndexofHuge();\n+\n+      for (String decorator : decorators) {\n+        for (Charset csHaystack : charSets) {\n+          for (Charset csNeedle : charSets) {\n+            System.out.println(\"Testing \" + titles.get(csHaystack) + titles.get(csNeedle) + decorator);\n+            for (boolean useOffset : truefalse) {\n+              for (boolean useBuffer : truefalse) {\n+                exhaustive(useOffset, useBuffer, csHaystack, csNeedle);\n+              }\n+            }\n+          }\n+        }\n+\n+        for (int i = 0; i < 128; i++) {\n+          haystack[i] = (char) 'a';\n+        }\n+\n+        for (int i = 0; i < 128; i++) {\n+          haystack_16[i] = (char) ('a' + 256);\n+        }\n+      }\n+    }\n+\n+    System.out.println(testName + \" complete.\");\n+\n+    if (failure)\n+      throw new RuntimeException(\"One or more failures.\");\n+  }\n+\n+  private static void report(String testName, int failCount) {\n+    System.err.println(testName + \": \" +\n+        (failCount == 0 ? \"Passed\" : \"Failed(\" + failCount + \")\"));\n+    if (failCount > 0)\n+      failure = true;\n+  }\n+\n+  private static String generateTestString(int min, int max) {\n+    StringBuffer aNewString = new StringBuffer(120);\n+    int aNewLength = getRandomIndex(min, max);\n+    for (int y = 0; y < aNewLength; y++) {\n+      int achar = generator.nextInt(30) + 30;\n+      char test = (char) (achar);\n+      aNewString.append(test);\n+    }\n+    return aNewString.toString();\n+  }\n+\n+  private static String makeRndString(boolean isUtf16, int length) {\n+    StringBuilder sb = new StringBuilder(length);\n+    if (length > 0) {\n+      sb.append(isUtf16 ? '\\u2026' : 'b'); \/\/ ...\n+\n+      for (int i = 1; i < length - 1; i++) {\n+        sb.append((char) ('b' + rng.nextInt(26)));\n+      }\n+\n+      sb.append(rng.nextInt(3) >= 1 ? 'a' : 'b');\/\/ 66.6% of time 'a' is in string\n+    }\n+    return sb.toString();\n+  }\n+\n+  private static int indexOfKernel(String haystack, String needle) {\n+    return haystack.indexOf(needle);\n+  }\n+\n+  private static int indexOfKernel(String haystack, String needle, int offset) {\n+    return haystack.indexOf(needle, offset);\n+  }\n+\n+  private static int indexOfKernel(StringBuffer haystack, String needle) {\n+    return haystack.indexOf(needle);\n+  }\n+\n+  private static int indexOfKernel(StringBuffer haystack, char cneedle) {\n+    String needle = String.valueOf(cneedle);\n+    return haystack.indexOf(needle);\n+  }\n+\n+  private static int indexOfKernel(StringBuffer haystack, String needle, int offset) {\n+    return haystack.indexOf(needle, offset);\n+  }\n+\n+  private static int indexOfKernel(StringBuffer haystack, char cneedle, int offset) {\n+    String needle = String.valueOf(cneedle);\n+    return haystack.indexOf(needle, offset);\n+  }\n+\n+  private static int indexOfKernel(String haystack, char needle) {\n+    return haystack.indexOf(needle);\n+  }\n+\n+  private static int indexOfKernel(String haystack, char needle, int offset) {\n+    return haystack.indexOf(needle, offset);\n+  }\n+\n+  private static void printStringBytes(byte[] bytes) {\n+    System.err.println(\" bytes.len=\" + bytes.length);\n+    for (byte b : bytes) {\n+      System.err.print(String.format(\"0x%02x \", b));\n+    }\n+    System.err.println(\"\");\n+  }\n+\n+  private static int getRandomIndex(int constraint1, int constraint2) {\n+    int range = constraint2 - constraint1;\n+    int x = generator.nextInt(range);\n+    return constraint1 + x;\n+  }\n+\n+  private static int naiveFind(String haystack, String needle) {\n+    return naiveFind(haystack, needle, 0);\n+  }\n+\n+  private static int naiveFind(String haystack, char needle) {\n+    return naiveFind(haystack, needle, 0);\n+  }\n+\n+  private static int naiveFind(String haystack, String needle, int offset) {\n+    int x = offset;\n+    int len = haystack.length() - offset;\n+    if (needle.length() == 0)\n+      return offset;\n+    if (needle.length() > len)\n+      return -1;\n+    int hsndx = 0;\n+    int nndx = 0;\n+    for (int xx = 0; xx < offset; xx++) {\n+      hsndx += Character.charCount(haystack.codePointAt(hsndx));\n+    }\n+\n+    for (x = offset; x < haystack.length() - needle.length() + 1; x++) {\n+      if (haystack.codePointAt(hsndx) == needle.codePointAt(0)) {\n+        nndx = Character.charCount(needle.codePointAt(0));\n+        int hsndx_tmp = hsndx + Character.charCount(haystack.codePointAt(hsndx));\n+\n+        while (nndx < needle.length()) {\n+          if (haystack.codePointAt(hsndx_tmp) != needle.codePointAt(nndx)) {\n+            break;\n+          }\n+          hsndx_tmp += Character.charCount(haystack.codePointAt(hsndx_tmp));\n+          nndx += Character.charCount(needle.codePointAt(nndx));\n+        }\n+        if (nndx == needle.length()) {\n+          return x;\n+        }\n+      }\n+      hsndx += Character.charCount(haystack.codePointAt(hsndx));\n+    }\n+    return -1;\n+  }\n+\n+  private static int naiveFind(String haystack, char cneedle, int offset) {\n+    int x = offset;\n+    int len = haystack.length() - offset;\n+    String needle = String.valueOf(cneedle);\n+    if (len == 0)\n+      return -1;\n+    int hsndx = 0;\n+    for (int xx = 0; xx < offset; xx++) {\n+      hsndx += Character.charCount(haystack.codePointAt(hsndx));\n+    }\n+\n+    for (x = offset; x < haystack.length(); x++) {\n+      if (haystack.codePointAt(hsndx) == needle.codePointAt(0)) {\n+        return x;\n+      }\n+      hsndx += Character.charCount(haystack.codePointAt(hsndx));\n+    }\n+\n+    return -1;\n+  }\n+\n+  private static void exhaustive(boolean useOffset, boolean useStringBuffer, Charset hs_charset,\n+      Charset needleCharset) {\n+    int result = 0;\n+    int midresult = 0;\n+    int endresult = 0;\n+    int l_offset = 0;\n+    int failCount = 0;\n+\n+    String thisTest = titles.get(hs_charset) + titles.get(needleCharset) + (useOffset ? \" w\/offset\" : \"\") + (useStringBuffer ? \" StringBuffer\" : \"\");\n+\n+    for (int needleSize = 0; needleSize < 128; needleSize++) {\n+      for (int haystackSize = 0; haystackSize < 128; haystackSize++) {\n+        for (l_offset = 0; l_offset <= haystackSize; l_offset++) {\n+          String needle = new String(Arrays.copyOfRange(\n+              (needleCharset == StandardCharsets.UTF_16) ? haystack_16 : haystack, l_offset, l_offset + needleSize));\n+          int hsSize = (haystackSize - l_offset) >= 0 ? haystackSize - l_offset : 0;\n+          int midStart = Math.max((hsSize \/ 2) - (needleSize \/ 2), 0);\n+          int endStart = (hsSize > needleSize) ? hsSize - needleSize : 0;\n+          String midNeedle = new String(\n+              Arrays.copyOfRange((needleCharset == StandardCharsets.UTF_16) ? haystack_16 : haystack,\n+                  midStart + l_offset, midStart + needleSize + l_offset));\n+          String endNeedle = new String(\n+              Arrays.copyOfRange((needleCharset == StandardCharsets.UTF_16) ? haystack_16 : haystack,\n+                  endStart + l_offset, endStart + needleSize + l_offset));\n+          String shs = new String(\n+              Arrays.copyOfRange((hs_charset == StandardCharsets.UTF_16) ? haystack_16 : haystack, 0, haystackSize));\n+\n+          \/\/ Truncate needles to correct lengths\n+\n+          if (l_offset + needleSize > haystack.length + 1) {\n+            needle = needle.substring(0, needleSize);\n+            midNeedle = midNeedle.substring(0, needleSize);\n+            endNeedle = endNeedle.substring(0, needleSize);\n+          }\n+\n+          if (!success && needleSize > 1) {\n+            needle = needle.substring(0, needle.length() - 1) + (char) ((int) (needle.charAt(needle.length() - 2) + 1));\n+            midNeedle = midNeedle.substring(0, midNeedle.length() - 1)\n+                + (char) ((int) (midNeedle.charAt(midNeedle.length() - 2) + 1));\n+            endNeedle = endNeedle.substring(0, endNeedle.length() - 1)\n+                + (char) ((int) (endNeedle.charAt(endNeedle.length() - 2) + 1));\n+          }\n+\n+          StringBuffer hs = new StringBuffer(shs.length());\n+          hs.append(shs);\n+          if (!shs.equals(hs.toString()))\n+            throw new RuntimeException(\"Initial equality failure\");\n+\n+          if (useStringBuffer) {\n+            result = indexOfKernel(hs, needle, l_offset);\n+            midresult = indexOfKernel(hs, midNeedle, l_offset);\n+            endresult = indexOfKernel(hs, endNeedle, l_offset);\n+          } else {\n+            result = indexOfKernel(shs, needle, l_offset);\n+            midresult = indexOfKernel(shs, midNeedle, l_offset);\n+            endresult = indexOfKernel(shs, endNeedle, l_offset);\n+          }\n+          int nResult = naiveFind(hs.toString(), needle, l_offset);\n+          int midnResult = naiveFind(hs.toString(), midNeedle, l_offset);\n+          int endnResult = naiveFind(hs.toString(), endNeedle, l_offset);\n+          if (result != nResult) {\n+            failCount++;\n+            System.err.println(\"useOffset=\" + useOffset + \", useStringBuffer=\" + useStringBuffer);\n+            System.err.print(\"Haystack=\");\n+            printStringBytes(shs.getBytes(hs_charset));\n+            System.err.print(\"Needle=\");\n+            printStringBytes(needle.getBytes(needleCharset));\n+            System.err.println(\"l_offset=\" + l_offset);\n+            System.err.println(\"haystackLen=\" + haystackSize + \" needleLen=\" + needleSize +\n+                \" result=\" + result + \" nResult=\" + nResult);\n+            System.err.println(\"\");\n+          }\n+          \/\/ badResults = success ? ((midnResult == -1) || (midresult == -1)) :\n+          \/\/ ((midnResult != -1) || (midresult != -1));\n+          if ((midresult != midnResult)) {\n+            failCount++;\n+            System.err.println(\"useOffset=\" + useOffset + \", useStringBuffer=\" + useStringBuffer);\n+            System.err.print(\"Haystack=\");\n+            printStringBytes(shs.getBytes(hs_charset));\n+            System.err.print(\"Needle=\");\n+            printStringBytes(midNeedle.getBytes(needleCharset));\n+            System.err.println(\"l_offset=\" + l_offset);\n+            System.err.println(\"haystackLen=\" + haystackSize + \" needleLen=\" + needleSize +\n+                \" midresult=\" + midresult + \" midnResult=\" + midnResult);\n+            System.err.println(\"\");\n+          }\n+          \/\/ badResults = success ? ((endnResult == -1) || (endresult == -1)) :\n+          \/\/ ((endnResult != -1) || (endresult != -1));\n+          if ((endresult != endnResult)) {\n+            failCount++;\n+            System.err.println(\"useOffset=\" + useOffset + \", useStringBuffer=\" + useStringBuffer);\n+            System.err.print(\"Haystack=\");\n+            printStringBytes(shs.getBytes(hs_charset));\n+            System.err.print(\"Needle=\");\n+            printStringBytes(endNeedle.getBytes(needleCharset));\n+            System.err.println(\"l_offset=\" + l_offset);\n+            System.err.println(\"haystackLen=\" + haystackSize + \" needleLen=\" + needleSize +\n+                \" endresult=\" + endresult + \" endnResult=\" + endnResult);\n+            System.err.println(\"\");\n+          }\n+\n+          if (!useOffset)\n+            l_offset = haystackSize + 100;\n+        }\n+      }\n+    }\n+\n+    report(\"Exhaustive \" + thisTest, failCount);\n+  }\n+\n+  private static void PrintError(int kernel, int naive, int num, String prefix, String hs, char needle) {\n+    PrintError(kernel, naive, num, prefix, hs, String.valueOf(needle));\n+  }\n+\n+  private static void PrintError(int kernel, int naive, int num, String prefix, String hs, String needle) {\n+    if (!verbose)\n+      return;\n+    System.err.println(prefix + \": (\" + num + \"): kernel=\" + kernel + \", naive=\" + naive);\n+    System.err.print(\"Haystack=\");\n+    printStringBytes(hs.getBytes());\n+    System.err.print(\"Needle=\");\n+    printStringBytes(needle.getBytes());\n+    System.err.println(\"\");\n+  }\n+\n+  private static void simpleTest() {\n+    int failCount = 0;\n+    String sourceString;\n+    StringBuffer sourceBuffer;\n+    String targetString;\n+    String emptyString = \"\";\n+    String allAs = new String(\"aaaaaaaaaaaaaaaaaaaaaaaaa\");\n+    StringBuffer allAsBuffer = new StringBuffer(allAs);\n+\n+    for (int i = 0; i < 10000; i++) {\n+      do {\n+        sourceString = generateTestString(99, 100);\n+        sourceBuffer = new StringBuffer(sourceString);\n+        targetString = generateTestString(10, 11);\n+      } while (indexOfKernel(sourceString, targetString) != -1);\n+\n+      int index1 = generator.nextInt(90) + 5;\n+      sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n+\n+      if ((indexOfKernel(sourceBuffer, targetString) != index1) ||\n+          (index1 != naiveFind(sourceBuffer.toString(), targetString, 0))) {\n+        System.err.println(\"sourceBuffer.indexOf(targetString) fragment '\" + targetString + \"' (\"\n+            + targetString.length() + \") String = \"\n+            + sourceBuffer.toString() + \" len Buffer = \" + sourceBuffer.toString().length());\n+        System.err.println(\"  naive = \" + naiveFind(sourceBuffer.toString(), targetString, 0) + \", IndexOf = \"\n+            + indexOfKernel(sourceBuffer, targetString));\n+        failCount++;\n+      }\n+      if ((indexOfKernel(sourceBuffer, targetString, 5) != index1) ||\n+          (index1 != naiveFind(sourceBuffer.toString(), targetString, 0))) {\n+        System.err.println(\"sourceBuffer.indexOf(targetString, 5) fragment '\" + targetString + \"' (\"\n+            + targetString.length() + \") String = \"\n+            + sourceBuffer.toString() + \" len Buffer = \" + sourceBuffer.toString().length());\n+        System.err.println(\"  naive = \" + naiveFind(sourceBuffer.toString(), targetString, 0) + \", IndexOf = \"\n+            + indexOfKernel(sourceBuffer, targetString, 5));\n+        failCount++;\n+      }\n+      if ((indexOfKernel(sourceBuffer, targetString, 99) == index1) ||\n+          (index1 != naiveFind(sourceBuffer.toString(), targetString, 0))) {\n+        System.err.println(\"sourceBuffer.indexOf(targetString, 99) fragment '\" + targetString + \"' (\"\n+            + targetString.length() + \") String = \"\n+            + sourceBuffer.toString() + \" len Buffer = \" + sourceBuffer.toString().length());\n+        System.err.println(\"  naive = \" + naiveFind(sourceBuffer.toString(), targetString, 0) + \", IndexOf = \"\n+            + indexOfKernel(sourceBuffer, targetString, 99));\n+        failCount++;\n+      }\n+      if ((indexOfKernel(sourceBuffer, emptyString, 99) != 99) ||\n+          (99 != naiveFind(sourceBuffer.toString(), emptyString, 99))) {\n+        System.err.println(\"sourceBuffer.indexOf(emptyString, 99) fragment '\" + emptyString + \"' (\"\n+            + emptyString.length() + \") String = \"\n+            + sourceBuffer.toString() + \" len Buffer = \" + sourceBuffer.toString().length());\n+        System.err.println(\"  naive = \" + naiveFind(sourceBuffer.toString(), emptyString, 99) + \", IndexOf = \"\n+            + indexOfKernel(sourceBuffer, emptyString, 99));\n+        failCount++;\n+      }\n+      if ((indexOfKernel(allAsBuffer.substring(1, 3), allAsBuffer.substring(5, 12)) != -1) ||\n+          (-1 != naiveFind(allAsBuffer.substring(1, 3).toString(), allAsBuffer.substring(5, 12), 0))) {\n+        System.err.println(\"allAsBuffer.substring(1, 3).indexOf(allAsBuffer.substring(5, 12)) fragment '\"\n+            + allAsBuffer.substring(5, 12) + \"' (\"\n+            + allAsBuffer.substring(5, 12).length() + \") String = \"\n+            + allAsBuffer.substring(1, 3) + \" len Buffer = \" + allAsBuffer.substring(1, 3).length());\n+        System.err.println(\n+            \"  naive = \" + naiveFind(allAsBuffer.substring(1, 3).toString(), allAsBuffer.substring(5, 12), 0)\n+                + \", IndexOf = \" + indexOfKernel(allAsBuffer.substring(1, 3), allAsBuffer.substring(5, 12)));\n+        failCount++;\n+      }\n+    }\n+\n+    report(\"Basic Test                   \", failCount);\n+  }\n+\n+  \/\/ Note: it is possible although highly improbable that failCount will\n+  \/\/ be > 0 even if everthing is working ok\n+  private static void compareIndexOfLastIndexOf() {\n+    int failCount = 0;\n+    String sourceString;\n+    StringBuffer sourceBuffer;\n+    String targetString;\n+\n+    for (int i = 0; i < 10000; i++) {\n+      do {\n+        sourceString = generateTestString(99, 100);\n+        sourceBuffer = new StringBuffer(sourceString);\n+        targetString = generateTestString(10, 11);\n+      } while (indexOfKernel(sourceString, targetString) != -1);\n+\n+      int index1 = generator.nextInt(100);\n+      sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n+\n+      \/\/ extremely remote possibility of > 1 match\n+      int matches = 0;\n+      int index2 = -1;\n+      while ((index2 = indexOfKernel(sourceBuffer, targetString, index2 + 1)) != -1)\n+        matches++;\n+      if (matches > 1)\n+        continue;\n+\n+      if (indexOfKernel(sourceBuffer, targetString) != sourceBuffer.lastIndexOf(targetString))\n+        failCount++;\n+      sourceString = sourceBuffer.toString();\n+      if (indexOfKernel(sourceString, targetString) != sourceString.lastIndexOf(targetString))\n+        failCount++;\n+    }\n+\n+    report(\"IndexOf vs LastIndexOf       \", failCount);\n+  }\n+\n+  private static void compareStringStringBuffer() {\n+    int failCount = 0;\n+    boolean make_new = true;\n+\n+    String fragment = null;\n+    StringBuffer testBuffer = null;\n+    String testString = null;\n+    int testIndex = 0;\n+\n+    failCount = indexOfKernel(\"\", \"\");\n+\n+    for (int x = 0; x < 1000000; x++) {\n+      if (make_new) {\n+        testString = generateTestString(1, 100);\n+        int len = testString.length();\n+\n+        testBuffer = new StringBuffer(len);\n+        testBuffer.append(testString);\n+        if (!testString.equals(testBuffer.toString()))\n+          throw new RuntimeException(\"Initial equality failure\");\n+\n+        int x1 = 0;\n+        int x2 = 1000;\n+        while (x2 > testString.length()) {\n+          x1 = generator.nextInt(len);\n+          x2 = generator.nextInt(100);\n+          x2 = x1 + x2;\n+        }\n+        fragment = testString.substring(x1, x2);\n+      }\n+\n+      int sAnswer = indexOfKernel(testString, fragment);\n+      int sbAnswer = indexOfKernel(testBuffer, fragment);\n+\n+      if (sAnswer != sbAnswer) {\n+        System.err.println(\"(1) IndexOf fragment '\" + fragment + \"' (\" + fragment.length() + \") len String = \"\n+            + testString.length() + \" len Buffer = \" + testBuffer.length());\n+        System.err.println(\"  sAnswer = \" + sAnswer + \", sbAnswer = \" + sbAnswer);\n+        System.err.println(\"  testString = '\" + testString + \"'\");\n+        System.err.println(\"  testBuffer = '\" + testBuffer + \"'\");\n+        failCount++;\n+\n+        sAnswer = indexOfKernel(testString, fragment);\n+        sbAnswer = indexOfKernel(testBuffer, fragment);\n+      } else {\n+        if (sAnswer > testString.length()) {\n+          System.err.println(\n+              \"IndexOf returned value out of range; return: \" + sAnswer + \" length max: \" + testBuffer.length());\n+        }\n+      }\n+\n+      if ((fragment == \"0#:02\/62;+-\\\"\\\"0$25-5$#)1263\") && (testBuffer.length() == 94)) {\n+        String xx = \"abc\";\n+        String yy = \"abcdefg\";\n+        int sA = indexOfKernel(xx, yy);\n+      }\n+\n+      if (make_new)\n+        testIndex = getRandomIndex(-100, 100);\n+\n+      sAnswer = indexOfKernel(testString, fragment, testIndex);\n+      sbAnswer = indexOfKernel(testBuffer, fragment, testIndex);\n+\n+      if (sAnswer != sbAnswer) {\n+        System.err.println(\"(2) IndexOf fragment '\" + fragment + \"' (\" + fragment.length() + \") index = \" + testIndex\n+            + \" len String = \" + testString.length() + \" len Buffer = \" + testBuffer.length());\n+        System.err.println(\"  sAnswer = \" + sAnswer + \", sbAnswer = \" + sbAnswer);\n+        System.err.println(\"  testString = '\" + testString + \"'\");\n+        System.err.println(\"  testBuffer = '\" + testBuffer + \"'\");\n+        failCount++;\n+        make_new = true;\n+\n+        sAnswer = indexOfKernel(testString, fragment, testIndex);\n+        sbAnswer = indexOfKernel(testBuffer, fragment, testIndex);\n+      } else {\n+        if ((sAnswer > testString.length()) || ((sAnswer != -1) && (sAnswer < testIndex) && (fragment.length() != 0))) {\n+          System.err.println(\"IndexOf returned value out of range; return: \" + sAnswer + \" length max: \"\n+              + testString.length() + \" index: \" + testIndex);\n+          System.err.println(\"(3) IndexOf fragment '\" + fragment + \"' (\" + fragment.length() + \") index = \" + testIndex\n+              + \" len String = \" + testString.length() + \" len Buffer = \" + testBuffer.length());\n+        }\n+      }\n+\n+      sAnswer = testString.lastIndexOf(fragment);\n+      sbAnswer = testBuffer.lastIndexOf(fragment);\n+\n+      if (sAnswer != sbAnswer) {\n+          System.err.println(\"(1) lastIndexOf fragment '\" + fragment + \"' len String = \" + testString.length()\n+            + \" len Buffer = \" + testBuffer.length());\n+          System.err.println(\"  sAnswer = \" + sAnswer + \", sbAnswer = \" + sbAnswer);\n+          failCount++;\n+\n+          sAnswer = testString.lastIndexOf(fragment);\n+          sbAnswer = testBuffer.lastIndexOf(fragment);\n+      }\n+\n+      if (make_new)\n+        testIndex = getRandomIndex(-100, 100);\n+\n+      sAnswer = testString.lastIndexOf(fragment, testIndex);\n+      sbAnswer = testBuffer.lastIndexOf(fragment, testIndex);\n+\n+      if (sAnswer != sbAnswer) {\n+        System.err.println(\"(2) lastIndexOf fragment '\" + fragment + \"' index = \" + testIndex + \" len String = \"\n+            + testString.length() + \" len Buffer = \" + testBuffer.length());\n+        failCount++;\n+      }\n+    }\n+\n+    report(\"String vs StringBuffer       \", failCount);\n+  }\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/ Test routines used in benchmarks\n+  \/\/\n+  \/\/ From StringIndexofHuge\n+  private static void StringIndexofHuge() {\n+    int stubResult = 0;\n+    int failCount = 0;\n+\n+    for (int xx = 0; xx < 2; xx++) {\n+      int num = 1;\n+\n+      String dataString = \"ngdflsoscargfdgf\";\n+      String dataString16 = \"ngdfilso\\u01facargfd\\u01eef\";\n+      String dataStringHuge = ((\"A\".repeat(32) + \"B\".repeat(32)).repeat(16) + \"X\").repeat(2) + \"bB\";\n+      String dataStringHuge16 = \"\\u01de\" + ((\"A\".repeat(32) + \"B\".repeat(32)).repeat(16) + \"\\u01fe\").repeat(2)\n+          + \"\\u01eeB\";\n+      String earlyMatchString = dataStringHuge.substring(0, 34);\n+      String earlyMatchString16 = dataStringHuge16.substring(0, 34);\n+      String midMatchString = dataStringHuge.substring(dataStringHuge.length() \/ 2 - 16,\n+          dataStringHuge.length() \/ 2 + 32);\n+      String midMatchString16 = dataStringHuge16.substring(dataStringHuge16.length() \/ 2 - 16,\n+          dataStringHuge16.length() \/ 2 + 32);\n+      String lateMatchString = dataStringHuge.substring(dataStringHuge.length() - 31);\n+      String lateMatchString16 = dataStringHuge16.substring(dataStringHuge16.length() - 31);\n+\n+      String searchString = \"oscar\";\n+      String searchString16 = \"o\\u01facar\";\n+      String searchStringSmall = \"dgf\";\n+      String searchStringSmall16 = \"d\\u01eef\";\n+\n+      String searchStringHuge = \"capaapapapasdkajdlkajskldjaslkajdlkajskldjaslkjdlkasjdsalk\";\n+      String searchStringHuge16 = \"capaapapapasdkajdlka\\u01feskldjaslkajdlkajskldjaslkjdlkasjdsalk\";\n+\n+      String searchNoMatch = \"XYXyxYxy\".repeat(22);\n+      String searchNoMatch16 = \"\\u01ab\\u01ba\\u01cb\\u01bc\\u01de\\u01ed\\u01fa\\u01af\".repeat(22);\n+\n+      stubResult = indexOfKernel(dataStringHuge16, earlyMatchString);\n+      int nResult = naiveFind(dataStringHuge16, earlyMatchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16, earlyMatchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge, earlyMatchString);\n+      nResult = naiveFind(dataStringHuge, earlyMatchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge, earlyMatchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge, midMatchString);\n+      nResult = naiveFind(dataStringHuge, midMatchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge, midMatchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge, lateMatchString);\n+      nResult = naiveFind(dataStringHuge, lateMatchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge, lateMatchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge, searchNoMatch);\n+      nResult = naiveFind(dataStringHuge, searchNoMatch);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge, searchNoMatch);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(searchString, searchString);\n+      nResult = naiveFind(searchString, searchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", searchString, searchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataString, searchString);\n+      nResult = naiveFind(dataString, searchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataString, searchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataString, searchStringSmall);\n+      nResult = naiveFind(dataString, searchStringSmall);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataString, searchStringSmall);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge, \"B\".repeat(30) + \"X\" + \"A\".repeat(30), 74);\n+      nResult = naiveFind(dataStringHuge, \"B\".repeat(30) + \"X\" + \"A\".repeat(30), 74);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge,\n+            \"B\".repeat(30) + \"X\" + \"A\".repeat(30));\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge, \"A\".repeat(32) + \"F\" + \"B\".repeat(32), 64);\n+      nResult = naiveFind(dataStringHuge, \"A\".repeat(32) + \"F\" + \"B\".repeat(32), 64);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge,\n+            \"A\".repeat(32) + \"F\" + \"B\".repeat(32));\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(midMatchString, dataStringHuge, 3);\n+      nResult = naiveFind(midMatchString, dataStringHuge, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", midMatchString, dataStringHuge);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge, \"A\".repeat(32) + \"B\".repeat(30) + \"bB\");\n+      nResult = naiveFind(dataStringHuge, \"A\".repeat(32) + \"B\".repeat(30) + \"bB\");\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge,\n+            \"A\".repeat(32) + \"B\".repeat(30) + \"bB\");\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, earlyMatchString);\n+      nResult = naiveFind(dataStringHuge16, earlyMatchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16, earlyMatchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, midMatchString);\n+      nResult = naiveFind(dataStringHuge16, midMatchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16, midMatchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, lateMatchString);\n+      nResult = naiveFind(dataStringHuge16, lateMatchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16, lateMatchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, searchNoMatch);\n+      nResult = naiveFind(dataStringHuge16, searchNoMatch);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16, searchNoMatch);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(searchString16, searchString);\n+      nResult = naiveFind(searchString16, searchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", searchString16, searchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataString16, searchString);\n+      nResult = naiveFind(dataString16, searchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataString16, searchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataString16, searchStringSmall);\n+      nResult = naiveFind(dataString16, searchStringSmall);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataString16, searchStringSmall);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, \"B\".repeat(30) + \"X\" + \"A\".repeat(30), 74);\n+      nResult = naiveFind(dataStringHuge16, \"B\".repeat(30) + \"X\" + \"A\".repeat(30), 74);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16,\n+            \"B\".repeat(30) + \"X\" + \"A\".repeat(30));\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, \"A\".repeat(32) + \"F\" + \"B\".repeat(32), 64);\n+      nResult = naiveFind(dataStringHuge16, \"A\".repeat(32) + \"F\" + \"B\".repeat(32), 64);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16,\n+            \"A\".repeat(32) + \"F\" + \"B\".repeat(32));\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(midMatchString16, dataStringHuge, 3);\n+      nResult = naiveFind(midMatchString16, dataStringHuge, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", midMatchString16, dataStringHuge);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, \"A\".repeat(32) + \"B\".repeat(30) + \"bB\");\n+      nResult = naiveFind(dataStringHuge16, \"A\".repeat(32) + \"B\".repeat(30) + \"bB\");\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16,\n+            \"A\".repeat(32) + \"B\".repeat(30) + \"bB\");\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, earlyMatchString16);\n+      nResult = naiveFind(dataStringHuge16, earlyMatchString16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16, earlyMatchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, midMatchString16);\n+      nResult = naiveFind(dataStringHuge16, midMatchString16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16, midMatchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, lateMatchString16);\n+      nResult = naiveFind(dataStringHuge16, lateMatchString16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16, lateMatchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, searchNoMatch16);\n+      nResult = naiveFind(dataStringHuge16, searchNoMatch16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16, searchNoMatch16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(searchString16, searchString16);\n+      nResult = naiveFind(searchString16, searchString16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", searchString16, searchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataString16, searchString16);\n+      nResult = naiveFind(dataString16, searchString16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataString16, searchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataString16, searchStringSmall16);\n+      nResult = naiveFind(dataString16, searchStringSmall16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataString16, searchStringSmall16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, \"B\".repeat(30) + \"X\" + \"A\".repeat(30), 74);\n+      nResult = naiveFind(dataStringHuge16, \"B\".repeat(30) + \"X\" + \"A\".repeat(30), 74);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16,\n+            \"B\".repeat(30) + \"X\" + \"A\".repeat(30));\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, \"A\".repeat(32) + \"\\u01ef\" + \"B\".repeat(32), 64);\n+      nResult = naiveFind(dataStringHuge16, \"A\".repeat(32) + \"\\u01ef\" + \"B\".repeat(32), 64);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16,\n+            \"A\".repeat(32) + \"\\u01ef\" + \"B\".repeat(32));\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(midMatchString16, dataStringHuge16, 3);\n+      nResult = naiveFind(midMatchString16, dataStringHuge16, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", midMatchString16, dataStringHuge16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, \"A\".repeat(32) + \"B\".repeat(30) + \"\\u01eeB\");\n+      nResult = naiveFind(dataStringHuge16, \"A\".repeat(32) + \"B\".repeat(30) + \"\\u01eeB\");\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16,\n+            \"A\".repeat(32) + \"B\".repeat(30) + \"\\u01eeB\");\n+        failCount++;\n+      }\n+      num++;\n+    }\n+\n+    report(\"StringIndexofHuge            \", failCount);\n+  }\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\n+  \/\/ From StringIndexof\n+  private static void StringIndexof() {\n+    int stubResult = 0;\n+    int failCount = 0;\n+\n+    for (int xx = 0; xx < 2; xx++) {\n+      int num = 1;\n+\n+      String dataString = \"ngdfilsoscargfdgf\";\n+      String searchString = \"oscar\";\n+      String dataStringBig = \"2937489745890797905764956790452976742965790437698498409583479067ngdcapaapapapasdkajdlkajskldjaslkjdlkasjdsalkjas\";\n+      String searchStringBig = \"capaapapapasdkajdlkajskldjaslkjdlkasjdsalk\";\n+      String data = \"0000100101010010110101010010101110101001110110101010010101010010000010111010101010101010100010010101110111010101101010100010010100001010111111100001010101001010100001010101001010101010111010010101010101010101010101010\";\n+      String sub = \"10101010\";\n+      String shortSub1 = \"1\";\n+      String data2 = \"00001001010100a10110101010010101110101001110110101010010101010010000010111010101010101010a100010010101110111010101101010100010010a100a0010101111111000010101010010101000010101010010101010101110a10010101010101010101010101010\";\n+      String shortSub2 = \"a\";\n+      char searchChar = 's';\n+\n+      String string16Short = \"scar\\u01fe1\";\n+      String string16Medium = \"capaapapapasdkajdlkajskldjaslkjdlkasjdsalksca1r\\u01fescar\";\n+      String string16Long = \"2937489745890797905764956790452976742965790437698498409583479067ngdcapaapapapasdkajdlkajskldjaslkjdlkasjdsalkja1sscar\\u01fescar\";\n+      char searchChar16 = 0x1fe;\n+      String searchString16 = \"\\u01fe\";\n+\n+      stubResult = indexOfKernel(dataStringBig, searchChar);\n+      int nResult = naiveFind(dataStringBig, searchChar);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", dataStringBig, searchChar);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(searchStringBig, searchChar);\n+      nResult = naiveFind(searchStringBig, searchChar);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", searchStringBig, searchChar);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(searchString, searchChar);\n+      nResult = naiveFind(searchString, searchChar);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", searchString, searchChar);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Long, searchChar16);\n+      nResult = naiveFind(string16Long, searchChar16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Long, searchChar16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Medium, searchChar16);\n+      nResult = naiveFind(string16Medium, searchChar16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Medium, searchChar16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Short, searchChar16);\n+      nResult = naiveFind(string16Short, searchChar16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Short, searchChar16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringBig, searchChar, 3);\n+      nResult = naiveFind(dataStringBig, searchChar, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", dataStringBig, searchChar);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(searchStringBig, searchChar, 3);\n+      nResult = naiveFind(searchStringBig, searchChar, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", searchStringBig, searchChar);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(searchString, searchChar, 1);\n+      nResult = naiveFind(searchString, searchChar, 1);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", searchString, searchChar);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Long, searchChar16, 3);\n+      nResult = naiveFind(string16Long, searchChar16, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Long, searchChar16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Medium, searchChar16, 3);\n+      nResult = naiveFind(string16Medium, searchChar16, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Medium, searchChar16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Short, searchChar16, 2);\n+      nResult = naiveFind(string16Short, searchChar16, 2);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Short, searchChar16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Long, shortSub1);\n+      nResult = naiveFind(string16Long, shortSub1);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Long, shortSub1);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Medium, shortSub1);\n+      nResult = naiveFind(string16Medium, shortSub1);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Medium, shortSub1);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Long, shortSub2);\n+      nResult = naiveFind(string16Long, shortSub2);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Long, shortSub2);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Long, shortSub1, 3);\n+      nResult = naiveFind(string16Long, shortSub1, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Long, shortSub1);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Medium, shortSub1, 3);\n+      nResult = naiveFind(string16Medium, shortSub1, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Medium, shortSub1);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Short, shortSub2, 1);\n+      nResult = naiveFind(string16Short, shortSub2, 1);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Short, shortSub2);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Long, searchString16, 3);\n+      nResult = naiveFind(string16Long, searchString16, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Long, searchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Medium, searchString16, 3);\n+      nResult = naiveFind(string16Medium, searchString16, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Medium, searchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Short, searchString16, 2);\n+      nResult = naiveFind(string16Short, searchString16, 2);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Short, searchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Long, searchString16);\n+      nResult = naiveFind(string16Long, searchString16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Long, searchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Medium, searchString16);\n+      nResult = naiveFind(string16Medium, searchString16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Medium, searchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Short, searchString16);\n+      nResult = naiveFind(string16Short, searchString16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Short, searchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataString, searchString, 2);\n+      nResult = naiveFind(dataString, searchString, 2);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", dataString, searchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringBig, searchStringBig, 2);\n+      nResult = naiveFind(dataStringBig, searchStringBig, 2);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", dataStringBig, searchStringBig);\n+      }\n+      {\n+        int index = 0;\n+        int dummy = 0;\n+        while ((index = indexOfKernel(data, sub, index)) > -1) {\n+          nResult = naiveFind(data, sub, index);\n+          if (index != nResult) {\n+            PrintError(stubResult, nResult, num, \"StringIndexof\", data, sub);\n+            failCount++;\n+          }\n+          index++;\n+          dummy += index;\n+        }\n+        num++;\n+      }\n+      {\n+        int dummy = 0;\n+        int index = 0;\n+        while ((index = indexOfKernel(data, shortSub1, index)) > -1) {\n+          nResult = naiveFind(data, shortSub1, index);\n+          if (index != nResult) {\n+            PrintError(stubResult, nResult, num, \"StringIndexof\", data, shortSub1);\n+            failCount++;\n+          }\n+          index++;\n+          dummy += index;\n+        }\n+        num++;\n+      }\n+      {\n+        int dummy = 0;\n+        int index = 0;\n+        while ((index = indexOfKernel(data2, shortSub2, index)) > -1) {\n+          nResult = naiveFind(data2, shortSub2, index);\n+          if (index != nResult) {\n+            PrintError(stubResult, nResult, num, \"StringIndexof\", data2, shortSub2);\n+            failCount++;\n+          }\n+          index++;\n+          dummy += index;\n+        }\n+        num++;\n+      }\n+      {\n+        String tmp = \"simple-hash:SHA-1\/UTF-8\";\n+        if (!tmp.contains(\"SHA-1\")) {\n+          PrintError(stubResult, nResult, num, \"StringIndexof\", \"simple-hash:SHA-1\/UTF-8\", \"SHA-1\");\n+          failCount++;\n+        }\n+        num++;\n+      }\n+    }\n+\n+    report(\"StringIndexof                \", failCount);\n+  }\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\n+  \/\/ From StringIndexofChar\n+  private static void StringIndexofChar() {\n+    int stubResult = 0;\n+    int failCount = 0;\n+\n+    for (int xx = 0; xx < 2; xx++) {\n+      stubResult = 0;\n+      int nResult = 0;\n+      int num = 1;\n+\n+      String[] latn1_short = new String[100];\n+      String[] latn1_sse4 = new String[100];\n+      String[] latn1_avx2 = new String[100];\n+      String[] latn1_mixedLength = new String[100];\n+      String[] utf16_short = new String[100];\n+      String[] utf16_sse4 = new String[100];\n+      String[] utf16_avx2 = new String[100];\n+      String[] utf16_mixedLength = new String[100];\n+\n+      for (int i = 0; i < 100; i++) {\n+        latn1_short[i] = makeRndString(false, 15);\n+        latn1_sse4[i] = makeRndString(false, 16);\n+        latn1_avx2[i] = makeRndString(false, 32);\n+        utf16_short[i] = makeRndString(true, 7);\n+        utf16_sse4[i] = makeRndString(true, 8);\n+        utf16_avx2[i] = makeRndString(true, 16);\n+        latn1_mixedLength[i] = makeRndString(false, rng.nextInt(65));\n+        utf16_mixedLength[i] = makeRndString(true, rng.nextInt(65));\n+      }\n+      for (String what : latn1_mixedLength) {\n+        stubResult = indexOfKernel(what, 'a');\n+        nResult = naiveFind(what, 'a');\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, 'a');\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : utf16_mixedLength) {\n+        stubResult = indexOfKernel(what, 'a');\n+        nResult = naiveFind(what, 'a');\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, 'a');\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : latn1_mixedLength) {\n+        stubResult = indexOfKernel(what, \"a\");\n+        nResult = naiveFind(what, \"a\");\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, \"a\");\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : utf16_mixedLength) {\n+        stubResult = indexOfKernel(what, \"a\");\n+        nResult = naiveFind(what, \"a\");\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, \"a\");\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : latn1_short) {\n+        stubResult = indexOfKernel(what, 'a');\n+        nResult = naiveFind(what, 'a');\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, 'a');\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : latn1_sse4) {\n+        stubResult = indexOfKernel(what, 'a');\n+        nResult = naiveFind(what, 'a');\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, 'a');\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : latn1_avx2) {\n+        stubResult = indexOfKernel(what, 'a');\n+        nResult = naiveFind(what, 'a');\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, 'a');\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : utf16_short) {\n+        stubResult = indexOfKernel(what, 'a');\n+        nResult = naiveFind(what, 'a');\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, 'a');\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : utf16_sse4) {\n+        stubResult = indexOfKernel(what, 'a');\n+        nResult = naiveFind(what, 'a');\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, 'a');\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : utf16_avx2) {\n+        stubResult = indexOfKernel(what, 'a');\n+        nResult = naiveFind(what, 'a');\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, 'a');\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : latn1_short) {\n+        stubResult = indexOfKernel(what, \"a\");\n+        nResult = naiveFind(what, \"a\");\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, \"a\");\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : latn1_sse4) {\n+        stubResult = indexOfKernel(what, \"a\");\n+        nResult = naiveFind(what, \"a\");\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, \"a\");\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : latn1_avx2) {\n+        stubResult = indexOfKernel(what, \"a\");\n+        nResult = naiveFind(what, \"a\");\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, \"a\");\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : utf16_short) {\n+        stubResult = indexOfKernel(what, \"a\");\n+        nResult = naiveFind(what, \"a\");\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, \"a\");\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : utf16_sse4) {\n+        stubResult = indexOfKernel(what, \"a\");\n+        nResult = naiveFind(what, \"a\");\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, \"a\");\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : utf16_avx2) {\n+        stubResult = indexOfKernel(what, \"a\");\n+        nResult = naiveFind(what, \"a\");\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, \"a\");\n+          failCount++;\n+        }\n+      }\n+      num++;\n+    }\n+\n+    report(\"StringIndexofChar            \", failCount);\n+  }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StringBuffer\/ECoreIndexOf.java","additions":1370,"deletions":0,"binary":false,"changes":1370,"status":"added"},{"patch":"@@ -30,0 +30,3 @@\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n@@ -34,2 +37,60 @@\n-    static Random generator = new Random();\n-    private static boolean failure = false;\n+  static Random generator = new Random();\n+  private static boolean failure = false;\n+  public static void main(String[] args) throws Exception {\n+    String testName = \"IndexOf\";\n+\n+  \/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  char[] haystack = new char[128];\n+  char[] haystack_16 = new char[128];\n+\n+  for (int i = 0; i < 128; i++) {\n+    haystack[i] = (char) i;\n+  }\n+\n+  \/\/ haystack_16[0] = (char) (23 + 256);\n+  \/\/ for (int i = 1; i < 128; i++) {\n+  \/\/   haystack_16[i] = (char) (i);\n+  \/\/ }\n+\n+  for (int i = 0; i < 128; i++) {\n+    haystack_16[i] = (char) (i + 256);\n+  }\n+\n+\n+  \/\/ Charset hs_charset = StandardCharsets.ISO_8859_1;\n+  Charset hs_charset = StandardCharsets.UTF_16;\n+  Charset needleCharset = StandardCharsets.ISO_8859_1;\n+  \/\/ Charset needleCharset = StandardCharsets.UTF_16;\n+  int l_offset = 0;\n+  int needleSize = 65;\n+  int haystackSize = 66;\n+  int result = 0;\n+\n+  String needle = new String(Arrays.copyOfRange((needleCharset == StandardCharsets.UTF_16) ? haystack_16 : haystack, l_offset, l_offset + needleSize));\n+  int hsSize = (haystackSize - l_offset) >= 0 ? haystackSize - l_offset : 0;\n+  int midStart = hsSize \/ 2;\n+  int endStart = (hsSize > needleSize) ? hsSize - needleSize : 0;\n+  String midNeedle = new String(\n+      Arrays.copyOfRange((needleCharset == StandardCharsets.UTF_16) ? haystack_16 : haystack, midStart + l_offset, midStart + needleSize + l_offset));\n+  String endNeedle = new String(\n+      Arrays.copyOfRange((needleCharset == StandardCharsets.UTF_16) ? haystack_16 : haystack, endStart + l_offset, endStart + needleSize + l_offset));\n+  \/\/ String shs = new String(Arrays.copyOfRange((hs_charset == StandardCharsets.UTF_16) ? haystack_16 : haystack, 0, haystackSize));\n+  String shs = (new String((hs_charset == StandardCharsets.UTF_16) ? haystack_16 : haystack)).substring(0, haystackSize);\n+\n+  shs = \"$&),,18+-!'8)+\";\n+  endNeedle = \"8)-\";\n+  l_offset = 9;\n+  endNeedle = \"\/'!(\\\"3\/\/\";\n+  shs = \");:(\/!-+ %*\/'!(\\\"3\/\/;9\";\n+  l_offset = 0;\n+  StringBuffer bshs = new StringBuffer(shs);\n+\n+  \/\/ printStringBytes(shs.getBytes(hs_charset));\n+  for (int i = 0; i < 200000; i++) {\n+    if(shs.indexOf(endNeedle, l_offset) != -1) {\n+      \/\/ System.out.println(\"result=\"+bshs.indexOf(endNeedle, l_offset));\n+    }\n+    result += bshs.indexOf(endNeedle, l_offset);\n+    \/\/ System.out.print(result + \" \" + needle + \" \" + shs);\n+  }\n@@ -37,4 +98,2 @@\n-    public static void main(String[] args) throws Exception {\n-        simpleTest();\n-        compareIndexOfLastIndexOf();\n-        compareStringStringBuffer();\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n@@ -42,3 +101,0 @@\n-        if (failure)\n-           throw new RuntimeException(\"One or more BitSet failures.\");\n-    }\n@@ -46,5 +102,2 @@\n-    private static void report(String testName, int failCount) {\n-        System.err.println(testName+\": \" +\n-                         (failCount==0 ? \"Passed\":\"Failed(\"+failCount+\")\"));\n-        if (failCount > 0)\n-            failure = true;\n+    for (int i = 0; i < 20000; i++) {\n+      int foo = testName.indexOf(\"dex\");\n@@ -52,10 +105,24 @@\n-\n-    private static String generateTestString(int min, int max) {\n-        StringBuffer aNewString = new StringBuffer(120);\n-        int aNewLength = getRandomIndex(min, max);\n-        for(int y=0; y<aNewLength; y++) {\n-            int achar = generator.nextInt(30)+30;\n-            char test = (char)(achar);\n-            aNewString.append(test);\n-        }\n-        return aNewString.toString();\n+    System.out.println(\"\");\n+    simpleTest();\n+    compareIndexOfLastIndexOf();\n+    compareStringStringBuffer();\n+    compareExhaustive();\n+\n+    if (failure)\n+      throw new RuntimeException(\"One or more BitSet failures.\");\n+  }\n+\n+  private static void report(String testName, int failCount) {\n+    System.err.println(testName + \": \" +\n+        (failCount == 0 ? \"Passed\" : \"Failed(\" + failCount + \")\"));\n+    if (failCount > 0)\n+      failure = true;\n+  }\n+\n+  private static String generateTestString(int min, int max) {\n+    StringBuffer aNewString = new StringBuffer(120);\n+    int aNewLength = getRandomIndex(min, max);\n+    for (int y = 0; y < aNewLength; y++) {\n+      int achar = generator.nextInt(30) + 30;\n+      char test = (char) (achar);\n+      aNewString.append(test);\n@@ -63,5 +130,20 @@\n-\n-    private static int getRandomIndex(int constraint1, int constraint2) {\n-        int range = constraint2 - constraint1;\n-        int x = generator.nextInt(range);\n-        return constraint1 + x;\n+    return aNewString.toString();\n+  }\n+\n+  private static int getRandomIndex(int constraint1, int constraint2) {\n+    int range = constraint2 - constraint1;\n+    int x = generator.nextInt(range);\n+    return constraint1 + x;\n+  }\n+\n+  private static int naiveFind(String haystack, String needle, int offset) {\n+    int x = offset;\n+    int len = haystack.length() - offset;\n+    if (needle.length() == 0)\n+      return offset;\n+    if (needle.length() > len)\n+      return -1;\n+    int hsndx = 0;\n+    int nndx = 0;\n+    for (int xx = 0; xx < offset; xx++) {\n+      hsndx += Character.charCount(haystack.codePointAt(hsndx));\n@@ -69,23 +151,12 @@\n-\n-    private static void simpleTest() {\n-        int failCount = 0;\n-        String sourceString;\n-        StringBuffer sourceBuffer;\n-        String targetString;\n-\n-        for (int i=0; i<10000; i++) {\n-            do {\n-                sourceString = generateTestString(99, 100);\n-                sourceBuffer = new StringBuffer(sourceString);\n-                targetString = generateTestString(10, 11);\n-            } while (sourceString.indexOf(targetString) != -1);\n-\n-            int index1 = generator.nextInt(90) + 5;\n-            sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n-\n-            if (sourceBuffer.indexOf(targetString) != index1)\n-                failCount++;\n-            if (sourceBuffer.indexOf(targetString, 5) != index1)\n-                failCount++;\n-            if (sourceBuffer.indexOf(targetString, 99) == index1)\n-                failCount++;\n+    \/\/ System.out.println(\"(1) hsndx=\" + hsndx);\n+    for (x = offset; x < haystack.length() - needle.length() + 1; x++) {\n+      if (haystack.codePointAt(hsndx) == needle.codePointAt(0)) {\n+        nndx = Character.charCount(needle.codePointAt(0));\n+        int hsndx_tmp = hsndx + Character.charCount(haystack.codePointAt(hsndx));;\n+        \/\/ System.out.println(\"(2) hsndx_tmp=\" + hsndx_tmp + \" nndx=\" + nndx);\n+        while (nndx < needle.length()) {\n+          if (haystack.codePointAt(hsndx_tmp) != needle.codePointAt(nndx)) {\n+            break;\n+          }\n+          hsndx_tmp += Character.charCount(haystack.codePointAt(hsndx_tmp));\n+          nndx += Character.charCount(needle.codePointAt(nndx));\n@@ -93,2 +164,5 @@\n-\n-        report(\"Basic Test                   \", failCount);\n+        if (nndx == needle.length()) {\n+          return x;\n+        }\n+      }\n+      hsndx += Character.charCount(haystack.codePointAt(hsndx));\n@@ -96,33 +170,31 @@\n-\n-    \/\/ Note: it is possible although highly improbable that failCount will\n-    \/\/ be > 0 even if everthing is working ok\n-    private static void compareIndexOfLastIndexOf() {\n-        int failCount = 0;\n-        String sourceString;\n-        StringBuffer sourceBuffer;\n-        String targetString;\n-\n-        for (int i=0; i<10000; i++) {\n-            do {\n-                sourceString = generateTestString(99, 100);\n-                sourceBuffer = new StringBuffer(sourceString);\n-                targetString = generateTestString(10, 11);\n-            } while (sourceString.indexOf(targetString) != -1);\n-\n-            int index1 = generator.nextInt(100);\n-            sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n-\n-            \/\/ extremely remote possibility of > 1 match\n-            int matches = 0;\n-            int index2 = -1;\n-            while((index2 = sourceBuffer.indexOf(targetString,index2+1)) != -1)\n-                matches++;\n-            if (matches > 1)\n-                continue;\n-\n-            if (sourceBuffer.indexOf(targetString) !=\n-                sourceBuffer.lastIndexOf(targetString))\n-                failCount++;\n-            sourceString = sourceBuffer.toString();\n-            if (sourceString.indexOf(targetString) !=\n-                sourceString.lastIndexOf(targetString))\n+    return -1;\n+  }\n+\n+  private static void compareExhaustive() {\n+    int failCount = 0;\n+    String sourceString;\n+    String targetString;\n+    int hsLen = 97;\n+    int maxNeedleLen = hsLen;\/\/ \/ 2;\n+    int haystackLen;\n+    int needleLen;\n+    int hsBegin, nBegin;\n+\n+    for (int i = 0; i < 10000; i++) {\n+      do {\n+        sourceString = generateTestString(hsLen - 1, hsLen);\n+        targetString = generateTestString(maxNeedleLen - 1, maxNeedleLen);\n+      } while (naiveFind(sourceString, targetString, 0) != -1);\n+\n+      for (haystackLen = 0; haystackLen < hsLen; haystackLen += 7) {\n+        for (needleLen = 0; (needleLen < maxNeedleLen) && (needleLen <= haystackLen); needleLen++) {\n+          for (hsBegin = 0; (hsBegin < haystackLen - needleLen) && (hsBegin + haystackLen < hsLen); hsBegin += 3) {\n+            for (nBegin = 0; (nBegin < needleLen) && (nBegin + needleLen < maxNeedleLen); nBegin += 3) {\n+              int nResult = naiveFind(sourceString.substring(hsBegin, hsBegin + haystackLen),\n+                                      targetString.substring(nBegin, nBegin + needleLen), 0);\n+              int iResult = sourceString.substring(hsBegin, hsBegin + haystackLen).indexOf(targetString.substring(nBegin, nBegin + needleLen));\n+              if (iResult != nResult) {\n+                System.out.println(\"Source=\"+sourceString.substring(hsBegin, hsBegin + haystackLen));\n+                System.out.println(\"Target=\"+targetString.substring(nBegin, nBegin + needleLen));\n+                System.out.println(\"haystackLen=\"+haystackLen+\" neeldeLen=\"+needleLen+\" hsBegin=\"+hsBegin+\" nBegin=\"+nBegin+\n+                                   \" iResult=\"+iResult+\" nResult=\"+nResult);\n@@ -130,0 +202,3 @@\n+              }\n+            }\n+          }\n@@ -131,2 +206,1 @@\n-\n-        report(\"IndexOf vs LastIndexOf       \", failCount);\n+      }\n@@ -135,31 +209,70 @@\n-    private static void compareStringStringBuffer() {\n-        int failCount = 0;\n-\n-        for (int x=0; x<10000; x++) {\n-            String testString = generateTestString(1, 100);\n-            int len = testString.length();\n-\n-            StringBuffer testBuffer = new StringBuffer(len);\n-            testBuffer.append(testString);\n-            if (!testString.equals(testBuffer.toString()))\n-                throw new RuntimeException(\"Initial equality failure\");\n-\n-            int x1 = 0;\n-            int x2 = 1000;\n-            while(x2 > testString.length()) {\n-                x1 = generator.nextInt(len);\n-                x2 = generator.nextInt(100);\n-                x2 = x1 + x2;\n-            }\n-            String fragment = testString.substring(x1,x2);\n-\n-            int sAnswer = testString.indexOf(fragment);\n-            int sbAnswer = testBuffer.indexOf(fragment);\n-\n-            if (sAnswer != sbAnswer)\n-                failCount++;\n-\n-            int testIndex = getRandomIndex(-100, 100);\n-\n-            sAnswer = testString.indexOf(fragment, testIndex);\n-            sbAnswer = testBuffer.indexOf(fragment, testIndex);\n+    report(\"Exhaustive                   \", failCount);\n+  }\n+\n+  private static void simpleTest() {\n+    int failCount = 0;\n+    String sourceString;\n+    StringBuffer sourceBuffer;\n+    String targetString;\n+    String emptyString = \"\";\n+    String allAs = new String(\"aaaaaaaaaaaaaaaaaaaaaaaaa\");\n+    StringBuffer allAsBuffer = new StringBuffer(allAs);\n+\n+    for (int i = 0; i < 10000; i++) {\n+      do {\n+        sourceString = generateTestString(99, 100);\n+        sourceBuffer = new StringBuffer(sourceString);\n+        targetString = generateTestString(10, 11);\n+      } while (sourceString.indexOf(targetString) != -1);\n+\n+      int index1 = generator.nextInt(90) + 5;\n+      sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n+\n+      if ((sourceBuffer.indexOf(targetString) != index1) ||\n+          (index1 != naiveFind(sourceBuffer.toString(), targetString, 0))) {\n+        System.err.println(\"sourceBuffer.indexOf(targetString) fragment '\" + targetString + \"' (\"\n+            + targetString.length() + \") String = \"\n+            + sourceBuffer.toString() + \" len Buffer = \" + sourceBuffer.toString().length());\n+        System.err.println(\"  naive = \" + naiveFind(sourceBuffer.toString(), targetString, 0) + \", IndexOf = \"\n+            + sourceBuffer.indexOf(targetString));\n+        failCount++;\n+      }\n+      if ((sourceBuffer.indexOf(targetString, 5) != index1) ||\n+          (index1 != naiveFind(sourceBuffer.toString(), targetString, 0))) {\n+        System.err.println(\"sourceBuffer.indexOf(targetString, 5) fragment '\" + targetString + \"' (\"\n+            + targetString.length() + \") String = \"\n+            + sourceBuffer.toString() + \" len Buffer = \" + sourceBuffer.toString().length());\n+        System.err.println(\"  naive = \" + naiveFind(sourceBuffer.toString(), targetString, 0) + \", IndexOf = \"\n+            + sourceBuffer.indexOf(targetString, 5));\n+        failCount++;\n+      }\n+      if ((sourceBuffer.indexOf(targetString, 99) == index1) ||\n+          (index1 != naiveFind(sourceBuffer.toString(), targetString, 0))) {\n+        System.err.println(\"sourceBuffer.indexOf(targetString, 99) fragment '\" + targetString + \"' (\"\n+            + targetString.length() + \") String = \"\n+            + sourceBuffer.toString() + \" len Buffer = \" + sourceBuffer.toString().length());\n+        System.err.println(\"  naive = \" + naiveFind(sourceBuffer.toString(), targetString, 0) + \", IndexOf = \"\n+            + sourceBuffer.indexOf(targetString, 99));\n+        failCount++;\n+      }\n+      if ((sourceBuffer.indexOf(emptyString, 99) != 99) ||\n+          (99 != naiveFind(sourceBuffer.toString(), emptyString, 99))) {\n+        System.err.println(\"sourceBuffer.indexOf(emptyString, 99) fragment '\" + emptyString + \"' (\"\n+            + emptyString.length() + \") String = \"\n+            + sourceBuffer.toString() + \" len Buffer = \" + sourceBuffer.toString().length());\n+        System.err.println(\"  naive = \" + naiveFind(sourceBuffer.toString(), emptyString, 99) + \", IndexOf = \"\n+            + sourceBuffer.indexOf(emptyString, 99));\n+        failCount++;\n+      }\n+      if ((allAsBuffer.substring(1, 3).indexOf(allAsBuffer.substring(5, 12)) != -1) ||\n+          (-1 != naiveFind(allAsBuffer.substring(1, 3).toString(), allAsBuffer.substring(5, 12), 0))) {\n+        System.err.println(\"allAsBuffer.substring(1, 3).indexOf(allAsBuffer.substring(5, 12)) fragment '\"\n+            + allAsBuffer.substring(5, 12) + \"' (\"\n+            + allAsBuffer.substring(5, 12).length() + \") String = \"\n+            + allAsBuffer.substring(1, 3) + \" len Buffer = \" + allAsBuffer.substring(1, 3).length());\n+        System.err.println(\n+            \"  naive = \" + naiveFind(allAsBuffer.substring(1, 3).toString(), allAsBuffer.substring(5, 12), 0)\n+                + \", IndexOf = \" + allAsBuffer.substring(1, 3).indexOf(allAsBuffer.substring(5, 12)));\n+        failCount++;\n+      }\n+    }\n@@ -167,2 +280,35 @@\n-            if (sAnswer != sbAnswer)\n-                failCount++;\n+    report(\"Basic Test                   \", failCount);\n+  }\n+\n+  \/\/ Note: it is possible although highly improbable that failCount will\n+  \/\/ be > 0 even if everthing is working ok\n+  private static void compareIndexOfLastIndexOf() {\n+    int failCount = 0;\n+    String sourceString;\n+    StringBuffer sourceBuffer;\n+    String targetString;\n+\n+    for (int i = 0; i < 10000; i++) {\n+      do {\n+        sourceString = generateTestString(99, 100);\n+        sourceBuffer = new StringBuffer(sourceString);\n+        targetString = generateTestString(10, 11);\n+      } while (sourceString.indexOf(targetString) != -1);\n+\n+      int index1 = generator.nextInt(100);\n+      sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n+\n+      \/\/ extremely remote possibility of > 1 match\n+      int matches = 0;\n+      int index2 = -1;\n+      while ((index2 = sourceBuffer.indexOf(targetString, index2 + 1)) != -1)\n+        matches++;\n+      if (matches > 1)\n+        continue;\n+\n+      if (sourceBuffer.indexOf(targetString) != sourceBuffer.lastIndexOf(targetString))\n+        failCount++;\n+      sourceString = sourceBuffer.toString();\n+      if (sourceString.indexOf(targetString) != sourceString.lastIndexOf(targetString))\n+        failCount++;\n+    }\n@@ -170,2 +316,80 @@\n-            sAnswer = testString.lastIndexOf(fragment);\n-            sbAnswer = testBuffer.lastIndexOf(fragment);\n+    report(\"IndexOf vs LastIndexOf       \", failCount);\n+  }\n+\n+  private static void compareStringStringBuffer() {\n+    int failCount = 0;\n+    boolean make_new = true;\n+\n+    String fragment = null;\n+    StringBuffer testBuffer = null;\n+    String testString = null;\n+    int testIndex = 0;\n+\n+    failCount = \"\".indexOf(\"\");\n+\n+    for (int x = 0; x < 1000000; x++) {\n+      if (make_new) {\n+        testString = \" \".repeat(1000);\n+        testString = generateTestString(1, 100);\n+        int len = testString.length();\n+\n+        testBuffer = new StringBuffer(len);\n+        testBuffer.append(testString);\n+        if (!testString.equals(testBuffer.toString()))\n+          throw new RuntimeException(\"Initial equality failure\");\n+\n+        int x1 = 0;\n+        int x2 = 1000;\n+        while (x2 > testString.length()) {\n+          x1 = generator.nextInt(len);\n+          x2 = generator.nextInt(100);\n+          x2 = x1 + x2;\n+        }\n+        fragment = \" \".repeat(1000);\n+        fragment = new String(testString.substring(x1, x2));\n+      }\n+\n+      int sAnswer = testString.indexOf(fragment);\n+      int sbAnswer = testBuffer.indexOf(fragment);\n+\n+      if (sAnswer != sbAnswer) {\n+        System.err.println(\"(1) IndexOf fragment '\" + fragment + \"' (\" + fragment.length() + \") len String = \"\n+            + testString.length() + \" len Buffer = \" + testBuffer.length());\n+        System.err.println(\"  sAnswer = \" + sAnswer + \", sbAnswer = \" + sbAnswer);\n+        System.err.println(\"  testString = '\" + testString + \"'\");\n+        System.err.println(\"  testBuffer = '\" + testBuffer + \"'\");\n+        failCount++;\n+      } else {\n+        if (sAnswer > testString.length()) {\n+          System.err.println(\n+              \"IndexOf returned value out of range; return: \" + sAnswer + \" length max: \" + testBuffer.length());\n+        }\n+      }\n+\n+      if ((fragment == \"0#:02\/62;+-\\\"\\\"0$25-5$#)1263\") && (testBuffer.length() == 94)) {\n+        String xx = \"abc\";\n+        String yy = \"abcdefg\";\n+        int sA = xx.indexOf(yy);\n+      }\n+\n+      if (make_new) testIndex = getRandomIndex(-100, 100);\n+\n+      sAnswer = testString.indexOf(fragment, testIndex);\n+      sbAnswer = testBuffer.indexOf(fragment, testIndex);\n+\n+      if (sAnswer != sbAnswer) {\n+        System.err.println(\"(2) IndexOf fragment '\" + fragment + \"' (\" + fragment.length() + \") index = \" + testIndex\n+            + \" len String = \" + testString.length() + \" len Buffer = \" + testBuffer.length());\n+        System.err.println(\"  sAnswer = \" + sAnswer + \", sbAnswer = \" + sbAnswer);\n+        System.err.println(\"  testString = '\" + testString + \"'\");\n+        System.err.println(\"  testBuffer = '\" + testBuffer + \"'\");\n+        failCount++;\n+        make_new = false;\n+      } else {\n+        if ((sAnswer > testString.length()) || ((sAnswer != -1) && (sAnswer < testIndex) && (fragment.length() != 0))) {\n+          System.err.println(\"IndexOf returned value out of range; return: \" + sAnswer + \" length max: \"\n+              + testString.length() + \" index: \" + testIndex);\n+          System.err.println(\"(3) IndexOf fragment '\" + fragment + \"' (\" + fragment.length() + \") index = \" + testIndex\n+              + \" len String = \" + testString.length() + \" len Buffer = \" + testBuffer.length());\n+        }\n+      }\n@@ -173,2 +397,2 @@\n-            if (sAnswer != sbAnswer)\n-                failCount++;\n+      sAnswer = testString.lastIndexOf(fragment);\n+      sbAnswer = testBuffer.lastIndexOf(fragment);\n@@ -176,1 +400,6 @@\n-            testIndex = getRandomIndex(-100, 100);\n+      if (sAnswer != sbAnswer) {\n+        System.err.println(\"(1) lastIndexOf fragment '\" + fragment + \"' len String = \" + testString.length()\n+            + \" len Buffer = \" + testBuffer.length());\n+        System.err.println(\"  sAnswer = \" + sAnswer + \", sbAnswer = \" + sbAnswer);\n+        failCount++;\n+      }\n@@ -178,2 +407,1 @@\n-            sAnswer = testString.lastIndexOf(fragment, testIndex);\n-            sbAnswer = testBuffer.lastIndexOf(fragment, testIndex);\n+      if (make_new) testIndex = getRandomIndex(-100, 100);\n@@ -181,3 +409,2 @@\n-            if (sAnswer != sbAnswer)\n-                failCount++;\n-        }\n+      sAnswer = testString.lastIndexOf(fragment, testIndex);\n+      sbAnswer = testBuffer.lastIndexOf(fragment, testIndex);\n@@ -185,1 +412,5 @@\n-        report(\"String vs StringBuffer       \", failCount);\n+      if (sAnswer != sbAnswer) {\n+        System.err.println(\"(2) lastIndexOf fragment '\" + fragment + \"' index = \" + testIndex + \" len String = \"\n+            + testString.length() + \" len Buffer = \" + testBuffer.length());\n+        failCount++;\n+      }\n@@ -188,0 +419,3 @@\n+    report(\"String vs StringBuffer       \", failCount);\n+  }\n+\n","filename":"test\/jdk\/java\/lang\/StringBuffer\/IndexOf.java","additions":367,"deletions":133,"binary":false,"changes":500,"status":"modified"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class StringIndexOfHuge {\n+\n+  private String dataString;\n+  private String dataString16;\n+  private String dataStringHuge;\n+  private String dataStringHuge16;\n+  private String earlyMatchString;\n+  private String earlyMatchString16;\n+  private String midMatchString;\n+  private String midMatchString16;\n+  private String lateMatchString;\n+  private String lateMatchString16;\n+\n+  private String searchString;\n+  private String searchString16;\n+  private String searchStringSmall;\n+  private String searchStringSmall16;\n+\n+  private String searchStringHuge;\n+  private String searchStringHuge16;\n+\n+  private String searchNoMatch;\n+  private String searchNoMatch16;\n+\n+  @Setup\n+  public void setup() {\n+    dataString = \"ngdflsoscargfdgf\";\n+    dataString16 = \"ngdfilso\\u01facargfd\\u01eef\";\n+    dataStringHuge = ((\"A\".repeat(32) + \"B\".repeat(32)).repeat(16) + \"X\").repeat(2) + \"bB\";\n+    dataStringHuge16 = \"\\u01de\" + ((\"A\".repeat(32) + \"B\".repeat(32)).repeat(16) + \"\\u01fe\").repeat(2) + \"\\u01eeB\";\n+    earlyMatchString = dataStringHuge.substring(0, 34);\n+    earlyMatchString16 = dataStringHuge16.substring(0, 34);\n+    midMatchString = dataStringHuge.substring(dataStringHuge.length() \/ 2 - 16, dataStringHuge.length() \/ 2 + 17);\n+    midMatchString16 = dataStringHuge16.substring(dataStringHuge16.length() \/ 2 - 16, dataStringHuge16.length() \/ 2 + 17);\n+    lateMatchString = dataStringHuge.substring(dataStringHuge.length() - 31);\n+    lateMatchString16 = dataStringHuge16.substring(dataStringHuge16.length() - 31);\n+\n+    searchString = \"oscar\";\n+    searchString16 = \"o\\u01facar\";\n+    searchStringSmall = \"dgf\";\n+    searchStringSmall16 = \"d\\u01eef\";\n+\n+    searchStringHuge = \"capaapapapasdkajdlkajskldjaslkajdlkajskldjaslkjdlkasjdsalk\";\n+    searchStringHuge16 = \"capaapapapasdkajdlka\\u01feskldjaslkajdlkajskldjaslkjdlkasjdsalk\";\n+\n+    searchNoMatch = \"XYXyxYxy\".repeat(22);\n+    searchNoMatch16 = \"\\u01ab\\u01ba\\u01cb\\u01bc\\u01de\\u01ed\\u01fa\\u01af\".repeat(22);\n+  }\n+\n+\n+  \/** IndexOf Micros *\/\n+  @Benchmark\n+  public int searchHugeEarlyMatch() {\n+      return dataStringHuge.indexOf(earlyMatchString);\n+  }\n+\n+  @Benchmark\n+  public int searchHugeMiddleMatch() {\n+      return dataStringHuge.indexOf(midMatchString);\n+  }\n+\n+  @Benchmark\n+  public int searchHugeLateMatch() {\n+      return dataStringHuge.indexOf(lateMatchString);\n+  }\n+\n+  @Benchmark\n+  public int searchHugeNoMatch() {\n+      return dataStringHuge.indexOf(searchNoMatch);\n+  }\n+\n+  @Benchmark\n+  public int searchSmallEarlyMatch() {\n+      return searchString.indexOf(searchString);\n+  }\n+\n+  @Benchmark\n+  public int searchSmallMidMatch() {\n+      return dataString.indexOf(searchString);\n+  }\n+\n+  @Benchmark\n+  public int searchSmallLateMatch() {\n+      return dataString.indexOf(searchStringSmall);\n+  }\n+\n+  @Benchmark\n+  public int searchHugeLargeSubstring() {\n+      return dataStringHuge.indexOf(\"B\".repeat(30) + \"X\" + \"A\".repeat(30), 74);\n+  }\n+\n+  @Benchmark\n+  public int searchHugeLargeSubstringNoMatch() {\n+      return dataStringHuge.indexOf(\"A\".repeat(32) + \"F\" + \"B\".repeat(32), 64);\n+  }\n+\n+  @Benchmark\n+  public int searchSubstringLongerThanString() {\n+      return midMatchString.indexOf(dataStringHuge, 3);\n+  }\n+\n+  @Benchmark\n+  public int searchHugeWorstCase() {\n+      return dataStringHuge.indexOf(\"A\".repeat(32) + \"B\".repeat(32) + \"XbB\");\n+  }\n+\n+  @Benchmark\n+  public int search16HugeEarlyMatch() {\n+    return dataStringHuge16.indexOf(earlyMatchString);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeMiddleMatch() {\n+    return dataStringHuge16.indexOf(midMatchString);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeLateMatch() {\n+    return dataStringHuge16.indexOf(lateMatchString);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeNoMatch() {\n+    return dataStringHuge16.indexOf(searchNoMatch);\n+  }\n+\n+  @Benchmark\n+  public int search16SmallEarlyMatch() {\n+    return searchString16.indexOf(searchString);\n+  }\n+\n+  @Benchmark\n+  public int search16SmallMidMatch() {\n+    return dataString16.indexOf(searchString);\n+  }\n+\n+  @Benchmark\n+  public int search16SmallLateMatch() {\n+    return dataString16.indexOf(searchStringSmall);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeLargeSubstring() {\n+    return dataStringHuge16.indexOf(\"B\".repeat(30) + \"X\" + \"A\".repeat(30), 74);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeLargeSubstringNoMatch() {\n+    return dataStringHuge16.indexOf(\"A\".repeat(32) + \"F\" + \"B\".repeat(32), 64);\n+  }\n+\n+  @Benchmark\n+  public int search16SubstringLongerThanString() {\n+    return midMatchString16.indexOf(dataStringHuge, 3);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeWorstCase() {\n+    return dataStringHuge16.indexOf(\"A\".repeat(32) + \"B\".repeat(32) + \"XbB\");\n+  }\n+\n+  @Benchmark\n+  public int search16HugeEarlyMatch16() {\n+    return dataStringHuge16.indexOf(earlyMatchString16);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeMiddleMatch16() {\n+    return dataStringHuge16.indexOf(midMatchString16);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeLateMatch16() {\n+    return dataStringHuge16.indexOf(lateMatchString16);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeNoMatch16() {\n+    return dataStringHuge16.indexOf(searchNoMatch16);\n+  }\n+\n+  @Benchmark\n+  public int search16SmallEarlyMatch16() {\n+    return searchString16.indexOf(searchString16);\n+  }\n+\n+  @Benchmark\n+  public int search16SmallMidMatch16() {\n+    return dataString16.indexOf(searchString16);\n+  }\n+\n+  @Benchmark\n+  public int search16SmallLateMatch16() {\n+    return dataString16.indexOf(searchStringSmall16);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeLargeSubstring16() {\n+    return dataStringHuge16.indexOf(\"B\".repeat(30) + \"X\" + \"A\".repeat(30), 74);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeLargeSubstringNoMatch16() {\n+    return dataStringHuge16.indexOf(\"A\".repeat(32) + \"\\u01ef\" + \"B\".repeat(32), 64);\n+  }\n+\n+  @Benchmark\n+  public int search16SubstringLongerThanString16() {\n+    return midMatchString16.indexOf(dataStringHuge16, 3);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeWorstCase16() {\n+    return dataStringHuge16.indexOf(\"A\".repeat(32) + \"B\".repeat(32) + \"\\u01fe\\u01eeB\");\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringIndexOfHuge.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"}]}