{"files":[{"patch":"@@ -4494,1 +4494,3 @@\n-                                      XMMRegister vec1, XMMRegister vec2, bool is_char, KRegister mask) {\n+                                      XMMRegister vec1, XMMRegister vec2, bool is_char,\n+                                      KRegister mask, bool expand_ary2) {\n+  \/\/ for expand_ary2, limit is the (smaller) size of the second array.\n@@ -4498,0 +4500,3 @@\n+  assert((!expand_ary2) || ((expand_ary2) && (UseAVX == 2)),\n+         \"Expansion only implemented for AVX2\");\n+\n@@ -4501,0 +4506,3 @@\n+  Address::ScaleFactor scaleFactor = expand_ary2 ? Address::times_2 : Address::times_1;\n+  int scaleIncr = expand_ary2 ? 8 : 16;\n+\n@@ -4536,1 +4544,1 @@\n-    Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n+    Label COMPARE_WIDE_VECTORS, COMPARE_WIDE_VECTORS_16, COMPARE_TAIL, COMPARE_TAIL_16;\n@@ -4539,3 +4547,9 @@\n-    andl(result, 0x0000001f);  \/\/   tail count (in bytes)\n-    andl(limit, 0xffffffe0);   \/\/ vector count (in bytes)\n-    jcc(Assembler::zero, COMPARE_TAIL);\n+    if (expand_ary2) {\n+      andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n+      andl(limit, 0xfffffff0);   \/\/ vector count (in bytes)\n+      jcc(Assembler::zero, COMPARE_TAIL);\n+    } else {\n+      andl(result, 0x0000001f);  \/\/   tail count (in bytes)\n+      andl(limit, 0xffffffe0);   \/\/ vector count (in bytes)\n+      jcc(Assembler::zero, COMPARE_TAIL_16);\n+    }\n@@ -4543,1 +4557,1 @@\n-    lea(ary1, Address(ary1, limit, Address::times_1));\n+    lea(ary1, Address(ary1, limit, scaleFactor));\n@@ -4586,2 +4600,6 @@\n-    vmovdqu(vec1, Address(ary1, limit, Address::times_1));\n-    vmovdqu(vec2, Address(ary2, limit, Address::times_1));\n+    vmovdqu(vec1, Address(ary1, limit, scaleFactor));\n+    if (expand_ary2) {\n+      vpmovzxbw(vec2, Address(ary2, limit, Address::times_1), Assembler::AVX_256bit);\n+    } else {\n+      vmovdqu(vec2, Address(ary2, limit, Address::times_1));\n+    }\n@@ -4592,1 +4610,1 @@\n-    addptr(limit, 32);\n+    addptr(limit, scaleIncr * 2);\n@@ -4598,2 +4616,6 @@\n-    vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));\n-    vmovdqu(vec2, Address(ary2, result, Address::times_1, -32));\n+    vmovdqu(vec1, Address(ary1, result, scaleFactor, -32));\n+    if (expand_ary2) {\n+      vpmovzxbw(vec2, Address(ary2, result, Address::times_1, -16), Assembler::AVX_256bit);\n+    } else {\n+      vmovdqu(vec2, Address(ary2, result, Address::times_1, -32));\n+    }\n@@ -4603,2 +4625,28 @@\n-    jccb(Assembler::notZero, FALSE_LABEL);\n-    jmpb(TRUE_LABEL);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    jmp(TRUE_LABEL);\n+\n+    bind(COMPARE_TAIL_16); \/\/ limit is zero\n+    movl(limit, result);\n+\n+    \/\/ Compare 16-byte chunks\n+    andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n+    andl(limit, 0xfffffff0);   \/\/ vector count (in bytes)\n+    jcc(Assembler::zero, COMPARE_TAIL);\n+\n+    lea(ary1, Address(ary1, limit, scaleFactor));\n+    lea(ary2, Address(ary2, limit, Address::times_1));\n+    negptr(limit);\n+\n+    bind(COMPARE_WIDE_VECTORS_16);\n+    movdqu(vec1, Address(ary1, limit, scaleFactor));\n+    if (expand_ary2) {\n+      vpmovzxbw(vec2, Address(ary2, limit, Address::times_1), Assembler::AVX_128bit);\n+    } else {\n+      movdqu(vec2, Address(ary2, limit, Address::times_1));\n+    }\n+    pxor(vec1, vec2);\n+\n+    ptest(vec1, vec1);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    addptr(limit, scaleIncr);\n+    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS_16);\n@@ -4649,2 +4697,7 @@\n-  andl(limit, 0xfffffffc); \/\/ vector count (in bytes)\n-  jccb(Assembler::zero, COMPARE_CHAR);\n+  if (expand_ary2) {\n+    testl(result, result);\n+    jccb(Assembler::zero, TRUE_LABEL);\n+  } else {\n+    andl(limit, 0xfffffffc); \/\/ vector count (in bytes)\n+    jccb(Assembler::zero, COMPARE_CHAR);\n+  }\n@@ -4652,1 +4705,1 @@\n-  lea(ary1, Address(ary1, limit, Address::times_1));\n+  lea(ary1, Address(ary1, limit, scaleFactor));\n@@ -4657,5 +4710,15 @@\n-  movl(chr, Address(ary1, limit, Address::times_1));\n-  cmpl(chr, Address(ary2, limit, Address::times_1));\n-  jccb(Assembler::notEqual, FALSE_LABEL);\n-  addptr(limit, 4);\n-  jcc(Assembler::notZero, COMPARE_VECTORS);\n+  if (expand_ary2) {\n+    \/\/ There are no \"vector\" operations for bytes to shorts\n+    movzbl(chr, Address(ary2, limit, Address::times_1));\n+    cmpw(Address(ary1, limit, Address::times_2), chr);\n+    jccb(Assembler::notEqual, FALSE_LABEL);\n+    addptr(limit, 1);\n+    jcc(Assembler::notZero, COMPARE_VECTORS);\n+    jmp(TRUE_LABEL);\n+  } else {\n+    movl(chr, Address(ary1, limit, Address::times_1));\n+    cmpl(chr, Address(ary2, limit, Address::times_1));\n+    jccb(Assembler::notEqual, FALSE_LABEL);\n+    addptr(limit, 4);\n+    jcc(Assembler::notZero, COMPARE_VECTORS);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":84,"deletions":21,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -292,0 +292,1 @@\n+\n@@ -293,3 +294,3 @@\n-  void arrays_equals(bool is_array_equ, Register ary1, Register ary2,\n-                     Register limit, Register result, Register chr,\n-                     XMMRegister vec1, XMMRegister vec2, bool is_char, KRegister mask = knoreg);\n+  void arrays_equals(bool is_array_equ, Register ary1, Register ary2, Register limit,\n+                     Register result, Register chr, XMMRegister vec1, XMMRegister vec2,\n+                     bool is_char, KRegister mask = knoreg, bool expand_ary2 = false);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,1837 @@\n+\/*\n+ * Copyright (c) 2023, 2024 Intel Corporation. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+#include \"opto\/c2_MacroAssembler.hpp\"\n+#include \"opto\/intrinsicnode.hpp\"\n+\n+\/******************************************************************************\/\n+\/\/                     String handling intrinsics\n+\/\/                     --------------------------\n+\/\/\n+\/\/ Currently implements scheme described in http:\/\/0x80.pl\/articles\/simd-strfind.html\n+\/\/ Implementation can be found at https:\/\/github.com\/WojciechMula\/sse4-strstr\n+\/\/\n+\/\/ The general idea is as follows:\n+\/\/ 1. Broadcast the first byte of the needle to a ymm register (32 bytes)\n+\/\/ 2. Broadcast the last byte of the needle to a different ymm register\n+\/\/ 3. Compare the first-byte ymm register to the first 32 bytes of the haystack\n+\/\/ 4. Compare the last-byte register to the 32 bytes of the haystack at the (k-1)st position\n+\/\/    where k is the length of the needle\n+\/\/ 5. Logically AND the results of the comparison\n+\/\/\n+\/\/ The result of the AND yields the position within the haystack where both the first\n+\/\/ and last bytes of the needle exist in their correct relative positions.  Check the full\n+\/\/ needle value against the haystack to confirm a match.\n+\/\/\n+\/\/ This implementation uses memcmp to compare when the size of the needle is >= 32 bytes.\n+\/\/ For other needle sizes, the comparison is done with register compares to eliminate the\n+\/\/ overhead of the call (including range checks, etc.).  The size of the comparison is\n+\/\/ known, and it is also known to be safe reading the haystack for the full width of the needle.\n+\/\/\n+\/\/ The original algorithm as implemented will potentially read past the end of the haystack.\n+\/\/ This implementation protects against that.  Instead of reading as many 32-byte chunks as\n+\/\/ possible and then handling the tail, we calculate the last position of a vaild 32-byte\n+\/\/ read and adjust the starting position of the second read such that the last read will not\n+\/\/ go beyond the end of the haystack.  So the first comparison is to the first 32 bytes of the\n+\/\/ haystack, and the second is offset by an amount to make the last read legal.  The remainder of\n+\/\/ the comparisons are done incrementing by 32 bytes.\n+\/\/\n+\/\/ This will cause 16 bytes on average to be examined twice, but that is cheaper than the\n+\/\/ logic required for tail processing.\n+\/\/\n+\/******************************************************************************\/\n+\n+#define __ _masm->\n+#define __C2 ((C2_MacroAssembler *) _masm)->\n+\n+\/\/ Register definitions for consistency\n+\/\/ These registers can be counted on to always contain\n+\/\/ the correct values (once set up)\n+#define XMM_BYTE_0 xmm0\n+#define XMM_BYTE_K xmm1\n+#define XMM_BYTE_1 xmm12\n+#define save_r12 xmm4\n+#define save_r13 xmm5\n+#define save_r14 xmm6\n+#define save_r15 xmm7\n+#define save_rbx xmm8\n+#define nMinusK r10\n+\n+\/\/ Global temporary xmm registers\n+#define XMM_TMP1 xmm15\n+#define XMM_TMP2 xmm14\n+#define XMM_TMP3 xmm2\n+#define XMM_TMP4 xmm3\n+\n+\/\/  This macro handles clearing the bits of the mask register depending\n+\/\/  on whether we're comparing bytes or words.\n+#define CLEAR_BIT(mask) \\\n+  if (isU) {                 \\\n+    __ blsrl(mask, mask);     \\\n+    __ blsrl(mask, mask);     \\\n+  } else {                   \\\n+    __ blsrl(mask, mask);    \\\n+  }\n+\n+#define NUMBER_OF_CASES 10\n+\n+#undef STACK_SPACE\n+#undef MAX_NEEDLE_LEN_TO_EXPAND\n+#define MAX_NEEDLE_LEN_TO_EXPAND 0x28\n+\n+\/\/ Stack layout:\n+#  define COPIED_HAYSTACK_STACK_OFFSET (0x0)  \/\/ MUST BE ZERO!\n+#  define COPIED_HAYSTACK_STACK_SIZE (64)     \/\/ MUST BE 64!\n+\n+#  define EXPANDED_NEEDLE_STACK_OFFSET (COPIED_HAYSTACK_STACK_OFFSET + COPIED_HAYSTACK_STACK_SIZE)\n+#  define EXPANDED_NEEDLE_STACK_SIZE (MAX_NEEDLE_LEN_TO_EXPAND * 2 + 32)\n+\n+#  define SAVED_HAYSTACK_STACK_OFFSET (EXPANDED_NEEDLE_STACK_OFFSET + EXPANDED_NEEDLE_STACK_SIZE)\n+#  define SAVED_HAYSTACK_STACK_SIZE (8)\n+\n+#  define SAVED_INCREMENT_STACK_OFFSET (SAVED_HAYSTACK_STACK_OFFSET + SAVED_HAYSTACK_STACK_SIZE)\n+#  define SAVED_INCREMENT_STACK_SIZE (8)\n+\n+#  define SAVED_TERM_ADDR_STACK_OFFSET (SAVED_INCREMENT_STACK_OFFSET + SAVED_INCREMENT_STACK_SIZE)\n+#  define SAVED_TERM_ADDR_STACK_SIZE (8)\n+\n+#  define STACK_SPACE                                                                                                  \\\n+    (COPIED_HAYSTACK_STACK_SIZE + EXPANDED_NEEDLE_STACK_SIZE + SAVED_HAYSTACK_STACK_SIZE + SAVED_INCREMENT_STACK_SIZE  \\\n+     + SAVED_TERM_ADDR_STACK_SIZE)\n+\n+\/\/ Forward declarations for helper functions\n+static void broadcast_additional_needles(bool sizeKnown, int size, Register needle,\n+                                         Register needleLen, Register rTmp,\n+                                         StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm);\n+\n+static void broadcast_first_and_last_needle(Register needle, Register needle_len, Register rTmp,\n+                                            StrIntrinsicNode::ArgEncoding ae,\n+                                            MacroAssembler *_masm);\n+\n+static void compare_big_haystack_to_needle(bool sizeKnown, int size, Label &noMatch,\n+                                           Register haystack, Register needleLen, Register eq_mask,\n+                                           XMMRegister rxTmp1, XMMRegister rxTmp2,\n+                                           XMMRegister rxTmp3, StrIntrinsicNode::ArgEncoding ae,\n+                                           MacroAssembler *_masm);\n+\n+static void compare_haystack_to_needle(bool sizeKnown, int size, Label &noMatch, Register haystack,\n+                                       Register eq_mask, Register needleLen, Register rTmp,\n+                                       XMMRegister rxTmp1, XMMRegister rxTmp2,\n+                                       StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm);\n+\n+static void big_case_loop_helper(bool sizeKnown, int size, Label &noMatch, Label &loop_top,\n+                                 Register eq_mask, Register hsPtrRet, Register needleLen,\n+                                 Register needle, Register haystack, Register hsLength,\n+                                 Register rTmp1, Register rTmp2, Register rTmp3, Register rTmp4,\n+                                 StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm);\n+\n+static void byte_compare_helper(int size, Label &L_noMatch, Label &L_matchFound, Register needle,\n+                                Register needleVal, Register haystack, Register mask,\n+                                Register foundIndex, Register tmp, StrIntrinsicNode::ArgEncoding ae,\n+                                MacroAssembler *_masm);\n+\n+static void highly_optimized_short_cases(StrIntrinsicNode::ArgEncoding ae, Register haystack,\n+                                         Register haystack_len, Register needle,\n+                                         Register needle_len, XMMRegister XMM0, XMMRegister XMM1,\n+                                         Register mask, Register tmp, MacroAssembler *_masm);\n+\n+static void setup_jump_tables(StrIntrinsicNode::ArgEncoding ae, Label &L_error, Label &L_checkRange,\n+                              Label &L_fixup, address *big_jump_table, address *small_jump_table,\n+                              MacroAssembler *_masm);\n+\n+static void vpcmpeq(XMMRegister dst, XMMRegister src, Address adr, int vector_len,\n+                    StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm) {\n+  if ((ae == StrIntrinsicNode::UL) || (ae == StrIntrinsicNode::UU)) {\n+      __ vpcmpeqw(dst, src, adr, vector_len);\n+  } else {\n+      __ vpcmpeqb(dst, src, adr, vector_len);\n+  }\n+}\n+\n+static void generate_string_indexof_stubs(StubGenerator *stubgen, address *fnptrs,\n+                                          StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm);\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/                         Start of generator\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+void StubGenerator::generate_string_indexof(address *fnptrs) {\n+  assert((int) StrIntrinsicNode::LL < 4, \"Enum out of range\");\n+  assert((int) StrIntrinsicNode::UL < 4, \"Enum out of range\");\n+  assert((int) StrIntrinsicNode::UU < 4, \"Enum out of range\");\n+  generate_string_indexof_stubs(this, fnptrs, StrIntrinsicNode::LL, _masm);\n+  generate_string_indexof_stubs(this, fnptrs, StrIntrinsicNode::UU, _masm);\n+  generate_string_indexof_stubs(this, fnptrs, StrIntrinsicNode::UL, _masm);\n+  assert(fnptrs[StrIntrinsicNode::LL] != nullptr, \"LL not generated.\");\n+  assert(fnptrs[StrIntrinsicNode::UL] != nullptr, \"UL not generated.\");\n+  assert(fnptrs[StrIntrinsicNode::UU] != nullptr, \"UU not generated.\");\n+}\n+\n+static void generate_string_indexof_stubs(StubGenerator *stubgen, address *fnptrs,\n+                                          StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm) {\n+  StubCodeMark mark(stubgen, \"StubRoutines\", \"stringIndexOf\");\n+  bool isLL = (ae == StrIntrinsicNode::LL);\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = isUL || isUU;  \/\/ At least one is UTF-16\n+  assert(isLL || isUL || isUU, \"Encoding not recognized\");\n+\n+  \/\/ Keep track of isUL since we need to generate UU code in the main body\n+  \/\/ for the case where we expand the needle from bytes to words on the stack.\n+  \/\/ This is done at L_wcharBegin.  The algorithm used is:\n+  \/\/  If the encoding is UL and the needle size is <= MAX_NEEDLE_LEN_TO_EXPAND,\n+  \/\/  allocate space on the stack and expand the Latin-1 encoded needle.  Then\n+  \/\/  effectively \"recurse\" into the mainline using UU encoding (since both the\n+  \/\/  haystack and needle are now UTF-16 encoded).\n+  bool isReallyUL = isUL;\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/                         AVX2 code\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  assert(VM_Version::supports_avx2(), \"Needs AVX2\");\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/                         Code generation explanation:\n+  \/\/\n+  \/\/  The generator will generate code for three cases:\n+  \/\/  1. Both needle and haystack are Latin-1 (single byte) encoded (LL)\n+  \/\/  2. Both the needle and haystack are UTF-16 encoded (two bytes per character) (UU)\n+  \/\/  3. The haystack is UTF-16 encoded and the needle is Latin-1 encoded (UL)\n+  \/\/\n+  \/\/  The case of the haystack being Latin-1 and the needle being UTF-16 is short-circuited\n+  \/\/  so that we never get called in this case.\n+  \/\/\n+  \/\/  For the UL case (haystack UTF-16 and needle Latin-1), the needle will be expanded\n+  \/\/  onto the stack (for size <= MAX_NEEDLE_LEN_TO_EXPAND) and the UU code will do the work.\n+  \/\/  For UL where the needle size is > MAX_NEEDLE_LEN_TO_EXPAND and the haystack size minus\n+  \/\/  the needle size is less than 32 bytes, we default to a\n+  \/\/  byte-by-byte comparison (this will be rare).\n+  \/\/\n+  \/\/  Note that the code assumes MAX_NEEDLE_LEN_TO_EXPAND is >= 32.\n+  \/\/\n+  \/\/  The UU and LL cases are identical except for the loop increments and loading\n+  \/\/  of the characters into registers.  UU loads and compares words, LL - bytes.\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  const Register haystack_p     = c_rarg0;\n+  const Register haystack_len_p = c_rarg1;\n+  const Register needle_p       = c_rarg2;\n+  const Register needle_len_p   = c_rarg3;\n+\n+  \/\/ Addresses of the two jump tables used for small needle processing\n+  address big_jump_table;\n+  address small_jump_table;\n+\n+  Label L_begin;\n+\n+  Label L_returnError, L_bigCaseFixupAndReturn;\n+  Label L_bigSwitchTop, L_bigCaseDefault, L_smallCaseDefault;\n+  Label L_nextCheck, L_checksPassed, L_return;\n+  Label L_wcharBegin, L_continue, L_wideNoExpand, L_returnR11;\n+\n+  __ align(CodeEntryAlignment);\n+  fnptrs[ae] = __ pc();\n+  __ enter();  \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/ Check for trivial cases\n+  \/\/ needle length == 0?\n+  __ cmpq(needle_len_p, 0);\n+  __ jg_b(L_nextCheck);\n+  __ xorl(rax, rax);\n+  __ leave();\n+  __ ret(0);\n+\n+  __ bind(L_nextCheck);\n+  \/\/ haystack length >= needle length?\n+  __ movq(rax, haystack_len_p);\n+  __ subq(rax, needle_len_p);\n+  __ jge_b(L_checksPassed);\n+\n+  __ movq(rax, -1);\n+  __ leave();\n+  __ ret(0);\n+\n+  __ bind(L_checksPassed);\n+\n+  \/\/ Check for highly-optimized ability - haystack <= 32 bytes and needle <= 6 bytes\n+  \/\/ haystack_len is in elements, not bytes, for UTF-16\n+  __ cmpq(haystack_len_p, isU ? 16 : 32);\n+  __ ja(L_begin);\n+\n+  \/\/ needle_len is in elements, not bytes, for UTF-16 <=> UTF-16\n+  __ cmpq(needle_len_p, isUU ? 3 : 6);\n+  __ ja(L_begin);\n+\n+  \/\/ Handle short haystack and needle specially\n+  \/\/ Generated code does not return - either found or not\n+  highly_optimized_short_cases(ae, haystack_p, haystack_len_p, needle_p, needle_len_p, xmm0, xmm1,\n+                               r10, r11, _masm);\n+\n+  \/\/ If we're generating UL, we need to \"pretend\" we're generating UU code\n+  \/\/ for the case where the needle can be expanded onto the stack\n+  if (isReallyUL) {\n+    ae = StrIntrinsicNode::UU;\n+    isUL = false;\n+    isUU = true;\n+  }\n+\n+  \/\/ Set up jump tables.  Used when needle size <= NUMBER_OF_CASES\n+  setup_jump_tables(ae, L_returnError, L_returnR11, L_bigCaseFixupAndReturn, &big_jump_table,\n+                    &small_jump_table, _masm);\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\n+  \/\/ The above code handles all cases (LL, UL, UU) for haystack size <= 32 bytes\n+  \/\/ and needle size <= 6 bytes.\n+  \/\/\n+  \/\/ Main processing proceeds as follows:\n+  \/\/  Save state and setup stack, etc.\n+  \/\/  If UL, jump to code to handle special-case UL situations (see L_wcharBegin below)\n+  \/\/  Broadcast the first and last needle elements to XMM_BYTE_0 and XMM_BYTE_K, respectively\n+  \/\/  If the length in bytes of the haystack is > 32, dispatch to the big switch handling code\n+  \/\/  If the haystack length in bytes is <= 32:\n+  \/\/    Copy the haystack to the stack.  This is done to prevent possible page faults and\n+  \/\/      allows for reading full 32-byte chunks of the haystack.\n+  \/\/    Dispatch to the small switch handling code\n+  \/\/\n+  \/\/ Here, \"big switch\" and \"small switch\" refers to the haystack size: > 32 bytes for big\n+  \/\/ and <= 32 bytes for small.  The switches implement optimized code for handling 1 to\n+  \/\/ NUMBER_OF_CASES (currently 10) needle sizes for both big and small.  There are special\n+  \/\/ routines for handling needle sizes > NUMBER_OF_CASES (L_{big,small}CaseDefault).  These\n+  \/\/ cases use C@'s arrays_equals() to compare the needle to the haystack.  The small cases\n+  \/\/ use specialized code for comparing the needle.\n+  \/\/\n+  \/\/ The algorithm currently does vector comparisons for the first, last, and second bytes\n+  \/\/ of the needle and, where each of these needle elements matches the correct position\n+  \/\/ within the haystack, the \"in-between\" bytes are compared using the most efficient\n+  \/\/ instructions possible for short needles, or C2's arrays_equals for longer needles.\n+\n+  __ align(CodeEntryAlignment);\n+\n+  __ bind(L_begin);\n+  __ movdq(save_r12, r12);\n+  __ movdq(save_r13, r13);\n+  __ movdq(save_r14, r14);\n+  __ movdq(save_r15, r15);\n+  __ movdq(save_rbx, rbx);\n+#ifdef _WIN64\n+  __ push(rsi);\n+  __ push(rdi);\n+\n+  \/\/ Move to Linux-style ABI\n+  __ movq(rdi, rcx);\n+  __ movq(rsi, rdx);\n+  __ movq(rdx, r8);\n+  __ movq(rcx, r9);\n+#endif\n+\n+  const Register haystack     = rdi;\n+  const Register haystack_len = rsi;\n+  const Register needle       = rdx;\n+  const Register needle_len   = rcx;\n+  const Register save_ndl_len = r12;\n+\n+  __ push(rbp);\n+  __ subptr(rsp, STACK_SPACE);\n+\n+  if (isReallyUL) {\n+    \/\/ Branch out if doing UL\n+    __ jmp(L_wcharBegin);\n+  }\n+\n+  if (!isReallyUL && isUU) {  \/\/ Adjust sizes of hs and needle\n+    \/\/ UU passes lengths in terms of chars - convert to bytes\n+    __ shlq(needle_len, 1);\n+    __ shlq(haystack_len, 1);\n+  }\n+\n+  \/\/ UL processing comes here after expanding needle\n+  __ bind(L_continue);\n+  \/\/ nMinusK (haystack length in bytes minus needle length in bytes) is used several\n+  \/\/ places to determine whether a compare will read past the end of the haystack.\n+  __ movq(nMinusK, haystack_len);\n+  __ subq(nMinusK, needle_len);\n+\n+  \/\/ Set up expected registers\n+  __ movq(save_ndl_len, needle_len);\n+  __ movq(r14, needle);\n+  __ movq(rbx, haystack);\n+\n+  \/\/ Always need needle broadcast to ymm registers (XMM_BYTE_0 and XMM_BYTE_K)\n+  broadcast_first_and_last_needle(needle, needle_len, rax, ae, _masm);\n+\n+  \/\/ Do \"big switch\" if haystack size > 32\n+  __ cmpq(haystack_len, 0x20);\n+  __ ja_b(L_bigSwitchTop);\n+\n+  \/\/ Copy the small (< 32 byte) haystack to the stack.  Allows for vector reads without page fault\n+  \/\/ Only done for small haystacks\n+  \/\/\n+  \/\/ NOTE: This code assumes that the haystack points to a java array type AND there are\n+  \/\/       at least 16 bytes of header preceeding the haystack pointer.\n+  \/\/\n+  \/\/ This means that we're copying up to 15 bytes of the header onto the stack along\n+  \/\/ with the haystack bytes.  After the copy completes, we adjust the haystack pointer\n+  \/\/ to the valid haystack bytes on the stack.\n+  {\n+    Label L_moreThan16, L_adjustHaystack;\n+\n+    const Register index = rax;\n+    const Register haystack = rbx;\n+\n+    \/\/ Only a single vector load\/store of either 16 or 32 bytes\n+    __ cmpq(haystack_len, 0x10);\n+    __ ja_b(L_moreThan16);\n+\n+    __ movq(index, COPIED_HAYSTACK_STACK_OFFSET + 0x10);\n+    __ movdqu(XMM_TMP1, Address(haystack, haystack_len, Address::times_1, -0x10));\n+    __ movdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), XMM_TMP1);\n+    __ jmpb(L_adjustHaystack);\n+\n+    __ bind(L_moreThan16);\n+    __ movq(index, COPIED_HAYSTACK_STACK_OFFSET + 0x20);\n+    __ vmovdqu(XMM_TMP1, Address(haystack, haystack_len, Address::times_1, -0x20));\n+    __ vmovdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), XMM_TMP1);\n+\n+    \/\/ Point the haystack at the correct location of the first byte of the \"real\" haystack on the stack\n+    __ bind(L_adjustHaystack);\n+    __ subq(index, haystack_len);\n+    __ leaq(haystack, Address(rsp, index, Address::times_1));\n+  }\n+\n+  \/\/ Dispatch to handlers for small needle and small haystack\n+  \/\/ Note that needle sizes of 1-6 have been handled in highly_optimized_short_cases,\n+  \/\/ so the dispatch only has valid entries for 7-10.\n+  __ leaq(r13, Address(save_ndl_len, -1));\n+  __ cmpq(r13, NUMBER_OF_CASES - 1);\n+  __ ja(L_smallCaseDefault);\n+  __ lea(r15, InternalAddress(small_jump_table));\n+  __ jmp(Address(r15, r13, Address::times_8));\n+\n+  \/\/ Dispatch to handlers for small needle and large haystack\n+  \/\/ For large haystacks, the jump table is fully populated (1-10)\n+  __ bind(L_bigSwitchTop);\n+  __ leaq(rax, Address(save_ndl_len, -1));\n+  __ cmpq(rax, NUMBER_OF_CASES - 1);\n+  __ ja(L_bigCaseDefault);\n+  __ lea(r15, InternalAddress(big_jump_table));\n+  __ jmp(Address(r15, rax, Address::times_8));\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/ Fixup and return routines\n+\n+  \/\/ Return not found\n+  __ bind(L_returnError);\n+  __ movq(rax, -1);\n+  __ jmpb(L_return);\n+\n+  \/\/ At this point, rcx has &haystack where match found, rbx has &haystack,\n+  \/\/ and r8 has the index where a match was found\n+  __ bind(L_bigCaseFixupAndReturn);\n+  __ subq(rcx, rbx);\n+  __ addq(rcx, r8);\n+\n+  __ movq(r11, rcx);\n+\n+  \/\/ r11 will contain the valid index.\n+  __ bind(L_returnR11);\n+  __ movq(rax, r11);\n+\n+  \/\/ Restore stack, vzeroupper and return\n+  __ bind(L_return);\n+  __ addptr(rsp, STACK_SPACE);\n+  __ pop(rbp);\n+#ifdef _WIN64\n+  __ pop(rdi);\n+  __ pop(rsi);\n+#endif\n+  __ movdq(r12, save_r12);\n+  __ movdq(r13, save_r13);\n+  __ movdq(r14, save_r14);\n+  __ movdq(r15, save_r15);\n+  __ movdq(rbx, save_rbx);\n+\n+  \/\/ Need to return elements for UTF-16 encodings\n+  if (isU) {\n+    \/\/ Return value for UTF-16 is elements, not bytes\n+    \/\/ sar is used to preserve -1\n+    __ sarq(rax, 1);\n+  }\n+  __ vzeroupper();\n+\n+  __ leave();  \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\n+  \/\/ Big case default:\n+  \/\/\n+  \/\/ Handle needle sizes > 10 bytes.  Uses C2's arrays_equals to compare the contents\n+  \/\/ of the needle to the haystack.\n+\n+  {\n+    Label L_loopTop, L_innerLoop, L_found;\n+\n+    const Register hsPtrRet = rax;\n+    const Register mask = r8;\n+    const Register index = r9;\n+    const Register compLen = rbp;\n+    const Register haystackStart = rcx;\n+    const Register rScratch = r13;\n+    const Register needleLen = r12;\n+    const Register needle = r14;\n+    const Register haystack = rbx;\n+    const Register hsLength = rsi;\n+    const Register tmp1 = rdi;\n+\n+\/\/ #define used for registers that are re-used in the code\n+#undef retval\n+#undef firstNeedleCompare\n+#undef tmp2\n+#undef tmp3\n+#define tmp2 r15\n+#define tmp3 rdx\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\n+    \/\/ Big case default:  registers on entry\n+    \/\/\n+    \/\/  rbx: haystack\n+    \/\/  rcx: k\n+    \/\/  rdx: junk\n+    \/\/  rsi: n\n+    \/\/  rdi: haystack\n+    \/\/  r10: n - k\n+    \/\/  r12: k\n+    \/\/  r13: junk\n+    \/\/  r14: needle\n+    \/\/  rbp: junk\n+    \/\/  XMM_BYTE_0 - first element of needle broadcast\n+    \/\/  XMM_BYTE_K - last element of needle broadcast\n+    \/\/\n+    \/\/ Set up in big_case_loop_helper\n+    \/\/  XMM_BYTE_1 - second element of needle broadcast\n+\n+    __ bind(L_bigCaseDefault);\n+\n+    \/\/ Loop construct handling for big haystacks\n+    \/\/ The helper binds L_loopTop which should be jumped to if potential matches fail to compare\n+    \/\/ equal (thus moving on to the next chunk of haystack).  If we run out of haystack, the\n+    \/\/ helper jumps to L_returnError.\n+    big_case_loop_helper(false, 0, L_returnError, L_loopTop, mask, hsPtrRet, needleLen, needle,\n+                         haystack, hsLength, tmp1, tmp2, tmp3, rScratch, ae, _masm);\n+\n+    \/\/ big_case_loop_helper will fall through to this point if one or more potential matches are found\n+    \/\/ The mask will have a bitmask indicating the position of the potential matches within the haystack\n+    __ align(OptoLoopAlignment);\n+    __ bind(L_innerLoop);\n+    __ tzcntl(index, mask);\n+\n+\/\/ Re-use of r15 and rdx\n+#undef tmp2\n+#undef tmp3\n+#define retval r15\n+#define firstNeedleCompare rdx\n+\n+    \/\/ Need a lot of registers here to preserve state across arrays_equals call\n+\n+    \/\/ Starting address in the haystack\n+    __ leaq(haystackStart, Address(hsPtrRet, index, Address::times_1, isU ? 4 : 2));\n+        \/\/ Starting address of first byte of needle to compare\n+    __ leaq(firstNeedleCompare, Address(needle, isU ? 4 : 2));\n+        \/\/ Number of bytes to compare\n+    __ leaq(compLen, Address(needleLen, isU ? -6 : -3));\n+\n+    \/\/ Call arrays_equals for both UU and LL cases as bytes should compare exact\n+    __C2 arrays_equals(false, haystackStart, firstNeedleCompare, compLen, retval, rScratch,\n+                        XMM_TMP3, XMM_TMP4, false \/* char *\/, knoreg);\n+    __ testl(retval, retval);\n+    __ jne_b(L_found);\n+\n+    \/\/ If more potential matches, continue at inner loop, otherwise go get another vector\n+    CLEAR_BIT(mask);\n+    __ jne(L_innerLoop);\n+    __ jmp(L_loopTop);\n+\n+    \/\/ Found exact match.  Compute offset from beginning of haystack\n+    __ bind(L_found);\n+    __ subq(hsPtrRet, haystack);\n+    __ addq(hsPtrRet, index);\n+    __ movq(r11, hsPtrRet);\n+    __ jmp(L_returnR11);\n+\n+#undef retval\n+#undef firstNeedleCompare\n+  }\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\n+  \/\/ Small case default:\n+  \/\/\n+  \/\/ Handle needle sizes > 10 bytes.  Uses C2's arrays_equals to compare the contents\n+  \/\/ of the needle to the haystack.\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\n+  \/\/ Small case default: register on entry\n+  \/\/\n+  \/\/  rbx: haystack\n+  \/\/  r14: needle\n+  \/\/  r13: k - 1\n+  \/\/  r12: k\n+  \/\/  r10: n - k\n+  \/\/  rbp: junk\n+  \/\/  rdi: junk\n+  \/\/  rsi: n\n+  \/\/  rdx: junk\n+  \/\/  rcx: junk\n+  \/\/  XMM_BYTE_0 - first element of needle broadcast\n+  \/\/  XMM_BYTE_K - last element of needle broadcast\n+  \/\/\n+  \/\/ Set up in broadcast_additional_needles\n+  \/\/  XMM_BYTE_1 - second element of needle broadcast\n+  \/\/\n+  \/\/  Haystack always copied to stack, so 32-byte reads OK\n+  \/\/  Haystack length <= 32\n+  \/\/  10 < needle length <= 32\n+\n+  {\n+    __ bind(L_smallCaseDefault);\n+\n+    Label L_innerLoop;\n+\n+    const Register firstNeedleCompare = rdx;\n+    const Register compLen = r9;\n+    const Register haystack = rbx;\n+    const Register mask = r8;\n+    const Register rTmp = rdi;\n+    const Register rTmp2 = r13;\n+    const Register rTmp3 = rax;\n+\n+\/\/ r14 and r12 will be re-used later in this procedure\n+#undef needle\n+#define needle r14\n+#undef needleLen\n+#define needleLen r12\n+\n+    broadcast_additional_needles(false, 0 \/* unknown *\/, needle, needleLen, rTmp3, ae, _masm);\n+\n+    \/\/ For small haystacks we already know that the 1st, 2nd, and last bytes of the needle\n+    \/\/ compare equal, so we can reduce the byte count to arrays_equals\n+    __ leaq(firstNeedleCompare, Address(needle, isU ? 4 : 2));\n+    __ leaq(compLen, Address(needleLen, isU ? -6 : -3));\n+\n+    \/\/  firstNeedleCompare has address of third element of needle\n+    \/\/  compLen has length of comparison to do (3 elements less than needle size)\n+\n+    \/\/ Helper to compare the 1st, 2nd, and last byte of the needle to the haystack\n+    \/\/ in the correct position.  Since the haystack is < 32 bytes, not finding matching\n+    \/\/ needle bytes can just return failure.  Otherwise, we loop through the found\n+    \/\/ matches.\n+    compare_haystack_to_needle(false, 0, L_returnError, haystack, mask, needleLen, rTmp3, XMM_TMP1,\n+                               XMM_TMP2, ae, _masm);\n+\n+\/\/ NOTE: REGISTER RE-USE for r12 and r14\n+#undef needle\n+#undef saveCompLen\n+#define saveCompLen r14\n+#undef needleLen\n+#undef saveNeedleAddress\n+#define saveNeedleAddress r12\n+\n+    \/\/ Save registers stomped by arrays_equals\n+    __ movq(saveCompLen, compLen);\n+    __ movq(saveNeedleAddress, firstNeedleCompare);  \/\/ Save address of 2nd element of needle\n+\n+    \/\/ Find index of a potential match\n+    __ align(OptoLoopAlignment);\n+    __ bind(L_innerLoop);\n+    __ tzcntl(r11, mask);\n+\n+    __ leaq(rTmp, Address(haystack, r11, Address::times_1, isU ? 4 : 2));\n+\n+    \/\/ Check for needle equality.  Handles UU and LL cases since byte comparison should be exact\n+    __C2 arrays_equals(false, rTmp, firstNeedleCompare, compLen, rTmp3, rTmp2, XMM_TMP3, XMM_TMP4,\n+                       false \/* char *\/, knoreg);\n+    __ testl(rTmp3, rTmp3);\n+    __ jne(L_returnR11);\n+\n+    \/\/ Restore saved registers\n+    __ movq(compLen, saveCompLen);\n+    __ movq(firstNeedleCompare, saveNeedleAddress);\n+\n+    \/\/ Jump to inner loop if more matches to check, otherwise return not found\n+    CLEAR_BIT(mask);\n+    __ jne(L_innerLoop);\n+    __ jmp(L_returnError);\n+\n+#undef saveCompLen\n+#undef saveNeedleAddress\n+  }\n+\n+  if (isReallyUL) {\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/                         Wide char code\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\n+    \/\/ Pseudo-code:\n+    \/\/\n+    \/\/ If needle length less than MAX_NEEDLE_LEN_TO_EXPAND, read the needle\n+    \/\/ bytes from r14 and write them as words onto the stack.  Then go to the\n+    \/\/ \"regular\" UU code.  This is equavilent to doing a UU comparison, since the\n+    \/\/ haystack will be in UTF-16.\n+    \/\/\n+    \/\/ If the needle can't be expanded, process the same way as the default\n+    \/\/ cases above.\n+    __ bind(L_wcharBegin);\n+\n+    \/\/ Restore argument encoding from UU back to UL for helpers\n+    ae = StrIntrinsicNode::UL;\n+    isUL = true;\n+    isUU = false;\n+\n+    Label L_top, L_finished;\n+\n+    const Register haystack = rdi;\n+    const Register hsLen = rsi;\n+    const Register needle = rdx;\n+    const Register nLen = rcx;\n+\n+    const Register offset = rax;\n+    const Register index = rbx;\n+    const Register wr_index = r13;\n+\n+    assert(MAX_NEEDLE_LEN_TO_EXPAND >= 32, \"Small UL needles not supported\");\n+\n+    \/\/ haystack length to bytes\n+    __ shlq(hsLen, 1);\n+\n+    \/\/ Ensure haystack >= needle\n+    __ leaq(index, Address(nLen, nLen, Address::times_1));\n+    __ cmpq(index, hsLen);\n+    __ jg(L_returnError);\n+\n+    \/\/ Can't expand large-ish needles\n+    __ cmpq(nLen, MAX_NEEDLE_LEN_TO_EXPAND);\n+    __ ja(L_wideNoExpand);\n+\n+    \/\/\n+    \/\/ Reads of existing needle are 16-byte chunks\n+    \/\/ Writes to copied needle are 32-byte chunks\n+    \/\/ Don't read past the end of the existing needle\n+    \/\/\n+    \/\/ Start first read at [((ndlLen % 16) - 16) & 0xf]\n+    \/\/ outndx += 32\n+    \/\/ inndx += 16\n+    \/\/ cmp nndx, ndlLen\n+    \/\/ jae done\n+    \/\/\n+    \/\/ Final index of start of needle @((16 - (ndlLen %16)) & 0xf) << 1\n+    \/\/\n+    \/\/ Starting read for needle at -(16 - (nLen % 16))\n+    \/\/ Offset of needle in stack should be (16 - (nLen % 16)) * 2\n+\n+    __ movq(index, needle_len);\n+    __ andq(index, 0xf);  \/\/ nLen % 16\n+    __ movq(offset, 0x10);\n+    __ subq(offset, index);  \/\/ 16 - (nLen % 16)\n+    __ movq(index, offset);\n+    __ shlq(offset, 1);  \/\/ * 2\n+    __ negq(index);      \/\/ -(16 - (nLen % 16))\n+    __ xorq(wr_index, wr_index);\n+\n+    __ bind(L_top);\n+    \/\/ load needle and expand\n+    __ vpmovzxbw(xmm0, Address(needle, index, Address::times_1), Assembler::AVX_256bit);\n+    \/\/ store expanded needle to stack\n+    __ vmovdqu(Address(rsp, wr_index, Address::times_1, EXPANDED_NEEDLE_STACK_OFFSET), xmm0);\n+    __ addq(index, 0x10);\n+    __ cmpq(index, needle_len);\n+    __ jae(L_finished);\n+    __ addq(wr_index, 32);\n+    __ jmpb(L_top);\n+\n+    \/\/ adjust pointer and length of needle\n+    __ bind(L_finished);\n+    __ leaq(needle, Address(rsp, offset, Address::times_1, EXPANDED_NEEDLE_STACK_OFFSET));\n+    __ leaq(needle_len, Address(needle_len, needle_len));\n+\n+    \/\/ Go handle this the same as UU\n+    __ jmp(L_continue);\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\n+    \/\/ Compare Latin-1 encoded needle against UTF-16 encoded haystack.\n+    \/\/\n+    \/\/ The needle is more than MAX_NEEDLE_LEN_TO_EXPAND bytes in length, and the haystack\n+    \/\/ is at least as big.\n+\n+    \/\/ Prepare for wchar anysize\n+    __ bind(L_wideNoExpand);\n+\n+    {\n+      Label L_loopTop, L_temp, L_innerLoop, L_found, L_compareFull;\n+      Label doCompare, topLoop;\n+\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+      \/\/ On entry:\n+      \/\/\n+      \/\/  rbx: haystack\n+      \/\/  rcx: k\n+      \/\/  rdx: junk\n+      \/\/  rsi: n\n+      \/\/  rdi: haystack\n+      \/\/  r10: n - k\n+      \/\/  r12: k\n+      \/\/  r13: junk\n+      \/\/  r14: needle\n+      \/\/  rbp: junk\n+      \/\/  XMM_BYTE_0 - first element of needle broadcast\n+      \/\/  XMM_BYTE_K - last element of needle broadcast\n+\n+      const Register hsPtrRet = rax;\n+      const Register haystack = rbx;\n+      const Register haystackStart = rcx;\n+      const Register hsLength = rsi;\n+      const Register tmp1 = rdi;\n+      const Register compLen = rbp;\n+      const Register mask = r8;\n+      const Register index = r9;\n+      const Register needleLen = r12;\n+      const Register rScratch = r13;\n+      const Register needle = r14;\n+\n+      \/\/ Move registers into expected registers for rest of this routine\n+      __ movq(rbx, rdi);\n+      __ movq(r12, rcx);\n+      __ movq(r14, rdx);\n+\n+      \/\/ Set up nMinusK\n+      __ movq(tmp1, needleLen);\n+      __ shlq(tmp1, 1);\n+      __ movq(rScratch, hsLength);\n+      __ subq(rScratch, tmp1);\n+      __ movq(nMinusK, rScratch);\n+\n+      \/\/ Check for room for a 32-byte read for the last iteration\n+      __ cmpq(nMinusK, 0x1f);\n+      __ jl(L_compareFull);\n+\n+      \/\/ Always need needle broadcast to ymm registers\n+      broadcast_first_and_last_needle(needle, needleLen, tmp1, ae, _masm);\n+\n+\/\/ Register redefinition for rbx and r15\n+#undef retval\n+#undef firstNeedleCompare\n+#undef tmp2\n+#undef tmp3\n+#define tmp2 r15\n+#define tmp3 rdx\n+\n+      \/\/ Loop construct handling for big haystacks\n+      \/\/ The helper binds L_loopTop which should be jumped to if potential matches fail to compare\n+      \/\/ equal (thus moving on to the next chunk of haystack).  If we run out of haystack, the\n+      \/\/ helper jumps to L_returnError.\n+      big_case_loop_helper(false, 0, L_returnError, L_loopTop, mask, hsPtrRet, needleLen, needle,\n+                           haystack, hsLength, tmp1, tmp2, tmp3, rScratch, ae, _masm);\n+\n+      \/\/ big_case_loop_helper will fall through to this point if one or more potential matches are\n+      \/\/ found The mask will have a bitmask indicating the position of the potential matches within\n+      \/\/ the haystack\n+      __ align(OptoLoopAlignment);\n+      __ bind(L_innerLoop);\n+      __ tzcntl(index, mask);\n+\n+#undef tmp2\n+#undef tmp3\n+#define retval r15\n+#define firstNeedleCompare rdx\n+\n+      \/\/ Note that we're comparing the full needle here even though in some paths\n+      \/\/ the 1st, 2nd, and last bytes are already known to be equal.  This is necessary\n+      \/\/ due to the handling of cases where nMinusK is < 32\n+\n+      \/\/ Need a lot of registers here to preserve state across arrays_equals call\n+\n+      \/\/ Starting address in the haystack\n+      __ leaq(haystackStart, Address(hsPtrRet, index));\n+      \/\/ Starting address of first byte of needle to compare\n+      __ movq(firstNeedleCompare, needle);\n+      \/\/ Number of bytes to compare\n+      __ movq(compLen, needleLen);\n+\n+      \/\/ Passing true as last parameter causes arrays_equals to expand the second array (needle)\n+      \/\/ as the comparison is done.\n+      __C2 arrays_equals(false, haystackStart, firstNeedleCompare, compLen, retval, rScratch,\n+                         XMM_TMP3, XMM_TMP4, false \/* char *\/, knoreg, true \/* expand_ary2 *\/);\n+      __ testl(retval, retval);\n+      __ jne_b(L_found);\n+\n+    \/\/ If more potential matches, continue at inner loop, otherwise go get another vector\n+      CLEAR_BIT(mask);\n+      __ jne(L_innerLoop);\n+      __ jmp(L_loopTop);\n+\n+      \/\/ Found exact match.  Compute offset from beginning of haystack\n+      __ bind(L_found);\n+      __ subq(hsPtrRet, haystack);\n+      __ addq(hsPtrRet, index);\n+      __ movq(r11, hsPtrRet);\n+      __ jmp(L_returnR11);\n+\n+#undef retval\n+#undef firstNeedleCompare\n+\n+      __ bind(L_compareFull);\n+\n+      \/\/ rScratch has n - k.  Compare entire string word-by-word\n+      \/\/ Index returned in r11\n+      __ xorq(r11, r11);\n+      __ movq(nMinusK, rScratch);\n+      __ jmpb(doCompare);\n+\n+      __ bind(topLoop);\n+      __ addq(r11, 2);\n+      __ cmpq(r11, nMinusK);\n+      __ jg(L_returnError);\n+\n+      __ bind(doCompare);\n+      __ leaq(r9, Address(haystack, r11));\n+      __ leaq(r8, Address(needle, 0));\n+      __ movq(r13, needleLen);\n+\n+      __C2 arrays_equals(false, r9, r8, r13, rax, rdx, XMM_TMP3, XMM_TMP4, false \/* char *\/, knoreg,\n+                         true \/* expand_ary2 *\/);\n+      __ testq(rax, rax);\n+      __ jz(topLoop);\n+\n+      \/\/ Match found\n+      __ jmp(L_returnR11);\n+    }\n+  }\n+\n+  return;\n+}\n+\n+\/\/ Helper for broadcasting needle elements to ymm registers for compares\n+\/\/ Expands into XMM_BYTE_0 and XMM_BYTE_K\n+\/\/\n+\/\/ For UTF-16 encoded needles, broadcast a word at the proper offset to the ymm\n+\/\/ register (case UU)\n+\/\/ For the UTF-16 encoded haystack with Latin1 encoded needle (case UL) we have\n+\/\/ to read into a temp register to zero-extend the single byte needle value, then\n+\/\/ broadcast words to the ymm register.\n+\/\/\n+\/\/ Parameters:\n+\/\/ needle - the address of the first byte of the needle\n+\/\/ needle_len - length of needle if !sizeKnown\n+\/\/ rTmp - temp register (for UL only)\n+\/\/ ae - the argument encodings\n+\/\/ _masm - Current MacroAssembler instance pointer\n+\/\/\n+\/\/ Modifies XMM_BYTE_0 and XMM_BYTE_K\n+static void broadcast_first_and_last_needle(Register needle, Register needle_len, Register rTmp,\n+                                            StrIntrinsicNode::ArgEncoding ae,\n+                                            MacroAssembler *_masm) {\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = (isUU || isUL);\n+  Label L_short;\n+\n+  \/\/ Always need needle broadcast to ymm registers\n+  \/\/ Broadcast the beginning of needle into a vector register.\n+  if (isUU) {\n+    __ vpbroadcastw(XMM_BYTE_0, Address(needle, 0), Assembler::AVX_256bit);\n+  } else if (isUL) {\n+\n+    __ movzbl(rTmp, Address(needle));\n+    __ movdl(XMM_BYTE_0, rTmp);\n+    \/\/ 1st byte of needle in words\n+    __ vpbroadcastw(XMM_BYTE_0, XMM_BYTE_0, Assembler::AVX_256bit);\n+  } else {\n+    __ vpbroadcastb(XMM_BYTE_0, Address(needle, 0), Assembler::AVX_256bit);\n+  }\n+\n+  \/\/ Broadcast the end of needle into a vector register.\n+  \/\/ For a single-element needle this is redundant but does no harm and\n+  \/\/ reduces code size as opposed to broadcasting only if used.\n+  if (isUU) {\n+    __ vpbroadcastw(XMM_BYTE_K, Address(needle, needle_len, Address::times_1, -2),\n+                    Assembler::AVX_256bit);\n+  } else if (isUL) {\n+    __ movzbl(rTmp, Address(needle, needle_len, Address::times_1, -1));\n+    __ movdl(XMM_BYTE_K, rTmp);\n+    \/\/ last byte of needle in words\n+    __ vpbroadcastw(XMM_BYTE_K, XMM_BYTE_K, Assembler::AVX_256bit);\n+  } else {\n+    __ vpbroadcastb(XMM_BYTE_K, Address(needle, needle_len, Address::times_1, -1),\n+                    Assembler::AVX_256bit);\n+  }\n+\n+  __ bind(L_short);\n+}\n+\n+\/\/ Helper for broadcasting the 2nd needle element to XMM_BYTE_1\n+\/\/\n+\/\/ For UTF-16 encoded needles, broadcast a word at the proper offset to the ymm\n+\/\/ register (case UU)\n+\/\/ For the UTF-16 encoded haystack with Latin1 encoded needle (case UL) we have\n+\/\/ to read into a temp register to zero-extend the single byte needle value, then\n+\/\/ broadcast words to the ymm register.\n+\/\/\n+\/\/ Parameters:\n+\/\/ sizeKnown - True if needle size known at compile time\n+\/\/ size - the size of the needle.  Pass 0 if unknown at compile time\n+\/\/ needle - the address of the first byte of the needle\n+\/\/ needleLen - length of needle if !sizeKnown\n+\/\/ rTmp - temp register (for UL only)\n+\/\/ ae - Argument encoding\n+\/\/ _masm - Current MacroAssembler instance pointer\n+\/\/\n+\/\/ Modifies XMM_BYTE_1\n+static void broadcast_additional_needles(bool sizeKnown, int size, Register needle,\n+                                         Register needleLen, Register rTmp,\n+                                         StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm) {\n+  Label L_done;\n+\n+  assert_different_registers(needle, needleLen, rTmp);\n+\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = (isUU || isUL);\n+\n+  size = sizeKnown ? size : NUMBER_OF_CASES + 1;\n+\n+  \/\/ Need code to determine whether it's valid to use second byte of\n+  \/\/ needle if the size isn't known at compile-time\n+  if (!sizeKnown) {\n+    __ cmpq(needleLen, (isU ? 4 : 2));\n+    __ jl_b(L_done);\n+  }\n+\n+  if (size > (isU ? 4 : 2)) {\n+    \/\/ Add compare for second byte\n+    if (isUU) {\n+      __ vpbroadcastw(XMM_BYTE_1, Address(needle, 2), Assembler::AVX_256bit);\n+    } else if (isUL) {\n+      __ movzbl(rTmp, Address(needle, 1));\n+      __ movdl(XMM_BYTE_1, rTmp);\n+      \/\/ 1st byte of needle in words\n+      __ vpbroadcastw(XMM_BYTE_1, XMM_BYTE_1, Assembler::AVX_256bit);\n+    } else {\n+      __ vpbroadcastb(XMM_BYTE_1, Address(needle, 1), Assembler::AVX_256bit);\n+    }\n+  }\n+\n+  __ bind(L_done);\n+}\n+\n+\/\/ Helper for comparing needle elements to a big haystack\n+\/\/\n+\/\/ This helper compares bytes or words in the ymm registers to\n+\/\/ the proper positions within the haystack.  It will bail out early if\n+\/\/ no match found, otherwise it will progressively and together\n+\/\/ the comparison results, returning the answer at the end.\n+\/\/\n+\/\/ On return, eq_mask will be set to the comparison mask value.  If no match\n+\/\/ is found, this helper will jump to noMatch.\n+\/\/\n+\/\/ Parameters:\n+\/\/ sizeKnown - True if size known at compile time\n+\/\/ size - the size of the needle in bytes.  Pass 0 if unknown at compile time\n+\/\/ noMatch - label bound outside to jump to if there is no match\n+\/\/ haystack - the address of the first byte of the haystack\n+\/\/ hsLen - the sizeof the haystack in bytes\n+\/\/ needleLen - size of the needle in bytes known at runtime\n+\/\/ eq_mask - The bit mask returned that holds the result of the comparison\n+\/\/ rxTmp1 - a temporary xmm register\n+\/\/ rxTmp2 - a temporary xmm register\n+\/\/ rxTmp3 - a temporary xmm register\n+\/\/ ae - Argument encoding\n+\/\/ _masm - Current MacroAssembler instance pointer\n+\/\/\n+\/\/ (n - k) will always be >= 32 on entry\n+static void compare_big_haystack_to_needle(bool sizeKnown, int size, Label &noMatch,\n+                                           Register haystack, Register needleLen, Register eq_mask,\n+                                           XMMRegister rxTmp1, XMMRegister rxTmp2,\n+                                           XMMRegister rxTmp3, StrIntrinsicNode::ArgEncoding ae,\n+                                           MacroAssembler *_masm) {\n+\n+  assert_different_registers(eq_mask, haystack, needleLen, nMinusK);\n+\n+  const XMMRegister result = rxTmp1;\n+  const XMMRegister cmp_0 = rxTmp2;\n+  const XMMRegister cmp_k = rxTmp3;\n+\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = (isUU || isUL);\n+\n+  int sizeIncr = isU ? 2 : 1;\n+\n+  Label L_OKtoCompareFull, L_done, L_specialCase_gt2;\n+\n+  assert(!sizeKnown || (sizeKnown && ((size > 0) && (size <= NUMBER_OF_CASES))), \"Incorrect size given\");\n+\n+  \/\/ Address of the kth byte of the needle within the haystack\n+  Address kThByte = sizeKnown ? Address(haystack, size - sizeIncr)\n+                              : Address(haystack, needleLen,\n+                                        isUL ? Address::times_2 : Address::times_1, -(sizeIncr));\n+  size = sizeKnown ? size : NUMBER_OF_CASES + 1;\n+\n+  \/\/ Compare first byte of needle to haystack\n+     vpcmpeq(cmp_0, XMM_BYTE_0, Address(haystack, 0), Assembler::AVX_256bit, ae, _masm);\n+\n+  __ vpmovmskb(eq_mask, cmp_0, Assembler::AVX_256bit);\n+\n+  \/\/ If the needle is a single element (at compile time) no need to compare more\n+  if (size != sizeIncr) {\n+    \/\/ Compare last byte of needle to haystack at proper position\n+    vpcmpeq(cmp_k, XMM_BYTE_K, kThByte, Assembler::AVX_256bit, ae, _masm);\n+\n+    __ vpand(result, cmp_k, cmp_0, Assembler::AVX_256bit);\n+\n+    if (size > sizeIncr * 2) {\n+      vpcmpeq(cmp_k, XMM_BYTE_1, Address(haystack, 1 * sizeIncr), Assembler::AVX_256bit, ae, _masm);\n+      __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n+    }\n+\n+    __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n+  }\n+\n+  __ bind(L_done);\n+  __ testl(eq_mask, eq_mask);\n+  __ je(noMatch);\n+  \/\/ At this point, we have at least one \"match\" where first and last bytes\n+  \/\/ of the needle are found the correct distance apart.\n+}\n+\n+\/\/ Helper for comparing needle elements to a small haystack\n+\/\/\n+\/\/ This helper compares bytes or words in the ymm registers to\n+\/\/ the proper positions within the haystack.  It will bail out early if\n+\/\/ a match is not found, otherwise it will progressively and together\n+\/\/ the comparison results, returning the answer at the end.\n+\/\/\n+\/\/ On return, eq_mask will be set to the comparison mask value.  If no match\n+\/\/ is found, this helper will jump to noMatch.\n+\/\/\n+\/\/ Parameters:\n+\/\/ sizeKnown - if true, size is valid and needleLen invalid.\n+\/\/             if false, size invalid and needleLen valid.\n+\/\/ size - the size of the needle.  Pass 0 if unknown at compile time\n+\/\/ noMatch - label bound outside to jump to if there is no match\n+\/\/ haystack - the address of the first byte of the haystack\n+\/\/ eq_mask - The bit mask returned that holds the result of the comparison\n+\/\/ needleLen - Length of the needle in bytes.  Only used if isUL true\n+\/\/ rTmp - temporary register\n+\/\/ rxTmp1 - temporary xmm register\n+\/\/ rxTmp2 - temporary xmm register\n+\/\/ ae - Argument encoding\n+\/\/ _masm - Current MacroAssembler instance pointer\n+\/\/\n+\/\/ No need to worry about reading past end of haystack since haystack\n+\/\/ has been copied to the stack\n+\/\/\n+\/\/ If !sizeKnown, needle is at least 11 bytes long\n+static void compare_haystack_to_needle(bool sizeKnown, int size, Label &noMatch, Register haystack,\n+                                       Register eq_mask, Register needleLen, Register rTmp,\n+                                       XMMRegister rxTmp1, XMMRegister rxTmp2,\n+                                       StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm) {\n+\n+  assert_different_registers(eq_mask, haystack, needleLen, rTmp, nMinusK);\n+\n+  \/\/ NOTE: cmp_0 and result are the same register\n+  const XMMRegister cmp_0 = rxTmp1;\n+  const XMMRegister result = rxTmp1;\n+  const XMMRegister cmp_k = rxTmp2;\n+\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = isUL || isUU;  \/\/ At least one is UTF-16\n+\n+  int sizeIncr = isU ? 2 : 1;\n+\n+  assert((!sizeKnown) || (((size > 0) && (size <= NUMBER_OF_CASES))), \"Incorrect size given\");\n+\n+  \/\/ Address of the kth byte of the needle within the haystack\n+  Address kThByte = sizeKnown ? Address(haystack, size - sizeIncr)\n+                              : Address(haystack, needleLen, Address::times_1, -(sizeIncr));\n+  size = sizeKnown ? size : NUMBER_OF_CASES + 1;\n+\n+  \/\/ Creates a mask of (n - k + 1) ones.  This prevents\n+  \/\/ recognizing any false-positives past the end of\n+  \/\/ the valid haystack.\n+  __ movq(rTmp, -1);\n+  __ movq(eq_mask, nMinusK);\n+  __ addq(eq_mask, 1);\n+  __ bzhiq(rTmp, rTmp, eq_mask);\n+\n+  \/\/ Compare first byte of needle to haystack\n+     vpcmpeq(cmp_0, XMM_BYTE_0, Address(haystack, 0), Assembler::AVX_256bit, ae, _masm);\n+  if (size != sizeIncr) {\n+    \/\/ Compare last byte of needle to haystack at proper position\n+    vpcmpeq(cmp_k, XMM_BYTE_K, kThByte, Assembler::AVX_256bit, ae, _masm);\n+\n+    __ vpand(result, cmp_k, cmp_0, Assembler::AVX_256bit);\n+\n+    if (size > (sizeIncr * 2)) {\n+      vpcmpeq(cmp_k, XMM_BYTE_1, Address(haystack, 1 * sizeIncr), Assembler::AVX_256bit, ae, _masm);\n+      __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n+    }\n+  }\n+\n+  __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n+  __ andl(eq_mask, rTmp);\n+\n+  __ testl(eq_mask, eq_mask);\n+  __ je(noMatch);\n+  \/\/ At this point, we have at least one \"match\" where first and last bytes\n+  \/\/ of the needle are found the correct distance apart.\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Helper for big haystack loop construct\n+\/\/\n+\/\/ For UTF-16 encoded needles, broadcast a word at the proper offset to the ymm\n+\/\/ register (case UU)\n+\/\/ For the UTF-16 encoded haystack with Latin1 encoded needle (case UL) we have\n+\/\/ to read into a temp register to zero-extend the single byte needle value, then\n+\/\/ broadcast words to the ymm register.\n+\/\/\n+\/\/ Parameters:\n+\/\/ sizeKnown - if true, size is valid and needleLen invalid.\n+\/\/ size - the size of the needle.  Pass 0 if unknown at compile time\n+\/\/ noMatch - label bound outside to jump to if there is no match\n+\/\/ loop_top - label bound inside this helper that should be branched to\n+\/\/            for additional comparisons.\n+\/\/ eq_mask - The bit mask returned that holds the result of the comparison\n+\/\/ hsPtrRet - This will hold the place within the needle where a match is found\n+\/\/            This is modified\n+\/\/ needleLen - The length of the needle\n+\/\/ needle - Address of the needle\n+\/\/ haystack - Address of the haystack\n+\/\/ hsLength - The length of the haystack\n+\/\/ rTmp1 - Temporary\n+\/\/ rTmp2 - Temporary\n+\/\/ rTmp3 - Temporary\n+\/\/ rTmp4 - Temporary\n+\/\/ ae - Argument encoding\n+\/\/ _masm - Current MacroAssembler instance pointer\n+\/\/\n+\/\/ On entry:\n+\/\/\n+\/\/  rbx: haystack\n+\/\/  rcx: k\n+\/\/  rdx: junk\n+\/\/  rsi: n\n+\/\/  rdi: haystack\n+\/\/  r10: n - k\n+\/\/  r12: k\n+\/\/  r13: junk\n+\/\/  r14: needle\n+\/\/  rbp: junk\n+\/\/  XMM_BYTE_0 - first element of needle broadcast\n+\/\/  XMM_BYTE_K - last element of needle broadcast\n+\n+static void big_case_loop_helper(bool sizeKnown, int size, Label &noMatch, Label &loop_top,\n+                                 Register eq_mask, Register hsPtrRet, Register needleLen,\n+                                 Register needle, Register haystack, Register hsLength,\n+                                 Register rTmp1, Register rTmp2, Register rTmp3, Register rTmp4,\n+                                 StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm) {\n+  Label L_midLoop, L_greaterThan32, L_out;\n+\n+  assert_different_registers(eq_mask, hsPtrRet, needleLen, rdi, r15, rdx, rsi, rbx, r14, nMinusK);\n+\n+  const Register last = rTmp1;\n+  const Register temp1 = rTmp2;\n+  const Register temp2 = rTmp3;\n+  const Register temp3 = rTmp4;\n+\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = isUL || isUU;  \/\/ At least one is UTF-16\n+\n+  \/\/ Assume failure\n+  __ movq(r11, -1);\n+\n+  broadcast_additional_needles(sizeKnown, size, needle, needleLen, temp1, ae, _masm);\n+\n+  __ cmpq(nMinusK, 31);\n+  __ jae_b(L_greaterThan32);\n+\n+  \/\/ Here the needle is too long, so we can't do a 32-byte read to compare the last element.\n+  \/\/\n+  \/\/ Instead we match the first two characters, read from the end of the haystack\n+  \/\/ back 32 characters, shift the result, compare and check that way.\n+  \/\/\n+  \/\/ Set last to hsPtrRet so the next attempt at loop iteration ends the compare.\n+  __ movq(last, haystack);\n+  __ movq(hsPtrRet, haystack);\n+\n+  \/\/ Compare first element of needle to haystack\n+  vpcmpeq(XMM_TMP3, XMM_BYTE_0, Address(haystack, 0), Assembler::AVX_256bit, ae, _masm);\n+\n+  __ vpmovmskb(eq_mask, XMM_TMP3, Assembler::AVX_256bit);\n+\n+  if (!sizeKnown || (sizeKnown && (size > (isU ? 4 : 2)))) {\n+    \/\/ Compare second element of needle to haystack and mask result\n+    vpcmpeq(XMM_TMP3, XMM_BYTE_1, Address(haystack, isU ? 2 : 1), Assembler::AVX_256bit, ae, _masm);\n+\n+    __ vpmovmskb(temp1, XMM_TMP3, Assembler::AVX_256bit);\n+    __ andq(eq_mask, temp1);\n+  }\n+\n+  \/\/ Compare last element of needle to haystack, shift and mask result\n+  vpcmpeq(XMM_TMP3, XMM_BYTE_K, Address(haystack, hsLength, Address::times_1, -32),\n+          Assembler::AVX_256bit, ae, _masm);\n+\n+  __ vpmovmskb(temp1, XMM_TMP3, Assembler::AVX_256bit);\n+\n+  \/\/ Compute the proper shift value.  If we let k be the needle length and n be the haystack\n+  \/\/ length, we should be comparing to haystack[k - 1] through haystack[k - 1 + 31].  Since\n+  \/\/ (n - k) < 32, (k - 1 + 31) would be past the end of the haystack.  So the shift value\n+  \/\/ is computed as (k + 31 - n).\n+  \/\/\n+  \/\/ Clarification:  The BYTE_K compare above compares haystack[(n-32):(n-1)].  We need to\n+  \/\/ compare haystack[(k-1):(k-1+31)].  Subtracting either index gives shift value of\n+  \/\/ (k + 31 - n):  x = (k-1+31)-(n-1) = k-1+31-n+1 = k+31-n.\n+  if (sizeKnown) {\n+    __ movl(temp2, 31 + size);\n+  } else {\n+    __ movl(temp2, 31);\n+    __ addl(temp2, needleLen);\n+  }\n+  __ subl(temp2, hsLength);\n+  __ shrxl(temp1, temp1, temp2);\n+  __ andl(eq_mask, temp1);\n+\n+  __ testl(eq_mask, eq_mask);\n+  __ je(noMatch);\n+\n+  __ jmp(L_out);\n+\n+  __ bind(L_greaterThan32);\n+\n+  \/\/ Read 32-byte chunks at a time until the last 32-byte read would go\n+  \/\/ past the end of the haystack.  Then, set the final read to read exactly\n+  \/\/ the number of bytes in the haystack.\n+  \/\/ For example, if haystack length is 45 and needle length is 13, the compares\n+  \/\/ will read the following bytes:\n+  \/\/\n+  \/\/  First compare          Last compare\n+  \/\/   [  0 : 31]            [12 : 43]\n+  \/\/ Next compare will go past end of haystack ([32:63])\n+  \/\/ Adjust so final read is:\n+  \/\/   [  1 : 32]            [13 : 44]\n+\n+  __ movq(hsPtrRet, haystack);\n+  __ leaq(last, Address(haystack, nMinusK, Address::times_1, isU ? -30 : -31));\n+  __ jmpb(L_midLoop);\n+\n+  __ align(OptoLoopAlignment);\n+  __ bind(loop_top);\n+  \/\/ An equal comparison indicates completion with no match\n+  __ cmpq(hsPtrRet, last);\n+  __ je(noMatch);\n+  __ addq(hsPtrRet, 32);\n+\n+  \/\/ If next compare will go beyond end of haystack adjust start of read\n+  \/\/ back to last valid read position\n+  __ cmpq(hsPtrRet, last);\n+  __ jbe_b(L_midLoop);\n+  __ movq(hsPtrRet, last);\n+\n+  __ bind(L_midLoop);\n+\n+  \/\/ compare_big_haystack_to_needle will jump to loop_top until a match has been\n+  \/\/ found\n+  compare_big_haystack_to_needle(sizeKnown, size, loop_top, hsPtrRet, needleLen, eq_mask, XMM_TMP1,\n+                                 XMM_TMP2, XMM_TMP3, ae, _masm);\n+\n+  \/\/ At this point, we have at least one \"match\" where first and last bytes\n+  \/\/ of the needle are found the correct distance apart.\n+  \/\/\n+  \/\/ NOTE: haystack (rbx) should be preserved; hsPtrRet(rcx) is expected to\n+  \/\/    point to the haystack such that hsPtrRet[tzcntl(eq_mask)] points to\n+  \/\/    the matched string.\n+\n+  __ bind(L_out);\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Helper for comparing small needles to the haystack after a potential match found.\n+\/\/\n+\/\/ Parameters:\n+\/\/ size - The size of the needle in bytes\n+\/\/ L_noMatch - Label to jump to if needle does not match haystack at this location\n+\/\/ L_matchFound - Label to jump to if needle matches haystack at this location\n+\/\/ needle - the address of the first byte of the needle\n+\/\/ needleVal - The bytes of the needle to compare\n+\/\/ haystack - The address of the first byte of the haystack\n+\/\/ mask - The comparison mask from comparing the first 2 and last elements of the needle\n+\/\/ foundIndex - The index within the haystack of the match\n+\/\/ tmp - A temporary register\n+\/\/ ae - the argument encodings\n+\/\/ _masm - Current MacroAssembler instance pointer\n+\/\/\n+\/\/ Branches to either L_noMatch or L_matchFound depending on the result of the comparison\n+\/\/ foundIndex will contain the index within the haystack of the match for L_matchFound\n+\n+static void byte_compare_helper(int size, Label &L_noMatch, Label &L_matchFound, Register needle,\n+                                Register needleVal, Register haystack, Register mask,\n+                                Register foundIndex, Register tmp, StrIntrinsicNode::ArgEncoding ae,\n+                                MacroAssembler *_masm) {\n+  \/\/ Compare size bytes of needle to haystack\n+  \/\/\n+  \/\/ At a minimum, the first, second and last bytes of needle already compare equal\n+  \/\/ to the haystack, so there is no need to compare them again.\n+\n+  Label L_loopTop;\n+\n+  assert_different_registers(needle, needleVal, haystack, mask, foundIndex, tmp);\n+\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = isUL || isUU;  \/\/ At least one is UTF-16\n+\n+  int bytesAlreadyCompared = 0;\n+  int bytesLeftToCompare = 0;\n+  int offsetOfFirstByteToCompare = 0;\n+\n+  Label temp;\n+\n+  \/\/ Getting her we already have the first two and last elements of the needle\n+  \/\/ comparing equal, so no need to compare them again\n+  bytesAlreadyCompared = isU ? 6 : 3;\n+  offsetOfFirstByteToCompare = isU ? 4 : 2;\n+\n+  bytesLeftToCompare = size - bytesAlreadyCompared;\n+  assert(bytesLeftToCompare <= 7, \"Too many bytes left to compare\");\n+\n+  \/\/ The needle is <= 3 elements long, so the ultimate result comes from the mask\n+  if (bytesLeftToCompare <= 0) {\n+    __ tzcntl(foundIndex, mask);\n+    __ jmp(L_matchFound);\n+    return;\n+  }\n+\n+  \/\/ At this point, there is at least one byte of the needle that needs to be\n+  \/\/ compared to the haystack.\n+\n+  \/\/ Pre-load the needle bytes to compare here\n+  switch (bytesLeftToCompare) {\n+  case 1:\n+  case 2:\n+    \/\/ Load for needle size of 4 and 5 bytes\n+    __ movl(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n+    break;\n+\n+  case 3:\n+  case 4:\n+    \/\/ Load for needle size of 6 and 7 bytes\n+    __ movl(needleVal, Address(needle, offsetOfFirstByteToCompare));\n+    break;\n+\n+  case 5:\n+  case 6:\n+    \/\/ Load for needle size of 8 and 9 bytes\n+    __ movq(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n+    break;\n+\n+  case 7:\n+    \/\/ Load for needle size of 10 bytes\n+    __ movq(needleVal, Address(needle, offsetOfFirstByteToCompare));\n+    break;\n+\n+  default:\n+    break;\n+  }\n+\n+  __ align(OptoLoopAlignment);\n+  __ bind(L_loopTop);\n+  __ tzcntl(foundIndex, mask);  \/\/ Index of match within haystack\n+\n+  switch (bytesLeftToCompare) {\n+  case 1:\n+  case 2:\n+    \/\/ Comparison for needle size of 4 and 5 bytes\n+    __ cmpl(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare - 2),\n+            needleVal);\n+    __ je(L_matchFound);\n+    break;\n+\n+  case 3:\n+  case 4:\n+    \/\/ Comparison for needle size of 6 and 7 bytes\n+    __ cmpl(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare), needleVal);\n+    __ je(L_matchFound);\n+    break;\n+\n+  case 5:\n+  case 6:\n+    \/\/ Comparison for needle size of 8 and 9 bytes\n+    __ cmpq(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare - 2),\n+            needleVal);\n+    __ je(L_matchFound);\n+    break;\n+\n+  case 7:\n+    \/\/ Comparison for needle size of 10 bytes\n+    __ cmpq(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare), needleVal);\n+    __ je(L_matchFound);\n+    break;\n+\n+  default:\n+    break;\n+  }\n+\n+  CLEAR_BIT(mask);  \/\/ Loop as long as there are other bits set\n+  __ jne(L_loopTop);\n+  __ jmp(L_noMatch);\n+}\n+\n+\/\/ highly_optimized_short_cases\n+\/\/ We can handle the cases where haystack size is <= 32 bytes and needle size <= 6 bytes\n+\/\/ as a special case.  We first copy the haystack tpo the stack to avoid page faults.  A mask is\n+\/\/ generated with (n - k + 1) bits set that ensures matches past the end of the original\n+\/\/ haystack do not get considered during compares. In this equation, n is length of haystack\n+\/\/ and k is length of needle.\n+\/\/\n+\/\/ A vector compare for the first needle byte is done against the haystack and anded with the mask.\n+\/\/ For needle size == 1, if there's a match we found it, otherwise failure.  The 2nd position\n+\/\/ of the needle is compared starting from the 2nd position of the haystack and anded with the\n+\/\/ mask.  If needle size == 2 and a match is found, success else failure.  This continues for\n+\/\/ all needle sizes up to 6 bytes.\n+\/\/\n+\/\/ ae - Argument encoding\n+\/\/ haystack - The address of the haystack\n+\/\/ haystack_len - the length of the haystack in elements\n+\/\/ needle - The address of the needle\n+\/\/ needle_len - the length of the needle in elements\n+\/\/ XMM0 - Temporary xmm register\n+\/\/ XMM1 - Temporary xmm register\n+\/\/ mask - Used to hold comparison mask\n+\/\/ tmp - Temporary register\n+\/\/ _masm - Current MacroAssembler instance pointer\n+static void highly_optimized_short_cases(StrIntrinsicNode::ArgEncoding ae, Register haystack,\n+                                         Register haystack_len, Register needle,\n+                                         Register needle_len, XMMRegister XMM0, XMMRegister XMM1,\n+                                         Register mask, Register tmp, MacroAssembler *_masm) {\n+  \/\/ Highly optimized special-cases\n+  Label L_noMatch, L_foundall, L_out;\n+\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = isUL || isUU;  \/\/ At least one is UTF-16\n+\n+  \/\/ Only optimize when haystack can fit on stack with room\n+  \/\/ left over for page fault prevention\n+  assert((COPIED_HAYSTACK_STACK_OFFSET == 0), \"Must be zero!\");\n+  assert((COPIED_HAYSTACK_STACK_SIZE == 64), \"Must be 64!\");\n+\n+  \/\/ Copy incoming haystack onto stack\n+  {\n+    Label L_adjustHaystack, L_moreThan16;\n+\n+    \/\/ Copy haystack to stack (haystack <= 32 bytes)\n+    __ subptr(rsp, COPIED_HAYSTACK_STACK_SIZE);\n+    __ cmpq(haystack_len, isU ? 0x8 : 0x10);\n+    __ ja_b(L_moreThan16);\n+\n+    __ movq(tmp, COPIED_HAYSTACK_STACK_OFFSET + 0x10);\n+    __ movdqu(XMM0, Address(haystack, haystack_len, isU ? Address::times_2 : Address::times_1, -0x10));\n+    __ movdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), XMM0);\n+    __ jmpb(L_adjustHaystack);\n+\n+    __ bind(L_moreThan16);\n+    __ movq(tmp, COPIED_HAYSTACK_STACK_OFFSET + 0x20);\n+    __ vmovdqu(XMM0, Address(haystack, haystack_len, isU ? Address::times_2 : Address::times_1, -0x20));\n+    __ vmovdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), XMM0);\n+\n+    __ bind(L_adjustHaystack);\n+    __ subptr(tmp, haystack_len);\n+\n+    if (isU) {\n+      \/\/ For UTF-16, lengths are half\n+      __ subptr(tmp, haystack_len);\n+    }\n+    \/\/ Point the haystack to the stack\n+    __ leaq(haystack, Address(rsp, tmp, Address::times_1));\n+  }\n+\n+  \/\/ Creates a mask of (n - k + 1) ones.  This prevents recognizing any false-positives\n+  \/\/ past the end of the valid haystack.\n+  __ movq(mask, -1);\n+  __ subq(haystack_len, needle_len);\n+  __ incrementq(haystack_len);\n+  if (isU) {\n+    __ shlq(haystack_len, 1);\n+  }\n+  __ bzhiq(mask, mask, haystack_len);\n+\n+  \/\/ Loop for each needle size from 1 to 6 bytes long.  For UU, only 3 elements.\n+  for (int size = 1; size <= (isUU ? 3 : 6); size++) {\n+    \/\/ Broadcast next needle byte into ymm register\n+    int needle_position = isUU ? (size - 1) * 2 : size - 1;\n+    int haystack_position = isU ? (size - 1) * 2 : size - 1;\n+    if (isUU) {\n+      __ vpbroadcastw(XMM0, Address(needle, needle_position), Assembler::AVX_256bit);\n+    } else if (isUL) {\n+      \/\/ Expand needle\n+      __ movzbl(tmp, Address(needle, needle_position));\n+      __ movdl(XMM0, tmp);\n+      \/\/ Byte of needle to words\n+      __ vpbroadcastw(XMM0, XMM0, Assembler::AVX_256bit);\n+    } else {\n+      __ vpbroadcastb(XMM0, Address(needle, needle_position), Assembler::AVX_256bit);\n+    }\n+\n+    \/\/ Compare next byte.  Keep the comparison mask in mask, which will\n+    \/\/ accumulate\n+    vpcmpeq(XMM1, XMM0, Address(haystack, haystack_position), Assembler::AVX_256bit, ae, _masm);\n+    __ vpmovmskb(tmp, XMM1, Assembler::AVX_256bit);\n+    __ andq(mask, tmp);  \/\/ Accumulate matched bytes\n+    __ testl(mask, mask);\n+    __ je(L_noMatch);\n+\n+    if (size != (isUU ? 3 : 6)) {\n+      \/\/ Found a match for this needle size\n+      __ cmpq(needle_len, size);\n+      __ je(L_foundall);\n+    }\n+  }\n+\n+  __ bind(L_foundall);\n+  __ tzcntl(rax, mask);\n+\n+  if (isU) {\n+    __ shrl(rax, 1);\n+  }\n+\n+  __ bind(L_out);\n+  __ addptr(rsp, COPIED_HAYSTACK_STACK_SIZE);\n+  __ vzeroupper();\n+  __ leave();\n+  __ ret(0);\n+\n+  __ bind(L_noMatch);\n+  __ movq(rax, -1);\n+  __ jmpb(L_out);\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\n+\/\/ Set up jump table entries for both small and large haystack switches.\n+\/\/\n+\/\/ ae - Argument encoding\n+\/\/ L_error - Label to branch to if no match found\n+\/\/ L_checkRange - label to jump to when match found.  Checks validity of returned index\n+\/\/ L_fixup - Jump to here for big cases.  Return value is pointer to matching haystack byte\n+\/\/ *big_jump_table - Address of pointer to the first element of big jump table\n+\/\/ *small_jump_table - Address of pointer to the first element of small jump table\n+\/\/ _masm - Current MacroAssembler instance pointer\n+\n+static void setup_jump_tables(StrIntrinsicNode::ArgEncoding ae, Label &L_error, Label &L_checkRange,\n+                              Label &L_fixup, address *big_jump_table, address *small_jump_table,\n+                              MacroAssembler *_masm) {\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = isUL || isUU;  \/\/ At least one is UTF-16\n+  const XMMRegister byte_1 = XMM_BYTE_1;\n+\n+  address big_hs_jmp_table[NUMBER_OF_CASES];    \/\/ Jump table for large haystacks\n+  address small_hs_jmp_table[NUMBER_OF_CASES];  \/\/ Jump table for small haystacks\n+  int jmp_ndx = 0;\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/  On entry to each case, the register state is:\n+  \/\/\n+  \/\/  rax = unused\n+  \/\/  rbx = &haystack\n+  \/\/  rcx = haystack length\n+  \/\/  rdx = &needle\n+  \/\/  rsi = haystack length\n+  \/\/  rdi = &haystack\n+  \/\/  rbp = unused\n+  \/\/  r8  = unused\n+  \/\/  r9  = unused\n+  \/\/  r10 = hs_len - needle len\n+  \/\/  r11 = unused\n+  \/\/  r12 = needle length\n+  \/\/  r13 = (needle length - 1)\n+  \/\/  r14 = &needle\n+  \/\/  r15 = unused\n+  \/\/  XMM_BYTE_0 - first element of needle, broadcast\n+  \/\/  XMM_BYTE_K - last element of needle, broadcast\n+\n+  {\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\n+    \/\/ Small haystack (<=32 bytes) switch\n+    \/\/\n+    \/\/ Handle cases that were not handled in highly_optimized_short_cases, which will be\n+    \/\/ haystack size <= 32 bytes with 6 < needle size < NUMBER_OF_CASES bytes.\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/  The haystack is <= 32 bytes\n+    \/\/\n+    \/\/ If a match is not found, branch to L_error (which will always\n+    \/\/ return -1).\n+    \/\/\n+    \/\/ If a match is found, jump to L_checkRange, which ensures the\n+    \/\/ matched needle is not past the end of the haystack.\n+    \/\/\n+    \/\/ The index where a match is found is returned in set_bit (r11).\n+\n+    const Register haystack = rbx;\n+    const Register needle = r14;\n+    const Register needle_val = r8;\n+    const Register set_bit = r11;\n+    const Register eq_mask = rsi;\n+    const Register rTmp = rax;\n+\n+    for (int i = 6; i < NUMBER_OF_CASES; i++) {\n+      small_hs_jmp_table[i] = __ pc();\n+      if (isU && ((i + 1) & 1)) {\n+        continue;\n+      } else {\n+        broadcast_additional_needles(true, i + 1, needle, noreg, rTmp, ae, _masm);\n+\n+        compare_haystack_to_needle(true, i + 1, L_error, haystack, eq_mask, noreg, rTmp, XMM_TMP1,\n+                                   XMM_TMP2, ae, _masm);\n+\n+        byte_compare_helper(i + 1, L_error, L_checkRange, needle, needle_val, haystack, eq_mask,\n+                            set_bit, rTmp, ae, _masm);\n+      }\n+    }\n+  }\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\n+  \/\/ Large haystack (> 32 bytes) switch\n+\n+  {\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/  The haystack is > 32 bytes\n+    \/\/\n+    \/\/ The value returned on a match is in hs_ptr (rcx) which is the address\n+    \/\/ of the first matching byte within the haystack.  The L_fixup label\n+    \/\/ takes hs_ptr (rcx), haystack (rbx), and set_bit (r8) to compute the\n+    \/\/ index as: hs_ptr - haystack + r8.  hs_ptr - haystack is the offset\n+    \/\/ within the haystack of the 32-byte chunk wherein a match was found,\n+    \/\/ and set_bit is the index within that 32-byte chunk of the matching string.\n+\n+    const Register haystack = rbx;\n+    const Register needle = r14;\n+    const Register needle_len = r12;\n+    const Register needle_val = r15;\n+    const Register set_bit = r8;\n+    const Register eq_mask = r9;\n+    const Register hs_ptr = rcx;\n+    const Register hsLength = rsi;\n+    const Register rTmp1 = rdi;\n+    const Register rTmp2 = r15;\n+    const Register rTmp3 = rdx;\n+    const Register rTmp4 = r13;\n+\n+    for (int i = 0; i < NUMBER_OF_CASES; i++) {\n+      big_hs_jmp_table[i] = __ pc();\n+      if (isU && ((i + 1) & 1)) {\n+        continue;\n+      } else {\n+        Label L_loopTop;\n+\n+        big_case_loop_helper(true, i + 1, L_error, L_loopTop, eq_mask, hs_ptr, needle_len,\n+                             needle, haystack, hsLength, rTmp1, rTmp2, rTmp3, rTmp4, ae, _masm);\n+        byte_compare_helper(i + 1, L_loopTop, L_fixup, needle, needle_val, hs_ptr, eq_mask, set_bit,\n+                            rTmp4, ae, _masm);\n+      }\n+    }\n+  }\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/ JUMP TABLES\n+  __ align(8);\n+\n+  *big_jump_table = __ pc();\n+\n+  for (jmp_ndx = 0; jmp_ndx < NUMBER_OF_CASES; jmp_ndx++) {\n+    __ emit_address(big_hs_jmp_table[jmp_ndx]);\n+  }\n+\n+  *small_jump_table = __ pc();\n+\n+  for (jmp_ndx = 0; jmp_ndx < NUMBER_OF_CASES; jmp_ndx++) {\n+    __ emit_address(small_hs_jmp_table[jmp_ndx]);\n+  }\n+}\n+\n+#undef STACK_SPACE\n+#undef MAX_NEEDLE_LEN_TO_EXPAND\n+#undef CLEAR_BIT\n+#undef XMM_BYTE_0\n+#undef XMM_BYTE_K\n+#undef XMM_BYTE_1\n+#undef XMM_TMP1\n+#undef XMM_TMP2\n+#undef XMM_TMP3\n+#undef XMM_TMP4\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/x86\/c2_stubGenerator_x86_64_string.cpp","additions":1837,"deletions":0,"binary":false,"changes":1837,"status":"added"},{"patch":"@@ -4250,0 +4250,6 @@\n+#ifdef COMPILER2\n+  if ((UseAVX == 2) && EnableX86ECoreOpts) {\n+    generate_string_indexof(StubRoutines::_string_indexof_array);\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -578,0 +578,3 @@\n+#ifdef COMPILER2\n+  void generate_string_indexof(address *fnptrs);\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  _compiler_stubs_code_size     = 20000 LP64_ONLY(+39000) WINDOWS_ONLY(+2000),\n+  _compiler_stubs_code_size     = 20000 LP64_ONLY(+46000) WINDOWS_ONLY(+2000),\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2200,0 +2200,1 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"stringIndexOf\") == 0 ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1208,0 +1208,3 @@\n+  Node* result = nullptr;\n+  bool call_opt_stub = (StubRoutines::_string_indexof_array[ae] != nullptr);\n+\n@@ -1217,1 +1220,10 @@\n-  Node* result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count, result_rgn, result_phi, ae);\n+  if (call_opt_stub) {\n+    Node* call = make_runtime_call(RC_LEAF, OptoRuntime::string_IndexOf_Type(),\n+                                   StubRoutines::_string_indexof_array[ae],\n+                                   \"stringIndexOf\", TypePtr::BOTTOM, src_start,\n+                                   src_count, tgt_start, tgt_count);\n+    result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n+  } else {\n+    result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count,\n+                               result_rgn, result_phi, ae);\n+  }\n@@ -1229,1 +1241,1 @@\n-\/\/-----------------------------inline_string_indexOf-----------------------\n+\/\/-----------------------------inline_string_indexOfI-----------------------\n@@ -1237,0 +1249,1 @@\n+\n@@ -1262,0 +1275,3 @@\n+  Node* result = nullptr;\n+\n+  bool call_opt_stub = (StubRoutines::_string_indexof_array[ae] != nullptr);\n@@ -1263,1 +1279,11 @@\n-  Node* result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count, region, phi, ae);\n+  if (call_opt_stub) {\n+    assert(arrayOopDesc::base_offset_in_bytes(T_BYTE) >= 16, \"Needed for indexOf\");\n+    Node* call = make_runtime_call(RC_LEAF, OptoRuntime::string_IndexOf_Type(),\n+                                   StubRoutines::_string_indexof_array[ae],\n+                                   \"stringIndexOf\", TypePtr::BOTTOM, src_start,\n+                                   src_count, tgt_start, tgt_count);\n+    result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n+  } else {\n+    result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count,\n+                               region, phi, ae);\n+  }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1361,0 +1361,21 @@\n+\n+\/\/ String IndexOf function\n+const TypeFunc* OptoRuntime::string_IndexOf_Type() {\n+  int argcnt = 4;\n+\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ haystack array\n+  fields[argp++] = TypeInt::INT;        \/\/ haystack length\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ needle array\n+  fields[argp++] = TypeInt::INT;        \/\/ needle length\n+  assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms + 0] = TypeInt::INT; \/\/ Index of needle in haystack\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -300,0 +300,1 @@\n+  static const TypeFunc* string_IndexOf_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -152,0 +152,2 @@\n+address StubRoutines::_string_indexof_array[4]   =    { nullptr };\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -235,0 +235,2 @@\n+  static address _string_indexof_array[4];\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-# Notes on \"client\" keywords : headful sound printer multimon \n+# Notes on \"client\" keywords : headful sound printer multimon\n@@ -34,1 +34,1 @@\n-# \n+#\n@@ -102,0 +102,1 @@\n+    vm.cpu.features \\\n","filename":"test\/jdk\/TEST.ROOT","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2024, Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary test String indexOf() intrinsic\n+ * @run main\/othervm IndexOf\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary test String indexOf() intrinsic\n+ * @requires vm.cpu.features ~= \".*avx2.*\"\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -Xcomp -XX:-TieredCompilation -XX:UseAVX=2 -XX:+UnlockDiagnosticVMOptions -XX:+EnableX86ECoreOpts IndexOf\n+ *\/\n+\n+ public class IndexOf {\n+  final int scope = 32*2+16+8;\n+  final char a, aa, b, c, d;\n+  enum Encoding {LL, UU, UL; }\n+  final Encoding ae;\n+  int failures;\n+\n+  IndexOf(Encoding _ae) {\n+      failures = 0;\n+      ae = _ae;\n+      switch (ae) {\n+          case LL:\n+              a = 'a';\n+              aa = a;\n+              b = 'b';\n+              c = 'c';\n+              d = 'd';\n+              break;\n+          case UU:\n+              a = '\\u0061';\n+              aa = a;\n+              b = '\\u0062';\n+              c = '\\u1063';\n+              d = '\\u0064';\n+              break;\n+          default: \/\/case UL:\n+              a = 'a';\n+              aa = '\\u1061';\n+              b = 'b';\n+              c = 'c';\n+              d = 'd';\n+              break;\n+      }\n+  }\n+\n+  \/\/ needle    =~ \/ab*d\/\n+  \/\/ badNeedle =~ \/ab*db*d\/\n+  interface Append {void append(int pos, char cc);}\n+  String newNeedle(int size, int badPosition) {\n+      if (size<2) {throw new RuntimeException(\"Fix testcase \"+size);}\n+\n+      StringBuilder needle = new StringBuilder(size);\n+      Append n = (int pos, char cc) -> {\n+          if (pos == badPosition)\n+              needle.append(c);\n+          else\n+              needle.append(cc);\n+      };\n+\n+      n.append(0, a);\n+      for (int i=1; i<size-1; i++) {\n+          n.append(i, b);\n+      }\n+      n.append(size-1, d);\n+\n+      return needle.toString();\n+  }\n+\n+  \/\/ haystack  =~ \/a*{needle}d*\/\n+  String newHaystack(int size, String needle, int nPosition) {\n+      if (nPosition+needle.length()>size) {throw new RuntimeException(\"Fix testcase \"+nPosition+\" \"+needle.length()+\" \"+size);}\n+      StringBuilder haystack = new StringBuilder(size);\n+      int i = 0;\n+      for (; i<nPosition; i++) {\n+          haystack.append(aa);\n+      }\n+      haystack.append(needle);\n+      i += needle.length();\n+      for (; i<size; i++) {\n+          haystack.append(d);\n+      }\n+      return haystack.toString();\n+  }\n+\n+  \/\/ haystack =~ \/a*{needle}+b*\/\n+  String newHaystackRepeat(int size, String needle, int nPosition) {\n+      if (nPosition+needle.length()>size) {throw new RuntimeException(\"Fix testcase \"+nPosition+\" \"+needle.length()+\" \"+size);}\n+      StringBuilder haystack = new StringBuilder(size);\n+      int i = 0;\n+      for (; i<nPosition; i++) {\n+          haystack.append(aa);\n+      }\n+      for (; i< nPosition+needle.length(); i += needle.length()) {\n+          haystack.append(needle);\n+      }\n+      for (; i<size; i++) {\n+          haystack.append(d);\n+      }\n+      return haystack.toString();\n+  }\n+\n+  public static void main(String[] args) {\n+      int failures = 0;\n+      for (Encoding ae : Encoding.values()) {\n+          failures += (new IndexOf(ae))\n+              .test0()\n+              .test1()\n+              .test2()\n+              .test3()\n+              .test4()\n+              .failures;\n+      }\n+      if (failures != 0) {\n+          throw new RuntimeException(\"IndexOf test failed.\");\n+      }\n+  }\n+\n+  \/\/ Need to disable checks in String.java if intrinsic is to be tested\n+  IndexOf test0() { \/\/ Test 'trivial cases'\n+      \/\/ if (0==needle_len) return haystack_off;\n+      if (3 != \"Hello\".indexOf(\"\", 3)) {\n+          System.out.println(\"FAILED: if (0==needle_len) return haystack_off\");\n+          failures++;\n+      }\n+      \/\/if (0==haystack_len) return -1;\n+      if (-1 != \"\".indexOf(\"Hello\", 3)) {\n+          System.out.println(\"FAILED: if (0==haystack_len) return -1\");\n+          failures++;\n+      }\n+      \/\/if (needle_len>haystack_len) return -1;\n+      if (-1 != \"Hello\".indexOf(\"HelloWorld\", 3)) {\n+          System.out.println(\"FAILED: if (needle_len>haystack_len) return -1\");\n+          failures++;\n+      }\n+      return this;\n+  }\n+\n+  IndexOf test1() { \/\/ Test expected to find one needle\n+      for (int nSize = 2; nSize<scope; nSize++) {\n+          String needle = newNeedle(nSize, -1);\n+          for (int hSize = nSize; hSize<scope; hSize++) {\n+              for (int i = 0; i<hSize-nSize; i++) {\n+                  String haystack = newHaystack(hSize, needle, i);\n+                  for (int j = 0; j<=i; j++) {\n+                      int found = haystack.indexOf(needle, j);\n+                      if (i != found) {\n+                          System.out.println(\"(\"+ae.name()+\")(T1) Trying needle[\"+nSize+\"] in haystack[\"+hSize+\"] at offset[\"+i+\"]\");\n+                          System.out.println(\"    FAILED: Found \" + needle + \"@\" + found + \" in \" + haystack + \" from [\"+j+\"]\");\n+                          failures++;\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+      return this;\n+  }\n+\n+  IndexOf test2() { \/\/ Test needle with one mismatched character\n+      for (int nSize = 2; nSize<scope; nSize++) {\n+          for (int hSize = nSize; hSize<scope; hSize++) {\n+              String needle = newNeedle(nSize, -1);\n+              for (int badPosition = 0; badPosition < nSize; badPosition+=1) {\n+                  String badNeedle = newNeedle(nSize, badPosition);\n+                  for (int i = 0; i<hSize-nSize; i++) {\n+                      String haystack = newHaystack(hSize, needle, i);\n+                      int found = haystack.indexOf(badNeedle, 1);\n+                      if (-1 != found) {\n+                          System.out.println(\"(\"+ae.name()+\")(T2) Trying bad needle[\"+nSize+\"][\"+badPosition+\"] in haystack[\"+hSize+\"] at offset[\"+i+\"]\");\n+                          System.out.println(\"    FAILED: False \" + found + \" \" + haystack + \"[\"+needle+\"][\"+badNeedle+\"]\");\n+                          failures++;\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+      return this;\n+  }\n+\n+  IndexOf test3() { \/\/ Test expected to find first of the repeated needles\n+      for (int nSize = 2; nSize<scope; nSize++) {\n+          String needle = newNeedle(nSize, -1);\n+          for (int hSize = nSize; hSize<scope; hSize++) {\n+              for (int i = 0; i<hSize-nSize; i++) {\n+                  String haystack = newHaystackRepeat(hSize, needle, i);\n+                  for (int j = 0; j<=i; j++) {\n+                      int found = haystack.indexOf(needle, j);\n+                      if (i != found) {\n+                          System.out.println(\"(\"+ae.name()+\")(T3) Trying repeaded needle[\"+nSize+\"] in haystack[\"+hSize+\"] at offset[\"+i+\"]\");\n+                          System.out.println(\"    FAILED: \" + found + \" \" + haystack + \"[\"+needle+\"]\");\n+                          failures++;\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+      return this;\n+  }\n+\n+  IndexOf test4() { \/\/ Test needle at unreachable offset\n+      for (int nSize = 2; nSize<scope; nSize++) {\n+          String needle = newNeedle(nSize, -1);\n+          for (int hSize = nSize; hSize<scope; hSize++) {\n+              for (int i = 0; i<hSize-nSize; i++) {\n+                  String haystack = newHaystack(hSize, needle, i);\n+                  \/\/ prefix lookup\n+                  for (int j = nSize-1; j<i+nSize; j++) {\n+                      int found = haystack.indexOf(needle, 0, j);\n+                      if (-1 != found) {\n+                          System.out.println(\"(\"+ae.name()+\")(T4) Trying needle[\"+nSize+\"] at offset [\"+i+\"] in haystack[\"+hSize+\"] upto [\"+j+\"]\");\n+                          System.out.println(\"    FAILED: False \" + found + \" \" + haystack + \"[\"+needle+\"]\");\n+                          failures++;\n+                      }\n+                  }\n+\n+                  \/\/ sufix lookup\n+                  for (int j = i+1; j<hSize; j++) {\n+                      int found = haystack.indexOf(needle, j);\n+                      if (-1 != found) {\n+                          System.out.println(\"(\"+ae.name()+\")(T4) Trying needle[\"+nSize+\"] at offset [\"+i+\"] in haystack[\"+hSize+\"] from [\"+j+\"]\");\n+                          System.out.println(\"    FAILED: False \" + found + \" \" + haystack + \"[\"+needle+\"]\");\n+                          failures++;\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+      return this;\n+  }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/String\/IndexOf.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -0,0 +1,1373 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 4162796 4162796\n+ * @summary Test indexOf and lastIndexOf\n+ * @requires vm.cpu.features ~= \".*avx2.*\"\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+EnableX86ECoreOpts -XX:UseAVX=2 -Xbatch -XX:-TieredCompilation -XX:CompileCommand=dontinline,ECoreIndexOf.indexOfKernel ECoreIndexOf\n+ * @key randomness\n+ *\/\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Random;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.nio.charset.Charset;\n+import java.lang.Math;\n+\n+\/\/ @ECoreIndexOf(singleThreaded=true)\n+public class ECoreIndexOf {\n+\n+  static Random generator;\n+  private static boolean failure = false;\n+  static char[] haystack = new char[128];\n+  static char[] haystack_16 = new char[128];\n+\n+  static boolean verbose = false;\n+  static boolean success = true;\n+\n+  static Map<Charset, String> titles = new HashMap<Charset, String>();\n+  static Random rng = new Random(1999);\n+\n+  public static void main(String[] args) throws Exception {\n+    int foo = 0;\n+    String testName = \"ECoreIndexOf\";\n+\n+    generator = new Random();\n+    long seed = generator.nextLong();\n+    generator.setSeed(seed);\n+    System.out.println(\"Seed set to \"+ seed);\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/  WARM-UP \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    for (int i = 0; i < 20000; i++) {\n+      char c = 65;\n+      char c16 = 0x1ed;\n+      StringBuffer sb = new StringBuffer(\"a\");\n+      StringBuffer sb16 = new StringBuffer(\"\\u01fe\");\n+\n+      foo += indexOfKernel(\"\\u01fe\", \"a\");\n+      foo += indexOfKernel(\"\\u01fe\", \"a\", 0);\n+      foo += indexOfKernel(\"\\u01fe\", \"\\u01ff\");\n+      foo += indexOfKernel(\"\\u01fe\", \"\\u01ff\", 0);\n+      foo += indexOfKernel(\"a\", \"a\");\n+      foo += indexOfKernel(\"a\", \"a\", 0);\n+      foo += indexOfKernel(\"a\", \"\\u01ff\");\n+      foo += indexOfKernel(\"a\", \"\\u01ff\", 0);\n+\n+      foo += indexOfKernel(\"\\u01fe\", c);\n+      foo += indexOfKernel(\"\\u01fe\", c, 0);\n+      foo += indexOfKernel(\"\\u01fe\", c16);\n+      foo += indexOfKernel(\"\\u01fe\", c16, 0);\n+      foo += indexOfKernel(\"a\", c);\n+      foo += indexOfKernel(\"a\", c, 0);\n+      foo += indexOfKernel(\"a\", c16);\n+      foo += indexOfKernel(\"a\", c16, 0);\n+\n+      foo += indexOfKernel(sb16, c);\n+      foo += indexOfKernel(sb16, c, 0);\n+      foo += indexOfKernel(sb16, c16);\n+      foo += indexOfKernel(sb16, c16, 0);\n+      foo += indexOfKernel(sb, c);\n+      foo += indexOfKernel(sb, c, 0);\n+      foo += indexOfKernel(sb, c16);\n+      foo += indexOfKernel(sb, c16, 0);\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    String[] decorators = {\"\", \" (same char)\"};\n+    Charset[] charSets = {StandardCharsets.ISO_8859_1, StandardCharsets.UTF_16};\n+    boolean[] truefalse = {true, false};\n+\n+    titles.put(StandardCharsets.ISO_8859_1, \"L\");\n+    titles.put(StandardCharsets.UTF_16, \"U\");\n+\n+    for (int xxy = 0; xxy < 2; xxy++) { \/\/ Run at least twice to ensure stub called\n+\n+      for (int i = 0; i < 128; i++) {\n+        haystack[i] = (char) i;\n+      }\n+\n+      haystack_16[0] = '\\u0000'; \/\/ (char) (23 + 256);\n+      for (int i = 1; i < 128; i++) {\n+        haystack_16[i] = (char) (i);\n+      }\n+\n+      simpleTest();\n+      compareIndexOfLastIndexOf();\n+      compareStringStringBuffer();\n+      StringIndexof();\n+      StringIndexofChar();\n+      StringIndexofHuge();\n+\n+      for (String decorator : decorators) {\n+        for (Charset csHaystack : charSets) {\n+          for (Charset csNeedle : charSets) {\n+            System.out.println(\"Testing \" + titles.get(csHaystack) + titles.get(csNeedle) + decorator);\n+            for (boolean useOffset : truefalse) {\n+              for (boolean useBuffer : truefalse) {\n+                exhaustive(useOffset, useBuffer, csHaystack, csNeedle);\n+              }\n+            }\n+          }\n+        }\n+\n+        for (int i = 0; i < 128; i++) {\n+          haystack[i] = (char) 'a';\n+        }\n+\n+        for (int i = 0; i < 128; i++) {\n+          haystack_16[i] = (char) ('a' + 256);\n+        }\n+      }\n+    }\n+\n+    System.out.println(testName + \" complete.\");\n+\n+    if (failure)\n+      throw new RuntimeException(\"One or more failures.\");\n+  }\n+\n+  private static void report(String testName, int failCount) {\n+    System.err.println(testName + \": \" +\n+        (failCount == 0 ? \"Passed\" : \"Failed(\" + failCount + \")\"));\n+    if (failCount > 0)\n+      failure = true;\n+  }\n+\n+  private static String generateTestString(int min, int max) {\n+    StringBuffer aNewString = new StringBuffer(120);\n+    int aNewLength = getRandomIndex(min, max);\n+    for (int y = 0; y < aNewLength; y++) {\n+      int achar = generator.nextInt(30) + 30;\n+      char test = (char) (achar);\n+      aNewString.append(test);\n+    }\n+    return aNewString.toString();\n+  }\n+\n+  private static String makeRndString(boolean isUtf16, int length) {\n+    StringBuilder sb = new StringBuilder(length);\n+    if (length > 0) {\n+      sb.append(isUtf16 ? '\\u2026' : 'b'); \/\/ ...\n+\n+      for (int i = 1; i < length - 1; i++) {\n+        sb.append((char) ('b' + rng.nextInt(26)));\n+      }\n+\n+      sb.append(rng.nextInt(3) >= 1 ? 'a' : 'b');\/\/ 66.6% of time 'a' is in string\n+    }\n+    return sb.toString();\n+  }\n+\n+  private static int indexOfKernel(String haystack, String needle) {\n+    return haystack.indexOf(needle);\n+  }\n+\n+  private static int indexOfKernel(String haystack, String needle, int offset) {\n+    return haystack.indexOf(needle, offset);\n+  }\n+\n+  private static int indexOfKernel(StringBuffer haystack, String needle) {\n+    return haystack.indexOf(needle);\n+  }\n+\n+  private static int indexOfKernel(StringBuffer haystack, char cneedle) {\n+    String needle = String.valueOf(cneedle);\n+    return haystack.indexOf(needle);\n+  }\n+\n+  private static int indexOfKernel(StringBuffer haystack, String needle, int offset) {\n+    return haystack.indexOf(needle, offset);\n+  }\n+\n+  private static int indexOfKernel(StringBuffer haystack, char cneedle, int offset) {\n+    String needle = String.valueOf(cneedle);\n+    return haystack.indexOf(needle, offset);\n+  }\n+\n+  private static int indexOfKernel(String haystack, char needle) {\n+    return haystack.indexOf(needle);\n+  }\n+\n+  private static int indexOfKernel(String haystack, char needle, int offset) {\n+    return haystack.indexOf(needle, offset);\n+  }\n+\n+  private static void printStringBytes(byte[] bytes) {\n+    System.err.println(\" bytes.len=\" + bytes.length);\n+    for (byte b : bytes) {\n+      System.err.print(String.format(\"0x%02x \", b));\n+    }\n+    System.err.println(\"\");\n+  }\n+\n+  private static int getRandomIndex(int constraint1, int constraint2) {\n+    int range = constraint2 - constraint1;\n+    int x = generator.nextInt(range);\n+    return constraint1 + x;\n+  }\n+\n+  private static int naiveFind(String haystack, String needle) {\n+    return naiveFind(haystack, needle, 0);\n+  }\n+\n+  private static int naiveFind(String haystack, char needle) {\n+    return naiveFind(haystack, needle, 0);\n+  }\n+\n+  private static int naiveFind(String haystack, String needle, int offset) {\n+    int x = offset;\n+    int len = haystack.length() - offset;\n+    if (needle.length() == 0)\n+      return offset;\n+    if (needle.length() > len)\n+      return -1;\n+    int hsndx = 0;\n+    int nndx = 0;\n+    for (int xx = 0; xx < offset; xx++) {\n+      hsndx += Character.charCount(haystack.codePointAt(hsndx));\n+    }\n+\n+    for (x = offset; x < haystack.length() - needle.length() + 1; x++) {\n+      if (haystack.codePointAt(hsndx) == needle.codePointAt(0)) {\n+        nndx = Character.charCount(needle.codePointAt(0));\n+        int hsndx_tmp = hsndx + Character.charCount(haystack.codePointAt(hsndx));\n+\n+        while (nndx < needle.length()) {\n+          if (haystack.codePointAt(hsndx_tmp) != needle.codePointAt(nndx)) {\n+            break;\n+          }\n+          hsndx_tmp += Character.charCount(haystack.codePointAt(hsndx_tmp));\n+          nndx += Character.charCount(needle.codePointAt(nndx));\n+        }\n+        if (nndx == needle.length()) {\n+          return x;\n+        }\n+      }\n+      hsndx += Character.charCount(haystack.codePointAt(hsndx));\n+    }\n+    return -1;\n+  }\n+\n+  private static int naiveFind(String haystack, char cneedle, int offset) {\n+    int x = offset;\n+    int len = haystack.length() - offset;\n+    String needle = String.valueOf(cneedle);\n+    if (len == 0)\n+      return -1;\n+    int hsndx = 0;\n+    for (int xx = 0; xx < offset; xx++) {\n+      hsndx += Character.charCount(haystack.codePointAt(hsndx));\n+    }\n+\n+    for (x = offset; x < haystack.length(); x++) {\n+      if (haystack.codePointAt(hsndx) == needle.codePointAt(0)) {\n+        return x;\n+      }\n+      hsndx += Character.charCount(haystack.codePointAt(hsndx));\n+    }\n+\n+    return -1;\n+  }\n+\n+  private static void exhaustive(boolean useOffset, boolean useStringBuffer, Charset hs_charset,\n+      Charset needleCharset) {\n+    int result = 0;\n+    int midresult = 0;\n+    int endresult = 0;\n+    int l_offset = 0;\n+    int failCount = 0;\n+\n+    String thisTest = titles.get(hs_charset) + titles.get(needleCharset) + (useOffset ? \" w\/offset\" : \"\") + (useStringBuffer ? \" StringBuffer\" : \"\");\n+\n+    for (int needleSize = 0; needleSize < 128; needleSize++) {\n+      for (int haystackSize = 0; haystackSize < 128; haystackSize++) {\n+        for (l_offset = 0; l_offset <= haystackSize; l_offset++) {\n+          String needle = new String(Arrays.copyOfRange(\n+              (needleCharset == StandardCharsets.UTF_16) ? haystack_16 : haystack, l_offset, l_offset + needleSize));\n+          int hsSize = (haystackSize - l_offset) >= 0 ? haystackSize - l_offset : 0;\n+          int midStart = Math.max((hsSize \/ 2) - (needleSize \/ 2), 0);\n+          int endStart = (hsSize > needleSize) ? hsSize - needleSize : 0;\n+          String midNeedle = new String(\n+              Arrays.copyOfRange((needleCharset == StandardCharsets.UTF_16) ? haystack_16 : haystack,\n+                  midStart + l_offset, midStart + needleSize + l_offset));\n+          String endNeedle = new String(\n+              Arrays.copyOfRange((needleCharset == StandardCharsets.UTF_16) ? haystack_16 : haystack,\n+                  endStart + l_offset, endStart + needleSize + l_offset));\n+          String shs = new String(\n+              Arrays.copyOfRange((hs_charset == StandardCharsets.UTF_16) ? haystack_16 : haystack, 0, haystackSize));\n+\n+          \/\/ Truncate needles to correct lengths\n+\n+          if (l_offset + needleSize > haystack.length + 1) {\n+            needle = needle.substring(0, needleSize);\n+            midNeedle = midNeedle.substring(0, needleSize);\n+            endNeedle = endNeedle.substring(0, needleSize);\n+          }\n+\n+          if (!success && needleSize > 1) {\n+            needle = needle.substring(0, needle.length() - 1) + (char) ((int) (needle.charAt(needle.length() - 2) + 1));\n+            midNeedle = midNeedle.substring(0, midNeedle.length() - 1)\n+                + (char) ((int) (midNeedle.charAt(midNeedle.length() - 2) + 1));\n+            endNeedle = endNeedle.substring(0, endNeedle.length() - 1)\n+                + (char) ((int) (endNeedle.charAt(endNeedle.length() - 2) + 1));\n+          }\n+\n+          StringBuffer hs = new StringBuffer(shs.length());\n+          hs.append(shs);\n+          if (!shs.equals(hs.toString()))\n+            throw new RuntimeException(\"Initial equality failure\");\n+\n+          if (useStringBuffer) {\n+            result = indexOfKernel(hs, needle, l_offset);\n+            midresult = indexOfKernel(hs, midNeedle, l_offset);\n+            endresult = indexOfKernel(hs, endNeedle, l_offset);\n+          } else {\n+            result = indexOfKernel(shs, needle, l_offset);\n+            midresult = indexOfKernel(shs, midNeedle, l_offset);\n+            endresult = indexOfKernel(shs, endNeedle, l_offset);\n+          }\n+          int nResult = naiveFind(hs.toString(), needle, l_offset);\n+          int midnResult = naiveFind(hs.toString(), midNeedle, l_offset);\n+          int endnResult = naiveFind(hs.toString(), endNeedle, l_offset);\n+          if (result != nResult) {\n+            failCount++;\n+            System.err.println(\"useOffset=\" + useOffset + \", useStringBuffer=\" + useStringBuffer);\n+            System.err.print(\"Haystack=\");\n+            printStringBytes(shs.getBytes(hs_charset));\n+            System.err.print(\"Needle=\");\n+            printStringBytes(needle.getBytes(needleCharset));\n+            System.err.println(\"l_offset=\" + l_offset);\n+            System.err.println(\"haystackLen=\" + haystackSize + \" needleLen=\" + needleSize +\n+                \" result=\" + result + \" nResult=\" + nResult);\n+            System.err.println(\"\");\n+          }\n+          \/\/ badResults = success ? ((midnResult == -1) || (midresult == -1)) :\n+          \/\/ ((midnResult != -1) || (midresult != -1));\n+          if ((midresult != midnResult)) {\n+            failCount++;\n+            System.err.println(\"useOffset=\" + useOffset + \", useStringBuffer=\" + useStringBuffer);\n+            System.err.print(\"Haystack=\");\n+            printStringBytes(shs.getBytes(hs_charset));\n+            System.err.print(\"Needle=\");\n+            printStringBytes(midNeedle.getBytes(needleCharset));\n+            System.err.println(\"l_offset=\" + l_offset);\n+            System.err.println(\"haystackLen=\" + haystackSize + \" needleLen=\" + needleSize +\n+                \" midresult=\" + midresult + \" midnResult=\" + midnResult);\n+            System.err.println(\"\");\n+          }\n+          \/\/ badResults = success ? ((endnResult == -1) || (endresult == -1)) :\n+          \/\/ ((endnResult != -1) || (endresult != -1));\n+          if ((endresult != endnResult)) {\n+            failCount++;\n+            System.err.println(\"useOffset=\" + useOffset + \", useStringBuffer=\" + useStringBuffer);\n+            System.err.print(\"Haystack=\");\n+            printStringBytes(shs.getBytes(hs_charset));\n+            System.err.print(\"Needle=\");\n+            printStringBytes(endNeedle.getBytes(needleCharset));\n+            System.err.println(\"l_offset=\" + l_offset);\n+            System.err.println(\"haystackLen=\" + haystackSize + \" needleLen=\" + needleSize +\n+                \" endresult=\" + endresult + \" endnResult=\" + endnResult);\n+            System.err.println(\"\");\n+          }\n+\n+          if (!useOffset)\n+            l_offset = haystackSize + 100;\n+        }\n+      }\n+    }\n+\n+    report(\"Exhaustive \" + thisTest, failCount);\n+  }\n+\n+  private static void PrintError(int kernel, int naive, int num, String prefix, String hs, char needle) {\n+    PrintError(kernel, naive, num, prefix, hs, String.valueOf(needle));\n+  }\n+\n+  private static void PrintError(int kernel, int naive, int num, String prefix, String hs, String needle) {\n+    if (!verbose)\n+      return;\n+    System.err.println(prefix + \": (\" + num + \"): kernel=\" + kernel + \", naive=\" + naive);\n+    System.err.print(\"Haystack=\");\n+    printStringBytes(hs.getBytes());\n+    System.err.print(\"Needle=\");\n+    printStringBytes(needle.getBytes());\n+    System.err.println(\"\");\n+  }\n+\n+  private static void simpleTest() {\n+    int failCount = 0;\n+    String sourceString;\n+    StringBuffer sourceBuffer;\n+    String targetString;\n+    String emptyString = \"\";\n+    String allAs = new String(\"aaaaaaaaaaaaaaaaaaaaaaaaa\");\n+    StringBuffer allAsBuffer = new StringBuffer(allAs);\n+\n+    for (int i = 0; i < 10000; i++) {\n+      do {\n+        sourceString = generateTestString(99, 100);\n+        sourceBuffer = new StringBuffer(sourceString);\n+        targetString = generateTestString(10, 11);\n+      } while (indexOfKernel(sourceString, targetString) != -1);\n+\n+      int index1 = generator.nextInt(90) + 5;\n+      sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n+\n+      if ((indexOfKernel(sourceBuffer, targetString) != index1) ||\n+          (index1 != naiveFind(sourceBuffer.toString(), targetString, 0))) {\n+        System.err.println(\"sourceBuffer.indexOf(targetString) fragment '\" + targetString + \"' (\"\n+            + targetString.length() + \") String = \"\n+            + sourceBuffer.toString() + \" len Buffer = \" + sourceBuffer.toString().length());\n+        System.err.println(\"  naive = \" + naiveFind(sourceBuffer.toString(), targetString, 0) + \", IndexOf = \"\n+            + indexOfKernel(sourceBuffer, targetString));\n+        failCount++;\n+      }\n+      if ((indexOfKernel(sourceBuffer, targetString, 5) != index1) ||\n+          (index1 != naiveFind(sourceBuffer.toString(), targetString, 0))) {\n+        System.err.println(\"sourceBuffer.indexOf(targetString, 5) fragment '\" + targetString + \"' (\"\n+            + targetString.length() + \") String = \"\n+            + sourceBuffer.toString() + \" len Buffer = \" + sourceBuffer.toString().length());\n+        System.err.println(\"  naive = \" + naiveFind(sourceBuffer.toString(), targetString, 0) + \", IndexOf = \"\n+            + indexOfKernel(sourceBuffer, targetString, 5));\n+        failCount++;\n+      }\n+      if ((indexOfKernel(sourceBuffer, targetString, 99) == index1) ||\n+          (index1 != naiveFind(sourceBuffer.toString(), targetString, 0))) {\n+        System.err.println(\"sourceBuffer.indexOf(targetString, 99) fragment '\" + targetString + \"' (\"\n+            + targetString.length() + \") String = \"\n+            + sourceBuffer.toString() + \" len Buffer = \" + sourceBuffer.toString().length());\n+        System.err.println(\"  naive = \" + naiveFind(sourceBuffer.toString(), targetString, 0) + \", IndexOf = \"\n+            + indexOfKernel(sourceBuffer, targetString, 99));\n+        failCount++;\n+      }\n+      if ((indexOfKernel(sourceBuffer, emptyString, 99) != 99) ||\n+          (99 != naiveFind(sourceBuffer.toString(), emptyString, 99))) {\n+        System.err.println(\"sourceBuffer.indexOf(emptyString, 99) fragment '\" + emptyString + \"' (\"\n+            + emptyString.length() + \") String = \"\n+            + sourceBuffer.toString() + \" len Buffer = \" + sourceBuffer.toString().length());\n+        System.err.println(\"  naive = \" + naiveFind(sourceBuffer.toString(), emptyString, 99) + \", IndexOf = \"\n+            + indexOfKernel(sourceBuffer, emptyString, 99));\n+        failCount++;\n+      }\n+      if ((indexOfKernel(allAsBuffer.substring(1, 3), allAsBuffer.substring(5, 12)) != -1) ||\n+          (-1 != naiveFind(allAsBuffer.substring(1, 3).toString(), allAsBuffer.substring(5, 12), 0))) {\n+        System.err.println(\"allAsBuffer.substring(1, 3).indexOf(allAsBuffer.substring(5, 12)) fragment '\"\n+            + allAsBuffer.substring(5, 12) + \"' (\"\n+            + allAsBuffer.substring(5, 12).length() + \") String = \"\n+            + allAsBuffer.substring(1, 3) + \" len Buffer = \" + allAsBuffer.substring(1, 3).length());\n+        System.err.println(\n+            \"  naive = \" + naiveFind(allAsBuffer.substring(1, 3).toString(), allAsBuffer.substring(5, 12), 0)\n+                + \", IndexOf = \" + indexOfKernel(allAsBuffer.substring(1, 3), allAsBuffer.substring(5, 12)));\n+        failCount++;\n+      }\n+    }\n+\n+    report(\"Basic Test                   \", failCount);\n+  }\n+\n+  \/\/ Note: it is possible although highly improbable that failCount will\n+  \/\/ be > 0 even if everthing is working ok\n+  private static void compareIndexOfLastIndexOf() {\n+    int failCount = 0;\n+    String sourceString;\n+    StringBuffer sourceBuffer;\n+    String targetString;\n+\n+    for (int i = 0; i < 10000; i++) {\n+      do {\n+        sourceString = generateTestString(99, 100);\n+        sourceBuffer = new StringBuffer(sourceString);\n+        targetString = generateTestString(10, 11);\n+      } while (indexOfKernel(sourceString, targetString) != -1);\n+\n+      int index1 = generator.nextInt(100);\n+      sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n+\n+      \/\/ extremely remote possibility of > 1 match\n+      int matches = 0;\n+      int index2 = -1;\n+      while ((index2 = indexOfKernel(sourceBuffer, targetString, index2 + 1)) != -1)\n+        matches++;\n+      if (matches > 1)\n+        continue;\n+\n+      if (indexOfKernel(sourceBuffer, targetString) != sourceBuffer.lastIndexOf(targetString))\n+        failCount++;\n+      sourceString = sourceBuffer.toString();\n+      if (indexOfKernel(sourceString, targetString) != sourceString.lastIndexOf(targetString))\n+        failCount++;\n+    }\n+\n+    report(\"IndexOf vs LastIndexOf       \", failCount);\n+  }\n+\n+  private static void compareStringStringBuffer() {\n+    int failCount = 0;\n+    boolean make_new = true;\n+\n+    String fragment = null;\n+    StringBuffer testBuffer = null;\n+    String testString = null;\n+    int testIndex = 0;\n+\n+    failCount = indexOfKernel(\"\", \"\");\n+\n+    for (int x = 0; x < 1000000; x++) {\n+      if (make_new) {\n+        testString = generateTestString(1, 100);\n+        int len = testString.length();\n+\n+        testBuffer = new StringBuffer(len);\n+        testBuffer.append(testString);\n+        if (!testString.equals(testBuffer.toString()))\n+          throw new RuntimeException(\"Initial equality failure\");\n+\n+        int x1 = 0;\n+        int x2 = 1000;\n+        while (x2 > testString.length()) {\n+          x1 = generator.nextInt(len);\n+          x2 = generator.nextInt(100);\n+          x2 = x1 + x2;\n+        }\n+        fragment = testString.substring(x1, x2);\n+      }\n+\n+      int sAnswer = indexOfKernel(testString, fragment);\n+      int sbAnswer = indexOfKernel(testBuffer, fragment);\n+\n+      if (sAnswer != sbAnswer) {\n+        System.err.println(\"(1) IndexOf fragment '\" + fragment + \"' (\" + fragment.length() + \") len String = \"\n+            + testString.length() + \" len Buffer = \" + testBuffer.length());\n+        System.err.println(\"  sAnswer = \" + sAnswer + \", sbAnswer = \" + sbAnswer);\n+        System.err.println(\"  testString = '\" + testString + \"'\");\n+        System.err.println(\"  testBuffer = '\" + testBuffer + \"'\");\n+        failCount++;\n+\n+        sAnswer = indexOfKernel(testString, fragment);\n+        sbAnswer = indexOfKernel(testBuffer, fragment);\n+      } else {\n+        if (sAnswer > testString.length()) {\n+          System.err.println(\n+              \"IndexOf returned value out of range; return: \" + sAnswer + \" length max: \" + testBuffer.length());\n+        }\n+      }\n+\n+      if ((fragment == \"0#:02\/62;+-\\\"\\\"0$25-5$#)1263\") && (testBuffer.length() == 94)) {\n+        String xx = \"abc\";\n+        String yy = \"abcdefg\";\n+        int sA = indexOfKernel(xx, yy);\n+      }\n+\n+      if (make_new)\n+        testIndex = getRandomIndex(-100, 100);\n+\n+      sAnswer = indexOfKernel(testString, fragment, testIndex);\n+      sbAnswer = indexOfKernel(testBuffer, fragment, testIndex);\n+\n+      if (sAnswer != sbAnswer) {\n+        System.err.println(\"(2) IndexOf fragment '\" + fragment + \"' (\" + fragment.length() + \") index = \" + testIndex\n+            + \" len String = \" + testString.length() + \" len Buffer = \" + testBuffer.length());\n+        System.err.println(\"  sAnswer = \" + sAnswer + \", sbAnswer = \" + sbAnswer);\n+        System.err.println(\"  testString = '\" + testString + \"'\");\n+        System.err.println(\"  testBuffer = '\" + testBuffer + \"'\");\n+        failCount++;\n+        make_new = true;\n+\n+        sAnswer = indexOfKernel(testString, fragment, testIndex);\n+        sbAnswer = indexOfKernel(testBuffer, fragment, testIndex);\n+      } else {\n+        if ((sAnswer > testString.length()) || ((sAnswer != -1) && (sAnswer < testIndex) && (fragment.length() != 0))) {\n+          System.err.println(\"IndexOf returned value out of range; return: \" + sAnswer + \" length max: \"\n+              + testString.length() + \" index: \" + testIndex);\n+          System.err.println(\"(3) IndexOf fragment '\" + fragment + \"' (\" + fragment.length() + \") index = \" + testIndex\n+              + \" len String = \" + testString.length() + \" len Buffer = \" + testBuffer.length());\n+        }\n+      }\n+\n+      sAnswer = testString.lastIndexOf(fragment);\n+      sbAnswer = testBuffer.lastIndexOf(fragment);\n+\n+      if (sAnswer != sbAnswer) {\n+          System.err.println(\"(1) lastIndexOf fragment '\" + fragment + \"' len String = \" + testString.length()\n+            + \" len Buffer = \" + testBuffer.length());\n+          System.err.println(\"  sAnswer = \" + sAnswer + \", sbAnswer = \" + sbAnswer);\n+          failCount++;\n+\n+          sAnswer = testString.lastIndexOf(fragment);\n+          sbAnswer = testBuffer.lastIndexOf(fragment);\n+      }\n+\n+      if (make_new)\n+        testIndex = getRandomIndex(-100, 100);\n+\n+      sAnswer = testString.lastIndexOf(fragment, testIndex);\n+      sbAnswer = testBuffer.lastIndexOf(fragment, testIndex);\n+\n+      if (sAnswer != sbAnswer) {\n+        System.err.println(\"(2) lastIndexOf fragment '\" + fragment + \"' index = \" + testIndex + \" len String = \"\n+            + testString.length() + \" len Buffer = \" + testBuffer.length());\n+        failCount++;\n+      }\n+    }\n+\n+    report(\"String vs StringBuffer       \", failCount);\n+  }\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/ Test routines used in benchmarks\n+  \/\/\n+  \/\/ From StringIndexofHuge\n+  private static void StringIndexofHuge() {\n+    int stubResult = 0;\n+    int failCount = 0;\n+\n+    for (int xx = 0; xx < 2; xx++) {\n+      int num = 1;\n+\n+      String dataString = \"ngdflsoscargfdgf\";\n+      String dataString16 = \"ngdfilso\\u01facargfd\\u01eef\";\n+      String dataStringHuge = ((\"A\".repeat(32) + \"B\".repeat(32)).repeat(16) + \"X\").repeat(2) + \"bB\";\n+      String dataStringHuge16 = \"\\u01de\" + ((\"A\".repeat(32) + \"B\".repeat(32)).repeat(16) + \"\\u01fe\").repeat(2)\n+          + \"\\u01eeB\";\n+      String earlyMatchString = dataStringHuge.substring(0, 34);\n+      String earlyMatchString16 = dataStringHuge16.substring(0, 34);\n+      String midMatchString = dataStringHuge.substring(dataStringHuge.length() \/ 2 - 16,\n+          dataStringHuge.length() \/ 2 + 32);\n+      String midMatchString16 = dataStringHuge16.substring(dataStringHuge16.length() \/ 2 - 16,\n+          dataStringHuge16.length() \/ 2 + 32);\n+      String lateMatchString = dataStringHuge.substring(dataStringHuge.length() - 31);\n+      String lateMatchString16 = dataStringHuge16.substring(dataStringHuge16.length() - 31);\n+\n+      String searchString = \"oscar\";\n+      String searchString16 = \"o\\u01facar\";\n+      String searchStringSmall = \"dgf\";\n+      String searchStringSmall16 = \"d\\u01eef\";\n+\n+      String searchStringHuge = \"capaapapapasdkajdlkajskldjaslkajdlkajskldjaslkjdlkasjdsalk\";\n+      String searchStringHuge16 = \"capaapapapasdkajdlka\\u01feskldjaslkajdlkajskldjaslkjdlkasjdsalk\";\n+\n+      String searchNoMatch = \"XYXyxYxy\".repeat(22);\n+      String searchNoMatch16 = \"\\u01ab\\u01ba\\u01cb\\u01bc\\u01de\\u01ed\\u01fa\\u01af\".repeat(22);\n+\n+      stubResult = indexOfKernel(dataStringHuge16, earlyMatchString);\n+      int nResult = naiveFind(dataStringHuge16, earlyMatchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16, earlyMatchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge, earlyMatchString);\n+      nResult = naiveFind(dataStringHuge, earlyMatchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge, earlyMatchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge, midMatchString);\n+      nResult = naiveFind(dataStringHuge, midMatchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge, midMatchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge, lateMatchString);\n+      nResult = naiveFind(dataStringHuge, lateMatchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge, lateMatchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge, searchNoMatch);\n+      nResult = naiveFind(dataStringHuge, searchNoMatch);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge, searchNoMatch);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(searchString, searchString);\n+      nResult = naiveFind(searchString, searchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", searchString, searchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataString, searchString);\n+      nResult = naiveFind(dataString, searchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataString, searchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataString, searchStringSmall);\n+      nResult = naiveFind(dataString, searchStringSmall);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataString, searchStringSmall);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge, \"B\".repeat(30) + \"X\" + \"A\".repeat(30), 74);\n+      nResult = naiveFind(dataStringHuge, \"B\".repeat(30) + \"X\" + \"A\".repeat(30), 74);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge,\n+            \"B\".repeat(30) + \"X\" + \"A\".repeat(30));\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge, \"A\".repeat(32) + \"F\" + \"B\".repeat(32), 64);\n+      nResult = naiveFind(dataStringHuge, \"A\".repeat(32) + \"F\" + \"B\".repeat(32), 64);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge,\n+            \"A\".repeat(32) + \"F\" + \"B\".repeat(32));\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(midMatchString, dataStringHuge, 3);\n+      nResult = naiveFind(midMatchString, dataStringHuge, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", midMatchString, dataStringHuge);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge, \"A\".repeat(32) + \"B\".repeat(30) + \"bB\");\n+      nResult = naiveFind(dataStringHuge, \"A\".repeat(32) + \"B\".repeat(30) + \"bB\");\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge,\n+            \"A\".repeat(32) + \"B\".repeat(30) + \"bB\");\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, earlyMatchString);\n+      nResult = naiveFind(dataStringHuge16, earlyMatchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16, earlyMatchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, midMatchString);\n+      nResult = naiveFind(dataStringHuge16, midMatchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16, midMatchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, lateMatchString);\n+      nResult = naiveFind(dataStringHuge16, lateMatchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16, lateMatchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, searchNoMatch);\n+      nResult = naiveFind(dataStringHuge16, searchNoMatch);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16, searchNoMatch);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(searchString16, searchString);\n+      nResult = naiveFind(searchString16, searchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", searchString16, searchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataString16, searchString);\n+      nResult = naiveFind(dataString16, searchString);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataString16, searchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataString16, searchStringSmall);\n+      nResult = naiveFind(dataString16, searchStringSmall);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataString16, searchStringSmall);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, \"B\".repeat(30) + \"X\" + \"A\".repeat(30), 74);\n+      nResult = naiveFind(dataStringHuge16, \"B\".repeat(30) + \"X\" + \"A\".repeat(30), 74);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16,\n+            \"B\".repeat(30) + \"X\" + \"A\".repeat(30));\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, \"A\".repeat(32) + \"F\" + \"B\".repeat(32), 64);\n+      nResult = naiveFind(dataStringHuge16, \"A\".repeat(32) + \"F\" + \"B\".repeat(32), 64);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16,\n+            \"A\".repeat(32) + \"F\" + \"B\".repeat(32));\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(midMatchString16, dataStringHuge, 3);\n+      nResult = naiveFind(midMatchString16, dataStringHuge, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", midMatchString16, dataStringHuge);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, \"A\".repeat(32) + \"B\".repeat(30) + \"bB\");\n+      nResult = naiveFind(dataStringHuge16, \"A\".repeat(32) + \"B\".repeat(30) + \"bB\");\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16,\n+            \"A\".repeat(32) + \"B\".repeat(30) + \"bB\");\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, earlyMatchString16);\n+      nResult = naiveFind(dataStringHuge16, earlyMatchString16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16, earlyMatchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, midMatchString16);\n+      nResult = naiveFind(dataStringHuge16, midMatchString16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16, midMatchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, lateMatchString16);\n+      nResult = naiveFind(dataStringHuge16, lateMatchString16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16, lateMatchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, searchNoMatch16);\n+      nResult = naiveFind(dataStringHuge16, searchNoMatch16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16, searchNoMatch16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(searchString16, searchString16);\n+      nResult = naiveFind(searchString16, searchString16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", searchString16, searchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataString16, searchString16);\n+      nResult = naiveFind(dataString16, searchString16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataString16, searchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataString16, searchStringSmall16);\n+      nResult = naiveFind(dataString16, searchStringSmall16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataString16, searchStringSmall16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, \"B\".repeat(30) + \"X\" + \"A\".repeat(30), 74);\n+      nResult = naiveFind(dataStringHuge16, \"B\".repeat(30) + \"X\" + \"A\".repeat(30), 74);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16,\n+            \"B\".repeat(30) + \"X\" + \"A\".repeat(30));\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, \"A\".repeat(32) + \"\\u01ef\" + \"B\".repeat(32), 64);\n+      nResult = naiveFind(dataStringHuge16, \"A\".repeat(32) + \"\\u01ef\" + \"B\".repeat(32), 64);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16,\n+            \"A\".repeat(32) + \"\\u01ef\" + \"B\".repeat(32));\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(midMatchString16, dataStringHuge16, 3);\n+      nResult = naiveFind(midMatchString16, dataStringHuge16, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", midMatchString16, dataStringHuge16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringHuge16, \"A\".repeat(32) + \"B\".repeat(30) + \"\\u01eeB\");\n+      nResult = naiveFind(dataStringHuge16, \"A\".repeat(32) + \"B\".repeat(30) + \"\\u01eeB\");\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexofHuge\", dataStringHuge16,\n+            \"A\".repeat(32) + \"B\".repeat(30) + \"\\u01eeB\");\n+        failCount++;\n+      }\n+      num++;\n+    }\n+\n+    report(\"StringIndexofHuge            \", failCount);\n+  }\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\n+  \/\/ From StringIndexof\n+  private static void StringIndexof() {\n+    int stubResult = 0;\n+    int failCount = 0;\n+\n+    for (int xx = 0; xx < 2; xx++) {\n+      int num = 1;\n+\n+      String dataString = \"ngdfilsoscargfdgf\";\n+      String searchString = \"oscar\";\n+      String dataStringBig = \"2937489745890797905764956790452976742965790437698498409583479067ngdcapaapapapasdkajdlkajskldjaslkjdlkasjdsalkjas\";\n+      String searchStringBig = \"capaapapapasdkajdlkajskldjaslkjdlkasjdsalk\";\n+      String data = \"0000100101010010110101010010101110101001110110101010010101010010000010111010101010101010100010010101110111010101101010100010010100001010111111100001010101001010100001010101001010101010111010010101010101010101010101010\";\n+      String sub = \"10101010\";\n+      String shortSub1 = \"1\";\n+      String data2 = \"00001001010100a10110101010010101110101001110110101010010101010010000010111010101010101010a100010010101110111010101101010100010010a100a0010101111111000010101010010101000010101010010101010101110a10010101010101010101010101010\";\n+      String shortSub2 = \"a\";\n+      char searchChar = 's';\n+\n+      String string16Short = \"scar\\u01fe1\";\n+      String string16Medium = \"capaapapapasdkajdlkajskldjaslkjdlkasjdsalksca1r\\u01fescar\";\n+      String string16Long = \"2937489745890797905764956790452976742965790437698498409583479067ngdcapaapapapasdkajdlkajskldjaslkjdlkasjdsalkja1sscar\\u01fescar\";\n+      char searchChar16 = 0x1fe;\n+      String searchString16 = \"\\u01fe\";\n+\n+      stubResult = indexOfKernel(dataStringBig, searchChar);\n+      int nResult = naiveFind(dataStringBig, searchChar);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", dataStringBig, searchChar);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(searchStringBig, searchChar);\n+      nResult = naiveFind(searchStringBig, searchChar);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", searchStringBig, searchChar);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(searchString, searchChar);\n+      nResult = naiveFind(searchString, searchChar);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", searchString, searchChar);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Long, searchChar16);\n+      nResult = naiveFind(string16Long, searchChar16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Long, searchChar16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Medium, searchChar16);\n+      nResult = naiveFind(string16Medium, searchChar16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Medium, searchChar16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Short, searchChar16);\n+      nResult = naiveFind(string16Short, searchChar16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Short, searchChar16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringBig, searchChar, 3);\n+      nResult = naiveFind(dataStringBig, searchChar, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", dataStringBig, searchChar);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(searchStringBig, searchChar, 3);\n+      nResult = naiveFind(searchStringBig, searchChar, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", searchStringBig, searchChar);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(searchString, searchChar, 1);\n+      nResult = naiveFind(searchString, searchChar, 1);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", searchString, searchChar);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Long, searchChar16, 3);\n+      nResult = naiveFind(string16Long, searchChar16, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Long, searchChar16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Medium, searchChar16, 3);\n+      nResult = naiveFind(string16Medium, searchChar16, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Medium, searchChar16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Short, searchChar16, 2);\n+      nResult = naiveFind(string16Short, searchChar16, 2);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Short, searchChar16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Long, shortSub1);\n+      nResult = naiveFind(string16Long, shortSub1);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Long, shortSub1);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Medium, shortSub1);\n+      nResult = naiveFind(string16Medium, shortSub1);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Medium, shortSub1);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Long, shortSub2);\n+      nResult = naiveFind(string16Long, shortSub2);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Long, shortSub2);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Long, shortSub1, 3);\n+      nResult = naiveFind(string16Long, shortSub1, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Long, shortSub1);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Medium, shortSub1, 3);\n+      nResult = naiveFind(string16Medium, shortSub1, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Medium, shortSub1);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Short, shortSub2, 1);\n+      nResult = naiveFind(string16Short, shortSub2, 1);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Short, shortSub2);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Long, searchString16, 3);\n+      nResult = naiveFind(string16Long, searchString16, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Long, searchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Medium, searchString16, 3);\n+      nResult = naiveFind(string16Medium, searchString16, 3);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Medium, searchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Short, searchString16, 2);\n+      nResult = naiveFind(string16Short, searchString16, 2);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Short, searchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Long, searchString16);\n+      nResult = naiveFind(string16Long, searchString16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Long, searchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Medium, searchString16);\n+      nResult = naiveFind(string16Medium, searchString16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Medium, searchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(string16Short, searchString16);\n+      nResult = naiveFind(string16Short, searchString16);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", string16Short, searchString16);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataString, searchString, 2);\n+      nResult = naiveFind(dataString, searchString, 2);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", dataString, searchString);\n+        failCount++;\n+      }\n+      num++;\n+      stubResult = indexOfKernel(dataStringBig, searchStringBig, 2);\n+      nResult = naiveFind(dataStringBig, searchStringBig, 2);\n+      if (nResult != stubResult) {\n+        PrintError(stubResult, nResult, num, \"StringIndexof\", dataStringBig, searchStringBig);\n+      }\n+      {\n+        int index = 0;\n+        int dummy = 0;\n+        while ((index = indexOfKernel(data, sub, index)) > -1) {\n+          nResult = naiveFind(data, sub, index);\n+          if (index != nResult) {\n+            PrintError(stubResult, nResult, num, \"StringIndexof\", data, sub);\n+            failCount++;\n+          }\n+          index++;\n+          dummy += index;\n+        }\n+        num++;\n+      }\n+      {\n+        int dummy = 0;\n+        int index = 0;\n+        while ((index = indexOfKernel(data, shortSub1, index)) > -1) {\n+          nResult = naiveFind(data, shortSub1, index);\n+          if (index != nResult) {\n+            PrintError(stubResult, nResult, num, \"StringIndexof\", data, shortSub1);\n+            failCount++;\n+          }\n+          index++;\n+          dummy += index;\n+        }\n+        num++;\n+      }\n+      {\n+        int dummy = 0;\n+        int index = 0;\n+        while ((index = indexOfKernel(data2, shortSub2, index)) > -1) {\n+          nResult = naiveFind(data2, shortSub2, index);\n+          if (index != nResult) {\n+            PrintError(stubResult, nResult, num, \"StringIndexof\", data2, shortSub2);\n+            failCount++;\n+          }\n+          index++;\n+          dummy += index;\n+        }\n+        num++;\n+      }\n+      {\n+        String tmp = \"simple-hash:SHA-1\/UTF-8\";\n+        if (!tmp.contains(\"SHA-1\")) {\n+          PrintError(stubResult, nResult, num, \"StringIndexof\", \"simple-hash:SHA-1\/UTF-8\", \"SHA-1\");\n+          failCount++;\n+        }\n+        num++;\n+      }\n+    }\n+\n+    report(\"StringIndexof                \", failCount);\n+  }\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\n+  \/\/ From StringIndexofChar\n+  private static void StringIndexofChar() {\n+    int stubResult = 0;\n+    int failCount = 0;\n+\n+    for (int xx = 0; xx < 2; xx++) {\n+      stubResult = 0;\n+      int nResult = 0;\n+      int num = 1;\n+\n+      String[] latn1_short = new String[100];\n+      String[] latn1_sse4 = new String[100];\n+      String[] latn1_avx2 = new String[100];\n+      String[] latn1_mixedLength = new String[100];\n+      String[] utf16_short = new String[100];\n+      String[] utf16_sse4 = new String[100];\n+      String[] utf16_avx2 = new String[100];\n+      String[] utf16_mixedLength = new String[100];\n+\n+      for (int i = 0; i < 100; i++) {\n+        latn1_short[i] = makeRndString(false, 15);\n+        latn1_sse4[i] = makeRndString(false, 16);\n+        latn1_avx2[i] = makeRndString(false, 32);\n+        utf16_short[i] = makeRndString(true, 7);\n+        utf16_sse4[i] = makeRndString(true, 8);\n+        utf16_avx2[i] = makeRndString(true, 16);\n+        latn1_mixedLength[i] = makeRndString(false, rng.nextInt(65));\n+        utf16_mixedLength[i] = makeRndString(true, rng.nextInt(65));\n+      }\n+      for (String what : latn1_mixedLength) {\n+        stubResult = indexOfKernel(what, 'a');\n+        nResult = naiveFind(what, 'a');\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, 'a');\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : utf16_mixedLength) {\n+        stubResult = indexOfKernel(what, 'a');\n+        nResult = naiveFind(what, 'a');\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, 'a');\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : latn1_mixedLength) {\n+        stubResult = indexOfKernel(what, \"a\");\n+        nResult = naiveFind(what, \"a\");\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, \"a\");\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : utf16_mixedLength) {\n+        stubResult = indexOfKernel(what, \"a\");\n+        nResult = naiveFind(what, \"a\");\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, \"a\");\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : latn1_short) {\n+        stubResult = indexOfKernel(what, 'a');\n+        nResult = naiveFind(what, 'a');\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, 'a');\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : latn1_sse4) {\n+        stubResult = indexOfKernel(what, 'a');\n+        nResult = naiveFind(what, 'a');\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, 'a');\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : latn1_avx2) {\n+        stubResult = indexOfKernel(what, 'a');\n+        nResult = naiveFind(what, 'a');\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, 'a');\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : utf16_short) {\n+        stubResult = indexOfKernel(what, 'a');\n+        nResult = naiveFind(what, 'a');\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, 'a');\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : utf16_sse4) {\n+        stubResult = indexOfKernel(what, 'a');\n+        nResult = naiveFind(what, 'a');\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, 'a');\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : utf16_avx2) {\n+        stubResult = indexOfKernel(what, 'a');\n+        nResult = naiveFind(what, 'a');\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, 'a');\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : latn1_short) {\n+        stubResult = indexOfKernel(what, \"a\");\n+        nResult = naiveFind(what, \"a\");\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, \"a\");\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : latn1_sse4) {\n+        stubResult = indexOfKernel(what, \"a\");\n+        nResult = naiveFind(what, \"a\");\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, \"a\");\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : latn1_avx2) {\n+        stubResult = indexOfKernel(what, \"a\");\n+        nResult = naiveFind(what, \"a\");\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, \"a\");\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : utf16_short) {\n+        stubResult = indexOfKernel(what, \"a\");\n+        nResult = naiveFind(what, \"a\");\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, \"a\");\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : utf16_sse4) {\n+        stubResult = indexOfKernel(what, \"a\");\n+        nResult = naiveFind(what, \"a\");\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, \"a\");\n+          failCount++;\n+        }\n+      }\n+      num++;\n+      for (String what : utf16_avx2) {\n+        stubResult = indexOfKernel(what, \"a\");\n+        nResult = naiveFind(what, \"a\");\n+        if (nResult != stubResult) {\n+          PrintError(stubResult, nResult, num, \"StringIndexofChar\", what, \"a\");\n+          failCount++;\n+        }\n+      }\n+      num++;\n+    }\n+\n+    report(\"StringIndexofChar            \", failCount);\n+  }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StringBuffer\/ECoreIndexOf.java","additions":1373,"deletions":0,"binary":false,"changes":1373,"status":"added"},{"patch":"@@ -30,159 +30,159 @@\n-import java.util.Random;\n-\n-public class IndexOf {\n-\n-    static Random generator = new Random();\n-    private static boolean failure = false;\n-\n-    public static void main(String[] args) throws Exception {\n-        simpleTest();\n-        compareIndexOfLastIndexOf();\n-        compareStringStringBuffer();\n-\n-        if (failure)\n-           throw new RuntimeException(\"One or more BitSet failures.\");\n-    }\n-\n-    private static void report(String testName, int failCount) {\n-        System.err.println(testName+\": \" +\n-                         (failCount==0 ? \"Passed\":\"Failed(\"+failCount+\")\"));\n-        if (failCount > 0)\n-            failure = true;\n-    }\n-\n-    private static String generateTestString(int min, int max) {\n-        StringBuffer aNewString = new StringBuffer(120);\n-        int aNewLength = getRandomIndex(min, max);\n-        for(int y=0; y<aNewLength; y++) {\n-            int achar = generator.nextInt(30)+30;\n-            char test = (char)(achar);\n-            aNewString.append(test);\n-        }\n-        return aNewString.toString();\n-    }\n-\n-    private static int getRandomIndex(int constraint1, int constraint2) {\n-        int range = constraint2 - constraint1;\n-        int x = generator.nextInt(range);\n-        return constraint1 + x;\n-    }\n-\n-    private static void simpleTest() {\n-        int failCount = 0;\n-        String sourceString;\n-        StringBuffer sourceBuffer;\n-        String targetString;\n-\n-        for (int i=0; i<10000; i++) {\n-            do {\n-                sourceString = generateTestString(99, 100);\n-                sourceBuffer = new StringBuffer(sourceString);\n-                targetString = generateTestString(10, 11);\n-            } while (sourceString.indexOf(targetString) != -1);\n-\n-            int index1 = generator.nextInt(90) + 5;\n-            sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n-\n-            if (sourceBuffer.indexOf(targetString) != index1)\n-                failCount++;\n-            if (sourceBuffer.indexOf(targetString, 5) != index1)\n-                failCount++;\n-            if (sourceBuffer.indexOf(targetString, 99) == index1)\n-                failCount++;\n-        }\n-\n-        report(\"Basic Test                   \", failCount);\n-    }\n-\n-    \/\/ Note: it is possible although highly improbable that failCount will\n-    \/\/ be > 0 even if everthing is working ok\n-    private static void compareIndexOfLastIndexOf() {\n-        int failCount = 0;\n-        String sourceString;\n-        StringBuffer sourceBuffer;\n-        String targetString;\n-\n-        for (int i=0; i<10000; i++) {\n-            do {\n-                sourceString = generateTestString(99, 100);\n-                sourceBuffer = new StringBuffer(sourceString);\n-                targetString = generateTestString(10, 11);\n-            } while (sourceString.indexOf(targetString) != -1);\n-\n-            int index1 = generator.nextInt(100);\n-            sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n-\n-            \/\/ extremely remote possibility of > 1 match\n-            int matches = 0;\n-            int index2 = -1;\n-            while((index2 = sourceBuffer.indexOf(targetString,index2+1)) != -1)\n-                matches++;\n-            if (matches > 1)\n-                continue;\n-\n-            if (sourceBuffer.indexOf(targetString) !=\n-                sourceBuffer.lastIndexOf(targetString))\n-                failCount++;\n-            sourceString = sourceBuffer.toString();\n-            if (sourceString.indexOf(targetString) !=\n-                sourceString.lastIndexOf(targetString))\n-                failCount++;\n-        }\n-\n-        report(\"IndexOf vs LastIndexOf       \", failCount);\n-    }\n-\n-    private static void compareStringStringBuffer() {\n-        int failCount = 0;\n-\n-        for (int x=0; x<10000; x++) {\n-            String testString = generateTestString(1, 100);\n-            int len = testString.length();\n-\n-            StringBuffer testBuffer = new StringBuffer(len);\n-            testBuffer.append(testString);\n-            if (!testString.equals(testBuffer.toString()))\n-                throw new RuntimeException(\"Initial equality failure\");\n-\n-            int x1 = 0;\n-            int x2 = 1000;\n-            while(x2 > testString.length()) {\n-                x1 = generator.nextInt(len);\n-                x2 = generator.nextInt(100);\n-                x2 = x1 + x2;\n-            }\n-            String fragment = testString.substring(x1,x2);\n-\n-            int sAnswer = testString.indexOf(fragment);\n-            int sbAnswer = testBuffer.indexOf(fragment);\n-\n-            if (sAnswer != sbAnswer)\n-                failCount++;\n-\n-            int testIndex = getRandomIndex(-100, 100);\n-\n-            sAnswer = testString.indexOf(fragment, testIndex);\n-            sbAnswer = testBuffer.indexOf(fragment, testIndex);\n-\n-            if (sAnswer != sbAnswer)\n-                failCount++;\n-\n-            sAnswer = testString.lastIndexOf(fragment);\n-            sbAnswer = testBuffer.lastIndexOf(fragment);\n-\n-            if (sAnswer != sbAnswer)\n-                failCount++;\n-\n-            testIndex = getRandomIndex(-100, 100);\n-\n-            sAnswer = testString.lastIndexOf(fragment, testIndex);\n-            sbAnswer = testBuffer.lastIndexOf(fragment, testIndex);\n-\n-            if (sAnswer != sbAnswer)\n-                failCount++;\n-        }\n-\n-        report(\"String vs StringBuffer       \", failCount);\n-    }\n-\n-}\n+ import java.util.Random;\n+\n+ public class IndexOf {\n+\n+     static Random generator = new Random();\n+     private static boolean failure = false;\n+\n+     public static void main(String[] args) throws Exception {\n+         simpleTest();\n+         compareIndexOfLastIndexOf();\n+         compareStringStringBuffer();\n+\n+         if (failure)\n+            throw new RuntimeException(\"One or more BitSet failures.\");\n+     }\n+\n+     private static void report(String testName, int failCount) {\n+         System.err.println(testName+\": \" +\n+                          (failCount==0 ? \"Passed\":\"Failed(\"+failCount+\")\"));\n+         if (failCount > 0)\n+             failure = true;\n+     }\n+\n+     private static String generateTestString(int min, int max) {\n+         StringBuffer aNewString = new StringBuffer(120);\n+         int aNewLength = getRandomIndex(min, max);\n+         for(int y=0; y<aNewLength; y++) {\n+             int achar = generator.nextInt(30)+30;\n+             char test = (char)(achar);\n+             aNewString.append(test);\n+         }\n+         return aNewString.toString();\n+     }\n+\n+     private static int getRandomIndex(int constraint1, int constraint2) {\n+         int range = constraint2 - constraint1;\n+         int x = generator.nextInt(range);\n+         return constraint1 + x;\n+     }\n+\n+     private static void simpleTest() {\n+         int failCount = 0;\n+         String sourceString;\n+         StringBuffer sourceBuffer;\n+         String targetString;\n+\n+         for (int i=0; i<10000; i++) {\n+             do {\n+                 sourceString = generateTestString(99, 100);\n+                 sourceBuffer = new StringBuffer(sourceString);\n+                 targetString = generateTestString(10, 11);\n+             } while (sourceString.indexOf(targetString) != -1);\n+\n+             int index1 = generator.nextInt(90) + 5;\n+             sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n+\n+             if (sourceBuffer.indexOf(targetString) != index1)\n+                 failCount++;\n+             if (sourceBuffer.indexOf(targetString, 5) != index1)\n+                 failCount++;\n+             if (sourceBuffer.indexOf(targetString, 99) == index1)\n+                 failCount++;\n+         }\n+\n+         report(\"Basic Test                   \", failCount);\n+     }\n+\n+     \/\/ Note: it is possible although highly improbable that failCount will\n+     \/\/ be > 0 even if everthing is working ok\n+     private static void compareIndexOfLastIndexOf() {\n+         int failCount = 0;\n+         String sourceString;\n+         StringBuffer sourceBuffer;\n+         String targetString;\n+\n+         for (int i=0; i<10000; i++) {\n+             do {\n+                 sourceString = generateTestString(99, 100);\n+                 sourceBuffer = new StringBuffer(sourceString);\n+                 targetString = generateTestString(10, 11);\n+             } while (sourceString.indexOf(targetString) != -1);\n+\n+             int index1 = generator.nextInt(100);\n+             sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n+\n+             \/\/ extremely remote possibility of > 1 match\n+             int matches = 0;\n+             int index2 = -1;\n+             while((index2 = sourceBuffer.indexOf(targetString,index2+1)) != -1)\n+                 matches++;\n+             if (matches > 1)\n+                 continue;\n+\n+             if (sourceBuffer.indexOf(targetString) !=\n+                 sourceBuffer.lastIndexOf(targetString))\n+                 failCount++;\n+             sourceString = sourceBuffer.toString();\n+             if (sourceString.indexOf(targetString) !=\n+                 sourceString.lastIndexOf(targetString))\n+                 failCount++;\n+         }\n+\n+         report(\"IndexOf vs LastIndexOf       \", failCount);\n+     }\n+\n+     private static void compareStringStringBuffer() {\n+         int failCount = 0;\n+\n+         for (int x=0; x<10000; x++) {\n+             String testString = generateTestString(1, 100);\n+             int len = testString.length();\n+\n+             StringBuffer testBuffer = new StringBuffer(len);\n+             testBuffer.append(testString);\n+             if (!testString.equals(testBuffer.toString()))\n+                 throw new RuntimeException(\"Initial equality failure\");\n+\n+             int x1 = 0;\n+             int x2 = 1000;\n+             while(x2 > testString.length()) {\n+                 x1 = generator.nextInt(len);\n+                 x2 = generator.nextInt(100);\n+                 x2 = x1 + x2;\n+             }\n+             String fragment = testString.substring(x1,x2);\n+\n+             int sAnswer = testString.indexOf(fragment);\n+             int sbAnswer = testBuffer.indexOf(fragment);\n+\n+             if (sAnswer != sbAnswer)\n+                 failCount++;\n+\n+             int testIndex = getRandomIndex(-100, 100);\n+\n+             sAnswer = testString.indexOf(fragment, testIndex);\n+             sbAnswer = testBuffer.indexOf(fragment, testIndex);\n+\n+             if (sAnswer != sbAnswer)\n+                 failCount++;\n+\n+             sAnswer = testString.lastIndexOf(fragment);\n+             sbAnswer = testBuffer.lastIndexOf(fragment);\n+\n+             if (sAnswer != sbAnswer)\n+                 failCount++;\n+\n+             testIndex = getRandomIndex(-100, 100);\n+\n+             sAnswer = testString.lastIndexOf(fragment, testIndex);\n+             sbAnswer = testBuffer.lastIndexOf(fragment, testIndex);\n+\n+             if (sAnswer != sbAnswer)\n+                 failCount++;\n+         }\n+\n+         report(\"String vs StringBuffer       \", failCount);\n+     }\n+\n+ }\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/StringBuffer\/IndexOf.java","additions":159,"deletions":159,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class StringIndexOfHuge {\n+\n+  private String dataString;\n+  private String dataString16;\n+  private String dataStringHuge;\n+  private String dataStringHuge16;\n+  private String earlyMatchString;\n+  private String earlyMatchString16;\n+  private String midMatchString;\n+  private String midMatchString16;\n+  private String lateMatchString;\n+  private String lateMatchString16;\n+\n+  private String searchString;\n+  private String searchString16;\n+  private String searchStringSmall;\n+  private String searchStringSmall16;\n+\n+  private String searchStringHuge;\n+  private String searchStringHuge16;\n+\n+  private String searchNoMatch;\n+  private String searchNoMatch16;\n+\n+  private String Amdahl_1;\n+  private String Amdahl_2;\n+  private String Amdahl_3;\n+  private String Amdahl_4;\n+  private String Amdahl_5;\n+  private String Amdahl_6;\n+\n+  @Setup\n+  public void setup() {\n+    dataString = \"ngdflsoscargfdgf\";\n+    dataString16 = \"ngdfilso\\u01facargfd\\u01eef\";\n+    dataStringHuge = ((\"A\".repeat(32) + \"B\".repeat(32)).repeat(16) + \"X\").repeat(2) + \"bB\";\n+    dataStringHuge16 = \"\\u01de\" + ((\"A\".repeat(32) + \"B\".repeat(32)).repeat(16) + \"\\u01fe\").repeat(2) + \"\\u01eeB\";\n+    earlyMatchString = dataStringHuge.substring(0, 34);\n+    earlyMatchString16 = dataStringHuge16.substring(0, 34);\n+    midMatchString = dataStringHuge.substring(dataStringHuge.length() \/ 2 - 16, dataStringHuge.length() \/ 2 + 17);\n+    midMatchString16 = dataStringHuge16.substring(dataStringHuge16.length() \/ 2 - 16, dataStringHuge16.length() \/ 2 + 17);\n+    lateMatchString = dataStringHuge.substring(dataStringHuge.length() - 31);\n+    lateMatchString16 = dataStringHuge16.substring(dataStringHuge16.length() - 31);\n+\n+    searchString = \"oscar\";\n+    searchString16 = \"o\\u01facar\";\n+    searchStringSmall = \"dgf\";\n+    searchStringSmall16 = \"d\\u01eef\";\n+\n+    searchStringHuge = \"capaapapapasdkajdlkajskldjaslkajdlkajskldjaslkjdlkasjdsalk\";\n+    searchStringHuge16 = \"capaapapapasdkajdlka\\u01feskldjaslkajdlkajskldjaslkjdlkasjdsalk\";\n+\n+    searchNoMatch = \"XYXyxYxy\".repeat(22);\n+    searchNoMatch16 = \"\\u01ab\\u01ba\\u01cb\\u01bc\\u01de\\u01ed\\u01fa\\u01af\".repeat(22);\n+\n+    Amdahl_1 = \"B\".repeat(30) + \"X\" + \"A\".repeat(30);\n+    Amdahl_2 = \"A\".repeat(32) + \"F\" + \"B\".repeat(32);\n+    Amdahl_3 = \"A\".repeat(32) + \"B\".repeat(32) + \"XbB\";\n+    Amdahl_4 = \"B\".repeat(30) + \"\\u01ef\" + \"A\".repeat(30);\n+    Amdahl_5 = \"A\".repeat(32) + \"\\u01ef\" + \"B\".repeat(32);\n+    Amdahl_6 = \"A\".repeat(32) + \"B\".repeat(32) + \"\\u01fe\\u01eeB\";\n+  }\n+\n+\n+  \/** IndexOf Micros *\/\n+  @Benchmark\n+  public int searchHugeEarlyMatch() {\n+      return dataStringHuge.indexOf(earlyMatchString);\n+  }\n+\n+  @Benchmark\n+  public int searchHugeMiddleMatch() {\n+      return dataStringHuge.indexOf(midMatchString);\n+  }\n+\n+  @Benchmark\n+  public int searchHugeLateMatch() {\n+      return dataStringHuge.indexOf(lateMatchString);\n+  }\n+\n+  @Benchmark\n+  public int searchHugeNoMatch() {\n+      return dataStringHuge.indexOf(searchNoMatch);\n+  }\n+\n+  @Benchmark\n+  public int searchSmallEarlyMatch() {\n+      return searchString.indexOf(searchString);\n+  }\n+\n+  @Benchmark\n+  public int searchSmallMidMatch() {\n+      return dataString.indexOf(searchString);\n+  }\n+\n+  @Benchmark\n+  public int searchSmallLateMatch() {\n+      return dataString.indexOf(searchStringSmall);\n+  }\n+\n+  @Benchmark\n+  public int searchHugeLargeSubstring() {\n+      return dataStringHuge.indexOf(Amdahl_1, 74);\n+  }\n+\n+  @Benchmark\n+  public int searchHugeLargeSubstringNoMatch() {\n+      return dataStringHuge.indexOf(Amdahl_2, 64);\n+  }\n+\n+  @Benchmark\n+  public int searchSubstringLongerThanString() {\n+      return midMatchString.indexOf(dataStringHuge, 3);\n+  }\n+\n+  @Benchmark\n+  public int searchHugeWorstCase() {\n+      return dataStringHuge.indexOf(Amdahl_3);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeEarlyMatch() {\n+    return dataStringHuge16.indexOf(earlyMatchString);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeMiddleMatch() {\n+    return dataStringHuge16.indexOf(midMatchString);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeLateMatch() {\n+    return dataStringHuge16.indexOf(lateMatchString);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeNoMatch() {\n+    return dataStringHuge16.indexOf(searchNoMatch);\n+  }\n+\n+  @Benchmark\n+  public int search16SmallEarlyMatch() {\n+    return searchString16.indexOf(searchString);\n+  }\n+\n+  @Benchmark\n+  public int search16SmallMidMatch() {\n+    return dataString16.indexOf(searchString);\n+  }\n+\n+  @Benchmark\n+  public int search16SmallLateMatch() {\n+    return dataString16.indexOf(searchStringSmall);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeLargeSubstring() {\n+    return dataStringHuge16.indexOf(Amdahl_1, 74);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeLargeSubstringNoMatch() {\n+    return dataStringHuge16.indexOf(Amdahl_2, 64);\n+  }\n+\n+  @Benchmark\n+  public int search16SubstringLongerThanString() {\n+    return midMatchString16.indexOf(dataStringHuge, 3);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeWorstCase() {\n+    return dataStringHuge16.indexOf(Amdahl_3);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeEarlyMatch16() {\n+    return dataStringHuge16.indexOf(earlyMatchString16);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeMiddleMatch16() {\n+    return dataStringHuge16.indexOf(midMatchString16);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeLateMatch16() {\n+    return dataStringHuge16.indexOf(lateMatchString16);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeNoMatch16() {\n+    return dataStringHuge16.indexOf(searchNoMatch16);\n+  }\n+\n+  @Benchmark\n+  public int search16SmallEarlyMatch16() {\n+    return searchString16.indexOf(searchString16);\n+  }\n+\n+  @Benchmark\n+  public int search16SmallMidMatch16() {\n+    return dataString16.indexOf(searchString16);\n+  }\n+\n+  @Benchmark\n+  public int search16SmallLateMatch16() {\n+    return dataString16.indexOf(searchStringSmall16);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeLargeSubstring16() {\n+    return dataStringHuge16.indexOf(Amdahl_4, 74);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeLargeSubstringNoMatch16() {\n+    return dataStringHuge16.indexOf(Amdahl_5, 64);\n+  }\n+\n+  @Benchmark\n+  public int search16SubstringLongerThanString16() {\n+    return midMatchString16.indexOf(dataStringHuge16, 3);\n+  }\n+\n+  @Benchmark\n+  public int search16HugeWorstCase16() {\n+    return dataStringHuge16.indexOf(Amdahl_6);\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringIndexOfHuge.java","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"}]}