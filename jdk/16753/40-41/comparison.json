{"files":[{"patch":"@@ -258,1 +258,1 @@\n-  Label L_returnRBP, L_checkRangeAndReturn, L_returnError, L_bigCaseFixupAndReturn;\n+  Label L_checkRangeAndReturn, L_returnError, L_bigCaseFixupAndReturn;\n@@ -315,1 +315,1 @@\n-  setup_jump_tables(ae, L_returnRBP, L_checkRangeAndReturn, L_bigCaseFixupAndReturn,\n+  setup_jump_tables(ae, L_returnError, L_checkRangeAndReturn, L_bigCaseFixupAndReturn,\n@@ -474,4 +474,0 @@\n-\/\/ Used to check and return value in rbp - usually error\n-  __ bind(L_returnRBP);\n-  __ movq(rax, rbp);\n-\n@@ -603,5 +599,5 @@\n-    __ leaq(haystackStart, Address(hsPtrRet, index));\n-    \/\/ Starting address of first byte of needle to compare\n-    __ movq(firstNeedleCompare, needle);\n-    \/\/ Number of bytes to compare\n-    __ movq(compLen, needleLen);\n+    __ leaq(haystackStart, Address(hsPtrRet, index, Address::times_1, isU ? 4 : 2));\n+        \/\/ Starting address of first byte of needle to compare\n+    __ leaq(firstNeedleCompare, Address(needle, isU ? 4 : 2));\n+        \/\/ Number of bytes to compare\n+    __ leaq(compLen, Address(needleLen, isU ? -6 : -3));\n@@ -699,1 +695,1 @@\n-    compare_haystack_to_needle(false, 0, L_returnRBP, haystack, mask, needleLen, rTmp3, XMM_TMP1,\n+    compare_haystack_to_needle(false, 0, L_returnError, haystack, mask, needleLen, rTmp3, XMM_TMP1,\n@@ -734,1 +730,1 @@\n-    __ jmp(L_returnRBP);\n+    __ jmp(L_returnError);\n@@ -782,1 +778,1 @@\n-    __ jg(L_returnRBP);\n+    __ jg(L_returnError);\n@@ -970,1 +966,1 @@\n-      __ jg(L_returnRBP);\n+      __ jg(L_returnError);\n@@ -1334,29 +1330,25 @@\n-  if (!sizeKnown) {\n-    __ cmpq(nMinusK, 32);\n-    __ jae_b(L_greaterThan32);\n-\n-    \/\/ Here the needle is too long, so we can't do a 32-byte read.\n-    \/\/ Default to a pseudo-scalar compare.\n-    \/\/ Find a match within the first 32 bytes for the first character.\n-    \/\/ If the matched character is at an offset > nMinusK, there's no match.\n-    \/\/ Otherwise fall out of the loop and let the callee do the compare.\n-    \/\/ Set last to hsPtrRet so the next attempt at loop iteration ends the compare.\n-    __ movq(last, haystack);\n-    __ movq(hsPtrRet, haystack);\n-\n-    \/\/ Build bitmask for compare\n-    __ movq(rTmp2, -1);\n-    __ movq(eq_mask, nMinusK);\n-    __ addq(eq_mask, 1);\n-    __ bzhiq(rTmp2, rTmp2, eq_mask);\n-\n-    \/\/ Compare first byte of needle to haystack and mask result\n-    vpcmpeq(XMM_TMP3, XMM_BYTE_0, Address(haystack, 0), Assembler::AVX_256bit, ae, _masm);\n-\n-    __ vpmovmskb(eq_mask, XMM_TMP3, Assembler::AVX_256bit);\n-    __ andq(eq_mask, rTmp2);\n-\n-    __ testl(eq_mask, eq_mask);\n-    __ je(noMatch);\n-\n-    __ jmp(L_out);\n+  broadcast_additional_needles(sizeKnown, size, needle, needleLen, temp1, ae, _masm);\n+\n+  __ cmpq(nMinusK, 32);\n+  __ jae_b(L_greaterThan32);\n+\n+  \/\/ Here the needle is too long, so we can't do a 32-byte read to compare the last element.\n+  \/\/\n+  \/\/ Instead we match the first two characters, read from the end of the haystack\n+  \/\/ back 32 characters, shift the result compare and check that way.\n+  \/\/\n+  \/\/ Set last to hsPtrRet so the next attempt at loop iteration ends the compare.\n+  __ movq(last, haystack);\n+  __ movq(hsPtrRet, haystack);\n+\n+  \/\/ Compare first element of needle to haystack\n+  vpcmpeq(XMM_TMP3, XMM_BYTE_0, Address(haystack, 0), Assembler::AVX_256bit, ae, _masm);\n+\n+  __ vpmovmskb(eq_mask, XMM_TMP3, Assembler::AVX_256bit);\n+\n+  if (!sizeKnown || (sizeKnown && (size > (isU ? 4 : 2)))) {\n+    \/\/ Compare second element of needle to haystack and mask result\n+    vpcmpeq(XMM_TMP3, XMM_BYTE_1, Address(haystack, isU ? 2 : 1), Assembler::AVX_256bit, ae, _masm);\n+\n+    __ vpmovmskb(temp1, XMM_TMP3, Assembler::AVX_256bit);\n+    __ andq(eq_mask, temp1);\n@@ -1364,1 +1356,0 @@\n-  __ bind(L_greaterThan32);\n@@ -1366,1 +1357,30 @@\n-  broadcast_additional_needles(sizeKnown, size, needle, needleLen, temp1, ae, _masm);\n+  \/\/ Compare last element of needle to haystack, shift and mask result\n+  vpcmpeq(XMM_TMP3, XMM_BYTE_K, Address(haystack, hsLength, Address::times_1, -32),\n+          Assembler::AVX_256bit, ae, _masm);\n+\n+  __ vpmovmskb(temp1, XMM_TMP3, Assembler::AVX_256bit);\n+\n+  \/\/ Compute the proper shift value.  If we let k be the needle length and n be the haystack\n+  \/\/ length, we should be comparing to haystack[k - 1] through haystack[k - 1 + 31].  Since\n+  \/\/ (n - k) < 32, (k - 1 + 31) would be past the end of the haystack.  So the shift value\n+  \/\/ is computed as (k + 31 - n).\n+  \/\/\n+  \/\/ Clarification:  The BYTE_K compare above compares haystack[(n-32):(n-1)].  We need to\n+  \/\/ compare haystack[(k-1):(k-1+31)].  Subtracting either index gives shift value of\n+  \/\/ (k + 31 - n):  x = (k-1+31)-(n-1) = k-1+31-n+1 = k+31-n.\n+  if (sizeKnown) {\n+    __ movl(temp2, 31 + size);\n+  } else {\n+    __ movl(temp2, 31);\n+    __ addl(temp2, needleLen);\n+  }\n+  __ subl(temp2, hsLength);\n+  __ shrxl(temp1, temp1, temp2);\n+  __ andq(eq_mask, temp1);\n+\n+  __ testl(eq_mask, eq_mask);\n+  __ je(noMatch);\n+\n+  __ jmp(L_out);\n+\n+  __ bind(L_greaterThan32);\n@@ -1734,1 +1754,1 @@\n-    \/\/ If a match is not found, branch to L_returnRBP (which will always\n+    \/\/ If a match is not found, branch to L_error (which will always\n@@ -1737,1 +1757,1 @@\n-    \/\/ If a match is found, jump to L_checkRangeAndReturn, which ensures the\n+    \/\/ If a match is found, jump to L_checkRange, which ensures the\n@@ -1812,1 +1832,1 @@\n-        big_case_loop_helper(true, i + 1, L_checkRange, L_loopTop, eq_mask, hs_ptr, needle_len,\n+        big_case_loop_helper(true, i + 1, L_error, L_loopTop, eq_mask, hs_ptr, needle_len,\n","filename":"src\/hotspot\/cpu\/x86\/c2_stubGenerator_x86_64_string.cpp","additions":69,"deletions":49,"binary":false,"changes":118,"status":"modified"}]}