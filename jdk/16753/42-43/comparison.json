{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @run main\/othervm IndexOf\n@@ -31,380 +30,159 @@\n-\/* @test\n- * @bug 8320448\n- * @summary Test indexOf\n- * @requires vm.cpu.features ~= \".*avx2.*\"\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -Xcomp -XX:-TieredCompilation -XX:UseAVX=2 -XX:+UnlockDiagnosticVMOptions -XX:+EnableX86ECoreOpts IndexOf\n- * @key randomness\n- *\/\n-\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n-import java.util.Arrays;\n-import java.util.Random;\n-\n-public class IndexOf {\n-\n-  static Random generator = new Random();\n-  private static boolean failure = false;\n-  public static void main(String[] args) throws Exception {\n-    String testName = \"IndexOf\";\n-\n-    \/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    char[] haystack = new char[128];\n-    char[] haystack_16 = new char[128];\n-\n-    for (int i = 0; i < 128; i++) {\n-      haystack[i] = (char) i;\n-    }\n-\n-    for (int i = 0; i < 128; i++) {\n-      haystack_16[i] = (char) (i + 256);\n-    }\n-\n-\n-    Charset hs_charset = StandardCharsets.UTF_16;\n-    Charset needleCharset = StandardCharsets.ISO_8859_1;\n-\n-    int l_offset = 0;\n-    int needleSize = 65;\n-    int haystackSize = 66;\n-    int result = 0;\n-\n-    String needle = new String(Arrays.copyOfRange((needleCharset == StandardCharsets.UTF_16) ? haystack_16 : haystack, l_offset, l_offset + needleSize));\n-    int hsSize = (haystackSize - l_offset) >= 0 ? haystackSize - l_offset : 0;\n-    int midStart = hsSize \/ 2;\n-    int endStart = (hsSize > needleSize) ? hsSize - needleSize : 0;\n-    String midNeedle = new String(\n-        Arrays.copyOfRange((needleCharset == StandardCharsets.UTF_16) ? haystack_16 : haystack, midStart + l_offset, midStart + needleSize + l_offset));\n-    String endNeedle = new String(\n-        Arrays.copyOfRange((needleCharset == StandardCharsets.UTF_16) ? haystack_16 : haystack, endStart + l_offset, endStart + needleSize + l_offset));\n-    String shs = (new String((hs_charset == StandardCharsets.UTF_16) ? haystack_16 : haystack)).substring(0, haystackSize);\n-\n-    endNeedle = \"\/'!(\\\"3\/\/\";\n-    shs = \");:(\/!-+ %*\/'!(\\\"3\/\/;9\";\n-    l_offset = 0;\n-    StringBuffer bshs = new StringBuffer(shs);\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-\n-    for (int i = 0; i < 20000; i++) {\n-      int foo = testName.indexOf(\"dex\");\n-    }\n-    System.out.println(\"\");\n-    simpleTest();\n-    compareIndexOfLastIndexOf();\n-    compareStringStringBuffer();\n-    compareExhaustive();\n-\n-    if (failure)\n-      throw new RuntimeException(\"One or more BitSet failures.\");\n-  }\n-\n-  private static void report(String testName, int failCount) {\n-    System.err.println(testName + \": \" +\n-        (failCount == 0 ? \"Passed\" : \"Failed(\" + failCount + \")\"));\n-    if (failCount > 0)\n-      failure = true;\n-  }\n-\n-  private static String generateTestString(int min, int max) {\n-    StringBuffer aNewString = new StringBuffer(120);\n-    int aNewLength = getRandomIndex(min, max);\n-    for (int y = 0; y < aNewLength; y++) {\n-      int achar = generator.nextInt(30) + 30;\n-      char test = (char) (achar);\n-      aNewString.append(test);\n-    }\n-    return aNewString.toString();\n-  }\n-\n-  private static int getRandomIndex(int constraint1, int constraint2) {\n-    int range = constraint2 - constraint1;\n-    int x = generator.nextInt(range);\n-    return constraint1 + x;\n-  }\n-\n-  private static int naiveFind(String haystack, String needle, int offset) {\n-    int x = offset;\n-    int len = haystack.length() - offset;\n-    if (needle.length() == 0)\n-      return offset;\n-    if (needle.length() > len)\n-      return -1;\n-    int hsndx = 0;\n-    int nndx = 0;\n-    for (int xx = 0; xx < offset; xx++) {\n-      hsndx += Character.charCount(haystack.codePointAt(hsndx));\n-    }\n-    for (x = offset; x < haystack.length() - needle.length() + 1; x++) {\n-      if (haystack.codePointAt(hsndx) == needle.codePointAt(0)) {\n-        nndx = Character.charCount(needle.codePointAt(0));\n-        int hsndx_tmp = hsndx + Character.charCount(haystack.codePointAt(hsndx));;\n-        while (nndx < needle.length()) {\n-          if (haystack.codePointAt(hsndx_tmp) != needle.codePointAt(nndx)) {\n-            break;\n-          }\n-          hsndx_tmp += Character.charCount(haystack.codePointAt(hsndx_tmp));\n-          nndx += Character.charCount(needle.codePointAt(nndx));\n-        }\n-        if (nndx == needle.length()) {\n-          return x;\n-        }\n-      }\n-      hsndx += Character.charCount(haystack.codePointAt(hsndx));\n-    }\n-    return -1;\n-  }\n-\n-  private static void compareExhaustive() {\n-    int failCount = 0;\n-    String sourceString;\n-    String targetString;\n-    int hsLen = 97;\n-    int maxNeedleLen = hsLen;\/\/ \/ 2;\n-    int haystackLen;\n-    int needleLen;\n-    int hsBegin, nBegin;\n-\n-    for (int i = 0; i < 10000; i++) {\n-      do {\n-        sourceString = generateTestString(hsLen - 1, hsLen);\n-        targetString = generateTestString(maxNeedleLen - 1, maxNeedleLen);\n-      } while (naiveFind(sourceString, targetString, 0) != -1);\n-\n-      for (haystackLen = 0; haystackLen < hsLen; haystackLen += 7) {\n-        for (needleLen = 0; (needleLen < maxNeedleLen) && (needleLen <= haystackLen); needleLen++) {\n-          for (hsBegin = 0; (hsBegin < haystackLen - needleLen) && (hsBegin + haystackLen < hsLen); hsBegin += 3) {\n-            for (nBegin = 0; (nBegin < needleLen) && (nBegin + needleLen < maxNeedleLen); nBegin += 3) {\n-              int nResult = naiveFind(sourceString.substring(hsBegin, hsBegin + haystackLen),\n-                                      targetString.substring(nBegin, nBegin + needleLen), 0);\n-              int iResult = sourceString.substring(hsBegin, hsBegin + haystackLen).indexOf(targetString.substring(nBegin, nBegin + needleLen));\n-              if (iResult != nResult) {\n-                System.out.println(\"Source=\"+sourceString.substring(hsBegin, hsBegin + haystackLen));\n-                System.out.println(\"Target=\"+targetString.substring(nBegin, nBegin + needleLen));\n-                System.out.println(\"haystackLen=\"+haystackLen+\" neeldeLen=\"+needleLen+\" hsBegin=\"+hsBegin+\" nBegin=\"+nBegin+\n-                                   \" iResult=\"+iResult+\" nResult=\"+nResult);\n-                failCount++;\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-\n-    report(\"Exhaustive                   \", failCount);\n-  }\n-\n-  private static void simpleTest() {\n-    int failCount = 0;\n-    String sourceString;\n-    StringBuffer sourceBuffer;\n-    String targetString;\n-    String emptyString = \"\";\n-    String allAs = new String(\"aaaaaaaaaaaaaaaaaaaaaaaaa\");\n-    StringBuffer allAsBuffer = new StringBuffer(allAs);\n-\n-    for (int i = 0; i < 10000; i++) {\n-      do {\n-        sourceString = generateTestString(99, 100);\n-        sourceBuffer = new StringBuffer(sourceString);\n-        targetString = generateTestString(10, 11);\n-      } while (sourceString.indexOf(targetString) != -1);\n-\n-      int index1 = generator.nextInt(90) + 5;\n-      sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n-\n-      if ((sourceBuffer.indexOf(targetString) != index1) ||\n-          (index1 != naiveFind(sourceBuffer.toString(), targetString, 0))) {\n-        System.err.println(\"sourceBuffer.indexOf(targetString) fragment '\" + targetString + \"' (\"\n-            + targetString.length() + \") String = \"\n-            + sourceBuffer.toString() + \" len Buffer = \" + sourceBuffer.toString().length());\n-        System.err.println(\"  naive = \" + naiveFind(sourceBuffer.toString(), targetString, 0) + \", IndexOf = \"\n-            + sourceBuffer.indexOf(targetString));\n-        failCount++;\n-      }\n-      if ((sourceBuffer.indexOf(targetString, 5) != index1) ||\n-          (index1 != naiveFind(sourceBuffer.toString(), targetString, 0))) {\n-        System.err.println(\"sourceBuffer.indexOf(targetString, 5) fragment '\" + targetString + \"' (\"\n-            + targetString.length() + \") String = \"\n-            + sourceBuffer.toString() + \" len Buffer = \" + sourceBuffer.toString().length());\n-        System.err.println(\"  naive = \" + naiveFind(sourceBuffer.toString(), targetString, 0) + \", IndexOf = \"\n-            + sourceBuffer.indexOf(targetString, 5));\n-        failCount++;\n-      }\n-      if ((sourceBuffer.indexOf(targetString, 99) == index1) ||\n-          (index1 != naiveFind(sourceBuffer.toString(), targetString, 0))) {\n-        System.err.println(\"sourceBuffer.indexOf(targetString, 99) fragment '\" + targetString + \"' (\"\n-            + targetString.length() + \") String = \"\n-            + sourceBuffer.toString() + \" len Buffer = \" + sourceBuffer.toString().length());\n-        System.err.println(\"  naive = \" + naiveFind(sourceBuffer.toString(), targetString, 0) + \", IndexOf = \"\n-            + sourceBuffer.indexOf(targetString, 99));\n-        failCount++;\n-      }\n-      if ((sourceBuffer.indexOf(emptyString, 99) != 99) ||\n-          (99 != naiveFind(sourceBuffer.toString(), emptyString, 99))) {\n-        System.err.println(\"sourceBuffer.indexOf(emptyString, 99) fragment '\" + emptyString + \"' (\"\n-            + emptyString.length() + \") String = \"\n-            + sourceBuffer.toString() + \" len Buffer = \" + sourceBuffer.toString().length());\n-        System.err.println(\"  naive = \" + naiveFind(sourceBuffer.toString(), emptyString, 99) + \", IndexOf = \"\n-            + sourceBuffer.indexOf(emptyString, 99));\n-        failCount++;\n-      }\n-      if ((allAsBuffer.substring(1, 3).indexOf(allAsBuffer.substring(5, 12)) != -1) ||\n-          (-1 != naiveFind(allAsBuffer.substring(1, 3).toString(), allAsBuffer.substring(5, 12), 0))) {\n-        System.err.println(\"allAsBuffer.substring(1, 3).indexOf(allAsBuffer.substring(5, 12)) fragment '\"\n-            + allAsBuffer.substring(5, 12) + \"' (\"\n-            + allAsBuffer.substring(5, 12).length() + \") String = \"\n-            + allAsBuffer.substring(1, 3) + \" len Buffer = \" + allAsBuffer.substring(1, 3).length());\n-        System.err.println(\n-            \"  naive = \" + naiveFind(allAsBuffer.substring(1, 3).toString(), allAsBuffer.substring(5, 12), 0)\n-                + \", IndexOf = \" + allAsBuffer.substring(1, 3).indexOf(allAsBuffer.substring(5, 12)));\n-        failCount++;\n-      }\n-    }\n-\n-    report(\"Basic Test                   \", failCount);\n-  }\n-\n-  \/\/ Note: it is possible although highly improbable that failCount will\n-  \/\/ be > 0 even if everthing is working ok\n-  private static void compareIndexOfLastIndexOf() {\n-    int failCount = 0;\n-    String sourceString;\n-    StringBuffer sourceBuffer;\n-    String targetString;\n-\n-    for (int i = 0; i < 10000; i++) {\n-      do {\n-        sourceString = generateTestString(99, 100);\n-        sourceBuffer = new StringBuffer(sourceString);\n-        targetString = generateTestString(10, 11);\n-      } while (sourceString.indexOf(targetString) != -1);\n-\n-      int index1 = generator.nextInt(100);\n-      sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n-\n-      \/\/ extremely remote possibility of > 1 match\n-      int matches = 0;\n-      int index2 = -1;\n-      while ((index2 = sourceBuffer.indexOf(targetString, index2 + 1)) != -1)\n-        matches++;\n-      if (matches > 1)\n-        continue;\n-\n-      if (sourceBuffer.indexOf(targetString) != sourceBuffer.lastIndexOf(targetString))\n-        failCount++;\n-      sourceString = sourceBuffer.toString();\n-      if (sourceString.indexOf(targetString) != sourceString.lastIndexOf(targetString))\n-        failCount++;\n-    }\n-\n-    report(\"IndexOf vs LastIndexOf       \", failCount);\n-  }\n-\n-  private static void compareStringStringBuffer() {\n-    int failCount = 0;\n-    boolean make_new = true;\n-\n-    String fragment = null;\n-    StringBuffer testBuffer = null;\n-    String testString = null;\n-    int testIndex = 0;\n-\n-    failCount = \"\".indexOf(\"\");\n-\n-    for (int x = 0; x < 1000000; x++) {\n-      if (make_new) {\n-        testString = \" \".repeat(1000);\n-        testString = generateTestString(1, 100);\n-        int len = testString.length();\n-\n-        testBuffer = new StringBuffer(len);\n-        testBuffer.append(testString);\n-        if (!testString.equals(testBuffer.toString()))\n-          throw new RuntimeException(\"Initial equality failure\");\n-\n-        int x1 = 0;\n-        int x2 = 1000;\n-        while (x2 > testString.length()) {\n-          x1 = generator.nextInt(len);\n-          x2 = generator.nextInt(100);\n-          x2 = x1 + x2;\n-        }\n-        fragment = \" \".repeat(1000);\n-        fragment = new String(testString.substring(x1, x2));\n-      }\n-\n-      int sAnswer = testString.indexOf(fragment);\n-      int sbAnswer = testBuffer.indexOf(fragment);\n-\n-      if (sAnswer != sbAnswer) {\n-        System.err.println(\"(1) IndexOf fragment '\" + fragment + \"' (\" + fragment.length() + \") len String = \"\n-            + testString.length() + \" len Buffer = \" + testBuffer.length());\n-        System.err.println(\"  sAnswer = \" + sAnswer + \", sbAnswer = \" + sbAnswer);\n-        System.err.println(\"  testString = '\" + testString + \"'\");\n-        System.err.println(\"  testBuffer = '\" + testBuffer + \"'\");\n-        failCount++;\n-      } else {\n-        if (sAnswer > testString.length()) {\n-          System.err.println(\n-              \"IndexOf returned value out of range; return: \" + sAnswer + \" length max: \" + testBuffer.length());\n-        }\n-      }\n-\n-      if ((fragment == \"0#:02\/62;+-\\\"\\\"0$25-5$#)1263\") && (testBuffer.length() == 94)) {\n-        String xx = \"abc\";\n-        String yy = \"abcdefg\";\n-        int sA = xx.indexOf(yy);\n-      }\n-\n-      if (make_new) testIndex = getRandomIndex(-100, 100);\n-\n-      sAnswer = testString.indexOf(fragment, testIndex);\n-      sbAnswer = testBuffer.indexOf(fragment, testIndex);\n-\n-      if (sAnswer != sbAnswer) {\n-        System.err.println(\"(2) IndexOf fragment '\" + fragment + \"' (\" + fragment.length() + \") index = \" + testIndex\n-            + \" len String = \" + testString.length() + \" len Buffer = \" + testBuffer.length());\n-        System.err.println(\"  sAnswer = \" + sAnswer + \", sbAnswer = \" + sbAnswer);\n-        System.err.println(\"  testString = '\" + testString + \"'\");\n-        System.err.println(\"  testBuffer = '\" + testBuffer + \"'\");\n-        failCount++;\n-        make_new = false;\n-      } else {\n-        if ((sAnswer > testString.length()) || ((sAnswer != -1) && (sAnswer < testIndex) && (fragment.length() != 0))) {\n-          System.err.println(\"IndexOf returned value out of range; return: \" + sAnswer + \" length max: \"\n-              + testString.length() + \" index: \" + testIndex);\n-          System.err.println(\"(3) IndexOf fragment '\" + fragment + \"' (\" + fragment.length() + \") index = \" + testIndex\n-              + \" len String = \" + testString.length() + \" len Buffer = \" + testBuffer.length());\n-        }\n-      }\n-\n-      sAnswer = testString.lastIndexOf(fragment);\n-      sbAnswer = testBuffer.lastIndexOf(fragment);\n-\n-      if (sAnswer != sbAnswer) {\n-        System.err.println(\"(1) lastIndexOf fragment '\" + fragment + \"' len String = \" + testString.length()\n-            + \" len Buffer = \" + testBuffer.length());\n-        System.err.println(\"  sAnswer = \" + sAnswer + \", sbAnswer = \" + sbAnswer);\n-        failCount++;\n-      }\n-\n-      if (make_new) testIndex = getRandomIndex(-100, 100);\n-\n-      sAnswer = testString.lastIndexOf(fragment, testIndex);\n-      sbAnswer = testBuffer.lastIndexOf(fragment, testIndex);\n-\n-      if (sAnswer != sbAnswer) {\n-        System.err.println(\"(2) lastIndexOf fragment '\" + fragment + \"' index = \" + testIndex + \" len String = \"\n-            + testString.length() + \" len Buffer = \" + testBuffer.length());\n-        failCount++;\n-      }\n-    }\n-\n-    report(\"String vs StringBuffer       \", failCount);\n-  }\n-\n-}\n+ import java.util.Random;\n+\n+ public class IndexOf {\n+\n+     static Random generator = new Random();\n+     private static boolean failure = false;\n+\n+     public static void main(String[] args) throws Exception {\n+         simpleTest();\n+         compareIndexOfLastIndexOf();\n+         compareStringStringBuffer();\n+\n+         if (failure)\n+            throw new RuntimeException(\"One or more BitSet failures.\");\n+     }\n+\n+     private static void report(String testName, int failCount) {\n+         System.err.println(testName+\": \" +\n+                          (failCount==0 ? \"Passed\":\"Failed(\"+failCount+\")\"));\n+         if (failCount > 0)\n+             failure = true;\n+     }\n+\n+     private static String generateTestString(int min, int max) {\n+         StringBuffer aNewString = new StringBuffer(120);\n+         int aNewLength = getRandomIndex(min, max);\n+         for(int y=0; y<aNewLength; y++) {\n+             int achar = generator.nextInt(30)+30;\n+             char test = (char)(achar);\n+             aNewString.append(test);\n+         }\n+         return aNewString.toString();\n+     }\n+\n+     private static int getRandomIndex(int constraint1, int constraint2) {\n+         int range = constraint2 - constraint1;\n+         int x = generator.nextInt(range);\n+         return constraint1 + x;\n+     }\n+\n+     private static void simpleTest() {\n+         int failCount = 0;\n+         String sourceString;\n+         StringBuffer sourceBuffer;\n+         String targetString;\n+\n+         for (int i=0; i<10000; i++) {\n+             do {\n+                 sourceString = generateTestString(99, 100);\n+                 sourceBuffer = new StringBuffer(sourceString);\n+                 targetString = generateTestString(10, 11);\n+             } while (sourceString.indexOf(targetString) != -1);\n+\n+             int index1 = generator.nextInt(90) + 5;\n+             sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n+\n+             if (sourceBuffer.indexOf(targetString) != index1)\n+                 failCount++;\n+             if (sourceBuffer.indexOf(targetString, 5) != index1)\n+                 failCount++;\n+             if (sourceBuffer.indexOf(targetString, 99) == index1)\n+                 failCount++;\n+         }\n+\n+         report(\"Basic Test                   \", failCount);\n+     }\n+\n+     \/\/ Note: it is possible although highly improbable that failCount will\n+     \/\/ be > 0 even if everthing is working ok\n+     private static void compareIndexOfLastIndexOf() {\n+         int failCount = 0;\n+         String sourceString;\n+         StringBuffer sourceBuffer;\n+         String targetString;\n+\n+         for (int i=0; i<10000; i++) {\n+             do {\n+                 sourceString = generateTestString(99, 100);\n+                 sourceBuffer = new StringBuffer(sourceString);\n+                 targetString = generateTestString(10, 11);\n+             } while (sourceString.indexOf(targetString) != -1);\n+\n+             int index1 = generator.nextInt(100);\n+             sourceBuffer = sourceBuffer.replace(index1, index1, targetString);\n+\n+             \/\/ extremely remote possibility of > 1 match\n+             int matches = 0;\n+             int index2 = -1;\n+             while((index2 = sourceBuffer.indexOf(targetString,index2+1)) != -1)\n+                 matches++;\n+             if (matches > 1)\n+                 continue;\n+\n+             if (sourceBuffer.indexOf(targetString) !=\n+                 sourceBuffer.lastIndexOf(targetString))\n+                 failCount++;\n+             sourceString = sourceBuffer.toString();\n+             if (sourceString.indexOf(targetString) !=\n+                 sourceString.lastIndexOf(targetString))\n+                 failCount++;\n+         }\n+\n+         report(\"IndexOf vs LastIndexOf       \", failCount);\n+     }\n+\n+     private static void compareStringStringBuffer() {\n+         int failCount = 0;\n+\n+         for (int x=0; x<10000; x++) {\n+             String testString = generateTestString(1, 100);\n+             int len = testString.length();\n+\n+             StringBuffer testBuffer = new StringBuffer(len);\n+             testBuffer.append(testString);\n+             if (!testString.equals(testBuffer.toString()))\n+                 throw new RuntimeException(\"Initial equality failure\");\n+\n+             int x1 = 0;\n+             int x2 = 1000;\n+             while(x2 > testString.length()) {\n+                 x1 = generator.nextInt(len);\n+                 x2 = generator.nextInt(100);\n+                 x2 = x1 + x2;\n+             }\n+             String fragment = testString.substring(x1,x2);\n+\n+             int sAnswer = testString.indexOf(fragment);\n+             int sbAnswer = testBuffer.indexOf(fragment);\n+\n+             if (sAnswer != sbAnswer)\n+                 failCount++;\n+\n+             int testIndex = getRandomIndex(-100, 100);\n+\n+             sAnswer = testString.indexOf(fragment, testIndex);\n+             sbAnswer = testBuffer.indexOf(fragment, testIndex);\n+\n+             if (sAnswer != sbAnswer)\n+                 failCount++;\n+\n+             sAnswer = testString.lastIndexOf(fragment);\n+             sbAnswer = testBuffer.lastIndexOf(fragment);\n+\n+             if (sAnswer != sbAnswer)\n+                 failCount++;\n+\n+             testIndex = getRandomIndex(-100, 100);\n+\n+             sAnswer = testString.lastIndexOf(fragment, testIndex);\n+             sbAnswer = testBuffer.lastIndexOf(fragment, testIndex);\n+\n+             if (sAnswer != sbAnswer)\n+                 failCount++;\n+         }\n+\n+         report(\"String vs StringBuffer       \", failCount);\n+     }\n+\n+ }\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/StringBuffer\/IndexOf.java","additions":160,"deletions":382,"binary":false,"changes":542,"status":"modified"}]}