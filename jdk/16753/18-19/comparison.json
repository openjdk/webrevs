{"files":[{"patch":"@@ -4492,6 +4492,4 @@\n-void C2_MacroAssembler::arrays_equals(bool is_array_equ, Register ary1,\n-                                      Register ary2, Register limit,\n-                                      Register result, Register chr,\n-                                      XMMRegister vec1, XMMRegister vec2,\n-                                      bool is_char, KRegister mask,\n-                                      bool expand_ary2) {\n+void C2_MacroAssembler::arrays_equals(bool is_array_equ, Register ary1, Register ary2,\n+                                      Register limit, Register result, Register chr,\n+                                      XMMRegister vec1, XMMRegister vec2, bool is_char,\n+                                      KRegister mask, bool expand_ary2) {\n@@ -4508,0 +4506,3 @@\n+  Address::ScaleFactor scaleFactor = expand_ary2 ? Address::times_2 : Address::times_1;\n+  int scaleIncr = expand_ary2 ? 8 : 16;\n+\n@@ -4546,2 +4547,7 @@\n-    andl(result, 0x0000001f);  \/\/   tail count (in bytes)\n-    andl(limit, 0xffffffe0);   \/\/ vector count (in bytes)\n+    if (expand_ary2) {\n+      andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n+      andl(limit, 0xfffffff0);   \/\/ vector count (in bytes)\n+    } else {\n+      andl(result, 0x0000001f);  \/\/   tail count (in bytes)\n+      andl(limit, 0xffffffe0);   \/\/ vector count (in bytes)\n+    }\n@@ -4550,2 +4556,1 @@\n-    lea(ary1, Address(ary1, limit,\n-                      expand_ary2 ? Address::times_2 : Address::times_1));\n+    lea(ary1, Address(ary1, limit, scaleFactor));\n@@ -4594,2 +4599,1 @@\n-    vmovdqu(vec1, Address(ary1, limit,\n-                          expand_ary2 ? Address::times_2 : Address::times_1));\n+    vmovdqu(vec1, Address(ary1, limit, scaleFactor));\n@@ -4597,2 +4601,1 @@\n-      vpmovzxbw(vec2, Address(ary2, limit, Address::times_1),\n-                Assembler::AVX_256bit);\n+      vpmovzxbw(vec2, Address(ary2, limit, Address::times_1), Assembler::AVX_256bit);\n@@ -4606,1 +4609,1 @@\n-    addptr(limit, expand_ary2 ? 16 : 32);\n+    addptr(limit, scaleIncr * 2);\n@@ -4612,3 +4615,1 @@\n-    vmovdqu(vec1,\n-            Address(ary1, result,\n-                    expand_ary2 ? Address::times_2 : Address::times_1, -32));\n+    vmovdqu(vec1, Address(ary1, result, scaleFactor, -32));\n@@ -4616,2 +4617,1 @@\n-      vpmovzxbw(vec2, Address(ary2, result, Address::times_1, -16),\n-                Assembler::AVX_256bit);\n+      vpmovzxbw(vec2, Address(ary2, result, Address::times_1, -16), Assembler::AVX_256bit);\n@@ -4635,1 +4635,1 @@\n-    lea(ary1, Address(ary1, limit, expand_ary2 ? Address::times_2 : Address::times_1));\n+    lea(ary1, Address(ary1, limit, scaleFactor));\n@@ -4640,2 +4640,1 @@\n-    movdqu(vec1, Address(ary1, limit,\n-                         expand_ary2 ? Address::times_2 : Address::times_1));\n+    movdqu(vec1, Address(ary1, limit, scaleFactor));\n@@ -4643,2 +4642,1 @@\n-      vpmovzxbw(vec2, Address(ary2, limit, Address::times_1),\n-                Assembler::AVX_128bit);\n+      vpmovzxbw(vec2, Address(ary2, limit, Address::times_1), Assembler::AVX_128bit);\n@@ -4652,1 +4650,1 @@\n-    addptr(limit, expand_ary2 ? 8 : 16);\n+    addptr(limit, scaleIncr);\n@@ -4706,1 +4704,1 @@\n-  lea(ary1, Address(ary1, limit, expand_ary2 ? Address::times_2 : Address::times_1));\n+  lea(ary1, Address(ary1, limit, scaleFactor));\n@@ -4720,2 +4718,1 @@\n-    movl(chr, Address(ary1, limit,\n-                      expand_ary2 ? Address::times_2 : Address::times_1));\n+    movl(chr, Address(ary1, limit, scaleFactor));\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":26,"deletions":29,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -294,4 +294,3 @@\n-  void arrays_equals(bool is_array_equ, Register ary1, Register ary2,\n-                     Register limit, Register result, Register chr,\n-                     XMMRegister vec1, XMMRegister vec2, bool is_char,\n-                     KRegister mask = knoreg, bool expand_ary2 = false);\n+  void arrays_equals(bool is_array_equ, Register ary1, Register ary2, Register limit,\n+                     Register result, Register chr, XMMRegister vec1, XMMRegister vec2,\n+                     bool is_char, KRegister mask = knoreg, bool expand_ary2 = false);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1172,8 +1172,0 @@\n-\/\/ Alignment specifying the maximum number of allowed bytes to pad.\n-\/\/ If padding > max, no padding is inserted.\n-void MacroAssembler::p2align(int modulus, int maxbytes) {\n-  if (modulus - (offset() % modulus) <= maxbytes) {\n-    align(modulus, offset());\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -218,1 +218,0 @@\n-  void p2align(int modulus, int maxbytes);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-#ifdef COMPILER2\n-\n@@ -74,0 +72,4 @@\n+\/\/ ASGASG\n+\/\/ #define DO_EARLY_BAILOUT 1\n+#undef DO_EARLY_BAILOUT\n+\n@@ -75,0 +77,2 @@\n+\/\/ These registers can be counted on to always contain\n+\/\/ the correct values (once set up)\n@@ -78,1 +82,8 @@\n-#define XMM_BYTE_2 xmm13\n+#define save_r12 xmm4\n+#define save_r13 xmm5\n+#define save_r14 xmm6\n+#define save_r15 xmm7\n+#define save_rbx xmm8\n+#define nMinusK r10\n+\n+\/\/ Global temporary xmm registers\n@@ -84,21 +95,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ Tuning parameters \/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-\/\/ Highly optimized special cases\n-\/\/ For haystack sizes <= 32 we can use vector comparisons by utilizing\n-\/\/ the stack.  We can copy the incoming haystack to the stack which\n-\/\/ will prevent having to check for reading past the end and causing\n-\/\/ potential page faults.\n-\/\/ Set this value to the largest needle size to optimize in this manner.\n-#define OPT_NEEDLE_SIZE_MAX 5\n-\n-\/\/ Number of bytes of haystack to compare for equality\n-\/\/ A value of 2 checks the first and last bytes of the needle.\n-\/\/ A value of 3 checks the first two bytes and the last byte of the needle.\n-\/\/ A value of 4 checks the first three bytes and last byte of the needle.\n-\/\/ Added for performance tuning.\n-#define NUMBER_OF_NEEDLE_BYTES_TO_COMPARE 3\n-\n-\/\/ If DO_EARLY_BAILOUT is non-zero, each element of comparison will be checked.\n-\/\/ If non-zero, all compares will be done with a final check.\n-#define DO_EARLY_BAILOUT 1\n-\n@@ -119,1 +109,1 @@\n-#define MAX_NEEDLE_LEN_TO_EXPAND 0x20\n+#define MAX_NEEDLE_LEN_TO_EXPAND 0x28\n@@ -141,4 +131,0 @@\n-\/\/ Define this to push registers onto stack, otherwise saved\n-\/\/ registers will be put into xmm registers.\n-#undef PUSH_REGS\n-\n@@ -146,26 +132,32 @@\n-static void broadcast_additional_needles(bool sizeKnown, int size, int bytesToCompare, Register needle,\n-                                         Register needleLen, Register rTmp, bool isUU, bool isUL,\n-                                         MacroAssembler *_masm);\n-\n-static void compare_big_haystack_to_needle(bool sizeKnown, int size, int bytesToCompare, Label &noMatch,\n-                                           Register haystack, Register hsLen, Register needleLen, bool isU,\n-                                           bool doEarlyBailout, Register eq_mask, Register rTmp, Register nMinusK,\n-                                           MacroAssembler *_masm);\n-\n-static void compare_haystack_to_needle(bool sizeKnown, int size, int bytesToCompare, Label &noMatch, Register haystack,\n-                                       bool isU, bool doEarlyBailout, Register eq_mask, Register needleLen,\n-                                       Register rTmp, MacroAssembler *_masm);\n-\n-static void big_case_loop_helper(bool sizeKnown, int size, Label &noMatch, Label &loop_top, Register eq_mask,\n-                                 Register hsPtrRet, Register needleLen, StrIntrinsicNode::ArgEncoding ae,\n-                                 MacroAssembler *_masm);\n-\n-static void preload_needle_helper(int size, Register needle, Register needleVal, StrIntrinsicNode::ArgEncoding ae,\n-                                  MacroAssembler *_masm);\n-\n-static void byte_compare_helper(int size, Label &L_noMatch, Label &L_matchFound, Register needle, Register needleVal,\n-                                Register haystack, Register mask, Register foundIndex, Register tmp,\n-                                StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm);\n-\n-static void highly_optimized_short_cases(StrIntrinsicNode::ArgEncoding ae, Register haystack, Register haystack_len,\n-                                         Register needle, Register needle_len, XMMRegister XMM0, XMMRegister XMM1,\n+static void broadcast_additional_needles(bool sizeKnown, int size, Register needle,\n+                                         Register needleLen, Register rTmp,\n+                                         StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm);\n+\n+static void compare_big_haystack_to_needle(bool sizeKnown, int size, Label &noMatch,\n+                                           Register haystack, Register hsLen, Register needleLen,\n+                                           bool isU, Register eq_mask, Register rTmp,\n+                                           Register rTmp2, XMMRegister rxTmp1, XMMRegister rxTmp2,\n+                                           XMMRegister rxTmp3, MacroAssembler *_masm);\n+\n+static void compare_haystack_to_needle(bool sizeKnown, int size, Label &noMatch, Register haystack,\n+                                       bool isU, Register eq_mask, Register needleLen,\n+                                       Register rTmp, XMMRegister rxTmp1, XMMRegister rxTmp2,\n+                                       MacroAssembler *_masm);\n+\n+static void big_case_loop_helper(bool sizeKnown, int size, Label &noMatch, Label &loop_top,\n+                                 Register eq_mask, Register hsPtrRet, Register needleLen,\n+                                 Register needle, Register haystack, Register hsLength,\n+                                 Register rTmp1, Register rTmp2, Register rTmp3, Register rTmp4,\n+                                 StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm);\n+\n+static void preload_needle_helper(int size, Register needle, Register needleVal,\n+                                  StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm);\n+\n+static void byte_compare_helper(int size, Label &L_noMatch, Label &L_matchFound, Register needle,\n+                                Register needleVal, Register haystack, Register mask,\n+                                Register foundIndex, Register tmp, StrIntrinsicNode::ArgEncoding ae,\n+                                MacroAssembler *_masm);\n+\n+static void highly_optimized_short_cases(StrIntrinsicNode::ArgEncoding ae, Register haystack,\n+                                         Register haystack_len, Register needle,\n+                                         Register needle_len, XMMRegister XMM0, XMMRegister XMM1,\n@@ -174,2 +166,3 @@\n-static void setup_jump_tables(StrIntrinsicNode::ArgEncoding ae, Label &L_error, Label &L_checkRange, Label &L_fixup,\n-                              address *jump_table, address *jump_table_1, MacroAssembler *_masm);\n+static void setup_jump_tables(StrIntrinsicNode::ArgEncoding ae, Label &L_error, Label &L_checkRange,\n+                              Label &L_fixup, address *big_jump_table, address *small_jump_table,\n+                              MacroAssembler *_masm);\n@@ -177,5 +170,5 @@\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/                         Start of generator\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/                         Start of generator\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n@@ -188,1 +181,0 @@\n-  generate_string_indexof_stubs(fnptrs, StrIntrinsicNode::UL);\n@@ -190,0 +182,1 @@\n+  generate_string_indexof_stubs(fnptrs, StrIntrinsicNode::UL);\n@@ -203,0 +196,2 @@\n+  bool isReallyUL = isUL;\n+\n@@ -208,1 +203,1 @@\n-  if (VM_Version::supports_avx2()) {  \/\/ AVX2 version\n+  assert(VM_Version::supports_avx2(), \"Needs AVX2\");\n@@ -210,23 +205,23 @@\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/                         Code generation explanation:\n-    \/\/\n-    \/\/  The generator will generate code for three cases:\n-    \/\/  1. Both needle and haystack are Latin-1 (single byte) encoded (LL)\n-    \/\/  2. Both the needle and haystack are UTF-16 encoded (two bytes per character) (UU)\n-    \/\/  3. The haystack is UTF-16 encoded and the needle is Latin-1 encoded (UL)\n-    \/\/\n-    \/\/  The case of the haystack being Latin-1 and the needle being UTF-16 is short-circuited\n-    \/\/  so that we never get called in this case.\n-    \/\/\n-    \/\/  For the UL case (haystack UTF-16 and needle Latin-1), the needle will be expanded\n-    \/\/  onto the stack (for size <= MAX_NEEDLE_LEN_TO_EXPAND) and the UU code will do the work.\n-    \/\/  For UL where the needle size is > MAX_NEEDLE_LEN_TO_EXPAND, we default to a\n-    \/\/  byte-by-byte comparison (this will be rare).\n-    \/\/\n-    \/\/  Note that the code assumes MAX_NEEDLE_LEN_TO_EXPAND is >= 32.\n-    \/\/\n-    \/\/  The UU and LL cases are identical except for the loop increments and loading\n-    \/\/  of the characters into registers.  UU loads and compares words, LL - bytes.\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/                         Code generation explanation:\n+  \/\/\n+  \/\/  The generator will generate code for three cases:\n+  \/\/  1. Both needle and haystack are Latin-1 (single byte) encoded (LL)\n+  \/\/  2. Both the needle and haystack are UTF-16 encoded (two bytes per character) (UU)\n+  \/\/  3. The haystack is UTF-16 encoded and the needle is Latin-1 encoded (UL)\n+  \/\/\n+  \/\/  The case of the haystack being Latin-1 and the needle being UTF-16 is short-circuited\n+  \/\/  so that we never get called in this case.\n+  \/\/\n+  \/\/  For the UL case (haystack UTF-16 and needle Latin-1), the needle will be expanded\n+  \/\/  onto the stack (for size <= MAX_NEEDLE_LEN_TO_EXPAND) and the UU code will do the work.\n+  \/\/  For UL where the needle size is > MAX_NEEDLE_LEN_TO_EXPAND, we default to a\n+  \/\/  byte-by-byte comparison (this will be rare).\n+  \/\/\n+  \/\/  Note that the code assumes MAX_NEEDLE_LEN_TO_EXPAND is >= 32.\n+  \/\/\n+  \/\/  The UU and LL cases are identical except for the loop increments and loading\n+  \/\/  of the characters into registers.  UU loads and compares words, LL - bytes.\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n@@ -234,90 +229,4 @@\n-    const Register haystack     = rdi;\n-    const Register haystack_len = rsi;\n-    const Register needle       = rdx;\n-    const Register needle_len   = rcx;\n-\n-    const Register save_ndl_len = r12;\n-\n-    const XMMRegister byte_0    = XMM_BYTE_0;\n-    const XMMRegister byte_k    = XMM_BYTE_K;\n-    const XMMRegister byte_1    = XMM_BYTE_1;\n-    const XMMRegister byte_2    = XMM_BYTE_2;\n-    const XMMRegister xmm_tmp1  = XMM_TMP1;\n-    const XMMRegister xmm_tmp2  = XMM_TMP2;\n-    const XMMRegister xmm_tmp3  = XMM_TMP3;\n-    const XMMRegister xmm_tmp4  = XMM_TMP4;\n-\n-    const XMMRegister save_r12  = xmm4;\n-    const XMMRegister save_r13  = xmm5;\n-    const XMMRegister save_r14  = xmm6;\n-    const XMMRegister save_r15  = xmm7;\n-    const XMMRegister save_rbx  = xmm8;\n-    \/\/ xmm registers more valuable in inner loops...\n-    \/\/ const XMMRegister save_rsi  = xmm9;\n-    \/\/ const XMMRegister save_rdi  = xmm10;\n-    \/\/ const XMMRegister save_rcx  = xmm11;\n-    \/\/ const XMMRegister save_r8   = xmm12;\n-\n-    \/\/ Addresses of the two jump tables used for small needle processing\n-    address jump_table;\n-    address jump_table_1;\n-\n-    Label L_begin;\n-\n-    Label L_returnRBP, L_checkRangeAndReturn, L_returnError;\n-    Label L_bigCaseFixupAndReturn, L_checkRangeAndReturnRCX;\n-    Label L_returnZero, L_copyHaystackToStackDone, L_bigSwitchTop;\n-    Label L_bigCaseDefault, L_smallCaseDefault, L_copyHaystackToStack, L_smallSwitchTop;\n-    Label L_nextCheck, L_checksPassed, L_zeroCheckFailed;\n-\n-    Label L_wcharBegin, L_continue, L_wideNoExpand, L_copyDone, L_copyHigh;\n-    Label L_wideMidLoop, L_wideTopLoop, L_wideInnerLoop, L_wideFound;\n-\n-    __ align(CodeEntryAlignment);\n-    fnptrs[isLL   ? StrIntrinsicNode::LL\n-           : isUU ? StrIntrinsicNode::UU\n-                  : StrIntrinsicNode::UL] = __ pc();\n-    __ enter();  \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-    \/\/ Check for trivial cases\n-    \/\/ needle length == 0?\n-    __ cmpq(needle_len, 0);\n-    __ jg_b(L_nextCheck);\n-    __ xorq(rax, rax);\n-    __ leave();\n-    __ ret(0);\n-\n-    \/\/ haystack length == 0?\n-    __ bind(L_nextCheck);\n-    __ testq(haystack_len, haystack_len);\n-    __ je(L_zeroCheckFailed);\n-\n-    \/\/ haystack length >= needle length?\n-    __ movq(rax, haystack_len);\n-    __ subq(rax, needle_len);\n-    __ jge_b(L_checksPassed);\n-\n-    __ bind(L_zeroCheckFailed);\n-    __ movq(rax, -1);\n-    __ leave();\n-    __ ret(0);\n-\n-    __ bind(L_checksPassed);\n-\n-    \/\/ Check for highly-optimized ability - haystack <= 32 bytes and needle <= OPT_NEEDLE_SIZE_MAX\n-    \/\/ haystack_len is in elements, not bytes, for UTF-16\n-    __ cmpq(haystack_len, isU ? COPIED_HAYSTACK_STACK_SIZE \/ 4\n-                              : COPIED_HAYSTACK_STACK_SIZE \/ 2);\n-    __ ja(L_begin);\n-\n-    \/\/ needle_len is in elements, not bytes, for UTF-16\n-    __ cmpq(needle_len, isUU ? OPT_NEEDLE_SIZE_MAX \/ 2 : OPT_NEEDLE_SIZE_MAX);\n-    __ ja(L_begin);\n-\n-    \/\/ Handle short haystack and needle specially\n-    \/\/ Generated code does not return - either found or not\n-    highly_optimized_short_cases(ae, haystack, haystack_len, needle, needle_len, xmm0, xmm1, r8, r9, _masm);\n-\n-    \/\/ Set up jump tables.  Used when needle size <= NUMBER_OF_CASES\n-    setup_jump_tables(ae, L_returnRBP, L_checkRangeAndReturn, L_bigCaseFixupAndReturn, &jump_table, &jump_table_1,\n-                      _masm);\n+  const Register haystack_p     = c_rarg0;\n+  const Register haystack_len_p = c_rarg1;\n+  const Register needle_p       = c_rarg2;\n+  const Register needle_len_p   = c_rarg3;\n@@ -325,3 +234,3 @@\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/ Addresses of the two jump tables used for small needle processing\n+  address big_jump_table;\n+  address small_jump_table;\n@@ -329,26 +238,1 @@\n-    __ bind(L_begin);\n-#ifdef PUSH_REGS\n-    __ push(r15);\n-    __ push(r14);\n-    __ push(r13);\n-    __ push(r12);\n-    __ push(rbx);\n-#else\n-    __ movdq(save_r12, r12);\n-    __ movdq(save_r13, r13);\n-    __ movdq(save_r14, r14);\n-    __ movdq(save_r15, r15);\n-    __ movdq(save_rbx, rbx);\n-#endif\n-#ifdef _WIN64\n-    __ push(rsi);\n-    __ push(rdi);\n-    __ push(rcx);\n-    __ push(r8);\n-    __ push(r9);\n-\n-    __ movq(rdi, rcx);\n-    __ movq(rsi, rdx);\n-    __ movq(rdx, r8);\n-    __ movq(rcx, r9);\n-#endif\n+  Label L_begin;\n@@ -356,2 +240,4 @@\n-    __ push(rbp);\n-    __ subptr(rsp, STACK_SPACE);\n+  Label L_returnRBP, L_checkRangeAndReturn, L_returnError, L_bigCaseFixupAndReturn;\n+  Label L_bigSwitchTop, L_bigCaseDefault, L_smallCaseDefault;\n+  Label L_nextCheck, L_checksPassed, L_zeroCheckFailed, L_return;\n+  Label L_wcharBegin, L_continue, L_wideNoExpand;\n@@ -359,2 +245,3 @@\n-    \/\/ Assume failure\n-    __ movq(rbp, -1);\n+  __ align(CodeEntryAlignment);\n+  fnptrs[ae] = __ pc();\n+  __ enter();  \/\/ required for proper stackwalking of RuntimeStub frame\n@@ -362,4 +249,7 @@\n-    if (isUL) {\n-      \/\/ Branch out if doing wide chars\n-      __ jmp(L_wcharBegin);\n-    }\n+  \/\/ Check for trivial cases\n+  \/\/ needle length == 0?\n+  __ cmpq(needle_len_p, 0);\n+  __ jg_b(L_nextCheck);\n+  __ xorq(rax, rax);\n+  __ leave();\n+  __ ret(0);\n@@ -367,4 +257,4 @@\n-    if (isUU) {  \/\/ Adjust sizes of hs and needle\n-      __ shlq(needle_len, 1);\n-      __ shlq(haystack_len, 1);\n-    }\n+  \/\/ haystack length == 0?\n+  __ bind(L_nextCheck);\n+  __ testq(haystack_len_p, haystack_len_p);\n+  __ je(L_zeroCheckFailed);\n@@ -372,4 +262,4 @@\n-    \/\/ wide char processing comes here after expanding needle\n-    __ bind(L_continue);\n-    __ movq(r10, haystack_len);\n-    __ subq(r10, needle_len);\n+  \/\/ haystack length >= needle length?\n+  __ movq(rax, haystack_len_p);\n+  __ subq(rax, needle_len_p);\n+  __ jge_b(L_checksPassed);\n@@ -377,3 +267,4 @@\n-    __ movq(save_ndl_len, needle_len);\n-    __ movq(r14, needle);\n-    __ movq(rbx, haystack);\n+  __ bind(L_zeroCheckFailed);\n+  __ movq(rax, -1);\n+  __ leave();\n+  __ ret(0);\n@@ -381,2 +272,1 @@\n-    {\n-      Label L_short;\n+  __ bind(L_checksPassed);\n@@ -384,6 +274,4 @@\n-      \/\/ Always need needle broadcast to ymm registers\n-      if (isU) {\n-        __ vpbroadcastw(byte_0, Address(needle, 0), Assembler::AVX_256bit);\n-      } else {\n-        __ vpbroadcastb(byte_0, Address(needle, 0), Assembler::AVX_256bit);\n-      }\n+  \/\/ Check for highly-optimized ability - haystack <= 32 bytes and needle <= 6 bytes\n+  \/\/ haystack_len is in elements, not bytes, for UTF-16\n+  __ cmpq(haystack_len_p, isU ? 16 : 32);\n+  __ ja(L_begin);\n@@ -391,2 +279,3 @@\n-      __ cmpq(needle_len, isU ? 2 : 1);\n-      __ je_b(L_short);\n+  \/\/ needle_len is in elements, not bytes, for UTF-16 <=> UTF-16\n+  __ cmpq(needle_len_p, isUU ? 3 : 6);\n+  __ ja(L_begin);\n@@ -394,5 +283,4 @@\n-      if (isU) {\n-        __ vpbroadcastw(byte_k, Address(needle, needle_len, Address::times_1, -2), Assembler::AVX_256bit);\n-      } else {\n-        __ vpbroadcastb(byte_k, Address(needle, needle_len, Address::times_1, -1), Assembler::AVX_256bit);\n-      }\n+  \/\/ Handle short haystack and needle specially\n+  \/\/ Generated code does not return - either found or not\n+  highly_optimized_short_cases(ae, haystack_p, haystack_len_p, needle_p, needle_len_p, xmm0, xmm1,\n+                               r10, r11, _masm);\n@@ -400,2 +288,7 @@\n-      __ bind(L_short);\n-    }\n+  \/\/ If we're generating UL, we need to \"pretend\" we're generating UU code\n+  \/\/ for the case where the needle can be expanded onto the stack\n+  if (isReallyUL) {\n+    ae = StrIntrinsicNode::UU;\n+    isUL = false;\n+    isUU = true;\n+  }\n@@ -403,3 +296,3 @@\n-    \/\/ Do \"big switch\" if haystack size >= 32\n-    __ cmpq(haystack_len, 0x20);\n-    __ jae_b(L_bigSwitchTop);\n+  \/\/ Set up jump tables.  Used when needle size <= NUMBER_OF_CASES\n+  setup_jump_tables(ae, L_returnRBP, L_checkRangeAndReturn, L_bigCaseFixupAndReturn,\n+                    &big_jump_table, &small_jump_table, _masm);\n@@ -407,4 +300,26 @@\n-    \/\/ Copy the small (< 32 byte) haystack to the stack.  Allows for vector reads without page fault\n-    \/\/ Only done for small haystacks\n-    {\n-      Label L_moreThan16, L_adjustHaystack;\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\n+  \/\/ The above code handles all cases (LL, UL, UU) for haystack size <= 32 bytes\n+  \/\/ and needle size <= 6 bytes.\n+\n+  __ bind(L_begin);\n+  __ movdq(save_r12, r12);\n+  __ movdq(save_r13, r13);\n+  __ movdq(save_r14, r14);\n+  __ movdq(save_r15, r15);\n+  __ movdq(save_rbx, rbx);\n+#ifdef _WIN64\n+  __ push(rsi);\n+  __ push(rdi);\n+  __ push(rcx);\n+  __ push(r8);\n+  __ push(r9);\n+\n+  \/\/ Move to Linux-style ABI\n+  __ movq(rdi, rcx);\n+  __ movq(rsi, rdx);\n+  __ movq(rdx, r8);\n+  __ movq(rcx, r9);\n+#endif\n@@ -412,2 +327,21 @@\n-      const Register index = rax;\n-      const Register haystack = rbx;\n+  const Register haystack     = rdi;\n+  const Register haystack_len = rsi;\n+  const Register needle       = rdx;\n+  const Register needle_len   = rcx;\n+  const Register save_ndl_len = r12;\n+\n+  __ push(rbp);\n+  __ subptr(rsp, STACK_SPACE);\n+\n+  \/\/ Assume failure\n+  __ movq(rbp, -1);\n+\n+  if (isReallyUL) {\n+    \/\/ Branch out if doing wide chars\n+    __ jmp(L_wcharBegin);\n+  }\n+\n+  if (!isReallyUL && isUU) {  \/\/ Adjust sizes of hs and needle\n+    __ shlq(needle_len, 1);\n+    __ shlq(haystack_len, 1);\n+  }\n@@ -415,3 +349,4 @@\n-      __ bind(L_copyHaystackToStack);\n-      __ cmpq(haystack_len, 0x10);\n-      __ ja_b(L_moreThan16);\n+  \/\/ wide char processing comes here after expanding needle\n+  __ bind(L_continue);\n+  __ movq(nMinusK, haystack_len);\n+  __ subq(nMinusK, needle_len);\n@@ -419,4 +354,3 @@\n-      __ movq(index, COPIED_HAYSTACK_STACK_OFFSET + 0x10);\n-      __ movdqu(xmm_tmp1, Address(haystack, haystack_len, Address::times_1, -0x10));\n-      __ movdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), xmm_tmp1);\n-      __ jmpb(L_adjustHaystack);\n+  __ movq(save_ndl_len, needle_len);\n+  __ movq(r14, needle);\n+  __ movq(rbx, haystack);\n@@ -424,4 +358,2 @@\n-      __ bind(L_moreThan16);\n-      __ movq(index, COPIED_HAYSTACK_STACK_OFFSET + 0x20);\n-      __ vmovdqu(xmm_tmp1, Address(haystack, haystack_len, Address::times_1, -0x20));\n-      __ vmovdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), xmm_tmp1);\n+  {\n+    Label L_short;\n@@ -429,3 +361,6 @@\n-      __ bind(L_adjustHaystack);\n-      __ subq(index, haystack_len);\n-      __ leaq(haystack, Address(rsp, index, Address::times_1));\n+    \/\/ Always need needle broadcast to ymm registers\n+    \/\/ Broadcast the beginning of needle into a vector register.\n+    if (isU) {\n+      __ vpbroadcastw(XMM_BYTE_0, Address(needle, 0), Assembler::AVX_256bit);\n+    } else {\n+      __ vpbroadcastb(XMM_BYTE_0, Address(needle, 0), Assembler::AVX_256bit);\n@@ -434,7 +369,8 @@\n-    \/\/ Dispatch to handlers for small needle and small haystack\n-    __ bind(L_smallSwitchTop);\n-    __ leaq(r13, Address(save_ndl_len, -1));\n-    __ cmpq(r13, NUMBER_OF_CASES - 1);\n-    __ ja(L_smallCaseDefault);\n-    __ mov64(r15, (int64_t)jump_table_1);\n-    __ jmp(Address(r15, r13, Address::times_8));\n+    \/\/ Broadcast the end of needle into a vector register.\n+    \/\/ For a single-element needle this is redundant but does no harm and\n+    \/\/ reduces code size as opposed to broadcasting only if used.\n+    if (isU) {\n+      __ vpbroadcastw(XMM_BYTE_K, Address(needle, needle_len, Address::times_1, -2), Assembler::AVX_256bit);\n+    } else {\n+      __ vpbroadcastb(XMM_BYTE_K, Address(needle, needle_len, Address::times_1, -1), Assembler::AVX_256bit);\n+    }\n@@ -442,7 +378,2 @@\n-    \/\/ Dispatch to handlers for small needle and large haystack\n-    __ bind(L_bigSwitchTop);\n-    __ leaq(rax, Address(save_ndl_len, -1));\n-    __ cmpq(rax, NUMBER_OF_CASES - 1);\n-    __ ja(L_bigCaseDefault);\n-    __ mov64(r15, (int64_t)jump_table);\n-    __ jmp(Address(r15, rax, Address::times_8));\n+    __ bind(L_short);\n+  }\n@@ -450,1 +381,3 @@\n-    __ align(CodeEntryAlignment);\n+  \/\/ Do \"big switch\" if haystack size > 32\n+  __ cmpq(haystack_len, 0x20);\n+  __ ja_b(L_bigSwitchTop);\n@@ -452,5 +385,11 @@\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/\n-    \/\/ Big case default:\n+  \/\/ Copy the small (< 32 byte) haystack to the stack.  Allows for vector reads without page fault\n+  \/\/ Only done for small haystacks\n+  \/\/\n+  \/\/ NOTE: This code assumes that the haystack points to a java array type AND there are\n+  \/\/       at least 16 bytes of header preceeding the haystack pointer.\n+  \/\/\n+  \/\/ This means that we're copying up to 15 bytes of the header onto the stack along\n+  \/\/ with the haystack bytes.  After the copy completes, we adjust the haystack pointer\n+  \/\/ to the valid haystack bytes on the stack.\n+  {\n+    Label L_moreThan16, L_adjustHaystack;\n@@ -458,2 +397,2 @@\n-    {\n-      Label L_loopTop, L_innerLoop, L_found;\n+    const Register index = rax;\n+    const Register haystack = rbx;\n@@ -461,11 +400,2 @@\n-      const Register hsPtrRet = rax;\n-      const Register mask = r8;\n-      const Register index = r9;\n-      const Register firstNeedleCompare = rdx;\n-      const Register compLen = rbp;\n-      const Register haystackStart = rcx;\n-      const Register rScratch = r13;\n-      const Register needleLen = r12;\n-      const Register needle = r14;\n-      const Register haystack = rbx;\n-      const Register retval = r15;\n+    __ cmpq(haystack_len, 0x10);\n+    __ ja_b(L_moreThan16);\n@@ -473,18 +403,4 @@\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-      \/\/\n-      \/\/ Big case default:\n-      \/\/\n-      \/\/  rbx: haystack\n-      \/\/  rcx: k\n-      \/\/  rdx: junk\n-      \/\/  rsi: n\n-      \/\/  rdi: haystack\n-      \/\/  r10: n - k\n-      \/\/  r12: k\n-      \/\/  r13: junk\n-      \/\/  r14: needle\n-      \/\/  rbp: -1\n-      \/\/  XMM_BYTE_0 - first element of needle broadcast\n-      \/\/  XMM_BYTE_K - last element of needle broadcast\n+    __ movq(index, COPIED_HAYSTACK_STACK_OFFSET + 0x10);\n+    __ movdqu(XMM_TMP1, Address(haystack, haystack_len, Address::times_1, -0x10));\n+    __ movdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), XMM_TMP1);\n+    __ jmpb(L_adjustHaystack);\n@@ -492,1 +408,4 @@\n-      __ bind(L_bigCaseDefault);\n+    __ bind(L_moreThan16);\n+    __ movq(index, COPIED_HAYSTACK_STACK_OFFSET + 0x20);\n+    __ vmovdqu(XMM_TMP1, Address(haystack, haystack_len, Address::times_1, -0x20));\n+    __ vmovdqu(Address(rsp, COPIED_HAYSTACK_STACK_OFFSET), XMM_TMP1);\n@@ -494,2 +413,4 @@\n-      \/\/ Loop construct handling for big haystacks\n-      big_case_loop_helper(false, 0, L_checkRangeAndReturn, L_loopTop, mask, hsPtrRet, needleLen, ae, _masm);\n+    __ bind(L_adjustHaystack);\n+    __ subq(index, haystack_len);\n+    __ leaq(haystack, Address(rsp, index, Address::times_1));\n+  }\n@@ -497,22 +418,6 @@\n-      \/\/ big_case_loop_helper will fall through to this point if one or more potential matches are found\n-      \/\/ The mask will have a bitmask indicating the position of the potential matches within the haystack\n-      __ align(8);\n-      __ bind(L_innerLoop);\n-      __ tzcntl(index, mask);\n-\n-      \/\/ Starting address in the haystack\n-      __ leaq(haystackStart,\n-              Address(hsPtrRet, index, Address::times_1,\n-                      isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2 : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n-      \/\/ Starting address of first byte of needle to compare\n-      __ leaq(firstNeedleCompare, Address(needle, isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2\n-                                                      : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n-      \/\/ Number of bytes to compare\n-      __ leaq(compLen, Address(needleLen,\n-                               isU ? -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE * 2)\n-                                   : -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE)));  \/\/ nlen - 2\n-                                                                              \/\/ elements\n-      __C2 arrays_equals(false, haystackStart, firstNeedleCompare, compLen, retval, rScratch, xmm_tmp3, xmm_tmp4,\n-                         false \/* char *\/, knoreg);\n-      __ testl(retval, retval);\n-      __ jne_b(L_found);\n+  \/\/ Dispatch to handlers for small needle and small haystack\n+  __ leaq(r13, Address(save_ndl_len, -1));\n+  __ cmpq(r13, NUMBER_OF_CASES - 1);\n+  __ ja(L_smallCaseDefault);\n+  __ mov64(r15, (int64_t)small_jump_table);\n+  __ jmp(Address(r15, r13, Address::times_8));\n@@ -520,3 +425,7 @@\n-      CLEAR_BIT(mask, index);\n-      __ jne(L_innerLoop);\n-      __ jmp(L_loopTop);\n+  \/\/ Dispatch to handlers for small needle and large haystack\n+  __ bind(L_bigSwitchTop);\n+  __ leaq(rax, Address(save_ndl_len, -1));\n+  __ cmpq(rax, NUMBER_OF_CASES - 1);\n+  __ ja(L_bigCaseDefault);\n+  __ mov64(r15, (int64_t)big_jump_table);\n+  __ jmp(Address(r15, rax, Address::times_8));\n@@ -524,7 +433,1 @@\n-      \/\/ Found exact match.  Compute offset from beginning of haystack\n-      __ bind(L_found);\n-      __ subq(hsPtrRet, haystack);\n-      __ addq(hsPtrRet, index);\n-      __ movq(r11, hsPtrRet);\n-      __ jmp(L_checkRangeAndReturn);\n-    }\n+  __ align(CodeEntryAlignment);\n@@ -532,0 +435,27 @@\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\n+  \/\/ Big case default:\n+\n+  {\n+    Label L_loopTop, L_innerLoop, L_found;\n+\n+    const Register hsPtrRet = rax;\n+    const Register mask = r8;\n+    const Register index = r9;\n+    const Register compLen = rbp;\n+    const Register haystackStart = rcx;\n+    const Register rScratch = r13;\n+    const Register needleLen = r12;\n+    const Register needle = r14;\n+    const Register haystack = rbx;\n+    const Register hsLength = rsi;\n+    const Register tmp1 = rdi;\n+\n+#undef retval\n+#undef firstNeedleCompare\n+#undef tmp2\n+#undef tmp3\n+#define tmp2 r15\n+#define tmp3 rdx\n@@ -536,1 +466,1 @@\n-    \/\/ Small case default:\n+    \/\/ Big case default:\n@@ -539,3 +469,4 @@\n-    \/\/  r14: needle\n-    \/\/  r13: k - 1\n-    \/\/  r12: k\n+    \/\/  rcx: k\n+    \/\/  rdx: junk\n+    \/\/  rsi: n\n+    \/\/  rdi: haystack\n@@ -543,0 +474,3 @@\n+    \/\/  r12: k\n+    \/\/  r13: junk\n+    \/\/  r14: needle\n@@ -544,4 +478,0 @@\n-    \/\/  rdi: junk\n-    \/\/  rsi: n\n-    \/\/  rdx: junk\n-    \/\/  rcx: junk\n@@ -550,4 +480,0 @@\n-    \/\/\n-    \/\/  Haystack always copied to stack, so 32-byte reads OK\n-    \/\/  Haystack length < 32\n-    \/\/  10 < needle length < 32\n@@ -555,2 +481,68 @@\n-    {\n-      __ bind(L_smallCaseDefault);\n+    __ bind(L_bigCaseDefault);\n+\n+    \/\/ Loop construct handling for big haystacks\n+    \/\/ The helper binds L_loopTop which should be jumped to if potential matches fail to compare\n+    \/\/ equal (thus moving on to the next chunk of haystack).  If we run out of haystack, the\n+    \/\/ helper jumps to L_checkRangeAndReturn with a (-1) return value.\n+    big_case_loop_helper(false, 0, L_checkRangeAndReturn, L_loopTop, mask, hsPtrRet, needleLen,\n+                         needle, haystack, hsLength, tmp1, tmp2, tmp3, rScratch, ae, _masm);\n+\n+    \/\/ big_case_loop_helper will fall through to this point if one or more potential matches are found\n+    \/\/ The mask will have a bitmask indicating the position of the potential matches within the haystack\n+    __ align(8);\n+    __ bind(L_innerLoop);\n+    __ tzcntl(index, mask);\n+\n+#undef tmp2\n+#undef tmp3\n+#define retval r15\n+#define firstNeedleCompare rdx\n+\n+    \/\/ Starting address in the haystack\n+    __ leaq(haystackStart, Address(hsPtrRet, index, Address::times_1, isU ? 4 : 2));\n+    \/\/ Starting address of first byte of needle to compare\n+    __ leaq(firstNeedleCompare, Address(needle, isU ? 4 : 2));\n+    \/\/ Number of bytes to compare\n+    __ leaq(compLen, Address(needleLen, isU ? -6 : -3));\n+    __C2 arrays_equals(false, haystackStart, firstNeedleCompare, compLen, retval, rScratch,\n+                        XMM_TMP3, XMM_TMP4, false \/* char *\/, knoreg);\n+    __ testl(retval, retval);\n+    __ jne_b(L_found);\n+\n+    CLEAR_BIT(mask, index);\n+    __ jne(L_innerLoop);\n+    __ jmp(L_loopTop);\n+\n+    \/\/ Found exact match.  Compute offset from beginning of haystack\n+    __ bind(L_found);\n+    __ subq(hsPtrRet, haystack);\n+    __ addq(hsPtrRet, index);\n+    __ movq(r11, hsPtrRet);\n+    __ jmp(L_checkRangeAndReturn);\n+\n+#undef retval\n+#undef firstNeedleCompare\n+  }\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\n+  \/\/ Small case default:\n+  \/\/\n+  \/\/  rbx: haystack\n+  \/\/  r14: needle\n+  \/\/  r13: k - 1\n+  \/\/  r12: k\n+  \/\/  r10: n - k\n+  \/\/  rbp: -1\n+  \/\/  rdi: junk\n+  \/\/  rsi: n\n+  \/\/  rdx: junk\n+  \/\/  rcx: junk\n+  \/\/  XMM_BYTE_0 - first element of needle broadcast\n+  \/\/  XMM_BYTE_K - last element of needle broadcast\n+  \/\/\n+  \/\/  Haystack always copied to stack, so 32-byte reads OK\n+  \/\/  Haystack length < 32\n+  \/\/  10 < needle length < 32\n@@ -558,1 +550,2 @@\n-      Label L_innerLoop;\n+  {\n+    __ bind(L_smallCaseDefault);\n@@ -560,7 +553,9 @@\n-      const Register firstNeedleCompare = rdx;\n-      const Register compLen = r9;\n-      const Register haystack = rbx;\n-      const Register mask = r8;\n-      const Register rTmp = rdi;\n-      const Register rTmp2 = r13;\n-      const Register rTmp3 = rax;\n+    Label L_innerLoop;\n+\n+    const Register firstNeedleCompare = rdx;\n+    const Register compLen = r9;\n+    const Register haystack = rbx;\n+    const Register mask = r8;\n+    const Register rTmp = rdi;\n+    const Register rTmp2 = r13;\n+    const Register rTmp3 = rax;\n@@ -574,13 +569,7 @@\n-      broadcast_additional_needles(false, 0 \/* unknown *\/, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, needle, needleLen, rTmp3,\n-                                   isUU, isUL, _masm);\n-\n-      assert(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 4, \"Invalid\");\n-      assert(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE >= 2, \"Invalid\");\n-      __ leaq(firstNeedleCompare, Address(needle, isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2\n-                                                      : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n-      __ leaq(compLen, Address(needleLen,\n-                               isU ? -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE * 2)\n-                                   : -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE)));  \/\/ nlen - 2\n-                                                                              \/\/ elements\n-      \/\/  firstNeedleCompare has address of second element of needle\n-      \/\/  compLen has length of comparison to do\n+    broadcast_additional_needles(false, 0 \/* unknown *\/, needle, needleLen, rTmp3, ae, _masm);\n+\n+    __ leaq(firstNeedleCompare, Address(needle, isU ? 4 : 2));\n+    __ leaq(compLen, Address(needleLen, isU ? -6 : -3));\n+\n+    \/\/  firstNeedleCompare has address of second element of needle\n+    \/\/  compLen has length of comparison to do\n@@ -588,2 +577,2 @@\n-      compare_haystack_to_needle(false, 0, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, L_returnRBP, haystack, isU,\n-                                 DO_EARLY_BAILOUT, mask, needleLen, rTmp3, _masm);\n+    compare_haystack_to_needle(false, 0, L_returnRBP, haystack, isU, mask, needleLen, rTmp3,\n+                               XMM_TMP1, XMM_TMP2, _masm);\n@@ -599,2 +588,2 @@\n-      __ movq(saveCompLen, compLen);\n-      __ movq(saveNeedleAddress, firstNeedleCompare);  \/\/ Save address of 2nd element of needle\n+    __ movq(saveCompLen, compLen);\n+    __ movq(saveNeedleAddress, firstNeedleCompare);  \/\/ Save address of 2nd element of needle\n@@ -602,3 +591,3 @@\n-      __ align(8);\n-      __ bind(L_innerLoop);\n-      __ tzcntl(r11, mask);\n+    __ align(8);\n+    __ bind(L_innerLoop);\n+    __ tzcntl(r11, mask);\n@@ -606,2 +595,1 @@\n-      __ leaq(rTmp, Address(haystack, r11, Address::times_1,\n-                            isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2 : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n+    __ leaq(rTmp, Address(haystack, r11, Address::times_1, isU ? 4 : 2));\n@@ -609,4 +597,4 @@\n-      __C2 arrays_equals(false, rTmp, firstNeedleCompare, compLen, rTmp3, rTmp2, xmm_tmp3, xmm_tmp4, false \/* char *\/,\n-                         knoreg);\n-      __ testl(rTmp3, rTmp3);\n-      __ jne_b(L_checkRangeAndReturn);\n+    __C2 arrays_equals(false, rTmp, firstNeedleCompare, compLen, rTmp3, rTmp2, XMM_TMP3, XMM_TMP4, false \/* char *\/,\n+                        knoreg);\n+    __ testl(rTmp3, rTmp3);\n+    __ jne_b(L_checkRangeAndReturn);\n@@ -614,5 +602,5 @@\n-      __ movq(compLen, saveCompLen);\n-      __ movq(firstNeedleCompare, saveNeedleAddress);\n-      CLEAR_BIT(mask, rTmp3);\n-      __ jne(L_innerLoop);\n-      __ jmp(L_returnRBP);\n+    __ movq(compLen, saveCompLen);\n+    __ movq(firstNeedleCompare, saveNeedleAddress);\n+    CLEAR_BIT(mask, rTmp3);\n+    __ jne(L_innerLoop);\n+    __ jmp(L_returnRBP);\n@@ -622,1 +610,47 @@\n-    }\n+  }\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ bind(L_returnError);\n+  __ movq(rax, -1);\n+  __ jmpb(L_return);\n+\n+  __ bind(L_returnRBP);\n+  __ movq(rax, rbp);\n+\n+  __ bind(L_bigCaseFixupAndReturn);\n+  __ subq(rcx, rbx);\n+  __ addq(rcx, r8);\n+\n+  __ movq(r11, rcx);\n+\n+  __ bind(L_checkRangeAndReturn);\n+  __ movq(rax, -1);\n+  __ cmpq(r11, nMinusK);\n+  \/\/ __ cmovq(Assembler::belowEqual, rax, r11);\n+  __ ja_b(L_return);\n+  __ movq(rax, r11);\n+\n+  __ bind(L_return);\n+  __ addptr(rsp, STACK_SPACE);\n+  __ pop(rbp);\n+#ifdef _WIN64\n+  __ pop(r9);\n+  __ pop(r8);\n+  __ pop(rcx);\n+  __ pop(rdi);\n+  __ pop(rsi);\n+#endif\n+  __ movdq(r12, save_r12);\n+  __ movdq(r13, save_r13);\n+  __ movdq(r14, save_r14);\n+  __ movdq(r15, save_r15);\n+  __ movdq(rbx, save_rbx);\n+\n+  \/\/ Need to return elements for UTF-16 encodings\n+  if (isU) {\n+    __ sarq(rax, 1);\n+  }\n+  __ vzeroupper();\n@@ -624,0 +658,5 @@\n+  __ leave();  \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n+\n+  if (isReallyUL) {\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n@@ -625,0 +664,1 @@\n+    \/\/                         Wide char code\n@@ -627,0 +667,11 @@\n+    \/\/\n+    \/\/ Pseudo-code:\n+    \/\/\n+    \/\/ If needle length less than MAX_NEEDLE_LEN_TO_EXPAND, read the needle\n+    \/\/ bytes from r14 and write them as words onto the stack.  Then go to the\n+    \/\/ \"regular\" code.  This is equavilent to doing a UU comparison, since the\n+    \/\/ haystack will be in UTF-16.\n+    \/\/\n+    \/\/ If the needle can't be expanded, process the same way as the default\n+    \/\/ cases above. That is, for each haystack chunk, compare the needle.\n+    __ bind(L_wcharBegin);\n@@ -628,3 +679,3 @@\n-    __ bind(L_returnError);\n-    __ movq(rbp, -1);\n-    __ jmpb(L_returnRBP);\n+    ae = StrIntrinsicNode::UL;\n+    isUL = true;\n+    isUU = false;\n@@ -632,3 +683,1 @@\n-    __ bind(L_returnZero);\n-    __ xorl(rbp, rbp);\n-    __ jmpb(L_returnRBP);\n+    Label L_top, L_finished;\n@@ -636,4 +685,4 @@\n-    __ bind(L_bigCaseFixupAndReturn);\n-    __ movl(rax, r8);\n-    __ subq(rcx, rbx);\n-    __ addq(rcx, rax);\n+    const Register haystack = rdi;\n+    const Register hsLen = rsi;\n+    const Register needle = rdx;\n+    const Register nLen = rcx;\n@@ -641,2 +690,3 @@\n-    __ bind(L_checkRangeAndReturnRCX);\n-    __ movq(r11, rcx);\n+    const Register offset = rax;\n+    const Register index = rbx;\n+    const Register wr_index = r13;\n@@ -644,4 +694,1 @@\n-    __ bind(L_checkRangeAndReturn);\n-    __ cmpq(r11, r10);\n-    __ movq(rbp, -1);\n-    __ cmovq(Assembler::belowEqual, rbp, r11);\n+    assert(MAX_NEEDLE_LEN_TO_EXPAND >= 32, \"Small UL needles not supported\");\n@@ -649,29 +696,1 @@\n-    __ bind(L_returnRBP);\n-    __ movq(rax, rbp);\n-    __ addptr(rsp, STACK_SPACE);\n-    __ pop(rbp);\n-#ifdef _WIN64\n-    __ pop(r9);\n-    __ pop(r8);\n-    __ pop(rcx);\n-    __ pop(rdi);\n-    __ pop(rsi);\n-#endif\n-#ifdef PUSH_REGS\n-    __ pop(rbx);\n-    __ pop(r12);\n-    __ pop(r13);\n-    __ pop(r14);\n-    __ pop(r15);\n-#else\n-    __ movdq(r12, save_r12);\n-    __ movdq(r13, save_r13);\n-    __ movdq(r14, save_r14);\n-    __ movdq(r15, save_r15);\n-    __ movdq(rbx, save_rbx);\n-#endif\n-    \/\/ Need to return elements for UTF-16 encodings\n-    if (isU) {\n-      __ sarq(rax, 1);\n-    }\n-    __ vzeroupper();\n+    __ shlq(hsLen, 1);\n@@ -679,2 +698,64 @@\n-    __ leave();  \/\/ required for proper stackwalking of RuntimeStub frame\n-    __ ret(0);\n+    __ leaq(index, Address(nLen, nLen, Address::times_1));\n+    __ cmpq(index, hsLen);\n+    __ jg(L_returnRBP);\n+\n+    __ cmpq(nLen, MAX_NEEDLE_LEN_TO_EXPAND);\n+    __ ja(L_wideNoExpand);\n+\n+    \/\/\n+    \/\/ Reads of existing needle are 16-byte chunks\n+    \/\/ Writes to copied needle are 32-byte chunks\n+    \/\/ Don't read past the end of the existing needle\n+    \/\/\n+    \/\/ Start first read at [((ndlLen % 16) - 16) & 0xf]\n+    \/\/ outndx += 32\n+    \/\/ inndx += 16\n+    \/\/ cmp nndx, ndlLen\n+    \/\/ jae done\n+    \/\/\n+    \/\/ Final index of start of needle @((16 - (ndlLen %16)) & 0xf) << 1\n+    \/\/\n+    \/\/ Starting read for needle at -(16 - (nLen % 16))\n+    \/\/ Offset of needle in stack should be (16 - (nLen % 16)) * 2\n+\n+    __ movq(index, needle_len);\n+    __ andq(index, 0xf);  \/\/ nLen % 16\n+    __ movq(offset, 0x10);\n+    __ subq(offset, index);  \/\/ 16 - (nLen % 16)\n+    __ movq(index, offset);\n+    __ shlq(offset, 1);  \/\/ * 2\n+    __ negq(index);      \/\/ -(16 - (nLen % 16))\n+    __ xorq(wr_index, wr_index);\n+\n+    __ bind(L_top);\n+    \/\/ load needle[low-16]\n+    __ vpmovzxbw(xmm0, Address(needle, index, Address::times_1), Assembler::AVX_256bit);\n+    \/\/ store to stack\n+    __ vmovdqu(Address(rsp, wr_index, Address::times_1, EXPANDED_NEEDLE_STACK_OFFSET), xmm0);\n+    __ addq(index, 0x10);\n+    __ cmpq(index, needle_len);\n+    __ jae(L_finished);\n+    __ addq(wr_index, 32);\n+    __ jmpb(L_top);\n+\n+    __ bind(L_finished);\n+    __ leaq(needle, Address(rsp, offset, Address::times_1, EXPANDED_NEEDLE_STACK_OFFSET));\n+    __ leaq(needle_len, Address(needle_len, needle_len));\n+\n+    __ jmp(L_continue);\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\n+    \/\/ Compare Latin-1 encoded needle against UTF-16 encoded haystack.\n+    \/\/\n+    \/\/ The needle is more than MAX_NEEDLE_LEN_TO_EXPAND bytes in length, and the haystack\n+    \/\/ is at least as big.\n+\n+    \/\/ Prepare for wchar anysize\n+    __ bind(L_wideNoExpand);\n+\n+    {\n+      Label L_loopTop, L_temp, L_innerLoop, L_found, L_compareFull;\n+      Label doCompare, topLoop;\n@@ -682,2 +763,0 @@\n-    if (isUL) {\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n@@ -685,1 +764,0 @@\n-      \/\/                         Wide char code\n@@ -689,12 +767,12 @@\n-      \/\/ Pseudo-code:\n-      \/\/\n-      \/\/ If needle length less than MAX_NEEDLE_LEN_TO_EXPAND, read the needle\n-      \/\/ bytes from r14 and write them as words onto the stack.  Then go to the\n-      \/\/ \"regular\" code.  This is equavilent to doing a UU comparison, since the\n-      \/\/ haystack will be in UTF-16.\n-      \/\/\n-      \/\/ If the needle can't be expanded, process the same way as the default\n-      \/\/ cases above. That is, for each haystack chunk, compare the needle.\n-      __ bind(L_wcharBegin);\n-\n-      Label L_top, L_finished;\n+      \/\/  rbx: haystack\n+      \/\/  rcx: k\n+      \/\/  rdx: junk\n+      \/\/  rsi: n\n+      \/\/  rdi: haystack\n+      \/\/  r10: n - k\n+      \/\/  r12: k\n+      \/\/  r13: junk\n+      \/\/  r14: needle\n+      \/\/  rbp: -1\n+      \/\/  XMM_BYTE_0 - first element of needle broadcast\n+      \/\/  XMM_BYTE_K - last element of needle broadcast\n@@ -702,1 +780,5 @@\n-      const Register haystack = rdi;\n+      const Register rTmp = rax;\n+      const Register haystack = rbx;\n+      const Register saveNeedleAddress = rbx;  \/\/ NOTE re-use\n+      const Register origNeedleLen = rcx;\n+      const Register firstNeedleCompare = rdx;\n@@ -704,2 +786,11 @@\n-      const Register needle = rdx;\n-      const Register nLen = rcx;\n+      const Register origHsLen = rsi;  \/\/ NOTE re-use\n+      const Register rTmp2 = rdi;\n+      const Register mask = rbp;\n+      const Register rScratch = r8;\n+      const Register compLen = r9;\n+      const Register needleLen = r12;\n+      const Register hsIndex = r12;  \/\/ NOTE re-use\n+      const Register constOffset = r13;\n+      const Register needle = r14;\n+      const Register index = r14;  \/\/ NOTE re-use\n+      const Register haystackEnd = r15;\n@@ -707,3 +798,3 @@\n-      const Register offset = rax;\n-      const Register index = rbx;\n-      const Register wr_index = r13;\n+      const XMMRegister result = XMM_TMP3;\n+      const XMMRegister cmp_0 = XMM_TMP3;\n+      const XMMRegister cmp_k = XMM_TMP4;\n@@ -711,1 +802,2 @@\n-      assert(MAX_NEEDLE_LEN_TO_EXPAND >= 32, \"Small UL needles not supported\");\n+      const XMMRegister saveCompLen = XMM_TMP2;\n+      const XMMRegister saveIndex = XMM_TMP1;\n@@ -713,1 +805,4 @@\n-      __ shlq(hsLen, 1);\n+      \/\/ Move registers into expected registers for rest of this routine\n+      __ movq(rbx, rdi);\n+      __ movq(r12, rcx);\n+      __ movq(r14, rdx);\n@@ -715,4 +810,6 @@\n-      \/\/ __ movq(r14, hsLen);\n-      __ leaq(index, Address(nLen, nLen, Address::times_1));\n-      __ cmpq(index, hsLen);\n-      __ jg(L_returnRBP);\n+      __ movq(rTmp, origNeedleLen);\n+      __ shlq(rTmp, 1);\n+      __ movq(rScratch, origHsLen);\n+      __ subq(rScratch, rTmp);\n+      __ cmpq(rScratch, 0x20);\n+      __ jl(L_compareFull);\n@@ -720,2 +817,1 @@\n-      __ cmpq(nLen, MAX_NEEDLE_LEN_TO_EXPAND);\n-      __ ja(L_wideNoExpand);\n+      \/\/ Now there is room for a 32-byte read for the last iteration\n@@ -723,41 +819,5 @@\n-      \/\/\n-      \/\/ Reads of existing needle are 16-byte chunks\n-      \/\/ Writes to copied needle are 32-byte chunks\n-      \/\/ Don't read past the end of the existing needle\n-      \/\/\n-      \/\/ Start first read at [((ndlLen % 16) - 16) & 0xf]\n-      \/\/ outndx += 32\n-      \/\/ inndx += 16\n-      \/\/ cmp nndx, ndlLen\n-      \/\/ jae done\n-      \/\/\n-      \/\/ Final index of start of needle @((16 - (ndlLen %16)) & 0xf) << 1\n-      \/\/\n-      \/\/ Starting read for needle at -(16 - (nLen % 16))\n-      \/\/ Offset of needle in stack should be (16 - (nLen % 16)) * 2\n-\n-      __ movq(index, needle_len);\n-      __ andq(index, 0xf);  \/\/ nLen % 16\n-      __ movq(offset, 0x10);\n-      __ subq(offset, index);  \/\/ 16 - (nLen % 16)\n-      __ movq(index, offset);\n-      __ shlq(offset, 1);  \/\/ * 2\n-      __ negq(index);      \/\/ -(16 - (nLen % 16))\n-      __ xorq(wr_index, wr_index);\n-\n-      __ bind(L_top);\n-      \/\/ load needle[low-16]\n-      __ vpmovzxbw(xmm0, Address(needle, index, Address::times_1), Assembler::AVX_256bit);\n-      \/\/ store to stack\n-      __ vmovdqu(Address(rsp, wr_index, Address::times_1, EXPANDED_NEEDLE_STACK_OFFSET), xmm0);\n-      __ addq(index, 0x10);\n-      __ cmpq(index, needle_len);\n-      __ jae(L_finished);\n-      __ addq(wr_index, 32);\n-      __ jmpb(L_top);\n-\n-      __ bind(L_finished);\n-      __ leaq(needle, Address(rsp, offset, Address::times_1, EXPANDED_NEEDLE_STACK_OFFSET));\n-      __ leaq(needle_len, Address(needle_len, needle_len));\n-\n-      __ jmp(L_continue);\n+      \/\/ Always need needle broadcast to ymm registers\n+      __ movzbl(rax, Address(needle));  \/\/ First byte of needle\n+      __ movdl(XMM_BYTE_0, rax);\n+      \/\/ 1st byte of needle in words\n+      __ vpbroadcastw(XMM_BYTE_0, XMM_BYTE_0, Assembler::AVX_256bit);\n@@ -765,8 +825,12 @@\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-      \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-      \/\/\n-      \/\/ Compare Latin-1 encoded needle against UTF-16 encoded haystack.\n-      \/\/\n-      \/\/ The needle is more than MAX_NEEDLE_LEN_TO_EXPAND bytes in length, and the haystack\n-      \/\/ is at least as big.\n+      __ movzbl(rax, Address(needle, needle_len, Address::times_1,\n+                              -1));  \/\/ Last byte of needle\n+      __ movdl(XMM_BYTE_K, rax);\n+      __ vpbroadcastw(XMM_BYTE_K, XMM_BYTE_K,\n+                      Assembler::AVX_256bit);  \/\/ Last byte of needle in words\n+\n+      \/\/ __ bind(L_bigCaseDefault);\n+      __ movq(r11, -1);\n+\n+      broadcast_additional_needles(false, 0 \/* unknown *\/, needle, origNeedleLen, rax, ae, _masm);\n+\n+      __ leaq(haystackEnd, Address(haystack, hsLen, Address::times_1));\n@@ -774,2 +838,2 @@\n-      \/\/ Prepare for wchar anysize\n-      __ bind(L_wideNoExpand);\n+      __ leaq(firstNeedleCompare, Address(needle, 2));\n+      __ leaq(compLen, Address(needleLen, -2));\n@@ -777,0 +841,23 @@\n+      \/\/  firstNeedleCompare has address of second element of needle\n+      \/\/  compLen has length of comparison to do\n+\n+      \/\/ Save haystack\n+      __ movq(Address(rsp, SAVED_HAYSTACK_STACK_OFFSET), haystack);\n+\n+      __ movq(index, origHsLen);\n+      __ negptr(index);  \/\/ incr\n+\n+      \/\/ constant offset from end for full 32-byte read\n+      __ movq(constOffset, origHsLen);\n+      __ shlq(origNeedleLen, 1);\n+      __ subq(constOffset, origNeedleLen);\n+      __ andq(constOffset, 0x1f);\n+      __ negptr(constOffset);\n+      __ jmpb(L_temp);\n+\n+      __ bind(L_loopTop);\n+      __ addq(index, 32);\n+      __ subq(origHsLen, 32);\n+      __ jle(L_returnError);\n+      __ cmpq(index, constOffset);\n+      \/\/ __ cmovq(Assembler::greater, index, constOffset);\n@@ -778,137 +865,19 @@\n-        Label L_loopTop, L_temp, L_innerLoop, L_found, L_compareFull;\n-        Label doCompare, topLoop;\n-\n-        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-        \/\/\n-        \/\/  rbx: haystack\n-        \/\/  rcx: k\n-        \/\/  rdx: junk\n-        \/\/  rsi: n\n-        \/\/  rdi: haystack\n-        \/\/  r10: n - k\n-        \/\/  r12: k\n-        \/\/  r13: junk\n-        \/\/  r14: needle\n-        \/\/  rbp: -1\n-        \/\/  XMM_BYTE_0 - first element of needle broadcast\n-        \/\/  XMM_BYTE_K - last element of needle broadcast\n-\n-        const Register rTmp = rax;\n-        const Register haystack = rbx;\n-        const Register saveNeedleAddress = rbx;  \/\/ NOTE re-use\n-        const Register origNeedleLen = rcx;\n-        const Register firstNeedleCompare = rdx;\n-        const Register hsLen = rsi;\n-        const Register origHsLen = rsi;  \/\/ NOTE re-use\n-        const Register rTmp2 = rdi;\n-        const Register mask = rbp;\n-        const Register rScratch = r8;\n-        const Register compLen = r9;\n-        const Register needleLen = r12;\n-        const Register hsIndex = r12;  \/\/ NOTE re-use\n-        const Register constOffset = r13;\n-        const Register needle = r14;\n-        const Register index = r14;  \/\/ NOTE re-use\n-        const Register haystackEnd = r15;\n-\n-        const XMMRegister cmp_0 = xmm_tmp3;\n-        const XMMRegister cmp_k = xmm_tmp4;\n-        const XMMRegister result = xmm_tmp3;\n-\n-        const XMMRegister saveCompLen = xmm_tmp2;\n-        const XMMRegister saveIndex = xmm_tmp1;\n-\n-        \/\/ Move registers into expected registers for rest of this routine\n-        __ movq(rbx, rdi);\n-        __ movq(r12, rcx);\n-        __ movq(r14, rdx);\n-\n-        __ movq(rTmp, origNeedleLen);\n-        __ shlq(rTmp, 1);\n-        __ movq(rScratch, origHsLen);\n-        __ subq(rScratch, rTmp);\n-        __ cmpq(rScratch, 0x20);\n-        __ jl(L_compareFull);\n-\n-        \/\/ Now there is room for a 32-byte read for the last iteration\n-\n-        \/\/ Always need needle broadcast to ymm registers\n-        __ movzbl(rax, Address(needle));  \/\/ First byte of needle\n-        __ movdl(byte_0, rax);\n-        \/\/ 1st byte of needle in words\n-        __ vpbroadcastw(byte_0, byte_0, Assembler::AVX_256bit);\n-\n-        __ movzbl(rax, Address(needle, needle_len, Address::times_1,\n-                               -1));  \/\/ Last byte of needle\n-        __ movdl(byte_k, rax);\n-        __ vpbroadcastw(byte_k, byte_k,\n-                        Assembler::AVX_256bit);  \/\/ Last byte of needle in words\n-\n-        \/\/ __ bind(L_bigCaseDefault);\n-        __ movq(r11, -1);\n-\n-        broadcast_additional_needles(false, 0 \/* unknown *\/, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, needle, origNeedleLen,\n-                                     rax, isUU, isUL, _masm);\n-\n-        __ leaq(haystackEnd, Address(haystack, hsLen, Address::times_1));\n-\n-        assert(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 4, \"Invalid\");\n-        assert(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE >= 2, \"Invalid\");\n-        __ leaq(firstNeedleCompare, Address(needle, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1));\n-        __ leaq(compLen, Address(needleLen,\n-                                 -(NUMBER_OF_NEEDLE_BYTES_TO_COMPARE)));  \/\/ nlen - 2 elements\n-\n-        \/\/  firstNeedleCompare has address of second element of needle\n-        \/\/  compLen has length of comparison to do\n-\n-        \/\/ Save haystack\n-        __ movq(Address(rsp, SAVED_HAYSTACK_STACK_OFFSET), haystack);\n-\n-        __ movq(index, origHsLen);\n-        __ negptr(index);  \/\/ incr\n-\n-        \/\/ constant offset from end for full 32-byte read\n-        __ movq(constOffset, origHsLen);\n-        __ shlq(origNeedleLen, 1);\n-        __ subq(constOffset, origNeedleLen);\n-        __ andq(constOffset, 0x1f);\n-        __ negptr(constOffset);\n-        __ jmpb(L_temp);\n-\n-        __ bind(L_loopTop);\n-        __ addq(index, 32);\n-        __ subq(origHsLen, 32);\n-        __ jle(L_returnError);\n-        __ cmpq(index, constOffset);\n-        __ cmovq(Assembler::greater, index, constOffset);\n-\n-        __ bind(L_temp);\n-        __ movq(hsIndex, origNeedleLen);\n-        __ addq(hsIndex, index);\n-\n-        \/\/ Compare first byte of needle to haystack\n-        __ vpcmpeqw(cmp_0, byte_0, Address(haystackEnd, index), Assembler::AVX_256bit);\n-        \/\/ Compare last byte of needle to haystack at proper position\n-        __ vpcmpeqw(cmp_k, byte_k, Address(haystackEnd, hsIndex, Address::times_1, -2), Assembler::AVX_256bit);\n-        __ vpand(result, cmp_k, cmp_0, Assembler::AVX_256bit);\n-#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE > 2\n-#if DO_EARLY_BAILOUT > 0\n-        __ vpmovmskb(mask, result, Assembler::AVX_256bit);\n-        __ testl(mask, mask);\n-        __ je_b(L_loopTop);\n-#endif\n-        \/\/ Compare second byte of needle to haystack\n-        __ vpcmpeqw(cmp_k, byte_1, Address(haystackEnd, index, Address::times_1, 2), Assembler::AVX_256bit);\n-        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n-#endif\n-#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE > 3\n-#if DO_EARLY_BAILOUT > 0\n-        __ vpmovmskb(mask, result, Assembler::AVX_256bit);\n-        __ testl(mask, mask);\n-        __ je_b(L_loopTop);\n-#endif\n-        \/\/ Compare third byte of needle to haystack\n-        __ vpcmpeqw(cmp_k, byte_2, Address(haystackEnd, index, Address::times_1, 4), Assembler::AVX_256bit);\n-        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n+        Label L_tmp;\n+        __ jle_b(L_tmp);\n+        __ movq(index, constOffset);\n+        __ bind(L_tmp);\n+      }\n+\n+      __ bind(L_temp);\n+      __ movq(hsIndex, origNeedleLen);\n+      __ addq(hsIndex, index);\n+\n+      \/\/ Compare first byte of needle to haystack\n+      __ vpcmpeqw(cmp_0, XMM_BYTE_0, Address(haystackEnd, index), Assembler::AVX_256bit);\n+      \/\/ Compare last byte of needle to haystack at proper position\n+      __ vpcmpeqw(cmp_k, XMM_BYTE_K, Address(haystackEnd, hsIndex, Address::times_1, -2), Assembler::AVX_256bit);\n+      __ vpand(result, cmp_k, cmp_0, Assembler::AVX_256bit);\n+#ifdef DO_EARLY_BAILOUT\n+      __ vpmovmskb(mask, result, Assembler::AVX_256bit);\n+      __ testl(mask, mask);\n+      __ je_b(L_loopTop);\n@@ -916,3 +885,0 @@\n-        __ vpmovmskb(mask, result, Assembler::AVX_256bit);\n-        __ testl(mask, mask);\n-        __ je_b(L_loopTop);\n@@ -920,3 +886,6 @@\n-        __ align(8);\n-        __ bind(L_innerLoop);\n-        __ tzcntl(rTmp, mask);\n+      \/\/ Compare second byte of needle to haystack\n+      __ vpcmpeqw(cmp_k, XMM_BYTE_1, Address(haystackEnd, index, Address::times_1, 2), Assembler::AVX_256bit);\n+      __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n+      __ vpmovmskb(mask, result, Assembler::AVX_256bit);\n+      __ testl(mask, mask);\n+      __ je_b(L_loopTop);\n@@ -924,4 +893,15 @@\n-        __ movdq(saveIndex, rTmp);\n-        __ movdq(saveCompLen, compLen);\n-        \/\/ Save address of nth element of needle\n-        __ movq(saveNeedleAddress, firstNeedleCompare);\n+      __ align(8);\n+      __ bind(L_innerLoop);\n+      __ tzcntl(rTmp, mask);\n+\n+      __ movdq(saveIndex, rTmp);\n+      __ movdq(saveCompLen, compLen);\n+      \/\/ Save address of nth element of needle\n+      __ movq(saveNeedleAddress, firstNeedleCompare);\n+\n+      __ leaq(rTmp2, Address(haystackEnd, index, Address::times_1, 4));\n+      __ addq(rTmp2, rTmp);\n+      __C2 arrays_equals(false, rTmp2, firstNeedleCompare, compLen, rTmp, rScratch, XMM_TMP3,\n+                         XMM_TMP4, false \/* char *\/, knoreg, true \/* expand_ary2 *\/);\n+      __ testl(rTmp, rTmp);\n+      __ jne_b(L_found);\n@@ -929,55 +909,35 @@\n-#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 2\n-        __ leaq(rTmp2, Address(haystackEnd, index, Address::times_1, 2));\n-#endif\n-#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE == 3\n-        __ leaq(rTmp2, Address(haystackEnd, index, Address::times_1, 4));\n-#endif\n-#if NUMBER_OF_NEEDLE_BYTES_TO_COMPARE == 4\n-        __ leaq(rTmp2, Address(haystackEnd, index, Address::times_1, 6));\n-#endif\n-        __ addq(rTmp2, rTmp);\n-        __C2 arrays_equals(false, rTmp2, firstNeedleCompare, compLen, rTmp, rScratch, xmm_tmp3, xmm_tmp4,\n-                           false \/* char *\/, knoreg, true \/* expand_ary2 *\/);\n-        __ testl(rTmp, rTmp);\n-        __ jne_b(L_found);\n-\n-        __ movdq(compLen, saveCompLen);\n-        __ movq(firstNeedleCompare, saveNeedleAddress);\n-        CLEAR_BIT(mask, rTmp);\n-        __ jne(L_innerLoop);\n-        __ jmp(L_loopTop);\n-\n-        __ bind(L_found);\n-        __ movdq(rTmp, saveIndex);\n-        __ leaq(rScratch, Address(haystackEnd, index, Address::times_1));\n-        __ subq(rScratch, Address(rsp, SAVED_HAYSTACK_STACK_OFFSET));\n-        __ addq(rScratch, rTmp);\n-        __ movq(r11, rScratch);\n-        __ jmp(L_checkRangeAndReturn);\n-\n-        __ bind(L_compareFull);\n-\n-        \/\/ rScratch has n - k.  Compare entire string word-by-word\n-        __ xorq(r11, r11);\n-        __ movq(r10, rScratch);\n-        __ jmpb(doCompare);\n-\n-        __ bind(topLoop);\n-        __ addq(r11, 2);\n-        __ cmpq(r11, rScratch);\n-        __ jg(L_returnRBP);\n-\n-        __ bind(doCompare);\n-        __ leaq(r9, Address(haystack, r11));\n-        __ leaq(r12, Address(needle, 0));\n-        __ movq(r13, origNeedleLen);\n-\n-        __C2 arrays_equals(false, r9, r12, r13, rax, rdx, xmm_tmp3, xmm_tmp4, false \/* char *\/, knoreg,\n-                           true \/* expand_ary2 *\/);\n-        __ testq(rax, rax);\n-        __ jz(topLoop);\n-\n-        \/\/ Match found\n-        __ jmp(L_checkRangeAndReturn);\n-      }\n-    }\n+      __ movdq(compLen, saveCompLen);\n+      __ movq(firstNeedleCompare, saveNeedleAddress);\n+      CLEAR_BIT(mask, rTmp);\n+      __ jne(L_innerLoop);\n+      __ jmp(L_loopTop);\n+\n+      __ bind(L_found);\n+      __ movdq(rTmp, saveIndex);\n+      __ leaq(rScratch, Address(haystackEnd, index, Address::times_1));\n+      __ subq(rScratch, Address(rsp, SAVED_HAYSTACK_STACK_OFFSET));\n+      __ addq(rScratch, rTmp);\n+      __ movq(r11, rScratch);\n+      __ jmp(L_checkRangeAndReturn);\n+\n+      __ bind(L_compareFull);\n+\n+      \/\/ rScratch has n - k.  Compare entire string word-by-word\n+      __ xorq(r11, r11);\n+      __ movq(nMinusK, rScratch);\n+      __ jmpb(doCompare);\n+\n+      __ bind(topLoop);\n+      __ addq(r11, 2);\n+      __ cmpq(r11, rScratch);\n+      __ jg(L_returnRBP);\n+\n+      __ bind(doCompare);\n+      __ leaq(r9, Address(haystack, r11));\n+      __ leaq(r12, Address(needle, 0));\n+      __ movq(r13, origNeedleLen);\n+\n+      __C2 arrays_equals(false, r9, r12, r13, rax, rdx, XMM_TMP3, XMM_TMP4, false \/* char *\/,\n+                         knoreg, true \/* expand_ary2 *\/);\n+      __ testq(rax, rax);\n+      __ jz(topLoop);\n@@ -985,2 +945,3 @@\n-  } else {  \/\/ SSE version\n-    assert(false, \"Only supports AVX2\");\n+      \/\/ Match found\n+      __ jmp(L_checkRangeAndReturn);\n+    }\n@@ -1003,1 +964,0 @@\n-\/\/ bytesToCompare - see NUMBER_OF_NEEDLE_BYTES_TO_COMPARE above\n@@ -1008,3 +968,3 @@\n-static void broadcast_additional_needles(bool sizeKnown, int size, int bytesToCompare, Register needle,\n-                                         Register needleLen, Register rTmp, bool isUU, bool isUL,\n-                                         MacroAssembler *_masm) {\n+static void broadcast_additional_needles(bool sizeKnown, int size, Register needle,\n+                                         Register needleLen, Register rTmp,\n+                                         StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm) {\n@@ -1013,3 +973,0 @@\n-  const XMMRegister byte_1 = XMM_BYTE_1;\n-  const XMMRegister byte_2 = XMM_BYTE_2;\n-\n@@ -1018,0 +975,3 @@\n+  bool isLL = (ae == StrIntrinsicNode::LL);\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n@@ -1022,25 +982,4 @@\n-  if (bytesToCompare > 2) {\n-    if (!sizeKnown) {\n-      __ cmpq(needleLen, (isU ? 4 : 2));\n-      __ jl_b(L_done);\n-    }\n-\n-    if (size > (isU ? 4 : 2)) {\n-      \/\/ Add compare for second byte\n-      if (isUU) {\n-        __ vpbroadcastw(byte_1, Address(needle, 2), Assembler::AVX_256bit);\n-      } else if (isUL) {\n-        __ movzbl(rTmp, Address(needle, 1));\n-        __ movdl(byte_1, rTmp);\n-        \/\/ 1st byte of needle in words\n-        __ vpbroadcastw(byte_1, byte_1, Assembler::AVX_256bit);\n-      } else {\n-        __ vpbroadcastb(byte_1, Address(needle, 1), Assembler::AVX_256bit);\n-      }\n-    }\n-\n-    if (bytesToCompare > 3) {\n-      if (!sizeKnown) {\n-        __ cmpq(needleLen, (isU ? 6 : 3));\n-        __ jl_b(L_done);\n-      }\n+  if (!sizeKnown) {\n+    __ cmpq(needleLen, (isU ? 4 : 2));\n+    __ jl_b(L_done);\n+  }\n@@ -1048,13 +987,11 @@\n-      if (size > (isU ? 6 : 3)) {\n-        \/\/ Add compare for third byte\n-        if (isUU) {\n-          __ vpbroadcastw(byte_2, Address(needle, 4), Assembler::AVX_256bit);\n-        } else if (isUL) {\n-          __ movzbl(rTmp, Address(needle, 2));\n-          __ movdl(byte_1, rTmp);\n-          \/\/ 1st byte of needle in words\n-          __ vpbroadcastw(byte_1, byte_1, Assembler::AVX_256bit);\n-        } else {\n-          __ vpbroadcastb(byte_2, Address(needle, 2), Assembler::AVX_256bit);\n-        }\n-      }\n+  if (size > (isU ? 4 : 2)) {\n+    \/\/ Add compare for second byte\n+    if (isUU) {\n+      __ vpbroadcastw(XMM_BYTE_1, Address(needle, 2), Assembler::AVX_256bit);\n+    } else if (isUL) {\n+      __ movzbl(rTmp, Address(needle, 1));\n+      __ movdl(XMM_BYTE_1, rTmp);\n+      \/\/ 1st byte of needle in words\n+      __ vpbroadcastw(XMM_BYTE_1, XMM_BYTE_1, Assembler::AVX_256bit);\n+    } else {\n+      __ vpbroadcastb(XMM_BYTE_1, Address(needle, 1), Assembler::AVX_256bit);\n@@ -1062,1 +999,0 @@\n-    __ bind(L_done);\n@@ -1064,0 +1000,2 @@\n+\n+  __ bind(L_done);\n@@ -1070,1 +1008,1 @@\n-\/\/ doEarlyBailout is true, otherwise it will progressively and together\n+\/\/ no match found, otherwise it will progressively and together\n@@ -1078,2 +1016,1 @@\n-\/\/ size - the size of the needle.  Pass 0 if unknown at compile time\n-\/\/ bytesToCompare - see NUMBER_OF_NEEDLE_BYTES_TO_COMPARE above\n+\/\/ size - the size of the needle in bytes.  Pass 0 if unknown at compile time\n@@ -1082,1 +1019,2 @@\n-\/\/ hsLen - the sizeof the haystack\n+\/\/ hsLen - the sizeof the haystack in bytes\n+\/\/ needleLen - size of the needle in bytes known at runtime\n@@ -1084,1 +1022,0 @@\n-\/\/ doEarlyBailout - if true, check mismatch after every comparison\n@@ -1091,4 +1028,7 @@\n-static void compare_big_haystack_to_needle(bool sizeKnown, int size, int bytesToCompare, Label &noMatch,\n-                                           Register haystack, Register hsLen, Register needleLen, bool isU,\n-                                           bool doEarlyBailout, Register eq_mask, Register rTmp, Register nMinusK,\n-                                           MacroAssembler *_masm) {\n+static void compare_big_haystack_to_needle(bool sizeKnown, int size, Label &noMatch,\n+                                           Register haystack, Register hsLen, Register needleLen,\n+                                           bool isU, Register eq_mask, Register rTmp,\n+                                           Register rTmp2, XMMRegister rxTmp1, XMMRegister rxTmp2,\n+                                           XMMRegister rxTmp3, MacroAssembler *_masm) {\n+\n+  assert_different_registers(eq_mask, haystack, needleLen, rTmp, hsLen, nMinusK, rTmp2);\n@@ -1096,2 +1036,4 @@\n-  assert_different_registers(eq_mask, haystack, needleLen, rTmp, hsLen, r10);\n-  assert(r10 == nMinusK, \"Bad register\");\n+  const XMMRegister result = rxTmp1;\n+  const XMMRegister cmp_0 = rxTmp2;\n+  const XMMRegister cmp_k = rxTmp3;\n+  const Register shiftVal = rTmp2;\n@@ -1099,4 +1041,2 @@\n-  const XMMRegister byte_0 = XMM_BYTE_0;\n-  const XMMRegister byte_1 = XMM_BYTE_1;\n-  const XMMRegister byte_2 = XMM_BYTE_2;\n-  const XMMRegister byte_k = XMM_BYTE_K;\n+#undef lastCompare\n+#define lastCompare rTmp\n@@ -1104,1 +1044,0 @@\n-  int scale = isU ? 2 : 1;\n@@ -1117,8 +1056,0 @@\n-#undef cmp_0\n-#define cmp_0 XMM_TMP3\n-#undef cmp_k\n-#define cmp_k XMM_TMP4\n-#undef lastCompare\n-#define lastCompare rTmp\n-#undef lastMask\n-\n@@ -1126,1 +1057,0 @@\n-  bool needToSaveRCX = false;\n@@ -1128,4 +1058,1 @@\n-  needToSaveRCX = (haystack == rcx) || (hsLen == rcx) || (eq_mask == rcx) || (rTmp == rcx) || (needleLen == rcx)\n-                  || (nMinusK == rcx);\n-\n-  Label L_OKtoCompareFull, L_done, L_specialCase_gt2, L_specialCase_gt3;\n+  Label L_OKtoCompareFull, L_done, L_specialCase_gt2;\n@@ -1140,1 +1067,1 @@\n-     vpcmpeq(cmp_0, byte_0, Address(haystack, 0), Assembler::AVX_256bit);\n+     vpcmpeq(cmp_0, XMM_BYTE_0, Address(haystack, 0), Assembler::AVX_256bit);\n@@ -1142,5 +1069,5 @@\n-  if (doEarlyBailout) {\n-    __ vpmovmskb(eq_mask, cmp_0, Assembler::AVX_256bit);\n-    __ testl(eq_mask, eq_mask);\n-    __ je(noMatch);\n-  }\n+  __ vpmovmskb(eq_mask, cmp_0, Assembler::AVX_256bit);\n+#ifdef DO_EARLY_BAILOUT\n+  __ testl(eq_mask, eq_mask);\n+  __ je(noMatch);\n+#endif\n@@ -1148,3 +1075,1 @@\n-  if (size == (isU ? 2 : 1)) {\n-    __ vpmovmskb(eq_mask, cmp_0, Assembler::AVX_256bit);\n-  } else {\n+  if (size != sizeIncr) {\n@@ -1153,1 +1078,0 @@\n-    __ vpmovmskb(eq_mask, cmp_0, Assembler::AVX_256bit);\n@@ -1158,10 +1082,2 @@\n-#undef cmp_0\n-#undef saveRCX\n-#define saveRCX XMM_TMP3\n-    if (needToSaveRCX) {\n-      __ movdq(saveRCX, rcx);\n-    }\n-#undef shiftVal\n-#define shiftVal rcx\n-    __ movq(shiftVal, isU ? 30 : 31);\n-    __ subq(shiftVal, nMinusK);\n+    __ movl(shiftVal, isU ? 30 : 31);\n+    __ subl(shiftVal, nMinusK);\n@@ -1169,1 +1085,1 @@\n-       vpcmpeq(cmp_k, byte_k, Address(lastCompare, 0), Assembler::AVX_256bit);\n+       vpcmpeq(cmp_k, XMM_BYTE_K, Address(lastCompare, 0), Assembler::AVX_256bit);\n@@ -1171,0 +1087,1 @@\n+#undef lastMask\n@@ -1174,20 +1091,11 @@\n-    __ shrq(lastMask);\n-#undef shiftVal\n-    __ andq(eq_mask, lastMask);\n-    if (needToSaveRCX) {\n-      __ movdq(rcx, saveRCX);\n-    }\n-#undef saveRCX\n-\n-    if (bytesToCompare > 2) {\n-      if (size > (isU ? 4 : 2)) {\n-        if (doEarlyBailout) {\n-          __ testl(eq_mask, eq_mask);\n-          __ je(noMatch);\n-        }\n-        __ cmpq(hsLen, isU ? 34 : 33);\n-        __ jl(L_specialCase_gt2);\n-           vpcmpeq(cmp_k, byte_1, Address(haystack, 1 * scale), Assembler::AVX_256bit);\n-        __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n-        __ andq(eq_mask, lastMask);\n-      }\n+    __ shrxl(lastMask, lastMask, shiftVal);\n+    __ andl(eq_mask, lastMask);\n+\n+    if (size > sizeIncr * 2) {\n+      __ testl(eq_mask, eq_mask);\n+      __ je(noMatch);\n+      __ cmpq(hsLen, isU ? 34 : 33);\n+      __ jl(L_specialCase_gt2);\n+      vpcmpeq(cmp_k, XMM_BYTE_1, Address(haystack, 1 * sizeIncr), Assembler::AVX_256bit);\n+      __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n+      __ andl(eq_mask, lastMask);\n@@ -1196,13 +1104,0 @@\n-    if (bytesToCompare > 3) {\n-      if (size > (isU ? 6 : 3)) {\n-        if (doEarlyBailout) {\n-          __ testl(eq_mask, eq_mask);\n-          __ je(noMatch);\n-        }\n-        __ cmpq(hsLen, isU ? 36 : 34);\n-        __ jl(L_specialCase_gt3);\n-           vpcmpeq(cmp_k, byte_2, Address(haystack, 2 * scale), Assembler::AVX_256bit);\n-        __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n-        __ andq(eq_mask, lastMask);\n-      }\n-    }\n@@ -1213,23 +1108,1 @@\n-       vpcmpeq(cmp_k, byte_1, Address(haystack, 0), Assembler::AVX_256bit);\n-    __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n-    __ shrq(lastMask, isU ? 2 : 1);\n-    __ andq(eq_mask, lastMask);\n-\n-    if (bytesToCompare > 3) {\n-      if (size > (isU ? 6 : 3)) {\n-        if (doEarlyBailout) {\n-          __ testl(eq_mask, eq_mask);\n-          __ je(noMatch);\n-        }\n-           vpcmpeq(cmp_k, byte_2, Address(haystack, 0), Assembler::AVX_256bit);\n-        __ vpmovmskb(lastMask, cmp_k, Assembler::AVX_256bit);\n-        __ shrq(lastMask, isU ? 4 : 2);\n-        __ andq(eq_mask, lastMask);\n-      }\n-    }\n-\n-    __ jmp(L_done);\n-\n-    __ bind(L_specialCase_gt3);\n-    \/\/ Comparing multiple bytes and hs length == isU ? 34 : 33\n-       vpcmpeq(cmp_k, byte_2, Address(haystack, 0), Assembler::AVX_256bit);\n+    vpcmpeq(cmp_k, XMM_BYTE_1, Address(haystack, 0), Assembler::AVX_256bit);\n@@ -1237,2 +1110,2 @@\n-    __ shrq(lastMask, isU ? 4 : 2);\n-    __ andq(eq_mask, lastMask);\n+    __ shrl(lastMask, sizeIncr);\n+    __ andl(eq_mask, lastMask);\n@@ -1244,2 +1117,0 @@\n-#define result XMM_TMP3\n-#define cmp_0 XMM_TMP3\n@@ -1248,1 +1119,1 @@\n-       vpcmpeq(cmp_k, byte_k, kThByte, Assembler::AVX_256bit);\n+    vpcmpeq(cmp_k, XMM_BYTE_K, kThByte, Assembler::AVX_256bit);\n@@ -1252,22 +1123,8 @@\n-    if (bytesToCompare > 2) {\n-      if (size > (isU ? 4 : 2)) {\n-        if (doEarlyBailout) {\n-          __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n-          __ testl(eq_mask, eq_mask);\n-          __ je(noMatch);\n-        }\n-           vpcmpeq(cmp_k, byte_1, Address(haystack, 1 * scale), Assembler::AVX_256bit);\n-        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n-      }\n-    }\n-\n-    if (bytesToCompare > 3) {\n-      if (size > (isU ? 6 : 3)) {\n-        if (doEarlyBailout) {\n-          __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n-          __ testl(eq_mask, eq_mask);\n-          __ je(noMatch);\n-        }\n-           vpcmpeq(cmp_k, byte_2, Address(haystack, 2 * scale), Assembler::AVX_256bit);\n-        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n-      }\n+    if (size > sizeIncr * 2) {\n+#ifdef DO_EARLY_BAILOUT\n+      __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n+      __ testl(eq_mask, eq_mask);\n+      __ je(noMatch);\n+#endif\n+      vpcmpeq(cmp_k, XMM_BYTE_1, Address(haystack, 1 * sizeIncr), Assembler::AVX_256bit);\n+      __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n@@ -1284,3 +1141,0 @@\n-#undef cmp_0\n-#undef cmp_k\n-#undef result\n@@ -1289,1 +1143,0 @@\n-#undef saveRCX\n@@ -1296,1 +1149,1 @@\n-\/\/ doEarlyBailout is true, otherwise it will progressively and together\n+\/\/ a match is not found, otherwise it will progressively and together\n@@ -1306,1 +1159,0 @@\n-\/\/ bytesToCompare - see NUMBER_OF_NEEDLE_BYTES_TO_COMPARE above\n@@ -1310,1 +1162,0 @@\n-\/\/ doEarlyBailout - if true, check mismatch after every comparison\n@@ -1319,3 +1170,4 @@\n-static void compare_haystack_to_needle(bool sizeKnown, int size, int bytesToCompare, Label &noMatch, Register haystack,\n-                                       bool isU, bool doEarlyBailout, Register eq_mask, Register needleLen,\n-                                       Register rTmp, MacroAssembler *_masm) {\n+static void compare_haystack_to_needle(bool sizeKnown, int size, Label &noMatch, Register haystack,\n+                                       bool isU, Register eq_mask, Register needleLen,\n+                                       Register rTmp, XMMRegister rxTmp1, XMMRegister rxTmp2,\n+                                       MacroAssembler *_masm) {\n@@ -1323,1 +1175,1 @@\n-  assert_different_registers(eq_mask, haystack, needleLen, rTmp, r10);\n+  assert_different_registers(eq_mask, haystack, needleLen, rTmp, nMinusK);\n@@ -1325,4 +1177,0 @@\n-  const XMMRegister byte_0 = XMM_BYTE_0;\n-  const XMMRegister byte_1 = XMM_BYTE_1;\n-  const XMMRegister byte_2 = XMM_BYTE_2;\n-  const XMMRegister byte_k = XMM_BYTE_K;\n@@ -1330,3 +1178,3 @@\n-  const XMMRegister cmp_0 = XMM_TMP3;\n-  const XMMRegister result = XMM_TMP3;\n-  const XMMRegister cmp_k = XMM_TMP4;\n+  const XMMRegister cmp_0 = rxTmp1;\n+  const XMMRegister result = rxTmp1;\n+  const XMMRegister cmp_k = rxTmp2;\n@@ -1334,1 +1182,0 @@\n-  int scale = isU ? 2 : 1;\n@@ -1359,1 +1206,1 @@\n-  __ movq(eq_mask, r10);  \/\/ Assumes r10 has n - k\n+  __ movq(eq_mask, nMinusK);\n@@ -1364,2 +1211,2 @@\n-     vpcmpeq(cmp_0, byte_0, Address(haystack, 0), Assembler::AVX_256bit);\n-  if (size != (isU ? 2 : 1)) {\n+     vpcmpeq(cmp_0, XMM_BYTE_0, Address(haystack, 0), Assembler::AVX_256bit);\n+  if (size != sizeIncr) {\n@@ -1367,1 +1214,1 @@\n-       vpcmpeq(cmp_k, byte_k, kThByte, Assembler::AVX_256bit);\n+    vpcmpeq(cmp_k, XMM_BYTE_K, kThByte, Assembler::AVX_256bit);\n@@ -1371,24 +1218,9 @@\n-    if (bytesToCompare > 2) {\n-      if (size > (isU ? 4 : 2)) {\n-        if (doEarlyBailout) {\n-          __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n-          __ andq(eq_mask, rTmp);\n-          __ testl(eq_mask, eq_mask);\n-          __ je(noMatch);\n-        }\n-           vpcmpeq(cmp_k, byte_1, Address(haystack, 1 * scale), Assembler::AVX_256bit);\n-        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n-      }\n-    }\n-\n-    if (bytesToCompare > 3) {\n-      if (size > (isU ? 6 : 3)) {\n-        if (doEarlyBailout) {\n-          __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n-          __ andq(eq_mask, rTmp);\n-          __ testl(eq_mask, eq_mask);\n-          __ je(noMatch);\n-        }\n-           vpcmpeq(cmp_k, byte_2, Address(haystack, 2 * scale), Assembler::AVX_256bit);\n-        __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n-      }\n+    if (size > (sizeIncr * 2)) {\n+#ifdef DO_EARLY_BAILOUT\n+      __ vpmovmskb(eq_mask, result, Assembler::AVX_256bit);\n+      __ andq(eq_mask, rTmp);\n+      __ testl(eq_mask, eq_mask);\n+      __ je(noMatch);\n+#endif\n+      vpcmpeq(cmp_k, XMM_BYTE_1, Address(haystack, 1 * sizeIncr), Assembler::AVX_256bit);\n+      __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n@@ -1446,4 +1278,6 @@\n-static void big_case_loop_helper(bool sizeKnown, int size, Label &noMatch, Label &loop_top, Register eq_mask,\n-                                 Register hsPtrRet, Register needleLen, StrIntrinsicNode::ArgEncoding ae,\n-                                 MacroAssembler *_masm) {\n-  Label temp;\n+static void big_case_loop_helper(bool sizeKnown, int size, Label &noMatch, Label &loop_top,\n+                                 Register eq_mask, Register hsPtrRet, Register needleLen,\n+                                 Register needle, Register haystack, Register hsLength,\n+                                 Register rTmp1, Register rTmp2, Register rTmp3, Register rTmp4,\n+                                 StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm) {\n+  Label L_midLoop;\n@@ -1451,1 +1285,1 @@\n-  assert_different_registers(eq_mask, hsPtrRet, needleLen, rdi, r15, rdx, rsi, rbx, r14, r10);\n+  assert_different_registers(eq_mask, hsPtrRet, needleLen, rdi, r15, rdx, rsi, rbx, r14, nMinusK);\n@@ -1453,6 +1287,4 @@\n-  const Register needle = r14;\n-  const Register haystack = rbx;\n-  const Register hsLength = rsi;\n-  const Register last = rdi;\n-  const Register temp1 = r15;\n-  const Register temp2 = rdx;\n+  const Register last = rTmp1;\n+  const Register temp1 = rTmp2;\n+  const Register temp2 = rTmp3;\n+  const Register temp3 = rTmp4;\n@@ -1465,10 +1297,1 @@\n-  assert_different_registers(eq_mask, hsPtrRet, needleLen, haystack, needle, hsLength, last);\n-  \/\/  hsLength, termAddr, last);\n-\n-  if (isU && (size & 1)) {\n-    __ emit_int8(0xcc);\n-    return;\n-  }\n-\n-  broadcast_additional_needles(sizeKnown, size, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, needle, needleLen, temp1, isUU, isUL,\n-                               _masm);\n+  broadcast_additional_needles(sizeKnown, size, needle, needleLen, temp1, ae, _masm);\n@@ -1491,3 +1314,2 @@\n-  \/\/ Assume r10 is n - k\n-  __ leaq(last, Address(haystack, r10, Address::times_1, isU ? -30 : -31));\n-  __ jmpb(temp);\n+  __ leaq(last, Address(haystack, nMinusK, Address::times_1, isU ? -30 : -31));\n+  __ jmpb(L_midLoop);\n@@ -1502,1 +1324,5 @@\n-  __ cmovq(Assembler::aboveEqual, hsPtrRet, last);\n+  \/\/ __ cmovq(Assembler::aboveEqual, hsPtrRet, last);\n+  {\n+    __ jb_b(L_midLoop);\n+    __ movq(hsPtrRet, last);\n+  }\n@@ -1504,1 +1330,1 @@\n-  __ bind(temp);\n+  __ bind(L_midLoop);\n@@ -1508,2 +1334,2 @@\n-  compare_big_haystack_to_needle(sizeKnown, size, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, loop_top, hsPtrRet, hsLength,\n-                                 needleLen, isU, DO_EARLY_BAILOUT, eq_mask, temp2, r10, _masm);\n+  compare_big_haystack_to_needle(sizeKnown, size, loop_top, hsPtrRet, hsLength, needleLen, isU,\n+                                 eq_mask, temp2, temp3, XMM_TMP1, XMM_TMP2, XMM_TMP3, _masm);\n@@ -1519,2 +1345,2 @@\n-static void preload_needle_helper(int size, Register needle, Register needleVal, StrIntrinsicNode::ArgEncoding ae,\n-                                  MacroAssembler *_masm) {\n+static void preload_needle_helper(int size, Register needle, Register needleVal,\n+                                  StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm) {\n@@ -1534,3 +1360,2 @@\n-  bytesAlreadyCompared = isU ? (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE * 2) : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE;\n-  offsetOfFirstByteToCompare\n-      = isU ? ((NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2) : (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1);\n+  bytesAlreadyCompared = isU ? 6 : 3;\n+  offsetOfFirstByteToCompare = isU ? 4 : 2;\n@@ -1548,57 +1373,23 @@\n-  if (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 2) {\n-    switch (bytesLeftToCompare) {\n-    case 1:\n-    case 2:\n-      __ movzwl(needleVal, Address(needle, offsetOfFirstByteToCompare));\n-      break;\n-\n-    case 3:\n-    case 4:\n-      __ movl(needleVal, Address(needle, offsetOfFirstByteToCompare));\n-      break;\n-\n-    case 5:\n-      \/\/ Read one byte before start of needle, then mask it off\n-      __ movq(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n-      __ shrq(needleVal, 0x8);\n-      break;\n-\n-    case 6:\n-      __ movq(needleVal, Address(needle, (offsetOfFirstByteToCompare - 1)));\n-      break;\n-\n-    case 7:\n-    case 8:\n-      __ movq(needleVal, Address(needle, offsetOfFirstByteToCompare));\n-      break;\n-\n-    default:\n-      break;\n-    }\n-  }\n-\n-  if (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE >= 3) {\n-    switch (bytesLeftToCompare) {\n-    case 1:\n-    case 2:\n-      __ movl(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n-      break;\n-\n-    case 3:\n-    case 4:\n-      __ movl(needleVal, Address(needle, offsetOfFirstByteToCompare));\n-      break;\n-\n-    case 5:\n-    case 6:\n-      __ movq(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n-      break;\n-\n-    case 7:\n-    case 8:\n-      __ movq(needleVal, Address(needle, offsetOfFirstByteToCompare));\n-      break;\n-\n-    default:\n-      break;\n-    }\n+  switch (bytesLeftToCompare) {\n+  case 1:\n+  case 2:\n+    __ movl(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n+    break;\n+\n+  case 3:\n+  case 4:\n+    __ movl(needleVal, Address(needle, offsetOfFirstByteToCompare));\n+    break;\n+\n+  case 5:\n+  case 6:\n+    __ movq(needleVal, Address(needle, (offsetOfFirstByteToCompare - 2)));\n+    break;\n+\n+  case 7:\n+  case 8:\n+    __ movq(needleVal, Address(needle, offsetOfFirstByteToCompare));\n+    break;\n+\n+  default:\n+    break;\n@@ -1608,3 +1399,4 @@\n-static void byte_compare_helper(int size, Label &L_noMatch, Label &L_matchFound, Register needle, Register needleVal,\n-                                Register haystack, Register mask, Register foundIndex, Register tmp,\n-                                StrIntrinsicNode::ArgEncoding ae, MacroAssembler *_masm) {\n+static void byte_compare_helper(int size, Label &L_noMatch, Label &L_matchFound, Register needle,\n+                                Register needleVal, Register haystack, Register mask,\n+                                Register foundIndex, Register tmp, StrIntrinsicNode::ArgEncoding ae,\n+                                MacroAssembler *_masm) {\n@@ -1613,1 +1405,1 @@\n-  \/\/ At a minimum, the first and last bytes of needle already compare equal\n+  \/\/ At a minimum, the first, second and last bytes of needle already compare equal\n@@ -1631,10 +1423,2 @@\n-  if (isU) {\n-    if ((size & 1) != 0) {\n-      __ emit_int8(0xcc);\n-      return;\n-    }\n-  }\n-\n-  bytesAlreadyCompared = isU ? NUMBER_OF_NEEDLE_BYTES_TO_COMPARE * 2 : NUMBER_OF_NEEDLE_BYTES_TO_COMPARE;\n-  offsetOfFirstByteToCompare\n-      = isU ? ((NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1) * 2) : (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE - 1);\n+  bytesAlreadyCompared = isU ? 6 : 3;\n+  offsetOfFirstByteToCompare = isU ? 4 : 2;\n@@ -1662,61 +1446,26 @@\n-  if (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE <= 2) {\n-    switch (bytesLeftToCompare) {\n-    case 1:\n-    case 2:\n-      __ cmpw(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare), needleVal);\n-      __ je(L_matchFound);\n-      break;\n-\n-    case 3:\n-    case 4:\n-      __ cmpl(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare), needleVal);\n-      __ je(L_matchFound);\n-      break;\n-\n-    case 5:\n-      \/\/ Read one byte before start of haystack, then mask it off\n-      __ movq(tmp, Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare - 2));\n-      __ shrq(tmp, 0x08);\n-      __ cmpq(needleVal, tmp);\n-      __ je(L_matchFound);\n-      break;\n-\n-    case 6:\n-      __ cmpq(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare - 1), needleVal);\n-      __ je(L_matchFound);\n-      break;\n-\n-    case 7:\n-    case 8:\n-      __ cmpq(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare), needleVal);\n-      __ je(L_matchFound);\n-      break;\n-    }\n-  }\n-\n-  if (NUMBER_OF_NEEDLE_BYTES_TO_COMPARE >= 3) {\n-    switch (bytesLeftToCompare) {\n-    case 1:\n-    case 2:\n-      __ cmpl(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare - 2), needleVal);\n-      __ je(L_matchFound);\n-      break;\n-\n-    case 3:\n-    case 4:\n-      __ cmpl(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare), needleVal);\n-      __ je(L_matchFound);\n-      break;\n-\n-    case 5:\n-    case 6:\n-      __ cmpq(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare - 2), needleVal);\n-      __ je(L_matchFound);\n-      break;\n-\n-    case 7:\n-    case 8:\n-      __ cmpq(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare), needleVal);\n-      __ je(L_matchFound);\n-      break;\n-    }\n+  switch (bytesLeftToCompare) {\n+  case 1:\n+  case 2:\n+    __ cmpl(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare - 2),\n+            needleVal);\n+    __ je(L_matchFound);\n+    break;\n+\n+  case 3:\n+  case 4:\n+    __ cmpl(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare), needleVal);\n+    __ je(L_matchFound);\n+    break;\n+\n+  case 5:\n+  case 6:\n+    __ cmpq(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare - 2),\n+            needleVal);\n+    __ je(L_matchFound);\n+    break;\n+\n+  case 7:\n+  case 8:\n+    __ cmpq(Address(haystack, foundIndex, Address::times_1, offsetOfFirstByteToCompare), needleVal);\n+    __ je(L_matchFound);\n+    break;\n@@ -1731,1 +1480,1 @@\n-\/\/ We can handle the cases where haystack size is <= 32 bytes and needle size <= OPT_NEEDLE_SIZE_MAX\n+\/\/ We can handle the cases where haystack size is <= 32 bytes and needle size <= 6 bytes\n@@ -1733,2 +1482,3 @@\n-\/\/ generated with 32 - (n - k + 1) bits set that ensures matches past the end of the original\n-\/\/ haystack do not get considered during compares.\n+\/\/ generated with (n - k + 1) bits set that ensures matches past the end of the original\n+\/\/ haystack do not get considered during compares. In this equation, n is length of haystack\n+\/\/ and k is length of needle.\n@@ -1740,1 +1490,1 @@\n-\/\/ all needle sizes up to OPT_NEEDLE_SIZE_MAX.\n+\/\/ all needle sizes up to 6 bytes.\n@@ -1743,2 +1493,3 @@\n-static void highly_optimized_short_cases(StrIntrinsicNode::ArgEncoding ae, Register haystack, Register haystack_len,\n-                                         Register needle, Register needle_len, XMMRegister XMM0, XMMRegister XMM1,\n+static void highly_optimized_short_cases(StrIntrinsicNode::ArgEncoding ae, Register haystack,\n+                                         Register haystack_len, Register needle,\n+                                         Register needle_len, XMMRegister XMM0, XMMRegister XMM1,\n@@ -1798,1 +1549,1 @@\n-  for (int size = 1; size <= OPT_NEEDLE_SIZE_MAX; size++) {\n+  for (int size = 1; size <= (isUU ? 3 : 6); size++) {\n@@ -1800,1 +1551,2 @@\n-    int position = isUU ? (size - 1) * 2 : size - 1;\n+    int needle_position = isUU ? (size - 1) * 2 : size - 1;\n+    int haystack_position = isU ? (size - 1) * 2 : size - 1;\n@@ -1802,1 +1554,1 @@\n-      __ vpbroadcastw(XMM0, Address(needle, position), Assembler::AVX_256bit);\n+      __ vpbroadcastw(XMM0, Address(needle, needle_position), Assembler::AVX_256bit);\n@@ -1805,1 +1557,1 @@\n-      __ movzbl(rax, Address(needle, position));\n+      __ movzbl(rax, Address(needle, needle_position));\n@@ -1810,1 +1562,1 @@\n-      __ vpbroadcastb(XMM0, Address(needle, position), Assembler::AVX_256bit);\n+      __ vpbroadcastb(XMM0, Address(needle, needle_position), Assembler::AVX_256bit);\n@@ -1816,1 +1568,1 @@\n-      __ vpcmpeqw(XMM1, XMM0, Address(haystack, position), Assembler::AVX_256bit);\n+      __ vpcmpeqw(XMM1, XMM0, Address(haystack, haystack_position), Assembler::AVX_256bit);\n@@ -1818,1 +1570,1 @@\n-      __ vpcmpeqb(XMM1, XMM0, Address(haystack, position), Assembler::AVX_256bit);\n+      __ vpcmpeqb(XMM1, XMM0, Address(haystack, haystack_position), Assembler::AVX_256bit);\n@@ -1825,1 +1577,1 @@\n-    if (size != OPT_NEEDLE_SIZE_MAX) {\n+    if (size != (isUU ? 3 : 6)) {\n@@ -1836,1 +1588,1 @@\n-    __ shrq(rax, 1);\n+    __ shrl(rax, 1);\n@@ -1857,1 +1609,1 @@\n-                              address *jump_table, address *jump_table_1, MacroAssembler *_masm) {\n+                              address *big_jump_table, address *small_jump_table, MacroAssembler *_masm) {\n@@ -1862,0 +1614,1 @@\n+  const XMMRegister byte_1    = XMM_BYTE_1;\n@@ -1863,1 +1616,1 @@\n-  address large_hs_jmp_table[NUMBER_OF_CASES];  \/\/ Jump table for large haystacks\n+  address big_hs_jmp_table[NUMBER_OF_CASES];  \/\/ Jump table for large haystacks\n@@ -1871,0 +1624,3 @@\n+    \/\/\n+    \/\/ Handle cases that were not handled in highly_optimized_short_cases, which will be\n+    \/\/ haystack size <= 32 bytes with 6 < needle size < NUMBER_OF_CASES bytes.\n@@ -1893,1 +1649,1 @@\n-    \/\/  The haystack is < 32 bytes\n+    \/\/  The haystack is <= 32 bytes\n@@ -1908,1 +1664,1 @@\n-    for (int i = OPT_NEEDLE_SIZE_MAX; i < NUMBER_OF_CASES; i++) {\n+    for (int i = (isUU ? 3 : 6); i < NUMBER_OF_CASES; i++) {\n@@ -1911,1 +1667,1 @@\n-        __ emit_int8(0xcc);\n+        continue;\n@@ -1915,2 +1671,1 @@\n-        broadcast_additional_needles(true, i + 1, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, needle, noreg, rTmp, isUU, isUL,\n-                                     _masm);\n+      broadcast_additional_needles(true, i + 1, needle, noreg, rTmp, ae, _masm);\n@@ -1918,2 +1673,2 @@\n-        compare_haystack_to_needle(true, i + 1, NUMBER_OF_NEEDLE_BYTES_TO_COMPARE, L_error, haystack, isU,\n-                                   DO_EARLY_BAILOUT, eq_mask, noreg, rTmp, _masm);\n+      compare_haystack_to_needle(true, i + 1, L_error, haystack, isU, eq_mask, noreg, rTmp,\n+                                 XMM_TMP1, XMM_TMP2, _masm);\n@@ -1921,2 +1676,2 @@\n-        byte_compare_helper(i + 1, L_error, L_checkRange, needle, needle_val, haystack, eq_mask, set_bit,\n-                            rTmp, ae, _masm);\n+      byte_compare_helper(i + 1, L_error, L_checkRange, needle, needle_val, haystack, eq_mask,\n+                          set_bit, rTmp, ae, _masm);\n@@ -1929,1 +1684,1 @@\n-  \/\/ Large haystack (>=32 bytes) switch\n+  \/\/ Large haystack (> 32 bytes) switch\n@@ -1962,1 +1717,0 @@\n-    const Register rTmp = r13;\n@@ -1964,0 +1718,5 @@\n+    const Register hsLength = rsi;\n+    const Register rTmp1 = rdi;\n+    const Register rTmp2 = r15;\n+    const Register rTmp3 = rdx;\n+    const Register rTmp4 = r13;\n@@ -1966,1 +1725,1 @@\n-      large_hs_jmp_table[i] = __ pc();\n+      big_hs_jmp_table[i] = __ pc();\n@@ -1968,1 +1727,1 @@\n-        __ emit_int8(0xcc);\n+        continue;\n@@ -1972,1 +1731,2 @@\n-        big_case_loop_helper(true, i + 1, L_checkRange, L_loopTop, eq_mask, hs_ptr, needle_len, ae, _masm);\n+        big_case_loop_helper(true, i + 1, L_checkRange, L_loopTop, eq_mask, hs_ptr, needle_len,\n+                             needle, haystack, hsLength, rTmp1, rTmp2, rTmp3, rTmp4, ae, _masm);\n@@ -1974,1 +1734,1 @@\n-                            rTmp, ae, _masm);\n+                            rTmp4, ae, _masm);\n@@ -1985,1 +1745,1 @@\n-  *jump_table = __ pc();\n+  *big_jump_table = __ pc();\n@@ -1988,1 +1748,1 @@\n-    __ emit_address(large_hs_jmp_table[jmp_ndx]);\n+    __ emit_address(big_hs_jmp_table[jmp_ndx]);\n@@ -1991,1 +1751,1 @@\n-  *jump_table_1 = __ pc();\n+  *small_jump_table = __ pc();\n@@ -2004,1 +1764,0 @@\n-#undef XMM_BYTE_2\n@@ -2011,2 +1770,0 @@\n-\n-#endif  \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_string.cpp","additions":922,"deletions":1165,"binary":false,"changes":2087,"status":"modified"},{"patch":"@@ -1286,0 +1286,2 @@\n+    \/\/ The result is index relative to from_index if substring was found, -1 otherwise.\n+    \/\/ Generate code which will fold into cmove.\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/StringBuffer\/ECoreIndexOf.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024 Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/StringBuffer\/IndexOf.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringIndexOfHuge.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}