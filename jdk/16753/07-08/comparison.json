{"files":[{"patch":"@@ -13147,0 +13147,4 @@\n+void Assembler::cdqe() {\n+  emit_int16(REX_W, (unsigned char)0x98);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1097,0 +1097,1 @@\n+  void cdqe();\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4142,211 +4142,0 @@\n-\/\/ Compare char[] or byte[] arrays aligned to 4 bytes or substrings.\n-void C2_MacroAssembler::arrays_equals(bool is_array_equ, Register ary1, Register ary2, \/\/ Move to MacroAssembler_x86.cpp\n-                                      Register limit, Register result, Register chr,\n-                                      XMMRegister vec1, XMMRegister vec2, bool is_char, KRegister mask) {\n-  ShortBranchVerifier sbv(this);\n-  Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_VECTORS, COMPARE_CHAR, COMPARE_BYTE;\n-\n-  int length_offset  = arrayOopDesc::length_offset_in_bytes();\n-  int base_offset    = arrayOopDesc::base_offset_in_bytes(is_char ? T_CHAR : T_BYTE);\n-\n-  if (is_array_equ) {\n-    \/\/ Check the input args\n-    cmpoop(ary1, ary2);\n-    jcc(Assembler::equal, TRUE_LABEL);\n-\n-    \/\/ Need additional checks for arrays_equals.\n-    testptr(ary1, ary1);\n-    jcc(Assembler::zero, FALSE_LABEL);\n-    testptr(ary2, ary2);\n-    jcc(Assembler::zero, FALSE_LABEL);\n-\n-    \/\/ Check the lengths\n-    movl(limit, Address(ary1, length_offset));\n-    cmpl(limit, Address(ary2, length_offset));\n-    jcc(Assembler::notEqual, FALSE_LABEL);\n-  }\n-\n-  \/\/ count == 0\n-  testl(limit, limit);\n-  jcc(Assembler::zero, TRUE_LABEL);\n-\n-  if (is_array_equ) {\n-    \/\/ Load array address\n-    lea(ary1, Address(ary1, base_offset));\n-    lea(ary2, Address(ary2, base_offset));\n-  }\n-\n-  if (is_array_equ && is_char) {\n-    \/\/ arrays_equals when used for char[].\n-    shll(limit, 1);      \/\/ byte count != 0\n-  }\n-  movl(result, limit); \/\/ copy\n-\n-  if (UseAVX >= 2) {\n-    \/\/ With AVX2, use 32-byte vector compare\n-    Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n-\n-    \/\/ Compare 32-byte vectors\n-    andl(result, 0x0000001f);  \/\/   tail count (in bytes)\n-    andl(limit, 0xffffffe0);   \/\/ vector count (in bytes)\n-    jcc(Assembler::zero, COMPARE_TAIL);\n-\n-    lea(ary1, Address(ary1, limit, Address::times_1));\n-    lea(ary2, Address(ary2, limit, Address::times_1));\n-    negptr(limit);\n-\n-#ifdef _LP64\n-    if ((AVX3Threshold == 0) && VM_Version::supports_avx512vlbw()) { \/\/ trying 64 bytes fast loop\n-      Label COMPARE_WIDE_VECTORS_LOOP_AVX2, COMPARE_WIDE_VECTORS_LOOP_AVX3;\n-\n-      cmpl(limit, -64);\n-      jcc(Assembler::greater, COMPARE_WIDE_VECTORS_LOOP_AVX2);\n-\n-      bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); \/\/ the hottest loop\n-\n-      evmovdquq(vec1, Address(ary1, limit, Address::times_1), Assembler::AVX_512bit);\n-      evpcmpeqb(mask, vec1, Address(ary2, limit, Address::times_1), Assembler::AVX_512bit);\n-      kortestql(mask, mask);\n-      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n-      addptr(limit, 64);  \/\/ update since we already compared at this addr\n-      cmpl(limit, -64);\n-      jccb(Assembler::lessEqual, COMPARE_WIDE_VECTORS_LOOP_AVX3);\n-\n-      \/\/ At this point we may still need to compare -limit+result bytes.\n-      \/\/ We could execute the next two instruction and just continue via non-wide path:\n-      \/\/  cmpl(limit, 0);\n-      \/\/  jcc(Assembler::equal, COMPARE_TAIL);  \/\/ true\n-      \/\/ But since we stopped at the points ary{1,2}+limit which are\n-      \/\/ not farther than 64 bytes from the ends of arrays ary{1,2}+result\n-      \/\/ (|limit| <= 32 and result < 32),\n-      \/\/ we may just compare the last 64 bytes.\n-      \/\/\n-      addptr(result, -64);   \/\/ it is safe, bc we just came from this area\n-      evmovdquq(vec1, Address(ary1, result, Address::times_1), Assembler::AVX_512bit);\n-      evpcmpeqb(mask, vec1, Address(ary2, result, Address::times_1), Assembler::AVX_512bit);\n-      kortestql(mask, mask);\n-      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n-\n-      jmp(TRUE_LABEL);\n-\n-      bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);\n-\n-    }\/\/if (VM_Version::supports_avx512vlbw())\n-#endif \/\/_LP64\n-    bind(COMPARE_WIDE_VECTORS);\n-    vmovdqu(vec1, Address(ary1, limit, Address::times_1));\n-    vmovdqu(vec2, Address(ary2, limit, Address::times_1));\n-    vpxor(vec1, vec2);\n-\n-    vptest(vec1, vec1);\n-    jcc(Assembler::notZero, FALSE_LABEL);\n-    addptr(limit, 32);\n-    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n-\n-    testl(result, result);\n-    jcc(Assembler::zero, TRUE_LABEL);\n-\n-    vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));\n-    vmovdqu(vec2, Address(ary2, result, Address::times_1, -32));\n-    vpxor(vec1, vec2);\n-\n-    vptest(vec1, vec1);\n-    jccb(Assembler::notZero, FALSE_LABEL);\n-    jmpb(TRUE_LABEL);\n-\n-    bind(COMPARE_TAIL); \/\/ limit is zero\n-    movl(limit, result);\n-    \/\/ Fallthru to tail compare\n-  } else if (UseSSE42Intrinsics) {\n-    \/\/ With SSE4.2, use double quad vector compare\n-    Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n-\n-    \/\/ Compare 16-byte vectors\n-    andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n-    andl(limit, 0xfffffff0);   \/\/ vector count (in bytes)\n-    jcc(Assembler::zero, COMPARE_TAIL);\n-\n-    lea(ary1, Address(ary1, limit, Address::times_1));\n-    lea(ary2, Address(ary2, limit, Address::times_1));\n-    negptr(limit);\n-\n-    bind(COMPARE_WIDE_VECTORS);\n-    movdqu(vec1, Address(ary1, limit, Address::times_1));\n-    movdqu(vec2, Address(ary2, limit, Address::times_1));\n-    pxor(vec1, vec2);\n-\n-    ptest(vec1, vec1);\n-    jcc(Assembler::notZero, FALSE_LABEL);\n-    addptr(limit, 16);\n-    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n-\n-    testl(result, result);\n-    jcc(Assembler::zero, TRUE_LABEL);\n-\n-    movdqu(vec1, Address(ary1, result, Address::times_1, -16));\n-    movdqu(vec2, Address(ary2, result, Address::times_1, -16));\n-    pxor(vec1, vec2);\n-\n-    ptest(vec1, vec1);\n-    jccb(Assembler::notZero, FALSE_LABEL);\n-    jmpb(TRUE_LABEL);\n-\n-    bind(COMPARE_TAIL); \/\/ limit is zero\n-    movl(limit, result);\n-    \/\/ Fallthru to tail compare\n-  }\n-\n-  \/\/ Compare 4-byte vectors\n-  andl(limit, 0xfffffffc); \/\/ vector count (in bytes)\n-  jccb(Assembler::zero, COMPARE_CHAR);\n-\n-  lea(ary1, Address(ary1, limit, Address::times_1));\n-  lea(ary2, Address(ary2, limit, Address::times_1));\n-  negptr(limit);\n-\n-  bind(COMPARE_VECTORS);\n-  movl(chr, Address(ary1, limit, Address::times_1));\n-  cmpl(chr, Address(ary2, limit, Address::times_1));\n-  jccb(Assembler::notEqual, FALSE_LABEL);\n-  addptr(limit, 4);\n-  jcc(Assembler::notZero, COMPARE_VECTORS);\n-\n-  \/\/ Compare trailing char (final 2 bytes), if any\n-  bind(COMPARE_CHAR);\n-  testl(result, 0x2);   \/\/ tail  char\n-  jccb(Assembler::zero, COMPARE_BYTE);\n-  load_unsigned_short(chr, Address(ary1, 0));\n-  load_unsigned_short(limit, Address(ary2, 0));\n-  cmpl(chr, limit);\n-  jccb(Assembler::notEqual, FALSE_LABEL);\n-\n-  if (is_array_equ && is_char) {\n-    bind(COMPARE_BYTE);\n-  } else {\n-    lea(ary1, Address(ary1, 2));\n-    lea(ary2, Address(ary2, 2));\n-\n-    bind(COMPARE_BYTE);\n-    testl(result, 0x1);   \/\/ tail  byte\n-    jccb(Assembler::zero, TRUE_LABEL);\n-    load_unsigned_byte(chr, Address(ary1, 0));\n-    load_unsigned_byte(limit, Address(ary2, 0));\n-    cmpl(chr, limit);\n-    jccb(Assembler::notEqual, FALSE_LABEL);\n-  }\n-  bind(TRUE_LABEL);\n-  movl(result, 1);   \/\/ return true\n-  jmpb(DONE);\n-\n-  bind(FALSE_LABEL);\n-  xorl(result, result); \/\/ return false\n-\n-  \/\/ That's it\n-  bind(DONE);\n-  if (UseAVX >= 2) {\n-    \/\/ clean upper bits of YMM registers\n-    vpxor(vec1, vec1);\n-    vpxor(vec2, vec2);\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":0,"deletions":211,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -288,4 +288,0 @@\n-  \/\/ Compare char[] or byte[] arrays.\n-  void arrays_equals(bool is_array_equ, Register ary1, Register ary2,\n-                     Register limit, Register result, Register chr,\n-                     XMMRegister vec1, XMMRegister vec2, bool is_char, KRegister mask = knoreg);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -9796,0 +9796,211 @@\n+\/\/ Compare char[] or byte[] arrays aligned to 4 bytes or substrings.\n+void MacroAssembler::arrays_equals(bool is_array_equ, Register ary1, Register ary2,\n+                                   Register limit, Register result, Register chr,\n+                                   XMMRegister vec1, XMMRegister vec2, bool is_char, KRegister mask) {\n+  ShortBranchVerifier sbv(this);\n+  Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_VECTORS, COMPARE_CHAR, COMPARE_BYTE;\n+\n+  int length_offset  = arrayOopDesc::length_offset_in_bytes();\n+  int base_offset    = arrayOopDesc::base_offset_in_bytes(is_char ? T_CHAR : T_BYTE);\n+\n+  if (is_array_equ) {\n+    \/\/ Check the input args\n+    cmpoop(ary1, ary2);\n+    jcc(Assembler::equal, TRUE_LABEL);\n+\n+    \/\/ Need additional checks for arrays_equals.\n+    testptr(ary1, ary1);\n+    jcc(Assembler::zero, FALSE_LABEL);\n+    testptr(ary2, ary2);\n+    jcc(Assembler::zero, FALSE_LABEL);\n+\n+    \/\/ Check the lengths\n+    movl(limit, Address(ary1, length_offset));\n+    cmpl(limit, Address(ary2, length_offset));\n+    jcc(Assembler::notEqual, FALSE_LABEL);\n+  }\n+\n+  \/\/ count == 0\n+  testl(limit, limit);\n+  jcc(Assembler::zero, TRUE_LABEL);\n+\n+  if (is_array_equ) {\n+    \/\/ Load array address\n+    lea(ary1, Address(ary1, base_offset));\n+    lea(ary2, Address(ary2, base_offset));\n+  }\n+\n+  if (is_array_equ && is_char) {\n+    \/\/ arrays_equals when used for char[].\n+    shll(limit, 1);      \/\/ byte count != 0\n+  }\n+  movl(result, limit); \/\/ copy\n+\n+  if (UseAVX >= 2) {\n+    \/\/ With AVX2, use 32-byte vector compare\n+    Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n+\n+    \/\/ Compare 32-byte vectors\n+    andl(result, 0x0000001f);  \/\/   tail count (in bytes)\n+    andl(limit, 0xffffffe0);   \/\/ vector count (in bytes)\n+    jcc(Assembler::zero, COMPARE_TAIL);\n+\n+    lea(ary1, Address(ary1, limit, Address::times_1));\n+    lea(ary2, Address(ary2, limit, Address::times_1));\n+    negptr(limit);\n+\n+#ifdef _LP64\n+    if ((AVX3Threshold == 0) && VM_Version::supports_avx512vlbw()) { \/\/ trying 64 bytes fast loop\n+      Label COMPARE_WIDE_VECTORS_LOOP_AVX2, COMPARE_WIDE_VECTORS_LOOP_AVX3;\n+\n+      cmpl(limit, -64);\n+      jcc(Assembler::greater, COMPARE_WIDE_VECTORS_LOOP_AVX2);\n+\n+      bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); \/\/ the hottest loop\n+\n+      evmovdquq(vec1, Address(ary1, limit, Address::times_1), Assembler::AVX_512bit);\n+      evpcmpeqb(mask, vec1, Address(ary2, limit, Address::times_1), Assembler::AVX_512bit);\n+      kortestql(mask, mask);\n+      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n+      addptr(limit, 64);  \/\/ update since we already compared at this addr\n+      cmpl(limit, -64);\n+      jccb(Assembler::lessEqual, COMPARE_WIDE_VECTORS_LOOP_AVX3);\n+\n+      \/\/ At this point we may still need to compare -limit+result bytes.\n+      \/\/ We could execute the next two instruction and just continue via non-wide path:\n+      \/\/  cmpl(limit, 0);\n+      \/\/  jcc(Assembler::equal, COMPARE_TAIL);  \/\/ true\n+      \/\/ But since we stopped at the points ary{1,2}+limit which are\n+      \/\/ not farther than 64 bytes from the ends of arrays ary{1,2}+result\n+      \/\/ (|limit| <= 32 and result < 32),\n+      \/\/ we may just compare the last 64 bytes.\n+      \/\/\n+      addptr(result, -64);   \/\/ it is safe, bc we just came from this area\n+      evmovdquq(vec1, Address(ary1, result, Address::times_1), Assembler::AVX_512bit);\n+      evpcmpeqb(mask, vec1, Address(ary2, result, Address::times_1), Assembler::AVX_512bit);\n+      kortestql(mask, mask);\n+      jcc(Assembler::aboveEqual, FALSE_LABEL);     \/\/ miscompare\n+\n+      jmp(TRUE_LABEL);\n+\n+      bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);\n+\n+    }\/\/if (VM_Version::supports_avx512vlbw())\n+#endif \/\/_LP64\n+    bind(COMPARE_WIDE_VECTORS);\n+    vmovdqu(vec1, Address(ary1, limit, Address::times_1));\n+    vmovdqu(vec2, Address(ary2, limit, Address::times_1));\n+    vpxor(vec1, vec2);\n+\n+    vptest(vec1, vec1);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    addptr(limit, 32);\n+    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n+\n+    testl(result, result);\n+    jcc(Assembler::zero, TRUE_LABEL);\n+\n+    vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));\n+    vmovdqu(vec2, Address(ary2, result, Address::times_1, -32));\n+    vpxor(vec1, vec2);\n+\n+    vptest(vec1, vec1);\n+    jccb(Assembler::notZero, FALSE_LABEL);\n+    jmpb(TRUE_LABEL);\n+\n+    bind(COMPARE_TAIL); \/\/ limit is zero\n+    movl(limit, result);\n+    \/\/ Fallthru to tail compare\n+  } else if (UseSSE42Intrinsics) {\n+    \/\/ With SSE4.2, use double quad vector compare\n+    Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n+\n+    \/\/ Compare 16-byte vectors\n+    andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n+    andl(limit, 0xfffffff0);   \/\/ vector count (in bytes)\n+    jcc(Assembler::zero, COMPARE_TAIL);\n+\n+    lea(ary1, Address(ary1, limit, Address::times_1));\n+    lea(ary2, Address(ary2, limit, Address::times_1));\n+    negptr(limit);\n+\n+    bind(COMPARE_WIDE_VECTORS);\n+    movdqu(vec1, Address(ary1, limit, Address::times_1));\n+    movdqu(vec2, Address(ary2, limit, Address::times_1));\n+    pxor(vec1, vec2);\n+\n+    ptest(vec1, vec1);\n+    jcc(Assembler::notZero, FALSE_LABEL);\n+    addptr(limit, 16);\n+    jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n+\n+    testl(result, result);\n+    jcc(Assembler::zero, TRUE_LABEL);\n+\n+    movdqu(vec1, Address(ary1, result, Address::times_1, -16));\n+    movdqu(vec2, Address(ary2, result, Address::times_1, -16));\n+    pxor(vec1, vec2);\n+\n+    ptest(vec1, vec1);\n+    jccb(Assembler::notZero, FALSE_LABEL);\n+    jmpb(TRUE_LABEL);\n+\n+    bind(COMPARE_TAIL); \/\/ limit is zero\n+    movl(limit, result);\n+    \/\/ Fallthru to tail compare\n+  }\n+\n+  \/\/ Compare 4-byte vectors\n+  andl(limit, 0xfffffffc); \/\/ vector count (in bytes)\n+  jccb(Assembler::zero, COMPARE_CHAR);\n+\n+  lea(ary1, Address(ary1, limit, Address::times_1));\n+  lea(ary2, Address(ary2, limit, Address::times_1));\n+  negptr(limit);\n+\n+  bind(COMPARE_VECTORS);\n+  movl(chr, Address(ary1, limit, Address::times_1));\n+  cmpl(chr, Address(ary2, limit, Address::times_1));\n+  jccb(Assembler::notEqual, FALSE_LABEL);\n+  addptr(limit, 4);\n+  jcc(Assembler::notZero, COMPARE_VECTORS);\n+\n+  \/\/ Compare trailing char (final 2 bytes), if any\n+  bind(COMPARE_CHAR);\n+  testl(result, 0x2);   \/\/ tail  char\n+  jccb(Assembler::zero, COMPARE_BYTE);\n+  load_unsigned_short(chr, Address(ary1, 0));\n+  load_unsigned_short(limit, Address(ary2, 0));\n+  cmpl(chr, limit);\n+  jccb(Assembler::notEqual, FALSE_LABEL);\n+\n+  if (is_array_equ && is_char) {\n+    bind(COMPARE_BYTE);\n+  } else {\n+    lea(ary1, Address(ary1, 2));\n+    lea(ary2, Address(ary2, 2));\n+\n+    bind(COMPARE_BYTE);\n+    testl(result, 0x1);   \/\/ tail  byte\n+    jccb(Assembler::zero, TRUE_LABEL);\n+    load_unsigned_byte(chr, Address(ary1, 0));\n+    load_unsigned_byte(limit, Address(ary2, 0));\n+    cmpl(chr, limit);\n+    jccb(Assembler::notEqual, FALSE_LABEL);\n+  }\n+  bind(TRUE_LABEL);\n+  movl(result, 1);   \/\/ return true\n+  jmpb(DONE);\n+\n+  bind(FALSE_LABEL);\n+  xorl(result, result); \/\/ return false\n+\n+  \/\/ That's it\n+  bind(DONE);\n+  if (UseAVX >= 2) {\n+    \/\/ clean upper bits of YMM registers\n+    vpxor(vec1, vec1);\n+    vpxor(vec2, vec2);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":211,"deletions":0,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -248,0 +248,4 @@\n+  \/\/ Compare char[] or byte[] arrays.\n+  void arrays_equals(bool is_array_equ, Register ary1, Register ary2,\n+                     Register limit, Register result, Register chr,\n+                     XMMRegister vec1, XMMRegister vec2, bool is_char, KRegister mask = knoreg);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -124,0 +124,1 @@\n+  \/\/ Load ymm0 with copies of first byte of needle and ymm1 with copies of last byte of needle\n@@ -127,0 +128,1 @@\n+  \/\/ Calculate first increment to ensure last read is exactly 32 bytes\n@@ -134,0 +136,1 @@\n+\n@@ -139,0 +142,1 @@\n+\n@@ -140,0 +144,1 @@\n+  \/\/ Compare first byte of needle to haystack\n@@ -141,0 +146,1 @@\n+  \/\/ Compare last byte of needle to haystack at proper position\n@@ -146,0 +152,2 @@\n+  \/\/ At this point, we have at least one \"match\" where first and last bytes\n+  \/\/ of the needle are found the correct distance apart.\n@@ -210,5 +218,4 @@\n-    Label L_0x403852, L_0x403bbd, L_0x403bca, L_0x403844;\n-    Label L_0x403b91, L_0x403bd2, L_0x4033c2, L_0x403838, L_0x403733, L_0x403841;\n-    Label L_0x40320e, L_0x403215, L_0x403265, L_0x40326f, L_0x403233, L_0x40315a;\n-    Label L_0x4032a0, L_0x40386a, L_0x40331c, L_0x403302, L_0x403b38, L_0x403360;\n-    Label L_0x4038bd, L_0x4038b5;\n+    Label L_returnRBP, L_returnRAX, L_checkRangeAndReturn;\n+    Label L_bigDefaultNotFound, L_bigCaseFixupAndReturn, L_small7_8_fixup, L_checkRangeAndReturnRCX;\n+    Label L_returnZero, L_haystackGreaterThan31, L_copyToStackDone, L_bigSwitchTop, L_copyToStack, L_smallSwitchTop;\n+    Label L_bigCaseDefault, L_smallCaseDefault;\n@@ -232,1 +239,2 @@\n-      Label L_tmp1, L_tmp2, L_tmp3, L_tmp4, L_tmp5, L_0x403ba5;\n+      Label L_tmp1, L_tmp2, L_tmp3, L_tmp4, L_tmp5, L_returnRDI, L_tail;\n+\n@@ -244,0 +252,1 @@\n+\n@@ -246,1 +255,1 @@\n-      __ je(L_0x403ba5);\n+      __ je(L_returnRDI);\n@@ -250,0 +259,1 @@\n+\n@@ -252,1 +262,1 @@\n-      __ jae(L_0x403852);\n+      __ jae(L_returnRBP);\n@@ -263,0 +273,1 @@\n+\n@@ -267,1 +278,1 @@\n-      __ jne(L_0x403bbd);\n+      __ jne(L_tail);\n@@ -271,0 +282,1 @@\n+\n@@ -273,1 +285,1 @@\n-      __ jae(L_0x403852);\n+      __ jae(L_returnRBP);\n@@ -275,0 +287,1 @@\n+\n@@ -277,1 +290,1 @@\n-      __ je(L_0x403bca);\n+      __ je(L_returnRAX);\n@@ -281,2 +294,3 @@\n-      __ jmp(L_0x403852);\n-      __ bind(L_0x403ba5);\n+      __ jmp(L_returnRBP);\n+\n+      __ bind(L_returnRDI);\n@@ -284,1 +298,11 @@\n-      __ jmp(L_0x403852);\n+      __ jmp(L_returnRBP);\n+\n+      __ bind(L_tail);\n+      \/\/ Small case tail stuff\n+      __ tzcntl(rcx, r11);\n+      __ addq(rax, rcx);\n+      __ addq(rax, r8);\n+\n+      __ bind(L_returnRAX);\n+      __ movq(rbp, rax);\n+      __ jmp(L_returnRBP);\n@@ -290,2 +314,2 @@\n-      string_indexof_small_loop_helper(2, L_0x403844, L_loopTop);\n-      __ jmp(L_0x403bca);\n+      string_indexof_small_loop_helper(2, L_checkRangeAndReturn, L_loopTop);\n+      __ jmp(L_returnRAX);\n@@ -297,1 +321,1 @@\n-      string_indexof_small_loop_helper(3, L_0x403844, L_loopTop);\n+      string_indexof_small_loop_helper(3, L_checkRangeAndReturn, L_loopTop);\n@@ -301,1 +325,1 @@\n-      __ jmp(L_0x403bca);\n+      __ jmp(L_returnRAX);\n@@ -307,1 +331,1 @@\n-      string_indexof_small_loop_helper(4, L_0x403844, L_loopTop);\n+      string_indexof_small_loop_helper(4, L_checkRangeAndReturn, L_loopTop);\n@@ -311,1 +335,1 @@\n-      __ jmp(L_0x403bca);\n+      __ jmp(L_returnRAX);\n@@ -317,1 +341,1 @@\n-      string_indexof_small_loop_helper(5, L_0x403844, L_loopTop);\n+      string_indexof_small_loop_helper(5, L_checkRangeAndReturn, L_loopTop);\n@@ -321,1 +345,1 @@\n-      __ jmp(L_0x403bca);\n+      __ jmp(L_returnRAX);\n@@ -327,1 +351,1 @@\n-      string_indexof_small_loop_helper(6, L_0x403844, L_loopTop);\n+      string_indexof_small_loop_helper(6, L_checkRangeAndReturn, L_loopTop);\n@@ -331,1 +355,1 @@\n-      __ jmp(L_0x403bca);\n+      __ jmp(L_returnRAX);\n@@ -337,1 +361,1 @@\n-      string_indexof_small_loop_helper(7, L_0x403844, L_loopTop);\n+      string_indexof_small_loop_helper(7, L_checkRangeAndReturn, L_loopTop);\n@@ -344,1 +368,1 @@\n-      __ jmp(L_0x403bca);\n+      __ jmp(L_returnRAX);\n@@ -350,1 +374,1 @@\n-      string_indexof_small_loop_helper(8, L_0x403844, L_loopTop);\n+      string_indexof_small_loop_helper(8, L_checkRangeAndReturn, L_loopTop);\n@@ -357,1 +381,1 @@\n-      __ jmp(L_0x403bca);\n+      __ jmp(L_returnRAX);\n@@ -363,1 +387,1 @@\n-      string_indexof_small_loop_helper(9, L_0x403844, L_loopTop);\n+      string_indexof_small_loop_helper(9, L_checkRangeAndReturn, L_loopTop);\n@@ -367,1 +391,1 @@\n-      __ jmp(L_0x403bca);\n+      __ jmp(L_returnRAX);\n@@ -373,1 +397,1 @@\n-      string_indexof_small_loop_helper(10, L_0x403844, L_loopTop);\n+      string_indexof_small_loop_helper(10, L_checkRangeAndReturn, L_loopTop);\n@@ -377,1 +401,1 @@\n-      __ jmp(L_0x403bca);\n+      __ jmp(L_returnRAX);\n@@ -389,1 +413,1 @@\n-      Label L_0x403b51, L_0x403bad, L_0x403b6e;\n+      Label L_notInFirst32, L_found, L_loopTop;\n@@ -394,1 +418,1 @@\n-      __ je_b(L_0x403b51);\n+      __ je_b(L_notInFirst32);\n@@ -396,1 +420,1 @@\n-      __ jmp(L_0x403844);\n+      __ jmp(L_checkRangeAndReturn);\n@@ -398,1 +422,1 @@\n-      __ bind(L_0x403b51);\n+      __ bind(L_notInFirst32);\n@@ -404,1 +428,1 @@\n-      __ jge(L_0x403844);\n+      __ jge(L_checkRangeAndReturn);\n@@ -407,1 +431,1 @@\n-      __ bind(L_0x403b6e);\n+      __ bind(L_loopTop);\n@@ -411,1 +435,1 @@\n-      __ je_b(L_0x403bad);\n+      __ jne_b(L_found);\n@@ -416,2 +440,2 @@\n-      __ jb(L_0x403b6e);\n-      __ jmp(L_0x403844);\n+      __ jb(L_loopTop);\n+      __ jmp(L_checkRangeAndReturn);\n@@ -419,1 +443,1 @@\n-      __ bind(L_0x403bad);\n+      __ bind(L_found);\n@@ -422,1 +446,1 @@\n-      __ jmp(L_0x403844);\n+      __ jmp(L_checkRangeAndReturn);\n@@ -425,16 +449,0 @@\n-  __ bind(L_0x403b91);\n-  __ tzcntl(rcx, rsi);\n-  __ subq(rax, rbx);\n-  __ addq(rax, rcx);\n-  __ movq(r11, rax);\n-  __ jmp(L_0x403844);\n-\n-  __ bind(L_0x403bbd);\n-   \/\/ Small case tail stuff\n-  __ tzcntl(rcx, r11);\n-  __ addq(rax, rcx);\n-  __ addq(rax, r8);\n-  __ bind(L_0x403bca);\n-  __ movq(rbp, rax);\n-  __ jmp(L_0x403852);\n-\n@@ -442,1 +450,1 @@\n-  __ bind(L_0x403bd2);\n+  __ bind(L_bigDefaultNotFound);\n@@ -445,1 +453,1 @@\n-  __ jmp(L_0x403844);\n+  __ jmp(L_checkRangeAndReturn);\n@@ -452,0 +460,2 @@\n+      Label L_found, L_loopTop;\n+\n@@ -454,1 +464,1 @@\n-      __ jle(L_0x403844);\n+      __ jle(L_checkRangeAndReturn);\n@@ -465,1 +475,1 @@\n-      __ bind(L_0x4033c2);\n+      __ bind(L_loopTop);\n@@ -471,1 +481,1 @@\n-      __ je_b(L_0x403b91);\n+      __ jne_b(L_found);\n@@ -474,1 +484,1 @@\n-      __ jae(L_0x403844);\n+      __ jae(L_checkRangeAndReturn);\n@@ -480,1 +490,1 @@\n-      __ jne_b(L_0x403b91);\n+      __ jne_b(L_found);\n@@ -484,2 +494,9 @@\n-      __ jb(L_0x4033c2);\n-      __ jmp(L_0x403844);\n+      __ jb(L_loopTop);\n+      __ jmp(L_checkRangeAndReturn);\n+\n+      __ bind(L_found);\n+      __ tzcntl(rcx, rsi);\n+      __ subq(rax, rbx);\n+      __ addq(rax, rcx);\n+      __ movq(r11, rax);\n+      __ jmp(L_checkRangeAndReturn);\n@@ -495,1 +512,1 @@\n-      string_indexof_big_loop_helper(3, L_0x403844, L_loopTop);\n+      string_indexof_big_loop_helper(3, L_checkRangeAndReturn, L_loopTop);\n@@ -501,1 +518,1 @@\n-      __ je(L_0x403838);\n+      __ je(L_bigCaseFixupAndReturn);\n@@ -514,1 +531,1 @@\n-      string_indexof_big_loop_helper(4, L_0x403844, L_loopTop);\n+      string_indexof_big_loop_helper(4, L_checkRangeAndReturn, L_loopTop);\n@@ -520,1 +537,1 @@\n-      __ je(L_0x403838);\n+      __ je(L_bigCaseFixupAndReturn);\n@@ -533,1 +550,1 @@\n-      string_indexof_big_loop_helper(5, L_0x403844, L_loopTop);\n+      string_indexof_big_loop_helper(5, L_checkRangeAndReturn, L_loopTop);\n@@ -539,1 +556,1 @@\n-      __ je(L_0x403838);\n+      __ je(L_bigCaseFixupAndReturn);\n@@ -552,1 +569,1 @@\n-      string_indexof_big_loop_helper(6, L_0x403844, L_loopTop);\n+      string_indexof_big_loop_helper(6, L_checkRangeAndReturn, L_loopTop);\n@@ -558,1 +575,1 @@\n-      __ je(L_0x403838);\n+      __ je(L_bigCaseFixupAndReturn);\n@@ -571,1 +588,1 @@\n-      string_indexof_big_loop_helper(7, L_0x403844, L_loopTop);\n+      string_indexof_big_loop_helper(7, L_checkRangeAndReturn, L_loopTop);\n@@ -584,1 +601,1 @@\n-      __ jmp(L_0x403733);\n+      __ jmp(L_small7_8_fixup);\n@@ -594,1 +611,1 @@\n-      string_indexof_big_loop_helper(8, L_0x403844, L_loopTop);\n+      string_indexof_big_loop_helper(8, L_checkRangeAndReturn, L_loopTop);\n@@ -607,1 +624,1 @@\n-      __ bind(L_0x403733);\n+      __ bind(L_small7_8_fixup);\n@@ -610,1 +627,1 @@\n-      __ jmp(L_0x403841);\n+      __ jmp(L_checkRangeAndReturnRCX);\n@@ -620,1 +637,1 @@\n-      string_indexof_big_loop_helper(9, L_0x403844, L_loopTop);\n+      string_indexof_big_loop_helper(9, L_checkRangeAndReturn, L_loopTop);\n@@ -626,1 +643,1 @@\n-      __ je(L_0x403838);\n+      __ je(L_bigCaseFixupAndReturn);\n@@ -639,1 +656,1 @@\n-      string_indexof_big_loop_helper(10, L_0x403844, L_loopTop);\n+      string_indexof_big_loop_helper(10, L_checkRangeAndReturn, L_loopTop);\n@@ -645,1 +662,1 @@\n-      __ je(L_0x403838);\n+      __ je(L_bigCaseFixupAndReturn);\n@@ -676,63 +693,69 @@\n-    __ bind(L_0x4032a0);\n-    __ movq(r11, -1);\n-    __ testq(rsi, rsi);\n-    __ jle(L_0x403844);\n-    __ movq(Address(rsp, 0x20), r10);\n-    __ leaq(rax, Address(rbx, rsi, Address::times_1));\n-    __ movq(Address(rsp, 0x10), rax);\n-    __ vpbroadcastb(xmm0, Address(r14, 0), Assembler::AVX_256bit);\n-    __ vmovdqu(Address(rsp, 0x50), xmm0);\n-    __ vpbroadcastb(xmm0, Address(r12, r14, Address::times_1, -1), Assembler::AVX_256bit);\n-    __ vmovdqu(Address(rsp, 0x30), xmm0);\n-    __ movl(rax, rsi);\n-    __ subl(rax, r12);\n-    __ incl(rax);\n-    __ andl(rax, 0x1f);\n-    __ cmpq(rsi, 0x21);\n-    __ movl(rcx, 0x20);\n-    __ cmovl(Assembler::aboveEqual, rcx, rax);\n-    __ incq(r14);\n-    __ movq(rax, rbx);\n-    __ movq(rbx, r14);\n-    __ leaq(r15, Address(r12, -0x2));\n-    __ movq(Address(rsp, 0x28), rax);\n-    __ jmpb(L_0x40331c);\n-    __ bind(L_0x403302);\n-    __ movq(rax, Address(rsp, 0x8));\n-    __ addq(rax, Address(rsp, 0x18));\n-    __ movl(rcx, 0x20);\n-    __ cmpq(rax, Address(rsp, 0x10));\n-    __ jae(L_0x403bd2);\n-\n-    __ bind(L_0x40331c);\n-    __ movq(Address(rsp, 0x18), rcx);\n-    __ vmovdqu(xmm0, Address(rsp, 0x50));\n-    __ vpcmpeqb(xmm0, xmm0, Address(rax, 0), Assembler::AVX_256bit);\n-    __ vmovdqu(xmm1, Address(rsp, 0x30));\n-    __ movq(Address(rsp, 0x8), rax);\n-    __ vpcmpeqb(xmm1, xmm1, Address(rax, r12, Address::times_1, -1), Assembler::AVX_256bit);\n-    __ vpand(xmm0, xmm1, xmm0, Assembler::AVX_256bit);\n-    __ vpmovmskb(r13, xmm0, Assembler::AVX_256bit);\n-    __ testl(r13, r13);\n-    __ je(L_0x403302);\n-    __ movq(rax, Address(rsp, 0x8));\n-    __ leaq(r14, Address(rax, 0x1));\n-    __ align(8);\n-    __ bind(L_0x403360);\n-    __ tzcntl(rbp, r13);\n-    __ leaq(rdi, Address(r14, rbp, Address::times_1));\n-    ((C2_MacroAssembler*) _masm)-> arrays_equals(true, rdi, rbx, r15, rax, rdx, xmm0, xmm1,\n-                     false \/* char *\/, knoreg);\n-    __ testl(rax, rax);\n-    __ je_b(L_0x403b38);\n-    __ blsrl(r13, r13);\n-    __ jne(L_0x403360);\n-    __ jmp(L_0x403302);\n-\n-    __ bind(L_0x403b38);\n-    __ movl(rax, rbp);\n-    __ movq(r11, Address(rsp, 0x8));\n-    __ subq(r11, Address(rsp, 0x28));\n-    __ addq(r11, rax);\n-    __ movq(r10, Address(rsp, 0x20));\n-    __ jmp(L_0x403844);\n+    {\n+      Label L_loopTop, L_loopMid, L_innerLoop, L_found;\n+\n+      __ bind(L_bigCaseDefault);\n+      __ movq(r11, -1);\n+      __ testq(rsi, rsi);\n+      __ jle(L_checkRangeAndReturn);\n+      __ movq(Address(rsp, 0x20), r10);\n+      __ leaq(rax, Address(rbx, rsi, Address::times_1));\n+      __ movq(Address(rsp, 0x10), rax);\n+      __ vpbroadcastb(xmm0, Address(r14, 0), Assembler::AVX_256bit);\n+      __ vmovdqu(Address(rsp, 0x50), xmm0);\n+      __ vpbroadcastb(xmm0, Address(r12, r14, Address::times_1, -1), Assembler::AVX_256bit);\n+      __ vmovdqu(Address(rsp, 0x30), xmm0);\n+      __ movl(rax, rsi);\n+      __ subl(rax, r12);\n+      __ incl(rax);\n+      __ andl(rax, 0x1f);\n+      __ cmpq(rsi, 0x21);\n+      __ movl(rcx, 0x20);\n+      __ cmovl(Assembler::aboveEqual, rcx, rax);\n+      __ incq(r14);\n+      __ movq(rax, rbx);\n+      __ movq(rbx, r14);\n+      __ leaq(r15, Address(r12, -0x2));\n+      __ movq(Address(rsp, 0x28), rax);\n+      __ jmpb(L_loopMid);\n+\n+      __ bind(L_loopTop);\n+      __ movq(rax, Address(rsp, 0x8));\n+      __ addq(rax, Address(rsp, 0x18));\n+      __ movl(rcx, 0x20);\n+      __ cmpq(rax, Address(rsp, 0x10));\n+      __ jae(L_bigDefaultNotFound);\n+\n+      __ bind(L_loopMid);\n+      __ movq(Address(rsp, 0x18), rcx);\n+      __ vmovdqu(xmm0, Address(rsp, 0x50));\n+      __ vpcmpeqb(xmm0, xmm0, Address(rax, 0), Assembler::AVX_256bit);\n+      __ vmovdqu(xmm1, Address(rsp, 0x30));\n+      __ movq(Address(rsp, 0x8), rax);\n+      __ vpcmpeqb(xmm1, xmm1, Address(rax, r12, Address::times_1, -1), Assembler::AVX_256bit);\n+      __ vpand(xmm0, xmm1, xmm0, Assembler::AVX_256bit);\n+      __ vpmovmskb(r13, xmm0, Assembler::AVX_256bit);\n+      __ testl(r13, r13);\n+      __ je(L_loopTop);\n+      __ movq(rax, Address(rsp, 0x8));\n+      __ leaq(r14, Address(rax, 0x1));\n+\n+      __ align(8);\n+      __ bind(L_innerLoop);\n+      __ tzcntl(rbp, r13);\n+      __ leaq(rdi, Address(r14, rbp, Address::times_1));\n+      __ arrays_equals(true, rdi, rbx, r15, rax, rdx, xmm0, xmm1,\n+                      false \/* char *\/, knoreg);\n+      __ testl(rax, rax);\n+      __ jne_b(L_found);\n+      __ blsrl(r13, r13);\n+      __ jne(L_innerLoop);\n+      __ jmp(L_loopTop);\n+\n+      __ bind(L_found);\n+      __ movl(rax, rbp);\n+      __ movq(r11, Address(rsp, 0x8));\n+      __ subq(r11, Address(rsp, 0x28));\n+      __ addq(r11, rax);\n+      __ movq(r10, Address(rsp, 0x20));\n+      __ jmp(L_checkRangeAndReturn);\n+    }\n@@ -746,42 +769,47 @@\n-    __ bind(L_0x40386a);\n-    __ incq(rsi);\n-    __ subq(rsi, r12);\n-    __ je(L_0x403852);\n-    __ movzbl(rcx, Address(r14, 0));\n-    __ leaq(rax, Address(r14, 0x1));\n-    __ movq(Address(rsp, 0x8), rax);\n-    __ cmpq(rsi, 0x2);\n-    __ movl(rcx, 0x1);\n-    __ cmovl(Assembler::aboveEqual, rdx, rsi);\n-    __ leaq(rax, Address(r12, -0x2));\n-    __ movq(Address(rsp, 0x50), rax);\n-    __ leaq(rsi, Address(rbx, r12, Address::times_1));\n-    __ decq(rsi);\n-    __ leaq(rax, Address(rbx, 0x1));\n-    __ movq(Address(rsp, 0x10), rax);\n-    __ xorl(r15, r15);\n-    __ movq(Address(rsp, 0x18), rdx);\n-    __ movq(Address(rsp, 0x30), rsi);\n-    __ jmpb(L_0x4038bd);\n-    __ bind(L_0x4038b5);\n-    __ incq(r15);\n-    __ cmpq(rdx, r15);\n-    __ je(L_0x403852);\n-\n-    __ bind(L_0x4038bd);\n-    __ cmpb(Address(rbx, r15, Address::times_1), rcx);\n-    __ jne(L_0x4038b5);\n-    __ movzbl(rax, Address(rsi, r15, Address::times_1));\n-    __ cmpb(Address(r14, r13, Address::times_1), rax);\n-    __ jne(L_0x4038b5);\n-\n-    __ movq(rax, Address(rsp, 0x10));\n-    __ leaq(rdi, Address(rax, r15, Address::times_1));\n-    __ movq(rsi, Address(rsp, 0x8));\n-    __ movq(rdx, Address(rsp, 0x50));\n-    ((C2_MacroAssembler*) _masm)-> arrays_equals(true, rdi, rsi, rdx, rax, r12, xmm0, xmm1,\n-                     false \/* char *\/, knoreg);\n-    __ testl(rax, rax);\n-    __ jne(L_0x4038b5);\n-    __ movq(rbp, r15);\n-    __ jmp(L_0x403852);\n+    {\n+      Label L_loopTop, L_loopMid;\n+\n+      __ bind(L_smallCaseDefault);\n+      __ incq(rsi);\n+      __ subq(rsi, r12);\n+      __ je(L_returnRBP);\n+      __ movzbl(rcx, Address(r14, 0));\n+      __ leaq(rax, Address(r14, 0x1));\n+      __ movq(Address(rsp, 0x8), rax);\n+      __ cmpq(rsi, 0x2);\n+      __ movl(rcx, 0x1);\n+      __ cmovl(Assembler::aboveEqual, rdx, rsi);\n+      __ leaq(rax, Address(r12, -0x2));\n+      __ movq(Address(rsp, 0x50), rax);\n+      __ leaq(rsi, Address(rbx, r12, Address::times_1));\n+      __ decq(rsi);\n+      __ leaq(rax, Address(rbx, 0x1));\n+      __ movq(Address(rsp, 0x10), rax);\n+      __ xorl(r15, r15);\n+      __ movq(Address(rsp, 0x18), rdx);\n+      __ movq(Address(rsp, 0x30), rsi);\n+      __ jmpb(L_loopMid);\n+\n+      __ bind(L_loopTop);\n+      __ incq(r15);\n+      __ cmpq(rdx, r15);\n+      __ je(L_returnRBP);\n+\n+      __ bind(L_loopMid);\n+      __ cmpb(Address(rbx, r15, Address::times_1), rcx);\n+      __ jne(L_loopTop);\n+      __ movzbl(rax, Address(rsi, r15, Address::times_1));\n+      __ cmpb(Address(r14, r13, Address::times_1), rax);\n+      __ jne(L_loopTop);\n+\n+      __ movq(rax, Address(rsp, 0x10));\n+      __ leaq(rdi, Address(rax, r15, Address::times_1));\n+      __ movq(rsi, Address(rsp, 0x8));\n+      __ movq(rdx, Address(rsp, 0x50));\n+      __ arrays_equals(true, rdi, rsi, rdx, rax, r12, xmm0, xmm1,\n+                      false \/* char *\/, knoreg);\n+      __ testl(rax, rax);\n+      __ je_b(L_loopTop);\n+      __ movq(rbp, r15);\n+      __ jmp(L_returnRBP);\n+    }\n@@ -793,1 +821,1 @@\n-    __ bind(L_0x403838);\n+    __ bind(L_bigCaseFixupAndReturn);\n@@ -798,1 +826,1 @@\n-    __ bind(L_0x403841);\n+    __ bind(L_checkRangeAndReturnRCX);\n@@ -801,1 +829,1 @@\n-    __ bind(L_0x403844);\n+    __ bind(L_checkRangeAndReturn);\n@@ -806,1 +834,1 @@\n-    __ bind(L_0x403852);\n+    __ bind(L_returnRBP);\n@@ -859,1 +887,1 @@\n-    __ jb(L_0x403852);\n+    __ jb(L_returnRBP);\n@@ -862,1 +890,1 @@\n-    __ je_b(L_0x40320e);\n+    __ je_b(L_returnZero);\n@@ -866,1 +894,1 @@\n-    __ jae_b(L_0x403215);\n+    __ jae_b(L_haystackGreaterThan31);\n@@ -868,3 +896,5 @@\n-    __ cmpq(r10, 0xb);\n-    __ jae_b(L_0x403233);\n-    __ bind(L_0x40315a);\n+    \/\/ __ cmpq(r10, 0xb);      \/\/ ASGASG\n+    \/\/ __ jae_b(L_copyToStack);\n+    __ jmpb(L_copyToStack);\n+\n+    __ bind(L_smallSwitchTop);\n@@ -873,1 +903,1 @@\n-    __ ja(L_0x40386a);\n+    __ ja(L_smallCaseDefault);\n@@ -877,1 +907,1 @@\n-    __ bind(L_0x40320e);\n+    __ bind(L_returnZero);\n@@ -879,1 +909,1 @@\n-    __ jmp(L_0x403852);\n+    __ jmp(L_returnRBP);\n@@ -881,1 +911,1 @@\n-    __ bind(L_0x403215);\n+    __ bind(L_haystackGreaterThan31);\n@@ -884,1 +914,1 @@\n-    __ jle(L_0x40326f);\n+    __ jle(L_bigSwitchTop);\n@@ -886,1 +916,1 @@\n-    __ ja(L_0x40315a);\n+    __ ja(L_smallSwitchTop);\n@@ -888,1 +918,1 @@\n-    \/\/ __ jbe(L_0x40315a);\n+    \/\/ __ jbe(L_smallSwitchTop);\n@@ -890,1 +920,1 @@\n-    __ bind(L_0x403233);\n+    __ bind(L_copyToStack);\n@@ -901,1 +931,1 @@\n-    __ je_b(L_0x403265);\n+    __ je_b(L_copyToStackDone);\n@@ -905,2 +935,3 @@\n-    __ bind(L_0x403265);\n-    __ emit_int16(0x48, 0x98);\n+\n+    __ bind(L_copyToStackDone);\n+    __ cdqe();\n@@ -909,1 +940,1 @@\n-    __ bind(L_0x40326f);\n+    __ bind(L_bigSwitchTop);\n@@ -912,1 +943,1 @@\n-    __ ja(L_0x4032a0);\n+    __ ja(L_bigCaseDefault);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_string.cpp","additions":244,"deletions":213,"binary":false,"changes":457,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  static Random generator = new Random(1999);\n+  static Random generator = new Random();\n@@ -44,1 +44,0 @@\n-    generator.setSeed(1999);\n@@ -46,1 +45,0 @@\n-    generator.setSeed(1999);\n@@ -48,1 +46,0 @@\n-    generator.setSeed(1999);\n@@ -50,1 +47,0 @@\n-    generator.setSeed(1999);\n@@ -103,1 +99,0 @@\n-    StringBuffer sourceBuffer;\n@@ -105,3 +100,0 @@\n-    String targetStringBeginning;\n-    String targetStringMiddle;\n-    String targetStringEnd;\n@@ -109,1 +101,1 @@\n-    int maxNeedleLen = hsLen \/ 2;\n+    int maxNeedleLen = hsLen;\/\/ \/ 2;\n@@ -112,1 +104,1 @@\n-    int hsBegin, hsEnd, nBegin, nEnd;\n+    int hsBegin, nBegin;\n@@ -117,1 +109,0 @@\n-        sourceBuffer = new StringBuffer(sourceString);\n@@ -133,0 +124,1 @@\n+                failCount++;\n@@ -211,1 +203,1 @@\n-  boolean make_new = true;\n+    boolean make_new = true;\n@@ -213,5 +205,4 @@\n-      String fragment = null;\n-      StringBuffer testBuffer = null;\n-      String testString = null;\n-      int testIndex = 0;\n-    generator.setSeed(1999);\n+    String fragment = null;\n+    StringBuffer testBuffer = null;\n+    String testString = null;\n+    int testIndex = 0;\n@@ -220,18 +211,18 @@\n-    if (make_new) {\n-        testString = generateTestString(1, 100);\n-        int len = testString.length();\n-\n-        testBuffer = new StringBuffer(len);\n-        testBuffer.append(testString);\n-        if (!testString.equals(testBuffer.toString()))\n-        throw new RuntimeException(\"Initial equality failure\");\n-\n-        int x1 = 0;\n-        int x2 = 1000;\n-        while (x2 > testString.length()) {\n-        x1 = generator.nextInt(len);\n-        x2 = generator.nextInt(100);\n-        x2 = x1 + x2;\n-        }\n-        fragment = testString.substring(x1, x2);\n-    }\n+      if (make_new) {\n+          testString = generateTestString(1, 100);\n+          int len = testString.length();\n+\n+          testBuffer = new StringBuffer(len);\n+          testBuffer.append(testString);\n+          if (!testString.equals(testBuffer.toString()))\n+          throw new RuntimeException(\"Initial equality failure\");\n+\n+          int x1 = 0;\n+          int x2 = 1000;\n+          while (x2 > testString.length()) {\n+          x1 = generator.nextInt(len);\n+          x2 = generator.nextInt(100);\n+          x2 = x1 + x2;\n+          }\n+          fragment = testString.substring(x1, x2);\n+      }\n@@ -262,2 +253,1 @@\n-    if (make_new)\n-        testIndex = getRandomIndex(-100, 100);\n+      if (make_new) testIndex = getRandomIndex(-100, 100);\n@@ -275,1 +265,1 @@\n-    make_new = false;\n+        make_new = false;\n","filename":"test\/jdk\/java\/lang\/StringBuffer\/IndexOf.java","additions":29,"deletions":39,"binary":false,"changes":68,"status":"modified"}]}