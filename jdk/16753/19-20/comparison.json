{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#ifdef COMPILER2\n@@ -32,0 +33,1 @@\n+#endif\n@@ -576,0 +578,1 @@\n+#ifdef COMPILER2\n@@ -578,0 +581,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-#include \"macroAssembler_x86.hpp\"\n-#include \"opto\/c2_MacroAssembler.hpp\"\n@@ -29,0 +27,2 @@\n+#ifdef COMPILER2\n+#include \"opto\/c2_MacroAssembler.hpp\"\n@@ -136,0 +136,4 @@\n+static void broadcast_first_and_last_needle(Register needle, Register needle_len, Register rTmp,\n+                                            StrIntrinsicNode::ArgEncoding ae,\n+                                            MacroAssembler *_masm);\n+\n@@ -138,3 +142,4 @@\n-                                           bool isU, Register eq_mask, Register rTmp,\n-                                           Register rTmp2, XMMRegister rxTmp1, XMMRegister rxTmp2,\n-                                           XMMRegister rxTmp3, MacroAssembler *_masm);\n+                                           Register eq_mask, Register rTmp, Register rTmp2,\n+                                           XMMRegister rxTmp1, XMMRegister rxTmp2,\n+                                           XMMRegister rxTmp3, StrIntrinsicNode::ArgEncoding ae,\n+                                           MacroAssembler *_masm);\n@@ -196,0 +201,7 @@\n+  \/\/ Keep track of isUL since we need to generate UU code in the main body\n+  \/\/ for the case where we expand the needle from bytes to words on the stack.\n+  \/\/ This is done at L_wcharBegin.  The algorithm used is:\n+  \/\/  If the encoding is UL and the needle size is <= MAX_NEEDLE_LEN_TO_EXPAND,\n+  \/\/  allocate space on the stack and expand the Latin-1 encoded needle.  Then\n+  \/\/  effectively \"recurse\" into the mainline using UU encoding (since both the\n+  \/\/  haystack and needle are now UTF-16 encoded).\n@@ -219,1 +231,2 @@\n-  \/\/  For UL where the needle size is > MAX_NEEDLE_LEN_TO_EXPAND, we default to a\n+  \/\/  For UL where the needle size is > MAX_NEEDLE_LEN_TO_EXPAND and the haystack size minus\n+  \/\/  the needle size is less than 32 bytes, we default to a\n@@ -306,0 +319,24 @@\n+  \/\/\n+  \/\/ Main processing proceeds as follows:\n+  \/\/  Save state and setup stack, etc.\n+  \/\/  If UL, jump to code to handle special-case UL situations (see L_wcharBegin below)\n+  \/\/  Broadcast the first and last needle elements to XMM_BYTE_0 and XMM_BYTE_K, respectively\n+  \/\/  If the length in bytes of the haystack is > 32, dispatch to the big switch handling code\n+  \/\/  If the haystack length in bytes is <= 32:\n+  \/\/    Copy the haystack to the stack.  This is done to prevent possible page faults and\n+  \/\/      allows for reading full 32-byte chunks of the haystack.\n+  \/\/    Dispatch to the small switch handling code\n+  \/\/\n+  \/\/ Here, \"big switch\" and \"small switch\" refers to the haystack size: > 32 bytes for big\n+  \/\/ and <= 32 bytes for small.  The switches implement optimized code for handling 1 to\n+  \/\/ NUMBER_OF_CASES (currently 10) needle sizes for both big and small.  There are special\n+  \/\/ routines for handling needle sizes > NUMBER_OF_CASES (L_{big,small}CaseDefault).  These\n+  \/\/ cases use C@'s arrays_equals() to compare the needle to the haystack.  The small cases\n+  \/\/ use specialized code for comparing the needle.\n+  \/\/\n+  \/\/ The algorithm currently does vector comparisons for the first, last, and second bytes\n+  \/\/ of the needle and, where each of these needle elements matches the correct position\n+  \/\/ within the haystack, the \"in-between\" bytes are compared using the most efficient\n+  \/\/ instructions possible for short needles, or C2's arrays_equals for longer needles.\n+\n+  __ align(CodeEntryAlignment);\n@@ -340,1 +377,1 @@\n-    \/\/ Branch out if doing wide chars\n+    \/\/ Branch out if doing UL\n@@ -345,0 +382,1 @@\n+    \/\/ UU passes lengths in terms of chars - convert to bytes\n@@ -349,1 +387,1 @@\n-  \/\/ wide char processing comes here after expanding needle\n+  \/\/ UL processing comes here after expanding needle\n@@ -351,0 +389,2 @@\n+  \/\/ nMinusK (haystack length in bytes minus needle length in bytes) is used several\n+  \/\/ places to determine whether a compare will read past the end of the haystack.\n@@ -354,0 +394,1 @@\n+  \/\/ Set up expected registers\n@@ -358,22 +399,2 @@\n-  {\n-    Label L_short;\n-\n-    \/\/ Always need needle broadcast to ymm registers\n-    \/\/ Broadcast the beginning of needle into a vector register.\n-    if (isU) {\n-      __ vpbroadcastw(XMM_BYTE_0, Address(needle, 0), Assembler::AVX_256bit);\n-    } else {\n-      __ vpbroadcastb(XMM_BYTE_0, Address(needle, 0), Assembler::AVX_256bit);\n-    }\n-\n-    \/\/ Broadcast the end of needle into a vector register.\n-    \/\/ For a single-element needle this is redundant but does no harm and\n-    \/\/ reduces code size as opposed to broadcasting only if used.\n-    if (isU) {\n-      __ vpbroadcastw(XMM_BYTE_K, Address(needle, needle_len, Address::times_1, -2), Assembler::AVX_256bit);\n-    } else {\n-      __ vpbroadcastb(XMM_BYTE_K, Address(needle, needle_len, Address::times_1, -1), Assembler::AVX_256bit);\n-    }\n-\n-    __ bind(L_short);\n-  }\n+  \/\/ Always need needle broadcast to ymm registers (XMM_BYTE_0 and XMM_BYTE_K)\n+  broadcast_first_and_last_needle(needle, needle_len, rax, ae, _masm);\n@@ -400,0 +421,1 @@\n+    \/\/ Only a single vector load\/store of either 16 or 32 bytes\n@@ -413,0 +435,1 @@\n+    \/\/ Point the haystack at the correct location of the first byte of the \"real\" haystack on the stack\n@@ -419,0 +442,2 @@\n+  \/\/ Note that needle sizes of 1-6 have been handled in highly_optimized_short_cases,\n+  \/\/ so the dispatch only has valid entries for 7-10.\n@@ -426,0 +451,1 @@\n+  \/\/ For large haystacks, the jump table is fully populated (1-10)\n@@ -433,1 +459,57 @@\n-  __ align(CodeEntryAlignment);\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/ Fixup and return routines\n+\n+  \/\/ Return not found\n+  __ bind(L_returnError);\n+  __ movq(rax, -1);\n+  __ jmpb(L_return);\n+\n+\/\/ Used to check and return value in rbp - usually error\n+  __ bind(L_returnRBP);\n+  __ movq(rax, rbp);\n+\n+  \/\/ At this point, rcx has &haystack where match found, rbx has &haystack,\n+  \/\/ and r8 has the index where a match was found\n+  __ bind(L_bigCaseFixupAndReturn);\n+  __ subq(rcx, rbx);\n+  __ addq(rcx, r8);\n+\n+  __ movq(r11, rcx);\n+\n+  \/\/ Ensure that the index where a match was found is within valid range.\n+  \/\/ r11 contains -1 or the index where match was found.\n+  __ bind(L_checkRangeAndReturn);\n+  __ movq(rax, -1);\n+  __ cmpq(r11, nMinusK);\n+  __ ja_b(L_return);\n+  __ movq(rax, r11);\n+\n+  \/\/ Restore stack, vzeroupper and return\n+  __ bind(L_return);\n+  __ addptr(rsp, STACK_SPACE);\n+  __ pop(rbp);\n+#ifdef _WIN64\n+  __ pop(r9);\n+  __ pop(r8);\n+  __ pop(rcx);\n+  __ pop(rdi);\n+  __ pop(rsi);\n+#endif\n+  __ movdq(r12, save_r12);\n+  __ movdq(r13, save_r13);\n+  __ movdq(r14, save_r14);\n+  __ movdq(r15, save_r15);\n+  __ movdq(rbx, save_rbx);\n+\n+  \/\/ Need to return elements for UTF-16 encodings\n+  if (isU) {\n+    \/\/ Return value for UTF-16 is elements, not bytes\n+    \/\/ sar is used to preserve -1\n+    __ sarq(rax, 1);\n+  }\n+  __ vzeroupper();\n+\n+  __ leave();  \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(0);\n@@ -440,0 +522,3 @@\n+  \/\/\n+  \/\/ Handle needle sizes > 10 bytes.  Uses C2's arrays_equals to compare the contents\n+  \/\/ of the needle to the haystack.\n@@ -456,0 +541,1 @@\n+\/\/ #define used for registers that are re-used in the code\n@@ -466,1 +552,1 @@\n-    \/\/ Big case default:\n+    \/\/ Big case default:  registers on entry\n@@ -480,0 +566,3 @@\n+    \/\/\n+    \/\/ Set up in big_case_loop_helper\n+    \/\/  XMM_BYTE_1 - second element of needle broadcast\n@@ -496,0 +585,1 @@\n+\/\/ Re-use of r15 and rdx\n@@ -501,0 +591,6 @@\n+    \/\/ Note that we're comparing the full needle here even though in some paths\n+    \/\/ the 1st, 2nd, and last bytes are already known to be equal.  This is necessary\n+    \/\/ due to the handling of cases where nMinusK is < 32\n+\n+    \/\/ Need a lot of registers here to preserve state across arrays_equals call\n+\n@@ -502,1 +598,1 @@\n-    __ leaq(haystackStart, Address(hsPtrRet, index, Address::times_1, isU ? 4 : 2));\n+    __ leaq(haystackStart, Address(hsPtrRet, index));\n@@ -504,1 +600,1 @@\n-    __ leaq(firstNeedleCompare, Address(needle, isU ? 4 : 2));\n+    __ movq(firstNeedleCompare, needle);\n@@ -506,1 +602,3 @@\n-    __ leaq(compLen, Address(needleLen, isU ? -6 : -3));\n+    __ movq(compLen, needleLen);\n+\n+    \/\/ Call arrays_equals for both UU and LL cases as bytes should compare exact\n@@ -512,0 +610,1 @@\n+    \/\/ If more potential matches, continue at inner loop, otherwise go get another vector\n@@ -533,0 +632,9 @@\n+  \/\/ Handle needle sizes > 10 bytes.  Uses C2's arrays_equals to compare the contents\n+  \/\/ of the needle to the haystack.\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\n+  \/\/ Small case default: register on entry\n+  \/\/\n@@ -546,0 +654,3 @@\n+  \/\/ Set up in broadcast_additional_needles\n+  \/\/  XMM_BYTE_1 - second element of needle broadcast\n+  \/\/\n@@ -571,0 +682,2 @@\n+    \/\/ For small haystacks we already know that the 1st, 2nd, and last bytes of the needle\n+    \/\/ compare equal, so we can reduce the byte count to arrays_equals\n@@ -574,2 +687,2 @@\n-    \/\/  firstNeedleCompare has address of second element of needle\n-    \/\/  compLen has length of comparison to do\n+    \/\/  firstNeedleCompare has address of third element of needle\n+    \/\/  compLen has length of comparison to do (3 elements less than needle size)\n@@ -577,0 +690,4 @@\n+    \/\/ Helper to compare the 1st, 2nd, and last byte of the needle to the haystack\n+    \/\/ in the correct position.  Since the haystack is < 32 bytes, not finding matching\n+    \/\/ needle bytes can just return failure.  Otherwise, we loop through the found\n+    \/\/ matches.\n@@ -588,0 +705,1 @@\n+    \/\/ Save registers stomped by arrays_equals\n@@ -591,0 +709,1 @@\n+    \/\/ Find index of a potential match\n@@ -597,2 +716,3 @@\n-    __C2 arrays_equals(false, rTmp, firstNeedleCompare, compLen, rTmp3, rTmp2, XMM_TMP3, XMM_TMP4, false \/* char *\/,\n-                        knoreg);\n+    \/\/ Check for needle equality.  Handles UU and LL cases since byte comparison should be exact\n+    __C2 arrays_equals(false, rTmp, firstNeedleCompare, compLen, rTmp3, rTmp2, XMM_TMP3, XMM_TMP4,\n+                       false \/* char *\/, knoreg);\n@@ -602,0 +722,1 @@\n+    \/\/ Restore saved registers\n@@ -604,0 +725,2 @@\n+\n+    \/\/ Jump to inner loop if more matches to check, otherwise return not found\n@@ -612,49 +735,0 @@\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  __ bind(L_returnError);\n-  __ movq(rax, -1);\n-  __ jmpb(L_return);\n-\n-  __ bind(L_returnRBP);\n-  __ movq(rax, rbp);\n-\n-  __ bind(L_bigCaseFixupAndReturn);\n-  __ subq(rcx, rbx);\n-  __ addq(rcx, r8);\n-\n-  __ movq(r11, rcx);\n-\n-  __ bind(L_checkRangeAndReturn);\n-  __ movq(rax, -1);\n-  __ cmpq(r11, nMinusK);\n-  \/\/ __ cmovq(Assembler::belowEqual, rax, r11);\n-  __ ja_b(L_return);\n-  __ movq(rax, r11);\n-\n-  __ bind(L_return);\n-  __ addptr(rsp, STACK_SPACE);\n-  __ pop(rbp);\n-#ifdef _WIN64\n-  __ pop(r9);\n-  __ pop(r8);\n-  __ pop(rcx);\n-  __ pop(rdi);\n-  __ pop(rsi);\n-#endif\n-  __ movdq(r12, save_r12);\n-  __ movdq(r13, save_r13);\n-  __ movdq(r14, save_r14);\n-  __ movdq(r15, save_r15);\n-  __ movdq(rbx, save_rbx);\n-\n-  \/\/ Need to return elements for UTF-16 encodings\n-  if (isU) {\n-    __ sarq(rax, 1);\n-  }\n-  __ vzeroupper();\n-\n-  __ leave();  \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(0);\n-\n@@ -672,1 +746,1 @@\n-    \/\/ \"regular\" code.  This is equavilent to doing a UU comparison, since the\n+    \/\/ \"regular\" UU code.  This is equavilent to doing a UU comparison, since the\n@@ -676,1 +750,1 @@\n-    \/\/ cases above. That is, for each haystack chunk, compare the needle.\n+    \/\/ cases above.\n@@ -679,0 +753,1 @@\n+    \/\/ Restore argument encoding from UU back to UL for helpers\n@@ -696,0 +771,1 @@\n+    \/\/ haystack length to bytes\n@@ -698,0 +774,1 @@\n+    \/\/ Ensure haystack >= needle\n@@ -702,0 +779,1 @@\n+    \/\/ Can't expand large-ish needles\n@@ -731,1 +809,1 @@\n-    \/\/ load needle[low-16]\n+    \/\/ load needle and expand\n@@ -733,1 +811,1 @@\n-    \/\/ store to stack\n+    \/\/ store expanded needle to stack\n@@ -741,0 +819,1 @@\n+    \/\/ adjust pointer and length of needle\n@@ -745,0 +824,1 @@\n+    \/\/ Go handle this the same as UU\n@@ -766,0 +846,1 @@\n+      \/\/ On entry:\n@@ -780,1 +861,1 @@\n-      const Register rTmp = rax;\n+      const Register hsPtrRet = rax;\n@@ -782,9 +863,6 @@\n-      const Register saveNeedleAddress = rbx;  \/\/ NOTE re-use\n-      const Register origNeedleLen = rcx;\n-      const Register firstNeedleCompare = rdx;\n-      const Register hsLen = rsi;\n-      const Register origHsLen = rsi;  \/\/ NOTE re-use\n-      const Register rTmp2 = rdi;\n-      const Register mask = rbp;\n-      const Register rScratch = r8;\n-      const Register compLen = r9;\n+      const Register haystackStart = rcx;\n+      const Register hsLength = rsi;\n+      const Register tmp1 = rdi;\n+      const Register compLen = rbp;\n+      const Register mask = r8;\n+      const Register index = r9;\n@@ -792,2 +870,1 @@\n-      const Register hsIndex = r12;  \/\/ NOTE re-use\n-      const Register constOffset = r13;\n+      const Register rScratch = r13;\n@@ -795,9 +872,0 @@\n-      const Register index = r14;  \/\/ NOTE re-use\n-      const Register haystackEnd = r15;\n-\n-      const XMMRegister result = XMM_TMP3;\n-      const XMMRegister cmp_0 = XMM_TMP3;\n-      const XMMRegister cmp_k = XMM_TMP4;\n-\n-      const XMMRegister saveCompLen = XMM_TMP2;\n-      const XMMRegister saveIndex = XMM_TMP1;\n@@ -810,4 +878,8 @@\n-      __ movq(rTmp, origNeedleLen);\n-      __ shlq(rTmp, 1);\n-      __ movq(rScratch, origHsLen);\n-      __ subq(rScratch, rTmp);\n+      \/\/ Set up nMinusK\n+      __ movq(tmp1, needleLen);\n+      __ shlq(tmp1, 1);\n+      __ movq(rScratch, hsLength);\n+      __ subq(rScratch, tmp1);\n+      __ movq(nMinusK, rScratch);\n+\n+      \/\/ Check for room for a 32-byte read for the last iteration\n@@ -817,2 +889,0 @@\n-      \/\/ Now there is room for a 32-byte read for the last iteration\n-\n@@ -820,54 +890,1 @@\n-      __ movzbl(rax, Address(needle));  \/\/ First byte of needle\n-      __ movdl(XMM_BYTE_0, rax);\n-      \/\/ 1st byte of needle in words\n-      __ vpbroadcastw(XMM_BYTE_0, XMM_BYTE_0, Assembler::AVX_256bit);\n-\n-      __ movzbl(rax, Address(needle, needle_len, Address::times_1,\n-                              -1));  \/\/ Last byte of needle\n-      __ movdl(XMM_BYTE_K, rax);\n-      __ vpbroadcastw(XMM_BYTE_K, XMM_BYTE_K,\n-                      Assembler::AVX_256bit);  \/\/ Last byte of needle in words\n-\n-      \/\/ __ bind(L_bigCaseDefault);\n-      __ movq(r11, -1);\n-\n-      broadcast_additional_needles(false, 0 \/* unknown *\/, needle, origNeedleLen, rax, ae, _masm);\n-\n-      __ leaq(haystackEnd, Address(haystack, hsLen, Address::times_1));\n-\n-      __ leaq(firstNeedleCompare, Address(needle, 2));\n-      __ leaq(compLen, Address(needleLen, -2));\n-\n-      \/\/  firstNeedleCompare has address of second element of needle\n-      \/\/  compLen has length of comparison to do\n-\n-      \/\/ Save haystack\n-      __ movq(Address(rsp, SAVED_HAYSTACK_STACK_OFFSET), haystack);\n-\n-      __ movq(index, origHsLen);\n-      __ negptr(index);  \/\/ incr\n-\n-      \/\/ constant offset from end for full 32-byte read\n-      __ movq(constOffset, origHsLen);\n-      __ shlq(origNeedleLen, 1);\n-      __ subq(constOffset, origNeedleLen);\n-      __ andq(constOffset, 0x1f);\n-      __ negptr(constOffset);\n-      __ jmpb(L_temp);\n-\n-      __ bind(L_loopTop);\n-      __ addq(index, 32);\n-      __ subq(origHsLen, 32);\n-      __ jle(L_returnError);\n-      __ cmpq(index, constOffset);\n-      \/\/ __ cmovq(Assembler::greater, index, constOffset);\n-      {\n-        Label L_tmp;\n-        __ jle_b(L_tmp);\n-        __ movq(index, constOffset);\n-        __ bind(L_tmp);\n-      }\n-\n-      __ bind(L_temp);\n-      __ movq(hsIndex, origNeedleLen);\n-      __ addq(hsIndex, index);\n+      broadcast_first_and_last_needle(needle, needleLen, tmp1, ae, _masm);\n@@ -875,10 +892,7 @@\n-      \/\/ Compare first byte of needle to haystack\n-      __ vpcmpeqw(cmp_0, XMM_BYTE_0, Address(haystackEnd, index), Assembler::AVX_256bit);\n-      \/\/ Compare last byte of needle to haystack at proper position\n-      __ vpcmpeqw(cmp_k, XMM_BYTE_K, Address(haystackEnd, hsIndex, Address::times_1, -2), Assembler::AVX_256bit);\n-      __ vpand(result, cmp_k, cmp_0, Assembler::AVX_256bit);\n-#ifdef DO_EARLY_BAILOUT\n-      __ vpmovmskb(mask, result, Assembler::AVX_256bit);\n-      __ testl(mask, mask);\n-      __ je_b(L_loopTop);\n-#endif\n+\/\/ Register redefinition for rbx and r15\n+#undef retval\n+#undef firstNeedleCompare\n+#undef tmp2\n+#undef tmp3\n+#define tmp2 r15\n+#define tmp3 rdx\n@@ -886,6 +900,6 @@\n-      \/\/ Compare second byte of needle to haystack\n-      __ vpcmpeqw(cmp_k, XMM_BYTE_1, Address(haystackEnd, index, Address::times_1, 2), Assembler::AVX_256bit);\n-      __ vpand(result, cmp_k, result, Assembler::AVX_256bit);\n-      __ vpmovmskb(mask, result, Assembler::AVX_256bit);\n-      __ testl(mask, mask);\n-      __ je_b(L_loopTop);\n+      \/\/ Loop construct handling for big haystacks\n+      \/\/ The helper binds L_loopTop which should be jumped to if potential matches fail to compare\n+      \/\/ equal (thus moving on to the next chunk of haystack).  If we run out of haystack, the\n+      \/\/ helper jumps to L_checkRangeAndReturn with a (-1) return value.\n+      big_case_loop_helper(false, 0, L_checkRangeAndReturn, L_loopTop, mask, hsPtrRet, needleLen,\n+                           needle, haystack, hsLength, tmp1, tmp2, tmp3, rScratch, ae, _masm);\n@@ -893,0 +907,3 @@\n+      \/\/ big_case_loop_helper will fall through to this point if one or more potential matches are\n+      \/\/ found The mask will have a bitmask indicating the position of the potential matches within\n+      \/\/ the haystack\n@@ -895,12 +912,25 @@\n-      __ tzcntl(rTmp, mask);\n-\n-      __ movdq(saveIndex, rTmp);\n-      __ movdq(saveCompLen, compLen);\n-      \/\/ Save address of nth element of needle\n-      __ movq(saveNeedleAddress, firstNeedleCompare);\n-\n-      __ leaq(rTmp2, Address(haystackEnd, index, Address::times_1, 4));\n-      __ addq(rTmp2, rTmp);\n-      __C2 arrays_equals(false, rTmp2, firstNeedleCompare, compLen, rTmp, rScratch, XMM_TMP3,\n-                         XMM_TMP4, false \/* char *\/, knoreg, true \/* expand_ary2 *\/);\n-      __ testl(rTmp, rTmp);\n+      __ tzcntl(index, mask);\n+\n+#undef tmp2\n+#undef tmp3\n+#define retval r15\n+#define firstNeedleCompare rdx\n+\n+      \/\/ Note that we're comparing the full needle here even though in some paths\n+      \/\/ the 1st, 2nd, and last bytes are already known to be equal.  This is necessary\n+      \/\/ due to the handling of cases where nMinusK is < 32\n+\n+      \/\/ Need a lot of registers here to preserve state across arrays_equals call\n+\n+      \/\/ Starting address in the haystack\n+      __ leaq(haystackStart, Address(hsPtrRet, index));\n+      \/\/ Starting address of first byte of needle to compare\n+      __ movq(firstNeedleCompare, needle);\n+      \/\/ Number of bytes to compare\n+      __ movq(compLen, needleLen);\n+\n+      \/\/ Passing true as last parameter causes arrays_equals to expand the second array (needle)\n+      \/\/ as the comparison is done.\n+      __C2 arrays_equals(false, haystackStart, firstNeedleCompare, compLen, retval, rScratch,\n+                         XMM_TMP3, XMM_TMP4, false \/* char *\/, knoreg, true \/* expand_ary2 *\/);\n+      __ testl(retval, retval);\n@@ -909,3 +939,2 @@\n-      __ movdq(compLen, saveCompLen);\n-      __ movq(firstNeedleCompare, saveNeedleAddress);\n-      CLEAR_BIT(mask, rTmp);\n+    \/\/ If more potential matches, continue at inner loop, otherwise go get another vector\n+      CLEAR_BIT(mask, index);\n@@ -915,0 +944,1 @@\n+      \/\/ Found exact match.  Compute offset from beginning of haystack\n@@ -916,5 +946,3 @@\n-      __ movdq(rTmp, saveIndex);\n-      __ leaq(rScratch, Address(haystackEnd, index, Address::times_1));\n-      __ subq(rScratch, Address(rsp, SAVED_HAYSTACK_STACK_OFFSET));\n-      __ addq(rScratch, rTmp);\n-      __ movq(r11, rScratch);\n+      __ subq(hsPtrRet, haystack);\n+      __ addq(hsPtrRet, index);\n+      __ movq(r11, hsPtrRet);\n@@ -923,0 +951,3 @@\n+#undef retval\n+#undef firstNeedleCompare\n+\n@@ -926,0 +957,1 @@\n+      \/\/ Index returned in r11\n@@ -932,1 +964,1 @@\n-      __ cmpq(r11, rScratch);\n+      __ cmpq(r11, nMinusK);\n@@ -937,2 +969,2 @@\n-      __ leaq(r12, Address(needle, 0));\n-      __ movq(r13, origNeedleLen);\n+      __ leaq(r8, Address(needle, 0));\n+      __ movq(r13, needleLen);\n@@ -940,2 +972,2 @@\n-      __C2 arrays_equals(false, r9, r12, r13, rax, rdx, XMM_TMP3, XMM_TMP4, false \/* char *\/,\n-                         knoreg, true \/* expand_ary2 *\/);\n+      __C2 arrays_equals(false, r9, r8, r13, rax, rdx, XMM_TMP3, XMM_TMP4, false \/* char *\/, knoreg,\n+                         true \/* expand_ary2 *\/);\n@@ -953,0 +985,1 @@\n+\n@@ -954,0 +987,1 @@\n+\/\/ Expands into XMM_BYTE_0 and XMM_BYTE_K\n@@ -962,1 +996,58 @@\n-\/\/ sizeKnown - True if size known at compile time\n+\/\/ needle - the address of the first byte of the needle\n+\/\/ needle_len - length of needle if !sizeKnown\n+\/\/ rTmp - temp register (for UL only)\n+\/\/ ae - the argument encodings\n+\/\/ _masm - Current MacroAssembler instance pointer\n+\/\/\n+\/\/ Modifies XMM_BYTE_0 and XMM_BYTE_K\n+static void broadcast_first_and_last_needle(Register needle, Register needle_len, Register rTmp,\n+                                            StrIntrinsicNode::ArgEncoding ae,\n+                                            MacroAssembler *_masm) {\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = (isUU || isUL);\n+  Label L_short;\n+\n+  \/\/ Always need needle broadcast to ymm registers\n+  \/\/ Broadcast the beginning of needle into a vector register.\n+  if (isUU) {\n+    __ vpbroadcastw(XMM_BYTE_0, Address(needle, 0), Assembler::AVX_256bit);\n+  } else if (isUL) {\n+\n+    __ movzbl(rTmp, Address(needle));\n+    __ movdl(XMM_BYTE_0, rTmp);\n+    \/\/ 1st byte of needle in words\n+    __ vpbroadcastw(XMM_BYTE_0, XMM_BYTE_0, Assembler::AVX_256bit);\n+  } else {\n+    __ vpbroadcastb(XMM_BYTE_0, Address(needle, 0), Assembler::AVX_256bit);\n+  }\n+\n+  \/\/ Broadcast the end of needle into a vector register.\n+  \/\/ For a single-element needle this is redundant but does no harm and\n+  \/\/ reduces code size as opposed to broadcasting only if used.\n+  if (isUU) {\n+    __ vpbroadcastw(XMM_BYTE_K, Address(needle, needle_len, Address::times_1, -2),\n+                    Assembler::AVX_256bit);\n+  } else if (isUL) {\n+    __ movzbl(rTmp, Address(needle, needle_len, Address::times_1, -1));\n+    __ movdl(XMM_BYTE_K, rTmp);\n+    \/\/ last byte of needle in words\n+    __ vpbroadcastw(XMM_BYTE_K, XMM_BYTE_K, Assembler::AVX_256bit);\n+  } else {\n+    __ vpbroadcastb(XMM_BYTE_K, Address(needle, needle_len, Address::times_1, -1),\n+                    Assembler::AVX_256bit);\n+  }\n+\n+  __ bind(L_short);\n+}\n+\n+\/\/ Helper for broadcasting the 2nd needle element to XMM_BYTE_1\n+\/\/\n+\/\/ For UTF-16 encoded needles, broadcast a word at the proper offset to the ymm\n+\/\/ register (case UU)\n+\/\/ For the UTF-16 encoded haystack with Latin1 encoded needle (case UL) we have\n+\/\/ to read into a temp register to zero-extend the single byte needle value, then\n+\/\/ broadcast words to the ymm register.\n+\/\/\n+\/\/ Parameters:\n+\/\/ sizeKnown - True if needle size known at compile time\n@@ -966,1 +1057,2 @@\n-\/\/ isUU and isUL - true if argument encoding is UU or UL, respectively\n+\/\/ rTmp - temp register (for UL only)\n+\/\/ ae - Argument encoding\n@@ -968,0 +1060,2 @@\n+\/\/\n+\/\/ Modifies XMM_BYTE_1\n@@ -975,1 +1069,0 @@\n-  bool isLL = (ae == StrIntrinsicNode::LL);\n@@ -982,0 +1075,2 @@\n+  \/\/ Need code to determine whether it's valid to use second byte of\n+  \/\/ needle if the size isn't known at compile-time\n@@ -1021,1 +1116,0 @@\n-\/\/ isU - true if argument encoding is either UU or UL\n@@ -1024,1 +1118,5 @@\n-\/\/ nMinusK - Size of haystack minus size of needle\n+\/\/ rTmp2 - a temporary register\n+\/\/ rxTmp1 - a temporary xmm register\n+\/\/ rxTmp2 - a temporary xmm register\n+\/\/ rxTmp3 - a temporary xmm register\n+\/\/ ae - Argument encoding\n@@ -1030,3 +1128,4 @@\n-                                           bool isU, Register eq_mask, Register rTmp,\n-                                           Register rTmp2, XMMRegister rxTmp1, XMMRegister rxTmp2,\n-                                           XMMRegister rxTmp3, MacroAssembler *_masm) {\n+                                           Register eq_mask, Register rTmp, Register rTmp2,\n+                                           XMMRegister rxTmp1, XMMRegister rxTmp2,\n+                                           XMMRegister rxTmp3, StrIntrinsicNode::ArgEncoding ae,\n+                                           MacroAssembler *_masm) {\n@@ -1041,0 +1140,4 @@\n+  bool isUL = (ae == StrIntrinsicNode::UL);\n+  bool isUU = (ae == StrIntrinsicNode::UU);\n+  bool isU = (isUU || isUL);\n+\n@@ -1044,0 +1147,1 @@\n+  \/\/ Set up lambdas for performing correct-sized comparisons\n@@ -1062,2 +1166,4 @@\n-  Address kThByte\n-      = sizeKnown ? Address(haystack, size - sizeIncr) : Address(haystack, needleLen, Address::times_1, -(sizeIncr));\n+  \/\/ Address of the kth byte of the needle within the haystack\n+  Address kThByte = sizeKnown ? Address(haystack, size - sizeIncr)\n+                              : Address(haystack, needleLen,\n+                                        isUL ? Address::times_2 : Address::times_1, -(sizeIncr));\n@@ -1075,0 +1181,1 @@\n+  \/\/ If the needle is a single element (at compile time) no need to compare more\n@@ -1076,0 +1183,2 @@\n+    \/\/ Need special handling for the case where there's not enough room\n+    \/\/ to read 32 bytes of haystack at the kth position\n@@ -1082,2 +1191,0 @@\n-    __ movl(shiftVal, isU ? 30 : 31);\n-    __ subl(shiftVal, nMinusK);\n@@ -1091,0 +1198,4 @@\n+\n+    \/\/ Mask off inappropriate comparisons\n+    __ movl(shiftVal, isU ? 30 : 31);\n+    __ subl(shiftVal, nMinusK);\n@@ -1094,0 +1205,1 @@\n+  \/\/ If the needle is only 2 elements (at compile time) no need to compare more\n@@ -1095,0 +1207,1 @@\n+#ifdef DO_EARLY_BAILOUT\n@@ -1097,0 +1210,1 @@\n+#endif\n@@ -1107,1 +1221,0 @@\n-    \/\/ Comparing multiple bytes and haystack length == 32\n@@ -1164,0 +1277,3 @@\n+\/\/ rTmp - temporary register\n+\/\/ rxTmp1 - temporary xmm register\n+\/\/ rxTmp2 - temporary xmm register\n@@ -1182,0 +1298,1 @@\n+  \/\/ Set up lambdas for performing correct-sized comparisons\n@@ -1198,2 +1315,3 @@\n-  Address kThByte\n-      = sizeKnown ? Address(haystack, size - sizeIncr) : Address(haystack, needleLen, Address::times_1, -(sizeIncr));\n+  \/\/ Address of the kth byte of the needle within the haystack\n+  Address kThByte = sizeKnown ? Address(haystack, size - sizeIncr)\n+                              : Address(haystack, needleLen, Address::times_1, -(sizeIncr));\n@@ -1283,1 +1401,1 @@\n-  Label L_midLoop;\n+  Label L_midLoop, L_greaterThan32, L_out;\n@@ -1292,1 +1410,0 @@\n-  bool isLL = (ae == StrIntrinsicNode::LL);\n@@ -1297,1 +1414,12 @@\n-  broadcast_additional_needles(sizeKnown, size, needle, needleLen, temp1, ae, _masm);\n+  \/\/ Set up lambdas for performing correct-sized comparisons\n+  std::function<void(XMMRegister dst, XMMRegister src, Address adr, int vector_len)> vpcmpeq;\n+\n+  if (isU) {\n+    vpcmpeq = [_masm](XMMRegister dst, XMMRegister src, Address adr, int vector_len) {\n+      __ vpcmpeqw(dst, src, adr, vector_len);\n+    };\n+  } else {\n+    vpcmpeq = [_masm](XMMRegister dst, XMMRegister src, Address adr, int vector_len) {\n+      __ vpcmpeqb(dst, src, adr, vector_len);\n+    };\n+  }\n@@ -1301,0 +1429,34 @@\n+  if (!sizeKnown) {\n+    __ cmpq(nMinusK, 32);\n+    __ jae_b(L_greaterThan32);\n+\n+    \/\/ Here the needle is too long, so we can't do a 32-byte read.\n+    \/\/ Default to a pseudo-scalar compare.\n+    \/\/ Find a match within the first 32 bytes for the first character.\n+    \/\/ If the matched character is at an offset > nMinusK, there's no match.\n+    \/\/ Otherwise fall out of the loop and let the callee do the compare.\n+    \/\/ Set last to hsPtrRet so the next attempt at loop iteration ends the compare.\n+    __ movq(last, haystack);\n+    __ movq(hsPtrRet, haystack);\n+\n+    \/\/ Build bitmask for compare\n+    __ movq(rTmp2, -1);\n+    __ movq(eq_mask, nMinusK);\n+    __ addq(eq_mask, 1);\n+    __ bzhiq(rTmp2, rTmp2, eq_mask);\n+\n+    \/\/ Compare first byte of needle to haystack\n+    vpcmpeq(XMM_TMP3, XMM_BYTE_0, Address(haystack, 0), Assembler::AVX_256bit);\n+\n+    __ vpmovmskb(eq_mask, XMM_TMP3, Assembler::AVX_256bit);\n+    __ andq(eq_mask, rTmp2);\n+\n+    __ testl(eq_mask, eq_mask);\n+    __ je(noMatch);\n+\n+    __ jmp(L_out);\n+  }\n+  __ bind(L_greaterThan32);\n+\n+  broadcast_additional_needles(sizeKnown, size, needle, needleLen, temp1, ae, _masm);\n+\n@@ -1324,5 +1486,2 @@\n-  \/\/ __ cmovq(Assembler::aboveEqual, hsPtrRet, last);\n-  {\n-    __ jb_b(L_midLoop);\n-    __ movq(hsPtrRet, last);\n-  }\n+  __ jb_b(L_midLoop);\n+  __ movq(hsPtrRet, last);\n@@ -1334,2 +1493,2 @@\n-  compare_big_haystack_to_needle(sizeKnown, size, loop_top, hsPtrRet, hsLength, needleLen, isU,\n-                                 eq_mask, temp2, temp3, XMM_TMP1, XMM_TMP2, XMM_TMP3, _masm);\n+  compare_big_haystack_to_needle(sizeKnown, size, loop_top, hsPtrRet, hsLength, needleLen, eq_mask,\n+                                 temp2, temp3, XMM_TMP1, XMM_TMP2, XMM_TMP3, ae, _masm);\n@@ -1343,0 +1502,2 @@\n+\n+  __ bind(L_out);\n@@ -1351,1 +1512,0 @@\n-  bool isLL = (ae == StrIntrinsicNode::LL);\n@@ -1412,1 +1572,0 @@\n-  bool isLL = (ae == StrIntrinsicNode::LL);\n@@ -1500,1 +1659,0 @@\n-  bool isLL = (ae == StrIntrinsicNode::LL);\n@@ -1510,0 +1668,5 @@\n+  \/\/ Since this code is generated before state is saved, we need to save\/restore\n+  \/\/ the used registers.\n+  __ push(mask);\n+  __ push(tmp);\n+\n@@ -1593,0 +1756,2 @@\n+  __ pop(tmp);\n+  __ pop(mask);\n@@ -1610,1 +1775,0 @@\n-  bool isLL = (ae == StrIntrinsicNode::LL);\n@@ -1770,0 +1934,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_string.cpp","additions":408,"deletions":243,"binary":false,"changes":651,"status":"modified"}]}