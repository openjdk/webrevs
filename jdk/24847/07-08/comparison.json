{"files":[{"patch":"@@ -132,1 +132,2 @@\n-  if (java_fields <= SEARCH_TABLE_THRESHOLD) {\n+  assert(java_fields >= 0, \"must be\");\n+  if (static_cast<uint>(java_fields) < BinarySearchThreshold) {\n@@ -225,4 +226,6 @@\n-  UNSIGNED5::Reader<const u1*, int> reader(fis->data(), fis->length());\n-  int java_fields = reader.next_uint();\n-  int position_width = search_table_position_width(fis->length());\n-  int item_width = position_width  + search_table_index_width(java_fields);\n+  FieldInfoReader reader(fis);\n+  int java_fields, injected_fields;\n+  reader.read_field_counts(&java_fields, &injected_fields);\n+  unsigned int position_width = search_table_position_width(fis->length());\n+  unsigned int item_width = position_width + search_table_index_width(java_fields);\n+  assert(item_width * java_fields == static_cast<unsigned int>(search_table->length()), \"size matches\");\n@@ -233,0 +236,1 @@\n+  \/\/ Check 1: assert that elements have the correct order based on the comparison function\n@@ -237,3 +241,6 @@\n-    reader.set_position(read_position(ptr));\n-    const Symbol* name = cp->symbol_at(reader.next_uint());\n-    const Symbol* signature = cp->symbol_at(reader.next_uint());\n+    int position = read_position(ptr);\n+    reader.set_position_and_next_index(position, -1);\n+    FieldInfo fi;\n+    reader.read_field_info(fi);\n+    const Symbol* name = fi.name(cp);\n+    const Symbol* signature = fi.signature(cp);\n@@ -247,0 +254,19 @@\n+\n+  \/\/ Check 2: Iterate through the original stream (not just search_table) and try if lookup works as expected\n+  reader.set_position_and_next_index(0, 0);\n+  reader.read_field_counts(&java_fields, &injected_fields);\n+  while (reader.has_next()) {\n+    int field_start = reader.position();\n+    FieldInfo fi;\n+    reader.read_field_info(fi);\n+    if (fi.field_flags().is_injected()) {\n+      \/\/ checking only java fields that precede injected ones\n+      break;\n+    }\n+\n+    FieldInfoReader r2(fis);\n+    int index = r2.search_table_lookup(search_table, fi.name(cp), fi.signature(cp), cp, java_fields);\n+    assert(index == static_cast<int>(fi.index()), \"wrong index: %d != %u\", index, fi.index());\n+    assert(index == r2.next_index(), \"index should match\");\n+    assert(field_start == r2.position(), \"must find the same position\");\n+  }\n@@ -251,4 +277,10 @@\n-  UNSIGNED5::Reader<const u1*, int> r2(_r.array());\n-  int low = 0, high = java_fields - 1;\n-  int position_width = FieldInfoStream::search_table_position_width(_r.limit());\n-  int item_width = position_width  + FieldInfoStream::search_table_index_width(java_fields);\n+  assert(java_fields >= 0, \"must be\");\n+  if (java_fields == 0) {\n+    return -1;\n+  }\n+  FieldInfoReader r2(*this);\n+  unsigned int low = 0, high = java_fields;\n+  assert(low < high, \"must be\");\n+  unsigned int position_width = FieldInfoStream::search_table_position_width(_r.limit());\n+  unsigned int index_width = FieldInfoStream::search_table_index_width(java_fields);\n+  unsigned int item_width = position_width + index_width;\n@@ -258,2 +290,3 @@\n-  while (low <= high) {\n-    int mid = low + (high - low) \/ 2;\n+  while (low < high) {\n+    unsigned int mid = low + (high - low) \/ 2;\n+    assert(mid >= low && mid < high, \"integer overflow?\");\n@@ -261,0 +294,1 @@\n+\n@@ -262,3 +296,6 @@\n-    r2.set_position(position);\n-    Symbol *mid_name = cp->symbol_at(checked_cast<u2>(r2.next_uint()));\n-    Symbol *mid_sig = cp->symbol_at(checked_cast<u2>(r2.next_uint()));\n+    assert(position >= 0 && position < _r.limit(), \"position out of bounds\");\n+    r2.set_position_and_next_index(position, -1);\n+    u2 name_index, sig_index;\n+    r2.read_name_and_signature(&name_index, &sig_index);\n+    Symbol *mid_name = cp->symbol_at(name_index);\n+    Symbol *mid_sig = cp->symbol_at(sig_index);\n@@ -269,1 +306,1 @@\n-      _next_index = item_width == 2 ?\n+      _next_index = index_width == 2 ?\n@@ -273,1 +310,1 @@\n-      high = mid - 1;\n+      high = mid;\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":56,"deletions":19,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -239,0 +239,1 @@\n+  void read_name_and_signature(u2 *name_index, u2 *signature_index);\n@@ -272,5 +273,2 @@\n-  \/\/ Don't generate the table for small classes at all.\n-  static const int SEARCH_TABLE_THRESHOLD = 16;\n-\n-  static inline int search_table_position_width(int stream_length) {\n-    assert(stream_length <= (1 << 24), \"stream too long\");\n+  static inline unsigned int search_table_position_width(int stream_length) {\n+    assert(stream_length >= 0 && stream_length <= (1 << 24), \"stream too long\");\n@@ -279,2 +277,2 @@\n-  static inline int search_table_index_width(int java_fields) {\n-    assert(java_fields <= (1 << 16), \"too many fields\");\n+  static inline unsigned int search_table_index_width(int java_fields) {\n+    assert(java_fields >= 0 && java_fields <= (1 << 16), \"too many fields\");\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -116,0 +116,5 @@\n+inline void FieldInfoReader::read_name_and_signature(u2 *name_index, u2 *signature_index) {\n+  *name_index = checked_cast<u2>(_r.next_uint());\n+  *signature_index = checked_cast<u2>(_r.next_uint());\n+}\n+\n@@ -118,2 +123,1 @@\n-  fi._name_index = checked_cast<u2>(_r.next_uint());\n-  fi._signature_index = checked_cast<u2>(_r.next_uint());\n+  read_name_and_signature(&fi._name_index, &fi._signature_index);\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2005,0 +2005,4 @@\n+                                                                            \\\n+  develop(uint, BinarySearchThreshold, 16,                                  \\\n+          \"Minimal number of elements in a sorted collection to prefer\"     \\\n+          \"binary search over simple linear search.\" )                      \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+\n+import static org.objectweb.asm.ClassWriter.COMPUTE_FRAMES;\n+import static org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+import static org.objectweb.asm.Opcodes.*;\n+\n+\/*\n+ * @test id=defaults\n+ * @bug 8352075\n+ * @library \/test\/lib\n+ * @library \/testlibrary\/asm\n+ * @run main\/othervm LocalFieldLookupTest\n+ *\/\n+\/*\n+ * @test id=custom-threshold\n+ * @bug 8352075\n+ * @library \/test\/lib\n+ * @library \/testlibrary\/asm\n+ * @requires vm.debug == true\n+ * @run main\/othervm LocalFieldLookupTest\n+ * @run main\/othervm -XX:BinarySearchThreshold=0 LocalFieldLookupTest\n+ * @run main\/othervm -XX:BinarySearchThreshold=1 LocalFieldLookupTest\n+ * @run main\/othervm -XX:BinarySearchThreshold=15 LocalFieldLookupTest\n+ * @run main\/othervm -XX:BinarySearchThreshold=100000 LocalFieldLookupTest\n+ *\/\n+public class LocalFieldLookupTest {\n+    private static final String TEST_CLASS_NAME = \"Test\";\n+    private static final int MAX_FIELDS_IN_METHOD = 10000;\n+\n+    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n+        \/\/ Test small classes, covering the tested thresholds\n+        for (int i = 0; i <= 33; ++i) {\n+            makeClass(i).newInstance();\n+        }\n+        \/\/ Test classes around 256 fields (index encoding 1\/2 bytes) to check off-by-one errors\n+        for (int i = 254; i <= 259; ++i) {\n+            makeClass(255).newInstance();\n+        }\n+        \/\/ We would like to test #fields that create have the stream about 65536 bytes long;\n+        \/\/ this value is not exposed, though, so these are rather experimentally found values,\n+        \/\/ hence fragile. Moreover, since the stream length is incremented by about 8 bytes\n+        \/\/ for each field we cannot test for off-by-one errors reliably.\n+        for (int i = 8433; i <= 8437; ++i) {\n+            makeClass(i).newInstance();\n+        }\n+        \/\/ The largest class we can create - this one has 65533 entries in the constant pool\n+        makeClass(26205).newInstance();\n+    }\n+\n+    public static Class<?> makeClass(int fields) throws ClassNotFoundException {\n+        ClassWriter writer = new ClassWriter(COMPUTE_MAXS | COMPUTE_FRAMES);\n+        writer.visit(49, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER, TEST_CLASS_NAME,null, \"java\/lang\/Object\", null);\n+\n+        for (int i = 0; i < fields; i += 2) {\n+            writer.visitField(ACC_PUBLIC, \"f\" + i, \"I\",  null, null);\n+            \/\/ Let's use duplicate names to confirm search takes signatures into account\n+            if (i + 1 < fields) {\n+                writer.visitField(ACC_PUBLIC, \"f\" + i, \"J\",  null, null);\n+            }\n+        }\n+        \/\/ We initialize fields in multiple methods to avoid running into bytecode limit per method\n+        MethodVisitor fi = null;\n+        for (int i = 0; i < fields; i+= 2) {\n+            if (fi == null) {\n+                fi = writer.visitMethod(ACC_PRIVATE, \"init\" + i, \"()V\", null, null);\n+                fi.visitCode();\n+            }\n+            fi.visitVarInsn(Opcodes.ALOAD, 0);\n+            fi.visitInsn(Opcodes.ICONST_2);\n+            fi.visitFieldInsn(PUTFIELD, TEST_CLASS_NAME, \"f\" + i, \"I\");\n+            if (i + 1 < fields) {\n+                fi.visitVarInsn(Opcodes.ALOAD, 0);\n+                fi.visitInsn(Opcodes.LCONST_1);\n+                fi.visitFieldInsn(PUTFIELD, TEST_CLASS_NAME, \"f\" + i, \"J\");\n+            }\n+            if (i % MAX_FIELDS_IN_METHOD == MAX_FIELDS_IN_METHOD - 2) {\n+                fi.visitInsn(Opcodes.RETURN);\n+                fi.visitMaxs(0, 0);\n+                fi.visitEnd();\n+                fi = null;\n+            }\n+        }\n+        if (fi != null) {\n+            fi.visitInsn(Opcodes.RETURN);\n+            fi.visitMaxs(0, 0);\n+            fi.visitEnd();\n+        }\n+        {\n+            MethodVisitor mv = writer.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n+            mv.visitCode();\n+            mv.visitVarInsn(ALOAD, 0);\n+            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n+            for (int i = 0; i < fields; i += MAX_FIELDS_IN_METHOD) {\n+                mv.visitVarInsn(ALOAD, 0);\n+                mv.visitMethodInsn(INVOKESPECIAL, TEST_CLASS_NAME, \"init\" + i, \"()V\", false);\n+            }\n+            mv.visitInsn(RETURN);\n+            mv.visitMaxs(0, 0);\n+            mv.visitEnd();\n+        }\n+        writer.visitEnd();\n+\n+        byte[] bytecode = writer.toByteArray();\n+        ClassLoader cl = new ClassLoader() {\n+            @Override\n+            protected Class<?> findClass(String name) throws ClassNotFoundException {\n+                if (!TEST_CLASS_NAME.equals(name)) {\n+                    throw new ClassNotFoundException();\n+                }\n+                return defineClass(TEST_CLASS_NAME, bytecode, 0, bytecode.length);\n+            }\n+        };\n+        return cl.loadClass(TEST_CLASS_NAME);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/8352075\/LocalFieldLookupTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"}]}