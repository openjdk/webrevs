{"files":[{"patch":"@@ -970,1 +970,1 @@\n-      Array<u1> *old_table = ik->fieldinfo_search_table();\n+      Array<u1>* old_table = ik->fieldinfo_search_table();\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,2 +132,2 @@\n-  Symbol *name;\n-  Symbol *signature;\n+  Symbol* name;\n+  Symbol* signature;\n@@ -137,1 +137,1 @@\n-field_pos_t *positions = nullptr;\n+field_pos_t* positions = nullptr;\n@@ -141,1 +141,1 @@\n-  const field_pos_t *_positions;\n+  const field_pos_t* _positions;\n@@ -144,1 +144,1 @@\n-  FieldInfoSupplier(const field_pos_t *positions, size_t elements): _positions(positions), _elements(elements) {}\n+  FieldInfoSupplier(const field_pos_t* positions, size_t elements): _positions(positions), _elements(elements) {}\n@@ -146,1 +146,1 @@\n-  bool next(uint32_t *key, uint32_t *value) override {\n+  bool next(uint32_t* key, uint32_t* value) override {\n@@ -188,3 +188,3 @@\n-  auto compare_pair = [](const void *v1, const void *v2) {\n-    const field_pos_t *p1 = reinterpret_cast<const field_pos_t *>(v1);\n-    const field_pos_t *p2 = reinterpret_cast<const field_pos_t *>(v2);\n+  auto compare_pair = [](const void* v1, const void* v2) {\n+    const field_pos_t* p1 = reinterpret_cast<const field_pos_t*>(v1);\n+    const field_pos_t* p2 = reinterpret_cast<const field_pos_t*>(v2);\n@@ -229,4 +229,4 @@\n-  const FieldInfoReader *_reader;\n-  ConstantPool *_cp;\n-  const Symbol *_name;\n-  const Symbol *_signature;\n+  const FieldInfoReader* _reader;\n+  ConstantPool* _cp;\n+  const Symbol* _name;\n+  const Symbol* _signature;\n@@ -235,1 +235,1 @@\n-  FieldInfoComparator(const FieldInfoReader *reader, ConstantPool *cp, const Symbol *name, const Symbol *signature):\n+  FieldInfoComparator(const FieldInfoReader* reader, ConstantPool* cp, const Symbol* name, const Symbol* signature):\n@@ -243,2 +243,2 @@\n-    Symbol *mid_name = _cp->symbol_at(name_index);\n-    Symbol *mid_sig = _cp->symbol_at(sig_index);\n+    Symbol* mid_name = _cp->symbol_at(name_index);\n+    Symbol* mid_sig = _cp->symbol_at(sig_index);\n@@ -249,0 +249,1 @@\n+#ifdef ASSERT\n@@ -257,0 +258,1 @@\n+#endif \/\/ ASSERT\n@@ -260,1 +262,1 @@\n-void FieldInfoStream::validate_search_table(ConstantPool* cp, const Array<u1>* fis, const Array<u1> *search_table) {\n+void FieldInfoStream::validate_search_table(ConstantPool* cp, const Array<u1>* fis, const Array<u1>* search_table) {\n@@ -295,1 +297,1 @@\n-#endif\n+#endif \/\/ ASSERT\n@@ -297,1 +299,1 @@\n-int FieldInfoReader::search_table_lookup(const Array<u1> *search_table, const Symbol *name, const Symbol *signature, ConstantPool *cp, int java_fields) {\n+int FieldInfoReader::search_table_lookup(const Array<u1>* search_table, const Symbol* name, const Symbol* signature, ConstantPool* cp, int java_fields) {\n@@ -307,1 +309,1 @@\n-      &position, reinterpret_cast<uint32_t *>(&_next_index))) {\n+      &position, reinterpret_cast<uint32_t*>(&_next_index))) {\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-  void read_field_counts(int *java_fields, int *injected_fields);\n+  void read_field_counts(int* java_fields, int* injected_fields);\n@@ -239,1 +239,1 @@\n-  void read_name_and_signature(u2 *name_index, u2 *signature_index);\n+  void read_name_and_signature(u2* name_index, u2* signature_index);\n@@ -242,1 +242,1 @@\n-  int search_table_lookup(const Array<u1> *search_table, const Symbol *name, const Symbol *signature, ConstantPool *cp, int java_fields);\n+  int search_table_lookup(const Array<u1>* search_table, const Symbol* name, const Symbol* signature, ConstantPool* cp, int java_fields);\n@@ -287,1 +287,1 @@\n-  DEBUG_ONLY(static void validate_search_table(ConstantPool* cp, const Array<u1>* fis, const Array<u1> *search_table);)\n+  DEBUG_ONLY(static void validate_search_table(ConstantPool* cp, const Array<u1>* fis, const Array<u1>* search_table);)\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-inline void FieldInfoReader::read_field_counts(int *java_fields, int *injected_fields) {\n+inline void FieldInfoReader::read_field_counts(int* java_fields, int* injected_fields) {\n@@ -116,1 +116,1 @@\n-inline void FieldInfoReader::read_name_and_signature(u2 *name_index, u2 *signature_index) {\n+inline void FieldInfoReader::read_name_and_signature(u2* name_index, u2* signature_index) {\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-  Array<u1> *_search_table;\n+  Array<u1>* _search_table;\n@@ -178,1 +178,1 @@\n-  bool lookup(const Symbol *name, const Symbol *signature);\n+  bool lookup(const Symbol* name, const Symbol* signature);\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-inline bool JavaFieldStream::lookup(const Symbol *name, const Symbol *signature) {\n+inline bool JavaFieldStream::lookup(const Symbol* name, const Symbol* signature) {\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -409,1 +409,1 @@\n-  void set_fieldinfo_search_table(Array<u1> *table) { _fieldinfo_search_table = table; }\n+  void set_fieldinfo_search_table(Array<u1>* table) { _fieldinfo_search_table = table; }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,3 @@\n-void PackedTableBuilder::fill(u1 *data, size_t length, Supplier &supplier) const {\n+\/\/ Note: we require the supplier to provide the elements in the final order as we can't easily sort\n+\/\/ within this method - qsort() accepts only pure function as comparator.\n+void PackedTableBuilder::fill(u1* data, size_t length, Supplier &supplier) const {\n@@ -47,1 +49,1 @@\n-    *reinterpret_cast<uint64_t *>(data + offset) = static_cast<uint64_t>(key) | (static_cast<uint64_t>(value) << _value_shift);\n+    *reinterpret_cast<uint64_t*>(data + offset) = static_cast<uint64_t>(key) | (static_cast<uint64_t>(value) << _value_shift);\n@@ -63,1 +65,1 @@\n-    return *reinterpret_cast<const uint64_t *>(data + offset);\n+    return *reinterpret_cast<const uint64_t*>(data + offset);\n@@ -74,2 +76,2 @@\n-bool PackedTableLookup::search(Comparator& comparator, const u1* data, size_t search_table_length, uint32_t* found_key, uint32_t* found_value) const {\n-  unsigned int low = 0, high = checked_cast<unsigned int>(search_table_length \/ _element_bytes);\n+bool PackedTableLookup::search(Comparator& comparator, const u1* data, size_t length, uint32_t* found_key, uint32_t* found_value) const {\n+  unsigned int low = 0, high = checked_cast<unsigned int>(length \/ _element_bytes);\n@@ -80,1 +82,1 @@\n-    uint64_t element = read_element(data, search_table_length, _element_bytes * mid);\n+    uint64_t element = read_element(data, length, _element_bytes * mid);\n@@ -97,1 +99,1 @@\n-void PackedTableLookup::validate_order(Comparator &comparator, const u1 *search_table, size_t length) const {\n+void PackedTableLookup::validate_order(Comparator &comparator, const u1* table, size_t length) const {\n@@ -99,1 +101,1 @@\n-    uint64_t element = read_element(search_table, length, offset);\n+    uint64_t element = read_element(table, length, offset);\n","filename":"src\/hotspot\/share\/utilities\/packedTable.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,6 +27,5 @@\n-\/*\n- * Base for space-optimized structure supporting binary search. Each element\n- * consists of up to 32-bit key, and up to 32-bit value; these are packed\n- * into a bit-record aligned on bytes.\n- * The keys are ordered according to a custom comparator.\n- *\/\n+\n+\/\/ Base for space-optimized structure supporting binary search. Each element\n+\/\/ consists of up to 32-bit key, and up to 32-bit value; these are packed\n+\/\/ into a bit-record with 1-byte alignment.\n+\/\/ The keys are ordered according to a custom comparator.\n@@ -41,0 +40,2 @@\n+  \/\/ The thresholds are inclusive, and in practice the limits are rounded\n+  \/\/ to the nearest power-of-two - 1.\n@@ -43,0 +44,1 @@\n+  \/\/ Returns number of bytes each element will occupy.\n@@ -46,0 +48,1 @@\n+\/\/ Helper class for constructing a packed table in the provided array.\n@@ -50,2 +53,5 @@\n-    \/* Returns elements with already ordered keys. *\/\n-    virtual bool next(uint32_t *key, uint32_t *value) = 0;\n+    \/\/ Returns elements with already ordered keys.\n+    \/\/ This function should return true when the key and value was set,\n+    \/\/ and false when there's no more elements.\n+    \/\/ Packed table does NOT support duplicate keys.\n+    virtual bool next(uint32_t* key, uint32_t* value) = 0;\n@@ -54,0 +60,2 @@\n+  \/\/ The thresholds are inclusive, and in practice the limits are rounded\n+  \/\/ to the nearest power-of-two - 1.\n@@ -56,4 +64,7 @@\n-  \/\/ The supplier should return elements with already ordered keys.\n-  \/\/ We can't easily sort within the builder because qsort() accepts\n-  \/\/ only pure function as comparator.\n-  void fill(u1 *search_table, size_t search_table_length, Supplier &supplier) const;\n+  \/\/ Constructs a packed table in the provided array, filling it with elements\n+  \/\/ from the supplier. Note that no comparator is requied by this method -\n+  \/\/ the supplier must return elements with already ordered keys.\n+  \/\/ The table_length (in bytes) should match number of elements provided\n+  \/\/ by the supplier (when Supplier::next() returns false the whole array should\n+  \/\/ be filled).\n+  void fill(u1* table, size_t table_length, Supplier &supplier) const;\n@@ -62,0 +73,1 @@\n+\/\/ Helper class for lookup in a packed table.\n@@ -67,6 +79,5 @@\n-  \/*\n-   * The comparator implementation does not have to store a key (uint32_t);\n-   * the idea is that key can point into a different structure that hosts data\n-   * suitable for the actual comparison. That's why PackedTableLookup::search(...)\n-   * returns the key it found as well as the value.\n-   *\/\n+\n+  \/\/ The comparator implementation does not have to store a key (uint32_t);\n+  \/\/ the idea is that key can point into a different structure that hosts data\n+  \/\/ suitable for the actual comparison. That's why PackedTableLookup::search(...)\n+  \/\/ returns the key it found as well as the value.\n@@ -75,0 +86,2 @@\n+    \/\/ Returns negative\/0\/positive if the target referred to by this comparator\n+    \/\/ is lower\/equal\/higher than the target referred to by the key.\n@@ -76,1 +89,2 @@\n-    virtual void reset(uint32_t key) = 0;\n+    \/\/ Changes the target this comparator refers to.\n+    DEBUG_ONLY(virtual void reset(uint32_t key) = 0);\n@@ -79,0 +93,2 @@\n+  \/\/ The thresholds are inclusive, and in practice the limits are rounded\n+  \/\/ to the nearest power-of-two - 1.\n@@ -81,2 +97,10 @@\n-  bool search(Comparator& comparator, const u1* search_table, size_t search_table_length, uint32_t* found_key, uint32_t* found_value) const;\n-  DEBUG_ONLY(void validate_order(Comparator &comparator, const u1 *search_table, size_t search_table_length) const);\n+  \/\/ Performs a binary search in the packed table, looking for an element with key\n+  \/\/ referring to a target equal according to the comparator.\n+  \/\/ When the element is found, found_key and found_value are updated from the element\n+  \/\/ and the function returns true.\n+  \/\/ When the element is not found, found_key and found_value are not changed and\n+  \/\/ the function returns false.\n+  bool search(Comparator& comparator, const u1* table, size_t table_length, uint32_t* found_key, uint32_t* found_value) const;\n+\n+  \/\/ Asserts that elements in the packed table follow the order defined by the comparator.\n+  DEBUG_ONLY(void validate_order(Comparator &comparator, const u1* table, size_t table_length) const);\n","filename":"src\/hotspot\/share\/utilities\/packedTable.hpp","additions":45,"deletions":21,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-    uint32_t *_keys;\n-    uint32_t *_values;\n+    uint32_t* _keys;\n+    uint32_t* _values;\n@@ -33,1 +33,1 @@\n-    Supplier(uint32_t *keys, uint32_t *values, size_t num_keys):\n+    Supplier(uint32_t* keys, uint32_t* values, size_t num_keys):\n@@ -36,1 +36,1 @@\n-    bool next(uint32_t *key, uint32_t *value) override {\n+    bool next(uint32_t* key, uint32_t* value) override {\n@@ -60,1 +60,2 @@\n-    void reset(uint32_t key) override {\n+\n+    void reset(uint32_t key) DEBUG_ONLY(override) {\n@@ -72,1 +73,1 @@\n-    u1 *table = new u1[table_bytes];\n+    u1* table = new u1[table_bytes];\n@@ -74,2 +75,2 @@\n-    uint32_t *keys = new uint32_t[length];\n-    uint32_t *values = max_value != 0 ? new uint32_t[length] : nullptr;\n+    uint32_t* keys = new uint32_t[length];\n+    uint32_t* values = max_value != 0 ? new uint32_t[length] : nullptr;\n","filename":"test\/hotspot\/gtest\/utilities\/test_packedTable.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"","filename":"test\/hotspot\/jtreg\/runtime\/FieldStream\/LocalFieldLookupTest.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/runtime\/8352075\/LocalFieldLookupTest.java","status":"renamed"}]}