{"files":[{"patch":"@@ -133,4 +133,4 @@\n-  Symbol* name;\n-  Symbol* signature;\n-  int index;\n-  int position;\n+  Symbol* _name;\n+  Symbol* _signature;\n+  int _index;\n+  int _position;\n@@ -150,2 +150,2 @@\n-    *key = _positions->position;\n-    *value = _positions->index;\n+    *key = _positions->_position;\n+    *value = _positions->_index;\n@@ -180,1 +180,1 @@\n-    positions[i].position = r.position();\n+    positions[i]._position = r.position();\n@@ -184,3 +184,3 @@\n-    positions[i].name = fi.name(cp);\n-    positions[i].signature = fi.signature(cp);\n-    positions[i].index = i;\n+    positions[i]._name = fi.name(cp);\n+    positions[i]._signature = fi.signature(cp);\n+    positions[i]._index = i;\n@@ -191,1 +191,1 @@\n-    return compare_name_and_sig(p1->name, p1->signature, p2->name, p2->signature);\n+    return compare_name_and_sig(p1->_name, p1->_signature, p2->_name, p2->_signature);\n@@ -273,1 +273,1 @@\n-  PackedTableLookup lookup(fis->length() - 1, java_fields - 1);\n+  PackedTableLookup lookup(fis->length() - 1, java_fields - 1, search_table);\n@@ -278,1 +278,1 @@\n-  lookup.validate_order(comparator, search_table->data(), static_cast<size_t>(search_table->length()));\n+  lookup.validate_order(comparator);\n@@ -301,0 +301,26 @@\n+void FieldInfoStream::print_search_table(outputStream* st, ConstantPool* cp, const Array<u1>* fis, const Array<u1>* search_table) {\n+  if (search_table == nullptr) {\n+    return;\n+  }\n+  FieldInfoReader reader(fis);\n+  int java_fields, injected_fields;\n+  reader.read_field_counts(&java_fields, &injected_fields);\n+  assert(java_fields > 0, \"must be\");\n+  PackedTableLookup lookup(fis->length() - 1, java_fields - 1, search_table);\n+  auto printer = [&] (size_t offset, uint32_t position, uint32_t index) {\n+    reader.set_position_and_next_index(position, -1);\n+    u2 name_index, sig_index;\n+    reader.read_name_and_signature(&name_index, &sig_index);\n+    Symbol* name = cp->symbol_at(name_index);\n+    Symbol* sig = cp->symbol_at(sig_index);\n+    st->print(\"   [%zu] #%d,#%d = \", offset, name_index, sig_index);\n+    name->print_symbol_on(st);\n+    st->print(\":\");\n+    sig->print_symbol_on(st);\n+    st->print(\" @ %p,%p\", name, sig);\n+    st->cr();\n+  };\n+\n+  lookup.iterate(printer);\n+}\n+\n@@ -307,1 +333,1 @@\n-  PackedTableLookup lookup(_r.limit() - 1, java_fields - 1);\n+  PackedTableLookup lookup(_r.limit() - 1, java_fields - 1, search_table);\n@@ -310,2 +336,1 @@\n-  if (lookup.search(comp, search_table->data(), static_cast<size_t>(search_table->length()),\n-      &position, reinterpret_cast<uint32_t*>(&_next_index))) {\n+  if (lookup.search(comp, &position, reinterpret_cast<uint32_t*>(&_next_index))) {\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":41,"deletions":16,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -288,0 +288,2 @@\n+\n+  static void print_search_table(outputStream* st, ConstantPool* cp, const Array<u1>* fis, const Array<u1>* search_table);\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,8 @@\n+\/\/ The thresholds are inclusive, and in practice the limits are rounded\n+\/\/ to the nearest power-of-two - 1.\n+\/\/ Based on the max_key and max_value we figure out the number of bits required to store\n+\/\/ key and value; imagine that only as bits (not aligned to byte boundary... yet).\n+\/\/ Then we concatenate the bits for key and value, and 'add' 1-7 padding zeroes\n+\/\/ (high-order bits) to align on bytes.\n+\/\/ In the end we have each element in the table consuming 1-8 bytes (case with 0 bits for key\n+\/\/ is ruled out).\n@@ -43,1 +51,1 @@\n-void PackedTableBuilder::fill(u1* data, size_t length, Supplier &supplier) const {\n+void PackedTableBuilder::fill(u1* table, size_t table_length, Supplier &supplier) const {\n@@ -46,1 +54,1 @@\n-  for (; offset + sizeof(uint64_t) <= length && supplier.next(&key, &value); offset += _element_bytes) {\n+  for (; offset + sizeof(uint64_t) <= table_length && supplier.next(&key, &value); offset += _element_bytes) {\n@@ -49,1 +57,2 @@\n-    *reinterpret_cast<uint64_t*>(data + offset) = static_cast<uint64_t>(key) | (static_cast<uint64_t>(value) << _value_shift);\n+    uint64_t element = static_cast<uint64_t>(key) | (static_cast<uint64_t>(value) << _value_shift);\n+    __builtin_memcpy(table + offset, &element, _element_bytes);\n@@ -52,1 +61,1 @@\n-  for (; offset < length && supplier.next(&key, &value); offset += _element_bytes) {\n+  for (; offset < table_length && supplier.next(&key, &value); offset += _element_bytes) {\n@@ -55,1 +64,1 @@\n-      data[offset + i] = static_cast<u1>(0xFF & (element >> (8 * i)));\n+      table[offset + i] = static_cast<u1>(0xFF & (element >> (8 * i)));\n@@ -59,1 +68,1 @@\n-  assert(offset == length, \"Did not fill whole array\");\n+  assert(offset == table_length, \"Did not fill whole array\");\n@@ -63,5 +72,1 @@\n-uint64_t PackedTableLookup::read_element(const u1* data, size_t length, size_t offset) const {\n-  if (offset + sizeof(uint64_t) <= length) {\n-    return *reinterpret_cast<const uint64_t*>(data + offset);\n-  }\n-  \/\/ slow path for accessing end of array\n+uint64_t PackedTableLookup::read_element(size_t offset) const {\n@@ -69,3 +74,1 @@\n-  for (size_t i = 0; i < _element_bytes && offset + i < length; ++i) {\n-    element = element | (static_cast<uint64_t>(data[offset + i]) << (i * 8));\n-  }\n+  __builtin_memcpy(&element, _table + offset, _element_bytes);\n@@ -76,2 +79,2 @@\n-bool PackedTableLookup::search(Comparator& comparator, const u1* data, size_t length, uint32_t* found_key, uint32_t* found_value) const {\n-  unsigned int low = 0, high = checked_cast<unsigned int>(length \/ _element_bytes);\n+bool PackedTableLookup::search(Comparator& comparator, uint32_t* found_key, uint32_t* found_value) const {\n+  unsigned int low = 0, high = checked_cast<unsigned int>(_table_length \/ _element_bytes);\n@@ -82,2 +85,3 @@\n-    uint64_t element = read_element(data, length, _element_bytes * mid);\n-    uint32_t key = element & _key_mask;\n+    uint64_t element = read_element(_element_bytes * mid);\n+    \/\/ Ignoring high 32 bits in element on purpose\n+    uint32_t key = static_cast<uint32_t>(element) & _key_mask;\n@@ -87,1 +91,3 @@\n-      *found_value = (element >> _value_shift) & _value_mask;\n+      \/\/ Since __builtin_memcpy in read_element does not copy bits outside the element\n+      \/\/ anything above _value_mask << _value_shift should be zero.\n+      *found_value = checked_cast<uint32_t>(element >> _value_shift) & _value_mask;\n@@ -99,5 +105,2 @@\n-void PackedTableLookup::validate_order(Comparator &comparator, const u1* table, size_t length) const {\n-  for (size_t offset = 0; offset < length; offset += _element_bytes) {\n-    uint64_t element = read_element(table, length, offset);\n-    uint32_t key = element & _key_mask;\n-\n+void PackedTableLookup::validate_order(Comparator &comparator) const {\n+  auto validator = [&] (size_t offset, uint32_t key, uint32_t value) {\n@@ -108,1 +111,2 @@\n-  }\n+  };\n+  iterate(validator);\n","filename":"src\/hotspot\/share\/utilities\/packedTable.cpp","additions":29,"deletions":25,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"oops\/array.hpp\"\n@@ -27,1 +28,0 @@\n-\n@@ -40,8 +40,0 @@\n-  \/\/ The thresholds are inclusive, and in practice the limits are rounded\n-  \/\/ to the nearest power-of-two - 1.\n-  \/\/ Based on the max_key and max_value we figure out the number of bits required to store\n-  \/\/ key and value; imagine that only as bits (not aligned to byte boundary... yet).\n-  \/\/ Then we concatenate the bits for key and value, and 'add' 1-7 padding zeroes\n-  \/\/ (high-order bits) to align on bytes.\n-  \/\/ In the end we have each element in the table consuming 1-8 bytes (case with 0 bits for key\n-  \/\/ is ruled out).\n@@ -83,1 +75,4 @@\n-  uint64_t read_element(const u1* data, size_t length, size_t offset) const;\n+  const u1* const _table;\n+  const size_t _table_length;\n+\n+  uint64_t read_element(size_t offset) const;\n@@ -103,1 +98,5 @@\n-  PackedTableLookup(uint32_t max_key, uint32_t max_value): PackedTableBase(max_key, max_value) {}\n+  PackedTableLookup(uint32_t max_key, uint32_t max_value, const u1 *table, size_t table_length):\n+    PackedTableBase(max_key, max_value), _table(table), _table_length(table_length) {}\n+\n+  PackedTableLookup(uint32_t max_key, uint32_t max_value, const Array<u1> *table):\n+    PackedTableLookup(max_key, max_value, table->data(), static_cast<size_t>(table->length())) {}\n@@ -111,1 +110,1 @@\n-  bool search(Comparator& comparator, const u1* table, size_t table_length, uint32_t* found_key, uint32_t* found_value) const;\n+  bool search(Comparator& comparator, uint32_t* found_key, uint32_t* found_value) const;\n@@ -114,1 +113,11 @@\n-  DEBUG_ONLY(void validate_order(Comparator &comparator, const u1* table, size_t table_length) const);\n+  DEBUG_ONLY(void validate_order(Comparator &comparator) const);\n+\n+  template<typename Function>\n+  void iterate(Function func) const {\n+    for (size_t offset = 0; offset < _table_length; offset += _element_bytes) {\n+      uint64_t element = read_element(offset);\n+      uint32_t key = static_cast<uint32_t>(element) & _key_mask;\n+      uint32_t value = checked_cast<uint32_t>(element >> _value_shift) & _value_mask;\n+      func(offset, key, value);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/utilities\/packedTable.hpp","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    size_t table_bytes = length * builder.element_bytes();\n-    u1* table = new u1[table_bytes];\n+    size_t table_length = length * builder.element_bytes();\n+    u1* table = new u1[table_length];\n@@ -84,1 +84,1 @@\n-    builder.fill(table, table_bytes, sup);\n+    builder.fill(table, table_length, sup);\n@@ -87,1 +87,1 @@\n-    PackedTableLookup lookup(max_key, max_value);\n+    PackedTableLookup lookup(max_key, max_value, table, table_length);\n@@ -89,1 +89,1 @@\n-    lookup.validate_order(comparator, table, table_bytes);\n+    lookup.validate_order(comparator);\n@@ -95,1 +95,1 @@\n-        EXPECT_TRUE(lookup.search(comparator, table, table_bytes, &key, &value));\n+        EXPECT_TRUE(lookup.search(comparator, &key, &value));\n","filename":"test\/hotspot\/gtest\/utilities\/test_packedTable.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}