{"files":[{"patch":"@@ -5772,1 +5772,1 @@\n-    FieldInfoStream::create_FieldInfoStream(_temp_field_info, _java_fields_count,\n+    FieldInfoStream::create_FieldInfoStream(_cp, _temp_field_info, _java_fields_count,\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -304,1 +304,1 @@\n-    for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n@@ -464,1 +464,1 @@\n-          for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+          for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -966,1 +966,1 @@\n-      Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(fields, java_fields, injected_fields, k->class_loader_data(), CHECK);\n+      Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(ik->constants(), fields, java_fields, injected_fields, k->class_loader_data(), CHECK);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -815,0 +815,2 @@\n+                                                                          \\\n+  declare_constant(FieldInfoStream::SORTED_FIELD_TABLE_THRESHOLD)         \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -40,2 +41,4 @@\n-                _field_flags.is_injected() ? lookup_symbol(generic_signature_index())->as_utf8() : cp->symbol_at(generic_signature_index())->as_utf8(),\n-                contended_group());\n+                _field_flags.is_generic() ? (_field_flags.is_injected() ?\n+                  lookup_symbol(generic_signature_index())->as_utf8() : cp->symbol_at(generic_signature_index())->as_utf8()\n+                  ) : \"\",\n+                is_contended() ? contended_group() : 0);\n@@ -50,1 +53,19 @@\n-Array<u1>* FieldInfoStream::create_FieldInfoStream(GrowableArray<FieldInfo>* fields, int java_fields, int injected_fields,\n+int FieldInfoStream::compare_symbols(const Symbol *s1, const Symbol *s2) {\n+  \/\/ not lexicographical sort, since we need only total ordering\n+  int l1 = s1->utf8_length();\n+  int l2 = s2->utf8_length();\n+  if (l1 == l2) {\n+    for (int i = 0; i < l1; ++i) {\n+      char c1 = s1->char_at(i);\n+      char c2 = s2->char_at(i);\n+      if (c1 != c2) {\n+        return c1 - c2;\n+      }\n+    }\n+    return 0;\n+  } else {\n+    return l1 - l2;\n+  }\n+}\n+\n+Array<u1>* FieldInfoStream::create_FieldInfoStream(ConstantPool* constants, GrowableArray<FieldInfo>* fields, int java_fields, int injected_fields,\n@@ -53,1 +74,2 @@\n-  \/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields Field[j+k] End\n+  \/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields SortedFieldTable_offset(0\/4 bytes) Field[j+k] SortedFieldRecord[j] End\n+  \/\/   SortedFieldRecord := stream_position(2-3 bytes) field_index(1-2 bytes)\n@@ -67,3 +89,5 @@\n-  for (int i = 0; i < fields->length(); i++) {\n-    FieldInfo* fi = fields->adr_at(i);\n-    sizer.map_field_info(*fi);\n+  assert(fields->length() == java_fields + injected_fields, \"must be\");\n+  \/\/ We need to put JumpTable at end because the position of fields must not depend\n+  \/\/ on the size of JumpTable.\n+  if (java_fields > SORTED_FIELD_TABLE_THRESHOLD) {\n+    sizer.consumer()->accept_bytes(sizeof(uint32_t));\n@@ -71,1 +95,52 @@\n-  int storage_size = sizer.consumer()->position() + 1;\n+  ResourceMark rm;\n+  \/\/ We use both name and signature during the comparison; while JLS require unique\n+  \/\/ names for fields, JVMS requires only unique name + signature combination.\n+  typedef struct {\n+    Symbol *name;\n+    Symbol *signature;\n+    int index;\n+    int position;\n+  } field_pos_t;\n+  field_pos_t *positions = nullptr;\n+  int sorted_table_position_width = 0;\n+  int sorted_table_index_width = 0;\n+  int sorted_table_item_width = 0;\n+  if (java_fields > SORTED_FIELD_TABLE_THRESHOLD) {\n+    positions = NEW_RESOURCE_ARRAY(field_pos_t, java_fields);\n+    for (int i = 0; i < java_fields; ++i) {\n+      positions[i].name = fields->at(i).name(constants);\n+      positions[i].signature = fields->at(i).signature(constants);\n+      positions[i].index = i;\n+      positions[i].position = sizer.consumer()->position();\n+      sizer.map_field_info(fields->at(i));\n+    }\n+    for (int i = java_fields; i < fields->length(); ++i) {\n+      sizer.map_field_info(fields->at(i));\n+    }\n+    auto compare_pair = [](const void *v1, const void *v2) {\n+      int name_result = FieldInfoStream::compare_symbols(\n+        reinterpret_cast<const field_pos_t *>(v1)->name,\n+        reinterpret_cast<const field_pos_t *>(v2)->name);\n+      if (name_result != 0) {\n+        return name_result;\n+      }\n+      return FieldInfoStream::compare_symbols(\n+        reinterpret_cast<const field_pos_t *>(v1)->signature,\n+        reinterpret_cast<const field_pos_t *>(v2)->signature);\n+    };\n+    qsort(positions, java_fields, sizeof(field_pos_t), compare_pair);\n+\n+    \/\/ We use fixed width to let us skip through the table during binary search.\n+    \/\/ With the max of 65536 fields (and at most tens of bytes per field),\n+    \/\/ 3-byte offsets would suffice. In the common case with < 64kB stream 2-byte offsets are enough.\n+    sorted_table_position_width = sizer.consumer()->position() > (UINT16_MAX + 1) ? 3 : 2;\n+    sorted_table_index_width = java_fields > (UINT8_MAX + 1) ? 2 : 1;\n+    sorted_table_item_width = sorted_table_position_width + sorted_table_index_width;\n+  } else {\n+    for (int i = 0; i < fields->length(); ++i) {\n+      sizer.map_field_info(fields->at(i));\n+    }\n+  }\n+  \/\/ Originally there was an extra byte with 0 terminating the reading;\n+  \/\/ now we check limits instead as there may be the SortedTable\n+  int storage_size = sizer.consumer()->position() + java_fields * sorted_table_item_width;\n@@ -81,0 +156,4 @@\n+  int sorted_table_offset_pos = w.position();\n+  if (positions != nullptr) {\n+    w.set_position(w.position() + sizeof(uint32_t));\n+  }\n@@ -82,2 +161,20 @@\n-    FieldInfo* fi = fields->adr_at(i);\n-    writer.map_field_info(*fi);\n+    writer.map_field_info(fields->at(i));\n+  }\n+  if (java_fields > SORTED_FIELD_TABLE_THRESHOLD) {\n+    *reinterpret_cast<uint32_t*>(w.array()->adr_at(sorted_table_offset_pos)) = checked_cast<uint32_t>(w.position());\n+\n+    auto write_position = sorted_table_position_width == 2 ?\n+      [](u1 *ptr, int position) { *reinterpret_cast<u2*>(ptr) = checked_cast<u2>(position); } :\n+      [](u1 *ptr, int position) {\n+        ptr[0] = static_cast<u1>(position);\n+        ptr[1] = static_cast<u1>(position >> 8);\n+        ptr[2] = checked_cast<u1>(position >> 16);\n+      };\n+    auto write_index = sorted_table_index_width == 1 ?\n+      [](u1 *ptr, int index) { *ptr = checked_cast<u1>(index); } :\n+      [](u1 *ptr, int index) { *reinterpret_cast<u2 *>(ptr) = checked_cast<u2>(index); };\n+     for (int i = 0; i < java_fields; ++i) {\n+      u1 *ptr = w.array()->adr_at(w.position() + sorted_table_item_width * i);\n+      write_position(ptr, positions[i].position);\n+      write_index(ptr + sorted_table_position_width, positions[i].index);\n+    }\n@@ -88,1 +185,2 @@\n-  int jfc = r.next_uint();\n+  int jfc, ifc;\n+  r.read_field_counts(&jfc, &ifc);\n@@ -90,1 +188,0 @@\n-  int ifc = r.next_uint();\n@@ -117,2 +214,0 @@\n-  int length = FieldInfoStream::num_total_fields(fis);\n-  GrowableArray<FieldInfo>* array = new GrowableArray<FieldInfo>(length);\n@@ -120,2 +215,4 @@\n-  *java_fields_count = r.next_uint();\n-  *injected_fields_count = r.next_uint();\n+  r.read_field_counts(java_fields_count, injected_fields_count);\n+  int length = *java_fields_count + *injected_fields_count;\n+\n+  GrowableArray<FieldInfo>* array = new GrowableArray<FieldInfo>(length);\n@@ -128,1 +225,0 @@\n-  assert(array->length() == *java_fields_count + *injected_fields_count, \"Must be\");\n@@ -133,1 +229,0 @@\n-  int length = FieldInfoStream::num_total_fields(fis);\n@@ -135,2 +230,3 @@\n-  int java_field_count = r.next_uint();\n-  int injected_fields_count = r.next_uint();\n+  int java_fields_count;\n+  int injected_fields_count;\n+  r.read_field_counts(&java_fields_count, &injected_fields_count);\n@@ -143,0 +239,43 @@\n+\n+int FieldInfoReader::sorted_table_lookup(const Symbol *name, const Symbol *signature, ConstantPool *cp, int java_fields) {\n+  UNSIGNED5::Reader<const u1*, int> r2(_r.array());\n+  int low = 0, high = java_fields - 1;\n+  int table_offset = _r.limit();\n+  int position_width = (table_offset > UINT16_MAX + 1 ? 3 : 2);\n+  int item_width = position_width  + (java_fields > UINT8_MAX + 1 ? 2 : 1);\n+  auto read_position = table_offset > UINT16_MAX + 1 ?\n+    [](const u1 *ptr) { return (int) ptr[0] + (((int) ptr[1] << 8)) + (((int) ptr[2]) << 16); } :\n+    [](const u1 *ptr) { return (int) *reinterpret_cast<const u2 *>(ptr); };\n+  while (low <= high) {\n+    int mid = low + (high - low) \/ 2;\n+    const u1 *ptr = _r.array() + table_offset + item_width * mid;\n+    int position = read_position(ptr);\n+    r2.set_position(position);\n+    Symbol *mid_name = cp->symbol_at(checked_cast<u2>(r2.next_uint()));\n+    Symbol *mid_sig = cp->symbol_at(checked_cast<u2>(r2.next_uint()));\n+\n+    if (mid_name == name && mid_sig == signature) {\n+      _r.set_position(position);\n+      _next_index = java_fields > UINT8_MAX + 1 ?\n+        *reinterpret_cast<const u2 *>(ptr + position_width) : ptr[position_width];\n+      return _next_index;\n+    }\n+\n+    int cmp = FieldInfoStream::compare_symbols(name, mid_name);\n+    if (cmp < 0) {\n+      high = mid - 1;\n+      continue;\n+    } else if (cmp > 0) {\n+      low = mid + 1;\n+      continue;\n+    }\n+    cmp = FieldInfoStream::compare_symbols(signature, mid_sig);\n+    assert(cmp != 0, \"Equality check above did not match\");\n+    if (cmp < 0) {\n+      high = mid - 1;\n+    } else {\n+      low = mid + 1;\n+    }\n+  }\n+  return -1;\n+}\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":159,"deletions":20,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -223,1 +223,0 @@\n-\n@@ -226,5 +225,0 @@\n-  friend class FieldInfoStream;\n-  friend class ClassFileParser;\n-  friend class FieldStreamBase;\n-  friend class FieldInfo;\n-\n@@ -234,1 +228,1 @@\n-  public:\n+public:\n@@ -237,2 +231,1 @@\n-  private:\n-  uint32_t next_uint() { return _r.next_uint(); }\n+private:\n@@ -242,3 +235,4 @@\n-  int has_next() { return _r.has_next(); }\n-  int position() { return _r.position(); }\n-  int next_index() { return _next_index; }\n+  void read_field_counts(int *java_fields, int *injected_fields);\n+  int has_next() const { return _r.position() < _r.limit(); }\n+  int position() const { return _r.position(); }\n+  int next_index() const { return _next_index; }\n@@ -246,0 +240,3 @@\n+\n+  int sorted_table_lookup(const Symbol *name, const Symbol *signature, ConstantPool *cp, int java_fields);\n+\n@@ -260,1 +257,2 @@\n-\/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields Field[j+k] End\n+\/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields SortedFieldTable_offset(0\/4 bytes) Field[j+k] SortedFieldRecord[j] End\n+\/\/   SortedFieldRecord := stream_position(2-3 bytes) field_index(1-2 bytes)\n@@ -274,0 +272,3 @@\n+  \/\/ Don't generate the table for small classes at all.\n+  static const int SORTED_FIELD_TABLE_THRESHOLD = 16;\n+\n@@ -278,1 +279,3 @@\n-  static Array<u1>* create_FieldInfoStream(GrowableArray<FieldInfo>* fields, int java_fields, int injected_fields,\n+  static int compare_symbols(const Symbol *s1, const Symbol *s2);\n+\n+  static Array<u1>* create_FieldInfoStream(ConstantPool* constants, GrowableArray<FieldInfo>* fields, int java_fields, int injected_fields,\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -59,2 +59,4 @@\n-  fir.skip(1);\n-  return fir.next_uint();\n+  int java_fields_count;\n+  int injected_fields_count;\n+  fir.read_field_counts(&java_fields_count, &injected_fields_count);\n+  return injected_fields_count;\n@@ -65,1 +67,4 @@\n-  return fir.next_uint() + fir.next_uint();\n+  int java_fields_count;\n+  int injected_fields_count;\n+  fir.read_field_counts(&java_fields_count, &injected_fields_count);\n+  return java_fields_count + injected_fields_count;\n@@ -68,1 +73,7 @@\n-inline int FieldInfoStream::num_java_fields(const Array<u1>* fis) { return FieldInfoReader(fis).next_uint(); }\n+inline int FieldInfoStream::num_java_fields(const Array<u1>* fis) {\n+  FieldInfoReader fir(fis);\n+  int java_fields_count;\n+  int injected_fields_count;\n+  fir.read_field_counts(&java_fields_count, &injected_fields_count);\n+  return java_fields_count;\n+}\n@@ -97,1 +108,1 @@\n-  : _r(fi->data(), 0),\n+  : _r(fi->data(), fi->length()),\n@@ -100,0 +111,10 @@\n+inline void FieldInfoReader::read_field_counts(int *java_fields, int *injected_fields) {\n+  *java_fields = _r.next_uint();\n+  *injected_fields = _r.next_uint();\n+  if (*java_fields > FieldInfoStream::SORTED_FIELD_TABLE_THRESHOLD) {\n+    uint32_t sorted_table_offset = *reinterpret_cast<const uint32_t *>(_r.array() + _r.position());\n+    _r.set_limit(sorted_table_offset);\n+    _r.set_position(_r.position() + sizeof(uint32_t));\n+  }\n+}\n+\n@@ -102,5 +123,5 @@\n-  fi._name_index = checked_cast<u2>(next_uint());\n-  fi._signature_index = checked_cast<u2>(next_uint());\n-  fi._offset = next_uint();\n-  fi._access_flags = AccessFlags(checked_cast<u2>(next_uint()));\n-  fi._field_flags = FieldInfo::FieldFlags(next_uint());\n+  fi._name_index = checked_cast<u2>(_r.next_uint());\n+  fi._signature_index = checked_cast<u2>(_r.next_uint());\n+  fi._offset = _r.next_uint();\n+  fi._access_flags = AccessFlags(checked_cast<u2>(_r.next_uint()));\n+  fi._field_flags = FieldInfo::FieldFlags(_r.next_uint());\n@@ -108,1 +129,1 @@\n-    fi._initializer_index = checked_cast<u2>(next_uint());\n+    fi._initializer_index = checked_cast<u2>(_r.next_uint());\n@@ -113,1 +134,1 @@\n-    fi._generic_signature_index = checked_cast<u2>(next_uint());\n+    fi._generic_signature_index = checked_cast<u2>(_r.next_uint());\n@@ -118,1 +139,1 @@\n-    fi._contention_group = checked_cast<u2>(next_uint());\n+    fi._contention_group = checked_cast<u2>(_r.next_uint());\n@@ -128,1 +149,1 @@\n-  FieldInfo::FieldFlags ff(next_uint());\n+  FieldInfo::FieldFlags ff(_r.next_uint());\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":35,"deletions":14,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  inline FieldStreamBase(Array<u1>* fieldinfo_stream, ConstantPool* constants);\n+  inline FieldStreamBase(const Array<u1>* fieldinfo_stream, ConstantPool* constants);\n@@ -61,1 +61,1 @@\n-  private:\n+ private:\n@@ -63,2 +63,3 @@\n-    int java_fields_count = _reader.next_uint();\n-    int injected_fields_count = _reader.next_uint();\n+    int java_fields_count;\n+    int injected_fields_count;\n+    _reader.read_field_counts(&java_fields_count, &injected_fields_count);\n@@ -71,0 +72,1 @@\n+\n@@ -152,1 +154,0 @@\n-    return -1;\n@@ -167,0 +168,4 @@\n+\n+  \/\/ Performs either a linear search or binary search through the stream\n+  \/\/ looking for a matchin name\/signature combo\n+  bool lookup(const Symbol *name, const Symbol *signature);\n@@ -179,1 +184,0 @@\n-  AllFieldStream(Array<u1>* fieldinfo, ConstantPool* constants): FieldStreamBase(fieldinfo, constants) {}\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-FieldStreamBase::FieldStreamBase(Array<u1>* fieldinfo_stream, ConstantPool* constants) :\n+FieldStreamBase::FieldStreamBase(const Array<u1>* fieldinfo_stream, ConstantPool* constants) :\n@@ -65,0 +65,19 @@\n+inline bool JavaFieldStream::lookup(const Symbol *name, const Symbol *signature) {\n+  if (_limit > FieldInfoStream::SORTED_FIELD_TABLE_THRESHOLD) {\n+    int index = _reader.sorted_table_lookup(name, signature, _constants(), _limit);\n+    if (index >= 0) {\n+      assert(index < _limit, \"must be\");\n+      _index = index;\n+      _reader.read_field_info(_fi_buf);\n+      return true;\n+    }\n+  } else {\n+    for (; !done(); next()) {\n+      if (this->name() == name && this->signature() == signature) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.inline.hpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1783,7 +1783,6 @@\n-  for (JavaFieldStream fs(this); !fs.done(); fs.next()) {\n-    Symbol* f_name = fs.name();\n-    Symbol* f_sig  = fs.signature();\n-    if (f_name == name && f_sig == sig) {\n-      fd->reinitialize(const_cast<InstanceKlass*>(this), fs.to_FieldInfo());\n-      return true;\n-    }\n+  JavaFieldStream fs(this);\n+  if (fs.lookup(name, sig)) {\n+    assert(fs.name() == name, \"name must match\");\n+    assert(fs.signature() == sig, \"signature must match\");\n+    fd->reinitialize(const_cast<InstanceKlass*>(this), fs.to_FieldInfo());\n+    return true;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3558,1 +3558,1 @@\n-    Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(fields, java_fields, injected_fields, scratch_class->class_loader_data(), CHECK);\n+    Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(cp, fields, java_fields, injected_fields, scratch_class->class_loader_data(), CHECK);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-    int next_length() {\n+    int next_length() const {\n@@ -273,1 +273,1 @@\n-    bool has_next() {\n+    bool has_next() const {\n@@ -287,2 +287,3 @@\n-    OFF limit() { return _limit; }\n-    OFF position() { return _position; }\n+    OFF limit() const { return _limit; }\n+    OFF position() const { return _position; }\n+    void set_limit(OFF limit) { _limit = limit; }\n@@ -394,0 +395,3 @@\n+    void accept_bytes(OFF bytes) {\n+      _position += bytes;\n+    }\n","filename":"src\/hotspot\/share\/utilities\/unsigned5.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -66,0 +66,4 @@\n+  public void skipBytes(int bytes) {\n+    this.position += bytes;\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CompressedStream.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+  private static final int SORTED_FIELD_TABLE_THRESHOLD =\n+    VM.getVM().getTypeDataBase().lookupIntConstant(\"FieldInfoStream::SORTED_FIELD_TABLE_THRESHOLD\");\n@@ -114,0 +116,5 @@\n+    \/\/ Sorted fields table is generated only for classes with > 16 (non-injected) fields\n+    if (numJavaFields > SORTED_FIELD_TABLE_THRESHOLD) {\n+      \/\/ Sorted field table offset offset (is not variable-size encoded)\n+      crs.skipBytes(4);\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Field.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}