{"files":[{"patch":"@@ -1480,0 +1480,44 @@\n+  if (length > JUMP_TABLE_STRIDE) {\n+    \/\/ We need to reorder the fields deterministically right after parsing,\n+    \/\/ as the FieldLayout is partially dependend on the order of fields\n+    \/\/ in the stream. Had we sorted only later, the field layout could be\n+    \/\/ different after RedefineClass and some assertions would fail.\n+    \/\/ Also the annotations defined on the fields (and it types) are linked\n+    \/\/ only through the order of fields, so we need to reorder these arrays\n+    \/\/ in sync.\n+    typedef struct {\n+      Symbol *symbol;\n+      int src;\n+      int target;\n+    } order_mapping_t;\n+    order_mapping_t *order_mapping = NEW_RESOURCE_ARRAY(order_mapping_t, length);\n+    for (int i = 0; i < length; ++i) {\n+      order_mapping[i].symbol = _temp_field_info->at(i).name(_cp);\n+      order_mapping[i].src = i;\n+    }\n+    \/\/ Reorder fields based on FieldInfoStream::compare_symbols\n+    auto compare_pair = [](const void *v1, const void *v2) {\n+      return FieldInfoStream::compare_symbols(reinterpret_cast<const order_mapping_t *>(v1)->symbol,\n+        reinterpret_cast<const order_mapping_t *>(v2)->symbol);\n+    };\n+    qsort(order_mapping, length, sizeof(order_mapping_t), compare_pair);\n+    \/\/ create reverse permutation in target\n+    for (int i = 0; i < length; ++i) {\n+      order_mapping[order_mapping[i].src].target = i;\n+    }\n+    \/\/ do the final move in-place\n+    for (int i = 0; i < length; ++i) {\n+      while (order_mapping[i].target != i) {\n+        int target = order_mapping[i].target;\n+        swap(_temp_field_info->at(i), _temp_field_info->at(target));\n+        if (_fields_annotations != nullptr) {\n+          _fields_annotations->swap(i, target);\n+        }\n+        if (_fields_type_annotations != nullptr) {\n+          _fields_type_annotations->swap(i, target);\n+        }\n+        swap(order_mapping[i], order_mapping[target]);\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -130,0 +130,7 @@\n+  void swap(int i, int j) {\n+    assert(i >= 0 && i < _length, \"oob: 0 <= %d < %d\", i, _length);\n+    assert(j >= 0 && j < _length, \"oob: 0 <= %d < %d\", j, _length);\n+    T t = data()[i];\n+    data()[i] = data()[j];\n+    data()[j] = t;\n+  }\n","filename":"src\/hotspot\/share\/oops\/array.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-static int compare_symbols(const Symbol *s1, const Symbol *s2) {\n+int FieldInfoStream::compare_symbols(const Symbol *s1, const Symbol *s2) {\n@@ -69,5 +69,0 @@\n-static int compare_fields(const FieldInfo *f1, const FieldInfo *f2, void *arg) {\n-  ConstantPool* cp = static_cast<ConstantPool*>(arg);\n-  return compare_symbols(f1->name(cp), f2->name(cp));\n-}\n-\n@@ -86,0 +81,1 @@\n+#ifdef ASSERT\n@@ -87,1 +83,3 @@\n-    fields->sort_range(0, java_fields, compare_fields, constants);\n+    for (int i = 1; i < java_fields; ++i) {\n+      assert(compare_symbols(fields->adr_at(i - 1)->name(constants), fields->adr_at(i)->name(constants)) < 0, \"Fields should be sorted\");\n+    }\n@@ -89,0 +87,1 @@\n+#endif\n@@ -215,1 +214,1 @@\n-    if (compare_symbols(name, sym) < 0) {\n+    if (FieldInfoStream::compare_symbols(name, sym) < 0) {\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -288,0 +288,2 @@\n+  static int compare_symbols(const Symbol *s1, const Symbol *s2);\n+\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -313,8 +313,0 @@\n-  \/\/ end is exclusive\n-  void sort_range(int start, int end, int f(const E*, const E*, void *), void *arg) {\n-    if (_data == nullptr) return;\n-    assert(start >= 0, \"start is negative\");\n-    assert(end <= length(), \"range too long\");\n-    qsort_r(_data + start, end - start, sizeof(E), (__compar_d_fn_t)f, arg);\n-  }\n-\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -114,1 +114,5 @@\n-    crs.skipBytes(numJavaFields > 16 ? 4 : 0);\n+    \/\/ JumpTable is generated only for classes with > 16 (non-injected) fields\n+    if (numJavaFields > 16) {\n+      \/\/ JumpTable offset (is not variable-size encoded)\n+      crs.skipBytes(4);\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Field.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -53,1 +55,1 @@\n-        int next = 0;       \/\/ indexes start at zero\n+        Map<Integer, String> map = new HashMap<>();\n@@ -64,1 +66,1 @@\n-                    Assert.assertEquals(ndx, next, \"index value wrong\");\n+                    Assert.assertNull(map.put(ndx, name), \"index should be unique\");\n@@ -66,1 +68,1 @@\n-                        fixedLength = next;     \/\/ remember for final check\n+                        fixedLength = ndx;     \/\/ remember for final check\n@@ -68,1 +70,0 @@\n-                    next++;\n@@ -76,1 +77,5 @@\n-        Assert.assertEquals(next - 1, fixedLength,\n+        int min = map.keySet().stream().mapToInt(i -> i).min().orElseThrow();\n+        int max = map.keySet().stream().mapToInt(i -> i).max().orElseThrow();\n+        Assert.assertEquals(min, 0, \"Should start with 0\");\n+        Assert.assertEquals(map.size(), max + 1, \"Should have unique items\");\n+        Assert.assertEquals(max, fixedLength,\n","filename":"test\/jdk\/java\/lang\/System\/VerifyRawIndexesTest.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"}]}