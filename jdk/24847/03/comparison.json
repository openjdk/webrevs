{"files":[{"patch":"@@ -1480,0 +1480,44 @@\n+  if (length > JUMP_TABLE_STRIDE) {\n+    \/\/ We need to reorder the fields deterministically right after parsing,\n+    \/\/ as the FieldLayout is partially dependend on the order of fields\n+    \/\/ in the stream. Had we sorted only later, the field layout could be\n+    \/\/ different after RedefineClass and some assertions would fail.\n+    \/\/ Also the annotations defined on the fields (and it types) are linked\n+    \/\/ only through the order of fields, so we need to reorder these arrays\n+    \/\/ in sync.\n+    typedef struct {\n+      Symbol *symbol;\n+      int src;\n+      int target;\n+    } order_mapping_t;\n+    order_mapping_t *order_mapping = NEW_RESOURCE_ARRAY(order_mapping_t, length);\n+    for (int i = 0; i < length; ++i) {\n+      order_mapping[i].symbol = _temp_field_info->at(i).name(_cp);\n+      order_mapping[i].src = i;\n+    }\n+    \/\/ Reorder fields based on FieldInfoStream::compare_symbols\n+    auto compare_pair = [](const void *v1, const void *v2) {\n+      return FieldInfoStream::compare_symbols(reinterpret_cast<const order_mapping_t *>(v1)->symbol,\n+        reinterpret_cast<const order_mapping_t *>(v2)->symbol);\n+    };\n+    qsort(order_mapping, length, sizeof(order_mapping_t), compare_pair);\n+    \/\/ create reverse permutation in target\n+    for (int i = 0; i < length; ++i) {\n+      order_mapping[order_mapping[i].src].target = i;\n+    }\n+    \/\/ do the final move in-place\n+    for (int i = 0; i < length; ++i) {\n+      while (order_mapping[i].target != i) {\n+        int target = order_mapping[i].target;\n+        swap(_temp_field_info->at(i), _temp_field_info->at(target));\n+        if (_fields_annotations != nullptr) {\n+          _fields_annotations->swap(i, target);\n+        }\n+        if (_fields_type_annotations != nullptr) {\n+          _fields_type_annotations->swap(i, target);\n+        }\n+        swap(order_mapping[i], order_mapping[target]);\n+      }\n+    }\n+  }\n+\n@@ -5772,1 +5816,1 @@\n-    FieldInfoStream::create_FieldInfoStream(_temp_field_info, _java_fields_count,\n+    FieldInfoStream::create_FieldInfoStream(_cp, _temp_field_info, _java_fields_count,\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -304,1 +304,1 @@\n-    for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n@@ -464,1 +464,1 @@\n-          for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+          for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -966,1 +966,1 @@\n-      Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(fields, java_fields, injected_fields, k->class_loader_data(), CHECK);\n+      Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(ik->constants(), fields, java_fields, injected_fields, k->class_loader_data(), CHECK);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,0 +130,7 @@\n+  void swap(int i, int j) {\n+    assert(i >= 0 && i < _length, \"oob: 0 <= %d < %d\", i, _length);\n+    assert(j >= 0 && j < _length, \"oob: 0 <= %d < %d\", j, _length);\n+    T t = data()[i];\n+    data()[i] = data()[j];\n+    data()[j] = t;\n+  }\n","filename":"src\/hotspot\/share\/oops\/array.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -50,1 +51,19 @@\n-Array<u1>* FieldInfoStream::create_FieldInfoStream(GrowableArray<FieldInfo>* fields, int java_fields, int injected_fields,\n+int FieldInfoStream::compare_symbols(const Symbol *s1, const Symbol *s2) {\n+  \/\/ not lexicographical sort, since we need only total ordering\n+  int l1 = s1->utf8_length();\n+  int l2 = s2->utf8_length();\n+  if (l1 == l2) {\n+    for (int i = 0; i < l1; ++i) {\n+      char c1 = s1->char_at(i);\n+      char c2 = s2->char_at(i);\n+      if (c1 != c2) {\n+        return c1 - c2;\n+      }\n+    }\n+    return 0;\n+  } else {\n+    return l1 - l2;\n+  }\n+}\n+\n+Array<u1>* FieldInfoStream::create_FieldInfoStream(ConstantPool* constants, GrowableArray<FieldInfo>* fields, int java_fields, int injected_fields,\n@@ -53,1 +72,2 @@\n-  \/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields Field[j+k] End\n+  \/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields JumpTable_offset(0\/4 bytes) Field[j+k] JumpTable[(j - 1)\/16 > 0] End\n+  \/\/   JumpTable := stream_index[(j - 1)\/16]\n@@ -60,0 +80,9 @@\n+  \/\/ We create JumpTable only for java_fields; JavaFieldStream relies on non-injected fields preceding injected\n+#ifdef ASSERT\n+  if (java_fields > JUMP_TABLE_STRIDE) {\n+    for (int i = 1; i < java_fields; ++i) {\n+      assert(compare_symbols(fields->adr_at(i - 1)->name(constants), fields->adr_at(i)->name(constants)) < 0, \"Fields should be sorted\");\n+    }\n+  }\n+#endif\n+\n@@ -67,0 +96,8 @@\n+  assert(fields->length() == java_fields + injected_fields, \"must be\");\n+  \/\/ We need to put JumpTable at end because the position of fields must not depend\n+  \/\/ on the size of JumpTable.\n+  if (java_fields > JUMP_TABLE_STRIDE) {\n+    sizer.consumer()->accept_bytes(sizeof(uint32_t));\n+  }\n+  ResourceMark rm;\n+  int *positions = java_fields > JUMP_TABLE_STRIDE ? NEW_RESOURCE_ARRAY(int, (java_fields - 1) \/ JUMP_TABLE_STRIDE) : nullptr;\n@@ -68,0 +105,3 @@\n+    if (i > 0 && i < java_fields && i % JUMP_TABLE_STRIDE == 0) {\n+      positions[i \/ JUMP_TABLE_STRIDE - 1] = sizer.consumer()->position();\n+    }\n@@ -71,1 +111,6 @@\n-  int storage_size = sizer.consumer()->position() + 1;\n+  for (int i = JUMP_TABLE_STRIDE; i < java_fields; i += JUMP_TABLE_STRIDE) {\n+    sizer.consumer()->accept_uint(positions[i \/ JUMP_TABLE_STRIDE - 1]);\n+  }\n+  \/\/ Originally there was an extra byte with 0 terminating the reading;\n+  \/\/ no we check limits instead as there may be the JumpTable\n+  int storage_size = sizer.consumer()->position();\n@@ -81,0 +126,4 @@\n+  int jump_table_offset_pos = w.position();\n+  if (java_fields > JUMP_TABLE_STRIDE) {\n+    w.set_position(w.position() + sizeof(uint32_t));\n+  }\n@@ -83,0 +132,2 @@\n+    assert(i == 0 || i >= java_fields || i % JUMP_TABLE_STRIDE != 0 ||\n+      w.position() == positions[i \/ JUMP_TABLE_STRIDE - 1], \"must be\");\n@@ -85,0 +136,6 @@\n+  if (java_fields > JUMP_TABLE_STRIDE) {\n+    *reinterpret_cast<uint32_t*>(w.array()->adr_at(jump_table_offset_pos)) = checked_cast<uint32_t>(w.position());\n+  }\n+  for (int i = JUMP_TABLE_STRIDE; i < java_fields; i += JUMP_TABLE_STRIDE) {\n+    writer.consumer()->accept_uint(positions[i \/ JUMP_TABLE_STRIDE - 1]);\n+  }\n@@ -88,1 +145,2 @@\n-  int jfc = r.next_uint();\n+  int jfc, ifc;\n+  r.read_field_counts(&jfc, &ifc);\n@@ -90,1 +148,0 @@\n-  int ifc = r.next_uint();\n@@ -117,2 +174,0 @@\n-  int length = FieldInfoStream::num_total_fields(fis);\n-  GrowableArray<FieldInfo>* array = new GrowableArray<FieldInfo>(length);\n@@ -120,2 +175,4 @@\n-  *java_fields_count = r.next_uint();\n-  *injected_fields_count = r.next_uint();\n+  r.read_field_counts(java_fields_count, injected_fields_count);\n+  int length = *java_fields_count + *injected_fields_count;\n+\n+  GrowableArray<FieldInfo>* array = new GrowableArray<FieldInfo>(length);\n@@ -128,1 +185,0 @@\n-  assert(array->length() == *java_fields_count + *injected_fields_count, \"Must be\");\n@@ -133,1 +189,0 @@\n-  int length = FieldInfoStream::num_total_fields(fis);\n@@ -135,2 +190,3 @@\n-  int java_field_count = r.next_uint();\n-  int injected_fields_count = r.next_uint();\n+  int java_fields_count;\n+  int injected_fields_count;\n+  r.read_field_counts(&java_fields_count, &injected_fields_count);\n@@ -143,0 +199,27 @@\n+\n+int FieldInfoReader::skip_fields_until(const Symbol *name, ConstantPool *cp, int java_fields) {\n+  int jump_table_size = (java_fields - 1) \/ JUMP_TABLE_STRIDE;\n+  if (jump_table_size == 0) {\n+    return -1;\n+  }\n+  int field_pos = -1;\n+  int field_index = -1;\n+  UNSIGNED5::Reader<const u1*, int> r2(_r.array());\n+  r2.set_position(_r.limit());\n+  for (int i = 0; i < jump_table_size; ++i) {\n+    int pos = r2.next_uint();\n+    int pos2 = pos; \/\/ read_uint updates this by reference\n+    uint32_t name_index = UNSIGNED5::read_uint<const u1 *, int>(_r.array(), pos2, _r.limit());\n+    Symbol *sym = cp->symbol_at(name_index);\n+    if (FieldInfoStream::compare_symbols(name, sym) < 0) {\n+      break;\n+    }\n+    field_pos = pos;\n+    field_index = (i + 1) * JUMP_TABLE_STRIDE;\n+  }\n+  if (field_pos >= 0) {\n+    _r.set_position(field_pos);\n+    _next_index = field_index;\n+  }\n+  return field_index;\n+}\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":96,"deletions":13,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -223,0 +223,1 @@\n+#define JUMP_TABLE_STRIDE 16\n@@ -226,5 +227,0 @@\n-  friend class FieldInfoStream;\n-  friend class ClassFileParser;\n-  friend class FieldStreamBase;\n-  friend class FieldInfo;\n-\n@@ -234,1 +230,1 @@\n-  public:\n+public:\n@@ -237,2 +233,1 @@\n-  private:\n-  uint32_t next_uint() { return _r.next_uint(); }\n+private:\n@@ -242,3 +237,12 @@\n-  int has_next() { return _r.has_next(); }\n-  int position() { return _r.position(); }\n-  int next_index() { return _next_index; }\n+  void read_field_counts(int *java_fields, int *injected_fields) {\n+    *java_fields = _r.next_uint();\n+    *injected_fields = _r.next_uint();\n+    if (*java_fields > JUMP_TABLE_STRIDE) {\n+      uint32_t jumptable_offset = *reinterpret_cast<const uint32_t *>(_r.array() + _r.position());\n+      _r.set_limit(jumptable_offset);\n+      _r.set_position(_r.position() + sizeof(uint32_t));\n+    }\n+  }\n+  int has_next() const { return _r.position() < _r.limit(); }\n+  int position() const { return _r.position(); }\n+  int next_index() const { return _next_index; }\n@@ -246,0 +250,5 @@\n+\n+  \/\/ Skips java fields based on condensed info in the jump table;\n+  \/\/ stops at a point before first field with matching name.\n+  int skip_fields_until(const Symbol *name, ConstantPool *cp, int java_fields);\n+\n@@ -260,1 +269,2 @@\n-\/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields Field[j+k] End\n+\/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields JumpTable_offset(0\/4 bytes) Field[j+k] JumpTable[(j - 1)\/16 > 0] End\n+\/\/   JumpTable := stream_index[(j - 1)\/16]\n@@ -278,1 +288,3 @@\n-  static Array<u1>* create_FieldInfoStream(GrowableArray<FieldInfo>* fields, int java_fields, int injected_fields,\n+  static int compare_symbols(const Symbol *s1, const Symbol *s2);\n+\n+  static Array<u1>* create_FieldInfoStream(ConstantPool* constants, GrowableArray<FieldInfo>* fields, int java_fields, int injected_fields,\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -59,2 +59,4 @@\n-  fir.skip(1);\n-  return fir.next_uint();\n+  int java_fields_count;\n+  int injected_fields_count;\n+  fir.read_field_counts(&java_fields_count, &injected_fields_count);\n+  return injected_fields_count;\n@@ -65,1 +67,4 @@\n-  return fir.next_uint() + fir.next_uint();\n+  int java_fields_count;\n+  int injected_fields_count;\n+  fir.read_field_counts(&java_fields_count, &injected_fields_count);\n+  return java_fields_count + injected_fields_count;\n@@ -68,1 +73,7 @@\n-inline int FieldInfoStream::num_java_fields(const Array<u1>* fis) { return FieldInfoReader(fis).next_uint(); }\n+inline int FieldInfoStream::num_java_fields(const Array<u1>* fis) {\n+  FieldInfoReader fir(fis);\n+  int java_fields_count;\n+  int injected_fields_count;\n+  fir.read_field_counts(&java_fields_count, &injected_fields_count);\n+  return java_fields_count;\n+}\n@@ -97,1 +108,1 @@\n-  : _r(fi->data(), 0),\n+  : _r(fi->data(), fi->length()),\n@@ -102,5 +113,5 @@\n-  fi._name_index = checked_cast<u2>(next_uint());\n-  fi._signature_index = checked_cast<u2>(next_uint());\n-  fi._offset = next_uint();\n-  fi._access_flags = AccessFlags(checked_cast<u2>(next_uint()));\n-  fi._field_flags = FieldInfo::FieldFlags(next_uint());\n+  fi._name_index = checked_cast<u2>(_r.next_uint());\n+  fi._signature_index = checked_cast<u2>(_r.next_uint());\n+  fi._offset = _r.next_uint();\n+  fi._access_flags = AccessFlags(checked_cast<u2>(_r.next_uint()));\n+  fi._field_flags = FieldInfo::FieldFlags(_r.next_uint());\n@@ -108,1 +119,1 @@\n-    fi._initializer_index = checked_cast<u2>(next_uint());\n+    fi._initializer_index = checked_cast<u2>(_r.next_uint());\n@@ -113,1 +124,1 @@\n-    fi._generic_signature_index = checked_cast<u2>(next_uint());\n+    fi._generic_signature_index = checked_cast<u2>(_r.next_uint());\n@@ -118,1 +129,1 @@\n-    fi._contention_group = checked_cast<u2>(next_uint());\n+    fi._contention_group = checked_cast<u2>(_r.next_uint());\n@@ -128,1 +139,1 @@\n-  FieldInfo::FieldFlags ff(next_uint());\n+  FieldInfo::FieldFlags ff(_r.next_uint());\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":25,"deletions":14,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  inline FieldStreamBase(Array<u1>* fieldinfo_stream, ConstantPool* constants);\n+  inline FieldStreamBase(const Array<u1>* fieldinfo_stream, ConstantPool* constants);\n@@ -61,1 +61,1 @@\n-  private:\n+ private:\n@@ -63,2 +63,3 @@\n-    int java_fields_count = _reader.next_uint();\n-    int injected_fields_count = _reader.next_uint();\n+    int java_fields_count;\n+    int injected_fields_count;\n+    _reader.read_field_counts(&java_fields_count, &injected_fields_count);\n@@ -71,0 +72,1 @@\n+\n@@ -152,1 +154,0 @@\n-    return -1;\n@@ -167,0 +168,2 @@\n+\n+  void skip_fields_until(const Symbol *name, ConstantPool *cp);\n@@ -179,1 +182,0 @@\n-  AllFieldStream(Array<u1>* fieldinfo, ConstantPool* constants): FieldStreamBase(fieldinfo, constants) {}\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-FieldStreamBase::FieldStreamBase(Array<u1>* fieldinfo_stream, ConstantPool* constants) :\n+FieldStreamBase::FieldStreamBase(const Array<u1>* fieldinfo_stream, ConstantPool* constants) :\n@@ -65,0 +65,13 @@\n+inline void JavaFieldStream::skip_fields_until(const Symbol *name, ConstantPool *cp) {\n+  if (done()) {\n+    return;\n+  }\n+  int index = _reader.skip_fields_until(name, cp, _limit);\n+  if (index < 0) {\n+    return;\n+  }\n+  assert(index > 0 && index < _limit && index % JUMP_TABLE_STRIDE == 0, \"must be\");\n+  _index = index;\n+  _reader.read_field_info(_fi_buf);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.inline.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1783,1 +1783,3 @@\n-  for (JavaFieldStream fs(this); !fs.done(); fs.next()) {\n+  JavaFieldStream fs(this);\n+  fs.skip_fields_until(name, constants());\n+  for (; !fs.done(); fs.next()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3558,1 +3558,1 @@\n-    Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(fields, java_fields, injected_fields, scratch_class->class_loader_data(), CHECK);\n+    Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(cp, fields, java_fields, injected_fields, scratch_class->class_loader_data(), CHECK);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-    int next_length() {\n+    int next_length() const {\n@@ -273,1 +273,1 @@\n-    bool has_next() {\n+    bool has_next() const {\n@@ -287,2 +287,3 @@\n-    OFF limit() { return _limit; }\n-    OFF position() { return _position; }\n+    OFF limit() const { return _limit; }\n+    OFF position() const { return _position; }\n+    void set_limit(OFF limit) { _limit = limit; }\n@@ -394,0 +395,3 @@\n+    void accept_bytes(OFF bytes) {\n+      _position += bytes;\n+    }\n","filename":"src\/hotspot\/share\/utilities\/unsigned5.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -66,0 +66,4 @@\n+  public void skipBytes(int bytes) {\n+    this.position += bytes;\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CompressedStream.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+  private static final int JUMP_TABLE_SIZE = 16;\n@@ -114,0 +115,5 @@\n+    \/\/ JumpTable is generated only for classes with > 16 (non-injected) fields\n+    if (numJavaFields > JUMP_TABLE_SIZE) {\n+      \/\/ JumpTable offset (is not variable-size encoded)\n+      crs.skipBytes(4);\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Field.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -53,1 +55,1 @@\n-        int next = 0;       \/\/ indexes start at zero\n+        Map<Integer, String> map = new HashMap<>();\n@@ -64,1 +66,1 @@\n-                    Assert.assertEquals(ndx, next, \"index value wrong\");\n+                    Assert.assertNull(map.put(ndx, name), \"index should be unique\");\n@@ -66,1 +68,1 @@\n-                        fixedLength = next;     \/\/ remember for final check\n+                        fixedLength = ndx;     \/\/ remember for final check\n@@ -68,1 +70,0 @@\n-                    next++;\n@@ -76,1 +77,5 @@\n-        Assert.assertEquals(next - 1, fixedLength,\n+        int min = map.keySet().stream().mapToInt(i -> i).min().orElseThrow();\n+        int max = map.keySet().stream().mapToInt(i -> i).max().orElseThrow();\n+        Assert.assertEquals(min, 0, \"Should start with 0\");\n+        Assert.assertEquals(map.size(), max + 1, \"Should have unique items\");\n+        Assert.assertEquals(max, fixedLength,\n","filename":"test\/jdk\/java\/lang\/System\/VerifyRawIndexesTest.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"}]}