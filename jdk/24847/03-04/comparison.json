{"files":[{"patch":"@@ -1480,44 +1480,0 @@\n-  if (length > JUMP_TABLE_STRIDE) {\n-    \/\/ We need to reorder the fields deterministically right after parsing,\n-    \/\/ as the FieldLayout is partially dependend on the order of fields\n-    \/\/ in the stream. Had we sorted only later, the field layout could be\n-    \/\/ different after RedefineClass and some assertions would fail.\n-    \/\/ Also the annotations defined on the fields (and it types) are linked\n-    \/\/ only through the order of fields, so we need to reorder these arrays\n-    \/\/ in sync.\n-    typedef struct {\n-      Symbol *symbol;\n-      int src;\n-      int target;\n-    } order_mapping_t;\n-    order_mapping_t *order_mapping = NEW_RESOURCE_ARRAY(order_mapping_t, length);\n-    for (int i = 0; i < length; ++i) {\n-      order_mapping[i].symbol = _temp_field_info->at(i).name(_cp);\n-      order_mapping[i].src = i;\n-    }\n-    \/\/ Reorder fields based on FieldInfoStream::compare_symbols\n-    auto compare_pair = [](const void *v1, const void *v2) {\n-      return FieldInfoStream::compare_symbols(reinterpret_cast<const order_mapping_t *>(v1)->symbol,\n-        reinterpret_cast<const order_mapping_t *>(v2)->symbol);\n-    };\n-    qsort(order_mapping, length, sizeof(order_mapping_t), compare_pair);\n-    \/\/ create reverse permutation in target\n-    for (int i = 0; i < length; ++i) {\n-      order_mapping[order_mapping[i].src].target = i;\n-    }\n-    \/\/ do the final move in-place\n-    for (int i = 0; i < length; ++i) {\n-      while (order_mapping[i].target != i) {\n-        int target = order_mapping[i].target;\n-        swap(_temp_field_info->at(i), _temp_field_info->at(target));\n-        if (_fields_annotations != nullptr) {\n-          _fields_annotations->swap(i, target);\n-        }\n-        if (_fields_type_annotations != nullptr) {\n-          _fields_type_annotations->swap(i, target);\n-        }\n-        swap(order_mapping[i], order_mapping[target]);\n-      }\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -815,0 +815,2 @@\n+                                                                          \\\n+  declare_constant(FieldInfoStream::SORTED_FIELD_TABLE_THRESHOLD)         \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,7 +130,0 @@\n-  void swap(int i, int j) {\n-    assert(i >= 0 && i < _length, \"oob: 0 <= %d < %d\", i, _length);\n-    assert(j >= 0 && j < _length, \"oob: 0 <= %d < %d\", j, _length);\n-    T t = data()[i];\n-    data()[i] = data()[j];\n-    data()[j] = t;\n-  }\n","filename":"src\/hotspot\/share\/oops\/array.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,2 +41,4 @@\n-                _field_flags.is_injected() ? lookup_symbol(generic_signature_index())->as_utf8() : cp->symbol_at(generic_signature_index())->as_utf8(),\n-                contended_group());\n+                _field_flags.is_generic() ? (_field_flags.is_injected() ?\n+                  lookup_symbol(generic_signature_index())->as_utf8() : cp->symbol_at(generic_signature_index())->as_utf8()\n+                  ) : \"\",\n+                is_contended() ? contended_group() : 0);\n@@ -72,2 +74,2 @@\n-  \/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields JumpTable_offset(0\/4 bytes) Field[j+k] JumpTable[(j - 1)\/16 > 0] End\n-  \/\/   JumpTable := stream_index[(j - 1)\/16]\n+  \/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields SortedFieldTable_offset(0\/4 bytes) Field[j+k] SortedFieldRecord[j] End\n+  \/\/   SortedFieldRecord := stream_position(2-3 bytes) field_index(1-2 bytes)\n@@ -80,9 +82,0 @@\n-  \/\/ We create JumpTable only for java_fields; JavaFieldStream relies on non-injected fields preceding injected\n-#ifdef ASSERT\n-  if (java_fields > JUMP_TABLE_STRIDE) {\n-    for (int i = 1; i < java_fields; ++i) {\n-      assert(compare_symbols(fields->adr_at(i - 1)->name(constants), fields->adr_at(i)->name(constants)) < 0, \"Fields should be sorted\");\n-    }\n-  }\n-#endif\n-\n@@ -99,1 +92,1 @@\n-  if (java_fields > JUMP_TABLE_STRIDE) {\n+  if (java_fields > SORTED_FIELD_TABLE_THRESHOLD) {\n@@ -103,4 +96,46 @@\n-  int *positions = java_fields > JUMP_TABLE_STRIDE ? NEW_RESOURCE_ARRAY(int, (java_fields - 1) \/ JUMP_TABLE_STRIDE) : nullptr;\n-  for (int i = 0; i < fields->length(); i++) {\n-    if (i > 0 && i < java_fields && i % JUMP_TABLE_STRIDE == 0) {\n-      positions[i \/ JUMP_TABLE_STRIDE - 1] = sizer.consumer()->position();\n+  \/\/ We use both name and signature during the comparison; while JLS require unique\n+  \/\/ names for fields, JVMS requires only unique name + signature combination.\n+  typedef struct {\n+    Symbol *name;\n+    Symbol *signature;\n+    int index;\n+    int position;\n+  } field_pos_t;\n+  field_pos_t *positions = nullptr;\n+  int sorted_table_position_width = 0;\n+  int sorted_table_index_width = 0;\n+  int sorted_table_item_width = 0;\n+  if (java_fields > SORTED_FIELD_TABLE_THRESHOLD) {\n+    positions = NEW_RESOURCE_ARRAY(field_pos_t, java_fields);\n+    for (int i = 0; i < java_fields; ++i) {\n+      positions[i].name = fields->at(i).name(constants);\n+      positions[i].signature = fields->at(i).signature(constants);\n+      positions[i].index = i;\n+      positions[i].position = sizer.consumer()->position();\n+      sizer.map_field_info(fields->at(i));\n+    }\n+    for (int i = java_fields; i < fields->length(); ++i) {\n+      sizer.map_field_info(fields->at(i));\n+    }\n+    auto compare_pair = [](const void *v1, const void *v2) {\n+      int name_result = FieldInfoStream::compare_symbols(\n+        reinterpret_cast<const field_pos_t *>(v1)->name,\n+        reinterpret_cast<const field_pos_t *>(v2)->name);\n+      if (name_result != 0) {\n+        return name_result;\n+      }\n+      return FieldInfoStream::compare_symbols(\n+        reinterpret_cast<const field_pos_t *>(v1)->signature,\n+        reinterpret_cast<const field_pos_t *>(v2)->signature);\n+    };\n+    qsort(positions, java_fields, sizeof(field_pos_t), compare_pair);\n+\n+    \/\/ We use fixed width to let us skip through the table during binary search.\n+    \/\/ With the max of 65536 fields (and at most tens of bytes per field),\n+    \/\/ 3-byte offsets would suffice. In the common case with < 64kB stream 2-byte offsets are enough.\n+    sorted_table_position_width = sizer.consumer()->position() > (UINT16_MAX + 1) ? 3 : 2;\n+    sorted_table_index_width = java_fields > (UINT8_MAX + 1) ? 2 : 1;\n+    sorted_table_item_width = sorted_table_position_width + sorted_table_index_width;\n+  } else {\n+    for (int i = 0; i < fields->length(); ++i) {\n+      sizer.map_field_info(fields->at(i));\n@@ -108,5 +143,0 @@\n-    FieldInfo* fi = fields->adr_at(i);\n-    sizer.map_field_info(*fi);\n-  }\n-  for (int i = JUMP_TABLE_STRIDE; i < java_fields; i += JUMP_TABLE_STRIDE) {\n-    sizer.consumer()->accept_uint(positions[i \/ JUMP_TABLE_STRIDE - 1]);\n@@ -115,2 +145,2 @@\n-  \/\/ no we check limits instead as there may be the JumpTable\n-  int storage_size = sizer.consumer()->position();\n+  \/\/ now we check limits instead as there may be the SortedTable\n+  int storage_size = sizer.consumer()->position() + java_fields * sorted_table_item_width;\n@@ -126,2 +156,2 @@\n-  int jump_table_offset_pos = w.position();\n-  if (java_fields > JUMP_TABLE_STRIDE) {\n+  int sorted_table_offset_pos = w.position();\n+  if (positions != nullptr) {\n@@ -131,7 +161,1 @@\n-    FieldInfo* fi = fields->adr_at(i);\n-    assert(i == 0 || i >= java_fields || i % JUMP_TABLE_STRIDE != 0 ||\n-      w.position() == positions[i \/ JUMP_TABLE_STRIDE - 1], \"must be\");\n-    writer.map_field_info(*fi);\n-  }\n-  if (java_fields > JUMP_TABLE_STRIDE) {\n-    *reinterpret_cast<uint32_t*>(w.array()->adr_at(jump_table_offset_pos)) = checked_cast<uint32_t>(w.position());\n+    writer.map_field_info(fields->at(i));\n@@ -139,2 +163,18 @@\n-  for (int i = JUMP_TABLE_STRIDE; i < java_fields; i += JUMP_TABLE_STRIDE) {\n-    writer.consumer()->accept_uint(positions[i \/ JUMP_TABLE_STRIDE - 1]);\n+  if (java_fields > SORTED_FIELD_TABLE_THRESHOLD) {\n+    *reinterpret_cast<uint32_t*>(w.array()->adr_at(sorted_table_offset_pos)) = checked_cast<uint32_t>(w.position());\n+\n+    auto write_position = sorted_table_position_width == 2 ?\n+      [](u1 *ptr, int position) { *reinterpret_cast<u2*>(ptr) = checked_cast<u2>(position); } :\n+      [](u1 *ptr, int position) {\n+        ptr[0] = static_cast<u1>(position);\n+        ptr[1] = static_cast<u1>(position >> 8);\n+        ptr[2] = checked_cast<u1>(position >> 16);\n+      };\n+    auto write_index = sorted_table_index_width == 1 ?\n+      [](u1 *ptr, int index) { *ptr = checked_cast<u1>(index); } :\n+      [](u1 *ptr, int index) { *reinterpret_cast<u2 *>(ptr) = checked_cast<u2>(index); };\n+     for (int i = 0; i < java_fields; ++i) {\n+      u1 *ptr = w.array()->adr_at(w.position() + sorted_table_item_width * i);\n+      write_position(ptr, positions[i].position);\n+      write_index(ptr + sorted_table_position_width, positions[i].index);\n+    }\n@@ -200,7 +240,1 @@\n-int FieldInfoReader::skip_fields_until(const Symbol *name, ConstantPool *cp, int java_fields) {\n-  int jump_table_size = (java_fields - 1) \/ JUMP_TABLE_STRIDE;\n-  if (jump_table_size == 0) {\n-    return -1;\n-  }\n-  int field_pos = -1;\n-  int field_index = -1;\n+int FieldInfoReader::sorted_table_lookup(const Symbol *name, const Symbol *signature, ConstantPool *cp, int java_fields) {\n@@ -208,8 +242,36 @@\n-  r2.set_position(_r.limit());\n-  for (int i = 0; i < jump_table_size; ++i) {\n-    int pos = r2.next_uint();\n-    int pos2 = pos; \/\/ read_uint updates this by reference\n-    uint32_t name_index = UNSIGNED5::read_uint<const u1 *, int>(_r.array(), pos2, _r.limit());\n-    Symbol *sym = cp->symbol_at(name_index);\n-    if (FieldInfoStream::compare_symbols(name, sym) < 0) {\n-      break;\n+  int low = 0, high = java_fields - 1;\n+  int table_offset = _r.limit();\n+  int position_width = (table_offset > UINT16_MAX + 1 ? 3 : 2);\n+  int item_width = position_width  + (java_fields > UINT8_MAX + 1 ? 2 : 1);\n+  auto read_position = table_offset > UINT16_MAX + 1 ?\n+    [](const u1 *ptr) { return (int) ptr[0] + (((int) ptr[1] << 8)) + (((int) ptr[2]) << 16); } :\n+    [](const u1 *ptr) { return (int) *reinterpret_cast<const u2 *>(ptr); };\n+  while (low <= high) {\n+    int mid = low + (high - low) \/ 2;\n+    const u1 *ptr = _r.array() + table_offset + item_width * mid;\n+    int position = read_position(ptr);\n+    r2.set_position(position);\n+    Symbol *mid_name = cp->symbol_at(checked_cast<u2>(r2.next_uint()));\n+    Symbol *mid_sig = cp->symbol_at(checked_cast<u2>(r2.next_uint()));\n+\n+    if (mid_name == name && mid_sig == signature) {\n+      _r.set_position(position);\n+      _next_index = java_fields > UINT8_MAX + 1 ?\n+        *reinterpret_cast<const u2 *>(ptr + position_width) : ptr[position_width];\n+      return _next_index;\n+    }\n+\n+    int cmp = FieldInfoStream::compare_symbols(name, mid_name);\n+    if (cmp < 0) {\n+      high = mid - 1;\n+      continue;\n+    } else if (cmp > 0) {\n+      low = mid + 1;\n+      continue;\n+    }\n+    cmp = FieldInfoStream::compare_symbols(signature, mid_sig);\n+    assert(cmp != 0, \"Equality check above did not match\");\n+    if (cmp < 0) {\n+      high = mid - 1;\n+    } else {\n+      low = mid + 1;\n@@ -217,6 +279,0 @@\n-    field_pos = pos;\n-    field_index = (i + 1) * JUMP_TABLE_STRIDE;\n-  }\n-  if (field_pos >= 0) {\n-    _r.set_position(field_pos);\n-    _next_index = field_index;\n@@ -224,1 +280,1 @@\n-  return field_index;\n+  return -1;\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":114,"deletions":58,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -223,2 +223,0 @@\n-#define JUMP_TABLE_STRIDE 16\n-\n@@ -237,9 +235,1 @@\n-  void read_field_counts(int *java_fields, int *injected_fields) {\n-    *java_fields = _r.next_uint();\n-    *injected_fields = _r.next_uint();\n-    if (*java_fields > JUMP_TABLE_STRIDE) {\n-      uint32_t jumptable_offset = *reinterpret_cast<const uint32_t *>(_r.array() + _r.position());\n-      _r.set_limit(jumptable_offset);\n-      _r.set_position(_r.position() + sizeof(uint32_t));\n-    }\n-  }\n+  void read_field_counts(int *java_fields, int *injected_fields);\n@@ -251,3 +241,1 @@\n-  \/\/ Skips java fields based on condensed info in the jump table;\n-  \/\/ stops at a point before first field with matching name.\n-  int skip_fields_until(const Symbol *name, ConstantPool *cp, int java_fields);\n+  int sorted_table_lookup(const Symbol *name, const Symbol *signature, ConstantPool *cp, int java_fields);\n@@ -269,2 +257,2 @@\n-\/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields JumpTable_offset(0\/4 bytes) Field[j+k] JumpTable[(j - 1)\/16 > 0] End\n-\/\/   JumpTable := stream_index[(j - 1)\/16]\n+\/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields SortedFieldTable_offset(0\/4 bytes) Field[j+k] SortedFieldRecord[j] End\n+\/\/   SortedFieldRecord := stream_position(2-3 bytes) field_index(1-2 bytes)\n@@ -284,0 +272,3 @@\n+  \/\/ Don't generate the table for small classes at all.\n+  static const int SORTED_FIELD_TABLE_THRESHOLD = 16;\n+\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -111,0 +111,10 @@\n+inline void FieldInfoReader::read_field_counts(int *java_fields, int *injected_fields) {\n+  *java_fields = _r.next_uint();\n+  *injected_fields = _r.next_uint();\n+  if (*java_fields > FieldInfoStream::SORTED_FIELD_TABLE_THRESHOLD) {\n+    uint32_t sorted_table_offset = *reinterpret_cast<const uint32_t *>(_r.array() + _r.position());\n+    _r.set_limit(sorted_table_offset);\n+    _r.set_position(_r.position() + sizeof(uint32_t));\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -169,1 +169,3 @@\n-  void skip_fields_until(const Symbol *name, ConstantPool *cp);\n+  \/\/ Performs either a linear search or binary search through the stream\n+  \/\/ looking for a matchin name\/signature combo\n+  bool lookup(const Symbol *name, const Symbol *signature);\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,7 +65,15 @@\n-inline void JavaFieldStream::skip_fields_until(const Symbol *name, ConstantPool *cp) {\n-  if (done()) {\n-    return;\n-  }\n-  int index = _reader.skip_fields_until(name, cp, _limit);\n-  if (index < 0) {\n-    return;\n+inline bool JavaFieldStream::lookup(const Symbol *name, const Symbol *signature) {\n+  if (_limit > FieldInfoStream::SORTED_FIELD_TABLE_THRESHOLD) {\n+    int index = _reader.sorted_table_lookup(name, signature, _constants(), _limit);\n+    if (index >= 0) {\n+      assert(index < _limit, \"must be\");\n+      _index = index;\n+      _reader.read_field_info(_fi_buf);\n+      return true;\n+    }\n+  } else {\n+    for (; !done(); next()) {\n+      if (this->name() == name && this->signature() == signature) {\n+        return true;\n+      }\n+    }\n@@ -73,3 +81,1 @@\n-  assert(index > 0 && index < _limit && index % JUMP_TABLE_STRIDE == 0, \"must be\");\n-  _index = index;\n-  _reader.read_field_info(_fi_buf);\n+  return false;\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.inline.hpp","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1784,8 +1784,5 @@\n-  fs.skip_fields_until(name, constants());\n-  for (; !fs.done(); fs.next()) {\n-    Symbol* f_name = fs.name();\n-    Symbol* f_sig  = fs.signature();\n-    if (f_name == name && f_sig == sig) {\n-      fd->reinitialize(const_cast<InstanceKlass*>(this), fs.to_FieldInfo());\n-      return true;\n-    }\n+  if (fs.lookup(name, sig)) {\n+    assert(fs.name() == name, \"name must match\");\n+    assert(fs.signature() == sig, \"signature must match\");\n+    fd->reinitialize(const_cast<InstanceKlass*>(this), fs.to_FieldInfo());\n+    return true;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-  private static final int JUMP_TABLE_SIZE = 16;\n+  private static final int SORTED_FIELD_TABLE_THRESHOLD =\n+    VM.getVM().getTypeDataBase().lookupIntConstant(\"FieldInfoStream::SORTED_FIELD_TABLE_THRESHOLD\");\n@@ -115,3 +116,3 @@\n-    \/\/ JumpTable is generated only for classes with > 16 (non-injected) fields\n-    if (numJavaFields > JUMP_TABLE_SIZE) {\n-      \/\/ JumpTable offset (is not variable-size encoded)\n+    \/\/ Sorted fields table is generated only for classes with > 16 (non-injected) fields\n+    if (numJavaFields > SORTED_FIELD_TABLE_THRESHOLD) {\n+      \/\/ Sorted field table offset offset (is not variable-size encoded)\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Field.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import java.util.HashMap;\n-import java.util.Map;\n@@ -55,1 +53,1 @@\n-        Map<Integer, String> map = new HashMap<>();\n+        int next = 0;       \/\/ indexes start at zero\n@@ -66,1 +64,1 @@\n-                    Assert.assertNull(map.put(ndx, name), \"index should be unique\");\n+                    Assert.assertEquals(ndx, next, \"index value wrong\");\n@@ -68,1 +66,1 @@\n-                        fixedLength = ndx;     \/\/ remember for final check\n+                        fixedLength = next;     \/\/ remember for final check\n@@ -70,0 +68,1 @@\n+                    next++;\n@@ -77,5 +76,1 @@\n-        int min = map.keySet().stream().mapToInt(i -> i).min().orElseThrow();\n-        int max = map.keySet().stream().mapToInt(i -> i).max().orElseThrow();\n-        Assert.assertEquals(min, 0, \"Should start with 0\");\n-        Assert.assertEquals(map.size(), max + 1, \"Should have unique items\");\n-        Assert.assertEquals(max, fixedLength,\n+        Assert.assertEquals(next - 1, fixedLength,\n","filename":"test\/jdk\/java\/lang\/System\/VerifyRawIndexesTest.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"}]}