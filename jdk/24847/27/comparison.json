{"files":[{"patch":"@@ -3741,0 +3741,1 @@\n+  this_klass->set_fieldinfo_search_table(_fieldinfo_search_table);\n@@ -3750,0 +3751,2 @@\n+  DEBUG_ONLY(FieldInfoStream::validate_search_table(_cp, _fieldinfo_stream, _fieldinfo_search_table));\n+\n@@ -5056,0 +5059,1 @@\n+  assert(nullptr == _fieldinfo_search_table, \"invariant\");\n@@ -5276,0 +5280,1 @@\n+  _fieldinfo_search_table(nullptr),\n@@ -5352,0 +5357,1 @@\n+  _fieldinfo_search_table = nullptr;\n@@ -5374,0 +5380,1 @@\n+  MetadataFactory::free_array<u1>(_loader_data, _fieldinfo_search_table);\n@@ -5774,0 +5781,1 @@\n+  _fieldinfo_search_table = FieldInfoStream::create_search_table(_cp, _fieldinfo_stream, _loader_data, CHECK);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -126,0 +126,1 @@\n+  Array<u1>* _fieldinfo_search_table;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -304,1 +304,1 @@\n-    for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n@@ -464,1 +464,1 @@\n-          for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+          for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -969,0 +969,7 @@\n+\n+      Array<u1>* old_table = ik->fieldinfo_search_table();\n+      Array<u1>* search_table = FieldInfoStream::create_search_table(ik->constants(), new_fis, k->class_loader_data(), CHECK);\n+      ik->set_fieldinfo_search_table(search_table);\n+      MetadataFactory::free_array<u1>(k->class_loader_data(), old_table);\n+\n+      DEBUG_ONLY(FieldInfoStream::validate_search_table(ik->constants(), new_fis, search_table));\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+#include \"memory\/resourceArea.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n@@ -27,0 +29,1 @@\n+#include \"utilities\/packedTable.hpp\"\n@@ -40,2 +43,4 @@\n-                _field_flags.is_injected() ? lookup_symbol(generic_signature_index())->as_utf8() : cp->symbol_at(generic_signature_index())->as_utf8(),\n-                contended_group());\n+                _field_flags.is_generic() ? (_field_flags.is_injected() ?\n+                  lookup_symbol(generic_signature_index())->as_utf8() : cp->symbol_at(generic_signature_index())->as_utf8()\n+                  ) : \"\",\n+                is_contended() ? contended_group() : 0);\n@@ -65,0 +70,2 @@\n+  assert(fields->length() == java_fields + injected_fields, \"must be\");\n+\n@@ -71,1 +78,3 @@\n-  int storage_size = sizer.consumer()->position() + 1;\n+  \/\/ Originally there was an extra byte with 0 terminating the reading;\n+  \/\/ now we check limits instead.\n+  int storage_size = sizer.consumer()->position();\n@@ -82,2 +91,1 @@\n-    FieldInfo* fi = fields->adr_at(i);\n-    writer.map_field_info(*fi);\n+    writer.map_field_info(fields->at(i));\n@@ -88,1 +96,2 @@\n-  int jfc = r.next_uint();\n+  int jfc, ifc;\n+  r.read_field_counts(&jfc, &ifc);\n@@ -90,1 +99,0 @@\n-  int ifc = r.next_uint();\n@@ -116,0 +124,78 @@\n+int FieldInfoStream::compare_name_and_sig(const Symbol* n1, const Symbol* s1, const Symbol* n2, const Symbol* s2) {\n+  int cmp = n1->fast_compare(n2);\n+  return cmp != 0 ? cmp : s1->fast_compare(s2);\n+}\n+\n+\n+\/\/ We use both name and signature during the comparison; while JLS require unique\n+\/\/ names for fields, JVMS requires only unique name + signature combination.\n+typedef struct {\n+  Symbol* _name;\n+  Symbol* _signature;\n+  int _index;\n+  int _position;\n+} field_pos;\n+\n+class FieldInfoSupplier: public PackedTableBuilder::Supplier {\n+  const field_pos* _positions;\n+  size_t _elements;\n+\n+public:\n+  FieldInfoSupplier(const field_pos* positions, size_t elements): _positions(positions), _elements(elements) {}\n+\n+  bool next(uint32_t* key, uint32_t* value) override {\n+    if (_elements == 0) {\n+      return false;\n+    }\n+    *key = _positions->_position;\n+    *value = _positions->_index;\n+    ++_positions;\n+    --_elements;\n+    return true;\n+  }\n+};\n+\n+Array<u1>* FieldInfoStream::create_search_table(ConstantPool* cp, const Array<u1>* fis, ClassLoaderData* loader_data, TRAPS) {\n+  if (CDSConfig::is_dumping_dynamic_archive()) {\n+    \/\/ We cannot use search table; in case of dynamic archives it should be sorted by \"requested\" addresses,\n+    \/\/ but Symbol* addresses are coming from _constants, which has \"buffered\" addresses.\n+    \/\/ For background, see new comments inside allocate_node_impl in symbolTable.cpp\n+    return nullptr;\n+  }\n+\n+  FieldInfoReader r(fis);\n+  int java_fields;\n+  int injected_fields;\n+  r.read_field_counts(&java_fields, &injected_fields);\n+  assert(java_fields >= 0, \"must be\");\n+  if (java_fields == 0 || fis->length() == 0 || static_cast<uint>(java_fields) < BinarySearchThreshold) {\n+    return nullptr;\n+  }\n+\n+  ResourceMark rm;\n+  field_pos* positions = NEW_RESOURCE_ARRAY(field_pos, java_fields);\n+  for (int i = 0; i < java_fields; ++i) {\n+    assert(r.has_next(), \"number of fields must match\");\n+\n+    positions[i]._position = r.position();\n+    FieldInfo fi;\n+    r.read_field_info(fi);\n+\n+    positions[i]._name = fi.name(cp);\n+    positions[i]._signature = fi.signature(cp);\n+    positions[i]._index = i;\n+  }\n+  auto compare_pair = [](const void* v1, const void* v2) {\n+    const field_pos* p1 = reinterpret_cast<const field_pos*>(v1);\n+    const field_pos* p2 = reinterpret_cast<const field_pos*>(v2);\n+    return compare_name_and_sig(p1->_name, p1->_signature, p2->_name, p2->_signature);\n+  };\n+  qsort(positions, java_fields, sizeof(field_pos), compare_pair);\n+\n+  PackedTableBuilder builder(fis->length() - 1, java_fields - 1);\n+  Array<u1>* table = MetadataFactory::new_array<u1>(loader_data, java_fields * builder.element_bytes(), CHECK_NULL);\n+  FieldInfoSupplier supplier(positions, java_fields);\n+  builder.fill(table->data(), static_cast<size_t>(table->length()), supplier);\n+  return table;\n+}\n+\n@@ -117,2 +203,0 @@\n-  int length = FieldInfoStream::num_total_fields(fis);\n-  GrowableArray<FieldInfo>* array = new GrowableArray<FieldInfo>(length);\n@@ -120,2 +204,4 @@\n-  *java_fields_count = r.next_uint();\n-  *injected_fields_count = r.next_uint();\n+  r.read_field_counts(java_fields_count, injected_fields_count);\n+  int length = *java_fields_count + *injected_fields_count;\n+\n+  GrowableArray<FieldInfo>* array = new GrowableArray<FieldInfo>(length);\n@@ -128,1 +214,0 @@\n-  assert(array->length() == *java_fields_count + *injected_fields_count, \"Must be\");\n@@ -133,1 +218,0 @@\n-  int length = FieldInfoStream::num_total_fields(fis);\n@@ -135,2 +219,3 @@\n-  int java_field_count = r.next_uint();\n-  int injected_fields_count = r.next_uint();\n+  int java_fields_count;\n+  int injected_fields_count;\n+  r.read_field_counts(&java_fields_count, &injected_fields_count);\n@@ -143,0 +228,115 @@\n+\n+class FieldInfoComparator: public PackedTableLookup::Comparator {\n+private:\n+  const FieldInfoReader* _reader;\n+  ConstantPool* _cp;\n+  const Symbol* _name;\n+  const Symbol* _signature;\n+\n+public:\n+  FieldInfoComparator(const FieldInfoReader* reader, ConstantPool* cp, const Symbol* name, const Symbol* signature):\n+    _reader(reader), _cp(cp), _name(name), _signature(signature) {}\n+\n+  int compare_to(uint32_t position) override {\n+    FieldInfoReader r2(*_reader);\n+    r2.set_position_and_next_index(position, -1);\n+    u2 name_index, sig_index;\n+    r2.read_name_and_signature(&name_index, &sig_index);\n+    Symbol* mid_name = _cp->symbol_at(name_index);\n+    Symbol* mid_sig = _cp->symbol_at(sig_index);\n+\n+    return FieldInfoStream::compare_name_and_sig(_name, _signature, mid_name, mid_sig);\n+  }\n+\n+#ifdef ASSERT\n+  void reset(uint32_t position) override {\n+    FieldInfoReader r2(*_reader);\n+    r2.set_position_and_next_index(position, -1);\n+    u2 name_index, signature_index;\n+    r2.read_name_and_signature(&name_index, &signature_index);\n+    _name = _cp->symbol_at(name_index);\n+    _signature = _cp->symbol_at(signature_index);\n+  }\n+#endif \/\/ ASSERT\n+};\n+\n+#ifdef ASSERT\n+void FieldInfoStream::validate_search_table(ConstantPool* cp, const Array<u1>* fis, const Array<u1>* search_table) {\n+  if (search_table == nullptr) {\n+    return;\n+  }\n+  FieldInfoReader reader(fis);\n+  int java_fields, injected_fields;\n+  reader.read_field_counts(&java_fields, &injected_fields);\n+  assert(java_fields > 0, \"must be\");\n+\n+  PackedTableLookup lookup(fis->length() - 1, java_fields - 1, search_table);\n+  assert(lookup.element_bytes() * java_fields == static_cast<unsigned int>(search_table->length()), \"size does not match\");\n+\n+  FieldInfoComparator comparator(&reader, cp, nullptr, nullptr);\n+  \/\/ Check 1: assert that elements have the correct order based on the comparison function\n+  lookup.validate_order(comparator);\n+\n+  \/\/ Check 2: Iterate through the original stream (not just search_table) and try if lookup works as expected\n+  reader.set_position_and_next_index(0, 0);\n+  reader.read_field_counts(&java_fields, &injected_fields);\n+  while (reader.has_next()) {\n+    int field_start = reader.position();\n+    FieldInfo fi;\n+    reader.read_field_info(fi);\n+    if (fi.field_flags().is_injected()) {\n+      \/\/ checking only java fields that precede injected ones\n+      break;\n+    }\n+\n+    FieldInfoReader r2(fis);\n+    int index = r2.search_table_lookup(search_table, fi.name(cp), fi.signature(cp), cp, java_fields);\n+    assert(index == static_cast<int>(fi.index()), \"wrong index: %d != %u\", index, fi.index());\n+    assert(index == r2.next_index(), \"index should match\");\n+    assert(field_start == r2.position(), \"must find the same position\");\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n+void FieldInfoStream::print_search_table(outputStream* st, ConstantPool* cp, const Array<u1>* fis, const Array<u1>* search_table) {\n+  if (search_table == nullptr) {\n+    return;\n+  }\n+  FieldInfoReader reader(fis);\n+  int java_fields, injected_fields;\n+  reader.read_field_counts(&java_fields, &injected_fields);\n+  assert(java_fields > 0, \"must be\");\n+  PackedTableLookup lookup(fis->length() - 1, java_fields - 1, search_table);\n+  auto printer = [&] (size_t offset, uint32_t position, uint32_t index) {\n+    reader.set_position_and_next_index(position, -1);\n+    u2 name_index, sig_index;\n+    reader.read_name_and_signature(&name_index, &sig_index);\n+    Symbol* name = cp->symbol_at(name_index);\n+    Symbol* sig = cp->symbol_at(sig_index);\n+    st->print(\"   [%zu] #%d,#%d = \", offset, name_index, sig_index);\n+    name->print_symbol_on(st);\n+    st->print(\":\");\n+    sig->print_symbol_on(st);\n+    st->print(\" @ %p,%p\", name, sig);\n+    st->cr();\n+  };\n+\n+  lookup.iterate(printer);\n+}\n+\n+int FieldInfoReader::search_table_lookup(const Array<u1>* search_table, const Symbol* name, const Symbol* signature, ConstantPool* cp, int java_fields) {\n+  assert(java_fields >= 0, \"must be\");\n+  if (java_fields == 0) {\n+    return -1;\n+  }\n+  FieldInfoComparator comp(this, cp, name, signature);\n+  PackedTableLookup lookup(_r.limit() - 1, java_fields - 1, search_table);\n+  uint32_t position;\n+  static_assert(sizeof(uint32_t) == sizeof(_next_index), \"field size assert\");\n+  if (lookup.search(comp, &position, reinterpret_cast<uint32_t*>(&_next_index))) {\n+    _r.set_position(static_cast<int>(position));\n+    return _next_index;\n+  } else {\n+    return -1;\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":215,"deletions":15,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -223,1 +223,0 @@\n-\n@@ -226,5 +225,0 @@\n-  friend class FieldInfoStream;\n-  friend class ClassFileParser;\n-  friend class FieldStreamBase;\n-  friend class FieldInfo;\n-\n@@ -234,1 +228,1 @@\n-  public:\n+public:\n@@ -237,2 +231,2 @@\n-  private:\n-  uint32_t next_uint() { return _r.next_uint(); }\n+private:\n+  inline uint32_t next_uint() { return _r.next_uint(); }\n@@ -242,3 +236,5 @@\n-  int has_next() { return _r.has_next(); }\n-  int position() { return _r.position(); }\n-  int next_index() { return _next_index; }\n+  void read_field_counts(int* java_fields, int* injected_fields);\n+  int has_next() const { return _r.position() < _r.limit(); }\n+  int position() const { return _r.position(); }\n+  int next_index() const { return _next_index; }\n+  void read_name_and_signature(u2* name_index, u2* signature_index);\n@@ -246,0 +242,3 @@\n+\n+  int search_table_lookup(const Array<u1>* search_table, const Symbol* name, const Symbol* signature, ConstantPool* cp, int java_fields);\n+\n@@ -272,0 +271,5 @@\n+  friend class FieldInfoReader;\n+  friend class FieldInfoComparator;\n+\n+ private:\n+  static int compare_name_and_sig(const Symbol* n1, const Symbol* s1, const Symbol* n2, const Symbol* s2);\n@@ -279,1 +283,2 @@\n-                                                          ClassLoaderData* loader_data, TRAPS);\n+                                           ClassLoaderData* loader_data, TRAPS);\n+  static Array<u1>* create_search_table(ConstantPool* cp, const Array<u1>* fis, ClassLoaderData* loader_data, TRAPS);\n@@ -282,0 +287,4 @@\n+\n+  DEBUG_ONLY(static void validate_search_table(ConstantPool* cp, const Array<u1>* fis, const Array<u1>* search_table);)\n+\n+  static void print_search_table(outputStream* st, ConstantPool* cp, const Array<u1>* fis, const Array<u1>* search_table);\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -59,2 +59,4 @@\n-  fir.skip(1);\n-  return fir.next_uint();\n+  int java_fields_count;\n+  int injected_fields_count;\n+  fir.read_field_counts(&java_fields_count, &injected_fields_count);\n+  return injected_fields_count;\n@@ -65,1 +67,4 @@\n-  return fir.next_uint() + fir.next_uint();\n+  int java_fields_count;\n+  int injected_fields_count;\n+  fir.read_field_counts(&java_fields_count, &injected_fields_count);\n+  return java_fields_count + injected_fields_count;\n@@ -68,1 +73,7 @@\n-inline int FieldInfoStream::num_java_fields(const Array<u1>* fis) { return FieldInfoReader(fis).next_uint(); }\n+inline int FieldInfoStream::num_java_fields(const Array<u1>* fis) {\n+  FieldInfoReader fir(fis);\n+  int java_fields_count;\n+  int injected_fields_count;\n+  fir.read_field_counts(&java_fields_count, &injected_fields_count);\n+  return java_fields_count;\n+}\n@@ -97,1 +108,1 @@\n-  : _r(fi->data(), 0),\n+  : _r(fi->data(), fi->length()),\n@@ -100,0 +111,10 @@\n+inline void FieldInfoReader::read_field_counts(int* java_fields, int* injected_fields) {\n+  *java_fields = next_uint();\n+  *injected_fields = next_uint();\n+}\n+\n+inline void FieldInfoReader::read_name_and_signature(u2* name_index, u2* signature_index) {\n+  *name_index = checked_cast<u2>(next_uint());\n+  *signature_index = checked_cast<u2>(next_uint());\n+}\n+\n@@ -102,2 +123,1 @@\n-  fi._name_index = checked_cast<u2>(next_uint());\n-  fi._signature_index = checked_cast<u2>(next_uint());\n+  read_name_and_signature(&fi._name_index, &fi._signature_index);\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  inline FieldStreamBase(Array<u1>* fieldinfo_stream, ConstantPool* constants);\n+  inline FieldStreamBase(const Array<u1>* fieldinfo_stream, ConstantPool* constants);\n@@ -61,1 +61,1 @@\n-  private:\n+ private:\n@@ -63,3 +63,8 @@\n-    int java_fields_count = _reader.next_uint();\n-    int injected_fields_count = _reader.next_uint();\n-    assert( _limit <= java_fields_count + injected_fields_count, \"Safety check\");\n+    int java_fields_count;\n+    int injected_fields_count;\n+    _reader.read_field_counts(&java_fields_count, &injected_fields_count);\n+    if (_limit < _index) {\n+      _limit = java_fields_count + injected_fields_count;\n+    } else {\n+      assert( _limit <= java_fields_count + injected_fields_count, \"Safety check\");\n+    }\n@@ -71,0 +76,1 @@\n+\n@@ -141,0 +147,2 @@\n+  Array<u1>* _search_table;\n+\n@@ -142,1 +150,2 @@\n-  JavaFieldStream(const InstanceKlass* k): FieldStreamBase(k->fieldinfo_stream(), k->constants(), 0, k->java_fields_count()) {}\n+  JavaFieldStream(const InstanceKlass* k): FieldStreamBase(k->fieldinfo_stream(), k->constants(), 0, k->java_fields_count()),\n+    _search_table(k->fieldinfo_search_table()) {}\n@@ -152,1 +161,0 @@\n-    return -1;\n@@ -167,0 +175,4 @@\n+\n+  \/\/ Performs either a linear search or binary search through the stream\n+  \/\/ looking for a matching name\/signature combo\n+  bool lookup(const Symbol* name, const Symbol* signature);\n@@ -179,1 +191,0 @@\n-  AllFieldStream(Array<u1>* fieldinfo, ConstantPool* constants): FieldStreamBase(fieldinfo, constants) {}\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -36,7 +36,3 @@\n-         _constants(constantPoolHandle(Thread::current(), constants)), _index(start) {\n-  _index = start;\n-  if (limit < start) {\n-    _limit = FieldInfoStream::num_total_fields(_fieldinfo_stream);\n-  } else {\n-    _limit = limit;\n-  }\n+         _constants(constantPoolHandle(Thread::current(), constants)),\n+         _index(start),\n+         _limit(limit) {\n@@ -46,1 +42,1 @@\n-FieldStreamBase::FieldStreamBase(Array<u1>* fieldinfo_stream, ConstantPool* constants) :\n+FieldStreamBase::FieldStreamBase(const Array<u1>* fieldinfo_stream, ConstantPool* constants) :\n@@ -51,1 +47,1 @@\n-        _limit(FieldInfoStream::num_total_fields(_fieldinfo_stream)) {\n+        _limit(-1) {\n@@ -60,1 +56,1 @@\n-         _limit(FieldInfoStream::num_total_fields(_fieldinfo_stream)) {\n+         _limit(-1) {\n@@ -65,0 +61,19 @@\n+inline bool JavaFieldStream::lookup(const Symbol* name, const Symbol* signature) {\n+  if (_search_table != nullptr) {\n+    int index = _reader.search_table_lookup(_search_table, name, signature, _constants(), _limit);\n+    if (index >= 0) {\n+      assert(index < _limit, \"must be\");\n+      _index = index;\n+      _reader.read_field_info(_fi_buf);\n+      return true;\n+    }\n+  } else {\n+    for (; !done(); next()) {\n+      if (this->name() == name && this->signature() == signature) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.inline.hpp","additions":25,"deletions":10,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -689,0 +689,5 @@\n+  if (fieldinfo_search_table() != nullptr && !fieldinfo_search_table()->is_shared()) {\n+    MetadataFactory::free_array<u1>(loader_data, fieldinfo_search_table());\n+  }\n+  set_fieldinfo_search_table(nullptr);\n+\n@@ -1783,7 +1788,6 @@\n-  for (JavaFieldStream fs(this); !fs.done(); fs.next()) {\n-    Symbol* f_name = fs.name();\n-    Symbol* f_sig  = fs.signature();\n-    if (f_name == name && f_sig == sig) {\n-      fd->reinitialize(const_cast<InstanceKlass*>(this), fs.to_FieldInfo());\n-      return true;\n-    }\n+  JavaFieldStream fs(this);\n+  if (fs.lookup(name, sig)) {\n+    assert(fs.name() == name, \"name must match\");\n+    assert(fs.signature() == sig, \"signature must match\");\n+    fd->reinitialize(const_cast<InstanceKlass*>(this), fs.to_FieldInfo());\n+    return true;\n@@ -2606,0 +2610,1 @@\n+  it->push(&_fieldinfo_search_table);\n@@ -2704,0 +2709,2 @@\n+\n+  DEBUG_ONLY(FieldInfoStream::validate_search_table(_constants, _fieldinfo_stream, _fieldinfo_search_table));\n@@ -2810,0 +2817,2 @@\n+\n+  DEBUG_ONLY(FieldInfoStream::validate_search_table(_constants, _fieldinfo_stream, _fieldinfo_search_table));\n@@ -3765,0 +3774,5 @@\n+\n+  if (fieldinfo_search_table() != nullptr) {\n+    st->print_cr(BULLET\"---- field info search table:\");\n+    FieldInfoStream::print_search_table(st, _constants, _fieldinfo_stream, _fieldinfo_search_table);\n+  }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -279,0 +279,1 @@\n+  Array<u1>*          _fieldinfo_search_table;\n@@ -407,0 +408,3 @@\n+  Array<u1>* fieldinfo_search_table() const { return _fieldinfo_search_table; }\n+  void set_fieldinfo_search_table(Array<u1>* table) { _fieldinfo_search_table = table; }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3561,0 +3561,7 @@\n+\n+    Array<u1>* old_table = scratch_class->fieldinfo_search_table();\n+    Array<u1>* search_table = FieldInfoStream::create_search_table(scratch_class->constants(), new_fis, scratch_class->class_loader_data(), CHECK);\n+    scratch_class->set_fieldinfo_search_table(search_table);\n+    MetadataFactory::free_array<u1>(scratch_class->class_loader_data(), old_table);\n+\n+    DEBUG_ONLY(FieldInfoStream::validate_search_table(scratch_class->constants(), new_fis, search_table));\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2005,0 +2005,4 @@\n+                                                                            \\\n+  develop(uint, BinarySearchThreshold, 16,                                  \\\n+          \"Minimal number of elements in a sorted collection to prefer\"     \\\n+          \"binary search over simple linear search.\" )                      \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include <cstring>\n+\n+\/\/ MSVC++ does not have an appropriate builtin, use library version\n+#ifdef _MSC_VER\n+# define __builtin_memcpy memcpy\n+#endif\n+\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/count_leading_zeros.hpp\"\n+#include \"utilities\/packedTable.hpp\"\n+\n+\/\/ The thresholds are inclusive, and in practice the limits are rounded\n+\/\/ to the nearest power-of-two - 1.\n+\/\/ Based on the max_key and max_value we figure out the number of bits required to store\n+\/\/ key and value; imagine that only as bits (not aligned to byte boundary... yet).\n+\/\/ Then we concatenate the bits for key and value, and 'add' 1-7 padding zeroes\n+\/\/ (high-order bits) to align on bytes.\n+\/\/ In the end we have each element in the table consuming 1-8 bytes (case with 0 bits for key\n+\/\/ is ruled out).\n+PackedTableBase::PackedTableBase(uint32_t max_key, uint32_t max_value) {\n+  unsigned int key_bits = max_key == 0 ? 0 : 32 - count_leading_zeros(max_key);\n+  unsigned int value_bits = max_value == 0 ? 0 : 32 - count_leading_zeros(max_value);\n+  _element_bytes = align_up(key_bits + value_bits, 8) \/ 8;\n+  \/\/ shifting left by 32 is undefined behaviour, and in practice returns 1\n+  _key_mask = key_bits >= 32 ? -1 : (1U << key_bits) - 1;\n+  _value_shift = key_bits;\n+  _value_mask = value_bits >= 32 ? -1 : (1U << value_bits) - 1;\n+  guarantee(_element_bytes > 0, \"wouldn't work\");\n+  assert(_element_bytes <= sizeof(uint64_t), \"shouldn't happen\");\n+}\n+\n+\/\/ Note: we require the supplier to provide the elements in the final order as we can't easily sort\n+\/\/ within this method - qsort() accepts only pure function as comparator.\n+void PackedTableBuilder::fill(u1* table, size_t table_length, Supplier &supplier) const {\n+  uint32_t key, value;\n+  size_t offset = 0;\n+  for (; offset + sizeof(uint64_t) <= table_length && supplier.next(&key, &value); offset += _element_bytes) {\n+    assert((key & ~_key_mask) == 0, \"key out of bounds\");\n+    assert((value & ~_value_mask) == 0, \"value out of bounds: %x vs. %x (%x)\", value, _value_mask, ~_value_mask);\n+    uint64_t element = static_cast<uint64_t>(key) | (static_cast<uint64_t>(value) << _value_shift);\n+    __builtin_memcpy(table + offset, &element, _element_bytes);\n+  }\n+  \/\/ last bytes\n+  for (; offset < table_length && supplier.next(&key, &value); offset += _element_bytes) {\n+    uint64_t element = static_cast<uint64_t>(key) | (static_cast<uint64_t>(value) << _value_shift);\n+    for (unsigned int i = 0; i < _element_bytes; ++i) {\n+      table[offset + i] = static_cast<u1>(0xFF & (element >> (8 * i)));\n+    }\n+  }\n+\n+  assert(offset == table_length, \"Did not fill whole array\");\n+  assert(!supplier.next(&key, &value), \"Supplier has more elements\");\n+}\n+\n+uint64_t PackedTableLookup::read_element(size_t offset) const {\n+  uint64_t element = 0;\n+  __builtin_memcpy(&element, _table + offset, _element_bytes);\n+  assert((element & ~((uint64_t) _key_mask | ((uint64_t) _value_mask << _value_shift))) == 0, \"read too much\");\n+  return element;\n+}\n+\n+bool PackedTableLookup::search(Comparator& comparator, uint32_t* found_key, uint32_t* found_value) const {\n+  unsigned int low = 0, high = checked_cast<unsigned int>(_table_length \/ _element_bytes);\n+  assert(low < high, \"must be\");\n+  while (low < high) {\n+    unsigned int mid = low + (high - low) \/ 2;\n+    assert(mid >= low && mid < high, \"integer overflow?\");\n+    uint64_t element = read_element(_element_bytes * mid);\n+    \/\/ Ignoring high 32 bits in element on purpose\n+    uint32_t key = static_cast<uint32_t>(element) & _key_mask;\n+    int cmp = comparator.compare_to(key);\n+    if (cmp == 0) {\n+      *found_key = key;\n+      \/\/ Since __builtin_memcpy in read_element does not copy bits outside the element\n+      \/\/ anything above _value_mask << _value_shift should be zero.\n+      *found_value = checked_cast<uint32_t>(element >> _value_shift) & _value_mask;\n+      return true;\n+    } else if (cmp < 0) {\n+      high = mid;\n+    } else {\n+      low = mid + 1;\n+    }\n+  }\n+  return false;\n+}\n+\n+#ifdef ASSERT\n+void PackedTableLookup::validate_order(Comparator &comparator) const {\n+  auto validator = [&] (size_t offset, uint32_t key, uint32_t value) {\n+    if (offset != 0) {\n+      assert(comparator.compare_to(key) < 0, \"not sorted\");\n+    }\n+    comparator.reset(key);\n+  };\n+  iterate(validator);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/utilities\/packedTable.cpp","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"oops\/array.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ Base for space-optimized structure supporting binary search. Each element\n+\/\/ consists of up to 32-bit key, and up to 32-bit value; these are packed\n+\/\/ into a bit-record with 1-byte alignment.\n+\/\/ The keys are ordered according to a custom comparator.\n+class PackedTableBase {\n+protected:\n+  unsigned int _element_bytes;\n+  uint32_t _key_mask;\n+  unsigned int _value_shift;\n+  uint32_t _value_mask;\n+\n+public:\n+  PackedTableBase(uint32_t max_key, uint32_t max_value);\n+\n+  \/\/ Returns number of bytes each element will occupy.\n+  inline unsigned int element_bytes(void) const { return _element_bytes; }\n+};\n+\n+\/\/ Helper class for constructing a packed table in the provided array.\n+class PackedTableBuilder: public PackedTableBase {\n+public:\n+  class Supplier {\n+  public:\n+    \/\/ Returns elements with already ordered keys.\n+    \/\/ This function should return true when the key and value was set,\n+    \/\/ and false when there's no more elements.\n+    \/\/ Packed table does NOT support duplicate keys.\n+    virtual bool next(uint32_t* key, uint32_t* value) = 0;\n+  };\n+\n+  \/\/ The thresholds are inclusive, and in practice the limits are rounded\n+  \/\/ to the nearest power-of-two - 1.\n+  \/\/ See PackedTableBase constructor for details.\n+  PackedTableBuilder(uint32_t max_key, uint32_t max_value): PackedTableBase(max_key, max_value) {}\n+\n+  \/\/ Constructs a packed table in the provided array, filling it with elements\n+  \/\/ from the supplier. Note that no comparator is requied by this method -\n+  \/\/ the supplier must return elements with already ordered keys.\n+  \/\/ The table_length (in bytes) should match number of elements provided\n+  \/\/ by the supplier (when Supplier::next() returns false the whole array should\n+  \/\/ be filled).\n+  void fill(u1* table, size_t table_length, Supplier &supplier) const;\n+};\n+\n+\/\/ Helper class for lookup in a packed table.\n+class PackedTableLookup: public PackedTableBase {\n+private:\n+  const u1* const _table;\n+  const size_t _table_length;\n+\n+  uint64_t read_element(size_t offset) const;\n+\n+public:\n+\n+  \/\/ The comparator implementation does not have to store a key (uint32_t);\n+  \/\/ the idea is that key can point into a different structure that hosts data\n+  \/\/ suitable for the actual comparison. That's why PackedTableLookup::search(...)\n+  \/\/ returns the key it found as well as the value.\n+  class Comparator {\n+  public:\n+    \/\/ Returns negative\/0\/positive if the target referred to by this comparator\n+    \/\/ is lower\/equal\/higher than the target referred to by the key.\n+    virtual int compare_to(uint32_t key) = 0;\n+    \/\/ Changes the target this comparator refers to.\n+    DEBUG_ONLY(virtual void reset(uint32_t key) = 0);\n+  };\n+\n+  \/\/ The thresholds are inclusive, and in practice the limits are rounded\n+  \/\/ to the nearest power-of-two - 1.\n+  \/\/ See PackedTableBase constructor for details.\n+  PackedTableLookup(uint32_t max_key, uint32_t max_value, const u1 *table, size_t table_length):\n+    PackedTableBase(max_key, max_value), _table(table), _table_length(table_length) {}\n+\n+  PackedTableLookup(uint32_t max_key, uint32_t max_value, const Array<u1> *table):\n+    PackedTableLookup(max_key, max_value, table->data(), static_cast<size_t>(table->length())) {}\n+\n+  \/\/ Performs a binary search in the packed table, looking for an element with key\n+  \/\/ referring to a target equal according to the comparator.\n+  \/\/ When the element is found, found_key and found_value are updated from the element\n+  \/\/ and the function returns true.\n+  \/\/ When the element is not found, found_key and found_value are not changed and\n+  \/\/ the function returns false.\n+  bool search(Comparator& comparator, uint32_t* found_key, uint32_t* found_value) const;\n+\n+  \/\/ Asserts that elements in the packed table follow the order defined by the comparator.\n+  DEBUG_ONLY(void validate_order(Comparator &comparator) const);\n+\n+  template<typename Function>\n+  void iterate(Function func) const {\n+    for (size_t offset = 0; offset < _table_length; offset += _element_bytes) {\n+      uint64_t element = read_element(offset);\n+      uint32_t key = static_cast<uint32_t>(element) & _key_mask;\n+      uint32_t value = checked_cast<uint32_t>(element >> _value_shift) & _value_mask;\n+      func(offset, key, value);\n+    }\n+  }\n+};\n","filename":"src\/hotspot\/share\/utilities\/packedTable.hpp","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -264,1 +264,1 @@\n-    int next_length() {\n+    int next_length() const {\n@@ -273,1 +273,1 @@\n-    bool has_next() {\n+    bool has_next() const {\n@@ -287,2 +287,3 @@\n-    OFF limit() { return _limit; }\n-    OFF position() { return _position; }\n+    OFF limit() const { return _limit; }\n+    OFF position() const { return _position; }\n+    void set_limit(OFF limit) { _limit = limit; }\n","filename":"src\/hotspot\/share\/utilities\/unsigned5.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"utilities\/packedTable.hpp\"\n+#include \"unittest.hpp\"\n+\n+class Supplier: public PackedTableBuilder::Supplier {\n+private:\n+    uint32_t* _keys;\n+    uint32_t* _values;\n+    size_t _num_keys;\n+public:\n+    Supplier(uint32_t* keys, uint32_t* values, size_t num_keys):\n+        _keys(keys), _values(values), _num_keys(num_keys) {}\n+\n+    bool next(uint32_t* key, uint32_t* value) override {\n+        if (_num_keys == 0) {\n+            return false;\n+        }\n+        *key = *_keys;\n+        ++_keys;\n+        if (_values != nullptr) {\n+            *value = *_values;\n+            ++_values;\n+        } else {\n+            *value = 0;\n+        }\n+        --_num_keys;\n+        return true;\n+    }\n+};\n+\n+class Comparator: public PackedTableLookup::Comparator {\n+private:\n+    uint32_t _current;\n+public:\n+    int compare_to(uint32_t key) override {\n+        return _current < key ? -1 : (_current > key ? 1 : 0);\n+    }\n+\n+    void reset(uint32_t key) DEBUG_ONLY(override) {\n+        _current = key;\n+    }\n+};\n+\n+static void test(uint32_t max_key, uint32_t max_value, unsigned int length) {\n+    if (length > max_key + 1) {\n+        \/\/ can't generate more keys, as keys must be unique\n+        return;\n+    }\n+    PackedTableBuilder builder(max_key, max_value);\n+    size_t table_length = length * builder.element_bytes();\n+    u1* table = new u1[table_length];\n+\n+    uint32_t* keys = new uint32_t[length];\n+    uint32_t* values = max_value != 0 ? new uint32_t[length] : nullptr;\n+    for (unsigned int i = 0; i < length; ++i) {\n+        keys[i] = i;\n+        if (values != nullptr) {\n+            values[i] = i % max_value;\n+        }\n+    }\n+    Supplier sup(keys, values, length);\n+    builder.fill(table, table_length, sup);\n+\n+    Comparator comparator;\n+    PackedTableLookup lookup(max_key, max_value, table, table_length);\n+#ifdef ASSERT\n+    lookup.validate_order(comparator);\n+#endif\n+\n+    for (unsigned int i = 0; i < length; ++i) {\n+        uint32_t key, value;\n+        comparator.reset(keys[i]);\n+        EXPECT_TRUE(lookup.search(comparator, &key, &value));\n+        EXPECT_EQ(key, keys[i]);\n+        if (values != nullptr) {\n+            EXPECT_EQ(value, values[i]);\n+        } else {\n+            EXPECT_EQ(value, 0U);\n+        }\n+    }\n+\n+    delete[] keys;\n+    delete[] values;\n+}\n+\n+static void test_with_bits(uint32_t max_key, uint32_t max_value) {\n+    \/\/ Some small sizes\n+    for (unsigned int i = 0; i <= 100; ++i) {\n+        test(max_key, max_value, i);\n+    }\n+    test(max_key, max_value, 10000);\n+}\n+\n+TEST(PackedTableLookup, lookup) {\n+    for (int key_bits = 1; key_bits <= 32; ++key_bits) {\n+        for (int value_bits = 0; value_bits <= 32; ++value_bits) {\n+            test_with_bits(static_cast<uint32_t>((1ULL << key_bits) - 1),\n+                           static_cast<uint32_t>((1ULL << value_bits) - 1));\n+        }\n+    }\n+}\n+\n+TEST(PackedTableBase, element_bytes) {\n+    {\n+        PackedTableBuilder builder(1, 0);\n+        EXPECT_EQ(builder.element_bytes(), 1U);\n+    }\n+    {\n+        PackedTableBuilder builder(15, 15);\n+        EXPECT_EQ(builder.element_bytes(), 1U);\n+    }\n+    {\n+        PackedTableBuilder builder(15, 16);\n+        EXPECT_EQ(builder.element_bytes(), 2U);\n+    }\n+    {\n+        PackedTableBuilder builder(31, 7);\n+        EXPECT_EQ(builder.element_bytes(), 1U);\n+    }\n+    {\n+        PackedTableBuilder builder(32, 7);\n+        EXPECT_EQ(builder.element_bytes(), 2U);\n+    }\n+    {\n+        PackedTableBuilder builder(-1, 0);\n+        EXPECT_EQ(builder.element_bytes(), 4U);\n+    }\n+    {\n+        PackedTableBuilder builder(-1, 1);\n+        EXPECT_EQ(builder.element_bytes(), 5U);\n+    }\n+    {\n+        PackedTableBuilder builder(-1, -1);\n+        EXPECT_EQ(builder.element_bytes(), 8U);\n+    }\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_packedTable.cpp","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+\n+import static org.objectweb.asm.ClassWriter.COMPUTE_FRAMES;\n+import static org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n+import static org.objectweb.asm.Opcodes.*;\n+\n+\/*\n+ * @test id=defaults\n+ * @bug 8352075\n+ * @library \/test\/lib\n+ * @library \/testlibrary\/asm\n+ * @run main\/othervm LocalFieldLookupTest\n+ *\/\n+\/*\n+ * @test id=custom-threshold\n+ * @bug 8352075\n+ * @library \/test\/lib\n+ * @library \/testlibrary\/asm\n+ * @requires vm.debug == true\n+ * @run main\/othervm LocalFieldLookupTest\n+ * @run main\/othervm -XX:BinarySearchThreshold=0 LocalFieldLookupTest\n+ * @run main\/othervm -XX:BinarySearchThreshold=1 LocalFieldLookupTest\n+ * @run main\/othervm -XX:BinarySearchThreshold=15 LocalFieldLookupTest\n+ * @run main\/othervm -XX:BinarySearchThreshold=100000 LocalFieldLookupTest\n+ *\/\n+public class LocalFieldLookupTest {\n+    private static final String TEST_CLASS_NAME = \"Test\";\n+    private static final int MAX_FIELDS_IN_METHOD = 10000;\n+\n+    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n+        \/\/ Test small classes, covering the tested thresholds\n+        for (int i = 0; i <= 33; ++i) {\n+            makeClass(i).newInstance();\n+        }\n+        \/\/ Test classes around 256 fields (index encoding 1\/2 bytes) to check off-by-one errors\n+        for (int i = 254; i <= 259; ++i) {\n+            makeClass(255).newInstance();\n+        }\n+        \/\/ We would like to test #fields that create have the stream about 65536 bytes long;\n+        \/\/ this value is not exposed, though, so these are rather experimentally found values,\n+        \/\/ hence fragile. Moreover, since the stream length is incremented by about 8 bytes\n+        \/\/ for each field we cannot test for off-by-one errors reliably.\n+        for (int i = 8433; i <= 8437; ++i) {\n+            makeClass(i).newInstance();\n+        }\n+        \/\/ The largest class we can create - this one has 65533 entries in the constant pool\n+        makeClass(26205).newInstance();\n+    }\n+\n+    public static Class<?> makeClass(int fields) throws ClassNotFoundException {\n+        ClassWriter writer = new ClassWriter(COMPUTE_MAXS | COMPUTE_FRAMES);\n+        writer.visit(49, Opcodes.ACC_PUBLIC + Opcodes.ACC_SUPER, TEST_CLASS_NAME,null, \"java\/lang\/Object\", null);\n+\n+        for (int i = 0; i < fields; i += 2) {\n+            writer.visitField(ACC_PUBLIC, \"f\" + i, \"I\",  null, null);\n+            \/\/ Let's use duplicate names to confirm search takes signatures into account\n+            if (i + 1 < fields) {\n+                writer.visitField(ACC_PUBLIC, \"f\" + i, \"J\",  null, null);\n+            }\n+        }\n+        \/\/ We initialize fields in multiple methods to avoid running into bytecode limit per method\n+        MethodVisitor fi = null;\n+        for (int i = 0; i < fields; i+= 2) {\n+            if (fi == null) {\n+                fi = writer.visitMethod(ACC_PRIVATE, \"init\" + i, \"()V\", null, null);\n+                fi.visitCode();\n+            }\n+            fi.visitVarInsn(Opcodes.ALOAD, 0);\n+            fi.visitInsn(Opcodes.ICONST_2);\n+            fi.visitFieldInsn(PUTFIELD, TEST_CLASS_NAME, \"f\" + i, \"I\");\n+            if (i + 1 < fields) {\n+                fi.visitVarInsn(Opcodes.ALOAD, 0);\n+                fi.visitInsn(Opcodes.LCONST_1);\n+                fi.visitFieldInsn(PUTFIELD, TEST_CLASS_NAME, \"f\" + i, \"J\");\n+            }\n+            if (i % MAX_FIELDS_IN_METHOD == MAX_FIELDS_IN_METHOD - 2) {\n+                fi.visitInsn(Opcodes.RETURN);\n+                fi.visitMaxs(0, 0);\n+                fi.visitEnd();\n+                fi = null;\n+            }\n+        }\n+        if (fi != null) {\n+            fi.visitInsn(Opcodes.RETURN);\n+            fi.visitMaxs(0, 0);\n+            fi.visitEnd();\n+        }\n+        {\n+            MethodVisitor mv = writer.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n+            mv.visitCode();\n+            mv.visitVarInsn(ALOAD, 0);\n+            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n+            for (int i = 0; i < fields; i += MAX_FIELDS_IN_METHOD) {\n+                mv.visitVarInsn(ALOAD, 0);\n+                mv.visitMethodInsn(INVOKESPECIAL, TEST_CLASS_NAME, \"init\" + i, \"()V\", false);\n+            }\n+            mv.visitInsn(RETURN);\n+            mv.visitMaxs(0, 0);\n+            mv.visitEnd();\n+        }\n+        writer.visitEnd();\n+\n+        byte[] bytecode = writer.toByteArray();\n+        ClassLoader cl = new ClassLoader() {\n+            @Override\n+            protected Class<?> findClass(String name) throws ClassNotFoundException {\n+                if (!TEST_CLASS_NAME.equals(name)) {\n+                    throw new ClassNotFoundException();\n+                }\n+                return defineClass(TEST_CLASS_NAME, bytecode, 0, bytecode.length);\n+            }\n+        };\n+        return cl.loadClass(TEST_CLASS_NAME);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldStream\/LocalFieldLookupTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"}]}