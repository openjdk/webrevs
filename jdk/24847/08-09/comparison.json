{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"utilities\/packedTable.hpp\"\n@@ -127,0 +128,30 @@\n+\n+\/\/ We use both name and signature during the comparison; while JLS require unique\n+\/\/ names for fields, JVMS requires only unique name + signature combination.\n+typedef struct {\n+  Symbol *name;\n+  Symbol *signature;\n+  int index;\n+  int position;\n+} field_pos_t;\n+field_pos_t *positions = nullptr;\n+\n+class FieldInfoSupplier: public PackedTableBuilder::Supplier {\n+private:\n+  const field_pos_t *_positions;\n+  size_t _elements;\n+public:\n+  FieldInfoSupplier(const field_pos_t *positions, size_t elements): _positions(positions), _elements(elements) {}\n+\n+  bool next(uint32_t *pivot, uint32_t *payload) override {\n+    if (_elements == 0) {\n+      return false;\n+    }\n+    *pivot = _positions->position;\n+    *payload = _positions->index;\n+    ++_positions;\n+    --_elements;\n+    return true;\n+  }\n+};\n+\n@@ -133,1 +164,1 @@\n-  if (static_cast<uint>(java_fields) < BinarySearchThreshold) {\n+  if (java_fields == 0 || fis->length() == 0 || static_cast<uint>(java_fields) < BinarySearchThreshold) {\n@@ -140,3 +171,1 @@\n-  int position_width = search_table_position_width(fis->length());\n-  int index_width = search_table_index_width(java_fields);\n-  int item_width = position_width + index_width;\n+  PackedTableBuilder builder(fis->length() - 1, java_fields - 1);\n@@ -144,1 +173,1 @@\n-  Array<u1>* table = MetadataFactory::new_array<u1>(loader_data, java_fields * item_width, CHECK_NULL);\n+  Array<u1>* table = MetadataFactory::new_array<u1>(loader_data, java_fields * builder.element_bytes(), CHECK_NULL);\n@@ -147,11 +176,1 @@\n-  \/\/ We use both name and signature during the comparison; while JLS require unique\n-  \/\/ names for fields, JVMS requires only unique name + signature combination.\n-  typedef struct {\n-    Symbol *name;\n-    Symbol *signature;\n-    int index;\n-    int position;\n-  } field_pos_t;\n-  field_pos_t *positions = nullptr;\n-\n-  positions = NEW_RESOURCE_ARRAY(field_pos_t, java_fields);\n+  field_pos_t* positions = NEW_RESOURCE_ARRAY(field_pos_t, java_fields);\n@@ -176,15 +195,2 @@\n-  auto write_position = position_width == 2 ?\n-    [](u1 *ptr, int position) { *reinterpret_cast<u2*>(ptr) = checked_cast<u2>(position); } :\n-    [](u1 *ptr, int position) {\n-      ptr[0] = static_cast<u1>(position);\n-      ptr[1] = static_cast<u1>(position >> 8);\n-      ptr[2] = checked_cast<u1>(position >> 16);\n-    };\n-  auto write_index = index_width == 1 ?\n-    [](u1 *ptr, int index) { *ptr = checked_cast<u1>(index); } :\n-    [](u1 *ptr, int index) { *reinterpret_cast<u2 *>(ptr) = checked_cast<u2>(index); };\n-  for (int i = 0; i < java_fields; ++i) {\n-    u1 *ptr = table->adr_at(item_width * i);\n-    write_position(ptr, positions[i].position);\n-    write_index(ptr + position_width, positions[i].index);\n-  }\n+  FieldInfoSupplier supplier(positions, java_fields);\n+  builder.fill(table, supplier);\n@@ -221,0 +227,32 @@\n+class FieldInfoComparator: public PackedTableLookup::Comparator {\n+private:\n+  const FieldInfoReader *_reader;\n+  ConstantPool *_cp;\n+  const Symbol *_name;\n+  const Symbol *_signature;\n+\n+public:\n+  FieldInfoComparator(const FieldInfoReader *reader, ConstantPool *cp, const Symbol *name, const Symbol *signature):\n+    _reader(reader), _cp(cp), _name(name), _signature(signature) {}\n+\n+  int compare_to(uint32_t position) override {\n+    FieldInfoReader r2(*_reader);\n+    r2.set_position_and_next_index(position, -1);\n+    u2 name_index, sig_index;\n+    r2.read_name_and_signature(&name_index, &sig_index);\n+    Symbol *mid_name = _cp->symbol_at(name_index);\n+    Symbol *mid_sig = _cp->symbol_at(sig_index);\n+\n+    return FieldInfoStream::compare_name_and_sig(_name, _signature, mid_name, mid_sig);\n+  }\n+\n+  void reset(uint32_t position) override {\n+    FieldInfoReader r2(*_reader);\n+    r2.set_position_and_next_index(position, -1);\n+    u2 name_index, signature_index;\n+    r2.read_name_and_signature(&name_index, &signature_index);\n+    _name = _cp->symbol_at(name_index);\n+    _signature = _cp->symbol_at(signature_index);\n+  }\n+};\n+\n@@ -229,6 +267,1 @@\n-  unsigned int position_width = search_table_position_width(fis->length());\n-  unsigned int item_width = position_width + search_table_index_width(java_fields);\n-  assert(item_width * java_fields == static_cast<unsigned int>(search_table->length()), \"size matches\");\n-  auto read_position = position_width == 3 ?\n-    [](const u1 *ptr) { return (int) ptr[0] + (((int) ptr[1] << 8)) + (((int) ptr[2]) << 16); } :\n-    [](const u1 *ptr) { return (int) *reinterpret_cast<const u2 *>(ptr); };\n+  assert(java_fields > 0, \"must be\");\n@@ -236,11 +269,2 @@\n-  \/\/ Check 1: assert that elements have the correct order based on the comparison function\n-  const Symbol* prev_name = nullptr;\n-  const Symbol* prev_sig = nullptr;\n-  const u1* ptr = search_table->data();\n-  for (int i = 0; i < java_fields; ++i, ptr += item_width) {\n-    int position = read_position(ptr);\n-    reader.set_position_and_next_index(position, -1);\n-    FieldInfo fi;\n-    reader.read_field_info(fi);\n-    const Symbol* name = fi.name(cp);\n-    const Symbol* signature = fi.signature(cp);\n+  PackedTableLookup lookup(fis->length() - 1, java_fields - 1);\n+  assert(lookup.element_bytes() * java_fields == static_cast<unsigned int>(search_table->length()), \"size does not match\");\n@@ -248,6 +272,3 @@\n-    if (prev_name != nullptr && prev_sig != nullptr) {\n-      assert(compare_name_and_sig(name, signature, prev_name, prev_sig) > 0, \"not sorted\");\n-    }\n-    prev_name = name;\n-    prev_sig = signature;\n-  }\n+  FieldInfoComparator comparator(&reader, cp, nullptr, nullptr);\n+  \/\/ Check 1: assert that elements have the correct order based on the comparison function\n+  lookup.validate_order(comparator, search_table);\n@@ -281,33 +302,9 @@\n-  FieldInfoReader r2(*this);\n-  unsigned int low = 0, high = java_fields;\n-  assert(low < high, \"must be\");\n-  unsigned int position_width = FieldInfoStream::search_table_position_width(_r.limit());\n-  unsigned int index_width = FieldInfoStream::search_table_index_width(java_fields);\n-  unsigned int item_width = position_width + index_width;\n-  auto read_position = position_width == 3 ?\n-    [](const u1 *ptr) { return (int) ptr[0] + (((int) ptr[1] << 8)) + (((int) ptr[2]) << 16); } :\n-    [](const u1 *ptr) { return (int) *reinterpret_cast<const u2 *>(ptr); };\n-  while (low < high) {\n-    unsigned int mid = low + (high - low) \/ 2;\n-    assert(mid >= low && mid < high, \"integer overflow?\");\n-    const u1 *ptr = search_table->data() + item_width * mid;\n-\n-    int position = read_position(ptr);\n-    assert(position >= 0 && position < _r.limit(), \"position out of bounds\");\n-    r2.set_position_and_next_index(position, -1);\n-    u2 name_index, sig_index;\n-    r2.read_name_and_signature(&name_index, &sig_index);\n-    Symbol *mid_name = cp->symbol_at(name_index);\n-    Symbol *mid_sig = cp->symbol_at(sig_index);\n-\n-    int cmp = FieldInfoStream::compare_name_and_sig(name, signature, mid_name, mid_sig);\n-    if (cmp == 0) {\n-      _r.set_position(position);\n-      _next_index = index_width == 2 ?\n-        *reinterpret_cast<const u2 *>(ptr + position_width) : ptr[position_width];\n-      return _next_index;\n-    } else if (cmp < 0) {\n-      high = mid;\n-    } else {\n-      low = mid + 1;\n-    }\n+  FieldInfoComparator comp(this, cp, name, signature);\n+  PackedTableLookup lookup(_r.limit() - 1, java_fields - 1);\n+  uint32_t position;\n+  static_assert(sizeof(uint32_t) == sizeof(_next_index));\n+  if (lookup.search(comp, search_table, &position, reinterpret_cast<uint32_t *>(&_next_index))) {\n+    _r.set_position(static_cast<int>(position));\n+    return _next_index;\n+  } else {\n+    return -1;\n@@ -315,1 +312,0 @@\n-  return -1;\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":84,"deletions":88,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -271,0 +271,1 @@\n+  friend class FieldInfoComparator;\n@@ -273,8 +274,0 @@\n-  static inline unsigned int search_table_position_width(int stream_length) {\n-    assert(stream_length >= 0 && stream_length <= (1 << 24), \"stream too long\");\n-    return stream_length > UINT16_MAX + 1 ? 3 : 2;\n-  }\n-  static inline unsigned int search_table_index_width(int java_fields) {\n-    assert(java_fields >= 0 && java_fields <= (1 << 16), \"too many fields\");\n-    return java_fields > UINT8_MAX + 1 ? 2 : 1;\n-  }\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/count_leading_zeros.hpp\"\n+#include \"utilities\/packedTable.hpp\"\n+\n+PackedTableBase::PackedTableBase(uint32_t max_pivot, uint32_t max_payload) {\n+  unsigned int pivot_bits = max_pivot == 0 ? 0 : 32 - count_leading_zeros(max_pivot);\n+  unsigned int payload_bits = max_payload == 0 ? 0 : 32 - count_leading_zeros(max_payload);\n+  _element_bytes = align_up(pivot_bits + payload_bits, 8) \/ 8;\n+  _pivot_mask = (1 << pivot_bits) - 1;\n+  _payload_shift = pivot_bits;\n+  _payload_mask = (1 << payload_bits) - 1;\n+  guarantee(_element_bytes > 0, \"wouldn't work\");\n+}\n+\n+void PackedTableBuilder::fill(Array<u1> *array, Supplier &supplier) const {\n+  uint32_t pivot, payload;\n+  u1 *data = array->data();\n+  size_t length = static_cast<size_t>(array->length());\n+  size_t offset = 0;\n+  for (; offset + sizeof(uint64_t) <= length && supplier.next(&pivot, &payload); offset += _element_bytes) {\n+    assert((pivot & ~_pivot_mask) == 0, \"pivot out of bounds\");\n+    assert((payload & ~_payload_mask) == 0, \"payload out of bounds\");\n+    *reinterpret_cast<uint64_t *>(data + offset) = static_cast<uint64_t>(pivot) | (static_cast<uint64_t>(payload) << _payload_shift);\n+  }\n+  \/\/ last bytes\n+  for (; offset < length && supplier.next(&pivot, &payload); offset += _element_bytes) {\n+    uint64_t value = static_cast<uint64_t>(pivot) | (static_cast<uint64_t>(payload) << _payload_shift);\n+    for (unsigned int i = 0; i < _element_bytes; ++i) {\n+      data[offset + i] = static_cast<u1>(0xFF & (value >> (8 * i)));\n+    }\n+  }\n+  assert(offset == length, \"Did not fill whole array\");\n+  assert(!supplier.next(&pivot, &payload), \"Supplier has more elements\");\n+}\n+\n+uint64_t PackedTableLookup::read_value(const u1* data, size_t length, size_t offset) const {\n+  if (offset + sizeof(uint64_t) <= length) {\n+    return *reinterpret_cast<const uint64_t *>(data + offset);\n+  }\n+  \/\/ slow path for accessing end of array\n+  uint64_t value = 0;\n+  for (size_t i = 0; i < sizeof(uint64_t) && offset + i < length; ++i) {\n+    value = value | (data[offset + i] << (i * 8));\n+  }\n+  return value;\n+}\n+\n+bool PackedTableLookup::search(Comparator& comparator, const Array<u1>* search_table, uint32_t* found_pivot, uint32_t* found_payload) const {\n+  unsigned int low = 0, high = search_table->length() \/ _element_bytes;\n+  assert(low < high, \"must be\");\n+  const u1 *data = search_table->data();\n+  while (low < high) {\n+    unsigned int mid = low + (high - low) \/ 2;\n+    assert(mid >= low && mid < high, \"integer overflow?\");\n+    uint64_t value = read_value(data, static_cast<size_t>(search_table->length()), _element_bytes * mid);\n+    uint32_t pivot = value & _pivot_mask;\n+    int cmp = comparator.compare_to(pivot);\n+    if (cmp == 0) {\n+      *found_pivot = pivot;\n+      *found_payload = (value >> _payload_shift) & _payload_mask;\n+      return true;\n+    } else if (cmp < 0) {\n+      high = mid;\n+    } else {\n+      low = mid + 1;\n+    }\n+  }\n+  return false;\n+}\n+\n+#ifdef ASSERT\n+void PackedTableLookup::validate_order(Comparator &comparator, const Array<u1> *search_table) const {\n+  const u1* data = search_table->data();\n+  size_t length = static_cast<size_t>(search_table->length());\n+  for (size_t offset = 0; offset < length; offset += _element_bytes) {\n+    uint64_t value = read_value(data, length, offset);\n+    uint32_t pivot = value & _pivot_mask;\n+\n+    if (offset != 0) {\n+      assert(comparator.compare_to(pivot) < 0, \"not sorted\");\n+    }\n+    comparator.reset(pivot);\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/share\/utilities\/packedTable.cpp","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * Base for space-optimized structure supporting binary search. Each element\n+ * consists of up to 32-bit pivot, and up to 32-bit payload; these are packed\n+ * into a bit-record aligned on bytes.\n+ * The pivots are ordered according to a custom comparator.\n+ *\/\n+class PackedTableBase {\n+protected:\n+  unsigned int _element_bytes;\n+  uint32_t _pivot_mask;\n+  unsigned int _payload_shift;\n+  uint32_t _payload_mask;\n+\n+public:\n+  PackedTableBase(uint32_t max_pivot, uint32_t max_payload);\n+\n+  inline unsigned int element_bytes(void) const { return _element_bytes; }\n+};\n+\n+class PackedTableBuilder: public PackedTableBase {\n+public:\n+  class Supplier {\n+  public:\n+    virtual bool next(uint32_t *pivot, uint32_t *payload) = 0;\n+  };\n+\n+  PackedTableBuilder(uint32_t max_pivot, uint32_t max_payload): PackedTableBase(max_pivot, max_payload) {}\n+\n+  \/\/ The supplier should return elements with already ordered pivots.\n+  \/\/ We can't easily sort within the builder because qsort() accepts\n+  \/\/ only pure function as comparator.\n+  void fill(Array<u1> *search_table, Supplier &supplier) const;\n+};\n+\n+class PackedTableLookup: public PackedTableBase {\n+private:\n+  uint64_t read_value(const u1* data, size_t length, size_t offset) const;\n+\n+public:\n+  class Comparator {\n+  public:\n+    virtual int compare_to(uint32_t pivot) = 0;\n+    virtual void reset(uint32_t pivot) = 0;\n+  };\n+\n+  PackedTableLookup(uint32_t max_pivot, uint32_t max_payload): PackedTableBase(max_pivot, max_payload) {}\n+\n+  bool search(Comparator& comparator, const Array<u1>* search_table, uint32_t* found_pivot, uint32_t* found_payload) const;\n+  DEBUG_ONLY(void validate_order(Comparator &comparator, const Array<u1> *search_table) const);\n+};\n","filename":"src\/hotspot\/share\/utilities\/packedTable.hpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}