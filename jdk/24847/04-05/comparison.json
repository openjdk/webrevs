{"files":[{"patch":"@@ -3741,0 +3741,1 @@\n+  this_klass->set_fieldinfo_search_table(_fieldinfo_search_table);\n@@ -5056,0 +5057,1 @@\n+  assert(nullptr == _fieldinfo_search_table, \"invariant\");\n@@ -5276,0 +5278,1 @@\n+  _fieldinfo_search_table(nullptr),\n@@ -5352,0 +5355,1 @@\n+  _fieldinfo_search_table = nullptr;\n@@ -5374,0 +5378,1 @@\n+  MetadataFactory::free_array<u1>(_loader_data, _fieldinfo_search_table);\n@@ -5772,1 +5777,1 @@\n-    FieldInfoStream::create_FieldInfoStream(_cp, _temp_field_info, _java_fields_count,\n+    FieldInfoStream::create_FieldInfoStream(_temp_field_info, _java_fields_count,\n@@ -5774,0 +5779,1 @@\n+  _fieldinfo_search_table = FieldInfoStream::create_search_table(_cp, _fieldinfo_stream, _loader_data, CHECK);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -126,0 +126,1 @@\n+  Array<u1>* _fieldinfo_search_table;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -966,1 +966,1 @@\n-      Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(ik->constants(), fields, java_fields, injected_fields, k->class_loader_data(), CHECK);\n+      Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(fields, java_fields, injected_fields, k->class_loader_data(), CHECK);\n@@ -969,0 +969,5 @@\n+\n+      Array<u1> *old_table = ik->fieldinfo_search_table();\n+      Array<u1>* search_table = FieldInfoStream::create_search_table(ik->constants(), new_fis, k->class_loader_data(), CHECK);\n+      ik->set_fieldinfo_search_table(search_table);\n+      MetadataFactory::free_array<u1>(k->class_loader_data(), old_table);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -815,2 +815,0 @@\n-                                                                          \\\n-  declare_constant(FieldInfoStream::SORTED_FIELD_TABLE_THRESHOLD)         \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,19 +53,1 @@\n-int FieldInfoStream::compare_symbols(const Symbol *s1, const Symbol *s2) {\n-  \/\/ not lexicographical sort, since we need only total ordering\n-  int l1 = s1->utf8_length();\n-  int l2 = s2->utf8_length();\n-  if (l1 == l2) {\n-    for (int i = 0; i < l1; ++i) {\n-      char c1 = s1->char_at(i);\n-      char c2 = s2->char_at(i);\n-      if (c1 != c2) {\n-        return c1 - c2;\n-      }\n-    }\n-    return 0;\n-  } else {\n-    return l1 - l2;\n-  }\n-}\n-\n-Array<u1>* FieldInfoStream::create_FieldInfoStream(ConstantPool* constants, GrowableArray<FieldInfo>* fields, int java_fields, int injected_fields,\n+Array<u1>* FieldInfoStream::create_FieldInfoStream(GrowableArray<FieldInfo>* fields, int java_fields, int injected_fields,\n@@ -74,2 +56,1 @@\n-  \/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields SortedFieldTable_offset(0\/4 bytes) Field[j+k] SortedFieldRecord[j] End\n-  \/\/   SortedFieldRecord := stream_position(2-3 bytes) field_index(1-2 bytes)\n+  \/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields Field[j+k] End\n@@ -87,2 +68,0 @@\n-  sizer.consumer()->accept_uint(java_fields);\n-  sizer.consumer()->accept_uint(injected_fields);\n@@ -90,42 +69,0 @@\n-  \/\/ We need to put JumpTable at end because the position of fields must not depend\n-  \/\/ on the size of JumpTable.\n-  if (java_fields > SORTED_FIELD_TABLE_THRESHOLD) {\n-    sizer.consumer()->accept_bytes(sizeof(uint32_t));\n-  }\n-  ResourceMark rm;\n-  \/\/ We use both name and signature during the comparison; while JLS require unique\n-  \/\/ names for fields, JVMS requires only unique name + signature combination.\n-  typedef struct {\n-    Symbol *name;\n-    Symbol *signature;\n-    int index;\n-    int position;\n-  } field_pos_t;\n-  field_pos_t *positions = nullptr;\n-  int sorted_table_position_width = 0;\n-  int sorted_table_index_width = 0;\n-  int sorted_table_item_width = 0;\n-  if (java_fields > SORTED_FIELD_TABLE_THRESHOLD) {\n-    positions = NEW_RESOURCE_ARRAY(field_pos_t, java_fields);\n-    for (int i = 0; i < java_fields; ++i) {\n-      positions[i].name = fields->at(i).name(constants);\n-      positions[i].signature = fields->at(i).signature(constants);\n-      positions[i].index = i;\n-      positions[i].position = sizer.consumer()->position();\n-      sizer.map_field_info(fields->at(i));\n-    }\n-    for (int i = java_fields; i < fields->length(); ++i) {\n-      sizer.map_field_info(fields->at(i));\n-    }\n-    auto compare_pair = [](const void *v1, const void *v2) {\n-      int name_result = FieldInfoStream::compare_symbols(\n-        reinterpret_cast<const field_pos_t *>(v1)->name,\n-        reinterpret_cast<const field_pos_t *>(v2)->name);\n-      if (name_result != 0) {\n-        return name_result;\n-      }\n-      return FieldInfoStream::compare_symbols(\n-        reinterpret_cast<const field_pos_t *>(v1)->signature,\n-        reinterpret_cast<const field_pos_t *>(v2)->signature);\n-    };\n-    qsort(positions, java_fields, sizeof(field_pos_t), compare_pair);\n@@ -133,10 +70,5 @@\n-    \/\/ We use fixed width to let us skip through the table during binary search.\n-    \/\/ With the max of 65536 fields (and at most tens of bytes per field),\n-    \/\/ 3-byte offsets would suffice. In the common case with < 64kB stream 2-byte offsets are enough.\n-    sorted_table_position_width = sizer.consumer()->position() > (UINT16_MAX + 1) ? 3 : 2;\n-    sorted_table_index_width = java_fields > (UINT8_MAX + 1) ? 2 : 1;\n-    sorted_table_item_width = sorted_table_position_width + sorted_table_index_width;\n-  } else {\n-    for (int i = 0; i < fields->length(); ++i) {\n-      sizer.map_field_info(fields->at(i));\n-    }\n+  sizer.consumer()->accept_uint(java_fields);\n+  sizer.consumer()->accept_uint(injected_fields);\n+  for (int i = 0; i < fields->length(); i++) {\n+    FieldInfo* fi = fields->adr_at(i);\n+    sizer.map_field_info(*fi);\n@@ -145,2 +77,2 @@\n-  \/\/ now we check limits instead as there may be the SortedTable\n-  int storage_size = sizer.consumer()->position() + java_fields * sorted_table_item_width;\n+  \/\/ now we check limits instead.\n+  int storage_size = sizer.consumer()->position();\n@@ -156,4 +88,0 @@\n-  int sorted_table_offset_pos = w.position();\n-  if (positions != nullptr) {\n-    w.set_position(w.position() + sizeof(uint32_t));\n-  }\n@@ -163,19 +91,0 @@\n-  if (java_fields > SORTED_FIELD_TABLE_THRESHOLD) {\n-    *reinterpret_cast<uint32_t*>(w.array()->adr_at(sorted_table_offset_pos)) = checked_cast<uint32_t>(w.position());\n-\n-    auto write_position = sorted_table_position_width == 2 ?\n-      [](u1 *ptr, int position) { *reinterpret_cast<u2*>(ptr) = checked_cast<u2>(position); } :\n-      [](u1 *ptr, int position) {\n-        ptr[0] = static_cast<u1>(position);\n-        ptr[1] = static_cast<u1>(position >> 8);\n-        ptr[2] = checked_cast<u1>(position >> 16);\n-      };\n-    auto write_index = sorted_table_index_width == 1 ?\n-      [](u1 *ptr, int index) { *ptr = checked_cast<u1>(index); } :\n-      [](u1 *ptr, int index) { *reinterpret_cast<u2 *>(ptr) = checked_cast<u2>(index); };\n-     for (int i = 0; i < java_fields; ++i) {\n-      u1 *ptr = w.array()->adr_at(w.position() + sorted_table_item_width * i);\n-      write_position(ptr, positions[i].position);\n-      write_index(ptr + sorted_table_position_width, positions[i].index);\n-    }\n-  }\n@@ -213,0 +122,70 @@\n+Array<u1>* FieldInfoStream::create_search_table(ConstantPool* cp, const Array<u1>* fis, ClassLoaderData* loader_data, TRAPS) {\n+  FieldInfoReader r(fis);\n+  int java_fields;\n+  int injected_fields;\n+  r.read_field_counts(&java_fields, &injected_fields);\n+  if (java_fields <= SEARCH_TABLE_THRESHOLD) {\n+    return nullptr;\n+  }\n+\n+  \/\/ We use fixed width to let us skip through the table during binary search.\n+  \/\/ With the max of 65536 fields (and at most tens of bytes per field),\n+  \/\/ 3-byte offsets would suffice. In the common case with < 64kB stream 2-byte offsets are enough.\n+  int position_width = fis->length() > UINT16_MAX + 1 ? 3 : 2;\n+  int index_width = java_fields > UINT8_MAX + 1 ? 2 : 1;\n+  int item_width = position_width + index_width;\n+\n+  Array<u1>* table = MetadataFactory::new_array<u1>(loader_data, java_fields * item_width, CHECK_NULL);\n+\n+  ResourceMark rm;\n+  \/\/ We use both name and signature during the comparison; while JLS require unique\n+  \/\/ names for fields, JVMS requires only unique name + signature combination.\n+  typedef struct {\n+    Symbol *name;\n+    Symbol *signature;\n+    int index;\n+    int position;\n+  } field_pos_t;\n+  field_pos_t *positions = nullptr;\n+\n+  positions = NEW_RESOURCE_ARRAY(field_pos_t, java_fields);\n+  for (int i = 0; i < java_fields; ++i) {\n+    assert(r.has_next(), \"number of fields must match\");\n+\n+    positions[i].position = r.position();\n+    FieldInfo fi;\n+    r.read_field_info(fi);\n+\n+    positions[i].name = fi.name(cp);\n+    positions[i].signature = fi.signature(cp);\n+    positions[i].index = i;\n+  }\n+  auto compare_pair = [](const void *v1, const void *v2) {\n+    int name_result = reinterpret_cast<const field_pos_t *>(v1)->name->fast_compare(\n+                      reinterpret_cast<const field_pos_t *>(v2)->name);\n+    if (name_result != 0) {\n+      return name_result;\n+    }\n+    return reinterpret_cast<const field_pos_t *>(v1)->signature->fast_compare(\n+           reinterpret_cast<const field_pos_t *>(v2)->signature);\n+  };\n+  qsort(positions, java_fields, sizeof(field_pos_t), compare_pair);\n+\n+  auto write_position = position_width == 2 ?\n+    [](u1 *ptr, int position) { *reinterpret_cast<u2*>(ptr) = checked_cast<u2>(position); } :\n+    [](u1 *ptr, int position) {\n+      ptr[0] = static_cast<u1>(position);\n+      ptr[1] = static_cast<u1>(position >> 8);\n+      ptr[2] = checked_cast<u1>(position >> 16);\n+    };\n+  auto write_index = index_width == 1 ?\n+    [](u1 *ptr, int index) { *ptr = checked_cast<u1>(index); } :\n+    [](u1 *ptr, int index) { *reinterpret_cast<u2 *>(ptr) = checked_cast<u2>(index); };\n+  for (int i = 0; i < java_fields; ++i) {\n+    u1 *ptr = table->adr_at(item_width * i);\n+    write_position(ptr, positions[i].position);\n+    write_index(ptr + position_width, positions[i].index);\n+  }\n+  return table;\n+}\n+\n@@ -240,1 +219,1 @@\n-int FieldInfoReader::sorted_table_lookup(const Symbol *name, const Symbol *signature, ConstantPool *cp, int java_fields) {\n+int FieldInfoReader::search_table_lookup(const Array<u1> *search_table, const Symbol *name, const Symbol *signature, ConstantPool *cp, int java_fields) {\n@@ -243,2 +222,1 @@\n-  int table_offset = _r.limit();\n-  int position_width = (table_offset > UINT16_MAX + 1 ? 3 : 2);\n+  int position_width = _r.limit() > UINT16_MAX + 1 ? 3 : 2;\n@@ -246,1 +224,1 @@\n-  auto read_position = table_offset > UINT16_MAX + 1 ?\n+  auto read_position = _r.limit() > UINT16_MAX + 1 ?\n@@ -251,1 +229,1 @@\n-    const u1 *ptr = _r.array() + table_offset + item_width * mid;\n+    const u1 *ptr = search_table->data() + item_width * mid;\n@@ -259,1 +237,1 @@\n-      _next_index = java_fields > UINT8_MAX + 1 ?\n+      int _next_index = java_fields > UINT8_MAX + 1 ?\n@@ -264,1 +242,1 @@\n-    int cmp = FieldInfoStream::compare_symbols(name, mid_name);\n+    int cmp = name->fast_compare(mid_name);\n@@ -272,1 +250,1 @@\n-    cmp = FieldInfoStream::compare_symbols(signature, mid_sig);\n+    cmp = signature->fast_compare(mid_sig);\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":86,"deletions":108,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-  int sorted_table_lookup(const Symbol *name, const Symbol *signature, ConstantPool *cp, int java_fields);\n+  int search_table_lookup(const Array<u1> *search_table, const Symbol *name, const Symbol *signature, ConstantPool *cp, int java_fields);\n@@ -257,2 +257,1 @@\n-\/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields SortedFieldTable_offset(0\/4 bytes) Field[j+k] SortedFieldRecord[j] End\n-\/\/   SortedFieldRecord := stream_position(2-3 bytes) field_index(1-2 bytes)\n+\/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields Field[j+k] End\n@@ -273,1 +272,1 @@\n-  static const int SORTED_FIELD_TABLE_THRESHOLD = 16;\n+  static const int SEARCH_TABLE_THRESHOLD = 16;\n@@ -279,4 +278,3 @@\n-  static int compare_symbols(const Symbol *s1, const Symbol *s2);\n-\n-  static Array<u1>* create_FieldInfoStream(ConstantPool* constants, GrowableArray<FieldInfo>* fields, int java_fields, int injected_fields,\n-                                                          ClassLoaderData* loader_data, TRAPS);\n+  static Array<u1>* create_FieldInfoStream(GrowableArray<FieldInfo>* fields, int java_fields, int injected_fields,\n+                                           ClassLoaderData* loader_data, TRAPS);\n+  static Array<u1>* create_search_table(ConstantPool* cp, const Array<u1>* fis, ClassLoaderData* loader_data, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -114,5 +114,0 @@\n-  if (*java_fields > FieldInfoStream::SORTED_FIELD_TABLE_THRESHOLD) {\n-    uint32_t sorted_table_offset = *reinterpret_cast<const uint32_t *>(_r.array() + _r.position());\n-    _r.set_limit(sorted_table_offset);\n-    _r.set_position(_r.position() + sizeof(uint32_t));\n-  }\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -66,1 +66,5 @@\n-    assert( _limit <= java_fields_count + injected_fields_count, \"Safety check\");\n+    if (_limit < _index) {\n+      _limit = java_fields_count + injected_fields_count;\n+    } else {\n+      assert( _limit <= java_fields_count + injected_fields_count, \"Safety check\");\n+    }\n@@ -143,0 +147,2 @@\n+ private:\n+  Array<u1> *_search_table;\n@@ -144,1 +150,2 @@\n-  JavaFieldStream(const InstanceKlass* k): FieldStreamBase(k->fieldinfo_stream(), k->constants(), 0, k->java_fields_count()) {}\n+  JavaFieldStream(const InstanceKlass* k): FieldStreamBase(k->fieldinfo_stream(), k->constants(), 0, k->java_fields_count()),\n+    _search_table(k->fieldinfo_search_table()) {}\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,7 +36,3 @@\n-         _constants(constantPoolHandle(Thread::current(), constants)), _index(start) {\n-  _index = start;\n-  if (limit < start) {\n-    _limit = FieldInfoStream::num_total_fields(_fieldinfo_stream);\n-  } else {\n-    _limit = limit;\n-  }\n+         _constants(constantPoolHandle(Thread::current(), constants)),\n+         _index(start),\n+         _limit(limit) {\n@@ -51,1 +47,1 @@\n-        _limit(FieldInfoStream::num_total_fields(_fieldinfo_stream)) {\n+        _limit(-1) {\n@@ -60,1 +56,1 @@\n-         _limit(FieldInfoStream::num_total_fields(_fieldinfo_stream)) {\n+         _limit(-1) {\n@@ -66,2 +62,2 @@\n-  if (_limit > FieldInfoStream::SORTED_FIELD_TABLE_THRESHOLD) {\n-    int index = _reader.sorted_table_lookup(name, signature, _constants(), _limit);\n+  if (_search_table != nullptr) {\n+    int index = _reader.search_table_lookup(_search_table, name, signature, _constants(), _limit);\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.inline.hpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -689,0 +689,5 @@\n+  if (fieldinfo_search_table() != nullptr && !fieldinfo_search_table()->is_shared()) {\n+    MetadataFactory::free_array<u1>(loader_data, fieldinfo_search_table());\n+  }\n+  set_fieldinfo_search_table(nullptr);\n+\n@@ -2605,0 +2610,1 @@\n+  it->push(&_fieldinfo_search_table);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -279,0 +279,1 @@\n+  Array<u1>*          _fieldinfo_search_table;\n@@ -407,0 +408,3 @@\n+  Array<u1>* fieldinfo_search_table() const { return _fieldinfo_search_table; }\n+  void set_fieldinfo_search_table(Array<u1> *table) { _fieldinfo_search_table = table; }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3558,1 +3558,1 @@\n-    Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(cp, fields, java_fields, injected_fields, scratch_class->class_loader_data(), CHECK);\n+    Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(fields, java_fields, injected_fields, scratch_class->class_loader_data(), CHECK);\n@@ -3561,0 +3561,5 @@\n+\n+    Array<u1>* old_table = scratch_class->fieldinfo_search_table();\n+    Array<u1>* search_table = FieldInfoStream::create_search_table(scratch_class->constants(), new_fis, scratch_class->class_loader_data(), CHECK);\n+    scratch_class->set_fieldinfo_search_table(search_table);\n+    MetadataFactory::free_array<u1>(scratch_class->class_loader_data(), old_table);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -395,3 +395,0 @@\n-    void accept_bytes(OFF bytes) {\n-      _position += bytes;\n-    }\n","filename":"src\/hotspot\/share\/utilities\/unsigned5.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -66,4 +66,0 @@\n-  public void skipBytes(int bytes) {\n-    this.position += bytes;\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CompressedStream.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-  private static final int SORTED_FIELD_TABLE_THRESHOLD =\n-    VM.getVM().getTypeDataBase().lookupIntConstant(\"FieldInfoStream::SORTED_FIELD_TABLE_THRESHOLD\");\n@@ -116,5 +114,0 @@\n-    \/\/ Sorted fields table is generated only for classes with > 16 (non-injected) fields\n-    if (numJavaFields > SORTED_FIELD_TABLE_THRESHOLD) {\n-      \/\/ Sorted field table offset offset (is not variable-size encoded)\n-      crs.skipBytes(4);\n-    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Field.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"}]}