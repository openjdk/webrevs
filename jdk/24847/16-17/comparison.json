{"files":[{"patch":"@@ -146,1 +146,1 @@\n-  bool next(uint32_t *pivot, uint32_t *payload) override {\n+  bool next(uint32_t *key, uint32_t *value) override {\n@@ -150,2 +150,2 @@\n-    *pivot = _positions->position;\n-    *payload = _positions->index;\n+    *key = _positions->position;\n+    *value = _positions->index;\n@@ -196,1 +196,1 @@\n-  builder.fill(table, supplier);\n+  builder.fill(table->data(), static_cast<size_t>(table->length()), supplier);\n@@ -274,1 +274,1 @@\n-  lookup.validate_order(comparator, search_table);\n+  lookup.validate_order(comparator, search_table->data(), static_cast<size_t>(search_table->length()));\n@@ -306,1 +306,2 @@\n-  if (lookup.search(comp, search_table, &position, reinterpret_cast<uint32_t *>(&_next_index))) {\n+  if (lookup.search(comp, search_table->data(), static_cast<size_t>(search_table->length()),\n+      &position, reinterpret_cast<uint32_t *>(&_next_index))) {\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,7 +29,8 @@\n-PackedTableBase::PackedTableBase(uint32_t max_pivot, uint32_t max_payload) {\n-  unsigned int pivot_bits = max_pivot == 0 ? 0 : 32 - count_leading_zeros(max_pivot);\n-  unsigned int payload_bits = max_payload == 0 ? 0 : 32 - count_leading_zeros(max_payload);\n-  _element_bytes = align_up(pivot_bits + payload_bits, 8) \/ 8;\n-  _pivot_mask = (1 << pivot_bits) - 1;\n-  _payload_shift = pivot_bits;\n-  _payload_mask = (1 << payload_bits) - 1;\n+PackedTableBase::PackedTableBase(uint32_t max_key, uint32_t max_value) {\n+  unsigned int key_bits = max_key == 0 ? 0 : 32 - count_leading_zeros(max_key);\n+  unsigned int value_bits = max_value == 0 ? 0 : 32 - count_leading_zeros(max_value);\n+  _element_bytes = align_up(key_bits + value_bits, 8) \/ 8;\n+  \/\/ shifting left by 32 is undefined behaviour, and in practice returns 1\n+  _key_mask = key_bits >= 32 ? -1 : (1U << key_bits) - 1;\n+  _value_shift = key_bits;\n+  _value_mask = value_bits >= 32 ? -1 : (1U << value_bits) - 1;\n@@ -40,4 +41,2 @@\n-void PackedTableBuilder::fill(Array<u1> *array, Supplier &supplier) const {\n-  uint32_t pivot, payload;\n-  u1 *data = array->data();\n-  size_t length = static_cast<size_t>(array->length());\n+void PackedTableBuilder::fill(u1 *data, size_t length, Supplier &supplier) const {\n+  uint32_t key, value;\n@@ -45,4 +44,4 @@\n-  for (; offset + sizeof(uint64_t) <= length && supplier.next(&pivot, &payload); offset += _element_bytes) {\n-    assert((pivot & ~_pivot_mask) == 0, \"pivot out of bounds\");\n-    assert((payload & ~_payload_mask) == 0, \"payload out of bounds\");\n-    *reinterpret_cast<uint64_t *>(data + offset) = static_cast<uint64_t>(pivot) | (static_cast<uint64_t>(payload) << _payload_shift);\n+  for (; offset + sizeof(uint64_t) <= length && supplier.next(&key, &value); offset += _element_bytes) {\n+    assert((key & ~_key_mask) == 0, \"key out of bounds\");\n+    assert((value & ~_value_mask) == 0, \"value out of bounds: %x vs. %x (%x)\", value, _value_mask, ~_value_mask);\n+    *reinterpret_cast<uint64_t *>(data + offset) = static_cast<uint64_t>(key) | (static_cast<uint64_t>(value) << _value_shift);\n@@ -51,2 +50,2 @@\n-  for (; offset < length && supplier.next(&pivot, &payload); offset += _element_bytes) {\n-    uint64_t value = static_cast<uint64_t>(pivot) | (static_cast<uint64_t>(payload) << _payload_shift);\n+  for (; offset < length && supplier.next(&key, &value); offset += _element_bytes) {\n+    uint64_t element = static_cast<uint64_t>(key) | (static_cast<uint64_t>(value) << _value_shift);\n@@ -54,1 +53,1 @@\n-      data[offset + i] = static_cast<u1>(0xFF & (value >> (8 * i)));\n+      data[offset + i] = static_cast<u1>(0xFF & (element >> (8 * i)));\n@@ -59,1 +58,1 @@\n-  assert(!supplier.next(&pivot, &payload), \"Supplier has more elements\");\n+  assert(!supplier.next(&key, &value), \"Supplier has more elements\");\n@@ -62,1 +61,1 @@\n-uint64_t PackedTableLookup::read_value(const u1* data, size_t length, size_t offset) const {\n+uint64_t PackedTableLookup::read_element(const u1* data, size_t length, size_t offset) const {\n@@ -67,1 +66,1 @@\n-  uint64_t value = 0;\n+  uint64_t element = 0;\n@@ -69,1 +68,1 @@\n-    value = value | (static_cast<uint64_t>(data[offset + i]) << (i * 8));\n+    element = element | (static_cast<uint64_t>(data[offset + i]) << (i * 8));\n@@ -71,2 +70,2 @@\n-  assert((value & ~((uint64_t) _pivot_mask | ((uint64_t) _payload_mask << _payload_shift))) == 0, \"read too much\");\n-  return value;\n+  assert((element & ~((uint64_t) _key_mask | ((uint64_t) _value_mask << _value_shift))) == 0, \"read too much\");\n+  return element;\n@@ -75,2 +74,2 @@\n-bool PackedTableLookup::search(Comparator& comparator, const Array<u1>* search_table, uint32_t* found_pivot, uint32_t* found_payload) const {\n-  unsigned int low = 0, high = search_table->length() \/ _element_bytes;\n+bool PackedTableLookup::search(Comparator& comparator, const u1* data, size_t search_table_length, uint32_t* found_key, uint32_t* found_value) const {\n+  unsigned int low = 0, high = search_table_length \/ _element_bytes;\n@@ -78,1 +77,0 @@\n-  const u1 *data = search_table->data();\n@@ -82,3 +80,3 @@\n-    uint64_t value = read_value(data, static_cast<size_t>(search_table->length()), _element_bytes * mid);\n-    uint32_t pivot = value & _pivot_mask;\n-    int cmp = comparator.compare_to(pivot);\n+    uint64_t element = read_element(data, search_table_length, _element_bytes * mid);\n+    uint32_t key = element & _key_mask;\n+    int cmp = comparator.compare_to(key);\n@@ -86,2 +84,2 @@\n-      *found_pivot = pivot;\n-      *found_payload = (value >> _payload_shift) & _payload_mask;\n+      *found_key = key;\n+      *found_value = (element >> _value_shift) & _value_mask;\n@@ -99,3 +97,1 @@\n-void PackedTableLookup::validate_order(Comparator &comparator, const Array<u1> *search_table) const {\n-  const u1* data = search_table->data();\n-  size_t length = static_cast<size_t>(search_table->length());\n+void PackedTableLookup::validate_order(Comparator &comparator, const u1 *search_table, size_t length) const {\n@@ -103,2 +99,2 @@\n-    uint64_t value = read_value(data, length, offset);\n-    uint32_t pivot = value & _pivot_mask;\n+    uint64_t element = read_element(search_table, length, offset);\n+    uint32_t key = element & _key_mask;\n@@ -107,1 +103,1 @@\n-      assert(comparator.compare_to(pivot) < 0, \"not sorted\");\n+      assert(comparator.compare_to(key) < 0, \"not sorted\");\n@@ -109,1 +105,1 @@\n-    comparator.reset(pivot);\n+    comparator.reset(key);\n","filename":"src\/hotspot\/share\/utilities\/packedTable.cpp","additions":35,"deletions":39,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"oops\/array.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -29,1 +29,1 @@\n- * consists of up to 32-bit pivot, and up to 32-bit payload; these are packed\n+ * consists of up to 32-bit key, and up to 32-bit value; these are packed\n@@ -31,1 +31,1 @@\n- * The pivots are ordered according to a custom comparator.\n+ * The keys are ordered according to a custom comparator.\n@@ -36,3 +36,3 @@\n-  uint32_t _pivot_mask;\n-  unsigned int _payload_shift;\n-  uint32_t _payload_mask;\n+  uint32_t _key_mask;\n+  unsigned int _value_shift;\n+  uint32_t _value_mask;\n@@ -41,1 +41,1 @@\n-  PackedTableBase(uint32_t max_pivot, uint32_t max_payload);\n+  PackedTableBase(uint32_t max_key, uint32_t max_value);\n@@ -50,1 +50,2 @@\n-    virtual bool next(uint32_t *pivot, uint32_t *payload) = 0;\n+    \/* Returns elements with already ordered keys. *\/\n+    virtual bool next(uint32_t *key, uint32_t *value) = 0;\n@@ -53,1 +54,1 @@\n-  PackedTableBuilder(uint32_t max_pivot, uint32_t max_payload): PackedTableBase(max_pivot, max_payload) {}\n+  PackedTableBuilder(uint32_t max_key, uint32_t max_value): PackedTableBase(max_key, max_value) {}\n@@ -55,1 +56,1 @@\n-  \/\/ The supplier should return elements with already ordered pivots.\n+  \/\/ The supplier should return elements with already ordered keys.\n@@ -58,1 +59,1 @@\n-  void fill(Array<u1> *search_table, Supplier &supplier) const;\n+  void fill(u1 *search_table, size_t search_table_length, Supplier &supplier) const;\n@@ -63,1 +64,1 @@\n-  uint64_t read_value(const u1* data, size_t length, size_t offset) const;\n+  uint64_t read_element(const u1* data, size_t length, size_t offset) const;\n@@ -66,0 +67,6 @@\n+  \/*\n+   * The comparator implementation does not have to store a key (uint32_t);\n+   * the idea is that key can point into a different structure that hosts data\n+   * suitable for the actual comparison. That's why PackedTableLookup::search(...)\n+   * returns the key it found as well as the value.\n+   *\/\n@@ -68,2 +75,2 @@\n-    virtual int compare_to(uint32_t pivot) = 0;\n-    virtual void reset(uint32_t pivot) = 0;\n+    virtual int compare_to(uint32_t key) = 0;\n+    virtual void reset(uint32_t key) = 0;\n@@ -72,1 +79,1 @@\n-  PackedTableLookup(uint32_t max_pivot, uint32_t max_payload): PackedTableBase(max_pivot, max_payload) {}\n+  PackedTableLookup(uint32_t max_key, uint32_t max_value): PackedTableBase(max_key, max_value) {}\n@@ -74,2 +81,2 @@\n-  bool search(Comparator& comparator, const Array<u1>* search_table, uint32_t* found_pivot, uint32_t* found_payload) const;\n-  DEBUG_ONLY(void validate_order(Comparator &comparator, const Array<u1> *search_table) const);\n+  bool search(Comparator& comparator, const u1* search_table, size_t search_table_length, uint32_t* found_key, uint32_t* found_value) const;\n+  DEBUG_ONLY(void validate_order(Comparator &comparator, const u1 *search_table, size_t search_table_length) const);\n","filename":"src\/hotspot\/share\/utilities\/packedTable.hpp","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"utilities\/packedTable.hpp\"\n+#include \"unittest.hpp\"\n+\n+class Supplier: public PackedTableBuilder::Supplier {\n+private:\n+    uint32_t *_keys;\n+    uint32_t *_values;\n+    size_t _num_keys;\n+public:\n+    Supplier(uint32_t *keys, uint32_t *values, size_t num_keys):\n+        _keys(keys), _values(values), _num_keys(num_keys) {}\n+\n+    bool next(uint32_t *key, uint32_t *value) override {\n+        if (_num_keys == 0) {\n+            return false;\n+        }\n+        *key = *_keys;\n+        ++_keys;\n+        if (_values != nullptr) {\n+            *value = *_values;\n+            ++_values;\n+        } else {\n+            *value = 0;\n+        }\n+        --_num_keys;\n+        return true;\n+    }\n+};\n+\n+class Comparator: public PackedTableLookup::Comparator {\n+private:\n+    uint32_t _current;\n+public:\n+    int compare_to(uint32_t key) override {\n+        return _current < key ? -1 : (_current > key ? 1 : 0);\n+    }\n+    void reset(uint32_t key) override {\n+        _current = key;\n+    }\n+};\n+\n+static void test(uint32_t max_key, uint32_t max_value, unsigned int length) {\n+    if (length > max_key + 1) {\n+        \/\/ can't generate more keys, as keys must be unique\n+        return;\n+    }\n+    PackedTableBuilder builder(max_key, max_value);\n+    size_t table_bytes = length * builder.element_bytes();\n+    u1 *table = new u1[table_bytes];\n+\n+    uint32_t *keys = new uint32_t[length];\n+    uint32_t *values = max_value != 0 ? new uint32_t[length] : nullptr;\n+    for (unsigned int i = 0; i < length; ++i) {\n+        keys[i] = i;\n+        if (values != nullptr) {\n+            values[i] = i % max_value;\n+        }\n+    }\n+    Supplier sup(keys, values, length);\n+    builder.fill(table, table_bytes, sup);\n+\n+    Comparator comparator;\n+    PackedTableLookup lookup(max_key, max_value);\n+#ifdef ASSERT\n+    lookup.validate_order(comparator, table, table_bytes);\n+#endif\n+\n+    for (unsigned int i = 0; i < length; ++i) {\n+        uint32_t key, value;\n+        comparator.reset(keys[i]);\n+        EXPECT_TRUE(lookup.search(comparator, table, table_bytes, &key, &value));\n+        EXPECT_EQ(key, keys[i]);\n+        if (values != nullptr) {\n+            EXPECT_EQ(value, values[i]);\n+        } else {\n+            EXPECT_EQ(value, 0U);\n+        }\n+    }\n+\n+    delete[] keys;\n+    delete[] values;\n+}\n+\n+static void test_with_bits(uint32_t max_key, uint32_t max_value) {\n+    \/\/ Some small sizes\n+    for (unsigned int i = 0; i <= 100; ++i) {\n+        test(max_key, max_value, 0);\n+    }\n+    test(max_key, max_value, 10000);\n+}\n+\n+TEST(PackedTableLookup, lookup) {\n+    for (int key_bits = 1; key_bits <= 32; ++key_bits) {\n+        for (int value_bits = 0; value_bits <= 32; ++value_bits) {\n+            test_with_bits(static_cast<uint32_t>((1ULL << key_bits) - 1),\n+                           static_cast<uint32_t>((1ULL << value_bits) - 1));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_packedTable.cpp","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"}]}