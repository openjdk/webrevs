{"files":[{"patch":"@@ -5772,1 +5772,1 @@\n-    FieldInfoStream::create_FieldInfoStream(_temp_field_info, _java_fields_count,\n+    FieldInfoStream::create_FieldInfoStream(_cp, _temp_field_info, _java_fields_count,\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -304,1 +304,1 @@\n-    for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n@@ -464,1 +464,1 @@\n-          for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+          for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -966,1 +966,1 @@\n-      Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(fields, java_fields, injected_fields, k->class_loader_data(), CHECK);\n+      Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(ik->constants(), fields, java_fields, injected_fields, k->class_loader_data(), CHECK);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,24 @@\n-Array<u1>* FieldInfoStream::create_FieldInfoStream(GrowableArray<FieldInfo>* fields, int java_fields, int injected_fields,\n+static int compare_symbols(const Symbol *s1, const Symbol *s2) {\n+  \/\/ not lexicographical sort, since we need only total ordering\n+  int l1 = s1->utf8_length();\n+  int l2 = s2->utf8_length();\n+  if (l1 == l2) {\n+    for (int i = 0; i < l1; ++i) {\n+      char c1 = s1->char_at(i);\n+      char c2 = s2->char_at(i);\n+      if (c1 != c2) {\n+        return c1 - c2;\n+      }\n+    }\n+    return 0;\n+  } else {\n+    return l1 - l2;\n+  }\n+}\n+\n+static int compare_fields(const FieldInfo *f1, const FieldInfo *f2, void *arg) {\n+  ConstantPool* cp = static_cast<ConstantPool*>(arg);\n+  return compare_symbols(f1->name(cp), f2->name(cp));\n+}\n+\n+Array<u1>* FieldInfoStream::create_FieldInfoStream(ConstantPool* constants, GrowableArray<FieldInfo>* fields, int java_fields, int injected_fields,\n@@ -53,1 +76,2 @@\n-  \/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields Field[j+k] End\n+  \/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields JumpTable_offset(0\/4 bytes) Field[j+k] JumpTable[(j - 1)\/16 > 0] End\n+  \/\/   JumpTable := stream_index[(j - 1)\/16]\n@@ -60,0 +84,5 @@\n+  \/\/ We create JumpTable only for java_fields; JavaFieldStream relies on non-injected fields preceding injected\n+  if (java_fields > JUMP_TABLE_STRIDE) {\n+    fields->sort_range(0, java_fields, compare_fields, constants);\n+  }\n+\n@@ -67,0 +96,8 @@\n+  assert(fields->length() == java_fields + injected_fields, \"must be\");\n+  \/\/ We need to put JumpTable at end because the position of fields must not depend\n+  \/\/ on the size of JumpTable.\n+  if (java_fields > JUMP_TABLE_STRIDE) {\n+    sizer.consumer()->accept_bytes(sizeof(uint32_t));\n+  }\n+  ResourceMark rm;\n+  int *positions = java_fields > JUMP_TABLE_STRIDE ? NEW_RESOURCE_ARRAY(int, (java_fields - 1) \/ JUMP_TABLE_STRIDE) : nullptr;\n@@ -68,0 +105,3 @@\n+    if (i > 0 && i < java_fields && i % JUMP_TABLE_STRIDE == 0) {\n+      positions[i \/ JUMP_TABLE_STRIDE - 1] = sizer.consumer()->position();\n+    }\n@@ -71,1 +111,6 @@\n-  int storage_size = sizer.consumer()->position() + 1;\n+  for (int i = JUMP_TABLE_STRIDE; i < java_fields; i += JUMP_TABLE_STRIDE) {\n+    sizer.consumer()->accept_uint(positions[i \/ JUMP_TABLE_STRIDE - 1]);\n+  }\n+  \/\/ Originally there was an extra byte with 0 terminating the reading;\n+  \/\/ no we check limits instead as there may be the JumpTable\n+  int storage_size = sizer.consumer()->position();\n@@ -81,0 +126,4 @@\n+  int jump_table_offset_pos = w.position();\n+  if (java_fields > JUMP_TABLE_STRIDE) {\n+    w.set_position(w.position() + sizeof(uint32_t));\n+  }\n@@ -83,0 +132,2 @@\n+    assert(i == 0 || i >= java_fields || i % JUMP_TABLE_STRIDE != 0 ||\n+      w.position() == positions[i \/ JUMP_TABLE_STRIDE - 1], \"must be\");\n@@ -85,0 +136,6 @@\n+  if (java_fields > JUMP_TABLE_STRIDE) {\n+    *reinterpret_cast<uint32_t*>(w.array()->adr_at(jump_table_offset_pos)) = checked_cast<uint32_t>(w.position());\n+  }\n+  for (int i = JUMP_TABLE_STRIDE; i < java_fields; i += JUMP_TABLE_STRIDE) {\n+    writer.consumer()->accept_uint(positions[i \/ JUMP_TABLE_STRIDE - 1]);\n+  }\n@@ -88,1 +145,2 @@\n-  int jfc = r.next_uint();\n+  int jfc, ifc;\n+  r.read_field_counts(&jfc, &ifc);\n@@ -90,1 +148,0 @@\n-  int ifc = r.next_uint();\n@@ -117,2 +174,0 @@\n-  int length = FieldInfoStream::num_total_fields(fis);\n-  GrowableArray<FieldInfo>* array = new GrowableArray<FieldInfo>(length);\n@@ -120,2 +175,4 @@\n-  *java_fields_count = r.next_uint();\n-  *injected_fields_count = r.next_uint();\n+  r.read_field_counts(java_fields_count, injected_fields_count);\n+  int length = *java_fields_count + *injected_fields_count;\n+\n+  GrowableArray<FieldInfo>* array = new GrowableArray<FieldInfo>(length);\n@@ -128,1 +185,0 @@\n-  assert(array->length() == *java_fields_count + *injected_fields_count, \"Must be\");\n@@ -133,1 +189,0 @@\n-  int length = FieldInfoStream::num_total_fields(fis);\n@@ -135,2 +190,3 @@\n-  int java_field_count = r.next_uint();\n-  int injected_fields_count = r.next_uint();\n+  int java_fields_count;\n+  int injected_fields_count;\n+  r.read_field_counts(&java_fields_count, &injected_fields_count);\n@@ -143,0 +199,27 @@\n+\n+int FieldInfoReader::skip_fields_until(const Symbol *name, ConstantPool *cp, int java_fields) {\n+  int jump_table_size = (java_fields - 1) \/ JUMP_TABLE_STRIDE;\n+  if (jump_table_size == 0) {\n+    return -1;\n+  }\n+  int field_pos = -1;\n+  int field_index = -1;\n+  UNSIGNED5::Reader<const u1*, int> r2(_r.array());\n+  r2.set_position(_r.limit());\n+  for (int i = 0; i < jump_table_size; ++i) {\n+    int pos = r2.next_uint();\n+    int pos2 = pos; \/\/ read_uint updates this by reference\n+    uint32_t name_index = UNSIGNED5::read_uint<const u1 *, int>(_r.array(), pos2, _r.limit());\n+    Symbol *sym = cp->symbol_at(name_index);\n+    if (compare_symbols(name, sym) < 0) {\n+      break;\n+    }\n+    field_pos = pos;\n+    field_index = (i + 1) * JUMP_TABLE_STRIDE;\n+  }\n+  if (field_pos >= 0) {\n+    _r.set_position(field_pos);\n+    _next_index = field_index;\n+  }\n+  return field_index;\n+}\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":96,"deletions":13,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -223,0 +223,1 @@\n+#define JUMP_TABLE_STRIDE 16\n@@ -226,5 +227,0 @@\n-  friend class FieldInfoStream;\n-  friend class ClassFileParser;\n-  friend class FieldStreamBase;\n-  friend class FieldInfo;\n-\n@@ -234,1 +230,1 @@\n-  public:\n+public:\n@@ -237,2 +233,1 @@\n-  private:\n-  uint32_t next_uint() { return _r.next_uint(); }\n+private:\n@@ -242,3 +237,12 @@\n-  int has_next() { return _r.has_next(); }\n-  int position() { return _r.position(); }\n-  int next_index() { return _next_index; }\n+  void read_field_counts(int *java_fields, int *injected_fields) {\n+    *java_fields = _r.next_uint();\n+    *injected_fields = _r.next_uint();\n+    if (*java_fields > JUMP_TABLE_STRIDE) {\n+      uint32_t jumptable_offset = *reinterpret_cast<const uint32_t *>(_r.array() + _r.position());\n+      _r.set_limit(jumptable_offset);\n+      _r.set_position(_r.position() + sizeof(uint32_t));\n+    }\n+  }\n+  int has_next() const { return _r.position() < _r.limit(); }\n+  int position() const { return _r.position(); }\n+  int next_index() const { return _next_index; }\n@@ -246,0 +250,5 @@\n+\n+  \/\/ Skips java fields based on condensed info in the jump table;\n+  \/\/ stops at a point before first field with matching name.\n+  int skip_fields_until(const Symbol *name, ConstantPool *cp, int java_fields);\n+\n@@ -260,1 +269,2 @@\n-\/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields Field[j+k] End\n+\/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields JumpTable_offset(0\/4 bytes) Field[j+k] JumpTable[(j - 1)\/16 > 0] End\n+\/\/   JumpTable := stream_index[(j - 1)\/16]\n@@ -278,1 +288,1 @@\n-  static Array<u1>* create_FieldInfoStream(GrowableArray<FieldInfo>* fields, int java_fields, int injected_fields,\n+  static Array<u1>* create_FieldInfoStream(ConstantPool* constants, GrowableArray<FieldInfo>* fields, int java_fields, int injected_fields,\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":23,"deletions":13,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -59,2 +59,4 @@\n-  fir.skip(1);\n-  return fir.next_uint();\n+  int java_fields_count;\n+  int injected_fields_count;\n+  fir.read_field_counts(&java_fields_count, &injected_fields_count);\n+  return injected_fields_count;\n@@ -65,1 +67,4 @@\n-  return fir.next_uint() + fir.next_uint();\n+  int java_fields_count;\n+  int injected_fields_count;\n+  fir.read_field_counts(&java_fields_count, &injected_fields_count);\n+  return java_fields_count + injected_fields_count;\n@@ -68,1 +73,7 @@\n-inline int FieldInfoStream::num_java_fields(const Array<u1>* fis) { return FieldInfoReader(fis).next_uint(); }\n+inline int FieldInfoStream::num_java_fields(const Array<u1>* fis) {\n+  FieldInfoReader fir(fis);\n+  int java_fields_count;\n+  int injected_fields_count;\n+  fir.read_field_counts(&java_fields_count, &injected_fields_count);\n+  return java_fields_count;\n+}\n@@ -97,1 +108,1 @@\n-  : _r(fi->data(), 0),\n+  : _r(fi->data(), fi->length()),\n@@ -102,5 +113,5 @@\n-  fi._name_index = checked_cast<u2>(next_uint());\n-  fi._signature_index = checked_cast<u2>(next_uint());\n-  fi._offset = next_uint();\n-  fi._access_flags = AccessFlags(checked_cast<u2>(next_uint()));\n-  fi._field_flags = FieldInfo::FieldFlags(next_uint());\n+  fi._name_index = checked_cast<u2>(_r.next_uint());\n+  fi._signature_index = checked_cast<u2>(_r.next_uint());\n+  fi._offset = _r.next_uint();\n+  fi._access_flags = AccessFlags(checked_cast<u2>(_r.next_uint()));\n+  fi._field_flags = FieldInfo::FieldFlags(_r.next_uint());\n@@ -108,1 +119,1 @@\n-    fi._initializer_index = checked_cast<u2>(next_uint());\n+    fi._initializer_index = checked_cast<u2>(_r.next_uint());\n@@ -113,1 +124,1 @@\n-    fi._generic_signature_index = checked_cast<u2>(next_uint());\n+    fi._generic_signature_index = checked_cast<u2>(_r.next_uint());\n@@ -118,1 +129,1 @@\n-    fi._contention_group = checked_cast<u2>(next_uint());\n+    fi._contention_group = checked_cast<u2>(_r.next_uint());\n@@ -128,1 +139,1 @@\n-  FieldInfo::FieldFlags ff(next_uint());\n+  FieldInfo::FieldFlags ff(_r.next_uint());\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":25,"deletions":14,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  inline FieldStreamBase(Array<u1>* fieldinfo_stream, ConstantPool* constants);\n+  inline FieldStreamBase(const Array<u1>* fieldinfo_stream, ConstantPool* constants);\n@@ -61,1 +61,1 @@\n-  private:\n+ private:\n@@ -63,2 +63,3 @@\n-    int java_fields_count = _reader.next_uint();\n-    int injected_fields_count = _reader.next_uint();\n+    int java_fields_count;\n+    int injected_fields_count;\n+    _reader.read_field_counts(&java_fields_count, &injected_fields_count);\n@@ -71,0 +72,1 @@\n+\n@@ -152,1 +154,0 @@\n-    return -1;\n@@ -167,0 +168,2 @@\n+\n+  void skip_fields_until(const Symbol *name, ConstantPool *cp);\n@@ -179,1 +182,0 @@\n-  AllFieldStream(Array<u1>* fieldinfo, ConstantPool* constants): FieldStreamBase(fieldinfo, constants) {}\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-FieldStreamBase::FieldStreamBase(Array<u1>* fieldinfo_stream, ConstantPool* constants) :\n+FieldStreamBase::FieldStreamBase(const Array<u1>* fieldinfo_stream, ConstantPool* constants) :\n@@ -65,0 +65,13 @@\n+inline void JavaFieldStream::skip_fields_until(const Symbol *name, ConstantPool *cp) {\n+  if (done()) {\n+    return;\n+  }\n+  int index = _reader.skip_fields_until(name, cp, _limit);\n+  if (index < 0) {\n+    return;\n+  }\n+  assert(index > 0 && index < _limit && index % JUMP_TABLE_STRIDE == 0, \"must be\");\n+  _index = index;\n+  _reader.read_field_info(_fi_buf);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.inline.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1783,1 +1783,3 @@\n-  for (JavaFieldStream fs(this); !fs.done(); fs.next()) {\n+  JavaFieldStream fs(this);\n+  fs.skip_fields_until(name, constants());\n+  for (; !fs.done(); fs.next()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3558,1 +3558,1 @@\n-    Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(fields, java_fields, injected_fields, scratch_class->class_loader_data(), CHECK);\n+    Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(cp, fields, java_fields, injected_fields, scratch_class->class_loader_data(), CHECK);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -313,0 +313,8 @@\n+  \/\/ end is exclusive\n+  void sort_range(int start, int end, int f(const E*, const E*, void *), void *arg) {\n+    if (_data == nullptr) return;\n+    assert(start >= 0, \"start is negative\");\n+    assert(end <= length(), \"range too long\");\n+    qsort_r(_data + start, end - start, sizeof(E), (__compar_d_fn_t)f, arg);\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-    int next_length() {\n+    int next_length() const {\n@@ -273,1 +273,1 @@\n-    bool has_next() {\n+    bool has_next() const {\n@@ -287,2 +287,3 @@\n-    OFF limit() { return _limit; }\n-    OFF position() { return _position; }\n+    OFF limit() const { return _limit; }\n+    OFF position() const { return _position; }\n+    void set_limit(OFF limit) { _limit = limit; }\n@@ -394,0 +395,3 @@\n+    void accept_bytes(OFF bytes) {\n+      _position += bytes;\n+    }\n","filename":"src\/hotspot\/share\/utilities\/unsigned5.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -66,0 +66,4 @@\n+  public void skipBytes(int bytes) {\n+    this.position += bytes;\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CompressedStream.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -114,0 +114,1 @@\n+    crs.skipBytes(numJavaFields > 16 ? 4 : 0);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Field.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}