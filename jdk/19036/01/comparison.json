{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,4 @@\n-import java.nio.ByteBuffer;\n-import java.util.Arrays;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n@@ -28,1 +30,4 @@\n-\/**\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n@@ -30,6 +35,6 @@\n- * @bug 8210583 8217969 8218265\n- * @summary Tests Base64.Encoder.encode and Base64.Decoder.decode\n- *          with the large size of input array\/buffer\n- * @requires (sun.arch.data.model == \"64\" & os.maxMemory >= 10g)\n- * @run main\/othervm -Xms6g -Xmx8g TestEncodingDecodingLength\n- *\n+ * @bug 8210583 8217969 8218265 8295153\n+ * @summary White-box test that effectively checks Base64.Encoder.encode and\n+ *          Base64.Decoder.decode behavior with large, (Integer.MAX_VALUE) sized\n+ *          input array\/buffer. Tests the private methods \"encodedOutLength\" and\n+ *          \"decodedOutLength\".\n+ * @run junit\/othervm --add-opens java.base\/java.util=ALL-UNNAMED TestEncodingDecodingLength\n@@ -38,0 +43,2 @@\n+\/\/ We perform a white-box test due to the heavy memory usage that testing\n+\/\/ the public API would require which has shown to cause intermittent issues\n@@ -40,4 +47,4 @@\n-    public static void main(String[] args) {\n-        int size = Integer.MAX_VALUE - 8;\n-        byte[] inputBytes = new byte[size];\n-        byte[] outputBytes = new byte[size];\n+    \/\/ A value large enough to test the desired memory conditions in encode and decode\n+    private static final int LARGE_MEM_SIZE = Integer.MAX_VALUE - 8;\n+    private static final Base64.Decoder DECODER = Base64.getDecoder();\n+    private static final Base64.Encoder ENCODER = Base64.getEncoder();\n@@ -45,14 +52,11 @@\n-        \/\/ Check encoder with large array length\n-        Base64.Encoder encoder = Base64.getEncoder();\n-        checkOOM(\"encode(byte[])\", () -> encoder.encode(inputBytes));\n-        checkIAE(\"encode(byte[] byte[])\", () -> encoder.encode(inputBytes, outputBytes));\n-        checkOOM(\"encodeToString(byte[])\", () -> encoder.encodeToString(inputBytes));\n-        checkOOM(\"encode(ByteBuffer)\", () -> encoder.encode(ByteBuffer.wrap(inputBytes)));\n-\n-        \/\/ Check decoder with large array length,\n-        \/\/ should not throw any exception\n-        Arrays.fill(inputBytes, (byte) 86);\n-        Base64.Decoder decoder = Base64.getDecoder();\n-        decoder.decode(inputBytes);\n-        decoder.decode(inputBytes, outputBytes);\n-        decoder.decode(ByteBuffer.wrap(inputBytes));\n+    \/\/ Effectively tests that encode(byte[] src, byte[] dst) throws an\n+    \/\/ IllegalArgumentException with array sized near Integer.MAX_VALUE. All the\n+    \/\/ encode() methods call encodedOutLength(), which is where the OOME is expected\n+    @Test\n+    public void largeEncodeIAETest() throws IllegalAccessException,\n+            InvocationTargetException, NoSuchMethodException {\n+        Method m = getMethod(ENCODER,\n+                \"encodedOutLength\", int.class, boolean.class);\n+        \/\/ When throwOOME param is false, encodedOutLength should return -1 in\n+        \/\/ this situation, which encode() uses to throw IAE\n+        assertEquals(-1, m.invoke(ENCODER, LARGE_MEM_SIZE, false));\n@@ -61,1 +65,6 @@\n-    private static final void checkOOM(String methodName, Runnable r) {\n+    \/\/ Effectively tests that the overloaded encode() and encodeToString() methods\n+    \/\/ throw OutOfMemoryError with array\/buffer sized near Integer.MAX_VALUE\n+    @Test\n+    public void largeEncodeOOMETest() throws IllegalAccessException, NoSuchMethodException {\n+        Method m = getMethod(ENCODER,\n+                \"encodedOutLength\", int.class, boolean.class);\n@@ -63,3 +72,6 @@\n-            r.run();\n-            throw new RuntimeException(\"OutOfMemoryError should have been thrown by: \" + methodName);\n-        } catch (OutOfMemoryError er) {}\n+            m.invoke(ENCODER, LARGE_MEM_SIZE, true);\n+        } catch (InvocationTargetException ex) {\n+            Throwable rootEx = ex.getCause();\n+            assertEquals(OutOfMemoryError.class, rootEx.getClass(), \"00ME should be thrown\");\n+            assertEquals(\"Encoded size is too large\", rootEx.getMessage());\n+        }\n@@ -68,1 +80,9 @@\n-    private static final void checkIAE(String methodName, Runnable r) {\n+    \/\/ Effectively tests that the overloaded decode() methods do not throw\n+    \/\/ OOME nor NASE with array\/buffer sized near Integer.MAX_VALUE All the decode\n+    \/\/ methods call decodedOutLength(), which is where the previously thrown\n+    \/\/ OOME or NASE would occur at.\n+    @Test\n+    public void largeDecodeTest() throws IllegalAccessException, NoSuchMethodException {\n+        Method m = getMethod(DECODER,\n+                \"decodedOutLength\", byte[].class, int.class, int.class);\n+        byte[] src = {1};\n@@ -70,3 +90,12 @@\n-            r.run();\n-            throw new RuntimeException(\"IllegalArgumentException should have been thrown by: \" + methodName);\n-        } catch (IllegalArgumentException iae) {}\n+            \/*\n+             decodedOutLength() takes the src array, position, and limit as params.\n+             The src array will be indexed at limit-1 to search for padding.\n+             To avoid passing an array with Integer.MAX_VALUE memory allocated, we\n+             set position param to be -size. Since the initial length\n+             is calculated as limit - position. This mocks the potential overflow\n+             calculation and still allows the array to be indexed without an AIOBE.\n+            *\/\n+            m.invoke(DECODER, src, -LARGE_MEM_SIZE + 1, 1);\n+        } catch (InvocationTargetException ex) {\n+            fail(\"Decode should neither throw NASE or OOME: \" + ex.getCause());\n+        }\n@@ -74,1 +103,0 @@\n-}\n@@ -76,0 +104,8 @@\n+    \/\/ Utility to get the private visibility method\n+    private static Method getMethod(Object obj, String methodName, Class<?>... params)\n+            throws NoSuchMethodException {\n+        Method m = obj.getClass().getDeclaredMethod(methodName, params);\n+        m.setAccessible(true);\n+        return m;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Base64\/TestEncodingDecodingLength.java","additions":73,"deletions":37,"binary":false,"changes":110,"status":"modified"}]}