{"files":[{"patch":"@@ -47,1 +47,4 @@\n-    private static final int size = Integer.MAX_VALUE - 8;\n+    \/\/ A value large enough to test the desired memory conditions in encode and decode\n+    private static final int LARGE_MEM_SIZE = Integer.MAX_VALUE - 8;\n+    private static final Base64.Decoder DECODER = Base64.getDecoder();\n+    private static final Base64.Encoder ENCODER = Base64.getEncoder();\n@@ -49,4 +52,3 @@\n-    \/\/ Effectively tests the overloaded Base64.Encoder.encode() methods and\n-    \/\/ encodeToString() throw OOME instead of NASE with large array values.\n-    \/\/ All the encode methods call encodedOutLength() which is where the OOME\n-    \/\/ is expected to be thrown from\n+    \/\/ Effectively tests that encode(byte[] src, byte[] dst) throws an\n+    \/\/ IllegalArgumentException with array sized near Integer.MAX_VALUE. All the\n+    \/\/ encode() methods call encodedOutLength(), which is where the OOME is expected\n@@ -54,4 +56,3 @@\n-    public void largeEncodeTest() throws NoSuchMethodException,\n-            IllegalAccessException, InvocationTargetException {\n-        Base64.Encoder encoder = Base64.getEncoder();\n-        Method m = encoder.getClass().getDeclaredMethod(\n+    public void largeEncodeIAETest() throws IllegalAccessException,\n+            InvocationTargetException, NoSuchMethodException {\n+        Method m = getMethod(ENCODER,\n@@ -59,3 +60,0 @@\n-        m.setAccessible(true);\n-\n-        \/\/ IAE case\n@@ -64,1 +62,2 @@\n-        assertEquals(-1, m.invoke(encoder, size, false));\n+        assertEquals(-1, m.invoke(ENCODER, LARGE_MEM_SIZE, false));\n+    }\n@@ -66,1 +65,6 @@\n-        \/\/ OOME case\n+    \/\/ Effectively tests that the overloaded encode() and encodeToString() methods\n+    \/\/ throw OutOfMemoryError with array\/buffer sized near Integer.MAX_VALUE\n+    @Test\n+    public void largeEncodeOOMETest() throws IllegalAccessException, NoSuchMethodException {\n+        Method m = getMethod(ENCODER,\n+                \"encodedOutLength\", int.class, boolean.class);\n@@ -68,1 +72,1 @@\n-            m.invoke(encoder, size, true);\n+            m.invoke(ENCODER, LARGE_MEM_SIZE, true);\n@@ -76,3 +80,4 @@\n-    \/\/ Effectively tests the overloaded Base64.Decoder.decode() methods do not\n-    \/\/ throw OOME nor NASE with large array values. All the decode methods call\n-    \/\/ decodedOutLength(), which is where the potential overflow situation occurs.\n+    \/\/ Effectively tests that the overloaded decode() methods do not throw\n+    \/\/ OOME nor NASE with array\/buffer sized near Integer.MAX_VALUE All the decode\n+    \/\/ methods call decodedOutLength(), which is where the previously thrown\n+    \/\/ OOME or NASE would occur at.\n@@ -80,3 +85,2 @@\n-    public void largeDecodeTest() throws NoSuchMethodException, IllegalAccessException {\n-        Base64.Decoder decoder = Base64.getDecoder();\n-        Method m = decoder.getClass().getDeclaredMethod(\n+    public void largeDecodeTest() throws IllegalAccessException, NoSuchMethodException {\n+        Method m = getMethod(DECODER,\n@@ -84,1 +88,0 @@\n-        m.setAccessible(true);\n@@ -87,7 +90,9 @@\n-            \/\/ decodedOutLength() takes the src array, position, and limit as params.\n-            \/\/ The src array will be indexed at limit-1 to search for padding.\n-            \/\/ To avoid passing an array with Integer.MAX_VALUE memory allocated, we\n-            \/\/ set position param to be -size. Since the initial length\n-            \/\/ is calculated as limit - position. This mocks the potential overflow\n-            \/\/ calculation and still allows the array to be indexed without an AIOBE.\n-            m.invoke(decoder, src, -size + 1, 1);\n+            \/*\n+             decodedOutLength() takes the src array, position, and limit as params.\n+             The src array will be indexed at limit-1 to search for padding.\n+             To avoid passing an array with Integer.MAX_VALUE memory allocated, we\n+             set position param to be -size. Since the initial length\n+             is calculated as limit - position. This mocks the potential overflow\n+             calculation and still allows the array to be indexed without an AIOBE.\n+            *\/\n+            m.invoke(DECODER, src, -LARGE_MEM_SIZE + 1, 1);\n@@ -98,0 +103,8 @@\n+\n+    \/\/ Utility to get the private visibility method\n+    private static Method getMethod(Object obj, String methodName, Class<?>... params)\n+            throws NoSuchMethodException {\n+        Method m = obj.getClass().getDeclaredMethod(methodName, params);\n+        m.setAccessible(true);\n+        return m;\n+    }\n","filename":"test\/jdk\/java\/util\/Base64\/TestEncodingDecodingLength.java","additions":42,"deletions":29,"binary":false,"changes":71,"status":"modified"}]}