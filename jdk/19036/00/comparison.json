{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,4 @@\n-import java.nio.ByteBuffer;\n-import java.util.Arrays;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n@@ -28,1 +30,4 @@\n-\/**\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n@@ -30,6 +35,6 @@\n- * @bug 8210583 8217969 8218265\n- * @summary Tests Base64.Encoder.encode and Base64.Decoder.decode\n- *          with the large size of input array\/buffer\n- * @requires (sun.arch.data.model == \"64\" & os.maxMemory >= 10g)\n- * @run main\/othervm -Xms6g -Xmx8g TestEncodingDecodingLength\n- *\n+ * @bug 8210583 8217969 8218265 8295153\n+ * @summary White-box test that effectively checks Base64.Encoder.encode and\n+ *          Base64.Decoder.decode behavior with large, (Integer.MAX_VALUE) sized\n+ *          input array\/buffer. Tests the private methods \"encodedOutLength\" and\n+ *          \"decodedOutLength\".\n+ * @run junit\/othervm --add-opens java.base\/java.util=ALL-UNNAMED TestEncodingDecodingLength\n@@ -38,0 +43,2 @@\n+\/\/ We perform a white-box test due to the heavy memory usage that testing\n+\/\/ the public API would require which has shown to cause intermittent issues\n@@ -40,4 +47,1 @@\n-    public static void main(String[] args) {\n-        int size = Integer.MAX_VALUE - 8;\n-        byte[] inputBytes = new byte[size];\n-        byte[] outputBytes = new byte[size];\n+    private static final int size = Integer.MAX_VALUE - 8;\n@@ -45,1 +49,7 @@\n-        \/\/ Check encoder with large array length\n+    \/\/ Effectively tests the overloaded Base64.Encoder.encode() methods and\n+    \/\/ encodeToString() throw OOME instead of NASE with large array values.\n+    \/\/ All the encode methods call encodedOutLength() which is where the OOME\n+    \/\/ is expected to be thrown from\n+    @Test\n+    public void largeEncodeTest() throws NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException {\n@@ -47,4 +57,3 @@\n-        checkOOM(\"encode(byte[])\", () -> encoder.encode(inputBytes));\n-        checkIAE(\"encode(byte[] byte[])\", () -> encoder.encode(inputBytes, outputBytes));\n-        checkOOM(\"encodeToString(byte[])\", () -> encoder.encodeToString(inputBytes));\n-        checkOOM(\"encode(ByteBuffer)\", () -> encoder.encode(ByteBuffer.wrap(inputBytes)));\n+        Method m = encoder.getClass().getDeclaredMethod(\n+                \"encodedOutLength\", int.class, boolean.class);\n+        m.setAccessible(true);\n@@ -52,8 +61,4 @@\n-        \/\/ Check decoder with large array length,\n-        \/\/ should not throw any exception\n-        Arrays.fill(inputBytes, (byte) 86);\n-        Base64.Decoder decoder = Base64.getDecoder();\n-        decoder.decode(inputBytes);\n-        decoder.decode(inputBytes, outputBytes);\n-        decoder.decode(ByteBuffer.wrap(inputBytes));\n-    }\n+        \/\/ IAE case\n+        \/\/ When throwOOME param is false, encodedOutLength should return -1 in\n+        \/\/ this situation, which encode() uses to throw IAE\n+        assertEquals(-1, m.invoke(encoder, size, false));\n@@ -61,1 +66,1 @@\n-    private static final void checkOOM(String methodName, Runnable r) {\n+        \/\/ OOME case\n@@ -63,3 +68,6 @@\n-            r.run();\n-            throw new RuntimeException(\"OutOfMemoryError should have been thrown by: \" + methodName);\n-        } catch (OutOfMemoryError er) {}\n+            m.invoke(encoder, size, true);\n+        } catch (InvocationTargetException ex) {\n+            Throwable rootEx = ex.getCause();\n+            assertEquals(OutOfMemoryError.class, rootEx.getClass(), \"00ME should be thrown\");\n+            assertEquals(\"Encoded size is too large\", rootEx.getMessage());\n+        }\n@@ -68,1 +76,10 @@\n-    private static final void checkIAE(String methodName, Runnable r) {\n+    \/\/ Effectively tests the overloaded Base64.Decoder.decode() methods do not\n+    \/\/ throw OOME nor NASE with large array values. All the decode methods call\n+    \/\/ decodedOutLength(), which is where the potential overflow situation occurs.\n+    @Test\n+    public void largeDecodeTest() throws NoSuchMethodException, IllegalAccessException {\n+        Base64.Decoder decoder = Base64.getDecoder();\n+        Method m = decoder.getClass().getDeclaredMethod(\n+                \"decodedOutLength\", byte[].class, int.class, int.class);\n+        m.setAccessible(true);\n+        byte[] src = {1};\n@@ -70,3 +87,10 @@\n-            r.run();\n-            throw new RuntimeException(\"IllegalArgumentException should have been thrown by: \" + methodName);\n-        } catch (IllegalArgumentException iae) {}\n+            \/\/ decodedOutLength() takes the src array, position, and limit as params.\n+            \/\/ The src array will be indexed at limit-1 to search for padding.\n+            \/\/ To avoid passing an array with Integer.MAX_VALUE memory allocated, we\n+            \/\/ set position param to be -size. Since the initial length\n+            \/\/ is calculated as limit - position. This mocks the potential overflow\n+            \/\/ calculation and still allows the array to be indexed without an AIOBE.\n+            m.invoke(decoder, src, -size + 1, 1);\n+        } catch (InvocationTargetException ex) {\n+            fail(\"Decode should neither throw NASE or OOME: \" + ex.getCause());\n+        }\n@@ -75,1 +99,0 @@\n-\n","filename":"test\/jdk\/java\/util\/Base64\/TestEncodingDecodingLength.java","additions":59,"deletions":36,"binary":false,"changes":95,"status":"modified"}]}