{"files":[{"patch":"@@ -73,1 +73,1 @@\n-    lightweight_lock(obj, hdr, temp, t1, slow_case);\n+    lightweight_lock(disp_hdr, obj, hdr, temp, t1, slow_case);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -256,1 +256,2 @@\n-void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register tmp1, Register tmp2, Register tmp3) {\n+void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box,\n+                                              Register tmp1, Register tmp2, Register tmp3) {\n@@ -261,1 +262,1 @@\n-  assert_different_registers(obj, tmp1, tmp2, tmp3, flag, t0);\n+  assert_different_registers(obj, box, tmp1, tmp2, tmp3, flag, t0);\n@@ -272,0 +273,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    sd(zr, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+  }\n+\n@@ -280,0 +286,1 @@\n+  const Register tmp3_t = tmp3;\n@@ -287,1 +294,0 @@\n-    const Register tmp3_t = tmp3;\n@@ -326,0 +332,1 @@\n+    const Register tmp1_monitor = tmp1;\n@@ -327,5 +334,3 @@\n-      \/\/ mark contains the tagged ObjectMonitor*.\n-      const Register tmp1_tagged_monitor = tmp1_mark;\n-      const uintptr_t monitor_tag = markWord::monitor_value;\n-      const Register tmp2_owner_addr = tmp2;\n-      const Register tmp3_owner = tmp3;\n+      assert(tmp1_monitor == tmp1_mark, \"should be the same here\");\n+    } else {\n+      Label monitor_found;\n@@ -333,2 +338,2 @@\n-      \/\/ Compute owner address.\n-      la(tmp2_owner_addr, Address(tmp1_tagged_monitor, (in_bytes(ObjectMonitor::owner_offset()) - monitor_tag)));\n+      \/\/ Load cache address\n+      la(tmp3_t, Address(xthread, JavaThread::om_cache_oops_offset()));\n@@ -336,4 +341,6 @@\n-      \/\/ CAS owner (null => current thread).\n-      cmpxchg(\/*addr*\/ tmp2_owner_addr, \/*expected*\/ zr, \/*new*\/ xthread, Assembler::int64,\n-              \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::relaxed, \/*result*\/ tmp3_owner);\n-      beqz(tmp3_owner, locked);\n+      const int num_unrolled = 2;\n+      for (int i = 0; i < num_unrolled; i++) {\n+        ld(tmp1, Address(tmp3_t));\n+        beq(obj, tmp1, monitor_found);\n+        add(tmp3_t, tmp3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+      }\n@@ -341,2 +348,1 @@\n-      \/\/ Check if recursive.\n-      bne(tmp3_owner, xthread, slow_path);\n+      Label loop;\n@@ -344,4 +350,11 @@\n-      \/\/ Recursive.\n-      increment(Address(tmp1_tagged_monitor, in_bytes(ObjectMonitor::recursions_offset()) - monitor_tag), 1, tmp2, tmp3);\n-    } else {\n-      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Search for obj in cache.\n+      bind(loop);\n+\n+      \/\/ Check for match.\n+      ld(tmp1, Address(tmp3_t));\n+      beq(obj, tmp1, monitor_found);\n+\n+      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+      add(tmp3_t, tmp3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+      bnez(tmp1, loop);\n+      \/\/ Cache Miss. Take the slowpath.\n@@ -349,0 +362,31 @@\n+\n+      bind(monitor_found);\n+      ld(tmp1_monitor, Address(tmp3_t, OMCache::oop_to_monitor_difference()));\n+    }\n+\n+    const Register tmp2_owner_addr = tmp2;\n+    const Register tmp3_owner = tmp3;\n+\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address owner_address(tmp1_monitor, ObjectMonitor::owner_offset() - monitor_tag);\n+    const Address recursions_address(tmp1_monitor, ObjectMonitor::recursions_offset() - monitor_tag);\n+\n+    Label monitor_locked;\n+\n+    \/\/ Compute owner address.\n+    la(tmp2_owner_addr, owner_address);\n+\n+    \/\/ CAS owner (null => current thread).\n+    cmpxchg(\/*addr*\/ tmp2_owner_addr, \/*expected*\/ zr, \/*new*\/ xthread, Assembler::int64,\n+            \/*acquire*\/ Assembler::aq, \/*release*\/ Assembler::relaxed, \/*result*\/ tmp3_owner);\n+    beqz(tmp3_owner, monitor_locked);\n+\n+    \/\/ Check if recursive.\n+    bne(tmp3_owner, xthread, slow_path);\n+\n+    \/\/ Recursive.\n+    increment(recursions_address, 1, tmp2, tmp3);\n+\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n+      sd(tmp1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n@@ -373,2 +417,2 @@\n-void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register tmp1, Register tmp2,\n-                                                Register tmp3) {\n+void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register box,\n+                                                Register tmp1, Register tmp2, Register tmp3) {\n@@ -379,1 +423,1 @@\n-  assert_different_registers(obj, tmp1, tmp2, tmp3, flag, t0);\n+  assert_different_registers(obj, box, tmp1, tmp2, tmp3, flag, t0);\n@@ -384,1 +428,1 @@\n-  Label inflated, inflated_load_monitor;\n+  Label inflated, inflated_load_mark;\n@@ -395,0 +439,1 @@\n+    Label push_and_slow_path;\n@@ -402,1 +447,1 @@\n-    bne(obj, tmp3_t, inflated_load_monitor);\n+    bne(obj, tmp3_t, inflated_load_mark);\n@@ -419,0 +464,3 @@\n+    \/\/ Because we got here by popping (meaning we pushed in locked)\n+    \/\/ there will be no monitor in the box. So we need to push back the obj\n+    \/\/ so that the runtime can fix any potential anonymous owner.\n@@ -420,1 +468,1 @@\n-    bnez(tmp3_t, inflated);\n+    bnez(tmp3_t, UseObjectMonitorTable ? push_and_slow_path : inflated);\n@@ -429,0 +477,1 @@\n+    bind(push_and_slow_path);\n@@ -439,1 +488,1 @@\n-    bind(inflated_load_monitor);\n+    bind(inflated_load_mark);\n@@ -461,4 +510,1 @@\n-    if (!UseObjectMonitorTable) {\n-      \/\/ mark contains the tagged ObjectMonitor*.\n-      const Register tmp1_monitor = tmp1_mark;\n-      const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register tmp1_monitor = tmp1;\n@@ -466,0 +512,2 @@\n+    if (!UseObjectMonitorTable) {\n+      assert(tmp1_monitor == tmp1_mark, \"should be the same here\");\n@@ -467,1 +515,7 @@\n-      sub(tmp1_monitor, tmp1_mark, monitor_tag);\n+      add(tmp1_monitor, tmp1_mark, -(int)markWord::monitor_value);\n+    } else {\n+      ld(tmp1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+      \/\/ No valid pointer below alignof(ObjectMonitor*). Take the slow path.\n+      mv(tmp3_t, alignof(ObjectMonitor*));\n+      bltu(tmp1_monitor, tmp3_t, slow_path);\n+    }\n@@ -469,2 +523,2 @@\n-      const Register tmp2_recursions = tmp2;\n-      Label not_recursive;\n+    const Register tmp2_recursions = tmp2;\n+    Label not_recursive;\n@@ -472,3 +526,3 @@\n-      \/\/ Check if recursive.\n-      ld(tmp2_recursions, Address(tmp1_monitor, ObjectMonitor::recursions_offset()));\n-      beqz(tmp2_recursions, not_recursive);\n+    \/\/ Check if recursive.\n+    ld(tmp2_recursions, Address(tmp1_monitor, ObjectMonitor::recursions_offset()));\n+    beqz(tmp2_recursions, not_recursive);\n@@ -476,4 +530,4 @@\n-      \/\/ Recursive unlock.\n-      addi(tmp2_recursions, tmp2_recursions, -1);\n-      sd(tmp2_recursions, Address(tmp1_monitor, ObjectMonitor::recursions_offset()));\n-      j(unlocked);\n+    \/\/ Recursive unlock.\n+    addi(tmp2_recursions, tmp2_recursions, -1);\n+    sd(tmp2_recursions, Address(tmp1_monitor, ObjectMonitor::recursions_offset()));\n+    j(unlocked);\n@@ -481,1 +535,1 @@\n-      bind(not_recursive);\n+    bind(not_recursive);\n@@ -483,2 +537,2 @@\n-      Label release;\n-      const Register tmp2_owner_addr = tmp2;\n+    Label release;\n+    const Register tmp2_owner_addr = tmp2;\n@@ -486,2 +540,2 @@\n-      \/\/ Compute owner address.\n-      la(tmp2_owner_addr, Address(tmp1_monitor, ObjectMonitor::owner_offset()));\n+    \/\/ Compute owner address.\n+    la(tmp2_owner_addr, Address(tmp1_monitor, ObjectMonitor::owner_offset()));\n@@ -489,5 +543,5 @@\n-      \/\/ Check if the entry lists are empty.\n-      ld(t0, Address(tmp1_monitor, ObjectMonitor::EntryList_offset()));\n-      ld(tmp3_t, Address(tmp1_monitor, ObjectMonitor::cxq_offset()));\n-      orr(t0, t0, tmp3_t);\n-      beqz(t0, release);\n+    \/\/ Check if the entry lists are empty.\n+    ld(t0, Address(tmp1_monitor, ObjectMonitor::EntryList_offset()));\n+    ld(tmp3_t, Address(tmp1_monitor, ObjectMonitor::cxq_offset()));\n+    orr(t0, t0, tmp3_t);\n+    beqz(t0, release);\n@@ -495,5 +549,5 @@\n-      \/\/ The owner may be anonymous and we removed the last obj entry in\n-      \/\/ the lock-stack. This loses the information about the owner.\n-      \/\/ Write the thread to the owner field so the runtime knows the owner.\n-      sd(xthread, Address(tmp2_owner_addr));\n-      j(slow_path);\n+    \/\/ The owner may be anonymous and we removed the last obj entry in\n+    \/\/ the lock-stack. This loses the information about the owner.\n+    \/\/ Write the thread to the owner field so the runtime knows the owner.\n+    sd(xthread, Address(tmp2_owner_addr));\n+    j(slow_path);\n@@ -501,8 +555,4 @@\n-      bind(release);\n-      \/\/ Set owner to null.\n-      membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n-      sd(zr, Address(tmp2_owner_addr));\n-    } else {\n-      \/\/ OMCache lookup not supported yet. Take the slowpath.\n-      j(slow_path);\n-    }\n+    bind(release);\n+    \/\/ Set owner to null.\n+    membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n+    sd(zr, Address(tmp2_owner_addr));\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":114,"deletions":64,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -50,2 +50,2 @@\n-  void fast_lock_lightweight(Register object, Register tmp1, Register tmp2, Register tmp3);\n-  void fast_unlock_lightweight(Register object, Register tmp1, Register tmp2, Register tmp3);\n+  void fast_lock_lightweight(Register object, Register box, Register tmp1, Register tmp2, Register tmp3);\n+  void fast_unlock_lightweight(Register object, Register box, Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -759,1 +759,1 @@\n-      lightweight_lock(obj_reg, tmp, tmp2, tmp3, slow_case);\n+      lightweight_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5795,1 +5795,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow) {\n@@ -5797,1 +5797,1 @@\n-  assert_different_registers(obj, tmp1, tmp2, tmp3, t0);\n+  assert_different_registers(basic_lock, obj, tmp1, tmp2, tmp3, t0);\n@@ -5808,0 +5808,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    sd(zr, Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))));\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1605,1 +1605,1 @@\n-  void lightweight_lock(Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow);\n+  void lightweight_lock(Register basic_lock, Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10556,1 +10556,1 @@\n-instruct cmpFastLockLightweight(rFlagsReg cr, iRegP object, iRegP_R10 box, iRegPNoSp tmp1, iRegPNoSp tmp2)\n+instruct cmpFastLockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -10560,1 +10560,1 @@\n-  effect(TEMP tmp1, TEMP tmp2, USE_KILL box);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n@@ -10563,1 +10563,1 @@\n-  format %{ \"fastlock $object,$box\\t! kills $box,$tmp1,$tmp2 #@cmpFastLockLightweight\" %}\n+  format %{ \"fastlock $object,$box\\t! kills $tmp1,$tmp2,$tmp3 #@cmpFastLockLightweight\" %}\n@@ -10566,1 +10566,1 @@\n-    __ fast_lock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+    __ fast_lock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n@@ -10572,1 +10572,1 @@\n-instruct cmpFastUnlockLightweight(rFlagsReg cr, iRegP object, iRegP_R10 box, iRegPNoSp tmp1, iRegPNoSp tmp2)\n+instruct cmpFastUnlockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -10576,1 +10576,1 @@\n-  effect(TEMP tmp1, TEMP tmp2, USE_KILL box);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n@@ -10579,1 +10579,1 @@\n-  format %{ \"fastunlock $object,$box\\t! kills $box,$tmp1,$tmp2, #@cmpFastUnlockLightweight\" %}\n+  format %{ \"fastunlock $object,$box\\t! kills $tmp1,$tmp2,$tmp3 #@cmpFastUnlockLightweight\" %}\n@@ -10582,1 +10582,1 @@\n-    __ fast_unlock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+    __ fast_unlock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1705,1 +1705,1 @@\n-      __ lightweight_lock(obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n+      __ lightweight_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#if defined(X86) || defined(AARCH64)\n+#if defined(X86) || defined(AARCH64) || defined(RISCV64)\n","filename":"src\/hotspot\/share\/runtime\/basicLock.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}