{"files":[{"patch":"@@ -34,2 +34,8 @@\n-import compiler.lib.ir_framework.*;\n-import jdk.test.lib.Utils;\n+import compiler.lib.generators.Generator;\n+import compiler.lib.generators.Generators;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.RunMode;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n@@ -38,2 +44,0 @@\n-import java.util.Random;\n-import java.util.stream.LongStream;\n@@ -43,1 +47,2 @@\n-    private static final Random random = Utils.getRandomInstance();\n+    private static final int SIZE = 1024;\n+    private static final Generator<Long> GEN_LONG = Generators.G.longs();\n@@ -56,4 +61,2 @@\n-        runMaxTest(50);\n-        runMaxTest(80);\n-        runMaxTest(100);\n-    }\n+        long[] longs = new long[SIZE];\n+        Generators.G.fill(GEN_LONG, longs);\n@@ -61,2 +64,0 @@\n-    private static void runMaxTest(int probability) {\n-        long[] longs = reductionInit(probability);\n@@ -67,1 +68,3 @@\n-        if (res == 11 * Arrays.stream(longs).max().getAsLong()) {\n+\n+        final long expected = Arrays.stream(longs).map(l -> l * 11).max().getAsLong();\n+        if (res == expected) {\n@@ -70,1 +73,1 @@\n-            throw new AssertionError(\"Failed\");\n+            throw new AssertionError(\"Failed, got result \" + res + \" but expected \" + expected);\n@@ -77,4 +80,2 @@\n-        runMinTest(50);\n-        runMinTest(80);\n-        runMinTest(100);\n-    }\n+        long[] longs = new long[SIZE];\n+        Generators.G.fill(GEN_LONG, longs);\n@@ -82,5 +83,0 @@\n-    private static void runMinTest(int probability) {\n-        long[] longs = reductionInit(probability);\n-        \/\/ Negating the values generated for controlling max branching\n-        \/\/ allows same logic to be used for min tests.\n-        longs = negate(longs);\n@@ -91,1 +87,3 @@\n-        if (res == 11 * Arrays.stream(longs).min().getAsLong()) {\n+\n+        final long expected = Arrays.stream(longs).map(l -> l * 11).min().getAsLong();\n+        if (res == expected) {\n@@ -94,1 +92,1 @@\n-            throw new AssertionError(\"Failed\");\n+            throw new AssertionError(\"Failed, got result \" + res + \" but expected \" + expected);\n@@ -98,49 +96,0 @@\n-    static long[] negate(long[] nums) {\n-        return LongStream.of(nums).map(l -> -l).toArray();\n-    }\n-\n-    public static long[] reductionInit(int probability) {\n-        int aboveCount, abovePercent;\n-        long[] longs = new long[1024];\n-\n-        \/\/ Generates an array of numbers such that as the array is iterated\n-        \/\/ there is P probability of finding a new max value,\n-        \/\/ and 100-P probability of not finding a new max value.\n-        \/\/ The algorithm loops around if the distribution does not match the probability,\n-        \/\/ but it approximates the probability as the array sizes increase.\n-        \/\/ The worst case of this algorithm is when the desired array size is 100\n-        \/\/ and the aim is to get 50% of probability, which can only be satisfied\n-        \/\/ with 50 elements being a new max. This situation can take 15 rounds.\n-        \/\/ As sizes increase, say 10'000 elements,\n-        \/\/ the number of elements that have to satisfy 50% increases,\n-        \/\/ so the algorithm will stop as an example when 5027 elements are a new max values.\n-        \/\/ Also, probability values in the edges will achieve their objective quicker,\n-        \/\/ with 0% or 100% probability doing it in a single loop.\n-        \/\/ To support the same algorithm for min calculations,\n-        \/\/ negating the array elements achieves the same objective.\n-        do {\n-            long max = random.nextLong(10);\n-            longs[0] = max;\n-\n-            aboveCount = 0;\n-            for (int i = 1; i < longs.length; i++) {\n-                long value;\n-                if (random.nextLong(101) <= probability) {\n-                    long increment = random.nextLong(10);\n-                    value = max + increment;\n-                    aboveCount++;\n-                } else {\n-                    \/\/ Decrement by at least 1\n-                    long diffToMax = random.nextLong(10) + 1;\n-                    value = max - diffToMax;\n-                }\n-                longs[i] = value;\n-                max = Math.max(max, value);\n-            }\n-\n-            abovePercent = ((aboveCount + 1) * 100) \/ longs.length;\n-        } while (abovePercent != probability);\n-\n-        return longs;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/MinMaxRed_Long.java","additions":22,"deletions":73,"binary":false,"changes":95,"status":"modified"}]}