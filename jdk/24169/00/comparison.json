{"files":[{"patch":"@@ -13753,0 +13753,10 @@\n+void Assembler::evcmpsh(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, ComparisonPredicateFP comparison) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  InstructionAttr attributes(Assembler::AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(kdst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24((unsigned char)0xC2, (0xC0 | encode), comparison);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3189,0 +3189,3 @@\n+  void evcmpsh(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src,\n+               ComparisonPredicateFP comparison);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6683,2 +6683,0 @@\n-    case Op_MaxHF: vmaxsh(dst, src1, src2); break;\n-    case Op_MinHF: vminsh(dst, src1, src2); break;\n@@ -7094,0 +7092,45 @@\n+\n+void C2_MacroAssembler::scalar_max_min_fp16(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                          KRegister ktmp, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc) {\n+  if (opcode == Op_MaxHF) {\n+    \/\/ Move sign bits of src2 to mask register.\n+    evpmovw2m(ktmp, src2, vlen_enc);\n+    \/\/ xtmp1 = src2 < 0 ? src2 : src1\n+    evpblendmw(xtmp1, ktmp, src1, src2, true, vlen_enc);\n+    \/\/ xtmp2 = src2 < 0 ? ? src1 : src2\n+    evpblendmw(xtmp2, ktmp, src2, src1, true, vlen_enc);\n+    \/\/ Idea behind above swapping is to make seconds source operand a +ve value.\n+    \/\/ As per instruction semantic, if the values being compared are both 0.0s (of either sign), the value in\n+    \/\/ the second source operand is returned. If only one value is a NaN (SNaN or QNaN) for this instruction,\n+    \/\/ the second source operand, either a NaN or a valid floating-point value, is returned\n+    \/\/ dst = max(xtmp1, xtmp2)\n+    vmaxsh(dst, xtmp1, xtmp2);\n+    \/\/ isNaN = is_unordered_quite(xtmp1)\n+    evcmpsh(ktmp, k0, xtmp1, xtmp1, Assembler::UNORD_Q);\n+    \/\/ Final result is same as first source if its a NaN value,\n+    \/\/ in case second operand holds a NaN value then as per above semantics\n+    \/\/ result is same as second operand.\n+    Assembler::evmovdquw(dst, ktmp, xtmp1, true, vlen_enc);\n+  } else {\n+    assert(opcode == Op_MinHF, \"\");\n+    \/\/ Move sign bits of src1 to mask register.\n+    evpmovw2m(ktmp, src1, vlen_enc);\n+    \/\/ xtmp1 = src1 < 0 ? src2 : src1\n+    evpblendmw(xtmp1, ktmp, src1, src2, true, vlen_enc);\n+    \/\/ xtmp2 = src1 < 0 ? src1 : src2\n+    evpblendmw(xtmp2, ktmp, src2, src1, true, vlen_enc);\n+    \/\/ Idea behind above swapping is to make seconds source operand a -ve value.\n+    \/\/ As per instruction semantics, if the values being compared are both 0.0s (of either sign), the value in\n+    \/\/ the second source operand is returned.\n+    \/\/ If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN\n+    \/\/ or a valid floating-point value, is written to the result.\n+    \/\/ dst = min(xtmp1, xtmp2)\n+    vminsh(dst, xtmp1, xtmp2);\n+    \/\/ isNaN = is_unordered_quite(xtmp1)\n+    evcmpsh(ktmp, k0, xtmp1, xtmp1, Assembler::UNORD_Q);\n+    \/\/ Final result is same as first source if its a NaN value,\n+    \/\/ in case second operand holds a NaN value then as per above semantics\n+    \/\/ result is same as second operand.\n+    Assembler::evmovdquw(dst, ktmp, xtmp1, true, vlen_enc);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":45,"deletions":2,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -587,0 +587,2 @@\n+  void scalar_max_min_fp16(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                           KRegister ktmp, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1464,0 +1464,5 @@\n+    case Op_MaxHF:\n+    case Op_MinHF:\n+      if (!VM_Version::supports_avx512bw()) {\n+        return false;\n+      }\n@@ -1467,2 +1472,0 @@\n-    case Op_MaxHF:\n-    case Op_MinHF:\n@@ -10938,2 +10941,0 @@\n-  match(Set dst (MaxHF src1 src2));\n-  match(Set dst (MinHF src1 src2));\n@@ -10950,0 +10951,14 @@\n+instruct scalar_minmax_HF_reg(regF dst, regF src1, regF src2, kReg ktmp, regF xtmp1, regF xtmp2)\n+%{\n+  match(Set dst (MaxHF src1 src2));\n+  match(Set dst (MinHF src1 src2));\n+  effect(TEMP_DEF dst, TEMP ktmp, TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"scalar_min_max_fp16 $dst, $src1, $src2\\t using $ktmp, $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    __ scalar_max_min_fp16(opcode, $dst$$XMMRegister, $src2$$XMMRegister, $src1$$XMMRegister, $ktmp$$KRegister,\n+                           $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.intrinsics.float16;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+\n+\/**\n+ * @test\n+ * @bug 8352585\n+ * @library \/test\/lib \/\n+ * @summary Add special case handling for Float16.max\/min x86 backend\n+ * @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx512_fp16.*\" & vm.cpu.features ~= \".*avx512bw.*\")\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.intrinsics.float16.TestFloat16MaxMinSpecialValues\n+ *\/\n+\n+\n+public class TestFloat16MaxMinSpecialValues {\n+    public static Float16 POS_ZERO = Float16.valueOf(0.0f);\n+    public static Float16 NEG_ZERO = Float16.valueOf(-0.0f);\n+\n+    public Float16 RES;\n+\n+    public static void main(String [] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_HF, \" >0 \"})\n+    public Float16 testMaxNaNOperands(Float16 src1, Float16 src2) {\n+        return Float16.max(src1, src2);\n+    }\n+\n+    @Run(test = \"testMaxNaNOperands\")\n+    @Warmup(1000)\n+    public void launchMaxNaNOperands() {\n+        for (int i = 0; i < 10000; i++) {\n+            Float16 SRC = Float16.valueOf(i);\n+            RES = testMaxNaNOperands(SRC, Float16.NaN);\n+            if (!RES.equals(Float16.NaN)) {\n+                throw new AssertionError(\"input1 = NaN, input2 = \" + SRC.floatValue() + \", expected = NaN, actual = \" + RES.floatValue());\n+            }\n+        }\n+        for (int i = 0; i < 10000; i++) {\n+            Float16 SRC = Float16.valueOf(i);\n+            RES = testMaxNaNOperands(Float16.NaN, SRC);\n+            if (!RES.equals(Float16.NaN)) {\n+                throw new AssertionError(\"input1 = NaN, input2 = \" + SRC.floatValue() + \", expected = NaN, actual = \" + RES.floatValue());\n+            }\n+        }\n+        for (int i = 0; i < 10000; i++) {\n+            RES = testMaxNaNOperands(Float16.NaN, Float16.NaN);\n+            if (!RES.equals(Float16.NaN)) {\n+                throw new AssertionError(\"input1 = NaN, input2 = NaN, expected = NaN, actual = \" + RES.floatValue());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MIN_HF, \" >0 \"})\n+    public Float16 testMinNaNOperands(Float16 src1, Float16 src2) {\n+        return Float16.min(src1, src2);\n+    }\n+\n+    @Run(test = \"testMinNaNOperands\")\n+    @Warmup(1000)\n+    public void launchMinNaNOperands() {\n+        for (int i = 0; i < 10000; i++) {\n+            Float16 SRC = Float16.valueOf(i);\n+            RES = testMinNaNOperands(SRC, Float16.NaN);\n+            if (!RES.equals(Float16.NaN)) {\n+                throw new AssertionError(\"input1 = NaN, input2 = \" + SRC.floatValue() + \", expected = NaN, actual = \" + RES.floatValue());\n+            }\n+        }\n+        for (int i = 0; i < 10000; i++) {\n+            Float16 SRC = Float16.valueOf(i);\n+            RES = testMinNaNOperands(Float16.NaN, SRC);\n+            if (!RES.equals(Float16.NaN)) {\n+                throw new AssertionError(\"input1 = NaN, input2 = \" + SRC.floatValue() + \", expected = NaN, actual = \" + RES.floatValue());\n+            }\n+        }\n+        for (int i = 0; i < 10000; i++) {\n+            RES = testMinNaNOperands(Float16.NaN, Float16.NaN);\n+            if (!RES.equals(Float16.NaN)) {\n+                throw new AssertionError(\"input1 = NaN, input2 = NaN, expected = NaN, actual = \" + RES.floatValue());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_HF, \" >0 \"})\n+    public Float16 testMaxZeroOperands(Float16 src1, Float16 src2) {\n+        return Float16.max(src1, src2);\n+    }\n+\n+    @Run(test = \"testMaxZeroOperands\")\n+    @Warmup(1000)\n+    public void launchMaxZeroOperands() {\n+        for (int i = 0; i < 10000; i++) {\n+            RES = testMaxZeroOperands(POS_ZERO, NEG_ZERO);\n+            if (!RES.equals(POS_ZERO)) {\n+                throw new AssertionError(\"input1 = +0.0, input2 = -0.0, expected = +0.0, actual = \" + RES.floatValue());\n+            }\n+        }\n+        for (int i = 0; i < 10000; i++) {\n+            Float16 SRC = Float16.valueOf(i);\n+            RES = testMaxZeroOperands(NEG_ZERO, POS_ZERO);\n+            if (!RES.equals(POS_ZERO)) {\n+                throw new AssertionError(\"input1 = -0.0, input2 = +0.0, expected = +0.0, actual = \" + RES.floatValue());\n+            }\n+        }\n+        for (int i = 0; i < 10000; i++) {\n+            Float16 SRC = Float16.valueOf(i);\n+            RES = testMaxZeroOperands(POS_ZERO, POS_ZERO);\n+            if (!RES.equals(POS_ZERO)) {\n+                throw new AssertionError(\"input1 = +0.0, input2 = +0.0, expected = +0.0, actual = \" + RES.floatValue());\n+            }\n+        }\n+        for (int i = 0; i < 10000; i++) {\n+            Float16 SRC = Float16.valueOf(i);\n+            RES = testMaxZeroOperands(NEG_ZERO, NEG_ZERO);\n+            if (!RES.equals(NEG_ZERO)) {\n+                throw new AssertionError(\"input1 = -0.0, input2 = -0.0, expected = -0.0, actual = \" + RES.floatValue());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MIN_HF, \" >0 \"})\n+    public Float16 testMinZeroOperands(Float16 src1, Float16 src2) {\n+        return Float16.min(src1, src2);\n+    }\n+\n+    @Run(test = \"testMinZeroOperands\")\n+    @Warmup(1000)\n+    public void launchMinZeroOperands() {\n+        for (int i = 0; i < 10000; i++) {\n+            RES = testMinZeroOperands(POS_ZERO, NEG_ZERO);\n+            if (!RES.equals(NEG_ZERO)) {\n+                throw new AssertionError(\"input1 = +0.0, input2 = -0.0, expected = -0.0, actual = \" + RES.floatValue());\n+            }\n+        }\n+        for (int i = 0; i < 10000; i++) {\n+            Float16 SRC = Float16.valueOf(i);\n+            RES = testMinZeroOperands(NEG_ZERO, POS_ZERO);\n+            if (!RES.equals(NEG_ZERO)) {\n+                throw new AssertionError(\"input1 = -0.0, input2 = +0.0, expected = -0.0, actual = \" + RES.floatValue());\n+            }\n+        }\n+        for (int i = 0; i < 10000; i++) {\n+            Float16 SRC = Float16.valueOf(i);\n+            RES = testMinZeroOperands(POS_ZERO, POS_ZERO);\n+            if (!RES.equals(POS_ZERO)) {\n+                throw new AssertionError(\"input1 = +0.0, input2 = +0.0, expected = +0.0, actual = \" + RES.floatValue());\n+            }\n+        }\n+        for (int i = 0; i < 10000; i++) {\n+            Float16 SRC = Float16.valueOf(i);\n+            RES = testMinZeroOperands(NEG_ZERO, NEG_ZERO);\n+            if (!RES.equals(NEG_ZERO)) {\n+                throw new AssertionError(\"input1 = -0.0, input2 = -0.0, expected = -0.0, actual = \" + RES.floatValue());\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestFloat16MaxMinSpecialValues.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"}]}