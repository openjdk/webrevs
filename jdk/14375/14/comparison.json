{"files":[{"patch":"@@ -1299,3 +1299,2 @@\n-  Label profile_cast_success, profile_cast_failure;\n-  Label *success_target = should_profile ? &profile_cast_success : success;\n-  Label *failure_target = should_profile ? &profile_cast_failure : failure;\n+  Label* success_target = success;\n+  Label* failure_target = failure;\n@@ -1317,18 +1316,27 @@\n-    if (should_profile) {\n-      Label not_null;\n-      __ cbnz(obj, not_null);\n-      \/\/ Object is null; update MDO and exit\n-      Register mdo  = klass_RInfo;\n-      __ mov_metadata(mdo, md->constant_encoding());\n-      Address data_addr\n-        = __ form_address(rscratch2, mdo,\n-                          md->byte_offset_of_slot(data, DataLayout::flags_offset()),\n-                          0);\n-      __ ldrb(rscratch1, data_addr);\n-      __ orr(rscratch1, rscratch1, BitData::null_seen_byte_constant());\n-      __ strb(rscratch1, data_addr);\n-      __ b(*obj_is_null);\n-      __ bind(not_null);\n-    } else {\n-      __ cbz(obj, *obj_is_null);\n-    }\n+  if (should_profile) {\n+    Register mdo  = klass_RInfo;\n+    __ mov_metadata(mdo, md->constant_encoding());\n+    Label not_null;\n+    __ cbnz(obj, not_null);\n+    \/\/ Object is null; update MDO and exit\n+    Address data_addr\n+      = __ form_address(rscratch2, mdo,\n+                        md->byte_offset_of_slot(data, DataLayout::flags_offset()),\n+                        0);\n+    __ ldrb(rscratch1, data_addr);\n+    __ orr(rscratch1, rscratch1, BitData::null_seen_byte_constant());\n+    __ strb(rscratch1, data_addr);\n+    __ b(*obj_is_null);\n+    __ bind(not_null);\n+\n+    Label update_done;\n+    Register recv = k_RInfo;\n+    __ load_klass(recv, obj);\n+    type_profile_helper(mdo, md, data, recv, &update_done);\n+    Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n+    __ addptr(counter_addr, DataLayout::counter_increment);\n+\n+    __ bind(update_done);\n+  } else {\n+    __ cbz(obj, *obj_is_null);\n+  }\n@@ -1388,20 +1396,0 @@\n-  if (should_profile) {\n-    Register mdo  = klass_RInfo, recv = k_RInfo;\n-    __ bind(profile_cast_success);\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    __ load_klass(recv, obj);\n-    Label update_done;\n-    type_profile_helper(mdo, md, data, recv, success);\n-    __ b(*success);\n-\n-    __ bind(profile_cast_failure);\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    Address counter_addr\n-      = __ form_address(rscratch2, mdo,\n-                        md->byte_offset_of_slot(data, CounterData::count_offset()),\n-                        0);\n-    __ ldr(rscratch1, counter_addr);\n-    __ sub(rscratch1, rscratch1, DataLayout::counter_increment);\n-    __ str(rscratch1, counter_addr);\n-    __ b(*failure);\n-  }\n@@ -1439,3 +1427,3 @@\n-    Label profile_cast_success, profile_cast_failure, done;\n-    Label *success_target = should_profile ? &profile_cast_success : &done;\n-    Label *failure_target = should_profile ? &profile_cast_failure : stub->entry();\n+    Label done;\n+    Label* success_target = &done;\n+    Label* failure_target = stub->entry();\n@@ -1445,2 +1433,0 @@\n-      __ cbnz(value, not_null);\n-      \/\/ Object is null; update MDO and exit\n@@ -1449,0 +1435,2 @@\n+      __ cbnz(value, not_null);\n+      \/\/ Object is null; update MDO and exit\n@@ -1458,0 +1446,8 @@\n+\n+      Label update_done;\n+      Register recv = k_RInfo;\n+      __ load_klass(recv, value);\n+      type_profile_helper(mdo, md, data, recv, &update_done);\n+      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n+      __ addptr(counter_addr, DataLayout::counter_increment);\n+      __ bind(update_done);\n@@ -1478,19 +1474,0 @@\n-    if (should_profile) {\n-      Register mdo  = klass_RInfo, recv = k_RInfo;\n-      __ bind(profile_cast_success);\n-      __ mov_metadata(mdo, md->constant_encoding());\n-      __ load_klass(recv, value);\n-      Label update_done;\n-      type_profile_helper(mdo, md, data, recv, &done);\n-      __ b(done);\n-\n-      __ bind(profile_cast_failure);\n-      __ mov_metadata(mdo, md->constant_encoding());\n-      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-      __ lea(rscratch2, counter_addr);\n-      __ ldr(rscratch1, Address(rscratch2));\n-      __ sub(rscratch1, rscratch1, DataLayout::counter_increment);\n-      __ str(rscratch1, Address(rscratch2));\n-      __ b(*stub->entry());\n-    }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":42,"deletions":65,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -330,3 +330,0 @@\n-\n-  \/\/ Profile the failure of the check.\n-  profile_typecheck_failed(r2); \/\/ blows r2\n@@ -1226,1 +1223,1 @@\n-    record_klass_in_profile(receiver, mdp, reg2, true);\n+    record_klass_in_profile(receiver, mdp, reg2);\n@@ -1249,1 +1246,1 @@\n-                                        Label& done, bool is_virtual_call) {\n+                                        Label& done) {\n@@ -1251,8 +1248,1 @@\n-    if (is_virtual_call) {\n-      increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n-    }\n-#if INCLUDE_JVMCI\n-    else if (EnableJVMCI) {\n-      increment_mdp_data_at(mdp, in_bytes(ReceiverTypeData::nonprofiled_receiver_count_offset()));\n-    }\n-#endif \/\/ INCLUDE_JVMCI\n+    increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n@@ -1260,10 +1250,0 @@\n-    int non_profiled_offset = -1;\n-    if (is_virtual_call) {\n-      non_profiled_offset = in_bytes(CounterData::count_offset());\n-    }\n-#if INCLUDE_JVMCI\n-    else if (EnableJVMCI) {\n-      non_profiled_offset = in_bytes(ReceiverTypeData::nonprofiled_receiver_count_offset());\n-    }\n-#endif \/\/ INCLUDE_JVMCI\n-\n@@ -1271,1 +1251,1 @@\n-        &VirtualCallData::receiver_offset, &VirtualCallData::receiver_count_offset, non_profiled_offset);\n+        &VirtualCallData::receiver_offset, &VirtualCallData::receiver_count_offset);\n@@ -1277,2 +1257,1 @@\n-                                        OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn,\n-                                        int non_profiled_offset) {\n+                                        OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn) {\n@@ -1309,10 +1288,6 @@\n-        if (non_profiled_offset >= 0) {\n-          cbz(reg2, found_null);\n-          \/\/ Item did not match any saved item and there is no empty row for it.\n-          \/\/ Increment total counter to indicate polymorphic case.\n-          increment_mdp_data_at(mdp, non_profiled_offset);\n-          b(done);\n-          bind(found_null);\n-        } else {\n-          cbnz(reg2, done);\n-        }\n+        cbz(reg2, found_null);\n+        \/\/ Item did not match any saved item and there is no empty row for it.\n+        \/\/ Increment total counter to indicate polymorphic case.\n+        increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n+        b(done);\n+        bind(found_null);\n@@ -1326,1 +1301,1 @@\n-        item_offset_fn, item_count_offset_fn, non_profiled_offset);\n+        item_offset_fn, item_count_offset_fn);\n@@ -1373,2 +1348,1 @@\n-                                                        Register mdp, Register reg2,\n-                                                        bool is_virtual_call) {\n+                                                        Register mdp, Register reg2) {\n@@ -1378,1 +1352,1 @@\n-  record_klass_in_profile_helper(receiver, mdp, reg2, 0, done, is_virtual_call);\n+  record_klass_in_profile_helper(receiver, mdp, reg2, 0, done);\n@@ -1440,18 +1414,0 @@\n-void InterpreterMacroAssembler::profile_typecheck_failed(Register mdp) {\n-  if (ProfileInterpreter && TypeProfileCasts) {\n-    Label profile_continue;\n-\n-    \/\/ If no method data exists, go to profile_continue.\n-    test_method_data_pointer(mdp, profile_continue);\n-\n-    int count_offset = in_bytes(CounterData::count_offset());\n-    \/\/ Back up the address, since we have already bumped the mdp.\n-    count_offset -= in_bytes(VirtualCallData::virtual_call_data_size());\n-\n-    \/\/ *Decrement* the counter.  We expect to see zero or small negatives.\n-    increment_mdp_data_at(mdp, count_offset, true);\n-\n-    bind (profile_continue);\n-  }\n-}\n-\n@@ -1471,1 +1427,1 @@\n-      record_klass_in_profile(klass, mdp, reg2, false);\n+      record_klass_in_profile(klass, mdp, reg2);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":15,"deletions":59,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -269,1 +269,1 @@\n-                               Register reg2, bool is_virtual_call);\n+                               Register reg2);\n@@ -272,1 +272,1 @@\n-                                      Label& done, bool is_virtual_call);\n+                                      Label& done);\n@@ -275,2 +275,1 @@\n-                                     OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn,\n-                                     int non_profiled_offset);\n+                                     OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -110,0 +110,2 @@\n+\n+  static bool profile_all_receivers_at_type_check() { return false; }\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+  static bool profile_all_receivers_at_type_check() { return false; }\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1136,1 +1136,3 @@\n-                                   Register klass_RInfo, Label* obj_is_null) {\n+                                   Register k_RInfo, Register klass_RInfo, Label* obj_is_null) {\n+  Register mdo = klass_RInfo;\n+  __ mov_metadata(mdo, md->constant_encoding());\n@@ -1140,2 +1142,0 @@\n-  Register mdo = klass_RInfo;\n-  __ mov_metadata(mdo, md->constant_encoding());\n@@ -1148,0 +1148,9 @@\n+\n+  Label update_done;\n+  Register recv = k_RInfo;\n+  __ load_klass(recv, obj);\n+  type_profile_helper(mdo, md, data, recv, &update_done);\n+  Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n+  __ increment(counter_addr, DataLayout::counter_increment);\n+\n+  __ bind(update_done);\n@@ -1174,3 +1183,2 @@\n-  Label profile_cast_success, profile_cast_failure;\n-  Label *success_target = should_profile ? &profile_cast_success : success;\n-  Label *failure_target = should_profile ? &profile_cast_failure : failure;\n+  Label* success_target = success;\n+  Label* failure_target = failure;\n@@ -1193,1 +1201,1 @@\n-    profile_object(md, data, obj, klass_RInfo, obj_is_null);\n+    profile_object(md, data, obj, k_RInfo, klass_RInfo, obj_is_null);\n@@ -1210,3 +1218,1 @@\n-  if (should_profile) {\n-    type_profile(obj, md, klass_RInfo, k_RInfo, data, success, failure, profile_cast_success, profile_cast_failure);\n-  }\n+\n@@ -2125,3 +2131,3 @@\n-  Label profile_cast_success, profile_cast_failure, done;\n-  Label *success_target = should_profile ? &profile_cast_success : &done;\n-  Label *failure_target = should_profile ? &profile_cast_failure : stub->entry();\n+  Label  done;\n+  Label* success_target = &done;\n+  Label* failure_target = stub->entry();\n@@ -2130,1 +2136,1 @@\n-    profile_object(md, data, value, klass_RInfo, &done);\n+    profile_object(md, data, value, k_RInfo, klass_RInfo, &done);\n@@ -2141,19 +2147,0 @@\n-  \/\/ fall through to the success case\n-  if (should_profile) {\n-    Register mdo = klass_RInfo;\n-    Register recv = k_RInfo;\n-    __ bind(profile_cast_success);\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    __ load_klass(recv, value);\n-    type_profile_helper(mdo, md, data, recv, &done);\n-    __ j(done);\n-\n-    __ bind(profile_cast_failure);\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-    __ ld(t1, counter_addr);\n-    __ addi(t1, t1, -DataLayout::counter_increment);\n-    __ sd(t1, counter_addr);\n-    __ j(*stub->entry());\n-  }\n-\n@@ -2163,21 +2150,0 @@\n-void LIR_Assembler::type_profile(Register obj, ciMethodData* md, Register klass_RInfo, Register k_RInfo,\n-                                 ciProfileData* data, Label* success, Label* failure,\n-                                 Label& profile_cast_success, Label& profile_cast_failure) {\n-  Register mdo = klass_RInfo;\n-  Register recv = k_RInfo;\n-  __ bind(profile_cast_success);\n-  __ mov_metadata(mdo, md->constant_encoding());\n-  __ load_klass(recv, obj);\n-  Label update_done;\n-  type_profile_helper(mdo, md, data, recv, success);\n-  __ j(*success);\n-\n-  __ bind(profile_cast_failure);\n-  __ mov_metadata(mdo, md->constant_encoding());\n-  Address counter_addr = __ form_address(t1, mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-  __ ld(t0, counter_addr);\n-  __ addi(t0, t0, -DataLayout::counter_increment);\n-  __ sd(t0, counter_addr);\n-  __ j(*failure);\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":20,"deletions":54,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-                      Register klass_RInfo, Label* obj_is_null);\n+                      Register k_RInfo, Register klass_RInfo, Label* obj_is_null);\n@@ -108,4 +108,0 @@\n-  void type_profile(Register obj, ciMethodData* md, Register klass_RInfo, Register k_RInfo,\n-                    ciProfileData* data, Label* success, Label* failure,\n-                    Label& profile_cast_success, Label& profile_cast_failure);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -354,3 +354,0 @@\n-\n-  \/\/ Profile the failure of the check.\n-  profile_typecheck_failed(x12); \/\/ blows x12\n@@ -1269,1 +1266,1 @@\n-    record_klass_in_profile(receiver, mdp, reg2, true);\n+    record_klass_in_profile(receiver, mdp, reg2);\n@@ -1294,2 +1291,1 @@\n-                                Register reg2,\n-                                Label& done, bool is_virtual_call) {\n+                                Register reg2, Label& done) {\n@@ -1297,4 +1293,1 @@\n-    if (is_virtual_call) {\n-      increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n-    }\n-\n+    increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n@@ -1302,5 +1295,0 @@\n-    int non_profiled_offset = -1;\n-    if (is_virtual_call) {\n-      non_profiled_offset = in_bytes(CounterData::count_offset());\n-    }\n-\n@@ -1308,1 +1296,1 @@\n-      &VirtualCallData::receiver_offset, &VirtualCallData::receiver_count_offset, non_profiled_offset);\n+        &VirtualCallData::receiver_offset, &VirtualCallData::receiver_count_offset);\n@@ -1312,3 +1300,3 @@\n-void InterpreterMacroAssembler::record_item_in_profile_helper(\n-  Register item, Register mdp, Register reg2, int start_row, Label& done, int total_rows,\n-  OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn, int non_profiled_offset) {\n+void InterpreterMacroAssembler::record_item_in_profile_helper(Register item, Register mdp,\n+                                        Register reg2, int start_row, Label& done, int total_rows,\n+                                        OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn) {\n@@ -1345,10 +1333,6 @@\n-        if (non_profiled_offset >= 0) {\n-          beqz(reg2, found_null);\n-          \/\/ Item did not match any saved item and there is no empty row for it.\n-          \/\/ Increment total counter to indicate polymorphic case.\n-          increment_mdp_data_at(mdp, non_profiled_offset);\n-          j(done);\n-          bind(found_null);\n-        } else {\n-          bnez(reg2, done);\n-        }\n+        beqz(reg2, found_null);\n+        \/\/ Item did not match any saved item and there is no empty row for it.\n+        \/\/ Increment total counter to indicate polymorphic case.\n+        increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n+        j(done);\n+        bind(found_null);\n@@ -1362,1 +1346,1 @@\n-        item_offset_fn, item_count_offset_fn, non_profiled_offset);\n+          item_offset_fn, item_count_offset_fn);\n@@ -1432,2 +1416,1 @@\n-                                                        Register mdp, Register reg2,\n-                                                        bool is_virtual_call) {\n+                                                        Register mdp, Register reg2) {\n@@ -1437,1 +1420,1 @@\n-  record_klass_in_profile_helper(receiver, mdp, reg2, done, is_virtual_call);\n+  record_klass_in_profile_helper(receiver, mdp, reg2, done);\n@@ -1497,18 +1480,0 @@\n-void InterpreterMacroAssembler::profile_typecheck_failed(Register mdp) {\n-    if (ProfileInterpreter && TypeProfileCasts) {\n-    Label profile_continue;\n-\n-    \/\/ If no method data exists, go to profile_continue.\n-    test_method_data_pointer(mdp, profile_continue);\n-\n-    int count_offset = in_bytes(CounterData::count_offset());\n-    \/\/ Back up the address, since we have already bumped the mdp.\n-    count_offset -= in_bytes(VirtualCallData::virtual_call_data_size());\n-\n-    \/\/ *Decrement* the counter.  We expect to see zero or small negatives.\n-    increment_mdp_data_at(mdp, count_offset, true);\n-\n-    bind (profile_continue);\n-  }\n-}\n-\n@@ -1528,1 +1493,1 @@\n-      record_klass_in_profile(klass, mdp, reg2, false);\n+      record_klass_in_profile(klass, mdp, reg2);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":17,"deletions":52,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-                               Register reg2, bool is_virtual_call);\n+                               Register reg2);\n@@ -253,2 +253,1 @@\n-                                      Register reg2,\n-                                      Label& done, bool is_virtual_call);\n+                                      Register reg2, Label& done);\n@@ -257,2 +256,1 @@\n-                                     OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn,\n-                                     int non_profiled_offset);\n+                                     OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -570,0 +570,1 @@\n+  static bool profile_all_receivers_at_type_check() { return false; }\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1698,3 +1698,2 @@\n-  Label profile_cast_success, profile_cast_failure;\n-  Label *success_target = op->should_profile() ? &profile_cast_success : success;\n-  Label *failure_target = op->should_profile() ? &profile_cast_failure : failure;\n+  Label* success_target = success;\n+  Label* failure_target = failure;\n@@ -1719,2 +1718,0 @@\n-    __ jccb(Assembler::notEqual, not_null);\n-    \/\/ Object is null; update MDO and exit\n@@ -1723,0 +1720,2 @@\n+    __ jccb(Assembler::notEqual, not_null);\n+    \/\/ Object is null; update MDO and exit\n@@ -1728,0 +1727,10 @@\n+\n+    Label update_done;\n+    Register recv = k_RInfo;\n+    __ load_klass(recv, obj, tmp_load_klass);\n+    type_profile_helper(mdo, md, data, recv, &update_done);\n+\n+    Address nonprofiled_receiver_count_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n+    __ addptr(nonprofiled_receiver_count_addr, DataLayout::counter_increment);\n+\n+    __ bind(update_done);\n@@ -1814,14 +1823,0 @@\n-  if (op->should_profile()) {\n-    Register mdo  = klass_RInfo, recv = k_RInfo;\n-    __ bind(profile_cast_success);\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    __ load_klass(recv, obj, tmp_load_klass);\n-    type_profile_helper(mdo, md, data, recv, success);\n-    __ jmp(*success);\n-\n-    __ bind(profile_cast_failure);\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-    __ subptr(counter_addr, DataLayout::counter_increment);\n-    __ jmp(*failure);\n-  }\n@@ -1858,3 +1853,3 @@\n-    Label profile_cast_success, profile_cast_failure, done;\n-    Label *success_target = op->should_profile() ? &profile_cast_success : &done;\n-    Label *failure_target = op->should_profile() ? &profile_cast_failure : stub->entry();\n+    Label done;\n+    Label* success_target = &done;\n+    Label* failure_target = stub->entry();\n@@ -1865,2 +1860,0 @@\n-      __ jccb(Assembler::notEqual, not_null);\n-      \/\/ Object is null; update MDO and exit\n@@ -1869,0 +1862,2 @@\n+      __ jccb(Assembler::notEqual, not_null);\n+      \/\/ Object is null; update MDO and exit\n@@ -1874,0 +1869,9 @@\n+\n+      Label update_done;\n+      Register recv = k_RInfo;\n+      __ load_klass(recv, value, tmp_load_klass);\n+      type_profile_helper(mdo, md, data, recv, &update_done);\n+\n+      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n+      __ addptr(counter_addr, DataLayout::counter_increment);\n+      __ bind(update_done);\n@@ -1897,15 +1901,0 @@\n-    if (op->should_profile()) {\n-      Register mdo  = klass_RInfo, recv = k_RInfo;\n-      __ bind(profile_cast_success);\n-      __ mov_metadata(mdo, md->constant_encoding());\n-      __ load_klass(recv, value, tmp_load_klass);\n-      type_profile_helper(mdo, md, data, recv, &done);\n-      __ jmpb(done);\n-\n-      __ bind(profile_cast_failure);\n-      __ mov_metadata(mdo, md->constant_encoding());\n-      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-      __ subptr(counter_addr, DataLayout::counter_increment);\n-      __ jmp(*stub->entry());\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":28,"deletions":39,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -572,3 +572,0 @@\n-\n-  \/\/ Profile the failure of the check.\n-  profile_typecheck_failed(rcx); \/\/ blows rcx\n@@ -1721,8 +1718,1 @@\n-    if (is_virtual_call) {\n-      increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n-    }\n-#if INCLUDE_JVMCI\n-    else if (EnableJVMCI) {\n-      increment_mdp_data_at(mdp, in_bytes(ReceiverTypeData::nonprofiled_receiver_count_offset()));\n-    }\n-#endif \/\/ INCLUDE_JVMCI\n+    increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n@@ -1730,10 +1720,0 @@\n-    int non_profiled_offset = -1;\n-    if (is_virtual_call) {\n-      non_profiled_offset = in_bytes(CounterData::count_offset());\n-    }\n-#if INCLUDE_JVMCI\n-    else if (EnableJVMCI) {\n-      non_profiled_offset = in_bytes(ReceiverTypeData::nonprofiled_receiver_count_offset());\n-    }\n-#endif \/\/ INCLUDE_JVMCI\n-\n@@ -1741,1 +1721,1 @@\n-        &VirtualCallData::receiver_offset, &VirtualCallData::receiver_count_offset, non_profiled_offset);\n+                                  &VirtualCallData::receiver_offset, &VirtualCallData::receiver_count_offset);\n@@ -1745,4 +1725,4 @@\n-void InterpreterMacroAssembler::record_item_in_profile_helper(Register item, Register mdp,\n-                                        Register reg2, int start_row, Label& done, int total_rows,\n-                                        OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn,\n-                                        int non_profiled_offset) {\n+void InterpreterMacroAssembler::record_item_in_profile_helper(Register item, Register mdp, Register reg2, int start_row,\n+                                                              Label& done, int total_rows,\n+                                                              OffsetFunction item_offset_fn,\n+                                                              OffsetFunction item_count_offset_fn) {\n@@ -1779,11 +1759,7 @@\n-        if (non_profiled_offset >= 0) {\n-          Label found_null;\n-          jccb(Assembler::zero, found_null);\n-          \/\/ Item did not match any saved item and there is no empty row for it.\n-          \/\/ Increment total counter to indicate polymorphic case.\n-          increment_mdp_data_at(mdp, non_profiled_offset);\n-          jmp(done);\n-          bind(found_null);\n-        } else {\n-          jcc(Assembler::notZero, done);\n-        }\n+        Label found_null;\n+        jccb(Assembler::zero, found_null);\n+        \/\/ Item did not match any saved item and there is no empty row for it.\n+        \/\/ Increment total counter to indicate polymorphic case.\n+        increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n+        jmp(done);\n+        bind(found_null);\n@@ -1798,1 +1774,1 @@\n-        item_offset_fn, item_count_offset_fn, non_profiled_offset);\n+                                    item_offset_fn, item_count_offset_fn);\n@@ -1914,19 +1890,0 @@\n-void InterpreterMacroAssembler::profile_typecheck_failed(Register mdp) {\n-  if (ProfileInterpreter && TypeProfileCasts) {\n-    Label profile_continue;\n-\n-    \/\/ If no method data exists, go to profile_continue.\n-    test_method_data_pointer(mdp, profile_continue);\n-\n-    int count_offset = in_bytes(CounterData::count_offset());\n-    \/\/ Back up the address, since we have already bumped the mdp.\n-    count_offset -= in_bytes(VirtualCallData::virtual_call_data_size());\n-\n-    \/\/ *Decrement* the counter.  We expect to see zero or small negatives.\n-    increment_mdp_data_at(mdp, count_offset, true);\n-\n-    bind (profile_continue);\n-  }\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":14,"deletions":57,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -260,4 +260,4 @@\n-  void record_item_in_profile_helper(Register item, Register mdp,\n-                                     Register reg2, int start_row, Label& done, int total_rows,\n-                                     OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn,\n-                                     int non_profiled_offset);\n+  void record_item_in_profile_helper(Register item, Register mdp, Register reg2, int start_row,\n+                                     Label& done, int total_rows,\n+                                     OffsetFunction item_offset_fn,\n+                                     OffsetFunction item_count_offset_fn);\n@@ -280,1 +280,1 @@\n-  void profile_typecheck_failed(Register mdp);\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+  static bool profile_all_receivers_at_type_check() { return false; }\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -444,0 +444,3 @@\n+      if (VM_Version::profile_all_receivers_at_type_check()) {\n+        return (c < 0 ? max_jint : c); \/\/ always non-negative\n+      }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -729,1 +729,0 @@\n-  declare_constant(ReceiverTypeData::nonprofiled_count_off_set)           \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -422,3 +422,0 @@\n-#if INCLUDE_JVMCI\n-  st->print_cr(\"count(%u) nonprofiled_count(%u) entries(%u)\", count(), nonprofiled_count(), entries);\n-#else\n@@ -426,1 +423,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1083,3 +1083,6 @@\n-\/\/ dynamic type check.  It consists of a counter which counts the total times\n-\/\/ that the check is reached, and a series of (Klass*, count) pairs\n-\/\/ which are used to store a type profile for the receiver of the check.\n+\/\/ dynamic type check.  It consists of a series of (Klass*, count)\n+\/\/ pairs which are used to store a type profile for the receiver of\n+\/\/ the check, the associated count is incremented every time the type\n+\/\/ is seen. A per ReceiverTypeData counter is incremented on type\n+\/\/ overflow (when there's no more room for a not yet profiled Klass*).\n+\/\/\n@@ -1091,13 +1094,0 @@\n-#if INCLUDE_JVMCI\n-    \/\/ Description of the different counters\n-    \/\/ ReceiverTypeData for instanceof\/checkcast\/aastore:\n-    \/\/   count is decremented for failed type checks\n-    \/\/   JVMCI only: nonprofiled_count is incremented on type overflow\n-    \/\/ VirtualCallData for invokevirtual\/invokeinterface:\n-    \/\/   count is incremented on type overflow\n-    \/\/   JVMCI only: nonprofiled_count is incremented on method overflow\n-\n-    \/\/ JVMCI is interested in knowing the percentage of type checks involving a type not explicitly in the profile\n-    nonprofiled_count_off_set = counter_cell_count,\n-    receiver0_offset,\n-#else\n@@ -1105,1 +1095,0 @@\n-#endif\n@@ -1120,1 +1109,1 @@\n-    return counter_cell_count + (uint) TypeProfileWidth * receiver_type_row_cell_count JVMCI_ONLY(+ 1);\n+    return counter_cell_count + (uint) TypeProfileWidth * receiver_type_row_cell_count;\n@@ -1182,7 +1171,0 @@\n-#if INCLUDE_JVMCI\n-    if (!this->is_VirtualCallData()) {\n-      \/\/ if this is a ReceiverTypeData for JVMCI, the nonprofiled_count\n-      \/\/ must also be reset (see \"Description of the different counters\" above)\n-      set_nonprofiled_count(0);\n-    }\n-#endif\n@@ -1198,11 +1180,0 @@\n-#if INCLUDE_JVMCI\n-  static ByteSize nonprofiled_receiver_count_offset() {\n-    return cell_offset(nonprofiled_count_off_set);\n-  }\n-  uint nonprofiled_count() const {\n-    return uint_at(nonprofiled_count_off_set);\n-  }\n-  void set_nonprofiled_count(uint count) {\n-    set_uint_at(nonprofiled_count_off_set, count);\n-  }\n-#endif \/\/ INCLUDE_JVMCI\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":7,"deletions":36,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -777,0 +777,6 @@\n+                                                                            \\\n+  product(intx, TypeProfileSubTypeCheckCommonThreshold, 50,                 \\\n+          \"Use profile data at type check if profiled types account for\"    \\\n+          \"more than this threshold\")                                       \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -342,1 +342,1 @@\n-  Node* search_identical(int dist);\n+  Node* search_identical(int dist, PhaseIterGVN* igvn);\n@@ -441,0 +441,2 @@\n+\n+  bool same_condition(const Node* dom, PhaseIterGVN* igvn) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2680,1 +2680,2 @@\n-Node* Phase::gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, Node* mem, PhaseGVN& gvn) {\n+Node* Phase::gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, Node* mem, PhaseGVN& gvn,\n+                               ciMethod* method, int bci) {\n@@ -2737,1 +2738,3 @@\n-  bool might_be_cache = (gvn.find_int_con(chk_off, cacheoff_con) == cacheoff_con);\n+  const TypeInt* chk_off_t = chk_off->Value(&gvn)->isa_int();\n+  int chk_off_con = (chk_off_t != nullptr && chk_off_t->is_con()) ? chk_off_t->get_con() : cacheoff_con;\n+  bool might_be_cache = (chk_off_con == cacheoff_con);\n@@ -2765,1 +2768,1 @@\n-  if( superklass == nkls )\n+  if (superklass == nkls) {\n@@ -2767,0 +2770,41 @@\n+  }\n+\n+  \/\/ Gather the various success & failures here\n+  RegionNode* r_not_subtype = new RegionNode(3);\n+  gvn.record_for_igvn(r_not_subtype);\n+  RegionNode* r_ok_subtype = new RegionNode(4);\n+  gvn.record_for_igvn(r_ok_subtype);\n+\n+  \/\/ If we might perform an expensive check, first try to take advantage of profile data that was attached to the\n+  \/\/ SubTypeCheck node\n+  if (might_be_cache && method != nullptr && VM_Version::profile_all_receivers_at_type_check()) {\n+    ciCallProfile profile = method->call_profile_at_bci(bci);\n+    float total_prob = 0;\n+    for (int i = 0; profile.has_receiver(i); ++i) {\n+      float prob = profile.receiver_prob(i);\n+      total_prob += prob;\n+    }\n+    if (total_prob * 100. >= TypeProfileSubTypeCheckCommonThreshold) {\n+      const TypeKlassPtr* superk = gvn.type(superklass)->is_klassptr();\n+      for (int i = 0; profile.has_receiver(i); ++i) {\n+        ciKlass* klass = profile.receiver(i);\n+        const TypeKlassPtr* klass_t = TypeKlassPtr::make(klass);\n+        Compile::SubTypeCheckResult result = C->static_subtype_check(superk, klass_t);\n+        if (result != Compile::SSC_always_true && result != Compile::SSC_always_false) {\n+          continue;\n+        }\n+        float prob = profile.receiver_prob(i);\n+        ConNode* klass_node = gvn.makecon(klass_t);\n+        IfNode* iff = gen_subtype_check_compare(*ctrl, subklass, klass_node, BoolTest::eq, prob, gvn, T_ADDRESS);\n+        Node* iftrue = gvn.transform(new IfTrueNode(iff));\n+\n+        if (result == Compile::SSC_always_true) {\n+          r_ok_subtype->add_req(iftrue);\n+        } else {\n+          assert(result == Compile::SSC_always_false, \"\");\n+          r_not_subtype->add_req(iftrue);\n+        }\n+        *ctrl = gvn.transform(new IfFalseNode(iff));\n+      }\n+    }\n+  }\n@@ -2782,0 +2826,5 @@\n+    PhaseIterGVN* igvn = gvn.is_IterGVN();\n+    if (igvn != nullptr) {\n+      igvn->remove_globally_dead_node(r_ok_subtype);\n+      igvn->remove_globally_dead_node(r_not_subtype);\n+    }\n@@ -2785,6 +2834,0 @@\n-  \/\/ Gather the various success & failures here\n-  RegionNode *r_ok_subtype = new RegionNode(4);\n-  gvn.record_for_igvn(r_ok_subtype);\n-  RegionNode *r_not_subtype = new RegionNode(3);\n-  gvn.record_for_igvn(r_not_subtype);\n-\n@@ -2854,1 +2897,1 @@\n-    Node* n = Phase::gen_subtype_check(subklass, superklass, &ctrl, mem, _gvn);\n+    Node* n = Phase::gen_subtype_check(subklass, superklass, &ctrl, mem, _gvn, method(), bci());\n@@ -2859,1 +2902,1 @@\n-  Node* check = _gvn.transform(new SubTypeCheckNode(C, obj_or_subklass, superklass));\n+  Node* check = _gvn.transform(new SubTypeCheckNode(C, obj_or_subklass, superklass, method(), bci()));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":54,"deletions":11,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"opto\/subtypenode.hpp\"\n@@ -1484,1 +1485,1 @@\n-  Node* prev_dom = search_identical(dist);\n+  Node* prev_dom = search_identical(dist, igvn);\n@@ -1559,1 +1560,1 @@\n-Node* IfNode::search_identical(int dist) {\n+Node* IfNode::search_identical(int dist, PhaseIterGVN* igvn) {\n@@ -1565,2 +1566,2 @@\n-  while (dom->Opcode() != op    ||  \/\/ Not same opcode?\n-         dom->in(1)    != in(1) ||  \/\/ Not same input 1?\n+  while (dom->Opcode() != op ||  \/\/ Not same opcode?\n+         !same_condition(dom, igvn) ||  \/\/ Not same input 1?\n@@ -1590,0 +1591,30 @@\n+bool IfNode::same_condition(const Node* dom, PhaseIterGVN* igvn) const {\n+  Node* dom_bool = dom->in(1);\n+  Node* this_bool = in(1);\n+  if (dom_bool == this_bool) {\n+    return true;\n+  }\n+\n+  if (dom_bool == nullptr || !dom_bool->is_Bool() ||\n+      this_bool == nullptr || !this_bool->is_Bool()) {\n+    return false;\n+  }\n+  Node* dom_cmp = dom_bool->in(1);\n+  Node* this_cmp = this_bool->in(1);\n+\n+  \/\/ If the comparison is a subtype check, then SubTypeCheck nodes may have profile data attached to them and may be\n+  \/\/ different nodes even-though they perform the same subtype check\n+  if (dom_cmp == nullptr || !dom_cmp->is_SubTypeCheck() ||\n+      this_cmp == nullptr || !this_cmp->is_SubTypeCheck()) {\n+    return false;\n+  }\n+\n+  if (dom_cmp->in(1) != this_cmp->in(1) ||\n+      dom_cmp->in(2) != this_cmp->in(2) ||\n+      dom_bool->as_Bool()->_test._test != this_bool->as_Bool()->_test._test) {\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n@@ -1967,1 +1998,1 @@\n-    prev_dom = search_identical(4);\n+    prev_dom = search_identical(4, igvn);\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1742,0 +1742,3 @@\n+\n+  Node* similar_subtype_check(const Node* x, Node* r_in);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -141,0 +141,3 @@\n+        if (y == nullptr) {\n+          y = similar_subtype_check(x, region->in(i));\n+        }\n@@ -218,0 +221,24 @@\n+\/\/ Subtype checks that carry profile data don't common so look for a replacement by following edges\n+Node* PhaseIdealLoop::similar_subtype_check(const Node* x, Node* r_in) {\n+  if (x->is_SubTypeCheck()) {\n+    Node* in1 = x->in(1);\n+    for (DUIterator_Fast imax, i = in1->fast_outs(imax); i < imax; i++) {\n+      Node* u = in1->fast_out(i);\n+      if (u != x && u->is_SubTypeCheck() && u->in(1) == x->in(1) && u->in(2) == x->in(2)) {\n+        for (DUIterator_Fast jmax, j = u->fast_outs(jmax); j < jmax; j++) {\n+          Node* bol = u->fast_out(j);\n+          for (DUIterator_Fast kmax, k = bol->fast_outs(kmax); k < kmax; k++) {\n+            Node* iff = bol->fast_out(k);\n+            \/\/ Only dominating subtype checks are interesting: otherwise we risk replacing a subtype check by another with\n+            \/\/ unrelated profile\n+            if (iff->is_If() && is_dominator(iff, r_in)) {\n+              return u;\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -1231,1 +1258,1 @@\n-  if (!dom->is_If() || dom->in(1) != n->in(1)) {\n+  if (!dom->is_If() ||  !n->as_If()->same_condition(dom, &_igvn)) {\n@@ -1418,1 +1445,1 @@\n-    if (max > 1 && bol->is_Bool()) {\n+    if (bol->is_Bool() && (max > 1 || bol->in(1)->is_SubTypeCheck())) {\n@@ -1420,1 +1447,2 @@\n-      Node *cutoff = get_ctrl(bol);\n+      Node* cmp = bol->in(1);\n+      Node *cutoff = cmp->is_SubTypeCheck() ? dom_lca(get_ctrl(cmp->in(1)), get_ctrl(cmp->in(2))) : get_ctrl(bol);\n@@ -1426,1 +1454,1 @@\n-        if (dom->req() > 1 && dom->in(1) == bol && prevdom->in(0) == dom &&\n+        if (dom->req() > 1 && n->as_If()->same_condition(dom, &_igvn) && prevdom->in(0) == dom &&\n@@ -1482,0 +1510,6 @@\n+    if (n->in(1) != dom_if->in(1)) {\n+      assert(n->in(1)->in(1)->is_SubTypeCheck() &&\n+             (n->in(1)->in(1)->as_SubTypeCheck()->method() != nullptr ||\n+              dom_if->in(1)->in(1)->as_SubTypeCheck()->method() != nullptr), \"only for subtype checks with profile data attached\");\n+      _igvn.replace_input_of(n, 1, dom_if->in(1));\n+    }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":38,"deletions":4,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2319,1 +2319,1 @@\n-    Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &ctrl, nullptr, _igvn);\n+    Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &ctrl, nullptr, _igvn, check->method(), check->bci());\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -636,1 +636,1 @@\n-      Node* not_subtype_ctrl = Phase::gen_subtype_check(src_klass, dest_klass, ctrl, mem, _igvn);\n+      Node* not_subtype_ctrl = Phase::gen_subtype_check(src_klass, dest_klass, ctrl, mem, _igvn, nullptr, -1);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  static Node* gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, Node* mem, PhaseGVN& gvn);\n+  static Node* gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, Node* mem, PhaseGVN& gvn, ciMethod* method, int bci);\n","filename":"src\/hotspot\/share\/opto\/phase.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -229,1 +229,0 @@\n-\n@@ -231,0 +230,18 @@\n+\n+uint SubTypeCheckNode::size_of() const {\n+  return sizeof(*this);\n+}\n+\n+uint SubTypeCheckNode::hash() const {\n+  return NO_HASH;\n+}\n+\n+#ifndef PRODUCT\n+void SubTypeCheckNode::dump_spec(outputStream* st) const {\n+  if (_method != nullptr) {\n+    st->print(\" profiled at: \");\n+    _method->print_short_name(st);\n+    st->print(\":%d\", _bci);\n+  }\n+}\n+#endif\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n-  SubTypeCheckNode(Compile* C, Node* obj_or_subklass, Node* superklass)\n-    : CmpNode(obj_or_subklass, superklass) {\n+  SubTypeCheckNode(Compile* C, Node* obj_or_subklass, Node* superklass, ciMethod* method, int bci)\n+    : CmpNode(obj_or_subklass, superklass), _method(method), _bci(bci) {\n@@ -51,1 +51,11 @@\n-  bool depends_only_on_test() const { return false; };\n+  bool depends_only_on_test() const { return false; }\n+\n+  ciMethod* method() const { return _method; }\n+  int bci() const { return _bci; }\n+\n+  uint size_of() const;\n+  uint hash() const;\n+\n+#ifndef PRODUCT\n+  void dump_spec(outputStream* st) const;\n+#endif\n@@ -53,1 +63,0 @@\n-#ifdef ASSERT\n@@ -55,0 +64,4 @@\n+  \/\/ method\/bci for this subtype check so profile data can be retrieved after parsing is over\n+  ciMethod* _method;\n+  int _bci;\n+#ifdef ASSERT\n@@ -59,1 +72,0 @@\n-#endif \/\/ ASSERT\n@@ -62,0 +74,1 @@\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/opto\/subtypenode.hpp","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -189,0 +189,2 @@\n+  static bool profile_all_receivers_at_type_check() { return true; }\n+\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-  static final int INCLUDE_JVMCI;\n@@ -47,6 +46,1 @@\n-    INCLUDE_JVMCI = VM.getVM().getTypeDataBase().lookupIntConstant(\"INCLUDE_JVMCI\");\n-    if (INCLUDE_JVMCI == 1) {\n-        receiver0Offset = nonProfiledCountOffset + 1;\n-    } else {\n-        receiver0Offset = counterCellCount;\n-    }\n+    receiver0Offset = counterCellCount;\n@@ -69,3 +63,0 @@\n-    if (INCLUDE_JVMCI == 1) {\n-      cellCount += 1;\n-    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ReceiverTypeData.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-        final int nonprofiledCountOffset = cellIndexToOffset(config.receiverTypeDataNonprofiledCountOffset);\n@@ -70,2 +69,2 @@\n-        final int typeCheckDataSize = cellIndexToOffset(2) + typeDataRowSize * config.typeProfileWidth;\n-        final int virtualCallDataSize = cellIndexToOffset(2) + typeDataRowSize * (config.typeProfileWidth + config.methodProfileWidth);\n+        final int typeCheckDataSize = cellIndexToOffset(1) + typeDataRowSize * config.typeProfileWidth;\n+        final int virtualCallDataSize = cellIndexToOffset(1) + typeDataRowSize * (config.typeProfileWidth + config.methodProfileWidth);\n@@ -505,1 +504,1 @@\n-            totalCount += getTypesNotRecordedExecutionCount(data, position);\n+            totalCount += getCounterValue(data, position);\n@@ -509,6 +508,0 @@\n-        protected abstract long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position);\n-\n-        public int getNonprofiledCount(HotSpotMethodData data, int position) {\n-            return data.readUnsignedIntAsSignedInt(position, state.nonprofiledCountOffset);\n-        }\n-\n@@ -549,2 +542,2 @@\n-            sb.append(format(\"count(%d) null_seen(%s) exception_seen(%s) nonprofiled_count(%d) entries(%d)\", getCounterValue(data, pos), nullSeen, exceptionSeen,\n-                            getNonprofiledCount(data, pos), profile.entries));\n+            sb.append(format(\"count(%d) null_seen(%s) exception_seen(%s) entries(%d)\", getCounterValue(data, pos), nullSeen, exceptionSeen,\n+                            profile.entries));\n@@ -573,5 +566,0 @@\n-\n-        @Override\n-        protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {\n-            return getNonprofiledCount(data, position);\n-        }\n@@ -603,9 +591,0 @@\n-        @Override\n-        protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {\n-            return getCounterValue(data, position);\n-        }\n-\n-        private long getMethodsNotRecordedExecutionCount(HotSpotMethodData data, int position) {\n-            return data.readUnsignedIntAsSignedInt(position, state.nonprofiledCountOffset);\n-        }\n-\n@@ -637,2 +616,0 @@\n-            totalCount += getMethodsNotRecordedExecutionCount(data, position);\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotMethodData.java","additions":5,"deletions":28,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -379,1 +379,0 @@\n-    final int receiverTypeDataNonprofiledCountOffset = getConstant(\"ReceiverTypeData::nonprofiled_count_off_set\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,434 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.whitebox.gc.GC;\n+import java.util.ArrayList;\n+\n+\/*\n+ * @test\n+ * bug 8308869\n+ * @summary C2: use profile data in subtype checks when profile has more than one class\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @requires vm.compiler2.enabled\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.c2.irTests.ProfileAtTypeCheck\n+ *\/\n+\n+public class ProfileAtTypeCheck {\n+    public static void main(String[] args) {\n+        \/\/ Only interpreter collects profile\n+        Scenario interpreterProfiling = new Scenario(0, \"-XX:TypeProfileSubTypeCheckCommonThreshold=90\", \"-XX:-TieredCompilation\");\n+        \/\/ Only c1 collects profile\n+        Scenario c1Profiling = new Scenario(1, \"-XX:TypeProfileSubTypeCheckCommonThreshold=90\", \"-XX:+TieredCompilation\", \"-XX:-ProfileInterpreter\");\n+\n+        if (GC.isSelectedErgonomically() && GC.Parallel.isSupported()) {\n+            interpreterProfiling.addFlags(\"-XX:+UseParallelGC\");\n+            c1Profiling.addFlags(\"-XX:+UseParallelGC\");\n+        }\n+\n+        TestFramework framework = new TestFramework();\n+        framework.addScenarios(interpreterProfiling, c1Profiling).start();\n+    }\n+\n+    @DontInline\n+    static void dummyA(A a) {\n+    }\n+\n+    @DontInline\n+    static void dummyB(B b) {\n+    }\n+\n+    @DontInline\n+    static void dummyI(I i) {\n+    }\n+\n+    \/\/ profile reports many classes\n+\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    @IR(phase = { CompilePhase.MACRO_EXPANSION }, counts = { IRNode.CMP_P, \"2\", IRNode.LOAD_KLASS_OR_NKLASS, \"2\" })\n+    public static void test1(Object o) {\n+        dummyA((A)o);\n+    }\n+\n+    @Run(test = \"test1\")\n+    @Warmup(10000)\n+    private void test1Runner() {\n+        test1(a);\n+        test1(b);\n+        test1(c);\n+        test1(d);\n+    }\n+\n+    \/\/ profile reports a single class\n+\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, failOn = { IRNode.SUBTYPE_CHECK })\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.CMP_P, \"2\", IRNode.LOAD_KLASS_OR_NKLASS, \"1\" })\n+    public static void test2(Object o) {\n+        dummyA((A)o);\n+    }\n+\n+    @Run(test = \"test2\")\n+    @Warmup(10000)\n+    private void test2Runner() {\n+        test2(a);\n+    }\n+\n+    \/\/ \"easy\" test because B has no subclass\n+\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    @IR(phase = { CompilePhase.MACRO_EXPANSION }, counts = { IRNode.CMP_P, \"2\", IRNode.LOAD_KLASS_OR_NKLASS, \"1\" })\n+    public static void test3(Object o) {\n+        if (o instanceof B) {\n+            dummyB((B)o);\n+        }\n+    }\n+\n+    @Run(test = \"test3\")\n+    @Warmup(10000)\n+    private void test3Runner() {\n+        test3(b);\n+        test3(c);\n+        test3(d);\n+    }\n+\n+    \/\/ full subtype check\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    @IR(phase = { CompilePhase.MACRO_EXPANSION }, counts = { IRNode.CMP_P, \"3\", IRNode.LOAD_KLASS_OR_NKLASS, \"2\", IRNode.PARTIAL_SUBTYPE_CHECK, \"1\" })\n+    public static void test4(Object o) {\n+        dummyI((I)o);\n+    }\n+\n+    @Run(test = \"test4\")\n+    @Warmup(10000)\n+    private void test4Runner() {\n+        test4(a);\n+        test4(b);\n+        test4(c);\n+        test4(d);\n+    }\n+\n+    \/\/ full subtype check + profile use for success path\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    @IR(phase = { CompilePhase.MACRO_EXPANSION }, counts = { IRNode.CMP_P, \"5\", IRNode.LOAD_KLASS_OR_NKLASS, \"2\", IRNode.PARTIAL_SUBTYPE_CHECK, \"1\" })\n+    public static void test5(Object o) {\n+        dummyI((I)o);\n+    }\n+\n+    @Run(test = \"test5\")\n+    @Warmup(10000)\n+    private void test5Runner() {\n+        test5(a);\n+        test5(b);\n+    }\n+\n+    \/\/ Check primary super\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    @IR(phase = { CompilePhase.MACRO_EXPANSION }, counts = { IRNode.CMP_P, \"2\", IRNode.LOAD_KLASS_OR_NKLASS, \"2\" }, failOn = { IRNode.PARTIAL_SUBTYPE_CHECK })\n+    public static void test6(Object o) {\n+        dummyA((A)o);\n+    }\n+\n+    @Run(test = \"test6\")\n+    @Warmup(10000)\n+    private void test6Runner() {\n+        test6(b);\n+        test6(c);\n+        test6(d);\n+    }\n+\n+    \/\/ full subtype check + profile use for both success and failure paths\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    @IR(phase = { CompilePhase.MACRO_EXPANSION }, counts = { IRNode.CMP_P, \"5\", IRNode.LOAD_KLASS_OR_NKLASS, \"2\", IRNode.PARTIAL_SUBTYPE_CHECK, \"1\" })\n+    public static boolean test7(Object o) {\n+        return o instanceof I;\n+    }\n+\n+    @Run(test = \"test7\")\n+    @Warmup(10000)\n+    private void test7Runner() {\n+        test7(a);\n+        test7(e);\n+    }\n+\n+    \/\/ full subtype check + profile use for success path (profile has unrecorded entries)\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    @IR(phase = { CompilePhase.MACRO_EXPANSION }, counts = { IRNode.CMP_P, \"5\", IRNode.LOAD_KLASS_OR_NKLASS, \"2\", IRNode.PARTIAL_SUBTYPE_CHECK, \"1\" })\n+    public static void test8(Object o) {\n+        dummyI((I)o);\n+    }\n+\n+    @Run(test = \"test8\")\n+    @Warmup(10000)\n+    private void test8Runner() {\n+        for (int i = 0; i < 40; i++) {\n+            test8(a); \/\/ 95% of profile is A\n+        }\n+        \/\/ plus some B and C\n+        test8(b);\n+        test8(c);\n+    }\n+\n+    \/\/ test that split if triggers\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    @IR(phase = { CompilePhase.PHASEIDEALLOOP1 }, counts = { IRNode.SUBTYPE_CHECK, \"2\" })\n+    public static void test9(boolean flag1, boolean flag2, Object o1, Object o2) {\n+        if (o1 == null) {\n+            throw new RuntimeException();\n+        }\n+        if (o2 == null) {\n+            throw new RuntimeException();\n+        }\n+        Object o;\n+        if (flag1) {\n+            o = a;\n+            if (o == null) {\n+            }\n+        } else {\n+            if (flag2) {\n+                o = o1;\n+            } else {\n+                o = o2;\n+            }\n+        }\n+        dummyI((I)o);\n+    }\n+\n+    @Run(test = \"test9\")\n+    @Warmup(10_000)\n+    private void test9Runner() {\n+        test9(true, true, a, a);\n+        test9(false, true, c, c);\n+        test9(false, false, d, d);\n+    }\n+\n+    \/\/ test that dominating subtype check is removed\n+    static Object fieldTest10;\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"2\" })\n+    @IR(phase = { CompilePhase.ITER_GVN1 }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    public static void test10(boolean flag) {\n+        if (fieldTest10 instanceof I) {\n+            if (flag) {\n+                dummyI((I)fieldTest10);\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test10\")\n+    @Warmup(10_000)\n+    private void test10Runner() {\n+        fieldTest10 = a;\n+        test10(true);\n+        fieldTest10 = b;\n+        test10(false);\n+        fieldTest10 = c;\n+        test10(true);\n+        fieldTest10 = d;\n+        test10(false);\n+    }\n+\n+    static Object fieldTest11;\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"2\" })\n+    @IR(phase = { CompilePhase.PHASEIDEALLOOP_ITERATIONS }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    public static void test11(boolean flag1, boolean flag2) {\n+        if (fieldTest11 instanceof I) {\n+            if (flag1) {\n+                for (int i = 1; i < 10; i *= 2) {\n+                }\n+            }\n+            if (flag2) {\n+                dummyI((I)fieldTest11);\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test11\")\n+    @Warmup(10_000)\n+    private void test11Runner() {\n+        fieldTest11 = a;\n+        test11(true, true);\n+        fieldTest11 = b;\n+        test11(false, false);\n+        fieldTest11 = c;\n+        test11(true, true);\n+        fieldTest11 = d;\n+        test11(false, false);\n+    }\n+\n+    static Object fieldTest12;\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"3\" })\n+    @IR(phase = { CompilePhase.PHASEIDEALLOOP_ITERATIONS }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    public static void test12() {\n+        test12Helper(true);\n+    }\n+\n+    public static void test12Helper(boolean flag) {\n+        if (fieldTest12 instanceof I) {\n+            for (int i = 1; i < 10; i *= 2) {\n+            }\n+        }\n+        if (flag) {\n+            if (fieldTest12 instanceof I) {\n+                dummyI((I)fieldTest12);\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test12\")\n+    @Warmup(10_000)\n+    private void test12Runner() {\n+        fieldTest12 = a;\n+        test12();\n+        test12Helper(false);\n+        fieldTest12 = b;\n+        test12();\n+        test12Helper(false);\n+        fieldTest12 = c;\n+        test12();\n+        test12Helper(true);\n+        fieldTest12 = d;\n+        test12();\n+        test12Helper(true);\n+        fieldTest12 = e;\n+        test12();\n+    }\n+\n+    \/\/ Test that subtype checks with different profile don't common\n+    @Test\n+    @IR(phase = { CompilePhase.ITER_GVN1 }, counts = { IRNode.SUBTYPE_CHECK, \"2\" })\n+    public static void test13(boolean flag, Object o) {\n+        if (o == null) {\n+            throw new RuntimeException();\n+        }\n+        if (flag) {\n+            dummyI((I)o);\n+        } else {\n+            dummyI((I)o);\n+        }\n+    }\n+\n+    @Run(test = \"test13\")\n+    @Warmup(10_000)\n+    private void test13Runner() {\n+        test13(true, a);\n+        test13(true, b);\n+        test13(false, c);\n+        test13(false, d);\n+    }\n+\n+    static Object fieldTest14_1;\n+    static Object fieldTest14_2;\n+    \/\/ test that split if triggers\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"2\" })\n+    @IR(applyIf = { \"UseParallelGC\", \"true\" }, phase = { CompilePhase.PHASEIDEALLOOP1 }, counts = { IRNode.SUBTYPE_CHECK, \"3\" })\n+    public static void test14(boolean flag1, boolean flag2, Object o1, Object o2, Object o3) {\n+        if (o1 == null) {\n+            throw new RuntimeException();\n+        }\n+        if (o2 == null) {\n+            throw new RuntimeException();\n+        }\n+        if (o3 == null) {\n+            throw new RuntimeException();\n+        }\n+        Object o;\n+        if (flag1) {\n+            fieldTest14_1 = o3;\n+            fieldTest14_2 = (I)o3;\n+            o = fieldTest14_1;\n+        } else {\n+            if (flag2) {\n+                o = o1;\n+            } else {\n+                o = o2;\n+            }\n+        }\n+        dummyI((I)o);\n+    }\n+\n+    @Run(test = \"test14\")\n+    @Warmup(10_000)\n+    private void test14Runner() {\n+        test14(true, true, a, a, a);\n+        test14(true, true, b, b, b);\n+        test14(false, true, c, c, c);\n+        test14(false, false, d, d, d);\n+    }\n+\n+    \/\/ full subtype check + profile use for success path\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    @IR(phase = { CompilePhase.MACRO_EXPANSION }, counts = { IRNode.CMP_P, \"5\", IRNode.LOAD_KLASS_OR_NKLASS, \"2\", IRNode.PARTIAL_SUBTYPE_CHECK, \"1\" })\n+    public static void test15(Object o) {\n+        array[0] = o;\n+    }\n+\n+    @Run(test = \"test15\")\n+    @Warmup(10000)\n+    private void test15Runner() {\n+        test15(a);\n+        test15(b);\n+    }\n+\n+    interface I {\n+    }\n+\n+\n+    static A a = new A();\n+    static B b = new B();\n+    static C c = new C();\n+    static D d = new D();\n+    static E e = new E();\n+    static final Object[] array = new I[1];\n+\n+    static class A implements I {\n+    }\n+\n+    static class B extends A {\n+    }\n+\n+    static class C extends A {\n+    }\n+\n+    static class D extends A {\n+    }\n+\n+    static class E {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ProfileAtTypeCheck.java","additions":434,"deletions":0,"binary":false,"changes":434,"status":"added"},{"patch":"@@ -435,0 +435,5 @@\n+    public static final String CMP_P = PREFIX + \"CMP_P\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_P, \"CmpP\");\n+    }\n+\n@@ -627,0 +632,10 @@\n+    public static final String LOAD_NKLASS = PREFIX + \"LOAD_NKLASS\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_NKLASS, \"LoadNKlass\");\n+    }\n+\n+    public static final String LOAD_KLASS_OR_NKLASS = PREFIX + \"LOAD_KLASS_OR_NKLASS\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_KLASS_OR_NKLASS, \"LoadN?Klass\");\n+    }\n+\n@@ -1051,0 +1066,5 @@\n+    public static final String PARTIAL_SUBTYPE_CHECK = PREFIX + \"PARTIAL_SUBTYPE_CHECK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(PARTIAL_SUBTYPE_CHECK, \"PartialSubtypeCheck\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-                 BadFailOnConstraint.create(Traps.class, \"nullCheck()\", 3, \"uncommon_trap\", \"unstable_if\"),\n+                 BadFailOnConstraint.create(Traps.class, \"nullCheck()\", 3, \"uncommon_trap\", \"class_check\"),\n@@ -225,4 +225,4 @@\n-        runCheck(BadFailOnConstraint.create(CheckCastArray.class, \"array()\", 1, cmp, \"precise\"),\n-                 BadFailOnConstraint.create(CheckCastArray.class, \"array()\", 2, 1,cmp, \"precise\", \"MyClass\"),\n-                 BadFailOnConstraint.create(CheckCastArray.class, \"array()\", 2, 2,cmp, \"precise\", \"ir_framework\/tests\/MyClass\"),\n-                 GoodFailOnConstraint.create(CheckCastArray.class, \"array()\", 3),\n+        runCheck(BadFailOnConstraint.create(CheckCastArray.class, \"array(java.lang.Object[])\", 1, cmp, \"precise\"),\n+                 BadFailOnConstraint.create(CheckCastArray.class, \"array(java.lang.Object[])\", 2, 1,cmp, \"precise\", \"MyClass\"),\n+                 BadFailOnConstraint.create(CheckCastArray.class, \"array(java.lang.Object[])\", 2, 2,cmp, \"precise\", \"ir_framework\/tests\/MyClass\"),\n+                 GoodFailOnConstraint.create(CheckCastArray.class, \"array(java.lang.Object[])\", 3),\n@@ -1083,1 +1083,1 @@\n-    @IR(failOn = IRNode.UNSTABLE_IF_TRAP) \/\/ fails\n+    @IR(failOn = IRNode.CLASS_CHECK_TRAP) \/\/ fails\n@@ -1087,1 +1087,1 @@\n-                  IRNode.CLASS_CHECK_TRAP,\n+                  IRNode.UNSTABLE_IF_TRAP,\n@@ -1240,2 +1240,8 @@\n-    public boolean array() {\n-        return oArr instanceof MyClass[];\n+    public boolean array(Object[] arr) {\n+        return arr instanceof MyClass[];\n+    }\n+\n+    @Run(test = \"array\")\n+    public void testArray() {\n+        array(oArr);\n+        array(mArr);\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"}]}