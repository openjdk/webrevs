{"files":[{"patch":"@@ -4417,0 +4417,215 @@\n+#ifdef COMPILER2\n+\n+  \/\/ In sun.security.util.math.intpoly.IntegerPolynomial1305, integers\n+  \/\/ are represented as long[5], with BITS_PER_LIMB = 26.\n+  \/\/ Pack five 26-bit limbs into three 64-bit registers.\n+  void pack_26(Register dest0, Register dest1, Register dest2, Register src, Register tmp1, Register tmp2) {\n+    assert_different_registers(dest0, dest1, dest2, src, tmp1, tmp2);\n+\n+    \/\/ The goal is to have 128-bit value in dest2:dest1:dest0\n+    __ ld(dest0, Address(src, 0));    \/\/ 26 bits in dest0\n+\n+    __ ld(tmp1, Address(src, sizeof(jlong)));\n+    __ slli(tmp1, tmp1, 26);\n+    __ add(dest0, dest0, tmp1);       \/\/ 52 bits in dest0\n+\n+    __ ld(tmp2, Address(src, 2 * sizeof(jlong)));\n+    __ slli(tmp1, tmp2, 52);\n+    __ add(dest0, dest0, tmp1);       \/\/ dest0 is full\n+\n+    __ srli(dest1, tmp2, 12);         \/\/ 14-bit in dest1\n+\n+    __ ld(tmp1, Address(src, 3 * sizeof(jlong)));\n+    __ slli(tmp1, tmp1, 14);\n+    __ add(dest1, dest1, tmp1);       \/\/ 40-bit in dest1\n+\n+    __ ld(tmp1, Address(src, 4 * sizeof(jlong)));\n+    __ slli(tmp2, tmp1, 40);\n+    __ add(dest1, dest1, tmp2);       \/\/ dest1 is full\n+\n+    if (dest2->is_valid()) {\n+      __ srli(tmp1, tmp1, 24);\n+      __ mv(dest2, tmp1);               \/\/ 2 bits in dest2\n+    } else {\n+#ifdef ASSERT\n+      Label OK;\n+      __ srli(tmp1, tmp1, 24);\n+      __ beq(zr, tmp1, OK);           \/\/ 2 bits\n+      __ stop(\"high bits of Poly1305 integer should be zero\");\n+      __ should_not_reach_here();\n+      __ bind(OK);\n+#endif\n+    }\n+  }\n+\n+  \/\/ As above, but return only a 128-bit integer, packed into two\n+  \/\/ 64-bit registers.\n+  void pack_26(Register dest0, Register dest1, Register src, Register tmp1, Register tmp2) {\n+    pack_26(dest0, dest1, noreg, src, tmp1, tmp2);\n+  }\n+\n+  \/\/ Multiply and multiply-accumulate unsigned 64-bit registers.\n+  void wide_mul(Register prod_lo, Register prod_hi, Register n, Register m) {\n+    __ mul(prod_lo, n, m);\n+    __ mulhu(prod_hi, n, m);\n+  }\n+  void wide_madd(Register sum_lo, Register sum_hi, Register n,\n+                 Register m, Register tmp1, Register tmp2) {\n+    wide_mul(tmp1, tmp2, n, m);\n+    __ cad(sum_lo, sum_lo, tmp1, tmp1);  \/\/ Add tmp1 to sum_lo with carry output to tmp1\n+    __ adc(sum_hi, sum_hi, tmp2, tmp1);  \/\/ Add tmp2 with carry to sum_hi\n+  }\n+\n+  \/\/ Poly1305, RFC 7539\n+  \/\/ Intrinsified version of com.sun.crypto.provider.Poly1305.processMultipleBlocks\n+\n+  \/\/ Arguments:\n+  \/\/    c_rarg0:   input_start -- where the input is stored\n+  \/\/    c_rarg1:   length\n+  \/\/    c_rarg2:   acc_start -- where the output will be stored\n+  \/\/    c_rarg3:   r_start -- where the randomly generated 128-bit key is stored\n+\n+  \/\/ See https:\/\/loup-vaillant.fr\/tutorials\/poly1305-design for a\n+  \/\/ description of the tricks used to simplify and accelerate this\n+  \/\/ computation.\n+\n+  address generate_poly1305_processBlocks() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"poly1305_processBlocks\");\n+    address start = __ pc();\n+    __ enter();\n+    Label here;\n+    const int64_t bits2 = right_n_bits(2);\n+\n+    RegSet saved_regs = RegSet::range(x18, x21);\n+    RegSetIterator<Register> regs = (RegSet::range(x13, x31) - RegSet::range(x22, x27)).begin();\n+    __ push_reg(saved_regs, sp);\n+\n+    \/\/ Arguments\n+    const Register input_start = c_rarg0, length = c_rarg1, acc_start = c_rarg2, r_start = c_rarg3;\n+\n+    \/\/ R_n is the 128-bit randomly-generated key, packed into two\n+    \/\/ registers. The caller passes this key to us as long[5], with\n+    \/\/ BITS_PER_LIMB = 26.\n+    const Register R_0 = *++regs, R_1 = *++regs;\n+    pack_26(R_0, R_1, r_start, t1, t2);\n+\n+    \/\/ RR_n is (R_n >> 2) * 5\n+    const Register RR_0 = *++regs, RR_1 = *++regs;\n+    __ srli(t1, R_0, 2);\n+    __ shadd(RR_0, t1, t1, t2, 2);\n+    __ srli(t1, R_1, 2);\n+    __ shadd(RR_1, t1, t1, t2, 2);\n+\n+    \/\/ U_n is the current checksum\n+    const Register U_0 = *++regs, U_1 = *++regs, U_2 = *++regs;\n+    pack_26(U_0, U_1, U_2, acc_start, t1, t2);\n+\n+    static constexpr int BLOCK_LENGTH = 16;\n+    Label DONE, LOOP;\n+\n+    __ mv(t1, checked_cast<u1>(BLOCK_LENGTH));\n+    __ blt(length, t1, DONE); {\n+      __ bind(LOOP);\n+\n+      \/\/ S_n is to be the sum of U_n and the next block of data\n+      const Register S_0 = *++regs, S_1 = *++regs, S_2 = *++regs;\n+      __ ld(S_0, Address(input_start, 0));\n+      __ ld(S_1, Address(input_start, wordSize));\n+\n+      __ cad(S_0, S_0, U_0, t1); \/\/ Add U_0 to S_0 with carry output to t1\n+      __ cadc(S_1, S_1, U_1, t1); \/\/ Add U_1 with carry to S_1 with carry output to t1\n+      __ add(S_2, U_2, t1);\n+\n+      __ addi(S_2, S_2, 1);\n+\n+      const Register U_0HI = *++regs, U_1HI = *++regs;\n+\n+      \/\/ NB: this logic depends on some of the special properties of\n+      \/\/ Poly1305 keys. In particular, because we know that the top\n+      \/\/ four bits of R_0 and R_1 are zero, we can add together\n+      \/\/ partial products without any risk of needing to propagate a\n+      \/\/ carry out.\n+      wide_mul(U_0, U_0HI, S_0, R_0);\n+      wide_madd(U_0, U_0HI, S_1, RR_1, t1, t2);\n+      wide_madd(U_0, U_0HI, S_2, RR_0, t1, t2);\n+\n+      wide_mul(U_1, U_1HI, S_0, R_1);\n+      wide_madd(U_1, U_1HI, S_1, R_0, t1, t2);\n+      wide_madd(U_1, U_1HI, S_2, RR_1, t1, t2);\n+\n+      __ andi(U_2, R_0, bits2);\n+      __ mul(U_2, S_2, U_2);\n+\n+      \/\/ Recycle registers S_0, S_1, S_2\n+      regs = (regs.remaining() + S_0 + S_1 + S_2).begin();\n+\n+      \/\/ Partial reduction mod 2**130 - 5\n+      __ cad(U_1, U_1, U_0HI, t1); \/\/ Add U_0HI to U_1 with carry output to t1\n+      __ adc(U_2, U_2, U_1HI, t1);\n+      \/\/ Sum now in U_2:U_1:U_0.\n+      \/\/ Dead: U_0HI, U_1HI.\n+      regs = (regs.remaining() + U_0HI + U_1HI).begin();\n+\n+      \/\/ U_2:U_1:U_0: += (U_2 >> 2) * 5\n+      __ srli(t1, U_2, 2);\n+      __ andi(U_2, U_2, bits2); \/\/ Clear U_2 except for the first two bits\n+      __ shadd(t1, t1, t1, t2, 2); \/\/ t1 is impossible to overflow since two leftmost bits are zero'ed in 'srli(t1, U_2, 2)'\n+      __ cad(U_0, U_0, t1, t2); \/\/ Add t1 (= (U_2 >> 2) * 5) to U_0 with carry output to t2\n+      __ cad(U_1, U_1, t2, t2); \/\/ Add carry to U_1 with carry output to t2\n+      __ add(U_2, U_2, t2);\n+\n+      __ sub(length, length, checked_cast<u1>(BLOCK_LENGTH));\n+      __ addi(input_start, input_start, 2 * wordSize);\n+      __ mv(t1, checked_cast<u1>(BLOCK_LENGTH));\n+      __ bge(length, t1, LOOP);\n+    }\n+\n+    \/\/ Further reduce modulo 2^130 - 5\n+    __ srli(t1, U_2, 2);\n+    __ shadd(t1, t1, t1, t2, 2); \/\/ t1 = U_2 * 5\n+    __ cad(U_0, U_0, t1, t2); \/\/ U_0 += U_2 * 5 with carry output to t2\n+    __ cad(U_1, U_1, t2, t2); \/\/ Add carry to U_1 with carry output to t2\n+    __ andi(U_2, U_2, bits2);\n+    __ add(U_2, U_2, t2); \/\/ Add carry to U_2\n+\n+    \/\/ Unpack the sum into five 26-bit limbs and write to memory.\n+    \/\/ First 26 bits is the first limb\n+    __ slli(t1, U_0, 38); \/\/ Take lowest 26 bits\n+    __ srli(t1, t1, 38);\n+    __ sd(t1, Address(acc_start)); \/\/ First 26-bit limb\n+\n+    \/\/ 27-52 bits of U_0 is the second limb\n+    __ slli(t1, U_0, 12); \/\/ Take next 27-52 bits\n+    __ srli(t1, t1, 38);\n+    __ sd(t1, Address(acc_start, sizeof (jlong))); \/\/ Second 26-bit limb\n+\n+    \/\/ Getting 53-64 bits of U_0 and 1-14 bits of U_1 in one register\n+    __ srli(t1, U_0, 52);\n+    __ slli(t2, U_1, 50);\n+    __ srli(t2, t2, 38);\n+    __ add(t1, t1, t2);\n+    __ sd(t1, Address(acc_start, 2 * sizeof (jlong))); \/\/ Third 26-bit limb\n+\n+    \/\/ Storing 15-40 bits of U_1\n+    __ slli(t1, U_1, 24); \/\/ Already used up 14 bits\n+    __ srli(t1, t1, 38); \/\/ Clear all other bits from t1\n+    __ sd(t1, Address(acc_start, 3 * sizeof (jlong))); \/\/ Fourth 26-bit limb\n+\n+    \/\/ Storing 41-64 bits of U_1 and first two bits from U_2 in one register\n+    __ srli(t1, U_1, 40);\n+    __ andi(t2, U_2, bits2); \/\/ Clear all bits in U_2 except for first 2\n+    __ slli(t2, t2, 24);\n+    __ add(t1, t1, t2);\n+    __ sd(t1, Address(acc_start, 4 * sizeof (jlong))); \/\/ Fifth 26-bit limb\n+\n+    __ bind(DONE);\n+    __ pop_reg(saved_regs, sp);\n+    __ leave(); \/\/ Required for proper stackwalking\n+    __ ret();\n+\n+    return start;\n+  }\n+\n+#endif \/\/ COMPILER2\n+\n@@ -4638,0 +4853,4 @@\n+    if (UsePoly1305Intrinsics) {\n+      StubRoutines::_poly1305_processBlocks = generate_poly1305_processBlocks();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":219,"deletions":0,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -194,0 +194,4 @@\n+  if (FLAG_IS_DEFAULT(UsePoly1305Intrinsics)) {\n+    FLAG_SET_DEFAULT(UsePoly1305Intrinsics, true);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}