{"files":[{"patch":"@@ -2051,0 +2051,17 @@\n+\/\/ Multiply and multiply-accumulate unsigned 64-bit registers.\n+void MacroAssembler::wide_mul(Register prod_lo, Register prod_hi, Register n, Register m) {\n+  assert_different_registers(prod_lo, prod_hi);\n+\n+  mul(prod_lo, n, m);\n+  mulhu(prod_hi, n, m);\n+}\n+void MacroAssembler::wide_madd(Register sum_lo, Register sum_hi, Register n,\n+                Register m, Register tmp1, Register tmp2) {\n+  assert_different_registers(sum_lo, sum_hi);\n+  assert_different_registers(sum_hi, tmp2);\n+\n+  wide_mul(tmp1, tmp2, n, m);\n+  cad(sum_lo, sum_lo, tmp1, tmp1);  \/\/ Add tmp1 to sum_lo with carry output to tmp1\n+  adc(sum_hi, sum_hi, tmp2, tmp1);  \/\/ Add tmp2 with carry to sum_hi\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -201,0 +201,4 @@\n+  void wide_mul(Register prod_lo, Register prod_hi, Register n, Register m);\n+  void wide_madd(Register sum_lo, Register sum_hi, Register n,\n+                Register m, Register tmp1, Register tmp2);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2712,1 +2712,1 @@\n-    __ orr(haystack_len, haystack_len, needle_len); \/\/ restore needle_len(32bits)\n+    __ orr(haystack_len, haystack_len, needle_len); \/\/ restore needle_len(3right_2_bits)\n@@ -4417,0 +4417,208 @@\n+#ifdef COMPILER2\n+\n+static const int64_t right_2_bits = right_n_bits(2);\n+static const int64_t right_3_bits = right_n_bits(3);\n+\n+  \/\/ In sun.security.util.math.intpoly.IntegerPolynomial1305, integers\n+  \/\/ are represented as long[5], with BITS_PER_LIMB = 26.\n+  \/\/ Pack five 26-bit limbs into three 64-bit registers.\n+  void poly1305_pack_26(Register dest0, Register dest1, Register dest2, Register src, Register tmp1, Register tmp2) {\n+    assert_different_registers(dest0, dest1, dest2, src, tmp1, tmp2);\n+\n+    \/\/ The goal is to have 128-bit value in dest2:dest1:dest0\n+    __ ld(dest0, Address(src, 0));    \/\/ 26 bits in dest0\n+\n+    __ ld(tmp1, Address(src, sizeof(jlong)));\n+    __ slli(tmp1, tmp1, 26);\n+    __ add(dest0, dest0, tmp1);       \/\/ 52 bits in dest0\n+\n+    __ ld(tmp2, Address(src, 2 * sizeof(jlong)));\n+    __ slli(tmp1, tmp2, 52);\n+    __ add(dest0, dest0, tmp1);       \/\/ dest0 is full\n+\n+    __ srli(dest1, tmp2, 12);         \/\/ 14-bit in dest1\n+\n+    __ ld(tmp1, Address(src, 3 * sizeof(jlong)));\n+    __ slli(tmp1, tmp1, 14);\n+    __ add(dest1, dest1, tmp1);       \/\/ 40-bit in dest1\n+\n+    __ ld(tmp1, Address(src, 4 * sizeof(jlong)));\n+    __ slli(tmp2, tmp1, 40);\n+    __ add(dest1, dest1, tmp2);       \/\/ dest1 is full\n+\n+    if (dest2->is_valid()) {\n+      __ srli(tmp1, tmp1, 24);\n+      __ mv(dest2, tmp1);               \/\/ 2 bits in dest2\n+    } else {\n+#ifdef ASSERT\n+      Label OK;\n+      __ srli(tmp1, tmp1, 24);\n+      __ beq(zr, tmp1, OK);           \/\/ 2 bits\n+      __ stop(\"high bits of Poly1305 integer should be zero\");\n+      __ should_not_reach_here();\n+      __ bind(OK);\n+#endif\n+    }\n+  }\n+\n+  \/\/ As above, but return only a 128-bit integer, packed into two\n+  \/\/ 64-bit registers.\n+  void poly1305_pack_26(Register dest0, Register dest1, Register src, Register tmp1, Register tmp2) {\n+    poly1305_pack_26(dest0, dest1, noreg, src, tmp1, tmp2);\n+  }\n+\n+  \/\/ U_2:U_1:U_0: += (U_2 >> 2) * 5\n+  void poly1305_reduce(Register U_2, Register U_1, Register U_0, Register tmp1, Register tmp2) {\n+    assert_different_registers(U_2, U_1, U_0, tmp1, tmp2);\n+\n+    \/\/ First, U_2:U_1:U_0 += (U_2 >> 2)\n+    __ srli(tmp1, U_2, 2);\n+    __ cad(U_0, U_0, tmp1, tmp2); \/\/ Add tmp1 to U_0 with carry output to tmp2\n+    __ andi(U_2, U_2, right_2_bits); \/\/ Clear U_2 except for the lowest two bits\n+    __ cad(U_1, U_1, tmp2, tmp2); \/\/ Add carry to U_1 with carry output to tmp2\n+    __ add(U_2, U_2, tmp2);\n+\n+    \/\/ Second, U_2:U_1:U_0 += (U_2 >> 2) << 2\n+    __ slli(tmp1, tmp1, 2);\n+    __ cad(U_0, U_0, tmp1, tmp2); \/\/ Add tmp1 to U_0 with carry output to tmp2\n+    __ cad(U_1, U_1, tmp2, tmp2); \/\/ Add carry to U_1 with carry output to tmp2\n+    __ add(U_2, U_2, tmp2);\n+  }\n+\n+  \/\/ Poly1305, RFC 7539\n+  \/\/ void com.sun.crypto.provider.Poly1305.processMultipleBlocks(byte[] input, int offset, int length, long[] aLimbs, long[] rLimbs)\n+\n+  \/\/ Arguments:\n+  \/\/    c_rarg0:   input_start -- where the input is stored\n+  \/\/    c_rarg1:   length\n+  \/\/    c_rarg2:   acc_start -- where the output will be stored\n+  \/\/    c_rarg3:   r_start -- where the randomly generated 128-bit key is stored\n+\n+  \/\/ See https:\/\/loup-vaillant.fr\/tutorials\/poly1305-design for a\n+  \/\/ description of the tricks used to simplify and accelerate this\n+  \/\/ computation.\n+\n+  address generate_poly1305_processBlocks() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"poly1305_processBlocks\");\n+    address start = __ pc();\n+    __ enter();\n+    Label here;\n+\n+    RegSet saved_regs = RegSet::range(x18, x21);\n+    RegSetIterator<Register> regs = (RegSet::range(x14, x31) - RegSet::range(x22, x27)).begin();\n+    __ push_reg(saved_regs, sp);\n+\n+    \/\/ Arguments\n+    const Register input_start = c_rarg0, length = c_rarg1, acc_start = c_rarg2, r_start = c_rarg3;\n+\n+    \/\/ R_n is the 128-bit randomly-generated key, packed into two\n+    \/\/ registers. The caller passes this key to us as long[5], with\n+    \/\/ BITS_PER_LIMB = 26.\n+    const Register R_0 = *regs, R_1 = *++regs;\n+    poly1305_pack_26(R_0, R_1, r_start, t1, t2);\n+\n+    \/\/ RR_n is (R_n >> 2) * 5\n+    const Register RR_0 = *++regs, RR_1 = *++regs;\n+    __ srli(t1, R_0, 2);\n+    __ shadd(RR_0, t1, t1, t2, 2);\n+    __ srli(t1, R_1, 2);\n+    __ shadd(RR_1, t1, t1, t2, 2);\n+\n+    \/\/ U_n is the current checksum\n+    const Register U_0 = *++regs, U_1 = *++regs, U_2 = *++regs;\n+    poly1305_pack_26(U_0, U_1, U_2, acc_start, t1, t2);\n+\n+    static constexpr int BLOCK_LENGTH = 16;\n+    Label DONE, LOOP;\n+\n+    __ mv(t1, BLOCK_LENGTH);\n+    __ blt(length, t1, DONE); {\n+      __ bind(LOOP);\n+\n+      \/\/ S_n is to be the sum of U_n and the next block of data\n+      const Register S_0 = *++regs, S_1 = *++regs, S_2 = *++regs;\n+      __ ld(S_0, Address(input_start, 0));\n+      __ ld(S_1, Address(input_start, wordSize));\n+\n+      __ cad(S_0, S_0, U_0, t1); \/\/ Add U_0 to S_0 with carry output to t1\n+      __ cadc(S_1, S_1, U_1, t1); \/\/ Add U_1 with carry to S_1 with carry output to t1\n+      __ add(S_2, U_2, t1);\n+\n+      __ addi(S_2, S_2, 1);\n+\n+      const Register U_0HI = *++regs, U_1HI = *++regs;\n+\n+      \/\/ NB: this logic depends on some of the special properties of\n+      \/\/ Poly1305 keys. In particular, because we know that the top\n+      \/\/ four bits of R_0 and R_1 are zero, we can add together\n+      \/\/ partial products without any risk of needing to propagate a\n+      \/\/ carry out.\n+      __ wide_mul(U_0, U_0HI, S_0, R_0);\n+      __ wide_madd(U_0, U_0HI, S_1, RR_1, t1, t2);\n+      __ wide_madd(U_0, U_0HI, S_2, RR_0, t1, t2);\n+\n+      __ wide_mul(U_1, U_1HI, S_0, R_1);\n+      __ wide_madd(U_1, U_1HI, S_1, R_0, t1, t2);\n+      __ wide_madd(U_1, U_1HI, S_2, RR_1, t1, t2);\n+\n+      __ andi(U_2, R_0, right_2_bits);\n+      __ mul(U_2, S_2, U_2);\n+\n+      \/\/ Partial reduction mod 2**130 - 5\n+      __ cad(U_1, U_1, U_0HI, t1); \/\/ Add U_0HI to U_1 with carry output to t1\n+      __ adc(U_2, U_2, U_1HI, t1);\n+      \/\/ Sum is now in U_2:U_1:U_0.\n+\n+      \/\/ U_2:U_1:U_0: += (U_2 >> 2) * 5\n+      poly1305_reduce(U_2, U_1, U_0, t1, t2);\n+\n+      __ sub(length, length, BLOCK_LENGTH);\n+      __ addi(input_start, input_start, BLOCK_LENGTH);\n+      __ mv(t1, BLOCK_LENGTH);\n+      __ bge(length, t1, LOOP);\n+    }\n+\n+    \/\/ Further reduce modulo 2^130 - 5\n+    poly1305_reduce(U_2, U_1, U_0, t1, t2);\n+\n+    \/\/ Unpack the sum into five 26-bit limbs and write to memory.\n+    \/\/ First 26 bits is the first limb\n+    __ slli(t1, U_0, 38); \/\/ Take lowest 26 bits\n+    __ srli(t1, t1, 38);\n+    __ sd(t1, Address(acc_start)); \/\/ First 26-bit limb\n+\n+    \/\/ 27-52 bits of U_0 is the second limb\n+    __ slli(t1, U_0, 12); \/\/ Take next 27-52 bits\n+    __ srli(t1, t1, 38);\n+    __ sd(t1, Address(acc_start, sizeof (jlong))); \/\/ Second 26-bit limb\n+\n+    \/\/ Getting 53-64 bits of U_0 and 1-14 bits of U_1 in one register\n+    __ srli(t1, U_0, 52);\n+    __ slli(t2, U_1, 50);\n+    __ srli(t2, t2, 38);\n+    __ add(t1, t1, t2);\n+    __ sd(t1, Address(acc_start, 2 * sizeof (jlong))); \/\/ Third 26-bit limb\n+\n+    \/\/ Storing 15-40 bits of U_1\n+    __ slli(t1, U_1, 24); \/\/ Already used up 14 bits\n+    __ srli(t1, t1, 38); \/\/ Clear all other bits from t1\n+    __ sd(t1, Address(acc_start, 3 * sizeof (jlong))); \/\/ Fourth 26-bit limb\n+\n+    \/\/ Storing 41-64 bits of U_1 and first three bits from U_2 in one register\n+    __ srli(t1, U_1, 40);\n+    __ andi(t2, U_2, right_3_bits);\n+    __ slli(t2, t2, 24);\n+    __ add(t1, t1, t2);\n+    __ sd(t1, Address(acc_start, 4 * sizeof (jlong))); \/\/ Fifth 26-bit limb\n+\n+    __ bind(DONE);\n+    __ pop_reg(saved_regs, sp);\n+    __ leave(); \/\/ Required for proper stackwalking\n+    __ ret();\n+\n+    return start;\n+  }\n+\n+#endif \/\/ COMPILER2\n+\n@@ -4638,0 +4846,4 @@\n+    if (UsePoly1305Intrinsics) {\n+      StubRoutines::_poly1305_processBlocks = generate_poly1305_processBlocks();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":213,"deletions":1,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -194,0 +194,4 @@\n+  if (FLAG_IS_DEFAULT(UsePoly1305Intrinsics)) {\n+    FLAG_SET_DEFAULT(UsePoly1305Intrinsics, true);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}