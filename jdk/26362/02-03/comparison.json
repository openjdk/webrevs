{"files":[{"patch":"@@ -61,0 +61,1 @@\n+#include \"opto\/graphInvariants.hpp\"\n@@ -700,1 +701,2 @@\n-      _in_dump_cnt(0)\n+      _in_dump_cnt(0),\n+      _invariant_checker(GraphInvariantChecker::make_default())\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+class GraphInvariantChecker;\n@@ -1317,0 +1318,2 @@\n+\n+  NOT_PRODUCT(GraphInvariantChecker* _invariant_checker;)\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"metaprogramming\/enableIf.hpp\"\n@@ -32,1 +33,1 @@\n-  precond(live_nodes.size() == 0);\n+  precond(_live_nodes.size() == 0);\n@@ -35,3 +36,3 @@\n-  live_nodes.push(Compile::current()->root());\n-  for (uint i = 0; i < live_nodes.size(); ++i) {\n-    Node* n = live_nodes.at(i);\n+  _live_nodes.push(Compile::current()->root());\n+  for (uint i = 0; i < _live_nodes.size(); ++i) {\n+    Node* n = _live_nodes.at(i);\n@@ -41,1 +42,1 @@\n-        live_nodes.push(out);\n+        _live_nodes.push(out);\n@@ -46,1 +47,1 @@\n-  postcond(live_nodes.size() > 0);\n+  postcond(_live_nodes.size() > 0);\n@@ -50,1 +51,1 @@\n-  if (live_nodes.size() == 0) {\n+  if (_live_nodes.size() == 0) {\n@@ -53,34 +54,2 @@\n-  assert(live_nodes.size() > 0, \"filling failed\");\n-  return !live_nodes.member(n);\n-}\n-\n-void print_path(const Node_List& steps, const GrowableArray<int>& path, stringStream& ss) {\n-  const int path_len = path.length();\n-  precond(steps.size() == static_cast<uint>(path_len) + 1);\n-  if (path.is_empty()) {\n-    ss.print_cr(\"At center node\");\n-    steps.at(0)->dump(\"\\n\", false, &ss);\n-    return;\n-  }\n-  ss.print(\"At node\\n   \");\n-  steps.at(0)->dump(\"\\n\", false, &ss);\n-  ss.print_cr(\"  From path:\");\n-  ss.print(\"    [center]\");\n-  steps.at(path_len)->dump(\"\\n\", false, &ss);\n-  for (int i = 0; i < path_len; ++i) {\n-    if (path.at(path_len - i - 1) >= 0) {\n-      \/\/ It's an input\n-      int input_nb = path.at(path_len - i - 1);\n-      if (input_nb <= 9) {\n-        ss.print(\" \");\n-      }\n-      ss.print(\"     <-(%d)-\", input_nb);\n-\n-    } else if (path.at(path_len - i - 1) == LocalGraphInvariant::OutputStep) {\n-      \/\/ It's an output\n-      ss.print(\"         -->\");\n-    } else {\n-      ss.print(\"         ???\");\n-    }\n-    steps.at(path_len - i - 1)->dump(\"\\n\", false, &ss);\n-  }\n+  assert(_live_nodes.size() > 0, \"filling failed\");\n+  return !_live_nodes.member(n);\n@@ -89,0 +58,5 @@\n+\/* A base class for checks expressed as data. Patterns are supposed to be local, centered around one node\n+ * and compositional to express complex structures from simple properties.\n+ * For instance, we have a pattern for saying \"the first input of the center match P\" where P is another\n+ * Pattern. We end up with trees of patterns matching the graph.\n+ *\/\n@@ -93,1 +67,5 @@\n-struct True : Pattern {\n+\/* This pattern just accepts any node. This is convenient mostly as leaves in a pattern tree.\n+ * For instance `AtSingleOutputOfType(..., new TruePattern())` will make sure there is\n+ * indeed a single output of the given type, but won't enforce anything on the said output.\n+ *\/\n+struct TruePattern : Pattern {\n@@ -99,0 +77,16 @@\n+\/* This is semantically equivalent to `TruePattern` but will set the given reference to the node\n+ * the pattern is matched against. This is useful to perform additional checks that would\n+ * otherwise be hard or impossible to express as local patterns.\n+ *\n+ * For instance, one could write\n+ * Node* first, second;\n+ * And::make(\n+ *   new AtInput(0, new Bind(first)),\n+ *   new AtInput(1, new Bind(second))\n+ * );\n+ * [...] \/\/ run the pattern\n+ * if (first == second) { \/\/ checking whether they are the same node\n+ *\n+ * Bindings are only honored if the overall pattern succeeds. Otherwise, don't assume anything reasonable\n+ * has been set. Anyway, you don't need it: you already know it doesn't have the right shape.\n+ *\/\n@@ -105,0 +99,2 @@\n+\n+private:\n@@ -108,0 +104,33 @@\n+\/* A more type-safe version of `Bind` mostly to use with NodeClassIsAndBind macro defined later\n+ *\/\n+template <typename N, ENABLE_IF(std::is_base_of<Node, N>::value)>\n+struct TypedBind : Pattern {\n+  explicit TypedBind(const N*& binding) : _binding(binding) {}\n+  bool check(const Node* center, Node_List&, GrowableArray<int>&, stringStream&) const override {\n+    _binding = static_cast<const N*>(center);\n+    return true;\n+  }\n+\n+private:\n+  const N*& _binding;\n+};\n+\n+\/* Matches multiple patterns at the same node.\n+ *\n+ * Evaluation order is guaranteed to be left-to-right. In particular, check a node has enough\n+ * inputs before checking a property of a given input. This allows better reporting. E.g. if\n+ * you know a node has 3 inputs and want patterns to be applied to each input, it would look like\n+ * And::make(\n+ *    new HasExactlyNInputs(3),\n+ *    new AtInput(0, P0),\n+ *    new AtInput(1, P1),\n+ *    new AtInput(2, P2),\n+ * )\n+ * If we relied on `AtInput` to report too few inputs, it would give confusing error messages as\n+ * the first `AtInput` can only know it expects at least one input, and seeing the message\n+ * \"Found 0 inputs, expected at least 1\" is not very helpful, potentially confusing as it doesn't\n+ * state what is actually expected: 3 inputs.\n+ * It also is not able to express that a node has exactly a given number of inputs, and it is a\n+ * significant difference whether we expect AT LEAST 3 inputs, or EXACTLY 3 inputs. Let's make\n+ * things precise.\n+ *\/\n@@ -110,0 +139,1 @@\n+  GrowableArray<Pattern*> _checks;\n@@ -133,1 +163,0 @@\n-  GrowableArray<Pattern*> _checks;\n@@ -136,0 +165,12 @@\n+void make_pretty_list_of_inputs(const Node* center, stringStream& ss) {\n+  for (uint i = 0; i < center->req(); ++i) {\n+    Node* in = center->in(i);\n+    ss.print(\"  %d: \", i);\n+    if (in == nullptr) {\n+      ss.print_cr(\"nullptr\");\n+    } else {\n+      in->dump(\"\\n\", false, &ss);\n+    }\n+  }\n+}\n+\n@@ -141,9 +182,1 @@\n-      for (uint i = 0; i < center->req(); ++i) {\n-        Node* in = center->in(i);\n-        ss.print(\"  %d: \", i);\n-        if (in == nullptr) {\n-          ss.print_cr(\"nullptr\");\n-        } else {\n-          in->dump(\"\\n\", false, &ss);\n-        }\n-      }\n+      make_pretty_list_of_inputs(center, ss);\n@@ -162,9 +195,1 @@\n-      for (uint i = 0; i < center->req(); ++i) {\n-        Node* in = center->in(i);\n-        ss.print(\"  %d: \", i);\n-        if (in == nullptr) {\n-          ss.print_cr(\"nullptr\");\n-        } else {\n-          in->dump(\"\\n\", false, &ss);\n-        }\n-      }\n+      make_pretty_list_of_inputs(center, ss);\n@@ -178,0 +203,5 @@\n+\/* Check that a given pattern applies at the given input of the center.\n+ *\n+ * As explained above, it doesn't check (nicely) that inputs are in sufficient numbers.\n+ * Use HasExactlyNInputs or HasAtLeastNInputs for that.\n+ *\/\n@@ -197,0 +227,3 @@\n+\/* Check a node has the right type (as which C++ class, not as abstract value). Typically used with\n+ * is_XXXNode methods.\n+ *\/\n@@ -209,0 +242,12 @@\n+\n+\/* To check the kind of a node and bind it to a variable of the right type.\n+ * For instance:\n+ *   const RegionNode* r;\n+ *   NodeClassIsAndBind(Region, r)\n+ *\/\n+#define NodeClassIsAndBind(node_type, binding)  \\\n+  And::make(                                    \\\n+      new NodeClass(&Node::is_ ## node_type),   \\\n+      new TypedBind<node_type ## Node>(binding) \\\n+  )\n+\n@@ -226,0 +271,6 @@\n+\/* Given a is_XXXNode method pointer and a pattern P, this pattern checks that\n+ * - only one output has the given type XXX\n+ * - this one output matches P.\n+ *\n+ * Since outputs are not numbered, this is a convenient way to walk on the graph in the Def-Use direction.\n+ *\/\n@@ -256,0 +307,4 @@\n+\/* A LocalGraphInvariant that mostly use a Pattern for checking.\n+ *\n+ * Can still override `check` to do more.\n+ *\/\n@@ -264,0 +319,2 @@\n+\/* Checks that If Nodes have exactly 2 outputs: IfTrue and IfFalse\n+ *\/\n@@ -269,2 +326,2 @@\n-                new AtSingleOutputOfType(&Node::is_IfTrue, new True()),\n-                new AtSingleOutputOfType(&Node::is_IfFalse, new True()))) {\n+                new AtSingleOutputOfType(&Node::is_IfTrue, new TruePattern()),\n+                new AtSingleOutputOfType(&Node::is_IfFalse, new TruePattern()))) {\n@@ -291,0 +348,2 @@\n+\/* Check that Phi has a Region as first input, and consistent arity\n+ *\/\n@@ -292,1 +351,1 @@\n-  const Node* region_node = nullptr;\n+  const RegionNode* region_node = nullptr;\n@@ -299,3 +358,1 @@\n-                    And::make(\n-                        new NodeClass(&Node::is_Region),\n-                        new Bind(region_node))))) {\n+                    NodeClassIsAndBind(Region, region_node)))) {\n@@ -323,0 +380,2 @@\n+\/* Make sure each control node has the right amount of control successors: that is 1 for most cases, 2 for If nodes...\n+ *\/\n@@ -333,1 +392,0 @@\n-    uint cfg_out = 0;\n@@ -337,1 +395,0 @@\n-        cfg_out++;\n@@ -342,0 +399,2 @@\n+    uint cfg_out = ctrl_succ.size();\n+\n@@ -394,1 +453,3 @@\n-struct RegionSelfLoop : LocalGraphInvariant {\n+\/* Checks that Region Start and Root nodes' first input is a self loop, except for copy regions, which then must have only one non null input.\n+ *\/\n+struct SelfLoopInvariant : LocalGraphInvariant {\n@@ -410,1 +471,1 @@\n-    if (center != self || (center->is_Region() && self == nullptr)) {\n+    if (self != center || (center->is_Region() && self == nullptr)) {\n@@ -417,1 +478,1 @@\n-      Node_List non_null_inputs;\n+      uint non_null_inputs_count = 0;\n@@ -420,1 +481,1 @@\n-          non_null_inputs.push(center->in(i));\n+          non_null_inputs_count++;\n@@ -423,4 +484,14 @@\n-      if (non_null_inputs.size() != 1) {\n-        ss.print_cr(\"%s copy nodes must have exactly one non-null input. Found: %d.\", center->Name(), non_null_inputs.size());\n-        for (uint i = 0; i < non_null_inputs.size(); ++i) {\n-          non_null_inputs.at(i)->dump(\"\\n\", false, &ss);\n+      if (non_null_inputs_count != 1) {\n+        \/\/ Should be a rare case, hence the second (but more expensive) traversal.\n+        Node_List non_null_inputs;\n+        for (uint i = 0; i < center->req(); i++) {\n+          if (center->in(i) != nullptr) {\n+            non_null_inputs.push(center->in(i));\n+          }\n+        }\n+        if (non_null_inputs.size() != 1) {\n+          ss.print_cr(\"%s copy nodes must have exactly one non-null input. Found: %d.\", center->Name(), non_null_inputs.size());\n+          for (uint i = 0; i < non_null_inputs.size(); ++i) {\n+            non_null_inputs.at(i)->dump(\"\\n\", false, &ss);\n+          }\n+          return CheckResult::FAILED;\n@@ -428,1 +499,0 @@\n-        return CheckResult::FAILED;\n@@ -438,1 +508,1 @@\n-  const Node* counted_loop = nullptr;\n+  const BaseCountedLoopEndNode* counted_loop_end = nullptr;\n@@ -447,1 +517,1 @@\n-                        new HasAtLeastNInputs(1),\n+                        new HasExactlyNInputs(1),\n@@ -450,3 +520,1 @@\n-                            And::make(\n-                                new NodeClass(&Node::is_BaseCountedLoopEnd),\n-                                new Bind(counted_loop))))))) {}\n+                            NodeClassIsAndBind(BaseCountedLoopEnd, counted_loop_end)))))) {}\n@@ -461,2 +529,0 @@\n-    bool is_long = center->is_LongCountedLoop();\n-\n@@ -467,3 +533,4 @@\n-    assert(counted_loop != nullptr, \"sanity\");\n-    if (is_long) {\n-      if (counted_loop->is_CountedLoopEnd()) {\n+    assert(counted_loop_end != nullptr, \"sanity\");\n+    if (center->is_LongCountedLoop()) {\n+      if (!counted_loop_end->is_LongCountedLoopEnd()) {\n+        assert(counted_loop_end->is_CountedLoopEnd(), \"Update the error message or add cases\");\n@@ -474,1 +541,2 @@\n-      if (counted_loop->is_LongCountedLoopEnd()) {\n+      if (!counted_loop_end->is_CountedLoopEnd()) {\n+        assert(counted_loop_end->is_LongCountedLoopEnd(), \"Update the error message or add cases\");\n@@ -508,1 +576,1 @@\n-                            new True()))))) {}\n+                            new TruePattern()))))) {}\n@@ -540,1 +608,0 @@\n-\n@@ -547,1 +614,1 @@\n-  ADD_CHECKER(RegionSelfLoop);\n+  ADD_CHECKER(SelfLoopInvariant);\n@@ -555,2 +622,31 @@\n-bool GraphInvariantChecker::run() const {\n-  ResourceMark rm;\n+void GraphInvariantChecker::print_path(const Node_List& steps, const GrowableArray<int>& path, stringStream& ss) {\n+  const int path_len = path.length();\n+  precond(steps.size() == static_cast<uint>(path_len) + 1);\n+  if (path.is_empty()) {\n+    ss.print_cr(\"At center node\");\n+    steps.at(0)->dump(\"\\n\", false, &ss);\n+    return;\n+  }\n+  ss.print(\"At node\\n   \");\n+  steps.at(0)->dump(\"\\n\", false, &ss);\n+  ss.print_cr(\"  From path:\");\n+  ss.print(\"    [center]\");\n+  steps.at(path_len)->dump(\"\\n\", false, &ss);\n+  for (int i = 0; i < path_len; ++i) {\n+    if (path.at(path_len - i - 1) >= 0) {\n+      \/\/ It's an input\n+      int input_nb = path.at(path_len - i - 1);\n+      if (input_nb <= 9) {\n+        ss.print(\" \");\n+      }\n+      ss.print(\"     <-(%d)-\", input_nb);\n+\n+    } else if (path.at(path_len - i - 1) == LocalGraphInvariant::OutputStep) {\n+      \/\/ It's an output\n+      ss.print(\"         -->\");\n+    } else {\n+      ss.print(\"         ???\");\n+    }\n+    steps.at(path_len - i - 1)->dump(\"\\n\", false, &ss);\n+  }\n+}\n@@ -558,0 +654,1 @@\n+bool GraphInvariantChecker::run() const {\n@@ -562,2 +659,2 @@\n-  VectorSet enqueued;\n-  Node_List worklist;\n+  ResourceMark rm;\n+  Unique_Node_List worklist;\n@@ -569,2 +666,2 @@\n-  \/\/ Sometimes, we get weird structure in dead code that will be cleaned up later. It typically happens\n-  \/\/ when data dies, but control is not cleanup right away, possibly kept alive by un unreachable loop.\n+  \/\/ Sometimes, we get weird structures in dead code that will be cleaned up later. It typically happens\n+  \/\/ when data dies, but control is not cleaned up right away, possibly kept alive by an unreachable loop.\n@@ -572,1 +669,1 @@\n-  \/\/ weird structure in dead code.\n+  \/\/ weird structures in dead code.\n@@ -574,1 +671,1 @@\n-  \/\/ the issue if the problematic node is reachable. This set of reachable node is thus computed lazily\n+  \/\/ the issue if the problematic node is reachable. This set of reachable nodes is thus computed lazily\n@@ -579,5 +676,5 @@\n-  while (worklist.size() > 0) {\n-    Node* center = worklist.pop();\n-    for (uint i = 0; i < center->req(); i++) {\n-      Node* in = center->in(i);\n-      if (in != nullptr && !enqueued.test_set(in->_idx)) {\n+  for (uint i = 0; i < worklist.size(); ++i) {\n+    Node* center = worklist.at(i);\n+    for (uint j = 0; j < center->req(); ++j) {\n+      Node* in = center->in(j);\n+      if (in != nullptr) {\n@@ -588,2 +685,2 @@\n-    for (int i = 0; i < _checks.length(); ++i) {\n-      switch (_checks.at(i)->check(center, reachable_cfg_nodes, steps, path, ss2)) {\n+    for (int j = 0; j < _checks.length(); ++j) {\n+      switch (_checks.at(j)->check(center, reachable_cfg_nodes, steps, path, ss2)) {\n@@ -594,1 +691,1 @@\n-        ss.print_cr(\"# %s:\", _checks.at(i)->name());\n+        ss.print_cr(\"# %s:\", _checks.at(j)->name());\n@@ -607,4 +704,5 @@\n-      ttyLocker ttyl;\n-      tty->print(\"%d failure%s for node\\n\", failures, failures == 1 ? \"\" : \"s\");\n-      center->dump();\n-      tty->print_cr(\"%s\", ss.base());\n+      stringStream ss3;\n+      ss3.print(\"%d failure%s for node\\n\", failures, failures == 1 ? \"\" : \"s\");\n+      center->dump(\"\\n\", false, &ss3);\n+      ss3.print_cr(\"%s\", ss.base());\n+      tty->print(\"%s\", ss3.base());\n","filename":"src\/hotspot\/share\/opto\/graphInvariants.cpp","additions":210,"deletions":112,"binary":false,"changes":322,"status":"modified"},{"patch":"@@ -35,0 +35,5 @@\n+  \/* When an invariant applied at a given node (the center) goes wrong at another\n+   * node, it is useful to show the path we took between them. OutputStep is used\n+   * to signify that a node is the output of the previous one in the path.\n+   * See LocalGraphInvariant::check for more details on paths.\n+   *\/\n@@ -37,0 +42,1 @@\n+  \/\/ See LocalGraphInvariant::check why we need that.\n@@ -41,1 +47,1 @@\n-    Unique_Node_List live_nodes;\n+    Unique_Node_List _live_nodes;\n@@ -56,1 +62,1 @@\n-   * Given a list of node\n+   * Given a list of nodes\n@@ -64,1 +70,1 @@\n-   * The list are reversed to allow to easily fill them lazily on failure.\n+   * The lists are reversed to allow to easily fill them lazily on failure.\n@@ -70,1 +76,3 @@\n-   * checks don't apply to dead code, suppress their error if a violation is detected in dead code.\n+   * checks don't apply to dead code, and we want to suppress their error if a violation is detected in dead code. Since it's\n+   * rather unlikely to have such a violation (they are rare overall), and then we won't need to check whether a node is dead,\n+   * it's better to have this set lazy.\n@@ -91,0 +99,4 @@\n+\n+  \/\/ See LocalGraphInvariant::check for the requirements on the arguments.\n+  \/\/ Fills parameter [ss] with pretty print of the path.\n+  static void print_path(const Node_List& steps, const GrowableArray<int>& path, stringStream& ss);\n","filename":"src\/hotspot\/share\/opto\/graphInvariants.hpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -808,1 +808,0 @@\n-  NOT_PRODUCT(_invariant_checker = GraphInvariantChecker::make_default());\n@@ -845,2 +844,0 @@\n-\n-  NOT_PRODUCT(_invariant_checker = GraphInvariantChecker::make_default());\n@@ -995,1 +992,1 @@\n-    assert(_invariant_checker->run(), \"Ideal graph doesn't verify structural invariants.\");\n+    assert(C->_invariant_checker->run(), \"Ideal graph doesn't verify structural invariants.\");\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-class GraphInvariantChecker;\n@@ -615,1 +614,0 @@\n-  GraphInvariantChecker* _invariant_checker;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350864\n+ * @requires vm.debug == true & vm.flavor == \"server\"\n+ * @summary Empty main program to run with flag VerifyIdealGraph.\n+ *\n+ * @run main\/othervm -Xbatch -Xcomp -XX:+VerifyIdealGraph compiler.c2.TestVerifyIdealGraph\n+ *\/\n+package compiler.c2;\n+\n+public class TestVerifyIdealGraph {\n+    public static void main(String[] args) {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestVerifyIdealGraph.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"}]}