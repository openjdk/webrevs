{"files":[{"patch":"@@ -706,0 +706,3 @@\n+  develop(bool, VerifyIdealGraph, false,                                    \\\n+          \"Check structural invariants of the ideal graph\")                 \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#include \"opto\/graphInvariants.hpp\"\n@@ -700,1 +701,2 @@\n-      _in_dump_cnt(0)\n+      _in_dump_cnt(0),\n+      _invariant_checker(GraphInvariantChecker::make_default())\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+class GraphInvariantChecker;\n@@ -1317,0 +1318,2 @@\n+\n+  NOT_PRODUCT(GraphInvariantChecker* _invariant_checker;)\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,715 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"metaprogramming\/enableIf.hpp\"\n+#include \"opto\/graphInvariants.hpp\"\n+#include \"opto\/rootnode.hpp\"\n+\n+#ifndef PRODUCT\n+constexpr int LocalGraphInvariant::OutputStep;\n+\n+void LocalGraphInvariant::LazyReachableCFGNodes::fill() {\n+  precond(_live_nodes.size() == 0);\n+\n+  \/\/ We should have at least root, so we are sure it's not filled yet.\n+  _live_nodes.push(Compile::current()->root());\n+  for (uint i = 0; i < _live_nodes.size(); ++i) {\n+    Node* n = _live_nodes.at(i);\n+    for (DUIterator_Fast jmax, j = n->fast_outs(jmax); j < jmax; j++) {\n+      Node* out = n->fast_out(j);\n+      if (out->is_CFG()) {\n+        _live_nodes.push(out);\n+      }\n+    }\n+  }\n+\n+  postcond(_live_nodes.size() > 0);\n+}\n+\n+bool LocalGraphInvariant::LazyReachableCFGNodes::is_node_dead(const Node* n) {\n+  if (_live_nodes.size() == 0) {\n+    fill();\n+  }\n+  assert(_live_nodes.size() > 0, \"filling failed\");\n+  return !_live_nodes.member(n);\n+}\n+\n+\/* A base class for checks expressed as data. Patterns are supposed to be local, centered around one node\n+ * and compositional to express complex structures from simple properties.\n+ * For instance, we have a pattern for saying \"the first input of the center match P\" where P is another\n+ * Pattern. We end up with trees of patterns matching the graph.\n+ *\/\n+struct Pattern : ResourceObj {\n+  virtual bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream&) const = 0;\n+};\n+\n+\/* This pattern just accepts any node. This is convenient mostly as leaves in a pattern tree.\n+ * For instance `AtSingleOutputOfType(..., new TruePattern())` will make sure there is\n+ * indeed a single output of the given type, but won't enforce anything on the said output.\n+ *\/\n+struct TruePattern : Pattern {\n+  bool check(const Node*, Node_List&, GrowableArray<int>&, stringStream&) const override {\n+    return true;\n+  }\n+};\n+\n+\/* This is semantically equivalent to `TruePattern` but will set the given reference to the node\n+ * the pattern is matched against. This is useful to perform additional checks that would\n+ * otherwise be hard or impossible to express as local patterns.\n+ *\n+ * For instance, one could write\n+ * Node* first, second;\n+ * And::make(\n+ *   new AtInput(0, new Bind(first)),\n+ *   new AtInput(1, new Bind(second))\n+ * );\n+ * [...] \/\/ run the pattern\n+ * if (first == second) { \/\/ checking whether they are the same node\n+ *\n+ * Bindings are only honored if the overall pattern succeeds. Otherwise, don't assume anything reasonable\n+ * has been set. Anyway, you don't need it: you already know it doesn't have the right shape.\n+ *\/\n+struct Bind : Pattern {\n+  explicit Bind(const Node*& binding) : _binding(binding) {}\n+  bool check(const Node* center, Node_List&, GrowableArray<int>&, stringStream&) const override {\n+    _binding = center;\n+    return true;\n+  }\n+\n+private:\n+  const Node*& _binding;\n+};\n+\n+\/* A more type-safe version of `Bind` mostly to use with NodeClassIsAndBind macro defined later\n+ *\/\n+template <typename N, ENABLE_IF(std::is_base_of<Node, N>::value)>\n+struct TypedBind : Pattern {\n+  explicit TypedBind(const N*& binding) : _binding(binding) {}\n+  bool check(const Node* center, Node_List&, GrowableArray<int>&, stringStream&) const override {\n+    _binding = static_cast<const N*>(center);\n+    return true;\n+  }\n+\n+private:\n+  const N*& _binding;\n+};\n+\n+\/* Matches multiple patterns at the same node.\n+ *\n+ * Evaluation order is guaranteed to be left-to-right. In particular, check a node has enough\n+ * inputs before checking a property of a given input. This allows better reporting. E.g. if\n+ * you know a node has 3 inputs and want patterns to be applied to each input, it would look like\n+ * And::make(\n+ *    new HasExactlyNInputs(3),\n+ *    new AtInput(0, P0),\n+ *    new AtInput(1, P1),\n+ *    new AtInput(2, P2),\n+ * )\n+ * If we relied on `AtInput` to report too few inputs, it would give confusing error messages as\n+ * the first `AtInput` can only know it expects at least one input, and seeing the message\n+ * \"Found 0 inputs, expected at least 1\" is not very helpful, potentially confusing as it doesn't\n+ * state what is actually expected: 3 inputs.\n+ * It also is not able to express that a node has exactly a given number of inputs, and it is a\n+ * significant difference whether we expect AT LEAST 3 inputs, or EXACTLY 3 inputs. Let's make\n+ * things precise.\n+ *\/\n+struct And : Pattern {\n+private:\n+  GrowableArray<Pattern*> _checks;\n+  template <typename... PP>\n+  static void make_helper(And* a, Pattern* pattern, PP... others) {\n+    a->_checks.push(pattern);\n+    make_helper(a, others...);\n+  }\n+  static void make_helper(And*) {}\n+\n+public:\n+  template <typename... PP>\n+  static And* make(PP... patterns) {\n+    And* andd = new And();\n+    make_helper(andd, patterns...);\n+    return andd;\n+  }\n+\n+  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    for (int i = 0; i < _checks.length(); ++i) {\n+      if (!_checks.at(i)->check(center, steps, path, ss)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+};\n+\n+void make_pretty_list_of_inputs(const Node* center, stringStream& ss) {\n+  for (uint i = 0; i < center->req(); ++i) {\n+    Node* in = center->in(i);\n+    ss.print(\"  %d: \", i);\n+    if (in == nullptr) {\n+      ss.print_cr(\"nullptr\");\n+    } else {\n+      in->dump(\"\\n\", false, &ss);\n+    }\n+  }\n+}\n+\n+struct HasExactlyNInputs : Pattern {\n+  explicit HasExactlyNInputs(uint expect_req) : _expect_req(expect_req) {}\n+  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (center->req() != _expect_req) {\n+      ss.print_cr(\"Unexpected number of input. Expected: %d. Found: %d\", _expect_req, center->req());\n+      make_pretty_list_of_inputs(center, ss);\n+      return false;\n+    }\n+    return true;\n+  }\n+  const uint _expect_req;\n+};\n+\n+struct HasAtLeastNInputs : Pattern {\n+  explicit HasAtLeastNInputs(uint expect_req) : _expect_req(expect_req) {}\n+  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (center->req() < _expect_req) {\n+      ss.print_cr(\"Too small number of input. Expected: %d. Found: %d\", _expect_req, center->req());\n+      make_pretty_list_of_inputs(center, ss);\n+      return false;\n+    }\n+    return true;\n+  }\n+  const uint _expect_req;\n+};\n+\n+\/* Check that a given pattern applies at the given input of the center.\n+ *\n+ * As explained above, it doesn't check (nicely) that inputs are in sufficient numbers.\n+ * Use HasExactlyNInputs or HasAtLeastNInputs for that.\n+ *\/\n+struct AtInput : Pattern {\n+  AtInput(uint which_input, const Pattern* pattern) : _which_input(which_input), _pattern(pattern) {}\n+  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    assert(_which_input < center->req(), \"Input number is out of range\");\n+    if (center->in(_which_input) == nullptr) {\n+      ss.print_cr(\"Input at index %d is nullptr.\", _which_input);\n+      return false;\n+    }\n+    bool result = _pattern->check(center->in(_which_input), steps, path, ss);\n+    if (!result) {\n+      steps.push(center->in(_which_input));\n+      path.push(static_cast<int>(_which_input));\n+    }\n+    return result;\n+  }\n+  const uint _which_input;\n+  const Pattern* const _pattern;\n+};\n+\n+\/* Check a node has the right type (as which C++ class, not as abstract value). Typically used with\n+ * is_XXXNode methods.\n+ *\/\n+struct NodeClass : Pattern {\n+  explicit NodeClass(bool (Node::*type_check)() const) : _type_check(type_check) {}\n+  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (!(center->*_type_check)()) {\n+      ss.print_cr(\"Unexpected type: %s.\", center->Name());\n+      return false;\n+    }\n+    return true;\n+  }\n+  bool (Node::*_type_check)() const;\n+};\n+\n+\n+\/* To check the kind of a node and bind it to a variable of the right type.\n+ * For instance:\n+ *   const RegionNode* r;\n+ *   NodeClassIsAndBind(Region, r)\n+ *\/\n+#define NodeClassIsAndBind(node_type, binding)  \\\n+  And::make(                                    \\\n+      new NodeClass(&Node::is_ ## node_type),   \\\n+      new TypedBind<node_type ## Node>(binding) \\\n+  )\n+\n+struct HasNOutputs : Pattern {\n+  explicit HasNOutputs(uint expect_outcnt) : _expect_outcnt(expect_outcnt) {}\n+  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (center->outcnt() != _expect_outcnt) {\n+      ss.print_cr(\"Unexpected number of outputs. Expected: %d, found: %d.\", _expect_outcnt, center->outcnt());\n+      for (DUIterator_Fast imax, i = center->fast_outs(imax); i < imax; i++) {\n+        Node* out = center->fast_out(i);\n+        ss.print(\"  \");\n+        out->dump(\"\\n\", false, &ss);\n+      }\n+      return false;\n+    }\n+    return true;\n+  }\n+  const uint _expect_outcnt;\n+};\n+\n+\/* Given a is_XXXNode method pointer and a pattern P, this pattern checks that\n+ * - only one output has the given type XXX\n+ * - this one output matches P.\n+ *\n+ * Since outputs are not numbered, this is a convenient way to walk on the graph in the Def-Use direction.\n+ *\/\n+struct AtSingleOutputOfType : Pattern {\n+  AtSingleOutputOfType(bool (Node::*type_check)() const, const Pattern* pattern) : _type_check(type_check), _pattern(pattern) {\n+  }\n+\n+  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    Node_List outputs_of_correct_type;\n+    for (DUIterator_Fast imax, i = center->fast_outs(imax); i < imax; i++) {\n+      Node* out = center->fast_out(i);\n+      if ((out->*_type_check)()) {\n+        outputs_of_correct_type.push(out);\n+      }\n+    }\n+    if (outputs_of_correct_type.size() != 1) {\n+      ss.print_cr(\"Non-unique output of expected type. Found: %d.\", outputs_of_correct_type.size());\n+      for (uint i = 0; i < outputs_of_correct_type.size(); ++i) {\n+        outputs_of_correct_type.at(i)->dump(\"\\n\", false, &ss);\n+      }\n+      return false;\n+    }\n+    bool result = _pattern->check(outputs_of_correct_type.at(0), steps, path, ss);\n+    if (!result) {\n+      steps.push(outputs_of_correct_type.at(0));\n+      path.push(LocalGraphInvariant::OutputStep);\n+    }\n+    return result;\n+  }\n+  bool (Node::*_type_check)() const;\n+  const Pattern* const _pattern;\n+};\n+\n+\/* A LocalGraphInvariant that mostly use a Pattern for checking.\n+ *\n+ * Can still override `check` to do more.\n+ *\/\n+struct PatternBasedCheck : LocalGraphInvariant {\n+  const Pattern* const _pattern;\n+  explicit PatternBasedCheck(const Pattern* pattern) : _pattern(pattern) {}\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    return _pattern->check(center, steps, path, ss) ? CheckResult::VALID : CheckResult::FAILED;\n+  }\n+};\n+\n+\/* Checks that If Nodes have exactly 2 outputs: IfTrue and IfFalse\n+ *\/\n+struct IfProjections : PatternBasedCheck {\n+  IfProjections()\n+      : PatternBasedCheck(\n+            And::make(\n+                new HasNOutputs(2),\n+                new AtSingleOutputOfType(&Node::is_IfTrue, new TruePattern()),\n+                new AtSingleOutputOfType(&Node::is_IfFalse, new TruePattern()))) {\n+  }\n+  const char* name() const override {\n+    return \"IfProjections\";\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (!center->is_If()) {\n+      return CheckResult::NOT_APPLICABLE;\n+    }\n+    CheckResult r = PatternBasedCheck::check(center, reachable_cfg_nodes, steps, path, ss);\n+    if (r == CheckResult::FAILED) {\n+      if (reachable_cfg_nodes.is_node_dead(center)) {\n+        \/\/ That's ok for dead nodes right now. It might be too expensive to collect for IGVN, but it will be removed in loop opts.\n+        ss.reset();\n+        return CheckResult::VALID;\n+      }\n+    }\n+    return r;\n+  }\n+};\n+\n+\/* Check that Phi has a Region as first input, and consistent arity\n+ *\/\n+struct PhiArity : PatternBasedCheck {\n+  const RegionNode* region_node = nullptr;\n+  PhiArity()\n+      : PatternBasedCheck(\n+            And::make(\n+                new HasAtLeastNInputs(1),\n+                new AtInput(\n+                    0,\n+                    NodeClassIsAndBind(Region, region_node)))) {\n+  }\n+  const char* name() const override {\n+    return \"PhiArity\";\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (!center->is_Phi()) {\n+      return CheckResult::NOT_APPLICABLE;\n+    }\n+    CheckResult result = PatternBasedCheck::check(center, reachable_cfg_nodes, steps, path, ss);\n+    if (result != CheckResult::VALID) {\n+      return result;\n+    }\n+    assert(region_node != nullptr, \"sanity\");\n+    if (region_node->req() != center->req()) {\n+      ss.print_cr(\"Phi nodes must have the same arity as their Region node. Phi arity: %d; Region arity: %d.\", center->req(), region_node->req());\n+      return CheckResult::FAILED;\n+    }\n+    return CheckResult::VALID;\n+  }\n+};\n+\n+\/* Make sure each control node has the right amount of control successors: that is 1 for most cases, 2 for If nodes...\n+ *\/\n+struct ControlSuccessor : LocalGraphInvariant {\n+  const char* name() const override {\n+    return \"ControlSuccessor\";\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (!center->is_CFG()) {\n+      return CheckResult::NOT_APPLICABLE;\n+    }\n+\n+    Node_List ctrl_succ;\n+    for (DUIterator_Fast imax, i = center->fast_outs(imax); i < imax; i++) {\n+      Node* out = center->fast_out(i);\n+      if (out->is_CFG()) {\n+        ctrl_succ.push(out);\n+      }\n+    }\n+\n+    uint cfg_out = ctrl_succ.size();\n+\n+    if (center->is_If() || center->is_Start() || center->is_Root() || center->is_Region() || center->is_NeverBranch()) {\n+      if (cfg_out != 2) {\n+        if (reachable_cfg_nodes.is_node_dead(center)) {\n+          \/\/ That's ok for dead nodes right now. It might be too expensive to collect for IGVN, but it will be removed in loop opts.\n+          return CheckResult::VALID;\n+        }\n+        ss.print_cr(\"%s node must have exactly two control successors. Found %d.\", center->Name(), cfg_out);\n+        for (uint i = 0; i < ctrl_succ.size(); ++i) {\n+          ss.print(\"  \");\n+          ctrl_succ.at(i)->dump(\"\\n\", false, &ss);\n+        }\n+        return CheckResult::FAILED;\n+      }\n+    } else if (center->Opcode() == Op_SafePoint) {\n+      if (cfg_out < 1 || cfg_out > 2) {\n+        ss.print_cr(\"%s node must have one or two control successors. Found %d.\", center->Name(), cfg_out);\n+        for (uint i = 0; i < ctrl_succ.size(); ++i) {\n+          ss.print(\"  \");\n+          ctrl_succ.at(i)->dump(\"\\n\", false, &ss);\n+        }\n+        return CheckResult::FAILED;\n+      }\n+      if (cfg_out == 2) {\n+        if (!ctrl_succ.at(0)->is_Root() && !ctrl_succ.at(1)->is_Root()) {\n+          ss.print_cr(\"One of the two control outputs of a %s node must be Root.\", center->Name());\n+          for (uint i = 0; i < ctrl_succ.size(); ++i) {\n+            ss.print(\"  \");\n+            ctrl_succ.at(i)->dump(\"\\n\", false, &ss);\n+          }\n+          return CheckResult::FAILED;\n+        }\n+      }\n+    } else if (center->is_Catch() || center->is_Jump()) {\n+      if (cfg_out < 1) {\n+        ss.print_cr(\"%s node must have at least one control successors. Found %d.\", center->Name(), cfg_out);\n+        return CheckResult::FAILED;\n+      }\n+    } else {\n+      if (cfg_out != 1) {\n+        ss.print_cr(\"Ordinary CFG nodes must have exactly one successor. Found %d.\", cfg_out);\n+        for (uint i = 0; i < ctrl_succ.size(); ++i) {\n+          ss.print(\"  \");\n+          ctrl_succ.at(i)->dump(\"\\n\", false, &ss);\n+        }\n+        return CheckResult::FAILED;\n+      }\n+    }\n+\n+    return CheckResult::VALID;\n+  }\n+};\n+\n+\/* Checks that Region Start and Root nodes' first input is a self loop, except for copy regions, which then must have only one non null input.\n+ *\/\n+struct SelfLoopInvariant : LocalGraphInvariant {\n+  const char* name() const override {\n+    return \"RegionSelfLoop\";\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (!center->is_Region() && !center->is_Start() && !center->is_Root()) {\n+      return CheckResult::NOT_APPLICABLE;\n+    }\n+\n+    if (center->req() == 0) {\n+      ss.print_cr(\"%s nodes must have at least one input.\", center->Name());\n+      return CheckResult::FAILED;\n+    }\n+\n+    Node* self = center->in(LoopNode::Self);\n+\n+    if (self != center || (center->is_Region() && self == nullptr)) {\n+      ss.print_cr(\"%s nodes' 0-th input must be itself or nullptr (for a copy Region).\", center->Name());\n+      return CheckResult::FAILED;\n+    }\n+\n+    if (self == nullptr) {\n+      \/\/ Must be a copy Region\n+      uint non_null_inputs_count = 0;\n+      for (uint i = 0; i < center->req(); i++) {\n+        if (center->in(i) != nullptr) {\n+          non_null_inputs_count++;\n+        }\n+      }\n+      if (non_null_inputs_count != 1) {\n+        \/\/ Should be a rare case, hence the second (but more expensive) traversal.\n+        Node_List non_null_inputs;\n+        for (uint i = 0; i < center->req(); i++) {\n+          if (center->in(i) != nullptr) {\n+            non_null_inputs.push(center->in(i));\n+          }\n+        }\n+        if (non_null_inputs.size() != 1) {\n+          ss.print_cr(\"%s copy nodes must have exactly one non-null input. Found: %d.\", center->Name(), non_null_inputs.size());\n+          for (uint i = 0; i < non_null_inputs.size(); ++i) {\n+            non_null_inputs.at(i)->dump(\"\\n\", false, &ss);\n+          }\n+          return CheckResult::FAILED;\n+        }\n+      }\n+    }\n+\n+    return CheckResult::VALID;\n+  }\n+};\n+\n+\/\/ CountedLoopEnd -> IfTrue -> CountedLoop\n+struct CountedLoopInvariants : PatternBasedCheck {\n+  const BaseCountedLoopEndNode* counted_loop_end = nullptr;\n+  CountedLoopInvariants()\n+      : PatternBasedCheck(\n+            And::make(\n+                new HasExactlyNInputs(3),\n+                new AtInput(\n+                    LoopNode::LoopBackControl,\n+                    And::make(\n+                        new NodeClass(&Node::is_IfTrue),\n+                        new HasExactlyNInputs(1),\n+                        new AtInput(\n+                            0,\n+                            NodeClassIsAndBind(BaseCountedLoopEnd, counted_loop_end)))))) {}\n+  const char* name() const override {\n+    return \"CountedLoopInvariants\";\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (!center->is_CountedLoop() && !center->is_LongCountedLoop()) {\n+      return CheckResult::NOT_APPLICABLE;\n+    }\n+\n+    CheckResult result = PatternBasedCheck::check(center, reachable_cfg_nodes, steps, path, ss);\n+    if (result != CheckResult::VALID) {\n+      return result;\n+    }\n+    assert(counted_loop_end != nullptr, \"sanity\");\n+    if (center->is_LongCountedLoop()) {\n+      if (!counted_loop_end->is_LongCountedLoopEnd()) {\n+        assert(counted_loop_end->is_CountedLoopEnd(), \"Update the error message or add cases\");\n+        ss.print_cr(\"A CountedLoopEnd is the backedge of a LongCountedLoop.\");\n+        return CheckResult::FAILED;\n+      }\n+    } else {\n+      if (!counted_loop_end->is_CountedLoopEnd()) {\n+        assert(counted_loop_end->is_LongCountedLoopEnd(), \"Update the error message or add cases\");\n+        ss.print_cr(\"A LongCountedLoopEnd is the backedge of a CountedLoop.\");\n+        return CheckResult::FAILED;\n+      }\n+    }\n+    return CheckResult::VALID;\n+  }\n+};\n+\n+\/\/ CountedLoopEnd -> IfFalse -> SafePoint -> OuterStripMinedLoopEnd[center] -> IfTrue -> OuterStripMinedLoop -> CountedLoop\n+struct OuterStripMinedLoopInvariants : PatternBasedCheck {\n+  OuterStripMinedLoopInvariants()\n+      : PatternBasedCheck(\n+            And::make(\n+                new HasExactlyNInputs(2),\n+                new AtInput(\n+                    0,\n+                    And::make(\n+                        new NodeClass(&Node::is_SafePoint),\n+                        new HasAtLeastNInputs(1),\n+                        new AtInput(\n+                            0,\n+                            And::make(\n+                                new NodeClass(&Node::is_IfFalse),\n+                                new HasAtLeastNInputs(1),\n+                                new AtInput(\n+                                    0,\n+                                    new NodeClass(&Node::is_CountedLoopEnd)))))),\n+                new AtSingleOutputOfType(\n+                    &Node::is_IfTrue,\n+                    new AtSingleOutputOfType(\n+                        &Node::is_OuterStripMinedLoop,\n+                        new AtSingleOutputOfType(\n+                            &Node::is_CountedLoop,\n+                            new TruePattern()))))) {}\n+  const char* name() const override {\n+    return \"OuterStripMinedLoopInvariants\";\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (!center->is_OuterStripMinedLoopEnd()) {\n+      return CheckResult::NOT_APPLICABLE;\n+    }\n+\n+    return PatternBasedCheck::check(center, reachable_cfg_nodes, steps, path, ss);\n+  }\n+};\n+\n+struct MultiBranchNodeOut : LocalGraphInvariant {\n+  const char* name() const override {\n+    return \"MultiBranchNodeOut\";\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (!center->is_MultiBranch()) {\n+      return CheckResult::NOT_APPLICABLE;\n+    }\n+\n+    MultiBranchNode* mb = center->as_MultiBranch();\n+    if (mb->required_outcnt() < static_cast<int>(mb->outcnt())) {\n+      ss.print_cr(\"The required_outcnt of a MultiBranch node must be smaller than or equal to its outcnt. But required_outcnt=%d vs. outcnt=%d\", mb->required_outcnt(), mb->outcnt());\n+      return CheckResult::FAILED;\n+    }\n+\n+    return CheckResult::VALID;\n+  }\n+};\n+\n+GraphInvariantChecker* GraphInvariantChecker::make_default() {\n+  auto* checker = new GraphInvariantChecker();\n+#define ADD_CHECKER(T) checker->_checks.push(new T())\n+  ADD_CHECKER(IfProjections);\n+  ADD_CHECKER(PhiArity);\n+  ADD_CHECKER(ControlSuccessor);\n+  ADD_CHECKER(SelfLoopInvariant);\n+  ADD_CHECKER(CountedLoopInvariants);\n+  ADD_CHECKER(OuterStripMinedLoopInvariants);\n+  ADD_CHECKER(MultiBranchNodeOut);\n+#undef ADD_CHECKER\n+  return checker;\n+}\n+\n+void GraphInvariantChecker::print_path(const Node_List& steps, const GrowableArray<int>& path, stringStream& ss) {\n+  const int path_len = path.length();\n+  precond(steps.size() == static_cast<uint>(path_len) + 1);\n+  if (path.is_empty()) {\n+    ss.print_cr(\"At center node\");\n+    steps.at(0)->dump(\"\\n\", false, &ss);\n+    return;\n+  }\n+  ss.print(\"At node\\n   \");\n+  steps.at(0)->dump(\"\\n\", false, &ss);\n+  ss.print_cr(\"  From path:\");\n+  ss.print(\"    [center]\");\n+  steps.at(path_len)->dump(\"\\n\", false, &ss);\n+  for (int i = 0; i < path_len; ++i) {\n+    if (path.at(path_len - i - 1) >= 0) {\n+      \/\/ It's an input\n+      int input_nb = path.at(path_len - i - 1);\n+      if (input_nb <= 9) {\n+        ss.print(\" \");\n+      }\n+      ss.print(\"     <-(%d)-\", input_nb);\n+\n+    } else if (path.at(path_len - i - 1) == LocalGraphInvariant::OutputStep) {\n+      \/\/ It's an output\n+      ss.print(\"         -->\");\n+    } else {\n+      ss.print(\"         ???\");\n+    }\n+    steps.at(path_len - i - 1)->dump(\"\\n\", false, &ss);\n+  }\n+}\n+\n+bool GraphInvariantChecker::run() const {\n+  if (_checks.is_empty()) {\n+    return true;\n+  }\n+\n+  ResourceMark rm;\n+  Unique_Node_List worklist;\n+  worklist.push(Compile::current()->root());\n+  Node_List steps;\n+  GrowableArray<int> path;\n+  stringStream ss;\n+  stringStream ss2;\n+  \/\/ Sometimes, we get weird structures in dead code that will be cleaned up later. It typically happens\n+  \/\/ when data dies, but control is not cleaned up right away, possibly kept alive by an unreachable loop.\n+  \/\/ Since we don't want to eagerly traverse the whole graph to remove dead code in IGVN, we can accept\n+  \/\/ weird structures in dead code.\n+  \/\/ For CFG-related errors, we will compute the set of reachable CFG nodes and decide whether to keep\n+  \/\/ the issue if the problematic node is reachable. This set of reachable nodes is thus computed lazily\n+  \/\/ (and it seems not to happen often in practice), and shared across checks.\n+  LocalGraphInvariant::LazyReachableCFGNodes reachable_cfg_nodes;\n+  bool success = true;\n+\n+  for (uint i = 0; i < worklist.size(); ++i) {\n+    Node* center = worklist.at(i);\n+    for (uint j = 0; j < center->req(); ++j) {\n+      Node* in = center->in(j);\n+      if (in != nullptr) {\n+        worklist.push(in);\n+      }\n+    }\n+    uint failures = 0;\n+    for (int j = 0; j < _checks.length(); ++j) {\n+      switch (_checks.at(j)->check(center, reachable_cfg_nodes, steps, path, ss2)) {\n+      case LocalGraphInvariant::CheckResult::FAILED:\n+        failures++;\n+        steps.push(center);\n+        print_path(steps, path, ss);\n+        ss.print_cr(\"# %s:\", _checks.at(j)->name());\n+        ss.print_cr(\"%s\", ss2.base());\n+        path.clear();\n+        steps.clear();\n+        ss2.reset();\n+        break;\n+      case LocalGraphInvariant::CheckResult::NOT_APPLICABLE:\n+      case LocalGraphInvariant::CheckResult::VALID:\n+        break;\n+      }\n+    }\n+    if (failures > 0) {\n+      success = false;\n+      stringStream ss3;\n+      ss3.print(\"%d failure%s for node\\n\", failures, failures == 1 ? \"\" : \"s\");\n+      center->dump(\"\\n\", false, &ss3);\n+      ss3.print_cr(\"%s\", ss.base());\n+      tty->print(\"%s\", ss3.base());\n+      ss.reset();\n+    }\n+  }\n+\n+  return success;\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/graphInvariants.cpp","additions":715,"deletions":0,"binary":false,"changes":715,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OPTO_GRAPHINVARIANTS_HPP\n+#define SHARE_OPTO_GRAPHINVARIANTS_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"opto\/node.hpp\"\n+\n+#ifndef PRODUCT\n+\/\/ An invariant that needs only a local view of the graph, around a given node.\n+class LocalGraphInvariant : public ResourceObj {\n+public:\n+  \/* When an invariant applied at a given node (the center) goes wrong at another\n+   * node, it is useful to show the path we took between them. OutputStep is used\n+   * to signify that a node is the output of the previous one in the path.\n+   * See LocalGraphInvariant::check for more details on paths.\n+   *\/\n+  static constexpr int OutputStep = -1;\n+\n+  \/\/ See LocalGraphInvariant::check why we need that.\n+  struct LazyReachableCFGNodes {\n+    bool is_node_dead(const Node*);\n+  private:\n+    void fill();\n+    Unique_Node_List _live_nodes;\n+  };\n+\n+  enum class CheckResult {\n+    VALID,          \/\/ The check applies, and it is satisfied on the given center\n+    FAILED,         \/\/ The check applies, but finds that the invariant is broken\n+    NOT_APPLICABLE, \/\/ The check has no opinion on the given center\n+  };\n+\n+  \/\/ For reporting\n+  virtual const char* name() const = 0;\n+\n+  \/* Check whether the invariant is true around the node [center]. The argument [steps] and [path] are initially empty.\n+   *\n+   * If the check fails steps and path must be filled with the path from the center to the failing node (where it's relevant to show).\n+   * Given a list of nodes\n+   * center = N0 --[r1]--> ... --[rk]-> Nk\n+   * where the ri are the relation between consecutive nodes: either p-th input, or an output,\n+   * then:\n+   * - steps must have length k + 1, and contain Nk ... N0\n+   * - path must have length k, and contain rk ... r1 where ri is:\n+   *   - a non-negative integer p for each step such that N{i-1} has Ni as p-th input (we need to follow an input edge)\n+   *   - the OUTPUT_STEP value in case N{i-1} has Ni as an output (we need to follow an output edge)\n+   * The lists are reversed to allow to easily fill them lazily on failure.\n+   * In addition, if the check fails, it must write its error message in [ss].\n+   *\n+   * If the check succeeds or is not applicable, [steps], [path] and [ss] must be untouched.\n+   *\n+   * The parameter [live_nodes] is used to share the lazily computed set of CFG nodes reachable from root. This is because some\n+   * checks don't apply to dead code, and we want to suppress their error if a violation is detected in dead code. Since it's\n+   * rather unlikely to have such a violation (they are rare overall), and then we won't need to check whether a node is dead,\n+   * it's better to have this set lazy.\n+   *\/\n+  virtual CheckResult check(const Node* center, LazyReachableCFGNodes& live_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const = 0;\n+};\n+\n+\/* Checks structural invariants of the graph connected to the root.\n+ *\n+ * The checker itself is not node or graph dependent and can be used\n+ * on any graph, to save memory: one allocation is enough!\n+ *\n+ * Local invariants are checked on each node of the graph: the check\n+ * is overall failing if any invariant doesn't hold on any node.\n+ *\n+ * It currently only checks local invariants, but it could be extended\n+ * to global ones.\n+ *\/\n+class GraphInvariantChecker : public ResourceObj {\n+  GrowableArray<const LocalGraphInvariant*> _checks;\n+\n+public:\n+  static GraphInvariantChecker* make_default();\n+\n+  \/\/ See LocalGraphInvariant::check for the requirements on the arguments.\n+  \/\/ Fills parameter [ss] with pretty print of the path.\n+  static void print_path(const Node_List& steps, const GrowableArray<int>& path, stringStream& ss);\n+  bool run() const;\n+};\n+#endif\n+\n+#endif \/\/ SHARE_OPTO_GRAPHINVARIANTS_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/opto\/graphInvariants.hpp","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"opto\/graphInvariants.hpp\"\n@@ -990,0 +991,3 @@\n+  if (VerifyIdealGraph) {\n+    assert(C->_invariant_checker->run(), \"Ideal graph doesn't verify structural invariants.\");\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350864\n+ * @requires vm.debug == true & vm.flavor == \"server\"\n+ * @summary Empty main program to run with flag VerifyIdealGraph.\n+ *\n+ * @run main\/othervm -Xbatch -Xcomp -XX:+VerifyIdealGraph compiler.c2.TestVerifyIdealGraph\n+ *\/\n+package compiler.c2;\n+\n+public class TestVerifyIdealGraph {\n+    public static void main(String[] args) {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestVerifyIdealGraph.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"}]}