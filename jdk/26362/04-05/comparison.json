{"files":[{"patch":"@@ -25,1 +25,0 @@\n-#include \"metaprogramming\/enableIf.hpp\"\n@@ -30,1 +29,0 @@\n-constexpr int LocalGraphInvariant::OutputStep;\n@@ -32,2 +30,2 @@\n-void LocalGraphInvariant::LazyReachableCFGNodes::fill() {\n-  precond(_live_nodes.size() == 0);\n+void LocalGraphInvariant::LazyReachableCFGNodes::compute() {\n+  precond(_reachable_nodes.size() == 0);\n@@ -36,3 +34,3 @@\n-  _live_nodes.push(Compile::current()->root());\n-  for (uint i = 0; i < _live_nodes.size(); ++i) {\n-    Node* n = _live_nodes.at(i);\n+  _reachable_nodes.push(Compile::current()->root());\n+  for (uint i = 0; i < _reachable_nodes.size(); ++i) {\n+    Node* n = _reachable_nodes.at(i);\n@@ -42,1 +40,1 @@\n-        _live_nodes.push(out);\n+        _reachable_nodes.push(out);\n@@ -47,1 +45,1 @@\n-  postcond(_live_nodes.size() > 0);\n+  postcond(_reachable_nodes.size() > 0);\n@@ -51,2 +49,2 @@\n-  if (_live_nodes.size() == 0) {\n-    fill();\n+  if (_reachable_nodes.size() == 0) {\n+    compute();\n@@ -54,2 +52,2 @@\n-  assert(_live_nodes.size() > 0, \"filling failed\");\n-  return !_live_nodes.member(n);\n+  assert(_reachable_nodes.size() > 0, \"filling failed\");\n+  return !_reachable_nodes.member(n);\n@@ -58,4 +56,1 @@\n-\/* A base class for checks expressed as data. Patterns are supposed to be local, centered around one node\n- * and compositional to express complex structures from simple properties.\n- * For instance, we have a pattern for saying \"the first input of the center match P\" where P is another\n- * Pattern. We end up with trees of patterns matching the graph.\n+\/* A base for local invariants that mostly work using a pattern.\n@@ -63,13 +58,2 @@\n-struct Pattern : ResourceObj {\n-  virtual bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream&) const = 0;\n-};\n-\n-\/* This pattern just accepts any node. This is convenient mostly as leaves in a pattern tree.\n- * For instance `AtSingleOutputOfType(..., new TruePattern())` will make sure there is\n- * indeed a single output of the given type, but won't enforce anything on the said output.\n- *\/\n-struct TruePattern : Pattern {\n-  bool check(const Node*, Node_List&, GrowableArray<int>&, stringStream&) const override {\n-    return true;\n-  }\n-};\n+struct PatternBasedCheck : LocalGraphInvariant {\n+  explicit PatternBasedCheck(const char* name, const Pattern* pattern) : _name(name), _pattern(pattern) {}\n@@ -77,21 +61,2 @@\n-\/* This is semantically equivalent to `TruePattern` but will set the given reference to the node\n- * the pattern is matched against. This is useful to perform additional checks that would\n- * otherwise be hard or impossible to express as local patterns.\n- *\n- * For instance, one could write\n- * Node* first, second;\n- * And::make(\n- *   new AtInput(0, new Bind(first)),\n- *   new AtInput(1, new Bind(second))\n- * );\n- * [...] \/\/ run the pattern\n- * if (first == second) { \/\/ checking whether they are the same node\n- *\n- * Bindings are only honored if the overall pattern succeeds. Otherwise, don't assume anything reasonable\n- * has been set. Anyway, you don't need it: you already know it doesn't have the right shape.\n- *\/\n-struct Bind : Pattern {\n-  explicit Bind(const Node*& binding) : _binding(binding) {}\n-  bool check(const Node* center, Node_List&, GrowableArray<int>&, stringStream&) const override {\n-    _binding = center;\n-    return true;\n+  const char* name() const override {\n+    return _name;\n@@ -100,12 +65,2 @@\n-private:\n-  const Node*& _binding;\n-};\n-\n-\/* A more type-safe version of `Bind` mostly to use with NodeClassIsAndBind macro defined later\n- *\/\n-template <typename N, ENABLE_IF(std::is_base_of<Node, N>::value)>\n-struct TypedBind : Pattern {\n-  explicit TypedBind(const N*& binding) : _binding(binding) {}\n-  bool check(const Node* center, Node_List&, GrowableArray<int>&, stringStream&) const override {\n-    _binding = static_cast<const N*>(center);\n-    return true;\n+  bool run_pattern(const Node* center, PathInGraph& path, stringStream& ss) const {\n+    return _pattern->match(center, path, ss);\n@@ -115,109 +70,1 @@\n-  const N*& _binding;\n-};\n-\n-\/* Matches multiple patterns at the same node.\n- *\n- * Evaluation order is guaranteed to be left-to-right. In particular, check a node has enough\n- * inputs before checking a property of a given input. This allows better reporting. E.g. if\n- * you know a node has 3 inputs and want patterns to be applied to each input, it would look like\n- * And::make(\n- *    new HasExactlyNInputs(3),\n- *    new AtInput(0, P0),\n- *    new AtInput(1, P1),\n- *    new AtInput(2, P2),\n- * )\n- * If we relied on `AtInput` to report too few inputs, it would give confusing error messages as\n- * the first `AtInput` can only know it expects at least one input, and seeing the message\n- * \"Found 0 inputs, expected at least 1\" is not very helpful, potentially confusing as it doesn't\n- * state what is actually expected: 3 inputs.\n- * It also is not able to express that a node has exactly a given number of inputs, and it is a\n- * significant difference whether we expect AT LEAST 3 inputs, or EXACTLY 3 inputs. Let's make\n- * things precise.\n- *\/\n-struct And : Pattern {\n-private:\n-  GrowableArray<Pattern*> _checks;\n-  template <typename... PP>\n-  static void make_helper(And* a, Pattern* pattern, PP... others) {\n-    a->_checks.push(pattern);\n-    make_helper(a, others...);\n-  }\n-  static void make_helper(And*) {}\n-\n-public:\n-  template <typename... PP>\n-  static And* make(PP... patterns) {\n-    And* andd = new And();\n-    make_helper(andd, patterns...);\n-    return andd;\n-  }\n-\n-  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n-    for (int i = 0; i < _checks.length(); ++i) {\n-      if (!_checks.at(i)->check(center, steps, path, ss)) {\n-        return false;\n-      }\n-    }\n-    return true;\n-  }\n-};\n-\n-void make_pretty_list_of_inputs(const Node* center, stringStream& ss) {\n-  for (uint i = 0; i < center->req(); ++i) {\n-    Node* in = center->in(i);\n-    ss.print(\"  %d: \", i);\n-    if (in == nullptr) {\n-      ss.print_cr(\"nullptr\");\n-    } else {\n-      in->dump(\"\\n\", false, &ss);\n-    }\n-  }\n-}\n-\n-struct HasExactlyNInputs : Pattern {\n-  explicit HasExactlyNInputs(uint expect_req) : _expect_req(expect_req) {}\n-  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n-    if (center->req() != _expect_req) {\n-      ss.print_cr(\"Unexpected number of input. Expected: %d. Found: %d\", _expect_req, center->req());\n-      make_pretty_list_of_inputs(center, ss);\n-      return false;\n-    }\n-    return true;\n-  }\n-  const uint _expect_req;\n-};\n-\n-struct HasAtLeastNInputs : Pattern {\n-  explicit HasAtLeastNInputs(uint expect_req) : _expect_req(expect_req) {}\n-  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n-    if (center->req() < _expect_req) {\n-      ss.print_cr(\"Too small number of input. Expected: %d. Found: %d\", _expect_req, center->req());\n-      make_pretty_list_of_inputs(center, ss);\n-      return false;\n-    }\n-    return true;\n-  }\n-  const uint _expect_req;\n-};\n-\n-\/* Check that a given pattern applies at the given input of the center.\n- *\n- * As explained above, it doesn't check (nicely) that inputs are in sufficient numbers.\n- * Use HasExactlyNInputs or HasAtLeastNInputs for that.\n- *\/\n-struct AtInput : Pattern {\n-  AtInput(uint which_input, const Pattern* pattern) : _which_input(which_input), _pattern(pattern) {}\n-  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n-    assert(_which_input < center->req(), \"Input number is out of range\");\n-    if (center->in(_which_input) == nullptr) {\n-      ss.print_cr(\"Input at index %d is nullptr.\", _which_input);\n-      return false;\n-    }\n-    bool result = _pattern->check(center->in(_which_input), steps, path, ss);\n-    if (!result) {\n-      steps.push(center->in(_which_input));\n-      path.push(static_cast<int>(_which_input));\n-    }\n-    return result;\n-  }\n-  const uint _which_input;\n+  const char* _name;\n@@ -227,36 +74,32 @@\n-\/* Check a node has the right type (as which C++ class, not as abstract value). Typically used with\n- * is_XXXNode methods.\n- *\/\n-struct NodeClass : Pattern {\n-  explicit NodeClass(bool (Node::*type_check)() const) : _type_check(type_check) {}\n-  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n-    if (!(center->*_type_check)()) {\n-      ss.print_cr(\"Unexpected type: %s.\", center->Name());\n-      return false;\n-    }\n-    return true;\n-  }\n-  bool (Node::*_type_check)() const;\n-};\n-\n-\n-\/* To check the kind of a node and bind it to a variable of the right type.\n- * For instance:\n- *   const RegionNode* r;\n- *   NodeClassIsAndBind(Region, r)\n- *\/\n-#define NodeClassIsAndBind(node_type, binding)  \\\n-  And::make(                                    \\\n-      new NodeClass(&Node::is_ ## node_type),   \\\n-      new TypedBind<node_type ## Node>(binding) \\\n-  )\n-\n-struct HasNOutputs : Pattern {\n-  explicit HasNOutputs(uint expect_outcnt) : _expect_outcnt(expect_outcnt) {}\n-  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n-    if (center->outcnt() != _expect_outcnt) {\n-      ss.print_cr(\"Unexpected number of outputs. Expected: %d, found: %d.\", _expect_outcnt, center->outcnt());\n-      for (DUIterator_Fast imax, i = center->fast_outs(imax); i < imax; i++) {\n-        Node* out = center->fast_out(i);\n-        ss.print(\"  \");\n-        out->dump(\"\\n\", false, &ss);\n+struct CheckHelper {\n+  static CheckHelper for_reachable_center(const PatternBasedCheck* check, const Node* center, LocalGraphInvariant::LazyReachableCFGNodes& reachable_cfg_nodes, PathInGraph& path, stringStream& ss) {\n+    return CheckHelper(check, center, &reachable_cfg_nodes, path, ss);\n+  }\n+  static CheckHelper for_any_center(const PatternBasedCheck* check, const Node* center, PathInGraph& path, stringStream& ss) {\n+    return CheckHelper(check, center, nullptr, path, ss);\n+  }\n+  CheckHelper& applies_if_center(bool (Node::*type_check)() const) {\n+    if (!(_center->*type_check)()) {\n+      _result = CheckHelperResult::NOT_APPLICABLE;\n+    }\n+    return *this;\n+  }\n+  template <typename F>\n+  CheckHelper& applies_if_center(F f) {\n+    if (!f(*_center)) {\n+      _result = CheckHelperResult::NOT_APPLICABLE;\n+    }\n+    return *this;\n+  }\n+  CheckHelper& run_pattern() {\n+    if (_result == CheckHelperResult::UNKNOWN) {\n+      if (_check.run_pattern(_center, _path, _ss)) {\n+        _result = CheckHelperResult::VALID;\n+      } else {\n+        if (_reachable_cfg_nodes == nullptr) {\n+          _result = CheckHelperResult::FAILED;\n+        } else if (_reachable_cfg_nodes->is_node_dead(_center)) {\n+          _result = CheckHelperResult::VALID;\n+        } else {\n+          _result = CheckHelperResult::FAILED;\n+        }\n@@ -264,1 +107,0 @@\n-      return false;\n@@ -266,13 +108,1 @@\n-    return true;\n-  }\n-  const uint _expect_outcnt;\n-};\n-\n-\/* Given a is_XXXNode method pointer and a pattern P, this pattern checks that\n- * - only one output has the given type XXX\n- * - this one output matches P.\n- *\n- * Since outputs are not numbered, this is a convenient way to walk on the graph in the Def-Use direction.\n- *\/\n-struct AtSingleOutputOfType : Pattern {\n-  AtSingleOutputOfType(bool (Node::*type_check)() const, const Pattern* pattern) : _type_check(type_check), _pattern(pattern) {\n+    return *this;\n@@ -280,13 +110,5 @@\n-\n-  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n-    Node_List outputs_of_correct_type;\n-    for (DUIterator_Fast imax, i = center->fast_outs(imax); i < imax; i++) {\n-      Node* out = center->fast_out(i);\n-      if ((out->*_type_check)()) {\n-        outputs_of_correct_type.push(out);\n-      }\n-    }\n-    if (outputs_of_correct_type.size() != 1) {\n-      ss.print_cr(\"Non-unique output of expected type. Found: %d.\", outputs_of_correct_type.size());\n-      for (uint i = 0; i < outputs_of_correct_type.size(); ++i) {\n-        outputs_of_correct_type.at(i)->dump(\"\\n\", false, &ss);\n+  template <typename Fun>\n+  CheckHelper& on_success_require(Fun fun) {\n+    if (_result == CheckHelperResult::VALID) {\n+      if (!fun()) {\n+        _result = CheckHelperResult::FAILED;\n@@ -294,1 +116,0 @@\n-      return false;\n@@ -296,4 +117,16 @@\n-    bool result = _pattern->check(outputs_of_correct_type.at(0), steps, path, ss);\n-    if (!result) {\n-      steps.push(outputs_of_correct_type.at(0));\n-      path.push(LocalGraphInvariant::OutputStep);\n+    return *this;\n+  }\n+  LocalGraphInvariant::CheckResult to_result() const {\n+    switch (_result) {\n+    case CheckHelperResult::VALID:\n+      return LocalGraphInvariant::CheckResult::VALID;\n+    case CheckHelperResult::FAILED:\n+      return LocalGraphInvariant::CheckResult::FAILED;\n+    case CheckHelperResult::NOT_APPLICABLE:\n+      return LocalGraphInvariant::CheckResult::NOT_APPLICABLE;\n+    case CheckHelperResult::UNKNOWN:\n+      assert(false, \"Should have decided before!\");\n+      return LocalGraphInvariant::CheckResult::FAILED;\n+    default:\n+      ShouldNotReachHere();\n+      return LocalGraphInvariant::CheckResult::FAILED;\n@@ -301,1 +134,0 @@\n-    return result;\n@@ -303,3 +135,0 @@\n-  bool (Node::*_type_check)() const;\n-  const Pattern* const _pattern;\n-};\n@@ -307,10 +136,22 @@\n-\/* A LocalGraphInvariant that mostly use a Pattern for checking.\n- *\n- * Can still override `check` to do more.\n- *\/\n-struct PatternBasedCheck : LocalGraphInvariant {\n-  const Pattern* const _pattern;\n-  explicit PatternBasedCheck(const Pattern* pattern) : _pattern(pattern) {}\n-  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n-    return _pattern->check(center, steps, path, ss) ? CheckResult::VALID : CheckResult::FAILED;\n-  }\n+private:\n+  CheckHelper(const PatternBasedCheck* check, const Node* center, LocalGraphInvariant::LazyReachableCFGNodes* reachable_cfg_nodes, PathInGraph& path, stringStream& ss)\n+      : _check(*check),\n+        _center(center),\n+        _reachable_cfg_nodes(reachable_cfg_nodes),\n+        _path(path),\n+        _ss(ss) {}\n+\n+  const PatternBasedCheck& _check;\n+  const Node* _center;\n+  LocalGraphInvariant::LazyReachableCFGNodes* _reachable_cfg_nodes;\n+  PathInGraph& _path;\n+  stringStream& _ss;\n+\n+  enum class CheckHelperResult {\n+    VALID,\n+    FAILED,\n+    NOT_APPLICABLE,\n+    UNKNOWN,\n+  };\n+\n+  CheckHelperResult _result = CheckHelperResult::UNKNOWN;\n@@ -324,0 +165,1 @@\n+            \"IfProjections\",\n@@ -329,16 +171,5 @@\n-  const char* name() const override {\n-    return \"IfProjections\";\n-  }\n-  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n-    if (!center->is_If()) {\n-      return CheckResult::NOT_APPLICABLE;\n-    }\n-    CheckResult r = PatternBasedCheck::check(center, reachable_cfg_nodes, steps, path, ss);\n-    if (r == CheckResult::FAILED) {\n-      if (reachable_cfg_nodes.is_node_dead(center)) {\n-        \/\/ That's ok for dead nodes right now. It might be too expensive to collect for IGVN, but it will be removed in loop opts.\n-        ss.reset();\n-        return CheckResult::VALID;\n-      }\n-    }\n-    return r;\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, PathInGraph& path, stringStream& ss) const override {\n+    return CheckHelper::for_reachable_center(this, center, reachable_cfg_nodes, path, ss)\n+        .applies_if_center(&Node::is_If)\n+        .run_pattern()\n+        .to_result();\n@@ -351,1 +182,4 @@\n-  const RegionNode* region_node = nullptr;\n+private:\n+  const RegionNode* _region_node = nullptr;\n+\n+public:\n@@ -354,0 +188,1 @@\n+            \"PhiArity\",\n@@ -355,1 +190,1 @@\n-                new HasAtLeastNInputs(1),\n+                new HasAtLeastNInputs(2),\n@@ -358,19 +193,15 @@\n-                    NodeClassIsAndBind(Region, region_node)))) {\n-  }\n-  const char* name() const override {\n-    return \"PhiArity\";\n-  }\n-  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n-    if (!center->is_Phi()) {\n-      return CheckResult::NOT_APPLICABLE;\n-    }\n-    CheckResult result = PatternBasedCheck::check(center, reachable_cfg_nodes, steps, path, ss);\n-    if (result != CheckResult::VALID) {\n-      return result;\n-    }\n-    assert(region_node != nullptr, \"sanity\");\n-    if (region_node->req() != center->req()) {\n-      ss.print_cr(\"Phi nodes must have the same arity as their Region node. Phi arity: %d; Region arity: %d.\", center->req(), region_node->req());\n-      return CheckResult::FAILED;\n-    }\n-    return CheckResult::VALID;\n+                    NodeClassIsAndBind(Region, _region_node)))) {\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes&, PathInGraph& path, stringStream& ss) const override {\n+    return CheckHelper::for_any_center(this, center, path, ss)\n+        .applies_if_center(&Node::is_Phi)\n+        .run_pattern()\n+        .on_success_require([&]() -> bool {\n+          assert(_region_node != nullptr, \"sanity\");\n+          if (_region_node->req() != center->req()) {\n+            ss.print_cr(\"Phi nodes must have the same arity as their Region node. Phi arity: %d; Region arity: %d.\", center->req(), _region_node->req());\n+            return false;\n+          }\n+          return true;\n+        })\n+        .to_result();\n@@ -386,1 +217,1 @@\n-  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, PathInGraph& path, stringStream& ss) const override {\n@@ -400,1 +231,1 @@\n-    uint cfg_out = ctrl_succ.size();\n+    const uint cfg_out = ctrl_succ.size();\n@@ -409,4 +240,1 @@\n-        for (uint i = 0; i < ctrl_succ.size(); ++i) {\n-          ss.print(\"  \");\n-          ctrl_succ.at(i)->dump(\"\\n\", false, &ss);\n-        }\n+        print_node_list(ctrl_succ, ss);\n@@ -418,4 +246,1 @@\n-        for (uint i = 0; i < ctrl_succ.size(); ++i) {\n-          ss.print(\"  \");\n-          ctrl_succ.at(i)->dump(\"\\n\", false, &ss);\n-        }\n+        print_node_list(ctrl_succ, ss);\n@@ -427,4 +252,1 @@\n-          for (uint i = 0; i < ctrl_succ.size(); ++i) {\n-            ss.print(\"  \");\n-            ctrl_succ.at(i)->dump(\"\\n\", false, &ss);\n-          }\n+          print_node_list(ctrl_succ, ss);\n@@ -434,1 +256,1 @@\n-    } else if (center->is_Catch() || center->is_Jump()) {\n+    } else if (center->is_PCTable()) {\n@@ -442,4 +264,1 @@\n-        for (uint i = 0; i < ctrl_succ.size(); ++i) {\n-          ss.print(\"  \");\n-          ctrl_succ.at(i)->dump(\"\\n\", false, &ss);\n-        }\n+        print_node_list(ctrl_succ, ss);\n@@ -452,0 +271,8 @@\n+\n+private:\n+  static void print_node_list(const Node_List& ctrl_succ, stringStream& ss) {\n+    for (uint i = 0; i < ctrl_succ.size(); ++i) {\n+      ss.print(\"  \");\n+      ctrl_succ.at(i)->dump(\"\\n\", false, &ss);\n+    }\n+  }\n@@ -454,1 +281,1 @@\n-\/* Checks that Region Start and Root nodes' first input is a self loop, except for copy regions, which then must have only one non null input.\n+\/* Checks that Region, Start and Root nodes' first input is a self loop, except for copy regions, which then must have only one non null input.\n@@ -460,1 +287,1 @@\n-  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, PathInGraph& path, stringStream& ss) const override {\n@@ -487,0 +314,1 @@\n+        ResourceMark rm;\n@@ -507,1 +335,1 @@\n-\/\/ CountedLoopEnd -> IfTrue -> CountedLoop\n+\/\/ CountedLoopEnd -> IfTrue -> CountedLoop[center]\n@@ -509,1 +337,4 @@\n-  const BaseCountedLoopEndNode* counted_loop_end = nullptr;\n+private:\n+  const BaseCountedLoopEndNode* _counted_loop_end = nullptr;\n+\n+public:\n@@ -512,0 +343,1 @@\n+            \"CountedLoopInvariants\",\n@@ -521,28 +353,23 @@\n-                            NodeClassIsAndBind(BaseCountedLoopEnd, counted_loop_end)))))) {}\n-  const char* name() const override {\n-    return \"CountedLoopInvariants\";\n-  }\n-  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n-    if (!center->is_CountedLoop() && !center->is_LongCountedLoop()) {\n-      return CheckResult::NOT_APPLICABLE;\n-    }\n-\n-    CheckResult result = PatternBasedCheck::check(center, reachable_cfg_nodes, steps, path, ss);\n-    if (result != CheckResult::VALID) {\n-      return result;\n-    }\n-    assert(counted_loop_end != nullptr, \"sanity\");\n-    if (center->is_LongCountedLoop()) {\n-      if (!counted_loop_end->is_LongCountedLoopEnd()) {\n-        assert(counted_loop_end->is_CountedLoopEnd(), \"Update the error message or add cases\");\n-        ss.print_cr(\"A CountedLoopEnd is the backedge of a LongCountedLoop.\");\n-        return CheckResult::FAILED;\n-      }\n-    } else {\n-      if (!counted_loop_end->is_CountedLoopEnd()) {\n-        assert(counted_loop_end->is_LongCountedLoopEnd(), \"Update the error message or add cases\");\n-        ss.print_cr(\"A LongCountedLoopEnd is the backedge of a CountedLoop.\");\n-        return CheckResult::FAILED;\n-      }\n-    }\n-    return CheckResult::VALID;\n+                            NodeClassIsAndBind(BaseCountedLoopEnd, _counted_loop_end)))))) {}\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, PathInGraph& path, stringStream& ss) const override {\n+    return CheckHelper::for_any_center(this, center, path, ss)\n+        .applies_if_center(&Node::is_BaseCountedLoop)\n+        .run_pattern()\n+        .on_success_require([&]() {\n+          assert(_counted_loop_end != nullptr, \"sanity\");\n+          if (center->is_LongCountedLoop()) {\n+            if (!_counted_loop_end->is_LongCountedLoopEnd()) {\n+              assert(_counted_loop_end->is_CountedLoopEnd(), \"Update the error message or add cases\");\n+              ss.print_cr(\"A CountedLoopEnd is the backedge of a LongCountedLoop.\");\n+              return false;\n+            }\n+          } else {\n+            if (!_counted_loop_end->is_CountedLoopEnd()) {\n+              assert(_counted_loop_end->is_LongCountedLoopEnd(), \"Update the error message or add cases\");\n+              ss.print_cr(\"A LongCountedLoopEnd is the backedge of a CountedLoop.\");\n+              return false;\n+            }\n+          }\n+          return true;\n+        })\n+        .to_result();\n@@ -553,0 +380,1 @@\n+\/\/               \\-> IfTrue  ->                                                                              \/\n@@ -554,0 +382,5 @@\n+private:\n+  const CountedLoopNode* _counted_loop_from_outer_strip_mined_loop;\n+  const CountedLoopNode* _counted_loop_from_backedge;\n+\n+public:\n@@ -556,0 +389,1 @@\n+            \"OuterStripMinedLoopInvariants\",\n@@ -570,1 +404,7 @@\n-                                    new NodeClass(&Node::is_CountedLoopEnd)))))),\n+                                    And::make(\n+                                        new NodeClass(&Node::is_CountedLoopEnd),\n+                                        new AtSingleOutputOfType(\n+                                            &Node::is_IfTrue,\n+                                            new AtSingleOutputOfType(\n+                                                &Node::is_CountedLoop,\n+                                                new TypedBind<CountedLoopNode>(_counted_loop_from_backedge))))))))),\n@@ -577,10 +417,19 @@\n-                            new TruePattern()))))) {}\n-  const char* name() const override {\n-    return \"OuterStripMinedLoopInvariants\";\n-  }\n-  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n-    if (!center->is_OuterStripMinedLoopEnd()) {\n-      return CheckResult::NOT_APPLICABLE;\n-    }\n-\n-    return PatternBasedCheck::check(center, reachable_cfg_nodes, steps, path, ss);\n+                            new TypedBind<CountedLoopNode>(_counted_loop_from_outer_strip_mined_loop)))))) {}\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, PathInGraph& path, stringStream& ss) const override {\n+    return CheckHelper::for_any_center(this, center, path, ss)\n+        .applies_if_center(&Node::is_OuterStripMinedLoopEnd)\n+        .run_pattern()\n+        .on_success_require([&]() {\n+          assert(_counted_loop_from_backedge != nullptr, \"sanity\");\n+          assert(_counted_loop_from_outer_strip_mined_loop != nullptr, \"sanity\");\n+          bool same_counted_loop = _counted_loop_from_backedge == _counted_loop_from_outer_strip_mined_loop;\n+          if (!same_counted_loop) {\n+            ss.print_cr(\"Found different counted loop from backedge and from output of OuterStripMinedLoop.\");\n+            ss.print_cr(\"From backedge:\");\n+            _counted_loop_from_backedge->dump(\"\\n\", false, &ss);\n+            ss.print_cr(\"From OuterStripMinedLoop:\");\n+            _counted_loop_from_outer_strip_mined_loop->dump(\"\\n\", false, &ss);\n+          }\n+          return same_counted_loop;\n+        })\n+        .to_result();\n@@ -594,1 +443,1 @@\n-  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, PathInGraph& path, stringStream& ss) const override {\n@@ -623,4 +472,6 @@\n-void GraphInvariantChecker::print_path(const Node_List& steps, const GrowableArray<int>& path, stringStream& ss) {\n-  const int path_len = path.length();\n-  precond(steps.size() == static_cast<uint>(path_len) + 1);\n-  if (path.is_empty()) {\n+void GraphInvariantChecker::print_path(const PathInGraph& path, stringStream& ss) {\n+  const GrowableArray<int>& relation_to_previous_node = path.relation_to_previous_node();\n+  const int path_len = relation_to_previous_node.length();\n+  const Node_List& nodes = path.nodes();\n+  precond(nodes.size() == static_cast<uint>(path_len) + 1);\n+  if (path_len == 0) {\n@@ -628,1 +479,1 @@\n-    steps.at(0)->dump(\"\\n\", false, &ss);\n+    nodes.at(0)->dump(\"\\n\", false, &ss);\n@@ -632,1 +483,1 @@\n-  steps.at(0)->dump(\"\\n\", false, &ss);\n+  nodes.at(0)->dump(\"\\n\", false, &ss);\n@@ -635,1 +486,1 @@\n-  steps.at(path_len)->dump(\"\\n\", false, &ss);\n+  nodes.at(path_len)->dump(\"\\n\", false, &ss);\n@@ -637,1 +488,1 @@\n-    if (path.at(path_len - i - 1) >= 0) {\n+    if (relation_to_previous_node.at(path_len - i - 1) >= 0) {\n@@ -639,1 +490,1 @@\n-      int input_nb = path.at(path_len - i - 1);\n+      int input_nb = relation_to_previous_node.at(path_len - i - 1);\n@@ -645,1 +496,1 @@\n-    } else if (path.at(path_len - i - 1) == LocalGraphInvariant::OutputStep) {\n+    } else if (relation_to_previous_node.at(path_len - i - 1) == PathInGraph::OutputStep) {\n@@ -651,1 +502,1 @@\n-    steps.at(path_len - i - 1)->dump(\"\\n\", false, &ss);\n+    nodes.at(path_len - i - 1)->dump(\"\\n\", false, &ss);\n@@ -663,2 +514,0 @@\n-  Node_List steps;\n-  GrowableArray<int> path;\n@@ -687,1 +536,2 @@\n-      switch (_checks.at(j)->check(center, reachable_cfg_nodes, steps, path, ss2)) {\n+      PathInGraph path;\n+      switch (_checks.at(j)->check(center, reachable_cfg_nodes, path, ss2)) {\n@@ -690,2 +540,2 @@\n-        steps.push(center);\n-        print_path(steps, path, ss);\n+        path.finalize(center);\n+        print_path(path, ss);\n@@ -694,2 +544,0 @@\n-        path.clear();\n-        steps.clear();\n","filename":"src\/hotspot\/share\/opto\/graphInvariants.cpp","additions":220,"deletions":372,"binary":false,"changes":592,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"opto\/pattern.hpp\"\n@@ -35,7 +36,0 @@\n-  \/* When an invariant applied at a given node (the center) goes wrong at another\n-   * node, it is useful to show the path we took between them. OutputStep is used\n-   * to signify that a node is the output of the previous one in the path.\n-   * See LocalGraphInvariant::check for more details on paths.\n-   *\/\n-  static constexpr int OutputStep = -1;\n-\n@@ -46,2 +40,2 @@\n-    void fill();\n-    Unique_Node_List _live_nodes;\n+    void compute();\n+    Unique_Node_List _reachable_nodes;\n@@ -59,1 +53,1 @@\n-  \/* Check whether the invariant is true around the node [center]. The argument [steps] and [path] are initially empty.\n+  \/* Check whether the invariant is true around the node [center].\n@@ -61,10 +55,2 @@\n-   * If the check fails steps and path must be filled with the path from the center to the failing node (where it's relevant to show).\n-   * Given a list of nodes\n-   * center = N0 --[r1]--> ... --[rk]-> Nk\n-   * where the ri are the relation between consecutive nodes: either p-th input, or an output,\n-   * then:\n-   * - steps must have length k + 1, and contain Nk ... N0\n-   * - path must have length k, and contain rk ... r1 where ri is:\n-   *   - a non-negative integer p for each step such that N{i-1} has Ni as p-th input (we need to follow an input edge)\n-   *   - the OUTPUT_STEP value in case N{i-1} has Ni as an output (we need to follow an output edge)\n-   * The lists are reversed to allow to easily fill them lazily on failure.\n+   * If the check fails steps and path must be filled with the path from the center to the failing node (where it's relevant to\n+   * show), in reverse order (for filling lazily on failures).\n@@ -73,1 +59,1 @@\n-   * If the check succeeds or is not applicable, [steps], [path] and [ss] must be untouched.\n+   * If the check succeeds or is not applicable, [path] and [ss] must be untouched.\n@@ -80,1 +66,1 @@\n-  virtual CheckResult check(const Node* center, LazyReachableCFGNodes& live_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const = 0;\n+  virtual CheckResult check(const Node* center, LazyReachableCFGNodes& live_nodes, PathInGraph& path, stringStream& ss) const = 0;\n@@ -102,1 +88,1 @@\n-  static void print_path(const Node_List& steps, const GrowableArray<int>& path, stringStream& ss);\n+  static void print_path(const PathInGraph& path, stringStream& ss);\n","filename":"src\/hotspot\/share\/opto\/graphInvariants.hpp","additions":9,"deletions":23,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"pattern.hpp\"\n+\n+constexpr int PathInGraph::OutputStep;\n+\n+void PathInGraph::finalize(Node* center) {\n+  _nodes.push(center);\n+}\n+\n+void PathInGraph::add_input_step(uint input_index, Node* input) {\n+  _nodes.push(input);\n+  _relation_to_previous_node.push(static_cast<int>(input_index));\n+}\n+\n+void PathInGraph::add_output_step(Node* output) {\n+  _nodes.push(output);\n+  _relation_to_previous_node.push(static_cast<int>(OutputStep));\n+}\n+\n+bool Bind::match(const Node* center, PathInGraph&, stringStream&) const {\n+  _binding = center;\n+  return true;\n+}\n+\n+bool And::match(const Node* center, PathInGraph& path, stringStream& ss) const {\n+  for (int i = 0; i < _checks.length(); ++i) {\n+    if (!_checks.at(i)->match(center, path, ss)) {\n+      \/\/ We stay on the same center, so no need to update path.\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+#ifndef PRODUCT\n+void print_list_of_inputs(const Node* center, stringStream& ss) {\n+  for (uint i = 0; i < center->req(); ++i) {\n+    Node* in = center->in(i);\n+    ss.print(\"  %d: \", i);\n+    if (in == nullptr) {\n+      ss.print_cr(\"nullptr\");\n+    } else {\n+      in->dump(\"\\n\", false, &ss);\n+    }\n+  }\n+}\n+#endif\n+\n+bool HasExactlyNInputs::match(const Node* center, PathInGraph& path, stringStream& ss) const {\n+  if (center->req() != _expect_req) {\n+    ss.print_cr(\"Unexpected number of inputs. Expected exactly: %d. Found: %d\", _expect_req, center->req());\n+#ifndef PRODUCT\n+    print_list_of_inputs(center, ss);\n+#endif\n+    return false;\n+  }\n+  return true;\n+}\n+\n+bool HasAtLeastNInputs::match(const Node* center, PathInGraph& path, stringStream& ss) const {\n+  if (center->req() < _expect_req) {\n+    ss.print_cr(\"Too few inputs. Expected at least: %d. Found: %d\", _expect_req, center->req());\n+#ifndef PRODUCT\n+    print_list_of_inputs(center, ss);\n+#endif\n+    return false;\n+  }\n+  return true;\n+}\n+\n+bool AtInput::match(const Node* center, PathInGraph& path, stringStream& ss) const {\n+  assert(_which_input < center->req(), \"Input number is out of range\");\n+  Node* input = center->in(_which_input);\n+  if (input == nullptr) {\n+    ss.print_cr(\"Input at index %d is nullptr.\", _which_input);\n+    return false;\n+  }\n+  bool result = _pattern->match(input, path, ss);\n+  if (!result) {\n+    path.add_input_step(_which_input, input);\n+  }\n+  return result;\n+}\n+\n+bool NodeClass::match(const Node* center, PathInGraph& path, stringStream& ss) const {\n+  if (!(center->*_type_check)()) {\n+#ifdef PRODUCT\n+    ss.print_cr(\"Unexpected type.\");\n+#else\n+    ss.print_cr(\"Unexpected type: %s.\", center->Name());\n+#endif\n+    return false;\n+  }\n+  return true;\n+}\n+\n+bool HasNOutputs::match(const Node* center, PathInGraph& path, stringStream& ss) const {\n+  if (center->outcnt() != _expect_outcnt) {\n+    ss.print_cr(\"Unexpected number of outputs. Expected: %d, found: %d.\", _expect_outcnt, center->outcnt());\n+#ifndef PRODUCT\n+    for (DUIterator_Fast imax, i = center->fast_outs(imax); i < imax; i++) {\n+      Node* out = center->fast_out(i);\n+      ss.print(\"  \");\n+      out->dump(\"\\n\", false, &ss);\n+    }\n+#endif\n+    return false;\n+  }\n+  return true;\n+}\n+\n+bool AtSingleOutputOfType::match(const Node* center, PathInGraph& path, stringStream& ss) const {\n+  Node* single_output_of_right_type = nullptr;\n+  bool too_many_outputs_of_right_type = false;\n+\n+  for (DUIterator_Fast imax, i = center->fast_outs(imax); i < imax; i++) {\n+    Node* out = center->fast_out(i);\n+    if ((out->*_type_check)()) {\n+      if (single_output_of_right_type == nullptr) {\n+        single_output_of_right_type = out;\n+      } else {\n+        too_many_outputs_of_right_type = true;\n+      }\n+    }\n+  }\n+\n+  if (single_output_of_right_type == nullptr) {\n+    ss.print_cr(\"No output of expected type.\");\n+    return false;\n+  }\n+  if (too_many_outputs_of_right_type) {\n+    ResourceMark rm;\n+    Node_List outputs_of_correct_type;\n+    for (DUIterator_Fast imax, i = center->fast_outs(imax); i < imax; i++) {\n+      Node* out = center->fast_out(i);\n+      if ((out->*_type_check)()) {\n+        outputs_of_correct_type.push(out);\n+      }\n+    }\n+    ss.print_cr(\"Non-unique output of expected type. Found: %d.\", outputs_of_correct_type.size());\n+#ifndef PRODUCT\n+    for (uint i = 0; i < outputs_of_correct_type.size(); ++i) {\n+      outputs_of_correct_type.at(i)->dump(\"\\n\", false, &ss);\n+    }\n+#endif\n+    return false;\n+  }\n+\n+  bool result = _pattern->match(single_output_of_right_type, path, ss);\n+  if (!result) {\n+    path.add_output_step(single_output_of_right_type);\n+  }\n+  return result;\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/opto\/pattern.cpp","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OPTO_PATTERN_HPP\n+#define SHARE_OPTO_PATTERN_HPP\n+\n+#include \"metaprogramming\/enableIf.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"opto\/node.hpp\"\n+\n+\/* A path in the graph from a center, for pretty reporting.\n+ * Given a list of nodes\n+ * center = N0 --[r1]--> ... --[rk]-> Nk\n+ * where the ri are the relation between consecutive nodes: either p-th input, or an output,\n+ * then:\n+ * - steps must have length k + 1, and contain Nk ... N0\n+ * - path must have length k, and contain rk ... r1 where ri is:\n+ *   - a non-negative integer p for each step such that N{i-1} has Ni as p-th input (we need to follow an input edge)\n+ *   - the OutputStep value in case N{i-1} has Ni as an output (we need to follow an output edge)\n+ * The lists are reversed to allow to easily fill them lazily on failure: as we backtrack in the pattern\n+ * structure, we add the path bottom-up, finishing by the center.\n+ *\/\n+struct PathInGraph {\n+  \/* When an invariant applied at a given node (the center) goes wrong at another\n+   * node, it is useful to show the path we took between them. OutputStep is used\n+   * to signify that a node is the output of the previous one in the path.\n+   * See LocalGraphInvariant::check for more details on paths.\n+   *\/\n+  static constexpr int OutputStep = -1;\n+\n+  void finalize(Node* center);\n+  void add_input_step(uint input_index, Node* input);\n+  void add_output_step(Node* output);\n+\n+  const Node_List& nodes() const { return _nodes; }\n+  const GrowableArray<int>& relation_to_previous_node() const { return _relation_to_previous_node; }\n+\n+private:\n+  Node_List _nodes;\n+  GrowableArray<int> _relation_to_previous_node;\n+};\n+\n+\/* A base class for checks expressed as data. Patterns are supposed to be local, centered around one node\n+ * and compositional to express complex structures from simple properties.\n+ * For instance, we have a pattern for saying \"match P on the first input of the center\" where P is another\n+ * Pattern. We end up with trees of patterns matching against the graph.\n+ *\/\n+struct Pattern : ResourceObj {\n+  typedef bool (Node::*TypeCheckMethod)() const;\n+  \/* Check whether the graph and the pattern matches. Returns false in case\n+   * of failure.\n+   * center: where to around which node to check whether the pattern matches\n+   * path: in case of failure, path to the place where the failure happened.\n+   *   Must be filled from the offending node to the original center, which allows\n+   *   to compute the path lazily.\n+   * ss: in case of failure, to fill with error description.\n+   *\n+   * In case of success, path and ss must not be changed.\n+   *\/\n+  virtual bool match(const Node* center, PathInGraph& path, stringStream& ss) const = 0;\n+};\n+\n+\/* This pattern just accepts any node. This is convenient mostly as leaf in a pattern tree.\n+ * For instance `AtSingleOutputOfType(..., new TruePattern())` will make sure there is\n+ * indeed a single output of the given type, but won't enforce anything on the said output.\n+ *\/\n+struct TruePattern : Pattern {\n+  bool match(const Node*, PathInGraph&, stringStream&) const override {\n+    return true;\n+  }\n+};\n+\n+\/* This is semantically equivalent to `TruePattern` but will set the given reference to the node\n+ * the pattern is matched against. This is useful to perform additional checks that would\n+ * otherwise be hard or impossible to express as local patterns.\n+ *\n+ * For instance, one could write\n+ * Node* first, second;\n+ * And::make(\n+ *   new AtInput(0, new Bind(first)),\n+ *   new AtInput(1, new Bind(second))\n+ * );\n+ * [...] \/\/ run the pattern\n+ * if (first == second) { \/\/ checking whether they are the same node\n+ *\n+ * Bindings are only honored if the overall pattern succeeds. Otherwise, don't assume anything reasonable\n+ * has been set. Anyway, you don't need it: you already know it doesn't have the right shape.\n+ *\/\n+struct Bind : Pattern {\n+  explicit Bind(const Node*& binding) : _binding(binding) {}\n+  bool match(const Node* center, PathInGraph&, stringStream&) const override;\n+\n+private:\n+  const Node*& _binding;\n+};\n+\n+\/* A more type-safe version of `Bind` mostly to use with NodeClassIsAndBind macro defined later\n+ *\/\n+template <typename N, ENABLE_IF(std::is_base_of<Node, N>::value)>\n+struct TypedBind : Pattern {\n+  explicit TypedBind(const N*& binding) : _binding(binding) {}\n+  bool match(const Node* center, PathInGraph&, stringStream&) const override {\n+    _binding = static_cast<const N*>(center);\n+    return true;\n+  }\n+\n+private:\n+  const N*& _binding;\n+};\n+\n+\/* Check a node has the right type (as which C++ class, not as abstract value). Typically used with\n+ * is_XXXNode methods.\n+ *\/\n+struct NodeClass : Pattern {\n+  explicit NodeClass(const TypeCheckMethod type_check) : _type_check(type_check) {}\n+  bool match(const Node* center, PathInGraph& path, stringStream& ss) const override;\n+\n+private:\n+  const TypeCheckMethod _type_check;\n+};\n+\n+\/* To check the kind of a node and bind it to a variable of the right type.\n+ * For instance:\n+ *   const RegionNode* r;\n+ *   NodeClassIsAndBind(Region, r)\n+ *\/\n+#define NodeClassIsAndBind(node_type, binding) \\\n+  And::make(                                   \\\n+      new NodeClass(&Node::is_##node_type),    \\\n+      new TypedBind<node_type##Node>(binding))\n+\n+\/* Matches multiple patterns at the same node.\n+ *\n+ * Evaluation order is guaranteed to be left-to-right. That is needed, for instance, to check\n+ * that a node has enough inputs before using `AtInput`, since `AtInput` won't fail gracefully\n+ * if the number of input is too low. E.g. if you know a node has 3 inputs and want patterns\n+ * to be applied to each input, it would look like\n+ * And::make(\n+ *    new HasExactlyNInputs(3),\n+ *    new AtInput(0, P0),\n+ *    new AtInput(1, P1),\n+ *    new AtInput(2, P2),\n+ * )\n+ * If we relied on `AtInput` to report too few inputs, it would give confusing error messages as\n+ * the first `AtInput` can only know it expects at least one input, and seeing the message\n+ * \"Found 0 inputs, expected at least 1\" is not very helpful, potentially confusing since it doesn't\n+ * state what is actually expected: 3 inputs.\n+ * It also is not able to express that a node has exactly a given number of inputs, and it is a\n+ * significant difference whether we expect AT LEAST 3 inputs, or EXACTLY 3 inputs. Let's make\n+ * things precise.\n+ * Overall, to get better reporting, `AtInput` is not expected to check the input count, and the\n+ * user is responsible for it, making the guarantee on the evaluation order of `And` necessary.\n+ *\n+ * The evaluation order can also allow you to check easier properties before harder ones: it's\n+ * nicer if you get a simpler error message, with shorter paths. It's also easier to read as C++\n+ * expressions when indentation is not going back and forth.\n+ *\/\n+struct And : Pattern {\n+private:\n+  GrowableArray<Pattern*> _checks;\n+  template <typename... PP>\n+  static void make_helper(And* a, Pattern* pattern, PP... others) {\n+    a->_checks.push(pattern);\n+    make_helper(a, others...);\n+  }\n+  static void make_helper(And*) {}\n+\n+public:\n+  template <typename... PP>\n+  static And* make(PP... patterns) {\n+    And* andd = new And();\n+    make_helper(andd, patterns...);\n+    return andd;\n+  }\n+\n+  bool match(const Node* center, PathInGraph& path, stringStream& ss) const override;\n+};\n+\n+struct HasExactlyNInputs : Pattern {\n+  explicit HasExactlyNInputs(uint expect_req) : _expect_req(expect_req) {}\n+  bool match(const Node* center, PathInGraph& path, stringStream& ss) const override;\n+\n+private:\n+  const uint _expect_req;\n+};\n+\n+struct HasAtLeastNInputs : Pattern {\n+  explicit HasAtLeastNInputs(uint expect_req) : _expect_req(expect_req) {}\n+  bool match(const Node* center, PathInGraph& path, stringStream& ss) const override;\n+\n+private:\n+  const uint _expect_req;\n+};\n+\n+\/* Check that a given pattern applies at the given input of the center.\n+ *\n+ * As explained above, it doesn't check (nicely) that inputs are in sufficient numbers.\n+ * Use HasExactlyNInputs or HasAtLeastNInputs for that.\n+ *\/\n+struct AtInput : Pattern {\n+  AtInput(uint which_input, const Pattern* pattern) : _which_input(which_input), _pattern(pattern) {}\n+  bool match(const Node* center, PathInGraph& path, stringStream& ss) const override;\n+\n+private:\n+  const uint _which_input;\n+  const Pattern* const _pattern;\n+};\n+\n+struct HasNOutputs : Pattern {\n+  explicit HasNOutputs(uint expect_outcnt) : _expect_outcnt(expect_outcnt) {}\n+  bool match(const Node* center, PathInGraph& path, stringStream& ss) const override;\n+\n+private:\n+  const uint _expect_outcnt;\n+};\n+\n+\/* Given a is_XXXNode method pointer and a pattern P, this pattern checks that\n+ * - only one output has the given type XXX\n+ * - this one output matches P.\n+ *\n+ * Since outputs are not numbered, this is a convenient way to walk on the graph in the Def-Use direction.\n+ *\/\n+struct AtSingleOutputOfType : Pattern {\n+  AtSingleOutputOfType(const TypeCheckMethod type_check, const Pattern* pattern) : _type_check(type_check), _pattern(pattern) {}\n+  bool match(const Node* center, PathInGraph& path, stringStream& ss) const override;\n+\n+private:\n+  const TypeCheckMethod _type_check;\n+  const Pattern* const _pattern;\n+};\n+\n+#endif \/\/ SHARE_OPTO_PATTERN_HPP\n","filename":"src\/hotspot\/share\/opto\/pattern.hpp","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"}]}