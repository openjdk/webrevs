{"files":[{"patch":"@@ -706,0 +706,3 @@\n+  develop(bool, VerifyIdealGraph, false,                                    \\\n+          \"Check structural invariants of the ideal graph\")                 \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#include \"opto\/graphInvariants.hpp\"\n@@ -700,1 +701,2 @@\n-      _in_dump_cnt(0)\n+      _in_dump_cnt(0),\n+      _invariant_checker(GraphInvariantChecker::make_default())\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+class GraphInvariantChecker;\n@@ -1317,0 +1318,2 @@\n+\n+  NOT_PRODUCT(GraphInvariantChecker* _invariant_checker;)\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,566 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"opto\/graphInvariants.hpp\"\n+#include \"opto\/rootnode.hpp\"\n+\n+#ifndef PRODUCT\n+\n+void LocalGraphInvariant::LazyReachableCFGNodes::compute() {\n+  precond(_reachable_nodes.size() == 0);\n+\n+  \/\/ We should have at least root, so we are sure it's not filled yet.\n+  _reachable_nodes.push(Compile::current()->root());\n+  for (uint i = 0; i < _reachable_nodes.size(); ++i) {\n+    Node* n = _reachable_nodes.at(i);\n+    for (DUIterator_Fast jmax, j = n->fast_outs(jmax); j < jmax; j++) {\n+      Node* out = n->fast_out(j);\n+      if (out->is_CFG()) {\n+        _reachable_nodes.push(out);\n+      }\n+    }\n+  }\n+\n+  postcond(_reachable_nodes.size() > 0);\n+}\n+\n+bool LocalGraphInvariant::LazyReachableCFGNodes::is_node_dead(const Node* n) {\n+  if (_reachable_nodes.size() == 0) {\n+    compute();\n+  }\n+  assert(_reachable_nodes.size() > 0, \"filling failed\");\n+  return !_reachable_nodes.member(n);\n+}\n+\n+\/* A base for local invariants that mostly work using a pattern.\n+ *\/\n+struct PatternBasedCheck : LocalGraphInvariant {\n+  explicit PatternBasedCheck(const char* name, const Pattern* pattern) : _name(name), _pattern(pattern) {}\n+\n+  const char* name() const override {\n+    return _name;\n+  }\n+\n+  bool run_pattern(const Node* center, PathInGraph& path, stringStream& ss) const {\n+    return _pattern->match(center, path, ss);\n+  }\n+\n+private:\n+  const char* _name;\n+  const Pattern* const _pattern;\n+};\n+\n+struct CheckHelper {\n+  static CheckHelper for_reachable_center(const PatternBasedCheck* check, const Node* center, LocalGraphInvariant::LazyReachableCFGNodes& reachable_cfg_nodes, PathInGraph& path, stringStream& ss) {\n+    return CheckHelper(check, center, &reachable_cfg_nodes, path, ss);\n+  }\n+  static CheckHelper for_any_center(const PatternBasedCheck* check, const Node* center, PathInGraph& path, stringStream& ss) {\n+    return CheckHelper(check, center, nullptr, path, ss);\n+  }\n+  CheckHelper& applies_if_center(bool (Node::*type_check)() const) {\n+    if (!(_center->*type_check)()) {\n+      _result = CheckHelperResult::NOT_APPLICABLE;\n+    }\n+    return *this;\n+  }\n+  template <typename F>\n+  CheckHelper& applies_if_center(F f) {\n+    if (!f(*_center)) {\n+      _result = CheckHelperResult::NOT_APPLICABLE;\n+    }\n+    return *this;\n+  }\n+  CheckHelper& run_pattern() {\n+    if (_result == CheckHelperResult::UNKNOWN) {\n+      if (_check.run_pattern(_center, _path, _ss)) {\n+        _result = CheckHelperResult::VALID;\n+      } else {\n+        if (_reachable_cfg_nodes == nullptr) {\n+          _result = CheckHelperResult::FAILED;\n+        } else if (_reachable_cfg_nodes->is_node_dead(_center)) {\n+          _ss.reset();\n+          _path.clear();\n+          _result = CheckHelperResult::VALID;\n+        } else {\n+          _result = CheckHelperResult::FAILED;\n+        }\n+      }\n+    }\n+    return *this;\n+  }\n+  template <typename Fun>\n+  CheckHelper& on_success_require(Fun fun) {\n+    if (_result == CheckHelperResult::VALID) {\n+      if (!fun()) {\n+        _result = CheckHelperResult::FAILED;\n+      }\n+    }\n+    return *this;\n+  }\n+  LocalGraphInvariant::CheckResult to_result() const {\n+    switch (_result) {\n+    case CheckHelperResult::VALID:\n+      return LocalGraphInvariant::CheckResult::VALID;\n+    case CheckHelperResult::FAILED:\n+      return LocalGraphInvariant::CheckResult::FAILED;\n+    case CheckHelperResult::NOT_APPLICABLE:\n+      return LocalGraphInvariant::CheckResult::NOT_APPLICABLE;\n+    case CheckHelperResult::UNKNOWN:\n+      assert(false, \"Should have decided before!\");\n+      return LocalGraphInvariant::CheckResult::FAILED;\n+    default:\n+      ShouldNotReachHere();\n+      return LocalGraphInvariant::CheckResult::FAILED;\n+    }\n+  }\n+\n+private:\n+  CheckHelper(const PatternBasedCheck* check, const Node* center, LocalGraphInvariant::LazyReachableCFGNodes* reachable_cfg_nodes, PathInGraph& path, stringStream& ss)\n+      : _check(*check),\n+        _center(center),\n+        _reachable_cfg_nodes(reachable_cfg_nodes),\n+        _path(path),\n+        _ss(ss) {}\n+\n+  const PatternBasedCheck& _check;\n+  const Node* _center;\n+  LocalGraphInvariant::LazyReachableCFGNodes* _reachable_cfg_nodes;  \/\/ Non nullptr iff the check applies only to reachable nodes.\n+  PathInGraph& _path;\n+  stringStream& _ss;\n+\n+  enum class CheckHelperResult {\n+    VALID,\n+    FAILED,\n+    NOT_APPLICABLE,\n+    UNKNOWN,\n+  };\n+\n+  CheckHelperResult _result = CheckHelperResult::UNKNOWN;\n+};\n+\n+\/* Checks that If Nodes have exactly 2 outputs: IfTrue and IfFalse\n+ *\/\n+struct IfProjections : PatternBasedCheck {\n+  IfProjections()\n+      : PatternBasedCheck(\n+            \"IfProjections\",\n+            And::make(\n+                new HasNOutputs(2),\n+                new AtSingleOutputOfType(&Node::is_IfTrue, new TruePattern()),\n+                new AtSingleOutputOfType(&Node::is_IfFalse, new TruePattern()))) {\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, PathInGraph& path, stringStream& ss) const override {\n+    return CheckHelper::for_reachable_center(this, center, reachable_cfg_nodes, path, ss)\n+        .applies_if_center(&Node::is_If)\n+        .run_pattern()\n+        .to_result();\n+  }\n+};\n+\n+\/* Check that Phi has a Region as first input, and consistent arity\n+ *\/\n+struct PhiArity : PatternBasedCheck {\n+private:\n+  const RegionNode* _region_node = nullptr;\n+\n+public:\n+  PhiArity()\n+      : PatternBasedCheck(\n+            \"PhiArity\",\n+            And::make(\n+                new HasAtLeastNInputs(2),\n+                new AtInput(\n+                    0,\n+                    NodeClassIsAndBind(Region, _region_node)))) {\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes&, PathInGraph& path, stringStream& ss) const override {\n+    return CheckHelper::for_any_center(this, center, path, ss)\n+        .applies_if_center(&Node::is_Phi)\n+        .run_pattern()\n+        .on_success_require([&]() -> bool {\n+          assert(_region_node != nullptr, \"sanity\");\n+          if (_region_node->req() != center->req()) {\n+            ss.print_cr(\"Phi nodes must have the same arity as their Region node. Phi arity: %d; Region arity: %d.\", center->req(), _region_node->req());\n+            return false;\n+          }\n+          return true;\n+        })\n+        .to_result();\n+  }\n+};\n+\n+\/* Make sure each control node has the right amount of control successors: that is 1 for most cases, 2 for If nodes...\n+ *\/\n+struct ControlSuccessor : LocalGraphInvariant {\n+  const char* name() const override {\n+    return \"ControlSuccessor\";\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, PathInGraph& path, stringStream& ss) const override {\n+    if (!center->is_CFG()) {\n+      return CheckResult::NOT_APPLICABLE;\n+    }\n+\n+    ResourceMark rm;\n+    Node_List ctrl_succ;\n+    for (DUIterator_Fast imax, i = center->fast_outs(imax); i < imax; i++) {\n+      Node* out = center->fast_out(i);\n+      if (out->is_CFG()) {\n+        ctrl_succ.push(out);\n+      }\n+    }\n+\n+    const uint cfg_out = ctrl_succ.size();\n+\n+    if (center->is_If() || center->is_Start() || center->is_Root() || center->is_Region() || center->is_NeverBranch()) {\n+      if (cfg_out != 2) {\n+        if (reachable_cfg_nodes.is_node_dead(center)) {\n+          \/\/ That's ok for dead nodes right now. It might be too expensive to collect for IGVN, but it will be removed in loop opts.\n+          return CheckResult::VALID;\n+        }\n+        ss.print_cr(\"%s node must have exactly two control successors. Found %d.\", center->Name(), cfg_out);\n+        print_node_list(ctrl_succ, ss);\n+        return CheckResult::FAILED;\n+      }\n+    } else if (center->Opcode() == Op_SafePoint) {\n+      if (cfg_out < 1 || cfg_out > 2) {\n+        ss.print_cr(\"%s node must have one or two control successors. Found %d.\", center->Name(), cfg_out);\n+        print_node_list(ctrl_succ, ss);\n+        return CheckResult::FAILED;\n+      }\n+      if (cfg_out == 2) {\n+        if (!ctrl_succ.at(0)->is_Root() && !ctrl_succ.at(1)->is_Root()) {\n+          ss.print_cr(\"One of the two control outputs of a %s node must be Root.\", center->Name());\n+          print_node_list(ctrl_succ, ss);\n+          return CheckResult::FAILED;\n+        }\n+      }\n+    } else if (center->is_PCTable()) {\n+      if (cfg_out < 1) {\n+        ss.print_cr(\"%s node must have at least one control successors. Found %d.\", center->Name(), cfg_out);\n+        return CheckResult::FAILED;\n+      }\n+    } else {\n+      if (cfg_out != 1) {\n+        ss.print_cr(\"Ordinary CFG nodes must have exactly one successor. Found %d.\", cfg_out);\n+        print_node_list(ctrl_succ, ss);\n+        return CheckResult::FAILED;\n+      }\n+    }\n+\n+    return CheckResult::VALID;\n+  }\n+\n+private:\n+  static void print_node_list(const Node_List& ctrl_succ, stringStream& ss) {\n+    for (uint i = 0; i < ctrl_succ.size(); ++i) {\n+      ss.print(\"  \");\n+      ctrl_succ.at(i)->dump(\"\\n\", false, &ss);\n+    }\n+  }\n+};\n+\n+\/* Checks that Region, Start and Root nodes' first input is a self loop, except for copy regions, which then must have only one non null input.\n+ *\/\n+struct SelfLoopInvariant : LocalGraphInvariant {\n+  const char* name() const override {\n+    return \"RegionSelfLoop\";\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, PathInGraph& path, stringStream& ss) const override {\n+    if (!center->is_Region() && !center->is_Start() && !center->is_Root()) {\n+      return CheckResult::NOT_APPLICABLE;\n+    }\n+\n+    if (center->req() == 0) {\n+      ss.print_cr(\"%s nodes must have at least one input.\", center->Name());\n+      return CheckResult::FAILED;\n+    }\n+\n+    Node* self = center->in(LoopNode::Self);\n+\n+    if (self != center || (center->is_Region() && self == nullptr)) {\n+      ss.print_cr(\"%s nodes' 0-th input must be itself or nullptr (for a copy Region).\", center->Name());\n+      return CheckResult::FAILED;\n+    }\n+\n+    if (self == nullptr) {\n+      \/\/ Must be a copy Region\n+      uint non_null_inputs_count = 0;\n+      for (uint i = 0; i < center->req(); i++) {\n+        if (center->in(i) != nullptr) {\n+          non_null_inputs_count++;\n+        }\n+      }\n+      if (non_null_inputs_count != 1) {\n+        \/\/ Should be a rare case, hence the second (but more expensive) traversal.\n+        ResourceMark rm;\n+        Node_List non_null_inputs;\n+        for (uint i = 0; i < center->req(); i++) {\n+          if (center->in(i) != nullptr) {\n+            non_null_inputs.push(center->in(i));\n+          }\n+        }\n+        if (non_null_inputs.size() != 1) {\n+          ss.print_cr(\"%s copy nodes must have exactly one non-null input. Found: %d.\", center->Name(), non_null_inputs.size());\n+          for (uint i = 0; i < non_null_inputs.size(); ++i) {\n+            non_null_inputs.at(i)->dump(\"\\n\", false, &ss);\n+          }\n+          return CheckResult::FAILED;\n+        }\n+      }\n+    }\n+\n+    return CheckResult::VALID;\n+  }\n+};\n+\n+\/\/ CountedLoopEnd -> IfTrue -> CountedLoop[center]\n+struct CountedLoopInvariants : PatternBasedCheck {\n+private:\n+  const BaseCountedLoopEndNode* _counted_loop_end = nullptr;\n+\n+public:\n+  CountedLoopInvariants()\n+      : PatternBasedCheck(\n+            \"CountedLoopInvariants\",\n+            And::make(\n+                new HasExactlyNInputs(3),\n+                new AtInput(\n+                    LoopNode::LoopBackControl,\n+                    And::make(\n+                        new NodeClass(&Node::is_IfTrue),\n+                        new HasExactlyNInputs(1),\n+                        new AtInput(\n+                            0,\n+                            NodeClassIsAndBind(BaseCountedLoopEnd, _counted_loop_end)))))) {}\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, PathInGraph& path, stringStream& ss) const override {\n+    return CheckHelper::for_any_center(this, center, path, ss)\n+        .applies_if_center(&Node::is_BaseCountedLoop)\n+        .run_pattern()\n+        .on_success_require([&]() {\n+          assert(_counted_loop_end != nullptr, \"sanity\");\n+          if (center->is_LongCountedLoop()) {\n+            if (!_counted_loop_end->is_LongCountedLoopEnd()) {\n+              assert(_counted_loop_end->is_CountedLoopEnd(), \"Update the error message or add cases\");\n+              ss.print_cr(\"A CountedLoopEnd is the backedge of a LongCountedLoop.\");\n+              return false;\n+            }\n+          } else {\n+            if (!_counted_loop_end->is_CountedLoopEnd()) {\n+              assert(_counted_loop_end->is_LongCountedLoopEnd(), \"Update the error message or add cases\");\n+              ss.print_cr(\"A LongCountedLoopEnd is the backedge of a CountedLoop.\");\n+              return false;\n+            }\n+          }\n+          return true;\n+        })\n+        .to_result();\n+  }\n+};\n+\n+\/\/ CountedLoopEnd -> IfFalse -> SafePoint -> OuterStripMinedLoopEnd[center] -> IfTrue -> OuterStripMinedLoop -> CountedLoop\n+\/\/               \\-> IfTrue  ->                                                                              \/\n+struct OuterStripMinedLoopInvariants : PatternBasedCheck {\n+private:\n+  const CountedLoopNode* _counted_loop_from_outer_strip_mined_loop;\n+  const CountedLoopNode* _counted_loop_from_backedge;\n+\n+public:\n+  OuterStripMinedLoopInvariants()\n+      : PatternBasedCheck(\n+            \"OuterStripMinedLoopInvariants\",\n+            And::make(\n+                new HasExactlyNInputs(2),\n+                new AtInput(\n+                    0,\n+                    And::make(\n+                        new NodeClass(&Node::is_SafePoint),\n+                        new HasAtLeastNInputs(1),\n+                        new AtInput(\n+                            0,\n+                            And::make(\n+                                new NodeClass(&Node::is_IfFalse),\n+                                new HasAtLeastNInputs(1),\n+                                new AtInput(\n+                                    0,\n+                                    And::make(\n+                                        new NodeClass(&Node::is_CountedLoopEnd),\n+                                        new AtSingleOutputOfType(\n+                                            &Node::is_IfTrue,\n+                                            new AtSingleOutputOfType(\n+                                                &Node::is_CountedLoop,\n+                                                new TypedBind<CountedLoopNode>(_counted_loop_from_backedge))))))))),\n+                new AtSingleOutputOfType(\n+                    &Node::is_IfTrue,\n+                    new AtSingleOutputOfType(\n+                        &Node::is_OuterStripMinedLoop,\n+                        new AtSingleOutputOfType(\n+                            &Node::is_CountedLoop,\n+                            new TypedBind<CountedLoopNode>(_counted_loop_from_outer_strip_mined_loop)))))) {}\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, PathInGraph& path, stringStream& ss) const override {\n+    return CheckHelper::for_any_center(this, center, path, ss)\n+        .applies_if_center(&Node::is_OuterStripMinedLoopEnd)\n+        .run_pattern()\n+        .on_success_require([&]() {\n+          assert(_counted_loop_from_backedge != nullptr, \"sanity\");\n+          assert(_counted_loop_from_outer_strip_mined_loop != nullptr, \"sanity\");\n+          bool same_counted_loop = _counted_loop_from_backedge == _counted_loop_from_outer_strip_mined_loop;\n+          if (!same_counted_loop) {\n+            ss.print_cr(\"Found different counted loop from backedge and from output of OuterStripMinedLoop.\");\n+            ss.print_cr(\"From backedge:\");\n+            _counted_loop_from_backedge->dump(\"\\n\", false, &ss);\n+            ss.print_cr(\"From OuterStripMinedLoop:\");\n+            _counted_loop_from_outer_strip_mined_loop->dump(\"\\n\", false, &ss);\n+          }\n+          return same_counted_loop;\n+        })\n+        .to_result();\n+  }\n+};\n+\n+struct MultiBranchNodeOut : LocalGraphInvariant {\n+  const char* name() const override {\n+    return \"MultiBranchNodeOut\";\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, PathInGraph& path, stringStream& ss) const override {\n+    if (!center->is_MultiBranch()) {\n+      return CheckResult::NOT_APPLICABLE;\n+    }\n+\n+    MultiBranchNode* mb = center->as_MultiBranch();\n+    if (mb->required_outcnt() < static_cast<int>(mb->outcnt())) {\n+      ss.print_cr(\"The required_outcnt of a MultiBranch node must be smaller than or equal to its outcnt. But required_outcnt=%d vs. outcnt=%d\", mb->required_outcnt(), mb->outcnt());\n+      return CheckResult::FAILED;\n+    }\n+\n+    return CheckResult::VALID;\n+  }\n+};\n+\n+GraphInvariantChecker* GraphInvariantChecker::make_default() {\n+  auto* checker = new GraphInvariantChecker();\n+#define ADD_CHECKER(T) checker->_checks.push(new T())\n+  ADD_CHECKER(IfProjections);\n+  ADD_CHECKER(PhiArity);\n+  ADD_CHECKER(ControlSuccessor);\n+  ADD_CHECKER(SelfLoopInvariant);\n+  ADD_CHECKER(CountedLoopInvariants);\n+  ADD_CHECKER(OuterStripMinedLoopInvariants);\n+  ADD_CHECKER(MultiBranchNodeOut);\n+#undef ADD_CHECKER\n+  return checker;\n+}\n+\n+void GraphInvariantChecker::print_path(const PathInGraph& path, stringStream& ss) {\n+  const GrowableArray<int>& relation_to_previous_node = path.relation_to_previous_node();\n+  const int path_len = relation_to_previous_node.length();\n+  const Node_List& nodes = path.nodes();\n+  precond(nodes.size() == static_cast<uint>(path_len) + 1);\n+  if (path_len == 0) {\n+    ss.print_cr(\"At center node\");\n+    nodes.at(0)->dump(\"\\n\", false, &ss);\n+    return;\n+  }\n+  ss.print(\"At node\\n   \");\n+  nodes.at(0)->dump(\"\\n\", false, &ss);\n+  ss.print_cr(\"  From path:\");\n+  ss.print(\"    [center]\");\n+  nodes.at(path_len)->dump(\"\\n\", false, &ss);\n+  for (int i = 0; i < path_len; ++i) {\n+    if (relation_to_previous_node.at(path_len - i - 1) >= 0) {\n+      \/\/ It's an input\n+      int input_nb = relation_to_previous_node.at(path_len - i - 1);\n+      if (input_nb <= 9) {\n+        ss.print(\" \");\n+      }\n+      ss.print(\"     <-(%d)-\", input_nb);\n+\n+    } else if (relation_to_previous_node.at(path_len - i - 1) == PathInGraph::OutputStep) {\n+      \/\/ It's an output\n+      ss.print(\"         -->\");\n+    } else {\n+      ss.print(\"         ???\");\n+    }\n+    nodes.at(path_len - i - 1)->dump(\"\\n\", false, &ss);\n+  }\n+}\n+\n+bool GraphInvariantChecker::run() const {\n+  if (_checks.is_empty()) {\n+    return true;\n+  }\n+\n+  ResourceMark rm;\n+  Unique_Node_List worklist;\n+  worklist.push(Compile::current()->root());\n+  stringStream ss;\n+  stringStream ss2;\n+  \/\/ Sometimes, we get weird structures in dead code that will be cleaned up later. It typically happens\n+  \/\/ when data dies, but control is not cleaned up right away, possibly kept alive by an unreachable loop.\n+  \/\/ Since we don't want to eagerly traverse the whole graph to remove dead code in IGVN, we can accept\n+  \/\/ weird structures in dead code.\n+  \/\/ For CFG-related errors, we will compute the set of reachable CFG nodes and decide whether to keep\n+  \/\/ the issue if the problematic node is reachable. This set of reachable nodes is thus computed lazily\n+  \/\/ (and it seems not to happen often in practice), and shared across checks.\n+  LocalGraphInvariant::LazyReachableCFGNodes reachable_cfg_nodes;\n+  bool success = true;\n+\n+  for (uint i = 0; i < worklist.size(); ++i) {\n+    Node* center = worklist.at(i);\n+    for (uint j = 0; j < center->req(); ++j) {\n+      Node* in = center->in(j);\n+      if (in != nullptr) {\n+        worklist.push(in);\n+      }\n+    }\n+    uint failures = 0;\n+    for (int j = 0; j < _checks.length(); ++j) {\n+      PathInGraph path;\n+      switch (_checks.at(j)->check(center, reachable_cfg_nodes, path, ss2)) {\n+      case LocalGraphInvariant::CheckResult::FAILED:\n+        failures++;\n+        path.finalize(center);\n+        print_path(path, ss);\n+        ss.print_cr(\"# %s:\", _checks.at(j)->name());\n+        ss.print_cr(\"%s\", ss2.base());\n+        ss2.reset();\n+        break;\n+      case LocalGraphInvariant::CheckResult::NOT_APPLICABLE:\n+      case LocalGraphInvariant::CheckResult::VALID:\n+        break;\n+      }\n+    }\n+    if (failures > 0) {\n+      success = false;\n+      stringStream ss3;\n+      ss3.print(\"%d failure%s for node\\n\", failures, failures == 1 ? \"\" : \"s\");\n+      center->dump(\"\\n\", false, &ss3);\n+      ss3.print_cr(\"%s\", ss.base());\n+      tty->print(\"%s\", ss3.base());\n+      ss.reset();\n+    }\n+  }\n+\n+  return success;\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/graphInvariants.cpp","additions":566,"deletions":0,"binary":false,"changes":566,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OPTO_GRAPHINVARIANTS_HPP\n+#define SHARE_OPTO_GRAPHINVARIANTS_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"opto\/node.hpp\"\n+#include \"opto\/pattern.hpp\"\n+\n+#ifndef PRODUCT\n+\/\/ An invariant that needs only a local view of the graph, around a given node.\n+class LocalGraphInvariant : public ResourceObj {\n+public:\n+  \/\/ See LocalGraphInvariant::check why we need that.\n+  struct LazyReachableCFGNodes {\n+    bool is_node_dead(const Node*);\n+  private:\n+    void compute();\n+    Unique_Node_List _reachable_nodes;\n+  };\n+\n+  enum class CheckResult {\n+    VALID,          \/\/ The check applies, and it is satisfied on the given center\n+    FAILED,         \/\/ The check applies, but finds that the invariant is broken\n+    NOT_APPLICABLE, \/\/ The check has no opinion on the given center\n+  };\n+\n+  \/\/ For reporting\n+  virtual const char* name() const = 0;\n+\n+  \/* Check whether the invariant is true around the node [center].\n+   *\n+   * If the check fails steps and path must be filled with the path from the center to the failing node (where it's relevant to\n+   * show), in reverse order (for filling lazily on failures).\n+   * In addition, if the check fails, it must write its error message in [ss].\n+   *\n+   * If the check succeeds or is not applicable, [path] and [ss] must be untouched.\n+   *\n+   * The parameter [live_nodes] is used to share the lazily computed set of CFG nodes reachable from root. This is because some\n+   * checks don't apply to dead code, and we want to suppress their error if a violation is detected in dead code. Since it's\n+   * rather unlikely to have such a violation (they are rare overall), and then we won't need to check whether a node is dead,\n+   * it's better to have this set lazy.\n+   *\/\n+  virtual CheckResult check(const Node* center, LazyReachableCFGNodes& live_nodes, PathInGraph& path, stringStream& ss) const = 0;\n+};\n+\n+\/* Checks structural invariants of the graph connected to the root.\n+ *\n+ * The checker itself is not node or graph dependent and can be used\n+ * on any graph, to save memory: one allocation is enough!\n+ *\n+ * Local invariants are checked on each node of the graph: the check\n+ * is overall failing if any invariant doesn't hold on any node.\n+ *\n+ * It currently only checks local invariants, but it could be extended\n+ * to global ones.\n+ *\/\n+class GraphInvariantChecker : public ResourceObj {\n+  GrowableArray<const LocalGraphInvariant*> _checks;\n+\n+public:\n+  static GraphInvariantChecker* make_default();\n+\n+  \/\/ See LocalGraphInvariant::check for the requirements on the arguments.\n+  \/\/ Fills parameter [ss] with pretty print of the path.\n+  static void print_path(const PathInGraph& path, stringStream& ss);\n+  bool run() const;\n+};\n+#endif\n+\n+#endif \/\/ SHARE_OPTO_GRAPHINVARIANTS_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/opto\/graphInvariants.hpp","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"pattern.hpp\"\n+\n+constexpr int PathInGraph::OutputStep;\n+\n+void PathInGraph::finalize(Node* center) {\n+  _nodes.push(center);\n+}\n+\n+void PathInGraph::add_input_step(uint input_index, Node* input) {\n+  _nodes.push(input);\n+  _relation_to_previous_node.push(static_cast<int>(input_index));\n+}\n+\n+void PathInGraph::add_output_step(Node* output) {\n+  _nodes.push(output);\n+  _relation_to_previous_node.push(static_cast<int>(OutputStep));\n+}\n+\n+void PathInGraph::clear() {\n+  _nodes.clear();\n+  _relation_to_previous_node.clear();\n+}\n+\n+bool Bind::match(const Node* center) const {\n+  _binding = center;\n+  return true;\n+}\n+\n+#ifndef PRODUCT\n+bool Bind::match(const Node* center, PathInGraph&, stringStream&) const {\n+  return match(center);\n+}\n+#endif\n+\n+bool And::match(const Node* center) const {\n+  for (int i = 0; i < _checks.length(); ++i) {\n+    if (!_checks.at(i)->match(center)) {\n+      \/\/ We stay on the same center, so no need to update path.\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+#ifndef PRODUCT\n+bool And::match(const Node* center, PathInGraph& path, stringStream& ss) const {\n+  for (int i = 0; i < _checks.length(); ++i) {\n+    if (!_checks.at(i)->match(center, path, ss)) {\n+      \/\/ We stay on the same center, so no need to update path.\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+#endif\n+\n+bool HasExactlyNInputs::match(const Node* center) const {\n+  return center->req() == _expect_req;\n+}\n+\n+bool HasAtLeastNInputs::match(const Node* center) const {\n+  return center->req() >= _expect_req;\n+}\n+\n+#ifndef PRODUCT\n+void print_list_of_inputs(const Node* center, stringStream& ss) {\n+  for (uint i = 0; i < center->req(); ++i) {\n+    Node* in = center->in(i);\n+    ss.print(\"  %d: \", i);\n+    if (in == nullptr) {\n+      ss.print_cr(\"nullptr\");\n+    } else {\n+      in->dump(\"\\n\", false, &ss);\n+    }\n+  }\n+}\n+\n+bool HasExactlyNInputs::match(const Node* center, PathInGraph& path, stringStream& ss) const {\n+  if (center->req() != _expect_req) {\n+    ss.print_cr(\"Unexpected number of inputs. Expected exactly: %d. Found: %d\", _expect_req, center->req());\n+    print_list_of_inputs(center, ss);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+bool HasAtLeastNInputs::match(const Node* center, PathInGraph& path, stringStream& ss) const {\n+  if (center->req() < _expect_req) {\n+    ss.print_cr(\"Too few inputs. Expected at least: %d. Found: %d\", _expect_req, center->req());\n+    print_list_of_inputs(center, ss);\n+    return false;\n+  }\n+  return true;\n+}\n+#endif\n+\n+bool AtInput::match(const Node* center) const {\n+  assert(_which_input < center->req(), \"Input number is out of range\");\n+  Node* input = center->in(_which_input);\n+  return input != nullptr && _pattern->match(input);\n+}\n+#ifndef PRODUCT\n+bool AtInput::match(const Node* center, PathInGraph& path, stringStream& ss) const {\n+  assert(_which_input < center->req(), \"Input number is out of range\");\n+  Node* input = center->in(_which_input);\n+  if (input == nullptr) {\n+    ss.print_cr(\"Input at index %d is nullptr.\", _which_input);\n+    return false;\n+  }\n+  bool result = _pattern->match(input, path, ss);\n+  if (!result) {\n+    path.add_input_step(_which_input, input);\n+  }\n+  return result;\n+}\n+#endif\n+\n+bool NodeClass::match(const Node* center) const {\n+  return (center->*_type_check)();\n+}\n+#ifndef PRODUCT\n+bool NodeClass::match(const Node* center, PathInGraph& path, stringStream& ss) const {\n+  if (!(center->*_type_check)()) {\n+    ss.print_cr(\"Unexpected type: %s.\", center->Name());\n+    return false;\n+  }\n+  return true;\n+}\n+#endif\n+\n+bool HasNOutputs::match(const Node* center) const {\n+  return center->outcnt() == _expect_outcnt;\n+}\n+#ifndef PRODUCT\n+bool HasNOutputs::match(const Node* center, PathInGraph& path, stringStream& ss) const {\n+  if (center->outcnt() != _expect_outcnt) {\n+    ss.print_cr(\"Unexpected number of outputs. Expected: %d, found: %d.\", _expect_outcnt, center->outcnt());\n+    for (DUIterator_Fast imax, i = center->fast_outs(imax); i < imax; i++) {\n+      Node* out = center->fast_out(i);\n+      ss.print(\"  \");\n+      out->dump(\"\\n\", false, &ss);\n+    }\n+    return false;\n+  }\n+  return true;\n+}\n+#endif\n+\n+bool AtSingleOutputOfType::match(const Node* center) const {\n+  Node* single_output_of_right_type = nullptr;\n+\n+  for (DUIterator_Fast imax, i = center->fast_outs(imax); i < imax; i++) {\n+    Node* out = center->fast_out(i);\n+    if ((out->*_type_check)()) {\n+      if (single_output_of_right_type != nullptr) {\n+        return false;\n+      }\n+      single_output_of_right_type = out;\n+    }\n+  }\n+\n+  if (single_output_of_right_type == nullptr) {\n+    return false;\n+  }\n+\n+  return _pattern->match(single_output_of_right_type);\n+}\n+#ifndef PRODUCT\n+bool AtSingleOutputOfType::match(const Node* center, PathInGraph& path, stringStream& ss) const {\n+  Node* single_output_of_right_type = nullptr;\n+  bool too_many_outputs_of_right_type = false;\n+\n+  for (DUIterator_Fast imax, i = center->fast_outs(imax); i < imax; i++) {\n+    Node* out = center->fast_out(i);\n+    if ((out->*_type_check)()) {\n+      if (single_output_of_right_type == nullptr) {\n+        single_output_of_right_type = out;\n+      } else {\n+        too_many_outputs_of_right_type = true;\n+        break;\n+      }\n+    }\n+  }\n+\n+  if (single_output_of_right_type == nullptr) {\n+    ss.print_cr(\"No output of expected type.\");\n+    return false;\n+  }\n+  if (too_many_outputs_of_right_type) {\n+    ResourceMark rm;\n+    Node_List outputs_of_correct_type;\n+    for (DUIterator_Fast imax, i = center->fast_outs(imax); i < imax; i++) {\n+      Node* out = center->fast_out(i);\n+      if ((out->*_type_check)()) {\n+        outputs_of_correct_type.push(out);\n+      }\n+    }\n+    ss.print_cr(\"Non-unique output of expected type. Found: %d.\", outputs_of_correct_type.size());\n+    for (uint i = 0; i < outputs_of_correct_type.size(); ++i) {\n+      outputs_of_correct_type.at(i)->dump(\"\\n\", false, &ss);\n+    }\n+    return false;\n+  }\n+\n+  bool result = _pattern->match(single_output_of_right_type, path, ss);\n+  if (!result) {\n+    path.add_output_step(single_output_of_right_type);\n+  }\n+  return result;\n+}\n+#endif\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/opto\/pattern.cpp","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,287 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OPTO_PATTERN_HPP\n+#define SHARE_OPTO_PATTERN_HPP\n+\n+#include \"metaprogramming\/enableIf.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"opto\/node.hpp\"\n+\n+\/* A path in the graph from a center, for pretty reporting.\n+ * Given a list of nodes\n+ * center = N0 --[r1]--> ... --[rk]-> Nk\n+ * where the ri are the relation between consecutive nodes: either p-th input, or an output,\n+ * then:\n+ * - steps must have length k + 1, and contain Nk ... N0\n+ * - path must have length k, and contain rk ... r1 where ri is:\n+ *   - a non-negative integer p for each step such that N{i-1} has Ni as p-th input (we need to follow an input edge)\n+ *   - the OutputStep value in case N{i-1} has Ni as an output (we need to follow an output edge)\n+ * The lists are reversed to allow to easily fill them lazily on failure: as we backtrack in the pattern\n+ * structure, we add the path bottom-up, finishing by the center.\n+ *\/\n+struct PathInGraph {\n+  \/* When an invariant applied at a given node (the center) goes wrong at another\n+   * node, it is useful to show the path we took between them. OutputStep is used\n+   * to signify that a node is the output of the previous one in the path.\n+   * See LocalGraphInvariant::check for more details on paths.\n+   *\/\n+  static constexpr int OutputStep = -1;\n+\n+  void finalize(Node* center);\n+  void add_input_step(uint input_index, Node* input);\n+  void add_output_step(Node* output);\n+\n+  void clear();\n+\n+  const Node_List& nodes() const { return _nodes; }\n+  const GrowableArray<int>& relation_to_previous_node() const { return _relation_to_previous_node; }\n+\n+private:\n+  Node_List _nodes;\n+  GrowableArray<int> _relation_to_previous_node;\n+};\n+\n+\/* A base class for checks expressed as data. Patterns are supposed to be local, centered around one node\n+ * and compositional to express complex structures from simple properties.\n+ * For instance, we have a pattern for saying \"match P on the first input of the center\" where P is another\n+ * Pattern. We end up with trees of patterns matching against the graph.\n+ *\/\n+struct Pattern : ResourceObj {\n+  typedef bool (Node::*TypeCheckMethod)() const;\n+\n+  \/* Check whether the graph and the pattern matches. Returns false in case\n+   * of failure. This version is quiet and can be used for non-debug purpose.\n+   * Since no reporting must be generated, this version is cheaper as it can\n+   * return as soon as possible.\n+   *\n+   * center: where to around which node to check whether the pattern matches\n+   *\/\n+  virtual bool match(const Node* center) const = 0;\n+\n+  \/* Check whether the graph and the pattern matches. Returns false in case\n+   * of failure. This version reports nicely on failure and is useful for\n+   * graph verification.\n+   *\n+   * center: where to around which node to check whether the pattern matches\n+   * path: in case of failure, path to the place where the failure happened.\n+   *   Must be filled from the offending node to the original center, which allows\n+   *   to compute the path lazily.\n+   * ss: in case of failure, to fill with error description.\n+   *\n+   * In case of success, path and ss must not be changed.\n+   *\/\n+#ifndef PRODUCT\n+  virtual bool match(const Node* center, PathInGraph& path, stringStream& ss) const = 0;\n+#endif\n+};\n+\n+\/* This pattern just accepts any node. This is convenient mostly as leaf in a pattern tree.\n+ * For instance `AtSingleOutputOfType(..., new TruePattern())` will make sure there is\n+ * indeed a single output of the given type, but won't enforce anything on the said output.\n+ *\/\n+struct TruePattern : Pattern {\n+  bool match(const Node*) const override {\n+    return true;\n+  }\n+#ifndef PRODUCT\n+  bool match(const Node*, PathInGraph&, stringStream&) const override {\n+    return true;\n+  }\n+#endif\n+};\n+\n+\/* This is semantically equivalent to `TruePattern` but will set the given reference to the node\n+ * the pattern is matched against. This is useful to perform additional checks that would\n+ * otherwise be hard or impossible to express as local patterns.\n+ *\n+ * For instance, one could write\n+ * Node* first, second;\n+ * And::make(\n+ *   new AtInput(0, new Bind(first)),\n+ *   new AtInput(1, new Bind(second))\n+ * );\n+ * [...] \/\/ run the pattern\n+ * if (first == second) { \/\/ checking whether they are the same node\n+ *\n+ * Bindings are only honored if the overall pattern succeeds. Otherwise, don't assume anything reasonable\n+ * has been set. Anyway, you don't need it: you already know it doesn't have the right shape.\n+ *\/\n+struct Bind : Pattern {\n+  explicit Bind(const Node*& binding) : _binding(binding) {}\n+  bool match(const Node* center) const override;\n+  NOT_PRODUCT(bool match(const Node* center, PathInGraph&, stringStream&) const override);\n+\n+private:\n+  const Node*& _binding;\n+};\n+\n+\/* A more type-safe version of `Bind` mostly to use with NodeClassIsAndBind macro defined later\n+ *\/\n+template <typename N, ENABLE_IF(std::is_base_of<Node, N>::value)>\n+struct TypedBind : Pattern {\n+  explicit TypedBind(const N*& binding) : _binding(binding) {}\n+  bool match(const Node* center) const override {\n+    _binding = static_cast<const N*>(center);\n+    return true;\n+  }\n+#ifndef PRODUCT\n+  bool match(const Node* center, PathInGraph&, stringStream&) const override {\n+    return match(center);\n+  }\n+#endif\n+\n+private:\n+  const N*& _binding;\n+};\n+\n+\/* Check a node has the right type (as which C++ class, not as abstract value). Typically used with\n+ * is_XXXNode methods.\n+ *\/\n+struct NodeClass : Pattern {\n+  explicit NodeClass(const TypeCheckMethod type_check) : _type_check(type_check) {}\n+  bool match(const Node* center) const override;\n+  NOT_PRODUCT(bool match(const Node* center, PathInGraph& path, stringStream& ss) const override;)\n+\n+private:\n+  const TypeCheckMethod _type_check;\n+};\n+\n+\/* To check the kind of a node and bind it to a variable of the right type.\n+ * For instance:\n+ *   const RegionNode* r;\n+ *   NodeClassIsAndBind(Region, r)\n+ *\/\n+#define NodeClassIsAndBind(node_type, binding) \\\n+  And::make(                                   \\\n+      new NodeClass(&Node::is_##node_type),    \\\n+      new TypedBind<node_type##Node>(binding))\n+\n+\/* Matches multiple patterns at the same node.\n+ *\n+ * Evaluation order is guaranteed to be left-to-right. That is needed, for instance, to check\n+ * that a node has enough inputs before using `AtInput`, since `AtInput` won't fail gracefully\n+ * if the number of input is too low. E.g. if you know a node has 3 inputs and want patterns\n+ * to be applied to each input, it would look like\n+ * And::make(\n+ *    new HasExactlyNInputs(3),\n+ *    new AtInput(0, P0),\n+ *    new AtInput(1, P1),\n+ *    new AtInput(2, P2),\n+ * )\n+ * If we relied on `AtInput` to report too few inputs, it would give confusing error messages as\n+ * the first `AtInput` can only know it expects at least one input, and seeing the message\n+ * \"Found 0 inputs, expected at least 1\" is not very helpful, potentially confusing since it doesn't\n+ * state what is actually expected: 3 inputs.\n+ * It also is not able to express that a node has exactly a given number of inputs, and it is a\n+ * significant difference whether we expect AT LEAST 3 inputs, or EXACTLY 3 inputs. Let's make\n+ * things precise.\n+ * Overall, to get better reporting, `AtInput` is not expected to check the input count, and the\n+ * user is responsible for it, making the guarantee on the evaluation order of `And` necessary.\n+ *\n+ * The evaluation order can also allow you to check easier properties before harder ones: it's\n+ * nicer if you get a simpler error message, with shorter paths. It's also easier to read as C++\n+ * expressions when indentation is not going back and forth.\n+ *\/\n+struct And : Pattern {\n+private:\n+  GrowableArray<Pattern*> _checks;\n+  template <typename... PP>\n+  static void make_helper(And* a, Pattern* pattern, PP... others) {\n+    a->_checks.push(pattern);\n+    make_helper(a, others...);\n+  }\n+  static void make_helper(And*) {}\n+\n+public:\n+  template <typename... PP>\n+  static And* make(PP... patterns) {\n+    And* andd = new And();\n+    make_helper(andd, patterns...);\n+    return andd;\n+  }\n+\n+  bool match(const Node* center) const override;\n+  NOT_PRODUCT(bool match(const Node* center, PathInGraph& path, stringStream& ss) const override;)\n+};\n+\n+struct HasExactlyNInputs : Pattern {\n+  explicit HasExactlyNInputs(uint expect_req) : _expect_req(expect_req) {}\n+  bool match(const Node* center) const override;\n+  NOT_PRODUCT(bool match(const Node* center, PathInGraph& path, stringStream& ss) const override;)\n+\n+private:\n+  const uint _expect_req;\n+};\n+\n+struct HasAtLeastNInputs : Pattern {\n+  explicit HasAtLeastNInputs(uint expect_req) : _expect_req(expect_req) {}\n+  bool match(const Node* center) const override;\n+  NOT_PRODUCT(bool match(const Node* center, PathInGraph& path, stringStream& ss) const override;)\n+\n+private:\n+  const uint _expect_req;\n+};\n+\n+\/* Check that a given pattern applies at the given input of the center.\n+ *\n+ * As explained above, it doesn't check (nicely) that inputs are in sufficient numbers.\n+ * Use HasExactlyNInputs or HasAtLeastNInputs for that.\n+ *\/\n+struct AtInput : Pattern {\n+  AtInput(uint which_input, const Pattern* pattern) : _which_input(which_input), _pattern(pattern) {}\n+  bool match(const Node* center) const override;\n+  NOT_PRODUCT(bool match(const Node* center, PathInGraph& path, stringStream& ss) const override;)\n+\n+private:\n+  const uint _which_input;\n+  const Pattern* const _pattern;\n+};\n+\n+struct HasNOutputs : Pattern {\n+  explicit HasNOutputs(uint expect_outcnt) : _expect_outcnt(expect_outcnt) {}\n+  bool match(const Node* center) const override;\n+  NOT_PRODUCT(bool match(const Node* center, PathInGraph& path, stringStream& ss) const override;)\n+\n+private:\n+  const uint _expect_outcnt;\n+};\n+\n+\/* Given a is_XXXNode method pointer and a pattern P, this pattern checks that\n+ * - only one output has the given type XXX\n+ * - this one output matches P.\n+ *\n+ * Since outputs are not numbered, this is a convenient way to walk on the graph in the Def-Use direction.\n+ *\/\n+struct AtSingleOutputOfType : Pattern {\n+  AtSingleOutputOfType(const TypeCheckMethod type_check, const Pattern* pattern) : _type_check(type_check), _pattern(pattern) {}\n+  bool match(const Node* center) const override;\n+  NOT_PRODUCT(bool match(const Node* center, PathInGraph& path, stringStream& ss) const override;)\n+\n+private:\n+  const TypeCheckMethod _type_check;\n+  const Pattern* const _pattern;\n+};\n+\n+#endif \/\/ SHARE_OPTO_PATTERN_HPP\n","filename":"src\/hotspot\/share\/opto\/pattern.hpp","additions":287,"deletions":0,"binary":false,"changes":287,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"opto\/graphInvariants.hpp\"\n@@ -990,0 +991,3 @@\n+  if (VerifyIdealGraph) {\n+    assert(C->_invariant_checker->run(), \"Ideal graph doesn't verify structural invariants.\");\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350864\n+ * @requires vm.debug == true & vm.flavor == \"server\"\n+ * @summary Empty main program to run with flag VerifyIdealGraph.\n+ *\n+ * @run main\/othervm -Xbatch -Xcomp -XX:+VerifyIdealGraph compiler.c2.TestVerifyIdealGraph\n+ *\/\n+package compiler.c2;\n+\n+public class TestVerifyIdealGraph {\n+    public static void main(String[] args) {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestVerifyIdealGraph.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"}]}