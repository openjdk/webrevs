{"files":[{"patch":"@@ -706,0 +706,3 @@\n+  develop(bool, VerifyIdealStructuralInvariants, false,                     \\\n+          \"Check structural invariants of the ideal graph\")                 \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,623 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"opto\/graphInvariants.hpp\"\n+#include \"opto\/rootnode.hpp\"\n+\n+constexpr int LocalGraphInvariant::OutputStep;\n+#ifndef PRODUCT\n+\n+void LocalGraphInvariant::LazyReachableCFGNodes::fill() {\n+  precond(live_nodes.size() == 0);\n+\n+  \/\/ We should have at least root, so we are sure it's not filled yet.\n+  live_nodes.push(Compile::current()->root());\n+  for (uint i = 0; i < live_nodes.size(); ++i) {\n+    Node* n = live_nodes.at(i);\n+    for (DUIterator_Fast jmax, j = n->fast_outs(jmax); j < jmax; j++) {\n+      Node* out = n->fast_out(j);\n+      if (out->is_CFG()) {\n+        live_nodes.push(out);\n+      }\n+    }\n+  }\n+\n+  postcond(live_nodes.size() > 0);\n+}\n+\n+bool LocalGraphInvariant::LazyReachableCFGNodes::is_node_dead(const Node* n) {\n+  if (live_nodes.size() == 0) {\n+    fill();\n+  }\n+  assert(live_nodes.size() > 0, \"filling failed\");\n+  return !live_nodes.member(n);\n+}\n+\n+void print_path(const Node_List& steps, const GrowableArray<int>& path, stringStream& ss) {\n+  const int path_len = path.length();\n+  precond(steps.size() == static_cast<uint>(path_len) + 1);\n+  if (path.is_empty()) {\n+    ss.print_cr(\"At center node\");\n+    steps.at(0)->dump(\"\\n\", false, &ss);\n+    return;\n+  }\n+  ss.print(\"At node\\n   \");\n+  steps.at(0)->dump(\"\\n\", false, &ss);\n+  ss.print_cr(\"  From path:\");\n+  ss.print(\"    [center]\");\n+  steps.at(path_len)->dump(\"\\n\", false, &ss);\n+  for (int i = 0; i < path_len; ++i) {\n+    if (path.at(path_len - i - 1) >= 0) {\n+      \/\/ It's an input\n+      int input_nb = path.at(path_len - i - 1);\n+      if (input_nb <= 9) {\n+        ss.print(\" \");\n+      }\n+      ss.print(\"     <-(%d)-\", input_nb);\n+\n+    } else if (path.at(path_len - i - 1) == LocalGraphInvariant::OutputStep) {\n+      \/\/ It's an output\n+      ss.print(\"         -->\");\n+    } else {\n+      ss.print(\"         ???\");\n+    }\n+    steps.at(path_len - i - 1)->dump(\"\\n\", false, &ss);\n+  }\n+}\n+\n+struct Pattern : ResourceObj {\n+  virtual bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream&) const = 0;\n+};\n+\n+struct True : Pattern {\n+  bool check(const Node*, Node_List&, GrowableArray<int>&, stringStream&) const override {\n+    return true;\n+  }\n+};\n+\n+struct Bind : Pattern {\n+  explicit Bind(const Node*& binding) : _binding(binding) {}\n+  bool check(const Node* center, Node_List&, GrowableArray<int>&, stringStream&) const override {\n+    _binding = center;\n+    return true;\n+  }\n+  const Node*& _binding;\n+};\n+\n+struct And : Pattern {\n+private:\n+  template <typename... PP>\n+  static void make_helper(And* a, Pattern* pattern, PP... others) {\n+    a->_checks.push(pattern);\n+    make_helper(a, others...);\n+  }\n+  static void make_helper(And*) {}\n+\n+public:\n+  template <typename... PP>\n+  static And* make(PP... patterns) {\n+    And* andd = new And();\n+    make_helper(andd, patterns...);\n+    return andd;\n+  }\n+\n+  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    for (int i = 0; i < _checks.length(); ++i) {\n+      if (!_checks.at(i)->check(center, steps, path, ss)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+  GrowableArray<Pattern*> _checks;\n+};\n+\n+struct HasExactlyNInputs : Pattern {\n+  explicit HasExactlyNInputs(uint expect_req) : _expect_req(expect_req) {}\n+  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (center->req() != _expect_req) {\n+      ss.print_cr(\"Unexpected number of input. Expected: %d. Found: %d\", _expect_req, center->req());\n+      for (uint i = 0; i < center->req(); ++i) {\n+        Node* in = center->in(i);\n+        ss.print(\"  %d: \", i);\n+        if (in == nullptr) {\n+          ss.print_cr(\"nullptr\");\n+        } else {\n+          in->dump(\"\\n\", false, &ss);\n+        }\n+      }\n+      return false;\n+    }\n+    return true;\n+  }\n+  const uint _expect_req;\n+};\n+\n+struct HasAtLeastNInputs : Pattern {\n+  explicit HasAtLeastNInputs(uint expect_req) : _expect_req(expect_req) {}\n+  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (center->req() < _expect_req) {\n+      ss.print_cr(\"Too small number of input. Expected: %d. Found: %d\", _expect_req, center->req());\n+      for (uint i = 0; i < center->req(); ++i) {\n+        Node* in = center->in(i);\n+        ss.print(\"  %d: \", i);\n+        if (in == nullptr) {\n+          ss.print_cr(\"nullptr\");\n+        } else {\n+          in->dump(\"\\n\", false, &ss);\n+        }\n+      }\n+      return false;\n+    }\n+    return true;\n+  }\n+  const uint _expect_req;\n+};\n+\n+struct AtInput : Pattern {\n+  AtInput(uint which_input, const Pattern* pattern) : _which_input(which_input), _pattern(pattern) {}\n+  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    assert(_which_input < center->req(), \"First check the input number\");\n+    if (center->in(_which_input) == nullptr) {\n+      ss.print_cr(\"Input at index %d is nullptr.\", _which_input);\n+      return false;\n+    }\n+    bool result = _pattern->check(center->in(_which_input), steps, path, ss);\n+    if (!result) {\n+      steps.push(center->in(_which_input));\n+      path.push(static_cast<int>(_which_input));\n+    }\n+    return result;\n+  }\n+  const uint _which_input;\n+  const Pattern* const _pattern;\n+};\n+\n+struct HasType : Pattern {\n+  explicit HasType(bool (Node::*type_check)() const) : _type_check(type_check) {}\n+  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (!(center->*_type_check)()) {\n+      ss.print_cr(\"Unexpected type: %s.\", center->Name());\n+      return false;\n+    }\n+    return true;\n+  }\n+  bool (Node::*_type_check)() const;\n+};\n+\n+struct HasNOutputs : Pattern {\n+  explicit HasNOutputs(uint expect_outcnt) : _expect_outcnt(expect_outcnt) {}\n+  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (center->outcnt() != _expect_outcnt) {\n+      ss.print_cr(\"Unexpected number of outputs. Expected: %d, found: %d.\", _expect_outcnt, center->outcnt());\n+      for (DUIterator_Fast imax, i = center->fast_outs(imax); i < imax; i++) {\n+        Node* out = center->fast_out(i);\n+        ss.print(\"  \");\n+        out->dump(\"\\n\", false, &ss);\n+      }\n+      return false;\n+    }\n+    return true;\n+  }\n+  const uint _expect_outcnt;\n+};\n+\n+struct AtSingleOutputOfType : Pattern {\n+  AtSingleOutputOfType(bool (Node::*type_check)() const, const Pattern* pattern) : _type_check(type_check), _pattern(pattern) {\n+  }\n+\n+  bool check(const Node* center, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    Node_List outputs_of_correct_type;\n+    for (DUIterator_Fast imax, i = center->fast_outs(imax); i < imax; i++) {\n+      Node* out = center->fast_out(i);\n+      if ((out->*_type_check)()) {\n+        outputs_of_correct_type.push(out);\n+      }\n+    }\n+    if (outputs_of_correct_type.size() != 1) {\n+      ss.print_cr(\"Non-unique output of expected type. Found: %d.\", outputs_of_correct_type.size());\n+      for (uint i = 0; i < outputs_of_correct_type.size(); ++i) {\n+        outputs_of_correct_type.at(i)->dump(\"\\n\", false, &ss);\n+      }\n+      return false;\n+    }\n+    bool result = _pattern->check(outputs_of_correct_type.at(0), steps, path, ss);\n+    if (!result) {\n+      steps.push(outputs_of_correct_type.at(0));\n+      path.push(LocalGraphInvariant::OutputStep);\n+    }\n+    return result;\n+  }\n+  bool (Node::*_type_check)() const;\n+  const Pattern* const _pattern;\n+};\n+\n+struct PatternBasedCheck : LocalGraphInvariant {\n+  const Pattern* const _pattern;\n+  explicit PatternBasedCheck(const Pattern* pattern) : _pattern(pattern) {}\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    return _pattern->check(center, steps, path, ss) ? CheckResult::VALID : CheckResult::FAILED;\n+  }\n+};\n+\n+struct IfProjections : PatternBasedCheck {\n+  IfProjections()\n+      : PatternBasedCheck(\n+            And::make(\n+                new HasNOutputs(2),\n+                new AtSingleOutputOfType(&Node::is_IfTrue, new True()),\n+                new AtSingleOutputOfType(&Node::is_IfFalse, new True()))) {\n+  }\n+  const char* name() const override {\n+    return \"IfProjections\";\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (!center->is_If()) {\n+      return CheckResult::NOT_APPLICABLE;\n+    }\n+    CheckResult r = PatternBasedCheck::check(center, reachable_cfg_nodes, steps, path, ss);\n+    if (r == CheckResult::FAILED) {\n+      if (reachable_cfg_nodes.is_node_dead(center)) {\n+        \/\/ That's ok for dead nodes right now. It might be too expensive to collect for IGVN, but it will be removed in loop opts.\n+        ss.reset();\n+        return CheckResult::VALID;\n+      }\n+    }\n+    return r;\n+  }\n+};\n+\n+struct PhiArity : PatternBasedCheck {\n+  const Node* region_node = nullptr;\n+  PhiArity()\n+      : PatternBasedCheck(\n+            And::make(\n+                new HasAtLeastNInputs(1),\n+                new AtInput(\n+                    0,\n+                    And::make(\n+                        new HasType(&Node::is_Region),\n+                        new Bind(region_node))))) {\n+  }\n+  const char* name() const override {\n+    return \"PhiArity\";\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (!center->is_Phi()) {\n+      return CheckResult::NOT_APPLICABLE;\n+    }\n+    CheckResult result = PatternBasedCheck::check(center, reachable_cfg_nodes, steps, path, ss);\n+    if (result != CheckResult::VALID) {\n+      return result;\n+    }\n+    assert(region_node != nullptr, \"sanity\");\n+    if (region_node->req() != center->req()) {\n+      ss.print_cr(\"Phi nodes must have the same arity as their Region node. Phi arity: %d; Region arity: %d.\", center->req(), region_node->req());\n+      return CheckResult::FAILED;\n+    }\n+    return CheckResult::VALID;\n+  }\n+};\n+\n+struct ControlSuccessor : LocalGraphInvariant {\n+  const char* name() const override {\n+    return \"ControlSuccessor\";\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (!center->is_CFG()) {\n+      return CheckResult::NOT_APPLICABLE;\n+    }\n+\n+    Node_List ctrl_succ;\n+    uint cfg_out = 0;\n+    for (DUIterator_Fast imax, i = center->fast_outs(imax); i < imax; i++) {\n+      Node* out = center->fast_out(i);\n+      if (out->is_CFG()) {\n+        cfg_out++;\n+        ctrl_succ.push(out);\n+      }\n+    }\n+\n+    if (center->is_If() || center->is_Start() || center->is_Root() || center->is_Region() || center->is_NeverBranch()) {\n+      if (cfg_out != 2) {\n+        if (reachable_cfg_nodes.is_node_dead(center)) {\n+          \/\/ That's ok for dead nodes right now. It might be too expensive to collect for IGVN, but it will be removed in loop opts.\n+          return CheckResult::VALID;\n+        }\n+        ss.print_cr(\"%s node must have exactly two control successors. Found %d.\", center->Name(), cfg_out);\n+        for (uint i = 0; i < ctrl_succ.size(); ++i) {\n+          ss.print(\"  \");\n+          ctrl_succ.at(i)->dump(\"\\n\", false, &ss);\n+        }\n+        return CheckResult::FAILED;\n+      }\n+    } else if (center->Opcode() == Op_SafePoint) {\n+      if (cfg_out < 1 || cfg_out > 2) {\n+        ss.print_cr(\"%s node must have one or two control successors. Found %d.\", center->Name(), cfg_out);\n+        for (uint i = 0; i < ctrl_succ.size(); ++i) {\n+          ss.print(\"  \");\n+          ctrl_succ.at(i)->dump(\"\\n\", false, &ss);\n+        }\n+        return CheckResult::FAILED;\n+      }\n+      if (cfg_out == 2) {\n+        if (!ctrl_succ.at(0)->is_Root() && !ctrl_succ.at(1)->is_Root()) {\n+          ss.print_cr(\"One of the two control outputs of a %s node must be Root.\", center->Name());\n+          for (uint i = 0; i < ctrl_succ.size(); ++i) {\n+            ss.print(\"  \");\n+            ctrl_succ.at(i)->dump(\"\\n\", false, &ss);\n+          }\n+          return CheckResult::FAILED;\n+        }\n+      }\n+    } else if (center->is_Catch() || center->is_Jump()) {\n+      if (cfg_out < 1) {\n+        ss.print_cr(\"%s node must have at least one control successors. Found %d.\", center->Name(), cfg_out);\n+        return CheckResult::FAILED;\n+      }\n+    } else {\n+      if (cfg_out != 1) {\n+        ss.print_cr(\"Ordinary CFG nodes must have exactly one successor. Found %d.\", cfg_out);\n+        for (uint i = 0; i < ctrl_succ.size(); ++i) {\n+          ss.print(\"  \");\n+          ctrl_succ.at(i)->dump(\"\\n\", false, &ss);\n+        }\n+        return CheckResult::FAILED;\n+      }\n+    }\n+\n+    return CheckResult::VALID;\n+  }\n+};\n+\n+struct RegionSelfLoop : LocalGraphInvariant {\n+  const char* name() const override {\n+    return \"RegionSelfLoop\";\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (!center->is_Region() && !center->is_Start() && !center->is_Root()) {\n+      return CheckResult::NOT_APPLICABLE;\n+    }\n+\n+    if (center->req() == 0) {\n+      ss.print_cr(\"%s nodes must have at least one input.\", center->Name());\n+      return CheckResult::FAILED;\n+    }\n+\n+    Node* self = center->in(LoopNode::Self);\n+\n+    if (center != self || (center->is_Region() && self == nullptr)) {\n+      ss.print_cr(\"%s nodes' 0-th input must be itself or nullptr (for a copy Region).\", center->Name());\n+      return CheckResult::FAILED;\n+    }\n+\n+    if (self == nullptr) {\n+      \/\/ Must be a copy Region\n+      Node_List non_null_inputs;\n+      for (uint i = 0; i < center->req(); i++) {\n+        if (center->in(i) != nullptr) {\n+          non_null_inputs.push(center->in(i));\n+        }\n+      }\n+      if (non_null_inputs.size() != 1) {\n+        ss.print_cr(\"%s copy nodes must have exactly one non-null input. Found: %d.\", center->Name(), non_null_inputs.size());\n+        for (uint i = 0; i < non_null_inputs.size(); ++i) {\n+          non_null_inputs.at(i)->dump(\"\\n\", false, &ss);\n+        }\n+        return CheckResult::FAILED;\n+      }\n+    }\n+\n+    return CheckResult::VALID;\n+  }\n+};\n+\n+\/\/ CountedLoopEnd -> IfTrue -> CountedLoop\n+struct CountedLoopInvariants : PatternBasedCheck {\n+  const Node* counted_loop = nullptr;\n+  CountedLoopInvariants()\n+      : PatternBasedCheck(\n+            And::make(\n+                new HasExactlyNInputs(3),\n+                new AtInput(\n+                    LoopNode::LoopBackControl,\n+                    And::make(\n+                        new HasType(&Node::is_IfTrue),\n+                        new HasAtLeastNInputs(1),\n+                        new AtInput(\n+                            0,\n+                            And::make(\n+                                new HasType(&Node::is_BaseCountedLoopEnd),\n+                                new Bind(counted_loop))))))) {}\n+  const char* name() const override {\n+    return \"CountedLoopInvariants\";\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (!center->is_CountedLoop() && !center->is_LongCountedLoop()) {\n+      return CheckResult::NOT_APPLICABLE;\n+    }\n+\n+    bool is_long = center->is_LongCountedLoop();\n+\n+    CheckResult result = PatternBasedCheck::check(center, reachable_cfg_nodes, steps, path, ss);\n+    if (result != CheckResult::VALID) {\n+      return result;\n+    }\n+    assert(counted_loop != nullptr, \"sanity\");\n+    if (is_long) {\n+      if (counted_loop->is_CountedLoopEnd()) {\n+        ss.print_cr(\"A CountedLoopEnd is the backedge of a LongCountedLoop.\");\n+        return CheckResult::FAILED;\n+      }\n+    } else {\n+      if (counted_loop->is_LongCountedLoopEnd()) {\n+        ss.print_cr(\"A LongCountedLoopEnd is the backedge of a CountedLoop.\");\n+        return CheckResult::FAILED;\n+      }\n+    }\n+    return CheckResult::VALID;\n+  }\n+};\n+\n+\/\/ CountedLoopEnd -> IfFalse -> SafePoint -> OuterStripMinedLoopEnd[center] -> IfTrue -> OuterStripMinedLoop -> CountedLoop\n+struct OuterStripMinedLoopInvariants : PatternBasedCheck {\n+  OuterStripMinedLoopInvariants()\n+      : PatternBasedCheck(\n+            And::make(\n+                new HasExactlyNInputs(2),\n+                new AtInput(\n+                    0,\n+                    And::make(\n+                        new HasType(&Node::is_SafePoint),\n+                        new HasAtLeastNInputs(1),\n+                        new AtInput(\n+                            0,\n+                            And::make(\n+                                new HasType(&Node::is_IfFalse),\n+                                new HasAtLeastNInputs(1),\n+                                new AtInput(\n+                                    0,\n+                                    new HasType(&Node::is_CountedLoopEnd)))))),\n+                new AtSingleOutputOfType(\n+                    &Node::is_IfTrue,\n+                    new AtSingleOutputOfType(\n+                        &Node::is_OuterStripMinedLoop,\n+                        new AtSingleOutputOfType(\n+                            &Node::is_CountedLoop,\n+                            new True()))))) {}\n+  const char* name() const override {\n+    return \"OuterStripMinedLoopInvariants\";\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (!center->is_OuterStripMinedLoopEnd()) {\n+      return CheckResult::NOT_APPLICABLE;\n+    }\n+\n+    return PatternBasedCheck::check(center, reachable_cfg_nodes, steps, path, ss);\n+  }\n+};\n+\n+struct MultiBranchNodeOut : LocalGraphInvariant {\n+  const char* name() const override {\n+    return \"MultiBranchNodeOut\";\n+  }\n+  CheckResult check(const Node* center, LazyReachableCFGNodes& reachable_cfg_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const override {\n+    if (!center->is_MultiBranch()) {\n+      return CheckResult::NOT_APPLICABLE;\n+    }\n+\n+    MultiBranchNode* mb = center->as_MultiBranch();\n+    if (mb->required_outcnt() < static_cast<int>(mb->outcnt())) {\n+      ss.print_cr(\"The required_outcnt of a MultiBranch node must be smaller than or equal to its outcnt. But required_outcnt=%d vs. outcnt=%d\", mb->required_outcnt(), mb->outcnt());\n+      return CheckResult::FAILED;\n+    }\n+\n+    return CheckResult::VALID;\n+  }\n+};\n+\n+#endif\n+\n+GraphInvariantChecker* GraphInvariantChecker::make_default() {\n+  auto* checker = new GraphInvariantChecker();\n+#ifndef PRODUCT\n+#define ADD_CHECKER(T) checker->_checks.push(new T())\n+  ADD_CHECKER(IfProjections);\n+  ADD_CHECKER(PhiArity);\n+  ADD_CHECKER(ControlSuccessor);\n+  ADD_CHECKER(RegionSelfLoop);\n+  ADD_CHECKER(CountedLoopInvariants);\n+  ADD_CHECKER(OuterStripMinedLoopInvariants);\n+  ADD_CHECKER(MultiBranchNodeOut);\n+#undef ADD_CHECKER\n+#endif\n+  return checker;\n+}\n+\n+bool GraphInvariantChecker::run() const {\n+#ifdef PRODUCT\n+  return true;\n+#else\n+  ResourceMark rm;\n+\n+  if (_checks.is_empty()) {\n+    return true;\n+  }\n+\n+  VectorSet enqueued;\n+  Node_List worklist;\n+  worklist.push(Compile::current()->root());\n+  Node_List steps;\n+  GrowableArray<int> path;\n+  stringStream ss;\n+  stringStream ss2;\n+  \/\/ Sometimes, we get weird structure in dead code that will be cleaned up later. It typically happens\n+  \/\/ when data dies, but control is not cleanup right away, possibly kept alive by un unreachable loop.\n+  \/\/ Since we don't want to eagerly traverse the whole graph to remove dead code in IGVN, we can accept\n+  \/\/ weird structure in dead code.\n+  \/\/ For CFG-related errors, we will compute the set of reachable CFG nodes and decide whether to keep\n+  \/\/ the issue if the problematic node is reachable. This set of reachable node is thus computed lazily\n+  \/\/ (and it seems not to happen often in practice), and shared across checks.\n+  LocalGraphInvariant::LazyReachableCFGNodes reachable_cfg_nodes;\n+  bool success = true;\n+\n+  while (worklist.size() > 0) {\n+    Node* center = worklist.pop();\n+    for (uint i = 0; i < center->req(); i++) {\n+      Node* in = center->in(i);\n+      if (in != nullptr && !enqueued.test_set(in->_idx)) {\n+        worklist.push(in);\n+      }\n+    }\n+    uint failures = 0;\n+    for (int i = 0; i < _checks.length(); ++i) {\n+      switch (_checks.at(i)->check(center, reachable_cfg_nodes, steps, path, ss2)) {\n+      case LocalGraphInvariant::CheckResult::FAILED:\n+        failures++;\n+        steps.push(center);\n+        print_path(steps, path, ss);\n+        ss.print_cr(\"# %s:\", _checks.at(i)->name());\n+        ss.print_cr(\"%s\", ss2.base());\n+        path.clear();\n+        steps.clear();\n+        ss2.reset();\n+        break;\n+      case LocalGraphInvariant::CheckResult::NOT_APPLICABLE:\n+      case LocalGraphInvariant::CheckResult::VALID:\n+        break;\n+      }\n+    }\n+    if (failures > 0) {\n+      success = false;\n+      ttyLocker ttyl;\n+      tty->print(\"%d failure%s for node\\n\", failures, failures == 1 ? \"\" : \"s\");\n+      center->dump();\n+      tty->print_cr(\"%s\", ss.base());\n+      ss.reset();\n+    }\n+  }\n+\n+  return success;\n+#endif\n+}\n","filename":"src\/hotspot\/share\/opto\/graphInvariants.cpp","additions":623,"deletions":0,"binary":false,"changes":623,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OPTO_GRAPHINVARIANTS_HPP\n+#define SHARE_OPTO_GRAPHINVARIANTS_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"opto\/node.hpp\"\n+\n+\/\/ An invariant that needs only a local view of the graph, around a given node.\n+class LocalGraphInvariant : public ResourceObj {\n+public:\n+  static constexpr int OutputStep = -1;\n+\n+  struct LazyReachableCFGNodes {\n+    bool is_node_dead(const Node*);\n+  private:\n+    void fill();\n+    Unique_Node_List live_nodes;\n+  };\n+\n+  enum class CheckResult {\n+    VALID,          \/\/ The check applies, and it is satisfied on the given center\n+    FAILED,         \/\/ The check applies, but finds that the invariant is broken\n+    NOT_APPLICABLE, \/\/ The check has no opinion on the given center\n+  };\n+\n+  \/\/ For reporting\n+  virtual const char* name() const = 0;\n+\n+  \/* Check whether the invariant is true around the node [center]. The argument [steps] and [path] are initially empty.\n+   *\n+   * If the check fails steps and path must be filled with the path from the center to the failing node (where it's relevant to show).\n+   * Given a list of node\n+   * center = N0 --[r1]--> ... --[rk]-> Nk\n+   * where the ri are the relation between consecutive nodes: either p-th input, or an output,\n+   * then:\n+   * - steps must have length k + 1, and contain Nk ... N0\n+   * - path must have length k, and contain rk ... r1 where ri is:\n+   *   - a non-negative integer p for each step such that N{i-1} has Ni as p-th input (we need to follow an input edge)\n+   *   - the OUTPUT_STEP value in case N{i-1} has Ni as an output (we need to follow an output edge)\n+   * The list are reversed to allow to easily fill them lazily on failure.\n+   * In addition, if the check fails, it must write its error message in [ss].\n+   *\n+   * If the check succeeds or is not applicable, [steps], [path] and [ss] must be untouched.\n+   *\n+   * The parameter [live_nodes] is used to share the lazily computed set of CFG nodes reachable from root. This is because some\n+   * checks don't apply to dead code, suppress their error if a violation is detected in dead code.\n+   *\/\n+  virtual CheckResult check(const Node* center, LazyReachableCFGNodes& live_nodes, Node_List& steps, GrowableArray<int>& path, stringStream& ss) const = 0;\n+};\n+\n+\/* Checks structural invariants of the graph connected to the root.\n+ *\n+ * The checker itself is not node or graph dependent and can be used\n+ * on any graph, to save memory: one allocation is enough!\n+ *\n+ * Local invariants are checked on each node of the graph: the check\n+ * is overall failing if any invariant doesn't hold on any node.\n+ *\n+ * It currently only checks local invariants, but it could be extended\n+ * to global ones.\n+ *\/\n+class GraphInvariantChecker : public ResourceObj {\n+  GrowableArray<const LocalGraphInvariant*> _checks;\n+\n+public:\n+  static GraphInvariantChecker* make_default();\n+  bool run() const;\n+};\n+\n+#endif \/\/ SHARE_OPTO_GRAPHINVARIANTS_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/opto\/graphInvariants.hpp","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"opto\/graphInvariants.hpp\"\n@@ -807,0 +808,1 @@\n+  NOT_PRODUCT(_invariant_checker = GraphInvariantChecker::make_default());\n@@ -843,0 +845,2 @@\n+\n+  NOT_PRODUCT(_invariant_checker = GraphInvariantChecker::make_default());\n@@ -990,0 +994,3 @@\n+  if (VerifyIdealStructuralInvariants) {\n+    assert(_invariant_checker->run(), \"Ideal graph doesn't verify structural invariants.\");\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+class GraphInvariantChecker;\n@@ -614,0 +615,1 @@\n+  GraphInvariantChecker* _invariant_checker;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}