{"files":[{"patch":"@@ -1338,0 +1338,5 @@\n+        \/\/ Subclasses of AbstractImmutableMap should override keySet and values with implementations\n+        \/\/ that throw UnsupportedOperationException on attempts to modify them.\n+        @Override public abstract Set<K> keySet();\n+        @Override public abstract Collection<V> values();\n+\n@@ -1370,0 +1375,10 @@\n+        @Override\n+        public Set<K> keySet() {\n+            return Set.of(k0);\n+        }\n+\n+        @Override\n+        public Collection<V> values() {\n+            return List.of(v0);\n+        }\n+\n@@ -1565,1 +1580,1 @@\n-            return new AbstractSet<>() {\n+            return new AbstractImmutableSet<>() {\n@@ -1575,0 +1590,5 @@\n+\n+                @Override\n+                public int hashCode() {\n+                    return MapN.this.hashCode();\n+                }\n@@ -1578,0 +1598,53 @@\n+        @Override\n+        public Set<K> keySet() {\n+            Set<K> ks = keySet;\n+            if (ks == null) {\n+                ks = new AbstractImmutableSet<>() {\n+                    @Override\n+                    public int size() {\n+                        return MapN.this.size;\n+                    }\n+\n+                    @Override\n+                    public Iterator<K> iterator() {\n+                        return new KeyIterator();\n+                    }\n+\n+                    @Override\n+                    public int hashCode() {\n+                        int hash = 0;\n+                        for (int i = 0; i < table.length; i += 2) {\n+                            Object k = table[i];\n+                            if (k != null) {\n+                                hash += k.hashCode();\n+                            }\n+                        }\n+                        return hash;\n+                    }\n+                };\n+                keySet = ks;\n+            }\n+            return ks;\n+        }\n+\n+        @Override\n+        public Collection<V> values() {\n+            Collection<V> vals = values;\n+            if (vals == null) {\n+                vals = new AbstractImmutableCollection<>() {\n+                    @Override\n+                    public int size() {\n+                        return MapN.this.size;\n+                    }\n+\n+                    @Override\n+                    public Iterator<V> iterator() {\n+                        return new ValueIterator();\n+                    }\n+                };\n+                values = vals;\n+            }\n+            return vals;\n+        }\n+\n+\n@@ -1640,0 +1713,29 @@\n+        @Override\n+        public Set<K> keySet() {\n+            Set<K> ks = keySet;\n+            if (ks == null) {\n+                ks = new AbstractImmutableSet<>() {\n+                    @Override\n+                    public int size() {\n+                        return delegate.size();\n+                    }\n+\n+                    @Override\n+                    public Iterator<K> iterator() {\n+                        return new KeyIterator();\n+                    }\n+\n+                    @Override\n+                    public int hashCode() {\n+                        int hash = 0;\n+                        for (K k : delegate.keySet()) {\n+                            hash += k.hashCode();\n+                        }\n+                        return hash;\n+                    }\n+                };\n+                keySet = ks;\n+            }\n+            return ks;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":103,"deletions":1,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -125,2 +125,2 @@\n- * cannot be added, removed, or updated. Calling any mutator method on the Map\n- * will always cause {@code UnsupportedOperationException} to be thrown.\n+ * cannot be added, removed, or updated. Calling any mutator method on the Map or any derived view\n+ * collection will always cause {@code UnsupportedOperationException} to be thrown.\n","filename":"src\/java.base\/share\/classes\/java\/util\/Map.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *          4802647 7123424 8024709 8193128 8327858 8368178\n+ *          4802647 7123424 8024709 8193128 8327858 8368178 8328821\n@@ -371,0 +371,3 @@\n+        testEmptyCollMutatorsAlwaysThrow(Map.of().entrySet());\n+        testEmptyCollMutatorsAlwaysThrow(Map.of().keySet());\n+        testEmptyCollMutatorsAlwaysThrow(Map.of().values());\n@@ -390,0 +393,3 @@\n+            testCollMutatorsAlwaysThrow(map.entrySet(), Map.entry(42, 43));\n+            testCollMutatorsAlwaysThrow(map.keySet());\n+            testCollMutatorsAlwaysThrow(map.values());\n@@ -558,0 +564,4 @@\n+        testCollMutatorsAlwaysThrow(c, ABSENT_VALUE);\n+    }\n+\n+    private static <T> void testCollMutatorsAlwaysThrow(Collection<T> c, T t) {\n@@ -560,1 +570,1 @@\n-                () -> c.remove(ABSENT_VALUE),\n+                () -> c.remove(t),\n@@ -605,1 +615,1 @@\n-    private static void testEmptyCollMutatorsAlwaysThrow(Collection<Integer> c) {\n+    private static void testEmptyCollMutatorsAlwaysThrow(Collection<?> c) {\n@@ -1390,0 +1400,2 @@\n+        check(m.hashCode() == m.entrySet().hashCode());\n+        check(Set.copyOf(m.keySet()).hashCode() == m.keySet().hashCode());\n","filename":"test\/jdk\/java\/util\/Collection\/MOAT.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"}]}