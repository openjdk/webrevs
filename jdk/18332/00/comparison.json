{"files":[{"patch":"@@ -1366,10 +1366,2 @@\n-  if (java_lang_VirtualThread::is_instance(thread_oop)) {\n-    \/\/ There is no monitor info to collect if target virtual thread is unmounted.\n-    if (java_thread != nullptr) {\n-      VirtualThreadGetOwnedMonitorInfoClosure op(this,\n-                                                 Handle(calling_thread, thread_oop),\n-                                                 owned_monitors_list);\n-      Handshake::execute(&op, java_thread);\n-      err = op.result();\n-    }\n-  } else {\n+  if (java_thread != nullptr) {\n+    Handle thread_handle(calling_thread, thread_oop);\n@@ -1381,11 +1373,4 @@\n-\n-    if (java_thread == calling_thread) {\n-      \/\/ It is only safe to make a direct call on the current thread.\n-      \/\/ All other usage needs to use a direct handshake for safety.\n-      err = get_owned_monitors(calling_thread, java_thread, owned_monitors_list);\n-    } else {\n-      \/\/ get owned monitors info with handshake\n-      GetOwnedMonitorInfoClosure op(calling_thread, this, owned_monitors_list);\n-      Handshake::execute(&op, java_thread);\n-      err = op.result();\n-    }\n+    \/\/ get owned monitors info with handshake\n+    GetOwnedMonitorInfoClosure op(this, calling_thread, owned_monitors_list);\n+    JvmtiHandshake::execute(&op, &tlh, java_thread, thread_handle);\n+    err = op.result();\n@@ -1439,10 +1424,2 @@\n-  if (java_lang_VirtualThread::is_instance(thread_oop)) {\n-    \/\/ There is no monitor info to collect if target virtual thread is unmounted.\n-    if (java_thread != nullptr) {\n-      VirtualThreadGetOwnedMonitorInfoClosure op(this,\n-                                                 Handle(calling_thread, thread_oop),\n-                                                 owned_monitors_list);\n-      Handshake::execute(&op, java_thread);\n-      err = op.result();\n-    }\n-  } else {\n+  if (java_thread != nullptr) {\n+    Handle thread_handle(calling_thread, thread_oop);\n@@ -1454,11 +1431,4 @@\n-\n-    if (java_thread == calling_thread) {\n-      \/\/ It is only safe to make a direct call on the current thread.\n-      \/\/ All other usage needs to use a direct handshake for safety.\n-      err = get_owned_monitors(calling_thread, java_thread, owned_monitors_list);\n-    } else {\n-      \/\/ get owned monitors info with handshake\n-      GetOwnedMonitorInfoClosure op(calling_thread, this, owned_monitors_list);\n-      Handshake::execute(&op, java_thread);\n-      err = op.result();\n-    }\n+    \/\/ get owned monitors info with handshake\n+    GetOwnedMonitorInfoClosure op(this, calling_thread, owned_monitors_list);\n+    JvmtiHandshake::execute(&op, &tlh, java_thread, thread_handle);\n+    err = op.result();\n@@ -1466,0 +1436,1 @@\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":13,"deletions":42,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2000,0 +2000,1 @@\n+  bool is_virtual = java_lang_VirtualThread::is_instance(target_h());\n@@ -2002,1 +2003,3 @@\n-  hs_cl->set_self(self);           \/\/ needed when suspend is required for non-current target thread\n+  hs_cl->set_target_jt(target_jt);   \/\/ can be needed in the virtual thread case\n+  hs_cl->set_is_virtual(is_virtual); \/\/ needed when suspend is required for non-current target thread\n+  hs_cl->set_self(self);             \/\/ needed when suspend is required for non-current target thread\n@@ -2004,1 +2007,1 @@\n-  if (java_lang_VirtualThread::is_instance(target_h())) { \/\/ virtual thread\n+  if (is_virtual) {                \/\/ virtual thread\n@@ -2469,0 +2472,20 @@\n+void\n+GetOwnedMonitorInfoClosure::do_vthread(Handle target_h) {\n+  if (_target_jt == nullptr) {\n+    _result = JVMTI_ERROR_NONE;\n+    return;\n+  }\n+  Thread* current = Thread::current();\n+  ResourceMark rm(current); \/\/ vframes are resource allocated\n+  HandleMark hm(current);\n+\n+  javaVFrame *jvf = JvmtiEnvBase::get_vthread_jvf(target_h());\n+\n+  if (!_target_jt->is_exiting() && _target_jt->threadObj() != nullptr) {\n+    _result = ((JvmtiEnvBase *)_env)->get_owned_monitors(_calling_thread,\n+                                                         _target_jt,\n+                                                         jvf,\n+                                                         _owned_monitors_list);\n+  }\n+}\n+\n@@ -2585,21 +2608,0 @@\n-void\n-VirtualThreadGetOwnedMonitorInfoClosure::do_thread(Thread *target) {\n-  if (!JvmtiEnvBase::is_vthread_alive(_vthread_h())) {\n-    _result = JVMTI_ERROR_THREAD_NOT_ALIVE;\n-    return;\n-  }\n-  JavaThread* java_thread = JavaThread::cast(target);\n-  Thread* cur_thread = Thread::current();\n-  ResourceMark rm(cur_thread);\n-  HandleMark hm(cur_thread);\n-\n-  javaVFrame *jvf = JvmtiEnvBase::get_vthread_jvf(_vthread_h());\n-\n-  if (!java_thread->is_exiting() && java_thread->threadObj() != nullptr) {\n-    _result = ((JvmtiEnvBase *)_env)->get_owned_monitors(java_thread,\n-                                                         java_thread,\n-                                                         jvf,\n-                                                         _owned_monitors_list);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":25,"deletions":23,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -474,0 +474,3 @@\n+  \/\/ the fields below are set by the JvmtiHandshake::execute\n+  JavaThread* _target_jt;\n+  bool _is_virtual;\n@@ -479,0 +482,2 @@\n+      _target_jt(nullptr),\n+      _is_virtual(false),\n@@ -482,0 +487,2 @@\n+  void set_target_jt(JavaThread* target_jt) { _target_jt = target_jt; }\n+  void set_is_virtual(bool val) { _is_virtual = val; }\n@@ -545,1 +552,1 @@\n-class GetOwnedMonitorInfoClosure : public JvmtiHandshakeClosure {\n+class GetOwnedMonitorInfoClosure : public JvmtiUnitedHandshakeClosure {\n@@ -547,1 +554,0 @@\n-  JavaThread* _calling_thread;\n@@ -549,0 +555,1 @@\n+  JavaThread* _calling_thread;\n@@ -552,4 +559,4 @@\n-  GetOwnedMonitorInfoClosure(JavaThread* calling_thread, JvmtiEnv* env,\n-                             GrowableArray<jvmtiMonitorStackDepthInfo*>* owned_monitor_list)\n-    : JvmtiHandshakeClosure(\"GetOwnedMonitorInfo\"),\n-      _calling_thread(calling_thread),\n+  GetOwnedMonitorInfoClosure(JvmtiEnv* env,\n+                             JavaThread* calling_thread,\n+                             GrowableArray<jvmtiMonitorStackDepthInfo*>* owned_monitors_list)\n+    : JvmtiUnitedHandshakeClosure(\"GetOwnedMonitorInfo\"),\n@@ -557,1 +564,3 @@\n-      _owned_monitors_list(owned_monitor_list) {}\n+      _calling_thread(calling_thread),\n+      _owned_monitors_list(owned_monitors_list) {}\n+\n@@ -559,0 +568,1 @@\n+  void do_vthread(Handle target_h);\n@@ -770,22 +780,0 @@\n-\/\/ HandshakeClosure to get virtual thread monitor information with stack depth.\n-class VirtualThreadGetOwnedMonitorInfoClosure : public HandshakeClosure {\n-private:\n-  JvmtiEnv *_env;\n-  Handle _vthread_h;\n-  GrowableArray<jvmtiMonitorStackDepthInfo*> *_owned_monitors_list;\n-  jvmtiError _result;\n-\n-public:\n-  VirtualThreadGetOwnedMonitorInfoClosure(JvmtiEnv* env,\n-                                          Handle vthread_h,\n-                                          GrowableArray<jvmtiMonitorStackDepthInfo*>* owned_monitors_list)\n-    : HandshakeClosure(\"VirtualThreadGetOwnedMonitorInfo\"),\n-      _env(env),\n-      _vthread_h(vthread_h),\n-      _owned_monitors_list(owned_monitors_list),\n-      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {}\n-\n-  void do_thread(Thread *target);\n-  jvmtiError result() { return _result; }\n-};\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":18,"deletions":30,"binary":false,"changes":48,"status":"modified"}]}