{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -576,0 +576,1 @@\n+            ensureOpen();\n@@ -854,0 +855,1 @@\n+            ensureOpen();\n@@ -1042,0 +1044,1 @@\n+            ensureOpen();\n@@ -1072,0 +1075,1 @@\n+            ensureOpen();\n@@ -1155,0 +1159,1 @@\n+            ensureOpen();\n@@ -1185,0 +1190,1 @@\n+            ensureOpen();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -395,0 +395,1 @@\n+            ensureOpen();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -958,0 +958,1 @@\n+                    ensureOpen();\n@@ -1056,0 +1057,1 @@\n+                    ensureOpen();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -309,0 +309,1 @@\n+            ensureOpen();\n@@ -337,0 +338,1 @@\n+            ensureOpen();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SinkChannelImpl.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -309,0 +309,1 @@\n+            ensureOpen();\n@@ -337,0 +338,1 @@\n+            ensureOpen();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SourceChannelImpl.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8329190\n+ * @summary Test that I\/O operations on a closed network channel throw ClosedChannelException\n+ *    and not AsynchronousCloseException\n+ * @run junit ClosedNetworkChannels\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.AsynchronousCloseException;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.DatagramChannel;\n+import java.nio.channels.NotYetConnectedException;\n+import java.nio.channels.Pipe;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ClosedNetworkChannels {\n+\n+    \/**\n+     * An operation that does not return a result but may throw an exception.\n+     *\/\n+    @FunctionalInterface\n+    interface ThrowingRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    \/**\n+     * Assert that the given operation throws ClosedChannelException.\n+     *\/\n+    private void assertThrowsCCE(ThrowingRunnable op) throws Exception {\n+        try {\n+            op.run();\n+            fail();\n+        } catch (AsynchronousCloseException e) {\n+            fail(e + \" thrown\");\n+        } catch (ClosedChannelException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    \/**\n+     * Closes the given SocketChannel and checks that I\/O ops throw ClosedChannelException.\n+     *\/\n+    private void testSocketChannel(SocketChannel sc) throws Exception {\n+        sc.close();\n+\n+        InetAddress lb = InetAddress.getLoopbackAddress();\n+        SocketAddress target = new InetSocketAddress(lb, 7777);  \/\/ any port will do\n+\n+        ByteBuffer bb = ByteBuffer.allocate(100);\n+        ByteBuffer[] bufs = new ByteBuffer[] { bb };\n+\n+        assertThrowsCCE(() -> sc.connect(target));\n+        assertThrowsCCE(() -> sc.finishConnect());\n+        assertThrowsCCE(() -> sc.read(bb));\n+        assertThrowsCCE(() -> sc.read(bufs));\n+        assertThrowsCCE(() -> sc.read(bufs, 0, 1));\n+        assertThrowsCCE(() -> sc.write(bb));\n+        assertThrowsCCE(() -> sc.write(bufs));\n+        assertThrowsCCE(() -> sc.write(bufs, 0, 1));\n+    }\n+\n+    \/**\n+     * Test that I\/O operations on a closed (but previously unconnected) SocketChannel\n+     * throw ClosedChannelException.\n+     *\/\n+    @Test\n+    void testUnconnectedSocketChannel() throws Exception {\n+        SocketChannel sc = SocketChannel.open();\n+        testSocketChannel(sc);\n+    }\n+\n+    \/**\n+     * Test that I\/O operations on a closed (but previously connected) SocketChannel\n+     * throw ClosedChannelException.\n+     *\/\n+    @Test\n+    void testConnectedSocketChannel() throws Exception {\n+        try (ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+            ssc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+            try (SocketChannel sc = SocketChannel.open(ssc.getLocalAddress());\n+                 SocketChannel peer = ssc.accept()) {\n+                testSocketChannel(sc);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test that the accept operation on a closed (but previously unbound) ServerSocketChannel\n+     * throws ClosedChannelException.\n+     *\/\n+    @Test\n+    void testUnboundServerSocketChannel() throws Exception {\n+        ServerSocketChannel ssc = ServerSocketChannel.open();\n+        ssc.close();\n+        assertThrowsCCE(() -> ssc.accept());\n+    }\n+\n+    \/**\n+     * Test that the accept operation on a closed (but previously bound) ServerSocketChannel\n+     * throws ClosedChannelException.\n+     *\/\n+    @Test\n+    void testBoundServerSocketChannel() throws Exception {\n+        try (ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+            ssc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+            ssc.close();\n+            assertThrowsCCE(() -> ssc.accept());\n+        }\n+    }\n+\n+    \/**\n+     * Test that I\/O operations on a closed Pipe.SourceChannel and Pipe.SinkChannel\n+     * throw ClosedChannelException.\n+     *\/\n+    @Test\n+    void testSourceAndSinkChannels() throws Exception {\n+        Pipe p = Pipe.open();\n+        try (Pipe.SourceChannel source = p.source();\n+             Pipe.SinkChannel sink = p.sink()) {\n+            source.close();\n+            sink.close();\n+\n+            ByteBuffer bb = ByteBuffer.allocate(100);\n+            ByteBuffer[] bufs = new ByteBuffer[]{bb};\n+\n+            assertThrowsCCE(() -> source.read(bb));\n+            assertThrowsCCE(() -> source.read(bufs));\n+            assertThrowsCCE(() -> source.read(bufs, 0, 1));\n+            assertThrowsCCE(() -> sink.write(bb));\n+            assertThrowsCCE(() -> sink.write(bufs));\n+            assertThrowsCCE(() -> sink.write(bufs, 0, 1));\n+        }\n+    }\n+\n+    \/**\n+     * Closes the given DatagramChannel and checks that I\/O ops throw ClosedChannelException.\n+     *\/\n+    private void testDatagramChannel(DatagramChannel dc) throws Exception {\n+        dc.close();\n+\n+        InetAddress lb = InetAddress.getLoopbackAddress();\n+        SocketAddress target = new InetSocketAddress(lb, 7777);  \/\/ any port will do\n+\n+        ByteBuffer bb = ByteBuffer.allocate(100);\n+        ByteBuffer[] bufs = new ByteBuffer[] { bb };\n+\n+        assertThrowsCCE(() -> dc.send(bb, target));\n+        assertThrowsCCE(() -> dc.receive(bb));\n+        assertThrowsCCE(() -> dc.read(bb));\n+        assertThrowsCCE(() -> dc.read(bufs));\n+        assertThrowsCCE(() -> dc.read(bufs, 0, 1));\n+        assertThrowsCCE(() -> dc.write(bb));\n+        assertThrowsCCE(() -> dc.write(bufs));\n+        assertThrowsCCE(() -> dc.write(bufs, 0, 1));\n+    }\n+\n+    \/**\n+     * Test that I\/O operations on a closed (but previously unconnected) DatagramChannel\n+     * throw ClosedChannelException.\n+     *\/\n+    @Test\n+    void testUnconnectedDatagramChannel() throws Exception {\n+        DatagramChannel dc = DatagramChannel.open();\n+        testDatagramChannel(dc);\n+    }\n+\n+    \/**\n+     * Test that I\/O operations on a closed (but previously connected) DatagramChannel\n+     * throw ClosedChannelException.\n+     *\/\n+    @Test\n+    void testConnectedDatagramChannel() throws Exception {\n+        try (DatagramChannel dc = DatagramChannel.open()) {\n+            InetAddress lb = InetAddress.getLoopbackAddress();\n+            dc.bind(new InetSocketAddress(lb, 0));\n+            dc.connect(new InetSocketAddress(lb, 7777));  \/\/ any port will do\n+            testDatagramChannel(dc);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/ClosedNetworkChannels.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"}]}