{"files":[{"patch":"@@ -966,1 +966,1 @@\n-static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, int& real_shift, int& masked_shift) {\n+static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, int& real_shift, uint& masked_shift) {\n@@ -975,1 +975,1 @@\n-static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, int& masked_shift) {\n+static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, uint& masked_shift) {\n@@ -982,1 +982,1 @@\n-static int mask_and_replace_shift_amount(PhaseGVN* phase, Node* shift_node, uint nBits) {\n+static uint mask_and_replace_shift_amount(PhaseGVN* phase, Node* shift_node, uint nBits) {\n@@ -984,1 +984,1 @@\n-  int masked_shift;\n+  uint masked_shift;\n@@ -991,1 +991,1 @@\n-    if (real_shift != masked_shift) {\n+    if (real_shift != (int)masked_shift) {\n@@ -1016,1 +1016,1 @@\n-static Node* collapse_nested_shift_left(PhaseGVN* phase, const Node* outer_shift, int con_outer, BasicType bt) {\n+static Node* collapse_nested_shift_left(PhaseGVN* phase, const Node* outer_shift, uint con_outer, BasicType bt) {\n@@ -1023,2 +1023,2 @@\n-  int nbits = static_cast<int>(bits_per_java_integer(bt));\n-  int con_inner;\n+  uint nbits = bits_per_java_integer(bt);\n+  uint con_inner;\n@@ -1049,6 +1049,1 @@\n-  int count = 0;\n-  if (const_shift_count(phase, this, &count) && (count & (BitsPerJavaInteger - 1)) == 0) {\n-    \/\/ Shift by a multiple of 32 does nothing\n-    return in(1);\n-  }\n-  return this;\n+  return IdentityIL(phase, T_INT);\n@@ -1057,8 +1052,2 @@\n-\/\/------------------------------Ideal------------------------------------------\n-\/\/ If the right input is a constant, and the left input is an add of a\n-\/\/ constant, flatten the tree: (X+con1)<<con0 ==> X<<con0 + con1<<con0\n-\/\/\n-\/\/ Also collapse nested left-shifts with constant rhs:\n-\/\/ (X << con1) << con2 ==> X << (con1 + con2)\n-Node *LShiftINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  int con = mask_and_replace_shift_amount(phase, this, BitsPerJavaInteger);\n+Node* LShiftNode::IdealIL(PhaseGVN* phase, bool can_reshape, BasicType bt) {\n+  uint con = mask_and_replace_shift_amount(phase, this, bits_per_java_integer(bt));\n@@ -1069,2 +1058,3 @@\n-  \/\/ Left input is an add?\n-  Node *add1 = in(1);\n+  \/\/ If the right input is a constant, and the left input is an add of a\n+  \/\/ constant, flatten the tree: (X+con1)<<con0 ==> X<<con0 + con1<<con0\n+  Node* add1 = in(1);\n@@ -1072,2 +1062,2 @@\n-  if( add1_op == Op_AddI ) {    \/\/ Left input is an add?\n-    assert( add1 != add1->in(1), \"dead loop in LShiftINode::Ideal\" );\n+  if (add1_op == Op_Add(bt)) {    \/\/ Left input is an add?\n+    assert(add1 != add1->in(1), \"dead loop in LShiftINode::Ideal\");\n@@ -1077,1 +1067,1 @@\n-    if( con < 16 ) {\n+    if (bt != T_INT || con < 16) {\n@@ -1079,1 +1069,1 @@\n-      if (add1->in(1) == add1->in(2)) {\n+      if (con != (bits_per_java_integer(bt) - 1) && add1->in(1) == add1->in(2)) {\n@@ -1081,1 +1071,1 @@\n-        \/\/ In general, this optimization cannot be applied for c0 == 31 since\n+        \/\/ In general, this optimization cannot be applied for c0 == 31 (for LShiftI) since\n@@ -1083,1 +1073,6 @@\n-        return new LShiftINode(add1->in(1), phase->intcon(con + 1));\n+        \/\/ or c0 != 63 (for LShiftL) because:\n+        \/\/ (x + x) << 63 = 2x << 63, while\n+        \/\/ (x + x) << 63 --transform--> x << 64 = x << 0 = x (!= 2x << 63, for example for x = 1)\n+        \/\/ According to the Java spec, chapter 15.19, we only consider the six lowest-order bits of the right-hand operand\n+        \/\/ (i.e. \"right-hand operand\" & 0b111111). Therefore, x << 64 is the same as x << 0 (64 = 0b10000000 & 0b0111111 = 0).\n+        return LShiftNode::make(add1->in(1), phase->intcon(con + 1), bt);\n@@ -1087,2 +1082,2 @@\n-      const TypeInt *t12 = phase->type(add1->in(2))->isa_int();\n-      if( t12 && t12->is_con() ){ \/\/ Left input is an add of a con?\n+      const TypeInteger* t12 = phase->type(add1->in(2))->isa_integer(bt);\n+      if (t12 != nullptr && t12->is_con()) { \/\/ Left input is an add of a con?\n@@ -1090,1 +1085,1 @@\n-        Node *lsh = phase->transform( new LShiftINode( add1->in(1), in(2) ) );\n+        Node* lsh = phase->transform(LShiftNode::make(add1->in(1), in(2), bt));\n@@ -1092,1 +1087,1 @@\n-        return new AddINode( lsh, phase->intcon(t12->get_con() << con));\n+        return AddNode::make(lsh, phase->integercon(java_shift_left(t12->get_con_as_long(bt), con, bt), bt), bt);\n@@ -1098,1 +1093,1 @@\n-  if (add1_op == Op_RShiftI || add1_op == Op_URShiftI) {\n+  if (add1_op == Op_RShift(bt) || add1_op == Op_URShift(bt)) {\n@@ -1103,1 +1098,1 @@\n-    if (add1Con > 0 && con == add1Con) {\n+    if (add1Con > 0 && con == (uint)add1Con) {\n@@ -1105,1 +1100,1 @@\n-      return new AndINode(add1->in(1), phase->intcon(java_negate(jint(1 << con))));\n+      return  MulNode::make_and(add1->in(1), phase->integercon(java_negate(java_shift_left(1, con, bt), bt), bt), bt);\n@@ -1108,1 +1103,1 @@\n-      if (add1Con > 0 && add1Con < BitsPerJavaInteger) {\n+      if (add1Con > 0 && (uint)add1Con < bits_per_java_integer(bt)) {\n@@ -1112,1 +1107,1 @@\n-          if (con > add1Con) {\n+          if (con > (uint)add1Con) {\n@@ -1114,2 +1109,2 @@\n-            Node* lshift = phase->transform(new LShiftINode(add1->in(1), phase->intcon(con - add1Con)));\n-            return new AndINode(lshift, phase->intcon(java_negate(jint(1 << con))));\n+            Node* lshift = phase->transform(LShiftNode::make(add1->in(1), phase->intcon(con - add1Con), bt));\n+            return MulNode::make_and(lshift, phase->integercon(java_negate(java_shift_left(1, con, bt), bt), bt), bt);\n@@ -1117,1 +1112,1 @@\n-            assert(con < add1Con, \"must be (%d < %d)\", con, add1Con);\n+            assert(con < (uint)add1Con, \"must be (%d < %d)\", con, add1Con);\n@@ -1122,2 +1117,2 @@\n-            if (add1_op == Op_RShiftI) {\n-              rshift = phase->transform(new RShiftINode(add1->in(1), phase->intcon(add1Con - con)));\n+            if (add1_op == Op_RShift(bt)) {\n+              rshift = phase->transform(RShiftNode::make(add1->in(1), phase->intcon(add1Con - con), bt));\n@@ -1125,1 +1120,1 @@\n-              rshift = phase->transform(new URShiftINode(add1->in(1), phase->intcon(add1Con - con)));\n+              rshift = phase->transform(URShiftNode::make(add1->in(1), phase->intcon(add1Con - con), bt));\n@@ -1128,1 +1123,1 @@\n-            return new AndINode(rshift, phase->intcon(java_negate(jint(1 << con))));\n+            return MulNode::make_and(rshift, phase->integercon(java_negate(java_shift_left(1,  con, bt)), bt), bt);\n@@ -1138,2 +1133,2 @@\n-  if (add1_op == Op_AndI) {\n-    Node *add2 = add1->in(1);\n+  if (add1_op == Op_And(bt)) {\n+    Node* add2 = add1->in(1);\n@@ -1141,1 +1136,1 @@\n-    if (add2_op == Op_RShiftI || add2_op == Op_URShiftI) {\n+    if (add2_op == Op_RShift(bt) || add2_op == Op_URShift(bt)) {\n@@ -1145,2 +1140,2 @@\n-        Node* y_sh = phase->transform(new LShiftINode(add1->in(2), phase->intcon(con)));\n-        return new AndINode(add2->in(1), y_sh);\n+        Node* y_sh = phase->transform(LShiftNode::make(add1->in(2), phase->intcon(con), bt));\n+        return MulNode::make_and(add2->in(1), y_sh, bt);\n@@ -1151,1 +1146,1 @@\n-      if (add2Con > 0 && add2Con < BitsPerJavaInteger) {\n+      if (add2Con > 0 && (uint)add2Con < bits_per_java_integer(bt)) {\n@@ -1156,1 +1151,1 @@\n-          Node* x_sh = phase->transform(new LShiftINode(add2, phase->intcon(con)));\n+          Node* x_sh = phase->transform(LShiftNode::make(add2, phase->intcon(con), bt));\n@@ -1158,1 +1153,1 @@\n-          Node* y_sh = phase->transform(new LShiftINode(add1->in(2), phase->intcon(con)));\n+          Node* y_sh = phase->transform(LShiftNode::make(add1->in(2), phase->intcon(con), bt));\n@@ -1160,1 +1155,1 @@\n-          return new AndINode(x_sh, y_sh);\n+          return MulNode::make_and(x_sh, y_sh, bt);\n@@ -1170,4 +1165,6 @@\n-  const jint bits_mask = right_n_bits(BitsPerJavaInteger-con);\n-  if( add1_op == Op_AndI &&\n-      phase->type(add1->in(2)) == TypeInt::make( bits_mask ) )\n-    return new LShiftINode( add1->in(1), in(2) );\n+  const jlong bits_mask = max_unsigned_integer(bt) >> con;\n+  assert(bt != T_INT || bits_mask == right_n_bits(bits_per_java_integer(bt)-con), \"inconsistent\");\n+  if (add1_op == Op_And(bt) &&\n+      phase->type(add1->in(2)) == TypeInteger::make(bits_mask, bt)) {\n+    return LShiftNode::make(add1->in(1), in(2), bt);\n+  }\n@@ -1175,1 +1172,1 @@\n-  \/\/ Performs:\n+  \/\/ Collapse nested left-shifts with constant rhs:\n@@ -1177,1 +1174,1 @@\n-  Node* doubleShift = collapse_nested_shift_left(phase, this, con, T_INT);\n+  Node* doubleShift = collapse_nested_shift_left(phase, this, con, bt);\n@@ -1185,5 +1182,8 @@\n-\/\/------------------------------Value------------------------------------------\n-\/\/ A LShiftINode shifts its input2 left by input1 amount.\n-const Type* LShiftINode::Value(PhaseGVN* phase) const {\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n+\/\/------------------------------Ideal------------------------------------------\n+Node* LShiftINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  return IdealIL(phase, can_reshape, T_INT);\n+}\n+\n+const Type* LShiftNode::ValueIL(PhaseGVN* phase, BasicType bt) const {\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n@@ -1191,2 +1191,6 @@\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+  if (t1 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  if (t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n@@ -1195,1 +1199,3 @@\n-  if( t1 == TypeInt::ZERO ) return TypeInt::ZERO;\n+  if (t1 == TypeInteger::zero(bt)) {\n+    return TypeInteger::zero(bt);\n+  }\n@@ -1197,1 +1203,3 @@\n-  if( t2 == TypeInt::ZERO ) return t1;\n+  if (t2 == TypeInt::ZERO) {\n+    return t1;\n+  }\n@@ -1200,3 +1208,4 @@\n-  if( (t1 == TypeInt::INT) || (t2 == TypeInt::INT) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return TypeInt::INT;\n+  if ((t1 == TypeInteger::bottom(bt)) || (t2 == TypeInt::INT) ||\n+      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM)) {\n+    return TypeInteger::bottom(bt);\n+  }\n@@ -1204,2 +1213,2 @@\n-  const TypeInt *r1 = t1->is_int(); \/\/ Handy access\n-  const TypeInt *r2 = t2->is_int(); \/\/ Handy access\n+  const TypeInteger* r1 = t1->is_integer(bt); \/\/ Handy access\n+  const TypeInt* r2 = t2->is_int(); \/\/ Handy access\n@@ -1207,2 +1216,3 @@\n-  if (!r2->is_con())\n-    return TypeInt::INT;\n+  if (!r2->is_con()) {\n+    return TypeInteger::bottom(bt);\n+  }\n@@ -1211,3 +1221,5 @@\n-  shift &= BitsPerJavaInteger-1;  \/\/ semantics of Java shifts\n-  \/\/ Shift by a multiple of 32 does nothing:\n-  if (shift == 0)  return t1;\n+  shift &= bits_per_java_integer(bt) - 1;  \/\/ semantics of Java shifts\n+  \/\/ Shift by a multiple of 32\/64 does nothing:\n+  if (shift == 0) {\n+    return t1;\n+  }\n@@ -1218,3 +1230,10 @@\n-    jint lo = r1->_lo, hi = r1->_hi;\n-    if (((lo << shift) >> shift) == lo &&\n-        ((hi << shift) >> shift) == hi) {\n+    jlong lo = r1->lo_as_long(), hi = r1->hi_as_long();\n+#ifdef ASSERT\n+    if (bt == T_INT) {\n+      jint lo_int = r1->is_int()->_lo, hi_int = r1->is_int()->_hi;\n+      assert((java_shift_right(java_shift_left(lo, shift, bt),  shift, bt) == lo) == (((lo_int << shift) >> shift) == lo_int), \"inconsistent\");\n+      assert((java_shift_right(java_shift_left(hi, shift, bt),  shift, bt) == hi) == (((hi_int << shift) >> shift) == hi_int), \"inconsistent\");\n+    }\n+#endif\n+    if (java_shift_right(java_shift_left(lo, shift, bt),  shift, bt) == lo &&\n+        java_shift_right(java_shift_left(hi, shift, bt), shift, bt) == hi) {\n@@ -1222,3 +1241,3 @@\n-      return TypeInt::make((jint)lo << (jint)shift,\n-                           (jint)hi << (jint)shift,\n-                           MAX2(r1->_widen,r2->_widen));\n+      return TypeInteger::make(java_shift_left(lo, shift, bt),\n+                               java_shift_left(hi,  shift, bt),\n+                               MAX2(r1->_widen, r2->_widen), bt);\n@@ -1226,1 +1245,1 @@\n-    return TypeInt::INT;\n+    return TypeInteger::bottom(bt);\n@@ -1229,1 +1248,1 @@\n-  return TypeInt::make( (jint)r1->get_con() << (jint)shift );\n+  return TypeInteger::make(java_shift_left(r1->get_con_as_long(bt), shift, bt), bt);\n@@ -1232,3 +1251,6 @@\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-Node* LShiftLNode::Identity(PhaseGVN* phase) {\n+\/\/------------------------------Value------------------------------------------\n+const Type* LShiftINode::Value(PhaseGVN* phase) const {\n+  return ValueIL(phase, T_INT);\n+}\n+\n+Node* LShiftNode::IdentityIL(PhaseGVN* phase, BasicType bt) {\n@@ -1236,2 +1258,2 @@\n-  if (const_shift_count(phase, this, &count) && (count & (BitsPerJavaLong - 1)) == 0) {\n-    \/\/ Shift by a multiple of 64 does nothing\n+  if (const_shift_count(phase, this, &count) && (count & (bits_per_java_integer(bt) - 1)) == 0) {\n+    \/\/ Shift by a multiple of 32\/64 does nothing\n@@ -1243,124 +1265,5 @@\n-\/\/------------------------------Ideal------------------------------------------\n-\/\/ If the right input is a constant, and the left input is an add of a\n-\/\/ constant, flatten the tree: (X+con1)<<con0 ==> X<<con0 + con1<<con0\n-\/\/\n-\/\/ Also collapse nested left-shifts with constant rhs:\n-\/\/ (X << con1) << con2 ==> X << (con1 + con2)\n-Node *LShiftLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  int con = mask_and_replace_shift_amount(phase, this, BitsPerJavaLong);\n-  if (con == 0) {\n-    return nullptr;\n-  }\n-\n-  \/\/ Left input is an add?\n-  Node *add1 = in(1);\n-  int add1_op = add1->Opcode();\n-  if( add1_op == Op_AddL ) {    \/\/ Left input is an add?\n-    \/\/ Avoid dead data cycles from dead loops\n-    assert( add1 != add1->in(1), \"dead loop in LShiftLNode::Ideal\" );\n-\n-    \/\/ Left input is an add of the same number?\n-    if (con != (BitsPerJavaLong - 1) && add1->in(1) == add1->in(2)) {\n-      \/\/ Convert \"(x + x) << c0\" into \"x << (c0 + 1)\"\n-      \/\/ Can only be applied if c0 != 63 because:\n-      \/\/ (x + x) << 63 = 2x << 63, while\n-      \/\/ (x + x) << 63 --transform--> x << 64 = x << 0 = x (!= 2x << 63, for example for x = 1)\n-      \/\/ According to the Java spec, chapter 15.19, we only consider the six lowest-order bits of the right-hand operand\n-      \/\/ (i.e. \"right-hand operand\" & 0b111111). Therefore, x << 64 is the same as x << 0 (64 = 0b10000000 & 0b0111111 = 0).\n-      return new LShiftLNode(add1->in(1), phase->intcon(con + 1));\n-    }\n-\n-    \/\/ Left input is an add of a constant?\n-    const TypeLong *t12 = phase->type(add1->in(2))->isa_long();\n-    if( t12 && t12->is_con() ){ \/\/ Left input is an add of a con?\n-      \/\/ Compute X << con0\n-      Node *lsh = phase->transform( new LShiftLNode( add1->in(1), in(2) ) );\n-      \/\/ Compute X<<con0 + (con1<<con0)\n-      return new AddLNode( lsh, phase->longcon(t12->get_con() << con));\n-    }\n-  }\n-\n-  \/\/ Check for \"(x >> C1) << C2\"\n-  if (add1_op == Op_RShiftL || add1_op == Op_URShiftL) {\n-    int add1Con = 0;\n-    const_shift_count(phase, add1, &add1Con);\n-\n-    \/\/ Special case C1 == C2, which just masks off low bits\n-    if (add1Con > 0 && con == add1Con) {\n-      \/\/ Convert to \"(x & -(1 << C2))\"\n-      return new AndLNode(add1->in(1), phase->longcon(java_negate(jlong(CONST64(1) << con))));\n-    } else {\n-      \/\/ Wait until the right shift has been sharpened to the correct count\n-      if (add1Con > 0 && add1Con < BitsPerJavaLong) {\n-        \/\/ As loop parsing can produce LShiftI nodes, we should wait until the graph is fully formed\n-        \/\/ to apply optimizations, otherwise we can inadvertently stop vectorization opportunities.\n-        if (phase->is_IterGVN()) {\n-          if (con > add1Con) {\n-            \/\/ Creates \"(x << (C2 - C1)) & -(1 << C2)\"\n-            Node* lshift = phase->transform(new LShiftLNode(add1->in(1), phase->intcon(con - add1Con)));\n-            return new AndLNode(lshift, phase->longcon(java_negate(jlong(CONST64(1) << con))));\n-          } else {\n-            assert(con < add1Con, \"must be (%d < %d)\", con, add1Con);\n-            \/\/ Creates \"(x >> (C1 - C2)) & -(1 << C2)\"\n-\n-            \/\/ Handle logical and arithmetic shifts\n-            Node* rshift;\n-            if (add1_op == Op_RShiftL) {\n-              rshift = phase->transform(new RShiftLNode(add1->in(1), phase->intcon(add1Con - con)));\n-            } else {\n-              rshift = phase->transform(new URShiftLNode(add1->in(1), phase->intcon(add1Con - con)));\n-            }\n-\n-            return new AndLNode(rshift, phase->longcon(java_negate(jlong(CONST64(1) << con))));\n-          }\n-        } else {\n-          phase->record_for_igvn(this);\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Check for \"((x >> C1) & Y) << C2\"\n-  if (add1_op == Op_AndL) {\n-    Node* add2 = add1->in(1);\n-    int add2_op = add2->Opcode();\n-    if (add2_op == Op_RShiftL || add2_op == Op_URShiftL) {\n-      \/\/ Special case C1 == C2, which just masks off low bits\n-      if (add2->in(2) == in(2)) {\n-        \/\/ Convert to \"(x & (Y << C2))\"\n-        Node* y_sh = phase->transform(new LShiftLNode(add1->in(2), phase->intcon(con)));\n-        return new AndLNode(add2->in(1), y_sh);\n-      }\n-\n-      int add2Con = 0;\n-      const_shift_count(phase, add2, &add2Con);\n-      if (add2Con > 0 && add2Con < BitsPerJavaLong) {\n-        if (phase->is_IterGVN()) {\n-          \/\/ Convert to \"((x >> C1) << C2) & (Y << C2)\"\n-\n-          \/\/ Make \"(x >> C1) << C2\", which will get folded away by the rule above\n-          Node* x_sh = phase->transform(new LShiftLNode(add2, phase->intcon(con)));\n-          \/\/ Make \"Y << C2\", which will simplify when Y is a constant\n-          Node* y_sh = phase->transform(new LShiftLNode(add1->in(2), phase->intcon(con)));\n-\n-          return new AndLNode(x_sh, y_sh);\n-        } else {\n-          phase->record_for_igvn(this);\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Check for ((x & ((CONST64(1)<<(64-c0))-1)) << c0) which ANDs off high bits\n-  \/\/ before shifting them away.\n-  const jlong bits_mask = jlong(max_julong >> con);\n-  if( add1_op == Op_AndL &&\n-      phase->type(add1->in(2)) == TypeLong::make( bits_mask ) )\n-    return new LShiftLNode( add1->in(1), in(2) );\n-\n-  \/\/ Performs:\n-  \/\/ (X << con1) << con2 ==> X << (con1 + con2)\n-  Node* doubleShift = collapse_nested_shift_left(phase, this, con, T_LONG);\n-  if (doubleShift != nullptr) {\n-    return doubleShift;\n-  }\n+\/\/=============================================================================\n+\/\/------------------------------Identity---------------------------------------\n+Node* LShiftLNode::Identity(PhaseGVN* phase) {\n+  return IdentityIL(phase, T_LONG);\n+}\n@@ -1368,1 +1271,3 @@\n-  return nullptr;\n+\/\/------------------------------Ideal------------------------------------------\n+Node* LShiftLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return IdealIL(phase, can_reshape, T_LONG);\n@@ -1372,1 +1277,0 @@\n-\/\/ A LShiftLNode shifts its input2 left by input1 amount.\n@@ -1374,42 +1278,1 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  \/\/ Either input is TOP ==> the result is TOP\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n-\n-  \/\/ Left input is ZERO ==> the result is ZERO.\n-  if( t1 == TypeLong::ZERO ) return TypeLong::ZERO;\n-  \/\/ Shift by zero does nothing\n-  if( t2 == TypeInt::ZERO ) return t1;\n-\n-  \/\/ Either input is BOTTOM ==> the result is BOTTOM\n-  if( (t1 == TypeLong::LONG) || (t2 == TypeInt::INT) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return TypeLong::LONG;\n-\n-  const TypeLong *r1 = t1->is_long(); \/\/ Handy access\n-  const TypeInt  *r2 = t2->is_int();  \/\/ Handy access\n-\n-  if (!r2->is_con())\n-    return TypeLong::LONG;\n-\n-  uint shift = r2->get_con();\n-  shift &= BitsPerJavaLong - 1;  \/\/ semantics of Java shifts\n-  \/\/ Shift by a multiple of 64 does nothing:\n-  if (shift == 0)  return t1;\n-\n-  \/\/ If the shift is a constant, shift the bounds of the type,\n-  \/\/ unless this could lead to an overflow.\n-  if (!r1->is_con()) {\n-    jlong lo = r1->_lo, hi = r1->_hi;\n-    if (((lo << shift) >> shift) == lo &&\n-        ((hi << shift) >> shift) == hi) {\n-      \/\/ No overflow.  The range shifts up cleanly.\n-      return TypeLong::make((jlong)lo << (jint)shift,\n-                            (jlong)hi << (jint)shift,\n-                            MAX2(r1->_widen,r2->_widen));\n-    }\n-    return TypeLong::LONG;\n-  }\n-\n-  return TypeLong::make( (jlong)r1->get_con() << (jint)shift );\n+  return ValueIL(phase, T_LONG);\n@@ -1652,0 +1515,12 @@\n+URShiftNode* URShiftNode::make(Node* in1, Node* in2, BasicType bt) {\n+  switch (bt) {\n+    case T_INT:\n+      return new URShiftINode(in1, in2);\n+    case T_LONG:\n+      return new URShiftLNode(in1, in2);\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n+  }\n+  return nullptr;\n+}\n+\n@@ -1687,1 +1562,1 @@\n-Node *URShiftINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* URShiftINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n@@ -1851,1 +1726,1 @@\n-Node *URShiftLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* URShiftLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":138,"deletions":263,"binary":false,"changes":401,"status":"modified"},{"patch":"@@ -263,1 +263,1 @@\n-  LShiftNode(Node *in1, Node *in2) : Node(nullptr,in1,in2) {\n+  LShiftNode(Node* in1, Node* in2) : Node(nullptr,in1,in2) {\n@@ -267,0 +267,4 @@\n+  const Type* ValueIL(PhaseGVN* phase, BasicType bt) const;\n+  Node* IdentityIL(PhaseGVN* phase, BasicType bt);\n+  Node* IdealIL(PhaseGVN* phase, bool can_reshape, BasicType bt);\n+\n@@ -274,1 +278,1 @@\n-  LShiftINode(Node *in1, Node *in2) : LShiftNode(in1,in2) {}\n+  LShiftINode(Node* in1, Node* in2) : LShiftNode(in1,in2) {}\n@@ -277,1 +281,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN *phase, bool can_reshape);\n@@ -279,1 +283,1 @@\n-  const Type *bottom_type() const { return TypeInt::INT; }\n+  const Type* bottom_type() const { return TypeInt::INT; }\n@@ -290,1 +294,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN *phase, bool can_reshape);\n@@ -292,1 +296,1 @@\n-  const Type *bottom_type() const { return TypeLong::LONG; }\n+  const Type* bottom_type() const { return TypeLong::LONG; }\n@@ -361,0 +365,6 @@\n+class URShiftNode : public Node {\n+public:\n+  URShiftNode(Node* in1, Node* in2) : Node(nullptr, in1, in2) {}\n+  static URShiftNode* make(Node* in1, Node* in2, BasicType bt);\n+};\n+\n@@ -363,1 +373,1 @@\n-class URShiftBNode : public Node {\n+class URShiftBNode : public URShiftNode {\n@@ -365,1 +375,1 @@\n-  URShiftBNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {\n+  URShiftBNode(Node* in1, Node* in2) : URShiftNode(in1,in2) {\n@@ -373,1 +383,1 @@\n-class URShiftSNode : public Node {\n+class URShiftSNode : public URShiftNode {\n@@ -375,1 +385,1 @@\n-  URShiftSNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {\n+  URShiftSNode(Node* in1, Node* in2) : URShiftNode(in1,in2) {\n@@ -383,1 +393,1 @@\n-class URShiftINode : public Node {\n+class URShiftINode : public URShiftNode {\n@@ -385,1 +395,1 @@\n-  URShiftINode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n+  URShiftINode(Node* in1, Node* in2) : URShiftNode(in1,in2) {}\n@@ -388,1 +398,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -390,1 +400,1 @@\n-  const Type *bottom_type() const { return TypeInt::INT; }\n+  const Type* bottom_type() const { return TypeInt::INT; }\n@@ -396,1 +406,1 @@\n-class URShiftLNode : public Node {\n+class URShiftLNode : public URShiftNode {\n@@ -398,1 +408,1 @@\n-  URShiftLNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n+  URShiftLNode(Node* in1, Node* in2) : URShiftNode(in1,in2) {}\n@@ -401,1 +411,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -403,1 +413,1 @@\n-  const Type *bottom_type() const { return TypeLong::LONG; }\n+  const Type* bottom_type() const { return TypeLong::LONG; }\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":28,"deletions":18,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2089,0 +2089,1 @@\n+Op_IL(RShift)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -1256,0 +1257,8 @@\n+inline jlong java_negate(jlong v, BasicType bt) {\n+  if (bt == T_INT) {\n+    return java_negate(checked_cast<jint>(v));\n+  }\n+  assert(bt == T_LONG, \"int or long only\");\n+  return java_negate(v);\n+}\n+\n@@ -1262,1 +1271,1 @@\n-    return FUNC((jint) lhs, rhs);                      \\\n+    return FUNC(checked_cast<jint>(lhs), rhs);         \\\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -57,0 +57,11 @@\n+            \"testShiftValue\",\n+            \"testShiftValueOverflow\",\n+            \"testShiftMultiple32\",\n+            \"testShiftOfAddSameInput\",\n+            \"testLargeShiftOfAddSameInput\",\n+            \"testShiftOfAddConstant\",\n+            \"testLShiftOfAndOfRShiftSameCon\",\n+            \"testLShiftOfAndOfURShiftSameCon\",\n+            \"testLShiftOfAndOfRShift\",\n+            \"testLShiftOfAndOfURShift\",\n+            \"testLShiftOfAndOfCon\",\n@@ -74,0 +85,23 @@\n+\n+        Asserts.assertEQ(42 << 1, testShiftValue(42));\n+        Asserts.assertEQ(Integer.MAX_VALUE << 1, testShiftValueOverflow(Integer.MAX_VALUE));\n+        Asserts.assertEQ((Integer.MAX_VALUE-1) << 1, testShiftValueOverflow(Integer.MAX_VALUE-1));\n+\n+        assertResult(a, b);\n+        assertResult(c, d);\n+        assertResult(a, min);\n+        assertResult(a, max);\n+        assertResult(min, a);\n+        assertResult(max, a);\n+        assertResult(min, max);\n+        assertResult(max, min);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    private void assertResult(int a, int b) {\n+        otherInput = b;\n+        Asserts.assertEQ(((a >> 4) & b) << 4, testLShiftOfAndOfRShiftSameCon(a));\n+        Asserts.assertEQ(((a >>> 4) & b) << 4, testLShiftOfAndOfURShiftSameCon(a));\n+        Asserts.assertEQ(((a >> 4) & b) << 8, testLShiftOfAndOfRShift(a));\n+        Asserts.assertEQ(((a >>> 4) & b) << 8, testLShiftOfAndOfURShift(a));\n@@ -86,0 +120,5 @@\n+        Asserts.assertEQ(a, testShiftMultiple32(a));\n+        Asserts.assertEQ((a + a) << 1, testShiftOfAddSameInput(a));\n+        Asserts.assertEQ((a + a) << 31, testLargeShiftOfAddSameInput(a));\n+        Asserts.assertEQ(((a + 1) << 1) + 1, testShiftOfAddConstant(a));\n+        Asserts.assertEQ((a & ((1 << (32 - 10)) -1)) << 10, testLShiftOfAndOfCon(a));\n@@ -270,0 +309,103 @@\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\"}, failOn = { IRNode.IF } )\n+    public int testShiftValue(int x) {\n+        x = Integer.min(Integer.max(x, 10), 100);\n+        int shift = x << 1;\n+        if (shift > 200 || shift < 20) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        return shift;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\", IRNode.IF, \"2\" } )\n+    public int testShiftValueOverflow(int x) {\n+        x = Integer.max(x, Integer.MAX_VALUE - 1);\n+        int shift = x << 1;\n+        if (shift != -2 && shift != -4) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        return shift;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LSHIFT_I } )\n+    public int testShiftMultiple32(int x) {\n+        return x << 128;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" }, failOn = { IRNode.ADD_I } )\n+    public int testShiftOfAddSameInput(int x) {\n+        return (x + x) << 1;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.ADD_I, \"1\" } )\n+    public int testLargeShiftOfAddSameInput(int x) {\n+        return (x + x) << 31;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\",  IRNode.ADD_I, \"1\" } )\n+    public int testShiftOfAddConstant(int x) {\n+        return ((x + 1) << 1) + 1;\n+    }\n+\n+    static short shortField;\n+    static byte byteField;\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\"} , failOn = { IRNode.LSHIFT_I, IRNode.RSHIFT_I } )\n+    @Arguments( values = { Argument.NUMBER_42 })\n+    public void testStoreShort(int x) {\n+        shortField = (short)(x + x);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\"} , failOn = { IRNode.LSHIFT_I, IRNode.RSHIFT_I } )\n+    @Arguments( values = { Argument.NUMBER_42 })\n+    public void testStoreByte(int x) {\n+        byteField = (byte)(x + x);\n+    }\n+\n+    static int otherInput;\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_I, \"1\", IRNode.LSHIFT_I, \"1\" } , failOn = { IRNode.RSHIFT_I } )\n+    public int testLShiftOfAndOfRShiftSameCon(int x) {\n+        int shift = x >> 4;\n+        int y = otherInput;\n+        return (shift & y) << 4;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_I, \"1\", IRNode.LSHIFT_I, \"1\" } , failOn = { IRNode.URSHIFT_I } )\n+    public int testLShiftOfAndOfURShiftSameCon(int x) {\n+        int shift = x >>> 4;\n+        int y = otherInput;\n+        return (shift & y) << 4;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_I, \"2\", IRNode.LSHIFT_I, \"2\" } , failOn = { IRNode.RSHIFT_I } )\n+    public int testLShiftOfAndOfRShift(int x) {\n+        int shift = x >> 4;\n+        int y = otherInput;\n+        return (shift & y) << 8;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_I, \"2\", IRNode.LSHIFT_I, \"2\" } , failOn = { IRNode.URSHIFT_I } )\n+    public int testLShiftOfAndOfURShift(int x) {\n+        int shift = x >>> 4;\n+        int y = otherInput;\n+        return (shift & y) << 8;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" } , failOn = { IRNode.AND_I } )\n+    public int testLShiftOfAndOfCon(int x) {\n+        return (x & ((1 << (32 - 10)) -1)) << 10;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftINodeIdealizationTests.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -55,0 +55,11 @@\n+            \"testShiftValue\",\n+            \"testShiftValueOverflow\",\n+            \"testShiftMultiple64\",\n+            \"testShiftOfAddSameInput\",\n+            \"testLargeShiftOfAddSameInput\",\n+            \"testShiftOfAddConstant\",\n+            \"testLShiftOfAndOfRShiftSameCon\",\n+            \"testLShiftOfAndOfURShiftSameCon\",\n+            \"testLShiftOfAndOfRShift\",\n+            \"testLShiftOfAndOfURShift\",\n+            \"testLShiftOfAndOfCon\",\n@@ -72,0 +83,23 @@\n+\n+        Asserts.assertEQ(42L << 1, testShiftValue(42));\n+        Asserts.assertEQ(Long.MAX_VALUE << 1, testShiftValueOverflow(Long.MAX_VALUE));\n+        Asserts.assertEQ((Long.MAX_VALUE-1) << 1, testShiftValueOverflow(Long.MAX_VALUE-1));\n+\n+        assertResult(a, b);\n+        assertResult(c, d);\n+        assertResult(a, min);\n+        assertResult(a, max);\n+        assertResult(min, a);\n+        assertResult(max, a);\n+        assertResult(min, max);\n+        assertResult(max, min);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    private void assertResult(long a, long b) {\n+        otherInput = b;\n+        Asserts.assertEQ(((a >> 4) & b) << 4, testLShiftOfAndOfRShiftSameCon(a));\n+        Asserts.assertEQ(((a >>> 4) & b) << 4, testLShiftOfAndOfURShiftSameCon(a));\n+        Asserts.assertEQ(((a >> 4) & b) << 8, testLShiftOfAndOfRShift(a));\n+        Asserts.assertEQ(((a >>> 4) & b) << 8, testLShiftOfAndOfURShift(a));\n@@ -82,0 +116,5 @@\n+        Asserts.assertEQ(a, testShiftMultiple64(a));\n+        Asserts.assertEQ((a + a) << 1, testShiftOfAddSameInput(a));\n+        Asserts.assertEQ((a + a) << 63, testLargeShiftOfAddSameInput(a));\n+        Asserts.assertEQ(((a + 1) << 1) + 1, testShiftOfAddConstant(a));\n+        Asserts.assertEQ((a & ((1L << (64 - 10)) -1)) << 10, testLShiftOfAndOfCon(a));\n@@ -236,0 +275,86 @@\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\"}, failOn = { IRNode.IF } )\n+    public long testShiftValue(long x) {\n+        x = Long.min(Long.max(x, 10), 100);\n+        long shift = x << 1;\n+        if (shift > 200 || shift < 20) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        return shift;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\", IRNode.IF, \"2\" } )\n+    public long testShiftValueOverflow(long x) {\n+        x = Long.max(x, Long.MAX_VALUE - 1);\n+        long shift = x << 1;\n+        if (shift != -2 && shift != -4) {\n+            throw new RuntimeException(\"never taken\");\n+        }\n+        return shift;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LSHIFT_L } )\n+    public long testShiftMultiple64(long x) {\n+        return x << 128;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" }, failOn = { IRNode.ADD_L } )\n+    public long testShiftOfAddSameInput(long x) {\n+        return (x + x) << 1;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\", IRNode.ADD_L, \"1\" } )\n+    public long testLargeShiftOfAddSameInput(long x) {\n+        return (x + x) << 63;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\",  IRNode.ADD_L, \"1\" } )\n+    public long testShiftOfAddConstant(long x) {\n+        return ((x + 1) << 1) + 1;\n+    }\n+\n+    static long otherInput;\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_L, \"1\", IRNode.LSHIFT_L, \"1\" } , failOn = { IRNode.RSHIFT_L } )\n+    public long testLShiftOfAndOfRShiftSameCon(long x) {\n+        long shift = x >> 4;\n+        long y = otherInput;\n+        return (shift & y) << 4;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_L, \"1\", IRNode.LSHIFT_L, \"1\" } , failOn = { IRNode.URSHIFT_L } )\n+    public long testLShiftOfAndOfURShiftSameCon(long x) {\n+        long shift = x >>> 4;\n+        long y = otherInput;\n+        return (shift & y) << 4;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_L, \"2\", IRNode.LSHIFT_L, \"2\" } , failOn = { IRNode.RSHIFT_L } )\n+    public long testLShiftOfAndOfRShift(long x) {\n+        long shift = x >> 4;\n+        long y = otherInput;\n+        return (shift & y) << 8;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_L, \"2\", IRNode.LSHIFT_L, \"2\" } , failOn = { IRNode.URSHIFT_L } )\n+    public long testLShiftOfAndOfURShift(long x) {\n+        long shift = x >>> 4;\n+        long y = otherInput;\n+        return (shift & y) << 8;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" } , failOn = { IRNode.AND_L } )\n+    public long testLShiftOfAndOfCon(long x) {\n+        return (x & ((1L << (64 - 10)) -1)) << 10;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftLNodeIdealizationTests.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"modified"}]}