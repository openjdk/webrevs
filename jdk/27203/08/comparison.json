{"files":[{"patch":"@@ -140,0 +140,39 @@\n+    \/**\n+     * Returns a resource node in the given module, or null if no resource of\n+     * that name exists.\n+     *\n+     * <p>This is equivalent to:\n+     * <pre>{@code\n+     * findNode(\"\/modules\/\" + moduleName + \"\/\" + resourcePath)\n+     * }<\/pre>\n+     * but more performant, and returns {@code null} for directories.\n+     *\n+     * @param moduleName The module name of the requested resource.\n+     * @param resourcePath Trailing module-relative resource path, not starting\n+     *     with {@code '\/'}.\n+     *\/\n+    public Node findResourceNode(String moduleName, String resourcePath)\n+            throws IOException {\n+        ensureOpen();\n+        return reader.findResourceNode(moduleName, resourcePath);\n+    }\n+\n+    \/**\n+     * Returns whether a resource exists in the given module.\n+     *\n+     * <p>This is equivalent to:\n+     * <pre>{@code\n+     * findResourceNode(moduleName, resourcePath) != null\n+     * }<\/pre>\n+     * but more performant, and will not create or cache new nodes.\n+     *\n+     * @param moduleName The module name of the resource being tested for.\n+     * @param resourcePath Trailing module-relative resource path, not starting\n+     *     with {@code '\/'}.\n+     *\/\n+    public boolean containsResource(String moduleName, String resourcePath)\n+            throws IOException {\n+        ensureOpen();\n+        return reader.containsResource(moduleName, resourcePath);\n+    }\n+\n@@ -279,4 +318,1 @@\n-         * <p>This is the only public API by which anything outside this class can access\n-         * {@code Node} instances either directly, or by resolving symbolic links.\n-         *\n-         * <p>Note also that there is no reentrant calling back to this method from within\n+         * <p>Note that there is no reentrant calling back to this method from within\n@@ -294,0 +330,3 @@\n+                    \/\/ This may perform two lookups, one for a directory (in\n+                    \/\/ \"\/modules\/...\") and one for a non-prefixed resource\n+                    \/\/ (with \"\/modules\" removed).\n@@ -310,0 +349,49 @@\n+        \/**\n+         * Returns a resource node in the given module, or null if no resource of\n+         * that name exists.\n+         *\n+         * <p>Note that there is no reentrant calling back to this method from within\n+         * the node handling code.\n+         *\/\n+        Node findResourceNode(String moduleName, String resourcePath) {\n+            \/\/ Unlike findNode(), this method makes only one lookup in the\n+            \/\/ underlying jimage, but can only reliably return resource nodes.\n+            if (moduleName.indexOf('\/') >= 0) {\n+                throw new IllegalArgumentException(\"invalid module name: \" + moduleName);\n+            }\n+            String nodeName = MODULES_ROOT + \"\/\" + moduleName + \"\/\" + resourcePath;\n+            \/\/ Synchronize as tightly as possible to reduce locking contention.\n+            synchronized (this) {\n+                Node node = nodes.get(nodeName);\n+                if (node == null) {\n+                    ImageLocation loc = findLocation(moduleName, resourcePath);\n+                    if (loc != null && isResource(loc)) {\n+                        node = newResource(nodeName, loc);\n+                        nodes.put(node.getName(), node);\n+                    }\n+                    return node;\n+                } else {\n+                    return node.isResource() ? node : null;\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Returns whether a resource exists in the given module.\n+         *\n+         * <p>This method is expected to be called frequently for resources\n+         * which do not exist in the given module (e.g. as part of classpath\n+         * search). As such, it skips checking the nodes cache and only checks\n+         * for an entry in the jimage file, as this is faster if the resource\n+         * is not present. This also means it doesn't need synchronization.\n+         *\/\n+        boolean containsResource(String moduleName, String resourcePath) {\n+            if (moduleName.indexOf('\/') >= 0) {\n+                throw new IllegalArgumentException(\"invalid module name: \" + moduleName);\n+            }\n+            \/\/ If the given module name is 'modules', then 'isResource()'\n+            \/\/ returns false to prevent false positives.\n+            ImageLocation loc = findLocation(moduleName, resourcePath);\n+            return loc != null && isResource(loc);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":92,"deletions":4,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -417,2 +417,2 @@\n-        private boolean containsResource(String resourcePath) throws IOException {\n-            Objects.requireNonNull(resourcePath);\n+        private boolean containsResource(String module, String name) throws IOException {\n+            Objects.requireNonNull(name);\n@@ -422,7 +422,1 @@\n-            if (imageReader != null) {\n-                ImageReader.Node node = imageReader.findNode(\"\/modules\" + resourcePath);\n-                return node != null && node.isResource();\n-            } else {\n-                \/\/ not an images build\n-                return false;\n-            }\n+            return imageReader != null && imageReader.containsResource(module, name);\n@@ -433,4 +427,2 @@\n-            Objects.requireNonNull(name);\n-            String resourcePath = \"\/\" + module + \"\/\" + name;\n-            if (containsResource(resourcePath)) {\n-                URI u = JNUA.create(\"jrt\", resourcePath);\n+            if (containsResource(module, name)) {\n+                URI u = JNUA.create(\"jrt\", \"\/\" + module + \"\/\" + name);\n@@ -468,3 +460,1 @@\n-            String nodeName = \"\/modules\/\" + module + \"\/\" + name;\n-            ImageReader.Node node = reader.findNode(nodeName);\n-            return (node != null && node.isResource()) ? node : null;\n+            return reader.findResourceNode(module, name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/SystemModuleFinders.java","additions":6,"deletions":16,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -90,2 +90,2 @@\n-            Node node = READER.findNode(\"\/modules\/\" + module + \"\/\" + path);\n-            if (node == null || !node.isResource()) {\n+            Node node = READER.findResourceNode(module, path);\n+            if (node == null) {\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/jrt\/JavaRuntimeURLConnection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import org.junit.jupiter.params.provider.CsvSource;\n@@ -46,0 +47,1 @@\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n@@ -125,0 +127,50 @@\n+    @ParameterizedTest\n+    @CsvSource(delimiter = ':', value = {\n+            \"modfoo:com\/foo\/Alpha.class\",\n+            \"modbar:com\/bar\/One.class\",\n+    })\n+    public void testResourceNodes_present(String modName, String resPath) throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            assertNotNull(reader.findResourceNode(modName, resPath));\n+            assertTrue(reader.containsResource(modName, resPath));\n+\n+            String canonicalNodeName = \"\/modules\/\" + modName + \"\/\" + resPath;\n+            Node node = reader.findNode(canonicalNodeName);\n+            assertTrue(node != null && node.isResource());\n+        }\n+    }\n+\n+    \/\/ Important to ensure we cannot be fooled.\n+    @ParameterizedTest\n+    @CsvSource(delimiter = ':', value = {\n+            \/\/ Absolute resource names are not allowed.\n+            \"modfoo:\/com\/bar\/One.class\",\n+            \/\/ Resource in wrong module.\n+            \"modfoo:com\/bar\/One.class\",\n+            \"modbar:com\/foo\/Alpha.class\",\n+            \/\/ Directories are not returned.\n+            \"modfoo:com\/foo\",\n+            \"modbar:com\/bar\",\n+            \/\/ JImage entries exist for these, but they are not resources.\n+            \"modules:modfoo\/com\/foo\/Alpha.class\",\n+            \"packages:com.foo\/modfoo\",\n+            \/\/ Don't permit module names to contain paths.\n+            \"modfoo\/com\/bar:One.class\",\n+            \"modfoo\/com:bar\/One.class\",\n+            \"modules\/modfoo\/com:foo\/Alpha.class\",\n+            \/\/ Or module names\/paths to be empty.\n+            \"'':modfoo\/com\/foo\/Alpha.class\",\n+            \"modfoo:''\"})\n+    public void testFindResourceNode_absent(String modName, String resPath) throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            assertNull(reader.findResourceNode(modName, resPath));\n+            assertFalse(reader.containsResource(modName, resPath));\n+\n+            \/\/ Non-existent resources names should either not be found,\n+            \/\/ or (in the case of directory nodes) not be resources.\n+            String canonicalNodeName = \"\/modules\/\" + modName + \"\/\" + resPath;\n+            Node node = reader.findNode(canonicalNodeName);\n+            assertTrue(node == null || !node.isResource());\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/internal\/jimage\/ImageReaderTest.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"}]}