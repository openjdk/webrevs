{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties;\n@@ -1405,1 +1404,0 @@\n-            checkArraySize(tree.elems);\n@@ -1428,6 +1426,0 @@\n-        private void checkArraySize(List<JCExpression> tree) {\n-            \/\/check if attribute length exceeds maximum unsigned 16-bit value\n-            if (!sigOnly && tree != null && (tree.size() >>> 16) > 0) {\n-                log.warning(tree.getFirst().pos(), CompilerProperties.Warnings.ProcAnnotationArrayTooLarge);\n-            }\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+    public static final int MAX_ANNOTATIONS = 0xffff;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -652,0 +652,1 @@\n+            checkAnnotationArraySizeInternal(p);\n@@ -657,0 +658,7 @@\n+    private void checkAnnotationArraySizeInternal(Pair<Symbol.MethodSymbol, Attribute> p) {\n+        if (p.snd instanceof Attribute.Array arrAttr &&\n+                arrAttr.values.length > ClassFile.MAX_ANNOTATIONS) {\n+            log.error(Errors.AnnotationArrayTooLarge(p.fst.owner));\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -890,0 +890,4 @@\n+# 0: symbol\n+compiler.err.annotation.array.too.large=\\\n+    Annotation array element too large in \\\"{0}\\\"\n+\n@@ -2238,2 +2242,0 @@\n-compiler.warn.proc.annotation.array.too.large=\\\n-    Annotation array element too large, length exceeds limit of 65535\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Check if error is thrown if annotation array exceeds limit\n+ * @library \/tools\/lib\n+ * @run main ParameterArrayLimit\n+ *\/\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.text.MessageFormat;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.tools.*;\n+\n+import com.sun.source.util.JavacTask;\n+\n+public class ParameterArrayLimit {\n+\n+    public static void main(String[] args) throws IOException {\n+\n+        int[] values = new int[]{65536, 65537, 512000};\n+        String[] retPolicies = {\"RUNTIME\", \"CLASS\"};\n+\n+        for (var value : values) {\n+            Path tmpDir = Paths.get(System.getProperty(\"java.io.tmpdir\"));\n+\n+            for (String retPolicy : retPolicies) {\n+                String className = MessageFormat.format(\"ClassAnnotationWithLength_{0,number,#}_{1}.java\",\n+                        value,\n+                        retPolicy);\n+                Path out = tmpDir.resolve(className);\n+                createAnnotationFile(out, value, retPolicy, false);\n+                checkParamArrayWarning(className, out);\n+            }\n+\n+            for (String retPolicy : retPolicies) {\n+                String className = MessageFormat.format(\"TypeAnnotationWithLength_{0,number,#}_{1}.java\",\n+                        value,\n+                        retPolicy);\n+                Path out = tmpDir.resolve(className);\n+                createAnnotationFile(out, value, retPolicy, true);\n+                checkParamArrayWarning(className, out);\n+            }\n+        }\n+    }\n+\n+    private static void checkParamArrayWarning(String className, Path out) throws IOException {\n+        JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();\n+        DiagnosticCollector<JavaFileObject> d = new DiagnosticCollector<>();\n+        JavacTask task = (JavacTask) javaCompiler.getTask(\n+                null,\n+                null,\n+                d,\n+                null,\n+                null,\n+                Collections.singletonList(\n+                        SimpleJavaFileObject.forSource(\n+                                URI.create(\"myfo:\/\" + className),\n+                                Files.readString(out)\n+                        )));\n+        task.call();\n+\n+        List<Diagnostic<? extends JavaFileObject>> diagnosticList = d.getDiagnostics();\n+        if (diagnosticList.isEmpty()) {\n+            throw new RuntimeException(\"No diagnostic found\");\n+        }\n+\n+        for (Diagnostic<? extends JavaFileObject> diagnostic : diagnosticList) {\n+            if (!(diagnostic.getKind() == Diagnostic.Kind.ERROR\n+                    && diagnostic.getCode()\n+                    .equals(\"compiler.err.annotation.array.too.large\"))) {\n+                throw new RuntimeException(\"Unexpected diagnostic: \" + diagnostic.getMessage(null));\n+            }\n+        }\n+    }\n+\n+    private static void createAnnotationFile(Path out, int value, String retPolicy, boolean isTypeAnnotation) throws IOException {\n+        StringBuilder sb = new StringBuilder();\n+\n+        if (isTypeAnnotation) {\n+            sb.append(MessageFormat.format(\"\"\"\n+                    import java.lang.annotation.*;\n+                    @Retention(RetentionPolicy.{0})\n+                    @Target(ElementType.TYPE_USE)\n+                    @interface TypeAnno '{'\n+                        long[] arr();\n+                    '}'\n+                    \"\"\", retPolicy));\n+            sb.append(MessageFormat.format(\"\"\"\n+                                public class TypeAnnotationWithLength_{0,number,#}_{1}'{'\n+                                @TypeAnno(arr = '{'\n+                    \"\"\", value, retPolicy));\n+        } else {\n+            sb.append(MessageFormat.format(\"\"\"\n+                    import java.lang.annotation.*;\n+                    @Retention(RetentionPolicy.{0})\n+                    @interface MyCustomAnno '{'\n+                        String value() default \"default value\";\n+                        long[] arr();\n+                        int count() default 0;\n+                    '}'\n+                    \"\"\", retPolicy));\n+            sb.append(MessageFormat.format(\"\"\"\n+                                public class ClassAnnotationWithLength_{0,number,#}_{1}'{'\n+                                @MyCustomAnno(value = \"custom\", count = 42, arr = '{'\n+                    \"\"\", value, retPolicy));\n+        }\n+\n+        sb.append(\"-1,\".repeat(Math.max(0, value - 1)));\n+        sb.append(\"-1})\");\n+\n+        sb.append(\"\"\"\n+                     static int x = 3;\n+\n+                     public void myAnnotatedMethod() { }\n+                }\n+                \"\"\");\n+\n+        try (BufferedWriter bufferedWriter = Files.newBufferedWriter(out)) {\n+            bufferedWriter.write(sb.toString());\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/ParameterArrayLimit.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -1,130 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test ParameterArraySizeLimit\n- * @library \/tools\/lib\n- * @run main ParameterArraySizeLimit\n- *\/\n-\n-\n-import java.io.BufferedWriter;\n-import java.io.IOException;\n-import java.net.URI;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.text.MessageFormat;\n-import java.util.Collections;\n-import java.util.List;\n-import javax.tools.*;\n-import com.sun.source.util.JavacTask;\n-\n-\n-public class ParameterArraySizeLimit {\n-\n-    public static void main(String[] args) throws IOException {\n-\n-        int[] values = new int[]{65536, 65537, 512000};\n-\n-        for (var value : values) {\n-\n-            Path tmpDir = Paths.get(System.getProperty(\"java.io.tmpdir\"));\n-            String className = MessageFormat.format(\"ClassAnnotationWithLength_{0,number,#}.java\", value);\n-            Path out = tmpDir.resolve(className);\n-\n-            createJavaFile(value, out);\n-            checkParamArrayWarning(className, out);\n-        }\n-    }\n-\n-    private static void checkParamArrayWarning(String className, Path out) throws IOException {\n-\n-        JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();\n-        DiagnosticCollector<JavaFileObject> d = new DiagnosticCollector<>();\n-        JavacTask task = (JavacTask) javaCompiler.getTask(\n-                null,\n-                null,\n-                d,\n-                null,\n-                null,\n-                Collections.singletonList(\n-                        SimpleJavaFileObject.forSource(\n-                                URI.create(\"myfo:\/\" + className),\n-                                Files.readString(out)\n-                        )));\n-        task.analyze();\n-\n-        List<Diagnostic<? extends JavaFileObject>> diagnosticList = d.getDiagnostics();\n-\n-        if (diagnosticList.isEmpty()) {\n-            throw new RuntimeException(\"No diagnostic found\");\n-        }\n-\n-        for (Diagnostic<? extends JavaFileObject> diagnostic : diagnosticList) {\n-            if (!(diagnostic.getKind() == Diagnostic.Kind.WARNING\n-                    && diagnostic.getMessage(null)\n-                    .equals(\"Annotation array element too large, length exceeds limit of 65535\"))) {\n-                throw new RuntimeException(\"Unexpected diagnostic: \" + diagnostic.getMessage(null));\n-            }\n-        }\n-    }\n-\n-    private static void createJavaFile(int value, Path out) throws IOException {\n-        String customAnno = \"\"\"\n-                import java.lang.annotation.*;\n-                @Retention(RetentionPolicy.RUNTIME)\n-                @interface CustomAnno {\n-                    String value() default \"default value\";\n-                    long[] arr() ;\n-                    int count() default 0;\n-                }\n-                \"\"\";\n-        String annotation = MessageFormat.format(\"\"\"\n-                            public class ClassAnnotationWithLength_{0,number,#} '{'\n-                            @CustomAnno(value = \"custom\", count = 42, arr='{'\n-                \"\"\", value);\n-\n-        String end = \"\"\"\n-                     })\n-\n-                    static int x = 3;\n-\n-                    public void myAnnotatedMethod() { }\n-                }\n-                \"\"\";\n-\n-        BufferedWriter bufferedWriter = Files.newBufferedWriter(out);\n-        bufferedWriter.write(customAnno);\n-        bufferedWriter.write(annotation);\n-\n-        for (int i = 0; i < value - 1; i++) {\n-            bufferedWriter.write(\"-1,\");\n-        }\n-\n-        bufferedWriter.write(\"-1\");\n-        bufferedWriter.write(end);\n-        bufferedWriter.close();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/annotations\/ParameterArraySizeLimit.java","additions":0,"deletions":130,"binary":false,"changes":130,"status":"deleted"},{"patch":"@@ -19,0 +19,1 @@\n+compiler.err.annotation.array.too.large                 # Code\n@@ -25,1 +26,0 @@\n-compiler.warn.proc.annotation.array.too.large           # Code\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}