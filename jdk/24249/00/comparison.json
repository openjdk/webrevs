{"files":[{"patch":"@@ -1,332 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifdef COMPILER2\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"asm\/macroAssembler.inline.hpp\"\n-#include \"code\/vmreg.hpp\"\n-#include \"compiler\/oopMap.hpp\"\n-#include \"interpreter\/interpreter.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"opto\/runtime.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n-#include \"runtime\/stubRoutines.hpp\"\n-#include \"runtime\/vframeArray.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"vmreg_x86.inline.hpp\"\n-#endif\n-\n-\n-#define __ masm->\n-\n-\/\/------------------------------generate_uncommon_trap_blob--------------------\n-UncommonTrapBlob* OptoRuntime::generate_uncommon_trap_blob() {\n-  \/\/ allocate space for the code\n-  ResourceMark rm;\n-  \/\/ setup code generation tools\n-  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n-  CodeBuffer   buffer(name, 512, 512);\n-  MacroAssembler* masm = new MacroAssembler(&buffer);\n-\n-  enum frame_layout {\n-    arg0_off,      \/\/ thread                     sp + 0 \/\/ Arg location for\n-    arg1_off,      \/\/ unloaded_class_index       sp + 1 \/\/ calling C\n-    arg2_off,      \/\/ exec_mode                  sp + 2\n-    \/\/ The frame sender code expects that rbp will be in the \"natural\" place and\n-    \/\/ will override any oopMap setting for it. We must therefore force the layout\n-    \/\/ so that it agrees with the frame sender code.\n-    rbp_off,       \/\/ callee saved register      sp + 3\n-    return_off,    \/\/ slot for return address    sp + 4\n-    framesize\n-  };\n-\n-  address start = __ pc();\n-\n-  \/\/ Push self-frame.\n-  __ subptr(rsp, return_off*wordSize);     \/\/ Epilog!\n-\n-  \/\/ rbp, is an implicitly saved callee saved register (i.e. the calling\n-  \/\/ convention will save restore it in prolog\/epilog) Other than that\n-  \/\/ there are no callee save registers no that adapter frames are gone.\n-  __ movptr(Address(rsp, rbp_off*wordSize), rbp);\n-\n-  \/\/ Clear the floating point exception stack\n-  __ empty_FPU_stack();\n-\n-  \/\/ set last_Java_sp\n-  __ get_thread(rdx);\n-  __ set_last_Java_frame(rdx, noreg, noreg, nullptr, noreg);\n-\n-  \/\/ Call C code.  Need thread but NOT official VM entry\n-  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n-  \/\/ capture callee-saved registers as well as return values.\n-  __ movptr(Address(rsp, arg0_off*wordSize), rdx);\n-  \/\/ argument already in ECX\n-  __ movl(Address(rsp, arg1_off*wordSize),rcx);\n-  __ movl(Address(rsp, arg2_off*wordSize), Deoptimization::Unpack_uncommon_trap);\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap)));\n-\n-  \/\/ Set an oopmap for the call site\n-  OopMapSet *oop_maps = new OopMapSet();\n-  OopMap* map =  new OopMap( framesize, 0 );\n-  \/\/ No oopMap for rbp, it is known implicitly\n-\n-  oop_maps->add_gc_map( __ pc()-start, map);\n-\n-  __ get_thread(rcx);\n-\n-  __ reset_last_Java_frame(rcx, false);\n-\n-  \/\/ Load UnrollBlock into EDI\n-  __ movptr(rdi, rax);\n-\n-#ifdef ASSERT\n-  { Label L;\n-    __ cmpptr(Address(rdi, Deoptimization::UnrollBlock::unpack_kind_offset()),\n-            (int32_t)Deoptimization::Unpack_uncommon_trap);\n-    __ jcc(Assembler::equal, L);\n-    __ stop(\"OptoRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap\");\n-    __ bind(L);\n-  }\n-#endif\n-\n-  \/\/ Pop all the frames we must move\/replace.\n-  \/\/\n-  \/\/ Frame picture (youngest to oldest)\n-  \/\/ 1: self-frame (no frame link)\n-  \/\/ 2: deopting frame  (no frame link)\n-  \/\/ 3: caller of deopting frame (could be compiled\/interpreted).\n-\n-  \/\/ Pop self-frame.  We have no frame, and must rely only on EAX and ESP.\n-  __ addptr(rsp,(framesize-1)*wordSize);     \/\/ Epilog!\n-\n-  \/\/ Pop deoptimized frame\n-  __ movl2ptr(rcx, Address(rdi,Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset()));\n-  __ addptr(rsp, rcx);\n-\n-  \/\/ sp should be pointing at the return address to the caller (3)\n-\n-  \/\/ Pick up the initial fp we should save\n-  \/\/ restore rbp before stack bang because if stack overflow is thrown it needs to be pushed (and preserved)\n-  __ movptr(rbp, Address(rdi, Deoptimization::UnrollBlock::initial_info_offset()));\n-\n-#ifdef ASSERT\n-  \/\/ Compilers generate code that bang the stack by as much as the\n-  \/\/ interpreter would need. So this stack banging should never\n-  \/\/ trigger a fault. Verify that it does not on non product builds.\n-  __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset()));\n-  __ bang_stack_size(rbx, rcx);\n-#endif\n-\n-  \/\/ Load array of frame pcs into ECX\n-  __ movl(rcx,Address(rdi,Deoptimization::UnrollBlock::frame_pcs_offset()));\n-\n-  __ pop(rsi); \/\/ trash the pc\n-\n-  \/\/ Load array of frame sizes into ESI\n-  __ movptr(rsi,Address(rdi,Deoptimization::UnrollBlock::frame_sizes_offset()));\n-\n-  Address counter(rdi, Deoptimization::UnrollBlock::counter_temp_offset());\n-\n-  __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::number_of_frames_offset()));\n-  __ movl(counter, rbx);\n-\n-  \/\/ Now adjust the caller's stack to make up for the extra locals\n-  \/\/ but record the original sp so that we can save it in the skeletal interpreter\n-  \/\/ frame and the stack walking of interpreter_sender will get the unextended sp\n-  \/\/ value and not the \"real\" sp value.\n-\n-  Address sp_temp(rdi, Deoptimization::UnrollBlock::sender_sp_temp_offset());\n-  __ movptr(sp_temp, rsp);\n-  __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::caller_adjustment_offset()));\n-  __ subptr(rsp, rbx);\n-\n-  \/\/ Push interpreter frames in a loop\n-  Label loop;\n-  __ bind(loop);\n-  __ movptr(rbx, Address(rsi, 0));      \/\/ Load frame size\n-  __ subptr(rbx, 2*wordSize);           \/\/ we'll push pc and rbp, by hand\n-  __ pushptr(Address(rcx, 0));          \/\/ save return address\n-  __ enter();                           \/\/ save old & set new rbp,\n-  __ subptr(rsp, rbx);                  \/\/ Prolog!\n-  __ movptr(rbx, sp_temp);              \/\/ sender's sp\n-  \/\/ This value is corrected by layout_activation_impl\n-  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD );\n-  __ movptr(Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize), rbx); \/\/ Make it walkable\n-  __ movptr(sp_temp, rsp);              \/\/ pass to next frame\n-  __ addptr(rsi, wordSize);             \/\/ Bump array pointer (sizes)\n-  __ addptr(rcx, wordSize);             \/\/ Bump array pointer (pcs)\n-  __ decrementl(counter);             \/\/ decrement counter\n-  __ jcc(Assembler::notZero, loop);\n-  __ pushptr(Address(rcx, 0));            \/\/ save final return address\n-\n-  \/\/ Re-push self-frame\n-  __ enter();                           \/\/ save old & set new rbp,\n-  __ subptr(rsp, (framesize-2) * wordSize);   \/\/ Prolog!\n-\n-\n-  \/\/ set last_Java_sp, last_Java_fp\n-  __ get_thread(rdi);\n-  __ set_last_Java_frame(rdi, noreg, rbp, nullptr, noreg);\n-\n-  \/\/ Call C code.  Need thread but NOT official VM entry\n-  \/\/ crud.  We cannot block on this call, no GC can happen.  Call should\n-  \/\/ restore return values to their stack-slots with the new SP.\n-  __ movptr(Address(rsp,arg0_off*wordSize),rdi);\n-  __ movl(Address(rsp,arg1_off*wordSize), Deoptimization::Unpack_uncommon_trap);\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));\n-  \/\/ Set an oopmap for the call site\n-  oop_maps->add_gc_map( __ pc()-start, new OopMap( framesize, 0 ) );\n-\n-  __ get_thread(rdi);\n-  __ reset_last_Java_frame(rdi, true);\n-\n-  \/\/ Pop self-frame.\n-  __ leave();     \/\/ Epilog!\n-\n-  \/\/ Jump to interpreter\n-  __ ret(0);\n-\n-  \/\/ -------------\n-  \/\/ make sure all code is generated\n-  masm->flush();\n-\n-   return UncommonTrapBlob::create(&buffer, oop_maps, framesize);\n-}\n-\n-\/\/------------------------------generate_exception_blob---------------------------\n-\/\/ creates exception blob at the end\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/\n-\/\/ Given an exception pc at a call we call into the runtime for the\n-\/\/ handler in this method. This handler might merely restore state\n-\/\/ (i.e. callee save registers) unwind the frame and jump to the\n-\/\/ exception handler for the nmethod if there is no Java level handler\n-\/\/ for the nmethod.\n-\/\/\n-\/\/ This code is entered with a jmp.\n-\/\/\n-\/\/ Arguments:\n-\/\/   rax: exception oop\n-\/\/   rdx: exception pc\n-\/\/\n-\/\/ Results:\n-\/\/   rax: exception oop\n-\/\/   rdx: exception pc in caller or ???\n-\/\/   destination: exception handler of caller\n-\/\/\n-\/\/ Note: the exception pc MUST be at a call (precise debug information)\n-\/\/       Only register rax, rdx, rcx are not callee saved.\n-\/\/\n-\n-ExceptionBlob* OptoRuntime::generate_exception_blob() {\n-\n-  \/\/ Capture info about frame layout\n-  enum layout {\n-    thread_off,                 \/\/ last_java_sp\n-    \/\/ The frame sender code expects that rbp will be in the \"natural\" place and\n-    \/\/ will override any oopMap setting for it. We must therefore force the layout\n-    \/\/ so that it agrees with the frame sender code.\n-    rbp_off,\n-    return_off,                 \/\/ slot for return address\n-    framesize\n-  };\n-\n-  \/\/ allocate space for the code\n-  ResourceMark rm;\n-  \/\/ setup code generation tools\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n-  CodeBuffer   buffer(name, 512, 512);\n-  MacroAssembler* masm = new MacroAssembler(&buffer);\n-\n-  OopMapSet *oop_maps = new OopMapSet();\n-\n-  address start = __ pc();\n-\n-  __ push(rdx);\n-  __ subptr(rsp, return_off * wordSize);   \/\/ Prolog!\n-\n-  \/\/ rbp, location is implicitly known\n-  __ movptr(Address(rsp,rbp_off  *wordSize), rbp);\n-\n-  \/\/ Store exception in Thread object. We cannot pass any arguments to the\n-  \/\/ handle_exception call, since we do not want to make any assumption\n-  \/\/ about the size of the frame where the exception happened in.\n-  __ get_thread(rcx);\n-  __ movptr(Address(rcx, JavaThread::exception_oop_offset()), rax);\n-  __ movptr(Address(rcx, JavaThread::exception_pc_offset()),  rdx);\n-\n-  \/\/ This call does all the hard work.  It checks if an exception handler\n-  \/\/ exists in the method.\n-  \/\/ If so, it returns the handler address.\n-  \/\/ If not, it prepares for stack-unwinding, restoring the callee-save\n-  \/\/ registers of the frame being removed.\n-  \/\/\n-  __ movptr(Address(rsp, thread_off * wordSize), rcx); \/\/ Thread is first argument\n-  __ set_last_Java_frame(rcx, noreg, noreg, nullptr, noreg);\n-\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C)));\n-\n-  \/\/ No registers to map, rbp is known implicitly\n-  oop_maps->add_gc_map( __ pc() - start,  new OopMap( framesize, 0 ));\n-  __ get_thread(rcx);\n-  __ reset_last_Java_frame(rcx, false);\n-\n-  \/\/ Restore callee-saved registers\n-  __ movptr(rbp, Address(rsp, rbp_off * wordSize));\n-\n-  __ addptr(rsp, return_off * wordSize);   \/\/ Epilog!\n-  __ pop(rdx); \/\/ Exception pc\n-\n-  \/\/ rax: exception handler for given <exception oop\/exception pc>\n-\n-  \/\/ We have a handler in rax, (could be deopt blob)\n-  \/\/ rdx - throwing pc, deopt blob will need it.\n-\n-  __ push(rax);\n-\n-  \/\/ Get the exception\n-  __ movptr(rax, Address(rcx, JavaThread::exception_oop_offset()));\n-  \/\/ Get the exception pc in case we are deoptimized\n-  __ movptr(rdx, Address(rcx, JavaThread::exception_pc_offset()));\n-#ifdef ASSERT\n-  __ movptr(Address(rcx, JavaThread::exception_handler_pc_offset()), NULL_WORD);\n-  __ movptr(Address(rcx, JavaThread::exception_pc_offset()), NULL_WORD);\n-#endif\n-  \/\/ Clear the exception oop so GC no longer processes it as a root.\n-  __ movptr(Address(rcx, JavaThread::exception_oop_offset()), NULL_WORD);\n-\n-  __ pop(rcx);\n-\n-  \/\/ rax: exception oop\n-  \/\/ rcx: exception handler\n-  \/\/ rdx: exception pc\n-  __ jmp (rcx);\n-\n-  \/\/ -------------\n-  \/\/ make sure all code is generated\n-  masm->flush();\n-\n-  return ExceptionBlob::create(&buffer, oop_maps, framesize);\n-}\n","filename":"src\/hotspot\/cpu\/x86\/runtime_x86_32.cpp","additions":0,"deletions":332,"binary":false,"changes":332,"status":"deleted"}]}