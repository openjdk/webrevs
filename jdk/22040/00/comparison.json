{"files":[{"patch":"@@ -290,1 +290,0 @@\n-                                                                   Deoptimization::DeoptReason reason,\n@@ -292,6 +291,3 @@\n-                                                                   ParsePredicateSuccessProj* fast_loop_parse_predicate_proj,\n-                                                                   ParsePredicateSuccessProj* slow_loop_parse_predicate_proj) {\n-  assert(fast_loop_parse_predicate_proj->in(0)->is_ParsePredicate() &&\n-         slow_loop_parse_predicate_proj->in(0)->is_ParsePredicate(), \"sanity check\");\n-  \/\/ Only need to clone range check predicates as those can be changed and duplicated by inserting pre\/main\/post loops\n-  \/\/ and doing loop unrolling. Push the original predicates on a list to later process them in reverse order to keep the\n+                                                                   ParsePredicateNode* true_path_loop_parse_predicate,\n+                                                                   ParsePredicateNode* false_path_loop_parse_predicate) {\n+  \/\/ Push the original Template Assertion Predicates on a list to later process them in reverse order to keep the\n@@ -300,1 +296,1 @@\n-  get_assertion_predicates(old_parse_predicate_proj, list);\n+  get_template_assertion_predicates(old_parse_predicate_proj, list);\n@@ -303,2 +299,0 @@\n-  \/\/ Process in reverse order such that 'create_new_if_for_predicate' can be used in\n-  \/\/ 'clone_assertion_predicate_for_unswitched_loops' and the original order is maintained.\n@@ -306,5 +300,2 @@\n-    Node* predicate = list.at(i);\n-    assert(predicate->in(0)->is_If(), \"must be If node\");\n-    IfNode* iff = predicate->in(0)->as_If();\n-    assert(predicate->is_Proj() && predicate->as_Proj()->is_IfProj(), \"predicate must be a projection of an if node\");\n-    IfProjNode* predicate_proj = predicate->as_IfProj();\n+    IfTrueNode* template_assertion_predicate_success_proj = list.at(i)->as_IfTrue();\n+    assert(template_assertion_predicate_success_proj->in(0)->is_If(), \"must be If node\");\n@@ -312,4 +303,6 @@\n-    IfProjNode* fast_proj = clone_assertion_predicate_for_unswitched_loops(iff, predicate_proj, reason, fast_loop_parse_predicate_proj);\n-    assert(assertion_predicate_has_loop_opaque_node(fast_proj->in(0)->as_If()), \"must find Assertion Predicate for fast loop\");\n-    IfProjNode* slow_proj = clone_assertion_predicate_for_unswitched_loops(iff, predicate_proj, reason, slow_loop_parse_predicate_proj);\n-    assert(assertion_predicate_has_loop_opaque_node(slow_proj->in(0)->as_If()), \"must find Assertion Predicate for slow loop\");\n+    IfTrueNode* true_path_loop_proj =\n+        clone_assertion_predicate_for_unswitched_loops(template_assertion_predicate_success_proj,\n+                                                       true_path_loop_parse_predicate);\n+    IfTrueNode* false_path_loop_proj =\n+        clone_assertion_predicate_for_unswitched_loops(template_assertion_predicate_success_proj,\n+                                                       false_path_loop_parse_predicate);\n@@ -318,2 +311,4 @@\n-    for (DUIterator j = predicate->outs(); predicate->has_out(j); j++) {\n-      Node* fast_node = predicate->out(j);\n+    for (DUIterator j = template_assertion_predicate_success_proj->outs();\n+         template_assertion_predicate_success_proj->has_out(j);\n+         j++) {\n+      Node* fast_node = template_assertion_predicate_success_proj->out(j);\n@@ -321,1 +316,1 @@\n-        assert(fast_node->in(0) == predicate, \"only control edge\");\n+        assert(fast_node->in(0) == template_assertion_predicate_success_proj, \"only control edge\");\n@@ -323,2 +318,2 @@\n-        assert(slow_node->in(0) == predicate, \"only control edge\");\n-        _igvn.replace_input_of(fast_node, 0, fast_proj);\n+        assert(slow_node->in(0) == template_assertion_predicate_success_proj, \"only control edge\");\n+        _igvn.replace_input_of(fast_node, 0, true_path_loop_proj);\n@@ -332,1 +327,1 @@\n-      _igvn.replace_input_of(slow_node, 0, slow_proj);\n+      _igvn.replace_input_of(slow_node, 0, false_path_loop_proj);\n@@ -340,2 +335,2 @@\n-void PhaseIdealLoop::get_assertion_predicates(ParsePredicateSuccessProj* parse_predicate_proj, Unique_Node_List& list,\n-                                              const bool get_opaque) {\n+void PhaseIdealLoop::get_template_assertion_predicates(ParsePredicateSuccessProj* parse_predicate_proj, Unique_Node_List& list,\n+                                                       const bool get_opaque) {\n@@ -351,12 +346,10 @@\n-IfProjNode* PhaseIdealLoop::clone_assertion_predicate_for_unswitched_loops(IfNode* template_assertion_predicate,\n-                                                                           IfProjNode* predicate,\n-                                                                           Deoptimization::DeoptReason reason,\n-                                                                           ParsePredicateSuccessProj* parse_predicate_proj) {\n-  TemplateAssertionExpression template_assertion_expression(template_assertion_predicate->in(1)->as_OpaqueTemplateAssertionPredicate());\n-  OpaqueTemplateAssertionPredicateNode* cloned_opaque_node = template_assertion_expression.clone(parse_predicate_proj->in(0)->in(0), this);\n-  IfProjNode* if_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason,\n-                                                    template_assertion_predicate->Opcode(), false);\n-  _igvn.replace_input_of(if_proj->in(0), 1, cloned_opaque_node);\n-  _igvn.replace_input_of(parse_predicate_proj->in(0), 0, if_proj);\n-  set_idom(parse_predicate_proj->in(0), if_proj, dom_depth(if_proj));\n-  return if_proj;\n+IfTrueNode*\n+PhaseIdealLoop::clone_assertion_predicate_for_unswitched_loops(IfTrueNode* template_assertion_predicate_success_proj,\n+                                                               ParsePredicateNode* unswitched_loop_parse_predicate) {\n+  TemplateAssertionPredicate template_assertion_predicate(template_assertion_predicate_success_proj);\n+  IfTrueNode* template_success_proj = template_assertion_predicate.clone(unswitched_loop_parse_predicate->in(0), this);\n+  assert(assertion_predicate_has_loop_opaque_node(template_success_proj->in(0)->as_If()),\n+         \"must find Assertion Predicate for fast loop\");\n+  _igvn.replace_input_of(unswitched_loop_parse_predicate, 0, template_success_proj);\n+  set_idom(unswitched_loop_parse_predicate, template_success_proj, dom_depth(template_success_proj));\n+  return template_success_proj;\n@@ -368,1 +361,2 @@\n-                                                                             IfProjNode*& iffast_pred, IfProjNode*& ifslow_pred) {\n+                                                                             IfProjNode*& true_path_loop_entry,\n+                                                                             IfProjNode*& false_path_loop_entry) {\n@@ -374,1 +368,1 @@\n-                                                       Deoptimization::Reason_predicate, iffast_pred, ifslow_pred);\n+                                                       Deoptimization::Reason_predicate, true_path_loop_entry, false_path_loop_entry);\n@@ -376,1 +370,1 @@\n-                                                       Deoptimization::Reason_profile_predicate, iffast_pred, ifslow_pred);\n+                                                       Deoptimization::Reason_profile_predicate, true_path_loop_entry, false_path_loop_entry);\n@@ -383,1 +377,1 @@\n-                                              iffast_pred, ifslow_pred);\n+                                              true_path_loop_entry, false_path_loop_entry);\n@@ -391,2 +385,2 @@\n-                                                                          IfProjNode*& iffast_pred,\n-                                                                          IfProjNode*& ifslow_pred) {\n+                                                                          IfProjNode*& true_path_loop_entry,\n+                                                                          IfProjNode*& false_path_loop_entry) {\n@@ -396,2 +390,2 @@\n-    clone_parse_predicate_to_unswitched_loops(predicate_block, reason, iffast_pred, ifslow_pred);\n-    assert(iffast_pred->in(0)->is_ParsePredicate() && ifslow_pred->in(0)->is_ParsePredicate(),\n+    clone_parse_predicate_to_unswitched_loops(predicate_block, reason, true_path_loop_entry, false_path_loop_entry);\n+    assert(true_path_loop_entry->in(0)->is_ParsePredicate() && false_path_loop_entry->in(0)->is_ParsePredicate(),\n@@ -399,2 +393,3 @@\n-    clone_assertion_predicates_to_unswitched_loop(loop, old_new, reason, predicate_block->parse_predicate_success_proj(),\n-                                                  iffast_pred->as_IfTrue(), ifslow_pred->as_IfTrue());\n+    clone_assertion_predicates_to_unswitched_loop(loop, old_new, predicate_block->parse_predicate_success_proj(),\n+                                                  true_path_loop_entry->in(0)->as_ParsePredicate(),\n+                                                  false_path_loop_entry->in(0)->as_ParsePredicate());\n@@ -1253,3 +1248,3 @@\n-    IfTrueNode* template_assertion_predicate_proj =\n-        create_template_assertion_predicate(if_opcode, cl, parse_predicate_proj, upper_bound_proj, scale, offset, range,\n-                                            deopt_reason);\n+    IfTrueNode* template_assertion_predicate_proj = create_template_assertion_predicate(cl, parse_predicate,\n+                                                                                        upper_bound_proj, scale, offset,\n+                                                                                        range);\n@@ -1291,2 +1286,2 @@\n-IfTrueNode* PhaseIdealLoop::create_template_assertion_predicate(const int if_opcode, CountedLoopNode* loop_head,\n-                                                                ParsePredicateSuccessProj* parse_predicate_proj,\n+IfTrueNode* PhaseIdealLoop::create_template_assertion_predicate(CountedLoopNode* loop_head,\n+                                                                ParsePredicateNode* parse_predicate,\n@@ -1294,1 +1289,1 @@\n-                                                                Node* range, Deoptimization::DeoptReason deopt_reason) {\n+                                                                Node* range) {\n@@ -1297,3 +1292,4 @@\n-  return template_assertion_predicate_creator.create_with_uncommon_trap(new_control, parse_predicate_proj, deopt_reason,\n-                                                                        if_opcode);\n-\n+  IfTrueNode* template_success_proj = template_assertion_predicate_creator.create(new_control);\n+  _igvn.replace_input_of(parse_predicate, 0, template_success_proj);\n+  set_idom(parse_predicate, template_success_proj, dom_depth(template_success_proj));\n+  return template_success_proj;\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":54,"deletions":58,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -2771,1 +2771,1 @@\n-          loop_entry = template_assertion_predicate_creator.create_with_halt(loop_entry);\n+          loop_entry = template_assertion_predicate_creator.create(loop_entry);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2837,1 +2837,1 @@\n-    AssertionPredicatesWithHalt assertion_predicates(ctrl);\n+    AssertionPredicates assertion_predicates(ctrl);\n@@ -4473,1 +4473,1 @@\n-      get_assertion_predicates(parse_predicate_proj, useful_predicates, true);\n+      get_template_assertion_predicates(parse_predicate_proj, useful_predicates, true);\n@@ -4481,1 +4481,1 @@\n-      get_assertion_predicates(parse_predicate_proj, useful_predicates, true);\n+      get_template_assertion_predicates(parse_predicate_proj, useful_predicates, true);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -950,1 +950,1 @@\n-  static void get_assertion_predicates(ParsePredicateSuccessProj* parse_predicate_proj, Unique_Node_List& list, bool get_opaque = false);\n+  static void get_template_assertion_predicates(ParsePredicateSuccessProj* parse_predicate_proj, Unique_Node_List& list, bool get_opaque = false);\n@@ -1392,4 +1392,2 @@\n-  IfTrueNode* create_template_assertion_predicate(int if_opcode, CountedLoopNode* loop_head,\n-                                                  ParsePredicateSuccessProj* parse_predicate_proj,\n-                                                  IfProjNode* new_control, int scale, Node* offset,\n-                                                  Node* range, Deoptimization::DeoptReason deopt_reason);\n+  IfTrueNode* create_template_assertion_predicate(CountedLoopNode* loop_head, ParsePredicateNode* parse_predicate,\n+                                                  IfProjNode* new_control, int scale, Node* offset, Node* range);\n@@ -1664,1 +1662,2 @@\n-                                                               IfProjNode*& iffast_pred, IfProjNode*& ifslow_pred);\n+                                                               IfProjNode*& true_path_loop_entry,\n+                                                               IfProjNode*& false_path_loop_entry);\n@@ -1668,2 +1667,3 @@\n-                                                            Deoptimization::DeoptReason reason, IfProjNode*& iffast_pred,\n-                                                            IfProjNode*& ifslow_pred);\n+                                                            Deoptimization::DeoptReason reason,\n+                                                            IfProjNode*& true_path_loop_entry,\n+                                                            IfProjNode*& false_path_loop_entry);\n@@ -1675,6 +1675,5 @@\n-                                                     Deoptimization::DeoptReason reason, ParsePredicateSuccessProj* old_parse_predicate_proj,\n-                                                     ParsePredicateSuccessProj* fast_loop_parse_predicate_proj,\n-                                                     ParsePredicateSuccessProj* slow_loop_parse_predicate_proj);\n-  IfProjNode* clone_assertion_predicate_for_unswitched_loops(IfNode* template_assertion_predicate, IfProjNode* predicate,\n-                                                             Deoptimization::DeoptReason reason,\n-                                                             ParsePredicateSuccessProj* parse_predicate_proj);\n+                                                     ParsePredicateSuccessProj* old_parse_predicate_proj,\n+                                                     ParsePredicateNode* true_path_loop_parse_predicate,\n+                                                     ParsePredicateNode* false_path_loop_parse_predicate);\n+  IfTrueNode* clone_assertion_predicate_for_unswitched_loops(IfTrueNode* template_assertion_predicate_success_proj,\n+                                                             ParsePredicateNode* unswitched_loop_parse_predicate);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-Node* AssertionPredicatesWithHalt::find_entry(Node* start_proj) {\n+Node* AssertionPredicates::find_entry(Node* start_proj) {\n@@ -39,1 +39,1 @@\n-  while (AssertionPredicateWithHalt::is_predicate(entry)) {\n+  while (AssertionPredicate::is_predicate(entry)) {\n@@ -51,1 +51,1 @@\n-bool AssertionPredicateWithHalt::is_predicate(const Node* maybe_success_proj) {\n+bool AssertionPredicate::is_predicate(const Node* maybe_success_proj) {\n@@ -60,1 +60,1 @@\n-bool AssertionPredicateWithHalt::has_assertion_predicate_opaque(const Node* predicate_proj) {\n+bool AssertionPredicate::has_assertion_predicate_opaque(const Node* predicate_proj) {\n@@ -67,1 +67,1 @@\n-bool AssertionPredicateWithHalt::has_halt(const Node* success_proj) {\n+bool AssertionPredicate::has_halt(const Node* success_proj) {\n@@ -85,1 +85,1 @@\n-Deoptimization::DeoptReason RegularPredicateWithUCT::uncommon_trap_reason(IfProjNode* if_proj) {\n+Deoptimization::DeoptReason RuntimePredicate::uncommon_trap_reason(IfProjNode* if_proj) {\n@@ -93,1 +93,1 @@\n-bool RegularPredicateWithUCT::is_predicate(Node* maybe_success_proj) {\n+bool RuntimePredicate::is_predicate(Node* maybe_success_proj) {\n@@ -101,1 +101,1 @@\n-bool RegularPredicateWithUCT::has_valid_uncommon_trap(const Node* success_proj) {\n+bool RuntimePredicate::has_valid_uncommon_trap(const Node* success_proj) {\n@@ -109,1 +109,1 @@\n-bool RegularPredicateWithUCT::is_predicate(const Node* node, Deoptimization::DeoptReason deopt_reason) {\n+bool RuntimePredicate::is_predicate(const Node* node, const Deoptimization::DeoptReason deopt_reason) {\n@@ -131,10 +131,0 @@\n-\/\/ Runtime Predicates always have an UCT since they could normally fail at runtime. In this case we execute the trap\n-\/\/ on the failing path.\n-bool RuntimePredicate::is_predicate(Node* node) {\n-  return RegularPredicateWithUCT::is_predicate(node);\n-}\n-\n-bool RuntimePredicate::is_predicate(Node* node, Deoptimization::DeoptReason deopt_reason) {\n-  return RegularPredicateWithUCT::is_predicate(node, deopt_reason);\n-}\n-\n@@ -164,0 +154,15 @@\n+\/\/ Clone this Template Assertion Predicate and replace the OpaqueLoopInitNode with the provided 'new_opaque_init' node.\n+IfTrueNode* TemplateAssertionPredicate::clone(Node* new_control, PhaseIdealLoop* phase) const {\n+  assert(PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(_if_node),\n+         \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n+  TemplateAssertionExpression template_assertion_expression(opaque_node());\n+  OpaqueTemplateAssertionPredicateNode* new_opaque_node = template_assertion_expression.clone(new_control, phase);\n+  AssertionPredicateIfCreator assertion_predicate_if_creator(phase);\n+  IfTrueNode* success_proj = assertion_predicate_if_creator.create_for_template(new_control, _if_node->Opcode(),\n+                                                                                new_opaque_node,\n+                                                                                _if_node->assertion_predicate_type());\n+  assert(PhaseIdealLoop::assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n+         \"Template Assertion Predicates must have OpaqueLoop* nodes in the bool expression\");\n+  return success_proj;\n+}\n+\n@@ -171,1 +176,1 @@\n-      template_assertion_expression.clone_and_replace_init(new_opaque_init, new_control, phase);\n+      template_assertion_expression.clone_and_replace_init(new_control, new_opaque_init, phase);\n@@ -298,3 +303,3 @@\n-OpaqueTemplateAssertionPredicateNode* TemplateAssertionExpression::clone(Node* new_ctrl, PhaseIdealLoop* phase) {\n-  CloneStrategy clone_init_and_stride_strategy(phase, new_ctrl);\n-  return clone(clone_init_and_stride_strategy, new_ctrl, phase);\n+OpaqueTemplateAssertionPredicateNode* TemplateAssertionExpression::clone(Node* new_control, PhaseIdealLoop* phase) {\n+  CloneStrategy clone_init_and_stride_strategy(phase, new_control);\n+  return clone(clone_init_and_stride_strategy, new_control, phase);\n@@ -305,3 +310,3 @@\n-TemplateAssertionExpression::clone_and_replace_init(Node* new_init, Node* new_ctrl, PhaseIdealLoop* phase) {\n-  ReplaceInitAndCloneStrideStrategy replace_init_and_clone_stride_strategy(new_init, new_ctrl, phase);\n-  return clone(replace_init_and_clone_stride_strategy, new_ctrl, phase);\n+TemplateAssertionExpression::clone_and_replace_init(Node* new_control, Node* new_init, PhaseIdealLoop* phase) {\n+  ReplaceInitAndCloneStrideStrategy replace_init_and_clone_stride_strategy(new_init, new_control, phase);\n+  return clone(replace_init_and_clone_stride_strategy, new_control, phase);\n@@ -620,20 +625,0 @@\n-\/\/ Creates an init and last value Template Assertion Predicate connected together from a Parse Predicate with an UCT on\n-\/\/ the failing path. Returns the success projection of the last value Template Assertion Predicate.\n-IfTrueNode* TemplateAssertionPredicateCreator::create_with_uncommon_trap(\n-    Node* new_control, ParsePredicateSuccessProj* parse_predicate_success_proj,\n-    const Deoptimization::DeoptReason deopt_reason, const int if_opcode) {\n-  OpaqueLoopInitNode* opaque_init = create_opaque_init(new_control);\n-  bool does_overflow;\n-  OpaqueTemplateAssertionPredicateNode* template_assertion_predicate_expression =\n-      create_for_init_value(new_control, opaque_init, does_overflow);\n-  IfTrueNode* template_predicate_success_proj =\n-      create_if_node_with_uncommon_trap(template_assertion_predicate_expression, parse_predicate_success_proj,\n-                                        deopt_reason, if_opcode, does_overflow,\n-                                        AssertionPredicateType::InitValue);\n-  template_assertion_predicate_expression = create_for_last_value(template_predicate_success_proj, opaque_init,\n-                                                                  does_overflow);\n-  return create_if_node_with_uncommon_trap(template_assertion_predicate_expression, parse_predicate_success_proj,\n-                                           deopt_reason, if_opcode, does_overflow,\n-                                           AssertionPredicateType::LastValue);\n-}\n-\n@@ -653,11 +638,0 @@\n-IfTrueNode* TemplateAssertionPredicateCreator::create_if_node_with_uncommon_trap(\n-    OpaqueTemplateAssertionPredicateNode* template_assertion_predicate_expression,\n-    ParsePredicateSuccessProj* parse_predicate_success_proj, const Deoptimization::DeoptReason deopt_reason,\n-    const int if_opcode, const bool does_overflow, const AssertionPredicateType assertion_predicate_type) {\n-  IfTrueNode* success_proj = _phase->create_new_if_for_predicate(parse_predicate_success_proj, nullptr, deopt_reason,\n-                                                                 does_overflow ? Op_If : if_opcode, false,\n-                                                                 assertion_predicate_type);\n-  _phase->igvn().replace_input_of(success_proj->in(0), 1, template_assertion_predicate_expression);\n-  return success_proj;\n-}\n-\n@@ -686,1 +660,1 @@\n-IfTrueNode* TemplateAssertionPredicateCreator::create_if_node_with_halt(\n+IfTrueNode* TemplateAssertionPredicateCreator::create_if_node(\n@@ -697,1 +671,1 @@\n-IfTrueNode* TemplateAssertionPredicateCreator::create_with_halt(Node* new_control) {\n+IfTrueNode* TemplateAssertionPredicateCreator::create(Node* new_control) {\n@@ -703,2 +677,2 @@\n-      create_if_node_with_halt(new_control, template_assertion_predicate_expression, does_overflow,\n-                               AssertionPredicateType::InitValue);\n+      create_if_node(new_control, template_assertion_predicate_expression, does_overflow,\n+                     AssertionPredicateType::InitValue);\n@@ -707,2 +681,2 @@\n-  return create_if_node_with_halt(template_predicate_success_proj, template_assertion_predicate_expression,\n-                                  does_overflow, AssertionPredicateType::LastValue);\n+  return create_if_node(template_predicate_success_proj, template_assertion_predicate_expression,\n+                        does_overflow, AssertionPredicateType::LastValue);\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":37,"deletions":63,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -255,4 +255,3 @@\n-\/\/ Class to represent Assertion Predicates with a HaltNode instead of an UCT (i.e. either an Initialized Assertion\n-\/\/ Predicate or a Template Assertion Predicate created after the initial one at Loop Predication).\n-class AssertionPredicatesWithHalt : public StackObj {\n-  Node* _entry;\n+\/\/ Class to represent Assertion Predicates (i.e. either Initialized and\/or Template Assertion Predicates).\n+class AssertionPredicates : public StackObj {\n+  Node* const _entry;\n@@ -263,1 +262,2 @@\n-  AssertionPredicatesWithHalt(Node* assertion_predicate_proj) : _entry(find_entry(assertion_predicate_proj)) {}\n+  explicit AssertionPredicates(Node* assertion_predicate_proj) : _entry(find_entry(assertion_predicate_proj)) {}\n+  NONCOPYABLE(AssertionPredicates);\n@@ -272,1 +272,1 @@\n-\/\/ Class to represent a single Assertion Predicate with a HaltNode. This could either be:\n+\/\/ Class to represent a single Assertion Predicate. This could either be:\n@@ -275,2 +275,1 @@\n-\/\/ Note that all other Regular Predicates have an UCT node.\n-class AssertionPredicateWithHalt : public StackObj {\n+class AssertionPredicate : public StackObj {\n@@ -278,0 +277,1 @@\n+  static bool has_halt(const Node* success_proj);\n@@ -280,1 +280,0 @@\n-  static bool has_halt(const Node* success_proj);\n@@ -289,13 +288,0 @@\n-\/\/ Class to represent a single Regular Predicate with an UCT. This could either be:\n-\/\/ - A Runtime Predicate\n-\/\/ - A Template Assertion Predicate\n-\/\/ Note that all other Regular Predicates have a Halt node.\n-class RegularPredicateWithUCT : public StackObj {\n-  static Deoptimization::DeoptReason uncommon_trap_reason(IfProjNode* if_proj);\n-\n- public:\n-  static bool is_predicate(Node* maybe_success_proj);\n-  static bool is_predicate(const Node* node, Deoptimization::DeoptReason deopt_reason);\n-  static bool has_valid_uncommon_trap(const Node* success_proj);\n-};\n-\n@@ -359,0 +345,2 @@\n+  static bool has_valid_uncommon_trap(const Node* success_proj);\n+  static Deoptimization::DeoptReason uncommon_trap_reason(IfProjNode* if_proj);\n@@ -373,1 +361,1 @@\n-  static bool is_predicate(Node* node, Deoptimization::DeoptReason deopt_reason);\n+  static bool is_predicate(const Node* node, Deoptimization::DeoptReason deopt_reason);\n@@ -408,0 +396,1 @@\n+  IfTrueNode* clone(Node* new_control, PhaseIdealLoop* phase) const;\n@@ -469,2 +458,3 @@\n-  OpaqueTemplateAssertionPredicateNode* clone(Node* new_ctrl, PhaseIdealLoop* phase);\n-  OpaqueTemplateAssertionPredicateNode* clone_and_replace_init(Node* new_init, Node* new_ctrl, PhaseIdealLoop* phase);\n+  OpaqueTemplateAssertionPredicateNode* clone(Node* new_control, PhaseIdealLoop* phase);\n+  OpaqueTemplateAssertionPredicateNode* clone_and_replace_init(Node* new_control, Node* new_init,\n+                                                               PhaseIdealLoop* phase);\n@@ -573,1 +563,1 @@\n-\/\/ This class is used to create a Template Assertion Predicate either with an UCT or a Halt Node from scratch.\n+\/\/ This class is used to create a Template Assertion Predicate either with a Halt Node from scratch.\n@@ -587,7 +577,3 @@\n-  IfTrueNode* create_if_node_with_uncommon_trap(OpaqueTemplateAssertionPredicateNode* template_assertion_predicate_expression,\n-                                                ParsePredicateSuccessProj* parse_predicate_success_proj,\n-                                                Deoptimization::DeoptReason deopt_reason, int if_opcode,\n-                                                bool does_overflow, AssertionPredicateType assertion_predicate_type);\n-  IfTrueNode* create_if_node_with_halt(Node* new_control,\n-                                       OpaqueTemplateAssertionPredicateNode* template_assertion_predicate_expression,\n-                                       bool does_overflow, AssertionPredicateType assertion_predicate_type);\n+  IfTrueNode* create_if_node(Node* new_control,\n+                             OpaqueTemplateAssertionPredicateNode* template_assertion_predicate_expression,\n+                             bool does_overflow, AssertionPredicateType assertion_predicate_type);\n@@ -605,3 +591,1 @@\n-  IfTrueNode* create_with_uncommon_trap(Node* new_control, ParsePredicateSuccessProj* parse_predicate_success_proj,\n-                                        Deoptimization::DeoptReason deopt_reason, int if_opcode);\n-  IfTrueNode* create_with_halt(Node* new_control);\n+  IfTrueNode* create(Node* new_control);\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":20,"deletions":36,"binary":false,"changes":56,"status":"modified"}]}