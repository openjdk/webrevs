{"files":[{"patch":"@@ -46,0 +46,1 @@\n+#include \"utilities\/utf8.hpp\"\n@@ -265,1 +266,1 @@\n-  os::vsnprintf(msg, max_msg_size, format, ap);\n+  int ret = os::vsnprintf(msg, max_msg_size, format, ap);\n@@ -267,0 +268,24 @@\n+\n+  \/\/ If ret == -1 then either there was a format conversion error, or the required buffer size\n+  \/\/ exceeds INT_MAX and so couldn't be returned (undocumented behaviour of vsnprintf). Depending\n+  \/\/ on the platform the buffer may be filled to its capacity (Linux), filled to the conversion\n+  \/\/ that encountered the overflow (macOS), or is empty (Windows), so it is possible we\n+  \/\/ have a truncated UTF-8 sequence. Similarly, if the buffer was too small and ret >= max_msg_size\n+  \/\/ we may also have a truncated UTF-8 sequence. In such cases we need to fix the buffer so the UTF-8\n+  \/\/ sequence is valid.\n+  if (ret == -1 || ret >= max_msg_size) {\n+    int len = (int) strlen(msg);\n+    if (len > 0) {\n+      \/\/ Truncation will only happen if the buffer was filled by vsnprintf,\n+      \/\/ otherwise vsnprintf already terminated filling it at a well-defined point.\n+      \/\/ But as this is not a clearly specified area we will perform our own UTF8\n+      \/\/ truncation anyway - though for those well-defined termination points it\n+      \/\/ will be a no-op.\n+      UTF8::truncate_to_legal_utf8((unsigned char*)msg, len);\n+    }\n+  }\n+  \/\/ UTF8::is_legal_utf8 should actually be called is_legal_utf8_class_name as the final\n+  \/\/ parameter controls a check for a specific character appearing in the \"name\", which is only\n+  \/\/ allowed for classfile versions <= 47. We pass `true` so that we allow such strings as this code\n+  \/\/ know nothing about the actual string content.\n+  assert(UTF8::is_legal_utf8((const unsigned char*)msg, (int)strlen(msg), true), \"must be\");\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -395,0 +395,63 @@\n+\/\/ Return true if `b` could be the starting byte of an encoded 2,3 or 6\n+\/\/ byte sequence.\n+static bool is_starting_byte(unsigned char b) {\n+  return b >= 0xC0 && b <= 0xEF;\n+}\n+\n+\/\/ Takes an incoming buffer that was valid UTF-8, but which has been truncated such that\n+\/\/ the last encoding may be partial, and returns the same buffer with a NUL-terminator\n+\/\/ inserted such that any partial encoding has gone.\n+\/\/ Note: if the incoming buffer is already valid then we may still drop the last encoding.\n+\/\/ To avoid that the caller can choose to check for validity first.\n+\/\/ The incoming buffer is still expected to be NUL-terminated.\n+\/\/ The incoming buffer is expected to be a realistic size - we assert if it is too small.\n+void UTF8::truncate_to_legal_utf8(unsigned char* buffer, int length) {\n+  assert(length > 5, \"invalid length\");\n+  assert(buffer[length - 1] == '\\0', \"Buffer should be NUL-terminated\");\n+\n+  if (buffer[length - 2] < 128) {  \/\/ valid \"ascii\" - common case\n+    return;\n+  }\n+\n+  \/\/ Modified UTF-8 encodes characters in sequences of 1, 2, 3 or 6 bytes.\n+  \/\/ The last byte is invalid if it is:\n+  \/\/ - the 1st byte of a 2, 3 or 6 byte sequence\n+  \/\/     0b110xxxxx\n+  \/\/     0b1110xxxx\n+  \/\/     0b11101101\n+  \/\/ - the 2nd byte of a 3 or 6 byte sequence\n+  \/\/     0b10xxxxxx\n+  \/\/     0b1010xxxx\n+  \/\/ - the 3rd, 4th or 5th byte of a 6 byte sequence\n+  \/\/     0b10xxxxxx\n+  \/\/     0b11101101\n+  \/\/     0b1011xxxx\n+  \/\/\n+  \/\/ Rather than checking all possible situations we simplify things noting that as we have already\n+  \/\/ got a truncated string, then dropping one more character is not significant. So we work from the\n+  \/\/ end of the buffer looking for the first byte that can be the starting byte of a UTF-8 encoded sequence,\n+  \/\/ then we insert NUL at that location to terminate the buffer. There is an added complexity with 6 byte\n+  \/\/ encodings as the first and fourth bytes are the same and overlap with the 3 byte encoding.\n+\n+  for (int index = length - 2; index > 0; index--) {\n+    if (is_starting_byte(buffer[index])) {\n+      if (buffer[index] == 0xED) {\n+        \/\/ Could be first byte of 3 or 6, or fourth byte of 6.\n+        \/\/ If fourth the previous three bytes will encode a high\n+        \/\/ surrogate value in the range EDA080 to EDAFBF. We only\n+        \/\/ need to check for EDA to establish this as the \"missing\"\n+        \/\/ values in EDAxxx would not be valid 3 byte encodings.\n+        if ((index - 3) >= 0 &&\n+            (buffer[index - 3] == 0xED) &&\n+            ((buffer[index - 2] & 0xF0) == 0xA0)) {\n+          assert(buffer[index - 1] >= 0x80 && buffer[index - 1] <= 0xBF, \"sanity check\");\n+          \/\/ It was fourth byte so truncate 3 bytes earlier\n+          index -= 3;\n+        }\n+      }\n+      buffer[index] = '\\0';\n+      break;\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/utf8.cpp","additions":63,"deletions":0,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,1 @@\n+  static void   truncate_to_legal_utf8(unsigned char* buffer, int length);\n","filename":"src\/hotspot\/share\/utilities\/utf8.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+#include \"nmt\/memflags.hpp\"\n+#include \"runtime\/os.hpp\"\n@@ -104,0 +106,100 @@\n+}\n+\n+TEST_VM(utf8, truncation) {\n+\n+  \/\/ Test that truncation removes partial encodings as expected.\n+\n+  const char orig_bytes[] = { 'A', 'B', 'C', 'D', 'E', '\\0' };\n+  const int orig_length = sizeof(orig_bytes)\/sizeof(char);\n+  ASSERT_TRUE(UTF8::is_legal_utf8((const unsigned char*)orig_bytes, orig_length - 1, false));\n+  const char* orig_str = &orig_bytes[0];\n+  ASSERT_EQ((int)strlen(orig_str), orig_length - 1);\n+\n+  unsigned char* temp_bytes;\n+  const char* temp_str;\n+  char* utf8;\n+  int n_utf8; \/\/ Number of bytes in the encoding\n+\n+  \/\/ Test 1: a valid UTF8 \"ascii\" ending string should be returned as-is\n+\n+  temp_bytes = (unsigned char*) os::malloc(sizeof(unsigned char) * orig_length, mtTest);\n+  strcpy((char*)temp_bytes, orig_str);\n+  temp_str = (const char*) temp_bytes;\n+  UTF8::truncate_to_legal_utf8(temp_bytes, orig_length);\n+  ASSERT_EQ((int)strlen(temp_str), orig_length - 1) << \"bytes should be unchanged\";\n+  ASSERT_EQ(strcmp(orig_str, temp_str), 0) << \"bytes should be unchanged\";\n+  os::free(temp_bytes);\n+\n+  \/\/ Test 2: a UTF8 sequence that \"ends\" with a 2-byte encoding\n+  \/\/         drops the 2-byte encoding\n+\n+  jchar two_byte_char[] = { 0x00D1 }; \/\/ N with tilde\n+  n_utf8 = 2;\n+  utf8 = (char*) os::malloc(sizeof(char) * (n_utf8 + 1), mtTest); \/\/ plus NUL\n+  UNICODE::convert_to_utf8(two_byte_char, 1, utf8);\n+  int utf8_len = (int)strlen(utf8);\n+  ASSERT_EQ(utf8_len, n_utf8) << \"setup error\";\n+\n+  \/\/ Now drop zero or one byte from the end and check it truncates as expected\n+  for (int drop = 0; drop < n_utf8; drop++) {\n+    int temp_len = orig_length + utf8_len - drop;\n+    temp_bytes = (unsigned char*) os::malloc(sizeof(unsigned char) * temp_len, mtTest);\n+    temp_str = (const char*) temp_bytes;\n+    strcpy((char*)temp_bytes, orig_str);\n+    strncat((char*)temp_bytes, utf8, utf8_len - drop);\n+    ASSERT_EQ((int)strlen(temp_str), temp_len - 1) << \"setup error\";\n+    UTF8::truncate_to_legal_utf8(temp_bytes, temp_len);\n+    ASSERT_EQ((int)strlen(temp_str), orig_length - 1) << \"bytes should be truncated to original length\";\n+    ASSERT_EQ(strcmp(orig_str, temp_str), 0) << \"bytes should be truncated to original\";\n+    os::free(temp_bytes);\n+  }\n+  os::free(utf8);\n+\n+  \/\/ Test 3: a UTF8 sequence that \"ends\" with a 3-byte encoding\n+  \/\/         drops the 3-byte encoding\n+  n_utf8 = 3;\n+  jchar three_byte_char[] = { 0x0800 };\n+  utf8 = (char*) os::malloc(sizeof(char) * (n_utf8 + 1), mtTest); \/\/ plus NUL\n+  UNICODE::convert_to_utf8(three_byte_char, 1, utf8);\n+  utf8_len = (int)strlen(utf8);\n+  ASSERT_EQ(utf8_len, n_utf8) << \"setup error\";\n+\n+  \/\/ Now drop zero, to two bytes from the end and check it truncates as expected\n+  for (int drop = 0; drop < n_utf8; drop++) {\n+    int temp_len = orig_length + utf8_len - drop;\n+    temp_bytes = (unsigned char*) os::malloc(sizeof(unsigned char) * temp_len, mtTest);\n+    temp_str = (const char*) temp_bytes;\n+    strcpy((char*)temp_bytes, orig_str);\n+    strncat((char*)temp_bytes, utf8, utf8_len - drop);\n+    ASSERT_EQ((int)strlen(temp_str), temp_len - 1) << \"setup error\";\n+    UTF8::truncate_to_legal_utf8(temp_bytes, temp_len);\n+    ASSERT_EQ((int)strlen(temp_str), orig_length - 1) << \"bytes should be truncated to original length\";\n+    ASSERT_EQ(strcmp(orig_str, temp_str), 0) << \"bytes should be truncated to original\";\n+    os::free(temp_bytes);\n+  }\n+  os::free(utf8);\n+\n+  \/\/ Test 4: a UTF8 sequence that \"ends\" with a 6-byte encoding\n+  \/\/         drops the 6-byte encoding\n+  n_utf8 = 6;\n+  jchar six_byte_char[] = { 0xD801, 0xDC37 }; \/\/ U+10437 as its UTF-16 surrogate pairs\n+  utf8 = (char*) os::malloc(sizeof(char) * (n_utf8 + 1), mtTest); \/\/ plus NUL\n+  UNICODE::convert_to_utf8(six_byte_char, 2, utf8);\n+  utf8_len = (int)strlen(utf8);\n+  ASSERT_EQ(utf8_len, n_utf8) << \"setup error\";\n+\n+  \/\/ Now drop zero to five bytes from the end and check it truncates as expected\n+  for (int drop = 0; drop < n_utf8; drop++) {\n+    int temp_len = orig_length + utf8_len - drop;\n+    temp_bytes = (unsigned char*) os::malloc(sizeof(unsigned char) * temp_len, mtTest);\n+    temp_str = (const char*) temp_bytes;\n+    strcpy((char*)temp_bytes, orig_str);\n+    strncat((char*)temp_bytes, utf8, utf8_len - drop);\n+    ASSERT_EQ((int)strlen(temp_str), temp_len - 1) << \"setup error\";\n+    UTF8::truncate_to_legal_utf8(temp_bytes, temp_len);\n+    ASSERT_EQ((int)strlen(temp_str), orig_length - 1) << \"bytes should be truncated to original length\";\n+    ASSERT_EQ(strcmp(orig_str, temp_str), 0) << \"bytes should be truncated to original\";\n+    os::free(temp_bytes);\n+  }\n+  os::free(utf8);\n+\n","filename":"test\/hotspot\/gtest\/utilities\/test_utf8.cpp","additions":103,"deletions":1,"binary":false,"changes":104,"status":"modified"}]}