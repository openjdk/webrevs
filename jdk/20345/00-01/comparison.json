{"files":[{"patch":"@@ -398,1 +398,1 @@\n-  return b >= 0xC0 && b <= 0xEF;;\n+  return b >= 0xC0 && b <= 0xEF;\n@@ -402,1 +402,1 @@\n-\/\/ the last encoding may be partial, and return the same buffer with a NUL-terminator\n+\/\/ the last encoding may be partial, and returns the same buffer with a NUL-terminator\n@@ -407,0 +407,1 @@\n+\/\/ The incoming buffer is expected to be a realistic size - we assert if it is too small.\n@@ -408,1 +409,1 @@\n-  assert(length > 0, \"invalid length\");\n+  assert(length > 5, \"invalid length\");\n@@ -433,1 +434,1 @@\n-  \/\/ encodings as the first and fourth bytes are the same.\n+  \/\/ encodings as the first and fourth bytes are the same and overlap with the 3 byte encoding.\n@@ -438,5 +439,10 @@\n-        \/\/ Could be first or fourth byte. If fourth\n-        \/\/ then 2 bytes before will have second byte pattern (0b1010xxxx)\n-        if ((index - 3) >= 0 && ((buffer[index - 2] & 0xA0) == 0xA0)) {\n-          \/\/ it was fourth byte so truncate 3 bytes earlier\n-          assert(buffer[index - 3] == 0xED, \"malformed sequence\");\n+        \/\/ Could be first byte of 3 or 6, or fourth byte of 6.\n+        \/\/ If fourth the previous three bytes will encode a high\n+        \/\/ surrogate value in the range EDA080 to EDAFBF. We only\n+        \/\/ need to check for EDA to establish this as the \"missing\"\n+        \/\/ values in EDAxxx would not be valid 3 byte encodings.\n+        if ((index - 3) >= 0 &&\n+            (buffer[index - 3] == 0xED) &&\n+            ((buffer[index - 2] & 0xF0) == 0xA0)) {\n+          assert(buffer[index - 1] >= 0x80 && buffer[index - 1] <= 0xBF, \"sanity check\");\n+          \/\/ It was fourth byte so truncate 3 bytes earlier\n","filename":"src\/hotspot\/share\/utilities\/utf8.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"}]}