{"files":[{"patch":"@@ -180,0 +180,6 @@\n+    int base_offset = arrayOopDesc::length_offset_in_bytes() + BytesPerInt;\n+    if (!is_aligned(base_offset, BytesPerWord)) {\n+      assert(is_aligned(base_offset, BytesPerInt), \"must be 4-byte aligned\");\n+      \/\/ Clear gap\/first 4 bytes following the length field.\n+      sw(zr, Address(obj, base_offset));\n+    }\n@@ -299,10 +305,3 @@\n-  \/\/ Clear leading 4 bytes, if necessary.\n-  \/\/ TODO: This could perhaps go into initialize_body() and also clear the leading 4 bytes\n-  \/\/ for non-array objects, thereby replacing the klass-gap clearing code in initialize_header().\n-  int base_offset = base_offset_in_bytes;\n-  if (!is_aligned(base_offset, BytesPerWord)) {\n-    assert(is_aligned(base_offset, BytesPerInt), \"must be 4-byte aligned\");\n-    sw(zr, Address(obj, base_offset));\n-    base_offset += BytesPerInt;\n-  }\n-  assert(is_aligned(base_offset, BytesPerWord), \"must be word-aligned\");\n+  \/\/ Align-up to word boundary, because we clear the 4 bytes potentially\n+  \/\/ following the length field in initialize_header().\n+  int base_offset = align_up(base_offset_in_bytes, BytesPerWord);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"}]}