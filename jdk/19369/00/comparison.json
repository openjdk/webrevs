{"files":[{"patch":"@@ -216,1 +216,7 @@\n-  res = widen_type(phase, res, T_INT);\n+  \/\/ But here we have to pay extra attention:\n+  \/\/ Do not narrow the type of range check dependent CastIINodes to\n+  \/\/ avoid corruption of the graph if a CastII is replaced by TOP but\n+  \/\/ the corresponding range check is not removed.\n+  if (!_range_check_dependency) {\n+    res = widen_type(phase, res, T_INT);\n+  }\n@@ -236,1 +242,1 @@\n-  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n+  if (can_reshape && !_range_check_dependency && !phase->C->post_loop_opts_phase()) {\n@@ -240,1 +246,1 @@\n-  if (!_type->is_int()->empty()) {\n+  if (!_range_check_dependency) {\n@@ -251,0 +257,7 @@\n+  if (_range_check_dependency) {\n+    if (phase->C->post_loop_opts_phase()) {\n+      return this->in(1);\n+    } else {\n+      phase->C->record_for_post_loop_opts_igvn(this);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -3467,4 +3467,0 @@\n-  case Op_CastII: {\n-    remove_range_check_cast(n->as_CastII());\n-  }\n-  break;\n@@ -3622,0 +3618,10 @@\n+#ifdef ASSERT\n+  case Op_CastII:\n+    \/\/ Verify that all range check dependent CastII nodes were removed.\n+    if (n->isa_CastII()->has_range_check()) {\n+      n->dump(3);\n+      assert(false, \"Range check dependent CastII node was not removed\");\n+    }\n+    break;\n+#endif\n+\n@@ -3630,2 +3636,0 @@\n-          divmod->add_prec_from(n);\n-          divmod->add_prec_from(d);\n@@ -3652,2 +3656,0 @@\n-          divmod->add_prec_from(n);\n-          divmod->add_prec_from(d);\n@@ -3674,2 +3676,0 @@\n-          divmod->add_prec_from(n);\n-          divmod->add_prec_from(d);\n@@ -3696,2 +3696,0 @@\n-          divmod->add_prec_from(n);\n-          divmod->add_prec_from(d);\n@@ -3899,28 +3897,0 @@\n-void Compile::remove_range_check_cast(CastIINode* cast) {\n-  if (cast->has_range_check()) {\n-    \/\/ Range check CastII nodes feed into an address computation subgraph. Remove them to let that subgraph float freely.\n-    \/\/ For memory access or integer divisions nodes that depend on the cast, record the dependency on the cast's control\n-    \/\/ as a precedence edge, so they can't float above the cast in case that cast's narrowed type helped eliminate a\n-    \/\/ range check or a null divisor check.\n-    assert(cast->in(0) != nullptr, \"All RangeCheck CastII must have a control dependency\");\n-    ResourceMark rm;\n-    Unique_Node_List wq;\n-    wq.push(cast);\n-    for (uint next = 0; next < wq.size(); ++next) {\n-      Node* m = wq.at(next);\n-      for (DUIterator_Fast imax, i = m->fast_outs(imax); i < imax; i++) {\n-        Node* use = m->fast_out(i);\n-        if (use->is_Mem() || use->is_div_or_mod(T_INT) || use->is_div_or_mod(T_LONG)) {\n-          use->ensure_control_or_add_prec(cast->in(0));\n-        } else if (!use->is_CFG() && !use->is_Phi()) {\n-          wq.push(use);\n-        }\n-      }\n-    }\n-    cast->subsume_by(cast->in(1), this);\n-    if (cast->outcnt() == 0) {\n-      cast->disconnect_inputs(this);\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":10,"deletions":40,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-class CastIINode;\n@@ -1318,2 +1317,0 @@\n-\n-  void remove_range_check_cast(CastIINode* cast);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2881,9 +2881,0 @@\n-void Node::add_prec_from(Node* n) {\n-  for (uint i = n->req(); i < n->len(); i++) {\n-    Node* prec = n->in(i);\n-    if (prec != nullptr) {\n-      add_prec(prec);\n-    }\n-  }\n-}\n-\n@@ -2913,3 +2904,0 @@\n-bool Node::is_div_or_mod(BasicType bt) const { return Opcode() == Op_Div(bt) || Opcode() == Op_Mod(bt) ||\n-                                                      Opcode() == Op_UDiv(bt) || Opcode() == Op_UMod(bt); }\n-\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1146,1 +1146,0 @@\n-  void add_prec_from(Node* n);\n@@ -1258,2 +1257,0 @@\n-  bool is_div_or_mod(BasicType bt) const;\n-\n@@ -2029,4 +2026,0 @@\n-Op_IL(Div)\n-Op_IL(Mod)\n-Op_IL(UDiv)\n-Op_IL(UMod)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,474 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8324517\n- * @summary C2: out of bound array load because of dependency on removed range check CastIIs\n- *\n- * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n- *                   -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n- *                   TestArrayAccessAboveRCAfterRCCastIIEliminated\n- * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n- *                   -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM TestArrayAccessAboveRCAfterRCCastIIEliminated\n- * @run main\/othervm TestArrayAccessAboveRCAfterRCCastIIEliminated\n- * @run main\/othervm -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n- *                   TestArrayAccessAboveRCAfterRCCastIIEliminated\n- *\n- *\/\n-\n-public class TestArrayAccessAboveRCAfterRCCastIIEliminated {\n-    private static int intField;\n-    private static long longField;\n-    private static volatile int volatileField;\n-\n-    public static void main(String[] args) {\n-        int[] array = new int[100];\n-        for (int i = 0; i < 20_000; i++) {\n-            test1(9, 10, 1, true);\n-            test1(9, 10, 1, false);\n-            test2(9, 10, 1, true);\n-            test2(9, 10, 1, false);\n-            test3(9, 10, 1, true);\n-            test3(9, 10, 1, false);\n-            test4(9, 10, 1, true);\n-            test4(9, 10, 1, false);\n-            test5(9, 10, 1, true);\n-            test5(9, 10, 1, false);\n-            test6(9, 10, 1, true);\n-            test6(9, 10, 1, false);\n-            test7(9, 10, 1, true);\n-            test7(9, 10, 1, false);\n-            test8(9, 10, 1, true);\n-            test8(9, 10, 1, false);\n-            test9(9, 10, 1, true);\n-            test9(9, 10, 1, false);\n-            test10(9, 10, 1, true);\n-            test10(9, 10, 1, false);\n-            test11(9, 10, 1, true);\n-            test11(9, 10, 1, false);\n-            test12(9, 10, 1, true);\n-            test12(9, 10, 1, false);\n-            test13(9, 10, 1, true);\n-            test13(9, 10, 1, false);\n-        }\n-        try {\n-            test1(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test2(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test3(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test4(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test5(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test6(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test7(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test8(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test9(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test10(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test11(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test12(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test13(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-    }\n-\n-    private static void test1(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = array[otherArray.length];\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = array[otherArray.length];\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test2(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = 1 \/ (otherArray.length + 1);\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = 1 \/ (otherArray.length + 1);\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test3(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = 1L \/ (otherArray.length + 1);\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = 1L \/ (otherArray.length + 1);\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test4(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = 1 % (otherArray.length + 1);\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = 1 % (otherArray.length + 1);\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test5(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = 1L % (otherArray.length + 1);\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = 1L % (otherArray.length + 1);\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test6(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = 1 % (otherArray.length + 1) + 1 \/ (otherArray.length + 1);\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = 1 % (otherArray.length + 1) + 1 \/ (otherArray.length + 1);\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test7(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = 1L % (otherArray.length + 1) + 1L \/ (otherArray.length + 1);\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = 1L % (otherArray.length + 1) + 1L \/ (otherArray.length + 1);\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-    private static void test8(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = Integer.divideUnsigned(1, (otherArray.length + 1));\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = Integer.divideUnsigned(1, (otherArray.length + 1));\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test9(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = Long.divideUnsigned(1L, (otherArray.length + 1));\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = Long.divideUnsigned(1L, (otherArray.length + 1));\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test10(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = Integer.remainderUnsigned(1, (otherArray.length + 1));\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = Integer.remainderUnsigned(1, (otherArray.length + 1));\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test11(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = Long.remainderUnsigned(1L, (otherArray.length + 1));\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = Long.remainderUnsigned(1L, (otherArray.length + 1));\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test12(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = Integer.divideUnsigned(1, (otherArray.length + 1)) +\n-                    Integer.remainderUnsigned(1, (otherArray.length + 1));\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = Integer.divideUnsigned(1, (otherArray.length + 1)) +\n-                    Integer.remainderUnsigned(1, (otherArray.length + 1));\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test13(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = Long.remainderUnsigned(1L, (otherArray.length + 1)) +\n-                    Long.divideUnsigned(1L, (otherArray.length + 1));\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = Long.remainderUnsigned(1L, (otherArray.length + 1)) +\n-                    Long.divideUnsigned(1L, (otherArray.length + 1));\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void notInlined(int[] array) {\n-\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCAfterRCCastIIEliminated.java","additions":0,"deletions":474,"binary":false,"changes":474,"status":"deleted"}]}