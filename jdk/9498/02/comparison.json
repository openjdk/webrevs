{"files":[{"patch":"@@ -5684,0 +5684,62 @@\n+void C2_MacroAssembler::rearrange_bytes(XMMRegister dst, XMMRegister shuffle, XMMRegister src, XMMRegister xtmp1,\n+                                        XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, XMMRegister xtmp5,\n+                                        Register rtmp, KRegister ktmp1, KRegister ktmp2, int vlen_enc) {\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  \/\/ Byte shuffles are inlane operations and indices are determined using\n+  \/\/ lower 4 bit of each shuffle lane, thus all shuffle indices are\n+  \/\/ normalized to index range 0-15. This makes sure that all the multiples\n+  \/\/ of an index value are placed at same relative position in 128 bit\n+  \/\/ lane i.e. elements corresponding to shuffle indices 16, 32 and 64\n+  \/\/ will be 16th element in their respective 128 bit lanes.\n+  movl(rtmp, 16);\n+  evpbroadcastb(xtmp2, rtmp, vlen_enc);\n+\n+  \/\/ Compute a mask for shuffle vector by comparing indices with expression INDEX < 16,\n+  \/\/ Broadcast first 128 bit lane across entire vector, shuffle the vector lanes using\n+  \/\/ original shuffle indices and move the shuffled lanes corresponding to true\n+  \/\/ mask to destination vector.\n+  evpcmpb(ktmp2, k0, shuffle, xtmp2, Assembler::lt, true, vlen_enc);\n+  vpermq(xtmp3, src, 0x44, vlen_enc);\n+  vinserti64x4(xtmp3, xtmp3, xtmp3, 0x1);\n+  vpshufb(xtmp3, xtmp3, shuffle, vlen_enc);\n+  evmovdqub(dst, ktmp2, xtmp3, false, vlen_enc);\n+\n+  \/\/ Perform above steps with lane comparison expression as INDEX >= 16 && INDEX < 32\n+  \/\/ and broadcasting second 128 bit lane.\n+  evpcmpb(ktmp1, k0, shuffle,  xtmp2, Assembler::nlt, true, vlen_enc);\n+  vpsllq(xtmp5, xtmp2, 0x1, vlen_enc);\n+  evpcmpb(ktmp2, k0, shuffle, xtmp5, Assembler::lt, true, vlen_enc);\n+  kandql(ktmp2, ktmp1, ktmp2);\n+  vpermq(xtmp3, src,  0xEE, vlen_enc);\n+  vinserti64x4(xtmp3, xtmp3, xtmp3, 0x1);\n+  vpshufb(xtmp3, xtmp3, shuffle, vlen_enc);\n+  evmovdqub(xtmp4, ktmp2, xtmp3, false, vlen_enc);\n+  vporq(dst, dst, xtmp4, vlen_enc);\n+\n+  \/\/ Perform above steps with lane comparison expression as INDEX >= 32 && INDEX < 48\n+  \/\/ and broadcasting third 128 bit lane.\n+  evpcmpb(ktmp1, k0, shuffle,  xtmp5, Assembler::nlt, true, vlen_enc);\n+  vpaddb(xtmp5, xtmp2, xtmp5, vlen_enc);\n+  evpcmpb(ktmp2, k0, shuffle,  xtmp5, Assembler::lt, true, vlen_enc);\n+  kandql(ktmp2, ktmp1 , ktmp2);\n+  vpermq(xtmp3, src,  0x44, vlen_enc);\n+  vextracti64x4_high(xtmp3, xtmp3);\n+  vinserti64x4(xtmp3, xtmp3, xtmp3, 0x1);\n+  vpshufb(xtmp3, xtmp3, shuffle, vlen_enc);\n+  evmovdqub(xtmp4, ktmp2, xtmp3, false, vlen_enc);\n+  vporq(dst, dst, xtmp4, vlen_enc);\n+\n+  \/\/ Perform above steps with lane comparison expression as INDEX >= 48 && INDEX < 64\n+  \/\/ and broadcasting third 128 bit lane.\n+  evpcmpb(ktmp1, k0, shuffle,  xtmp5, Assembler::nlt, true, vlen_enc);\n+  vpsllq(xtmp5, xtmp2, 0x2, vlen_enc);\n+  evpcmpb(ktmp2, k0, shuffle,  xtmp5, Assembler::lt, true, vlen_enc);\n+  kandql(ktmp2, ktmp1 , ktmp2);\n+  vpermq(xtmp3, src,  0xEE, vlen_enc);\n+  vextracti64x4_high(xtmp3, xtmp3);\n+  vinserti64x4(xtmp3, xtmp3, xtmp3, 0x1);\n+  vpshufb(xtmp3, xtmp3, shuffle, vlen_enc);\n+  evmovdqub(xtmp4, ktmp2, xtmp3, false, vlen_enc);\n+  vporq(dst, dst, xtmp4, vlen_enc);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -461,0 +461,4 @@\n+  void rearrange_bytes(XMMRegister dst, XMMRegister shuffle, XMMRegister src, XMMRegister xtmp1,\n+                       XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, XMMRegister xtmp5,\n+                       Register rtmp, KRegister ktmp1, KRegister ktmp2, int vlen_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1851,4 +1851,0 @@\n-      } else if (bt == T_BYTE && size_in_bits > 256 && !VM_Version::supports_avx512_vbmi())  {\n-        return false; \/\/ Implementation limitation\n-      } else if (bt == T_SHORT && size_in_bits > 256 && !VM_Version::supports_avx512bw())  {\n-        return false; \/\/ Implementation limitation\n@@ -8532,1 +8528,17 @@\n-instruct rearrangeB_evex(vec dst, vec src, vec shuffle) %{\n+\n+instruct rearrangeB_evex(vec dst, vec src, vec shuffle, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, vec xtmp5, kReg ktmp1, kReg ktmp2, rRegI rtmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE &&\n+            Matcher::vector_length(n) > 32 && !VM_Version::supports_avx512_vbmi());\n+  match(Set dst (VectorRearrange src shuffle));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP xtmp4, TEMP xtmp5, TEMP ktmp1, TEMP ktmp2, TEMP rtmp);\n+  format %{ \"vector_rearrange $dst, $shuffle, $src!\\t using $xtmp1, $xtmp2, $xtmp3, $xtmp4, $xtmp5, $rtmp, $ktmp1, and $ktmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ rearrange_bytes($dst$$XMMRegister, $shuffle$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister, $xtmp5$$XMMRegister,\n+                       $rtmp$$Register, $ktmp1$$KRegister, $ktmp2$$KRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct rearrangeB_evex_vbmi(vec dst, vec src, vec shuffle) %{\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class RearrangeBytesBenchmark {\n+    @Param({\"256\", \"512\", \"1024\"})\n+    int size;\n+\n+    int [][] shuffles;\n+    byte[] byteinp;\n+    byte[] byteres;\n+\n+    static final VectorSpecies<Byte> bspecies64 = ByteVector.SPECIES_64;\n+    static final VectorSpecies<Byte> bspecies128 = ByteVector.SPECIES_128;\n+    static final VectorSpecies<Byte> bspecies256 = ByteVector.SPECIES_256;\n+    static final VectorSpecies<Byte> bspecies512 = ByteVector.SPECIES_512;\n+\n+    static final byte[] specialvalsbyte = {0, -0, Byte.MIN_VALUE, Byte.MAX_VALUE};\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        Random r = new Random(1024);\n+        int [] bits = {64, 128, 256, 512};\n+        byteinp = new byte[size];\n+        byteres = new byte[size];\n+\n+        for (int i = 4; i < size; i++) {\n+            byteinp[i] = (byte)i;\n+        }\n+        for (int i = 0; i < specialvalsbyte.length; i++) {\n+            byteinp[i] = specialvalsbyte[i];\n+        }\n+\n+        shuffles = new int[4][];\n+        for (int i = 0; i < bits.length; i++) {\n+           int bytes = bits[i] >> 3;\n+           shuffles[i] = new int[bytes];\n+           for (int j = 0; j < bytes ; j++) {\n+              shuffles[i][j] = r.nextInt(bytes - 1);\n+           }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testRearrangeBytes64() {\n+        VectorShuffle<Byte> shuffle = VectorShuffle.fromArray(bspecies512, shuffles[3], 0);\n+        for (int j = 0; j < bspecies512.loopBound(size); j += bspecies512.length()) {\n+            ByteVector.fromArray(bspecies512, byteinp, j)\n+                .rearrange(shuffle)\n+                .intoArray(byteres, j);\n+        }\n+    }\n+    @Benchmark\n+    public void testRearrangeBytes32() {\n+        VectorShuffle<Byte> shuffle = VectorShuffle.fromArray(bspecies256, shuffles[2], 0);\n+        for (int j = 0; j < bspecies256.loopBound(size); j += bspecies256.length()) {\n+            ByteVector.fromArray(bspecies256, byteinp, j)\n+                .rearrange(shuffle)\n+                .intoArray(byteres, j);\n+        }\n+    }\n+    @Benchmark\n+    public void testRearrangeBytes16() {\n+        VectorShuffle<Byte> shuffle = VectorShuffle.fromArray(bspecies128, shuffles[1], 0);\n+        for (int j = 0; j < bspecies128.loopBound(size); j += bspecies128.length()) {\n+            ByteVector.fromArray(bspecies128, byteinp, j)\n+                .rearrange(shuffle)\n+                .intoArray(byteres, j);\n+        }\n+    }\n+    @Benchmark\n+    public void testRearrangeBytes8() {\n+        VectorShuffle<Byte> shuffle = VectorShuffle.fromArray(bspecies64, shuffles[0], 0);\n+        for (int j = 0; j < bspecies64.loopBound(size); j += bspecies64.length()) {\n+            ByteVector.fromArray(bspecies64, byteinp, j)\n+                .rearrange(shuffle)\n+                .intoArray(byteres, j);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/RearrangeBytesBenchmark.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"}]}