{"files":[{"patch":"@@ -36,8 +36,16 @@\n-  \/\/ We always attempt to reserve < 4GB:\n-  \/\/ - without CDS, this means we can use zero-based encoding\n-  \/\/ - even with CDS (which disallows zero-based encoding), this allows us to use shorter imm32 movs when loading the base\n-  result = reserve_address_space_X(0, nth_bit(32), size, Metaspace::reserve_alignment(), aslr);\n-\n-  if (result == 0 && optimize_for_zero_base) {\n-    \/\/ Failing that, if we are running without CDS, attempt to allocate below 32G. This allows us to use zero-based encoding\n-    \/\/ with a non-zero shift.\n+  assert(CompressedKlassPointers::narrow_klass_pointer_bits() == 32 ||\n+         CompressedKlassPointers::narrow_klass_pointer_bits() == 22, \"Rethink if we ever use different nKlass bit sizes\");\n+\n+  \/\/ Unconditionally attempting to reserve in lower 4G first makes always sense:\n+  \/\/ -CDS -COH: try to get unscaled mode (zero base zero shift)\n+  \/\/ +CDS -COH: No zero base possible (CDS prevents it); but we still benefit from small base pointers (imm32 movabs)\n+  \/\/ -CDS +COH: No zero base possible (22bit nKlass + zero base zero shift = 4MB encoding range, way too small);\n+  \/\/            but we still benefit from small base pointers (imm32 movabs)\n+  \/\/ +CDS +COH: No zero base possible for multiple reasons (CDS prevents it and encoding range too small);\n+  \/\/            but we still benefit from small base pointers (imm32 movabs)\n+\n+  result = reserve_address_space_below_4G(size, aslr);\n+\n+  if (result == nullptr && optimize_for_zero_base) {\n+    \/\/ Failing that, if we are running without CDS, attempt to allocate below 32G.\n+    \/\/ This allows us to use zero-based encoding with a non-zero shift.\n","filename":"src\/hotspot\/cpu\/x86\/compressedKlass_x86.cpp","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -5405,0 +5405,1 @@\n+  BLOCK_COMMENT(\"encode_klass_not_null {\");\n@@ -5410,1 +5411,1 @@\n-      mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+      movptr(tmp, (intptr_t)CompressedKlassPointers::base());\n@@ -5417,0 +5418,1 @@\n+  BLOCK_COMMENT(\"} encode_and_move_klass_not_null\");\n@@ -5420,0 +5422,1 @@\n+  BLOCK_COMMENT(\"encode_and_move_klass_not_null {\");\n@@ -5422,1 +5425,1 @@\n-    mov64(dst, -(int64_t)CompressedKlassPointers::base());\n+    movptr(dst, -(intptr_t)CompressedKlassPointers::base());\n@@ -5430,0 +5433,1 @@\n+  BLOCK_COMMENT(\"} encode_and_move_klass_not_null\");\n@@ -5433,1 +5437,1 @@\n-  BLOCK_COMMENT(\"decode_klass_not_null\");\n+  BLOCK_COMMENT(\"decode_klass_not_null {\");\n@@ -5444,1 +5448,0 @@\n-    \/\/ Note: we use movptr to uses a 32-bit mov if the base is small enough\n@@ -5452,0 +5455,1 @@\n+  BLOCK_COMMENT(\"} decode_klass_not_null\");\n@@ -5455,0 +5459,1 @@\n+  BLOCK_COMMENT(\"decode_and_move_klass_not_null {\");\n@@ -5470,1 +5475,0 @@\n-        \/\/ Uses 32-bit mov if base is small enough\n@@ -5485,1 +5489,0 @@\n-        \/\/ Uses 32-bit mov if base is small enough\n@@ -5494,0 +5497,1 @@\n+  BLOCK_COMMENT(\"} decode_and_move_klass_not_null\");\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -189,0 +189,4 @@\n+char* CompressedKlassPointers::reserve_address_space_below_4G(size_t size, bool aslr) {\n+  return reserve_address_space_X(0, nth_bit(32), size, Metaspace::reserve_alignment(), aslr);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+  static char* reserve_address_space_below_4G(size_t size, bool aslr);\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Red Hat. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +67,1 @@\n+        final String tryReserveBelow4G = \"reserve_between (range [0x0000000000000000-0x0000000100000000)\";\n@@ -101,0 +103,1 @@\n+            output.shouldContain(tryReserveBelow4G);\n@@ -102,2 +105,0 @@\n-                \/\/ We always try to allocate below 4 GB.\n-                output.shouldContain(\"reserve_between (range [0x0000000000000000-0x0000000100000000)\");\n@@ -106,1 +107,0 @@\n-                output.shouldContain(tryReserveForUnscaled);\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedCPUSpecificClassSpaceReservation.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}