{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, 2025, Red Hat, Inc. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"memory\/metaspace.hpp\"\n@@ -35,7 +36,18 @@\n-  \/\/ Optimize for unscaled encoding; failing that, for zero-based encoding:\n-  if (optimize_for_zero_base) {\n-    result = reserve_address_space_for_unscaled_encoding(size, aslr);\n-    if (result == nullptr) {\n-      result = reserve_address_space_for_zerobased_encoding(size, aslr);\n-    }\n-  } \/\/ end: low-address reservation\n+  assert(CompressedKlassPointers::narrow_klass_pointer_bits() == 32 ||\n+         CompressedKlassPointers::narrow_klass_pointer_bits() == 22, \"Rethink if we ever use different nKlass bit sizes\");\n+\n+  \/\/ Unconditionally attempting to reserve in lower 4G first makes always sense:\n+  \/\/ -CDS -COH: try to get unscaled mode (zero base zero shift)\n+  \/\/ +CDS -COH: No zero base possible (CDS prevents it); but we still benefit from small base pointers (imm32 movabs)\n+  \/\/ -CDS +COH: No zero base possible (22bit nKlass + zero base zero shift = 4MB encoding range, way too small);\n+  \/\/            but we still benefit from small base pointers (imm32 movabs)\n+  \/\/ +CDS +COH: No zero base possible for multiple reasons (CDS prevents it and encoding range too small);\n+  \/\/            but we still benefit from small base pointers (imm32 movabs)\n+\n+  result = reserve_address_space_below_4G(size, aslr);\n+\n+  if (result == nullptr && optimize_for_zero_base) {\n+    \/\/ Failing that, if we are running without CDS, attempt to allocate below 32G.\n+    \/\/ This allows us to use zero-based encoding with a non-zero shift.\n+    result = reserve_address_space_for_zerobased_encoding(size, aslr);\n+  }\n@@ -43,1 +55,0 @@\n-  \/\/ Nothing more to optimize for on x64. If base != 0, we will always emit the full 64-bit immediate.\n","filename":"src\/hotspot\/cpu\/x86\/compressedKlass_x86.cpp","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -5405,0 +5405,1 @@\n+  BLOCK_COMMENT(\"encode_klass_not_null {\");\n@@ -5410,1 +5411,1 @@\n-      mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+      movptr(tmp, (intptr_t)CompressedKlassPointers::base());\n@@ -5417,0 +5418,1 @@\n+  BLOCK_COMMENT(\"} encode_and_move_klass_not_null\");\n@@ -5420,0 +5422,1 @@\n+  BLOCK_COMMENT(\"encode_and_move_klass_not_null {\");\n@@ -5422,1 +5425,1 @@\n-    mov64(dst, -(int64_t)CompressedKlassPointers::base());\n+    movptr(dst, -(intptr_t)CompressedKlassPointers::base());\n@@ -5430,0 +5433,1 @@\n+  BLOCK_COMMENT(\"} encode_and_move_klass_not_null\");\n@@ -5433,0 +5437,1 @@\n+  BLOCK_COMMENT(\"decode_klass_not_null {\");\n@@ -5446,1 +5451,1 @@\n-      mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+      movptr(tmp, (intptr_t)CompressedKlassPointers::base());\n@@ -5450,0 +5455,1 @@\n+  BLOCK_COMMENT(\"} decode_klass_not_null\");\n@@ -5453,0 +5459,1 @@\n+  BLOCK_COMMENT(\"decode_and_move_klass_not_null {\");\n@@ -5468,1 +5475,1 @@\n-        mov64(dst, (int64_t)CompressedKlassPointers::base());\n+        movptr(dst, (intptr_t)CompressedKlassPointers::base());\n@@ -5480,3 +5487,3 @@\n-        const uint64_t base_right_shifted =\n-            (uint64_t)CompressedKlassPointers::base() >> CompressedKlassPointers::shift();\n-        mov64(dst, base_right_shifted);\n+        const intptr_t base_right_shifted =\n+            (intptr_t)CompressedKlassPointers::base() >> CompressedKlassPointers::shift();\n+        movptr(dst, base_right_shifted);\n@@ -5490,0 +5497,1 @@\n+  BLOCK_COMMENT(\"} decode_and_move_klass_not_null\");\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -189,0 +189,4 @@\n+char* CompressedKlassPointers::reserve_address_space_below_4G(size_t size, bool aslr) {\n+  return reserve_address_space_X(0, nth_bit(32), size, Metaspace::reserve_alignment(), aslr);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+  static char* reserve_address_space_below_4G(size_t size, bool aslr);\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Red Hat. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +67,1 @@\n+        final String tryReserveBelow4G = \"reserve_between (range [0x0000000000000000-0x0000000100000000)\";\n@@ -101,0 +103,1 @@\n+            output.shouldContain(tryReserveBelow4G);\n@@ -102,1 +105,0 @@\n-                output.shouldNotContain(tryReserveForUnscaled);\n@@ -105,1 +107,0 @@\n-                output.shouldContain(tryReserveForUnscaled);\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedCPUSpecificClassSpaceReservation.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}