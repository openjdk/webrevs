{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, 2025, Red Hat, Inc. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"memory\/metaspace.hpp\"\n@@ -35,7 +36,10 @@\n-  \/\/ Optimize for unscaled encoding; failing that, for zero-based encoding:\n-  if (optimize_for_zero_base) {\n-    result = reserve_address_space_for_unscaled_encoding(size, aslr);\n-    if (result == nullptr) {\n-      result = reserve_address_space_for_zerobased_encoding(size, aslr);\n-    }\n-  } \/\/ end: low-address reservation\n+  \/\/ We always attempt to reserve < 4GB:\n+  \/\/ - without CDS, this means we can use zero-based encoding\n+  \/\/ - even with CDS (which disallows zero-based encoding), this allows us to use shorter imm32 movs when loading the base\n+  result = reserve_address_space_X(0, nth_bit(32), size, Metaspace::reserve_alignment(), aslr);\n+\n+  if (result == 0 && optimize_for_zero_base) {\n+    \/\/ Failing that, if we are running without CDS, attempt to allocate below 32G. This allows us to use zero-based encoding\n+    \/\/ with a non-zero shift.\n+    result = reserve_address_space_for_zerobased_encoding(size, aslr);\n+  }\n@@ -43,1 +47,0 @@\n-  \/\/ Nothing more to optimize for on x64. If base != 0, we will always emit the full 64-bit immediate.\n","filename":"src\/hotspot\/cpu\/x86\/compressedKlass_x86.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -5433,0 +5433,1 @@\n+  BLOCK_COMMENT(\"decode_klass_not_null\");\n@@ -5443,0 +5444,1 @@\n+    \/\/ Note: we use movptr to uses a 32-bit mov if the base is small enough\n@@ -5446,1 +5448,1 @@\n-      mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+      movptr(tmp, (intptr_t)CompressedKlassPointers::base());\n@@ -5468,1 +5470,2 @@\n-        mov64(dst, (int64_t)CompressedKlassPointers::base());\n+        \/\/ Uses 32-bit mov if base is small enough\n+        movptr(dst, (intptr_t)CompressedKlassPointers::base());\n@@ -5482,1 +5485,2 @@\n-        mov64(dst, base_right_shifted);\n+        \/\/ Uses 32-bit mov if base is small enough\n+        movptr(dst, (intptr_t)CompressedKlassPointers::base());\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -102,1 +102,2 @@\n-                output.shouldNotContain(tryReserveForUnscaled);\n+                \/\/ We always try to allocate below 4 GB.\n+                output.shouldContain(\"reserve_between (range [0x0000000000000000-0x0000000100000000)\");\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedCPUSpecificClassSpaceReservation.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}