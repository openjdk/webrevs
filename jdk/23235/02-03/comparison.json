{"files":[{"patch":"@@ -546,2 +546,3 @@\n-  \/\/ Find stores and allocations, and track them in lists.\n-  Node_List stores;\n+  \/\/ Find allocations and memory accesses (stores and atomic operations), and\n+  \/\/ track them in lists.\n+  Node_List accesses;\n@@ -566,0 +567,6 @@\n+      case Op_CompareAndExchangeP:\n+      case Op_CompareAndSwapP:\n+      case Op_GetAndSetP:\n+      case Op_CompareAndExchangeN:\n+      case Op_CompareAndSwapN:\n+      case Op_GetAndSetN:\n@@ -567,1 +574,1 @@\n-          stores.push(mach);\n+          accesses.push(mach);\n@@ -576,3 +583,3 @@\n-  \/\/ Find dominating allocations for each store and elide barriers if there is\n-  \/\/ no safepoint poll in between.\n-  elide_dominated_barriers(stores, allocations);\n+  \/\/ Find dominating allocations for each memory access (store or atomic\n+  \/\/ operation) and elide barriers if there is no safepoint poll in between.\n+  elide_dominated_barriers(accesses, allocations);\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -740,0 +740,115 @@\n+    @Test\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_COMPARE_AND_EXCHANGE_P_WITH_BARRIER_FLAG, POST_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_COMPARE_AND_EXCHANGE_N_WITH_BARRIER_FLAG, POST_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_COMPARE_AND_EXCHANGE_P_WITH_BARRIER_FLAG, ANY},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_COMPARE_AND_EXCHANGE_N_WITH_BARRIER_FLAG, ANY},\n+        phase = CompilePhase.FINAL_CODE)\n+    static Object testCompareAndExchangeOnNewObject(Object oldVal, Object newVal) {\n+        Outer o = new Outer();\n+        o.f = oldVal;\n+        return fVarHandle.compareAndExchange(o, oldVal, newVal);\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_COMPARE_AND_SWAP_P_WITH_BARRIER_FLAG, POST_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_COMPARE_AND_SWAP_N_WITH_BARRIER_FLAG, POST_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_COMPARE_AND_SWAP_P_WITH_BARRIER_FLAG, ANY},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_COMPARE_AND_SWAP_N_WITH_BARRIER_FLAG, ANY},\n+        phase = CompilePhase.FINAL_CODE)\n+    static boolean testCompareAndSwapOnNewObject(Object oldVal, Object newVal) {\n+        Outer o = new Outer();\n+        o.f = oldVal;\n+        return fVarHandle.compareAndSet(o, oldVal, newVal);\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_GET_AND_SET_P_WITH_BARRIER_FLAG, POST_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_GET_AND_SET_N_WITH_BARRIER_FLAG, POST_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_GET_AND_SET_P_WITH_BARRIER_FLAG, ANY},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_GET_AND_SET_N_WITH_BARRIER_FLAG, ANY},\n+        phase = CompilePhase.FINAL_CODE)\n+    static Object testGetAndSetOnNewObject(Object oldVal, Object newVal) {\n+        Outer o = new Outer();\n+        o.f = oldVal;\n+        return fVarHandle.getAndSet(o, newVal);\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_GET_AND_SET_P_WITH_BARRIER_FLAG, POST_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_GET_AND_SET_N_WITH_BARRIER_FLAG, POST_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_GET_AND_SET_P_WITH_BARRIER_FLAG, ANY},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_GET_AND_SET_N_WITH_BARRIER_FLAG, ANY},\n+        phase = CompilePhase.FINAL_CODE)\n+    static Object testGetAndSetConditionallyOnNewObject(Object oldVal, Object newVal, boolean c) {\n+        Outer o = new Outer();\n+        o.f = oldVal;\n+        if (c) {\n+            return fVarHandle.getAndSet(o, newVal);\n+        }\n+        return oldVal;\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_GET_AND_SET_P_WITH_BARRIER_FLAG, POST_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"false\"},\n+        counts = {IRNode.G1_GET_AND_SET_N_WITH_BARRIER_FLAG, POST_ONLY, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"false\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_GET_AND_SET_P_WITH_BARRIER_FLAG, ANY},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIfAnd = {\"UseCompressedOops\", \"true\", \"ReduceInitialCardMarks\", \"true\"},\n+        failOn = {IRNode.G1_GET_AND_SET_N_WITH_BARRIER_FLAG, ANY},\n+        phase = CompilePhase.FINAL_CODE)\n+    static Object testGetAndSetOnNewObjectAfterException(Object oldVal, Object newVal, boolean c) throws Exception {\n+        Outer o = new Outer();\n+        if (c) {\n+            throw new Exception(\"\");\n+        }\n+        o.f = oldVal;\n+        return fVarHandle.getAndSet(o, newVal);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseCompressedOops\", \"false\"},\n+        counts = {IRNode.G1_GET_AND_SET_P_WITH_BARRIER_FLAG, PRE_AND_POST, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(applyIf = {\"UseCompressedOops\", \"true\"},\n+        counts = {IRNode.G1_GET_AND_SET_N_WITH_BARRIER_FLAG, PRE_AND_POST, \"1\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    static Object testGetAndSetOnNewObjectAfterCall(Object oldVal, Object newVal) {\n+        Outer o = new Outer();\n+        nonInlinedMethod();\n+        o.f = oldVal;\n+        return fVarHandle.getAndSet(o, newVal);\n+    }\n+\n@@ -742,1 +857,7 @@\n-                 \"testGetAndSet\"})\n+                 \"testGetAndSet\",\n+                 \"testCompareAndExchangeOnNewObject\",\n+                 \"testCompareAndSwapOnNewObject\",\n+                 \"testGetAndSetOnNewObject\",\n+                 \"testGetAndSetConditionallyOnNewObject\",\n+                 \"testGetAndSetOnNewObjectAfterException\",\n+                 \"testGetAndSetOnNewObjectAfterCall\"})\n@@ -771,0 +892,39 @@\n+        {\n+            Object oldVal = new Object();\n+            Object newVal = new Object();\n+            Object oldVal2 = testCompareAndExchangeOnNewObject(oldVal, newVal);\n+            Asserts.assertEquals(oldVal, oldVal2);\n+        }\n+        {\n+            Object oldVal = new Object();\n+            Object newVal = new Object();\n+            boolean b = testCompareAndSwapOnNewObject(oldVal, newVal);\n+            Asserts.assertTrue(b);\n+        }\n+        {\n+            Object oldVal = new Object();\n+            Object newVal = new Object();\n+            Object oldVal2 = testGetAndSetOnNewObject(oldVal, newVal);\n+            Asserts.assertEquals(oldVal, oldVal2);\n+        }\n+        {\n+            Object oldVal = new Object();\n+            Object newVal = new Object();\n+            boolean c = ThreadLocalRandom.current().nextBoolean();\n+            Object oldVal2 = testGetAndSetConditionallyOnNewObject(oldVal, newVal, c);\n+            Asserts.assertEquals(oldVal, oldVal2);\n+        }\n+        {\n+            Object oldVal = new Object();\n+            Object newVal = new Object();\n+            boolean c = ThreadLocalRandom.current().nextBoolean();\n+            try {\n+                Object oldVal2 = testGetAndSetOnNewObjectAfterException(oldVal, newVal, c);\n+            } catch (Exception e) {}\n+        }\n+        {\n+            Object oldVal = new Object();\n+            Object newVal = new Object();\n+            Object oldVal2 = testGetAndSetOnNewObjectAfterCall(oldVal, newVal);\n+            Asserts.assertEquals(oldVal, oldVal2);\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestG1BarrierGeneration.java","additions":161,"deletions":1,"binary":false,"changes":162,"status":"modified"}]}