{"files":[{"patch":"@@ -108,0 +108,1 @@\n+\/\/ This method determines whether we run the verifier and class file format checking code.\n@@ -113,0 +114,1 @@\n+\/\/ This method determines whether we allow package access in access checks in reflection.\n@@ -123,0 +125,15 @@\n+\/\/ Callers will pass should_verify_class as true, depending on the results of should_verify_for() above,\n+\/\/ or pass true for redefinition of any class.\n+static bool is_eligible_for_verification(InstanceKlass* klass, bool should_verify_class) {\n+  Symbol* name = klass->name();\n+\n+  return (should_verify_class &&\n+    \/\/ Can not verify the bytecodes for shared classes because they have\n+    \/\/ already been rewritten to contain constant pool cache indices,\n+    \/\/ which the verifier can't understand.\n+    \/\/ Shared classes shouldn't have stackmaps either.\n+    \/\/ However, bytecodes for shared old classes can be verified because\n+    \/\/ they have not been rewritten.\n+    !(klass->is_shared() && klass->is_rewritten()));\n+}\n+\n@@ -276,21 +293,0 @@\n-bool Verifier::is_eligible_for_verification(InstanceKlass* klass, bool should_verify_class) {\n-  Symbol* name = klass->name();\n-\n-  return (should_verify_class &&\n-    \/\/ return if the class is a bootstrapping class\n-    \/\/ or defineClass specified not to verify by default (flags override passed arg)\n-    \/\/ We need to skip the following four for bootstraping\n-    name != vmSymbols::java_lang_Object() &&\n-    name != vmSymbols::java_lang_Class() &&\n-    name != vmSymbols::java_lang_String() &&\n-    name != vmSymbols::java_lang_Throwable() &&\n-\n-    \/\/ Can not verify the bytecodes for shared classes because they have\n-    \/\/ already been rewritten to contain constant pool cache indices,\n-    \/\/ which the verifier can't understand.\n-    \/\/ Shared classes shouldn't have stackmaps either.\n-    \/\/ However, bytecodes for shared old classes can be verified because\n-    \/\/ they have not been rewritten.\n-    !(klass->is_shared() && klass->is_rewritten()));\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-  static bool is_eligible_for_verification(InstanceKlass* klass, bool should_verify_class);\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -338,1 +338,2 @@\n-  return (bci == 0 || bci < code_size()) ? bci : -1;\n+  \/\/ Called from the verifier, and should return -1 if not valid.\n+  return ((is_native() && bci == 0) || (!is_native() && 0 <= bci && bci < code_size())) ? bci : -1;\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6402717 8330606\n+ * @summary Redefine VerifyError to get a VerifyError should not throw SOE\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.org.objectweb.asm\n+ *          java.compiler\n+ *          java.instrument\n+ *          jdk.jartool\/sun.tools.jar\n+ * @run main RedefineClassHelper\n+ * @run main\/othervm\/timeout=180\n+ *         -javaagent:redefineagent.jar\n+ *         -Xlog:class+init,exceptions\n+ *         RedefineVerifyError\n+ *\/\n+\n+import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n+import jdk.internal.org.objectweb.asm.Attribute;\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.ConstantDynamic;\n+import jdk.internal.org.objectweb.asm.FieldVisitor;\n+import jdk.internal.org.objectweb.asm.Handle;\n+import jdk.internal.org.objectweb.asm.Label;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.RecordComponentVisitor;\n+import jdk.internal.org.objectweb.asm.Type;\n+import jdk.internal.org.objectweb.asm.TypePath;\n+\n+public class RedefineVerifyError implements Opcodes {\n+\n+    \/\/ This is a redefinition of java.lang.VerifyError with two broken init methods (no bytecodes)\n+    public static byte[] dump () throws Exception {\n+\n+        ClassWriter classWriter = new ClassWriter(0);\n+        FieldVisitor fieldVisitor;\n+        RecordComponentVisitor recordComponentVisitor;\n+        MethodVisitor methodVisitor;\n+        AnnotationVisitor annotationVisitor0;\n+\n+        classWriter.visit(52, ACC_SUPER | ACC_PUBLIC, \"java\/lang\/VerifyError\", null, \"java\/lang\/LinkageError\", null);\n+        {\n+            fieldVisitor = classWriter.visitField(ACC_PRIVATE | ACC_FINAL | ACC_STATIC, \"serialVersionUID\", \"J\", null, new Long(7001962396098498785L));\n+            fieldVisitor.visitEnd();\n+        }\n+        {\n+            methodVisitor = classWriter.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n+            methodVisitor.visitCode();\n+            methodVisitor.visitEnd();\n+        }\n+\n+        {\n+            methodVisitor = classWriter.visitMethod(ACC_PUBLIC, \"<init>\", \"(Ljava\/lang\/String;)V\", null, null);\n+            methodVisitor.visitCode();\n+            classWriter.visitEnd();\n+        }\n+\n+        return classWriter.toByteArray();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        Class<?> verifyErrorMirror = java.lang.VerifyError.class;\n+\n+        try {\n+            \/\/ The Verifier is called for the redefinition, which will fail because of the broken <init> method above.\n+            RedefineClassHelper.redefineClass(verifyErrorMirror, dump());\n+            throw new RuntimeException(\"This should throw VerifyError\");\n+        } catch (VerifyError e) {\n+            \/\/ JVMTI recreates the VerifyError so the verification message is lost.\n+            System.out.println(\"Passed\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineVerifyError.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"}]}