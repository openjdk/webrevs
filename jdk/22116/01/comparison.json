{"files":[{"patch":"@@ -108,0 +108,1 @@\n+\/\/ This method determines whether we run the verifier and class file format checking code.\n@@ -113,0 +114,1 @@\n+\/\/ This method determines whether we allow package access in access checks in reflection.\n@@ -280,8 +282,0 @@\n-    \/\/ return if the class is a bootstrapping class\n-    \/\/ or defineClass specified not to verify by default (flags override passed arg)\n-    \/\/ We need to skip the following four for bootstraping\n-    name != vmSymbols::java_lang_Object() &&\n-    name != vmSymbols::java_lang_Class() &&\n-    name != vmSymbols::java_lang_String() &&\n-    name != vmSymbols::java_lang_Throwable() &&\n-\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6402717 8330606\n+ * @summary Redefine VerifyError to get a VerifyError should not throw SOE\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.org.objectweb.asm\n+ *          java.compiler\n+ *          java.instrument\n+ *          jdk.jartool\/sun.tools.jar\n+ * @run main RedefineClassHelper\n+ * @run main\/othervm\/timeout=180\n+ *         -javaagent:redefineagent.jar\n+ *         -Xlog:class+init,exceptions\n+ *         RedefineVerifyError\n+ *\/\n+\n+import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n+import jdk.internal.org.objectweb.asm.Attribute;\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.ConstantDynamic;\n+import jdk.internal.org.objectweb.asm.FieldVisitor;\n+import jdk.internal.org.objectweb.asm.Handle;\n+import jdk.internal.org.objectweb.asm.Label;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.RecordComponentVisitor;\n+import jdk.internal.org.objectweb.asm.Type;\n+import jdk.internal.org.objectweb.asm.TypePath;\n+\n+public class RedefineVerifyError implements Opcodes {\n+\n+    public static byte[] dump () throws Exception {\n+\n+        ClassWriter classWriter = new ClassWriter(0);\n+        FieldVisitor fieldVisitor;\n+        RecordComponentVisitor recordComponentVisitor;\n+        MethodVisitor methodVisitor;\n+        AnnotationVisitor annotationVisitor0;\n+\n+        classWriter.visit(52, ACC_SUPER | ACC_PUBLIC, \"java\/lang\/VerifyError\", null, \"java\/lang\/LinkageError\", null);\n+        {\n+            fieldVisitor = classWriter.visitField(ACC_PRIVATE | ACC_FINAL | ACC_STATIC, \"serialVersionUID\", \"J\", null, new Long(7001962396098498785L));\n+            fieldVisitor.visitEnd();\n+        }\n+        {\n+            methodVisitor = classWriter.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n+            methodVisitor.visitCode();\n+            Label label0 = new Label();\n+            methodVisitor.visitLabel(label0);\n+            methodVisitor.visitLineNumber(43, label0);\n+            methodVisitor.visitVarInsn(ALOAD, 0);\n+            methodVisitor.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/LinkageError\", \"<init>\", \"()V\", false);\n+            Label label1 = new Label();\n+            methodVisitor.visitLabel(label1);\n+            methodVisitor.visitLineNumber(44, label1);\n+            methodVisitor.visitInsn(RETURN);\n+            Label label2 = new Label();\n+            methodVisitor.visitLabel(label2);\n+            methodVisitor.visitLocalVariable(\"this\", \"Ljava\/lang\/VerifyError;\", null, label0, label2, 0);\n+            methodVisitor.visitMaxs(1, 1);\n+            methodVisitor.visitEnd();\n+        }\n+\n+        {   \/\/ broken method\n+            methodVisitor = classWriter.visitMethod(ACC_PUBLIC, \"<init>\", \"(Ljava\/lang\/String;)V\", null, null);\n+            methodVisitor.visitCode();\n+            Label label0 = new Label();\n+            Label label1 = new Label();\n+            Label label2 = new Label();\n+            methodVisitor.visitTryCatchBlock(label0, label1, label2, \"java\/lang\/Exception\");\n+            methodVisitor.visitLabel(label0);\n+            methodVisitor.visitVarInsn(ALOAD, 0);\n+            methodVisitor.visitVarInsn(ALOAD, 1);\n+            methodVisitor.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/LinkageError\", \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n+            methodVisitor.visitLabel(label1);\n+            Label label3 = new Label();\n+            methodVisitor.visitJumpInsn(GOTO, label3);\n+            methodVisitor.visitLabel(label2);\n+            methodVisitor.visitFrame(Opcodes.F_FULL, 2, new Object[] {\"MyError\", \"java\/lang\/String\"}, 1, new Object[] {\"java\/lang\/Exception\"});\n+            methodVisitor.visitVarInsn(ASTORE, 2);\n+            methodVisitor.visitLabel(label3);\n+            \/\/ Missing stackmap frame makes rededefine classes throw VerifyError\n+            \/\/ methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n+            methodVisitor.visitInsn(RETURN);\n+            methodVisitor.visitMaxs(2, 3);\n+            methodVisitor.visitEnd();\n+            classWriter.visitEnd();\n+        }\n+\n+        return classWriter.toByteArray();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        Class<?> verifyErrorMirror = java.lang.VerifyError.class;\n+\n+        try {\n+            \/\/ The Verifier is called for the redefinition, which will fail because of the broken <init> method above.\n+            RedefineClassHelper.redefineClass(verifyErrorMirror, dump());\n+            throw new RuntimeException(\"This should throw VerifyError\");\n+        } catch (VerifyError e) {\n+            System.out.println(\"Passed\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineVerifyError.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"}]}