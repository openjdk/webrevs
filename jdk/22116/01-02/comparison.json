{"files":[{"patch":"@@ -125,0 +125,15 @@\n+\/\/ Callers will pass should_verify_class as true, depending on the results of should_verify_for() above,\n+\/\/ or pass true for redefinition of any class.\n+static bool is_eligible_for_verification(InstanceKlass* klass, bool should_verify_class) {\n+  Symbol* name = klass->name();\n+\n+  return (should_verify_class &&\n+    \/\/ Can not verify the bytecodes for shared classes because they have\n+    \/\/ already been rewritten to contain constant pool cache indices,\n+    \/\/ which the verifier can't understand.\n+    \/\/ Shared classes shouldn't have stackmaps either.\n+    \/\/ However, bytecodes for shared old classes can be verified because\n+    \/\/ they have not been rewritten.\n+    !(klass->is_shared() && klass->is_rewritten()));\n+}\n+\n@@ -278,13 +293,0 @@\n-bool Verifier::is_eligible_for_verification(InstanceKlass* klass, bool should_verify_class) {\n-  Symbol* name = klass->name();\n-\n-  return (should_verify_class &&\n-    \/\/ Can not verify the bytecodes for shared classes because they have\n-    \/\/ already been rewritten to contain constant pool cache indices,\n-    \/\/ which the verifier can't understand.\n-    \/\/ Shared classes shouldn't have stackmaps either.\n-    \/\/ However, bytecodes for shared old classes can be verified because\n-    \/\/ they have not been rewritten.\n-    !(klass->is_shared() && klass->is_rewritten()));\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-  static bool is_eligible_for_verification(InstanceKlass* klass, bool should_verify_class);\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -338,1 +338,2 @@\n-  return (bci == 0 || bci < code_size()) ? bci : -1;\n+  \/\/ Called from the verifier, and should return -1 if not valid.\n+  return ((is_native() && bci == 0) || (!is_native() && 0 <= bci && bci < code_size())) ? bci : -1;\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+    \/\/ This is a redefinition of java.lang.VerifyError with two broken init methods (no bytecodes)\n@@ -74,13 +75,0 @@\n-            Label label0 = new Label();\n-            methodVisitor.visitLabel(label0);\n-            methodVisitor.visitLineNumber(43, label0);\n-            methodVisitor.visitVarInsn(ALOAD, 0);\n-            methodVisitor.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/LinkageError\", \"<init>\", \"()V\", false);\n-            Label label1 = new Label();\n-            methodVisitor.visitLabel(label1);\n-            methodVisitor.visitLineNumber(44, label1);\n-            methodVisitor.visitInsn(RETURN);\n-            Label label2 = new Label();\n-            methodVisitor.visitLabel(label2);\n-            methodVisitor.visitLocalVariable(\"this\", \"Ljava\/lang\/VerifyError;\", null, label0, label2, 0);\n-            methodVisitor.visitMaxs(1, 1);\n@@ -90,1 +78,1 @@\n-        {   \/\/ broken method\n+        {\n@@ -93,20 +81,0 @@\n-            Label label0 = new Label();\n-            Label label1 = new Label();\n-            Label label2 = new Label();\n-            methodVisitor.visitTryCatchBlock(label0, label1, label2, \"java\/lang\/Exception\");\n-            methodVisitor.visitLabel(label0);\n-            methodVisitor.visitVarInsn(ALOAD, 0);\n-            methodVisitor.visitVarInsn(ALOAD, 1);\n-            methodVisitor.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/LinkageError\", \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-            methodVisitor.visitLabel(label1);\n-            Label label3 = new Label();\n-            methodVisitor.visitJumpInsn(GOTO, label3);\n-            methodVisitor.visitLabel(label2);\n-            methodVisitor.visitFrame(Opcodes.F_FULL, 2, new Object[] {\"MyError\", \"java\/lang\/String\"}, 1, new Object[] {\"java\/lang\/Exception\"});\n-            methodVisitor.visitVarInsn(ASTORE, 2);\n-            methodVisitor.visitLabel(label3);\n-            \/\/ Missing stackmap frame makes rededefine classes throw VerifyError\n-            \/\/ methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-            methodVisitor.visitInsn(RETURN);\n-            methodVisitor.visitMaxs(2, 3);\n-            methodVisitor.visitEnd();\n@@ -128,0 +96,1 @@\n+            \/\/ JVMTI recreates the VerifyError so the verification message is lost.\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineVerifyError.java","additions":3,"deletions":34,"binary":false,"changes":37,"status":"modified"}]}