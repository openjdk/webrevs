{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -35,0 +36,1 @@\n+import java.util.Objects;\n@@ -48,2 +50,2 @@\n-     * {@return a new Arena that tries to provided {@code size} and {@code byteAlignment}\n-     * allocations by recycling the BufferStacks internal memory}\n+     * {@return a new Arena that tries to provide {@code size} and {@code byteAlignment}\n+     *          allocations by recycling the BufferStacks internal memory}\n@@ -59,0 +61,26 @@\n+    \/**\n+     * {@return a new Arena that tries to provide {@code layout}\n+     *          allocations by recycling the BufferStacks internal memory}\n+     *\n+     * @param layout for which to reserve internal memory\n+     *\/\n+    @ForceInline\n+    public Arena pushFrame(MemoryLayout layout) {\n+        return pushFrame(layout.byteSize(), layout.byteAlignment());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"BufferStack[\" + size + \"]\";\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(this);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return this == obj;\n+    }\n+\n@@ -85,1 +113,1 @@\n-            private final Arena scope = Arena.ofConfined();\n+            private final Arena confinedArena = Arena.ofConfined();\n@@ -95,1 +123,1 @@\n-                frame = new SlicingAllocator(frameSegment.reinterpret(scope, null));\n+                frame = new SlicingAllocator(frameSegment.reinterpret(confinedArena, null));\n@@ -108,0 +136,4 @@\n+                \/\/ Make sure we are on the right thread\n+                if (((MemorySessionImpl) scope()).ownerThread() != Thread.currentThread()) {\n+                    throw MemorySessionImpl.wrongThread();\n+                }\n@@ -111,0 +143,1 @@\n+            @ForceInline\n@@ -113,1 +146,1 @@\n-                return scope.scope();\n+                return confinedArena.scope();\n@@ -120,1 +153,3 @@\n-                scope.close();\n+                \/\/ the Arena::close method is closed \"early\" as it checks thread\n+                \/\/ confinement and before any mutation of the internal state takes place.\n+                confinedArena.close();\n@@ -131,0 +166,3 @@\n+        if (size < 0) {\n+            throw new IllegalArgumentException(\"Size is negative: \" + size);\n+        }\n@@ -138,0 +176,8 @@\n+\n+    public static BufferStack of(MemoryLayout layout) {\n+        Objects.requireNonNull(layout);\n+        long size = layout.byteAlignment() > 8\n+                ? layout.byteSize() + layout.byteAlignment() - 1\n+                : layout.byteSize();\n+        return of(size);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/BufferStack.java","additions":52,"deletions":6,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -36,0 +37,1 @@\n+import java.lang.foreign.Linker;\n@@ -40,0 +42,5 @@\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+import jdk.test.lib.thread.VThreadRunner;\n@@ -45,1 +52,25 @@\n-public class TestBufferStack extends NativeTestHelper {\n+final class TestBufferStack extends NativeTestHelper {\n+\n+    private static final long POOL_SIZE = 64;\n+    private static final long SMALL_ALLOC_SIZE = 8;\n+\n+    @Test\n+    void invariants() {\n+        var ex = assertThrows(IllegalArgumentException.class, () -> BufferStack.of(-1));\n+        assertEquals(\"Size is negative: -1\", ex.getMessage());\n+        assertThrows(NullPointerException.class, () -> BufferStack.of(null));\n+\n+        BufferStack stack = BufferStack.of(POOL_SIZE);\n+        assertThrows(IllegalArgumentException.class, () -> stack.pushFrame(-1, 8));\n+        assertThrows(IllegalArgumentException.class, () -> stack.pushFrame(SMALL_ALLOC_SIZE, -1));\n+\n+        try (var arena = stack.pushFrame(SMALL_ALLOC_SIZE, 1)) {\n+            assertThrows(IllegalArgumentException.class, () -> arena.allocate(-1));\n+            assertThrows(IllegalArgumentException.class, () -> arena.allocate(4, -1));\n+        }\n+    }\n+\n+    @Test\n+    void invariantsVt() {\n+        VThreadRunner.run(this::invariants);\n+    }\n@@ -48,1 +79,1 @@\n-    public void testScopedAllocation() {\n+    void testScopedAllocation() {\n@@ -103,0 +134,5 @@\n+    @Test\n+    void testScopedAllocationVt() {\n+        VThreadRunner.run(this::testScopedAllocation);\n+    }\n+\n@@ -120,1 +156,1 @@\n-    public void testDeepStack() throws Throwable {\n+    void testDeepStack() {\n@@ -128,0 +164,117 @@\n+\n+    @Test\n+    void testDeepStackVt() {\n+        VThreadRunner.run(this::testDeepStack);\n+    }\n+\n+    @Test\n+    void equals() {\n+        var first = BufferStack.of(POOL_SIZE);\n+        var second = BufferStack.of(POOL_SIZE);\n+        assertNotEquals(first, second);\n+        assertEquals(first, first);\n+    }\n+\n+    @Test\n+    void allocationSameAsPoolSize() {\n+        MemoryLayout twoInts = MemoryLayout.sequenceLayout(2, JAVA_INT);\n+        var pool = BufferStack.of(POOL_SIZE);\n+        long firstAddress;\n+        try (var arena = pool.pushFrame(JAVA_INT)) {\n+            var segment = arena.allocate(JAVA_INT);\n+            firstAddress = segment.address();\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            try (var arena = pool.pushFrame(twoInts)) {\n+                var segment = arena.allocate(JAVA_INT);\n+                assertEquals(firstAddress, segment.address());\n+                var segmentTwo = arena.allocate(JAVA_INT);\n+                assertNotEquals(firstAddress, segmentTwo.address());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void allocationSameAsPoolSizeVt() {\n+        VThreadRunner.run(this::allocationSameAsPoolSize);\n+    }\n+\n+    @Test\n+    void allocationCaptureStateLayout() {\n+        var layout = Linker.Option.captureStateLayout();\n+        var pool = BufferStack.of(layout);\n+        long firstAddress;\n+        try (var arena = pool.pushFrame(layout)) {\n+            var segment = arena.allocate(layout);\n+            firstAddress = segment.address();\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            try (var arena = pool.pushFrame(layout)) {\n+                var segment = arena.allocate(layout);\n+                assertEquals(firstAddress, segment.address());\n+                \/\/ Questionable exception type\n+                assertThrows(IndexOutOfBoundsException.class, () -> arena.allocate(layout));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void allocateConfinement() {\n+        var pool = BufferStack.of(POOL_SIZE);\n+        Consumer<Arena> allocateAction = arena ->\n+                assertThrows(WrongThreadException.class, () -> {\n+                    CompletableFuture<Arena> future = CompletableFuture.supplyAsync(() -> pool.pushFrame(SMALL_ALLOC_SIZE, 1));\n+                    var otherThreadArena = future.get();\n+                    otherThreadArena.allocate(SMALL_ALLOC_SIZE);\n+                    \/\/ Intentionally do not close the otherThreadArena here.\n+                });\n+        doInTwoStackedArenas(pool, allocateAction, allocateAction);\n+    }\n+\n+    @Test\n+    void allocateConfinementVt() {\n+        VThreadRunner.run(this::allocateConfinement);\n+    }\n+\n+    @Test\n+    void closeConfinement() {\n+        var pool = BufferStack.of(POOL_SIZE);\n+        Consumer<Arena> closeAction = arena -> {\n+            \/\/ Do not use CompletableFuture here as it might accidentally run on the\n+            \/\/ same carrier thread as a virtual thread.\n+            AtomicReference<Arena> otherThreadArena = new AtomicReference<>();\n+            var thread = Thread.ofPlatform().start(() -> {\n+                otherThreadArena.set(pool.pushFrame(SMALL_ALLOC_SIZE, 1));\n+            });\n+            try {\n+                thread.join();\n+            } catch (InterruptedException ie) {\n+                fail(ie);\n+            }\n+            assertThrows(WrongThreadException.class, otherThreadArena.get()::close);\n+        };\n+        doInTwoStackedArenas(pool, closeAction, closeAction);\n+    }\n+\n+    @Test\n+    void closeConfinementVt() {\n+        VThreadRunner.run(this::closeConfinement);\n+    }\n+\n+    @Test\n+    void toStringTest() {\n+        BufferStack stack = BufferStack.of(POOL_SIZE);\n+        assertEquals(\"BufferStack[\" + POOL_SIZE + \"]\", stack.toString());\n+    }\n+\n+    static void doInTwoStackedArenas(BufferStack pool,\n+                                     Consumer<Arena> firstAction,\n+                                     Consumer<Arena> secondAction) {\n+        try (var firstArena = pool.pushFrame(SMALL_ALLOC_SIZE, 1)) {\n+            firstAction.accept(firstArena);\n+            try (var secondArena = pool.pushFrame(SMALL_ALLOC_SIZE, 1)) {\n+                secondAction.accept(secondArena);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestBufferStack.java","additions":156,"deletions":3,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.foreign\n+ * @build NativeTestHelper TestBufferStackStress2\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED TestBufferStackStress2\n+ *\/\n+\n+import jdk.internal.foreign.BufferStack;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.FileDescriptor;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+final class TestBufferStackStress2 extends NativeTestHelper {\n+\n+    private static final long POOL_SIZE = 64;\n+    private static final long SMALL_ALLOC_SIZE = 8;\n+\n+    \/**\n+     * The objective with this test is to test the case when a virtual thread VT0 is\n+     * mounted on a carrier thread CT0; VT0 is then suspended; The pool of carrier threads\n+     * are then contracted; VT0 is then remounted on another carrier thread C1. VT0 runs\n+     * for a while when there is a lot of GC activity.\n+     * In other words, we are trying to establish that there is no use-after-free and that\n+     * the original arena, from which reusable segments are initially allocated from, is\n+     * not closed underneath.\n+     * <p>\n+     * Unfortunately, this test takes about 30 seconds as that is the time it takes for\n+     * the pool of carrier threads to be contracted.\n+     *\/\n+    @Test\n+    void movingVirtualThreadWithGc() throws InterruptedException {\n+        final long begin = System.nanoTime();\n+        var pool = BufferStack.of(POOL_SIZE);\n+\n+        System.setProperty(\"jdk.virtualThreadScheduler.parallelism\", \"1\");\n+\n+        var done = new AtomicBoolean();\n+        var quiescent = new Object();\n+        var executor = Executors.newVirtualThreadPerTaskExecutor();\n+\n+        executor.submit(() -> {\n+            while (!done.get()) {\n+                FileDescriptor.out.sync();\n+            }\n+            return null;\n+        });\n+\n+        executor.submit(() -> {\n+            System.out.println(duration(begin) + \"ALLOCATING = \" + Thread.currentThread());\n+            try (Arena arena = pool.pushFrame(SMALL_ALLOC_SIZE, 1)) {\n+                MemorySegment segment = arena.allocate(SMALL_ALLOC_SIZE);\n+                done.set(true);\n+                synchronized (quiescent) {\n+                    try {\n+                        quiescent.wait();\n+                    } catch (Throwable ex) {\n+                        throw new AssertionError(ex);\n+                    }\n+                }\n+                System.out.println(duration(begin) + \"ACCESSING SEGMENT\");\n+\n+                for (int i = 0; i < 100_000; i++) {\n+                    if (i % 100 == 0) {\n+                        System.gc();\n+                    }\n+                    segment.get(ValueLayout.JAVA_BYTE, i);\n+                }\n+                System.out.println(duration(begin) + \"DONE ACCESSING SEGMENT\");\n+            }\n+            System.out.println(duration(begin) + \"VT DONE\");\n+        });\n+\n+        long count;\n+        do {\n+            Thread.sleep(1000);\n+            count = Thread.getAllStackTraces().keySet().stream()\n+                    .filter(t -> t instanceof ForkJoinWorkerThread)\n+                    .count();\n+        } while (count > 0);\n+\n+        System.out.println(duration(begin) + \"FJP HAS CONTRACTED\");\n+\n+        synchronized (quiescent) {\n+            quiescent.notify();\n+        }\n+\n+        System.out.println(duration(begin) + \"CLOSING EXECUTOR\");\n+        executor.close();\n+        System.out.println(duration(begin) + \"EXECUTOR CLOSED\");\n+    }\n+\n+    private static String duration(Long begin) {\n+        var duration = Duration.of(System.nanoTime() - begin, ChronoUnit.NANOS);\n+        long seconds = duration.toSeconds();\n+        int nanos = duration.toNanosPart();\n+        return (Thread.currentThread().isVirtual() ? \"VT: \" : \"PT: \") +\n+                String.format(\"%3d:%09d \", seconds, nanos);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestBufferStackStress2.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"}]}