{"files":[{"patch":"@@ -787,0 +787,2 @@\n+java\/foreign\/TestBufferStackStress.java                         8350455 macosx-all\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,3 +41,0 @@\n-import java.time.Duration;\n-import java.util.Arrays;\n-import java.util.stream.IntStream;\n@@ -47,1 +44,0 @@\n-import static java.time.temporal.ChronoUnit.SECONDS;\n@@ -106,26 +102,0 @@\n-    @Test\n-    public void stress() throws InterruptedException {\n-        BufferStack stack = BufferStack.of(256);\n-        Thread[] vThreads = IntStream.range(0, 1024).mapToObj(_ ->\n-                Thread.ofVirtual().start(() -> {\n-                    long threadId = Thread.currentThread().threadId();\n-                    while (!Thread.interrupted()) {\n-                        for (int i = 0; i < 1_000_000; i++) {\n-                            try (Arena arena = stack.pushFrame(JAVA_LONG.byteSize(), JAVA_LONG.byteAlignment())) {\n-                                \/\/ Try to assert no two vThreads get allocated the same stack space.\n-                                MemorySegment segment = arena.allocate(JAVA_LONG);\n-                                JAVA_LONG.varHandle().setVolatile(segment, 0L, threadId);\n-                                Assert.assertEquals(threadId, (long) JAVA_LONG.varHandle().getVolatile(segment, 0L));\n-                            }\n-                        }\n-                        Thread.yield(); \/\/ make sure the driver thread gets a chance.\n-                    }\n-                })).toArray(Thread[]::new);\n-        Thread.sleep(Duration.of(10, SECONDS));\n-        Arrays.stream(vThreads).forEach(\n-                thread -> {\n-                    Assert.assertTrue(thread.isAlive());\n-                    thread.interrupt();\n-                });\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestBufferStack.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.foreign\n+ * @build NativeTestHelper TestBufferStackStress\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestBufferStackStress\n+ *\/\n+\n+import jdk.internal.foreign.BufferStack;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.stream.IntStream;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.time.temporal.ChronoUnit.SECONDS;\n+\n+public class TestBufferStackStress extends NativeTestHelper {\n+\n+    @Test\n+    public void stress() throws InterruptedException {\n+        BufferStack stack = BufferStack.of(256);\n+        Thread[] vThreads = IntStream.range(0, 1024).mapToObj(_ ->\n+                Thread.ofVirtual().start(() -> {\n+                    long threadId = Thread.currentThread().threadId();\n+                    while (!Thread.interrupted()) {\n+                        for (int i = 0; i < 1_000_000; i++) {\n+                            try (Arena arena = stack.pushFrame(JAVA_LONG.byteSize(), JAVA_LONG.byteAlignment())) {\n+                                \/\/ Try to assert no two vThreads get allocated the same stack space.\n+                                MemorySegment segment = arena.allocate(JAVA_LONG);\n+                                JAVA_LONG.varHandle().setVolatile(segment, 0L, threadId);\n+                                Assert.assertEquals(threadId, (long) JAVA_LONG.varHandle().getVolatile(segment, 0L));\n+                            }\n+                        }\n+                        Thread.yield(); \/\/ make sure the driver thread gets a chance.\n+                    }\n+                })).toArray(Thread[]::new);\n+        Thread.sleep(Duration.of(10, SECONDS));\n+        Arrays.stream(vThreads).forEach(\n+                thread -> {\n+                    Assert.assertTrue(thread.isAlive());\n+                    thread.interrupt();\n+                });\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestBufferStackStress.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}