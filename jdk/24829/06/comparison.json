{"files":[{"patch":"@@ -0,0 +1,206 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.misc.CarrierThreadLocal;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.ref.Reference;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * A buffer stack that allows efficient reuse of memory segments. This is useful in cases\n+ * where temporary memory is needed.\n+ * <p>\n+ * Use the factories {@code BufferStack.of(...)} to create new instances of this class.\n+ * <p>\n+ * Note: The reused segments are neither zeroed out before nor after re-use.\n+ *\/\n+public final class BufferStack {\n+\n+    private final long byteSize;\n+    private final CarrierThreadLocal<PerThread> tl;\n+\n+    public BufferStack(long byteSize, long byteAlignment) {\n+        this.byteSize = byteSize;\n+        this.tl = new CarrierThreadLocal<>() {\n+            @Override\n+            protected BufferStack.PerThread initialValue() {\n+                return BufferStack.PerThread.of(byteSize, byteAlignment);\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * {@return a new Arena that tries to provide {@code byteSize} and {@code byteAlignment}\n+     *          allocations by recycling the BufferStack's internal memory}\n+     *\n+     * @param byteSize      to be reserved from this BufferStack's internal memory\n+     * @param byteAlignment to be used for reservation\n+     *\/\n+    @ForceInline\n+    public Arena pushFrame(long byteSize, long byteAlignment) {\n+        return tl.get().pushFrame(byteSize, byteAlignment);\n+    }\n+\n+    \/**\n+     * {@return a new Arena that tries to provide {@code byteSize}\n+     *          allocations by recycling the BufferStack's internal memory}\n+     *\n+     * @param byteSize      to be reserved from this BufferStack's internal memory\n+     *\/\n+    @ForceInline\n+    public Arena pushFrame(long byteSize) {\n+        return pushFrame(byteSize, 1);\n+    }\n+\n+    \/**\n+     * {@return a new Arena that tries to provide {@code layout}\n+     *          allocations by recycling the BufferStack's internal memory}\n+     *\n+     * @param layout for which to reserve internal memory\n+     *\/\n+    @ForceInline\n+    public Arena pushFrame(MemoryLayout layout) {\n+        return pushFrame(layout.byteSize(), layout.byteAlignment());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"BufferStack[\" + byteSize + \"]\";\n+    }\n+\n+    private record PerThread(ReentrantLock lock, Arena arena, SlicingAllocator stack) {\n+\n+        @ForceInline\n+        public Arena pushFrame(long size, long byteAlignment) {\n+            boolean needsLock = Thread.currentThread().isVirtual() && !lock.isHeldByCurrentThread();\n+            if (needsLock && !lock.tryLock()) {\n+                \/\/ Rare: another virtual thread on the same carrier competed for acquisition.\n+                return Arena.ofConfined();\n+            }\n+            if (!stack.canAllocate(size, byteAlignment)) {\n+                if (needsLock) lock.unlock();\n+                return Arena.ofConfined();\n+            }\n+            return new Frame(needsLock, size, byteAlignment);\n+        }\n+\n+        static PerThread of(long byteSize, long byteAlignment) {\n+            final Arena arena = Arena.ofAuto();\n+            return new PerThread(new ReentrantLock(),\n+                    arena,\n+                    new SlicingAllocator(arena.allocate(byteSize, byteAlignment)));\n+        }\n+\n+        private final class Frame implements Arena {\n+            private final boolean locked;\n+            private final long parentOffset;\n+            private final long topOfStack;\n+            private final Arena confinedArena = Arena.ofConfined();\n+            private final SegmentAllocator frame;\n+\n+            @SuppressWarnings(\"restricted\")\n+            @ForceInline\n+            public Frame(boolean locked, long byteSize, long byteAlignment) {\n+                this.locked = locked;\n+                parentOffset = stack.currentOffset();\n+                MemorySegment frameSegment = stack.allocate(byteSize, byteAlignment);\n+                topOfStack = stack.currentOffset();\n+                \/\/ The cleanup action will keep the original automatic `arena` (from which\n+                \/\/ the reusable segment is first allocated) alive even if this Frame\n+                \/\/ becomes unreachable but there are reachable segments still alive.\n+                frame = new SlicingAllocator(frameSegment.reinterpret(confinedArena, new CleanupAction(arena)));\n+            }\n+\n+            record CleanupAction(Arena arena) implements Consumer<MemorySegment> {\n+                @Override\n+                public void accept(MemorySegment memorySegment) {\n+                    Reference.reachabilityFence(arena);\n+                }\n+            }\n+\n+            @ForceInline\n+            private void assertOrder() {\n+                if (topOfStack != stack.currentOffset())\n+                    throw new IllegalStateException(\"Out of order access: frame not top-of-stack\");\n+            }\n+\n+            @ForceInline\n+            @Override\n+            @SuppressWarnings(\"restricted\")\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                \/\/ Make sure we are on the right thread and not closed\n+                MemorySessionImpl.toMemorySession(confinedArena).checkValidState();\n+                return frame.allocate(byteSize, byteAlignment);\n+            }\n+\n+            @ForceInline\n+            @Override\n+            public MemorySegment.Scope scope() {\n+                return confinedArena.scope();\n+            }\n+\n+            @ForceInline\n+            @Override\n+            public void close() {\n+                assertOrder();\n+                \/\/ the Arena::close method is called \"early\" as it checks thread\n+                \/\/ confinement and crucially before any mutation of the internal\n+                \/\/ state takes place.\n+                confinedArena.close();\n+                stack.resetTo(parentOffset);\n+                if (locked) {\n+                    lock.unlock();\n+                }\n+            }\n+        }\n+    }\n+\n+    public static BufferStack of(long byteSize, long byteAlignment) {\n+        if (byteSize < 0) {\n+            throw new IllegalArgumentException(\"Negative byteSize: \" + byteSize);\n+        }\n+        if (byteAlignment < 0) {\n+            throw new IllegalArgumentException(\"Negative byteAlignment: \" + byteAlignment);\n+        }\n+        return new BufferStack(byteSize, byteAlignment);\n+    }\n+\n+    public static BufferStack of(long byteSize) {\n+        return new BufferStack(byteSize, 1);\n+    }\n+\n+    public static BufferStack of(MemoryLayout layout) {\n+        \/\/ Implicit null check\n+        return of(layout.byteSize(), layout.byteAlignment());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/BufferStack.java","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,16 @@\n+    public long currentOffset() {\n+        return sp;\n+    }\n+\n+    public void resetTo(long offset) {\n+        if (offset < 0 || offset > sp)\n+            throw new IllegalArgumentException(String.format(\"offset %d should be in [0, %d] \", offset, sp));\n+        this.sp = offset;\n+    }\n+\n+    public boolean canAllocate(long byteSize, long byteAlignment) {\n+        long min = segment.address();\n+        long start = Utils.alignUp(min + sp, byteAlignment) - min;\n+        return start + byteSize <= segment.byteSize();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SlicingAllocator.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.internal.access.JavaLangAccess;\n@@ -30,0 +29,1 @@\n+import jdk.internal.foreign.BufferStack;\n@@ -393,14 +393,2 @@\n-    public static Arena newBoundedArena(long size) {\n-        return new Arena() {\n-            final Arena arena = Arena.ofConfined();\n-            final SegmentAllocator slicingAllocator = SegmentAllocator.slicingAllocator(arena.allocate(size));\n-\n-            @Override\n-            public Scope scope() {\n-                return arena.scope();\n-            }\n-\n-            @Override\n-            public void close() {\n-                arena.close();\n-            }\n+    private static final int LINKER_STACK_SIZE = Integer.getInteger(\"jdk.internal.foreign.LINKER_STACK_SIZE\", 256);\n+    private static final BufferStack LINKER_STACK = BufferStack.of(LINKER_STACK_SIZE, 1);\n@@ -408,5 +396,3 @@\n-            @Override\n-            public MemorySegment allocate(long byteSize, long byteAlignment) {\n-                return slicingAllocator.allocate(byteSize, byteAlignment);\n-            }\n-        };\n+    @ForceInline\n+    public static Arena newBoundedArena(long size) {\n+        return LINKER_STACK.pushFrame(size, 8);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":6,"deletions":20,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -787,0 +787,2 @@\n+java\/foreign\/TestBufferStackStress.java                         8350455 macosx-all\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,287 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.foreign\n+ * @build NativeTestHelper TestBufferStack\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED TestBufferStack\n+ *\/\n+\n+import jdk.internal.foreign.BufferStack;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+import jdk.test.lib.thread.VThreadRunner;\n+\n+import static java.lang.foreign.MemoryLayout.structLayout;\n+import static java.lang.foreign.ValueLayout.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestBufferStack extends NativeTestHelper {\n+\n+    private static final long POOL_SIZE = 64;\n+    private static final long SMALL_ALLOC_SIZE = 8;\n+\n+    @Test\n+    void invariants() {\n+        var exBS = assertThrows(IllegalArgumentException.class, () -> BufferStack.of(-1, 1));\n+        assertEquals(\"Negative byteSize: -1\", exBS.getMessage());\n+        var exBA = assertThrows(IllegalArgumentException.class, () -> BufferStack.of(1, -1));\n+        assertEquals(\"Negative byteAlignment: -1\", exBA.getMessage());\n+        assertThrows(NullPointerException.class, () -> BufferStack.of(null));\n+\n+        BufferStack stack = newBufferStack();\n+        assertThrows(IllegalArgumentException.class, () -> stack.pushFrame(-1, 8));\n+        assertThrows(IllegalArgumentException.class, () -> stack.pushFrame(SMALL_ALLOC_SIZE, -1));\n+\n+        try (var arena = stack.pushFrame(SMALL_ALLOC_SIZE, 1)) {\n+            assertThrows(IllegalArgumentException.class, () -> arena.allocate(-1));\n+            assertThrows(IllegalArgumentException.class, () -> arena.allocate(4, -1));\n+        }\n+    }\n+\n+    @Test\n+    void invariantsVt() {\n+        VThreadRunner.run(this::invariants);\n+    }\n+\n+    @Test\n+    void testScopedAllocation() {\n+        int stackSize = 128;\n+        BufferStack stack = newBufferStack();\n+        try (Arena frame1 = stack.pushFrame(3 * JAVA_INT.byteSize(), JAVA_INT.byteAlignment())) {\n+            \/\/ Segments have expected sizes and are accessible and allocated consecutively in the same scope.\n+            MemorySegment segment11 = frame1.allocate(JAVA_INT);\n+            assertEquals(frame1.scope(), segment11.scope());\n+            assertEquals(JAVA_INT.byteSize(), segment11.byteSize());\n+            segment11.set(JAVA_INT, 0, 1);\n+\n+            MemorySegment segment12 = frame1.allocate(JAVA_INT);\n+            assertEquals(segment11.address() + JAVA_INT.byteSize(), segment12.address());\n+            assertEquals(JAVA_INT.byteSize(), segment12.byteSize());\n+            assertEquals(frame1.scope(), segment12.scope());\n+            segment12.set(JAVA_INT, 0, 1);\n+\n+            MemorySegment segment2;\n+            try (Arena frame2 = stack.pushFrame(JAVA_LONG.byteSize(), JAVA_LONG.byteAlignment())) {\n+                assertNotEquals(frame1.scope(), frame2.scope());\n+                \/\/ same here, but a new scope.\n+                segment2 = frame2.allocate(JAVA_LONG);\n+                assertEquals( segment12.address() + \/*segment12 size + frame 1 spare + alignment constraint*\/ 3 * JAVA_INT.byteSize(), segment2.address());\n+                assertEquals(JAVA_LONG.byteSize(), segment2.byteSize());\n+                assertEquals(frame2.scope(), segment2.scope());\n+                segment2.set(JAVA_LONG, 0, 1);\n+\n+                \/\/ Frames must be closed in stack order.\n+                assertThrows(IllegalStateException.class, frame1::close);\n+            }\n+            \/\/ Scope is closed here, inner segments throw.\n+            assertThrows(IllegalStateException.class, () -> segment2.get(JAVA_INT, 0));\n+            \/\/ A new stack frame allocates at the same location (but different scope) as the previous did.\n+            try (Arena frame3 = stack.pushFrame(2 * JAVA_INT.byteSize(), JAVA_INT.byteAlignment())) {\n+                MemorySegment segment3 = frame3.allocate(JAVA_INT);\n+                assertEquals(frame3.scope(), segment3.scope());\n+                assertEquals(segment12.address() + 2 * JAVA_INT.byteSize(), segment3.address());\n+            }\n+\n+            \/\/ Fallback arena behaves like regular stack frame.\n+            MemorySegment outOfStack;\n+            try (Arena hugeFrame = stack.pushFrame(1024, 4)) {\n+                outOfStack = hugeFrame.allocate(4);\n+                assertEquals(hugeFrame.scope(), outOfStack.scope());\n+                assertTrue(outOfStack.asOverlappingSlice(segment11).isEmpty());\n+            }\n+            assertThrows(IllegalStateException.class, () -> outOfStack.get(JAVA_INT, 0));\n+\n+            \/\/ Outer segments are still accessible.\n+            segment11.get(JAVA_INT, 0);\n+            segment12.get(JAVA_INT, 0);\n+        }\n+    }\n+\n+    @Test\n+    void testScopedAllocationVt() {\n+        VThreadRunner.run(this::testScopedAllocation);\n+    }\n+\n+    static {\n+        System.loadLibrary(\"TestBufferStack\");\n+    }\n+\n+    private static final MemoryLayout HVAPoint3D = structLayout(NativeTestHelper.C_DOUBLE, C_DOUBLE, C_DOUBLE);\n+    private static final MemorySegment UPCALL_MH = upcallStub(TestBufferStack.class, \"recurse\", FunctionDescriptor.of(HVAPoint3D, C_INT));\n+    private static final MethodHandle DOWNCALL_MH = downcallHandle(\"recurse\", FunctionDescriptor.of(HVAPoint3D, C_INT, ADDRESS));\n+\n+    public static MemorySegment recurse(int depth) {\n+        try {\n+            return (MemorySegment) DOWNCALL_MH.invokeExact((SegmentAllocator) Arena.ofAuto(), depth, UPCALL_MH);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Test\n+    void testDeepStack() {\n+        \/\/ Each downcall and upcall require 48 bytes of stack.\n+        \/\/ After five allocations we start falling back.\n+        MemorySegment point = recurse(10);\n+        assertEquals( 12.0, point.getAtIndex(C_DOUBLE, 0));\n+        assertEquals(11.0, point.getAtIndex(C_DOUBLE, 1));\n+        assertEquals( 10.0, point.getAtIndex(C_DOUBLE, 2));\n+    }\n+\n+    @Test\n+    void testDeepStackVt() {\n+        VThreadRunner.run(this::testDeepStack);\n+    }\n+\n+    @Test\n+    void equals() {\n+        var first = newBufferStack();\n+        var second = newBufferStack();\n+        assertNotEquals(first, second);\n+        assertEquals(first, first);\n+    }\n+\n+    @Test\n+    void allocationSameAsPoolSize() {\n+        MemoryLayout twoInts = MemoryLayout.sequenceLayout(2, JAVA_INT);\n+        var pool = newBufferStack();\n+        long firstAddress;\n+        try (var arena = pool.pushFrame(JAVA_INT)) {\n+            var segment = arena.allocate(JAVA_INT);\n+            firstAddress = segment.address();\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            try (var arena = pool.pushFrame(twoInts)) {\n+                var segment = arena.allocate(JAVA_INT);\n+                assertEquals(firstAddress, segment.address());\n+                var segmentTwo = arena.allocate(JAVA_INT);\n+                assertEquals(firstAddress + JAVA_INT.byteSize(), segmentTwo.address());\n+                \/\/ Questionable exception type\n+                assertThrows(IndexOutOfBoundsException.class, () -> arena.allocate(JAVA_INT));\n+            }\n+        }\n+    }\n+    @Test\n+    void allocationSameAsPoolSizeVt() {\n+        VThreadRunner.run(this::allocationSameAsPoolSize);\n+    }\n+\n+    @Test\n+    void allocateConfinement() {\n+        var pool = newBufferStack();\n+        Consumer<Arena> allocateAction = arena ->\n+                assertThrows(WrongThreadException.class, () -> {\n+                    CompletableFuture<Arena> future = CompletableFuture.supplyAsync(() -> pool.pushFrame(SMALL_ALLOC_SIZE, 1));\n+                    var otherThreadArena = future.get();\n+                    otherThreadArena.allocate(SMALL_ALLOC_SIZE);\n+                    \/\/ Intentionally do not close the otherThreadArena here.\n+                });\n+        doInTwoStackedArenas(pool, allocateAction, allocateAction);\n+    }\n+\n+    @Test\n+    void allocateConfinementVt() {\n+        VThreadRunner.run(this::allocateConfinement);\n+    }\n+\n+    @Test\n+    void closeConfinement() {\n+        var pool = newBufferStack();\n+        Consumer<Arena> closeAction = arena -> {\n+            \/\/ Do not use CompletableFuture here as it might accidentally run on the\n+            \/\/ same carrier thread as a virtual thread.\n+            AtomicReference<Arena> otherThreadArena = new AtomicReference<>();\n+            var thread = Thread.ofPlatform().start(() -> {\n+                otherThreadArena.set(pool.pushFrame(SMALL_ALLOC_SIZE, 1));\n+            });\n+            try {\n+                thread.join();\n+            } catch (InterruptedException ie) {\n+                fail(ie);\n+            }\n+            assertThrows(WrongThreadException.class, otherThreadArena.get()::close);\n+        };\n+        doInTwoStackedArenas(pool, closeAction, closeAction);\n+    }\n+\n+    @Test\n+    void closeConfinementVt() {\n+        VThreadRunner.run(this::closeConfinement);\n+    }\n+\n+    @Test\n+    void toStringTest() {\n+        BufferStack stack = newBufferStack();\n+        assertEquals(\"BufferStack[\" + POOL_SIZE + \"]\", stack.toString());\n+    }\n+\n+    @Test\n+    void allocBounds() {\n+        BufferStack stack = newBufferStack();\n+        try (var arena = stack.pushFrame(SMALL_ALLOC_SIZE, 1)) {\n+            assertThrows(IllegalArgumentException.class, () -> arena.allocate(-1));\n+            assertDoesNotThrow(() -> arena.allocate(SMALL_ALLOC_SIZE));\n+            assertThrows(IndexOutOfBoundsException.class, () -> arena.allocate(SMALL_ALLOC_SIZE + 1));\n+        }\n+    }\n+\n+    @Test\n+    void accessBounds() {\n+        BufferStack stack = newBufferStack();\n+        try (var arena = stack.pushFrame(SMALL_ALLOC_SIZE, 1)) {\n+            var segment = arena.allocate(SMALL_ALLOC_SIZE);\n+            assertThrows(IndexOutOfBoundsException.class, () -> segment.get(JAVA_BYTE, SMALL_ALLOC_SIZE));\n+        }\n+    }\n+\n+    static void doInTwoStackedArenas(BufferStack pool,\n+                                     Consumer<Arena> firstAction,\n+                                     Consumer<Arena> secondAction) {\n+        try (var firstArena = pool.pushFrame(SMALL_ALLOC_SIZE, 1)) {\n+            firstAction.accept(firstArena);\n+            try (var secondArena = pool.pushFrame(SMALL_ALLOC_SIZE, 1)) {\n+                secondAction.accept(secondArena);\n+            }\n+        }\n+    }\n+\n+    private static BufferStack newBufferStack() {\n+        return BufferStack.of(POOL_SIZE, 1);\n+    }\n+\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestBufferStack.java","additions":287,"deletions":0,"binary":false,"changes":287,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.foreign\n+ * @build NativeTestHelper TestBufferStackStress\n+ * @run junit TestBufferStackStress\n+ *\/\n+\n+import jdk.internal.foreign.BufferStack;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.stream.IntStream;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.time.temporal.ChronoUnit.SECONDS;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class TestBufferStackStress {\n+\n+    @Test\n+    public void stress() throws InterruptedException {\n+        BufferStack stack = BufferStack.of(256, 1);\n+        Thread[] vThreads = IntStream.range(0, 1024).mapToObj(_ ->\n+                Thread.ofVirtual().start(() -> {\n+                    long threadId = Thread.currentThread().threadId();\n+                    while (!Thread.interrupted()) {\n+                        for (int i = 0; i < 1_000_000; i++) {\n+                            try (Arena arena = stack.pushFrame(JAVA_LONG.byteSize(), JAVA_LONG.byteAlignment())) {\n+                                \/\/ Try to assert no two vThreads get allocated the same stack space.\n+                                MemorySegment segment = arena.allocate(JAVA_LONG);\n+                                JAVA_LONG.varHandle().setVolatile(segment, 0L, threadId);\n+                                assertEquals(threadId, (long) JAVA_LONG.varHandle().getVolatile(segment, 0L));\n+                            }\n+                        }\n+                        Thread.yield(); \/\/ make sure the driver thread gets a chance.\n+                    }\n+                })).toArray(Thread[]::new);\n+        Thread.sleep(Duration.of(10, SECONDS));\n+        Arrays.stream(vThreads).forEach(\n+                thread -> {\n+                    assertTrue(thread.isAlive());\n+                    thread.interrupt();\n+                });\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestBufferStackStress.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.foreign\n+ * @build NativeTestHelper TestBufferStackStress2\n+ * @run junit TestBufferStackStress2\n+ *\/\n+\n+import jdk.internal.foreign.BufferStack;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.FileDescriptor;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestBufferStackStress2 {\n+\n+    private static final long POOL_SIZE = 64;\n+    private static final long SMALL_ALLOC_SIZE = 8;\n+\n+    \/**\n+     * The objective with this test is to test the case when a virtual thread VT0 is\n+     * mounted on a carrier thread CT0; VT0 is then suspended; The pool of carrier threads\n+     * are then contracted; VT0 is then remounted on another carrier thread C1. VT0 runs\n+     * for a while when there is a lot of GC activity.\n+     * In other words, we are trying to establish that there is no use-after-free and that\n+     * the original arena, from which reusable segments are initially allocated from, is\n+     * not closed underneath.\n+     * <p>\n+     * Unfortunately, this test takes about 30 seconds as that is the time it takes for\n+     * the pool of carrier threads to be contracted.\n+     *\/\n+    @Test\n+    void movingVirtualThreadWithGc() throws InterruptedException {\n+        final long begin = System.nanoTime();\n+        var pool = BufferStack.of(POOL_SIZE, 1);\n+\n+        System.setProperty(\"jdk.virtualThreadScheduler.parallelism\", \"1\");\n+\n+        var done = new AtomicBoolean();\n+        var completed = new AtomicBoolean();\n+        var quiescent = new Object();\n+        var executor = Executors.newVirtualThreadPerTaskExecutor();\n+\n+        executor.submit(() -> {\n+            while (!done.get()) {\n+                FileDescriptor.out.sync();\n+            }\n+            return null;\n+        });\n+\n+        executor.submit(() -> {\n+            System.out.println(duration(begin) + \"ALLOCATING = \" + Thread.currentThread());\n+            try (Arena arena = pool.pushFrame(SMALL_ALLOC_SIZE, 1)) {\n+                MemorySegment segment = arena.allocate(SMALL_ALLOC_SIZE);\n+                done.set(true);\n+                synchronized (quiescent) {\n+                    try {\n+                        quiescent.wait();\n+                    } catch (Throwable ex) {\n+                        throw new AssertionError(ex);\n+                    }\n+                }\n+                System.out.println(duration(begin) + \"ACCESSING SEGMENT\");\n+\n+                for (int i = 0; i < 100_000; i++) {\n+                    if (i % 100 == 0) {\n+                        System.gc();\n+                    }\n+                    segment.get(ValueLayout.JAVA_BYTE, i % SMALL_ALLOC_SIZE);\n+                }\n+                System.out.println(duration(begin) + \"DONE ACCESSING SEGMENT\");\n+            }\n+            System.out.println(duration(begin) + \"VT DONE\");\n+            completed.set(true);\n+        });\n+\n+        long count;\n+        do {\n+            Thread.sleep(1000);\n+            count = Thread.getAllStackTraces().keySet().stream()\n+                    .filter(t -> t instanceof ForkJoinWorkerThread)\n+                    .count();\n+        } while (count > 0);\n+\n+        System.out.println(duration(begin) + \"FJP HAS CONTRACTED\");\n+\n+        synchronized (quiescent) {\n+            quiescent.notify();\n+        }\n+\n+        System.out.println(duration(begin) + \"CLOSING EXECUTOR\");\n+        executor.close();\n+        System.out.println(duration(begin) + \"EXECUTOR CLOSED\");\n+        assertTrue(completed.get(), \"The VT did not complete properly\");\n+    }\n+\n+    private static String duration(Long begin) {\n+        var duration = Duration.of(System.nanoTime() - begin, ChronoUnit.NANOS);\n+        long seconds = duration.toSeconds();\n+        int nanos = duration.toNanosPart();\n+        return (Thread.currentThread().isVirtual() ? \"VT: \" : \"PT: \") +\n+                String.format(\"%3d:%09d \", seconds, nanos);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestBufferStackStress2.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"export.h\"\n+\n+typedef struct { double x, y, z; } HVAPoint3D;\n+\n+EXPORT HVAPoint3D recurse(int depth, HVAPoint3D (*cb)(int)) {\n+  if (depth == 0) {\n+    HVAPoint3D result = { 2, 1, 0};\n+    return result;\n+  }\n+\n+  HVAPoint3D result = cb(depth - 1);\n+  result.x += 1;\n+  result.y += 1;\n+  result.z += 1;\n+  return result;\n+}\n","filename":"test\/jdk\/java\/foreign\/libTestBufferStack.c","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ *  Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import jdk.internal.foreign.BufferStack;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\"})\n+public class BufferStackBench {\n+\n+    @Param({\"8\", \"16\", \"32\"})\n+    public int ELEM_SIZE;\n+\n+    private BufferStack bufferStack;\n+\n+    @Setup\n+    public void setup() {\n+        bufferStack = BufferStack.of(128);\n+    }\n+\n+    @Benchmark\n+    public long confined() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            return arena.allocate(ELEM_SIZE).address();\n+        }\n+    }\n+\n+    @Benchmark\n+    public long buffer() {\n+        try (Arena arena = bufferStack.pushFrame(64, 1)) {\n+            return arena.allocate(ELEM_SIZE).address();\n+        }\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = \"-Djmh.executor=VIRTUAL\")\n+    public static class OfVirtual extends BufferStackBench {}\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BufferStackBench.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openjdk.bench.java.lang.foreign.CLayouts.C_DOUBLE;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n+public class CallOverheadByValue {\n+\n+    public static final MemoryLayout POINT_LAYOUT = MemoryLayout.structLayout(\n+            C_DOUBLE, C_DOUBLE\n+    );\n+    private static final MethodHandle MH_UNIT_BY_VALUE;\n+    private static final MethodHandle MH_UNIT_BY_PTR;\n+\n+    static {\n+        Linker abi = Linker.nativeLinker();\n+        System.loadLibrary(\"CallOverheadByValue\");\n+        SymbolLookup loaderLibs = SymbolLookup.loaderLookup();\n+        MH_UNIT_BY_VALUE = abi.downcallHandle(\n+                loaderLibs.findOrThrow(\"unit\"),\n+                FunctionDescriptor.of(POINT_LAYOUT)\n+        );\n+        MH_UNIT_BY_PTR = abi.downcallHandle(\n+                loaderLibs.findOrThrow(\"unit_ptr\"),\n+                FunctionDescriptor.ofVoid(ValueLayout.ADDRESS)\n+        );\n+    }\n+\n+    private static final Arena arena = Arena.ofConfined();\n+    private static final MemorySegment point = arena.allocate(POINT_LAYOUT);\n+    private static final SegmentAllocator BY_VALUE_ALLOCATOR = (SegmentAllocator) (_, _) -> point;\n+\n+    @TearDown\n+    public void tearDown() {\n+        arena.close();\n+    }\n+\n+    @Benchmark\n+    public void byValue() throws Throwable {\n+        \/\/ point = unit();\n+        MemorySegment unused = (MemorySegment) MH_UNIT_BY_VALUE.invokeExact(BY_VALUE_ALLOCATOR);\n+    }\n+\n+    @Benchmark\n+    public void byPtr() throws Throwable {\n+        \/\/ unit_ptr(&point);\n+        MH_UNIT_BY_PTR.invokeExact(point);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = \"-Djmh.executor=VIRTUAL\")\n+    public static class OfVirtual extends CallOverheadByValue {}\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadByValue.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"export.h\"\n+\n+typedef struct {\n+    double x;\n+    double y;\n+} DoublePoint;\n+\n+EXPORT DoublePoint unit() {\n+    DoublePoint result = { 1, 0 };\n+    return result;\n+}\n+\n+EXPORT void unit_ptr(DoublePoint* out) {\n+  *out = unit();\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libCallOverheadByValue.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"}]}