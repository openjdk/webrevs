{"files":[{"patch":"@@ -50,0 +50,1 @@\n+    private final long byteAlignment;\n@@ -52,1 +53,1 @@\n-    public BufferStack(long byteSize, long byteAlignment) {\n+    private BufferStack(long byteSize, long byteAlignment) {\n@@ -54,0 +55,1 @@\n+        this.byteAlignment = byteAlignment;\n@@ -98,1 +100,1 @@\n-        return \"BufferStack[\" + byteSize + \"]\";\n+        return \"BufferStack[byteSize=\" + byteSize + \", byteAlignment=\" + byteAlignment + \"]\";\n@@ -101,1 +103,4 @@\n-    private record PerThread(ReentrantLock lock, Arena arena, SlicingAllocator stack) {\n+    private record PerThread(ReentrantLock lock,\n+                             Arena arena,\n+                             SlicingAllocator stack,\n+                             CleanupAction cleanupAction) {\n@@ -121,1 +126,9 @@\n-                    new SlicingAllocator(arena.allocate(byteSize, byteAlignment)));\n+                    new SlicingAllocator(arena.allocate(byteSize, byteAlignment)),\n+                    new CleanupAction(arena));\n+        }\n+\n+        private record CleanupAction(Arena arena) implements Consumer<MemorySegment> {\n+            @Override\n+            public void accept(MemorySegment memorySegment) {\n+                Reference.reachabilityFence(arena);\n+            }\n@@ -125,0 +138,1 @@\n+\n@@ -128,1 +142,1 @@\n-            private final Arena confinedArena = Arena.ofConfined();\n+            private final Arena confinedArena;\n@@ -135,3 +149,4 @@\n-                parentOffset = stack.currentOffset();\n-                MemorySegment frameSegment = stack.allocate(byteSize, byteAlignment);\n-                topOfStack = stack.currentOffset();\n+                this.parentOffset = stack.currentOffset();\n+                final MemorySegment frameSegment = stack.allocate(byteSize, byteAlignment);\n+                this.topOfStack = stack.currentOffset();\n+                this.confinedArena = Arena.ofConfined();\n@@ -141,8 +156,1 @@\n-                frame = new SlicingAllocator(frameSegment.reinterpret(confinedArena, new CleanupAction(arena)));\n-            }\n-\n-            record CleanupAction(Arena arena) implements Consumer<MemorySegment> {\n-                @Override\n-                public void accept(MemorySegment memorySegment) {\n-                    Reference.reachabilityFence(arena);\n-                }\n+                this.frame = new SlicingAllocator(frameSegment.reinterpret(confinedArena, cleanupAction));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/BufferStack.java","additions":24,"deletions":16,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.foreign.Linker;\n@@ -249,1 +248,1 @@\n-        assertEquals(\"BufferStack[\" + POOL_SIZE + \"]\", stack.toString());\n+        assertEquals(\"BufferStack[byteSize=\" + POOL_SIZE + \", byteAlignment=1]\", stack.toString());\n","filename":"test\/jdk\/java\/foreign\/TestBufferStack.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}