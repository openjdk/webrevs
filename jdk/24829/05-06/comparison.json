{"files":[{"patch":"@@ -36,1 +36,0 @@\n-import java.util.Objects;\n@@ -38,2 +37,1 @@\n-\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import java.util.function.Consumer;\n@@ -45,1 +43,1 @@\n- * Use the factory {@link #of(long)} to create new instances of this class.\n+ * Use the factories {@code BufferStack.of(...)} to create new instances of this class.\n@@ -49,1 +47,14 @@\n-public record BufferStack(long size, CarrierThreadLocal<PerThread> tl) {\n+public final class BufferStack {\n+\n+    private final long byteSize;\n+    private final CarrierThreadLocal<PerThread> tl;\n+\n+    public BufferStack(long byteSize, long byteAlignment) {\n+        this.byteSize = byteSize;\n+        this.tl = new CarrierThreadLocal<>() {\n+            @Override\n+            protected BufferStack.PerThread initialValue() {\n+                return BufferStack.PerThread.of(byteSize, byteAlignment);\n+            }\n+        };\n+    }\n@@ -52,2 +63,2 @@\n-     * {@return a new Arena that tries to provide {@code size} and {@code byteAlignment}\n-     *          allocations by recycling the BufferStacks internal memory}\n+     * {@return a new Arena that tries to provide {@code byteSize} and {@code byteAlignment}\n+     *          allocations by recycling the BufferStack's internal memory}\n@@ -55,1 +66,1 @@\n-     * @param size          to be reserved from this BufferStacks internal memory\n+     * @param byteSize      to be reserved from this BufferStack's internal memory\n@@ -59,2 +70,13 @@\n-    public Arena pushFrame(long size, long byteAlignment) {\n-        return tl.get().pushFrame(size, byteAlignment);\n+    public Arena pushFrame(long byteSize, long byteAlignment) {\n+        return tl.get().pushFrame(byteSize, byteAlignment);\n+    }\n+\n+    \/**\n+     * {@return a new Arena that tries to provide {@code byteSize}\n+     *          allocations by recycling the BufferStack's internal memory}\n+     *\n+     * @param byteSize      to be reserved from this BufferStack's internal memory\n+     *\/\n+    @ForceInline\n+    public Arena pushFrame(long byteSize) {\n+        return pushFrame(byteSize, 1);\n@@ -65,1 +87,1 @@\n-     *          allocations by recycling the BufferStacks internal memory}\n+     *          allocations by recycling the BufferStack's internal memory}\n@@ -76,1 +98,1 @@\n-        return \"BufferStack[\" + size + \"]\";\n+        return \"BufferStack[\" + byteSize + \"]\";\n@@ -79,11 +101,1 @@\n-    @Override\n-    public int hashCode() {\n-        return System.identityHashCode(this);\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        return this == obj;\n-    }\n-\n-    private record PerThread(ReentrantLock lock, SlicingAllocator stack, Arena arena) {\n+    private record PerThread(ReentrantLock lock, Arena arena, SlicingAllocator stack) {\n@@ -105,1 +117,1 @@\n-        static PerThread of(long size) {\n+        static PerThread of(long byteSize, long byteAlignment) {\n@@ -107,2 +119,3 @@\n-            final SlicingAllocator stack = new SlicingAllocator(arena.allocate(size));\n-            return new PerThread(new ReentrantLock(), stack, arena);\n+            return new PerThread(new ReentrantLock(),\n+                    arena,\n+                    new SlicingAllocator(arena.allocate(byteSize, byteAlignment)));\n@@ -125,1 +138,11 @@\n-                frame = new SlicingAllocator(frameSegment.reinterpret(confinedArena, null));\n+                \/\/ The cleanup action will keep the original automatic `arena` (from which\n+                \/\/ the reusable segment is first allocated) alive even if this Frame\n+                \/\/ becomes unreachable but there are reachable segments still alive.\n+                frame = new SlicingAllocator(frameSegment.reinterpret(confinedArena, new CleanupAction(arena)));\n+            }\n+\n+            record CleanupAction(Arena arena) implements Consumer<MemorySegment> {\n+                @Override\n+                public void accept(MemorySegment memorySegment) {\n+                    Reference.reachabilityFence(arena);\n+                }\n@@ -138,4 +161,2 @@\n-                \/\/ Make sure we are on the right thread\n-                if (((MemorySessionImpl) scope()).ownerThread() != Thread.currentThread()) {\n-                    throw MemorySessionImpl.wrongThread();\n-                }\n+                \/\/ Make sure we are on the right thread and not closed\n+                MemorySessionImpl.toMemorySession(confinedArena).checkValidState();\n@@ -163,1 +184,0 @@\n-                Reference.reachabilityFence(arena);\n@@ -168,3 +188,3 @@\n-    public static BufferStack of(long size) {\n-        if (size < 0) {\n-            throw new IllegalArgumentException(\"Size is negative: \" + size);\n+    public static BufferStack of(long byteSize, long byteAlignment) {\n+        if (byteSize < 0) {\n+            throw new IllegalArgumentException(\"Negative byteSize: \" + byteSize);\n@@ -172,6 +192,8 @@\n-        return new BufferStack(size, new CarrierThreadLocal<>() {\n-            @Override\n-            protected BufferStack.PerThread initialValue() {\n-                return BufferStack.PerThread.of(size);\n-            }\n-        });\n+        if (byteAlignment < 0) {\n+            throw new IllegalArgumentException(\"Negative byteAlignment: \" + byteAlignment);\n+        }\n+        return new BufferStack(byteSize, byteAlignment);\n+    }\n+\n+    public static BufferStack of(long byteSize) {\n+        return new BufferStack(byteSize, 1);\n@@ -181,6 +203,2 @@\n-        Objects.requireNonNull(layout);\n-        \/\/ Allocations are always at least aligned with the largest Java type (e.g., long)\n-        long size = layout.byteAlignment() > JAVA_LONG.byteSize()\n-                ? Utils.alignUp(layout.byteSize(), layout.byteAlignment())\n-                : layout.byteSize();\n-        return of(size);\n+        \/\/ Implicit null check\n+        return of(layout.byteSize(), layout.byteAlignment());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/BufferStack.java","additions":65,"deletions":47,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -394,1 +394,1 @@\n-    private static final BufferStack LINKER_STACK = BufferStack.of(LINKER_STACK_SIZE);\n+    private static final BufferStack LINKER_STACK = BufferStack.of(LINKER_STACK_SIZE, 1);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,2 +59,4 @@\n-        var ex = assertThrows(IllegalArgumentException.class, () -> BufferStack.of(-1));\n-        assertEquals(\"Size is negative: -1\", ex.getMessage());\n+        var exBS = assertThrows(IllegalArgumentException.class, () -> BufferStack.of(-1, 1));\n+        assertEquals(\"Negative byteSize: -1\", exBS.getMessage());\n+        var exBA = assertThrows(IllegalArgumentException.class, () -> BufferStack.of(1, -1));\n+        assertEquals(\"Negative byteAlignment: -1\", exBA.getMessage());\n@@ -63,1 +65,1 @@\n-        BufferStack stack = BufferStack.of(POOL_SIZE);\n+        BufferStack stack = newBufferStack();\n@@ -81,2 +83,1 @@\n-        BufferStack stack = BufferStack.of(stackSize);\n-        MemorySegment stackSegment;\n+        BufferStack stack = newBufferStack();\n@@ -89,1 +90,0 @@\n-            stackSegment = segment11.reinterpret(stackSize);\n@@ -124,1 +124,1 @@\n-                assertTrue(outOfStack.asOverlappingSlice(stackSegment).isEmpty());\n+                assertTrue(outOfStack.asOverlappingSlice(segment11).isEmpty());\n@@ -172,2 +172,2 @@\n-        var first = BufferStack.of(POOL_SIZE);\n-        var second = BufferStack.of(POOL_SIZE);\n+        var first = newBufferStack();\n+        var second = newBufferStack();\n@@ -181,1 +181,1 @@\n-        var pool = BufferStack.of(POOL_SIZE);\n+        var pool = newBufferStack();\n@@ -192,1 +192,3 @@\n-                assertNotEquals(firstAddress, segmentTwo.address());\n+                assertEquals(firstAddress + JAVA_INT.byteSize(), segmentTwo.address());\n+                \/\/ Questionable exception type\n+                assertThrows(IndexOutOfBoundsException.class, () -> arena.allocate(JAVA_INT));\n@@ -196,1 +198,0 @@\n-\n@@ -202,19 +203,0 @@\n-    @Test\n-    void allocationCaptureStateLayout() {\n-        var layout = Linker.Option.captureStateLayout();\n-        var pool = BufferStack.of(layout);\n-        long firstAddress;\n-        try (var arena = pool.pushFrame(layout)) {\n-            var segment = arena.allocate(layout);\n-            firstAddress = segment.address();\n-        }\n-        for (int i = 0; i < 10; i++) {\n-            try (var arena = pool.pushFrame(layout)) {\n-                var segment = arena.allocate(layout);\n-                assertEquals(firstAddress, segment.address());\n-                \/\/ Questionable exception type\n-                assertThrows(IndexOutOfBoundsException.class, () -> arena.allocate(layout));\n-            }\n-        }\n-    }\n-\n@@ -223,1 +205,1 @@\n-        var pool = BufferStack.of(POOL_SIZE);\n+        var pool = newBufferStack();\n@@ -241,1 +223,1 @@\n-        var pool = BufferStack.of(POOL_SIZE);\n+        var pool = newBufferStack();\n@@ -266,1 +248,1 @@\n-        BufferStack stack = BufferStack.of(POOL_SIZE);\n+        BufferStack stack = newBufferStack();\n@@ -270,0 +252,19 @@\n+    @Test\n+    void allocBounds() {\n+        BufferStack stack = newBufferStack();\n+        try (var arena = stack.pushFrame(SMALL_ALLOC_SIZE, 1)) {\n+            assertThrows(IllegalArgumentException.class, () -> arena.allocate(-1));\n+            assertDoesNotThrow(() -> arena.allocate(SMALL_ALLOC_SIZE));\n+            assertThrows(IndexOutOfBoundsException.class, () -> arena.allocate(SMALL_ALLOC_SIZE + 1));\n+        }\n+    }\n+\n+    @Test\n+    void accessBounds() {\n+        BufferStack stack = newBufferStack();\n+        try (var arena = stack.pushFrame(SMALL_ALLOC_SIZE, 1)) {\n+            var segment = arena.allocate(SMALL_ALLOC_SIZE);\n+            assertThrows(IndexOutOfBoundsException.class, () -> segment.get(JAVA_BYTE, SMALL_ALLOC_SIZE));\n+        }\n+    }\n+\n@@ -281,0 +282,5 @@\n+    private static BufferStack newBufferStack() {\n+        return BufferStack.of(POOL_SIZE, 1);\n+    }\n+\n+\n","filename":"test\/jdk\/java\/foreign\/TestBufferStack.java","additions":40,"deletions":34,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run junit\/othervm --enable-native-access=ALL-UNNAMED TestBufferStackStress\n+ * @run junit TestBufferStackStress\n@@ -44,1 +44,1 @@\n-public class TestBufferStackStress extends NativeTestHelper {\n+public class TestBufferStackStress {\n@@ -48,1 +48,1 @@\n-        BufferStack stack = BufferStack.of(256);\n+        BufferStack stack = BufferStack.of(256, 1);\n","filename":"test\/jdk\/java\/foreign\/TestBufferStackStress.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @library \/test\/lib\n@@ -29,1 +28,1 @@\n- * @run junit\/othervm --enable-native-access=ALL-UNNAMED TestBufferStackStress2\n+ * @run junit TestBufferStackStress2\n@@ -45,1 +44,3 @@\n-final class TestBufferStackStress2 extends NativeTestHelper {\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestBufferStackStress2 {\n@@ -65,1 +66,1 @@\n-        var pool = BufferStack.of(POOL_SIZE);\n+        var pool = BufferStack.of(POOL_SIZE, 1);\n@@ -70,0 +71,1 @@\n+        var completed = new AtomicBoolean();\n@@ -98,1 +100,1 @@\n-                    segment.get(ValueLayout.JAVA_BYTE, i);\n+                    segment.get(ValueLayout.JAVA_BYTE, i % SMALL_ALLOC_SIZE);\n@@ -103,0 +105,1 @@\n+            completed.set(true);\n@@ -122,0 +125,1 @@\n+        assertTrue(completed.get(), \"The VT did not complete properly\");\n","filename":"test\/jdk\/java\/foreign\/TestBufferStackStress2.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -76,2 +76,3 @@\n-    Arena arena = Arena.ofConfined();\n-    MemorySegment point = arena.allocate(POINT_LAYOUT);\n+    private static final Arena arena = Arena.ofConfined();\n+    private static final MemorySegment point = arena.allocate(POINT_LAYOUT);\n+    private static final SegmentAllocator BY_VALUE_ALLOCATOR = (SegmentAllocator) (_, _) -> point;\n@@ -87,2 +88,1 @@\n-        MemorySegment unused = (MemorySegment) MH_UNIT_BY_VALUE.invokeExact(\n-                (SegmentAllocator) (_, _) -> point);\n+        MemorySegment unused = (MemorySegment) MH_UNIT_BY_VALUE.invokeExact(BY_VALUE_ALLOCATOR);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadByValue.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}