{"files":[{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.misc.CarrierThreadLocal;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.ref.Reference;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+\/**\n+ * A buffer stack that allows efficient reuse of memory segments. This is useful in cases\n+ * where temporary memory is needed.\n+ * <p>\n+ * Use the factory {@link #of(long)} to create new instances of this class.\n+ * <p>\n+ * Note: The reused segments are neither zeroed out before nor after re-use.\n+ *\/\n+public record BufferStack(long size, CarrierThreadLocal<PerThread> tl) {\n+\n+    \/**\n+     * {@return a new Arena that tries to provided {@code size} and {@code byteAlignment}\n+     * allocations by recycling the BufferStacks internal memory}\n+     *\n+     * @param size          to be reserved from this BufferStacks internal memory\n+     * @param byteAlignment to be used for reservation\n+     *\/\n+    @ForceInline\n+    public Arena pushFrame(long size, long byteAlignment) {\n+        return tl.get().pushFrame(size, byteAlignment);\n+    }\n+\n+    private record PerThread(ReentrantLock lock, SlicingAllocator stack, Arena arena) {\n+\n+        @ForceInline\n+        public Arena pushFrame(long size, long byteAlignment) {\n+            boolean needsLock = Thread.currentThread().isVirtual() && !lock.isHeldByCurrentThread();\n+            if (needsLock && !lock.tryLock()) {\n+                \/\/ Rare: another virtual thread on the same carrier competed for acquisition.\n+                return Arena.ofConfined();\n+            }\n+            if (!stack.canAllocate(size, byteAlignment)) {\n+                if (needsLock) lock.unlock();\n+                return Arena.ofConfined();\n+            }\n+            return new Frame(needsLock, size, byteAlignment);\n+        }\n+\n+        static PerThread of(long size) {\n+            final Arena arena = Arena.ofAuto();\n+            final SlicingAllocator stack = new SlicingAllocator(arena.allocate(size));\n+            return new PerThread(new ReentrantLock(), stack, arena);\n+        }\n+\n+        private final class Frame implements Arena {\n+            private final boolean locked;\n+            private final long parentOffset;\n+            private final long topOfStack;\n+            private final Arena scope = Arena.ofConfined();\n+            private final SegmentAllocator frame;\n+\n+            @SuppressWarnings(\"restricted\")\n+            @ForceInline\n+            public Frame(boolean locked, long byteSize, long byteAlignment) {\n+                this.locked = locked;\n+                parentOffset = stack.currentOffset();\n+                MemorySegment frameSegment = stack.allocate(byteSize, byteAlignment);\n+                topOfStack = stack.currentOffset();\n+                frame = new SlicingAllocator(frameSegment.reinterpret(scope, null));\n+            }\n+\n+            @ForceInline\n+            private void assertOrder() {\n+                if (topOfStack != stack.currentOffset())\n+                    throw new IllegalStateException(\"Out of order access: frame not top-of-stack\");\n+            }\n+\n+            @ForceInline\n+            @Override\n+            @SuppressWarnings(\"restricted\")\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                return frame.allocate(byteSize, byteAlignment);\n+            }\n+\n+            @Override\n+            public MemorySegment.Scope scope() {\n+                return scope.scope();\n+            }\n+\n+            @ForceInline\n+            @Override\n+            public void close() {\n+                assertOrder();\n+                scope.close();\n+                stack.resetTo(parentOffset);\n+                if (locked) {\n+                    lock.unlock();\n+                }\n+                Reference.reachabilityFence(arena);\n+            }\n+        }\n+    }\n+\n+    public static BufferStack of(long size) {\n+        return new BufferStack(size, new CarrierThreadLocal<>() {\n+            @Override\n+            protected BufferStack.PerThread initialValue() {\n+                return BufferStack.PerThread.of(size);\n+            }\n+        });\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/BufferStack.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,16 @@\n+    public long currentOffset() {\n+        return sp;\n+    }\n+\n+    public void resetTo(long offset) {\n+        if (offset < 0 || offset > sp)\n+            throw new IllegalArgumentException(String.format(\"offset %d should be in [0, %d] \", offset, sp));\n+        this.sp = offset;\n+    }\n+\n+    public boolean canAllocate(long byteSize, long byteAlignment) {\n+        long min = segment.address();\n+        long start = Utils.alignUp(min + sp, byteAlignment) - min;\n+        return start + byteSize <= segment.byteSize();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SlicingAllocator.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.internal.access.JavaLangAccess;\n@@ -30,0 +29,1 @@\n+import jdk.internal.foreign.BufferStack;\n@@ -393,14 +393,2 @@\n-    public static Arena newBoundedArena(long size) {\n-        return new Arena() {\n-            final Arena arena = Arena.ofConfined();\n-            final SegmentAllocator slicingAllocator = SegmentAllocator.slicingAllocator(arena.allocate(size));\n-\n-            @Override\n-            public Scope scope() {\n-                return arena.scope();\n-            }\n-\n-            @Override\n-            public void close() {\n-                arena.close();\n-            }\n+    private static final int LINKER_STACK_SIZE = Integer.getInteger(\"jdk.internal.foreign.LINKER_STACK_SIZE\", 256);\n+    private static final BufferStack LINKER_STACK = BufferStack.of(LINKER_STACK_SIZE);\n@@ -408,5 +396,3 @@\n-            @Override\n-            public MemorySegment allocate(long byteSize, long byteAlignment) {\n-                return slicingAllocator.allocate(byteSize, byteAlignment);\n-            }\n-        };\n+    @ForceInline\n+    public static Arena newBoundedArena(long size) {\n+        return LINKER_STACK.pushFrame(size, 8);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":6,"deletions":20,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -787,0 +787,2 @@\n+java\/foreign\/TestBufferStackStress.java                         8350455 macosx-all\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.foreign\n+ * @build NativeTestHelper TestBufferStack\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestBufferStack\n+ *\/\n+\n+import jdk.internal.foreign.BufferStack;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.invoke.MethodHandle;\n+\n+import static java.lang.foreign.MemoryLayout.structLayout;\n+import static java.lang.foreign.ValueLayout.*;\n+\n+public class TestBufferStack extends NativeTestHelper {\n+    @Test\n+    public void testScopedAllocation() {\n+        int stackSize = 128;\n+        BufferStack stack = BufferStack.of(stackSize);\n+        MemorySegment stackSegment;\n+        try (Arena frame1 = stack.pushFrame(3 * JAVA_INT.byteSize(), JAVA_INT.byteAlignment())) {\n+            \/\/ Segments have expected sizes and are accessible and allocated consecutively in the same scope.\n+            MemorySegment segment11 = frame1.allocate(JAVA_INT);\n+            Assert.assertEquals(segment11.scope(), frame1.scope());\n+            Assert.assertEquals(segment11.byteSize(), JAVA_INT.byteSize());\n+            segment11.set(JAVA_INT, 0, 1);\n+            stackSegment = segment11.reinterpret(stackSize);\n+\n+            MemorySegment segment12 = frame1.allocate(JAVA_INT);\n+            Assert.assertEquals(segment12.address(), segment11.address() + JAVA_INT.byteSize());\n+            Assert.assertEquals(segment12.byteSize(), JAVA_INT.byteSize());\n+            Assert.assertEquals(segment12.scope(), frame1.scope());\n+            segment12.set(JAVA_INT, 0, 1);\n+\n+            MemorySegment segment2;\n+            try (Arena frame2 = stack.pushFrame(JAVA_LONG.byteSize(), JAVA_LONG.byteAlignment())) {\n+                Assert.assertNotEquals(frame2.scope(), frame1.scope());\n+                \/\/ same here, but a new scope.\n+                segment2 = frame2.allocate(JAVA_LONG);\n+                Assert.assertEquals(segment2.address(), segment12.address() + \/*segment12 size + frame 1 spare + alignment constraint*\/ 3 * JAVA_INT.byteSize());\n+                Assert.assertEquals(segment2.byteSize(), JAVA_LONG.byteSize());\n+                Assert.assertEquals(segment2.scope(), frame2.scope());\n+                segment2.set(JAVA_LONG, 0, 1);\n+\n+                \/\/ Frames must be closed in stack order.\n+                Assert.assertThrows(IllegalStateException.class, frame1::close);\n+            }\n+            \/\/ Scope is closed here, inner segments throw.\n+            Assert.assertThrows(IllegalStateException.class, () -> segment2.get(JAVA_INT, 0));\n+            \/\/ A new stack frame allocates at the same location (but different scope) as the previous did.\n+            try (Arena frame3 = stack.pushFrame(2 * JAVA_INT.byteSize(), JAVA_INT.byteAlignment())) {\n+                MemorySegment segment3 = frame3.allocate(JAVA_INT);\n+                Assert.assertEquals(segment3.scope(), frame3.scope());\n+                Assert.assertEquals(segment3.address(), segment12.address() + 2 * JAVA_INT.byteSize());\n+            }\n+\n+            \/\/ Fallback arena behaves like regular stack frame.\n+            MemorySegment outOfStack;\n+            try (Arena hugeFrame = stack.pushFrame(1024, 4)) {\n+                outOfStack = hugeFrame.allocate(4);\n+                Assert.assertEquals(outOfStack.scope(), hugeFrame.scope());\n+                Assert.assertTrue(outOfStack.asOverlappingSlice(stackSegment).isEmpty());\n+            }\n+            Assert.assertThrows(IllegalStateException.class, () -> outOfStack.get(JAVA_INT, 0));\n+\n+            \/\/ Outer segments are still accessible.\n+            segment11.get(JAVA_INT, 0);\n+            segment12.get(JAVA_INT, 0);\n+        }\n+    }\n+\n+    static {\n+        System.loadLibrary(\"TestBufferStack\");\n+    }\n+\n+    private static final MemoryLayout HVAPoint3D = structLayout(NativeTestHelper.C_DOUBLE, C_DOUBLE, C_DOUBLE);\n+    private static final MemorySegment UPCALL_MH = upcallStub(TestBufferStack.class, \"recurse\", FunctionDescriptor.of(HVAPoint3D, C_INT));\n+    private static final MethodHandle DOWNCALL_MH = downcallHandle(\"recurse\", FunctionDescriptor.of(HVAPoint3D, C_INT, ADDRESS));\n+\n+    public static MemorySegment recurse(int depth) {\n+        try {\n+            return (MemorySegment) DOWNCALL_MH.invokeExact((SegmentAllocator) Arena.ofAuto(), depth, UPCALL_MH);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Test\n+    public void testDeepStack() throws Throwable {\n+        \/\/ Each downcall and upcall require 48 bytes of stack.\n+        \/\/ After five allocations we start falling back.\n+        MemorySegment point = recurse(10);\n+        Assert.assertEquals(point.getAtIndex(C_DOUBLE, 0), 12.0);\n+        Assert.assertEquals(point.getAtIndex(C_DOUBLE, 1), 11.0);\n+        Assert.assertEquals(point.getAtIndex(C_DOUBLE, 2), 10.0);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestBufferStack.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.foreign\n+ * @build NativeTestHelper TestBufferStackStress\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestBufferStackStress\n+ *\/\n+\n+import jdk.internal.foreign.BufferStack;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.stream.IntStream;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.time.temporal.ChronoUnit.SECONDS;\n+\n+public class TestBufferStackStress extends NativeTestHelper {\n+\n+    @Test\n+    public void stress() throws InterruptedException {\n+        BufferStack stack = BufferStack.of(256);\n+        Thread[] vThreads = IntStream.range(0, 1024).mapToObj(_ ->\n+                Thread.ofVirtual().start(() -> {\n+                    long threadId = Thread.currentThread().threadId();\n+                    while (!Thread.interrupted()) {\n+                        for (int i = 0; i < 1_000_000; i++) {\n+                            try (Arena arena = stack.pushFrame(JAVA_LONG.byteSize(), JAVA_LONG.byteAlignment())) {\n+                                \/\/ Try to assert no two vThreads get allocated the same stack space.\n+                                MemorySegment segment = arena.allocate(JAVA_LONG);\n+                                JAVA_LONG.varHandle().setVolatile(segment, 0L, threadId);\n+                                Assert.assertEquals(threadId, (long) JAVA_LONG.varHandle().getVolatile(segment, 0L));\n+                            }\n+                        }\n+                        Thread.yield(); \/\/ make sure the driver thread gets a chance.\n+                    }\n+                })).toArray(Thread[]::new);\n+        Thread.sleep(Duration.of(10, SECONDS));\n+        Arrays.stream(vThreads).forEach(\n+                thread -> {\n+                    Assert.assertTrue(thread.isAlive());\n+                    thread.interrupt();\n+                });\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestBufferStackStress.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"export.h\"\n+\n+typedef struct { double x, y, z; } HVAPoint3D;\n+\n+EXPORT HVAPoint3D recurse(int depth, HVAPoint3D (*cb)(int)) {\n+  if (depth == 0) {\n+    HVAPoint3D result = { 2, 1, 0};\n+    return result;\n+  }\n+\n+  HVAPoint3D result = cb(depth - 1);\n+  result.x += 1;\n+  result.y += 1;\n+  result.z += 1;\n+  return result;\n+}\n","filename":"test\/jdk\/java\/foreign\/libTestBufferStack.c","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ *  Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import jdk.internal.foreign.BufferStack;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\"})\n+public class BufferStackBench {\n+\n+    @Param({\"8\", \"16\", \"32\"})\n+    public int ELEM_SIZE;\n+\n+    private BufferStack bufferStack;\n+\n+    @Setup\n+    public void setup() {\n+        bufferStack = BufferStack.of(128);\n+    }\n+\n+    @Benchmark\n+    public long confined() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            return arena.allocate(ELEM_SIZE).address();\n+        }\n+    }\n+\n+    @Benchmark\n+    public long buffer() {\n+        try (Arena arena = bufferStack.pushFrame(64, 1)) {\n+            return arena.allocate(ELEM_SIZE).address();\n+        }\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = \"-Djmh.executor=VIRTUAL\")\n+    public static class OfVirtual extends BufferStackBench {}\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BufferStackBench.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openjdk.bench.java.lang.foreign.CLayouts.C_DOUBLE;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n+public class CallOverheadByValue {\n+\n+    public static final MemoryLayout POINT_LAYOUT = MemoryLayout.structLayout(\n+            C_DOUBLE, C_DOUBLE\n+    );\n+    private static final MethodHandle MH_UNIT_BY_VALUE;\n+    private static final MethodHandle MH_UNIT_BY_PTR;\n+\n+    static {\n+        Linker abi = Linker.nativeLinker();\n+        System.loadLibrary(\"CallOverheadByValue\");\n+        SymbolLookup loaderLibs = SymbolLookup.loaderLookup();\n+        MH_UNIT_BY_VALUE = abi.downcallHandle(\n+                loaderLibs.findOrThrow(\"unit\"),\n+                FunctionDescriptor.of(POINT_LAYOUT)\n+        );\n+        MH_UNIT_BY_PTR = abi.downcallHandle(\n+                loaderLibs.findOrThrow(\"unit_ptr\"),\n+                FunctionDescriptor.ofVoid(ValueLayout.ADDRESS)\n+        );\n+    }\n+\n+    Arena arena = Arena.ofConfined();\n+    MemorySegment point = arena.allocate(POINT_LAYOUT);\n+\n+    @TearDown\n+    public void tearDown() {\n+        arena.close();\n+    }\n+\n+    @Benchmark\n+    public void byValue() throws Throwable {\n+        \/\/ point = unit();\n+        MemorySegment unused = (MemorySegment) MH_UNIT_BY_VALUE.invokeExact(\n+                (SegmentAllocator) (_, _) -> point);\n+    }\n+\n+    @Benchmark\n+    public void byPtr() throws Throwable {\n+        \/\/ unit_ptr(&point);\n+        MH_UNIT_BY_PTR.invokeExact(point);\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = \"-Djmh.executor=VIRTUAL\")\n+    public static class OfVirtual extends CallOverheadByValue {}\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadByValue.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"export.h\"\n+\n+typedef struct {\n+    double x;\n+    double y;\n+} DoublePoint;\n+\n+EXPORT DoublePoint unit() {\n+    DoublePoint result = { 1, 0 };\n+    return result;\n+}\n+\n+EXPORT void unit_ptr(DoublePoint* out) {\n+  *out = unit();\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libCallOverheadByValue.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"}]}