{"files":[{"patch":"@@ -27,0 +27,1 @@\n+#include \"logging\/log.hpp\"\n@@ -37,1 +38,3 @@\n-                                               const RegionData& metadata) {\n+                                               const RegionData& metadata, bool use_tag_inplace) {\n+  assert(!use_tag_inplace || metadata.mem_tag == mtNone,\n+         \"If using use_tag_inplace, then the supplied tag should be mtNone, was instead: %s\", NMTUtil::tag_to_name(metadata.mem_tag));\n@@ -58,0 +61,4 @@\n+    assert(!use_tag_inplace, \"Cannot use the tag inplace if no pre-existing tag exists. From: \" PTR_FORMAT \" To: \" PTR_FORMAT, A, B);\n+    if (use_tag_inplace) {\n+      log_debug(nmt)(\"Cannot use the tag inplace if no pre-existing tag exists. From: \" PTR_FORMAT \" To: \" PTR_FORMAT, A, B);\n+    }\n@@ -65,0 +72,11 @@\n+    StateType leqA_state = leqA_n->val().out.type();\n+    StateType new_state = stA.out.type();\n+    \/\/ If we specify use_tag_inplace then the new region takes over the current tag instead of the tag in metadata.\n+    \/\/ This is important because the VirtualMemoryTracker API doesn't require supplying the tag for some operations.\n+    if (use_tag_inplace) {\n+      assert(leqA_n->val().out.type() != StateType::Released, \"Should not use inplace the tag of a released region\");\n+      MemTag tag = leqA_n->val().out.mem_tag();\n+      stA.out.set_tag(tag);\n+      stB.in.set_tag(tag);\n+    }\n+\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  \/\/ Each point has some stack and a flag associated with it.\n+  \/\/ Each point has some stack and a tag associated with it.\n@@ -91,1 +91,1 @@\n-    uint8_t type_flag[2];\n+    uint8_t type_tag[2];\n@@ -95,1 +95,1 @@\n-    IntervalState() : type_flag{0,0}, sidx() {}\n+    IntervalState() : type_tag{0,0}, sidx() {}\n@@ -98,2 +98,2 @@\n-      type_flag[0] = static_cast<uint8_t>(type);\n-      type_flag[1] = static_cast<uint8_t>(data.mem_tag);\n+      type_tag[0] = static_cast<uint8_t>(type);\n+      type_tag[1] = static_cast<uint8_t>(data.mem_tag);\n@@ -104,1 +104,1 @@\n-      return static_cast<StateType>(type_flag[0]);\n+      return static_cast<StateType>(type_tag[0]);\n@@ -108,1 +108,1 @@\n-      return static_cast<MemTag>(type_flag[1]);\n+      return static_cast<MemTag>(type_tag[1]);\n@@ -115,0 +115,4 @@\n+    void set_tag(MemTag tag) {\n+      type_tag[1] = static_cast<uint8_t>(tag);\n+    }\n+\n@@ -170,1 +174,2 @@\n-  SummaryDiff register_mapping(position A, position B, StateType state, const RegionData& metadata);\n+ private:\n+  SummaryDiff register_mapping(position A, position B, StateType state, const RegionData& metadata, bool use_tag_inplace = false);\n@@ -172,0 +177,1 @@\n+ public:\n@@ -173,1 +179,5 @@\n-    return register_mapping(from, from + sz, StateType::Reserved, metadata);\n+    return register_mapping(from, from + sz, StateType::Reserved, metadata, false);\n+  }\n+\n+  SummaryDiff commit_mapping(position from, position sz, const RegionData& metadata, bool use_tag_inplace = false) {\n+    return register_mapping(from, from + sz, StateType::Committed, metadata, use_tag_inplace);\n@@ -176,2 +186,2 @@\n-  SummaryDiff commit_mapping(position from, position sz, const RegionData& metadata) {\n-    return register_mapping(from, from + sz, StateType::Committed, metadata);\n+  SummaryDiff uncommit_mapping(position from, position sz, const RegionData& metadata) {\n+    return register_mapping(from, from + sz, StateType::Reserved, metadata, true);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -174,1 +174,0 @@\n-\n@@ -184,0 +183,17 @@\n+TEST_VM_F(NMTVMATreeTest, UseFlagInplace) {\n+  Tree tree;\n+  VMATree::RegionData rd1(si[0], mtTest);\n+  VMATree::RegionData rd2(si[1], mtNone);\n+  tree.reserve_mapping(0, 100, rd1);\n+  tree.commit_mapping(20, 50, rd2, true);\n+  tree.uncommit_mapping(30, 10, rd2);\n+  tree.visit_in_order([&](Node* node) {\n+    if (node->key() != 100) {\n+      EXPECT_EQ(mtTest, node->val().out.mem_tag()) << \"failed at: \" << node->key();\n+      if (node->key() != 20 && node->key() != 40) {\n+        EXPECT_EQ(VMATree::StateType::Reserved, node->val().out.type());\n+      }\n+    }\n+  });\n+}\n+\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"}]}