{"files":[{"patch":"@@ -38,0 +38,2 @@\n+  assert(!copy_flag || metadata.flag == mtNone,\n+         \"If copying flag then supplied flag should be mtNone, was instead: %s\", NMTUtil::flag_to_name(metadata.flag));\n@@ -58,0 +60,4 @@\n+    assert(!copy_flag, \"Cannot copy the flag if no pre-existing flag exists. From: \" PTR_FORMAT \" To: \" PTR_FORMAT, A, B);\n+    if (copy_flag) {\n+      log_debug(nmt)(\"Cannot copy the flag if no pre-existing flag exists. From: \" PTR_FORMAT \" To: \" PTR_FORMAT, A, B);\n+    }\n@@ -67,68 +73,2 @@\n-    \/\/ Table of states and copy_flag permutations. '..' means 'the same as above line'.\n-    \/\/   #  leqA_state new_state  copy_flag   meaning                                 comments                    visibility   VMATree::xxx()\n-    \/\/   1  Reserved   Reserved     true      re-reserving a region                    ?                             private    register_mapping\n-    \/\/   2  Committed     ..         ..       uncommitting a committed region          OK                            private        ..\n-    \/\/   3  Released      ..         ..       reserving a released region              invalid mapping request       private        ..\n-    \/\/   4  Reserved   Committed     ..       committing a reserved region             OK                            public     commit_mapping\n-    \/\/   5  Committed     ..         ..       re-committing a region                   OK                            public         ..\n-    \/\/   6  Released      ..         ..       committing a non-reserved region         invalid mapping request       public         ..\n-    \/\/   7  Reserved   Released      ..       releasing a reserved region              invalid mapping request       private    register_mapping\n-    \/\/   8  Committed     ..         ..       releasing a committed region             invalid mapping request       private        ..\n-    \/\/   9  Released      ..         ..       re-releasing a region                    ?                             private        ..\n-    \/\/  10  Reserved   Reserved     false     re-reserving a region                    split a reserved region       public     reserve_mapping\n-    \/\/  11  Committed     ..         ..       uncommitting a region                    Error                         public         ..\n-    \/\/  12  Released      ..         ..       reserving a released region              OK                            public         ..\n-    \/\/  13  Reserved   Committed     ..       committing a reserved ergion             OK                            public     commit_mapping\n-    \/\/  14  Committed     ..         ..       re-committing a region                   flags should match            public         ..\n-    \/\/  15  Released      ..         ..       committing a non-reserved region         invalid mapping request       public         ..\n-    \/\/  16  Reserved   Released      ..       releasing a reserved region              OK                            private    register_mapping\n-    \/\/  17  Committed     ..         ..       releasing w\/out uncommitting a region    OK                            private        ..\n-    \/\/  18  Released      ..         ..       re-releasing a region                    OK                            private        ..\n-\n-\n-    static int count_6 = 0;\n-    static int count_11 = 0;\n-    static int count_14 = 0;\n-    auto notify = [&](int row_no, const char* str) -> bool {\n-      if (row_no == 6 || row_no == 11 || row_no == 14) {\n-        if (row_no == 6)  { if (count_6++) return true; }\n-        if (row_no == 11) { if (count_11++) return true; }\n-        if (row_no == 14) { if (count_14++) return true; }\n-        tty->print_cr(\"new region \" SIZE_FORMAT \"-\" SIZE_FORMAT, (size_t)A, (size_t)B);\n-        tty->print_cr(\"leqA node \" SIZE_FORMAT \", flag: %d\", (size_t)leqA_n->key(), (int)leqA_n->val().out.flag());\n-        warning(\"%s\", str);\n-        return true;\n-      } else {\n-        fatal(\"%s\", str);\n-        return false;\n-      }\n-      return false;\n-    };\n-    VMATree::SummaryDiff invalid_diff(-1);\n-    if (leqA_state == StateType::Released && new_state == StateType::Reserved && copy_flag) { \/\/ row #3\n-      if (!notify(3, \"Reserving a released region and requesting to copy the flag\") )\n-        return invalid_diff;\n-    }\n-    if (leqA_state == StateType::Released && new_state == StateType::Committed) { \/\/ rows #6 and #15\n-      if (!notify(6, \"Committing a non-reserved region\"))\n-        return invalid_diff;\n-    }\n-    if ((leqA_state == StateType::Reserved || leqA_state == StateType::Committed) &&  \/\/ rows #7 and #8\n-         new_state == StateType::Released && copy_flag) {\n-      if (!notify(7, \"Releasing a region and requesting to copy the flag\"))\n-        return invalid_diff;\n-    }\n-    if (leqA_state == StateType::Committed && new_state == StateType::Reserved && !copy_flag) { \/\/ row #11\n-      if (!notify(11, \"Reserving a committed region is requested\"))\n-        return invalid_diff;\n-    }\n-    if (leqA_state == StateType::Committed && new_state == StateType::Committed && !copy_flag) { \/\/ row #14\n-      if (leqA_n->val().out.flag() != stA.out.flag()) {\n-        if (!notify(14, \"Re-committing a region with a different flag\"))\n-          return invalid_diff;\n-      }\n-    }\n-    if (new_state == StateType::Released && stA.out.flag() != mtNone) {\n-      if (!notify(0, \"Releasng a region with a not mtNone flag\"))\n-      return invalid_diff;\n-    }\n+    \/\/ If we specify copy_flag then the new region takes over the current flag instead of the flag in metadata.\n+    \/\/ This is important because the VirtualMemoryTracker API doesn't require supplying the flag for some operations.\n@@ -136,0 +76,1 @@\n+      assert(leqA_n->val().out.type() != StateType::Released, \"Should not copy flag of a released region\");\n@@ -140,0 +81,1 @@\n+\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":10,"deletions":68,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-      type_flag[1] = (uint8_t)flag;\n+      type_flag[1] = static_cast<uint8_t>(flag);\n@@ -118,1 +118,2 @@\n-    const NativeCallStackStorage::StackIndex stack() const {\n+\n+    NativeCallStackStorage::StackIndex stack() const {\n@@ -171,15 +172,0 @@\n-    SummaryDiff(int invalid_amount) {\n-      for (int i = 0; i < mt_number_of_types; i++) {\n-        flag[i] = SingleDiff{invalid_amount, invalid_amount};\n-      }\n-    }\n-\n-    bool is_valid(int invalid_amount = -1) {\n-      for (int i = 0; i < mt_number_of_types; i++) {\n-        if (flag[i].reserve != invalid_amount)\n-          return true;\n-        if (flag[i].commit != invalid_amount)\n-          return true;\n-      }\n-      return false;\n-    }\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -171,31 +171,0 @@\n-\n-  void copy_flag_test() {\n-    {\n-      Tree tree;\n-      VMATree::RegionData rd1{ si[0], mtTest };\n-      VMATree::RegionData rd2{ si[1], mtNMT };\n-\n-      tree.reserve_mapping(0, 100, rd1);\n-      tree.commit_mapping(20, 50, rd2, true); \/\/ mtTest flag is to be copied to new nodes, even if it is given as mtNMT.\n-      tree.uncommit_mapping(30, 10, rd2);\/\/ same here.\n-      tree.visit_in_order([&](Node* node) {\n-        if ((size_t)node->key() != 100) {\n-          EXPECT_EQ(node->val().out.flag(), mtTest) << \"failed at: \" << node->key();\n-        }\n-      });\n-    }\n-    {\n-      Tree tree;\n-      VMATree::RegionData rd1{ si[0], mtTest };\n-      VMATree::RegionData rd2{ si[1], mtNMT };\n-\n-      tree.reserve_mapping(0, 10, rd1);\n-      tree.reserve_mapping(10000, 10, rd2);\n-      tree.visit_in_order([&](Node* node) {\n-        if ((size_t)node->key() == 0    ) { EXPECT_EQ(node->val().out.flag(), mtTest) << \"failed at: \" << node->key(); }\n-        if ((size_t)node->key() == 10   ) { EXPECT_EQ(node->val().in.flag(),  mtTest) << \"failed at: \" << node->key(); }\n-        if ((size_t)node->key() == 10000) { EXPECT_EQ(node->val().out.flag(), mtNMT)  << \"failed at: \" << node->key(); }\n-        if ((size_t)node->key() == 10010) { EXPECT_EQ(node->val().in.flag(),  mtNMT)  << \"failed at: \" << node->key(); }\n-      });\n-    }\n-  }\n@@ -205,1 +174,0 @@\n-\n@@ -215,0 +183,14 @@\n+TEST_VM_F(NMTVMATreeTest, CopyFlag) {\n+  Tree tree;\n+  VMATree::RegionData rd1(si[0], mtTest);\n+  VMATree::RegionData rd2(si[1], mtNone);\n+  tree.reserve_mapping(0, 100, rd1);\n+  tree.commit_mapping(20, 50, rd2, true);\n+  tree.uncommit_mapping(30, 10, rd2);\n+  tree.visit_in_order([&](Node* node) {\n+    if (node->key() != 100) {\n+      EXPECT_EQ(mtTest, node->val().out.flag()) << \"failed at: \" << node->key();\n+    }\n+  });\n+}\n+\n@@ -227,1 +209,0 @@\n-  copy_flag_test();\n@@ -366,1 +347,0 @@\n-    tree.reserve_mapping(0, 1024, rd);\n@@ -371,1 +351,1 @@\n-    EXPECT_EQ(0, diff.flag[NMTUtil::flag_to_index(mtTest)].reserve);\n+    EXPECT_EQ(768, diff.flag[NMTUtil::flag_to_index(mtTest)].reserve);\n@@ -502,2 +482,0 @@\n-      tree_diff = tree.reserve_mapping(start, size, data);\n-      if (!tree_diff.is_valid()) { i--; continue; }\n@@ -505,0 +483,1 @@\n+      tree_diff = tree.reserve_mapping(start, size, data);\n@@ -506,2 +485,0 @@\n-      tree_diff = tree.commit_mapping(start, size, data);\n-      if (!tree_diff.is_valid()) { i--; continue; }\n@@ -509,0 +486,1 @@\n+      tree_diff = tree.commit_mapping(start, size, data);\n@@ -510,2 +488,0 @@\n-      tree_diff = tree.release_mapping(start, size);\n-      if (!tree_diff.is_valid()) { i--; continue; }\n@@ -513,0 +489,1 @@\n+      tree_diff = tree.release_mapping(start, size);\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":18,"deletions":41,"binary":false,"changes":59,"status":"modified"}]}