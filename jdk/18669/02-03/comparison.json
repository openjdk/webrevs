{"files":[{"patch":"@@ -78,1 +78,0 @@\n-  _line_no = 0;\n@@ -176,1 +175,0 @@\n-        \/\/ Don't try to print the input line that we already know is too long.\n@@ -179,1 +177,1 @@\n-        error(\"Input line too long\"); \/\/ will exit JVM\n+        error(\"Out of memory\"); \/\/ will exit JVM\n@@ -183,1 +181,0 @@\n-    ++ _line_no;\n@@ -296,1 +293,1 @@\n-    error(\"Too few items following the @ tag \\\"%s\\\" line #%d\", _line, _line_no);\n+    error(\"Too few items following the @ tag \\\"%s\\\" line #%d\", _line, _line_reader.line_num());\n@@ -314,1 +311,1 @@\n-      error(\"Line with @ tag has too few items \\\"%s\\\" line #%d\", _token, _line_no);\n+      error(\"Line with @ tag has too few items \\\"%s\\\" line #%d\", _token, _line_reader.line_num());\n@@ -325,1 +322,1 @@\n-    error(\"Invalid @ tag at the beginning of line \\\"%s\\\" line #%d\", _token, _line_no);\n+    error(\"Invalid @ tag at the beginning of line \\\"%s\\\" line #%d\", _token, _line_reader.line_num());\n@@ -434,1 +431,1 @@\n-              _classlist_file, _line_no, (error_index + 1));\n+              _classlist_file, _line_reader.line_num(), (error_index + 1));\n@@ -462,1 +459,2 @@\n-  if (strlen(class_name) > (size_t)Symbol::max_length()) {\n+  size_t len = strlen(class_name);\n+  if (len > (size_t)Symbol::max_length()) {\n@@ -465,2 +463,2 @@\n-    int len = (int)strlen(class_name);\n-    if (!UTF8::is_legal_utf8((const unsigned char*)class_name, len, \/*version_leq_47*\/false)) {\n+    assert(Symbol::max_length() < INT_MAX && len < INT_MAX, \"must be\");\n+    if (!UTF8::is_legal_utf8((const unsigned char*)class_name, (int)len, \/*version_leq_47*\/false)) {\n@@ -473,1 +471,1 @@\n-              _classlist_file, _line_no, err);\n+              _classlist_file, _line_reader.line_num(), err);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-  int                 _line_no;               \/\/ Line number for current line being parsed\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,6 +29,2 @@\n-LineReader::LineReader() {\n-  _file = nullptr;\n-  _is_oom = false;\n-  _buffer = nullptr;\n-  _buffer_len = 0;\n-}\n+LineReader::LineReader()\n+  : _buffer(nullptr), _buffer_len(0), _line_num(0), _is_oom(false), _file(nullptr) {}\n@@ -36,4 +32,3 @@\n-LineReader::LineReader(FILE* file) {\n-  _is_oom = false;\n-  _buffer = nullptr;\n-  _buffer_len = 0;\n+LineReader::LineReader(FILE* file)\n+  : _buffer(nullptr), _buffer_len(0), _line_num(0), _is_oom(false)\n+{\n@@ -79,0 +74,1 @@\n+        ++ _line_num;\n@@ -90,1 +86,1 @@\n-    assert(line_len >= 0 && new_len >= 0 && (line_len + new_len) >= 0, \"no int overflow\");\n+    assert(line_len >= 0 && new_len >= 0 && line_len <= INT_MAX - new_len, \"no int overflow\");\n@@ -99,0 +95,1 @@\n+      ++ _line_num;\n@@ -108,0 +105,1 @@\n+        ++ _line_num;\n@@ -111,1 +109,1 @@\n-      if (new_len < _buffer_len) { \/\/ overflows int\n+      if (new_len > MAX_LEN) {\n","filename":"src\/hotspot\/share\/utilities\/lineReader.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-\/\/ possible for valid lines to be longer than this limit.\n+\/\/ possible for valid lines to be longer than this limit, as such lines\n+\/\/ would be broken up into chunks.\n@@ -40,1 +41,1 @@\n-  FILE* _file;\n+  int   _line_num;\n@@ -42,0 +43,1 @@\n+  FILE* _file;\n@@ -43,1 +45,1 @@\n-  static const int MAX_LEN = 4 * 1024 * 1024;\n+  static const int MAX_LEN = 4 * M;\n@@ -54,0 +56,6 @@\n+  \/\/ The \"line number\" of the previous (non-null) line returned by read_line().\n+  \/\/ Per Unix convention, the first line is numbered as 1.\n+  int line_num() {\n+    return _line_num;\n+  }\n+\n@@ -61,1 +69,1 @@\n-  \/\/ LineReader is destructed.\n+  \/\/ LineReader is destroyed.\n","filename":"src\/hotspot\/share\/utilities\/lineReader.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -81,0 +81,5 @@\n+\n+    \/\/ line_num() should be numbered from 1\n+    EXPECT_TRUE(lr.line_num() == i + 1)\n+      << \" line_num() should be \" << (i + 1)\n+      << \" but is \" << lr.line_num();\n","filename":"test\/hotspot\/gtest\/utilities\/test_lineReader.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+                fw.write(\"java\/lang\/Object\\n\");\n@@ -144,1 +145,1 @@\n-                .shouldContain(\"class name too long\")\n+                .shouldContain(classList + \":2 class name too long\") \/\/ test line number as well.\n@@ -169,1 +170,1 @@\n-                .shouldContain(\"class name is not valid UTF8\")\n+                .shouldContain(classList + \":1 class name is not valid UTF8\") \/\/ test line number as well.\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/ClassListFormatA.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}