{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+#include \"utilities\/utf8.hpp\"\n@@ -57,1 +58,2 @@\n-ClassListParser::ClassListParser(const char* file, ParseMode parse_mode) : _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {\n+ClassListParser::ClassListParser(const char* file, ParseMode parse_mode) :\n+    _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE), _line_reader() {\n@@ -75,0 +77,1 @@\n+  _line_reader.init(_file);\n@@ -76,1 +79,1 @@\n-  _token = _line;\n+  _token = _line = nullptr;\n@@ -115,0 +118,1 @@\n+    check_class_name(_class_name);\n@@ -169,1 +173,8 @@\n-    if (fgets(_line, sizeof(_line), _file) == nullptr) {\n+    _line = _line_reader.read_line();\n+    if (_line == nullptr) {\n+      if (_line_reader.is_oom()) {\n+        \/\/ Don't try to print the input line that we already know is too long.\n+        _token = nullptr;\n+        _line_len = 0;\n+        error(\"Input line too long\"); \/\/ will exit JVM\n+      }\n@@ -173,4 +184,0 @@\n-    _line_len = (int)strlen(_line);\n-    if (_line_len > _max_allowed_line_len) {\n-      error(\"input line too long (must be no longer than %d chars)\", _max_allowed_line_len);\n-    }\n@@ -453,0 +460,18 @@\n+void ClassListParser::check_class_name(const char* class_name) {\n+  const char* err = nullptr;\n+  if (strlen(class_name) > (size_t)Symbol::max_length()) {\n+    err = \"class name too long\";\n+  } else {\n+    int len = (int)strlen(class_name);\n+    if (!UTF8::is_legal_utf8((const unsigned char*)class_name, len, \/*version_leq_47*\/false)) {\n+      err = \"class name is not valid UTF8\";\n+    }\n+  }\n+  if (err != nullptr) {\n+    jio_fprintf(defaultStream::error_stream(),\n+              \"An error has occurred while processing class list file %s:%d %s\\n\",\n+              _classlist_file, _line_no, err);\n+    vm_exit_during_initialization(\"class list format error.\", nullptr);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":33,"deletions":8,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"utilities\/lineReader.hpp\"\n@@ -83,8 +84,0 @@\n-\n-    \/\/ Max number of bytes allowed per line in the classlist.\n-    \/\/ Theoretically Java class names could be 65535 bytes in length. Also, an input line\n-    \/\/ could have a very long path name up to JVM_MAXPATHLEN bytes in length. In reality,\n-    \/\/ 4K bytes is more than enough.\n-    _max_allowed_line_len = 4096,\n-    _line_buf_extra       = 10, \/\/ for detecting input too long\n-    _line_buf_size        = _max_allowed_line_len + _line_buf_extra\n@@ -103,3 +96,2 @@\n-  \/\/ The following field contains information from the *current* line being\n-  \/\/ parsed.\n-  char                _line[_line_buf_size];  \/\/ The buffer that holds the current line. Some characters in\n+  LineReader          _line_reader;\n+  char*               _line;                  \/\/ The buffer that holds the current line. Some characters in\n@@ -186,0 +178,1 @@\n+  void check_class_name(const char* class_name);\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/lineReader.hpp\"\n+\n+LineReader::LineReader() {\n+  _file = nullptr;\n+  _is_oom = false;\n+  _buffer = nullptr;\n+  _buffer_len = 0;\n+}\n+\n+LineReader::LineReader(FILE* file) {\n+  _is_oom = false;\n+  _buffer = nullptr;\n+  _buffer_len = 0;\n+  init(file);\n+}\n+\n+LineReader::~LineReader() {\n+  if (_buffer != nullptr) {\n+    os::free(_buffer);\n+  }\n+}\n+\n+void LineReader::init(FILE* file) {\n+  assert(file != nullptr, \"sanity\");\n+  _file = file;\n+  _buffer_len = DEBUG_ONLY(16) NOT_DEBUG(4096); \/\/ debug build: start small to test expansion logic\n+  _buffer = (char*)os::malloc(_buffer_len, mtClass);\n+  if (_buffer == nullptr) {\n+    _is_oom = true;\n+  }\n+}\n+\n+char* LineReader::read_line() {\n+  STATIC_ASSERT(0 < MAX_LEN && MAX_LEN <= INT_MAX);\n+  assert(_file != nullptr, \"must be initialized\");\n+  if (_is_oom) {\n+    return nullptr;\n+  }\n+\n+  int line_len = 0; \/\/ the number of characters we have read so far (excluding the trailing \\0)\n+  while (true) {\n+    assert(line_len < _buffer_len, \"sanity\");\n+    int available_space = _buffer_len - line_len;\n+    char* p = _buffer + line_len;\n+    int new_len = 0;\n+    if (fgets(p, available_space, _file) == nullptr) {\n+      \/\/ _file is at EOF\n+      if (line_len == 0) {\n+        return nullptr; \/\/ EOF\n+      } else {\n+        \/\/ We have read something in previous loop iteration(s). Return that.\n+        \/\/ The next call to read_line() will return nullptr to indicate EOF.\n+        return _buffer;\n+      }\n+    }\n+\n+    \/\/ fgets() reads at most available_space chars, including the trailing \\0, so\n+    \/\/ strlen(p) must be smaller than INT_MAX, and can be safely cast to int.\n+    assert(strlen(p) < INT_MAX, \"sanity\");\n+    new_len = (int)strlen(p);\n+\n+    \/\/ _buffer_len will stop at MAX_LEN, so we will never be able to read more than\n+    \/\/ MAX_LEN chars for a single input line.\n+    assert(line_len >= 0 && new_len >= 0 && (line_len + new_len) >= 0, \"no int overflow\");\n+\n+    line_len += new_len; \/\/ We have read line_len chars so far.\n+\n+    assert(line_len < _buffer_len, \"sanity\");\n+    assert(_buffer[line_len] == '\\0', \"sanity\");\n+\n+    if (_buffer[line_len - 1] == '\\n' || feof(_file)) {\n+      \/\/ We have read an entire line, or reached EOF\n+      return _buffer;\n+    }\n+\n+    if (line_len == _buffer_len - 1) {\n+      \/\/ The buffer is not big enough to hold the entire input line. Expand it.\n+      if (_buffer_len == MAX_LEN) {\n+        \/\/ Cannot expand anymore. Return the first MAX_LEN-1 bytes of input.\n+        \/\/ The behavior is exactly the same as if we had called fgets() with a\n+        \/\/ buffer whose size is MAX_LEN.\n+        return _buffer;\n+      }\n+      int new_len = _buffer_len * 2;\n+      if (new_len < _buffer_len) { \/\/ overflows int\n+        new_len = MAX_LEN;\n+      }\n+      assert(new_len > _buffer_len, \"must be\");\n+\n+      char* new_buffer = (char*)os::realloc(_buffer, new_len, mtClass);\n+      if (new_buffer == nullptr) {\n+        _is_oom = true; \/\/ oom\n+        return nullptr;\n+      } else {\n+        _buffer = new_buffer;\n+        _buffer_len = new_len;\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/utilities\/lineReader.cpp","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_LINEREADER_HPP\n+#define SHARE_UTILITIES_LINEREADER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ This class is a wrapper around fgets() for reading *reasonably long*\n+\/\/ text lines (up to LineReader::MAX_LEN-1 chars) from a FILE*.\n+\/\/\n+\/\/ MAX_LEN is currently 4M. This should be enough for any practical use\n+\/\/ of text-based input files for HotSpot. Don't use LineReader if it's\n+\/\/ possible for valid lines to be longer than this limit.\n+class LineReader : public StackObj {\n+  char* _buffer;       \/\/ The buffer that holds the value returned by read_line().\n+  int   _buffer_len;   \/\/ Max characters that can be stored in _line, including the trailing \\0;\n+  FILE* _file;\n+  bool  _is_oom;\n+public:\n+  static const int MAX_LEN = 4 * 1024 * 1024;\n+  LineReader(FILE* file);\n+  LineReader();\n+  void init(FILE* file);\n+  ~LineReader();\n+\n+  \/\/ Out of memory. See comments below.\n+  bool is_oom() {\n+    return _is_oom;\n+  }\n+\n+  \/\/ Return one line from _file, as a 0-terminated string. The length and contents of this\n+  \/\/ string are the same as those returned by a call to fgets() with a buffer that's\n+  \/\/ MAX_LEN bytes long. (Note: if the file contains a line longer than MAX_LEN-1 chars,\n+  \/\/ we'd break it up in multiple chunks, just as fgets() would).\n+  \/\/\n+  \/\/ When successful, a non-null value is returned. The caller is free to read or modify this\n+  \/\/ string (up to the terminating \\0 character) until the next call to read_line(), or until the\n+  \/\/ LineReader is destructed.\n+  \/\/\n+  \/\/ nullptr is returned if:\n+  \/\/   1. os::malloc\/os::realloc failed to allocate enough space to accommodate the input line.\n+  \/\/      When this happens, all subsequent calls to is_oom() will return true, and all\n+  \/\/      subsequent calls to read_line() will return nullptr;\n+  \/\/   2. Upon the entry of this function, _file is already at the EOF position.\n+  char* read_line();\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_LINEREADER_HPP\n","filename":"src\/hotspot\/share\/utilities\/lineReader.hpp","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"include\/jvm_io.h\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/lineReader.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ Write num_lines into filename.\n+\/\/ The i-th line has (first_len + step_size * i) chars, plus \\n\n+static FILE* get_input(const char* filename, int num_lines, int step_size, int first_len) {\n+  ResourceMark rm;\n+\n+  const char* tmp_dir = os::get_temp_directory();\n+  const char* file_sep = os::file_separator();\n+  size_t temp_file_len = strlen(tmp_dir) + strlen(file_sep) + strlen(filename) + 1;\n+  char* temp_file = NEW_RESOURCE_ARRAY(char, temp_file_len);\n+  jio_snprintf(temp_file, temp_file_len, \"%s%s%s\",\n+               tmp_dir, file_sep, filename);\n+\n+  FILE* fp = os::fopen(filename, \"w+\");\n+  for (int i = 0; i < num_lines; i++) {\n+    int len = first_len + i * step_size;\n+    for (; len > 0; len --) {\n+      fputc('x', fp);\n+    }\n+    fputc('\\n', fp);\n+  }\n+  fclose(fp);\n+\n+  fp = os::fopen(filename, \"r\");\n+  return fp;\n+}\n+\n+\/\/ Test the expansion of LineReader::_buffer\n+TEST_VM(LineReader, increasingly_longer_lines) {\n+  const int num_lines = 161;\n+  const int step_size = 100; \/\/ The last line will be 16000 chars + \\n\n+  const int first_len = 0;\n+  FILE* fp = get_input(\"input\", num_lines, step_size, first_len);\n+  LineReader lr(fp);\n+\n+  for (int i = 0; i < num_lines; i++) {\n+    char* line = lr.read_line();\n+    ASSERT_NE(nullptr, line);\n+\n+    int line_len = (int)strlen(line);\n+    EXPECT_TRUE(line_len == i * step_size + 1)\n+      << \"line[\" << i << \"] should have \" << i * step_size + 1\n+      << \" chars but has \" << line_len << \" chars instead\";\n+\n+    for (int n = 0; n < line_len-1; n++) {\n+      EXPECT_TRUE(line[n] == 'x') << \" unexpected character \" << line[n];\n+    }\n+\n+    \/\/ Each line should have a trailing \\n\n+    char last_char = line[line_len - 1];\n+    EXPECT_TRUE(last_char == '\\n') << \" unexpected character \" << last_char;\n+  }\n+  fclose(fp);\n+}\n+\n+\/\/ If line is too long, break it up into multiple chunks (just as fgets() would)\n+TEST_VM(LineReader, longer_than_MAX_LEN) {\n+  const int MAX_LEN = LineReader::MAX_LEN;\n+  FILE* fp = get_input(\"verylong\", 1, 0, MAX_LEN);\n+  LineReader lr(fp);\n+\n+  \/\/ If the input has MAX_LEN chars, LineReader should split it into two parts\n+  \/\/ [1] MAX_LEN-1 chars, plus \\0\n+  \/\/ [2] 1 char, plus \\n, plus \\0\n+\n+  char* line1 = lr.read_line();\n+  int line1_len = (int)strlen(line1);\n+  EXPECT_TRUE(line1_len == MAX_LEN - 1)\n+    << \"the first line returned by LineReader should have \" << (MAX_LEN - 1)\n+    << \" chars but has \" << line1_len << \" chars instead\";\n+\n+  char* line2 = lr.read_line();\n+  int line2_len = (int)strlen(line2);\n+  EXPECT_TRUE(line2_len == 2)\n+    << \"the second line returned by LineReader should have \" << 2\n+    << \" chars but has \" << line2_len << \" chars instead\";\n+\n+  EXPECT_TRUE(line2[0] == 'x' && line2[1] == '\\n')\n+    << \"the second line returned by LineReader should be \\\"x\\\\n\";\n+\n+  fclose(fp);\n+}\n+\n","filename":"test\/hotspot\/gtest\/utilities\/test_lineReader.cpp","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,6 @@\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+\n@@ -107,5 +113,6 @@\n-        int _max_allowed_line = 4096; \/\/ Must match ClassListParser::_max_allowed_line in C code.\n-        int _line_buf_extra = 10;     \/\/ Must match ClassListParser::_line_buf_extra in C code.\n-        StringBuffer sbuf = new StringBuffer();\n-        for (int i=0; i<_max_allowed_line+1; i++) {\n-          sbuf.append(\"x\");\n+        \/\/ Tests for corner cases in the C++ class LineReader, or invalid UTF8. These can't\n+        \/\/ be tested with dumpShouldPass\/dumpShouldFail as we need to prepare a special class\n+        \/\/ list file.\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < 6500; i++) {\n+            sb.append(\"X123456789\");\n@@ -114,6 +121,12 @@\n-        dumpShouldFail(\n-            \"TESTCASE A7: bad input - line too long\",\n-            appJar, classlist(\n-                sbuf.toString()\n-            ),\n-            \"input line too long (must be no longer than \" + _max_allowed_line + \" chars\");\n+        {\n+            System.out.println(\"TESTCASE A7.1: Long line (65000 chars)\");\n+            String longName = sb.toString(); \/\/ 65000 chars long\n+            String classList = \"LongLine.classlist\";\n+            try (FileWriter fw = new FileWriter(classList)) {\n+                fw.write(longName + \"\\n\");\n+            }\n+            CDSOptions opts = (new CDSOptions())\n+                .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+            CDSTestUtils.createArchiveAndCheck(opts)\n+                .shouldContain(\"Preload Warning: Cannot find \" + longName);\n+        }\n@@ -121,2 +134,12 @@\n-        for (int i=0; i<_line_buf_extra + 1000; i++) {\n-          sbuf.append(\"X\");\n+        {\n+            System.out.println(\"TESTCASE A7.2: Name Length > Symbol::max_length()\");\n+            String tooLongName = sb.toString() + sb.toString();\n+            String classList = \"TooLongLine.classlist\";\n+            try (FileWriter fw = new FileWriter(classList)) {\n+                fw.write(tooLongName + \"\\n\");\n+            }\n+            CDSOptions opts = (new CDSOptions())\n+                .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+            CDSTestUtils.createArchive(opts)\n+                .shouldContain(\"class name too long\")\n+                .shouldHaveExitValue(1);\n@@ -125,6 +148,24 @@\n-        dumpShouldFail(\n-            \"TESTCASE A8: bad input - line too long: try to overflow C buffer\",\n-            appJar, classlist(\n-                sbuf.toString()\n-            ),\n-            \"input line too long (must be no longer than \" + _max_allowed_line + \" chars\");\n+        {\n+            System.out.println(\"TESTCASE A7.3: File doesn't end with newline\");\n+            String classList = \"NoTrailingNewLine.classlist\";\n+            try (FileWriter fw = new FileWriter(classList)) {\n+                fw.write(\"No\/Such\/ClassABCD\");\n+            }\n+            CDSOptions opts = (new CDSOptions())\n+                .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+            CDSTestUtils.createArchiveAndCheck(opts)\n+                .shouldContain(\"Preload Warning: Cannot find No\/Such\/ClassABCD\");\n+        }\n+        {\n+            System.out.println(\"TESTCASE A7.4: invalid UTF8 character\");\n+            String classList = \"BadUTF8.classlist\";\n+            try (FileOutputStream fos = new FileOutputStream(classList)) {\n+                byte chars[] = new byte[] { (byte)0xa0, (byte)0xa1, '\\n'};\n+                fos.write(chars);\n+            }\n+            CDSOptions opts = (new CDSOptions())\n+                .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+            CDSTestUtils.createArchive(opts)\n+                .shouldContain(\"class name is not valid UTF8\")\n+                .shouldHaveExitValue(1);\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/ClassListFormatA.java","additions":61,"deletions":20,"binary":false,"changes":81,"status":"modified"}]}