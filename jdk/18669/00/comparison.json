{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,2 @@\n-ClassListParser::ClassListParser(const char* file, ParseMode parse_mode) : _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {\n+ClassListParser::ClassListParser(const char* file, ParseMode parse_mode) :\n+    _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE), _line_reader() {\n@@ -75,0 +76,1 @@\n+  _line_reader.init(_file);\n@@ -76,1 +78,1 @@\n-  _token = _line;\n+  _token = _line = nullptr;\n@@ -169,1 +171,7 @@\n-    if (fgets(_line, sizeof(_line), _file) == nullptr) {\n+    _line = _line_reader.read_line();\n+    if (_line == nullptr) {\n+      if (_line_reader.is_oom()) {\n+        \/\/ Don't try to print the input line that we already know is too long.\n+        _line_len = 0;\n+        error(\"Input line too long\"); \/\/ will exit JVM\n+      }\n@@ -173,4 +181,0 @@\n-    _line_len = (int)strlen(_line);\n-    if (_line_len > _max_allowed_line_len) {\n-      error(\"input line too long (must be no longer than %d chars)\", _max_allowed_line_len);\n-    }\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"utilities\/lineReader.hpp\"\n@@ -83,8 +84,0 @@\n-\n-    \/\/ Max number of bytes allowed per line in the classlist.\n-    \/\/ Theoretically Java class names could be 65535 bytes in length. Also, an input line\n-    \/\/ could have a very long path name up to JVM_MAXPATHLEN bytes in length. In reality,\n-    \/\/ 4K bytes is more than enough.\n-    _max_allowed_line_len = 4096,\n-    _line_buf_extra       = 10, \/\/ for detecting input too long\n-    _line_buf_size        = _max_allowed_line_len + _line_buf_extra\n@@ -103,3 +96,2 @@\n-  \/\/ The following field contains information from the *current* line being\n-  \/\/ parsed.\n-  char                _line[_line_buf_size];  \/\/ The buffer that holds the current line. Some characters in\n+  LineReader          _line_reader;\n+  char*               _line;                  \/\/ The buffer that holds the current line. Some characters in\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/lineReader.hpp\"\n+\n+LineReader::LineReader() {\n+  _file = nullptr;\n+  _is_oom = false;\n+  _buffer = nullptr;\n+  _buffer_len = 0;\n+}\n+\n+LineReader::~LineReader() {\n+  if (_buffer != nullptr) {\n+    os::free(_buffer);\n+  }\n+}\n+\n+void LineReader::init(FILE* file) {\n+  _file = file;\n+  _buffer_len = 16; \/\/ start at small size to test expansion logic\n+  _buffer = (char*)os::malloc(_buffer_len, mtClass);\n+  if (_buffer == nullptr) {\n+    _is_oom = true;\n+  }\n+}\n+\n+char* LineReader::read_line() {\n+  if (_is_oom) {\n+    return nullptr;\n+  }\n+\n+  int line_len = 0; \/\/ the number of characters we have read so far (excluding the trailing \\0)\n+  while (true) {\n+    assert(line_len < _buffer_len, \"sanity\");\n+    int free_space = _buffer_len - line_len;\n+    char* p = _buffer + line_len;\n+    int new_len = 0;\n+    if (fgets(p, free_space, _file) == nullptr) {\n+      \/\/ _file is at EOF\n+      if (line_len == 0) {\n+        return nullptr; \/\/ EOF\n+      } else {\n+        \/\/ We have read something in previous loop iteration(s). Return that.\n+        \/\/ The next call to read_line() will return nullptr to indicate EOF.\n+        return _buffer;\n+      }\n+    }\n+\n+    \/\/ fgets() reads at most free_space characters, including the trailing \\0, so\n+    \/\/ strlen(p) must be smaller than INT_MAX, and can be safely cast to int.\n+    assert(strlen(p) < INT_MAX, \"sanity\");\n+    new_len = (int)strlen(p);\n+\n+    \/\/ _buffer_len will stop at INT_MAX, so we will never be able to read more than\n+    \/\/ INT_MAX chars for a single input line.\n+    assert(line_len >= 0 && new_len >= 0 && (line_len + new_len) >= 0, \"no int overflow\");\n+\n+    line_len += new_len; \/\/ We have read line_len chars so far.\n+\n+    assert(line_len < _buffer_len, \"sanity\");\n+    assert(_buffer[line_len] == '\\0', \"sanity\");\n+\n+    if (_buffer[line_len - 1] == '\\n' || feof(_file)) {\n+      \/\/ We have read an entire line, or reached EOF\n+      return _buffer;\n+    }\n+\n+    if (line_len == _buffer_len - 1) {\n+      \/\/ The buffer is not big enough to hold the entire input line. Expand it.\n+      if (_buffer_len == INT_MAX) {\n+        _is_oom = true; \/\/ cannot expand anymore.\n+        return nullptr;\n+      }\n+      int new_len = _buffer_len * 2;\n+      if (new_len < _buffer_len) { \/\/ overflows int\n+        new_len = INT_MAX;\n+      }\n+      assert(new_len > _buffer_len, \"must be\");\n+\n+      char* new_buffer = (char*)os::realloc(_buffer, new_len, mtClass);\n+      if (new_buffer == nullptr) {\n+        _is_oom = true; \/\/ oom\n+        return nullptr;\n+      } else {\n+        _buffer = new_buffer;\n+        _buffer_len = new_len;\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/utilities\/lineReader.cpp","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_LINEREADER_HPP\n+#define SHARE_UTILITIES_LINEREADER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ This class is a wrapper around fgets() for reading arbitrarily long\n+\/\/ text lines (upto INT_MAX chars) from a FILE*.\n+class LineReader : public StackObj {\n+  char* _buffer;       \/\/ The buffer that holds the value returned by read_line().\n+  int   _buffer_len;   \/\/ Max characters that can be stored in _line, including the trailing \\0;\n+  FILE* _file;\n+  bool  _is_oom;\n+public:\n+  LineReader();\n+  void init(FILE* file);\n+  ~LineReader();\n+\n+  \/\/ Out of memory. See comments below.\n+  bool is_oom() {\n+    return _is_oom;\n+  }\n+\n+  \/\/ Return one line from _file, as a NUL-terminated string. The length and contents of this\n+  \/\/ string are the same as those returned by a call to fgets(s, size, _file) with size==INT_MAX.\n+  \/\/\n+  \/\/ When successful, a non-null value is returned. The caller is free to read or modify this\n+  \/\/ string (up to the terminating NUL character) until the next call to read_line(), or until the\n+  \/\/ LineReader is destructed.\n+  \/\/\n+  \/\/ nullptr is returned if:\n+  \/\/   1. The input line in _file is longer than INT_MAX characters.\n+  \/\/   2. os::malloc\/os::realloc failed to allocate enough space to accommodate the input line.\n+  \/\/   3. Upon the entry of this function, _file is already at the EOF position.\n+  \/\/ If this function returns nullptr because of cases 1 or 2, all subsequent calls to\n+  \/\/ is_oom() will return true.\n+  char* read_line();\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_LINEREADER_HPP\n","filename":"src\/hotspot\/share\/utilities\/lineReader.hpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,5 @@\n+import java.io.File;\n+import java.io.FileWriter;\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+\n@@ -107,5 +112,6 @@\n-        int _max_allowed_line = 4096; \/\/ Must match ClassListParser::_max_allowed_line in C code.\n-        int _line_buf_extra = 10;     \/\/ Must match ClassListParser::_line_buf_extra in C code.\n-        StringBuffer sbuf = new StringBuffer();\n-        for (int i=0; i<_max_allowed_line+1; i++) {\n-          sbuf.append(\"x\");\n+        \/\/ The C++ class LineReader should be able to:\n+        \/\/ [1] read a very long line (65000 chars)\n+        \/\/ [2] read the last line from a file that doesn't end with a newline character.\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < 6500; i++) {\n+          sb.append(\"X123456789\");\n@@ -113,10 +119,6 @@\n-\n-        dumpShouldFail(\n-            \"TESTCASE A7: bad input - line too long\",\n-            appJar, classlist(\n-                sbuf.toString()\n-            ),\n-            \"input line too long (must be no longer than \" + _max_allowed_line + \" chars\");\n-\n-        for (int i=0; i<_line_buf_extra + 1000; i++) {\n-          sbuf.append(\"X\");\n+        String longName = sb.toString(); \/\/ 65000 chars long\n+        System.out.println(\"TESTCASE A7: Long line; Last line in file is not newline.\");\n+        String classList = \"NoEndingNewLine.classlist\";\n+        try (FileWriter fw = new FileWriter(classList)) {\n+            fw.write(longName + \"\\n\");\n+            fw.write(\"No\/Such\/ClassABCD\");\n@@ -125,6 +127,5 @@\n-        dumpShouldFail(\n-            \"TESTCASE A8: bad input - line too long: try to overflow C buffer\",\n-            appJar, classlist(\n-                sbuf.toString()\n-            ),\n-            \"input line too long (must be no longer than \" + _max_allowed_line + \" chars\");\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+        CDSTestUtils.createArchiveAndCheck(opts)\n+            .shouldContain(\"Preload Warning: Cannot find \" + longName)\n+            .shouldContain(\"Preload Warning: Cannot find No\/Such\/ClassABCD\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/ClassListFormatA.java","additions":23,"deletions":22,"binary":false,"changes":45,"status":"modified"}]}