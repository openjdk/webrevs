{"files":[{"patch":"@@ -117,0 +117,1 @@\n+    check_class_name_length(_class_name);\n@@ -175,0 +176,1 @@\n+        _token = nullptr;\n@@ -457,0 +459,9 @@\n+void ClassListParser::check_class_name_length(const char* class_name) {\n+  if (strlen(class_name) > (size_t)Symbol::max_length()) {\n+    jio_fprintf(defaultStream::error_stream(),\n+              \"An error has occurred while processing class list file %s:%d class name too long\\n\",\n+              _classlist_file, _line_no);\n+    vm_exit_during_initialization(\"class list format error.\", nullptr);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -178,0 +178,1 @@\n+  void check_class_name_length(const char* class_name);\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,7 @@\n+LineReader::LineReader(FILE* file) {\n+  _is_oom = false;\n+  _buffer = nullptr;\n+  _buffer_len = 0;\n+  init(file);\n+}\n+\n@@ -43,0 +50,1 @@\n+  assert(file != nullptr, \"sanity\");\n@@ -44,1 +52,1 @@\n-  _buffer_len = 16; \/\/ start at small size to test expansion logic\n+  _buffer_len = DEBUG_ONLY(16) NOT_DEBUG(4096); \/\/ debug build: start small to test expansion logic\n@@ -52,0 +60,2 @@\n+  STATIC_ASSERT(0 < MAX_LEN && MAX_LEN <= INT_MAX);\n+  assert(_file != nullptr, \"must be initialized\");\n@@ -59,1 +69,1 @@\n-    int free_space = _buffer_len - line_len;\n+    int available_space = _buffer_len - line_len;\n@@ -62,1 +72,1 @@\n-    if (fgets(p, free_space, _file) == nullptr) {\n+    if (fgets(p, available_space, _file) == nullptr) {\n@@ -73,1 +83,1 @@\n-    \/\/ fgets() reads at most free_space characters, including the trailing \\0, so\n+    \/\/ fgets() reads at most available_space chars, including the trailing \\0, so\n@@ -78,2 +88,2 @@\n-    \/\/ _buffer_len will stop at INT_MAX, so we will never be able to read more than\n-    \/\/ INT_MAX chars for a single input line.\n+    \/\/ _buffer_len will stop at MAX_LEN, so we will never be able to read more than\n+    \/\/ MAX_LEN chars for a single input line.\n@@ -94,3 +104,5 @@\n-      if (_buffer_len == INT_MAX) {\n-        _is_oom = true; \/\/ cannot expand anymore.\n-        return nullptr;\n+      if (_buffer_len == MAX_LEN) {\n+        \/\/ Cannot expand anymore. Return the first MAX_LEN-1 bytes of input.\n+        \/\/ The behavior is exactly the same as if we had called fgets() with a\n+        \/\/ buffer whose size is MAX_LEN.\n+        return _buffer;\n@@ -100,1 +112,1 @@\n-        new_len = INT_MAX;\n+        new_len = MAX_LEN;\n","filename":"src\/hotspot\/share\/utilities\/lineReader.cpp","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -31,2 +31,6 @@\n-\/\/ This class is a wrapper around fgets() for reading arbitrarily long\n-\/\/ text lines (upto INT_MAX chars) from a FILE*.\n+\/\/ This class is a wrapper around fgets() for reading *reasonably long*\n+\/\/ text lines (up to LineReader::MAX_LEN-1 chars) from a FILE*.\n+\/\/\n+\/\/ MAX_LEN is currently 4M. This should be enough for any practical use\n+\/\/ of text-based input files for HotSpot. Don't use LineReader if it's\n+\/\/ possible for valid lines to be longer than this limit.\n@@ -39,0 +43,2 @@\n+  static const int MAX_LEN = 4 * 1024 * 1024;\n+  LineReader(FILE* file);\n@@ -48,2 +54,4 @@\n-  \/\/ Return one line from _file, as a NUL-terminated string. The length and contents of this\n-  \/\/ string are the same as those returned by a call to fgets(s, size, _file) with size==INT_MAX.\n+  \/\/ Return one line from _file, as a 0-terminated string. The length and contents of this\n+  \/\/ string are the same as those returned by a call to fgets() with a buffer that's\n+  \/\/ MAX_LEN bytes long. (Note: if the file contains a line longer than MAX_LEN-1 chars,\n+  \/\/ we'd break it up in multiple chunks, just as fgets() would).\n@@ -52,1 +60,1 @@\n-  \/\/ string (up to the terminating NUL character) until the next call to read_line(), or until the\n+  \/\/ string (up to the terminating \\0 character) until the next call to read_line(), or until the\n@@ -56,5 +64,4 @@\n-  \/\/   1. The input line in _file is longer than INT_MAX characters.\n-  \/\/   2. os::malloc\/os::realloc failed to allocate enough space to accommodate the input line.\n-  \/\/   3. Upon the entry of this function, _file is already at the EOF position.\n-  \/\/ If this function returns nullptr because of cases 1 or 2, all subsequent calls to\n-  \/\/ is_oom() will return true.\n+  \/\/   1. os::malloc\/os::realloc failed to allocate enough space to accommodate the input line.\n+  \/\/      When this happens, all subsequent calls to is_oom() will return true, and all\n+  \/\/      subsequent calls to read_line() will return nullptr;\n+  \/\/   2. Upon the entry of this function, _file is already at the EOF position.\n","filename":"src\/hotspot\/share\/utilities\/lineReader.hpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"include\/jvm_io.h\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/lineReader.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ Write num_lines into filename.\n+\/\/ The i-th line has (first_len + step_size * i) chars, plus \\n\n+static FILE* get_input(const char* filename, int num_lines, int step_size, int first_len) {\n+  ResourceMark rm;\n+\n+  const char* tmp_dir = os::get_temp_directory();\n+  const char* file_sep = os::file_separator();\n+  size_t temp_file_len = strlen(tmp_dir) + strlen(file_sep) + strlen(filename) + 1;\n+  char* temp_file = NEW_RESOURCE_ARRAY(char, temp_file_len);\n+  jio_snprintf(temp_file, temp_file_len, \"%s%s%s\",\n+               tmp_dir, file_sep, filename);\n+\n+  FILE* fp = os::fopen(filename, \"w+\");\n+  for (int i = 0; i < num_lines; i++) {\n+    int len = first_len + i * step_size;\n+    for (; len > 0; len --) {\n+      fputc('x', fp);\n+    }\n+    fputc('\\n', fp);\n+  }\n+  fclose(fp);\n+\n+  fp = os::fopen(filename, \"r\");\n+  return fp;\n+}\n+\n+\/\/ Test the expansion of LineReader::_buffer\n+TEST_VM(LineReader, increasingly_longer_lines) {\n+  const int num_lines = 161;\n+  const int step_size = 100; \/\/ The last line will be 16000 chars + \\n\n+  const int first_len = 0;\n+  FILE* fp = get_input(\"input\", num_lines, step_size, first_len);\n+  LineReader lr(fp);\n+\n+  for (int i = 0; i < num_lines; i++) {\n+    char* line = lr.read_line();\n+    ASSERT_NE(nullptr, line);\n+\n+    int line_len = (int)strlen(line);\n+    EXPECT_TRUE(line_len == i * step_size + 1)\n+      << \"line[\" << i << \"] should have \" << i * step_size + 1\n+      << \" chars but has \" << line_len << \" chars instead\";\n+\n+    for (int n = 0; n < line_len-1; n++) {\n+      EXPECT_TRUE(line[n] == 'x') << \" unexpected character \" << line[n];\n+    }\n+\n+    \/\/ Each line should have a trailing \\n\n+    char last_char = line[line_len - 1];\n+    EXPECT_TRUE(last_char == '\\n') << \" unexpected character \" << last_char;\n+  }\n+  fclose(fp);\n+}\n+\n+\/\/ If line is too long, break it up into multiple chunks (just as fgets() would)\n+TEST_VM(LineReader, longer_than_MAX_LEN) {\n+  const int MAX_LEN = LineReader::MAX_LEN;\n+  FILE* fp = get_input(\"verylong\", 1, 0, MAX_LEN);\n+  LineReader lr(fp);\n+\n+  \/\/ If the input has MAX_LEN chars, LineReader should split it into two parts\n+  \/\/ [1] MAX_LEN-1 chars, plus \\0\n+  \/\/ [2] 1 char, plus \\n, plus \\0\n+\n+  char* line1 = lr.read_line();\n+  int line1_len = (int)strlen(line1);\n+  EXPECT_TRUE(line1_len == MAX_LEN - 1)\n+    << \"the first line returned by LineReader should have \" << (MAX_LEN - 1)\n+    << \" chars but has \" << line1_len << \" chars instead\";\n+\n+  char* line2 = lr.read_line();\n+  int line2_len = (int)strlen(line2);\n+  EXPECT_TRUE(line2_len == 2)\n+    << \"the second line returned by LineReader should have \" << 2\n+    << \" chars but has \" << line2_len << \" chars instead\";\n+\n+  EXPECT_TRUE(line2[0] == 'x' && line2[1] == '\\n')\n+    << \"the second line returned by LineReader should be \\\"x\\\\n\";\n+\n+  fclose(fp);\n+}\n+\n","filename":"test\/hotspot\/gtest\/utilities\/test_lineReader.cpp","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -112,3 +112,1 @@\n-        \/\/ The C++ class LineReader should be able to:\n-        \/\/ [1] read a very long line (65000 chars)\n-        \/\/ [2] read the last line from a file that doesn't end with a newline character.\n+        \/\/ Tests for corner cases in the C++ class LineReader.\n@@ -117,1 +115,1 @@\n-          sb.append(\"X123456789\");\n+            sb.append(\"X123456789\");\n@@ -119,6 +117,26 @@\n-        String longName = sb.toString(); \/\/ 65000 chars long\n-        System.out.println(\"TESTCASE A7: Long line; Last line in file is not newline.\");\n-        String classList = \"NoEndingNewLine.classlist\";\n-        try (FileWriter fw = new FileWriter(classList)) {\n-            fw.write(longName + \"\\n\");\n-            fw.write(\"No\/Such\/ClassABCD\");\n+\n+        {\n+            System.out.println(\"TESTCASE A7.1: Long line (65000 chars)\");\n+            String longName = sb.toString(); \/\/ 65000 chars long\n+            String classList = \"LongLine.classlist\";\n+            try (FileWriter fw = new FileWriter(classList)) {\n+                fw.write(longName + \"\\n\");\n+            }\n+            CDSOptions opts = (new CDSOptions())\n+                .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+            CDSTestUtils.createArchiveAndCheck(opts)\n+                .shouldContain(\"Preload Warning: Cannot find \" + longName);\n+        }\n+\n+        {\n+            System.out.println(\"TESTCASE A7.2: Name Length > Symbol::max_length()\");\n+            String tooLongName = sb.toString() + sb.toString();\n+            String classList = \"TooLongLine.classlist\";\n+            try (FileWriter fw = new FileWriter(classList)) {\n+                fw.write(tooLongName + \"\\n\");\n+            }\n+            CDSOptions opts = (new CDSOptions())\n+                .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+            CDSTestUtils.createArchive(opts)\n+                .shouldContain(\"class name too long\")\n+                .shouldHaveExitValue(1);\n@@ -127,5 +145,11 @@\n-        CDSOptions opts = (new CDSOptions())\n-            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n-        CDSTestUtils.createArchiveAndCheck(opts)\n-            .shouldContain(\"Preload Warning: Cannot find \" + longName)\n-            .shouldContain(\"Preload Warning: Cannot find No\/Such\/ClassABCD\");\n+        {\n+            System.out.println(\"TESTCASE A7.3: File doesn't end with newline\");\n+            String classList = \"NoTrailingNewLine.classlist\";\n+            try (FileWriter fw = new FileWriter(classList)) {\n+                fw.write(\"No\/Such\/ClassABCD\");\n+            }\n+            CDSOptions opts = (new CDSOptions())\n+                .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+            CDSTestUtils.createArchiveAndCheck(opts)\n+                .shouldContain(\"Preload Warning: Cannot find No\/Such\/ClassABCD\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/ClassListFormatA.java","additions":39,"deletions":15,"binary":false,"changes":54,"status":"modified"}]}