{"files":[{"patch":"@@ -281,1 +281,1 @@\n-  if (compiler->is_jvmci()) {\n+  if (compiler->is_jvmci() && !UseJVMCINativeLibrary) {\n@@ -300,1 +300,1 @@\n-      if (compiler->is_jvmci()) {\n+      if (compiler->is_jvmci() && !UseJVMCINativeLibrary) {\n@@ -949,6 +949,7 @@\n-    JVMCI_ONLY(if (!UseJVMCICompiler || !UseDynamicNumberOfCompilerThreads || i == 0) {)\n-    \/\/ Create a name for our thread.\n-    os::snprintf_checked(name_buffer, sizeof(name_buffer), \"%s CompilerThread%d\", _compilers[1]->name(), i);\n-    Handle thread_oop = create_thread_oop(name_buffer, CHECK);\n-    thread_handle = JNIHandles::make_global(thread_oop);\n-    JVMCI_ONLY(})\n+    bool create = !UseDynamicNumberOfCompilerThreads || i == 0;\n+    if (create JVMCI_ONLY(|| !UseJVMCICompiler || UseJVMCINativeLibrary)) {\n+      \/\/ Create a name for our thread.\n+      os::snprintf_checked(name_buffer, sizeof(name_buffer), \"%s CompilerThread%d\", _compilers[1]->name(), i);\n+      Handle thread_oop = create_thread_oop(name_buffer, CHECK);\n+      thread_handle = JNIHandles::make_global(thread_oop);\n+    }\n@@ -1032,7 +1033,9 @@\n-      if (UseJVMCICompiler) {\n-        \/\/ Native compiler threads as used in C1\/C2 can reuse the j.l.Thread\n-        \/\/ objects as their existence is completely hidden from the rest of\n-        \/\/ the VM (and those compiler threads can't call Java code to do the\n-        \/\/ creation anyway). For JVMCI we have to create new j.l.Thread objects\n-        \/\/ as they are visible and we can see unexpected thread lifecycle\n-        \/\/ transitions if we bind them to new JavaThreads.\n+      if (UseJVMCICompiler && !UseJVMCINativeLibrary) {\n+        \/\/ Native compiler threads as used in C1\/C2 can reuse the j.l.Thread objects as their\n+        \/\/ existence is completely hidden from the rest of the VM (and those compiler threads can't\n+        \/\/ call Java code to do the creation anyway).\n+        \/\/\n+        \/\/ For pure Java JVMCI we have to create new j.l.Thread objects as they are visible and we\n+        \/\/ can see unexpected thread lifecycle transitions if we bind them to new JavaThreads.  For\n+        \/\/ native library JVMCI it's preferred to use the C1\/C2 strategy as this avoids unnecessary\n+        \/\/ coupling with Java.\n@@ -1066,0 +1069,1 @@\n+      assert(compiler2_object(i) != nullptr, \"Thread oop must exist\");\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"}]}