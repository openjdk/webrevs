{"files":[{"patch":"@@ -281,1 +281,1 @@\n-  if (compiler->is_jvmci()) {\n+  if (compiler->is_jvmci() && !UseJVMCINativeLibrary) {\n@@ -300,1 +300,1 @@\n-      if (compiler->is_jvmci()) {\n+      if (compiler->is_jvmci() && !UseJVMCINativeLibrary) {\n@@ -775,5 +775,0 @@\n-Handle CompileBroker::create_thread_oop(const char* name, TRAPS) {\n-  Handle thread_oop = JavaThread::create_system_thread_object(name, CHECK_NH);\n-  return thread_oop;\n-}\n-\n@@ -926,0 +921,7 @@\n+static jobject create_compiler_thread(AbstractCompiler* compiler, int i, TRAPS) {\n+  char name_buffer[256];\n+  os::snprintf_checked(name_buffer, sizeof(name_buffer), \"%s CompilerThread%d\", compiler->name(), i);\n+  Handle thread_oop = JavaThread::create_system_thread_object(name_buffer, CHECK_NULL);\n+  return JNIHandles::make_global(thread_oop);\n+}\n+\n@@ -956,2 +958,0 @@\n-  char name_buffer[256];\n-\n@@ -959,4 +959,0 @@\n-    jobject thread_handle = nullptr;\n-    \/\/ Create all j.l.Thread objects for C1 and C2 threads here, but only one\n-    \/\/ for JVMCI compiler which can create further ones on demand.\n-    JVMCI_ONLY(if (!UseJVMCICompiler || !UseDynamicNumberOfCompilerThreads || i == 0) {)\n@@ -964,4 +960,1 @@\n-    os::snprintf_checked(name_buffer, sizeof(name_buffer), \"%s CompilerThread%d\", _compilers[1]->name(), i);\n-    Handle thread_oop = create_thread_oop(name_buffer, CHECK);\n-    thread_handle = JNIHandles::make_global(thread_oop);\n-    JVMCI_ONLY(})\n+    jobject thread_handle = create_compiler_thread(_compilers[1], i, CHECK);\n@@ -988,3 +981,1 @@\n-    os::snprintf_checked(name_buffer, sizeof(name_buffer), \"C1 CompilerThread%d\", i);\n-    Handle thread_oop = create_thread_oop(name_buffer, CHECK);\n-    jobject thread_handle = JNIHandles::make_global(thread_oop);\n+    jobject thread_handle = create_compiler_thread(_compilers[0], i, CHECK);\n@@ -1018,1 +1009,1 @@\n-      Handle thread_oop = create_thread_oop(\"Deoptimize objects a lot single mode\", CHECK);\n+      Handle thread_oop = JavaThread::create_system_thread_object(\"Deoptimize objects a lot single mode\", CHECK);\n@@ -1045,7 +1036,9 @@\n-      if (UseJVMCICompiler) {\n-        \/\/ Native compiler threads as used in C1\/C2 can reuse the j.l.Thread\n-        \/\/ objects as their existence is completely hidden from the rest of\n-        \/\/ the VM (and those compiler threads can't call Java code to do the\n-        \/\/ creation anyway). For JVMCI we have to create new j.l.Thread objects\n-        \/\/ as they are visible and we can see unexpected thread lifecycle\n-        \/\/ transitions if we bind them to new JavaThreads.\n+      if (UseJVMCICompiler && !UseJVMCINativeLibrary && _compiler2_objects[i] == nullptr) {\n+        \/\/ Native compiler threads as used in C1\/C2 can reuse the j.l.Thread objects as their\n+        \/\/ existence is completely hidden from the rest of the VM (and those compiler threads can't\n+        \/\/ call Java code to do the creation anyway).\n+        \/\/\n+        \/\/ For pure Java JVMCI we have to create new j.l.Thread objects as they are visible and we\n+        \/\/ can see unexpected thread lifecycle transitions if we bind them to new JavaThreads.  For\n+        \/\/ native library JVMCI it's preferred to use the C1\/C2 strategy as this avoids unnecessary\n+        \/\/ coupling with Java.\n@@ -1059,1 +1052,1 @@\n-          thread_oop = create_thread_oop(name_buffer, THREAD);\n+          thread_oop = JavaThread::create_system_thread_object(name_buffer, THREAD);\n@@ -1079,0 +1072,1 @@\n+      guarantee(compiler2_object(i) != nullptr, \"Thread oop must exist\");\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":23,"deletions":29,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -244,1 +244,0 @@\n-  static Handle create_thread_oop(const char* name, TRAPS);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}