{"files":[{"patch":"@@ -445,0 +445,30 @@\n+    \/**\n+     * Called before sleeping to create a jdk.ThreadSleepEvent event.\n+     *\/\n+    private static ThreadSleepEvent beforeSleep(long nanos) {\n+        ThreadSleepEvent event = null;\n+        if (ThreadSleepEvent.isTurnedOn()) {\n+            try {\n+                event = new ThreadSleepEvent();\n+                event.time = nanos;\n+                event.begin();\n+            } catch (OutOfMemoryError e) {\n+                event = null;\n+            }\n+        }\n+        return event;\n+    }\n+\n+    \/**\n+     * Called after sleeping to commit the jdk.ThreadSleepEvent event.\n+     *\/\n+    private static void afterSleep(ThreadSleepEvent event) {\n+        if (event != null) {\n+            try {\n+                event.commit();\n+            } catch (OutOfMemoryError e) {\n+                \/\/ ignore\n+            }\n+        }\n+    }\n+\n@@ -466,13 +496,0 @@\n-        long nanos = MILLISECONDS.toNanos(millis);\n-\n-        \/\/ create jdk.ThreadSleepEvent event if enabled\n-        ThreadSleepEvent event = null;\n-        if (ThreadSleepEvent.isTurnedOn()) {\n-            try {\n-                event = new ThreadSleepEvent();\n-                event.time = nanos;\n-                event.begin();\n-            } catch (OutOfMemoryError e) {\n-                event = null;\n-            }\n-        }\n@@ -480,0 +497,2 @@\n+        long nanos = MILLISECONDS.toNanos(millis);\n+        ThreadSleepEvent event = beforeSleep(nanos);\n@@ -487,5 +506,1 @@\n-            try {\n-                if (event != null) event.commit();\n-            } catch (OutOfMemoryError e) {\n-                \/\/ ignore\n-            }\n+            afterSleep(event);\n@@ -528,2 +543,16 @@\n-        if (nanos > 0 && millis < Long.MAX_VALUE) {\n-            millis++;\n+        ThreadSleepEvent event = beforeSleep(nanos);\n+        try {\n+            if (currentThread() instanceof VirtualThread vthread) {\n+                \/\/ total sleep time, in nanoseconds\n+                long totalNanos = MILLISECONDS.toNanos(millis);\n+                totalNanos += Math.min(Long.MAX_VALUE - totalNanos, nanos);\n+                vthread.sleepNanos(totalNanos);\n+            } else {\n+                \/\/ millisecond precision\n+                if (nanos > 0 && millis < Long.MAX_VALUE) {\n+                    millis++;\n+                }\n+                sleep0(millis);\n+            }\n+        } finally {\n+            afterSleep(event);\n@@ -531,1 +560,0 @@\n-        sleep(millis);\n@@ -556,12 +584,1 @@\n-        \/\/ create jdk.ThreadSleepEvent event if enabled\n-        ThreadSleepEvent event = null;\n-        if (ThreadSleepEvent.isTurnedOn()) {\n-            try {\n-                event = new ThreadSleepEvent();\n-                event.time = nanos;\n-                event.begin();\n-            } catch (OutOfMemoryError e) {\n-                event = null;\n-            }\n-        }\n-\n+        ThreadSleepEvent event = beforeSleep(nanos);\n@@ -572,1 +589,1 @@\n-                \/\/ convert to milliseconds\n+                \/\/ millisecond precision\n@@ -580,5 +597,1 @@\n-            try {\n-                if (event != null) event.commit();\n-            } catch (OutOfMemoryError e) {\n-                \/\/ ignore\n-            }\n+            afterSleep(event);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":52,"deletions":39,"binary":false,"changes":91,"status":"modified"}]}