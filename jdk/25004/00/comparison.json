{"files":[{"patch":"@@ -387,2 +387,2 @@\n- * Invocations of {@link #setOrThrow(Object)} form a total order of zero or more\n- * exceptional invocations followed by zero (if the contents were already set) or one\n+ * Invocations of {@link #orElseSet(Supplier)} form a total order of zero or\n+ * more exceptional invocations followed by zero (if the contents were already set) or one\n@@ -447,2 +447,0 @@\n-    \/\/ Principal methods\n-\n@@ -512,2 +510,0 @@\n-    \/\/ Convenience methods\n-\n@@ -522,0 +518,3 @@\n+     * @throws IllegalStateException if a supplier invoked by {@link #orElseSet(Supplier)}\n+     *         recursively attempts to set this stable value by calling this method\n+     *         directly or indirectly.\n@@ -576,2 +575,2 @@\n-     * thrown by the computing thread. The computing threads will then observe the newly\n-     * computed value (if any) and will then never execute.\n+     * thrown by the computing thread. The competing threads will then observe the newly\n+     * computed value (if any) and will then never execute the {@code underlying} supplier.\n@@ -617,3 +616,3 @@\n-     * @param size       the size of the allowed inputs in the continuous\n-     *                   interval {@code [0, size)}\n-     * @param underlying IntFunction used to compute cached values\n+     * @param size       the upper bound of the range {@code [0, size)} indicating\n+     *                   the allowed inputs\n+     * @param underlying {@code IntFunction} used to compute cached values\n@@ -730,2 +729,2 @@\n-     * Any direct {@link Map#values()} or {@link Map#entrySet()} views\n-     * of the returned map are also stable.\n+     * Any {@link Map#values()} or {@link Map#entrySet()} views of the returned map are\n+     * also stable.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StableValue.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -140,1 +140,2 @@\n-                    return ImmutableCollections.stableList(size, mapper);\n+                    \/\/ A stable list is not Serializable so, we cannot return `List.of()` if `size == 0`\n+                    return new StableList<>(size, mapper);\n@@ -143,0 +144,1 @@\n+                    \/\/ A stable map is not Serializable so, we cannot return `Map.of()` if `keys.isEmpty()`\n@@ -267,5 +269,0 @@\n-    static <E> List<E> stableList(int size, IntFunction<? extends E> mapper) {\n-        \/\/ A lazy list is not Serializable so, we cannot return `List.of()` if size == 0\n-        return new StableList<>(size, mapper);\n-    }\n-\n@@ -457,1 +454,1 @@\n-    static final class SubList<E> extends AbstractImmutableList<E>\n+    static sealed class SubList<E> extends AbstractImmutableList<E>\n@@ -461,1 +458,1 @@\n-        private final AbstractImmutableList<E> root;\n+        final AbstractImmutableList<E> root;\n@@ -464,1 +461,1 @@\n-        private final int offset;\n+        final int offset;\n@@ -467,1 +464,1 @@\n-        private final int size;\n+        final int size;\n@@ -521,2 +518,1 @@\n-            return root instanceof ListN<?> listN && listN.allowNulls\n-                    || root instanceof StableList<E>;\n+            return root instanceof ListN<?> listN && listN.allowNulls;\n@@ -575,8 +571,0 @@\n-        @Override\n-        public String toString() {\n-            if (root instanceof StableList<E> stableList) {\n-                return StableUtil.renderElements(root, \"StableList\", stableList.delegates, offset, size);\n-            } else {\n-                return super.toString();\n-            }\n-        }\n@@ -881,0 +869,7 @@\n+        @Override\n+        public List<E> subList(int fromIndex, int toIndex) {\n+            final int size = size();\n+            subListRangeCheck(fromIndex, toIndex, size);\n+            return StableSubList.fromList(this, fromIndex, toIndex);\n+        }\n+\n@@ -886,0 +881,34 @@\n+        private static final class StableSubList<E> extends SubList<E> {\n+\n+            private StableSubList(AbstractImmutableList<E> root, int offset, int size) {\n+                super(root, offset, size);\n+            }\n+\n+            @Override\n+            public List<E> reversed() {\n+                return new StableReverseOrderListView<>(this);\n+            }\n+\n+            @Override\n+            public List<E> subList(int fromIndex, int toIndex) {\n+                subListRangeCheck(fromIndex, toIndex, size());\n+                return StableSubList.fromSubList(this, fromIndex, toIndex);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                \/\/ Todo: Provide a copy free solution\n+                final StableValueImpl<E>[] reversed = Arrays.copyOfRange(deepRoot(root).delegates, this.offset, this.size - offset);\n+                return StableUtil.renderElements(this, \"StableCollection\", reversed);\n+            }\n+\n+            static <E> SubList<E> fromList(AbstractImmutableList<E> list, int fromIndex, int toIndex) {\n+                return new StableSubList<>(list, fromIndex, toIndex - fromIndex);\n+            }\n+\n+            static <E> SubList<E> fromSubList(SubList<E> parent, int fromIndex, int toIndex) {\n+                return new StableSubList<>(parent.root, parent.offset + fromIndex, toIndex - fromIndex);\n+            }\n+\n+        }\n+\n@@ -895,1 +924,2 @@\n-                final StableValueImpl<E>[] delegates = ((StableList<E>)base).delegates;\n+                final StableValueImpl<E>[] delegates = deepRoot(base).delegates;\n+                \/\/ Todo: Provide a copy free solution\n@@ -898,1 +928,1 @@\n-                return StableUtil.renderElements(base, \"Collection\", reversed);\n+                return StableUtil.renderElements(this, \"Collection\", reversed);\n@@ -906,0 +936,19 @@\n+            @Override\n+            public List<E> subList(int fromIndex, int toIndex) {\n+                final int size = base.size();\n+                subListRangeCheck(fromIndex, toIndex, size);\n+                return new StableReverseOrderListView<>(base.subList(size - toIndex, size - fromIndex));\n+            }\n+\n+        }\n+\n+        static <E> StableList<E> deepRoot(List<E> list) {\n+            \/\/ Avoid spinning code for a pattern matching switch, instead use an if rake\n+            if (list instanceof StableList<E> sl) {\n+                return sl;\n+            } else if (list instanceof StableList.StableReverseOrderListView<E> rev) {\n+                return deepRoot(rev.base);\n+            } else if (list instanceof StableList.StableSubList<E> sub) {\n+                return deepRoot(sub.root);\n+            }\n+            throw new InternalError(\"Should not reach here: \" + list.getClass().getName());\n@@ -1563,1 +1612,1 @@\n-        @Override public Set<Map.Entry<K, V>> entrySet() { return new StableMapEntrySet(); }\n+        @Override public Set<Map.Entry<K, V>> entrySet() { return StableMapEntrySet.of(this); }\n@@ -1585,1 +1634,6 @@\n-        final class StableMapEntrySet extends AbstractImmutableSet<Map.Entry<K, V>> {\n+        static final class StableMapEntrySet<K, V> extends AbstractImmutableSet<Map.Entry<K, V>> {\n+\n+            \/\/ Use a separate field for the outer class in order to facilitate\n+            \/\/ a @Stable annotation.\n+            @Stable\n+            private final StableMap<K, V> outer;\n@@ -1590,2 +1644,3 @@\n-            StableMapEntrySet() {\n-                this.delegateEntrySet = delegate.entrySet();\n+            private StableMapEntrySet(StableMap<K, V> outer) {\n+                this.outer = outer;\n+                this.delegateEntrySet = outer.delegate.entrySet();\n@@ -1594,1 +1649,1 @@\n-            @Override public Iterator<Map.Entry<K, V>> iterator() { return new LazyMapIterator(); }\n+            @Override public Iterator<Map.Entry<K, V>> iterator() { return LazyMapIterator.of(this); }\n@@ -1596,1 +1651,1 @@\n-            @Override public int                       hashCode() { return StableMap.this.hashCode(); }\n+            @Override public int                       hashCode() { return outer.hashCode(); }\n@@ -1603,0 +1658,5 @@\n+            \/\/ For @ValueBased\n+            static private <K, V> StableMapEntrySet<K, V> of(StableMap<K, V> outer) {\n+                return new StableMapEntrySet<>(outer);\n+            }\n+\n@@ -1604,1 +1664,6 @@\n-            final class LazyMapIterator implements Iterator<Map.Entry<K, V>> {\n+            static final class LazyMapIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n+\n+                \/\/ Use a separate field for the outer class in order to facilitate\n+                \/\/ a @Stable annotation.\n+                @Stable\n+                private final StableMapEntrySet<K, V> outer;\n@@ -1609,2 +1674,3 @@\n-                LazyMapIterator() {\n-                    this.delegateIterator = delegateEntrySet.iterator();\n+                private LazyMapIterator(StableMapEntrySet<K, V> outer) {\n+                    this.outer = outer;\n+                    this.delegateIterator = outer.delegateEntrySet.iterator();\n@@ -1620,1 +1686,1 @@\n-                        @Override public V get() { return mapper.apply(k); }}));\n+                        @Override public V get() { return outer.outer.mapper.apply(k); }}));\n@@ -1631,1 +1697,1 @@\n-                                        @Override public V get() { return mapper.apply(k); }})));\n+                                        @Override public V get() { return outer.outer.mapper.apply(k); }})));\n@@ -1636,0 +1702,6 @@\n+\n+                \/\/ For @ValueBased\n+                static private <K, V> LazyMapIterator<K, V> of(StableMapEntrySet<K, V> outer) {\n+                    return new LazyMapIterator<>(outer);\n+                }\n+\n@@ -1641,1 +1713,1 @@\n-            return new StableMapValues();\n+            return StableMapValues.of(this);\n@@ -1644,5 +1716,16 @@\n-        final class StableMapValues extends AbstractImmutableCollection<V> {\n-            @Override public Iterator<V> iterator() { return new ValueIterator(); }\n-            @Override public int size() { return StableMap.this.size(); }\n-            @Override public boolean isEmpty() { return StableMap.this.isEmpty();}\n-            @Override public boolean contains(Object v) { return StableMap.this.containsValue(v); }\n+        @jdk.internal.ValueBased\n+        static final class StableMapValues<V> extends AbstractImmutableCollection<V> {\n+\n+            \/\/ Use a separate field for the outer class in order to facilitate\n+            \/\/ a @Stable annotation.\n+            @Stable\n+            private final StableMap<?, V> outer;\n+\n+            private StableMapValues(StableMap<?, V> outer) {\n+                this.outer = outer;\n+            }\n+\n+            @Override public Iterator<V> iterator() { return outer.new ValueIterator(); }\n+            @Override public int size() { return outer.size(); }\n+            @Override public boolean isEmpty() { return outer.isEmpty();}\n+            @Override public boolean contains(Object v) { return outer.containsValue(v); }\n@@ -1659,2 +1742,2 @@\n-                final StableValueImpl<?>[] values = delegate.values().toArray(GENERATOR);\n-                return StableUtil.renderElements(StableMap.this, \"StableMap\", values);\n+                final StableValueImpl<?>[] values = outer.delegate.values().toArray(GENERATOR);\n+                return StableUtil.renderElements(this, \"StableCollection\", values);\n@@ -1662,0 +1745,6 @@\n+\n+            \/\/ For @ValueBased\n+            private static <V> StableMapValues<V> of(StableMap<?, V> outer) {\n+                return new StableMapValues<>(outer);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":130,"deletions":41,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -42,0 +43,1 @@\n+    @Stable\n@@ -43,0 +45,1 @@\n+    @Stable\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderListView.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+ * @param enumType     the class type of the Enum\n@@ -50,0 +51,2 @@\n+ * @param member       an int predicate that can be used to test if an enum is a member\n+ *                     of the valid inputs (as there might be \"holes\")\n@@ -69,2 +72,1 @@\n-        delegate = delegates[index];\n-        return delegate.orElseSet(new Supplier<R>() {\n+        return delegates[index].orElseSet(new Supplier<R>() {\n@@ -87,0 +89,1 @@\n+        final Collection<Map.Entry<E, StableValueImpl<R>>> entries = new ArrayList<>(delegates.length);\n@@ -88,1 +91,0 @@\n-        final Collection<Map.Entry<E, StableValueImpl<R>>> entries = new ArrayList<>(enumElements.length);\n@@ -102,1 +104,1 @@\n-        final Class<E> enumType = (Class<E>)inputs.iterator().next().getClass();\n+        final Class<E> enumType = ((E) inputs.iterator().next()).getDeclaringClass();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableEnumFunction.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-\/\/ Note: It would be possible to just use `LazyMap::get` with some additional logic\n+\/\/ Note: It would be possible to just use `StableMap::get` with some additional logic\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableFunction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,3 +34,0 @@\n-\/\/ Note: It would be possible to just use `LazyList::get` instead of this\n-\/\/ class but explicitly providing a class like this provides better\n-\/\/ debug capability, exception handling, and may provide better performance.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableIntFunction.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        final Object t = delegate.wrappedContentAcquire();\n+        final Object t = delegate.wrappedContentsAcquire();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableSupplier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-            final Object value = delegates[i + offset].wrappedContentAcquire();\n+            final Object value = delegates[i + offset].wrappedContentsAcquire();\n@@ -66,1 +66,1 @@\n-            final Object value = e.getValue().wrappedContentAcquire();\n+            final Object value = e.getValue().wrappedContentsAcquire();\n@@ -69,1 +69,1 @@\n-                valueString = (\"(this \") + selfName + \")\";\n+                valueString = \"(this \" + selfName + \")\";\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableUtil.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    private static final long CONTENT_OFFSET =\n+    private static final long CONTENTS_OFFSET =\n@@ -56,0 +56,1 @@\n+\n@@ -57,1 +58,0 @@\n-    \/\/ A wrapper method `nullSentinel()` is used for generic type conversion.\n@@ -80,1 +80,1 @@\n-        if (wrappedContentAcquire() != null) {\n+        if (wrappedContentsAcquire() != null) {\n@@ -86,1 +86,1 @@\n-        \/\/ attempt to modify the `wrappedValue`\n+        \/\/ attempt to modify `this.contents`\n@@ -105,1 +105,1 @@\n-        final Object t = wrappedContentAcquire();\n+        final Object t = wrappedContentsAcquire();\n@@ -115,1 +115,1 @@\n-        final Object t = wrappedContentAcquire();\n+        final Object t = wrappedContentsAcquire();\n@@ -122,1 +122,1 @@\n-        return wrappedContentAcquire() != null;\n+        return wrappedContentsAcquire() != null;\n@@ -129,1 +129,1 @@\n-        final Object t = wrappedContentAcquire();\n+        final Object t = wrappedContentsAcquire();\n@@ -152,1 +152,1 @@\n-        final Object t = wrappedContentAcquire();\n+        final Object t = wrappedContentsAcquire();\n@@ -161,2 +161,2 @@\n-    public Object wrappedContentAcquire() {\n-        return UNSAFE.getReferenceAcquire(this, CONTENT_OFFSET);\n+    public Object wrappedContentsAcquire() {\n+        return UNSAFE.getReferenceAcquire(this, CONTENTS_OFFSET);\n@@ -188,1 +188,1 @@\n-    private boolean wrapAndSet(Object newValue) {\n+    private boolean wrapAndSet(T newValue) {\n@@ -192,1 +192,1 @@\n-            UNSAFE.putReferenceRelease(this, CONTENT_OFFSET, wrap(newValue));\n+            UNSAFE.putReferenceRelease(this, CONTENTS_OFFSET, wrap(newValue));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableValueImpl.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -55,1 +55,7 @@\n-        THIRTEEN(13),\n+        THIRTEEN(13) {\n+            @Override\n+            public String toString() {\n+                \/\/ getEnumConstants will be `null` for this enum as it is overridden\n+                return super.toString()+\" (Overridden)\";\n+            }\n+        },\n@@ -199,0 +205,7 @@\n+    @Test\n+    void overriddenEnum() {\n+        final var overridden = Value.THIRTEEN;\n+        Function<Value, Integer> enumFunction = StableValue.function(EnumSet.of(overridden), Value::asInt);\n+        assertEquals(MAPPER.apply(overridden), enumFunction.apply(overridden));\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFunctionTest.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.util.Arrays;\n@@ -49,0 +48,1 @@\n+import java.util.function.Function;\n@@ -50,0 +50,1 @@\n+import java.util.function.UnaryOperator;\n@@ -245,8 +246,1 @@\n-    @Test\n-    void subListToString() {\n-        subListToString0(newList());\n-        subListToString0(newList().subList(1, SIZE));\n-        subListToString0(newList().subList(1, SIZE).subList(0, SIZE - 2));\n-    }\n-\n-    void subListToString0(List<Integer> subList) {\n+    void assertUnevaluated(List<Integer> subList) {\n@@ -254,3 +248,0 @@\n-\n-        var first = subList.getFirst();\n-        assertEquals(asString(first.toString(), subList), subList.toString());\n@@ -274,0 +265,2 @@\n+    \/\/ This test makes sure successive view operations retains the property\n+    \/\/ of being a Stable view.\n@@ -275,11 +268,21 @@\n-    void reversedToString() {\n-        var reversed = newList().reversed();\n-        subListToString0(reversed);\n-    }\n-\n-    @Test\n-    void subListReversedToString() {\n-        var list = newList().subList(1, SIZE - 1).reversed();\n-        \/\/ This combination is not lazy. There has to be a limit somewhere.\n-        var regularList = newRegularList().subList(1, SIZE - 1).reversed();\n-        assertEquals(regularList.toString(), list.toString());\n+    void viewsStable() {\n+        viewOperations().forEach(op0 -> {\n+            viewOperations().forEach( op1 -> {\n+                viewOperations().forEach(op2 -> {\n+                    var list = newList();\n+                    var view1 = op0.apply(list);\n+                    var view2 = op1.apply(view1);\n+                    var view3 = op2.apply(view2);\n+                    var className3 = className(view3);\n+                    var transitions = className(list) + \", \" +\n+                            op0 + \" -> \" + className(view1) + \", \" +\n+                            op1 + \" -> \" + className(view2) + \", \" +\n+                            op2 + \" -> \" + className3;\n+                    assertTrue(className3.contains(\"Stable\"), transitions);\n+                    assertUnevaluated(list);\n+                    assertUnevaluated(view1);\n+                    assertUnevaluated(view2);\n+                    assertUnevaluated(view3);\n+                });\n+            });\n+        });\n@@ -365,0 +368,33 @@\n+    @Test\n+    void childObjectOpsLazy() {\n+        viewOperations().forEach(op0 -> {\n+            viewOperations().forEach(op1 -> {\n+                viewOperations().forEach(op2 -> {\n+                    childOperations().forEach(co -> {\n+                        var list = newList();\n+                        var view1 = op0.apply(list);\n+                        var view2 = op1.apply(view1);\n+                        var view3 = op2.apply(view2);\n+                        var child = co.apply(view3);\n+                        var childClassName = className(child);\n+                        var transitions = className(list) + \", \" +\n+                                op0 + \" -> \" + className(view1) + \", \" +\n+                                op1 + \" -> \" + className(view2) + \", \" +\n+                                op2 + \" -> \" + className(view3) + \", \" +\n+                                co + \" -> \" + childClassName;\n+\n+                        \/\/ None of these operations should trigger evaluation\n+                        var childToString = child.toString();\n+                        int childHashCode = child.hashCode();\n+                        boolean childEqualToNewObj = child.equals(new Object());\n+\n+                        assertUnevaluated(list);\n+                        assertUnevaluated(view1);\n+                        assertUnevaluated(view2);\n+                        assertUnevaluated(view3);\n+                    });\n+                });\n+            });\n+        });\n+    }\n+\n@@ -373,0 +409,30 @@\n+    record UnaryOperation(String name,\n+                     UnaryOperator<List<Integer>> operator) implements UnaryOperator<List<Integer>> {\n+        @Override public List<Integer> apply(List<Integer> list) { return operator.apply(list); }\n+        @Override public String toString() { return name; }\n+    }\n+\n+    record ListFunction(String name,\n+                        Function<List<Integer>, Object> function) implements Function<List<Integer>, Object> {\n+        @Override public Object apply(List<Integer> list) { return function.apply(list); }\n+        @Override public String toString() { return name; }\n+    }\n+\n+    static Stream<UnaryOperation> viewOperations() {\n+        return Stream.of(\n+                \/\/ We need identity to capture all combinations\n+                new UnaryOperation(\"identity\", l -> l),\n+                new UnaryOperation(\"reversed\", List::reversed),\n+                new UnaryOperation(\"subList\", l -> l.subList(0, l.size()))\n+        );\n+    }\n+\n+    static Stream<ListFunction> childOperations() {\n+        return Stream.of(\n+                \/\/ We need identity to capture all combinations\n+                new ListFunction(\"iterator\", List::iterator),\n+                new ListFunction(\"listIterator\", List::listIterator),\n+                new ListFunction(\"listIterator\", List::stream)\n+        );\n+    }\n+\n@@ -436,0 +502,3 @@\n+    static String className(Object o) {\n+        return o.getClass().getName();\n+    }\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableListTest.java","additions":92,"deletions":23,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.ArrayList;\n@@ -358,1 +359,1 @@\n-        CountDownLatch starter = new CountDownLatch(1);\n+        CountDownLatch starter = new CountDownLatch(noThreads);\n@@ -363,1 +364,3 @@\n-                        \/\/ Ready, set ...\n+                        \/\/ Ready ...\n+                        starter.countDown();\n+                        \/\/ ... set ...\n@@ -373,3 +376,0 @@\n-        LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(1));\n-        \/\/ Start the race\n-        starter.countDown();\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValueTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -68,1 +68,2 @@\n-    private static MethodHandle mh = identityHandle();\n+\n+    private static \/* intentionally not final *\/ MethodHandle mh = identityHandle();\n@@ -115,8 +116,0 @@\n-    Object cp() {\n-        CodeBuilder cob = null;\n-        ConstantPoolBuilder cp = ConstantPoolBuilder.of();\n-        cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(cp.methodHandleEntry(BSM_CLASS_DATA), List.of()),\n-                cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle)));\n-        return null;\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableMethodHandleBenchmark.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"}]}