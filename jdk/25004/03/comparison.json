{"files":[{"patch":"@@ -387,2 +387,2 @@\n- * Invocations of {@link #setOrThrow(Object)} form a total order of zero or more\n- * exceptional invocations followed by zero (if the contents were already set) or one\n+ * Invocations of {@link #orElseSet(Supplier)} form a total order of zero or\n+ * more exceptional invocations followed by zero (if the contents were already set) or one\n@@ -447,2 +447,0 @@\n-    \/\/ Principal methods\n-\n@@ -512,2 +510,0 @@\n-    \/\/ Convenience methods\n-\n@@ -522,0 +518,3 @@\n+     * @throws IllegalStateException if a supplier invoked by {@link #orElseSet(Supplier)}\n+     *         recursively attempts to set this stable value by calling this method\n+     *         directly or indirectly.\n@@ -576,2 +575,2 @@\n-     * thrown by the computing thread. The computing threads will then observe the newly\n-     * computed value (if any) and will then never execute.\n+     * thrown by the computing thread. The competing threads will then observe the newly\n+     * computed value (if any) and will then never execute the {@code underlying} supplier.\n@@ -617,3 +616,3 @@\n-     * @param size       the size of the allowed inputs in the continuous\n-     *                   interval {@code [0, size)}\n-     * @param underlying IntFunction used to compute cached values\n+     * @param size       the upper bound of the range {@code [0, size)} indicating\n+     *                   the allowed inputs\n+     * @param underlying {@code IntFunction} used to compute cached values\n@@ -687,1 +686,1 @@\n-     * Any direct {@link List#subList(int, int) subList} or {@link List#reversed()} views\n+     * Any {@link List#subList(int, int) subList} or {@link List#reversed()} views\n@@ -730,2 +729,2 @@\n-     * Any direct {@link Map#values()} or {@link Map#entrySet()} views\n-     * of the returned map are also stable.\n+     * Any {@link Map#values()} or {@link Map#entrySet()} views of the returned map are\n+     * also stable.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StableValue.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-import jdk.internal.util.NullableKeyValueHolder;\n@@ -140,1 +139,2 @@\n-                    return ImmutableCollections.stableList(size, mapper);\n+                    \/\/ A stable list is not Serializable, so we cannot return `List.of()` if `size == 0`\n+                    return new StableList<>(size, mapper);\n@@ -143,0 +143,1 @@\n+                    \/\/ A stable map is not Serializable, so we cannot return `Map.of()` if `keys.isEmpty()`\n@@ -267,5 +268,0 @@\n-    static <E> List<E> stableList(int size, IntFunction<? extends E> mapper) {\n-        \/\/ A lazy list is not Serializable so, we cannot return `List.of()` if size == 0\n-        return new StableList<>(size, mapper);\n-    }\n-\n@@ -457,1 +453,1 @@\n-    static final class SubList<E> extends AbstractImmutableList<E>\n+    static sealed class SubList<E> extends AbstractImmutableList<E>\n@@ -461,1 +457,1 @@\n-        private final AbstractImmutableList<E> root;\n+        final AbstractImmutableList<E> root;\n@@ -464,1 +460,1 @@\n-        private final int offset;\n+        final int offset;\n@@ -467,1 +463,1 @@\n-        private final int size;\n+        final int size;\n@@ -520,3 +516,2 @@\n-        private boolean allowNulls() {\n-            return root instanceof ListN<?> listN && listN.allowNulls\n-                    || root instanceof StableList<E>;\n+        boolean allowNulls() {\n+            return root instanceof ListN<?> listN && listN.allowNulls;\n@@ -575,8 +570,0 @@\n-        @Override\n-        public String toString() {\n-            if (root instanceof StableList<E> stableList) {\n-                return StableUtil.renderElements(root, \"StableList\", stableList.delegates, offset, size);\n-            } else {\n-                return super.toString();\n-            }\n-        }\n@@ -800,0 +787,5 @@\n+    @FunctionalInterface\n+    interface HasStableDelegates<E> {\n+        StableValueImpl<E>[] delegates();\n+    }\n+\n@@ -801,1 +793,3 @@\n-    static final class StableList<E> extends AbstractImmutableList<E> {\n+    static final class StableList<E>\n+            extends AbstractImmutableList<E>\n+            implements HasStableDelegates<E> {\n@@ -881,0 +875,6 @@\n+        @Override\n+        public List<E> subList(int fromIndex, int toIndex) {\n+            subListRangeCheck(fromIndex, toIndex, size());\n+            return StableSubList.fromStableList(this, fromIndex, toIndex);\n+        }\n+\n@@ -883,1 +883,1 @@\n-            return StableUtil.renderElements(this, \"StableList\", delegates);\n+            return StableUtil.renderElements(this, \"StableCollection\", delegates);\n@@ -886,1 +886,53 @@\n-        private static final class StableReverseOrderListView<E> extends ReverseOrderListView.Rand<E> {\n+        @Override\n+        public StableValueImpl<E>[] delegates() {\n+            return delegates;\n+        }\n+\n+        private static final class StableSubList<E> extends SubList<E>\n+                implements HasStableDelegates<E> {\n+\n+            private StableSubList(AbstractImmutableList<E> root, int offset, int size) {\n+                super(root, offset, size);\n+            }\n+\n+            @Override\n+            public List<E> reversed() {\n+                return new StableReverseOrderListView<>(this);\n+            }\n+\n+            @Override\n+            public List<E> subList(int fromIndex, int toIndex) {\n+                subListRangeCheck(fromIndex, toIndex, size());\n+                return StableSubList.fromStableSubList(this, fromIndex, toIndex);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return StableUtil.renderElements(this, \"StableCollection\", delegates());\n+            }\n+\n+            @Override\n+            boolean allowNulls() {\n+                return true;\n+            }\n+\n+            @Override\n+            public StableValueImpl<E>[] delegates() {\n+                @SuppressWarnings(\"unchecked\")\n+                final var rootDelegates = ((HasStableDelegates<E>) root).delegates();\n+                return Arrays.copyOfRange(rootDelegates, offset, offset + size);\n+            }\n+\n+            static <E> SubList<E> fromStableList(StableList<E> list, int fromIndex, int toIndex) {\n+                return new StableSubList<>(list, fromIndex, toIndex - fromIndex);\n+            }\n+\n+            static <E> SubList<E> fromStableSubList(StableSubList<E> parent, int fromIndex, int toIndex) {\n+                return new StableSubList<>(parent.root, parent.offset + fromIndex, toIndex - fromIndex);\n+            }\n+\n+        }\n+\n+        private static final class StableReverseOrderListView<E>\n+                extends ReverseOrderListView.Rand<E>\n+                implements HasStableDelegates<E> {\n@@ -895,4 +947,1 @@\n-                final StableValueImpl<E>[] delegates = ((StableList<E>)base).delegates;\n-                final StableValueImpl<E>[] reversed = ArraysSupport.reverse(\n-                        Arrays.copyOf(delegates, delegates.length));\n-                return StableUtil.renderElements(base, \"Collection\", reversed);\n+                return StableUtil.renderElements(this, \"StableCollection\", delegates());\n@@ -902,2 +951,4 @@\n-            public List<E> reversed() {\n-                return base;\n+            public List<E> subList(int fromIndex, int toIndex) {\n+                final int size = base.size();\n+                subListRangeCheck(fromIndex, toIndex, size);\n+                return new StableReverseOrderListView<>(base.subList(size - toIndex, size - fromIndex));\n@@ -906,0 +957,7 @@\n+            @Override\n+            public StableValueImpl<E>[] delegates() {\n+                @SuppressWarnings(\"unchecked\")\n+                final var baseDelegates = ((HasStableDelegates<E>) base).delegates();\n+                return ArraysSupport.reverse(\n+                        Arrays.copyOf(baseDelegates, baseDelegates.length));\n+            }\n@@ -1563,1 +1621,1 @@\n-        @Override public Set<Map.Entry<K, V>> entrySet() { return new StableMapEntrySet(); }\n+        @Override public Set<Map.Entry<K, V>> entrySet() { return StableMapEntrySet.of(this); }\n@@ -1585,1 +1643,6 @@\n-        final class StableMapEntrySet extends AbstractImmutableSet<Map.Entry<K, V>> {\n+        static final class StableMapEntrySet<K, V> extends AbstractImmutableSet<Map.Entry<K, V>> {\n+\n+            \/\/ Use a separate field for the outer class in order to facilitate\n+            \/\/ a @Stable annotation.\n+            @Stable\n+            private final StableMap<K, V> outer;\n@@ -1590,2 +1653,3 @@\n-            StableMapEntrySet() {\n-                this.delegateEntrySet = delegate.entrySet();\n+            private StableMapEntrySet(StableMap<K, V> outer) {\n+                this.outer = outer;\n+                this.delegateEntrySet = outer.delegate.entrySet();\n@@ -1594,1 +1658,1 @@\n-            @Override public Iterator<Map.Entry<K, V>> iterator() { return new LazyMapIterator(); }\n+            @Override public Iterator<Map.Entry<K, V>> iterator() { return LazyMapIterator.of(this); }\n@@ -1596,1 +1660,1 @@\n-            @Override public int                       hashCode() { return StableMap.this.hashCode(); }\n+            @Override public int                       hashCode() { return outer.hashCode(); }\n@@ -1600,1 +1664,6 @@\n-                return StableUtil.renderMappings(this, \"StableSet\", delegateEntrySet, false);\n+                return StableUtil.renderMappings(this, \"StableCollection\", delegateEntrySet, false);\n+            }\n+\n+            \/\/ For @ValueBased\n+            private static <K, V> StableMapEntrySet<K, V> of(StableMap<K, V> outer) {\n+                return new StableMapEntrySet<>(outer);\n@@ -1604,1 +1673,6 @@\n-            final class LazyMapIterator implements Iterator<Map.Entry<K, V>> {\n+            static final class LazyMapIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n+\n+                \/\/ Use a separate field for the outer class in order to facilitate\n+                \/\/ a @Stable annotation.\n+                @Stable\n+                private final StableMapEntrySet<K, V> outer;\n@@ -1609,2 +1683,3 @@\n-                LazyMapIterator() {\n-                    this.delegateIterator = delegateEntrySet.iterator();\n+                private LazyMapIterator(StableMapEntrySet<K, V> outer) {\n+                    this.outer = outer;\n+                    this.delegateIterator = outer.delegateEntrySet.iterator();\n@@ -1619,2 +1694,2 @@\n-                    return new NullableKeyValueHolder<>(k, inner.getValue().orElseSet(new Supplier<V>() {\n-                        @Override public V get() { return mapper.apply(k); }}));\n+                    return new StableEntry<>(k, inner.getValue(), new Supplier<V>() {\n+                        @Override public V get() { return outer.outer.mapper.apply(k); }});\n@@ -1630,2 +1705,2 @@\n-                                    action.accept(new NullableKeyValueHolder<>(k, inner.getValue().orElseSet(new Supplier<V>() {\n-                                        @Override public V get() { return mapper.apply(k); }})));\n+                                    action.accept(new StableEntry<>(k, inner.getValue(), new Supplier<V>() {\n+                                        @Override public V get() { return outer.outer.mapper.apply(k); }}));\n@@ -1636,0 +1711,6 @@\n+\n+                \/\/ For @ValueBased\n+                private static  <K, V> LazyMapIterator<K, V> of(StableMapEntrySet<K, V> outer) {\n+                    return new LazyMapIterator<>(outer);\n+                }\n+\n@@ -1639,0 +1720,18 @@\n+        private record StableEntry<K, V>(K getKey, \/\/ trick\n+                                         StableValueImpl<V> stableValue,\n+                                         Supplier<? extends V> supplier) implements Map.Entry<K, V> {\n+\n+            @Override public V setValue(V value) { throw uoe(); }\n+            @Override public V getValue() { return stableValue.orElseSet(supplier); }\n+            @Override public int hashCode() { return hash(getKey()) ^ hash(getValue()); }\n+            @Override public String toString() { return getKey() + \"=\" + stableValue.toString(); }\n+            @Override public boolean equals(Object o) {\n+                return o instanceof Map.Entry<?, ?> e\n+                        && Objects.equals(getKey(), e.getKey())\n+                        \/\/ Invoke `getValue()` as late as possible to avoid evaluation\n+                        && Objects.equals(getValue(), e.getValue());\n+            }\n+\n+            private int hash(Object obj) { return (obj == null) ? 0 : obj.hashCode(); }\n+        }\n+\n@@ -1641,1 +1740,1 @@\n-            return new StableMapValues();\n+            return StableMapValues.of(this);\n@@ -1644,5 +1743,16 @@\n-        final class StableMapValues extends AbstractImmutableCollection<V> {\n-            @Override public Iterator<V> iterator() { return new ValueIterator(); }\n-            @Override public int size() { return StableMap.this.size(); }\n-            @Override public boolean isEmpty() { return StableMap.this.isEmpty();}\n-            @Override public boolean contains(Object v) { return StableMap.this.containsValue(v); }\n+        @jdk.internal.ValueBased\n+        static final class StableMapValues<V> extends AbstractImmutableCollection<V> {\n+\n+            \/\/ Use a separate field for the outer class in order to facilitate\n+            \/\/ a @Stable annotation.\n+            @Stable\n+            private final StableMap<?, V> outer;\n+\n+            private StableMapValues(StableMap<?, V> outer) {\n+                this.outer = outer;\n+            }\n+\n+            @Override public Iterator<V> iterator() { return outer.new ValueIterator(); }\n+            @Override public int size() { return outer.size(); }\n+            @Override public boolean isEmpty() { return outer.isEmpty();}\n+            @Override public boolean contains(Object v) { return outer.containsValue(v); }\n@@ -1659,2 +1769,7 @@\n-                final StableValueImpl<?>[] values = delegate.values().toArray(GENERATOR);\n-                return StableUtil.renderElements(StableMap.this, \"StableMap\", values);\n+                final StableValueImpl<?>[] values = outer.delegate.values().toArray(GENERATOR);\n+                return StableUtil.renderElements(this, \"StableCollection\", values);\n+            }\n+\n+            \/\/ For @ValueBased\n+            private static <V> StableMapValues<V> of(StableMap<?, V> outer) {\n+                return new StableMapValues<>(outer);\n@@ -1662,0 +1777,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":169,"deletions":53,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -42,0 +43,1 @@\n+    @Stable\n@@ -43,1 +45,2 @@\n-    final boolean modifiable;\n+    @Stable\n+    final Boolean modifiable;\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderListView.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+ * @param enumType     the class type of the Enum\n@@ -50,0 +51,2 @@\n+ * @param member       an int predicate that can be used to test if an enum is a member\n+ *                     of the valid inputs (as there might be \"holes\")\n@@ -67,1 +70,0 @@\n-        final StableValueImpl<R> delegate;\n@@ -69,2 +71,1 @@\n-        delegate = delegates[index];\n-        return delegate.orElseSet(new Supplier<R>() {\n+        return delegates[index].orElseSet(new Supplier<R>() {\n@@ -87,0 +88,1 @@\n+        final Collection<Map.Entry<E, StableValueImpl<R>>> entries = new ArrayList<>(delegates.length);\n@@ -88,1 +90,0 @@\n-        final Collection<Map.Entry<E, StableValueImpl<R>>> entries = new ArrayList<>(enumElements.length);\n@@ -102,1 +103,1 @@\n-        final Class<E> enumType = (Class<E>)inputs.iterator().next().getClass();\n+        final Class<E> enumType = ((E) inputs.iterator().next()).getDeclaringClass();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableEnumFunction.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-\/\/ Note: It would be possible to just use `LazyMap::get` with some additional logic\n+\/\/ Note: It would be possible to just use `StableMap::get` with some additional logic\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableFunction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,3 +34,0 @@\n-\/\/ Note: It would be possible to just use `LazyList::get` instead of this\n-\/\/ class but explicitly providing a class like this provides better\n-\/\/ debug capability, exception handling, and may provide better performance.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableIntFunction.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        final Object t = delegate.wrappedContentAcquire();\n+        final Object t = delegate.wrappedContentsAcquire();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableSupplier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-            final Object value = delegates[i + offset].wrappedContentAcquire();\n+            final Object value = delegates[i + offset].wrappedContentsAcquire();\n@@ -66,1 +66,1 @@\n-            final Object value = e.getValue().wrappedContentAcquire();\n+            final Object value = e.getValue().wrappedContentsAcquire();\n@@ -69,1 +69,1 @@\n-                valueString = (\"(this \") + selfName + \")\";\n+                valueString = \"(this \" + selfName + \")\";\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableUtil.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    private static final long CONTENT_OFFSET =\n+    private static final long CONTENTS_OFFSET =\n@@ -56,2 +56,2 @@\n-    \/\/ Used to indicate a holder value is `null` (see field `value` below)\n-    \/\/ A wrapper method `nullSentinel()` is used for generic type conversion.\n+\n+    \/\/ Used to indicate a holder value is `null` (see field `contents` below)\n@@ -80,1 +80,1 @@\n-        if (wrappedContentAcquire() != null) {\n+        if (wrappedContentsAcquire() != null) {\n@@ -86,1 +86,1 @@\n-        \/\/ attempt to modify the `wrappedValue`\n+        \/\/ attempt to modify `this.contents`\n@@ -105,1 +105,1 @@\n-        final Object t = wrappedContentAcquire();\n+        final Object t = wrappedContentsAcquire();\n@@ -115,1 +115,1 @@\n-        final Object t = wrappedContentAcquire();\n+        final Object t = wrappedContentsAcquire();\n@@ -122,1 +122,1 @@\n-        return wrappedContentAcquire() != null;\n+        return wrappedContentsAcquire() != null;\n@@ -129,1 +129,1 @@\n-        final Object t = wrappedContentAcquire();\n+        final Object t = wrappedContentsAcquire();\n@@ -152,1 +152,1 @@\n-        final Object t = wrappedContentAcquire();\n+        final Object t = wrappedContentsAcquire();\n@@ -161,2 +161,2 @@\n-    public Object wrappedContentAcquire() {\n-        return UNSAFE.getReferenceAcquire(this, CONTENT_OFFSET);\n+    public Object wrappedContentsAcquire() {\n+        return UNSAFE.getReferenceAcquire(this, CONTENTS_OFFSET);\n@@ -188,1 +188,1 @@\n-    private boolean wrapAndSet(Object newValue) {\n+    private boolean wrapAndSet(T newValue) {\n@@ -192,1 +192,1 @@\n-            UNSAFE.putReferenceRelease(this, CONTENT_OFFSET, wrap(newValue));\n+            UNSAFE.putReferenceRelease(this, CONTENTS_OFFSET, wrap(newValue));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableValueImpl.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -55,1 +55,7 @@\n-        THIRTEEN(13),\n+        THIRTEEN(13) {\n+            @Override\n+            public String toString() {\n+                \/\/ getEnumConstants will be `null` for this enum as it is overridden\n+                return super.toString()+\" (Overridden)\";\n+            }\n+        },\n@@ -199,0 +205,7 @@\n+    @Test\n+    void overriddenEnum() {\n+        final var overridden = Value.THIRTEEN;\n+        Function<Value, Integer> enumFunction = StableValue.function(EnumSet.of(overridden), Value::asInt);\n+        assertEquals(MAPPER.apply(overridden), enumFunction.apply(overridden));\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFunctionTest.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.util.Arrays;\n@@ -49,0 +48,1 @@\n+import java.util.function.Function;\n@@ -50,0 +50,1 @@\n+import java.util.function.UnaryOperator;\n@@ -245,8 +246,1 @@\n-    @Test\n-    void subListToString() {\n-        subListToString0(newList());\n-        subListToString0(newList().subList(1, SIZE));\n-        subListToString0(newList().subList(1, SIZE).subList(0, SIZE - 2));\n-    }\n-\n-    void subListToString0(List<Integer> subList) {\n+    void assertUnevaluated(List<Integer> subList) {\n@@ -254,3 +248,0 @@\n-\n-        var first = subList.getFirst();\n-        assertEquals(asString(first.toString(), subList), subList.toString());\n@@ -275,3 +266,15 @@\n-    void reversedToString() {\n-        var reversed = newList().reversed();\n-        subListToString0(reversed);\n+    void sublistReversedToString() {\n+        var actual = StableValue.list(4, IDENTITY);\n+        var expected = List.of(0, 1, 2, 3);\n+        for (UnaryOperation op : List.of(\n+                new UnaryOperation(\"subList\", l -> l.subList(1, 3)),\n+                new UnaryOperation(\"reversed\", List::reversed))) {\n+            actual = op.apply(actual);\n+            expected = op.apply(expected);\n+        }\n+        \/\/ Touch one of the elements\n+        actual.getLast();\n+\n+        var actualToString = actual.toString();\n+        var expectedToString = expected.toString().replace(\"2\", \".unset\");\n+        assertEquals(expectedToString, actualToString);\n@@ -280,0 +283,2 @@\n+    \/\/ This test makes sure successive view operations retains the property\n+    \/\/ of being a Stable view.\n@@ -281,5 +286,21 @@\n-    void subListReversedToString() {\n-        var list = newList().subList(1, SIZE - 1).reversed();\n-        \/\/ This combination is not lazy. There has to be a limit somewhere.\n-        var regularList = newRegularList().subList(1, SIZE - 1).reversed();\n-        assertEquals(regularList.toString(), list.toString());\n+    void viewsStable() {\n+        viewOperations().forEach(op0 -> {\n+            viewOperations().forEach( op1 -> {\n+                viewOperations().forEach(op2 -> {\n+                    var list = newList();\n+                    var view1 = op0.apply(list);\n+                    var view2 = op1.apply(view1);\n+                    var view3 = op2.apply(view2);\n+                    var className3 = className(view3);\n+                    var transitions = className(list) + \", \" +\n+                            op0 + \" -> \" + className(view1) + \", \" +\n+                            op1 + \" -> \" + className(view2) + \", \" +\n+                            op2 + \" -> \" + className3;\n+                    assertTrue(className3.contains(\"Stable\"), transitions);\n+                    assertUnevaluated(list);\n+                    assertUnevaluated(view1);\n+                    assertUnevaluated(view2);\n+                    assertUnevaluated(view3);\n+                });\n+            });\n+        });\n@@ -297,0 +318,17 @@\n+    @Test\n+    void indexOfNullInViews() {\n+        final int size = 5;\n+        final int middle = 2;\n+        viewOperations().forEach(op0 -> {\n+            viewOperations().forEach( op1 -> {\n+                viewOperations().forEach(op2 -> {\n+                    var list = StableValue.list(size, x -> x == middle ? null : x);;\n+                    var view1 = op0.apply(list);\n+                    var view2 = op1.apply(view1);\n+                    var view3 = op2.apply(view2);\n+                    assertEquals(middle, view3.indexOf(null));\n+                });\n+            });\n+        });\n+    }\n+\n@@ -365,0 +403,33 @@\n+    @Test\n+    void childObjectOpsLazy() {\n+        viewOperations().forEach(op0 -> {\n+            viewOperations().forEach(op1 -> {\n+                viewOperations().forEach(op2 -> {\n+                    childOperations().forEach(co -> {\n+                        var list = newList();\n+                        var view1 = op0.apply(list);\n+                        var view2 = op1.apply(view1);\n+                        var view3 = op2.apply(view2);\n+                        var child = co.apply(view3);\n+                        var childClassName = className(child);\n+                        var transitions = className(list) + \", \" +\n+                                op0 + \" -> \" + className(view1) + \", \" +\n+                                op1 + \" -> \" + className(view2) + \", \" +\n+                                op2 + \" -> \" + className(view3) + \", \" +\n+                                co + \" -> \" + childClassName;\n+\n+                        \/\/ None of these operations should trigger evaluation\n+                        var childToString = child.toString();\n+                        int childHashCode = child.hashCode();\n+                        boolean childEqualToNewObj = child.equals(new Object());\n+\n+                        assertUnevaluated(list);\n+                        assertUnevaluated(view1);\n+                        assertUnevaluated(view2);\n+                        assertUnevaluated(view3);\n+                    });\n+                });\n+            });\n+        });\n+    }\n+\n@@ -373,0 +444,30 @@\n+    record UnaryOperation(String name,\n+                     UnaryOperator<List<Integer>> operator) implements UnaryOperator<List<Integer>> {\n+        @Override public List<Integer> apply(List<Integer> list) { return operator.apply(list); }\n+        @Override public String toString() { return name; }\n+    }\n+\n+    record ListFunction(String name,\n+                        Function<List<Integer>, Object> function) implements Function<List<Integer>, Object> {\n+        @Override public Object apply(List<Integer> list) { return function.apply(list); }\n+        @Override public String toString() { return name; }\n+    }\n+\n+    static Stream<UnaryOperation> viewOperations() {\n+        return Stream.of(\n+                \/\/ We need identity to capture all combinations\n+                new UnaryOperation(\"identity\", l -> l),\n+                new UnaryOperation(\"reversed\", List::reversed),\n+                new UnaryOperation(\"subList\", l -> l.subList(0, l.size()))\n+        );\n+    }\n+\n+    static Stream<ListFunction> childOperations() {\n+        return Stream.of(\n+                \/\/ We need identity to capture all combinations\n+                new ListFunction(\"iterator\", List::iterator),\n+                new ListFunction(\"listIterator\", List::listIterator),\n+                new ListFunction(\"listIterator\", List::stream)\n+        );\n+    }\n+\n@@ -436,0 +537,3 @@\n+    static String className(Object o) {\n+        return o.getClass().getName();\n+    }\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableListTest.java","additions":124,"deletions":20,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -251,0 +251,31 @@\n+    @Test\n+    void stableEntry() {\n+        var map = newMap();\n+        var entry = map.entrySet().stream()\n+                .filter(e -> e.getKey().equals(KEY))\n+                .findAny()\n+                .orElseThrow();\n+\n+        assertEquals(KEY + \"=.unset\", entry.toString());\n+        var otherDifferent = Map.entry(-1, -1);\n+        assertNotEquals(entry, otherDifferent);\n+        assertEquals(KEY + \"=.unset\", entry.toString());\n+        var otherEqual = Map.entry(KEY, KEY);\n+        assertEquals(entry, otherEqual);\n+        assertEquals(KEY + \"=\" + KEY, entry.toString());\n+        assertEquals(entry.hashCode(), otherEqual.hashCode());\n+    }\n+\n+    @Test\n+    void stableForEachEntry() {\n+        var map = newMap();\n+        \/\/ Only touch the key.\n+        map.entrySet().iterator().forEachRemaining(Map.Entry::getKey);\n+        map.entrySet().iterator()\n+                .forEachRemaining(e -> assertTrue(e.toString().contains(\".unset\")));\n+        \/\/ Only touch the value.\n+        map.entrySet().iterator().forEachRemaining(Map.Entry::getValue);\n+        map.entrySet().iterator()\n+                .forEachRemaining(e -> assertFalse(e.toString().contains(\".unset\")));\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableMapTest.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.ArrayList;\n@@ -358,1 +359,1 @@\n-        CountDownLatch starter = new CountDownLatch(1);\n+        CountDownLatch starter = new CountDownLatch(noThreads);\n@@ -363,1 +364,3 @@\n-                        \/\/ Ready, set ...\n+                        \/\/ Ready ...\n+                        starter.countDown();\n+                        \/\/ ... set ...\n@@ -373,3 +376,0 @@\n-        LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(1));\n-        \/\/ Start the race\n-        starter.countDown();\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValueTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -68,1 +68,2 @@\n-    private static MethodHandle mh = identityHandle();\n+\n+    private static \/* intentionally not final *\/ MethodHandle mh = identityHandle();\n@@ -115,8 +116,0 @@\n-    Object cp() {\n-        CodeBuilder cob = null;\n-        ConstantPoolBuilder cp = ConstantPoolBuilder.of();\n-        cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(cp.methodHandleEntry(BSM_CLASS_DATA), List.of()),\n-                cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle)));\n-        return null;\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableMethodHandleBenchmark.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"}]}