{"files":[{"patch":"@@ -54,0 +54,1 @@\n+import jdk.internal.net.http.LimitingSubscriber;\n@@ -751,0 +752,24 @@\n+\n+        \/**\n+         * {@return a handler limiting the number of bytes consumed and passed to the given downstream}\n+         *\n+         * @param downstreamHandler the downstream handler to pass received data to\n+         * @param capacity the maximum number of bytes that are allowed\n+         * @param discardExcess if {@code true}, excessive input will be discarded; otherwise, it will throw an exception\n+         * @throws IllegalArgumentException if {@code capacity < 0}\n+         * @since 25\n+         *\/\n+        public static <T> BodyHandler<T> limiting(\n+                BodyHandler<T> downstreamHandler,\n+                long capacity,\n+                boolean discardExcess) {\n+            Objects.requireNonNull(downstreamHandler, \"downstreamHandler\");\n+            if (capacity < 0) {\n+                throw new IllegalArgumentException(\"was expecting \\\"capacity >= 0\\\", found: \" + capacity);\n+            }\n+            return responseInfo -> {\n+                BodySubscriber<T> downstreamSubscriber = downstreamHandler.apply(responseInfo);\n+                return BodySubscribers.limiting(downstreamSubscriber, capacity, discardExcess);\n+            };\n+        }\n+\n@@ -1353,0 +1378,18 @@\n+\n+        \/**\n+         * {@return a subscriber limiting the number of bytes consumed and passed to the given downstream}\n+         *\n+         * @param downstreamSubscriber the downstream subscriber to pass received data to\n+         * @param capacity the maximum number of bytes that are allowed\n+         * @param discardExcess if {@code true}, excessive input will be discarded; otherwise, it will throw an exception\n+         * @throws IllegalArgumentException if {@code capacity < 0}\n+         * @since 25\n+         *\/\n+        public static <T> BodySubscriber<T> limiting(\n+                BodySubscriber<T> downstreamSubscriber,\n+                long capacity,\n+                boolean discardExcess) {\n+            Objects.requireNonNull(downstreamSubscriber, \"downstreamSubscriber\");\n+            return new LimitingSubscriber<>(downstreamSubscriber, capacity, discardExcess);\n+        }\n+\n@@ -1354,0 +1397,1 @@\n+\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpResponse.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http;\n+\n+import jdk.internal.net.http.ResponseSubscribers.TrustedSubscriber;\n+import jdk.internal.net.http.common.Utils;\n+\n+import java.net.http.HttpResponse.BodySubscriber;\n+import java.nio.Buffer;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * A subscriber limiting the maximum number of bytes that are allowed to be consumed by a downstream subscriber.\n+ *\n+ * @param <T> the response type\n+ *\/\n+public final class LimitingSubscriber<T> implements TrustedSubscriber<T> {\n+\n+    private final BodySubscriber<T> downstreamSubscriber;\n+\n+    private final long capacity;\n+\n+    private final boolean discardExcess;\n+\n+    private final AtomicReference<Subscription> subscriptionRef = new AtomicReference<>();\n+\n+    private long length;\n+\n+    \/**\n+     * @param downstreamSubscriber the downstream subscriber to pass received data to\n+     * @param capacity the maximum number of bytes that are allowed\n+     * @param discardExcess if {@code true}, excessive input will be discarded; otherwise, it will throw an exception\n+     * @throws IllegalArgumentException if {@code capacity < 0}\n+     *\/\n+    public LimitingSubscriber(BodySubscriber<T> downstreamSubscriber, long capacity, boolean discardExcess) {\n+        if (capacity < 0) {\n+            throw new IllegalArgumentException(\"was expecting \\\"capacity >= 0\\\", found: \" + capacity);\n+        }\n+        this.downstreamSubscriber = requireNonNull(downstreamSubscriber, \"downstreamSubscriber\");\n+        this.capacity = capacity;\n+        this.discardExcess = discardExcess;\n+    }\n+\n+    @Override\n+    public void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        boolean alreadySubscribed = !subscriptionRef.compareAndSet(null, subscription);\n+        if (alreadySubscribed) {\n+            subscription.cancel();\n+        } else {\n+            length = 0;\n+            downstreamSubscriber.onSubscribe(subscription);\n+        }\n+    }\n+\n+    @Override\n+    public void onNext(List<ByteBuffer> buffers) {\n+\n+        \/\/ Check arguments\n+        requireNonNull(buffers, \"buffers\");\n+        assert Utils.hasRemaining(buffers);\n+\n+        \/\/ See if we can consume the input completely\n+        boolean lengthAllocated = allocateLength(buffers);\n+        Subscription subscription = subscriptionRef.get();\n+        assert subscription != null;\n+        if (lengthAllocated) {\n+            downstreamSubscriber.onNext(buffers);\n+        }\n+\n+        \/\/ See if we can consume the input partially\n+        else if (discardExcess) {\n+            List<ByteBuffer> retainedBuffers = removeExcess(buffers);\n+            if (!retainedBuffers.isEmpty()) {\n+                downstreamSubscriber.onNext(retainedBuffers);\n+            }\n+            downstreamSubscriber.onComplete();\n+            subscription.cancel();\n+        }\n+\n+        \/\/ Partial consumption is not allowed, trigger failure\n+        else {\n+            downstreamSubscriber.onError(new IllegalStateException(\n+                    \"the maximum number of bytes that are allowed to be consumed is exceeded\"));\n+            subscription.cancel();\n+        }\n+\n+    }\n+\n+    private boolean allocateLength(List<ByteBuffer> buffers) {\n+        long bufferLength = buffers.stream().mapToLong(Buffer::remaining).sum();\n+        long nextReceivedByteCount = Math.addExact(length, bufferLength);\n+        if (nextReceivedByteCount > capacity) {\n+            return false;\n+        }\n+        length = nextReceivedByteCount;\n+        return true;\n+    }\n+\n+    private List<ByteBuffer> removeExcess(List<ByteBuffer> buffers) {\n+        List<ByteBuffer> retainedBuffers = new ArrayList<>(buffers.size());\n+        long remaining = capacity - length;\n+        for (ByteBuffer buffer : buffers) {\n+            \/\/ No capacity left; stop\n+            if (remaining < 1) {\n+                break;\n+            }\n+            \/\/ Buffer fits as is; keep it\n+            else if (buffer.remaining() <= remaining) {\n+                retainedBuffers.add(buffer);\n+                remaining -= buffer.remaining();\n+            }\n+            \/\/ There is capacity, but the buffer doesn't fit; truncate and keep it\n+            else {\n+                buffer.limit(Math.toIntExact(Math.addExact(buffer.position(), remaining)));\n+                retainedBuffers.add(buffer);\n+                remaining = 0;\n+            }\n+        }\n+        return retainedBuffers;\n+    }\n+\n+    @Override\n+    public void onError(Throwable throwable) {\n+        requireNonNull(throwable, \"throwable\");\n+        downstreamSubscriber.onError(throwable);\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        downstreamSubscriber.onComplete();\n+    }\n+\n+    @Override\n+    public CompletionStage<T> getBody() {\n+        return downstreamSubscriber.getBody();\n+    }\n+\n+}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/LimitingSubscriber.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,315 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8328919\n+ * @summary verifies `BodyHandlers.limiting()` behaviour\n+ * @library \/test\/lib\n+ * @run junit HttpResponseLimitingTest\n+ *\/\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandler;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.net.http.HttpResponse.BodySubscriber;\n+import java.net.http.HttpResponse.BodySubscribers;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.copyOfRange;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class HttpResponseLimitingTest {\n+\n+    private static final Charset CHARSET = StandardCharsets.UTF_8;\n+\n+    private static final HttpServer SERVER = new HttpServer();\n+\n+    private static final HttpRequest REQUEST = HttpRequest\n+            .newBuilder(URI.create(\"http:\/\/localhost:\" + SERVER.socket.getLocalPort()))\n+            .timeout(Duration.ofSeconds(5))\n+            .build();\n+\n+    private static final HttpClient CLIENT = HttpClient\n+            .newBuilder()\n+            .connectTimeout(Duration.ofSeconds(5))\n+            .build();\n+\n+    @AfterAll\n+    static void tearDown() throws Exception {\n+        CLIENT.close();\n+        SERVER.close();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sufficientCapacities\")\n+    void testSuccessOnSufficientCapacity(long sufficientCapacity) throws Exception {\n+        BodyHandler<byte[]> handler =\n+                BodyHandlers.limiting(BodyHandlers.ofByteArray(), sufficientCapacity, false);\n+        HttpResponse<byte[]> response = CLIENT.send(REQUEST, handler);\n+        assertArrayEquals(HttpServer.RESPONSE_BODY, response.body());\n+    }\n+\n+    static long[] sufficientCapacities() {\n+        return new long[]{Long.MAX_VALUE, HttpServer.RESPONSE_BODY.length};\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"insufficientCapacities\")\n+    void testFailureOnInsufficientCapacity(long insufficientCapacity) {\n+        assertThrows(\n+                IOException.class,\n+                () -> {\n+                    BodyHandler<byte[]> handler =\n+                            BodyHandlers.limiting(BodyHandlers.ofByteArray(), insufficientCapacity, false);\n+                    CLIENT.send(REQUEST, handler);\n+                },\n+                \"the maximum number of bytes that are allowed to be consumed is exceeded\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"insufficientCapacities\")\n+    void testTruncationOnInsufficientCapacity(long insufficientCapacity) throws Exception {\n+        BodyHandler<byte[]> handler =\n+                BodyHandlers.limiting(BodyHandlers.ofByteArray(), insufficientCapacity, true);\n+        HttpResponse<byte[]> response = CLIENT.send(REQUEST, handler);\n+        byte[] expectedResponseBody = new byte[(int) insufficientCapacity];\n+        System.arraycopy(HttpServer.RESPONSE_BODY, 0, expectedResponseBody, 0, expectedResponseBody.length);\n+        assertArrayEquals(expectedResponseBody, response.body());\n+    }\n+\n+    static long[] insufficientCapacities() {\n+        return new long[]{0, HttpServer.RESPONSE_BODY.length - 1};\n+    }\n+\n+    @Test\n+    void testSubscriberForCompleteConsumption() {\n+\n+        \/\/ Create the subscriber (with sufficient capacity)\n+        ObserverSubscriber downstreamSubscriber = new ObserverSubscriber();\n+        int sufficientCapacity = HttpServer.RESPONSE_BODY.length;\n+        BodySubscriber<String> subscriber = BodySubscribers.limiting(downstreamSubscriber, sufficientCapacity, false);\n+\n+        \/\/ Emit values\n+        subscriber.onSubscribe(DummySubscription.INSTANCE);\n+        byte[] responseBodyPart1 = {HttpServer.RESPONSE_BODY[0]};\n+        byte[] responseBodyPart2 = copyOfRange(HttpServer.RESPONSE_BODY, 1, HttpServer.RESPONSE_BODY.length);\n+        List<ByteBuffer> buffers = toByteBuffers(responseBodyPart1, responseBodyPart2);\n+        subscriber.onNext(buffers);\n+\n+        \/\/ Verify the downstream propagation\n+        assertSame(buffers, downstreamSubscriber.lastBuffers);\n+        assertNull(downstreamSubscriber.lastThrowable);\n+        assertFalse(downstreamSubscriber.completed);\n+\n+    }\n+\n+    @Test\n+    void testSubscriberForTruncationOnExcess() {\n+\n+        \/\/ Create the subscriber (with insufficient capacity)\n+        ObserverSubscriber downstreamSubscriber = new ObserverSubscriber();\n+        int insufficientCapacity = 4;\n+        BodySubscriber<String> subscriber = BodySubscribers.limiting(downstreamSubscriber, insufficientCapacity, true);\n+\n+        \/\/ Emit values\n+        subscriber.onSubscribe(DummySubscription.INSTANCE);\n+        byte[] responseBodyPart1 = {HttpServer.RESPONSE_BODY[0]};\n+        byte[] responseBodyPart2 = {HttpServer.RESPONSE_BODY[1], HttpServer.RESPONSE_BODY[2]};\n+        byte[] responseBodyPart3 = copyOfRange(HttpServer.RESPONSE_BODY, 3, HttpServer.RESPONSE_BODY.length);\n+        List<ByteBuffer> buffers = toByteBuffers(responseBodyPart1, responseBodyPart2, responseBodyPart3);\n+        subscriber.onNext(buffers);\n+\n+        \/\/ Verify the downstream propagation\n+        assertNotNull(downstreamSubscriber.lastBuffers);\n+        List<ByteBuffer> expectedBuffers = toByteBuffers(\n+                responseBodyPart1,\n+                responseBodyPart2,\n+                copyOfRange(HttpServer.RESPONSE_BODY, 3, 4));\n+        assertEquals(expectedBuffers, downstreamSubscriber.lastBuffers);\n+        assertNull(downstreamSubscriber.lastThrowable);\n+        assertTrue(downstreamSubscriber.completed);\n+\n+    }\n+\n+    @Test\n+    void testSubscriberForFailureOnExcess() {\n+\n+        \/\/ Create the subscriber (with insufficient capacity)\n+        ObserverSubscriber downstreamSubscriber = new ObserverSubscriber();\n+        int insufficientCapacity = 2;\n+        BodySubscriber<String> subscriber = BodySubscribers.limiting(downstreamSubscriber, insufficientCapacity, false);\n+\n+        \/\/ Emit values\n+        subscriber.onSubscribe(DummySubscription.INSTANCE);\n+        byte[] responseBodyPart1 = {HttpServer.RESPONSE_BODY[0]};\n+        byte[] responseBodyPart2 = copyOfRange(HttpServer.RESPONSE_BODY, 1, HttpServer.RESPONSE_BODY.length);\n+        List<ByteBuffer> buffers = toByteBuffers(responseBodyPart1, responseBodyPart2);\n+        subscriber.onNext(buffers);\n+\n+        \/\/ Verify the downstream propagation\n+        assertNull(downstreamSubscriber.lastBuffers);\n+        assertNotNull(downstreamSubscriber.lastThrowable);\n+        assertEquals(\n+                \"the maximum number of bytes that are allowed to be consumed is exceeded\",\n+                downstreamSubscriber.lastThrowable.getMessage());\n+        assertFalse(downstreamSubscriber.completed);\n+\n+    }\n+\n+    private static List<ByteBuffer> toByteBuffers(byte[]... buffers) {\n+        return Arrays.stream(buffers).map(ByteBuffer::wrap).collect(Collectors.toList());\n+    }\n+\n+    \/**\n+     * An HTTP server always returning an excessive response.\n+     *\/\n+    private static final class HttpServer implements Runnable, AutoCloseable {\n+\n+        private static final byte[] RESPONSE_BODY = \"random non-empty body\".getBytes(CHARSET);\n+\n+        private static final byte[] RESPONSE = (\n+                \"HTTP\/1.2 200 OK\\r\\n\" +\n+                        \"Content-Length: \" + RESPONSE_BODY.length + \"\\r\\n\" +\n+                        \"\\r\\n\" +\n+                        new String(RESPONSE_BODY, CHARSET))\n+                .getBytes(CHARSET);\n+\n+        private final ServerSocket socket;\n+\n+        private final Thread thread;\n+\n+        private HttpServer() {\n+            try {\n+                this.socket = new ServerSocket(0, 0, InetAddress.getLoopbackAddress());\n+            } catch (IOException exception) {\n+                throw new UncheckedIOException(exception);\n+            }\n+            this.thread = new Thread(this);\n+            thread.setDaemon(true);     \/\/ Avoid blocking JVM exit\n+            thread.start();\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!Thread.currentThread().isInterrupted()) {\n+                try (Socket clientSocket = socket.accept();\n+                     OutputStream outputStream = clientSocket.getOutputStream()) {\n+                    outputStream.write(RESPONSE);\n+                } catch (IOException _) {\n+                    \/\/ Do nothing\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            socket.close();\n+            thread.interrupt();\n+        }\n+\n+    }\n+\n+    private static final class ObserverSubscriber implements BodySubscriber<String> {\n+\n+        private List<ByteBuffer> lastBuffers;\n+\n+        private Throwable lastThrowable;\n+\n+        private boolean completed;\n+\n+        @Override\n+        public CompletionStage<String> getBody() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            subscription.request(Long.MAX_VALUE);\n+        }\n+\n+        @Override\n+        public void onNext(List<ByteBuffer> buffers) {\n+            lastBuffers = buffers;\n+        }\n+\n+        @Override\n+        public void onError(Throwable throwable) {\n+            lastThrowable = throwable;\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            completed = true;\n+        }\n+\n+    }\n+\n+    private enum DummySubscription implements Subscription {\n+\n+        INSTANCE;\n+\n+        @Override\n+        public void request(long n) {\n+            \/\/ Do nothing\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            \/\/ Do nothing\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpResponseLimitingTest.java","additions":315,"deletions":0,"binary":false,"changes":315,"status":"added"}]}