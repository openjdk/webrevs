{"files":[{"patch":"@@ -754,2 +754,2 @@\n-         * {@return a {@code BodyHandler} limiting the number of bytes consumed\n-         * and passed to the given downstream {@code BodyHandler}}\n+         * {@return a {@code BodyHandler} limiting the number of body bytes\n+         * consumed and passed to the given downstream {@code BodyHandler}}\n@@ -757,6 +757,5 @@\n-         * If the number of bytes received exceeds the maximum number of bytes\n-         * desired as indicated by the given {@code capacity},\n-         * {@link BodySubscriber#onError(Throwable) onError} is called on the\n-         * downstream {@code BodySubscriber} with an {@link IOException}\n-         * indicating that the capacity is exceeded, and the upstream\n-         * subscription is cancelled.\n+         * If the number of body bytes received exceeds the the given\n+         * {@code capacity}, {@link BodySubscriber#onError(Throwable) onError}\n+         * is called on the downstream {@code BodySubscriber} with an\n+         * {@link IOException} indicating that the capacity is exceeded, and\n+         * the upstream subscription is cancelled.\n@@ -766,1 +765,1 @@\n-         * @throws IllegalArgumentException if {@code capacity < 0}\n+         * @throws IllegalArgumentException if {@code capacity} is negative\n@@ -772,1 +771,1 @@\n-                throw new IllegalArgumentException(\"was expecting \\\"capacity >= 0\\\", found: \" + capacity);\n+                throw new IllegalArgumentException(\"capacity must not be negative: \" + capacity);\n@@ -1384,1 +1383,1 @@\n-         * {@return a {@code BodySubscriber} limiting the number of bytes\n+         * {@return a {@code BodySubscriber} limiting the number of body bytes\n@@ -1387,6 +1386,5 @@\n-         * If the number of bytes received exceeds the maximum number of bytes\n-         * desired as indicated by the given {@code capacity},\n-         * {@link BodySubscriber#onError(Throwable) onError} is called on the\n-         * downstream {@code BodySubscriber} with an {@link IOException}\n-         * indicating that the capacity is exceeded, and the upstream\n-         * subscription is cancelled.\n+         * If the number of body bytes received exceeds the given\n+         * {@code capacity}, {@link BodySubscriber#onError(Throwable) onError}\n+         * is called on the downstream {@code BodySubscriber} with an\n+         * {@link IOException} indicating that the capacity is exceeded, and\n+         * the upstream subscription is cancelled.\n@@ -1396,1 +1394,1 @@\n-         * @throws IllegalArgumentException if {@code capacity < 0}\n+         * @throws IllegalArgumentException if {@code capacity} is negative\n@@ -1402,1 +1400,1 @@\n-                throw new IllegalArgumentException(\"was expecting \\\"capacity >= 0\\\", found: \" + capacity);\n+                throw new IllegalArgumentException(\"capacity must not be negative: \" + capacity);\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpResponse.java","additions":17,"deletions":19,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.nio.Buffer;\n@@ -58,1 +57,1 @@\n-        enum Terminated implements State { INSTANCE }\n+        State TERMINATED = new State() {};\n@@ -67,1 +66,1 @@\n-     * @throws IllegalArgumentException if {@code capacity < 0}\n+     * @throws IllegalArgumentException if {@code capacity} is negative\n@@ -71,1 +70,1 @@\n-            throw new IllegalArgumentException(\"was expecting \\\"capacity >= 0\\\", found: \" + capacity);\n+            throw new IllegalArgumentException(\"capacity must not be negative: \" + capacity);\n@@ -104,7 +103,3 @@\n-        }\n-\n-        \/\/ Otherwise, trigger failure\n-        else {\n-            state = State.Terminated.INSTANCE;\n-            downstreamSubscriber.onError(new IOException(\n-                    \"the maximum number of bytes that are allowed to be consumed is exceeded\"));\n+        } else { \/\/ Otherwise, trigger failure\n+            state = State.TERMINATED;\n+            downstreamSubscriber.onError(new IOException(\"body exceeds capacity: \" + capacity));\n@@ -117,2 +112,7 @@\n-        long bufferLength = buffers.stream().mapToLong(Buffer::remaining).sum();\n-        long nextLength = Math.addExact(length, bufferLength);\n+        long bufferLength = Utils.remaining(buffers);\n+        long nextLength;\n+        try {\n+            nextLength = Math.addExact(length, bufferLength);\n+        } catch (ArithmeticException _) {\n+            return false;\n+        }\n@@ -130,1 +130,1 @@\n-            state = State.Terminated.INSTANCE;\n+            state = State.TERMINATED;\n@@ -138,1 +138,1 @@\n-            state = State.Terminated.INSTANCE;\n+            state = State.TERMINATED;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/LimitingSubscriber.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @summary verifies `limiting()` behaviour in `HttpResponse.Body{Handlers,Subscribers}`\n+ * @summary tests `limiting()` in `HttpResponse.Body{Handlers,Subscribers}`\n@@ -31,0 +31,3 @@\n+ *          \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n@@ -34,1 +37,2 @@\n-import org.junit.jupiter.api.AfterAll;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.test.lib.net.SimpleSSLContext;\n@@ -37,0 +41,1 @@\n+import org.junit.jupiter.params.provider.Arguments;\n@@ -39,0 +44,1 @@\n+import javax.net.ssl.SSLContext;\n@@ -40,5 +46,0 @@\n-import java.io.OutputStream;\n-import java.io.UncheckedIOException;\n-import java.net.InetAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n@@ -49,1 +50,0 @@\n-import java.net.http.HttpResponse.BodyHandler;\n@@ -62,0 +62,1 @@\n+import java.util.stream.Stream;\n@@ -76,17 +77,1 @@\n-    private static final HttpServer SERVER = new HttpServer();\n-\n-    private static final HttpRequest REQUEST = HttpRequest\n-            .newBuilder(URI.create(\"http:\/\/localhost:\" + SERVER.socket.getLocalPort()))\n-            .timeout(Duration.ofSeconds(5))\n-            .build();\n-\n-    private static final HttpClient CLIENT = HttpClient\n-            .newBuilder()\n-            .connectTimeout(Duration.ofSeconds(5))\n-            .build();\n-\n-    @AfterAll\n-    static void tearDown() throws Exception {\n-        CLIENT.close();\n-        SERVER.close();\n-    }\n+    private static final byte[] RESPONSE_BODY = \"random non-empty body\".getBytes(CHARSET);\n@@ -96,5 +81,3 @@\n-    void testSuccessOnSufficientCapacity(long sufficientCapacity) throws Exception {\n-        BodyHandler<byte[]> handler =\n-                BodyHandlers.limiting(BodyHandlers.ofByteArray(), sufficientCapacity);\n-        HttpResponse<byte[]> response = CLIENT.send(REQUEST, handler);\n-        assertArrayEquals(HttpServer.RESPONSE_BODY, response.body());\n+    void testSuccessOnSufficientCapacity(HttpClient.Version version, boolean secure, long sufficientCapacity) throws Exception {\n+        HttpResponse<byte[]> response = requestBytes(version, secure, sufficientCapacity);\n+        assertArrayEquals(RESPONSE_BODY, response.body());\n@@ -103,2 +86,2 @@\n-    static long[] sufficientCapacities() {\n-        return new long[]{Long.MAX_VALUE, HttpServer.RESPONSE_BODY.length};\n+    static Arguments[] sufficientCapacities() {\n+        return capacityArgs(Long.MAX_VALUE, RESPONSE_BODY.length);\n@@ -109,1 +92,1 @@\n-    void testFailureOnInsufficientCapacity(long insufficientCapacity) {\n+    void testFailureOnInsufficientCapacity(HttpClient.Version version, boolean secure, long insufficientCapacity) {\n@@ -112,4 +95,48 @@\n-                () -> {\n-                    BodyHandler<byte[]> handler =\n-                            BodyHandlers.limiting(BodyHandlers.ofByteArray(), insufficientCapacity);\n-                    CLIENT.send(REQUEST, handler);\n+                () -> requestBytes(version, secure, insufficientCapacity),\n+                \"body exceeds capacity: \" + RESPONSE_BODY.length);\n+    }\n+\n+    static Arguments[] insufficientCapacities() {\n+        return capacityArgs(0, RESPONSE_BODY.length - 1);\n+    }\n+\n+    private static Arguments[] capacityArgs(long... capacities) {\n+        return Stream\n+                .of(HttpClient.Version.HTTP_1_1, HttpClient.Version.HTTP_2)\n+                .flatMap(version -> Stream\n+                        .of(true, false)\n+                        .flatMap(secure -> Arrays\n+                                .stream(capacities)\n+                                .mapToObj(capacity -> Arguments.of(version, secure, capacity))))\n+                .toArray(Arguments[]::new);\n+    }\n+\n+    private static HttpResponse<byte[]> requestBytes(\n+            HttpClient.Version version,\n+            boolean secure,\n+            long capacity)\n+            throws Exception {\n+\n+        \/\/ Create the server and the request URI\n+        SSLContext sslContext;\n+        HttpServerAdapters.HttpTestServer server;\n+        String handlerPath = \"\/\";\n+        URI requestUri;\n+        if (secure) {\n+            sslContext = new SimpleSSLContext().get();\n+            server = HttpServerAdapters.HttpTestServer.create(version, sslContext);\n+            requestUri = URI.create(\"https:\/\/\" + server.serverAuthority() + handlerPath);\n+        } else {\n+            sslContext = null;\n+            server = HttpServerAdapters.HttpTestServer.create(version);\n+            requestUri = URI.create(\"http:\/\/\" + server.serverAuthority() + handlerPath);\n+        }\n+\n+        \/\/ Register the request handler\n+        server.addHandler(\n+                (exchange) -> {\n+                    exchange.sendResponseHeaders(200, RESPONSE_BODY.length);\n+                    try (var outputStream = exchange.getResponseBody()) {\n+                        outputStream.write(RESPONSE_BODY);\n+                    }\n+                    exchange.close();\n@@ -117,1 +144,18 @@\n-                \"the maximum number of bytes that are allowed to be consumed is exceeded\");\n+                handlerPath);\n+\n+        \/\/ Start the server and the client\n+        server.start();\n+        try (var client = createClient(sslContext)) {\n+\n+            \/\/ Issue the request\n+            var request = HttpRequest\n+                    .newBuilder(requestUri)\n+                    .timeout(Duration.ofSeconds(5))\n+                    .build();\n+            var handler = BodyHandlers.limiting(BodyHandlers.ofByteArray(), capacity);\n+            return client.send(request, handler);\n+\n+        } finally {\n+            server.stop();\n+        }\n+\n@@ -120,2 +164,8 @@\n-    static long[] insufficientCapacities() {\n-        return new long[]{0, HttpServer.RESPONSE_BODY.length - 1};\n+    private static HttpClient createClient(SSLContext sslContext) {\n+        HttpClient.Builder builder = HttpClient\n+                .newBuilder()\n+                .connectTimeout(Duration.ofSeconds(5));\n+        if (sslContext != null) {\n+            builder.sslContext(sslContext);\n+        }\n+        return builder.build();\n@@ -129,1 +179,1 @@\n-        int sufficientCapacity = HttpServer.RESPONSE_BODY.length;\n+        int sufficientCapacity = RESPONSE_BODY.length;\n@@ -134,2 +184,2 @@\n-        byte[] responseBodyPart1 = {HttpServer.RESPONSE_BODY[0]};\n-        byte[] responseBodyPart2 = copyOfRange(HttpServer.RESPONSE_BODY, 1, HttpServer.RESPONSE_BODY.length);\n+        byte[] responseBodyPart1 = {RESPONSE_BODY[0]};\n+        byte[] responseBodyPart2 = copyOfRange(RESPONSE_BODY, 1, RESPONSE_BODY.length);\n@@ -156,2 +206,2 @@\n-        byte[] responseBodyPart1 = {HttpServer.RESPONSE_BODY[0]};\n-        byte[] responseBodyPart2 = copyOfRange(HttpServer.RESPONSE_BODY, 1, HttpServer.RESPONSE_BODY.length);\n+        byte[] responseBodyPart1 = {RESPONSE_BODY[0]};\n+        byte[] responseBodyPart2 = copyOfRange(RESPONSE_BODY, 1, RESPONSE_BODY.length);\n@@ -165,1 +215,1 @@\n-                \"the maximum number of bytes that are allowed to be consumed is exceeded\",\n+                \"body exceeds capacity: \" + insufficientCapacity,\n@@ -175,49 +225,0 @@\n-    \/**\n-     * An HTTP server always returning a fixed response containing a non-empty body.\n-     *\/\n-    private static final class HttpServer implements Runnable, AutoCloseable {\n-\n-        private static final byte[] RESPONSE_BODY = \"random non-empty body\".getBytes(CHARSET);\n-\n-        private static final byte[] RESPONSE = (\n-                \"HTTP\/1.2 200 OK\\r\\n\" +\n-                        \"Content-Length: \" + RESPONSE_BODY.length + \"\\r\\n\" +\n-                        \"\\r\\n\" +\n-                        new String(RESPONSE_BODY, CHARSET))\n-                .getBytes(CHARSET);\n-\n-        private final ServerSocket socket;\n-\n-        private final Thread thread;\n-\n-        private HttpServer() {\n-            try {\n-                this.socket = new ServerSocket(0, 0, InetAddress.getLoopbackAddress());\n-            } catch (IOException exception) {\n-                throw new UncheckedIOException(exception);\n-            }\n-            this.thread = new Thread(this);\n-            thread.setDaemon(true);     \/\/ Avoid blocking JVM exit\n-            thread.start();\n-        }\n-\n-        @Override\n-        public void run() {\n-            while (!Thread.currentThread().isInterrupted()) {\n-                try (Socket clientSocket = socket.accept();\n-                     OutputStream outputStream = clientSocket.getOutputStream()) {\n-                    outputStream.write(RESPONSE);\n-                } catch (IOException _) {\n-                    \/\/ Do nothing\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public void close() throws Exception {\n-            socket.close();\n-            thread.interrupt();\n-        }\n-\n-    }\n-\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpResponseLimitingTest.java","additions":96,"deletions":95,"binary":false,"changes":191,"status":"modified"}]}