{"files":[{"patch":"@@ -37,1 +37,1 @@\n-import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n@@ -40,0 +40,1 @@\n+import org.junit.jupiter.api.AfterAll;\n@@ -47,0 +48,2 @@\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n@@ -51,0 +54,1 @@\n+import java.net.http.HttpResponse.BodyHandler;\n@@ -80,0 +84,90 @@\n+    private static final ServerClientPair HTTP1 = ServerClientPair.of(HttpClient.Version.HTTP_1_1, false);\n+\n+    private static final ServerClientPair HTTPS1 = ServerClientPair.of(HttpClient.Version.HTTP_1_1, true);\n+\n+    private static final ServerClientPair HTTP2 = ServerClientPair.of(HttpClient.Version.HTTP_2, false);\n+\n+    private static final ServerClientPair HTTPS2 = ServerClientPair.of(HttpClient.Version.HTTP_2, true);\n+\n+    private record ServerClientPair(HttpTestServer server, HttpClient client, HttpRequest request) {\n+\n+        private static final SSLContext SSL_CONTEXT = createSslContext();\n+\n+        private static SSLContext createSslContext() {\n+            try {\n+                return new SimpleSSLContext().get();\n+            } catch (IOException exception) {\n+                throw new UncheckedIOException(exception);\n+            }\n+        }\n+\n+        private ServerClientPair {\n+            server.start();\n+        }\n+\n+        private static ServerClientPair of(HttpClient.Version version, boolean secure) {\n+\n+            \/\/ Create the server and the request URI\n+            SSLContext sslContext = secure ? SSL_CONTEXT : null;\n+            HttpTestServer server = createServer(version, sslContext);\n+            String handlerPath = \"\/\";\n+            String requestUriScheme = secure ? \"https\" : \"http\";\n+            URI requestUri = URI.create(requestUriScheme + \":\/\/\" + server.serverAuthority() + handlerPath);\n+\n+            \/\/ Register the request handler\n+            server.addHandler(\n+                    (exchange) -> {\n+                        exchange.sendResponseHeaders(200, RESPONSE_BODY.length);\n+                        try (var outputStream = exchange.getResponseBody()) {\n+                            outputStream.write(RESPONSE_BODY);\n+                        }\n+                        exchange.close();\n+                    },\n+                    handlerPath);\n+\n+            \/\/ Create the client and the request\n+            HttpClient client = createClient(version, sslContext);\n+            HttpRequest request = HttpRequest.newBuilder(requestUri).version(version).build();\n+\n+            \/\/ Create the pair\n+            return new ServerClientPair(server, client, request);\n+\n+        }\n+\n+        private static HttpTestServer createServer(HttpClient.Version version, SSLContext sslContext) {\n+            try {\n+                return HttpTestServer.create(version, sslContext);\n+            } catch (IOException exception) {\n+                throw new UncheckedIOException(exception);\n+            }\n+        }\n+\n+        private static HttpClient createClient(HttpClient.Version version, SSLContext sslContext) {\n+            HttpClient.Builder builder = HttpClient.newBuilder().version(version).proxy(NO_PROXY);\n+            if (sslContext != null) {\n+                builder.sslContext(sslContext);\n+            }\n+            return builder.build();\n+        }\n+\n+        private <T> HttpResponse<T> request(BodyHandler<T> downstreamHandler, long capacity) throws Exception {\n+            var handler = BodyHandlers.limiting(downstreamHandler, capacity);\n+            return client.send(request, handler);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String version = client.version().toString();\n+            return client.sslContext() != null ? version.replaceFirst(\"_\", \"S_\") : version;\n+        }\n+\n+    }\n+\n+    @AfterAll\n+    static void closeServerClientPairs() {\n+        for (var pair : new ServerClientPair[]{HTTP1, HTTPS1, HTTP2, HTTPS2}) {\n+            pair.client.close();\n+            pair.server.stop();\n+        }\n+    }\n+\n@@ -82,2 +176,2 @@\n-    void testSuccessOnSufficientCapacity(HttpClient.Version version, boolean secure, long sufficientCapacity) throws Exception {\n-        HttpResponse<byte[]> response = requestBytes(version, secure, sufficientCapacity);\n+    void testSuccessOnSufficientCapacityForByteArray(ServerClientPair pair, long sufficientCapacity) throws Exception {\n+        HttpResponse<byte[]> response = pair.request(BodyHandlers.ofByteArray(), sufficientCapacity);\n@@ -87,0 +181,12 @@\n+    @ParameterizedTest\n+    @MethodSource(\"sufficientCapacities\")\n+    void testSuccessOnSufficientCapacityForInputStream(ServerClientPair pair, long sufficientCapacity) throws Exception {\n+        HttpResponse<InputStream> response = pair.request(BodyHandlers.ofInputStream(), sufficientCapacity);\n+        try (InputStream responseBodyStream = response.body()) {\n+            byte[] responseBodyBuffer = new byte[RESPONSE_BODY.length];\n+            int responseBodyBufferLength = responseBodyStream.read(responseBodyBuffer);\n+            assertEquals(responseBodyBuffer.length, responseBodyBufferLength);\n+            assertArrayEquals(RESPONSE_BODY, responseBodyBuffer);\n+        }\n+    }\n+\n@@ -96,2 +202,4 @@\n-    void testFailureOnInsufficientCapacity(HttpClient.Version version, boolean secure, long insufficientCapacity) {\n-        var exception = assertThrows(IOException.class, () -> requestBytes(version, secure, insufficientCapacity));\n+    void testFailureOnInsufficientCapacityForByteArray(ServerClientPair pair, long insufficientCapacity) {\n+        var exception = assertThrows(\n+                IOException.class,\n+                () -> pair.request(BodyHandlers.ofByteArray(), insufficientCapacity));\n@@ -101,0 +209,13 @@\n+    @ParameterizedTest\n+    @MethodSource(\"insufficientCapacities\")\n+    void testFailureOnInsufficientCapacityForInputStream(ServerClientPair pair, long insufficientCapacity) throws Exception {\n+        HttpResponse<InputStream> response = pair.request(BodyHandlers.ofInputStream(), insufficientCapacity);\n+        try (InputStream responseBodyStream = response.body()) {\n+            var exception = assertThrows(\n+                    IOException.class,\n+                    () -> responseBodyStream.read(new byte[RESPONSE_BODY.length]));\n+            assertNotNull(exception.getCause());\n+            assertEquals(exception.getCause().getMessage(), \"body exceeds capacity: \" + insufficientCapacity);\n+        }\n+    }\n+\n@@ -147,4 +268,2 @@\n-                .of(HttpClient.Version.HTTP_1_1, HttpClient.Version.HTTP_2)\n-                .flatMap(version -> Stream\n-                        .of(true, false)\n-                        .flatMap(secure -> Arrays\n+                .of(HTTP1, HTTPS1, HTTP2, HTTPS2)\n+                .flatMap(pair -> Arrays\n@@ -152,1 +271,1 @@\n-                                .mapToObj(capacity -> Arguments.of(version, secure, capacity))))\n+                                .mapToObj(capacity -> Arguments.of(pair, capacity)))\n@@ -156,55 +275,0 @@\n-    private static HttpResponse<byte[]> requestBytes(\n-            HttpClient.Version version,\n-            boolean secure,\n-            long capacity)\n-            throws Exception {\n-\n-        \/\/ Create the server and the request URI\n-        SSLContext sslContext;\n-        HttpServerAdapters.HttpTestServer server;\n-        String handlerPath = \"\/\";\n-        URI requestUri;\n-        if (secure) {\n-            sslContext = new SimpleSSLContext().get();\n-            server = HttpServerAdapters.HttpTestServer.create(version, sslContext);\n-            requestUri = URI.create(\"https:\/\/\" + server.serverAuthority() + handlerPath);\n-        } else {\n-            sslContext = null;\n-            server = HttpServerAdapters.HttpTestServer.create(version);\n-            requestUri = URI.create(\"http:\/\/\" + server.serverAuthority() + handlerPath);\n-        }\n-\n-        \/\/ Register the request handler\n-        server.addHandler(\n-                (exchange) -> {\n-                    exchange.sendResponseHeaders(200, RESPONSE_BODY.length);\n-                    try (var outputStream = exchange.getResponseBody()) {\n-                        outputStream.write(RESPONSE_BODY);\n-                    }\n-                    exchange.close();\n-                },\n-                handlerPath);\n-\n-        \/\/ Start the server and the client\n-        server.start();\n-        try (var client = createClient(version, sslContext)) {\n-\n-            \/\/ Issue the request\n-            var request = HttpRequest.newBuilder(requestUri).version(version).build();\n-            var handler = BodyHandlers.limiting(BodyHandlers.ofByteArray(), capacity);\n-            return client.send(request, handler);\n-\n-        } finally {\n-            server.stop();\n-        }\n-\n-    }\n-\n-    private static HttpClient createClient(HttpClient.Version version, SSLContext sslContext) {\n-        HttpClient.Builder builder = HttpClient.newBuilder().version(version).proxy(NO_PROXY);\n-        if (sslContext != null) {\n-            builder.sslContext(sslContext);\n-        }\n-        return builder.build();\n-    }\n-\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpResponseLimitingTest.java","additions":129,"deletions":65,"binary":false,"changes":194,"status":"modified"}]}