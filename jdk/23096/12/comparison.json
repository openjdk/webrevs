{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+import jdk.internal.net.http.LimitingSubscriber;\n@@ -751,0 +752,27 @@\n+\n+        \/**\n+         * {@return a {@code BodyHandler} that limits the number of body bytes\n+         * that are delivered to the given {@code downstreamHandler}}\n+         * <p>\n+         * If the number of body bytes received exceeds the given\n+         * {@code capacity}, {@link BodySubscriber#onError(Throwable) onError}\n+         * is called on the downstream {@code BodySubscriber} with an\n+         * {@link IOException} indicating that the capacity is exceeded, and\n+         * the upstream subscription is cancelled.\n+         *\n+         * @param downstreamHandler the downstream handler to pass received data to\n+         * @param capacity the maximum number of bytes that are allowed\n+         * @throws IllegalArgumentException if {@code capacity} is negative\n+         * @since 25\n+         *\/\n+        public static <T> BodyHandler<T> limiting(BodyHandler<T> downstreamHandler, long capacity) {\n+            Objects.requireNonNull(downstreamHandler, \"downstreamHandler\");\n+            if (capacity < 0) {\n+                throw new IllegalArgumentException(\"capacity must not be negative: \" + capacity);\n+            }\n+            return responseInfo -> {\n+                BodySubscriber<T> downstreamSubscriber = downstreamHandler.apply(responseInfo);\n+                return BodySubscribers.limiting(downstreamSubscriber, capacity);\n+            };\n+        }\n+\n@@ -1353,0 +1381,24 @@\n+\n+        \/**\n+         * {@return a {@code BodySubscriber} that limits the number of body\n+         * bytes that are delivered to the given {@code downstreamSubscriber}}\n+         * <p>\n+         * If the number of body bytes received exceeds the given\n+         * {@code capacity}, {@link BodySubscriber#onError(Throwable) onError}\n+         * is called on the downstream {@code BodySubscriber} with an\n+         * {@link IOException} indicating that the capacity is exceeded, and\n+         * the upstream subscription is cancelled.\n+         *\n+         * @param downstreamSubscriber the downstream subscriber to pass received data to\n+         * @param capacity the maximum number of bytes that are allowed\n+         * @throws IllegalArgumentException if {@code capacity} is negative\n+         * @since 25\n+         *\/\n+        public static <T> BodySubscriber<T> limiting(BodySubscriber<T> downstreamSubscriber, long capacity) {\n+            Objects.requireNonNull(downstreamSubscriber, \"downstreamSubscriber\");\n+            if (capacity < 0) {\n+                throw new IllegalArgumentException(\"capacity must not be negative: \" + capacity);\n+            }\n+            return new LimitingSubscriber<>(downstreamSubscriber, capacity);\n+        }\n+\n@@ -1354,0 +1406,1 @@\n+\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpResponse.java","additions":54,"deletions":1,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http;\n+\n+import jdk.internal.net.http.ResponseSubscribers.TrustedSubscriber;\n+import jdk.internal.net.http.common.Utils;\n+\n+import java.io.IOException;\n+import java.net.http.HttpResponse.BodySubscriber;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Flow.Subscription;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * A subscriber limiting the maximum number of bytes that are allowed to be consumed by a downstream subscriber.\n+ *\n+ * @param <T> the response type\n+ *\/\n+public final class LimitingSubscriber<T> implements TrustedSubscriber<T> {\n+\n+    private final BodySubscriber<T> downstreamSubscriber;\n+\n+    private final long capacity;\n+\n+    private State state;\n+\n+    private long length;\n+\n+    private interface State {\n+\n+        State TERMINATED = new State() {};\n+\n+        record Subscribed(Subscription subscription) implements State {}\n+\n+    }\n+\n+    \/**\n+     * @param downstreamSubscriber the downstream subscriber to pass received data to\n+     * @param capacity the maximum number of bytes that are allowed\n+     * @throws IllegalArgumentException if {@code capacity} is negative\n+     *\/\n+    public LimitingSubscriber(BodySubscriber<T> downstreamSubscriber, long capacity) {\n+        if (capacity < 0) {\n+            throw new IllegalArgumentException(\"capacity must not be negative: \" + capacity);\n+        }\n+        this.downstreamSubscriber = requireNonNull(downstreamSubscriber, \"downstreamSubscriber\");\n+        this.capacity = capacity;\n+    }\n+\n+    @Override\n+    public void onSubscribe(Subscription subscription) {\n+        requireNonNull(subscription, \"subscription\");\n+        if (state != null) {\n+            subscription.cancel();\n+        } else {\n+            state = new State.Subscribed(subscription);\n+            downstreamSubscriber.onSubscribe(subscription);\n+        }\n+    }\n+\n+    @Override\n+    public void onNext(List<ByteBuffer> buffers) {\n+\n+        \/\/ Check arguments\n+        requireNonNull(buffers, \"buffers\");\n+        assert Utils.hasRemaining(buffers);\n+\n+        \/\/ Short-circuit if not subscribed\n+        if (!(state instanceof State.Subscribed subscribed)) {\n+            return;\n+        }\n+\n+        \/\/ See if we may consume the input\n+        boolean lengthAllocated = allocateLength(buffers);\n+        if (lengthAllocated) {\n+            downstreamSubscriber.onNext(buffers);\n+        } else { \/\/ Otherwise, trigger failure\n+            state = State.TERMINATED;\n+            downstreamSubscriber.onError(new IOException(\"body exceeds capacity: \" + capacity));\n+            subscribed.subscription.cancel();\n+        }\n+\n+    }\n+\n+    private boolean allocateLength(List<ByteBuffer> buffers) {\n+        long bufferLength = Utils.remaining(buffers);\n+        long nextLength;\n+        try {\n+            nextLength = Math.addExact(length, bufferLength);\n+        } catch (ArithmeticException _) {\n+            return false;\n+        }\n+        if (nextLength > capacity) {\n+            return false;\n+        }\n+        length = nextLength;\n+        return true;\n+    }\n+\n+    @Override\n+    public void onError(Throwable throwable) {\n+        requireNonNull(throwable, \"throwable\");\n+        if (state instanceof State.Subscribed) {\n+            state = State.TERMINATED;\n+            downstreamSubscriber.onError(throwable);\n+        }\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        if (state instanceof State.Subscribed) {\n+            state = State.TERMINATED;\n+            downstreamSubscriber.onComplete();\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<T> getBody() {\n+        return downstreamSubscriber.getBody();\n+    }\n+\n+}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/LimitingSubscriber.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,396 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8328919\n+ * @summary tests `limiting()` in `HttpResponse.Body{Handlers,Subscribers}`\n+ * @key randomness\n+ * @library \/test\/lib\n+ *          \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *        jdk.test.lib.RandomFactory\n+ *        jdk.test.lib.net.SimpleSSLContext\n+ * @run junit HttpResponseLimitingTest\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandler;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.net.http.HttpResponse.BodySubscriber;\n+import java.net.http.HttpResponse.BodySubscribers;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Arrays.copyOfRange;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class HttpResponseLimitingTest {\n+\n+    private static final Random RANDOM = RandomFactory.getRandom();\n+\n+    private static final byte[] RESPONSE_BODY = \"random non-empty body\".getBytes(UTF_8);\n+\n+    private static final String RESPONSE_HEADER_NAME = \"X-Excessive-Data\";\n+\n+    \/**\n+     * A header value larger than {@link #RESPONSE_BODY} to verify that {@code limiting()} doesn't affect header parsing.\n+     *\/\n+    private static final String RESPONSE_HEADER_VALUE = \"!\".repeat(RESPONSE_BODY.length);\n+\n+    private static final ServerClientPair HTTP1 = ServerClientPair.of(HttpClient.Version.HTTP_1_1, false);\n+\n+    private static final ServerClientPair HTTPS1 = ServerClientPair.of(HttpClient.Version.HTTP_1_1, true);\n+\n+    private static final ServerClientPair HTTP2 = ServerClientPair.of(HttpClient.Version.HTTP_2, false);\n+\n+    private static final ServerClientPair HTTPS2 = ServerClientPair.of(HttpClient.Version.HTTP_2, true);\n+\n+    private record ServerClientPair(HttpTestServer server, HttpClient client, HttpRequest request) {\n+\n+        private static final SSLContext SSL_CONTEXT = createSslContext();\n+\n+        private static SSLContext createSslContext() {\n+            try {\n+                return new SimpleSSLContext().get();\n+            } catch (IOException exception) {\n+                throw new UncheckedIOException(exception);\n+            }\n+        }\n+\n+        private ServerClientPair {\n+            server.start();\n+        }\n+\n+        private static ServerClientPair of(HttpClient.Version version, boolean secure) {\n+\n+            \/\/ Create the server and the request URI\n+            SSLContext sslContext = secure ? SSL_CONTEXT : null;\n+            HttpTestServer server = createServer(version, sslContext);\n+            String handlerPath = \"\/\";\n+            String requestUriScheme = secure ? \"https\" : \"http\";\n+            URI requestUri = URI.create(requestUriScheme + \":\/\/\" + server.serverAuthority() + handlerPath);\n+\n+            \/\/ Register the request handler\n+            server.addHandler(\n+                    (exchange) -> {\n+                        exchange.getResponseHeaders().addHeader(RESPONSE_HEADER_NAME, RESPONSE_HEADER_VALUE);\n+                        exchange.sendResponseHeaders(200, RESPONSE_BODY.length);\n+                        try (var outputStream = exchange.getResponseBody()) {\n+                            outputStream.write(RESPONSE_BODY);\n+                        }\n+                        exchange.close();\n+                    },\n+                    handlerPath);\n+\n+            \/\/ Create the client and the request\n+            HttpClient client = createClient(version, sslContext);\n+            HttpRequest request = HttpRequest.newBuilder(requestUri).version(version).build();\n+\n+            \/\/ Create the pair\n+            return new ServerClientPair(server, client, request);\n+\n+        }\n+\n+        private static HttpTestServer createServer(HttpClient.Version version, SSLContext sslContext) {\n+            try {\n+                return HttpTestServer.create(version, sslContext);\n+            } catch (IOException exception) {\n+                throw new UncheckedIOException(exception);\n+            }\n+        }\n+\n+        private static HttpClient createClient(HttpClient.Version version, SSLContext sslContext) {\n+            HttpClient.Builder builder = HttpClient.newBuilder().version(version).proxy(NO_PROXY);\n+            if (sslContext != null) {\n+                builder.sslContext(sslContext);\n+            }\n+            return builder.build();\n+        }\n+\n+        private <T> HttpResponse<T> request(BodyHandler<T> downstreamHandler, long capacity) throws Exception {\n+            var handler = BodyHandlers.limiting(downstreamHandler, capacity);\n+            return client.send(request, handler);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String version = client.version().toString();\n+            return client.sslContext() != null ? version.replaceFirst(\"_\", \"S_\") : version;\n+        }\n+\n+    }\n+\n+    @AfterAll\n+    static void closeServerClientPairs() {\n+        for (var pair : new ServerClientPair[]{HTTP1, HTTPS1, HTTP2, HTTPS2}) {\n+            pair.client.close();\n+            pair.server.stop();\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sufficientCapacities\")\n+    void testSuccessOnSufficientCapacityForByteArray(ServerClientPair pair, long sufficientCapacity) throws Exception {\n+        HttpResponse<byte[]> response = pair.request(BodyHandlers.ofByteArray(), sufficientCapacity);\n+        verifyHeaders(response.headers());\n+        assertArrayEquals(RESPONSE_BODY, response.body());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sufficientCapacities\")\n+    void testSuccessOnSufficientCapacityForInputStream(ServerClientPair pair, long sufficientCapacity) throws Exception {\n+        HttpResponse<InputStream> response = pair.request(BodyHandlers.ofInputStream(), sufficientCapacity);\n+        verifyHeaders(response.headers());\n+        try (InputStream responseBodyStream = response.body()) {\n+            byte[] responseBodyBuffer = new byte[RESPONSE_BODY.length];\n+            int responseBodyBufferLength = responseBodyStream.read(responseBodyBuffer);\n+            assertEquals(responseBodyBuffer.length, responseBodyBufferLength);\n+            assertArrayEquals(RESPONSE_BODY, responseBodyBuffer);\n+        }\n+    }\n+\n+    static Arguments[] sufficientCapacities() {\n+        long minExtremeCapacity = RESPONSE_BODY.length;\n+        long maxExtremeCapacity = Long.MAX_VALUE;\n+        long nonExtremeCapacity = RANDOM.nextLong(minExtremeCapacity + 1, maxExtremeCapacity);\n+        return capacityArgs(minExtremeCapacity, nonExtremeCapacity, maxExtremeCapacity);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"insufficientCapacities\")\n+    void testFailureOnInsufficientCapacityForByteArray(ServerClientPair pair, long insufficientCapacity) {\n+        BodyHandler<byte[]> handler = responseInfo -> {\n+            verifyHeaders(responseInfo.headers());\n+            return BodySubscribers.limiting(BodySubscribers.ofByteArray(), insufficientCapacity);\n+        };\n+        var exception = assertThrows(IOException.class, () -> pair.request(handler, insufficientCapacity));\n+        assertEquals(exception.getMessage(), \"body exceeds capacity: \" + insufficientCapacity);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"insufficientCapacities\")\n+    void testFailureOnInsufficientCapacityForInputStream(ServerClientPair pair, long insufficientCapacity) throws Exception {\n+        HttpResponse<InputStream> response = pair.request(BodyHandlers.ofInputStream(), insufficientCapacity);\n+        verifyHeaders(response.headers());\n+        try (InputStream responseBodyStream = response.body()) {\n+            var exception = assertThrows(\n+                    IOException.class,\n+                    () -> responseBodyStream.read(new byte[RESPONSE_BODY.length]));\n+            assertNotNull(exception.getCause());\n+            assertEquals(exception.getCause().getMessage(), \"body exceeds capacity: \" + insufficientCapacity);\n+        }\n+    }\n+\n+    static Arguments[] insufficientCapacities() {\n+        long minExtremeCapacity = 0;\n+        long maxExtremeCapacity = RESPONSE_BODY.length - 1;\n+        long nonExtremeCapacity = RANDOM.nextLong(minExtremeCapacity + 1, maxExtremeCapacity);\n+        return capacityArgs(minExtremeCapacity, nonExtremeCapacity, maxExtremeCapacity);\n+    }\n+\n+    private static void verifyHeaders(HttpHeaders responseHeaders) {\n+        List<String> responseHeaderValues = responseHeaders.allValues(RESPONSE_HEADER_NAME);\n+        assertEquals(List.of(RESPONSE_HEADER_VALUE), responseHeaderValues);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"invalidCapacities\")\n+    void testFailureOnInvalidCapacityForHandler(long invalidCapacity) {\n+        var exception = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> BodyHandlers.limiting(BodyHandlers.ofByteArray(), invalidCapacity));\n+        assertEquals(exception.getMessage(), \"capacity must not be negative: \" + invalidCapacity);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"invalidCapacities\")\n+    void testFailureOnInvalidCapacityForSubscriber(long invalidCapacity) {\n+        var exception = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> BodySubscribers.limiting(BodySubscribers.ofByteArray(), invalidCapacity));\n+        assertEquals(exception.getMessage(), \"capacity must not be negative: \" + invalidCapacity);\n+    }\n+\n+    static long[] invalidCapacities() {\n+        long minExtremeCapacity = Long.MIN_VALUE;\n+        long maxExtremeCapacity = -1;\n+        long nonExtremeCapacity = RANDOM.nextLong(minExtremeCapacity + 1, maxExtremeCapacity);\n+        return new long[]{minExtremeCapacity, nonExtremeCapacity, maxExtremeCapacity};\n+    }\n+\n+    @Test\n+    void testFailureOnNullDownstreamHandler() {\n+        var exception = assertThrows(NullPointerException.class, () -> BodyHandlers.limiting(null, 0));\n+        assertEquals(exception.getMessage(), \"downstreamHandler\");\n+    }\n+\n+    @Test\n+    void testFailureOnNullDownstreamSubscriber() {\n+        var exception = assertThrows(NullPointerException.class, () -> BodySubscribers.limiting(null, 0));\n+        assertEquals(exception.getMessage(), \"downstreamSubscriber\");\n+    }\n+\n+    private static Arguments[] capacityArgs(long... capacities) {\n+        return Stream\n+                .of(HTTP1, HTTPS1, HTTP2, HTTPS2)\n+                .flatMap(pair -> Arrays\n+                                .stream(capacities)\n+                                .mapToObj(capacity -> Arguments.of(pair, capacity)))\n+                .toArray(Arguments[]::new);\n+    }\n+\n+    @Test\n+    void testSubscriberForCompleteConsumption() {\n+\n+        \/\/ Create the subscriber (with sufficient capacity)\n+        ObserverSubscriber downstreamSubscriber = new ObserverSubscriber();\n+        int sufficientCapacity = RESPONSE_BODY.length;\n+        BodySubscriber<String> subscriber = BodySubscribers.limiting(downstreamSubscriber, sufficientCapacity);\n+\n+        \/\/ Emit values\n+        subscriber.onSubscribe(DummySubscription.INSTANCE);\n+        byte[] responseBodyPart1 = {RESPONSE_BODY[0]};\n+        byte[] responseBodyPart2 = copyOfRange(RESPONSE_BODY, 1, RESPONSE_BODY.length);\n+        List<ByteBuffer> buffers = toByteBuffers(responseBodyPart1, responseBodyPart2);\n+        subscriber.onNext(buffers);\n+\n+        \/\/ Verify the downstream propagation\n+        assertSame(buffers, downstreamSubscriber.lastBuffers);\n+        assertNull(downstreamSubscriber.lastThrowable);\n+        assertFalse(downstreamSubscriber.completed);\n+\n+    }\n+\n+    @Test\n+    void testSubscriberForFailureOnExcess() {\n+\n+        \/\/ Create the subscriber (with insufficient capacity)\n+        ObserverSubscriber downstreamSubscriber = new ObserverSubscriber();\n+        int insufficientCapacity = 2;\n+        BodySubscriber<String> subscriber = BodySubscribers.limiting(downstreamSubscriber, insufficientCapacity);\n+\n+        \/\/ Emit values\n+        subscriber.onSubscribe(DummySubscription.INSTANCE);\n+        byte[] responseBodyPart1 = {RESPONSE_BODY[0]};\n+        byte[] responseBodyPart2 = copyOfRange(RESPONSE_BODY, 1, RESPONSE_BODY.length);\n+        List<ByteBuffer> buffers = toByteBuffers(responseBodyPart1, responseBodyPart2);\n+        subscriber.onNext(buffers);\n+\n+        \/\/ Verify the downstream propagation\n+        assertNull(downstreamSubscriber.lastBuffers);\n+        assertNotNull(downstreamSubscriber.lastThrowable);\n+        assertEquals(\n+                \"body exceeds capacity: \" + insufficientCapacity,\n+                downstreamSubscriber.lastThrowable.getMessage());\n+        assertFalse(downstreamSubscriber.completed);\n+\n+    }\n+\n+    private static List<ByteBuffer> toByteBuffers(byte[]... buffers) {\n+        return Arrays.stream(buffers).map(ByteBuffer::wrap).collect(Collectors.toList());\n+    }\n+\n+    private static final class ObserverSubscriber implements BodySubscriber<String> {\n+\n+        private List<ByteBuffer> lastBuffers;\n+\n+        private Throwable lastThrowable;\n+\n+        private boolean completed;\n+\n+        @Override\n+        public CompletionStage<String> getBody() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            subscription.request(Long.MAX_VALUE);\n+        }\n+\n+        @Override\n+        public void onNext(List<ByteBuffer> buffers) {\n+            lastBuffers = buffers;\n+        }\n+\n+        @Override\n+        public void onError(Throwable throwable) {\n+            lastThrowable = throwable;\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            completed = true;\n+        }\n+\n+    }\n+\n+    private enum DummySubscription implements Subscription {\n+\n+        INSTANCE;\n+\n+        @Override\n+        public void request(long n) {\n+            \/\/ Do nothing\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            \/\/ Do nothing\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpResponseLimitingTest.java","additions":396,"deletions":0,"binary":false,"changes":396,"status":"added"}]}