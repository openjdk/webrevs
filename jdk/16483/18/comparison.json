{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n@@ -29,3 +32,1 @@\n-import java.util.*;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.io.*;\n+import java.net.URI;\n@@ -33,0 +34,15 @@\n+import java.nio.file.Files;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -35,0 +51,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -37,1 +54,0 @@\n-import jdk.internal.access.SharedSecrets;\n@@ -39,0 +55,3 @@\n+import sun.security.jca.GetInstance;\n+import sun.security.jca.ProviderList;\n+import sun.security.jca.Providers;\n@@ -42,2 +61,0 @@\n-import sun.security.jca.*;\n-\n@@ -66,1 +83,11 @@\n-    private static Properties props;\n+    private static final Properties props = new Properties() {\n+        @Override\n+        public synchronized Object put(Object key, Object val) {\n+            if (key instanceof String strKey && val instanceof String strVal &&\n+                    SecPropLoader.isInclude(strKey)) {\n+                SecPropLoader.loadInclude(strVal);\n+                return null;\n+            }\n+            return super.put(key, val);\n+        }\n+    };\n@@ -77,0 +104,210 @@\n+    private static final class SecPropLoader {\n+        private enum LoadingMode {OVERRIDE, APPEND}\n+\n+        private static final String OVERRIDE_SEC_PROP =\n+                \"security.overridePropertiesFile\";\n+\n+        private static final String EXTRA_SYS_PROP =\n+                \"java.security.properties\";\n+\n+        private static Path currentPath;\n+\n+        private static final Set<Path> activePaths = new HashSet<>();\n+\n+        static void loadAll() {\n+            \/\/ first load the master properties file to\n+            \/\/ determine the value of OVERRIDE_SEC_PROP\n+            loadMaster();\n+            loadExtra();\n+        }\n+\n+        static boolean isInclude(String key) {\n+            return \"include\".equals(key);\n+        }\n+\n+        static void checkReservedKey(String key)\n+                throws IllegalArgumentException {\n+            if (isInclude(key)) {\n+                throw new IllegalArgumentException(\"Key '\" + key +\n+                        \"' is reserved and cannot be used as a \" +\n+                        \"Security property name.\");\n+            }\n+        }\n+\n+        private static void loadMaster() {\n+            try {\n+                loadFromPath(Path.of(StaticProperty.javaHome(), \"conf\",\n+                        \"security\", \"java.security\"), LoadingMode.APPEND);\n+            } catch (IOException e) {\n+                throw new InternalError(\"Error loading java.security file\", e);\n+            }\n+        }\n+\n+        private static void loadExtra() {\n+            if (\"true\".equalsIgnoreCase(props.getProperty(OVERRIDE_SEC_PROP))) {\n+                String propFile = System.getProperty(EXTRA_SYS_PROP);\n+                if (propFile != null) {\n+                    LoadingMode mode = LoadingMode.APPEND;\n+                    if (propFile.startsWith(\"=\")) {\n+                        mode = LoadingMode.OVERRIDE;\n+                        propFile = propFile.substring(1);\n+                    }\n+                    try {\n+                        loadExtraHelper(propFile, mode);\n+                    } catch (Exception e) {\n+                        if (sdebug != null) {\n+                            sdebug.println(\"unable to load security \" +\n+                                    \"properties from \" + propFile);\n+                            e.printStackTrace();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        private static void loadExtraHelper(String propFile, LoadingMode mode)\n+                throws Exception {\n+            propFile = PropertyExpander.expand(propFile);\n+            if (propFile.isEmpty()) {\n+                throw new IOException(\"Empty extra properties file path\");\n+            }\n+\n+            \/\/ Try to interpret propFile as a path\n+            Exception error;\n+            if ((error = loadExtraFromPath(propFile, mode)) == null) {\n+                return;\n+            }\n+\n+            \/\/ Try to interpret propFile as a file URL\n+            URI uri = null;\n+            try {\n+                uri = new URI(propFile);\n+            } catch (Exception ignore) {}\n+            if (uri != null && \"file\".equalsIgnoreCase(uri.getScheme()) &&\n+                    (error = loadExtraFromFileUrl(uri, mode)) == null) {\n+                return;\n+            }\n+\n+            \/\/ Try to interpret propFile as a URL\n+            URL url;\n+            try {\n+                url = newURL(propFile);\n+            } catch (MalformedURLException ignore) {\n+                \/\/ URL has no scheme: previous error is more accurate\n+                throw error;\n+            }\n+            loadFromUrl(url, mode);\n+        }\n+\n+        private static Exception loadExtraFromPath(String propFile,\n+                LoadingMode mode) throws Exception {\n+            Path path;\n+            try {\n+                path = Path.of(propFile);\n+                if (!Files.exists(path)) {\n+                    return new FileNotFoundException(propFile);\n+                }\n+            } catch (InvalidPathException e) {\n+                return e;\n+            }\n+            loadFromPath(path, mode);\n+            return null;\n+        }\n+\n+\n+        private static Exception loadExtraFromFileUrl(URI uri, LoadingMode mode)\n+                throws Exception {\n+            Path path;\n+            try {\n+                path = Path.of(uri);\n+            } catch (Exception e) {\n+                return e;\n+            }\n+            loadFromPath(path, mode);\n+            return null;\n+        }\n+\n+        private static void reset(LoadingMode mode) {\n+            if (mode == LoadingMode.OVERRIDE) {\n+                if (sdebug != null) {\n+                    sdebug.println(\n+                            \"overriding other security properties files!\");\n+                }\n+                props.clear();\n+            }\n+        }\n+\n+        static void loadInclude(String propFile) {\n+            String expPropFile = PropertyExpander.expandNonStrict(propFile);\n+            if (sdebug != null) {\n+                sdebug.println(\"processing include: '\" + propFile + \"'\" +\n+                        (propFile.equals(expPropFile) ? \"\" :\n+                                \" (expanded to '\" + expPropFile + \"')\"));\n+            }\n+            try {\n+                Path path = Path.of(expPropFile);\n+                if (!path.isAbsolute()) {\n+                    if (currentPath == null) {\n+                        throw new InternalError(\"Cannot resolve '\" +\n+                                expPropFile + \"' relative path when included \" +\n+                                \"from a non-regular properties file \" +\n+                                \"(e.g. HTTP served file)\");\n+                    }\n+                    path = currentPath.resolveSibling(path);\n+                }\n+                loadFromPath(path, LoadingMode.APPEND);\n+            } catch (IOException | InvalidPathException e) {\n+                throw new InternalError(\"Unable to include '\" + expPropFile +\n+                        \"'\", e);\n+            }\n+        }\n+\n+        private static void loadFromPath(Path path, LoadingMode mode)\n+                throws IOException {\n+            boolean isRegularFile = Files.isRegularFile(path);\n+            if (isRegularFile) {\n+                path = path.toRealPath();\n+            } else if (Files.isDirectory(path)) {\n+                throw new IOException(\"Is a directory\");\n+            } else {\n+                path = path.toAbsolutePath();\n+            }\n+            if (activePaths.contains(path)) {\n+                throw new InternalError(\"Cyclic include of '\" + path + \"'\");\n+            }\n+            try (InputStream is = Files.newInputStream(path)) {\n+                reset(mode);\n+                Path previousPath = currentPath;\n+                currentPath = isRegularFile ? path : null;\n+                activePaths.add(path);\n+                try {\n+                    debugLoad(true, path);\n+                    props.load(is);\n+                    debugLoad(false, path);\n+                } finally {\n+                    activePaths.remove(path);\n+                    currentPath = previousPath;\n+                }\n+            }\n+        }\n+\n+        private static void loadFromUrl(URL url, LoadingMode mode)\n+                throws IOException {\n+            try (InputStream is = url.openStream()) {\n+                reset(mode);\n+                debugLoad(true, url);\n+                props.load(is);\n+                debugLoad(false, url);\n+            }\n+        }\n+\n+        private static void debugLoad(boolean start, Object source) {\n+            if (sdebug != null) {\n+                int level = activePaths.isEmpty() ? 1 : activePaths.size();\n+                sdebug.println((start ?\n+                        \">\".repeat(level) + \" starting to process \" :\n+                        \"<\".repeat(level) + \" finished processing \") + source);\n+            }\n+        }\n+    }\n+\n@@ -80,2 +317,1 @@\n-        \/\/ (the FileInputStream call and the File.exists call,\n-        \/\/ the securityPropFile call, etc)\n+        \/\/ (the FileInputStream call and the File.exists call, etc)\n@@ -97,22 +333,1 @@\n-        props = new Properties();\n-        boolean overrideAll = false;\n-\n-        \/\/ first load the system properties file\n-        \/\/ to determine the value of security.overridePropertiesFile\n-        File propFile = securityPropFile(\"java.security\");\n-        boolean success = loadProps(propFile, null, false);\n-        if (!success) {\n-            throw new InternalError(\"Error loading java.security file\");\n-        }\n-\n-        if (\"true\".equalsIgnoreCase(props.getProperty\n-                (\"security.overridePropertiesFile\"))) {\n-\n-            String extraPropFile = System.getProperty\n-                    (\"java.security.properties\");\n-            if (extraPropFile != null && extraPropFile.startsWith(\"=\")) {\n-                overrideAll = true;\n-                extraPropFile = extraPropFile.substring(1);\n-            }\n-            loadProps(null, extraPropFile, overrideAll);\n-        }\n+        SecPropLoader.loadAll();\n@@ -126,57 +341,0 @@\n-\n-    }\n-\n-    private static boolean loadProps(File masterFile, String extraPropFile, boolean overrideAll) {\n-        InputStream is = null;\n-        try {\n-            if (masterFile != null && masterFile.exists()) {\n-                is = new FileInputStream(masterFile);\n-            } else if (extraPropFile != null) {\n-                extraPropFile = PropertyExpander.expand(extraPropFile);\n-                File propFile = new File(extraPropFile);\n-                URL propURL;\n-                if (propFile.exists()) {\n-                    propURL = newURL\n-                            (\"file:\" + propFile.getCanonicalPath());\n-                } else {\n-                    propURL = newURL(extraPropFile);\n-                }\n-\n-                is = propURL.openStream();\n-                if (overrideAll) {\n-                    props = new Properties();\n-                    if (sdebug != null) {\n-                        sdebug.println\n-                                (\"overriding other security properties files!\");\n-                    }\n-                }\n-            } else {\n-                \/\/ unexpected\n-                return false;\n-            }\n-            props.load(is);\n-            if (sdebug != null) {\n-                \/\/ ExceptionInInitializerError if masterFile.getName() is\n-                \/\/ called here (NPE!). Leave as is (and few lines down)\n-                sdebug.println(\"reading security properties file: \" +\n-                        masterFile == null ? extraPropFile : \"java.security\");\n-            }\n-            return true;\n-        } catch (IOException | PropertyExpander.ExpandException e) {\n-            if (sdebug != null) {\n-                sdebug.println(\"unable to load security properties from \" +\n-                        masterFile == null ? extraPropFile : \"java.security\");\n-                e.printStackTrace();\n-            }\n-            return false;\n-        } finally {\n-            if (is != null) {\n-                try {\n-                    is.close();\n-                } catch (IOException ioe) {\n-                    if (sdebug != null) {\n-                        sdebug.println(\"unable to close input stream\");\n-                    }\n-                }\n-            }\n-        }\n@@ -191,8 +349,0 @@\n-    private static File securityPropFile(String filename) {\n-        \/\/ maybe check for a system property which will specify where to\n-        \/\/ look. Someday.\n-        String sep = File.separator;\n-        return new File(StaticProperty.javaHome() + sep + \"conf\" + sep +\n-                        \"security\" + sep + filename);\n-    }\n-\n@@ -717,0 +867,2 @@\n+     * @throws  IllegalArgumentException if key is reserved and cannot be\n+     *          used as a Security property name.\n@@ -722,6 +874,2 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new SecurityPermission(\"getProperty.\"+\n-                                                      key));\n-        }\n+        SecPropLoader.checkReservedKey(key);\n+        check(\"getProperty.\" + key);\n@@ -752,0 +900,2 @@\n+     * @throws  IllegalArgumentException if key is reserved and cannot be\n+     *          used as a Security property name.\n@@ -757,0 +907,1 @@\n+        SecPropLoader.checkReservedKey(key);\n","filename":"src\/java.base\/share\/classes\/java\/security\/Security.java","additions":254,"deletions":103,"binary":false,"changes":357,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.function.UnaryOperator;\n@@ -54,3 +55,1 @@\n-    public static String expand(String value)\n-        throws ExpandException\n-    {\n+    public static String expand(String value) throws ExpandException {\n@@ -60,3 +59,21 @@\n-     public static String expand(String value, boolean encodeURL)\n-         throws ExpandException\n-     {\n+    public static String expand(String value, boolean encodeURL)\n+            throws ExpandException {\n+        return expand(value, encodeURL, System::getProperty);\n+    }\n+\n+    \/*\n+     * In non-strict mode an undefined property is replaced by an empty string.\n+     *\/\n+    public static String expandNonStrict(String value) {\n+        try {\n+            return expand(value, false, key -> System.getProperty(key, \"\"));\n+        } catch (ExpandException e) {\n+            \/\/ should not happen\n+            throw new AssertionError(\"unexpected expansion error: when \" +\n+                    \"expansion is non-strict, undefined properties should \" +\n+                    \"be replaced by an empty string\", e);\n+        }\n+    }\n+\n+    private static String expand(String value, boolean encodeURL,\n+            UnaryOperator<String> propertiesGetter) throws ExpandException {\n@@ -108,1 +125,1 @@\n-                    String val = System.getProperty(prop);\n+                    String val = propertiesGetter.apply(prop);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/PropertyExpander.java","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -31,0 +31,27 @@\n+#\n+# The special \"include\" property can be defined one or multiple times with\n+# a filesystem path value. The effect of each definition is to include a\n+# referred security properties file inline, adding all its properties.\n+# Security properties defined before an include statement may be overridden\n+# by properties in the included file, if their names match. Conversely,\n+# properties defined after an include statement may override properties in\n+# the included file.\n+#\n+# Included files, as well as files pointed to by java.security.properties,\n+# can include other files recursively. Paths may be absolute or relative.\n+# Each relative path is resolved against the base file containing its\n+# \"include\" definition, if local. Paths may contain system properties for\n+# expansion in the form of ${system.property}. If a system property does\n+# not have a value, it expands to the empty string.\n+#\n+# An error will be thrown if a file cannot be included. This may happen\n+# if the file cannot be resolved, does not exist, is a directory, there are\n+# insufficient permissions to read it, it is recursively included more than\n+# once, or for any other reason. For a secure JDK configuration, it is\n+# important to review OS write permissions assigned to any file included.\n+#\n+# Examples:\n+#   1) include ${java.home}\/conf\/security\/extra.security\n+#   2) include extra.security\n+#   3) include ${java.home}\/conf\/security\/profile${SecurityProfile}.security\n+#\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpServer;\n@@ -27,0 +29,2 @@\n+import jdk.test.lib.util.FileUtils;\n+import sun.net.www.ParseUtil;\n@@ -28,0 +32,1 @@\n+import java.io.Closeable;\n@@ -29,0 +34,2 @@\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n@@ -30,3 +37,11 @@\n-import java.nio.file.*;\n-\n-import java.security.Provider;\n+import java.lang.reflect.Method;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.nio.CharBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n@@ -34,0 +49,1 @@\n+import java.time.Instant;\n@@ -35,1 +51,0 @@\n-import java.util.Arrays;\n@@ -37,1 +52,8 @@\n-import java.util.Optional;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Stream;\n@@ -41,2 +63,4 @@\n- * @summary Throw error if default java.security file is missing\n- * @bug 8155246 8292297 8292177 8281658\n+ * @summary Tests security properties passed through java.security,\n+ *   java.security.properties or included from other properties files.\n+ * @bug 8155246 8292297 8292177 8281658 8319332\n+ * @modules java.base\/sun.net.www\n@@ -46,0 +70,1 @@\n+\n@@ -47,0 +72,47 @@\n+    static final String SEPARATOR_THIN = \"----------------------------\";\n+\n+    private static void printTestHeader(String testName) {\n+        System.out.println();\n+        System.out.println(SEPARATOR_THIN);\n+        System.out.println(testName);\n+        System.out.println(SEPARATOR_THIN);\n+        System.out.println();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 1 && Executor.RUNNER_ARG.equals(args[0])) {\n+            \/\/ Executed by a test-launched JVM.\n+            \/\/ Force the initialization of java.security.Security.\n+            Security.getProviders();\n+            Security.setProperty(\"postInitTest\", \"shouldNotRecord\");\n+            System.out.println(FilesManager.LAST_FILE_PROP_NAME + \": \" +\n+                    Security.getProperty(FilesManager.LAST_FILE_PROP_NAME));\n+            assertTestSecuritySetPropertyShouldNotInclude();\n+        } else {\n+            \/\/ Executed by the test JVM.\n+            try (FilesManager filesMgr = new FilesManager()) {\n+                for (Method m : ConfigFileTest.class.getDeclaredMethods()) {\n+                    if (m.getName().startsWith(\"test\")) {\n+                        printTestHeader(m.getName());\n+                        Executor.run(m, filesMgr);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Success cases\n+     *\/\n+\n+    static void testShowSettings(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Sanity test passing the -XshowSettings:security option.\n+        ex.addJvmArg(\"-XshowSettings:security\");\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.assertSuccess();\n+        ex.getOutputAnalyzer()\n+                .shouldContain(\"Security properties:\")\n+                .shouldContain(\"Security provider static configuration:\")\n+                .shouldContain(\"Security TLS configuration\");\n+    }\n@@ -48,2 +120,7 @@\n-    private static final String EXPECTED_DEBUG_OUTPUT =\n-        \"Initial security property: crypto.policy=unlimited\";\n+    static void testIncludeBasic(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n+        PropsFile file2 = filesMgr.newFile(\"dir1\/dir2\/file2.properties\");\n@@ -51,2 +128,3 @@\n-    private static final String UNEXPECTED_DEBUG_OUTPUT =\n-            \"Initial security property: postInitTest=shouldNotRecord\";\n+        masterFile.addAbsoluteInclude(file0);\n+        extraFile.addRelativeInclude(file2);\n+        file2.addAbsoluteInclude(file1);\n@@ -54,1 +132,4 @@\n-    private static boolean overrideDetected = false;\n+        ex.setMasterFile(masterFile);\n+        ex.setExtraFile(extraFile, Executor.ExtraMode.FILE_URI, false);\n+        ex.assertSuccess();\n+    }\n@@ -56,2 +137,5 @@\n-    private static Path COPY_JDK_DIR = Path.of(\".\/jdk-8155246-tmpdir\");\n-    private static Path COPIED_JAVA = COPY_JDK_DIR.resolve(\"bin\", \"java\");\n+    static void testRepeatedInclude(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n@@ -59,12 +143,64 @@\n-    public static void main(String[] args) throws Exception {\n-        Path copyJdkDir = Path.of(\".\/jdk-8155246-tmpdir\");\n-        Path copiedJava = Optional.of(\n-                        Path.of(copyJdkDir.toString(), \"bin\", \"java\"))\n-                .orElseThrow(() -> new RuntimeException(\"Unable to locate new JDK\")\n-                );\n-\n-        if (args.length == 1) {\n-            \/\/ set up is complete. Run code to exercise loading of java.security\n-            Provider[] provs = Security.getProviders();\n-            Security.setProperty(\"postInitTest\", \"shouldNotRecord\");\n-            System.out.println(Arrays.toString(provs) + \"NumProviders: \" + provs.length);\n+        masterFile.addAbsoluteInclude(file0);\n+        masterFile.addAbsoluteInclude(file1);\n+        masterFile.addAbsoluteInclude(file0);\n+        file1.addRelativeInclude(file0);\n+\n+        ex.setMasterFile(masterFile);\n+        ex.assertSuccess();\n+    }\n+\n+    static void testIncludeWithOverrideAll(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n+\n+        masterFile.addRelativeInclude(file0);\n+        extraFile.addAbsoluteInclude(file1);\n+\n+        ex.setMasterFile(masterFile);\n+        ex.setExtraFile(extraFile, Executor.ExtraMode.HTTP_SERVED, true);\n+        ex.assertSuccess();\n+    }\n+\n+    static void extraPropertiesByHelper(Executor ex, FilesManager filesMgr,\n+            Executor.ExtraMode mode) throws Exception {\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+\n+        extraFile.addRelativeInclude(file0);\n+\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.setExtraFile(extraFile, mode, true);\n+        ex.assertSuccess();\n+    }\n+\n+    static void testExtraPropertiesByPathAbsolute(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        extraPropertiesByHelper(ex, filesMgr, Executor.ExtraMode.PATH_ABS);\n+    }\n+\n+    static void testExtraPropertiesByPathRelative(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        extraPropertiesByHelper(ex, filesMgr, Executor.ExtraMode.PATH_REL);\n+    }\n+\n+    static void specialCharsIncludes(Executor ex, FilesManager filesMgr,\n+            char specialChar, Executor.ExtraMode extraMode,\n+            boolean useRelativeIncludes) throws Exception {\n+        String suffix = specialChar + \".properties\";\n+        ExtraPropsFile extraFile;\n+        PropsFile file0, file1;\n+        try {\n+            extraFile = filesMgr.newExtraFile(\"extra\" + suffix);\n+            file0 = filesMgr.newFile(\"file0\" + suffix);\n+            file1 = filesMgr.newFile(\"file1\" + suffix);\n+        } catch (InvalidPathException ipe) {\n+            \/\/ The platform encoding may not allow to create files with some\n+            \/\/ special characters. Skip the test in these cases.\n+            return;\n+        }\n+\n+        if (useRelativeIncludes) {\n+            extraFile.addRelativeInclude(file0);\n@@ -72,52 +208,150 @@\n-            Files.createDirectory(copyJdkDir);\n-            Path jdkTestDir = Path.of(Optional.of(System.getProperty(\"test.jdk\"))\n-                            .orElseThrow(() -> new RuntimeException(\"Couldn't load JDK Test Dir\"))\n-            );\n-\n-            copyJDK(jdkTestDir, copyJdkDir);\n-            String extraPropsFile = Path.of(System.getProperty(\"test.src\"), \"override.props\").toString();\n-\n-            \/\/ sanity test -XshowSettings:security option\n-            exerciseShowSettingsSecurity(buildCommand(\"-cp\", System.getProperty(\"test.classes\"),\n-                    \"-Djava.security.debug=all\", \"-XshowSettings:security\", \"ConfigFileTest\", \"runner\"));\n-\n-            \/\/ exercise some debug flags while we're here\n-            \/\/ regular JDK install - should expect success\n-            exerciseSecurity(0, \"java\",\n-                    buildCommand(\"-cp\", System.getProperty(\"test.classes\"),\n-                    \"-Djava.security.debug=all\", \"-Djavax.net.debug=all\", \"ConfigFileTest\", \"runner\"));\n-\n-            \/\/ given an overriding security conf file that doesn't exist, we shouldn't\n-            \/\/ overwrite the properties from original\/master security conf file\n-            exerciseSecurity(0, \"SUN version\",\n-                    buildCommand(\"-cp\", System.getProperty(\"test.classes\"),\n-                    \"-Djava.security.debug=all\", \"-Djavax.net.debug=all\",\n-                    \"-Djava.security.properties==file:\/\/\/\" + extraPropsFile + \"badFileName\",\n-                    \"ConfigFileTest\", \"runner\"));\n-\n-            \/\/ test JDK launch with customized properties file\n-            exerciseSecurity(0, \"NumProviders: 6\",\n-                    buildCommand(\"-cp\", System.getProperty(\"test.classes\"),\n-                    \"-Djava.security.debug=all\", \"-Djavax.net.debug=all\",\n-                    \"-Djava.security.properties==file:\/\/\/\" + extraPropsFile,\n-                    \"ConfigFileTest\", \"runner\"));\n-\n-            \/\/ delete the master conf file\n-            Files.delete(Path.of(copyJdkDir.toString(), \"conf\",\n-                    \"security\",\"java.security\"));\n-\n-            \/\/ launch JDK without java.security file being present or specified\n-            exerciseSecurity(1, \"Error loading java.security file\",\n-                    buildCommand(\"-cp\", System.getProperty(\"test.classes\"),\n-                    \"-Djava.security.debug=all\", \"-Djavax.net.debug=all\",\n-                    \"ConfigFileTest\", \"runner\"));\n-\n-            \/\/ test the override functionality also. Should not be allowed since\n-            \/\/ \"security.overridePropertiesFile=true\" Security property is missing.\n-            exerciseSecurity(1, \"Error loading java.security file\",\n-                    buildCommand(\"-cp\", System.getProperty(\"test.classes\"),\n-                    \"-Djava.security.debug=all\", \"-Djavax.net.debug=all\",\n-                    \"-Djava.security.properties==file:\/\/\/\" + extraPropsFile, \"ConfigFileTest\", \"runner\"));\n-\n-            if (!overrideDetected) {\n-                throw new RuntimeException(\"Override scenario not seen\");\n+            extraFile.addAbsoluteInclude(file0);\n+        }\n+        extraFile.addAbsoluteInclude(file1);\n+\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.setExtraFile(extraFile, extraMode, false);\n+        ex.assertSuccess();\n+    }\n+\n+    static void testUnicodeIncludes1(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        specialCharsIncludes(ex, filesMgr, '\\u2022',\n+                Executor.ExtraMode.PATH_ABS, true);\n+    }\n+\n+    static void testUnicodeIncludes2(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        specialCharsIncludes(ex, filesMgr, '\\u2022',\n+                Executor.ExtraMode.FILE_URI, true);\n+    }\n+\n+    static void testUnicodeIncludes3(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Backward compatibility check. Malformed URLs such as\n+        \/\/ file:\/tmp\/extra•.properties are supported for the extra file.\n+        \/\/ However, relative includes are not allowed in these cases.\n+        specialCharsIncludes(ex, filesMgr, '\\u2022',\n+                Executor.ExtraMode.RAW_FILE_URI1, false);\n+    }\n+\n+    static void testUnicodeIncludes4(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Backward compatibility check. Malformed URLs such as\n+        \/\/ file:\/\/\/tmp\/extra•.properties are supported for the extra file.\n+        \/\/ However, relative includes are not allowed in these cases.\n+        specialCharsIncludes(ex, filesMgr, '\\u2022',\n+                Executor.ExtraMode.RAW_FILE_URI2, false);\n+    }\n+\n+    static void testSpaceIncludes1(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        specialCharsIncludes(ex, filesMgr, ' ',\n+                Executor.ExtraMode.PATH_ABS, true);\n+    }\n+\n+    static void testSpaceIncludes2(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        specialCharsIncludes(ex, filesMgr, ' ',\n+                Executor.ExtraMode.FILE_URI, true);\n+    }\n+\n+    static void testSpaceIncludes3(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Backward compatibility check. Malformed URLs such as\n+        \/\/ file:\/tmp\/extra .properties are supported for the extra file.\n+        \/\/ However, relative includes are not allowed in these cases.\n+        specialCharsIncludes(ex, filesMgr, ' ',\n+                Executor.ExtraMode.RAW_FILE_URI1, false);\n+    }\n+\n+    static void testSpaceIncludes4(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Backward compatibility check. Malformed URLs such as\n+        \/\/ file:\/\/\/tmp\/extra .properties are supported for the extra file.\n+        \/\/ However, relative includes are not allowed in these cases.\n+        specialCharsIncludes(ex, filesMgr, ' ',\n+                Executor.ExtraMode.RAW_FILE_URI2, false);\n+    }\n+\n+    static void notOverrideOnFailureHelper(Executor ex, FilesManager filesMgr,\n+            String nonExistentExtraFile) throws Exception {\n+        \/\/ An overriding extra properties file that does not exist\n+        \/\/ should not erase properties from the master file.\n+        ex.setIgnoredExtraFile(nonExistentExtraFile, true);\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.assertSuccess();\n+        ex.getOutputAnalyzer().shouldContain(\"unable to load security \" +\n+                \"properties from \" + nonExistentExtraFile);\n+    }\n+\n+    static void testNotOverrideOnEmptyFailure(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr, \"\");\n+        ex.getOutputAnalyzer()\n+                .shouldContain(\"Empty extra properties file path\");\n+    }\n+\n+    static void testNotOverrideOnURLFailure(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr,\n+                \"file:\/\/\/nonExistentFile.properties\");\n+    }\n+\n+    static void testNotOverrideOnPathFailure(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr, \"nonExistentFile.properties\");\n+    }\n+\n+    static void testNotOverrideOnDirFailure(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr, \"file:\/\/\/\");\n+        ex.getOutputAnalyzer().shouldContain(\"Is a directory\");\n+    }\n+\n+    static void testNotOverrideOnBadFileURLFailure(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr, \"file:\/\/\/%00\");\n+    }\n+\n+    static void testDisabledExtraPropertiesFile(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+\n+        masterFile.addRawProperty(\"security.overridePropertiesFile\", \"false\");\n+\n+        ex.setMasterFile(masterFile);\n+        ex.setIgnoredExtraFile(file0.path.toString(), true);\n+        ex.assertSuccess();\n+    }\n+\n+    static final String SECURITY_SET_PROP_FILE_PATH =\n+            \"testSecuritySetPropertyShouldNotInclude.propsFilePath\";\n+\n+    static void testSecuritySetPropertyShouldNotInclude(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+\n+        ex.addSystemProp(SECURITY_SET_PROP_FILE_PATH, file0.path.toString());\n+        ex.setMasterFile(masterFile);\n+        ex.assertSuccess();\n+    }\n+\n+    static void assertTestSecuritySetPropertyShouldNotInclude() {\n+        \/\/ This check is executed by the launched JVM.\n+        String propsFilePath = System.getProperty(SECURITY_SET_PROP_FILE_PATH);\n+        if (propsFilePath != null) {\n+            String name = Path.of(propsFilePath).getFileName().toString();\n+            String setPropInvokeRepr = \"Security.setProperty(\\\"include\\\", \" +\n+                    \"\\\"\" + propsFilePath + \"\\\")\";\n+            try {\n+                Security.setProperty(\"include\", propsFilePath);\n+                throw new RuntimeException(setPropInvokeRepr + \" was \" +\n+                        \"expected to throw IllegalArgumentException.\");\n+            } catch (IllegalArgumentException expected) {}\n+            if (FilesManager.APPLIED_PROP_VALUE.equals(\n+                    Security.getProperty(name))) {\n+                throw new RuntimeException(setPropInvokeRepr + \" caused \" +\n+                        \"a file inclusion.\");\n@@ -125,0 +359,5 @@\n+            try {\n+                Security.getProperty(\"include\");\n+                throw new RuntimeException(\"Security.getProperty(\\\"include\\\")\" +\n+                        \" was expected to throw IllegalArgumentException.\");\n+            } catch (IllegalArgumentException expected) {}\n@@ -128,5 +367,16 @@\n-    private static ProcessBuilder buildCommand(String... command) {\n-        ArrayList<String> args = new ArrayList<>();\n-        args.add(COPIED_JAVA.toString());\n-        Collections.addAll(args, Utils.prependTestJavaOpts(command));\n-        return new ProcessBuilder(args);\n+    \/*\n+     * Error cases\n+     *\/\n+\n+    static void testCannotResolveRelativeFromHTTPServed(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+\n+        extraFile.addRelativeInclude(file0);\n+\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.setExtraFile(extraFile, Executor.ExtraMode.HTTP_SERVED, true);\n+        ex.assertError(\"InternalError: Cannot resolve '\" + file0.fileName +\n+                \"' relative path when included from a non-regular \" +\n+                \"properties file (e.g. HTTP served file)\");\n@@ -135,4 +385,10 @@\n-    private static void exerciseSecurity(int exitCode, String output, ProcessBuilder process) throws Exception {\n-        OutputAnalyzer oa = ProcessTools.executeProcess(process);\n-        oa.shouldHaveExitValue(exitCode)\n-                .shouldContain(output);\n+    static void testCannotIncludeCycles(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n+\n+        \/\/ Includes chain: master -> file0 -> file1 -> master.\n+        file1.addRelativeInclude(masterFile);\n+        file0.addRelativeInclude(file1);\n+        masterFile.addRelativeInclude(file0);\n@@ -140,8 +396,88 @@\n-        \/\/ extra checks on debug output\n-        if (exitCode != 1) {\n-            if (oa.getStderr().contains(\"overriding other security properties files!\")) {\n-                overrideDetected = true;\n-                \/\/ master file is not in use - only provider properties are set in custom file\n-                oa.shouldContain(\"security.provider.2=SunRsaSign\")\n-                        .shouldNotContain(EXPECTED_DEBUG_OUTPUT)\n-                        .shouldNotContain(UNEXPECTED_DEBUG_OUTPUT);\n+        ex.setMasterFile(masterFile);\n+        ex.assertError(\n+                \"InternalError: Cyclic include of '\" + masterFile.path + \"'\");\n+    }\n+\n+    static void testCannotIncludeURL(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n+\n+        masterFile.addRawProperty(\"include\", extraFile.url.toString());\n+\n+        ex.setMasterFile(masterFile);\n+        ex.assertError(\"InternalError: Unable to include 'http:\/\/127.0.0.1:\");\n+    }\n+\n+    static void testCannotIncludeNonexistentFile(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+\n+        String nonexistentPath = \"\/nonExistentFile.properties\";\n+        masterFile.addRawProperty(\"include\", nonexistentPath);\n+\n+        ex.setMasterFile(masterFile);\n+        ex.assertError(\n+                \"InternalError: Unable to include '\" + nonexistentPath + \"'\");\n+    }\n+\n+    static void testMustHaveMasterFile(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Launch a JDK without a master java.security file present.\n+        ex.assertError(\"InternalError: Error loading java.security file\");\n+    }\n+\n+    static void testMustHaveMasterFileEvenWithExtraFile(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        \/\/ Launch a JDK without a master java.security file present, but with an\n+        \/\/ extra file passed. Since the \"security.overridePropertiesFile=true\"\n+        \/\/ security property is missing, it should fail anyway.\n+        ex.setExtraFile(\n+                filesMgr.newExtraFile(), Executor.ExtraMode.FILE_URI, true);\n+        ex.assertError(\"InternalError: Error loading java.security file\");\n+    }\n+}\n+\n+sealed class PropsFile permits ExtraPropsFile {\n+    protected static final class Include {\n+        final PropsFile propsFile;\n+        final String value;\n+\n+        private Include(PropsFile propsFile, String value) {\n+            this.propsFile = propsFile;\n+            this.value = value;\n+        }\n+\n+        static Include of(PropsFile propsFile) {\n+            return new Include(propsFile, propsFile.path.toString());\n+        }\n+\n+        static Include of(PropsFile propsFile, String value) {\n+            return new Include(propsFile, value);\n+        }\n+    }\n+\n+    protected final List<Include> includes = new ArrayList<>();\n+    protected final PrintWriter writer;\n+    protected boolean includedFromExtra = false;\n+    final String fileName;\n+    final Path path;\n+\n+    PropsFile(String fileName, Path path) throws IOException {\n+        this.fileName = fileName;\n+        this.path = path;\n+        this.writer = new PrintWriter(Files.newOutputStream(path,\n+                StandardOpenOption.CREATE, StandardOpenOption.APPEND), true);\n+    }\n+\n+    private static String escape(String text, boolean escapeSpace) {\n+        StringBuilder sb = new StringBuilder(text.length());\n+        CharBuffer cb = CharBuffer.wrap(text);\n+        while (cb.hasRemaining()) {\n+            char c = cb.get();\n+            if (c == '\\\\' || escapeSpace && c == ' ') {\n+                sb.append('\\\\');\n+            }\n+            if (Character.UnicodeBlock.of(c) ==\n+                    Character.UnicodeBlock.BASIC_LATIN) {\n+                sb.append(c);\n@@ -149,2 +485,1 @@\n-                oa.shouldContain(EXPECTED_DEBUG_OUTPUT)\n-                        .shouldNotContain(UNEXPECTED_DEBUG_OUTPUT);\n+                sb.append(\"\\\\u%04x\".formatted((int) c));\n@@ -153,0 +488,1 @@\n+        return sb.toString();\n@@ -155,7 +491,61 @@\n-    \/\/ exercise the -XshowSettings:security launcher\n-    private static void exerciseShowSettingsSecurity(ProcessBuilder process) throws Exception {\n-        OutputAnalyzer oa = ProcessTools.executeProcess(process);\n-        oa.shouldHaveExitValue(0)\n-                .shouldContain(\"Security properties:\")\n-                .shouldContain(\"Security provider static configuration:\")\n-                .shouldContain(\"Security TLS configuration\");\n+    private void addRawProperty(String key, String value, String sep) {\n+        writer.println(escape(key, true) + sep + escape(value, false));\n+    }\n+\n+    protected void addIncludeDefinition(Include include) {\n+        if (include.propsFile instanceof ExtraPropsFile) {\n+            throw new RuntimeException(\"ExtraPropsFile should not be included\");\n+        }\n+        includes.add(include);\n+        addRawProperty(\"include\", include.value, \" \");\n+    }\n+\n+    void addComment(String comment) {\n+        writer.println(\"# \" + comment);\n+    }\n+\n+    void addRawProperty(String key, String value) {\n+        addRawProperty(key, value, \"=\");\n+    }\n+\n+    void addAbsoluteInclude(PropsFile propsFile) {\n+        addIncludeDefinition(Include.of(propsFile));\n+    }\n+\n+    void addRelativeInclude(PropsFile propsFile) {\n+        addIncludeDefinition(Include.of(propsFile,\n+                path.getParent().relativize(propsFile.path).toString()));\n+    }\n+\n+    void assertApplied(OutputAnalyzer oa) {\n+        oa.shouldContain(Executor.INITIAL_PROP_LOG_MSG + fileName + \"=\" +\n+                FilesManager.APPLIED_PROP_VALUE);\n+        for (Include include : includes) {\n+            include.propsFile.assertApplied(oa);\n+            oa.shouldContain(\"processing include: '\" + include.value + \"'\");\n+            oa.shouldContain(\"finished processing \" + include.propsFile.path);\n+        }\n+    }\n+\n+    void assertWasOverwritten(OutputAnalyzer oa) {\n+        oa.shouldNotContain(Executor.INITIAL_PROP_LOG_MSG + fileName + \"=\" +\n+                FilesManager.APPLIED_PROP_VALUE);\n+        for (Include include : includes) {\n+            if (!include.propsFile.includedFromExtra) {\n+                include.propsFile.assertWasOverwritten(oa);\n+            }\n+            oa.shouldContain(\"processing include: '\" + include.value + \"'\");\n+            oa.shouldContain(\"finished processing \" + include.propsFile.path);\n+        }\n+    }\n+\n+    void markAsIncludedFromExtra() {\n+        includedFromExtra = true;\n+        for (Include include : includes) {\n+            include.propsFile.markAsIncludedFromExtra();\n+        }\n+    }\n+\n+    PropsFile getLastFile() {\n+        return includes.isEmpty() ?\n+                this : includes.getLast().propsFile.getLastFile();\n@@ -164,4 +554,77 @@\n-    private static void copyJDK(Path src, Path dst) throws Exception {\n-        Files.walk(src)\n-            .skip(1)\n-            .forEach(file -> {\n+    void close() {\n+        writer.close();\n+    }\n+}\n+\n+final class ExtraPropsFile extends PropsFile {\n+    private final Map<String, String> systemProps = new LinkedHashMap<>();\n+    final URI url;\n+\n+    ExtraPropsFile(String fileName, URI url, Path path) throws IOException {\n+        super(fileName, path);\n+        this.url = url;\n+    }\n+\n+    @Override\n+    protected void addIncludeDefinition(Include include) {\n+        if (includes.isEmpty()) {\n+            String propName = \"props.fileName\";\n+            systemProps.put(propName, include.propsFile.fileName);\n+            include = Include.of(include.propsFile,\n+                    include.value.replace(include.propsFile.fileName,\n+                            \"${props.none}${\" + propName + \"}\"));\n+        }\n+        include.propsFile.markAsIncludedFromExtra();\n+        super.addIncludeDefinition(include);\n+    }\n+\n+    Map<String, String> getSystemProperties() {\n+        return Collections.unmodifiableMap(systemProps);\n+    }\n+}\n+\n+final class FilesManager implements Closeable {\n+    private static final Path ROOT_DIR =\n+            Path.of(ConfigFileTest.class.getSimpleName()).toAbsolutePath();\n+    private static final Path PROPS_DIR = ROOT_DIR.resolve(\"properties\");\n+    private static final Path JDK_DIR = ROOT_DIR.resolve(\"jdk\");\n+    private static final Path MASTER_FILE =\n+            JDK_DIR.resolve(\"conf\/security\/java.security\");\n+    private static final Path MASTER_FILE_TEMPLATE =\n+            MASTER_FILE.resolveSibling(\"java.security.template\");\n+    static final String JAVA_EXECUTABLE =\n+            JDK_DIR.resolve(\"bin\/java\").toString();\n+    static final String LAST_FILE_PROP_NAME = \"last-file\";\n+    static final String APPLIED_PROP_VALUE = \"applied\";\n+\n+    private final List<PropsFile> createdFiles;\n+    private final Set<String> fileNamesInUse;\n+    private final HttpServer httpServer;\n+    private final URI serverUri;\n+    private final long masterFileLines;\n+\n+    FilesManager() throws Exception {\n+        createdFiles = new ArrayList<>();\n+        fileNamesInUse = new HashSet<>();\n+        httpServer = HttpServer.create(\n+                new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);\n+        httpServer.createContext(\"\/\", this::handleRequest);\n+        InetSocketAddress address = httpServer.getAddress();\n+        httpServer.start();\n+        serverUri = new URI(\"http\", null, address.getHostString(),\n+                address.getPort(), null, null, null);\n+        copyJDK();\n+        try (Stream<String> s = Files.lines(MASTER_FILE_TEMPLATE)) {\n+            masterFileLines = s.count();\n+        }\n+    }\n+\n+    private static void copyJDK() throws Exception {\n+        Path testJDK = Path.of(Objects.requireNonNull(\n+                System.getProperty(\"test.jdk\"), \"unspecified test.jdk\"));\n+        if (!Files.exists(testJDK)) {\n+            throw new RuntimeException(\"test.jdk -> nonexistent JDK\");\n+        }\n+        Files.createDirectories(JDK_DIR);\n+        try (Stream<Path> pathStream = Files.walk(testJDK)) {\n+            pathStream.skip(1).forEach((Path file) -> {\n@@ -169,1 +632,2 @@\n-                    Files.copy(file, dst.resolve(src.relativize(file)), StandardCopyOption.COPY_ATTRIBUTES);\n+                    Files.copy(file, JDK_DIR.resolve(testJDK.relativize(file)),\n+                            StandardCopyOption.COPY_ATTRIBUTES);\n@@ -174,0 +638,288 @@\n+        }\n+        Files.move(MASTER_FILE, MASTER_FILE_TEMPLATE);\n+    }\n+\n+    private void handleRequest(HttpExchange x) throws IOException {\n+        String rawPath = x.getRequestURI().getRawPath();\n+        Path f = ROOT_DIR.resolve(x.getRequestURI().getPath().substring(1));\n+        int statusCode;\n+        byte[] responseBody;\n+        \/\/ Check for unescaped space, unresolved parent or backward slash.\n+        if (rawPath.matches(\"^.*( |(\\\\.|%2[Ee]){2}|\\\\\\\\|%5[Cc]).*$\")) {\n+            statusCode = HttpURLConnection.HTTP_BAD_REQUEST;\n+            responseBody = new byte[0];\n+        } else if (Files.isRegularFile(f)) {\n+            x.getResponseHeaders().add(\"Content-type\", \"text\/plain\");\n+            statusCode = HttpURLConnection.HTTP_OK;\n+            responseBody = Files.readAllBytes(f);\n+        } else {\n+            statusCode = HttpURLConnection.HTTP_NOT_FOUND;\n+            responseBody = new byte[0];\n+        }\n+        System.out.println(\"[\" + Instant.now() + \"] \" +\n+                getClass().getSimpleName() + \": \" +\n+                x.getRequestMethod() + \" \" + rawPath + \" -> \" +\n+                statusCode + \" (\" + responseBody.length + \" bytes)\");\n+        try (OutputStream responseStream = x.getResponseBody()) {\n+            x.sendResponseHeaders(statusCode, responseBody.length);\n+            responseStream.write(responseBody);\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    private interface PropsFileBuilder {\n+        PropsFile build(String fileName, Path path) throws IOException;\n+    }\n+\n+    private PropsFile newFile(Path path, PropsFileBuilder builder)\n+            throws IOException {\n+        String fileName = path.getFileName().toString();\n+        if (!fileNamesInUse.add(fileName)) {\n+            \/\/ Names must be unique in order for the special\n+            \/\/ property <fileName>=<APPLIED_PROP_VALUE> to work.\n+            throw new RuntimeException(fileName + \" is repeated\");\n+        }\n+        Files.createDirectories(path.getParent());\n+        PropsFile propsFile = builder.build(fileName, path);\n+        propsFile.addComment(\"Property to determine if this properties file \" +\n+                \"was parsed and not overwritten:\");\n+        propsFile.addRawProperty(fileName, APPLIED_PROP_VALUE);\n+        propsFile.addComment(ConfigFileTest.SEPARATOR_THIN);\n+        propsFile.addComment(\"Property to be overwritten by every properties \" +\n+                \"file (master, extra or included):\");\n+        propsFile.addRawProperty(LAST_FILE_PROP_NAME, fileName);\n+        propsFile.addComment(ConfigFileTest.SEPARATOR_THIN);\n+        createdFiles.add(propsFile);\n+        return propsFile;\n+    }\n+\n+    PropsFile newFile(String relPathStr) throws IOException {\n+        return newFile(PROPS_DIR.resolve(relPathStr), PropsFile::new);\n+    }\n+\n+    PropsFile newMasterFile() throws IOException {\n+        Files.copy(MASTER_FILE_TEMPLATE, MASTER_FILE);\n+        return newFile(MASTER_FILE, PropsFile::new);\n+    }\n+\n+    ExtraPropsFile newExtraFile() throws IOException {\n+        return newExtraFile(\"extra.properties\");\n+    }\n+\n+    ExtraPropsFile newExtraFile(String extraFileName) throws IOException {\n+        return (ExtraPropsFile) newFile(PROPS_DIR.resolve(extraFileName),\n+                (fileName, path) -> {\n+                    URI uri = serverUri.resolve(ParseUtil.encodePath(\n+                            ROOT_DIR.relativize(path).toString()));\n+                    return new ExtraPropsFile(fileName, uri, path);\n+                });\n+    }\n+\n+    void reportCreatedFiles() throws IOException {\n+        for (PropsFile propsFile : createdFiles) {\n+            System.err.println();\n+            System.err.println(propsFile.path.toString());\n+            System.err.println(ConfigFileTest.SEPARATOR_THIN.repeat(3));\n+            try (Stream<String> lines = Files.lines(propsFile.path)) {\n+                long lineNumber = 1L;\n+                Iterator<String> it = lines.iterator();\n+                while (it.hasNext()) {\n+                    String line = it.next();\n+                    if (!propsFile.path.equals(MASTER_FILE) ||\n+                            lineNumber > masterFileLines) {\n+                        System.err.println(line);\n+                    }\n+                    lineNumber++;\n+                }\n+            }\n+            System.err.println();\n+        }\n+    }\n+\n+    void clear() throws IOException {\n+        if (!createdFiles.isEmpty()) {\n+            for (PropsFile propsFile : createdFiles) {\n+                propsFile.close();\n+                Files.delete(propsFile.path);\n+            }\n+            FileUtils.deleteFileTreeUnchecked(PROPS_DIR);\n+            createdFiles.clear();\n+            fileNamesInUse.clear();\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        clear();\n+        httpServer.stop(0);\n+        FileUtils.deleteFileTreeUnchecked(ROOT_DIR);\n+    }\n+}\n+\n+final class Executor {\n+    enum ExtraMode {\n+        HTTP_SERVED, FILE_URI, RAW_FILE_URI1, RAW_FILE_URI2, PATH_ABS, PATH_REL\n+    }\n+    static final String RUNNER_ARG = \"runner\";\n+    static final String INITIAL_PROP_LOG_MSG = \"Initial security property: \";\n+    private static final String OVERRIDING_LOG_MSG =\n+            \"overriding other security properties files!\";\n+    private static final String[] ALWAYS_UNEXPECTED_LOG_MSGS = {\n+            \"java.lang.AssertionError\",\n+            INITIAL_PROP_LOG_MSG + \"postInitTest=shouldNotRecord\",\n+            INITIAL_PROP_LOG_MSG + \"include=\",\n+    };\n+    private static final Path CWD = Path.of(\".\").toAbsolutePath();\n+    private static final String JAVA_SEC_PROPS = \"java.security.properties\";\n+    private static final String CLASS_PATH = Objects.requireNonNull(\n+            System.getProperty(\"test.classes\"), \"unspecified test.classes\");\n+    private static final String DEBUG_ARG =\n+            \"-Xrunjdwp:transport=dt_socket,address=localhost:8000,suspend=y\";\n+    private final Map<String, String> systemProps = new LinkedHashMap<>(\n+            Map.of(\"java.security.debug\", \"all\", \"javax.net.debug\", \"all\",\n+                    \/\/ Ensure we get UTF-8 debug outputs in Windows:\n+                    \"stderr.encoding\", \"UTF-8\", \"stdout.encoding\", \"UTF-8\"));\n+    private final List<String> jvmArgs = new ArrayList<>(\n+            List.of(FilesManager.JAVA_EXECUTABLE, \"-enablesystemassertions\",\n+                    \/\/ Uncomment DEBUG_ARG to debug test-launched JVMs:\n+                    \"-classpath\", CLASS_PATH\/\/, DEBUG_ARG\n+            ));\n+    private PropsFile masterPropsFile;\n+    private ExtraPropsFile extraPropsFile;\n+    private boolean expectedOverrideAll = false;\n+    private OutputAnalyzer oa;\n+\n+    static void run(Method m, FilesManager filesMgr) throws Exception {\n+        try {\n+            m.invoke(null, new Executor(), filesMgr);\n+        } catch (Throwable e) {\n+            filesMgr.reportCreatedFiles();\n+            throw e;\n+        } finally {\n+            filesMgr.clear();\n+        }\n+    }\n+\n+    void addSystemProp(String key, String value) {\n+        systemProps.put(key, value);\n+    }\n+\n+    private void setRawExtraFile(String extraFile, boolean overrideAll) {\n+        addSystemProp(JAVA_SEC_PROPS, (overrideAll ? \"=\" : \"\") + extraFile);\n+    }\n+\n+    void setMasterFile(PropsFile masterPropsFile) {\n+        this.masterPropsFile = masterPropsFile;\n+    }\n+\n+    void setExtraFile(ExtraPropsFile extraPropsFile, ExtraMode mode,\n+            boolean overrideAll) {\n+        this.extraPropsFile = extraPropsFile;\n+        expectedOverrideAll = overrideAll;\n+        setRawExtraFile(switch (mode) {\n+            case HTTP_SERVED -> extraPropsFile.url.toString();\n+            case FILE_URI -> extraPropsFile.path.toUri().toString();\n+            case RAW_FILE_URI1 -> \"file:\" + extraPropsFile.path;\n+            case RAW_FILE_URI2 -> \"file:\/\/\" +\n+                    (extraPropsFile.path.startsWith(\"\/\") ? \"\" : \"\/\") +\n+                    extraPropsFile.path;\n+            case PATH_ABS -> extraPropsFile.path.toString();\n+            case PATH_REL -> CWD.relativize(extraPropsFile.path).toString();\n+        }, overrideAll);\n+    }\n+\n+    void setIgnoredExtraFile(String extraPropsFile, boolean overrideAll) {\n+        setRawExtraFile(extraPropsFile, overrideAll);\n+        expectedOverrideAll = false;\n+    }\n+\n+    void addJvmArg(String arg) {\n+        jvmArgs.add(arg);\n+    }\n+\n+    private void execute(boolean successExpected) throws Exception {\n+        List<String> command = new ArrayList<>(jvmArgs);\n+        Collections.addAll(command, Utils.getTestJavaOpts());\n+        addSystemPropertiesAsJvmArgs(command);\n+        command.add(ConfigFileTest.class.getSimpleName());\n+        command.add(RUNNER_ARG);\n+        oa = ProcessTools.executeProcess(new ProcessBuilder(command));\n+        oa.shouldHaveExitValue(successExpected ? 0 : 1);\n+        for (String output : ALWAYS_UNEXPECTED_LOG_MSGS) {\n+            oa.shouldNotContain(output);\n+        }\n+    }\n+\n+    private void addSystemPropertiesAsJvmArgs(List<String> command) {\n+        Map<String, String> allSystemProps = new LinkedHashMap<>(systemProps);\n+        if (extraPropsFile != null) {\n+            allSystemProps.putAll(extraPropsFile.getSystemProperties());\n+        }\n+        for (Map.Entry<String, String> e : allSystemProps.entrySet()) {\n+            command.add(\"-D\" + e.getKey() + \"=\" + e.getValue());\n+        }\n+    }\n+\n+    void assertSuccess() throws Exception {\n+        execute(true);\n+\n+        \/\/ Ensure every file was processed by checking a unique property used as\n+        \/\/ a flag. Each file defines <fileName>=applied.\n+        \/\/\n+        \/\/ For example:\n+        \/\/\n+        \/\/   file0\n+        \/\/   ---------------\n+        \/\/   file0=applied\n+        \/\/   include file1\n+        \/\/\n+        \/\/   file1\n+        \/\/   ---------------\n+        \/\/   file1=applied\n+        \/\/\n+        \/\/ The assertion would be file0 == applied AND file1 == applied.\n+        \/\/\n+        if (extraPropsFile != null) {\n+            extraPropsFile.assertApplied(oa);\n+        }\n+        if (expectedOverrideAll) {\n+            \/\/ When overriding with an extra file, check that neither\n+            \/\/ the master file nor its includes are visible.\n+            oa.shouldContain(OVERRIDING_LOG_MSG);\n+            masterPropsFile.assertWasOverwritten(oa);\n+        } else {\n+            oa.shouldNotContain(OVERRIDING_LOG_MSG);\n+            masterPropsFile.assertApplied(oa);\n+        }\n+\n+        \/\/ Ensure the last included file overwrote a fixed property. Each file\n+        \/\/ defines last-file=<fileName>.\n+        \/\/\n+        \/\/ For example:\n+        \/\/\n+        \/\/   file0\n+        \/\/   ---------------\n+        \/\/   last-file=file0\n+        \/\/   include file1\n+        \/\/\n+        \/\/   file1\n+        \/\/   ---------------\n+        \/\/   last-file=file1\n+        \/\/\n+        \/\/ The assertion would be last-file == file1.\n+        \/\/\n+        PropsFile lastFile = (extraPropsFile == null ?\n+                masterPropsFile : extraPropsFile).getLastFile();\n+        oa.shouldContain(FilesManager.LAST_FILE_PROP_NAME + \"=\" +\n+                lastFile.fileName);\n+        oa.stdoutShouldContain(FilesManager.LAST_FILE_PROP_NAME + \": \" +\n+                lastFile.fileName);\n+    }\n+\n+    void assertError(String message) throws Exception {\n+        execute(false);\n+        oa.shouldContain(message);\n+    }\n+\n+    OutputAnalyzer getOutputAnalyzer() {\n+        return oa;\n","filename":"test\/jdk\/java\/security\/Security\/ConfigFileTest.java","additions":861,"deletions":109,"binary":false,"changes":970,"status":"modified"},{"patch":"@@ -1,7 +0,0 @@\n-# exercise ServiceLoader and legacy (class load) approach\n-security.provider.1=sun.security.provider.Sun\n-security.provider.2=SunRsaSign\n-security.provider.3=sun.security.ssl.SunJSSE\n-security.provider.4=com.sun.crypto.provider.SunJCE\n-security.provider.5=SunJGSS\n-security.provider.6=SunSASL\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/security\/Security\/override.props","additions":0,"deletions":7,"binary":false,"changes":7,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.util.List;\n@@ -55,3 +54,2 @@\n-\n-    private static final String STATIC_PROPS =\n-        Paths.get(TEST_SRC, \"Static.props\").toString();\n+    private static final Path STATIC_PROPS =\n+        Paths.get(TEST_SRC, \"Static.props\");\n@@ -92,1 +90,1 @@\n-            \"-Djava.security.properties=file:\" + STATIC_PROPS,\n+            \"-Djava.security.properties=\" + STATIC_PROPS.toUri(),\n","filename":"test\/jdk\/java\/security\/Security\/signedfirst\/DynStatic.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"}]}