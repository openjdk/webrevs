{"files":[{"patch":"@@ -436,6 +436,1 @@\n-    \/\/ Interned string. Because the objects are laid out in DFS order, the value\n-    \/\/ array will always be the next object in iteration order. Finish materializing\n-    \/\/ and link it to the string table.\n-    int value_object_index = object_index + 1;\n-    assert(value_object_index == archived_string_value_object_index(archive_object), \"Next object must be the value\");\n-    assert(heap_object_for_object_index(value_object_index) == nullptr, \"Should not be initialized\");\n+    int value_object_index = archived_string_value_object_index(archive_object);\n@@ -554,3 +549,6 @@\n-      \/\/ Interned strings are eagerly materialized in the allocation phase, so there is\n-      \/\/ nothing else to do for interned strings here for the string nor its value array.\n-      i++;\n+      int value_object_index = archived_string_value_object_index(archive_object);\n+      if (value_object_index == i + 1) {\n+        \/\/ Interned strings are eagerly materialized in the allocation phase, so there is\n+        \/\/ nothing else to do for interned strings here for the string nor its value array.\n+        i++;\n+      }\n@@ -582,17 +580,5 @@\n-    if (heap_object == nullptr) {\n-      if (string_intern) {\n-        \/\/ Eagerly materialize interned strings to ensure that objects earlier than the string\n-        \/\/ in a batch get linked to the intended interned string, and not a copy.\n-        int value_object_index = i + 1;\n-        assert(value_object_index == archived_string_value_object_index(archive_object), \"Next object must be the value\");\n-        assert(heap_object_for_object_index(value_object_index) == nullptr, \"Should not be initialized\");\n-        assert(value_object_index <= last_object_index, \"Must be within this batch: %d <= %d\", value_object_index, last_object_index);\n-\n-        { \/\/ Materialize the value object.\n-          oopDesc* archive_value_object = archive_object_for_object_index(value_object_index);\n-          markWord value_mark = archive_value_object->mark();\n-          size_t value_size = archive_object_size(archive_value_object);\n-          oop value_heap_object = allocate_object(archive_value_object, value_mark, value_size, CHECK_0);\n-          set_heap_object_for_object_index(value_object_index, value_heap_object);\n-          copy_object_eager_linking(archive_value_object, value_heap_object, value_size);\n-        }\n+    if (heap_object != nullptr) {\n+      \/\/ Lazy loading has already initialized the object; we must not mutate it\n+      lazy_object_indices.append(i);\n+      continue;\n+    }\n@@ -600,3 +586,6 @@\n-        \/\/ Allocate and link the string.\n-        heap_object = allocate_object(archive_object, mark, size, CHECK_0);\n-        copy_object_eager_linking(archive_object, heap_object, size);\n+    if (!string_intern) {\n+     \/\/ The normal case; no lazy loading have loaded the object yet\n+      heap_object = allocate_object(archive_object, mark, size, CHECK_0);\n+      set_heap_object_for_object_index(i, heap_object);\n+      continue;\n+    }\n@@ -604,1 +593,3 @@\n-        assert(java_lang_String::value(heap_object) == heap_object_for_object_index(value_object_index), \"Linker should have linked this correctly\");\n+    \/\/ Eagerly materialize interned strings to ensure that objects earlier than the string\n+    \/\/ in a batch get linked to the intended interned string, and not a copy.\n+    int value_object_index = archived_string_value_object_index(archive_object);\n@@ -606,3 +597,1 @@\n-        \/\/ Replace the string with interned string\n-        heap_object = StringTable::intern(heap_object, CHECK_0);\n-        set_heap_object_for_object_index(i, heap_object);\n+    bool is_normal_interned_string = value_object_index == i + 1;\n@@ -610,3 +599,16 @@\n-        \/\/ Skip over the object value, already materialized\n-        i = value_object_index;\n-        continue;\n+    if (value_object_index < first_object_index) {\n+      \/\/ If materialized in a previous batch, the value should already be allocated and initialized.\n+      assert(heap_object_for_object_index(value_object_index) != nullptr, \"should be materialized\");\n+    } else {\n+      \/\/ Materialize the value object.\n+      oopDesc* archive_value_object = archive_object_for_object_index(value_object_index);\n+      markWord value_mark = archive_value_object->mark();\n+      size_t value_size = archive_object_size(archive_value_object);\n+      oop value_heap_object;\n+\n+      if (is_normal_interned_string) {\n+        \/\/ The common case: the value is next to the string. This happens when only the interned\n+        \/\/ string points to its value character array.\n+        assert(value_object_index <= last_object_index, \"Must be within this batch: %d <= %d\", value_object_index, last_object_index);\n+        value_heap_object = allocate_object(archive_value_object, value_mark, value_size, CHECK_0);\n+        set_heap_object_for_object_index(value_object_index, value_heap_object);\n@@ -614,3 +616,4 @@\n-       \/\/ The normal case; no lazy loading have loaded the object yet\n-        heap_object = allocate_object(archive_object, mark, size, CHECK_0);\n-        set_heap_object_for_object_index(i, heap_object);\n+        \/\/ In the uncommon case, multiple strings point to the value of an interned string.\n+        \/\/ The string can then be earlier in the batch.\n+        assert(value_object_index < i, \"surprising index\");\n+        value_heap_object = heap_object_for_object_index(value_object_index);\n@@ -618,3 +621,16 @@\n-    } else {\n-      \/\/ Lazy loading has already initialized the object; we must not mutate it\n-      lazy_object_indices.append(i);\n+\n+      copy_object_eager_linking(archive_value_object, value_heap_object, value_size);\n+    }\n+    \/\/ Allocate and link the string.\n+    heap_object = allocate_object(archive_object, mark, size, CHECK_0);\n+    copy_object_eager_linking(archive_object, heap_object, size);\n+\n+    assert(java_lang_String::value(heap_object) == heap_object_for_object_index(value_object_index), \"Linker should have linked this correctly\");\n+\n+    \/\/ Replace the string with interned string\n+    heap_object = StringTable::intern(heap_object, CHECK_0);\n+    set_heap_object_for_object_index(i, heap_object);\n+\n+    if (is_normal_interned_string) {\n+      \/\/ Skip over the object value, already materialized\n+      i++;\n","filename":"src\/hotspot\/share\/cds\/aotStreamedHeapLoader.cpp","additions":58,"deletions":42,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -129,6 +129,0 @@\n-  } else if (CDSConfig::is_dumping_heap()) {\n-    \/\/ String deduplication can mess with the string interning logic during\n-    \/\/ heap dumping.\n-    log_warning(stringdedup)(\"String Deduplication disabled: \"\n-                             \"not supported when heap dumping\");\n-    FLAG_SET_ERGO(UseStringDeduplication, false);\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupConfig.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"}]}