{"files":[{"patch":"@@ -150,1 +150,1 @@\n- * <h3> Root modules <\/h3>\n+ * <h3><a id=\"root-modules\"><\/a> Root modules <\/h3>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-     * Returns a package given its fully qualified name if the package is unique in the environment.\n-     * If running with modules, all modules in the modules graph are searched for matching packages.\n+     * Returns a package given its fully qualified name if the package is uniquely\n+     * determinable in the environment.\n@@ -57,2 +57,21 @@\n-     * @param name  fully qualified package name, or an empty string for an unnamed package\n-     * @return the specified package, or {@code null} if it cannot be uniquely found\n+     * If running with modules, packages of the given name are searched in a\n+     * two-stage process:\n+     * <ul>\n+     *     <li>find non-empty packages with the given name returned by\n+     *         {@link #getPackageElement(ModuleElement, CharSequence)},\n+     *         where the provided ModuleSymbol is any\n+     *         <a href=\"..\/..\/..\/..\/..\/java.base\/java\/lang\/module\/package-summary.html#root-modules\">root module<\/a>,\n+     *     <\/li>\n+     *     <li>if the above yields an empty list, search\n+     *         {@link #getAllModuleElements() all modules} for observable\n+     *         packages with the given name\n+     *     <\/li>\n+     * <\/ul>\n+     *\n+     * If this process leads to a list with a single element,\n+     * the single element is returned, otherwise null is returned.\n+     *\n+     * @param name fully qualified package name,\n+     *             or an empty string for an unnamed package\n+     * @return the specified package,\n+     *         or {@code null} if no package can be uniquely determined.\n@@ -122,3 +141,2 @@\n-     * Returns a type element given its canonical name if the type element is unique in the environment.\n-     * If running with modules, all modules in the modules graph are searched for matching\n-     * type elements.\n+     * Returns a type element given its canonical name if the type element is uniquely\n+     * determinable in the environment.\n@@ -126,2 +144,20 @@\n-     * @param name  the canonical name\n-     * @return the named type element, or {@code null} if it cannot be uniquely found\n+     * If running with modules, type elements of the given name are\n+     * searched in a two-stage process:\n+     * <ul>\n+     *     <li>find type elements with the given name returned by\n+     *         {@link #getTypeElement(ModuleElement, CharSequence)},\n+     *         where the provided ModuleSymbol is any\n+     *         <a href=\"..\/..\/..\/..\/..\/java.base\/java\/lang\/module\/package-summary.html#root-modules\">root module<\/a>,\n+     *     <\/li>\n+     *     <li>if the above yields an empty list, search\n+     *         {@link #getAllModuleElements() all modules} for observable\n+     *         type elements with the given name\n+     *     <\/li>\n+     * <\/ul>\n+     *\n+     * If this process leads to a list with a single element,\n+     * the single element is returned, otherwise null is returned.\n+     *\n+     * @param name the canonical name\n+     * @return the named type element,\n+     *         or {@code null} if no type element can be uniquely determined.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":45,"deletions":9,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Arrays;\n@@ -201,0 +202,1 @@\n+            Set<ModuleSymbol> allModules = new HashSet<>(modules.allModules());\n@@ -202,2 +204,1 @@\n-            for (ModuleSymbol msym : modules.allModules()) {\n-                S sym = nameToSymbol(msym, nameStr, clazz);\n+            allModules.removeAll(modules.getRootModules());\n@@ -205,2 +206,3 @@\n-                if (sym == null)\n-                    continue;\n+            for (Set<ModuleSymbol> modules : Arrays.asList(modules.getRootModules(), allModules)) {\n+                for (ModuleSymbol msym : modules) {\n+                    S sym = nameToSymbol(msym, nameStr, clazz);\n@@ -208,9 +210,5 @@\n-                if (clazz == ClassSymbol.class) {\n-                    \/\/ Always include classes\n-                    found.add(sym);\n-                } else if (clazz == PackageSymbol.class) {\n-                    \/\/ In module mode, ignore the \"spurious\" empty packages that \"enclose\" module-specific packages.\n-                    \/\/ For example, if a module contains classes or package info in package p.q.r, it will also appear\n-                    \/\/ to have additional packages p.q and p, even though these packages have no content other\n-                    \/\/ than the subpackage.  We don't want those empty packages showing up in searches for p or p.q.\n-                    if (!sym.members().isEmpty() || ((PackageSymbol) sym).package_info != null) {\n+                    if (sym == null)\n+                        continue;\n+\n+                    if (clazz == ClassSymbol.class) {\n+                        \/\/ Always include classes\n@@ -218,0 +216,8 @@\n+                    } else if (clazz == PackageSymbol.class) {\n+                        \/\/ In module mode, ignore the \"spurious\" empty packages that \"enclose\" module-specific packages.\n+                        \/\/ For example, if a module contains classes or package info in package p.q.r, it will also appear\n+                        \/\/ to have additional packages p.q and p, even though these packages have no content other\n+                        \/\/ than the subpackage.  We don't want those empty packages showing up in searches for p or p.q.\n+                        if (!sym.members().isEmpty() || ((PackageSymbol) sym).package_info != null) {\n+                            found.add(sym);\n+                        }\n@@ -220,1 +226,0 @@\n-            }\n@@ -222,10 +227,14 @@\n-            if (found.size() == 1) {\n-                return Optional.of(found.iterator().next());\n-            } else if (found.size() > 1) {\n-                \/\/more than one element found, produce a note:\n-                if (alreadyWarnedDuplicates.add(methodName + \":\" + nameStr)) {\n-                    String moduleNames = found.stream()\n-                                              .map(s -> s.packge().modle)\n-                                              .map(m -> m.toString())\n-                                              .collect(Collectors.joining(\", \"));\n-                    log.note(Notes.MultipleElements(methodName, nameStr, moduleNames));\n+                if (found.size() == 1) {\n+                    return Optional.of(found.iterator().next());\n+                } else if (found.size() > 1) {\n+                    \/\/more than one element found, produce a note:\n+                    if (alreadyWarnedDuplicates.add(methodName + \":\" + nameStr)) {\n+                        String moduleNames = found.stream()\n+                                                  .map(s -> s.packge().modle)\n+                                                  .map(m -> m.toString())\n+                                                  .collect(Collectors.joining(\", \"));\n+                        log.note(Notes.MultipleElements(methodName, nameStr, moduleNames));\n+                    }\n+                    return Optional.empty();\n+                } else {\n+                    \/\/not found, try another option\n@@ -233,4 +242,0 @@\n-                return Optional.empty();\n-            } else {\n-                \/\/not found:\n-                return Optional.empty();\n@@ -238,0 +243,1 @@\n+            return Optional.empty();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":34,"deletions":28,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8133884 8162711 8133896 8172158 8172262 8173636 8175119 8189747\n+ * @bug 8133884 8162711 8133896 8172158 8172262 8173636 8175119 8189747 8236842\n@@ -49,0 +49,1 @@\n+import java.util.Iterator;\n@@ -56,1 +57,0 @@\n-import java.util.regex.Pattern;\n@@ -83,2 +83,0 @@\n-import javax.tools.JavaFileManager;\n-import javax.tools.JavaFileManager.Location;\n@@ -87,1 +85,0 @@\n-import javax.tools.StandardLocation;\n@@ -1302,0 +1299,434 @@\n+    @Test\n+    public void testUnboundLookupNew(Path base) throws Exception {\n+        Path moduleSrc = base.resolve(\"module-src\");\n+        Path m1 = moduleSrc.resolve(\"m1x\");\n+        Path m2 = moduleSrc.resolve(\"m2x\");\n+        Path m3 = moduleSrc.resolve(\"m3x\");\n+        Path m4 = moduleSrc.resolve(\"m4x\");\n+\n+        Path src = base.resolve(\"src\");\n+\n+        Path classes = base.resolve(\"classes\");\n+        Path srcClasses = base.resolve(\"src-classes\");\n+\n+        Files.createDirectories(classes);\n+        Files.createDirectories(srcClasses);\n+        Files.createDirectories(moduleSrc);\n+\n+        {\n+            tb.cleanDirectory(classes);\n+            tb.cleanDirectory(moduleSrc);\n+\n+            tb.writeJavaFiles(m1,\n+                              \"module m1x { exports api; }\",\n+                              \"package test; public class Test { }\",\n+                              \"package api; public class API {}\");\n+\n+            tb.writeJavaFiles(m2,\n+                              \"module m2x { requires m1x; }\",\n+                              \"package test; public class Test { }\",\n+                              \"package api.impl; public class Impl { }\");\n+\n+            new JavacTask(tb)\n+                .options(\"--module-source-path\", moduleSrc.toString())\n+                .outdir(classes)\n+                .files(findJavaFiles(moduleSrc))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+            List<String> log = new JavacTask(tb)\n+                .options(\"--module-source-path\", moduleSrc.toString(),\n+                         \"-processorpath\", System.getProperty(\"test.class.path\"),\n+                         \"-processor\", UnboundLookupNew.class.getName(),\n+                         \"-AlookupClass=+test.Test\",\n+                         \"-AlookupPackage=+test,+api\",\n+                         \"-XDrawDiagnostics\")\n+                .outdir(classes)\n+                .files(findJavaFiles(m2))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+            List<String> expected = Arrays.asList(\"- compiler.note.proc.messager: test.Test found in module: m2x\",\n+                                                  \"- compiler.note.proc.messager: test found in module: m2x\",\n+                                                  \"- compiler.note.proc.messager: api found in module: m1x\",\n+                                                  \"- compiler.note.proc.messager: test.Test found in module: m2x\",\n+                                                  \"- compiler.note.proc.messager: test found in module: m2x\",\n+                                                  \"- compiler.note.proc.messager: api found in module: m1x\"\n+                                                 );\n+\n+            if (!expected.equals(log)) {\n+                throw new AssertionError(\"Expected output not found: \" + log);\n+            }\n+        }\n+\n+        {\n+            tb.cleanDirectory(classes);\n+            tb.cleanDirectory(moduleSrc);\n+\n+            tb.writeJavaFiles(m1,\n+                              \"module m1x { exports test; }\",\n+                              \"package test; public class Test { }\");\n+\n+            tb.writeJavaFiles(m2,\n+                              \"module m2x { requires m1x; }\",\n+                              \"package test; public class Test { }\");\n+\n+            List<String> log = new JavacTask(tb)\n+                .options(\"--module-source-path\", moduleSrc.toString(),\n+                         \"-processorpath\", System.getProperty(\"test.class.path\"),\n+                         \"-processor\", UnboundLookupNew.class.getName(),\n+                         \"-AlookupClass=+test.Test\",\n+                         \"-AlookupPackage=+test\",\n+                         \"-XDrawDiagnostics\",\n+                         \"-XDshould-stop.at=FLOW\")\n+                .outdir(classes)\n+                .files(findJavaFiles(m2))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+            List<String> expected = Arrays.asList(\n+                    \"Test.java:1:1: compiler.err.package.in.other.module: m1x\",\n+                    \"- compiler.note.proc.messager: test.Test found in module: m2x\",\n+                    \"- compiler.note.proc.messager: test found in module: m1x\",\n+                    \"- compiler.note.proc.messager: test.Test found in module: m2x\",\n+                    \"- compiler.note.proc.messager: test found in module: m1x\",\n+                    \"1 error\");\n+\n+            if (!expected.equals(log)) {\n+                throw new AssertionError(\"Expected output not found: \" + log);\n+            }\n+        }\n+\n+        {\n+            tb.cleanDirectory(classes);\n+            tb.cleanDirectory(moduleSrc);\n+\n+            tb.writeJavaFiles(m1,\n+                              \"module m1x { }\",\n+                              \"package test; public class Test { }\");\n+\n+            tb.writeJavaFiles(m2,\n+                              \"module m2x { requires m1x; requires m3x; }\",\n+                              \"package test; public class Test { }\");\n+\n+            tb.writeJavaFiles(m3,\n+                              \"module m3x { }\",\n+                              \"package test; public class Test { }\");\n+\n+            new JavacTask(tb)\n+                .options(\"--module-source-path\", moduleSrc.toString())\n+                .outdir(classes)\n+                .files(findJavaFiles(moduleSrc))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+            List<String> log = new JavacTask(tb)\n+                .options(\"--module-source-path\", moduleSrc.toString(),\n+                         \"-processorpath\", System.getProperty(\"test.class.path\"),\n+                         \"-processor\", UnboundLookupNew.class.getName(),\n+                         \"-AlookupClass=+test.Test\",\n+                         \"-AlookupPackage=+test\",\n+                         \"-XDrawDiagnostics\")\n+                .outdir(classes)\n+                .files(findJavaFiles(m2))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+            List<String> expected = Arrays.asList(\n+                    \"- compiler.note.proc.messager: test.Test found in module: m2x\",\n+                    \"- compiler.note.proc.messager: test found in module: m2x\",\n+                    \"- compiler.note.proc.messager: test.Test found in module: m2x\",\n+                    \"- compiler.note.proc.messager: test found in module: m2x\"\n+            );\n+\n+            if (!expected.equals(log)) {\n+                throw new AssertionError(\"Expected output not found: \" + log);\n+            }\n+        }\n+\n+        {\n+            tb.cleanDirectory(classes);\n+            tb.cleanDirectory(moduleSrc);\n+\n+            tb.writeJavaFiles(m1,\n+                              \"module m1x { exports test; }\",\n+                              \"package test; public class Test { }\");\n+\n+            tb.writeJavaFiles(m2,\n+                              \"module m2x { requires m1x; requires m3x; }\");\n+\n+            tb.writeJavaFiles(m3,\n+                              \"module m3x { exports test; }\",\n+                              \"package test; public class Test { }\");\n+\n+            tb.writeJavaFiles(m4,\n+                              \"module m4x { }\",\n+                              \"package test; public class Test { }\");\n+\n+            {\n+                List<String> log = new JavacTask(tb)\n+                    .options(\"--module-source-path\", moduleSrc.toString(),\n+                             \"-processorpath\", System.getProperty(\"test.class.path\"),\n+                             \"-processor\", UnboundLookupNew.class.getName(),\n+                             \"-AlookupClass=+test.Test\",\n+                             \"-AlookupPackage=+test\",\n+                             \"-XDrawDiagnostics\",\n+                             \"-XDshould-stop.at=FLOW\")\n+                    .outdir(classes)\n+                    .files(findJavaFiles(m2))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(OutputKind.DIRECT);\n+\n+                List<Set<String>> expected = Arrays.asList(\n+                        variants(\"module-info.java:1:1: compiler.err.package.clash.from.requires: m2x, test, m1x, m3x\"),\n+                        variants(\"- compiler.note.proc.messager: test.Test found in module: m1x\"),\n+                        variants(\"- compiler.note.proc.messager: test found in module: m1x\"),\n+                        variants(\"- compiler.note.proc.messager: test.Test found in module: m1x\"),\n+                        variants(\"- compiler.note.proc.messager: test found in module: m1x\"),\n+                        variants(\"1 error\"));\n+\n+                assertErrorsWithVariants(expected, log);\n+            }\n+\n+            {\n+                List<String> log = new JavacTask(tb)\n+                    .options(\"--module-source-path\", moduleSrc.toString(),\n+                             \"-processorpath\", System.getProperty(\"test.class.path\"),\n+                             \"-processor\", UnboundLookupNew.class.getName(),\n+                             \"-AlookupClass=-test.Test\",\n+                             \"-AlookupPackage=-test\",\n+                             \"-XDrawDiagnostics\",\n+                             \"-XDshould-stop.at=FLOW\")\n+                    .outdir(classes)\n+                    .files(findJavaFiles(m2, m4))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(OutputKind.DIRECT);\n+\n+                List<String> expected = Arrays.asList(\n+                        \"module-info.java:1:1: compiler.err.package.clash.from.requires: m2x, test, m1x, m3x\",\n+                        \"- compiler.note.multiple.elements: getTypeElement, test.Test, m1x, m4x\",\n+                        \"- compiler.note.multiple.elements: getPackageElement, test, m1x, m4x\",\n+                        \"1 error\");\n+\n+                if (!expected.equals(log)) {\n+                    throw new AssertionError(\"Expected output not found: \" + log);\n+                }\n+            }\n+        }\n+\n+        {\n+            tb.cleanDirectory(classes);\n+            tb.cleanDirectory(moduleSrc);\n+\n+            tb.writeJavaFiles(m1,\n+                              \"module m1x { exports test; }\",\n+                              \"package test; public class Test { }\");\n+\n+            tb.writeJavaFiles(m2,\n+                              \"module m2x { requires m1x; }\");\n+\n+            tb.writeJavaFiles(src,\n+                              \"package test; public class Test { }\");\n+\n+            new JavacTask(tb)\n+                .options(\"--module-source-path\", moduleSrc.toString())\n+                .outdir(classes)\n+                .files(findJavaFiles(moduleSrc))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+            List<String> log = new JavacTask(tb)\n+                .options(\"--module-source-path\", moduleSrc.toString(),\n+                         \"--source-path\", src.toString(),\n+                         \"-processorpath\", System.getProperty(\"test.class.path\"),\n+                         \"-processor\", UnboundLookupNew.class.getName(),\n+                         \"-AlookupClass=+test.Test\",\n+                         \"-AlookupPackage=+test\",\n+                         \"-XDrawDiagnostics\")\n+                .outdir(classes)\n+                .files(findJavaFiles(m2))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+            List<String> expected = Arrays.asList(\n+                    \"- compiler.note.proc.messager: test.Test found in module: m1x\",\n+                    \"- compiler.note.proc.messager: test found in module: m1x\",\n+                    \"- compiler.note.proc.messager: test.Test found in module: m1x\",\n+                    \"- compiler.note.proc.messager: test found in module: m1x\"\n+            );\n+\n+            if (!expected.equals(log)) {\n+                throw new AssertionError(\"Expected output not found: \" + log);\n+            }\n+        }\n+\n+        {\n+            tb.cleanDirectory(classes);\n+            tb.cleanDirectory(moduleSrc);\n+\n+            tb.writeJavaFiles(m1,\n+                              \"module m1x { exports test; }\",\n+                              \"package test; public class Test { }\");\n+\n+            tb.writeJavaFiles(m2,\n+                              \"module m2x { requires m1x; }\");\n+\n+            tb.writeJavaFiles(src,\n+                              \"package test; public class Test { }\");\n+\n+            new JavacTask(tb)\n+                .options(\"--module-source-path\", moduleSrc.toString())\n+                .outdir(classes)\n+                .files(findJavaFiles(moduleSrc))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+            List<String> log = new JavacTask(tb)\n+                .options(\"--module-source-path\", moduleSrc.toString(),\n+                         \"--source-path\", src.toString(),\n+                         \"--add-reads=m2x=ALL-UNNAMED\",\n+                         \"-processorpath\", System.getProperty(\"test.class.path\"),\n+                         \"-processor\", UnboundLookupNew.class.getName(),\n+                         \"-AlookupClass=+test.Test\",\n+                         \"-AlookupPackage=+test\",\n+                         \"-XDrawDiagnostics\")\n+                .outdir(classes)\n+                .files(findJavaFiles(m2))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+            List<String> expected = Arrays.asList(\n+                    \"- compiler.note.proc.messager: test.Test found in module: m1x\",\n+                    \"- compiler.note.proc.messager: test found in module: m1x\",\n+                    \"- compiler.note.proc.messager: test.Test found in module: m1x\",\n+                    \"- compiler.note.proc.messager: test found in module: m1x\"\n+            );\n+\n+            if (!expected.equals(log)) {\n+                throw new AssertionError(\"Expected output not found: \" + log);\n+            }\n+        }\n+\n+        {\n+            tb.cleanDirectory(classes);\n+            tb.cleanDirectory(srcClasses);\n+            tb.cleanDirectory(moduleSrc);\n+\n+            tb.writeJavaFiles(m1,\n+                              \"module m1x { exports test; }\",\n+                              \"package test; public class Test { }\");\n+\n+            tb.writeJavaFiles(m2,\n+                              \"module m2x { requires m1x; }\");\n+\n+            tb.writeJavaFiles(src,\n+                              \"package test; public class Test { }\");\n+\n+            new JavacTask(tb)\n+                .options(\"--module-source-path\", moduleSrc.toString())\n+                .outdir(classes)\n+                .files(findJavaFiles(moduleSrc))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+            List<String> log = new JavacTask(tb)\n+                .options(\"--module-path\", classes.toString(),\n+                         \"--source-path\", src.toString(),\n+                         \"-processorpath\", System.getProperty(\"test.class.path\"),\n+                         \"-processor\", UnboundLookupNew.class.getName(),\n+                         \"-AlookupClass=+test.Test\",\n+                         \"-AlookupPackage=+test\",\n+                         \"--add-modules=m2x\",\n+                         \"-XDshould-stop.at=ATTR\",\n+                         \"-XDrawDiagnostics\")\n+                .outdir(srcClasses)\n+                .files(findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+            List<String> expected = Arrays.asList(\"Test.java:1:1: compiler.err.package.in.other.module: m1x\",\n+                                                  \"- compiler.note.proc.messager: test.Test found in module: unnamed module\",\n+                                                  \"- compiler.note.proc.messager: test found in module: m1x\",\n+                                                  \"- compiler.note.proc.messager: test.Test found in module: unnamed module\",\n+                                                  \"- compiler.note.proc.messager: test found in module: m1x\",\n+                                                  \"1 error\"\n+                                                 );\n+\n+            if (!expected.equals(log)) {\n+                throw new AssertionError(\"Expected output not found: \" + log);\n+            }\n+        }\n+    }\n+\n+    private Set<String> variants(String... expected) {\n+        return new HashSet<>(Arrays.asList(expected));\n+    }\n+\n+    private void assertErrorsWithVariants(List<Set<String>> expectedVariants, List<String> actual) {\n+        assertEquals(expectedVariants.size(), actual.size());\n+        Iterator<Set<String>> expIt = expectedVariants.iterator();\n+        Iterator<String> actIt = actual.iterator();\n+\n+        while (expIt.hasNext() && actIt.hasNext()) {\n+            Set<String> exp = expIt.next();\n+            String act = actIt.next();\n+\n+            if (!exp.contains(act)) {\n+                throw new AssertionError(\"Expected: \" + exp + \", actual: \" + act);\n+            }\n+        }\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    @SupportedOptions({\"lookupClass\", \"lookupPackage\"})\n+    public static final class UnboundLookupNew extends AbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            performLookup(\"lookupClass\", processingEnv.getElementUtils()::getTypeElement);\n+            performLookup(\"lookupPackage\", processingEnv.getElementUtils()::getPackageElement);\n+\n+            return false;\n+        }\n+\n+        private void performLookup(String optionName, Function<String, Element> name2Element) {\n+            String[] lookupList = processingEnv.getOptions().get(optionName).split(\",\");\n+            for (String lookup : lookupList) {\n+                boolean shouldExists = lookup.charAt(0) == '+';\n+                String name = lookup.substring(1);\n+                Element type = name2Element.apply(name);\n+\n+                if (shouldExists) {\n+                    if (type == null) {\n+                        throw new AssertionError(\"Did not find the expected type.\");\n+                    } else {\n+                        processingEnv.getMessager().printMessage(Kind.NOTE, name + \" found in module: \" + processingEnv.getElementUtils().getModuleOf(type));\n+                    }\n+                } else {\n+                    if (type != null) {\n+                        throw new AssertionError(\"Found the unexpected type.\");\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latest();\n+        }\n+\n+    }\n+\n@@ -1336,1 +1767,1 @@\n-        String log = new JavacTask(tb)\n+        new JavacTask(tb)\n@@ -1348,14 +1779,0 @@\n-        String moduleImplConflictString =\n-                \"- compiler.note.multiple.elements: getTypeElement, impl.conflict.module.Impl, m2x, m1x\";\n-        String srcConflictString =\n-                \"- compiler.note.multiple.elements: getTypeElement, impl.conflict.src.Impl, m1x, unnamed module\";\n-\n-        if (!log.contains(moduleImplConflictString) ||\n-            !log.contains(srcConflictString)) {\n-            throw new AssertionError(\"Expected output not found: \" + log);\n-        }\n-\n-        if (log.split(Pattern.quote(moduleImplConflictString)).length > 2) {\n-            throw new AssertionError(\"Too many warnings in: \" + log);\n-        }\n-\n@@ -1376,1 +1793,2 @@\n-                     \"-proc:only\")\n+                     \"-proc:only\",\n+                     \"-Aunnamedmodule\")\n@@ -1408,0 +1826,1 @@\n+    @SupportedOptions(\"unnamedmodule\")\n@@ -1425,2 +1844,2 @@\n-            assertTypeElementNotFound(\"impl.conflict.src.Impl\");\n-            assertPackageElementNotFound(\"impl.conflict.src\");\n+            assertTypeElementExists(\"impl.conflict.src.Impl\", processingEnv.getOptions().containsKey(\"unnamedmodule\") ? \"\" : \"m1x\");\n+            assertPackageElementExists(\"impl.conflict.src\", processingEnv.getOptions().containsKey(\"unnamedmodule\") ? \"\" : \"m1x\");\n","filename":"test\/langtools\/tools\/javac\/modules\/AnnotationProcessing.java","additions":442,"deletions":23,"binary":false,"changes":465,"status":"modified"}]}