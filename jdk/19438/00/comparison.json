{"files":[{"patch":"@@ -208,0 +208,2 @@\n+  JvmtiThreadState* _state;\n+\n@@ -209,1 +211,5 @@\n-  EnterInterpOnlyModeClosure() : HandshakeClosure(\"EnterInterpOnlyMode\"), _completed(false) { }\n+  EnterInterpOnlyModeClosure(JvmtiThreadState* state)\n+    : HandshakeClosure(\"EnterInterpOnlyMode\"),\n+      _completed(false),\n+      _state(state) { }\n+\n@@ -212,1 +218,1 @@\n-    JvmtiThreadState* state = jt->jvmti_thread_state();\n+    JvmtiThreadState* state = _state;\n@@ -372,1 +378,1 @@\n-  EnterInterpOnlyModeClosure hs;\n+  EnterInterpOnlyModeClosure hs(state);\n@@ -1104,1 +1110,1 @@\n-JvmtiEventController::enter_interp_only_mode() {\n+JvmtiEventController::enter_interp_only_mode(JvmtiThreadState* state) {\n@@ -1106,1 +1112,1 @@\n-  EnterInterpOnlyModeClosure hs;\n+  EnterInterpOnlyModeClosure hs(state);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-  static void enter_interp_only_mode();\n+  static void enter_interp_only_mode(JvmtiThreadState* state);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -553,0 +553,12 @@\n+void JvmtiVTMSTransitionDisabler::process_pending_interp_only(JavaThread* current) {\n+  JvmtiThreadState* state = current->jvmti_thread_state();\n+\n+  if (state != nullptr && state->is_pending_interp_only_mode()) {\n+    MutexLocker mu(JvmtiThreadState_lock);\n+    state = current->jvmti_thread_state();\n+    if (state != nullptr && state->is_pending_interp_only_mode()) {\n+      JvmtiEventController::enter_interp_only_mode(state);\n+    }\n+  }\n+}\n+\n@@ -642,8 +654,3 @@\n-  JvmtiThreadState* state = thread->jvmti_thread_state();\n-  if (state != nullptr && state->is_pending_interp_only_mode()) {\n-    MutexLocker mu(JvmtiThreadState_lock);\n-    state = thread->jvmti_thread_state();\n-    if (state != nullptr && state->is_pending_interp_only_mode()) {\n-      JvmtiEventController::enter_interp_only_mode();\n-    }\n-  }\n+  \/\/ enable interp_only_mode for virtual thread if it has pending bit\n+  process_pending_interp_only(thread);\n+\n@@ -666,0 +673,2 @@\n+  \/\/ enable interp_only_mode for carrier thread if it has pending bit\n+  process_pending_interp_only(thread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+  static void process_pending_interp_only(JavaThread* current);\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8311177\n+ * @requires vm.continuations\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:CarrierThreadEventNotification CarrierThreadEventNotification\n+ *\/\n+\n+import java.util.concurrent.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class CarrierThreadEventNotification {\n+    static final int VTHREAD_COUNT = 64;\n+    static volatile boolean stopRunning = false;\n+\n+    private static native void setSingleSteppingMode(boolean enable);\n+\n+    final Runnable FOO = () -> {\n+        while(!stopRunning) {\n+            recurse(10);\n+        }\n+    };\n+\n+    private void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth -1);\n+        } else {\n+            Thread.yield();\n+        }\n+    }\n+\n+    private void runTest() throws Exception {\n+        List<Thread> virtualThreads = new ArrayList<>();\n+        for (int i = 0; i < VTHREAD_COUNT; i++) {\n+            virtualThreads.add(Thread.ofVirtual().start(FOO));\n+        }\n+        for (int cnt = 0; cnt < 500; cnt++) {\n+            setSingleSteppingMode(true);\n+            Thread.sleep(10);\n+            setSingleSteppingMode(false);\n+        }\n+        stopRunning = true;\n+        for (Thread t : virtualThreads) {\n+            t.join();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        CarrierThreadEventNotification obj = new CarrierThreadEventNotification();\n+        obj.runTest();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/CarrierThreadEventNotification\/CarrierThreadEventNotification.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <jvmti.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti_common.hpp\"\n+\n+\n+extern \"C\" {\n+\n+\/\/ set by Agent_OnLoad\n+static jvmtiEnv* jvmti = nullptr;\n+\n+static jthread* tested_cthreads = nullptr;\n+static jint cthread_cnt = 0;\n+\n+static const char* CTHREAD_NAME_START = \"ForkJoinPool\";\n+static const int CTHREAD_NAME_START_LEN = (int)strlen(\"ForkJoinPool\");\n+\n+static jint\n+get_cthreads(JNIEnv* jni, jthread** cthreads_p) {\n+  jthread* tested_cthreads = NULL;\n+  jint all_cnt = 0;\n+  jint ct_cnt = 0;\n+\n+  jvmtiError err = jvmti->GetAllThreads(&all_cnt, &tested_cthreads);\n+  check_jvmti_status(jni, err, \"get_cthreads: error in JVMTI GetAllThreads\");\n+\n+  for (int idx = 0; idx < all_cnt; idx++) {\n+    jthread thread = tested_cthreads[idx];\n+    char* tname = get_thread_name(jvmti, jni, thread);\n+\n+    if (strncmp(tname, CTHREAD_NAME_START, CTHREAD_NAME_START_LEN) == 0) {\n+      tested_cthreads[ct_cnt++] = jni->NewGlobalRef(thread);\n+    }\n+    deallocate(jvmti, jni, (void*)tname);\n+  }\n+  *cthreads_p = tested_cthreads;\n+  return ct_cnt;\n+}\n+\n+static void JNICALL\n+SingleStep(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread,\n+           jmethodID method, jlocation location) {\n+  jboolean is_virtual = jni->IsVirtualThread(thread);\n+  if (is_virtual) {\n+    jni->FatalError(\"Virtual thread should not have posted single stepping event\");\n+  }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_CarrierThreadEventNotification_setSingleSteppingMode(JNIEnv* jni, jclass klass, jboolean enable) {\n+  if (enable) {\n+    if (cthread_cnt != 0 || tested_cthreads != nullptr) {\n+      jni->FatalError(\"Should not be set\");\n+    }\n+    cthread_cnt = get_cthreads(jni, &tested_cthreads);\n+    for (int i = 0; i < cthread_cnt; i++) {\n+      jthread thread = tested_cthreads[i];\n+      jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, thread);\n+      check_jvmti_status(jni, err, \"event handler: error in JVMTI SetEventNotificationMode for event JVMTI_EVENT_SINGLE_STEP\");\n+    }\n+  } else {\n+    if (tested_cthreads == nullptr) {\n+      jni->FatalError(\"Should be set\");\n+    }\n+    for (int i = 0; i < cthread_cnt; i++) {\n+      jthread thread = tested_cthreads[i];\n+      char* tname = get_thread_name(jvmti, jni, thread);\n+      jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, thread);\n+      check_jvmti_status(jni, err, \"event handler: error in JVMTI SetEventNotificationMode for event JVMTI_EVENT_SINGLE_STEP\");\n+      jni->DeleteGlobalRef(thread);\n+      deallocate(jvmti, jni, (void*)tname);\n+    }\n+    jvmtiError err = jvmti->Deallocate((unsigned char*)tested_cthreads);\n+    check_jvmti_status(jni, err, \"deallocate: error in JVMTI Deallocate call\");\n+    cthread_cnt = 0;\n+    tested_cthreads = nullptr;\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* jvm, char* options, void* reserved) {\n+  jvmtiEventCallbacks callbacks;\n+  jvmtiCapabilities caps;\n+  jvmtiError err;\n+\n+  printf(\"Agent_OnLoad: started\\n\");\n+  if (jvm->GetEnv((void **) (&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    LOG(\"error in GetEnv\");\n+    return JNI_ERR;\n+  }\n+\n+  memset(&caps, 0, sizeof(caps));\n+  caps.can_generate_single_step_events = 1;\n+  caps.can_support_virtual_threads = 1;\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"error in JVMTI AddCapabilities: %d\\n\", err);\n+  }\n+\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.SingleStep = &SingleStep;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(jvmtiEventCallbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent_OnLoad: Error in JVMTI SetEventCallbacks: %d\\n\", err);\n+  }\n+\n+  return 0;\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/CarrierThreadEventNotification\/libCarrierThreadEventNotification.cpp","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -200,6 +200,2 @@\n-  \/\/ Verify that we did not get a METHOD_EXIT events when enabled on the cthread.\n-  if (received_method_exit_event) {\n-    passed = JNI_FALSE;\n-    received_method_exit_event = JNI_FALSE;\n-    LOG(\"FAILED: got METHOD_EXIT event on the cthread: %p\\n\", cthread);\n-  }\n+  \/\/ need to reset this value after the breakpoint_hit1\n+  received_method_exit_event = JNI_FALSE;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/MethodExitTest\/libMethodExitTest.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"}]}