{"files":[{"patch":"@@ -215,0 +215,5 @@\n+        @Override\n+        public void onTimeout() {\n+            \/\/ do nothing, this joiner does not throw TimeoutException\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Joiners.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.function.Function;\n@@ -31,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -54,3 +54,3 @@\n- * the {@code join} method may only be invoked once, and the {@code close} method throws\n- * an exception after closing if the owner did not invoke the {@code join} method after\n- * forking subtasks.\n+ * the {@code join} method may only be invoked once to get the outcome, and the\n+ * {@code close} method throws an exception after closing if the owner did not invoke the\n+ * {@code join} method after forking subtasks.\n@@ -201,1 +201,0 @@\n- *\n@@ -203,2 +202,3 @@\n- * that consists of a {@link ThreadFactory} to create threads, an optional name for\n- * monitoring and management purposes, and an optional timeout.\n+ * that consists of a {@link ThreadFactory} to create threads, an optional name for the\n+ * scope, and an optional timeout. The name is intended for monitoring and management\n+ * purposes.\n@@ -208,10 +208,9 @@\n- * configuration has a {@code ThreadFactory} that creates unnamed\n- * <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">virtual threads<\/a>,\n- * is unnamed for monitoring and management purposes, and has no timeout.\n- *\n- * <p> The 2-arg {@link #open(Joiner, Function) open} method can be used to create a\n- * {@code StructuredTaskScope} that uses a different {@code ThreadFactory}, has a name for\n- * the purposes of monitoring and management, or has a timeout that cancels the scope if\n- * the timeout expires before or while waiting for subtasks to complete. The {@code open}\n- * method is called with a {@linkplain Function function} that is applied to the default\n- * configuration and returns a {@link Configuration Configuration} for the\n+ * configuration has a {@code ThreadFactory} that creates unnamed {@linkplain\n+ * Thread##virtual-threads virtual threads}, does not name the scope, and has no timeout.\n+ *\n+ * <p> The 2-arg {@link #open(Joiner, UnaryOperator) open} method can be used to create a\n+ * {@code StructuredTaskScope} that uses a different {@code ThreadFactory}, is named for\n+ * monitoring and management purposes, or has a timeout that cancels the scope if the\n+ * timeout expires before or while waiting for subtasks to complete. The {@code open}\n+ * method is called with a {@linkplain UnaryOperator operator} that is applied to the\n+ * default configuration and returns a {@link Configuration Configuration} for the\n@@ -240,3 +239,3 @@\n- * method has completed then the scope is <a href=\"#Cancallation\">cancelled<\/a>. This\n- * interrupts the threads executing the two subtasks and causes the {@link #join() join}\n- * method to throw {@link TimeoutException}.\n+ * method has completed then the scope is {@linkplain ##Cancallation cancelled} (this\n+ * interrupts the threads executing the two subtasks), and the {@code join} method\n+ * throws {@link TimeoutException TimeoutException}.\n@@ -317,5 +316,4 @@\n- * <p> A scoped value inherited into a subtask may be\n- * <a href=\"{@docRoot}\/java.base\/java\/lang\/ScopedValue.html#rebind\">rebound<\/a> to a new\n- * value in the subtask for the bounded execution of some method executed in the subtask.\n- * When the method completes, the value of the {@code ScopedValue} reverts to its previous\n- * value, the value inherited from the thread executing the task.\n+ * <p> A scoped value inherited into a subtask may be {@linkplain ScopedValue##rebind\n+ * rebound} to a new value in the subtask for the bounded execution of some method executed\n+ * in the subtask. When the method completes, the value of the {@code ScopedValue} reverts\n+ * to its previous value, the value inherited from the thread executing the task.\n@@ -334,4 +332,3 @@\n- * <p> Actions in the owner thread of a {@code StructuredTaskScope} prior to\n- * {@linkplain #fork forking} of a subtask\n- * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\">\n- * <i>happen-before<\/i><\/a> any actions taken by that subtask, which in turn\n+ * <p> Actions in the owner thread of a {@code StructuredTaskScope} prior to {@linkplain\n+ * #fork forking} of a subtask {@linkplain java.util.concurrent##MemoryVisibility\n+ * <i>happen-before<\/i>} any actions taken by that subtask, which in turn\n@@ -408,1 +405,1 @@\n-         * result of a successful subtask only after it has {@linkplain #join() joined}.\n+         * result of a successful subtask after it has {@linkplain #join() joined}.\n@@ -414,0 +411,4 @@\n+         * <p> This method may be invoked by any thread after the scope owner has joined.\n+         * The only case where this method can be used to get the result before the scope\n+         * owner has joined is when called from the {@code onComplete(Subtask)} method.\n+         *\n@@ -415,3 +416,3 @@\n-         * @throws IllegalStateException if the subtask has not completed, did not complete\n-         * successfully, or the current thread is the scope owner invoking this\n-         * method before {@linkplain #join() joining}\n+         * @throws IllegalStateException if the subtask has not completed or did not\n+         * complete successfully, or this method if invoked outside the context of the\n+         * {@code onComplete(Subtask)} method before the owner thread has joined\n@@ -430,1 +431,1 @@\n-         * exception thrown by a failed subtask only after it has {@linkplain #join() joined}.\n+         * exception thrown by a failed subtask after it has {@linkplain #join() joined}.\n@@ -436,3 +437,7 @@\n-         * @throws IllegalStateException if the subtask has not completed, completed with\n-         * a result, or the current thread is the scope owner invoking this method\n-         * before {@linkplain #join() joining}\n+         * <p> This method may be invoked by any thread after the scope owner has joined.\n+         * The only case where this method can be used to get the exception before the scope\n+         * owner has joined is when called from the {@code onComplete(Subtask)} method.\n+         *\n+         * @throws IllegalStateException if the subtask has not completed or completed\n+         * with a result, or this method if invoked outside the context of the {@code\n+         * onComplete(Subtask)} method before the owner thread has joined\n@@ -462,1 +467,1 @@\n-     *   subtasks. It does not cancel the scope or cause {@code join} to throw.\n+     *   subtasks to complete. It does not cancel the scope or cause {@code join} to throw.\n@@ -475,1 +480,1 @@\n-     * result or exception. These methods return a {@code boolean} to indicate if scope\n+     * result or exception. These methods return a {@code boolean} to indicate if the scope\n@@ -481,0 +486,10 @@\n+     * <p> If a {@code StructuredTaskScope} is opened with a {@linkplain\n+     * Configuration#withTimeout(Duration) timeout}, and the timeout expires before or\n+     * while waiting in {@link StructuredTaskScope#join() join()}, then the scope is\n+     * {@linkplain StructuredTaskScope##Cancallation cancelled}, and the {@code Joiners}'s\n+     * {@link #onTimeout()} method is invoked to notify the {@code Joiner} and optionally\n+     * throw {@link TimeoutException TimeoutException}. If the {@code onTimeout()} method\n+     * does not throw then the {@code join()} method will invoke the {@link #result()}\n+     * method to produce a result. This result may be based on the outcome of subtasks\n+     * that completed before the timeout expired.\n+     *\n@@ -486,1 +501,2 @@\n-     * threads concurrently.\n+     * threads concurrently. The {@link #onTimeout()} method may be invoked at around\n+     * the same time that subtasks complete.\n@@ -490,1 +506,1 @@\n-     * different scopes or re-used after a task is closed.\n+     * different scopes or re-used after a scope is closed.\n@@ -505,1 +521,0 @@\n-    @FunctionalInterface\n@@ -509,3 +524,2 @@\n-         * fork(Runnable)} when forking a subtask. The method is invoked from the task\n-         * owner thread. The method is invoked before a thread is created to run the\n-         * subtask.\n+         * fork(Runnable)} when forking a subtask. The method is invoked before a thread\n+         * is created to run the subtask.\n@@ -554,0 +568,21 @@\n+        \/**\n+         * Invoked by the {@link #join() join()} method if the scope was opened with a\n+         * timeout, and the timeout expires before or while waiting in the {@code join}\n+         * method.\n+         *\n+         * @implSpec The default implementation throws {@link TimeoutException TimeoutException}.\n+         *\n+         * @apiNote This method is intended for {@code Joiner} implementations that do not\n+         * throw {@link TimeoutException TimeoutException}, or require a notification when\n+         * the timeout expires before or while waiting in {@code join}.\n+         *\n+         * <p> This method is invoked by the {@code join} method. It should not be\n+         * invoked directly.\n+         *\n+         * @throws TimeoutException for {@code join} to throw\n+         * @since 26\n+         *\/\n+        default void onTimeout() {\n+            throw new TimeoutException();\n+        }\n+\n@@ -578,1 +613,1 @@\n-         * The {@code Joiner} <a href=\"StructuredTaskScope.html#Cancallation\">cancels<\/a>\n+         * The {@code Joiner} {@linkplain StructuredTaskScope##Cancallation cancels}\n@@ -581,4 +616,6 @@\n-         * <p> If all subtasks complete successfully, the joiner's {@link Joiner#result()}\n-         * method returns a stream of all subtasks in the order that they were forked.\n-         * If any subtask failed then the {@code result} method throws the exception from\n-         * the first subtask to fail.\n+         * <p> If all subtasks complete successfully then the joiner's {@link\n+         * Joiner#result()} method returns a stream of all subtasks, in the order that they\n+         * were forked, for the {@link StructuredTaskScope#join() join()} to return. If\n+         * the scope was opened with a {@linkplain Configuration#withTimeout(Duration)\n+         * timeout}, and the timeout expires before or while waiting for all subtasks to\n+         * complete, then the {@code join} method throws {@code TimeoutException}.\n@@ -602,4 +639,8 @@\n-         * <p> The joiner's {@link Joiner#result()} method returns the result of a subtask\n-         * that completed successfully. If all subtasks fail then the {@code result} method\n-         * throws the exception from one of the failed subtasks. The {@code result} method\n-         * throws {@code NoSuchElementException} if no subtasks were forked.\n+         * <p> The joiner's {@link Joiner#result()} method returns the result of a subtask,\n+         * that completed successfully, for the {@link StructuredTaskScope#join() join()}\n+         * to return. If all subtasks fail then the {@code result} method throws the\n+         * exception from one of the failed subtasks. The {@code result} method throws\n+         * {@code NoSuchElementException} if no subtasks were forked. If the scope was\n+         * opened with a {@linkplain Configuration#withTimeout(Duration) timeout}, and\n+         * the timeout expires before or while waiting for any subtask to complete\n+         * successfully, then the {@code join} method throws {@code TimeoutException}.\n@@ -615,1 +656,1 @@\n-         * The {@code Joiner} <a href=\"StructuredTaskScope.html#Cancallation\">cancels<\/a>\n+         * The {@code Joiner} {@linkplain StructuredTaskScope##Cancallation cancels}\n@@ -620,1 +661,4 @@\n-         * subtask to fail.\n+         * subtask to fail. If the scope was opened with a {@linkplain\n+         * Configuration#withTimeout(Duration) timeout}, and the timeout expires before or\n+         * while waiting for all subtasks to complete, then the {@code join} method throws\n+         * {@code TimeoutException}.\n@@ -637,0 +681,3 @@\n+         * If the scope was opened with a {@linkplain Configuration#withTimeout(Duration)\n+         * timeout}, and the timeout expires before or while waiting for all subtasks to\n+         * complete, then the {@code join} method throws {@code TimeoutException}.\n@@ -674,5 +721,5 @@\n-         * <p> The joiner's {@link Joiner#onComplete(Subtask)} method invokes the\n-         * predicate's {@link Predicate#test(Object) test} method with the subtask that\n-         * completed successfully or failed with an exception. If the {@code test} method\n-         * returns {@code true} then <a href=\"StructuredTaskScope.html#Cancallation\">\n-         * the scope is cancelled<\/a>. The {@code test} method must be thread safe as it\n+         * <p> The joiner's {@link #onComplete(Subtask)} method invokes the predicate's\n+         * {@link Predicate#test(Object) test} method with the subtask that completed\n+         * successfully or failed with an exception. If the {@code test} method\n+         * returns {@code true} then {@linkplain StructuredTaskScope##Cancallation\n+         * the scope is cancelled}. The {@code test} method must be thread safe as it\n@@ -690,0 +737,7 @@\n+         * <p> The joiner's {@link #onTimeout()} method does nothing. If configured with\n+         * a {@linkplain Configuration#withTimeout(Duration) timeout}, and the timeout\n+         * expires before or while waiting in {@link StructuredTaskScope#join() join},\n+         * then the {@link #result()} method returns the stream of all subtasks.\n+         * Subtasks that did not complete before the timeout expired will be in the\n+         * {@link Subtask.State#UNAVAILABLE UNAVAILABLE} state.\n+         *\n@@ -691,2 +745,2 @@\n-         * <a href=\"StructuredTaskScope.html#Cancallation\">cancels<\/a> the scope when\n-         * two or more subtasks fail.\n+         * {@linkplain StructuredTaskScope##Cancallation cancels} the scope when two or\n+         * more subtasks fail.\n@@ -718,0 +772,14 @@\n+         * <p> The following example uses {@code allUntil} to get the results of all\n+         * subtasks that complete successfully within a timeout period.\n+         * {@snippet lang=java :\n+         *    <T> List<T> invokeAll(Collection<Callable<T>> tasks, Duration timeout) throws InterruptedException {\n+         *    try (var scope = StructuredTaskScope.open(Joiner.<T>allUntil(_ -> false), cf -> cf.withTimeout(timeout))) {\n+         *        tasks.forEach(scope::fork);\n+         *        return scope.join()\n+         *                 .filter(s -> s.state() == Subtask.State.SUCCESS)\n+         *                 .map(Subtask::get)\n+         *                 .toList();\n+         *         }\n+         *     }\n+         * }\n+         *\n@@ -730,8 +798,2 @@\n-     * ThreadFactory} to create threads, an optional name for the purposes of monitoring\n-     * and management, and an optional timeout.\n-     *\n-     * <p> Creating a {@code StructuredTaskScope} with {@link #open()} or {@link #open(Joiner)}\n-     * uses the <a href=\"StructuredTaskScope.html#DefaultConfiguration\">default\n-     * configuration<\/a>. The default configuration consists of a thread factory that\n-     * creates unnamed <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">\n-     * virtual threads<\/a>, no name for monitoring and management purposes, and no timeout.\n+     * ThreadFactory} to create threads, an optional name for the scope, and an optional\n+     * timeout. The name is intended for monitoring and management purposes.\n@@ -739,2 +801,2 @@\n-     * <p> Creating a {@code StructuredTaskScope} with its 2-arg {@link #open(Joiner, Function)\n-     * open} method allows a different configuration to be used. The function specified\n+     * <p> Creating a {@code StructuredTaskScope} with its 2-arg {@link #open(Joiner, UnaryOperator)\n+     * open} method allows a different configuration to be used. The operator specified\n@@ -742,1 +804,1 @@\n-     * configuration for the {@code StructuredTaskScope} under construction. The function\n+     * configuration for the {@code StructuredTaskScope} under construction. The operator\n@@ -759,4 +821,4 @@\n-         * @apiNote The thread factory will typically create\n-         * <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">virtual threads<\/a>,\n-         * maybe with names for monitoring purposes, an {@linkplain Thread.UncaughtExceptionHandler\n-         * uncaught exception handler}, or other properties configured.\n+         * @apiNote The thread factory will typically create {@linkplain Thread##virtual-threads\n+         * virtual threads}, maybe with names for monitoring purposes, an {@linkplain\n+         * Thread.UncaughtExceptionHandler uncaught exception handler}, or other properties\n+         * configured.\n@@ -769,1 +831,1 @@\n-         * {@return a new {@code Configuration} object with the given name}\n+         * {@return a new {@code Configuration} object with the given scope name}\n@@ -786,0 +848,1 @@\n+         * @see Joiner#onTimeout()\n@@ -812,2 +875,3 @@\n-     * Exception thrown by {@link #join()} if the scope was created with a timeout and\n-     * the timeout expired before or while waiting in {@code join}.\n+     * Exception thrown by {@link #join()} if the scope was opened with a timeout,\n+     * the timeout expired before or while waiting in {@code join}, and the {@link\n+     * Joiner#onTimeout() Joiner.onTimeout} method throws this exception.\n@@ -817,0 +881,1 @@\n+     * @see Joiner#onTimeout()\n@@ -831,2 +896,2 @@\n-     * with configuration that is the result of applying the given function to the\n-     * <a href=\"#DefaultConfiguration\">default configuration<\/a>.\n+     * with configuration that is the result of applying the given operator to the\n+     * {@linkplain ##DefaultConfiguration default configuration}.\n@@ -834,2 +899,2 @@\n-     * <p> The {@code configFunction} is called with the default configuration and returns\n-     * the configuration for the new scope. The function may, for example, set the\n+     * <p> The {@code configOperator} is called with the default configuration and returns\n+     * the configuration for the new scope. The operator may, for example, set the\n@@ -837,2 +902,2 @@\n-     * {@linkplain Configuration#withTimeout(Duration) timeout}. If the function completes\n-     * with an exception or error then it is propagated by this method. If the function\n+     * {@linkplain Configuration#withTimeout(Duration) timeout}. If the operator completes\n+     * with an exception or error then it is propagated by this method. If the operator\n@@ -848,2 +913,3 @@\n-     * {@linkplain #join() joined} then the scope is <a href=\"#Cancallation\">cancelled<\/a>\n-     * and the {@code join} method throws {@link TimeoutException}.\n+     * {@linkplain #join() joined} then the scope is {@linkplain ##Cancallation cancelled}\n+     * and the {@code Joiner}'s {@link Joiner#onTimeout()} method is invoked to throw\n+     * optionally throw {@link TimeoutException TimeoutException}.\n@@ -859,1 +925,1 @@\n-     * @param configFunction a function to produce the configuration\n+     * @param configOperator the operator to produce the configuration\n@@ -863,1 +929,1 @@\n-     * @since 25\n+     * @since 26\n@@ -866,2 +932,2 @@\n-                                                 Function<Configuration, Configuration> configFunction) {\n-        return StructuredTaskScopeImpl.open(joiner, configFunction);\n+                                                 UnaryOperator<Configuration> configOperator) {\n+        return StructuredTaskScopeImpl.open(joiner, configOperator);\n@@ -872,1 +938,1 @@\n-     * scope is created with the <a href=\"#DefaultConfiguration\">default configuration<\/a>.\n+     * scope is created with the {@linkplain ##DefaultConfiguration default configuration}.\n@@ -874,2 +940,2 @@\n-     * <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">virtual threads<\/a>,\n-     * is unnamed for monitoring and management purposes, and has no timeout.\n+     * {@linkplain Thread##irtual-threads virtual threads}, does not name the scope, and\n+     * has no timeout.\n@@ -879,1 +945,1 @@\n-     * joiner and the {@linkplain Function#identity() identity function}.\n+     * joiner and the {@linkplain UnaryOperator#identity() identity operator}.\n@@ -888,1 +954,1 @@\n-        return open(joiner, Function.identity());\n+        return open(joiner, UnaryOperator.identity());\n@@ -900,4 +966,4 @@\n-     * <p> The scope is created with the <a href=\"#DefaultConfiguration\">default\n-     * configuration<\/a>. The default configuration has a {@code ThreadFactory} that creates\n-     * unnamed <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">virtual\n-     * threads<\/a>, is unnamed for monitoring and management purposes, and has no timeout.\n+     * <p> The scope is created with the {@linkplain ##DefaultConfiguration default\n+     * configuration}. The default configuration has a {@code ThreadFactory} that creates\n+     * unnamed {@linkplain Thread##virtual-threads virtual threads}, does not name the\n+     * scope, and has no timeout.\n@@ -908,1 +974,1 @@\n-     * and the {@linkplain Function#identity() identity function}.\n+     * and the {@linkplain UnaryOperator#identity() identity operator}.\n@@ -915,1 +981,1 @@\n-        return open(Joiner.awaitAllSuccessfulOrThrow(), Function.identity());\n+        return open(Joiner.awaitAllSuccessfulOrThrow(), UnaryOperator.identity());\n@@ -929,1 +995,1 @@\n-     * <a href=\"#Cancallation\">cancelled<\/a>, or {@code onFork} returns {@code true} to\n+     * {@linkplain ##Cancallation cancelled}, or {@code onFork} returns {@code true} to\n@@ -996,1 +1062,1 @@\n-     * the scope to be <a href=\"#Cancallation\">cancelled<\/a>.\n+     * the scope to be {@linkplain ##Cancallation cancelled}.\n@@ -999,6 +1065,13 @@\n-     * scope to be cancelled. If a {@linkplain Configuration#withTimeout(Duration) timeout}\n-     * is configured and the timeout expires before or while waiting, then the scope is\n-     * cancelled and {@link TimeoutException TimeoutException} is thrown. Once finished\n-     * waiting, the {@code Joiner}'s {@link Joiner#result() result()} method is invoked\n-     * to get the result or throw an exception. If the {@code result()} method throws\n-     * then this method throws {@code FailedException} with the exception as the cause.\n+     * scope to be cancelled. Once finished waiting, the {@code Joiner}'s {@link\n+     * Joiner#result() result()} method is invoked to get the result or throw an exception.\n+     * If the {@code result()} method throws then {@code join()} throws\n+     * {@code FailedException} with the exception from the {@code Joiner} as the cause.\n+     *\n+     * <p> If a {@linkplain Configuration#withTimeout(Duration) timeout} is configured,\n+     * and the timeout expires before or while waiting, then the scope is cancelled and\n+     * the {@code Joiner}'s {@link Joiner#onTimeout() onTimeout()} method is invoked\n+     * before calling the {@code Joiner}'s {@code result()} method. If the {@code onTimeout()}\n+     * method throws {@link TimeoutException TimeoutException} (or throws any exception\n+     * or error), then it is propagated by this method. If the {@code onTimeout()} method\n+     * does not throw then the {@code Joiner}'s {@code result()} method is invoked to\n+     * get the result or throw.\n@@ -1006,1 +1079,4 @@\n-     * <p> This method may only be invoked by the scope owner, and only once.\n+     * <p> This method may only be invoked by the scope owner. Once the result or\n+     * exception outcome is obtained, this method may not be invoked again. The only\n+     * case where the method may be called again is where {@code InterruptedException}\n+     * is thrown while waiting.\n@@ -1013,2 +1089,2 @@\n-     * @throws TimeoutException if a timeout is set and the timeout expires before or\n-     * while waiting\n+     * @throws TimeoutException if a timeout is set, the timeout expires before or while\n+     * waiting, and {@link Joiner#onTimeout() Joiner.onTimeout()} throws this exception\n@@ -1021,1 +1097,1 @@\n-     * {@return {@code true} if this scope is <a href=\"#Cancallation\">cancelled<\/a> or in\n+     * {@return {@code true} if this scope is {@linkplain ##Cancallation cancelled} or in\n@@ -1041,1 +1117,1 @@\n-     * <p> This method first <a href=\"#Cancallation\">cancels<\/a> the scope, if not\n+     * <p> This method first {@linkplain ##Cancallation cancels} the scope, if not\n@@ -1072,1 +1148,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":194,"deletions":118,"binary":false,"changes":312,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.util.function.Function;\n+import java.util.function.UnaryOperator;\n@@ -34,0 +34,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -46,3 +47,2 @@\n-    \/\/ state, only accessed by owner thread\n-    private static final int ST_NEW            = 0,\n-                             ST_FORKED         = 1,   \/\/ subtasks forked, need to join\n+    \/\/ scope state, set by owner thread, read by any thread\n+    private static final int ST_FORKED         = 1,   \/\/ subtasks forked, need to join\n@@ -52,4 +52,1 @@\n-    private int state;\n-\n-    \/\/ timer task, only accessed by owner thread\n-    private Future<?> timerTask;\n+    private volatile int state;\n@@ -60,0 +57,3 @@\n+    \/\/ timer task, only accessed by owner thread\n+    private Future<?> timerTask;\n+\n@@ -70,1 +70,0 @@\n-        this.state = ST_NEW;\n@@ -79,1 +78,1 @@\n-                                                 Function<Configuration, Configuration> configFunction) {\n+                                                 UnaryOperator<Configuration> configOperator) {\n@@ -82,1 +81,1 @@\n-        var config = (ConfigImpl) configFunction.apply(ConfigImpl.defaultConfig());\n+        var config = (ConfigImpl) configOperator.apply(ConfigImpl.defaultConfig());\n@@ -112,1 +111,1 @@\n-     * Throws IllegalStateException if already joined or scope is closed.\n+     * Returns true if join has been invoked and there is an outcome.\n@@ -114,15 +113,2 @@\n-    private void ensureNotJoined() {\n-        assert Thread.currentThread() == flock.owner();\n-        if (state > ST_FORKED) {\n-            throw new IllegalStateException(\"Already joined or scope is closed\");\n-        }\n-    }\n-\n-    \/**\n-     * Throws IllegalStateException if invoked by the owner thread and the owner thread\n-     * has not joined.\n-     *\/\n-    private void ensureJoinedIfOwner() {\n-        if (Thread.currentThread() == flock.owner() && state <= ST_JOIN_STARTED) {\n-            throw new IllegalStateException(\"join not called\");\n-        }\n+    private boolean isJoinCompleted() {\n+        return state >= ST_JOIN_COMPLETED;\n@@ -198,1 +184,4 @@\n-        ensureNotJoined();\n+        int s = state;\n+        if (s > ST_FORKED) {\n+            throw new IllegalStateException(\"join already called or scope is closed\");\n+        }\n@@ -215,0 +204,1 @@\n+            subtask.setThread(thread);\n@@ -224,1 +214,3 @@\n-        state = ST_FORKED;\n+        if (s < ST_FORKED) {\n+            state = ST_FORKED;\n+        }\n@@ -237,4 +229,3 @@\n-        ensureNotJoined();\n-\n-        \/\/ join started\n-        state = ST_JOIN_STARTED;\n+        if (state >= ST_JOIN_COMPLETED) {\n+            throw new IllegalStateException(\"Already joined or scope is closed\");\n+        }\n@@ -243,5 +234,5 @@\n-        flock.awaitAll();\n-\n-        \/\/ throw if timeout expired\n-        if (timeoutExpired) {\n-            throw new TimeoutException();\n+        try {\n+            flock.awaitAll();\n+        } catch (InterruptedException e) {\n+            state = ST_JOIN_STARTED;  \/\/ joining not completed, prevent new forks\n+            throw e;\n@@ -249,1 +240,0 @@\n-        cancelTimeout();\n@@ -251,1 +241,1 @@\n-        \/\/ all subtasks completed or cancelled\n+        \/\/ all subtasks completed or scope cancelled\n@@ -254,0 +244,8 @@\n+        \/\/ invoke joiner onTimeout if timeout expired\n+        if (timeoutExpired) {\n+            cancel();  \/\/ ensure cancelled before calling onTimeout\n+            joiner.onTimeout();\n+        } else {\n+            cancelTimeout();\n+        }\n+\n@@ -314,0 +312,1 @@\n+        @Stable private Thread thread;\n@@ -320,0 +319,18 @@\n+        \/**\n+         * Sets the thread for this subtask.\n+         *\/\n+        void setThread(Thread thread) {\n+            assert thread.getState() == Thread.State.NEW;\n+            this.thread = thread;\n+        }\n+\n+        \/**\n+         * Throws IllegalStateException if the caller thread is not the subtask and\n+         * the scope owner has not joined.\n+         *\/\n+        private void ensureJoinedIfNotSubtask() {\n+            if (Thread.currentThread() != thread && !scope.isJoinCompleted()) {\n+                throw new IllegalStateException();\n+            }\n+        }\n+\n@@ -322,0 +339,4 @@\n+            if (Thread.currentThread() != thread) {\n+                throw new WrongThreadException();\n+            }\n+\n@@ -358,1 +379,1 @@\n-            scope.ensureJoinedIfOwner();\n+            ensureJoinedIfNotSubtask();\n@@ -373,1 +394,1 @@\n-            scope.ensureJoinedIfOwner();\n+            ensureJoinedIfNotSubtask();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScopeImpl.java","additions":63,"deletions":42,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        @JEP(number=505, title=\"Structured Concurrency\", status=\"Fifth Preview\")\n+        @JEP(number=525, title=\"Structured Concurrency\", status=\"Sixth Preview\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-import java.util.function.Function;\n@@ -66,0 +65,1 @@\n+import java.util.function.UnaryOperator;\n@@ -212,1 +212,1 @@\n-    void testForkAfterJoin1(ThreadFactory factory) throws Exception {\n+    void testForkAfterJoinCompleted1(ThreadFactory factory) throws Exception {\n@@ -225,1 +225,1 @@\n-    void testForkAfterJoin2(ThreadFactory factory) throws Exception {\n+    void testForkAfterJoinCompleted2(ThreadFactory factory) throws Exception {\n@@ -235,1 +235,1 @@\n-     * Test fork after join throws.\n+     * Test fork after join interrupted.\n@@ -239,1 +239,1 @@\n-    void testForkAfterJoinThrows(ThreadFactory factory) throws Exception {\n+    void testForkAfterJoinInterrupted(ThreadFactory factory) throws Exception {\n@@ -242,1 +242,0 @@\n-            var latch = new CountDownLatch(1);\n@@ -244,1 +243,1 @@\n-                latch.await();\n+                Thread.sleep(Duration.ofDays(1));\n@@ -257,0 +256,19 @@\n+    \/**\n+     * Test fork after join timeout.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkAfterJoinTimeout(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory)\n+                        .withTimeout(Duration.ofMillis(100)))) {\n+            awaitCancelled(scope);\n+\n+            \/\/ join throws\n+            assertThrows(TimeoutException.class, scope::join);\n+\n+            \/\/ fork should throw\n+            assertThrows(IllegalStateException.class, () -> scope.fork(() -> \"bar\"));\n+        }\n+    }\n+\n@@ -299,3 +317,5 @@\n-    @Test\n-    void testForkAfterClose() {\n-        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkAfterClose(ThreadFactory factory) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -385,1 +405,28 @@\n-    void testJoinAfterJoin3() throws Exception {\n+    void testJoinAfterJoinInterrupted() throws Exception {\n+        try (var scope = StructuredTaskScope.open()) {\n+            var latch = new CountDownLatch(1);\n+            var subtask = scope.fork(() -> {\n+                latch.await();\n+                return \"foo\";\n+            });\n+\n+            \/\/ join throws InterruptedException\n+            Thread.currentThread().interrupt();\n+            assertThrows(InterruptedException.class, scope::join);\n+\n+            latch.countDown();\n+\n+            \/\/ retry join to get result\n+            scope.join();\n+            assertEquals(\"foo\", subtask.get());\n+\n+            \/\/ retry after otbaining result\n+            assertThrows(IllegalStateException.class, scope::join);\n+        }\n+    }\n+\n+    \/**\n+     * Test join after join completed with a timeout.\n+     *\/\n+    @Test\n+    void testJoinAfterJoinTimeout() throws Exception {\n@@ -399,0 +446,29 @@\n+    \/**\n+     * Test join invoked from Joiner.onTimeout.\n+     *\/\n+    @Test\n+    void testJoinInOnTimeout() throws Exception {\n+        Thread owner = Thread.currentThread();\n+        var scopeRef = new AtomicReference<StructuredTaskScope<?, ?>>();\n+\n+        var joiner = new Joiner<String, Void>() {\n+            @Override\n+            public void onTimeout() {\n+                assertTrue(Thread.currentThread() == owner);\n+                var scope = scopeRef.get();\n+                assertThrows(IllegalStateException.class, scope::join);\n+            }\n+            @Override\n+            public Void result() {\n+                return null;\n+            }\n+        };\n+\n+        try (var scope = StructuredTaskScope.open(joiner,\n+                cf -> cf.withTimeout(Duration.ofMillis(100)))) {\n+            awaitCancelled(scope);\n+            scopeRef.set(scope);\n+            scope.join();  \/\/ invokes onTimeout\n+        }\n+    }\n+\n@@ -437,1 +513,1 @@\n-                Thread.sleep(60_000);\n+                Thread.sleep(Duration.ofDays(1));\n@@ -460,2 +536,0 @@\n-\n-            var latch = new CountDownLatch(1);\n@@ -463,1 +537,1 @@\n-                Thread.sleep(60_000);\n+                Thread.sleep(Duration.ofDays(1));\n@@ -968,0 +1042,60 @@\n+    \/**\n+     * Test Joiner.onTimeout invoked by owner thread when timeout expires.\n+     *\/\n+    @Test\n+    void testOnTimeoutInvoked() throws Exception {\n+        var scopeRef = new AtomicReference<StructuredTaskScope<?, ?>>();\n+        Thread owner = Thread.currentThread();\n+        var invokeCount = new AtomicInteger();\n+        var joiner = new Joiner<String, Void>() {\n+            @Override\n+            public void onTimeout() {\n+                assertTrue(Thread.currentThread() == owner);\n+                assertTrue(scopeRef.get().isCancelled());\n+                invokeCount.incrementAndGet();\n+            }\n+            @Override\n+            public Void result() {\n+                return null;\n+            }\n+        };\n+        try (var scope = StructuredTaskScope.open(joiner,\n+                cf -> cf.withTimeout(Duration.ofMillis(100)))) {\n+            scopeRef.set(scope);\n+            scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+            scope.join();\n+            assertEquals(1, invokeCount.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test Joiner.onTimeout throwing an excepiton.\n+     *\/\n+    @Test\n+    void testOnTimeoutThrows() throws Exception {\n+        var joiner = new Joiner<String, Void>() {\n+            @Override\n+            public void onTimeout() {\n+                throw new FooException();\n+            }\n+            @Override\n+            public Void result() {\n+                return null;\n+            }\n+        };\n+        try (var scope = StructuredTaskScope.open(joiner,\n+                cf -> cf.withTimeout(Duration.ofMillis(100)))) {\n+            \/\/ wait for scope to be cancelled by timeout\n+            awaitCancelled(scope);\n+\n+            \/\/ join should throw FooException on first usage\n+            assertThrows(FooException.class, scope::join);\n+\n+            \/\/ retry after onTimeout fails\n+            assertThrows(IllegalStateException.class, scope::join);\n+        }\n+    }\n+\n@@ -993,1 +1127,0 @@\n-\n@@ -996,1 +1129,1 @@\n-            \/\/ before join\n+            \/\/ before join, owner thread\n@@ -1000,0 +1133,4 @@\n+            \/\/ before join, another thread\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::get));\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::exception));\n+\n@@ -1002,1 +1139,0 @@\n-            \/\/ after join\n@@ -1004,0 +1140,2 @@\n+\n+            \/\/ after join, owner thread\n@@ -1006,0 +1144,4 @@\n+\n+            \/\/ after join, another thread\n+            assertEquals(\"foo\", callInOtherThread(subtask::get));\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::exception));\n@@ -1020,1 +1162,1 @@\n-            \/\/ before join\n+            \/\/ before join, owner thread\n@@ -1024,0 +1166,4 @@\n+            \/\/ before join, another thread\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::get));\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::exception));\n+\n@@ -1026,1 +1172,0 @@\n-            \/\/ after join\n@@ -1028,0 +1173,2 @@\n+\n+            \/\/ after join, owner thread\n@@ -1030,0 +1177,4 @@\n+\n+            \/\/ after join, another thread\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::get));\n+            assertTrue(callInOtherThread(subtask::exception) instanceof FooException);\n@@ -1045,2 +1196,0 @@\n-\n-            \/\/ before join\n@@ -1048,0 +1197,2 @@\n+\n+            \/\/ before join, owner thread\n@@ -1051,0 +1202,4 @@\n+            \/\/ before join, another thread\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::get));\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::exception));\n+\n@@ -1055,1 +1210,0 @@\n-            \/\/ after join\n@@ -1057,0 +1211,2 @@\n+\n+            \/\/ after join, owner thread\n@@ -1059,0 +1215,4 @@\n+\n+            \/\/ before join, another thread\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::get));\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::exception));\n@@ -1074,2 +1234,1 @@\n-            \/\/ before join\n-            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            \/\/ before join, owner thread\n@@ -1079,0 +1238,4 @@\n+            \/\/ before join, another thread\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::get));\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::exception));\n+\n@@ -1081,1 +1244,0 @@\n-            \/\/ after join\n@@ -1083,0 +1245,2 @@\n+\n+            \/\/ after join, owner thread\n@@ -1085,0 +1249,4 @@\n+\n+            \/\/ before join, another thread\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::get));\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::exception));\n@@ -1159,0 +1327,19 @@\n+    \/**\n+     * Test Joiner.allSuccessfulOrThrow() with a timeout.\n+     *\/\n+    @Test\n+    void testAllSuccessfulOrThrow4() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allSuccessfulOrThrow(),\n+                cf -> cf.withTimeout(Duration.ofMillis(100)))) {\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"bar\";\n+            });\n+            assertThrows(TimeoutException.class, scope::join);\n+\n+            \/\/ retry after join throws TimeoutException\n+            assertThrows(IllegalStateException.class, scope::join);\n+        }\n+    }\n+\n@@ -1232,0 +1419,19 @@\n+    \/**\n+     * Test Joiner.allSuccessfulOrThrow() with a timeout.\n+     *\/\n+    @Test\n+    void anySuccessfulResultOrThrow6() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulResultOrThrow(),\n+                cf -> cf.withTimeout(Duration.ofMillis(100)))) {\n+            scope.fork(() -> { throw new FooException(); });\n+            scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"bar\";\n+            });\n+            assertThrows(TimeoutException.class, scope::join);\n+\n+            \/\/ retry after join throws TimeoutException\n+            assertThrows(IllegalStateException.class, scope::join);\n+        }\n+    }\n+\n@@ -1279,0 +1485,19 @@\n+    \/**\n+     * Test Joiner.awaitAllSuccessfulOrThrow() with a timeout.\n+     *\/\n+    @Test\n+    void testAwaitSuccessfulOrThrow4() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>awaitAllSuccessfulOrThrow(),\n+                cf -> cf.withTimeout(Duration.ofMillis(100)))) {\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"bar\";\n+            });\n+            assertThrows(TimeoutException.class, scope::join);\n+\n+            \/\/ retry after join throws TimeoutException\n+            assertThrows(IllegalStateException.class, scope::join);\n+        }\n+    }\n+\n@@ -1325,0 +1550,19 @@\n+    \/**\n+     * Test Joiner.awaitAll() with a timeout.\n+     *\/\n+    @Test\n+    void testAwaitAll4() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>awaitAll(),\n+                cf -> cf.withTimeout(Duration.ofMillis(100)))) {\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"bar\";\n+            });\n+            assertThrows(TimeoutException.class, scope::join);\n+\n+            \/\/ retry after join throws TimeoutException\n+            assertThrows(IllegalStateException.class, scope::join);\n+        }\n+    }\n+\n@@ -1349,1 +1593,1 @@\n-            assertEquals(2, subtasks.size());\n+            assertEquals(List.of(subtask1, subtask2), subtasks);\n@@ -1351,2 +1595,0 @@\n-            assertSame(subtask1, subtasks.get(0));\n-            assertSame(subtask2, subtasks.get(1));\n@@ -1374,0 +1616,1 @@\n+            assertEquals(List.of(subtask1, subtask2), subtasks);\n@@ -1375,3 +1618,0 @@\n-            assertEquals(2, subtasks.size());\n-            assertSame(subtask1, subtasks.get(0));\n-            assertSame(subtask2, subtasks.get(1));\n@@ -1440,0 +1680,25 @@\n+    \/**\n+     * Test Joiner.allUntil(Predicate) with a timeout.\n+     *\/\n+    @Test\n+    void testAllUntil6() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allUntil(s -> false),\n+                cf -> cf.withTimeout(Duration.ofMillis(100)))) {\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            var subtask2 = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"bar\";\n+            });\n+\n+            \/\/ TimeoutException should not be thrown\n+            var subtasks = scope.join().toList();\n+\n+            \/\/ stream should have two elements, subtask1 may or may not have completed\n+            assertEquals(List.of(subtask1, subtask2), subtasks);\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask2.state());\n+\n+            \/\/ retry after join throws TimeoutException\n+            assertThrows(IllegalStateException.class, scope::join);\n+        }\n+    }\n+\n@@ -1464,0 +1729,1 @@\n+            assertThrows(TimeoutException.class, joiner::onTimeout);\n@@ -1526,1 +1792,1 @@\n-        Function<Configuration, Configuration> testConfig = cf -> {\n+        UnaryOperator<Configuration> configOperator = cf -> {\n@@ -1551,1 +1817,1 @@\n-        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(), testConfig)) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(), configOperator)) {\n@@ -1758,0 +2024,34 @@\n+    \/**\n+     * Calls a result returning task from another thread.\n+     *\/\n+    private <V> V callInOtherThread(Callable<V> task) throws Exception {\n+        var result = new AtomicReference<V>();\n+        var exc = new AtomicReference<Exception>();\n+        Thread thread = Thread.ofVirtual().start(() -> {\n+            try {\n+                result.set(task.call());\n+            } catch (Exception e) {\n+                exc.set(e);\n+            }\n+        });\n+        boolean interrupted = false;\n+        boolean terminated = false;\n+        while (!terminated) {\n+            try {\n+                thread.join();\n+                terminated = true;\n+            } catch (InterruptedException e) {\n+                interrupted = true;\n+            }\n+        }\n+        if (interrupted) {\n+            Thread.currentThread().interrupt();\n+        }\n+        Exception e = exc.get();\n+        if (e != null) {\n+            throw e;\n+        } else {\n+            return result.get();\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/StructuredTaskScopeTest.java","additions":334,"deletions":34,"binary":false,"changes":368,"status":"modified"}]}