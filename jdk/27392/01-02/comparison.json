{"files":[{"patch":"@@ -37,1 +37,0 @@\n-import java.util.stream.Stream;\n@@ -67,1 +66,1 @@\n-     * A joiner that returns a stream of all subtasks when all subtasks complete\n+     * A joiner that returns a list of all results when all subtasks complete\n@@ -70,1 +69,1 @@\n-    static final class AllSuccessful<T> implements Joiner<T, Stream<Subtask<T>>> {\n+    static final class AllSuccessful<T> implements Joiner<T, List<T>> {\n@@ -80,1 +79,1 @@\n-        public boolean onFork(Subtask<? extends T> subtask) {\n+        public boolean onFork(Subtask<T> subtask) {\n@@ -82,3 +81,1 @@\n-            @SuppressWarnings(\"unchecked\")\n-            var s = (Subtask<T>) subtask;\n-            subtasks.add(s);\n+            subtasks.add(subtask);\n@@ -89,1 +86,1 @@\n-        public boolean onComplete(Subtask<? extends T> subtask) {\n+        public boolean onComplete(Subtask<T> subtask) {\n@@ -97,1 +94,1 @@\n-        public Stream<Subtask<T>> result() throws Throwable {\n+        public List<T> result() throws Throwable {\n@@ -102,1 +99,1 @@\n-                return subtasks.stream();\n+                return subtasks.stream().map(Subtask::get).toList();\n@@ -133,1 +130,1 @@\n-        public boolean onComplete(Subtask<? extends T> subtask) {\n+        public boolean onComplete(Subtask<T> subtask) {\n@@ -169,1 +166,1 @@\n-        public boolean onComplete(Subtask<? extends T> subtask) {\n+        public boolean onComplete(Subtask<T> subtask) {\n@@ -188,1 +185,1 @@\n-     * A joiner that returns a stream of all subtasks.\n+     * A joiner that returns a list of all subtasks.\n@@ -190,2 +187,2 @@\n-    static final class AllSubtasks<T> implements Joiner<T, Stream<Subtask<T>>> {\n-        private final Predicate<Subtask<? extends T>> isDone;\n+    static final class AllSubtasks<T> implements Joiner<T, List<Subtask<T>>> {\n+        private final Predicate<Subtask<T>> isDone;\n@@ -196,1 +193,1 @@\n-        AllSubtasks(Predicate<Subtask<? extends T>> isDone) {\n+        AllSubtasks(Predicate<Subtask<T>> isDone) {\n@@ -201,1 +198,1 @@\n-        public boolean onFork(Subtask<? extends T> subtask) {\n+        public boolean onFork(Subtask<T> subtask) {\n@@ -203,3 +200,1 @@\n-            @SuppressWarnings(\"unchecked\")\n-            var s = (Subtask<T>) subtask;\n-            subtasks.add(s);\n+            subtasks.add(subtask);\n@@ -210,1 +205,1 @@\n-        public boolean onComplete(Subtask<? extends T> subtask) {\n+        public boolean onComplete(Subtask<T> subtask) {\n@@ -221,2 +216,2 @@\n-        public Stream<Subtask<T>> result() {\n-            return subtasks.stream();\n+        public List<Subtask<T>> result() {\n+            return List.copyOf(subtasks);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Joiners.java","additions":18,"deletions":23,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.List;\n@@ -31,1 +32,0 @@\n-import java.util.stream.Stream;\n@@ -54,3 +54,3 @@\n- * the {@code join} method may only be invoked once to get the outcome, and the\n- * {@code close} method throws an exception after closing if the owner did not invoke the\n- * {@code join} method after forking subtasks.\n+ * the {@code join} method must be invoked to get the outcome after forking subtasks, and\n+ * the {@code close} method throws an exception after closing if the owner did not invoke\n+ * the {@code join} method after forking subtasks.\n@@ -110,1 +110,1 @@\n- * result, a stream of elements, or some other object. The {@code Joiner} interface defines\n+ * result, a list of elements, or some other object. The {@code Joiner} interface defines\n@@ -127,4 +127,4 @@\n- * Joiner#anySuccessfulResultOrThrow() Joiner.anySuccessfulResultOrThrow()} to\n- * create a {@code Joiner} that makes available the result of the first subtask to\n- * complete successfully. The type parameter in the example is \"{@code String}\" so that\n- * only subtasks that return a {@code String} can be forked.\n+ * Joiner#anySuccessfulOrThrow() Joiner.anySuccessfulOrThrow()} to create a {@code Joiner}\n+ * that makes available the result of the first subtask to complete successfully. The type\n+ * parameter in the example is \"{@code String}\" so that only subtasks that return a\n+ * {@code String} can be forked.\n@@ -133,1 +133,1 @@\n- *    try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulResultOrThrow())) {\n+ *    try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulOrThrow())) {\n@@ -157,2 +157,3 @@\n- * types, and uses a {@code Joiner} such as {@code Joiner.awaitAllSuccessfulOrThrow()} that\n- * does not return a result, will use {@link Subtask#get() Subtask.get()} after joining.\n+ * types, and uses a {@code Joiner} such as {@link Joiner#awaitAllSuccessfulOrThrow()\n+ * awaitAllSuccessfulOrThrow} that does not return a result, will use {@link Subtask#get()\n+ * Subtask.get()} after joining.\n@@ -253,3 +254,1 @@\n- *        List<String> result = scope.join()\n- *                                   .map(Subtask::get)\n- *                                   .toList();\n+ *        List<String> results = scope.join();\n@@ -457,6 +456,6 @@\n-     *   that yields a stream of the completed subtasks for {@code join} to return when\n-     *   all subtasks complete successfully. It cancels the scope and causes {@code join}\n-     *   to throw if any subtask fails.\n-     *   <li> {@link #anySuccessfulResultOrThrow() anySuccessfulResultOrThrow()} creates a\n-     *   {@code Joiner} that yields the result of the first subtask to succeed for {@code\n-     *   join} to return. It causes {@code join} to throw if all subtasks fail.\n+     *   that yields a list of all results for {@code join} to return when all subtasks\n+     *   complete successfully. It cancels the scope and causes {@code join} to throw if\n+     *   any subtask fails.\n+     *   <li> {@link #anySuccessfulOrThrow() anySuccessfulOrThrow()} creates a {@code Joiner}\n+     *   that yields the result of the first subtask to succeed for {@code join} to return.\n+     *   It causes {@code join} to throw if all subtasks fail.\n@@ -472,1 +471,1 @@\n-     * {@code Joiner} that yields a stream of all subtasks. It is created with a {@link\n+     * {@code Joiner} that yields a list of all subtasks. It is created with a {@link\n@@ -538,1 +537,1 @@\n-        default boolean onFork(Subtask<? extends T> subtask) {\n+        default boolean onFork(Subtask<T> subtask) {\n@@ -561,1 +560,1 @@\n-        default boolean onComplete(Subtask<? extends T> subtask) {\n+        default boolean onComplete(Subtask<T> subtask) {\n@@ -611,1 +610,1 @@\n-         * {@return a new Joiner object that yields a stream of all subtasks when all\n+         * {@return a new Joiner object that yields a list of all results when all\n@@ -617,3 +616,3 @@\n-         * Joiner#result()} method returns a stream of all subtasks, in the order that they\n-         * were forked, for the {@link StructuredTaskScope#join() join()} to return. If\n-         * the scope was opened with a {@linkplain Configuration#withTimeout(Duration)\n+         * Joiner#result()} method returns a list of all results, in the order that the\n+         * subtasks were forked, for the {@link StructuredTaskScope#join() join()} to return.\n+         * If the scope was opened with a {@linkplain Configuration#withTimeout(Duration)\n@@ -630,1 +629,1 @@\n-        static <T> Joiner<T, Stream<Subtask<T>>> allSuccessfulOrThrow() {\n+        static <T> Joiner<T, List<T>> allSuccessfulOrThrow() {\n@@ -649,0 +648,1 @@\n+         * @since 26\n@@ -650,1 +650,1 @@\n-        static <T> Joiner<T, T> anySuccessfulResultOrThrow() {\n+        static <T> Joiner<T, T> anySuccessfulOrThrow() {\n@@ -718,1 +718,1 @@\n-         * {@return a new Joiner object that yields a stream of all subtasks when all\n+         * {@return a new Joiner object that yields a list of all subtasks when all\n@@ -731,2 +731,2 @@\n-         * <p> The joiner's {@link #result()} method returns the stream of all subtasks,\n-         * in fork order. The stream may contain subtasks that have completed\n+         * <p> The joiner's {@link #result()} method returns the list of all subtasks,\n+         * in fork order. The list may contain subtasks that have completed\n@@ -740,1 +740,1 @@\n-         * then the {@link #result()} method returns the stream of all subtasks.\n+         * then the {@link #result()} method returns the list of all subtasks.\n@@ -748,1 +748,1 @@\n-         *    class CancelAfterTwoFailures<T> implements Predicate<Subtask<? extends T>> {\n+         *    class CancelAfterTwoFailures<T> implements Predicate<Subtask<T>> {\n@@ -751,1 +751,1 @@\n-         *         public boolean test(Subtask<? extends T> subtask) {\n+         *         public boolean test(Subtask<T> subtask) {\n@@ -767,1 +767,1 @@\n-         *            return scope.join().toList();\n+         *            return scope.join();\n@@ -779,0 +779,1 @@\n+         *                 .stream()\n@@ -789,1 +790,1 @@\n-        static <T> Joiner<T, Stream<Subtask<T>>> allUntil(Predicate<Subtask<? extends T>> isDone) {\n+        static <T> Joiner<T, List<Subtask<T>>> allUntil(Predicate<Subtask<T>> isDone) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":39,"deletions":38,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -173,1 +173,1 @@\n-    private void onComplete(SubtaskImpl<? extends T> subtask) {\n+    private <U extends T> void onComplete(SubtaskImpl<U> subtask) {\n@@ -175,1 +175,3 @@\n-        if (joiner.onComplete(subtask)) {\n+        @SuppressWarnings(\"unchecked\")\n+        var j = (Joiner<U, ? extends R>) joiner;\n+        if (j.onComplete(subtask)) {\n@@ -192,1 +194,3 @@\n-        if (joiner.onFork(subtask)) {\n+        @SuppressWarnings(\"unchecked\")\n+        var j = (Joiner<U, ? extends R>) joiner;\n+        if (j.onFork(subtask)) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScopeImpl.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-            public boolean onComplete(Subtask<? extends Boolean> subtask) {\n+            public boolean onComplete(Subtask<Boolean> subtask) {\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/StressCancellation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -389,1 +389,1 @@\n-        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulResultOrThrow())) {\n+        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulOrThrow())) {\n@@ -402,1 +402,1 @@\n-     * Test join after join completed with a timeout.\n+     * Test join after join interrupted.\n@@ -433,1 +433,1 @@\n-        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulResultOrThrow(),\n+        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulOrThrow(),\n@@ -956,1 +956,1 @@\n-            public boolean onFork(Subtask<? extends String> subtask) {\n+            public boolean onFork(Subtask<String> subtask) {\n@@ -976,1 +976,1 @@\n-            public boolean onFork(Subtask<? extends String> subtask) {\n+            public boolean onFork(Subtask<String> subtask) {\n@@ -999,1 +999,1 @@\n-            public boolean onComplete(Subtask<? extends String> subtask) {\n+            public boolean onComplete(Subtask<String> subtask) {\n@@ -1026,1 +1026,1 @@\n-            public boolean onComplete(Subtask<? extends String> subtask) {\n+            public boolean onComplete(Subtask<String> subtask) {\n@@ -1286,2 +1286,2 @@\n-            var subtasks = scope.join().toList();\n-            assertTrue(subtasks.isEmpty());\n+            var results = scope.join();\n+            assertTrue(results.isEmpty());\n@@ -1299,6 +1299,4 @@\n-            var subtask1 = scope.fork(() -> \"foo\");\n-            var subtask2 = scope.fork(() -> \"bar\");\n-            var subtasks = scope.join().toList();\n-            assertEquals(List.of(subtask1, subtask2), subtasks);\n-            assertEquals(\"foo\", subtask1.get());\n-            assertEquals(\"bar\", subtask2.get());\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> \"bar\");\n+            var results = scope.join();\n+            assertEquals(List.of(\"foo\", \"bar\"), results);\n@@ -1347,1 +1345,23 @@\n-     * Test Joiner.anySuccessfulResultOrThrow() with no subtasks.\n+     * Test Joiner.allSuccessfulOrThrow() yields an unmodifiable list.\n+     *\/\n+    @Test\n+    void testAllSuccessfulOrThrow5() throws Exception {\n+        \/\/ empty list\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allSuccessfulOrThrow())) {\n+            var results = scope.join();\n+            assertEquals(0, results.size());\n+            assertThrows(UnsupportedOperationException.class, () -> results.add(\"foo\"));\n+        }\n+\n+        \/\/ non-empty list\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allSuccessfulOrThrow())) {\n+            scope.fork(() -> \"foo\");\n+            var results = scope.join();\n+            assertEquals(1, results.size());\n+            assertThrows(UnsupportedOperationException.class, () -> results.add(\"foo\"));\n+            assertThrows(UnsupportedOperationException.class, () -> results.add(\"bar\"));\n+        }\n+    }\n+\n+    \/**\n+     * Test Joiner.anySuccessfulOrThrow() with no subtasks.\n@@ -1350,2 +1370,2 @@\n-    void testAnySuccessfulResultOrThrow1() throws Exception {\n-        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulResultOrThrow())) {\n+    void testAnySuccessfulOrThrow1() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulOrThrow())) {\n@@ -1361,1 +1381,1 @@\n-     * Test Joiner.anySuccessfulResultOrThrow() with a subtask that completes successfully.\n+     * Test Joiner.anySuccessfulOrThrow() with a subtask that completes successfully.\n@@ -1365,2 +1385,2 @@\n-    void testAnySuccessfulResultOrThrow2(ThreadFactory factory) throws Exception {\n-        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulResultOrThrow(),\n+    void testAnySuccessfulOrThrow2(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulOrThrow(),\n@@ -1375,1 +1395,1 @@\n-     * Test Joiner.anySuccessfulResultOrThrow() with a subtask that completes successfully\n+     * Test Joiner.anySuccessfulOrThrow() with a subtask that completes successfully\n@@ -1380,2 +1400,2 @@\n-    void testAnySuccessfulResultOrThrow3(ThreadFactory factory) throws Exception {\n-        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulResultOrThrow(),\n+    void testAnySuccessfulOrThrow3(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulOrThrow(),\n@@ -1390,1 +1410,1 @@\n-     * Test Joiner.anySuccessfulResultOrThrow() with a subtask that complete succcessfully\n+     * Test Joiner.anySuccessfulOrThrow() with a subtask that complete succcessfully\n@@ -1395,2 +1415,2 @@\n-    void testAnySuccessfulResultOrThrow4(ThreadFactory factory) throws Exception {\n-        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulResultOrThrow(),\n+    void testAnySuccessfulOrThrow4(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulOrThrow(),\n@@ -1406,1 +1426,1 @@\n-     * Test Joiner.anySuccessfulResultOrThrow() with a subtask that fails.\n+     * Test Joiner.anySuccessfulOrThrow() with a subtask that fails.\n@@ -1410,2 +1430,2 @@\n-    void testAnySuccessfulResultOrThrow5(ThreadFactory factory) throws Exception {\n-        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulResultOrThrow(),\n+    void testAnySuccessfulOrThrow5(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulOrThrow(),\n@@ -1420,1 +1440,1 @@\n-     * Test Joiner.allSuccessfulOrThrow() with a timeout.\n+     * Test Joiner.anySuccessfulOrThrow() with a timeout.\n@@ -1423,2 +1443,2 @@\n-    void anySuccessfulResultOrThrow6() throws Exception {\n-        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulResultOrThrow(),\n+    void anySuccessfulOrThrow6() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulOrThrow(),\n@@ -1576,1 +1596,1 @@\n-            assertEquals(0, subtasks.count());\n+            assertEquals(0, subtasks.size());\n@@ -1592,1 +1612,1 @@\n-            var subtasks = scope.join().toList();\n+            var subtasks = scope.join();\n@@ -1615,1 +1635,1 @@\n-            var subtasks = scope.join().toList();\n+            var subtasks = scope.join();\n@@ -1631,1 +1651,1 @@\n-        class CancelAfterTwoFailures<T> implements Predicate<Subtask<? extends T>> {\n+        class CancelAfterTwoFailures<T> implements Predicate<Subtask<T>> {\n@@ -1634,1 +1654,1 @@\n-            public boolean test(Subtask<? extends T> subtask) {\n+            public boolean test(Subtask<T> subtask) {\n@@ -1652,1 +1672,1 @@\n-            var subtasks = scope.join().toList();\n+            var subtasks = scope.join();\n@@ -1694,1 +1714,1 @@\n-            var subtasks = scope.join().toList();\n+            var subtasks = scope.join();\n@@ -1705,0 +1725,28 @@\n+    \/**\n+     * Test Joiner.allUntil(Predicate) yields an unmodifiable list.\n+     *\/\n+    @Test\n+    void testAllUntil7() throws Exception {\n+        Subtask<String> subtask1;\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allUntil(s -> false))) {\n+            subtask1 = scope.fork(() -> \"?\");\n+            scope.join();\n+        }\n+\n+        \/\/ empty list\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allUntil(s -> false))) {\n+            var subtasks = scope.join();\n+            assertEquals(0, subtasks.size());\n+            assertThrows(UnsupportedOperationException.class, () -> subtasks.add(subtask1));\n+        }\n+\n+        \/\/ non-empty list\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allUntil(s -> false))) {\n+            var subtask2 = scope.fork(() -> \"foo\");\n+            var subtasks = scope.join();\n+            assertEquals(1, subtasks.size());\n+            assertThrows(UnsupportedOperationException.class, () -> subtasks.add(subtask1));\n+            assertThrows(UnsupportedOperationException.class, () -> subtasks.add(subtask2));\n+        }\n+    }\n+\n@@ -1722,1 +1770,1 @@\n-            Joiner<Object, Void> joiner = () -> null;\n+            Joiner<String, Void> joiner = () -> null;\n@@ -1750,1 +1798,1 @@\n-                    () -> Joiner.anySuccessfulResultOrThrow().onComplete(subtask));\n+                    () -> Joiner.anySuccessfulOrThrow().onComplete(subtask));\n@@ -1766,1 +1814,1 @@\n-                    () -> Joiner.anySuccessfulResultOrThrow().onFork(subtask));\n+                    () -> Joiner.anySuccessfulOrThrow().onFork(subtask));\n@@ -1866,1 +1914,1 @@\n-                () -> Joiner.anySuccessfulResultOrThrow().onFork(null));\n+                () -> Joiner.anySuccessfulOrThrow().onFork(null));\n@@ -1868,1 +1916,1 @@\n-                () -> Joiner.anySuccessfulResultOrThrow().onComplete(null));\n+                () -> Joiner.anySuccessfulOrThrow().onComplete(null));\n@@ -1898,1 +1946,1 @@\n-        public boolean onFork(Subtask<? extends T> subtask) {\n+        public boolean onFork(Subtask<T> subtask) {\n@@ -1903,1 +1951,1 @@\n-        public boolean onComplete(Subtask<? extends T> subtask) {\n+        public boolean onComplete(Subtask<T> subtask) {\n@@ -1927,1 +1975,1 @@\n-        public boolean onFork(Subtask<? extends T> subtask) {\n+        public boolean onFork(Subtask<T> subtask) {\n@@ -1932,1 +1980,1 @@\n-        public boolean onComplete(Subtask<? extends T> subtask) {\n+        public boolean onComplete(Subtask<T> subtask) {\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/StructuredTaskScopeTest.java","additions":97,"deletions":49,"binary":false,"changes":146,"status":"modified"}]}