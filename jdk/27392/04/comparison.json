{"files":[{"patch":"@@ -37,1 +37,0 @@\n-import java.util.stream.Stream;\n@@ -67,1 +66,1 @@\n-     * A joiner that returns a stream of all subtasks when all subtasks complete\n+     * A joiner that returns a list of all results when all subtasks complete\n@@ -70,1 +69,1 @@\n-    static final class AllSuccessful<T> implements Joiner<T, Stream<Subtask<T>>> {\n+    static final class AllSuccessful<T> implements Joiner<T, List<T>> {\n@@ -74,2 +73,2 @@\n-        \/\/ list of forked subtasks, only accessed by owner thread\n-        private final List<Subtask<T>> subtasks = new ArrayList<>();\n+        \/\/ list of forked subtasks, created lazily, only accessed by owner thread\n+        private List<Subtask<T>> subtasks;\n@@ -80,1 +79,1 @@\n-        public boolean onFork(Subtask<? extends T> subtask) {\n+        public boolean onFork(Subtask<T> subtask) {\n@@ -82,3 +81,4 @@\n-            @SuppressWarnings(\"unchecked\")\n-            var s = (Subtask<T>) subtask;\n-            subtasks.add(s);\n+            if (subtasks == null) {\n+                subtasks = new ArrayList<>();\n+            }\n+            subtasks.add(subtask);\n@@ -89,1 +89,1 @@\n-        public boolean onComplete(Subtask<? extends T> subtask) {\n+        public boolean onComplete(Subtask<T> subtask) {\n@@ -97,1 +97,1 @@\n-        public Stream<Subtask<T>> result() throws Throwable {\n+        public List<T> result() throws Throwable {\n@@ -99,4 +99,9 @@\n-            if (ex != null) {\n-                throw ex;\n-            } else {\n-                return subtasks.stream();\n+            try {\n+                if (ex != null) {\n+                    throw ex;\n+                }\n+                return (subtasks != null)\n+                        ? subtasks.stream().map(Subtask::get).toList()\n+                        : List.of();\n+            } finally {\n+                subtasks = null;  \/\/ allow subtasks to be GC'ed\n@@ -133,1 +138,1 @@\n-        public boolean onComplete(Subtask<? extends T> subtask) {\n+        public boolean onComplete(Subtask<T> subtask) {\n@@ -169,1 +174,1 @@\n-        public boolean onComplete(Subtask<? extends T> subtask) {\n+        public boolean onComplete(Subtask<T> subtask) {\n@@ -188,1 +193,1 @@\n-     * A joiner that returns a stream of all subtasks.\n+     * A joiner that returns a list of all subtasks.\n@@ -190,2 +195,2 @@\n-    static final class AllSubtasks<T> implements Joiner<T, Stream<Subtask<T>>> {\n-        private final Predicate<Subtask<? extends T>> isDone;\n+    static final class AllSubtasks<T> implements Joiner<T, List<Subtask<T>>> {\n+        private final Predicate<Subtask<T>> isDone;\n@@ -193,2 +198,2 @@\n-        \/\/ list of forked subtasks, only accessed by owner thread\n-        private final List<Subtask<T>> subtasks = new ArrayList<>();\n+        \/\/ list of forked subtasks, created lazily, only accessed by owner thread\n+        private List<Subtask<T>> subtasks;\n@@ -196,1 +201,1 @@\n-        AllSubtasks(Predicate<Subtask<? extends T>> isDone) {\n+        AllSubtasks(Predicate<Subtask<T>> isDone) {\n@@ -201,1 +206,1 @@\n-        public boolean onFork(Subtask<? extends T> subtask) {\n+        public boolean onFork(Subtask<T> subtask) {\n@@ -203,3 +208,4 @@\n-            @SuppressWarnings(\"unchecked\")\n-            var s = (Subtask<T>) subtask;\n-            subtasks.add(s);\n+            if (subtasks == null) {\n+                subtasks = new ArrayList<>();\n+            }\n+            subtasks.add(subtask);\n@@ -210,1 +216,1 @@\n-        public boolean onComplete(Subtask<? extends T> subtask) {\n+        public boolean onComplete(Subtask<T> subtask) {\n@@ -216,2 +222,13 @@\n-        public Stream<Subtask<T>> result() {\n-            return subtasks.stream();\n+        public void onTimeout() {\n+            \/\/ do nothing, this joiner does not throw TimeoutException\n+        }\n+\n+        @Override\n+        public List<Subtask<T>> result() {\n+            if (subtasks != null) {\n+                List<Subtask<T>> result = List.copyOf(subtasks);\n+                subtasks = null;  \/\/ allow subtasks to be GC'ed\n+                return result;\n+            } else {\n+                return List.of();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Joiners.java","additions":47,"deletions":30,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.util.function.Function;\n+import java.util.List;\n@@ -31,1 +31,1 @@\n-import java.util.stream.Stream;\n+import java.util.function.UnaryOperator;\n@@ -54,3 +54,3 @@\n- * the {@code join} method may only be invoked once, and the {@code close} method throws\n- * an exception after closing if the owner did not invoke the {@code join} method after\n- * forking subtasks.\n+ * the {@code join} method must be invoked to get the outcome after forking subtasks, and\n+ * the {@code close} method throws an exception after closing if the owner did not invoke\n+ * the {@code join} method after forking subtasks.\n@@ -110,1 +110,1 @@\n- * result, a stream of elements, or some other object. The {@code Joiner} interface defines\n+ * result, a list of elements, or some other object. The {@code Joiner} interface defines\n@@ -113,1 +113,1 @@\n- * <p> A {@code Joiner} may <a id=\"Cancallation\">cancel<\/a> the scope (sometimes called\n+ * <p> A {@code Joiner} may <a id=\"Cancellation\">cancel<\/a> the scope (sometimes called\n@@ -127,4 +127,4 @@\n- * Joiner#anySuccessfulResultOrThrow() Joiner.anySuccessfulResultOrThrow()} to\n- * create a {@code Joiner} that makes available the result of the first subtask to\n- * complete successfully. The type parameter in the example is \"{@code String}\" so that\n- * only subtasks that return a {@code String} can be forked.\n+ * Joiner#anySuccessfulOrThrow() Joiner.anySuccessfulOrThrow()} to create a {@code Joiner}\n+ * that makes available the result of the first subtask to complete successfully. The type\n+ * parameter in the example is \"{@code String}\" so that only subtasks that return a\n+ * {@code String} can be forked.\n@@ -133,1 +133,1 @@\n- *    try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulResultOrThrow())) {\n+ *    try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulOrThrow())) {\n@@ -157,2 +157,3 @@\n- * types, and uses a {@code Joiner} such as {@code Joiner.awaitAllSuccessfulOrThrow()} that\n- * does not return a result, will use {@link Subtask#get() Subtask.get()} after joining.\n+ * types, and uses a {@code Joiner} such as {@link Joiner#awaitAllSuccessfulOrThrow()\n+ * awaitAllSuccessfulOrThrow} that does not return a result, will use {@link Subtask#get()\n+ * Subtask.get()} after joining.\n@@ -201,1 +202,0 @@\n- *\n@@ -203,2 +203,3 @@\n- * that consists of a {@link ThreadFactory} to create threads, an optional name for\n- * monitoring and management purposes, and an optional timeout.\n+ * that consists of a {@link ThreadFactory} to create threads, an optional name for the\n+ * scope, and an optional timeout. The name is intended for monitoring and management\n+ * purposes.\n@@ -208,10 +209,9 @@\n- * configuration has a {@code ThreadFactory} that creates unnamed\n- * <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">virtual threads<\/a>,\n- * is unnamed for monitoring and management purposes, and has no timeout.\n- *\n- * <p> The 2-arg {@link #open(Joiner, Function) open} method can be used to create a\n- * {@code StructuredTaskScope} that uses a different {@code ThreadFactory}, has a name for\n- * the purposes of monitoring and management, or has a timeout that cancels the scope if\n- * the timeout expires before or while waiting for subtasks to complete. The {@code open}\n- * method is called with a {@linkplain Function function} that is applied to the default\n- * configuration and returns a {@link Configuration Configuration} for the\n+ * configuration has a {@code ThreadFactory} that creates unnamed {@linkplain\n+ * Thread##virtual-threads virtual threads}, does not name the scope, and has no timeout.\n+ *\n+ * <p> The 2-arg {@link #open(Joiner, UnaryOperator) open} method can be used to create a\n+ * {@code StructuredTaskScope} that uses a different {@code ThreadFactory}, is named for\n+ * monitoring and management purposes, or has a timeout that cancels the scope if the\n+ * timeout expires before or while waiting for subtasks to complete. The {@code open}\n+ * method is called with an {@linkplain UnaryOperator operator} that is applied to the\n+ * default configuration and returns a {@link Configuration Configuration} for the\n@@ -240,3 +240,3 @@\n- * method has completed then the scope is <a href=\"#Cancallation\">cancelled<\/a>. This\n- * interrupts the threads executing the two subtasks and causes the {@link #join() join}\n- * method to throw {@link TimeoutException}.\n+ * method has completed then the scope is {@linkplain ##Cancellation cancelled} (this\n+ * interrupts the threads executing the two subtasks), and the {@code join} method\n+ * throws {@link TimeoutException TimeoutException}.\n@@ -254,3 +254,1 @@\n- *        List<String> result = scope.join()\n- *                                   .map(Subtask::get)\n- *                                   .toList();\n+ *        List<String> results = scope.join();\n@@ -317,5 +315,4 @@\n- * <p> A scoped value inherited into a subtask may be\n- * <a href=\"{@docRoot}\/java.base\/java\/lang\/ScopedValue.html#rebind\">rebound<\/a> to a new\n- * value in the subtask for the bounded execution of some method executed in the subtask.\n- * When the method completes, the value of the {@code ScopedValue} reverts to its previous\n- * value, the value inherited from the thread executing the task.\n+ * <p> A scoped value inherited into a subtask may be {@linkplain ScopedValue##rebind\n+ * rebound} to a new value in the subtask for the bounded execution of some method executed\n+ * in the subtask. When the method completes, the value of the {@code ScopedValue} reverts\n+ * to its previous value, the value inherited from the thread executing the task.\n@@ -334,5 +331,9 @@\n- * <p> Actions in the owner thread of a {@code StructuredTaskScope} prior to\n- * {@linkplain #fork forking} of a subtask\n- * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\">\n- * <i>happen-before<\/i><\/a> any actions taken by that subtask, which in turn\n- * <i>happen-before<\/i> the subtask result is {@linkplain Subtask#get() retrieved}.\n+ * <p> Actions in the owner thread of a {@code StructuredTaskScope} prior to {@linkplain\n+ * #fork forking} of a subtask {@linkplain java.util.concurrent##MemoryVisibility\n+ * <i>happen-before<\/i>} any actions taken by the thread that executes the subtask, which\n+ * in turn <i>happen-before<\/i> actions in any thread that successfully obtains the\n+ * subtask outcome with {@link Subtask#get() Subtask.get()} or {@link Subtask#exception()\n+ * Subtask.exception()}. If a subtask's outcome contributes to the result or exception\n+ * from {@link #join()}, then any actions taken by the thread executing that subtask\n+ * <i>happen-before<\/i> the owner thread returns from {@code join} with a result or\n+ * {@link FailedException FailedException}.\n@@ -408,1 +409,1 @@\n-         * result of a successful subtask only after it has {@linkplain #join() joined}.\n+         * result of a successful subtask after it has {@linkplain #join() joined}.\n@@ -414,0 +415,4 @@\n+         * <p> This method may be invoked by any thread after the scope owner has joined.\n+         * The only case where this method can be used to get the result before the scope\n+         * owner has joined is when called from the {@code onComplete(Subtask)} method.\n+         *\n@@ -415,3 +420,3 @@\n-         * @throws IllegalStateException if the subtask has not completed, did not complete\n-         * successfully, or the current thread is the scope owner invoking this\n-         * method before {@linkplain #join() joining}\n+         * @throws IllegalStateException if the subtask has not completed or did not\n+         * complete successfully, or this method if invoked outside the context of the\n+         * {@code onComplete(Subtask)} method before the owner thread has joined\n@@ -430,1 +435,1 @@\n-         * exception thrown by a failed subtask only after it has {@linkplain #join() joined}.\n+         * exception thrown by a failed subtask after it has {@linkplain #join() joined}.\n@@ -436,3 +441,7 @@\n-         * @throws IllegalStateException if the subtask has not completed, completed with\n-         * a result, or the current thread is the scope owner invoking this method\n-         * before {@linkplain #join() joining}\n+         * <p> This method may be invoked by any thread after the scope owner has joined.\n+         * The only case where this method can be used to get the exception before the scope\n+         * owner has joined is when called from the {@code onComplete(Subtask)} method.\n+         *\n+         * @throws IllegalStateException if the subtask has not completed or completed\n+         * with a result, or this method if invoked outside the context of the {@code\n+         * onComplete(Subtask)} method before the owner thread has joined\n@@ -452,6 +461,6 @@\n-     *   that yields a stream of the completed subtasks for {@code join} to return when\n-     *   all subtasks complete successfully. It cancels the scope and causes {@code join}\n-     *   to throw if any subtask fails.\n-     *   <li> {@link #anySuccessfulResultOrThrow() anySuccessfulResultOrThrow()} creates a\n-     *   {@code Joiner} that yields the result of the first subtask to succeed for {@code\n-     *   join} to return. It causes {@code join} to throw if all subtasks fail.\n+     *   that yields a list of all results for {@code join} to return when all subtasks\n+     *   complete successfully. It cancels the scope and causes {@code join} to throw if\n+     *   any subtask fails.\n+     *   <li> {@link #anySuccessfulOrThrow() anySuccessfulOrThrow()} creates a {@code Joiner}\n+     *   that yields the result of the first subtask to succeed for {@code join} to return.\n+     *   It causes {@code join} to throw if all subtasks fail.\n@@ -462,1 +471,1 @@\n-     *   subtasks. It does not cancel the scope or cause {@code join} to throw.\n+     *   subtasks to complete. It does not cancel the scope or cause {@code join} to throw.\n@@ -467,1 +476,1 @@\n-     * {@code Joiner} that yields a stream of all subtasks. It is created with a {@link\n+     * {@code Joiner} that yields a list of all subtasks. It is created with a {@link\n@@ -475,1 +484,1 @@\n-     * result or exception. These methods return a {@code boolean} to indicate if scope\n+     * result or exception. These methods return a {@code boolean} to indicate if the scope\n@@ -481,0 +490,10 @@\n+     * <p> If a {@code StructuredTaskScope} is opened with a {@linkplain\n+     * Configuration#withTimeout(Duration) timeout}, and the timeout expires before or\n+     * while waiting in {@link StructuredTaskScope#join() join()}, then the scope is\n+     * {@linkplain StructuredTaskScope##Cancellation cancelled}, and the {@code Joiners}'s\n+     * {@link #onTimeout()} method is invoked to notify the {@code Joiner} and optionally\n+     * throw {@link TimeoutException TimeoutException}. If the {@code onTimeout()} method\n+     * does not throw then the {@code join()} method will invoke the {@link #result()}\n+     * method to produce a result. This result may be based on the outcome of subtasks\n+     * that completed before the timeout expired.\n+     *\n@@ -486,1 +505,3 @@\n-     * threads concurrently.\n+     * threads concurrently, concurrently with the owner thread invoking the {@link\n+     * #onFork(Subtask)} method, or if a timeout is configured, concurrently with the owner\n+     * thread invoking the {@link #onTimeout()} method.\n@@ -490,1 +511,1 @@\n-     * different scopes or re-used after a task is closed.\n+     * different scopes or re-used after a scope is closed.\n@@ -505,1 +526,0 @@\n-    @FunctionalInterface\n@@ -509,3 +529,2 @@\n-         * fork(Runnable)} when forking a subtask. The method is invoked from the task\n-         * owner thread. The method is invoked before a thread is created to run the\n-         * subtask.\n+         * fork(Runnable)} when forking a subtask. The method is invoked before a thread\n+         * is created to run the subtask.\n@@ -524,1 +543,1 @@\n-        default boolean onFork(Subtask<? extends T> subtask) {\n+        default boolean onFork(Subtask<T> subtask) {\n@@ -547,1 +566,1 @@\n-        default boolean onComplete(Subtask<? extends T> subtask) {\n+        default boolean onComplete(Subtask<T> subtask) {\n@@ -554,0 +573,21 @@\n+        \/**\n+         * Invoked by the {@link #join() join()} method if the scope was opened with a\n+         * timeout, and the timeout expires before or while waiting in the {@code join}\n+         * method.\n+         *\n+         * @implSpec The default implementation throws {@link TimeoutException TimeoutException}.\n+         *\n+         * @apiNote This method is intended for {@code Joiner} implementations that do not\n+         * throw {@link TimeoutException TimeoutException}, or require a notification when\n+         * the timeout expires before or while waiting in {@code join}.\n+         *\n+         * <p> This method is invoked by the {@code join} method. It should not be\n+         * invoked directly.\n+         *\n+         * @throws TimeoutException for {@code join} to throw\n+         * @since 26\n+         *\/\n+        default void onTimeout() {\n+            throw new TimeoutException();\n+        }\n+\n@@ -563,3 +603,1 @@\n-         * invoked directly, and invoked more than once, is undefined. Where possible, an\n-         * implementation should return an equal result (or throw the same exception) on\n-         * second or subsequent calls to produce the outcome.\n+         * invoked directly is undefined.\n@@ -576,1 +614,1 @@\n-         * {@return a new Joiner object that yields a stream of all subtasks when all\n+         * {@return a new Joiner object that yields a list of all results when all\n@@ -578,1 +616,1 @@\n-         * The {@code Joiner} <a href=\"StructuredTaskScope.html#Cancallation\">cancels<\/a>\n+         * The {@code Joiner} {@linkplain StructuredTaskScope##Cancellation cancels}\n@@ -581,4 +619,6 @@\n-         * <p> If all subtasks complete successfully, the joiner's {@link Joiner#result()}\n-         * method returns a stream of all subtasks in the order that they were forked.\n-         * If any subtask failed then the {@code result} method throws the exception from\n-         * the first subtask to fail.\n+         * <p> If all subtasks complete successfully then the joiner's {@link\n+         * Joiner#result()} method returns a list of all results, in the order that the\n+         * subtasks were forked, for the {@link StructuredTaskScope#join() join()} to return.\n+         * If the scope was opened with a {@linkplain Configuration#withTimeout(Duration)\n+         * timeout}, and the timeout expires before or while waiting for all subtasks to\n+         * complete, then the {@code join} method throws {@code TimeoutException}.\n@@ -593,1 +633,1 @@\n-        static <T> Joiner<T, Stream<Subtask<T>>> allSuccessfulOrThrow() {\n+        static <T> Joiner<T, List<T>> allSuccessfulOrThrow() {\n@@ -602,4 +642,8 @@\n-         * <p> The joiner's {@link Joiner#result()} method returns the result of a subtask\n-         * that completed successfully. If all subtasks fail then the {@code result} method\n-         * throws the exception from one of the failed subtasks. The {@code result} method\n-         * throws {@code NoSuchElementException} if no subtasks were forked.\n+         * <p> The joiner's {@link Joiner#result()} method returns the result of a subtask,\n+         * that completed successfully, for the {@link StructuredTaskScope#join() join()}\n+         * to return. If all subtasks fail then the {@code result} method throws the\n+         * exception from one of the failed subtasks. The {@code result} method throws\n+         * {@code NoSuchElementException} if no subtasks were forked. If the scope was\n+         * opened with a {@linkplain Configuration#withTimeout(Duration) timeout}, and\n+         * the timeout expires before or while waiting for any subtask to complete\n+         * successfully, then the {@code join} method throws {@code TimeoutException}.\n@@ -608,0 +652,1 @@\n+         * @since 26\n@@ -609,1 +654,1 @@\n-        static <T> Joiner<T, T> anySuccessfulResultOrThrow() {\n+        static <T> Joiner<T, T> anySuccessfulOrThrow() {\n@@ -615,1 +660,1 @@\n-         * The {@code Joiner} <a href=\"StructuredTaskScope.html#Cancallation\">cancels<\/a>\n+         * The {@code Joiner} {@linkplain StructuredTaskScope##Cancellation cancels}\n@@ -620,1 +665,4 @@\n-         * subtask to fail.\n+         * subtask to fail. If the scope was opened with a {@linkplain\n+         * Configuration#withTimeout(Duration) timeout}, and the timeout expires before or\n+         * while waiting for all subtasks to complete, then the {@code join} method throws\n+         * {@code TimeoutException}.\n@@ -637,0 +685,3 @@\n+         * If the scope was opened with a {@linkplain Configuration#withTimeout(Duration)\n+         * timeout}, and the timeout expires before or while waiting for all subtasks to\n+         * complete, then the {@code join} method throws {@code TimeoutException}.\n@@ -671,1 +722,1 @@\n-         * {@return a new Joiner object that yields a stream of all subtasks when all\n+         * {@return a new Joiner object that yields a list of all subtasks when all\n@@ -674,5 +725,5 @@\n-         * <p> The joiner's {@link Joiner#onComplete(Subtask)} method invokes the\n-         * predicate's {@link Predicate#test(Object) test} method with the subtask that\n-         * completed successfully or failed with an exception. If the {@code test} method\n-         * returns {@code true} then <a href=\"StructuredTaskScope.html#Cancallation\">\n-         * the scope is cancelled<\/a>. The {@code test} method must be thread safe as it\n+         * <p> The joiner's {@link #onComplete(Subtask)} method invokes the predicate's\n+         * {@link Predicate#test(Object) test} method with the subtask that completed\n+         * successfully or failed with an exception. If the {@code test} method\n+         * returns {@code true} then {@linkplain StructuredTaskScope##Cancellation\n+         * the scope is cancelled}. The {@code test} method must be thread safe as it\n@@ -684,2 +735,2 @@\n-         * <p> The joiner's {@link #result()} method returns the stream of all subtasks,\n-         * in fork order. The stream may contain subtasks that have completed\n+         * <p> The joiner's {@link #result()} method returns the list of all subtasks,\n+         * in fork order. The list may contain subtasks that have completed\n@@ -690,0 +741,7 @@\n+         * <p> The joiner's {@link #onTimeout()} method does nothing. If configured with\n+         * a {@linkplain Configuration#withTimeout(Duration) timeout}, and the timeout\n+         * expires before or while waiting in {@link StructuredTaskScope#join() join},\n+         * then the {@link #result()} method returns the list of all subtasks.\n+         * Subtasks that did not complete before the timeout expired will be in the\n+         * {@link Subtask.State#UNAVAILABLE UNAVAILABLE} state.\n+         *\n@@ -691,2 +749,2 @@\n-         * <a href=\"StructuredTaskScope.html#Cancallation\">cancels<\/a> the scope when\n-         * two or more subtasks fail.\n+         * {@linkplain StructuredTaskScope##Cancellation cancels} the scope when two or\n+         * more subtasks fail.\n@@ -694,1 +752,1 @@\n-         *    class CancelAfterTwoFailures<T> implements Predicate<Subtask<? extends T>> {\n+         *    class CancelAfterTwoFailures<T> implements Predicate<Subtask<T>> {\n@@ -697,1 +755,1 @@\n-         *         public boolean test(Subtask<? extends T> subtask) {\n+         *         public boolean test(Subtask<T> subtask) {\n@@ -713,1 +771,1 @@\n-         *            return scope.join().toList();\n+         *            return scope.join();\n@@ -718,0 +776,15 @@\n+         * <p> The following example uses {@code allUntil} to get the results of all\n+         * subtasks that complete successfully within a timeout period.\n+         * {@snippet lang=java :\n+         *    <T> List<T> invokeAll(Collection<Callable<T>> tasks, Duration timeout) throws InterruptedException {\n+         *    try (var scope = StructuredTaskScope.open(Joiner.<T>allUntil(_ -> false), cf -> cf.withTimeout(timeout))) {\n+         *        tasks.forEach(scope::fork);\n+         *        return scope.join()\n+         *                 .stream()\n+         *                 .filter(s -> s.state() == Subtask.State.SUCCESS)\n+         *                 .map(Subtask::get)\n+         *                 .toList();\n+         *         }\n+         *     }\n+         * }\n+         *\n@@ -721,1 +794,1 @@\n-        static <T> Joiner<T, Stream<Subtask<T>>> allUntil(Predicate<Subtask<? extends T>> isDone) {\n+        static <T> Joiner<T, List<Subtask<T>>> allUntil(Predicate<Subtask<T>> isDone) {\n@@ -730,8 +803,2 @@\n-     * ThreadFactory} to create threads, an optional name for the purposes of monitoring\n-     * and management, and an optional timeout.\n-     *\n-     * <p> Creating a {@code StructuredTaskScope} with {@link #open()} or {@link #open(Joiner)}\n-     * uses the <a href=\"StructuredTaskScope.html#DefaultConfiguration\">default\n-     * configuration<\/a>. The default configuration consists of a thread factory that\n-     * creates unnamed <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">\n-     * virtual threads<\/a>, no name for monitoring and management purposes, and no timeout.\n+     * ThreadFactory} to create threads, an optional name for the scope, and an optional\n+     * timeout. The name is intended for monitoring and management purposes.\n@@ -739,2 +806,2 @@\n-     * <p> Creating a {@code StructuredTaskScope} with its 2-arg {@link #open(Joiner, Function)\n-     * open} method allows a different configuration to be used. The function specified\n+     * <p> Creating a {@code StructuredTaskScope} with its 2-arg {@link #open(Joiner, UnaryOperator)\n+     * open} method allows a different configuration to be used. The operator specified\n@@ -742,1 +809,1 @@\n-     * configuration for the {@code StructuredTaskScope} under construction. The function\n+     * configuration for the {@code StructuredTaskScope} under construction. The operator\n@@ -759,4 +826,4 @@\n-         * @apiNote The thread factory will typically create\n-         * <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">virtual threads<\/a>,\n-         * maybe with names for monitoring purposes, an {@linkplain Thread.UncaughtExceptionHandler\n-         * uncaught exception handler}, or other properties configured.\n+         * @apiNote The thread factory will typically create {@linkplain Thread##virtual-threads\n+         * virtual threads}, maybe with names for monitoring purposes, an {@linkplain\n+         * Thread.UncaughtExceptionHandler uncaught exception handler}, or other properties\n+         * configured.\n@@ -769,1 +836,1 @@\n-         * {@return a new {@code Configuration} object with the given name}\n+         * {@return a new {@code Configuration} object with the given scope name}\n@@ -786,0 +853,1 @@\n+         * @see Joiner#onTimeout()\n@@ -812,2 +880,3 @@\n-     * Exception thrown by {@link #join()} if the scope was created with a timeout and\n-     * the timeout expired before or while waiting in {@code join}.\n+     * Exception thrown by {@link #join()} if the scope was opened with a timeout,\n+     * the timeout expired before or while waiting in {@code join}, and the {@link\n+     * Joiner#onTimeout() Joiner.onTimeout} method throws this exception.\n@@ -817,0 +886,1 @@\n+     * @see Joiner#onTimeout()\n@@ -831,2 +901,2 @@\n-     * with configuration that is the result of applying the given function to the\n-     * <a href=\"#DefaultConfiguration\">default configuration<\/a>.\n+     * with configuration that is the result of applying the given operator to the\n+     * {@linkplain ##DefaultConfiguration default configuration}.\n@@ -834,2 +904,2 @@\n-     * <p> The {@code configFunction} is called with the default configuration and returns\n-     * the configuration for the new scope. The function may, for example, set the\n+     * <p> The {@code configOperator} is called with the default configuration and returns\n+     * the configuration for the new scope. The operator may, for example, set the\n@@ -837,2 +907,2 @@\n-     * {@linkplain Configuration#withTimeout(Duration) timeout}. If the function completes\n-     * with an exception or error then it is propagated by this method. If the function\n+     * {@linkplain Configuration#withTimeout(Duration) timeout}. If the operator completes\n+     * with an exception or error then it is propagated by this method. If the operator\n@@ -848,2 +918,3 @@\n-     * {@linkplain #join() joined} then the scope is <a href=\"#Cancallation\">cancelled<\/a>\n-     * and the {@code join} method throws {@link TimeoutException}.\n+     * {@linkplain #join() joined} then the scope is {@linkplain ##Cancellation cancelled}\n+     * and the {@code Joiner}'s {@link Joiner#onTimeout()} method is invoked to throw\n+     * optionally throw {@link TimeoutException TimeoutException}.\n@@ -859,1 +930,1 @@\n-     * @param configFunction a function to produce the configuration\n+     * @param configOperator the operator to produce the configuration\n@@ -863,1 +934,1 @@\n-     * @since 25\n+     * @since 26\n@@ -866,2 +937,2 @@\n-                                                 Function<Configuration, Configuration> configFunction) {\n-        return StructuredTaskScopeImpl.open(joiner, configFunction);\n+                                                 UnaryOperator<Configuration> configOperator) {\n+        return StructuredTaskScopeImpl.open(joiner, configOperator);\n@@ -872,1 +943,1 @@\n-     * scope is created with the <a href=\"#DefaultConfiguration\">default configuration<\/a>.\n+     * scope is created with the {@linkplain ##DefaultConfiguration default configuration}.\n@@ -874,2 +945,2 @@\n-     * <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">virtual threads<\/a>,\n-     * is unnamed for monitoring and management purposes, and has no timeout.\n+     * {@linkplain Thread##irtual-threads virtual threads}, does not name the scope, and\n+     * has no timeout.\n@@ -879,1 +950,1 @@\n-     * joiner and the {@linkplain Function#identity() identity function}.\n+     * joiner and the {@linkplain UnaryOperator#identity() identity operator}.\n@@ -888,1 +959,1 @@\n-        return open(joiner, Function.identity());\n+        return open(joiner, UnaryOperator.identity());\n@@ -900,4 +971,4 @@\n-     * <p> The scope is created with the <a href=\"#DefaultConfiguration\">default\n-     * configuration<\/a>. The default configuration has a {@code ThreadFactory} that creates\n-     * unnamed <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">virtual\n-     * threads<\/a>, is unnamed for monitoring and management purposes, and has no timeout.\n+     * <p> The scope is created with the {@linkplain ##DefaultConfiguration default\n+     * configuration}. The default configuration has a {@code ThreadFactory} that creates\n+     * unnamed {@linkplain Thread##virtual-threads virtual threads}, does not name the\n+     * scope, and has no timeout.\n@@ -908,1 +979,1 @@\n-     * and the {@linkplain Function#identity() identity function}.\n+     * and the {@linkplain UnaryOperator#identity() identity operator}.\n@@ -915,1 +986,1 @@\n-        return open(Joiner.awaitAllSuccessfulOrThrow(), Function.identity());\n+        return open(Joiner.awaitAllSuccessfulOrThrow(), UnaryOperator.identity());\n@@ -929,1 +1000,1 @@\n-     * <a href=\"#Cancallation\">cancelled<\/a>, or {@code onFork} returns {@code true} to\n+     * {@linkplain ##Cancellation cancelled}, or {@code onFork} returns {@code true} to\n@@ -996,1 +1067,1 @@\n-     * the scope to be <a href=\"#Cancallation\">cancelled<\/a>.\n+     * the scope to be {@linkplain ##Cancellation cancelled}.\n@@ -999,6 +1070,13 @@\n-     * scope to be cancelled. If a {@linkplain Configuration#withTimeout(Duration) timeout}\n-     * is configured and the timeout expires before or while waiting, then the scope is\n-     * cancelled and {@link TimeoutException TimeoutException} is thrown. Once finished\n-     * waiting, the {@code Joiner}'s {@link Joiner#result() result()} method is invoked\n-     * to get the result or throw an exception. If the {@code result()} method throws\n-     * then this method throws {@code FailedException} with the exception as the cause.\n+     * scope to be cancelled. Once finished waiting, the {@code Joiner}'s {@link\n+     * Joiner#result() result()} method is invoked to get the result or throw an exception.\n+     * If the {@code result()} method throws then {@code join()} throws\n+     * {@code FailedException} with the exception from the {@code Joiner} as the cause.\n+     *\n+     * <p> If a {@linkplain Configuration#withTimeout(Duration) timeout} is configured,\n+     * and the timeout expires before or while waiting, then the scope is cancelled and\n+     * the {@code Joiner}'s {@link Joiner#onTimeout() onTimeout()} method is invoked\n+     * before calling the {@code Joiner}'s {@code result()} method. If the {@code onTimeout()}\n+     * method throws {@link TimeoutException TimeoutException} (or throws any exception\n+     * or error), then it is propagated by this method. If the {@code onTimeout()} method\n+     * does not throw then the {@code Joiner}'s {@code result()} method is invoked to\n+     * get the result or throw.\n@@ -1006,1 +1084,4 @@\n-     * <p> This method may only be invoked by the scope owner, and only once.\n+     * <p> This method may only be invoked by the scope owner. Once the result or\n+     * exception outcome is obtained, this method may not be invoked again. The only\n+     * case where the method may be called again is where {@code InterruptedException}\n+     * is thrown while waiting.\n@@ -1013,2 +1094,2 @@\n-     * @throws TimeoutException if a timeout is set and the timeout expires before or\n-     * while waiting\n+     * @throws TimeoutException if a timeout is set, the timeout expires before or while\n+     * waiting, and {@link Joiner#onTimeout() Joiner.onTimeout()} throws this exception\n@@ -1021,1 +1102,1 @@\n-     * {@return {@code true} if this scope is <a href=\"#Cancallation\">cancelled<\/a> or in\n+     * {@return {@code true} if this scope is {@linkplain ##Cancellation cancelled} or in\n@@ -1041,1 +1122,1 @@\n-     * <p> This method first <a href=\"#Cancallation\">cancels<\/a> the scope, if not\n+     * <p> This method first {@linkplain ##Cancellation cancels} the scope, if not\n@@ -1044,2 +1125,2 @@\n-     * will continue to wait until the threads finish, before completing with the interrupt\n-     * status set.\n+     * will continue to wait until the threads finish, before completing with the\n+     * {@linkplain Thread#isInterrupted() interrupted status} set.\n@@ -1072,1 +1153,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":237,"deletions":156,"binary":false,"changes":393,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.util.function.Function;\n+import java.util.function.UnaryOperator;\n@@ -34,0 +34,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -46,3 +47,2 @@\n-    \/\/ state, only accessed by owner thread\n-    private static final int ST_NEW            = 0,\n-                             ST_FORKED         = 1,   \/\/ subtasks forked, need to join\n+    \/\/ scope state, set by owner thread, read by any thread\n+    private static final int ST_FORKED         = 1,   \/\/ subtasks forked, need to join\n@@ -52,4 +52,1 @@\n-    private int state;\n-\n-    \/\/ timer task, only accessed by owner thread\n-    private Future<?> timerTask;\n+    private volatile int state;\n@@ -60,0 +57,3 @@\n+    \/\/ timer task, only accessed by owner thread\n+    private Future<?> timerTask;\n+\n@@ -70,1 +70,0 @@\n-        this.state = ST_NEW;\n@@ -79,1 +78,1 @@\n-                                                 Function<Configuration, Configuration> configFunction) {\n+                                                 UnaryOperator<Configuration> configOperator) {\n@@ -82,1 +81,1 @@\n-        var config = (ConfigImpl) configFunction.apply(ConfigImpl.defaultConfig());\n+        var config = (ConfigImpl) configOperator.apply(ConfigImpl.defaultConfig());\n@@ -112,1 +111,1 @@\n-     * Throws IllegalStateException if already joined or scope is closed.\n+     * Returns true if join has been invoked and there is an outcome.\n@@ -114,15 +113,2 @@\n-    private void ensureNotJoined() {\n-        assert Thread.currentThread() == flock.owner();\n-        if (state > ST_FORKED) {\n-            throw new IllegalStateException(\"Already joined or scope is closed\");\n-        }\n-    }\n-\n-    \/**\n-     * Throws IllegalStateException if invoked by the owner thread and the owner thread\n-     * has not joined.\n-     *\/\n-    private void ensureJoinedIfOwner() {\n-        if (Thread.currentThread() == flock.owner() && state <= ST_JOIN_STARTED) {\n-            throw new IllegalStateException(\"join not called\");\n-        }\n+    private boolean isJoinCompleted() {\n+        return state >= ST_JOIN_COMPLETED;\n@@ -187,1 +173,1 @@\n-    private void onComplete(SubtaskImpl<? extends T> subtask) {\n+    private <U extends T> void onComplete(SubtaskImpl<U> subtask) {\n@@ -189,1 +175,3 @@\n-        if (joiner.onComplete(subtask)) {\n+        @SuppressWarnings(\"unchecked\")\n+        var j = (Joiner<U, ? extends R>) joiner;\n+        if (j.onComplete(subtask)) {\n@@ -198,1 +186,4 @@\n-        ensureNotJoined();\n+        int s = state;\n+        if (s > ST_FORKED) {\n+            throw new IllegalStateException(\"join already called or scope is closed\");\n+        }\n@@ -203,1 +194,3 @@\n-        if (joiner.onFork(subtask)) {\n+        @SuppressWarnings(\"unchecked\")\n+        var j = (Joiner<U, ? extends R>) joiner;\n+        if (j.onFork(subtask)) {\n@@ -215,0 +208,1 @@\n+            subtask.setThread(thread);\n@@ -224,1 +218,3 @@\n-        state = ST_FORKED;\n+        if (s < ST_FORKED) {\n+            state = ST_FORKED;\n+        }\n@@ -237,4 +233,3 @@\n-        ensureNotJoined();\n-\n-        \/\/ join started\n-        state = ST_JOIN_STARTED;\n+        if (state >= ST_JOIN_COMPLETED) {\n+            throw new IllegalStateException(\"Already joined or scope is closed\");\n+        }\n@@ -243,5 +238,5 @@\n-        flock.awaitAll();\n-\n-        \/\/ throw if timeout expired\n-        if (timeoutExpired) {\n-            throw new TimeoutException();\n+        try {\n+            flock.awaitAll();\n+        } catch (InterruptedException e) {\n+            state = ST_JOIN_STARTED;  \/\/ joining not completed, prevent new forks\n+            throw e;\n@@ -249,1 +244,0 @@\n-        cancelTimeout();\n@@ -251,1 +245,1 @@\n-        \/\/ all subtasks completed or cancelled\n+        \/\/ all subtasks completed or scope cancelled\n@@ -254,0 +248,8 @@\n+        \/\/ invoke joiner onTimeout if timeout expired\n+        if (timeoutExpired) {\n+            cancel();  \/\/ ensure cancelled before calling onTimeout\n+            joiner.onTimeout();\n+        } else {\n+            cancelTimeout();\n+        }\n+\n@@ -314,0 +316,1 @@\n+        @Stable private Thread thread;\n@@ -320,0 +323,18 @@\n+        \/**\n+         * Sets the thread for this subtask.\n+         *\/\n+        void setThread(Thread thread) {\n+            assert thread.getState() == Thread.State.NEW;\n+            this.thread = thread;\n+        }\n+\n+        \/**\n+         * Throws IllegalStateException if the caller thread is not the subtask and\n+         * the scope owner has not joined.\n+         *\/\n+        private void ensureJoinedIfNotSubtask() {\n+            if (Thread.currentThread() != thread && !scope.isJoinCompleted()) {\n+                throw new IllegalStateException();\n+            }\n+        }\n+\n@@ -322,0 +343,4 @@\n+            if (Thread.currentThread() != thread) {\n+                throw new WrongThreadException();\n+            }\n+\n@@ -358,1 +383,1 @@\n-            scope.ensureJoinedIfOwner();\n+            ensureJoinedIfNotSubtask();\n@@ -373,1 +398,1 @@\n-            scope.ensureJoinedIfOwner();\n+            ensureJoinedIfNotSubtask();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScopeImpl.java","additions":70,"deletions":45,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        @JEP(number=505, title=\"Structured Concurrency\", status=\"Fifth Preview\")\n+        @JEP(number=525, title=\"Structured Concurrency\", status=\"Sixth Preview\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-            public boolean onComplete(Subtask<? extends Boolean> subtask) {\n+            public boolean onComplete(Subtask<Boolean> subtask) {\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/StressCancellation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-import java.util.function.Function;\n@@ -66,0 +65,1 @@\n+import java.util.function.UnaryOperator;\n@@ -212,1 +212,1 @@\n-    void testForkAfterJoin1(ThreadFactory factory) throws Exception {\n+    void testForkAfterJoinCompleted1(ThreadFactory factory) throws Exception {\n@@ -225,1 +225,1 @@\n-    void testForkAfterJoin2(ThreadFactory factory) throws Exception {\n+    void testForkAfterJoinCompleted2(ThreadFactory factory) throws Exception {\n@@ -235,1 +235,1 @@\n-     * Test fork after join throws.\n+     * Test fork after join interrupted.\n@@ -239,1 +239,1 @@\n-    void testForkAfterJoinThrows(ThreadFactory factory) throws Exception {\n+    void testForkAfterJoinInterrupted(ThreadFactory factory) throws Exception {\n@@ -242,1 +242,0 @@\n-            var latch = new CountDownLatch(1);\n@@ -244,1 +243,1 @@\n-                latch.await();\n+                Thread.sleep(Duration.ofDays(1));\n@@ -257,0 +256,19 @@\n+    \/**\n+     * Test fork after join timeout.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkAfterJoinTimeout(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory)\n+                        .withTimeout(Duration.ofMillis(100)))) {\n+            awaitCancelled(scope);\n+\n+            \/\/ join throws\n+            assertThrows(TimeoutException.class, scope::join);\n+\n+            \/\/ fork should throw\n+            assertThrows(IllegalStateException.class, () -> scope.fork(() -> \"bar\"));\n+        }\n+    }\n+\n@@ -299,3 +317,5 @@\n-    @Test\n-    void testForkAfterClose() {\n-        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkAfterClose(ThreadFactory factory) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -369,1 +389,1 @@\n-        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulResultOrThrow())) {\n+        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulOrThrow())) {\n@@ -381,0 +401,27 @@\n+    \/**\n+     * Test join after join interrupted.\n+     *\/\n+    @Test\n+    void testJoinAfterJoinInterrupted() throws Exception {\n+        try (var scope = StructuredTaskScope.open()) {\n+            var latch = new CountDownLatch(1);\n+            var subtask = scope.fork(() -> {\n+                latch.await();\n+                return \"foo\";\n+            });\n+\n+            \/\/ join throws InterruptedException\n+            Thread.currentThread().interrupt();\n+            assertThrows(InterruptedException.class, scope::join);\n+\n+            latch.countDown();\n+\n+            \/\/ retry join to get result\n+            scope.join();\n+            assertEquals(\"foo\", subtask.get());\n+\n+            \/\/ retry after otbaining result\n+            assertThrows(IllegalStateException.class, scope::join);\n+        }\n+    }\n+\n@@ -385,2 +432,2 @@\n-    void testJoinAfterJoin3() throws Exception {\n-        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulResultOrThrow(),\n+    void testJoinAfterJoinTimeout() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulOrThrow(),\n@@ -399,0 +446,29 @@\n+    \/**\n+     * Test join invoked from Joiner.onTimeout.\n+     *\/\n+    @Test\n+    void testJoinInOnTimeout() throws Exception {\n+        Thread owner = Thread.currentThread();\n+        var scopeRef = new AtomicReference<StructuredTaskScope<?, ?>>();\n+\n+        var joiner = new Joiner<String, Void>() {\n+            @Override\n+            public void onTimeout() {\n+                assertTrue(Thread.currentThread() == owner);\n+                var scope = scopeRef.get();\n+                assertThrows(IllegalStateException.class, scope::join);\n+            }\n+            @Override\n+            public Void result() {\n+                return null;\n+            }\n+        };\n+\n+        try (var scope = StructuredTaskScope.open(joiner,\n+                cf -> cf.withTimeout(Duration.ofMillis(100)))) {\n+            awaitCancelled(scope);\n+            scopeRef.set(scope);\n+            scope.join();  \/\/ invokes onTimeout\n+        }\n+    }\n+\n@@ -437,1 +513,1 @@\n-                Thread.sleep(60_000);\n+                Thread.sleep(Duration.ofDays(1));\n@@ -460,2 +536,0 @@\n-\n-            var latch = new CountDownLatch(1);\n@@ -463,1 +537,1 @@\n-                Thread.sleep(60_000);\n+                Thread.sleep(Duration.ofDays(1));\n@@ -882,1 +956,1 @@\n-            public boolean onFork(Subtask<? extends String> subtask) {\n+            public boolean onFork(Subtask<String> subtask) {\n@@ -902,1 +976,1 @@\n-            public boolean onFork(Subtask<? extends String> subtask) {\n+            public boolean onFork(Subtask<String> subtask) {\n@@ -925,1 +999,1 @@\n-            public boolean onComplete(Subtask<? extends String> subtask) {\n+            public boolean onComplete(Subtask<String> subtask) {\n@@ -952,1 +1026,1 @@\n-            public boolean onComplete(Subtask<? extends String> subtask) {\n+            public boolean onComplete(Subtask<String> subtask) {\n@@ -968,0 +1042,60 @@\n+    \/**\n+     * Test Joiner.onTimeout invoked by owner thread when timeout expires.\n+     *\/\n+    @Test\n+    void testOnTimeoutInvoked() throws Exception {\n+        var scopeRef = new AtomicReference<StructuredTaskScope<?, ?>>();\n+        Thread owner = Thread.currentThread();\n+        var invokeCount = new AtomicInteger();\n+        var joiner = new Joiner<String, Void>() {\n+            @Override\n+            public void onTimeout() {\n+                assertTrue(Thread.currentThread() == owner);\n+                assertTrue(scopeRef.get().isCancelled());\n+                invokeCount.incrementAndGet();\n+            }\n+            @Override\n+            public Void result() {\n+                return null;\n+            }\n+        };\n+        try (var scope = StructuredTaskScope.open(joiner,\n+                cf -> cf.withTimeout(Duration.ofMillis(100)))) {\n+            scopeRef.set(scope);\n+            scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+            scope.join();\n+            assertEquals(1, invokeCount.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test Joiner.onTimeout throwing an excepiton.\n+     *\/\n+    @Test\n+    void testOnTimeoutThrows() throws Exception {\n+        var joiner = new Joiner<String, Void>() {\n+            @Override\n+            public void onTimeout() {\n+                throw new FooException();\n+            }\n+            @Override\n+            public Void result() {\n+                return null;\n+            }\n+        };\n+        try (var scope = StructuredTaskScope.open(joiner,\n+                cf -> cf.withTimeout(Duration.ofMillis(100)))) {\n+            \/\/ wait for scope to be cancelled by timeout\n+            awaitCancelled(scope);\n+\n+            \/\/ join should throw FooException on first usage\n+            assertThrows(FooException.class, scope::join);\n+\n+            \/\/ retry after onTimeout fails\n+            assertThrows(IllegalStateException.class, scope::join);\n+        }\n+    }\n+\n@@ -993,1 +1127,0 @@\n-\n@@ -996,1 +1129,1 @@\n-            \/\/ before join\n+            \/\/ before join, owner thread\n@@ -1000,0 +1133,4 @@\n+            \/\/ before join, another thread\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::get));\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::exception));\n+\n@@ -1002,1 +1139,0 @@\n-            \/\/ after join\n@@ -1004,0 +1140,2 @@\n+\n+            \/\/ after join, owner thread\n@@ -1006,0 +1144,4 @@\n+\n+            \/\/ after join, another thread\n+            assertEquals(\"foo\", callInOtherThread(subtask::get));\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::exception));\n@@ -1020,1 +1162,1 @@\n-            \/\/ before join\n+            \/\/ before join, owner thread\n@@ -1024,0 +1166,4 @@\n+            \/\/ before join, another thread\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::get));\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::exception));\n+\n@@ -1026,1 +1172,0 @@\n-            \/\/ after join\n@@ -1028,0 +1173,2 @@\n+\n+            \/\/ after join, owner thread\n@@ -1030,0 +1177,4 @@\n+\n+            \/\/ after join, another thread\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::get));\n+            assertTrue(callInOtherThread(subtask::exception) instanceof FooException);\n@@ -1045,2 +1196,0 @@\n-\n-            \/\/ before join\n@@ -1048,0 +1197,2 @@\n+\n+            \/\/ before join, owner thread\n@@ -1051,0 +1202,4 @@\n+            \/\/ before join, another thread\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::get));\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::exception));\n+\n@@ -1055,1 +1210,0 @@\n-            \/\/ after join\n@@ -1057,0 +1211,2 @@\n+\n+            \/\/ after join, owner thread\n@@ -1059,0 +1215,4 @@\n+\n+            \/\/ before join, another thread\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::get));\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::exception));\n@@ -1074,2 +1234,1 @@\n-            \/\/ before join\n-            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            \/\/ before join, owner thread\n@@ -1079,0 +1238,4 @@\n+            \/\/ before join, another thread\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::get));\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::exception));\n+\n@@ -1081,1 +1244,0 @@\n-            \/\/ after join\n@@ -1083,0 +1245,2 @@\n+\n+            \/\/ after join, owner thread\n@@ -1085,0 +1249,4 @@\n+\n+            \/\/ before join, another thread\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::get));\n+            assertThrows(IllegalStateException.class, () -> callInOtherThread(subtask::exception));\n@@ -1118,2 +1286,2 @@\n-            var subtasks = scope.join().toList();\n-            assertTrue(subtasks.isEmpty());\n+            var results = scope.join();\n+            assertTrue(results.isEmpty());\n@@ -1131,6 +1299,4 @@\n-            var subtask1 = scope.fork(() -> \"foo\");\n-            var subtask2 = scope.fork(() -> \"bar\");\n-            var subtasks = scope.join().toList();\n-            assertEquals(List.of(subtask1, subtask2), subtasks);\n-            assertEquals(\"foo\", subtask1.get());\n-            assertEquals(\"bar\", subtask2.get());\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> \"bar\");\n+            var results = scope.join();\n+            assertEquals(List.of(\"foo\", \"bar\"), results);\n@@ -1160,1 +1326,42 @@\n-     * Test Joiner.anySuccessfulResultOrThrow() with no subtasks.\n+     * Test Joiner.allSuccessfulOrThrow() with a timeout.\n+     *\/\n+    @Test\n+    void testAllSuccessfulOrThrow4() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allSuccessfulOrThrow(),\n+                cf -> cf.withTimeout(Duration.ofMillis(100)))) {\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"bar\";\n+            });\n+            assertThrows(TimeoutException.class, scope::join);\n+\n+            \/\/ retry after join throws TimeoutException\n+            assertThrows(IllegalStateException.class, scope::join);\n+        }\n+    }\n+\n+    \/**\n+     * Test Joiner.allSuccessfulOrThrow() yields an unmodifiable list.\n+     *\/\n+    @Test\n+    void testAllSuccessfulOrThrow5() throws Exception {\n+        \/\/ empty list\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allSuccessfulOrThrow())) {\n+            var results = scope.join();\n+            assertEquals(0, results.size());\n+            assertThrows(UnsupportedOperationException.class, () -> results.add(\"foo\"));\n+        }\n+\n+        \/\/ non-empty list\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allSuccessfulOrThrow())) {\n+            scope.fork(() -> \"foo\");\n+            var results = scope.join();\n+            assertEquals(1, results.size());\n+            assertThrows(UnsupportedOperationException.class, () -> results.add(\"foo\"));\n+            assertThrows(UnsupportedOperationException.class, () -> results.add(\"bar\"));\n+        }\n+    }\n+\n+    \/**\n+     * Test Joiner.anySuccessfulOrThrow() with no subtasks.\n@@ -1163,2 +1370,2 @@\n-    void testAnySuccessfulResultOrThrow1() throws Exception {\n-        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulResultOrThrow())) {\n+    void testAnySuccessfulOrThrow1() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulOrThrow())) {\n@@ -1174,1 +1381,1 @@\n-     * Test Joiner.anySuccessfulResultOrThrow() with a subtask that completes successfully.\n+     * Test Joiner.anySuccessfulOrThrow() with a subtask that completes successfully.\n@@ -1178,2 +1385,2 @@\n-    void testAnySuccessfulResultOrThrow2(ThreadFactory factory) throws Exception {\n-        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulResultOrThrow(),\n+    void testAnySuccessfulOrThrow2(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulOrThrow(),\n@@ -1188,1 +1395,1 @@\n-     * Test Joiner.anySuccessfulResultOrThrow() with a subtask that completes successfully\n+     * Test Joiner.anySuccessfulOrThrow() with a subtask that completes successfully\n@@ -1193,2 +1400,2 @@\n-    void testAnySuccessfulResultOrThrow3(ThreadFactory factory) throws Exception {\n-        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulResultOrThrow(),\n+    void testAnySuccessfulOrThrow3(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulOrThrow(),\n@@ -1203,1 +1410,1 @@\n-     * Test Joiner.anySuccessfulResultOrThrow() with a subtask that complete succcessfully\n+     * Test Joiner.anySuccessfulOrThrow() with a subtask that complete succcessfully\n@@ -1208,2 +1415,2 @@\n-    void testAnySuccessfulResultOrThrow4(ThreadFactory factory) throws Exception {\n-        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulResultOrThrow(),\n+    void testAnySuccessfulOrThrow4(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulOrThrow(),\n@@ -1219,1 +1426,1 @@\n-     * Test Joiner.anySuccessfulResultOrThrow() with a subtask that fails.\n+     * Test Joiner.anySuccessfulOrThrow() with a subtask that fails.\n@@ -1223,2 +1430,2 @@\n-    void testAnySuccessfulResultOrThrow5(ThreadFactory factory) throws Exception {\n-        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulResultOrThrow(),\n+    void testAnySuccessfulOrThrow5(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulOrThrow(),\n@@ -1232,0 +1439,19 @@\n+    \/**\n+     * Test Joiner.anySuccessfulOrThrow() with a timeout.\n+     *\/\n+    @Test\n+    void anySuccessfulOrThrow6() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulOrThrow(),\n+                cf -> cf.withTimeout(Duration.ofMillis(100)))) {\n+            scope.fork(() -> { throw new FooException(); });\n+            scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"bar\";\n+            });\n+            assertThrows(TimeoutException.class, scope::join);\n+\n+            \/\/ retry after join throws TimeoutException\n+            assertThrows(IllegalStateException.class, scope::join);\n+        }\n+    }\n+\n@@ -1279,0 +1505,19 @@\n+    \/**\n+     * Test Joiner.awaitAllSuccessfulOrThrow() with a timeout.\n+     *\/\n+    @Test\n+    void testAwaitSuccessfulOrThrow4() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>awaitAllSuccessfulOrThrow(),\n+                cf -> cf.withTimeout(Duration.ofMillis(100)))) {\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"bar\";\n+            });\n+            assertThrows(TimeoutException.class, scope::join);\n+\n+            \/\/ retry after join throws TimeoutException\n+            assertThrows(IllegalStateException.class, scope::join);\n+        }\n+    }\n+\n@@ -1325,0 +1570,19 @@\n+    \/**\n+     * Test Joiner.awaitAll() with a timeout.\n+     *\/\n+    @Test\n+    void testAwaitAll4() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>awaitAll(),\n+                cf -> cf.withTimeout(Duration.ofMillis(100)))) {\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"bar\";\n+            });\n+            assertThrows(TimeoutException.class, scope::join);\n+\n+            \/\/ retry after join throws TimeoutException\n+            assertThrows(IllegalStateException.class, scope::join);\n+        }\n+    }\n+\n@@ -1332,1 +1596,1 @@\n-            assertEquals(0, subtasks.count());\n+            assertEquals(0, subtasks.size());\n@@ -1348,2 +1612,2 @@\n-            var subtasks = scope.join().toList();\n-            assertEquals(2, subtasks.size());\n+            var subtasks = scope.join();\n+            assertEquals(List.of(subtask1, subtask2), subtasks);\n@@ -1351,2 +1615,0 @@\n-            assertSame(subtask1, subtasks.get(0));\n-            assertSame(subtask2, subtasks.get(1));\n@@ -1373,1 +1635,2 @@\n-            var subtasks = scope.join().toList();\n+            var subtasks = scope.join();\n+            assertEquals(List.of(subtask1, subtask2), subtasks);\n@@ -1375,3 +1638,0 @@\n-            assertEquals(2, subtasks.size());\n-            assertSame(subtask1, subtasks.get(0));\n-            assertSame(subtask2, subtasks.get(1));\n@@ -1391,1 +1651,1 @@\n-        class CancelAfterTwoFailures<T> implements Predicate<Subtask<? extends T>> {\n+        class CancelAfterTwoFailures<T> implements Predicate<Subtask<T>> {\n@@ -1394,1 +1654,1 @@\n-            public boolean test(Subtask<? extends T> subtask) {\n+            public boolean test(Subtask<T> subtask) {\n@@ -1412,1 +1672,1 @@\n-            var subtasks = scope.join().toList();\n+            var subtasks = scope.join();\n@@ -1440,0 +1700,53 @@\n+    \/**\n+     * Test Joiner.allUntil(Predicate) with a timeout.\n+     *\/\n+    @Test\n+    void testAllUntil6() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allUntil(s -> false),\n+                cf -> cf.withTimeout(Duration.ofMillis(100)))) {\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            var subtask2 = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"bar\";\n+            });\n+\n+            \/\/ TimeoutException should not be thrown\n+            var subtasks = scope.join();\n+\n+            \/\/ stream should have two elements, subtask1 may or may not have completed\n+            assertEquals(List.of(subtask1, subtask2), subtasks);\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask2.state());\n+\n+            \/\/ retry after join throws TimeoutException\n+            assertThrows(IllegalStateException.class, scope::join);\n+        }\n+    }\n+\n+    \/**\n+     * Test Joiner.allUntil(Predicate) yields an unmodifiable list.\n+     *\/\n+    @Test\n+    void testAllUntil7() throws Exception {\n+        Subtask<String> subtask1;\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allUntil(s -> false))) {\n+            subtask1 = scope.fork(() -> \"?\");\n+            scope.join();\n+        }\n+\n+        \/\/ empty list\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allUntil(s -> false))) {\n+            var subtasks = scope.join();\n+            assertEquals(0, subtasks.size());\n+            assertThrows(UnsupportedOperationException.class, () -> subtasks.add(subtask1));\n+        }\n+\n+        \/\/ non-empty list\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allUntil(s -> false))) {\n+            var subtask2 = scope.fork(() -> \"foo\");\n+            var subtasks = scope.join();\n+            assertEquals(1, subtasks.size());\n+            assertThrows(UnsupportedOperationException.class, () -> subtasks.add(subtask1));\n+            assertThrows(UnsupportedOperationException.class, () -> subtasks.add(subtask2));\n+        }\n+    }\n+\n@@ -1457,1 +1770,1 @@\n-            Joiner<Object, Void> joiner = () -> null;\n+            Joiner<String, Void> joiner = () -> null;\n@@ -1464,0 +1777,1 @@\n+            assertThrows(TimeoutException.class, joiner::onTimeout);\n@@ -1484,1 +1798,1 @@\n-                    () -> Joiner.anySuccessfulResultOrThrow().onComplete(subtask));\n+                    () -> Joiner.anySuccessfulOrThrow().onComplete(subtask));\n@@ -1500,1 +1814,1 @@\n-                    () -> Joiner.anySuccessfulResultOrThrow().onFork(subtask));\n+                    () -> Joiner.anySuccessfulOrThrow().onFork(subtask));\n@@ -1526,1 +1840,1 @@\n-        Function<Configuration, Configuration> testConfig = cf -> {\n+        UnaryOperator<Configuration> configOperator = cf -> {\n@@ -1551,1 +1865,1 @@\n-        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(), testConfig)) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(), configOperator)) {\n@@ -1600,1 +1914,1 @@\n-                () -> Joiner.anySuccessfulResultOrThrow().onFork(null));\n+                () -> Joiner.anySuccessfulOrThrow().onFork(null));\n@@ -1602,1 +1916,1 @@\n-                () -> Joiner.anySuccessfulResultOrThrow().onComplete(null));\n+                () -> Joiner.anySuccessfulOrThrow().onComplete(null));\n@@ -1632,1 +1946,1 @@\n-        public boolean onFork(Subtask<? extends T> subtask) {\n+        public boolean onFork(Subtask<T> subtask) {\n@@ -1637,1 +1951,1 @@\n-        public boolean onComplete(Subtask<? extends T> subtask) {\n+        public boolean onComplete(Subtask<T> subtask) {\n@@ -1661,1 +1975,1 @@\n-        public boolean onFork(Subtask<? extends T> subtask) {\n+        public boolean onFork(Subtask<T> subtask) {\n@@ -1666,1 +1980,1 @@\n-        public boolean onComplete(Subtask<? extends T> subtask) {\n+        public boolean onComplete(Subtask<T> subtask) {\n@@ -1758,0 +2072,34 @@\n+    \/**\n+     * Calls a result returning task from another thread.\n+     *\/\n+    private <V> V callInOtherThread(Callable<V> task) throws Exception {\n+        var result = new AtomicReference<V>();\n+        var exc = new AtomicReference<Exception>();\n+        Thread thread = Thread.ofVirtual().start(() -> {\n+            try {\n+                result.set(task.call());\n+            } catch (Exception e) {\n+                exc.set(e);\n+            }\n+        });\n+        boolean interrupted = false;\n+        boolean terminated = false;\n+        while (!terminated) {\n+            try {\n+                thread.join();\n+                terminated = true;\n+            } catch (InterruptedException e) {\n+                interrupted = true;\n+            }\n+        }\n+        if (interrupted) {\n+            Thread.currentThread().interrupt();\n+        }\n+        Exception e = exc.get();\n+        if (e != null) {\n+            throw e;\n+        } else {\n+            return result.get();\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/StructuredTaskScopeTest.java","additions":426,"deletions":78,"binary":false,"changes":504,"status":"modified"}]}