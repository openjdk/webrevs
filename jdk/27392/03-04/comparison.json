{"files":[{"patch":"@@ -73,2 +73,2 @@\n-        \/\/ list of forked subtasks, only accessed by owner thread\n-        private final List<Subtask<T>> subtasks = new ArrayList<>();\n+        \/\/ list of forked subtasks, created lazily, only accessed by owner thread\n+        private List<Subtask<T>> subtasks;\n@@ -81,0 +81,3 @@\n+            if (subtasks == null) {\n+                subtasks = new ArrayList<>();\n+            }\n@@ -96,4 +99,9 @@\n-            if (ex != null) {\n-                throw ex;\n-            } else {\n-                return subtasks.stream().map(Subtask::get).toList();\n+            try {\n+                if (ex != null) {\n+                    throw ex;\n+                }\n+                return (subtasks != null)\n+                        ? subtasks.stream().map(Subtask::get).toList()\n+                        : List.of();\n+            } finally {\n+                subtasks = null;  \/\/ allow subtasks to be GC'ed\n@@ -190,2 +198,2 @@\n-        \/\/ list of forked subtasks, only accessed by owner thread\n-        private final List<Subtask<T>> subtasks = new ArrayList<>();\n+        \/\/ list of forked subtasks, created lazily, only accessed by owner thread\n+        private List<Subtask<T>> subtasks;\n@@ -200,0 +208,3 @@\n+            if (subtasks == null) {\n+                subtasks = new ArrayList<>();\n+            }\n@@ -217,1 +228,7 @@\n-            return List.copyOf(subtasks);\n+            if (subtasks != null) {\n+                List<Subtask<T>> result = List.copyOf(subtasks);\n+                subtasks = null;  \/\/ allow subtasks to be GC'ed\n+                return result;\n+            } else {\n+                return List.of();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Joiners.java","additions":26,"deletions":9,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -333,2 +333,7 @@\n- * <i>happen-before<\/i>} any actions taken by that subtask, which in turn\n- * <i>happen-before<\/i> the subtask result is {@linkplain Subtask#get() retrieved}.\n+ * <i>happen-before<\/i>} any actions taken by the thread that executes the subtask, which\n+ * in turn <i>happen-before<\/i> actions in any thread that successfully obtains the\n+ * subtask outcome with {@link Subtask#get() Subtask.get()} or {@link Subtask#exception()\n+ * Subtask.exception()}. If a subtask's outcome contributes to the result or exception\n+ * from {@link #join()}, then any actions taken by the thread executing that subtask\n+ * <i>happen-before<\/i> the owner thread returns from {@code join} with a result or\n+ * {@link FailedException FailedException}.\n@@ -500,2 +505,3 @@\n-     * threads concurrently. The {@link #onTimeout()} method may be invoked at around\n-     * the same time that subtasks complete.\n+     * threads concurrently, concurrently with the owner thread invoking the {@link\n+     * #onFork(Subtask)} method, or if a timeout is configured, concurrently with the owner\n+     * thread invoking the {@link #onTimeout()} method.\n@@ -597,3 +603,1 @@\n-         * invoked directly, and invoked more than once, is undefined. Where possible, an\n-         * implementation should return an equal result (or throw the same exception) on\n-         * second or subsequent calls to produce the outcome.\n+         * invoked directly is undefined.\n@@ -1121,2 +1125,2 @@\n-     * will continue to wait until the threads finish, before completing with the interrupt\n-     * status set.\n+     * will continue to wait until the threads finish, before completing with the\n+     * {@linkplain Thread#isInterrupted() interrupted status} set.\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"}]}