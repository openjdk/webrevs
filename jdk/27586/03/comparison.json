{"files":[{"patch":"@@ -1929,2 +1929,12 @@\n-    \/\/ Zero-trip test uses an 'opaque' node which is not shared.\n-    assert(opaq->outcnt() == 1 && opaq->in(1) == limit, \"\");\n+    \/\/ Zero-trip test uses an 'opaque' node which is not shared, otherwise bailout.\n+    if (opaq->outcnt() != 1 || opaq->in(1) != limit) {\n+#ifdef ASSERT\n+      \/\/ In rare cases, loop cloning (as for peeling, for instance) can break this,\n+      \/\/ but IGVN should clean it up. Let's try to detect we are in such a case.\n+      Unique_Node_List& worklist = loop->_phase->_igvn._worklist;\n+      assert(C->major_progress(), \"The operation that replaced limit and opaq->in(1) (e.g. peeling) should have set major_progress\");\n+      assert(opaq->in(1)->is_Phi() && limit->is_Phi(), \"Nodes limit and opaq->in(1) should have been replaced by PhiNodes by fix_data_uses from clone_loop.\");\n+      assert(worklist.member(opaq->in(1)) && worklist.member(limit), \"Nodes limit and opaq->in(1) differ and should have been recorded for IGVN.\");\n+#endif\n+      return;\n+    }\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361608\n+ * @summary assert in do_unroll does not hold in some cases when peeling comes\n+ *          just before unrolling. It seems to happen only with stress peeling\n+ *\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ *                   -XX:+StressLoopPeeling\n+ *                   -XX:CompileCommand=compileonly,compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling::test\n+ *                   -XX:-TieredCompilation\n+ *                   -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling\n+ * @run main compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling\n+ *\/\n+package compiler.loopopts;\n+\n+public class TooStrictAssertForUnrollAfterStressPeeling {\n+    public static void main(String[] args) {\n+        for (int i = 1; i < 1000; i++) {\n+            test();\n+        }\n+    }\n+\n+    static long test() {\n+        int s = 0;\n+        int iArr[] = new int[400];\n+        for (int i = 0; i < 70; i++) {}\n+\n+        for (int i = 0; i < 36; i++) {\n+            for (int j = 0; j < 3; j++) {\n+                s += iArr[0] = 7;\n+                if (s != 0) {\n+                    return s + foo(iArr);\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    public static long foo(int[] a) {\n+        long sum = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TooStrictAssertForUnrollAfterStressPeeling.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361608\n+ * @summary assert in do_unroll does not hold in some cases when peeling comes\n+ *          just before unrolling. It seems to happen only with stress peeling\n+ *\n+ * @run main\/othervm -XX:CompileOnly=compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling2::test\n+ *                   -XX:-TieredCompilation\n+ *                   -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=inline,compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling2::foo\n+ *                   compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling2\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361608\n+ * @summary assert in do_unroll does not hold in some cases when peeling comes\n+ *          just before unrolling. It seems to happen only with stress peeling\n+ * @run main\/othervm -XX:CompileOnly=compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling2::test\n+ *                   -XX:-TieredCompilation\n+ *                   -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:-LoopMultiversioning\n+ *                   -XX:-RangeCheckElimination\n+ *                   -XX:-SplitIfBlocks\n+ *                   -XX:-UseOnStackReplacement\n+ *                   -XX:LoopMaxUnroll=2\n+ *                   -XX:CompileCommand=inline,compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling2::foo\n+ *                   compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling2\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361608\n+ * @summary assert in do_unroll does not hold in some cases when peeling comes\n+ *          just before unrolling. It seems to happen only with stress peeling\n+ * @run main compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling2\n+ *\/\n+package compiler.loopopts;\n+\n+public class TooStrictAssertForUnrollAfterStressPeeling2 {\n+    static int iArr[] = new int[400];\n+    static boolean flag;\n+\n+    public static void main(String[] args) {\n+        for (int i = 1; i < 10000; i++) {\n+            test();\n+        }\n+    }\n+\n+    \/\/ Lx: Optimized in loop opts round x.\n+\n+    static int test() {\n+        int x = 5;\n+        for (int i = 1; i < 37; i++) { \/\/ L3: Peeled\n+            for (int a = 0; a < 2; a++) { \/\/ L2: Max unrolled\n+                for (int b = 0; b < 300; b++) {} \/\/ L1: Empty -> removed\n+            }\n+            int j = 1;\n+            x *= 12;\n+            while (++j < 5) { \/\/ L1: Max unrolled: peel + unroll\n+                iArr[0] += 2;\n+                if (iArr[0] > 0) {\n+                    \/\/ foo(): everything outside loop.\n+                    return foo(iArr);\n+                }\n+            }\n+        }\n+        return 3;\n+    }\n+\n+    public static int foo(int[] a) {\n+        int sum = 0;\n+        for (int i = 0; i < a.length; i++) { \/\/ L2: Pre\/main\/post, L3: Unrolled -> hit assert!\n+            for (int j = 0; j < 34; j++) {} \/\/ L1: Empty -> removed\n+            if (flag) {\n+                \/\/ Ensure not directly unrolled in L2 but only in L3.\n+                return 3;\n+            }\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TooStrictAssertForUnrollAfterStressPeeling2.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361608\n+ * @summary assert in do_unroll does not hold in some cases when peeling comes\n+ *          just before unrolling. It seems to happen only with stress peeling\n+ *\n+ * @run main\/othervm -XX:CompileOnly=compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling3::test\n+ *                   -XX:-TieredCompilation\n+ *                   -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=inline,compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling3::foo\n+ *                   -XX:-RangeCheckElimination\n+ *                   compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling3\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361608\n+ * @summary assert in do_unroll does not hold in some cases when peeling comes\n+ *          just before unrolling. It seems to happen only with stress peeling\n+ * @run main\/othervm -XX:CompileOnly=compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling3::test\n+ *                   -XX:-TieredCompilation\n+ *                   -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:-LoopMultiversioning\n+ *                   -XX:-RangeCheckElimination\n+ *                   -XX:-SplitIfBlocks\n+ *                   -XX:-UseOnStackReplacement\n+ *                   -XX:LoopMaxUnroll=2\n+ *                   -XX:CompileCommand=inline,compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling3::foo\n+ *                   compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling3\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361608\n+ * @summary assert in do_unroll does not hold in some cases when peeling comes\n+ *          just before unrolling. It seems to happen only with stress peeling\n+ * @run main compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling3\n+ *\/\n+package compiler.loopopts;\n+\n+public class TooStrictAssertForUnrollAfterStressPeeling3 {\n+    static int iArr[] = new int[400];\n+    static boolean flag;\n+\n+    public static void main(String[] args) {\n+        for (int i = 1; i < 10000; i++) {\n+            test();\n+        }\n+    }\n+\n+    \/\/ Lx: Optimized in loop opts round x.\n+\n+    static int test() {\n+        int x = 5;\n+        for (int i = 1; i < 37; i++) { \/\/ L3: Peeled\n+            for (int a = 0; a < 2; a++) { \/\/ L2: Max unrolled\n+                for (int b = 0; b < 300; b++) {} \/\/ L1: Empty -> removed\n+            }\n+            int j = 1;\n+            x *= 12;\n+            while (++j < 5) { \/\/ L1: Max unrolled: peel + unroll\n+                iArr[0] += 2;\n+                if (iArr[0] > 0) {\n+                    \/\/ foo(): everything outside loop.\n+                    return foo(iArr, x);\n+                }\n+            }\n+        }\n+        return 3;\n+    }\n+\n+    public static int foo(int[] a, int limit) {\n+        int sum = 0;\n+        for (int i = 0; i < limit; i++) { \/\/ L2: Pre\/main\/post, L3: Unrolled -> hit assert!\n+            for (int j = 0; j < 34; j++) {} \/\/ L1: Empty -> removed\n+            if (flag) {\n+                \/\/ Ensure not directly unrolled in L2 but only in L3.\n+                return 3;\n+            }\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TooStrictAssertForUnrollAfterStressPeeling3.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"}]}