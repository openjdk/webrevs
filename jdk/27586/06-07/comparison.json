{"files":[{"patch":"@@ -1929,1 +1929,1 @@\n-    \/\/ Zero-trip test uses an 'opaque' node which is not shared, otherwise bailout.\n+    \/\/ Zero-trip test uses an 'opaque' node which is not shared, otherwise bail out.\n@@ -1932,2 +1932,3 @@\n-      \/\/ In rare cases, loop cloning (as for peeling, for instance) can break this,\n-      \/\/ but IGVN should clean it up. Let's try to detect we are in such a case.\n+      \/\/ In rare cases, loop cloning (as for peeling, for instance) can break this by replacing\n+      \/\/ limit and the input of opaq by equivalent but distinct phis.\n+      \/\/ Next IGVN should clean it up. Let's try to detect we are in such a case.\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4770,7 +4770,8 @@\n-        \/\/ This property is desirable, but it maybe not hold after cloning a loop.\n-        \/\/ In such a case, we bail out from unrolling, and rely on IGVN to cleanup stuff.\n-        \/\/ We are here before loop cloning (before iteration_split), so if there is a\n-        \/\/ mess, it must come from the previous round of loop optimizations, which is bad.\n-        \/\/ On the other hand, if this assert passes, bailing out in do_unroll means that\n-        \/\/ this property was broken in the current round of loop optimization, which is\n-        \/\/ acceptable.\n+        \/\/ This property is required in do_unroll, but it may not hold after cloning a loop.\n+        \/\/ In such a case, we bail out from unrolling, and rely on IGVN to clean up the graph.\n+        \/\/ We are here before loop cloning (before iteration_split), so if this property\n+        \/\/ does not hold, it must come from the previous round of loop optimizations, meaning\n+        \/\/ that IGVN failed to clean it: we will catch that here.\n+        \/\/ On the other hand, if this assert passes, a bailout in do_unroll means that\n+        \/\/ this property was broken in the current round of loop optimization (between here\n+        \/\/ and do_unroll), so we give a chance to IGVN to make the property true again.\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n- * @summary assert in do_unroll does not hold in some cases when peeling comes\n- *          just before unrolling. It seems to happen only with stress peeling\n+ * @summary crash during unrolling in some rare cases where loop cloning\n+ *          (typically from peeling) breaks an invariant in do_unroll\n@@ -32,1 +32,1 @@\n- *                   -XX:CompileCommand=compileonly,compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling::test\n+ *                   -XX:CompileCommand=compileonly,compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling::test1\n@@ -37,0 +37,42 @@\n+ *\n+ * @run main\/othervm -XX:CompileOnly=compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling::test2\n+ *                   -XX:-TieredCompilation\n+ *                   -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=inline,compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling::foo2\n+ *                   compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling\n+ *\n+ * @run main\/othervm -XX:CompileOnly=compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling::test2\n+ *                   -XX:-TieredCompilation\n+ *                   -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:-LoopMultiversioning\n+ *                   -XX:-RangeCheckElimination\n+ *                   -XX:-SplitIfBlocks\n+ *                   -XX:-UseOnStackReplacement\n+ *                   -XX:LoopMaxUnroll=2\n+ *                   -XX:CompileCommand=inline,compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling::foo2\n+ *                   compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling\n+ *\n+ * @run main\/othervm -XX:CompileOnly=compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling::test3\n+ *                   -XX:-TieredCompilation\n+ *                   -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=inline,compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling::foo3\n+ *                   -XX:-RangeCheckElimination\n+ *                   compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling\n+ *\n+ * @run main\/othervm -XX:CompileOnly=compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling::test3\n+ *                   -XX:-TieredCompilation\n+ *                   -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:-LoopMultiversioning\n+ *                   -XX:-RangeCheckElimination\n+ *                   -XX:-SplitIfBlocks\n+ *                   -XX:-UseOnStackReplacement\n+ *                   -XX:LoopMaxUnroll=2\n+ *                   -XX:CompileCommand=inline,compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling::foo3\n+ *                   compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling\n+ *\n@@ -42,0 +84,3 @@\n+    static int iArr[] = new int[400];\n+    static boolean flag;\n+\n@@ -43,0 +88,8 @@\n+        run1();\n+        run2();\n+        run3();\n+    }\n+\n+    \/\/ Case 1\n+\n+    public static void run1() {\n@@ -44,1 +97,1 @@\n-            test();\n+            test1();\n@@ -48,1 +101,1 @@\n-    static long test() {\n+    static long test1() {\n@@ -57,1 +110,1 @@\n-                    return s + foo(iArr);\n+                    return s + foo1(iArr);\n@@ -64,1 +117,1 @@\n-    public static long foo(int[] a) {\n+    public static long foo1(int[] a) {\n@@ -71,0 +124,86 @@\n+\n+    \/\/ Case 2\n+\n+    public static void run2() {\n+        for (int i = 1; i < 10000; i++) {\n+            test2();\n+        }\n+    }\n+\n+    \/\/ Lx: Optimized in loop opts round x.\n+\n+    static int test2() {\n+        int x = 5;\n+        for (int i = 1; i < 37; i++) { \/\/ L3: Peeled\n+            for (int a = 0; a < 2; a++) { \/\/ L2: Max unrolled\n+                for (int b = 0; b < 300; b++) {\n+                } \/\/ L1: Empty -> removed\n+            }\n+            int j = 1;\n+            x *= 12;\n+            while (++j < 5) { \/\/ L1: Max unrolled: peel + unroll\n+                iArr[0] += 2;\n+                if (iArr[0] > 0) {\n+                    \/\/ foo(): everything outside loop.\n+                    return foo2(iArr);\n+                }\n+            }\n+        }\n+        return 3;\n+    }\n+\n+    public static int foo2(int[] a) {\n+        int sum = 0;\n+        for (int i = 0; i < a.length; i++) { \/\/ L2: Pre\/main\/post, L3: Unrolled -> hit assert!\n+            for (int j = 0; j < 34; j++) {\n+            } \/\/ L1: Empty -> removed\n+            if (flag) {\n+                \/\/ Ensure not directly unrolled in L2 but only in L3.\n+                return 3;\n+            }\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+\n+    public static void run3() {\n+        for (int i = 1; i < 10000; i++) {\n+            test3();\n+        }\n+    }\n+\n+    \/\/ Case 3\n+\n+    static int test3() {\n+        int x = 5;\n+        for (int i = 1; i < 37; i++) { \/\/ L3: Peeled\n+            for (int a = 0; a < 2; a++) { \/\/ L2: Max unrolled\n+                for (int b = 0; b < 300; b++) {\n+                } \/\/ L1: Empty -> removed\n+            }\n+            int j = 1;\n+            x *= 12;\n+            while (++j < 5) { \/\/ L1: Max unrolled: peel + unroll\n+                iArr[0] += 2;\n+                if (iArr[0] > 0) {\n+                    \/\/ foo(): everything outside loop.\n+                    return foo3(iArr, x);\n+                }\n+            }\n+        }\n+        return 3;\n+    }\n+\n+    public static int foo3(int[] a, int limit) {\n+        int sum = 0;\n+        for (int i = 0; i < limit; i++) { \/\/ L2: Pre\/main\/post, L3: Unrolled -> hit assert!\n+            for (int j = 0; j < 34; j++) {\n+            } \/\/ L1: Empty -> removed\n+            if (flag) {\n+                \/\/ Ensure not directly unrolled in L2 but only in L3.\n+                return 3;\n+            }\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TooStrictAssertForUnrollAfterStressPeeling.java","additions":146,"deletions":7,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -1,109 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8361608\n- * @summary assert in do_unroll does not hold in some cases when peeling comes\n- *          just before unrolling. It seems to happen only with stress peeling\n- *\n- * @run main\/othervm -XX:CompileOnly=compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling2::test\n- *                   -XX:-TieredCompilation\n- *                   -Xbatch\n- *                   -XX:PerMethodTrapLimit=0\n- *                   -XX:CompileCommand=inline,compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling2::foo\n- *                   compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling2\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8361608\n- * @summary assert in do_unroll does not hold in some cases when peeling comes\n- *          just before unrolling. It seems to happen only with stress peeling\n- * @run main\/othervm -XX:CompileOnly=compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling2::test\n- *                   -XX:-TieredCompilation\n- *                   -Xbatch\n- *                   -XX:PerMethodTrapLimit=0\n- *                   -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:-LoopMultiversioning\n- *                   -XX:-RangeCheckElimination\n- *                   -XX:-SplitIfBlocks\n- *                   -XX:-UseOnStackReplacement\n- *                   -XX:LoopMaxUnroll=2\n- *                   -XX:CompileCommand=inline,compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling2::foo\n- *                   compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling2\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8361608\n- * @summary assert in do_unroll does not hold in some cases when peeling comes\n- *          just before unrolling. It seems to happen only with stress peeling\n- * @run main compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling2\n- *\/\n-package compiler.loopopts;\n-\n-public class TooStrictAssertForUnrollAfterStressPeeling2 {\n-    static int iArr[] = new int[400];\n-    static boolean flag;\n-\n-    public static void main(String[] args) {\n-        for (int i = 1; i < 10000; i++) {\n-            test();\n-        }\n-    }\n-\n-    \/\/ Lx: Optimized in loop opts round x.\n-\n-    static int test() {\n-        int x = 5;\n-        for (int i = 1; i < 37; i++) { \/\/ L3: Peeled\n-            for (int a = 0; a < 2; a++) { \/\/ L2: Max unrolled\n-                for (int b = 0; b < 300; b++) {} \/\/ L1: Empty -> removed\n-            }\n-            int j = 1;\n-            x *= 12;\n-            while (++j < 5) { \/\/ L1: Max unrolled: peel + unroll\n-                iArr[0] += 2;\n-                if (iArr[0] > 0) {\n-                    \/\/ foo(): everything outside loop.\n-                    return foo(iArr);\n-                }\n-            }\n-        }\n-        return 3;\n-    }\n-\n-    public static int foo(int[] a) {\n-        int sum = 0;\n-        for (int i = 0; i < a.length; i++) { \/\/ L2: Pre\/main\/post, L3: Unrolled -> hit assert!\n-            for (int j = 0; j < 34; j++) {} \/\/ L1: Empty -> removed\n-            if (flag) {\n-                \/\/ Ensure not directly unrolled in L2 but only in L3.\n-                return 3;\n-            }\n-            sum += a[i];\n-        }\n-        return sum;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TooStrictAssertForUnrollAfterStressPeeling2.java","additions":0,"deletions":109,"binary":false,"changes":109,"status":"deleted"},{"patch":"@@ -1,110 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8361608\n- * @summary assert in do_unroll does not hold in some cases when peeling comes\n- *          just before unrolling. It seems to happen only with stress peeling\n- *\n- * @run main\/othervm -XX:CompileOnly=compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling3::test\n- *                   -XX:-TieredCompilation\n- *                   -Xbatch\n- *                   -XX:PerMethodTrapLimit=0\n- *                   -XX:CompileCommand=inline,compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling3::foo\n- *                   -XX:-RangeCheckElimination\n- *                   compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling3\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8361608\n- * @summary assert in do_unroll does not hold in some cases when peeling comes\n- *          just before unrolling. It seems to happen only with stress peeling\n- * @run main\/othervm -XX:CompileOnly=compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling3::test\n- *                   -XX:-TieredCompilation\n- *                   -Xbatch\n- *                   -XX:PerMethodTrapLimit=0\n- *                   -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:-LoopMultiversioning\n- *                   -XX:-RangeCheckElimination\n- *                   -XX:-SplitIfBlocks\n- *                   -XX:-UseOnStackReplacement\n- *                   -XX:LoopMaxUnroll=2\n- *                   -XX:CompileCommand=inline,compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling3::foo\n- *                   compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling3\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8361608\n- * @summary assert in do_unroll does not hold in some cases when peeling comes\n- *          just before unrolling. It seems to happen only with stress peeling\n- * @run main compiler.loopopts.TooStrictAssertForUnrollAfterStressPeeling3\n- *\/\n-package compiler.loopopts;\n-\n-public class TooStrictAssertForUnrollAfterStressPeeling3 {\n-    static int iArr[] = new int[400];\n-    static boolean flag;\n-\n-    public static void main(String[] args) {\n-        for (int i = 1; i < 10000; i++) {\n-            test();\n-        }\n-    }\n-\n-    \/\/ Lx: Optimized in loop opts round x.\n-\n-    static int test() {\n-        int x = 5;\n-        for (int i = 1; i < 37; i++) { \/\/ L3: Peeled\n-            for (int a = 0; a < 2; a++) { \/\/ L2: Max unrolled\n-                for (int b = 0; b < 300; b++) {} \/\/ L1: Empty -> removed\n-            }\n-            int j = 1;\n-            x *= 12;\n-            while (++j < 5) { \/\/ L1: Max unrolled: peel + unroll\n-                iArr[0] += 2;\n-                if (iArr[0] > 0) {\n-                    \/\/ foo(): everything outside loop.\n-                    return foo(iArr, x);\n-                }\n-            }\n-        }\n-        return 3;\n-    }\n-\n-    public static int foo(int[] a, int limit) {\n-        int sum = 0;\n-        for (int i = 0; i < limit; i++) { \/\/ L2: Pre\/main\/post, L3: Unrolled -> hit assert!\n-            for (int j = 0; j < 34; j++) {} \/\/ L1: Empty -> removed\n-            if (flag) {\n-                \/\/ Ensure not directly unrolled in L2 but only in L3.\n-                return 3;\n-            }\n-            sum += a[i];\n-        }\n-        return sum;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TooStrictAssertForUnrollAfterStressPeeling3.java","additions":0,"deletions":110,"binary":false,"changes":110,"status":"deleted"}]}