{"files":[{"patch":"@@ -1929,2 +1929,13 @@\n-    \/\/ Zero-trip test uses an 'opaque' node which is not shared.\n-    assert(opaq->outcnt() == 1 && opaq->in(1) == limit, \"\");\n+    \/\/ Zero-trip test uses an 'opaque' node which is not shared, otherwise bail out.\n+    if (opaq->outcnt() != 1 || opaq->in(1) != limit) {\n+#ifdef ASSERT\n+      \/\/ In rare cases, loop cloning (as for peeling, for instance) can break this by replacing\n+      \/\/ limit and the input of opaq by equivalent but distinct phis.\n+      \/\/ Next IGVN should clean it up. Let's try to detect we are in such a case.\n+      Unique_Node_List& worklist = loop->_phase->_igvn._worklist;\n+      assert(C->major_progress(), \"The operation that replaced limit and opaq->in(1) (e.g. peeling) should have set major_progress\");\n+      assert(opaq->in(1)->is_Phi() && limit->is_Phi(), \"Nodes limit and opaq->in(1) should have been replaced by PhiNodes by fix_data_uses from clone_loop.\");\n+      assert(worklist.member(opaq->in(1)) && worklist.member(limit), \"Nodes limit and opaq->in(1) differ and should have been recorded for IGVN.\");\n+#endif\n+      return;\n+    }\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -4768,0 +4768,18 @@\n+#ifdef ASSERT\n+        \/\/ See PhaseIdealLoop::do_unroll\n+        \/\/ This property is required in do_unroll, but it may not hold after cloning a loop.\n+        \/\/ In such a case, we bail out from unrolling, and rely on IGVN to clean up the graph.\n+        \/\/ We are here before loop cloning (before iteration_split), so if this property\n+        \/\/ does not hold, it must come from the previous round of loop optimizations, meaning\n+        \/\/ that IGVN failed to clean it: we will catch that here.\n+        \/\/ On the other hand, if this assert passes, a bailout in do_unroll means that\n+        \/\/ this property was broken in the current round of loop optimization (between here\n+        \/\/ and do_unroll), so we give a chance to IGVN to make the property true again.\n+        if (head->is_main_loop()) {\n+          assert(opaque->outcnt() == 1, \"opaque node should not be shared\");\n+          assert(opaque->in(1) == head->limit(), \"After IGVN cleanup, input of opaque node must be the limit.\");\n+        }\n+        if (head->is_post_loop()) {\n+          assert(opaque->outcnt() == 1, \"opaque node should not be shared\");\n+        }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361608\n+ * @summary crash during unrolling in some rare cases where loop cloning\n+ *          (typically from peeling) breaks an invariant in do_unroll\n+ *\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ *                   -XX:+StressLoopPeeling\n+ *                   -XX:CompileCommand=compileonly,compiler.loopopts.TooStrictAssertForUnrollAfterPeeling::test1\n+ *                   -XX:-TieredCompilation\n+ *                   -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   compiler.loopopts.TooStrictAssertForUnrollAfterPeeling\n+ *\n+ * @run main\/othervm -XX:CompileOnly=compiler.loopopts.TooStrictAssertForUnrollAfterPeeling::test2\n+ *                   -XX:-TieredCompilation\n+ *                   -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=inline,compiler.loopopts.TooStrictAssertForUnrollAfterPeeling::foo2\n+ *                   compiler.loopopts.TooStrictAssertForUnrollAfterPeeling\n+ *\n+ * @run main\/othervm -XX:CompileOnly=compiler.loopopts.TooStrictAssertForUnrollAfterPeeling::test2\n+ *                   -XX:-TieredCompilation\n+ *                   -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:-LoopMultiversioning\n+ *                   -XX:-RangeCheckElimination\n+ *                   -XX:-SplitIfBlocks\n+ *                   -XX:-UseOnStackReplacement\n+ *                   -XX:LoopMaxUnroll=2\n+ *                   -XX:CompileCommand=inline,compiler.loopopts.TooStrictAssertForUnrollAfterPeeling::foo2\n+ *                   compiler.loopopts.TooStrictAssertForUnrollAfterPeeling\n+ *\n+ * @run main\/othervm -XX:CompileOnly=compiler.loopopts.TooStrictAssertForUnrollAfterPeeling::test3\n+ *                   -XX:-TieredCompilation\n+ *                   -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=inline,compiler.loopopts.TooStrictAssertForUnrollAfterPeeling::foo3\n+ *                   -XX:-RangeCheckElimination\n+ *                   compiler.loopopts.TooStrictAssertForUnrollAfterPeeling\n+ *\n+ * @run main\/othervm -XX:CompileOnly=compiler.loopopts.TooStrictAssertForUnrollAfterPeeling::test3\n+ *                   -XX:-TieredCompilation\n+ *                   -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:-LoopMultiversioning\n+ *                   -XX:-RangeCheckElimination\n+ *                   -XX:-SplitIfBlocks\n+ *                   -XX:-UseOnStackReplacement\n+ *                   -XX:LoopMaxUnroll=2\n+ *                   -XX:CompileCommand=inline,compiler.loopopts.TooStrictAssertForUnrollAfterPeeling::foo3\n+ *                   compiler.loopopts.TooStrictAssertForUnrollAfterPeeling\n+ *\n+ * @run main compiler.loopopts.TooStrictAssertForUnrollAfterPeeling\n+ *\/\n+package compiler.loopopts;\n+\n+public class TooStrictAssertForUnrollAfterPeeling {\n+    static int iArr[] = new int[400];\n+    static boolean flag;\n+\n+    public static void main(String[] args) {\n+        run1();\n+        run2();\n+        run3();\n+    }\n+\n+    \/\/ Case 1\n+\n+    public static void run1() {\n+        for (int i = 1; i < 1000; i++) {\n+            test1();\n+        }\n+    }\n+\n+    static long test1() {\n+        int s = 0;\n+        int iArr[] = new int[400];\n+        for (int i = 0; i < 70; i++) {}\n+\n+        for (int i = 0; i < 36; i++) {\n+            for (int j = 0; j < 3; j++) {\n+                s += iArr[0] = 7;\n+                if (s != 0) {\n+                    return s + foo1(iArr);\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    public static long foo1(int[] a) {\n+        long sum = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+\n+    \/\/ Case 2\n+\n+    public static void run2() {\n+        for (int i = 1; i < 10000; i++) {\n+            test2();\n+        }\n+    }\n+\n+    \/\/ Lx: Optimized in loop opts round x.\n+\n+    static int test2() {\n+        int x = 5;\n+        for (int i = 1; i < 37; i++) { \/\/ L3: Peeled\n+            for (int a = 0; a < 2; a++) { \/\/ L2: Max unrolled\n+                for (int b = 0; b < 300; b++) {\n+                } \/\/ L1: Empty -> removed\n+            }\n+            int j = 1;\n+            x *= 12;\n+            while (++j < 5) { \/\/ L1: Max unrolled: peel + unroll\n+                iArr[0] += 2;\n+                if (iArr[0] > 0) {\n+                    \/\/ foo(): everything outside loop.\n+                    return foo2(iArr);\n+                }\n+            }\n+        }\n+        return 3;\n+    }\n+\n+    public static int foo2(int[] a) {\n+        int sum = 0;\n+        for (int i = 0; i < a.length; i++) { \/\/ L2: Pre\/main\/post, L3: Unrolled -> hit assert!\n+            for (int j = 0; j < 34; j++) {\n+            } \/\/ L1: Empty -> removed\n+            if (flag) {\n+                \/\/ Ensure not directly unrolled in L2 but only in L3.\n+                return 3;\n+            }\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+\n+    public static void run3() {\n+        for (int i = 1; i < 10000; i++) {\n+            test3();\n+        }\n+    }\n+\n+    \/\/ Case 3\n+\n+    static int test3() {\n+        int x = 5;\n+        for (int i = 1; i < 37; i++) { \/\/ L3: Peeled\n+            for (int a = 0; a < 2; a++) { \/\/ L2: Max unrolled\n+                for (int b = 0; b < 300; b++) {\n+                } \/\/ L1: Empty -> removed\n+            }\n+            int j = 1;\n+            x *= 12;\n+            while (++j < 5) { \/\/ L1: Max unrolled: peel + unroll\n+                iArr[0] += 2;\n+                if (iArr[0] > 0) {\n+                    \/\/ foo(): everything outside loop.\n+                    return foo3(iArr, x);\n+                }\n+            }\n+        }\n+        return 3;\n+    }\n+\n+    public static int foo3(int[] a, int limit) {\n+        int sum = 0;\n+        for (int i = 0; i < limit; i++) { \/\/ L2: Pre\/main\/post, L3: Unrolled -> hit assert!\n+            for (int j = 0; j < 34; j++) {\n+            } \/\/ L1: Empty -> removed\n+            if (flag) {\n+                \/\/ Ensure not directly unrolled in L2 but only in L3.\n+                return 3;\n+            }\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TooStrictAssertForUnrollAfterPeeling.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"}]}