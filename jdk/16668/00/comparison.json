{"files":[{"patch":"@@ -1668,1 +1668,1 @@\n-                    !areDisjoint((ClassSymbol)t.tsym, (ClassSymbol)s.tsym);\n+                    !(new DisjointChecker().areDisjoint((ClassSymbol)t.tsym, (ClassSymbol)s.tsym));\n@@ -1673,11 +1673,6 @@\n-        private boolean areDisjoint(ClassSymbol ts, ClassSymbol ss) {\n-            if (isSubtype(erasure(ts.type), erasure(ss.type))) {\n-                return false;\n-            }\n-            \/\/ if both are classes or both are interfaces, shortcut\n-            if (ts.isInterface() == ss.isInterface() && isSubtype(erasure(ss.type), erasure(ts.type))) {\n-                return false;\n-            }\n-            if (ts.isInterface() && !ss.isInterface()) {\n-                \/* so ts is interface but ss is a class\n-                 * an interface is disjoint from a class if the class is disjoint form the interface\n+        class DisjointChecker {\n+            Set<Pair<ClassSymbol, ClassSymbol>> pairsSeen = new HashSet<>();\n+            private boolean areDisjoint(ClassSymbol ts, ClassSymbol ss) {\n+                Pair<ClassSymbol, ClassSymbol> newPair = new Pair<>(ts, ss);\n+                \/* if we are seeing the same pair again then there is an issue with the sealed hierarchy\n+                 * bail out, a detailed error will be reported downstream\n@@ -1685,12 +1680,30 @@\n-                return areDisjoint(ss, ts);\n-            }\n-            \/\/ a final class that is not subtype of ss is disjoint\n-            if (!ts.isInterface() && ts.isFinal()) {\n-                return true;\n-            }\n-            \/\/ if at least one is sealed\n-            if (ts.isSealed() || ss.isSealed()) {\n-                \/\/ permitted subtypes have to be disjoint with the other symbol\n-                ClassSymbol sealedOne = ts.isSealed() ? ts : ss;\n-                ClassSymbol other = sealedOne == ts ? ss : ts;\n-                return sealedOne.permitted.stream().allMatch(sym -> areDisjoint((ClassSymbol)sym, other));\n+                if (pairsSeen.contains(newPair)) {\n+                    return false;\n+                } else {\n+                    pairsSeen.add(newPair);\n+                }\n+                if (isSubtype(erasure(ts.type), erasure(ss.type))) {\n+                    return false;\n+                }\n+                \/\/ if both are classes or both are interfaces, shortcut\n+                if (ts.isInterface() == ss.isInterface() && isSubtype(erasure(ss.type), erasure(ts.type))) {\n+                    return false;\n+                }\n+                if (ts.isInterface() && !ss.isInterface()) {\n+                    \/* so ts is interface but ss is a class\n+                     * an interface is disjoint from a class if the class is disjoint form the interface\n+                     *\/\n+                    return areDisjoint(ss, ts);\n+                }\n+                \/\/ a final class that is not subtype of ss is disjoint\n+                if (!ts.isInterface() && ts.isFinal()) {\n+                    return true;\n+                }\n+                \/\/ if at least one is sealed\n+                if (ts.isSealed() || ss.isSealed()) {\n+                    \/\/ permitted subtypes have to be disjoint with the other symbol\n+                    ClassSymbol sealedOne = ts.isSealed() ? ts : ss;\n+                    ClassSymbol other = sealedOne == ts ? ss : ts;\n+                    return sealedOne.permitted.stream().allMatch(sym -> areDisjoint((ClassSymbol)sym, other));\n+                }\n+                return false;\n@@ -1698,1 +1711,0 @@\n-            return false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":37,"deletions":25,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -0,0 +1,12 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8319987\n+ * @summary compilation of sealed classes leads to infinite recursion\n+ * @compile\/fail\/ref=CyclicHierarchyTest.out -XDrawDiagnostics CyclicHierarchyTest.java\n+ *\/\n+\n+class CyclicHierarchyTest {\n+    sealed interface Action permits Add {}\n+    sealed interface MathOp permits Add {}\n+    sealed static class Add implements MathOp permits Add {}\n+}\n","filename":"test\/langtools\/tools\/javac\/sealed\/erroneous_hierarchy\/CyclicHierarchyTest.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+CyclicHierarchyTest.java:9:37: compiler.err.invalid.permits.clause: (compiler.misc.doesnt.extend.sealed: CyclicHierarchyTest.Add)\n+CyclicHierarchyTest.java:11:55: compiler.err.invalid.permits.clause: (compiler.misc.must.not.be.same.class)\n+2 errors\n","filename":"test\/langtools\/tools\/javac\/sealed\/erroneous_hierarchy\/CyclicHierarchyTest.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"}]}