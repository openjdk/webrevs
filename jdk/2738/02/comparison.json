{"files":[{"patch":"@@ -44,0 +44,1 @@\n+#include \"memory\/universe.hpp\"\n@@ -66,0 +67,1 @@\n+static bool _clear_artifacts = false;\n@@ -86,0 +88,4 @@\n+static bool is_initial_typeset_for_chunk() {\n+  return _clear_artifacts && !_class_unload;\n+}\n+\n@@ -102,0 +108,29 @@\n+static const char* primitive_name(KlassPtr type_array_klass) {\n+  switch (type_array_klass->name()->base()[1]) {\n+    case JVM_SIGNATURE_BOOLEAN: return \"boolean\";\n+    case JVM_SIGNATURE_BYTE: return \"byte\";\n+    case JVM_SIGNATURE_CHAR: return \"char\";\n+    case JVM_SIGNATURE_SHORT: return \"short\";\n+    case JVM_SIGNATURE_INT: return \"int\";\n+    case JVM_SIGNATURE_LONG: return \"long\";\n+    case JVM_SIGNATURE_FLOAT: return \"float\";\n+    case JVM_SIGNATURE_DOUBLE: return \"double\";\n+  }\n+  assert(false, \"invalid type array klass\");\n+  return NULL;\n+}\n+\n+static Symbol* primitive_symbol(KlassPtr type_array_klass) {\n+  if (type_array_klass == NULL) {\n+    \/\/ void.class\n+    static Symbol* const void_class_name = SymbolTable::probe(\"void\", 4);\n+    assert(void_class_name != NULL, \"invariant\");\n+    return void_class_name;\n+  }\n+  const char* const primitive_type_str = primitive_name(type_array_klass);\n+  assert(primitive_type_str != NULL, \"invariant\");\n+  Symbol* const primitive_type_sym = SymbolTable::probe(primitive_type_str, (int)strlen(primitive_type_str));\n+  assert(primitive_type_sym != NULL, \"invariant\");\n+  return primitive_type_sym;\n+}\n+\n@@ -157,0 +192,5 @@\n+\/\/ Same as JVM_GetClassModifiers\n+static u4 get_primitive_flags() {\n+  return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;\n+}\n+\n@@ -228,0 +268,21 @@\n+\n+static traceid primitive_id(KlassPtr array_klass) {\n+  if (array_klass == NULL) {\n+    \/\/ The first klass id is reserved for the void.class.\n+    return LAST_TYPE_ID + 1;\n+  }\n+  \/\/ Derive the traceid for a primitive mirror from its associated array klass (+1).\n+  return JfrTraceId::load_raw(array_klass) + 1;\n+}\n+\n+static void write_primitive(JfrCheckpointWriter* writer, KlassPtr type_array_klass) {\n+  assert(writer != NULL, \"invariant\");\n+  assert(_artifacts != NULL, \"invariant\");\n+  writer->write(primitive_id(type_array_klass));\n+  writer->write(cld_id(get_cld(Universe::boolArrayKlassObj()), false));\n+  writer->write(mark_symbol(primitive_symbol(type_array_klass), false));\n+  writer->write(package_id(Universe::boolArrayKlassObj(), false));\n+  writer->write(get_primitive_flags());\n+  writer->write<bool>(false);\n+}\n+\n@@ -298,0 +359,22 @@\n+static int primitives_count = 9;\n+\n+\/\/ A mirror representing a primitive class (e.g. int.class) has no reified Klass*,\n+\/\/ instead it has an associated TypeArrayKlass* (e.g. int[].class).\n+\/\/ We can use the TypeArrayKlass* as a proxy for deriving the id of the primitive class.\n+\/\/ The exception is the void.class, which has neither a Klass* nor a TypeArrayKlass*.\n+\/\/ It will use a reserved constant.\n+static void do_primitives() {\n+  \/\/ Only write the primitive classes once per chunk.\n+  if (is_initial_typeset_for_chunk()) {\n+    write_primitive(_writer, Universe::boolArrayKlassObj());\n+    write_primitive(_writer, Universe::byteArrayKlassObj());\n+    write_primitive(_writer, Universe::charArrayKlassObj());\n+    write_primitive(_writer, Universe::shortArrayKlassObj());\n+    write_primitive(_writer, Universe::intArrayKlassObj());\n+    write_primitive(_writer, Universe::longArrayKlassObj());\n+    write_primitive(_writer, Universe::floatArrayKlassObj());\n+    write_primitive(_writer, Universe::doubleArrayKlassObj());\n+    write_primitive(_writer, NULL); \/\/ void.class\n+  }\n+}\n+\n@@ -310,0 +393,1 @@\n+  do_primitives();\n@@ -355,0 +439,5 @@\n+  if (is_initial_typeset_for_chunk()) {\n+    \/\/ Because the set of primitives is written outside the callback,\n+    \/\/ their count is not automatically incremented.\n+    kw.add(primitives_count);\n+  }\n@@ -982,2 +1071,0 @@\n-static bool clear_artifacts = false;\n-\n@@ -995,1 +1082,1 @@\n-    clear_artifacts = true;\n+    _clear_artifacts = true;\n@@ -997,0 +1084,2 @@\n+  } else {\n+    _clear_artifacts = false;\n@@ -1009,1 +1098,1 @@\n-    _artifacts->initialize(class_unload, clear_artifacts);\n+    _artifacts->initialize(class_unload, _clear_artifacts);\n@@ -1014,1 +1103,0 @@\n-  clear_artifacts = false;\n@@ -1045,1 +1133,1 @@\n-  clear_artifacts = true;\n+  _clear_artifacts = true;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":94,"deletions":6,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-  static volatile traceid class_id_counter = LAST_TYPE_ID;\n+  static volatile traceid class_id_counter = LAST_TYPE_ID + 1; \/\/ + 1 is for the void.class primitive\n@@ -151,0 +151,4 @@\n+traceid JfrTraceId::assign_primitive_klass_id() {\n+  return next_class_id();\n+}\n+\n@@ -155,1 +159,20 @@\n-traceid JfrTraceId::load_raw(jclass jc) {\n+\/\/ A mirror representing a primitive class (e.g. int.class) has no reified Klass*,\n+\/\/ instead it has an associated TypeArrayKlass* (e.g. int[].class).\n+\/\/ We can use the TypeArrayKlass* as a proxy for deriving the id of the primitive class.\n+\/\/ The exception is the void.class, which has neither a Klass* nor a TypeArrayKlass*.\n+\/\/ It will use a reserved constant.\n+static traceid load_primitive(const oop mirror) {\n+  assert(java_lang_Class::is_primitive(mirror), \"invariant\");\n+  const Klass* const tak = java_lang_Class::array_klass_acquire(mirror);\n+  traceid id;\n+  if (tak == NULL) {\n+    \/\/ The first klass id is reserved for the void.class\n+    id = LAST_TYPE_ID + 1;\n+  } else {\n+    id = JfrTraceId::load_raw(tak) + 1;\n+  }\n+  JfrTraceIdEpoch::set_changed_tag_state();\n+  return id;\n+}\n+\n+traceid JfrTraceId::load(jclass jc, bool raw \/* false *\/) {\n@@ -158,3 +181,8 @@\n-  const oop my_oop = JNIHandles::resolve(jc);\n-  assert(my_oop != NULL, \"invariant\");\n-  return load_raw(java_lang_Class::as_Klass(my_oop));\n+  const oop mirror = JNIHandles::resolve(jc);\n+  assert(mirror != NULL, \"invariant\");\n+  const Klass* const k = java_lang_Class::as_Klass(mirror);\n+  return k != NULL ? (raw ? load_raw(k) : load(k)) : load_primitive(mirror);\n+}\n+\n+traceid JfrTraceId::load_raw(jclass jc) {\n+  return load(jc, true);\n@@ -189,0 +217,4 @@\n+  if (k->is_typeArray_klass()) {\n+    \/\/ the next id is reserved for the corresponding primitive class\n+    next_class_id();\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.cpp","additions":38,"deletions":6,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,0 +86,1 @@\n+  static traceid assign_primitive_klass_id();\n@@ -90,1 +91,1 @@\n-  static traceid load(jclass jc);\n+  static traceid load(jclass jc, bool raw = false);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,4 +38,0 @@\n-inline traceid JfrTraceId::load(jclass jc) {\n-  return JfrTraceIdLoadBarrier::load(jc);\n-}\n-\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -31,1 +30,0 @@\n-#include \"runtime\/jniHandles.inline.hpp\"\n@@ -73,8 +71,0 @@\n-\n-traceid JfrTraceIdLoadBarrier::load(jclass jc) {\n-  assert(jc != NULL, \"invariant\");\n-  assert(JavaThread::current()->thread_state() == _thread_in_vm, \"invariant\");\n-  const oop my_oop = JNIHandles::resolve(jc);\n-  assert(my_oop != NULL, \"invariant\");\n-  return load(java_lang_Class::as_Klass(my_oop));\n-}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"jni.h\"\n@@ -81,1 +80,0 @@\n-  static traceid load(jclass jc);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#define ASSIGN_PRIMITIVE_CLASS_ID(data) JfrTraceId::assign_primitive_klass_id()\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrTraceIdExtension.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-\n+  JFR_ONLY(ASSIGN_PRIMITIVE_CLASS_ID(ak);)\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jvm;\n+\n+import java.util.List;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test TestPrimitiveClasses\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.jvm.TestPrimitiveClasses\n+ *\/\n+public class TestPrimitiveClasses {\n+\n+    private static class MyEvent extends Event {\n+        Class<?> booleanClass = boolean.class;\n+        Class<?> charClass = char.class;\n+        Class<?> floatClass = float.class;\n+        Class<?> doubleClass = double.class;\n+        Class<?> byteClass = byte.class;\n+        Class<?> shortClass = short.class;\n+        Class<?> intClass = int.class;\n+        Class<?> longClass = long.class;\n+        Class<?> voidClass = void.class;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(MyEvent.class);\n+            r.start();\n+            MyEvent myEvent = new MyEvent();\n+            myEvent.commit();\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            Events.hasEvents(events);\n+            RecordedEvent event = events.get(0);\n+            System.out.println(event);\n+            testField(event, \"booleanClass\", boolean.class);\n+            testField(event, \"charClass\", char.class);\n+            testField(event, \"floatClass\", float.class);\n+            testField(event, \"doubleClass\", double.class);\n+            testField(event, \"byteClass\", byte.class);\n+            testField(event, \"shortClass\", short.class);\n+            testField(event, \"intClass\", int.class);\n+            testField(event, \"longClass\", long.class);\n+            testField(event, \"voidClass\", void.class);\n+        }\n+    }\n+\n+    private static void testField(RecordedEvent event, String fieldName, Class<?> expected) {\n+        Asserts.assertTrue(event.hasField(fieldName));\n+        RecordedClass classField = event.getValue(fieldName);\n+        Asserts.assertEquals(classField.getName(), expected.getName());\n+        Asserts.assertEquals(classField.getClassLoader().getName(), \"bootstrap\");\n+        Asserts.assertEquals(classField.getModifiers(), expected.getModifiers());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestPrimitiveClasses.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"}]}