{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,1 @@\n+    public static final int IO_REPARSE_TAG_MOUNT_POINT          = 0xA0000003;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsConstants.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -415,0 +415,4 @@\n+    boolean isDirectoryJunction() {\n+        return reparseTag == IO_REPARSE_TAG_MOUNT_POINT;\n+    }\n+\n@@ -426,4 +430,2 @@\n-        \/\/ ignore FILE_ATTRIBUTE_DIRECTORY attribute if file is a sym link\n-        if (isSymbolicLink())\n-            return false;\n-        return ((fileAttrs & FILE_ATTRIBUTE_DIRECTORY) != 0);\n+        return ((fileAttrs & FILE_ATTRIBUTE_DIRECTORY) != 0 &&\n+                (fileAttrs & FILE_ATTRIBUTE_REPARSE_POINT) == 0);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileAttributes.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -246,1 +246,2 @@\n-             if (attrs.isDirectory() || attrs.isDirectoryLink()) {\n+             if (attrs.isDirectory() || attrs.isDirectoryLink() ||\n+                 attrs.isDirectoryJunction()) {\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystemProvider.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333\n+ * @bug 4313887 6838333 8364277\n@@ -27,1 +27,4 @@\n- * @library ..\/..\n+ * @library ..\/.. \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ *        jdk.test.lib.util.FileUtils\n+ * @run main\/othervm --enable-native-access=ALL-UNNAMED Basic\n@@ -36,0 +39,3 @@\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.util.FileUtils;\n+\n@@ -100,0 +106,11 @@\n+    static void checkAttributesOfJunction(Path junction)\n+        throws IOException\n+    {\n+        BasicFileAttributes attrs =\n+            Files.readAttributes(junction, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n+        check(!attrs.isSymbolicLink(), \"is a link\");\n+        check(!attrs.isDirectory(), \"is a directory\");\n+        check(!attrs.isRegularFile(), \"is not a regular file\");\n+        check(attrs.isOther(), \"is other\");\n+    }\n+\n@@ -117,4 +134,11 @@\n-        } catch (UnsupportedOperationException x) {\n-            return;\n-        } catch (IOException x) {\n-            return;\n+            checkAttributesOfLink(link);\n+        } catch (IOException | UnsupportedOperationException x) {\n+            if (!Platform.isWindows())\n+                return;\n+        }\n+\n+        \/\/ NTFS junctions are Windows-only\n+        if (Platform.isWindows()) {\n+            Path junction = dir.resolve(\"junction\");\n+            FileUtils.createWinDirectoryJunction(junction, dir);\n+            checkAttributesOfJunction(junction);\n@@ -122,1 +146,0 @@\n-        checkAttributesOfLink(link);\n","filename":"test\/jdk\/java\/nio\/file\/attribute\/BasicFileAttributeView\/Basic.java","additions":31,"deletions":8,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.io.File;\n@@ -36,0 +37,1 @@\n+import java.nio.file.LinkOption;\n@@ -67,0 +69,7 @@\n+    private static void loadNativeLib() {\n+        if (!nativeLibLoaded) {\n+            System.loadLibrary(\"FileUtils\");\n+            nativeLibLoaded = true;\n+        }\n+    }\n+\n@@ -398,5 +407,2 @@\n-            if (!nativeLibLoaded) {\n-                System.loadLibrary(\"FileUtils\");\n-                nativeLibLoaded = true;\n-            }\n-            return getWinProcessHandleCount();\n+            loadNativeLib();\n+            return getWinProcessHandleCount0();\n@@ -446,1 +452,17 @@\n-    private static native long getWinProcessHandleCount();\n+    \/\/ Create a directory junction with the specified target\n+    public static boolean createWinDirectoryJunction(Path junction, Path target)\n+        throws IOException\n+    {\n+        assert IS_WINDOWS;\n+\n+        \/\/ Convert \"target\" to its real path\n+        target = target.toRealPath();\n+\n+        \/\/ Create a directory junction\n+        loadNativeLib();\n+        return createWinDirectoryJunction0(junction.toString(), target.toString());\n+    }\n+\n+    private static native long getWinProcessHandleCount0();\n+    private static native boolean createWinDirectoryJunction0(String junction,\n+        String target) throws IOException;\n","filename":"test\/lib\/jdk\/test\/lib\/util\/FileUtils.java","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+#include \"jni_util.h\"\n+#include <string.h>\n@@ -31,0 +33,8 @@\n+#include <fileapi.h>\n+#include <handleapi.h>\n+#include <ioapiset.h>\n+#include <winioctl.h>\n+#include <errhandlingapi.h>\n+\n+\/\/ Based on Microsoft documentation\n+#define MAX_REPARSE_BUFFER_SIZE 16384\n@@ -32,1 +42,31 @@\n-JNIEXPORT jlong JNICALL Java_jdk_test_lib_util_FileUtils_getWinProcessHandleCount(JNIEnv *env)\n+\/\/ Unavailable in standard header files:\n+\/\/ copied from Microsoft documentation\n+typedef struct _REPARSE_DATA_BUFFER {\n+    ULONG  ReparseTag;\n+    USHORT ReparseDataLength;\n+    USHORT Reserved;\n+    union {\n+        struct {\n+            USHORT SubstituteNameOffset;\n+            USHORT SubstituteNameLength;\n+            USHORT PrintNameOffset;\n+            USHORT PrintNameLength;\n+            ULONG  Flags;\n+            WCHAR  PathBuffer[1];\n+        } SymbolicLinkReparseBuffer;\n+        struct {\n+            USHORT SubstituteNameOffset;\n+            USHORT SubstituteNameLength;\n+            USHORT PrintNameOffset;\n+            USHORT PrintNameLength;\n+            WCHAR  PathBuffer[1];\n+        } MountPointReparseBuffer;\n+        struct {\n+            UCHAR DataBuffer[1];\n+        } GenericReparseBuffer;\n+    } DUMMYUNIONNAME;\n+} REPARSE_DATA_BUFFER, * PREPARSE_DATA_BUFFER;\n+\n+JNIEXPORT jlong JNICALL\n+Java_jdk_test_lib_util_FileUtils_getWinProcessHandleCount0\n+    (JNIEnv* env)\n@@ -43,0 +83,114 @@\n+void throwIOExceptionWithLastError(JNIEnv* env) {\n+#define BUFSIZE 256\n+    DWORD errval;\n+    WCHAR buf[BUFSIZE];\n+\n+    if ((errval = GetLastError()) != 0) {\n+        jsize n = FormatMessageW(\n+            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n+            NULL, errval, 0, buf, BUFSIZE, NULL);\n+\n+        jclass ioExceptionClass = (*env)->FindClass(env, \"java\/io\/IOException\");\n+        (*env)->ThrowNew(env, ioExceptionClass, (const char*) buf);\n+    }\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_test_lib_util_FileUtils_createWinDirectoryJunction0\n+    (JNIEnv* env, jclass unused, jstring sjunction, jstring starget)\n+{\n+    BOOL error = FALSE;\n+\n+    const jshort bpc = sizeof(wchar_t); \/\/ bytes per character\n+    HANDLE hJunction = INVALID_HANDLE_VALUE;\n+\n+    const jchar* junction = (*env)->GetStringChars(env, sjunction, NULL);\n+    const jchar* target   = (*env)->GetStringChars(env, starget, NULL);\n+    if (junction == NULL || target == NULL) {\n+        jclass npeClass = (*env)->FindClass(env, \"java\/lang\/NullPointerException\");\n+        (*env)->ThrowNew(env, npeClass, NULL);\n+        error = TRUE;\n+    }\n+\n+    USHORT wlen = (USHORT)0;\n+    USHORT blen = (USHORT)0;\n+    void* lpInBuffer = NULL;\n+    if (!error) {\n+        wlen = (USHORT)wcslen(target);\n+        blen = (USHORT)(wlen * sizeof(wchar_t));\n+        lpInBuffer = calloc(MAX_REPARSE_BUFFER_SIZE, sizeof(char));\n+        if (lpInBuffer == NULL) {\n+            jclass oomeClass = (*env)->FindClass(env, \"java\/lang\/OutOfMemoryError\");\n+            (*env)->ThrowNew(env, oomeClass, NULL);\n+            error = TRUE;\n+        }\n+    }\n+\n+    if (!error) {\n+        if (CreateDirectoryW(junction, NULL) == 0) {\n+            throwIOExceptionWithLastError(env);\n+            error = TRUE;\n+        }\n+    }\n+\n+    if (!error) {\n+        hJunction = CreateFileW(junction, GENERIC_READ | GENERIC_WRITE,\n+                                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,\n+                                OPEN_EXISTING,\n+                                FILE_FLAG_OPEN_REPARSE_POINT\n+                                | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n+        if (hJunction == INVALID_HANDLE_VALUE) {\n+            throwIOExceptionWithLastError(env);\n+            error = TRUE;\n+        }\n+    }\n+\n+    if (!error) {\n+        PREPARSE_DATA_BUFFER reparseBuffer = (PREPARSE_DATA_BUFFER)lpInBuffer;\n+        reparseBuffer->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\n+        reparseBuffer->Reserved = 0;\n+        WCHAR* prefix = L\"\\\\??\\\\\";\n+        USHORT prefixLength = (USHORT)(bpc * wcslen(prefix));\n+        reparseBuffer->MountPointReparseBuffer.SubstituteNameOffset = 0;\n+        reparseBuffer->MountPointReparseBuffer.SubstituteNameLength =\n+            prefixLength + blen;\n+        reparseBuffer->MountPointReparseBuffer.PrintNameOffset =\n+            prefixLength + blen + sizeof(WCHAR);\n+        reparseBuffer->MountPointReparseBuffer.PrintNameLength = blen;\n+        memcpy(&reparseBuffer->MountPointReparseBuffer.PathBuffer,\n+               prefix, prefixLength);\n+        memcpy(&reparseBuffer->MountPointReparseBuffer.PathBuffer[prefixLength\/bpc],\n+               target, blen);\n+        memcpy(&reparseBuffer->MountPointReparseBuffer.PathBuffer[prefixLength\/bpc + blen\/bpc + 1],\n+               target, blen);\n+        reparseBuffer->ReparseDataLength =\n+            (USHORT)(sizeof(reparseBuffer->MountPointReparseBuffer) +\n+                     prefixLength + bpc*blen + bpc);\n+        DWORD nInBufferSize = FIELD_OFFSET(REPARSE_DATA_BUFFER,\n+            MountPointReparseBuffer) + reparseBuffer->ReparseDataLength;\n+        BOOL result = DeviceIoControl(hJunction, FSCTL_SET_REPARSE_POINT,\n+                                      lpInBuffer, nInBufferSize,\n+                                      NULL, 0, NULL, NULL);\n+        if (result == 0) {\n+            throwIOExceptionWithLastError(env);\n+            error = TRUE;\n+        }\n+    }\n+\n+    if (junction != NULL) {\n+        (*env)->ReleaseStringChars(env, sjunction, junction);\n+        if (target != NULL) {\n+            (*env)->ReleaseStringChars(env, starget, target);\n+            if (lpInBuffer != NULL) {\n+                free(lpInBuffer);\n+                if (hJunction != INVALID_HANDLE_VALUE) {\n+                    \/\/ Ignore any error in CloseHandle\n+                    CloseHandle(hJunction);\n+                }\n+            }\n+        }\n+    }\n+\n+    return error ? JNI_FALSE : JNI_TRUE;\n+}\n+\n","filename":"test\/lib\/jdk\/test\/lib\/util\/libFileUtils.c","additions":156,"deletions":2,"binary":false,"changes":158,"status":"modified"}]}