{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.math.BigInteger;\n@@ -29,0 +30,1 @@\n+import java.util.random.RandomGenerator;\n@@ -30,1 +32,0 @@\n-\n@@ -33,0 +34,1 @@\n+import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n@@ -150,0 +152,4 @@\n+@RandomGeneratorProperties(\n+        name = \"SecureRandom\",\n+        isStochastic = true\n+)\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureRandom.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+\n@@ -29,3 +30,0 @@\n-import java.util.function.DoubleConsumer;\n-import java.util.function.IntConsumer;\n-import java.util.function.LongConsumer;\n@@ -35,1 +33,7 @@\n-import java.util.stream.StreamSupport;\n+\n+import jdk.internal.util.random.RandomSupport.AbstractSpliteratorGenerator;\n+import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n+import jdk.internal.util.random.RandomSupport.RandomIntsSpliterator;\n+import jdk.internal.util.random.RandomSupport.RandomLongsSpliterator;\n+import jdk.internal.util.random.RandomSupport.RandomDoublesSpliterator;\n+import static jdk.internal.util.random.RandomSupport.*;\n@@ -41,1 +45,2 @@\n- * pseudorandom numbers. The class uses a 48-bit seed, which is\n+ * pseudorandom numbers; its period is only 2<sup>48<\/sup>.\n+ * The class uses a 48-bit seed, which is\n@@ -77,1 +82,8 @@\n-public class Random implements java.io.Serializable {\n+@SuppressWarnings(\"exports\")\n+@RandomGeneratorProperties(\n+        name = \"Random\",\n+        i = 48, j = 0, k = 0,\n+        equidistribution = 0\n+)\n+public class Random extends AbstractSpliteratorGenerator\n+        implements java.io.Serializable {\n@@ -95,5 +107,0 @@\n-    \/\/ IllegalArgumentException messages\n-    static final String BadBound = \"bound must be positive\";\n-    static final String BadRange = \"bound must be greater than origin\";\n-    static final String BadSize  = \"size must be non-negative\";\n-\n@@ -121,1 +128,1 @@\n-        = new AtomicLong(8682522807148012L);\n+            = new AtomicLong(8682522807148012L);\n@@ -128,2 +135,2 @@\n-     * <p>The invocation {@code new Random(seed)} is equivalent to:\n-     *  <pre> {@code\n+     * @implSpec The invocation {@code new Random(seed)} is equivalent to:\n+     * <pre>{@code\n@@ -131,1 +138,2 @@\n-     * rnd.setSeed(seed);}<\/pre>\n+     * rnd.setSeed(seed);\n+     * }<\/pre>\n@@ -214,3 +222,3 @@\n-     * <p>The method {@code nextBytes} is implemented by class {@code Random}\n-     * as if by:\n-     *  <pre> {@code\n+     * @implSpec The method {@code nextBytes} is\n+     * implemented by class {@code Random} as if by:\n+     * <pre>{@code\n@@ -228,0 +236,1 @@\n+    @Override\n@@ -231,1 +240,1 @@\n-                     n = Math.min(len - i, Integer.SIZE\/Byte.SIZE);\n+                 n = Math.min(len - i, Integer.SIZE\/Byte.SIZE);\n@@ -236,76 +245,0 @@\n-    \/**\n-     * The form of nextLong used by LongStream Spliterators.  If\n-     * origin is greater than bound, acts as unbounded form of\n-     * nextLong, else as bounded form.\n-     *\n-     * @param origin the least value, unless greater than bound\n-     * @param bound the upper bound (exclusive), must not equal origin\n-     * @return a pseudorandom value\n-     *\/\n-    final long internalNextLong(long origin, long bound) {\n-        long r = nextLong();\n-        if (origin < bound) {\n-            long n = bound - origin, m = n - 1;\n-            if ((n & m) == 0L)  \/\/ power of two\n-                r = (r & m) + origin;\n-            else if (n > 0L) {  \/\/ reject over-represented candidates\n-                for (long u = r >>> 1;            \/\/ ensure nonnegative\n-                     u + m - (r = u % n) < 0L;    \/\/ rejection check\n-                     u = nextLong() >>> 1) \/\/ retry\n-                    ;\n-                r += origin;\n-            }\n-            else {              \/\/ range not representable as long\n-                while (r < origin || r >= bound)\n-                    r = nextLong();\n-            }\n-        }\n-        return r;\n-    }\n-\n-    \/**\n-     * The form of nextInt used by IntStream Spliterators.\n-     * For the unbounded case: uses nextInt().\n-     * For the bounded case with representable range: uses nextInt(int bound)\n-     * For the bounded case with unrepresentable range: uses nextInt()\n-     *\n-     * @param origin the least value, unless greater than bound\n-     * @param bound the upper bound (exclusive), must not equal origin\n-     * @return a pseudorandom value\n-     *\/\n-    final int internalNextInt(int origin, int bound) {\n-        if (origin < bound) {\n-            int n = bound - origin;\n-            if (n > 0) {\n-                return nextInt(n) + origin;\n-            }\n-            else {  \/\/ range not representable as int\n-                int r;\n-                do {\n-                    r = nextInt();\n-                } while (r < origin || r >= bound);\n-                return r;\n-            }\n-        }\n-        else {\n-            return nextInt();\n-        }\n-    }\n-\n-    \/**\n-     * The form of nextDouble used by DoubleStream Spliterators.\n-     *\n-     * @param origin the least value, unless greater than bound\n-     * @param bound the upper bound (exclusive), must not equal origin\n-     * @return a pseudorandom value\n-     *\/\n-    final double internalNextDouble(double origin, double bound) {\n-        double r = nextDouble();\n-        if (origin < bound) {\n-            r = r * (bound - origin) + origin;\n-            if (r >= bound) \/\/ correct for rounding\n-                r = Double.longBitsToDouble(Double.doubleToLongBits(bound) - 1);\n-        }\n-        return r;\n-    }\n-\n@@ -319,3 +252,3 @@\n-     * <p>The method {@code nextInt} is implemented by class {@code Random}\n-     * as if by:\n-     *  <pre> {@code\n+     * @implSpec The method {@code nextInt} is\n+     * implemented by class {@code Random} as if by:\n+     * <pre>{@code\n@@ -329,0 +262,1 @@\n+    @Override\n@@ -340,1 +274,3 @@\n-     * probability.  The method {@code nextInt(int bound)} is implemented by\n+     * probability.\n+     *\n+     * @implSpec The method {@code nextInt(int bound)} is implemented by\n@@ -342,1 +278,1 @@\n-     *  <pre> {@code\n+     * <pre>{@code\n@@ -387,0 +323,1 @@\n+    @Override\n@@ -389,2 +326,1 @@\n-            throw new IllegalArgumentException(BadBound);\n-\n+            throw new IllegalArgumentException(BAD_BOUND);\n@@ -395,1 +331,1 @@\n-        else {\n+        else { \/\/ reject over-represented candidates\n@@ -403,1 +339,0 @@\n-\n@@ -410,1 +345,1 @@\n-     * <p>The method {@code nextLong} is implemented by class {@code Random}\n+     * @implSpec The method {@code nextLong} is implemented by class {@code Random}\n@@ -412,1 +347,1 @@\n-     *  <pre> {@code\n+     * <pre>{@code\n@@ -423,0 +358,1 @@\n+    @Override\n@@ -436,3 +372,3 @@\n-     * <p>The method {@code nextBoolean} is implemented by class {@code Random}\n-     * as if by:\n-     *  <pre> {@code\n+     * @implSpec The method {@code nextBoolean} is implemented by class\n+     * {@code Random} as if by:\n+     * <pre>{@code\n@@ -448,0 +384,1 @@\n+    @Override\n@@ -465,3 +402,3 @@\n-     * <p>The method {@code nextFloat} is implemented by class {@code Random}\n-     * as if by:\n-     *  <pre> {@code\n+     * @implSpec The method {@code nextFloat} is implemented by class\n+     * {@code Random} as if by:\n+     * <pre>{@code\n@@ -471,1 +408,0 @@\n-     *\n@@ -478,2 +414,1 @@\n-     *  <pre> {@code\n-     *   return next(30) \/ ((float)(1 << 30));}<\/pre>\n+     *  <pre> {@code return next(30) \/ ((float)(1 << 30));}<\/pre>\n@@ -489,0 +424,1 @@\n+    @Override\n@@ -503,3 +439,3 @@\n-     * <p>The method {@code nextDouble} is implemented by class {@code Random}\n-     * as if by:\n-     *  <pre> {@code\n+     * @implSpec The method {@code nextDouble} is implemented by class\n+     * {@code Random} as if by:\n+     * <pre>{@code\n@@ -510,1 +446,0 @@\n-     *\n@@ -512,4 +447,4 @@\n-     * because the {@code next} method is only approximately an unbiased\n-     * source of independently chosen bits. If it were a perfect source of\n-     * randomly chosen bits, then the algorithm shown would choose\n-     * {@code double} values from the stated range with perfect uniformity.\n+     * because the {@code next} method is only approximately an unbiased source\n+     * of independently chosen bits. If it were a perfect source of randomly\n+     * chosen bits, then the algorithm shown would choose {@code double} values\n+     * from the stated range with perfect uniformity.\n@@ -517,3 +452,1 @@\n-     *  <pre> {@code\n-     *   return (((long)next(27) << 27) + next(27))\n-     *     \/ (double)(1L << 54);}<\/pre>\n+     * <pre> {@code return (((long)next(27) << 27) + next(27)) \/ (double)(1L << 54);}<\/pre>\n@@ -521,5 +454,5 @@\n-     * introduced a large nonuniformity because of the bias in the rounding\n-     * of floating-point numbers: it was three times as likely that the\n-     * low-order bit of the significand would be 0 than that it would be 1!\n-     * This nonuniformity probably doesn't matter much in practice, but we\n-     * strive for perfection.]\n+     * introduced a large nonuniformity because of the bias in the rounding of\n+     * floating-point numbers: it was three times as likely that the low-order\n+     * bit of the significand would be 0 than that it would be 1! This\n+     * nonuniformity probably doesn't matter much in practice, but we strive\n+     * for perfection.]\n@@ -532,0 +465,1 @@\n+    @Override\n@@ -549,1 +483,1 @@\n-     * <p>The method {@code nextGaussian} is implemented by class\n+     * @implSpec The method {@code nextGaussian} is implemented by class\n@@ -551,1 +485,1 @@\n-     *  <pre> {@code\n+     * <pre>{@code\n@@ -572,0 +506,1 @@\n+     *\n@@ -584,0 +519,1 @@\n+    @Override\n@@ -603,2 +539,104 @@\n-    \/\/ stream methods, coded in a way intended to better isolate for\n-    \/\/ maintenance purposes the small differences across forms.\n+    \/**\n+     * Serializable fields for Random.\n+     *\n+     * @serialField    seed long\n+     *              seed for random computations\n+     * @serialField    nextNextGaussian double\n+     *              next Gaussian to be returned\n+     * @serialField      haveNextNextGaussian boolean\n+     *              nextNextGaussian is valid\n+     *\/\n+    @java.io.Serial\n+    private static final ObjectStreamField[] serialPersistentFields = {\n+            new ObjectStreamField(\"seed\", Long.TYPE),\n+            new ObjectStreamField(\"nextNextGaussian\", Double.TYPE),\n+            new ObjectStreamField(\"haveNextNextGaussian\", Boolean.TYPE)\n+    };\n+\n+    \/**\n+     * Reconstitute the {@code Random} instance from a stream (that is,\n+     * deserialize it).\n+     *\n+     * @param  s the {@code ObjectInputStream} from which data is read\n+     *\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(java.io.ObjectInputStream s)\n+            throws java.io.IOException, ClassNotFoundException {\n+\n+        ObjectInputStream.GetField fields = s.readFields();\n+\n+        \/\/ The seed is read in as {@code long} for\n+        \/\/ historical reasons, but it is converted to an AtomicLong.\n+        long seedVal = fields.get(\"seed\", -1L);\n+        if (seedVal < 0)\n+            throw new java.io.StreamCorruptedException(\n+                    \"Random: invalid seed\");\n+        resetSeed(seedVal);\n+        nextNextGaussian = fields.get(\"nextNextGaussian\", 0.0);\n+        haveNextNextGaussian = fields.get(\"haveNextNextGaussian\", false);\n+    }\n+\n+    \/**\n+     * Save the {@code Random} instance to a stream.\n+     *\n+     * @param  s the {@code ObjectOutputStream} to which data is written\n+     *\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    @java.io.Serial\n+    private synchronized void writeObject(ObjectOutputStream s)\n+            throws IOException {\n+\n+        \/\/ set the values of the Serializable fields\n+        ObjectOutputStream.PutField fields = s.putFields();\n+\n+        \/\/ The seed is serialized as a long for historical reasons.\n+        fields.put(\"seed\", seed.get());\n+        fields.put(\"nextNextGaussian\", nextNextGaussian);\n+        fields.put(\"haveNextNextGaussian\", haveNextNextGaussian);\n+\n+        \/\/ save them\n+        s.writeFields();\n+    }\n+\n+    \/\/ Support for resetting seed while deserializing\n+    private static final Unsafe unsafe = Unsafe.getUnsafe();\n+    private static final long seedOffset;\n+    static {\n+        try {\n+            seedOffset = unsafe.objectFieldOffset\n+                    (Random.class.getDeclaredField(\"seed\"));\n+        } catch (Exception ex) { throw new Error(ex); }\n+    }\n+    private void resetSeed(long seedVal) {\n+        unsafe.putReferenceVolatile(this, seedOffset, new AtomicLong(seedVal));\n+    }\n+\n+    \/\/ Methods required by class AbstractSpliteratorGenerator\n+\n+    \/**\n+     * @hidden\n+     *\/\n+    @Override\n+    public Spliterator.OfInt makeIntsSpliterator(long index, long fence, int origin, int bound) {\n+        return new RandomIntsSpliterator(this, index, fence, origin, bound);\n+    }\n+\n+    \/**\n+     * @hidden\n+     *\/\n+    @Override\n+    public Spliterator.OfLong makeLongsSpliterator(long index, long fence, long origin, long bound) {\n+        return new RandomLongsSpliterator(this, index, fence, origin, bound);\n+    }\n+\n+    \/**\n+     * @hidden\n+     *\/\n+    @Override\n+    public Spliterator.OfDouble makeDoublesSpliterator(long index, long fence, double origin, double bound) {\n+        return new RandomDoublesSpliterator(this, index, fence, origin, bound);\n+    }\n@@ -619,0 +657,1 @@\n+    @Override\n@@ -620,6 +659,1 @@\n-        if (streamSize < 0L)\n-            throw new IllegalArgumentException(BadSize);\n-        return StreamSupport.intStream\n-                (new RandomIntsSpliterator\n-                         (this, 0L, streamSize, Integer.MAX_VALUE, 0),\n-                 false);\n+        return super.ints(streamSize);\n@@ -641,0 +675,1 @@\n+    @Override\n@@ -642,4 +677,1 @@\n-        return StreamSupport.intStream\n-                (new RandomIntsSpliterator\n-                         (this, 0L, Long.MAX_VALUE, Integer.MAX_VALUE, 0),\n-                 false);\n+        return super.ints();\n@@ -680,10 +712,3 @@\n-    public IntStream ints(long streamSize, int randomNumberOrigin,\n-                          int randomNumberBound) {\n-        if (streamSize < 0L)\n-            throw new IllegalArgumentException(BadSize);\n-        if (randomNumberOrigin >= randomNumberBound)\n-            throw new IllegalArgumentException(BadRange);\n-        return StreamSupport.intStream\n-                (new RandomIntsSpliterator\n-                         (this, 0L, streamSize, randomNumberOrigin, randomNumberBound),\n-                 false);\n+    @Override\n+    public IntStream ints(long streamSize, int randomNumberOrigin, int randomNumberBound) {\n+        return super.ints(streamSize, randomNumberOrigin, randomNumberBound);\n@@ -725,0 +750,1 @@\n+    @Override\n@@ -726,6 +752,1 @@\n-        if (randomNumberOrigin >= randomNumberBound)\n-            throw new IllegalArgumentException(BadRange);\n-        return StreamSupport.intStream\n-                (new RandomIntsSpliterator\n-                         (this, 0L, Long.MAX_VALUE, randomNumberOrigin, randomNumberBound),\n-                 false);\n+        return super.ints(randomNumberOrigin, randomNumberBound);\n@@ -747,0 +768,1 @@\n+    @Override\n@@ -748,6 +770,1 @@\n-        if (streamSize < 0L)\n-            throw new IllegalArgumentException(BadSize);\n-        return StreamSupport.longStream\n-                (new RandomLongsSpliterator\n-                         (this, 0L, streamSize, Long.MAX_VALUE, 0L),\n-                 false);\n+        return super.longs(streamSize);\n@@ -769,0 +786,1 @@\n+    @Override\n@@ -770,4 +788,1 @@\n-        return StreamSupport.longStream\n-                (new RandomLongsSpliterator\n-                         (this, 0L, Long.MAX_VALUE, Long.MAX_VALUE, 0L),\n-                 false);\n+        return super.longs();\n@@ -813,10 +828,3 @@\n-    public LongStream longs(long streamSize, long randomNumberOrigin,\n-                            long randomNumberBound) {\n-        if (streamSize < 0L)\n-            throw new IllegalArgumentException(BadSize);\n-        if (randomNumberOrigin >= randomNumberBound)\n-            throw new IllegalArgumentException(BadRange);\n-        return StreamSupport.longStream\n-                (new RandomLongsSpliterator\n-                         (this, 0L, streamSize, randomNumberOrigin, randomNumberBound),\n-                 false);\n+    @Override\n+    public LongStream longs(long streamSize, long randomNumberOrigin, long randomNumberBound) {\n+        return super.longs(streamSize, randomNumberOrigin, randomNumberBound);\n@@ -863,0 +871,1 @@\n+    @Override\n@@ -864,6 +873,1 @@\n-        if (randomNumberOrigin >= randomNumberBound)\n-            throw new IllegalArgumentException(BadRange);\n-        return StreamSupport.longStream\n-                (new RandomLongsSpliterator\n-                         (this, 0L, Long.MAX_VALUE, randomNumberOrigin, randomNumberBound),\n-                 false);\n+        return super.longs(randomNumberOrigin, randomNumberBound);\n@@ -886,0 +890,1 @@\n+    @Override\n@@ -887,6 +892,1 @@\n-        if (streamSize < 0L)\n-            throw new IllegalArgumentException(BadSize);\n-        return StreamSupport.doubleStream\n-                (new RandomDoublesSpliterator\n-                         (this, 0L, streamSize, Double.MAX_VALUE, 0.0),\n-                 false);\n+        return super.doubles(streamSize);\n@@ -909,0 +909,1 @@\n+    @Override\n@@ -910,4 +911,1 @@\n-        return StreamSupport.doubleStream\n-                (new RandomDoublesSpliterator\n-                         (this, 0L, Long.MAX_VALUE, Double.MAX_VALUE, 0.0),\n-                 false);\n+        return super.doubles();\n@@ -916,1 +914,1 @@\n-    \/**\n+   \/**\n@@ -943,10 +941,3 @@\n-    public DoubleStream doubles(long streamSize, double randomNumberOrigin,\n-                                double randomNumberBound) {\n-        if (streamSize < 0L)\n-            throw new IllegalArgumentException(BadSize);\n-        if (!(randomNumberOrigin < randomNumberBound))\n-            throw new IllegalArgumentException(BadRange);\n-        return StreamSupport.doubleStream\n-                (new RandomDoublesSpliterator\n-                         (this, 0L, streamSize, randomNumberOrigin, randomNumberBound),\n-                 false);\n+    @Override\n+    public DoubleStream doubles(long streamSize, double randomNumberOrigin, double randomNumberBound) {\n+        return super.doubles(streamSize, randomNumberOrigin, randomNumberBound);\n@@ -982,0 +973,1 @@\n+    @Override\n@@ -983,254 +975,1 @@\n-        if (!(randomNumberOrigin < randomNumberBound))\n-            throw new IllegalArgumentException(BadRange);\n-        return StreamSupport.doubleStream\n-                (new RandomDoublesSpliterator\n-                         (this, 0L, Long.MAX_VALUE, randomNumberOrigin, randomNumberBound),\n-                 false);\n-    }\n-\n-    \/**\n-     * Spliterator for int streams.  We multiplex the four int\n-     * versions into one class by treating a bound less than origin as\n-     * unbounded, and also by treating \"infinite\" as equivalent to\n-     * Long.MAX_VALUE. For splits, it uses the standard divide-by-two\n-     * approach. The long and double versions of this class are\n-     * identical except for types.\n-     *\/\n-    static final class RandomIntsSpliterator implements Spliterator.OfInt {\n-        final Random rng;\n-        long index;\n-        final long fence;\n-        final int origin;\n-        final int bound;\n-        RandomIntsSpliterator(Random rng, long index, long fence,\n-                              int origin, int bound) {\n-            this.rng = rng; this.index = index; this.fence = fence;\n-            this.origin = origin; this.bound = bound;\n-        }\n-\n-        public RandomIntsSpliterator trySplit() {\n-            long i = index, m = (i + fence) >>> 1;\n-            return (m <= i) ? null :\n-                   new RandomIntsSpliterator(rng, i, index = m, origin, bound);\n-        }\n-\n-        public long estimateSize() {\n-            return fence - index;\n-        }\n-\n-        public int characteristics() {\n-            return (Spliterator.SIZED | Spliterator.SUBSIZED |\n-                    Spliterator.NONNULL | Spliterator.IMMUTABLE);\n-        }\n-\n-        public boolean tryAdvance(IntConsumer consumer) {\n-            if (consumer == null) throw new NullPointerException();\n-            long i = index, f = fence;\n-            if (i < f) {\n-                consumer.accept(rng.internalNextInt(origin, bound));\n-                index = i + 1;\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-        public void forEachRemaining(IntConsumer consumer) {\n-            if (consumer == null) throw new NullPointerException();\n-            long i = index, f = fence;\n-            if (i < f) {\n-                index = f;\n-                Random r = rng;\n-                int o = origin, b = bound;\n-                do {\n-                    consumer.accept(r.internalNextInt(o, b));\n-                } while (++i < f);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Spliterator for long streams.\n-     *\/\n-    static final class RandomLongsSpliterator implements Spliterator.OfLong {\n-        final Random rng;\n-        long index;\n-        final long fence;\n-        final long origin;\n-        final long bound;\n-        RandomLongsSpliterator(Random rng, long index, long fence,\n-                               long origin, long bound) {\n-            this.rng = rng; this.index = index; this.fence = fence;\n-            this.origin = origin; this.bound = bound;\n-        }\n-\n-        public RandomLongsSpliterator trySplit() {\n-            long i = index, m = (i + fence) >>> 1;\n-            return (m <= i) ? null :\n-                   new RandomLongsSpliterator(rng, i, index = m, origin, bound);\n-        }\n-\n-        public long estimateSize() {\n-            return fence - index;\n-        }\n-\n-        public int characteristics() {\n-            return (Spliterator.SIZED | Spliterator.SUBSIZED |\n-                    Spliterator.NONNULL | Spliterator.IMMUTABLE);\n-        }\n-\n-        public boolean tryAdvance(LongConsumer consumer) {\n-            if (consumer == null) throw new NullPointerException();\n-            long i = index, f = fence;\n-            if (i < f) {\n-                consumer.accept(rng.internalNextLong(origin, bound));\n-                index = i + 1;\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-        public void forEachRemaining(LongConsumer consumer) {\n-            if (consumer == null) throw new NullPointerException();\n-            long i = index, f = fence;\n-            if (i < f) {\n-                index = f;\n-                Random r = rng;\n-                long o = origin, b = bound;\n-                do {\n-                    consumer.accept(r.internalNextLong(o, b));\n-                } while (++i < f);\n-            }\n-        }\n-\n-    }\n-\n-    \/**\n-     * Spliterator for double streams.\n-     *\/\n-    static final class RandomDoublesSpliterator implements Spliterator.OfDouble {\n-        final Random rng;\n-        long index;\n-        final long fence;\n-        final double origin;\n-        final double bound;\n-        RandomDoublesSpliterator(Random rng, long index, long fence,\n-                                 double origin, double bound) {\n-            this.rng = rng; this.index = index; this.fence = fence;\n-            this.origin = origin; this.bound = bound;\n-        }\n-\n-        public RandomDoublesSpliterator trySplit() {\n-            long i = index, m = (i + fence) >>> 1;\n-            return (m <= i) ? null :\n-                   new RandomDoublesSpliterator(rng, i, index = m, origin, bound);\n-        }\n-\n-        public long estimateSize() {\n-            return fence - index;\n-        }\n-\n-        public int characteristics() {\n-            return (Spliterator.SIZED | Spliterator.SUBSIZED |\n-                    Spliterator.NONNULL | Spliterator.IMMUTABLE);\n-        }\n-\n-        public boolean tryAdvance(DoubleConsumer consumer) {\n-            if (consumer == null) throw new NullPointerException();\n-            long i = index, f = fence;\n-            if (i < f) {\n-                consumer.accept(rng.internalNextDouble(origin, bound));\n-                index = i + 1;\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-        public void forEachRemaining(DoubleConsumer consumer) {\n-            if (consumer == null) throw new NullPointerException();\n-            long i = index, f = fence;\n-            if (i < f) {\n-                index = f;\n-                Random r = rng;\n-                double o = origin, b = bound;\n-                do {\n-                    consumer.accept(r.internalNextDouble(o, b));\n-                } while (++i < f);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Serializable fields for Random.\n-     *\n-     * @serialField    seed long\n-     *              seed for random computations\n-     * @serialField    nextNextGaussian double\n-     *              next Gaussian to be returned\n-     * @serialField      haveNextNextGaussian boolean\n-     *              nextNextGaussian is valid\n-     *\/\n-    @java.io.Serial\n-    private static final ObjectStreamField[] serialPersistentFields = {\n-        new ObjectStreamField(\"seed\", Long.TYPE),\n-        new ObjectStreamField(\"nextNextGaussian\", Double.TYPE),\n-        new ObjectStreamField(\"haveNextNextGaussian\", Boolean.TYPE)\n-    };\n-\n-    \/**\n-     * Reconstitute the {@code Random} instance from a stream (that is,\n-     * deserialize it).\n-     *\n-     * @param  s the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\/\n-    @java.io.Serial\n-    private void readObject(java.io.ObjectInputStream s)\n-        throws java.io.IOException, ClassNotFoundException {\n-\n-        ObjectInputStream.GetField fields = s.readFields();\n-\n-        \/\/ The seed is read in as {@code long} for\n-        \/\/ historical reasons, but it is converted to an AtomicLong.\n-        long seedVal = fields.get(\"seed\", -1L);\n-        if (seedVal < 0)\n-          throw new java.io.StreamCorruptedException(\n-                              \"Random: invalid seed\");\n-        resetSeed(seedVal);\n-        nextNextGaussian = fields.get(\"nextNextGaussian\", 0.0);\n-        haveNextNextGaussian = fields.get(\"haveNextNextGaussian\", false);\n-    }\n-\n-    \/**\n-     * Save the {@code Random} instance to a stream.\n-     *\n-     * @param  s the {@code ObjectOutputStream} to which data is written\n-     * @throws IOException if an I\/O error occurs\n-     *\/\n-    @java.io.Serial\n-    private synchronized void writeObject(ObjectOutputStream s)\n-        throws IOException {\n-\n-        \/\/ set the values of the Serializable fields\n-        ObjectOutputStream.PutField fields = s.putFields();\n-\n-        \/\/ The seed is serialized as a long for historical reasons.\n-        fields.put(\"seed\", seed.get());\n-        fields.put(\"nextNextGaussian\", nextNextGaussian);\n-        fields.put(\"haveNextNextGaussian\", haveNextNextGaussian);\n-\n-        \/\/ save them\n-        s.writeFields();\n-    }\n-\n-    \/\/ Support for resetting seed while deserializing\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n-    private static final long seedOffset;\n-    static {\n-        try {\n-            seedOffset = unsafe.objectFieldOffset\n-                (Random.class.getDeclaredField(\"seed\"));\n-        } catch (Exception ex) { throw new Error(ex); }\n-    }\n-    private void resetSeed(long seedVal) {\n-        unsafe.putReferenceVolatile(this, seedOffset, new AtomicLong(seedVal));\n+        return super.doubles(randomNumberOrigin, randomNumberBound);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Random.java","additions":201,"deletions":462,"binary":false,"changes":663,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-\n@@ -28,0 +27,1 @@\n+import java.math.BigInteger;\n@@ -29,3 +29,0 @@\n-import java.util.function.DoubleConsumer;\n-import java.util.function.IntConsumer;\n-import java.util.function.LongConsumer;\n@@ -35,1 +32,4 @@\n-import java.util.stream.StreamSupport;\n+import java.util.stream.Stream;\n+import jdk.internal.util.random.RandomSupport;\n+import jdk.internal.util.random.RandomSupport.AbstractSplittableGenerator;\n+import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n@@ -38,5 +38,5 @@\n- * A generator of uniform pseudorandom values applicable for use in\n- * (among other contexts) isolated parallel computations that may\n- * generate subtasks. Class {@code SplittableRandom} supports methods for\n- * producing pseudorandom numbers of type {@code int}, {@code long},\n- * and {@code double} with similar usages as for class\n+ * A generator of uniform pseudorandom values (with period 2<sup>64<\/sup>)\n+ * applicable for use in (among other contexts) isolated parallel\n+ * computations that may generate subtasks. Class {@code SplittableRandom}\n+ * supports methods for producing pseudorandom numbers of type {@code int},\n+ * {@code long}, and {@code double} with similar usages as for class\n@@ -54,2 +54,2 @@\n- * (length of any series of generated values before it repeats) is at\n- * least 2<sup>64<\/sup>.\n+ * (length of any series of generated values before it repeats) is\n+ * 2<sup>64<\/sup>. <\/li>\n@@ -57,1 +57,1 @@\n- * <li>Method {@link #split} constructs and returns a new\n+ * <li> Method {@link #split} constructs and returns a new\n@@ -63,1 +63,1 @@\n- * SplittableRandom} object.\n+ * SplittableRandom} object.  <\/li>\n@@ -74,1 +74,1 @@\n- * stream.parallel()} mode.\n+ * stream.parallel()} mode.<\/li>\n@@ -83,1 +83,1 @@\n- * {@systemProperty java.util.secureRandomSeed} is set to {@code true}.\n+ * {@code java.util.secureRandomSeed} is set to {@code true}.\n@@ -89,1 +89,7 @@\n-public final class SplittableRandom {\n+@SuppressWarnings(\"exports\")\n+@RandomGeneratorProperties(\n+        name = \"SplittableRandom\",\n+        i = 64, j = 0, k = 0,\n+        equidistribution = 1\n+)\n+public final class SplittableRandom extends AbstractSplittableGenerator {\n@@ -163,6 +169,0 @@\n-    \/**\n-     * The least non-zero value returned by nextDouble(). This value\n-     * is scaled by a random value of 53 bits to produce a result.\n-     *\/\n-    private static final double DOUBLE_UNIT = 0x1.0p-53; \/\/ 1.0 \/ (1L << 53);\n-\n@@ -189,0 +189,1 @@\n+     * http:\/\/zimbry.blogspot.com\/2011\/09\/better-bit-mixing-improving-on.html\n@@ -198,0 +199,1 @@\n+     * http:\/\/zimbry.blogspot.com\/2011\/09\/better-bit-mixing-improving-on.html\n@@ -206,0 +208,2 @@\n+     * Uses the 64bit mix function from MurmurHash3.\n+     * https:\/\/github.com\/aappleby\/smhasher\/wiki\/MurmurHash3\n@@ -222,5 +226,0 @@\n-    \/\/ IllegalArgumentException messages\n-    static final String BAD_BOUND = \"bound must be positive\";\n-    static final String BAD_RANGE = \"bound must be greater than origin\";\n-    static final String BAD_SIZE  = \"size must be non-negative\";\n-\n@@ -230,127 +229,1 @@\n-    private static final AtomicLong defaultGen\n-        = new AtomicLong(mix64(System.currentTimeMillis()) ^\n-                         mix64(System.nanoTime()));\n-\n-    \/\/ at end of <clinit> to survive static initialization circularity\n-    static {\n-        if (java.security.AccessController.doPrivileged(\n-            new java.security.PrivilegedAction<Boolean>() {\n-                public Boolean run() {\n-                    return Boolean.getBoolean(\"java.util.secureRandomSeed\");\n-                }})) {\n-            byte[] seedBytes = java.security.SecureRandom.getSeed(8);\n-            long s = (long)seedBytes[0] & 0xffL;\n-            for (int i = 1; i < 8; ++i)\n-                s = (s << 8) | ((long)seedBytes[i] & 0xffL);\n-            defaultGen.set(s);\n-        }\n-    }\n-\n-    \/*\n-     * Internal versions of nextX methods used by streams, as well as\n-     * the public nextX(origin, bound) methods.  These exist mainly to\n-     * avoid the need for multiple versions of stream spliterators\n-     * across the different exported forms of streams.\n-     *\/\n-\n-    \/**\n-     * The form of nextLong used by LongStream Spliterators.  If\n-     * origin is greater than bound, acts as unbounded form of\n-     * nextLong, else as bounded form.\n-     *\n-     * @param origin the least value, unless greater than bound\n-     * @param bound the upper bound (exclusive), must not equal origin\n-     * @return a pseudorandom value\n-     *\/\n-    final long internalNextLong(long origin, long bound) {\n-        \/*\n-         * Four Cases:\n-         *\n-         * 1. If the arguments indicate unbounded form, act as\n-         * nextLong().\n-         *\n-         * 2. If the range is an exact power of two, apply the\n-         * associated bit mask.\n-         *\n-         * 3. If the range is positive, loop to avoid potential bias\n-         * when the implicit nextLong() bound (2<sup>64<\/sup>) is not\n-         * evenly divisible by the range. The loop rejects candidates\n-         * computed from otherwise over-represented values.  The\n-         * expected number of iterations under an ideal generator\n-         * varies from 1 to 2, depending on the bound. The loop itself\n-         * takes an unlovable form. Because the first candidate is\n-         * already available, we need a break-in-the-middle\n-         * construction, which is concisely but cryptically performed\n-         * within the while-condition of a body-less for loop.\n-         *\n-         * 4. Otherwise, the range cannot be represented as a positive\n-         * long.  The loop repeatedly generates unbounded longs until\n-         * obtaining a candidate meeting constraints (with an expected\n-         * number of iterations of less than two).\n-         *\/\n-\n-        long r = mix64(nextSeed());\n-        if (origin < bound) {\n-            long n = bound - origin, m = n - 1;\n-            if ((n & m) == 0L)  \/\/ power of two\n-                r = (r & m) + origin;\n-            else if (n > 0L) {  \/\/ reject over-represented candidates\n-                for (long u = r >>> 1;            \/\/ ensure nonnegative\n-                     u + m - (r = u % n) < 0L;    \/\/ rejection check\n-                     u = mix64(nextSeed()) >>> 1) \/\/ retry\n-                    ;\n-                r += origin;\n-            }\n-            else {              \/\/ range not representable as long\n-                while (r < origin || r >= bound)\n-                    r = mix64(nextSeed());\n-            }\n-        }\n-        return r;\n-    }\n-\n-    \/**\n-     * The form of nextInt used by IntStream Spliterators.\n-     * Exactly the same as long version, except for types.\n-     *\n-     * @param origin the least value, unless greater than bound\n-     * @param bound the upper bound (exclusive), must not equal origin\n-     * @return a pseudorandom value\n-     *\/\n-    final int internalNextInt(int origin, int bound) {\n-        int r = mix32(nextSeed());\n-        if (origin < bound) {\n-            int n = bound - origin, m = n - 1;\n-            if ((n & m) == 0)\n-                r = (r & m) + origin;\n-            else if (n > 0) {\n-                for (int u = r >>> 1;\n-                     u + m - (r = u % n) < 0;\n-                     u = mix32(nextSeed()) >>> 1)\n-                    ;\n-                r += origin;\n-            }\n-            else {\n-                while (r < origin || r >= bound)\n-                    r = mix32(nextSeed());\n-            }\n-        }\n-        return r;\n-    }\n-\n-    \/**\n-     * The form of nextDouble used by DoubleStream Spliterators.\n-     *\n-     * @param origin the least value, unless greater than bound\n-     * @param bound the upper bound (exclusive), must not equal origin\n-     * @return a pseudorandom value\n-     *\/\n-    final double internalNextDouble(double origin, double bound) {\n-        double r = (nextLong() >>> 11) * DOUBLE_UNIT;\n-        if (origin < bound) {\n-            r = r * (bound - origin) + origin;\n-            if (r >= bound) \/\/ correct for rounding\n-                r = Double.longBitsToDouble(Double.doubleToLongBits(bound) - 1);\n-        }\n-        return r;\n-    }\n+    private static final AtomicLong defaultGen = new AtomicLong(RandomSupport.initialSeed());\n@@ -378,1 +251,1 @@\n-        long s = defaultGen.getAndAdd(GOLDEN_GAMMA << 1);\n+        long s = defaultGen.getAndAdd(2 * GOLDEN_GAMMA);\n@@ -402,5 +275,3 @@\n-     * Fills a user-supplied byte array with generated pseudorandom bytes.\n-     *\n-     * @param  bytes the byte array to fill with pseudorandom bytes\n-     * @throws NullPointerException if bytes is null\n-     * @since  10\n+     * {@inheritDoc}\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 17\n@@ -408,11 +279,2 @@\n-    public void nextBytes(byte[] bytes) {\n-        int i = 0;\n-        int len = bytes.length;\n-        for (int words = len >> 3; words--> 0; ) {\n-            long rnd = nextLong();\n-            for (int n = 8; n--> 0; rnd >>>= Byte.SIZE)\n-                bytes[i++] = (byte)rnd;\n-        }\n-        if (i < len)\n-            for (long rnd = nextLong(); i < len; rnd >>>= Byte.SIZE)\n-                bytes[i++] = (byte)rnd;\n+    public SplittableRandom split(SplittableGenerator source) {\n+        return new SplittableRandom(source.nextLong(), mixGamma(source.nextLong()));\n@@ -422,3 +284,1 @@\n-     * Returns a pseudorandom {@code int} value.\n-     *\n-     * @return a pseudorandom {@code int} value\n+     * @hidden\n@@ -426,2 +286,3 @@\n-    public int nextInt() {\n-        return mix32(nextSeed());\n+    @Override\n+    public Spliterator.OfInt makeIntsSpliterator(long index, long fence, int origin, int bound) {\n+        return super.makeIntsSpliterator(index, fence, origin, bound);\n@@ -431,23 +292,5 @@\n-     * Returns a pseudorandom {@code int} value between zero (inclusive)\n-     * and the specified bound (exclusive).\n-     *\n-     * @param bound the upper bound (exclusive).  Must be positive.\n-     * @return a pseudorandom {@code int} value between zero\n-     *         (inclusive) and the bound (exclusive)\n-     * @throws IllegalArgumentException if {@code bound} is not positive\n-     *\/\n-    public int nextInt(int bound) {\n-        if (bound <= 0)\n-            throw new IllegalArgumentException(BAD_BOUND);\n-        \/\/ Specialize internalNextInt for origin 0\n-        int r = mix32(nextSeed());\n-        int m = bound - 1;\n-        if ((bound & m) == 0) \/\/ power of two\n-            r &= m;\n-        else { \/\/ reject over-represented candidates\n-            for (int u = r >>> 1;\n-                 u + m - (r = u % bound) < 0;\n-                 u = mix32(nextSeed()) >>> 1)\n-                ;\n-        }\n-        return r;\n+     * @hidden\n+     *\/\n+    @Override\n+    public Spliterator.OfLong makeLongsSpliterator(long index, long fence, long origin, long bound) {\n+        return super.makeLongsSpliterator(index, fence, origin, bound);\n@@ -457,14 +300,5 @@\n-     * Returns a pseudorandom {@code int} value between the specified\n-     * origin (inclusive) and the specified bound (exclusive).\n-     *\n-     * @param origin the least value returned\n-     * @param bound the upper bound (exclusive)\n-     * @return a pseudorandom {@code int} value between the origin\n-     *         (inclusive) and the bound (exclusive)\n-     * @throws IllegalArgumentException if {@code origin} is greater than\n-     *         or equal to {@code bound}\n-     *\/\n-    public int nextInt(int origin, int bound) {\n-        if (origin >= bound)\n-            throw new IllegalArgumentException(BAD_RANGE);\n-        return internalNextInt(origin, bound);\n+     * @hidden\n+     *\/\n+    @Override\n+    public Spliterator.OfDouble makeDoublesSpliterator(long index, long fence, double origin, double bound) {\n+        return super.makeDoublesSpliterator(index, fence, origin, bound);\n@@ -473,7 +307,3 @@\n-    \/**\n-     * Returns a pseudorandom {@code long} value.\n-     *\n-     * @return a pseudorandom {@code long} value\n-     *\/\n-    public long nextLong() {\n-        return mix64(nextSeed());\n+    @Override\n+    public int nextInt() {\n+        return mix32(nextSeed());\n@@ -482,24 +312,3 @@\n-    \/**\n-     * Returns a pseudorandom {@code long} value between zero (inclusive)\n-     * and the specified bound (exclusive).\n-     *\n-     * @param bound the upper bound (exclusive).  Must be positive.\n-     * @return a pseudorandom {@code long} value between zero\n-     *         (inclusive) and the bound (exclusive)\n-     * @throws IllegalArgumentException if {@code bound} is not positive\n-     *\/\n-    public long nextLong(long bound) {\n-        if (bound <= 0)\n-            throw new IllegalArgumentException(BAD_BOUND);\n-        \/\/ Specialize internalNextLong for origin 0\n-        long r = mix64(nextSeed());\n-        long m = bound - 1;\n-        if ((bound & m) == 0L) \/\/ power of two\n-            r &= m;\n-        else { \/\/ reject over-represented candidates\n-            for (long u = r >>> 1;\n-                 u + m - (r = u % bound) < 0L;\n-                 u = mix64(nextSeed()) >>> 1)\n-                ;\n-        }\n-        return r;\n+    @Override\n+    public long nextLong() {\n+        return mix64(nextSeed());\n@@ -509,14 +318,7 @@\n-     * Returns a pseudorandom {@code long} value between the specified\n-     * origin (inclusive) and the specified bound (exclusive).\n-     *\n-     * @param origin the least value returned\n-     * @param bound the upper bound (exclusive)\n-     * @return a pseudorandom {@code long} value between the origin\n-     *         (inclusive) and the bound (exclusive)\n-     * @throws IllegalArgumentException if {@code origin} is greater than\n-     *         or equal to {@code bound}\n-     *\/\n-    public long nextLong(long origin, long bound) {\n-        if (origin >= bound)\n-            throw new IllegalArgumentException(BAD_RANGE);\n-        return internalNextLong(origin, bound);\n+     * {@inheritDoc}\n+     * @throws NullPointerException {@inheritDoc}\n+     * @since 10\n+     *\/\n+    @Override\n+    public void nextBytes(byte[] bytes) {\n+        super.nextBytes(bytes);\n@@ -526,5 +328,3 @@\n-     * Returns a pseudorandom {@code double} value between zero\n-     * (inclusive) and one (exclusive).\n-     *\n-     * @return a pseudorandom {@code double} value between zero\n-     *         (inclusive) and one (exclusive)\n+     * {@inheritDoc}\n+     * @implSpec {@inheritDoc}\n+     * @since 17\n@@ -532,2 +332,3 @@\n-    public double nextDouble() {\n-        return (mix64(nextSeed()) >>> 11) * DOUBLE_UNIT;\n+    @Override\n+    public Stream<SplittableGenerator> splits() {\n+        return super.splits();\n@@ -537,14 +338,8 @@\n-     * Returns a pseudorandom {@code double} value between 0.0\n-     * (inclusive) and the specified bound (exclusive).\n-     *\n-     * @param bound the upper bound (exclusive).  Must be positive.\n-     * @return a pseudorandom {@code double} value between zero\n-     *         (inclusive) and the bound (exclusive)\n-     * @throws IllegalArgumentException if {@code bound} is not positive\n-     *\/\n-    public double nextDouble(double bound) {\n-        if (!(bound > 0.0))\n-            throw new IllegalArgumentException(BAD_BOUND);\n-        double result = (mix64(nextSeed()) >>> 11) * DOUBLE_UNIT * bound;\n-        return (result < bound) ?  result : \/\/ correct for rounding\n-            Double.longBitsToDouble(Double.doubleToLongBits(bound) - 1);\n+     * {@inheritDoc}\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @implSpec {@inheritDoc}\n+     * @since 17\n+     *\/\n+    @Override\n+    public Stream<SplittableGenerator> splits(long streamSize) {\n+        return super.splits(streamSize, this);\n@@ -554,14 +349,8 @@\n-     * Returns a pseudorandom {@code double} value between the specified\n-     * origin (inclusive) and bound (exclusive).\n-     *\n-     * @param origin the least value returned\n-     * @param bound the upper bound (exclusive)\n-     * @return a pseudorandom {@code double} value between the origin\n-     *         (inclusive) and the bound (exclusive)\n-     * @throws IllegalArgumentException if {@code origin} is greater than\n-     *         or equal to {@code bound}\n-     *\/\n-    public double nextDouble(double origin, double bound) {\n-        if (!(origin < bound))\n-            throw new IllegalArgumentException(BAD_RANGE);\n-        return internalNextDouble(origin, bound);\n+     * {@inheritDoc}\n+     * @throws NullPointerException {@inheritDoc}\n+     * @implSpec {@inheritDoc}\n+     * @since 17\n+     *\/\n+    @Override\n+    public Stream<SplittableGenerator> splits(SplittableGenerator source) {\n+        return super.splits(Long.MAX_VALUE, source);\n@@ -571,3 +360,5 @@\n-     * Returns a pseudorandom {@code boolean} value.\n-     *\n-     * @return a pseudorandom {@code boolean} value\n+     * {@inheritDoc}\n+     * @throws NullPointerException {@inheritDoc}\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @implSpec {@inheritDoc}\n+     * @since 17\n@@ -575,2 +366,3 @@\n-    public boolean nextBoolean() {\n-        return mix32(nextSeed()) < 0;\n+    @Override\n+    public Stream<SplittableGenerator> splits(long streamSize, SplittableGenerator source) {\n+        return super.splits(streamSize, source);\n@@ -579,3 +371,0 @@\n-    \/\/ stream methods, coded in a way intended to better isolate for\n-    \/\/ maintenance purposes the small differences across forms.\n-\n@@ -592,0 +381,1 @@\n+    @Override\n@@ -593,6 +383,1 @@\n-        if (streamSize < 0L)\n-            throw new IllegalArgumentException(BAD_SIZE);\n-        return StreamSupport.intStream\n-            (new RandomIntsSpliterator\n-             (this, 0L, streamSize, Integer.MAX_VALUE, 0),\n-             false);\n+        return super.ints(streamSize);\n@@ -610,0 +395,1 @@\n+    @Override\n@@ -611,4 +397,1 @@\n-        return StreamSupport.intStream\n-            (new RandomIntsSpliterator\n-             (this, 0L, Long.MAX_VALUE, Integer.MAX_VALUE, 0),\n-             false);\n+        return super.ints();\n@@ -632,10 +415,3 @@\n-    public IntStream ints(long streamSize, int randomNumberOrigin,\n-                          int randomNumberBound) {\n-        if (streamSize < 0L)\n-            throw new IllegalArgumentException(BAD_SIZE);\n-        if (randomNumberOrigin >= randomNumberBound)\n-            throw new IllegalArgumentException(BAD_RANGE);\n-        return StreamSupport.intStream\n-            (new RandomIntsSpliterator\n-             (this, 0L, streamSize, randomNumberOrigin, randomNumberBound),\n-             false);\n+    @Override\n+    public IntStream ints(long streamSize, int randomNumberOrigin, int randomNumberBound) {\n+        return super.ints(streamSize, randomNumberOrigin, randomNumberBound);\n@@ -659,0 +435,1 @@\n+    @Override\n@@ -660,6 +437,1 @@\n-        if (randomNumberOrigin >= randomNumberBound)\n-            throw new IllegalArgumentException(BAD_RANGE);\n-        return StreamSupport.intStream\n-            (new RandomIntsSpliterator\n-             (this, 0L, Long.MAX_VALUE, randomNumberOrigin, randomNumberBound),\n-             false);\n+        return super.ints(randomNumberOrigin, randomNumberBound);\n@@ -678,0 +450,1 @@\n+    @Override\n@@ -679,6 +452,1 @@\n-        if (streamSize < 0L)\n-            throw new IllegalArgumentException(BAD_SIZE);\n-        return StreamSupport.longStream\n-            (new RandomLongsSpliterator\n-             (this, 0L, streamSize, Long.MAX_VALUE, 0L),\n-             false);\n+        return super.longs(streamSize);\n@@ -696,0 +464,1 @@\n+    @Override\n@@ -697,4 +466,1 @@\n-        return StreamSupport.longStream\n-            (new RandomLongsSpliterator\n-             (this, 0L, Long.MAX_VALUE, Long.MAX_VALUE, 0L),\n-             false);\n+        return super.longs();\n@@ -718,10 +484,3 @@\n-    public LongStream longs(long streamSize, long randomNumberOrigin,\n-                            long randomNumberBound) {\n-        if (streamSize < 0L)\n-            throw new IllegalArgumentException(BAD_SIZE);\n-        if (randomNumberOrigin >= randomNumberBound)\n-            throw new IllegalArgumentException(BAD_RANGE);\n-        return StreamSupport.longStream\n-            (new RandomLongsSpliterator\n-             (this, 0L, streamSize, randomNumberOrigin, randomNumberBound),\n-             false);\n+    @Override\n+    public LongStream longs(long streamSize, long randomNumberOrigin, long randomNumberBound) {\n+        return super.longs(streamSize, randomNumberOrigin, randomNumberBound);\n@@ -745,0 +504,1 @@\n+    @Override\n@@ -746,6 +506,1 @@\n-        if (randomNumberOrigin >= randomNumberBound)\n-            throw new IllegalArgumentException(BAD_RANGE);\n-        return StreamSupport.longStream\n-            (new RandomLongsSpliterator\n-             (this, 0L, Long.MAX_VALUE, randomNumberOrigin, randomNumberBound),\n-             false);\n+        return super.longs(randomNumberOrigin, randomNumberBound);\n@@ -764,0 +519,1 @@\n+    @Override\n@@ -765,6 +521,1 @@\n-        if (streamSize < 0L)\n-            throw new IllegalArgumentException(BAD_SIZE);\n-        return StreamSupport.doubleStream\n-            (new RandomDoublesSpliterator\n-             (this, 0L, streamSize, Double.MAX_VALUE, 0.0),\n-             false);\n+        return super.doubles(streamSize);\n@@ -783,0 +534,1 @@\n+    @Override\n@@ -784,4 +536,1 @@\n-        return StreamSupport.doubleStream\n-            (new RandomDoublesSpliterator\n-             (this, 0L, Long.MAX_VALUE, Double.MAX_VALUE, 0.0),\n-             false);\n+        return super.doubles();\n@@ -805,10 +554,3 @@\n-    public DoubleStream doubles(long streamSize, double randomNumberOrigin,\n-                                double randomNumberBound) {\n-        if (streamSize < 0L)\n-            throw new IllegalArgumentException(BAD_SIZE);\n-        if (!(randomNumberOrigin < randomNumberBound))\n-            throw new IllegalArgumentException(BAD_RANGE);\n-        return StreamSupport.doubleStream\n-            (new RandomDoublesSpliterator\n-             (this, 0L, streamSize, randomNumberOrigin, randomNumberBound),\n-             false);\n+    @Override\n+    public DoubleStream doubles(long streamSize, double randomNumberOrigin, double randomNumberBound) {\n+        return super.doubles(streamSize, randomNumberOrigin, randomNumberBound);\n@@ -832,0 +574,1 @@\n+    @Override\n@@ -833,6 +576,1 @@\n-        if (!(randomNumberOrigin < randomNumberBound))\n-            throw new IllegalArgumentException(BAD_RANGE);\n-        return StreamSupport.doubleStream\n-            (new RandomDoublesSpliterator\n-             (this, 0L, Long.MAX_VALUE, randomNumberOrigin, randomNumberBound),\n-             false);\n+        return super.doubles(randomNumberOrigin, randomNumberBound);\n@@ -840,175 +578,0 @@\n-\n-    \/**\n-     * Spliterator for int streams.  We multiplex the four int\n-     * versions into one class by treating a bound less than origin as\n-     * unbounded, and also by treating \"infinite\" as equivalent to\n-     * Long.MAX_VALUE. For splits, it uses the standard divide-by-two\n-     * approach. The long and double versions of this class are\n-     * identical except for types.\n-     *\/\n-    private static final class RandomIntsSpliterator\n-            implements Spliterator.OfInt {\n-        final SplittableRandom rng;\n-        long index;\n-        final long fence;\n-        final int origin;\n-        final int bound;\n-        RandomIntsSpliterator(SplittableRandom rng, long index, long fence,\n-                              int origin, int bound) {\n-            this.rng = rng; this.index = index; this.fence = fence;\n-            this.origin = origin; this.bound = bound;\n-        }\n-\n-        public RandomIntsSpliterator trySplit() {\n-            long i = index, m = (i + fence) >>> 1;\n-            return (m <= i) ? null :\n-                new RandomIntsSpliterator(rng.split(), i, index = m, origin, bound);\n-        }\n-\n-        public long estimateSize() {\n-            return fence - index;\n-        }\n-\n-        public int characteristics() {\n-            return (Spliterator.SIZED | Spliterator.SUBSIZED |\n-                    Spliterator.NONNULL | Spliterator.IMMUTABLE);\n-        }\n-\n-        public boolean tryAdvance(IntConsumer consumer) {\n-            if (consumer == null) throw new NullPointerException();\n-            long i = index, f = fence;\n-            if (i < f) {\n-                consumer.accept(rng.internalNextInt(origin, bound));\n-                index = i + 1;\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-        public void forEachRemaining(IntConsumer consumer) {\n-            if (consumer == null) throw new NullPointerException();\n-            long i = index, f = fence;\n-            if (i < f) {\n-                index = f;\n-                SplittableRandom r = rng;\n-                int o = origin, b = bound;\n-                do {\n-                    consumer.accept(r.internalNextInt(o, b));\n-                } while (++i < f);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Spliterator for long streams.\n-     *\/\n-    private static final class RandomLongsSpliterator\n-            implements Spliterator.OfLong {\n-        final SplittableRandom rng;\n-        long index;\n-        final long fence;\n-        final long origin;\n-        final long bound;\n-        RandomLongsSpliterator(SplittableRandom rng, long index, long fence,\n-                               long origin, long bound) {\n-            this.rng = rng; this.index = index; this.fence = fence;\n-            this.origin = origin; this.bound = bound;\n-        }\n-\n-        public RandomLongsSpliterator trySplit() {\n-            long i = index, m = (i + fence) >>> 1;\n-            return (m <= i) ? null :\n-                new RandomLongsSpliterator(rng.split(), i, index = m, origin, bound);\n-        }\n-\n-        public long estimateSize() {\n-            return fence - index;\n-        }\n-\n-        public int characteristics() {\n-            return (Spliterator.SIZED | Spliterator.SUBSIZED |\n-                    Spliterator.NONNULL | Spliterator.IMMUTABLE);\n-        }\n-\n-        public boolean tryAdvance(LongConsumer consumer) {\n-            if (consumer == null) throw new NullPointerException();\n-            long i = index, f = fence;\n-            if (i < f) {\n-                consumer.accept(rng.internalNextLong(origin, bound));\n-                index = i + 1;\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-        public void forEachRemaining(LongConsumer consumer) {\n-            if (consumer == null) throw new NullPointerException();\n-            long i = index, f = fence;\n-            if (i < f) {\n-                index = f;\n-                SplittableRandom r = rng;\n-                long o = origin, b = bound;\n-                do {\n-                    consumer.accept(r.internalNextLong(o, b));\n-                } while (++i < f);\n-            }\n-        }\n-\n-    }\n-\n-    \/**\n-     * Spliterator for double streams.\n-     *\/\n-    private static final class RandomDoublesSpliterator\n-            implements Spliterator.OfDouble {\n-        final SplittableRandom rng;\n-        long index;\n-        final long fence;\n-        final double origin;\n-        final double bound;\n-        RandomDoublesSpliterator(SplittableRandom rng, long index, long fence,\n-                                 double origin, double bound) {\n-            this.rng = rng; this.index = index; this.fence = fence;\n-            this.origin = origin; this.bound = bound;\n-        }\n-\n-        public RandomDoublesSpliterator trySplit() {\n-            long i = index, m = (i + fence) >>> 1;\n-            return (m <= i) ? null :\n-                new RandomDoublesSpliterator(rng.split(), i, index = m, origin, bound);\n-        }\n-\n-        public long estimateSize() {\n-            return fence - index;\n-        }\n-\n-        public int characteristics() {\n-            return (Spliterator.SIZED | Spliterator.SUBSIZED |\n-                    Spliterator.NONNULL | Spliterator.IMMUTABLE);\n-        }\n-\n-        public boolean tryAdvance(DoubleConsumer consumer) {\n-            if (consumer == null) throw new NullPointerException();\n-            long i = index, f = fence;\n-            if (i < f) {\n-                consumer.accept(rng.internalNextDouble(origin, bound));\n-                index = i + 1;\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-        public void forEachRemaining(DoubleConsumer consumer) {\n-            if (consumer == null) throw new NullPointerException();\n-            long i = index, f = fence;\n-            if (i < f) {\n-                index = f;\n-                SplittableRandom r = rng;\n-                double o = origin, b = bound;\n-                do {\n-                    consumer.accept(r.internalNextDouble(o, b));\n-                } while (++i < f);\n-            }\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/SplittableRandom.java","additions":119,"deletions":556,"binary":false,"changes":675,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+ *\n+ * Additional modifications by Guy Steele in 2019 to refactor the code\n+ * and to implement the {@link RandomGenerator} interface.\n@@ -39,0 +42,1 @@\n+import java.math.BigInteger;\n@@ -40,0 +44,1 @@\n+import java.util.Map;\n@@ -44,3 +49,1 @@\n-import java.util.function.DoubleConsumer;\n-import java.util.function.IntConsumer;\n-import java.util.function.LongConsumer;\n+import java.util.random.RandomGenerator;\n@@ -50,1 +53,6 @@\n-import java.util.stream.StreamSupport;\n+import jdk.internal.util.random.RandomSupport;\n+import jdk.internal.util.random.RandomSupport.AbstractSpliteratorGenerator;\n+import jdk.internal.util.random.RandomSupport.RandomIntsSpliterator;\n+import jdk.internal.util.random.RandomSupport.RandomLongsSpliterator;\n+import jdk.internal.util.random.RandomSupport.RandomDoublesSpliterator;\n+import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n@@ -55,3 +63,4 @@\n- * A random number generator isolated to the current thread.  Like the\n- * global {@link java.util.Random} generator used by the {@link\n- * java.lang.Math} class, a {@code ThreadLocalRandom} is initialized\n+ * A random number generator (with period 2<sup>64<\/sup>) isolated\n+ * to the current thread.  Like the global {@link java.util.Random}\n+ * generator used by the {@link java.lang.Math} class,\n+ * a {@code ThreadLocalRandom} is initialized\n@@ -85,0 +94,6 @@\n+\n+@RandomGeneratorProperties(\n+        name = \"ThreadLocalRandom\",\n+        i = 64, j = 0, k = 0,\n+        equidistribution = 1\n+)\n@@ -88,2 +103,2 @@\n-     * Random) using a single static instance that accesses random\n-     * number state held in class Thread (primarily, field\n+     * Random) using a single static instance that accesses 64 bits of\n+     * random number state held in class java.lang.Thread (field\n@@ -108,2 +123,5 @@\n-     * here.)  Because ThreadLocalRandoms are not splittable\n-     * though, we use only a single 64bit gamma.\n+     * here.)  Note that ThreadLocalRandom is not a \"splittable\" generator\n+     * (it does not support the split method), but it behaves as if\n+     * one instance of the SplittableRandom algorithm had been\n+     * created for each thread, each with a distinct gamma parameter\n+     * (calculated from the thread id).\n@@ -126,5 +144,4 @@\n-     * The nextLocalGaussian ThreadLocal supports the very rarely used\n-     * nextGaussian method by providing a holder for the second of a\n-     * pair of them. As is true for the base class version of this\n-     * method, this time\/space tradeoff is probably never worthwhile,\n-     * but we provide identical statistical properties.\n+     * This implementation of ThreadLocalRandom overrides the\n+     * definition of the nextGaussian() method in the class Random,\n+     * and instead uses the ziggurat-based algorithm that is the\n+     * default for the RandomGenerator interface.\n@@ -133,6 +150,0 @@\n-    private static long mix64(long z) {\n-        z = (z ^ (z >>> 33)) * 0xff51afd7ed558ccdL;\n-        z = (z ^ (z >>> 33)) * 0xc4ceb9fe1a85ec53L;\n-        return z ^ (z >>> 33);\n-    }\n-\n@@ -165,1 +176,1 @@\n-        long seed = mix64(seeder.getAndAdd(SEEDER_INCREMENT));\n+        long seed = RandomSupport.mixMurmur64(seeder.getAndAdd(SEEDER_INCREMENT));\n@@ -172,1 +183,3 @@\n-     * Returns the current thread's {@code ThreadLocalRandom}.\n+     * Returns the current thread's {@code ThreadLocalRandom} object.\n+     * Methods of this object should be called only by the current thread,\n+     * not by other threads.\n@@ -194,0 +207,15 @@\n+    \/**\n+     * Update the thread local seed value by adding to it the sum\n+     * of {@code GOLDEN_GAMMA} (an odd value) and twice the thread id.\n+     * This sum is always odd (to guarantee that the generator\n+     * has maximum period) and is different for different threads.\n+     * Because thread id values are allocated consecutively starting\n+     * from 0, the high 32 bits of this sum will be the same as the\n+     * high 32 bits of {@code GOLDEN_GAMMA} unless an extremely large\n+     * number of threads have been created, and so the overall\n+     * value added to the thread local seed value will have at least\n+     * fourteen 01 and 10 transitions (see the documentation for the\n+     * method {@code mixGamma} in class {@code SplittableRandom}),\n+     * which should provide adequate statistical quality for\n+     * applications likely to use {@code ThreadLocalRandom}.\n+     *\/\n@@ -197,1 +225,1 @@\n-                  r = U.getLong(t, SEED) + GAMMA);\n+                  r = U.getLong(t, SEED) + (t.getId() << 1) + GOLDEN_GAMMA);\n@@ -214,702 +242,0 @@\n-    \/**\n-     * The form of nextLong used by LongStream Spliterators.  If\n-     * origin is greater than bound, acts as unbounded form of\n-     * nextLong, else as bounded form.\n-     *\n-     * @param origin the least value, unless greater than bound\n-     * @param bound the upper bound (exclusive), must not equal origin\n-     * @return a pseudorandom value\n-     *\/\n-    final long internalNextLong(long origin, long bound) {\n-        long r = mix64(nextSeed());\n-        if (origin < bound) {\n-            long n = bound - origin, m = n - 1;\n-            if ((n & m) == 0L)  \/\/ power of two\n-                r = (r & m) + origin;\n-            else if (n > 0L) {  \/\/ reject over-represented candidates\n-                for (long u = r >>> 1;            \/\/ ensure nonnegative\n-                     u + m - (r = u % n) < 0L;    \/\/ rejection check\n-                     u = mix64(nextSeed()) >>> 1) \/\/ retry\n-                    ;\n-                r += origin;\n-            }\n-            else {              \/\/ range not representable as long\n-                while (r < origin || r >= bound)\n-                    r = mix64(nextSeed());\n-            }\n-        }\n-        return r;\n-    }\n-\n-    \/**\n-     * The form of nextInt used by IntStream Spliterators.\n-     * Exactly the same as long version, except for types.\n-     *\n-     * @param origin the least value, unless greater than bound\n-     * @param bound the upper bound (exclusive), must not equal origin\n-     * @return a pseudorandom value\n-     *\/\n-    final int internalNextInt(int origin, int bound) {\n-        int r = mix32(nextSeed());\n-        if (origin < bound) {\n-            int n = bound - origin, m = n - 1;\n-            if ((n & m) == 0)\n-                r = (r & m) + origin;\n-            else if (n > 0) {\n-                for (int u = r >>> 1;\n-                     u + m - (r = u % n) < 0;\n-                     u = mix32(nextSeed()) >>> 1)\n-                    ;\n-                r += origin;\n-            }\n-            else {\n-                while (r < origin || r >= bound)\n-                    r = mix32(nextSeed());\n-            }\n-        }\n-        return r;\n-    }\n-\n-    \/**\n-     * The form of nextDouble used by DoubleStream Spliterators.\n-     *\n-     * @param origin the least value, unless greater than bound\n-     * @param bound the upper bound (exclusive), must not equal origin\n-     * @return a pseudorandom value\n-     *\/\n-    final double internalNextDouble(double origin, double bound) {\n-        double r = (nextLong() >>> 11) * DOUBLE_UNIT;\n-        if (origin < bound) {\n-            r = r * (bound - origin) + origin;\n-            if (r >= bound) \/\/ correct for rounding\n-                r = Double.longBitsToDouble(Double.doubleToLongBits(bound) - 1);\n-        }\n-        return r;\n-    }\n-\n-    \/**\n-     * Returns a pseudorandom {@code int} value.\n-     *\n-     * @return a pseudorandom {@code int} value\n-     *\/\n-    public int nextInt() {\n-        return mix32(nextSeed());\n-    }\n-\n-    \/**\n-     * Returns a pseudorandom {@code int} value between zero (inclusive)\n-     * and the specified bound (exclusive).\n-     *\n-     * @param bound the upper bound (exclusive).  Must be positive.\n-     * @return a pseudorandom {@code int} value between zero\n-     *         (inclusive) and the bound (exclusive)\n-     * @throws IllegalArgumentException if {@code bound} is not positive\n-     *\/\n-    public int nextInt(int bound) {\n-        if (bound <= 0)\n-            throw new IllegalArgumentException(BAD_BOUND);\n-        int r = mix32(nextSeed());\n-        int m = bound - 1;\n-        if ((bound & m) == 0) \/\/ power of two\n-            r &= m;\n-        else { \/\/ reject over-represented candidates\n-            for (int u = r >>> 1;\n-                 u + m - (r = u % bound) < 0;\n-                 u = mix32(nextSeed()) >>> 1)\n-                ;\n-        }\n-        return r;\n-    }\n-\n-    \/**\n-     * Returns a pseudorandom {@code int} value between the specified\n-     * origin (inclusive) and the specified bound (exclusive).\n-     *\n-     * @param origin the least value returned\n-     * @param bound the upper bound (exclusive)\n-     * @return a pseudorandom {@code int} value between the origin\n-     *         (inclusive) and the bound (exclusive)\n-     * @throws IllegalArgumentException if {@code origin} is greater than\n-     *         or equal to {@code bound}\n-     *\/\n-    public int nextInt(int origin, int bound) {\n-        if (origin >= bound)\n-            throw new IllegalArgumentException(BAD_RANGE);\n-        return internalNextInt(origin, bound);\n-    }\n-\n-    \/**\n-     * Returns a pseudorandom {@code long} value.\n-     *\n-     * @return a pseudorandom {@code long} value\n-     *\/\n-    public long nextLong() {\n-        return mix64(nextSeed());\n-    }\n-\n-    \/**\n-     * Returns a pseudorandom {@code long} value between zero (inclusive)\n-     * and the specified bound (exclusive).\n-     *\n-     * @param bound the upper bound (exclusive).  Must be positive.\n-     * @return a pseudorandom {@code long} value between zero\n-     *         (inclusive) and the bound (exclusive)\n-     * @throws IllegalArgumentException if {@code bound} is not positive\n-     *\/\n-    public long nextLong(long bound) {\n-        if (bound <= 0)\n-            throw new IllegalArgumentException(BAD_BOUND);\n-        long r = mix64(nextSeed());\n-        long m = bound - 1;\n-        if ((bound & m) == 0L) \/\/ power of two\n-            r &= m;\n-        else { \/\/ reject over-represented candidates\n-            for (long u = r >>> 1;\n-                 u + m - (r = u % bound) < 0L;\n-                 u = mix64(nextSeed()) >>> 1)\n-                ;\n-        }\n-        return r;\n-    }\n-\n-    \/**\n-     * Returns a pseudorandom {@code long} value between the specified\n-     * origin (inclusive) and the specified bound (exclusive).\n-     *\n-     * @param origin the least value returned\n-     * @param bound the upper bound (exclusive)\n-     * @return a pseudorandom {@code long} value between the origin\n-     *         (inclusive) and the bound (exclusive)\n-     * @throws IllegalArgumentException if {@code origin} is greater than\n-     *         or equal to {@code bound}\n-     *\/\n-    public long nextLong(long origin, long bound) {\n-        if (origin >= bound)\n-            throw new IllegalArgumentException(BAD_RANGE);\n-        return internalNextLong(origin, bound);\n-    }\n-\n-    \/**\n-     * Returns a pseudorandom {@code double} value between zero\n-     * (inclusive) and one (exclusive).\n-     *\n-     * @return a pseudorandom {@code double} value between zero\n-     *         (inclusive) and one (exclusive)\n-     *\/\n-    public double nextDouble() {\n-        return (mix64(nextSeed()) >>> 11) * DOUBLE_UNIT;\n-    }\n-\n-    \/**\n-     * Returns a pseudorandom {@code double} value between 0.0\n-     * (inclusive) and the specified bound (exclusive).\n-     *\n-     * @param bound the upper bound (exclusive).  Must be positive.\n-     * @return a pseudorandom {@code double} value between zero\n-     *         (inclusive) and the bound (exclusive)\n-     * @throws IllegalArgumentException if {@code bound} is not positive\n-     *\/\n-    public double nextDouble(double bound) {\n-        if (!(bound > 0.0))\n-            throw new IllegalArgumentException(BAD_BOUND);\n-        double result = (mix64(nextSeed()) >>> 11) * DOUBLE_UNIT * bound;\n-        return (result < bound) ? result : \/\/ correct for rounding\n-            Double.longBitsToDouble(Double.doubleToLongBits(bound) - 1);\n-    }\n-\n-    \/**\n-     * Returns a pseudorandom {@code double} value between the specified\n-     * origin (inclusive) and bound (exclusive).\n-     *\n-     * @param origin the least value returned\n-     * @param bound the upper bound (exclusive)\n-     * @return a pseudorandom {@code double} value between the origin\n-     *         (inclusive) and the bound (exclusive)\n-     * @throws IllegalArgumentException if {@code origin} is greater than\n-     *         or equal to {@code bound}\n-     *\/\n-    public double nextDouble(double origin, double bound) {\n-        if (!(origin < bound))\n-            throw new IllegalArgumentException(BAD_RANGE);\n-        return internalNextDouble(origin, bound);\n-    }\n-\n-    \/**\n-     * Returns a pseudorandom {@code boolean} value.\n-     *\n-     * @return a pseudorandom {@code boolean} value\n-     *\/\n-    public boolean nextBoolean() {\n-        return mix32(nextSeed()) < 0;\n-    }\n-\n-    \/**\n-     * Returns a pseudorandom {@code float} value between zero\n-     * (inclusive) and one (exclusive).\n-     *\n-     * @return a pseudorandom {@code float} value between zero\n-     *         (inclusive) and one (exclusive)\n-     *\/\n-    public float nextFloat() {\n-        return (mix32(nextSeed()) >>> 8) * FLOAT_UNIT;\n-    }\n-\n-    public double nextGaussian() {\n-        \/\/ Use nextLocalGaussian instead of nextGaussian field\n-        Double d = nextLocalGaussian.get();\n-        if (d != null) {\n-            nextLocalGaussian.set(null);\n-            return d.doubleValue();\n-        }\n-        double v1, v2, s;\n-        do {\n-            v1 = 2 * nextDouble() - 1; \/\/ between -1 and 1\n-            v2 = 2 * nextDouble() - 1; \/\/ between -1 and 1\n-            s = v1 * v1 + v2 * v2;\n-        } while (s >= 1 || s == 0);\n-        double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)\/s);\n-        nextLocalGaussian.set(Double.valueOf(v2 * multiplier));\n-        return v1 * multiplier;\n-    }\n-\n-    \/\/ stream methods, coded in a way intended to better isolate for\n-    \/\/ maintenance purposes the small differences across forms.\n-\n-    \/**\n-     * Returns a stream producing the given {@code streamSize} number of\n-     * pseudorandom {@code int} values.\n-     *\n-     * @param streamSize the number of values to generate\n-     * @return a stream of pseudorandom {@code int} values\n-     * @throws IllegalArgumentException if {@code streamSize} is\n-     *         less than zero\n-     * @since 1.8\n-     *\/\n-    public IntStream ints(long streamSize) {\n-        if (streamSize < 0L)\n-            throw new IllegalArgumentException(BAD_SIZE);\n-        return StreamSupport.intStream\n-            (new RandomIntsSpliterator\n-             (0L, streamSize, Integer.MAX_VALUE, 0),\n-             false);\n-    }\n-\n-    \/**\n-     * Returns an effectively unlimited stream of pseudorandom {@code int}\n-     * values.\n-     *\n-     * @implNote This method is implemented to be equivalent to {@code\n-     * ints(Long.MAX_VALUE)}.\n-     *\n-     * @return a stream of pseudorandom {@code int} values\n-     * @since 1.8\n-     *\/\n-    public IntStream ints() {\n-        return StreamSupport.intStream\n-            (new RandomIntsSpliterator\n-             (0L, Long.MAX_VALUE, Integer.MAX_VALUE, 0),\n-             false);\n-    }\n-\n-    \/**\n-     * Returns a stream producing the given {@code streamSize} number\n-     * of pseudorandom {@code int} values, each conforming to the given\n-     * origin (inclusive) and bound (exclusive).\n-     *\n-     * @param streamSize the number of values to generate\n-     * @param randomNumberOrigin the origin (inclusive) of each random value\n-     * @param randomNumberBound the bound (exclusive) of each random value\n-     * @return a stream of pseudorandom {@code int} values,\n-     *         each with the given origin (inclusive) and bound (exclusive)\n-     * @throws IllegalArgumentException if {@code streamSize} is\n-     *         less than zero, or {@code randomNumberOrigin}\n-     *         is greater than or equal to {@code randomNumberBound}\n-     * @since 1.8\n-     *\/\n-    public IntStream ints(long streamSize, int randomNumberOrigin,\n-                          int randomNumberBound) {\n-        if (streamSize < 0L)\n-            throw new IllegalArgumentException(BAD_SIZE);\n-        if (randomNumberOrigin >= randomNumberBound)\n-            throw new IllegalArgumentException(BAD_RANGE);\n-        return StreamSupport.intStream\n-            (new RandomIntsSpliterator\n-             (0L, streamSize, randomNumberOrigin, randomNumberBound),\n-             false);\n-    }\n-\n-    \/**\n-     * Returns an effectively unlimited stream of pseudorandom {@code\n-     * int} values, each conforming to the given origin (inclusive) and bound\n-     * (exclusive).\n-     *\n-     * @implNote This method is implemented to be equivalent to {@code\n-     * ints(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.\n-     *\n-     * @param randomNumberOrigin the origin (inclusive) of each random value\n-     * @param randomNumberBound the bound (exclusive) of each random value\n-     * @return a stream of pseudorandom {@code int} values,\n-     *         each with the given origin (inclusive) and bound (exclusive)\n-     * @throws IllegalArgumentException if {@code randomNumberOrigin}\n-     *         is greater than or equal to {@code randomNumberBound}\n-     * @since 1.8\n-     *\/\n-    public IntStream ints(int randomNumberOrigin, int randomNumberBound) {\n-        if (randomNumberOrigin >= randomNumberBound)\n-            throw new IllegalArgumentException(BAD_RANGE);\n-        return StreamSupport.intStream\n-            (new RandomIntsSpliterator\n-             (0L, Long.MAX_VALUE, randomNumberOrigin, randomNumberBound),\n-             false);\n-    }\n-\n-    \/**\n-     * Returns a stream producing the given {@code streamSize} number of\n-     * pseudorandom {@code long} values.\n-     *\n-     * @param streamSize the number of values to generate\n-     * @return a stream of pseudorandom {@code long} values\n-     * @throws IllegalArgumentException if {@code streamSize} is\n-     *         less than zero\n-     * @since 1.8\n-     *\/\n-    public LongStream longs(long streamSize) {\n-        if (streamSize < 0L)\n-            throw new IllegalArgumentException(BAD_SIZE);\n-        return StreamSupport.longStream\n-            (new RandomLongsSpliterator\n-             (0L, streamSize, Long.MAX_VALUE, 0L),\n-             false);\n-    }\n-\n-    \/**\n-     * Returns an effectively unlimited stream of pseudorandom {@code long}\n-     * values.\n-     *\n-     * @implNote This method is implemented to be equivalent to {@code\n-     * longs(Long.MAX_VALUE)}.\n-     *\n-     * @return a stream of pseudorandom {@code long} values\n-     * @since 1.8\n-     *\/\n-    public LongStream longs() {\n-        return StreamSupport.longStream\n-            (new RandomLongsSpliterator\n-             (0L, Long.MAX_VALUE, Long.MAX_VALUE, 0L),\n-             false);\n-    }\n-\n-    \/**\n-     * Returns a stream producing the given {@code streamSize} number of\n-     * pseudorandom {@code long}, each conforming to the given origin\n-     * (inclusive) and bound (exclusive).\n-     *\n-     * @param streamSize the number of values to generate\n-     * @param randomNumberOrigin the origin (inclusive) of each random value\n-     * @param randomNumberBound the bound (exclusive) of each random value\n-     * @return a stream of pseudorandom {@code long} values,\n-     *         each with the given origin (inclusive) and bound (exclusive)\n-     * @throws IllegalArgumentException if {@code streamSize} is\n-     *         less than zero, or {@code randomNumberOrigin}\n-     *         is greater than or equal to {@code randomNumberBound}\n-     * @since 1.8\n-     *\/\n-    public LongStream longs(long streamSize, long randomNumberOrigin,\n-                            long randomNumberBound) {\n-        if (streamSize < 0L)\n-            throw new IllegalArgumentException(BAD_SIZE);\n-        if (randomNumberOrigin >= randomNumberBound)\n-            throw new IllegalArgumentException(BAD_RANGE);\n-        return StreamSupport.longStream\n-            (new RandomLongsSpliterator\n-             (0L, streamSize, randomNumberOrigin, randomNumberBound),\n-             false);\n-    }\n-\n-    \/**\n-     * Returns an effectively unlimited stream of pseudorandom {@code\n-     * long} values, each conforming to the given origin (inclusive) and bound\n-     * (exclusive).\n-     *\n-     * @implNote This method is implemented to be equivalent to {@code\n-     * longs(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.\n-     *\n-     * @param randomNumberOrigin the origin (inclusive) of each random value\n-     * @param randomNumberBound the bound (exclusive) of each random value\n-     * @return a stream of pseudorandom {@code long} values,\n-     *         each with the given origin (inclusive) and bound (exclusive)\n-     * @throws IllegalArgumentException if {@code randomNumberOrigin}\n-     *         is greater than or equal to {@code randomNumberBound}\n-     * @since 1.8\n-     *\/\n-    public LongStream longs(long randomNumberOrigin, long randomNumberBound) {\n-        if (randomNumberOrigin >= randomNumberBound)\n-            throw new IllegalArgumentException(BAD_RANGE);\n-        return StreamSupport.longStream\n-            (new RandomLongsSpliterator\n-             (0L, Long.MAX_VALUE, randomNumberOrigin, randomNumberBound),\n-             false);\n-    }\n-\n-    \/**\n-     * Returns a stream producing the given {@code streamSize} number of\n-     * pseudorandom {@code double} values, each between zero\n-     * (inclusive) and one (exclusive).\n-     *\n-     * @param streamSize the number of values to generate\n-     * @return a stream of {@code double} values\n-     * @throws IllegalArgumentException if {@code streamSize} is\n-     *         less than zero\n-     * @since 1.8\n-     *\/\n-    public DoubleStream doubles(long streamSize) {\n-        if (streamSize < 0L)\n-            throw new IllegalArgumentException(BAD_SIZE);\n-        return StreamSupport.doubleStream\n-            (new RandomDoublesSpliterator\n-             (0L, streamSize, Double.MAX_VALUE, 0.0),\n-             false);\n-    }\n-\n-    \/**\n-     * Returns an effectively unlimited stream of pseudorandom {@code\n-     * double} values, each between zero (inclusive) and one\n-     * (exclusive).\n-     *\n-     * @implNote This method is implemented to be equivalent to {@code\n-     * doubles(Long.MAX_VALUE)}.\n-     *\n-     * @return a stream of pseudorandom {@code double} values\n-     * @since 1.8\n-     *\/\n-    public DoubleStream doubles() {\n-        return StreamSupport.doubleStream\n-            (new RandomDoublesSpliterator\n-             (0L, Long.MAX_VALUE, Double.MAX_VALUE, 0.0),\n-             false);\n-    }\n-\n-    \/**\n-     * Returns a stream producing the given {@code streamSize} number of\n-     * pseudorandom {@code double} values, each conforming to the given origin\n-     * (inclusive) and bound (exclusive).\n-     *\n-     * @param streamSize the number of values to generate\n-     * @param randomNumberOrigin the origin (inclusive) of each random value\n-     * @param randomNumberBound the bound (exclusive) of each random value\n-     * @return a stream of pseudorandom {@code double} values,\n-     *         each with the given origin (inclusive) and bound (exclusive)\n-     * @throws IllegalArgumentException if {@code streamSize} is\n-     *         less than zero, or {@code randomNumberOrigin}\n-     *         is greater than or equal to {@code randomNumberBound}\n-     * @since 1.8\n-     *\/\n-    public DoubleStream doubles(long streamSize, double randomNumberOrigin,\n-                                double randomNumberBound) {\n-        if (streamSize < 0L)\n-            throw new IllegalArgumentException(BAD_SIZE);\n-        if (!(randomNumberOrigin < randomNumberBound))\n-            throw new IllegalArgumentException(BAD_RANGE);\n-        return StreamSupport.doubleStream\n-            (new RandomDoublesSpliterator\n-             (0L, streamSize, randomNumberOrigin, randomNumberBound),\n-             false);\n-    }\n-\n-    \/**\n-     * Returns an effectively unlimited stream of pseudorandom {@code\n-     * double} values, each conforming to the given origin (inclusive) and bound\n-     * (exclusive).\n-     *\n-     * @implNote This method is implemented to be equivalent to {@code\n-     * doubles(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.\n-     *\n-     * @param randomNumberOrigin the origin (inclusive) of each random value\n-     * @param randomNumberBound the bound (exclusive) of each random value\n-     * @return a stream of pseudorandom {@code double} values,\n-     *         each with the given origin (inclusive) and bound (exclusive)\n-     * @throws IllegalArgumentException if {@code randomNumberOrigin}\n-     *         is greater than or equal to {@code randomNumberBound}\n-     * @since 1.8\n-     *\/\n-    public DoubleStream doubles(double randomNumberOrigin, double randomNumberBound) {\n-        if (!(randomNumberOrigin < randomNumberBound))\n-            throw new IllegalArgumentException(BAD_RANGE);\n-        return StreamSupport.doubleStream\n-            (new RandomDoublesSpliterator\n-             (0L, Long.MAX_VALUE, randomNumberOrigin, randomNumberBound),\n-             false);\n-    }\n-\n-    \/**\n-     * Spliterator for int streams.  We multiplex the four int\n-     * versions into one class by treating a bound less than origin as\n-     * unbounded, and also by treating \"infinite\" as equivalent to\n-     * Long.MAX_VALUE. For splits, it uses the standard divide-by-two\n-     * approach. The long and double versions of this class are\n-     * identical except for types.\n-     *\/\n-    private static final class RandomIntsSpliterator\n-            implements Spliterator.OfInt {\n-        long index;\n-        final long fence;\n-        final int origin;\n-        final int bound;\n-        RandomIntsSpliterator(long index, long fence,\n-                              int origin, int bound) {\n-            this.index = index; this.fence = fence;\n-            this.origin = origin; this.bound = bound;\n-        }\n-\n-        public RandomIntsSpliterator trySplit() {\n-            long i = index, m = (i + fence) >>> 1;\n-            return (m <= i) ? null :\n-                new RandomIntsSpliterator(i, index = m, origin, bound);\n-        }\n-\n-        public long estimateSize() {\n-            return fence - index;\n-        }\n-\n-        public int characteristics() {\n-            return (Spliterator.SIZED | Spliterator.SUBSIZED |\n-                    Spliterator.NONNULL | Spliterator.IMMUTABLE);\n-        }\n-\n-        public boolean tryAdvance(IntConsumer consumer) {\n-            if (consumer == null) throw new NullPointerException();\n-            long i = index, f = fence;\n-            if (i < f) {\n-                consumer.accept(ThreadLocalRandom.current().internalNextInt(origin, bound));\n-                index = i + 1;\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-        public void forEachRemaining(IntConsumer consumer) {\n-            if (consumer == null) throw new NullPointerException();\n-            long i = index, f = fence;\n-            if (i < f) {\n-                index = f;\n-                int o = origin, b = bound;\n-                ThreadLocalRandom rng = ThreadLocalRandom.current();\n-                do {\n-                    consumer.accept(rng.internalNextInt(o, b));\n-                } while (++i < f);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Spliterator for long streams.\n-     *\/\n-    private static final class RandomLongsSpliterator\n-            implements Spliterator.OfLong {\n-        long index;\n-        final long fence;\n-        final long origin;\n-        final long bound;\n-        RandomLongsSpliterator(long index, long fence,\n-                               long origin, long bound) {\n-            this.index = index; this.fence = fence;\n-            this.origin = origin; this.bound = bound;\n-        }\n-\n-        public RandomLongsSpliterator trySplit() {\n-            long i = index, m = (i + fence) >>> 1;\n-            return (m <= i) ? null :\n-                new RandomLongsSpliterator(i, index = m, origin, bound);\n-        }\n-\n-        public long estimateSize() {\n-            return fence - index;\n-        }\n-\n-        public int characteristics() {\n-            return (Spliterator.SIZED | Spliterator.SUBSIZED |\n-                    Spliterator.NONNULL | Spliterator.IMMUTABLE);\n-        }\n-\n-        public boolean tryAdvance(LongConsumer consumer) {\n-            if (consumer == null) throw new NullPointerException();\n-            long i = index, f = fence;\n-            if (i < f) {\n-                consumer.accept(ThreadLocalRandom.current().internalNextLong(origin, bound));\n-                index = i + 1;\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-        public void forEachRemaining(LongConsumer consumer) {\n-            if (consumer == null) throw new NullPointerException();\n-            long i = index, f = fence;\n-            if (i < f) {\n-                index = f;\n-                long o = origin, b = bound;\n-                ThreadLocalRandom rng = ThreadLocalRandom.current();\n-                do {\n-                    consumer.accept(rng.internalNextLong(o, b));\n-                } while (++i < f);\n-            }\n-        }\n-\n-    }\n-\n-    \/**\n-     * Spliterator for double streams.\n-     *\/\n-    private static final class RandomDoublesSpliterator\n-            implements Spliterator.OfDouble {\n-        long index;\n-        final long fence;\n-        final double origin;\n-        final double bound;\n-        RandomDoublesSpliterator(long index, long fence,\n-                                 double origin, double bound) {\n-            this.index = index; this.fence = fence;\n-            this.origin = origin; this.bound = bound;\n-        }\n-\n-        public RandomDoublesSpliterator trySplit() {\n-            long i = index, m = (i + fence) >>> 1;\n-            return (m <= i) ? null :\n-                new RandomDoublesSpliterator(i, index = m, origin, bound);\n-        }\n-\n-        public long estimateSize() {\n-            return fence - index;\n-        }\n-\n-        public int characteristics() {\n-            return (Spliterator.SIZED | Spliterator.SUBSIZED |\n-                    Spliterator.NONNULL | Spliterator.IMMUTABLE);\n-        }\n-\n-        public boolean tryAdvance(DoubleConsumer consumer) {\n-            if (consumer == null) throw new NullPointerException();\n-            long i = index, f = fence;\n-            if (i < f) {\n-                consumer.accept(ThreadLocalRandom.current().internalNextDouble(origin, bound));\n-                index = i + 1;\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-        public void forEachRemaining(DoubleConsumer consumer) {\n-            if (consumer == null) throw new NullPointerException();\n-            long i = index, f = fence;\n-            if (i < f) {\n-                index = f;\n-                double o = origin, b = bound;\n-                ThreadLocalRandom rng = ThreadLocalRandom.current();\n-                do {\n-                    consumer.accept(rng.internalNextDouble(o, b));\n-                } while (++i < f);\n-            }\n-        }\n-    }\n-\n-\n@@ -1028,1 +354,6 @@\n-     * The seed increment.\n+     * The seed increment.  This must be an odd value for the generator to\n+     * have the maximum period (2 to the 64th power).\n+     *\n+     * The value 0x9e3779b97f4a7c15L is odd, and moreover consists of the\n+     * first 64 bits of the fractional part of the golden ratio,\n+     * which is known to generate good Weyl sequences.\n@@ -1030,1 +361,1 @@\n-    private static final long GAMMA = 0x9e3779b97f4a7c15L;\n+    private static final long GOLDEN_GAMMA = 0x9e3779b97f4a7c15L;\n@@ -1042,7 +373,0 @@\n-    \/**\n-     * The least non-zero value returned by nextDouble(). This value\n-     * is scaled by a random value of 53 bits to produce a result.\n-     *\/\n-    private static final double DOUBLE_UNIT = 0x1.0p-53;  \/\/ 1.0  \/ (1L << 53)\n-    private static final float  FLOAT_UNIT  = 0x1.0p-24f; \/\/ 1.0f \/ (1 << 24)\n-\n@@ -1069,4 +393,0 @@\n-    \/** Rarely-used holder for the second of a pair of Gaussians *\/\n-    private static final ThreadLocal<Double> nextLocalGaussian =\n-        new ThreadLocal<>();\n-\n@@ -1077,1 +397,43 @@\n-    static final ThreadLocalRandom instance = new ThreadLocalRandom();\n+    private static final ThreadLocalRandom instance = new ThreadLocalRandom();\n+\n+    private static final class ThreadLocalRandomProxy extends Random {\n+        @java.io.Serial\n+        static final long serialVersionUID = 0L;\n+\n+\n+        static final AbstractSpliteratorGenerator proxy = new ThreadLocalRandomProxy();\n+\n+\n+        public int nextInt() {\n+            return ThreadLocalRandom.current().nextInt();\n+        }\n+\n+        public long nextLong() {\n+            return ThreadLocalRandom.current().nextLong();\n+        }\n+    }\n+\n+    \/\/ Methods required by class AbstractSpliteratorGenerator\n+    \/**\n+     * @hidden\n+     *\/\n+    @Override\n+    public Spliterator.OfInt makeIntsSpliterator(long index, long fence, int origin, int bound) {\n+        return new RandomIntsSpliterator(ThreadLocalRandomProxy.proxy, index, fence, origin, bound);\n+    }\n+\n+    \/**\n+     * @hidden\n+     *\/\n+    @Override\n+    public Spliterator.OfLong makeLongsSpliterator(long index, long fence, long origin, long bound) {\n+        return new RandomLongsSpliterator(ThreadLocalRandomProxy.proxy, index, fence, origin, bound);\n+    }\n+\n+    \/**\n+     * @hidden\n+     *\/\n+    @Override\n+    public Spliterator.OfDouble makeDoublesSpliterator(long index, long fence, double origin, double bound) {\n+        return new RandomDoublesSpliterator(ThreadLocalRandomProxy.proxy, index, fence, origin, bound);\n+    }\n@@ -1083,2 +445,2 @@\n-        = new AtomicLong(mix64(System.currentTimeMillis()) ^\n-                         mix64(System.nanoTime()));\n+        = new AtomicLong(RandomSupport.mixMurmur64(System.currentTimeMillis()) ^\n+                         RandomSupport.mixMurmur64(System.nanoTime()));\n@@ -1097,0 +459,245 @@\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public boolean nextBoolean() {\n+        return super.nextBoolean();\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public int nextInt() {\n+        return mix32(nextSeed());\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     *\/\n+    @Override\n+    public int nextInt(int bound) {\n+        return super.nextInt(bound);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     *\/\n+    @Override\n+    public int nextInt(int origin, int bound) {\n+        return super.nextInt(origin, bound);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public long nextLong() {\n+        return RandomSupport.mixMurmur64(nextSeed());\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     *\/\n+    @Override\n+    public long nextLong(long bound) {\n+        return super.nextLong(bound);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     *\/\n+    @Override\n+    public long nextLong(long origin, long bound) {\n+        return super.nextLong(origin, bound);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @since 7\n+     *\/\n+    public float nextFloat() {\n+        return super.nextFloat();\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @implNote {@inheritDoc}\n+     * @since 17\n+     *\/\n+    public float nextFloat(float bound) {\n+         return super.nextFloat(bound);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @implNote {@inheritDoc}\n+     * @since 17\n+     *\/\n+    public float nextFloat(float origin, float bound) {\n+        return super.nextFloat(origin, bound);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @since 7\n+     *\/\n+    public double nextDouble() {\n+        return super.nextDouble();\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @implNote {@inheritDoc}\n+     * @since 17\n+     *\/\n+    public double nextDouble(double bound) {\n+        return super.nextDouble(bound);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @implNote {@inheritDoc}\n+     * @since 17\n+     *\/\n+    public double nextDouble(double origin, double bound) {\n+        return super.nextDouble(origin, bound);\n+    }\n+    \/**\n+     * {@inheritDoc}\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @since 1.8\n+     *\/\n+    @Override\n+    public IntStream ints(long streamSize) {\n+        return super.ints(streamSize);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @implNote This method is implemented to be equivalent to\n+     *           {@code ints(Long.MAX_VALUE)}.\n+     * @since 1.8\n+     *\/\n+    @Override\n+    public IntStream ints() {\n+        return super.ints();\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @since 1.8\n+     *\/\n+    @Override\n+    public IntStream ints(long streamSize, int randomNumberOrigin, int randomNumberBound) {\n+        return super.ints(streamSize, randomNumberOrigin, randomNumberBound);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @implNote This method is implemented to be equivalent to\n+     *           {@code ints(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @since 1.8\n+     *\/\n+    @Override\n+    public IntStream ints(int randomNumberOrigin, int randomNumberBound) {\n+        return super.ints(randomNumberOrigin, randomNumberBound);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @since 1.8\n+     *\/\n+    @Override\n+    public LongStream longs(long streamSize) {\n+        return super.longs(streamSize);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @implNote This method is implemented to be equivalent to\n+     *           {@code longs(Long.MAX_VALUE)}.\n+     * @since 1.8\n+     *\/\n+    @Override\n+    public LongStream longs() {\n+        return super.longs();\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @since 1.8\n+     *\/\n+    @Override\n+    public LongStream longs(long streamSize, long randomNumberOrigin, long randomNumberBound) {\n+        return super.longs(streamSize, randomNumberOrigin, randomNumberBound);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @implNote This method is implemented to be equivalent to\n+     *           {@code longs(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @since 1.8\n+     *\/\n+    @Override\n+    public LongStream longs(long randomNumberOrigin, long randomNumberBound) {\n+        return super.longs(randomNumberOrigin, randomNumberBound);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @since 1.8\n+     *\/\n+    @Override\n+    public DoubleStream doubles(long streamSize) {\n+        return super.doubles(streamSize);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @implNote This method is implemented to be equivalent to\n+     *           {@code doubles(Long.MAX_VALUE)}.\n+     * @since 1.8\n+     *\/\n+    @Override\n+    public DoubleStream doubles() {\n+        return super.doubles();\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @since 1.8\n+     *\/\n+    @Override\n+    public DoubleStream doubles(long streamSize, double randomNumberOrigin, double randomNumberBound) {\n+        return super.doubles(streamSize, randomNumberOrigin, randomNumberBound);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @implNote This method is implemented to be equivalent to\n+     *           {@code doubles(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.\n+     * @throws IllegalArgumentException {@inheritDoc}\n+     * @since 1.8\n+     *\/\n+    @Override\n+    public DoubleStream doubles(double randomNumberOrigin, double randomNumberBound) {\n+        return super.doubles(randomNumberOrigin, randomNumberBound);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadLocalRandom.java","additions":350,"deletions":743,"binary":false,"changes":1093,"status":"modified"},{"patch":"@@ -0,0 +1,1546 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util.random;\n+\n+import java.math.BigInteger;\n+import java.security.SecureRandom;\n+import java.util.Objects;\n+import java.util.concurrent.ThreadLocalRandom;\n+import jdk.internal.util.random.RandomSupport;\n+import jdk.internal.util.random.RandomSupport.*;\n+\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * The {@link RandomGenerator} interface is designed to provide a common\n+ * protocol for objects that generate random or (more typically) pseudorandom\n+ * sequences of numbers (or Boolean values). Such a sequence may be obtained by\n+ * either repeatedly invoking a method that returns a single pseudorandomly\n+ * chosen value, or by invoking a method that returns a stream of\n+ * pseudorandomly chosen values.\n+ *\n+ * <p> Ideally, given an implicitly or explicitly specified range of values,\n+ * each value would be chosen independently and uniformly from that range. In\n+ * practice, one may have to settle for some approximation to independence and\n+ * uniformity.\n+ *\n+ * <p> In the case of {@code int}, {@code long}, and {@code boolean} values, if\n+ * there is no explicit specification of range, then the range includes all\n+ * possible values of the type. In the case of {@code float} and {@code double}\n+ * values, first a value is always chosen uniformly from the set of\n+ * 2<sup><i>w<\/i><\/sup> values between 0.0 (inclusive) and 1.0 (exclusive),\n+ * where <i>w<\/i> is 23 for {@code float} values and 52 for {@code double}\n+ * values, such that adjacent values differ by 2<sup>&minus;<i>w<\/i><\/sup>\n+ * (notice that this set is a <i>subset<\/i> of the set of\n+ * <i>all representable floating-point values<\/i> between 0.0 (inclusive) and 1.0 (exclusive));\n+ * then if an explicit range was specified, then the chosen number is\n+ * computationally scaled and translated so as to appear to have been chosen\n+ * approximately uniformly from that explicit range.\n+ *\n+ * <p> Each method that returns a stream produces a stream of values each of\n+ * which is chosen in the same manner as for a method that returns a single\n+ * pseudorandomly chosen value. For example, if {@code r} implements\n+ * {@link RandomGenerator}, then the method call {@code r.ints(100)} returns a\n+ * stream of 100 {@code int} values. These are not necessarily the exact same\n+ * values that would have been returned if instead {@code r.nextInt()} had been\n+ * called 100 times; all that is guaranteed is that each value in the stream is\n+ * chosen in a similar pseudorandom manner from the same range.\n+ *\n+ * <p> Every object that implements the {@link RandomGenerator} interface by\n+ * using a pseudorandom algorithm is assumed to contain a finite amount of\n+ * state. Using such an object to generate a pseudorandomly chosen value alters\n+ * its state by computing a new state as a function of the current state,\n+ * without reference to any information other than the current state. The number\n+ * of distinct possible states of such an object is called its <i>period<\/i>.\n+ * (Some implementations of the {@link RandomGenerator} interface may be truly\n+ * random rather than pseudorandom, for example relying on the statistical\n+ * behavior of a physical object to derive chosen values. Such implementations\n+ * do not have a fixed period.)\n+ *\n+ * <p> As a rule, objects that implement the {@link RandomGenerator} interface\n+ * need not be thread-safe. It is recommended that multithreaded applications\n+ * use either {@link ThreadLocalRandom} or (preferably) pseudorandom number\n+ * generators that implement the {@link SplittableGenerator} or\n+ * {@link JumpableGenerator} interface.\n+ *\n+ * <p> Objects that implement {@link RandomGenerator} are typically not\n+ * cryptographically secure. Consider instead using {@link SecureRandom} to get\n+ * a cryptographically secure pseudorandom number generator for use by\n+ * security-sensitive applications. Note, however, that {@link SecureRandom}\n+ * does implement the {@link RandomGenerator} interface, so that instances of\n+ * {@link SecureRandom} may be used interchangeably with other types of\n+ * pseudorandom generators in applications that do not require a secure\n+ * generator.\n+ *\n+ * <p>Unless explicit stated otherwise, the use of null for any method argument\n+ * will cause a NullPointerException.\n+ *\n+ * @since 17\n+ *\n+ *\/\n+public interface RandomGenerator {\n+     \/**\n+     * Returns an instance of {@link RandomGenerator} that utilizes the\n+     * {@code name} <a href=\"package-summary.html#algorithms\">algorithm<\/a>.\n+     *\n+     * @param name  Name of random number generator\n+     *              <a href=\"package-summary.html#algorithms\">algorithm<\/a>\n+     *\n+     * @return An instance of {@link RandomGenerator}\n+     *\n+     * @throws NullPointerException if name is null\n+     * @throws IllegalArgumentException if the named algorithm is not found\n+     *\/\n+    static RandomGenerator of(String name) {\n+        Objects.requireNonNull(name);\n+\n+        return RandomGeneratorFactory.of(name, RandomGenerator.class);\n+    }\n+\n+    \/**\n+     * Returns a {@link RandomGenerator} meeting the minimal requirement\n+     * of having an <a href=\"package-summary.html#algorithms\">algorithm<\/a>\n+     * whose state bits are greater than or equal 64.\n+     *\n+     * @implSpec  Since algorithms will improve over time, there is no\n+     * guarantee that this method will return the same algorithm over time.\n+     * <p> The default implementation selects L32X64MixRandom.\n+     *\n+     * @return a {@link RandomGenerator}\n+     *\/\n+    static RandomGenerator getDefault() {\n+        return of(\"L32X64MixRandom\");\n+    }\n+\n+    \/**\n+     * Return true if the implementation of RandomGenerator (algorithm) has been\n+     * marked for deprecation.\n+     *\n+     * @implNote Random number generator algorithms evolve over time; new\n+     * algorithms will be introduced and old algorithms will\n+     * lose standing. If an older algorithm is deemed unsuitable\n+     * for continued use, it will be marked as deprecated to indicate\n+     * that it may be removed at some point in the future.\n+     *\n+     * @return true if the implementation of RandomGenerator (algorithm) has been\n+     *         marked for deprecation\n+     *\n+     * @implSpec The default implementation checks for the @Deprecated annotation.\n+     *\/\n+     default boolean isDeprecated() {\n+        return this.getClass().isAnnotationPresent(Deprecated.class);\n+     }\n+\n+    \/**\n+     * Returns an effectively unlimited stream of pseudorandomly chosen\n+     * {@code double} values.\n+     *\n+     * @return a stream of pseudorandomly chosen {@code double} values\n+     *\n+     * @implNote It is permitted to implement this method in a manner equivalent to\n+     * {@link RandomGenerator#doubles(long) doubles}\n+     * ({@link Long#MAX_VALUE Long.MAX_VALUE}).\n+     *\n+     * @implSpec The default implementation produces a sequential stream\n+     * that repeatedly calls {@link RandomGenerator#nextDouble nextDouble}().\n+     *\/\n+    default DoubleStream doubles() {\n+        return DoubleStream.generate(this::nextDouble).sequential();\n+    }\n+\n+    \/**\n+     * Returns an effectively unlimited stream of pseudorandomly chosen\n+     * {@code double} values, where each value is between the specified origin\n+     * (inclusive) and the specified bound (exclusive).\n+     *\n+     * @param randomNumberOrigin the least value that can be produced\n+     * @param randomNumberBound the upper bound (exclusive) for each value produced\n+     *\n+     * @return a stream of pseudorandomly chosen {@code double} values, each between\n+     *         the specified origin (inclusive) and the specified bound (exclusive)\n+     *\n+     * @throws IllegalArgumentException if {@code randomNumberOrigin} is not finite,\n+     *         or {@code randomNumberBound} is not finite, or {@code randomNumberOrigin}\n+     *         is greater than or equal to {@code randomNumberBound}\n+     *\n+     * @implNote It is permitted to implement this method in a manner equivalent to\n+     * {@link RandomGenerator#doubles(long, double, double) doubles}\n+     * ({@link Long#MAX_VALUE Long.MAX_VALUE}, randomNumberOrigin, randomNumberBound).\n+     *\n+     * @implSpec The default implementation produces a sequential stream that repeatedly\n+     * calls {@link RandomGenerator#nextDouble(double, double) nextDouble}(randomNumberOrigin, randomNumberBound).\n+     *\/\n+    default DoubleStream doubles(double randomNumberOrigin, double randomNumberBound) {\n+        RandomSupport.checkRange(randomNumberOrigin, randomNumberBound);\n+\n+        return DoubleStream.generate(() -> nextDouble(randomNumberOrigin, randomNumberBound)).sequential();\n+    }\n+\n+    \/**\n+     * Returns a stream producing the given {@code streamSize} number of\n+     * pseudorandomly chosen {@code double} values.\n+     *\n+     * @param streamSize the number of values to generate\n+     *\n+     * @return a stream of pseudorandomly chosen {@code double} values\n+     *\n+     * @throws IllegalArgumentException if {@code streamSize} is\n+     *         less than zero\n+     *\n+     * @implSpec The default implementation produces a sequential stream\n+     * that repeatedly calls {@link RandomGenerator#nextDouble nextDouble()}.\n+     *\/\n+    default DoubleStream doubles(long streamSize) {\n+        RandomSupport.checkStreamSize(streamSize);\n+\n+        return doubles().limit(streamSize);\n+    }\n+\n+    \/**\n+     * Returns a stream producing the given {@code streamSize} number of\n+     * pseudorandomly chosen {@code double} values, where each value is\n+     * between the specified origin (inclusive) and the specified bound\n+     * (exclusive).\n+     *\n+     * @param streamSize the number of values to generate\n+     * @param randomNumberOrigin the least value that can be produced\n+     * @param randomNumberBound the upper bound (exclusive) for each value produced\n+     *\n+     * @return a stream of pseudorandomly chosen {@code double} values, each between\n+     *         the specified origin (inclusive) and the specified bound (exclusive)\n+     *\n+     * @throws IllegalArgumentException if {@code streamSize} is less than zero,\n+     *         or {@code randomNumberOrigin} is not finite,\n+     *         or {@code randomNumberBound} is not finite, or {@code randomNumberOrigin}\n+     *         is greater than or equal to {@code randomNumberBound}\n+     *\n+     * @implSpec The default implementation produces a sequential stream that repeatedly\n+     * calls {@link RandomGenerator#nextDouble(double, double)  nextDouble}(randomNumberOrigin, randomNumberBound).\n+     *\/\n+    default DoubleStream doubles(long streamSize, double randomNumberOrigin,\n+                double randomNumberBound) {\n+        RandomSupport.checkStreamSize(streamSize);\n+        RandomSupport.checkRange(randomNumberOrigin, randomNumberBound);\n+\n+        return doubles(randomNumberOrigin, randomNumberBound).limit(streamSize);\n+    }\n+\n+    \/**\n+     * Returns an effectively unlimited stream of pseudorandomly chosen\n+     * {@code int} values.\n+     *\n+     * @return a stream of pseudorandomly chosen {@code int} values\n+     *\n+     * @implNote It is permitted to implement this method in a manner\n+     * equivalent to {@link RandomGenerator#ints(long) ints}\n+     * ({@link Long#MAX_VALUE Long.MAX_VALUE}).\n+     *\n+     * @implSpec The default implementation produces a sequential stream\n+     * that repeatedly calls {@link RandomGenerator#nextInt() nextInt}().\n+     *\/\n+    default IntStream ints() {\n+        return IntStream.generate(this::nextInt).sequential();\n+    }\n+\n+    \/**\n+     * Returns an effectively unlimited stream of pseudorandomly chosen\n+     * {@code int} values, where each value is between the specified origin\n+     * (inclusive) and the specified bound (exclusive).\n+     *\n+     * @param randomNumberOrigin the least value that can be produced\n+     * @param randomNumberBound the upper bound (exclusive) for each value produced\n+     *\n+     * @return a stream of pseudorandomly chosen {@code int} values, each between\n+     *         the specified origin (inclusive) and the specified bound (exclusive)\n+     *\n+     * @throws IllegalArgumentException if {@code randomNumberOrigin}\n+     *         is greater than or equal to {@code randomNumberBound}\n+     *\n+     * @implNote It is permitted to implement this method in a manner equivalent to\n+     * {@link RandomGenerator#ints(long, int, int) ints}\n+     * ({@link Long#MAX_VALUE Long.MAX_VALUE}, randomNumberOrigin, randomNumberBound).\n+     *\n+     * @implSpec The default implementation produces a sequential stream that repeatedly\n+     * calls {@link RandomGenerator#nextInt(int, int) nextInt}(randomNumberOrigin, randomNumberBound).\n+     *\/\n+    default IntStream ints(int randomNumberOrigin, int randomNumberBound) {\n+        RandomSupport.checkRange(randomNumberOrigin, randomNumberBound);\n+\n+        return IntStream.generate(() -> nextInt(randomNumberOrigin, randomNumberBound)).sequential();\n+    }\n+\n+    \/**\n+     * Returns a stream producing the given {@code streamSize} number of\n+     * pseudorandomly chosen {@code int} values.\n+     *\n+     * @param streamSize the number of values to generate\n+     *\n+     * @return a stream of pseudorandomly chosen {@code int} values\n+     *\n+     * @throws IllegalArgumentException if {@code streamSize} is\n+     *         less than zero\n+     *\n+     * @implSpec The default implementation produces a sequential stream\n+     * that repeatedly calls {@link RandomGenerator#nextInt() nextInt}().\n+     *\/\n+    default IntStream ints(long streamSize) {\n+        RandomSupport.checkStreamSize(streamSize);\n+\n+        return ints().limit(streamSize);\n+    }\n+\n+    \/**\n+     * Returns a stream producing the given {@code streamSize} number of\n+     * pseudorandomly chosen {@code int} values, where each value is between\n+     * the specified origin (inclusive) and the specified bound (exclusive).\n+     *\n+     * @param streamSize the number of values to generate\n+     * @param randomNumberOrigin the least value that can be produced\n+     * @param randomNumberBound the upper bound (exclusive) for each value produced\n+     *\n+     * @return a stream of pseudorandomly chosen {@code int} values, each between\n+     *         the specified origin (inclusive) and the specified bound (exclusive)\n+     *\n+     * @throws IllegalArgumentException if {@code streamSize} is\n+     *         less than zero, or {@code randomNumberOrigin}\n+     *         is greater than or equal to {@code randomNumberBound}\n+     *\n+     * @implSpec The default implementation produces a sequential stream that repeatedly\n+     * calls {@link RandomGenerator#nextInt(int, int) nextInt}(randomNumberOrigin, randomNumberBound).\n+     *\/\n+    default IntStream ints(long streamSize, int randomNumberOrigin,\n+              int randomNumberBound) {\n+        RandomSupport.checkStreamSize(streamSize);\n+        RandomSupport.checkRange(randomNumberOrigin, randomNumberBound);\n+\n+        return ints(randomNumberOrigin, randomNumberBound).limit(streamSize);\n+    }\n+\n+    \/**\n+     * Returns an effectively unlimited stream of pseudorandomly chosen\n+     * {@code long} values.\n+     *\n+     * @return a stream of pseudorandomly chosen {@code long} values\n+     *\n+     * @implNote It is permitted to implement this method in a manner\n+     * equivalent to {@link RandomGenerator#longs(long) longs}\n+     * ({@link Long#MAX_VALUE Long.MAX_VALUE}).\n+     *\n+     * @implSpec The default implementation produces a sequential stream\n+     * that repeatedly calls {@link RandomGenerator#nextLong() nextLong}().\n+     *\/\n+    default LongStream longs() {\n+        return LongStream.generate(this::nextLong).sequential();\n+    }\n+\n+    \/**\n+     * Returns an effectively unlimited stream of pseudorandomly chosen\n+     * {@code long} values, where each value is between the specified origin\n+     * (inclusive) and the specified bound (exclusive).\n+     *\n+     * @param randomNumberOrigin the least value that can be produced\n+     * @param randomNumberBound the upper bound (exclusive) for each value produced\n+     *\n+     * @return a stream of pseudorandomly chosen {@code long} values, each between\n+     *         the specified origin (inclusive) and the specified bound (exclusive)\n+     *\n+     * @throws IllegalArgumentException if {@code randomNumberOrigin}\n+     *         is greater than or equal to {@code randomNumberBound}\n+     *\n+     * @implNote It is permitted to implement this method in a manner equivalent to\n+     * {@link RandomGenerator#longs(long, long, long) longs}\n+     * ({@link Long#MAX_VALUE Long.MAX_VALUE}, randomNumberOrigin, randomNumberBound).\n+     *\n+     * @implSpec The default implementation produces a sequential stream that repeatedly\n+     * calls {@link RandomGenerator#nextLong(long, long) nextLong}(randomNumberOrigin, randomNumberBound).\n+     *\/\n+    default LongStream longs(long randomNumberOrigin, long randomNumberBound) {\n+        RandomSupport.checkRange(randomNumberOrigin, randomNumberBound);\n+\n+        return LongStream.generate(() -> nextLong(randomNumberOrigin, randomNumberBound)).sequential();\n+    }\n+\n+    \/**\n+     * Returns a stream producing the given {@code streamSize} number of\n+     * pseudorandomly chosen {@code long} values.\n+     *\n+     * @param streamSize the number of values to generate\n+     *\n+     * @return a stream of pseudorandomly chosen {@code long} values\n+     *\n+     * @throws IllegalArgumentException if {@code streamSize} is\n+     *         less than zero\n+     *\n+     * @implSpec The default implementation produces a sequential stream\n+     * that repeatedly calls {@link RandomGenerator#nextLong() nextLong}().\n+     *\/\n+    default LongStream longs(long streamSize) {\n+        RandomSupport.checkStreamSize(streamSize);\n+\n+        return longs().limit(streamSize);\n+    }\n+\n+    \/**\n+     * Returns a stream producing the given {@code streamSize} number of\n+     * pseudorandomly chosen {@code long} values, where each value is between\n+     * the specified origin (inclusive) and the specified bound (exclusive).\n+     *\n+     * @param streamSize the number of values to generate\n+     * @param randomNumberOrigin the least value that can be produced\n+     * @param randomNumberBound the upper bound (exclusive) for each value produced\n+     *\n+     * @return a stream of pseudorandomly chosen {@code long} values, each between\n+     *         the specified origin (inclusive) and the specified bound (exclusive)\n+     *\n+     * @throws IllegalArgumentException if {@code streamSize} is\n+     *         less than zero, or {@code randomNumberOrigin}\n+     *         is greater than or equal to {@code randomNumberBound}\n+     *\n+     * @implSpec The default implementation produces a sequential stream that repeatedly\n+     * calls {@link RandomGenerator#nextLong(long, long) nextLong}(randomNumberOrigin, randomNumberBound).\n+     *\/\n+    default LongStream longs(long streamSize, long randomNumberOrigin,\n+                long randomNumberBound) {\n+        RandomSupport.checkStreamSize(streamSize);\n+        RandomSupport.checkRange(randomNumberOrigin, randomNumberBound);\n+\n+        return longs(randomNumberOrigin, randomNumberBound).limit(streamSize);\n+    }\n+\n+    \/**\n+     * Returns a pseudorandomly chosen {@code boolean} value.\n+     *\n+     * <p> The default implementation tests the high-order bit (sign bit) of a\n+     * value produced by {@link RandomGenerator#nextInt() nextInt}(), on the\n+     * grounds that some algorithms for pseudorandom number generation produce\n+     * values whose high-order bits have better statistical quality than the\n+     * low-order bits.\n+     *\n+     * @return a pseudorandomly chosen {@code boolean} value\n+     *\n+     * @implSpec The default implementation produces a result based on the\n+     * sign bit of a number generated by {@link nextInt()}.\n+     *\/\n+    default boolean nextBoolean() {\n+        return nextInt() < 0;\n+    }\n+\n+    \/**\n+     * Fills a user-supplied byte array with generated byte values\n+     * pseudorandomly chosen uniformly from the range of values between -128\n+     * (inclusive) and 127 (inclusive).\n+     *\n+     * @implNote Algorithm used to fill the byte array;\n+     *           <pre>{@code\n+     *           void nextBytes(byte[] bytes) {\n+     *               int i = 0;\n+     *               int len = bytes.length;\n+     *               for (int words = len >> 3; words--> 0; ) {\n+     *                   long rnd = nextLong();\n+     *                   for (int n = 8; n--> 0; rnd >>>= Byte.SIZE)\n+     *                       bytes[i++] = (byte)rnd;\n+     *               }\n+     *               if (i < len)\n+     *                   for (long rnd = nextLong(); i < len; rnd >>>= Byte.SIZE)\n+     *                       bytes[i++] = (byte)rnd;\n+     *           }}<\/pre>\n+     *\n+     * @param  bytes the byte array to fill with pseudorandom bytes\n+     * @throws NullPointerException if bytes is null\n+     *\n+     * @implSpec The default implementation produces results from repeated calls\n+     * to {@link nextLong()}.\n+     *\/\n+    default void nextBytes(byte[] bytes) {\n+        int i = 0;\n+        int len = bytes.length;\n+        for (int words = len >> 3; words--> 0; ) {\n+            long rnd = nextLong();\n+            for (int n = 8; n--> 0; rnd >>>= Byte.SIZE)\n+                bytes[i++] = (byte)rnd;\n+        }\n+        if (i < len)\n+            for (long rnd = nextLong(); i < len; rnd >>>= Byte.SIZE)\n+                bytes[i++] = (byte)rnd;\n+    }\n+\n+    \/**\n+     * Returns a pseudorandom {@code float} value between zero (inclusive) and\n+     * one (exclusive).\n+     *\n+     * @return a pseudorandom {@code float} value between zero (inclusive) and one (exclusive)\n+     *\n+     * @implSpec The default implementation uses the 24 high-order bits from a call to\n+     * {@link RandomGenerator#nextInt() nextInt}().\n+     *\/\n+    default float nextFloat() {\n+        return (nextInt() >>> 8) * 0x1.0p-24f;\n+    }\n+\n+    \/**\n+     * Returns a pseudorandomly chosen {@code float} value between zero\n+     * (inclusive) and the specified bound (exclusive).\n+     *\n+     * @param bound the upper bound (exclusive) for the returned value.\n+     *        Must be positive and finite\n+     *\n+     * @return a pseudorandomly chosen {@code float} value between\n+     *         zero (inclusive) and the bound (exclusive)\n+     *\n+     * @throws IllegalArgumentException if {@code bound} is not\n+     *         both positive and finite\n+     *\n+     * @implSpec The default implementation simply calls\n+     * {@link RandomSupport#checkBound checkBound}(bound) and then\n+     * {@link RandomSupport#boundedNextFloat boundedNextFloat}(this, bound).\n+     *\/\n+    default float nextFloat(float bound) {\n+        RandomSupport.checkBound(bound);\n+\n+        return RandomSupport.boundedNextFloat(this, bound);\n+    }\n+\n+    \/**\n+     * Returns a pseudorandomly chosen {@code float} value between the\n+     * specified origin (inclusive) and the specified bound (exclusive).\n+     *\n+     * @param origin the least value that can be returned\n+     * @param bound the upper bound (exclusive)\n+     *\n+     * @return a pseudorandomly chosen {@code float} value between the\n+     *         origin (inclusive) and the bound (exclusive)\n+     *\n+     * @throws IllegalArgumentException if {@code origin} is not finite,\n+     *         or {@code bound} is not finite, or {@code origin}\n+     *         is greater than or equal to {@code bound}\n+     *\n+     * @implSpec The default implementation simply calls\n+     * {@link RandomSupport#checkBound checkBound}(bound) and then\n+     * {@link RandomSupport#boundedNextFloat boundedNextFloat}(this, bound).\n+     *\/\n+    default float nextFloat(float origin, float bound) {\n+        RandomSupport.checkRange(origin, bound);\n+\n+        return RandomSupport.boundedNextFloat(this, origin, bound);\n+    }\n+\n+    \/**\n+     * Returns a pseudorandom {@code double} value between zero (inclusive) and\n+     * one (exclusive).\n+     *\n+     * @return a pseudorandom {@code double} value between zero (inclusive)\n+     *         and one (exclusive)\n+     *\n+     * @implSpec The default implementation uses the 53 high-order bits from a call to\n+     * {@link RandomGenerator#nextLong nextLong}().\n+     *\/\n+    default double nextDouble() {\n+        return (nextLong() >>> 11) * 0x1.0p-53;\n+    }\n+\n+    \/**\n+     * Returns a pseudorandomly chosen {@code double} value between zero\n+     * (inclusive) and the specified bound (exclusive).\n+     *\n+     * @param bound the upper bound (exclusive) for the returned value.\n+     *        Must be positive and finite\n+     *\n+     * @return a pseudorandomly chosen {@code double} value between\n+     *         zero (inclusive) and the bound (exclusive)\n+     *\n+     * @throws IllegalArgumentException if {@code bound} is not\n+     *         both positive and finite\n+     *\n+     * @implSpec The default implementation simply calls\n+     * {@link RandomSupport#checkBound checkBound}(bound) and then\n+     * {@link RandomSupport#boundedNextDouble boundedNextDouble}(this, bound).\n+     *\/\n+    default double nextDouble(double bound) {\n+        RandomSupport.checkBound(bound);\n+\n+        return RandomSupport.boundedNextDouble(this, bound);\n+    }\n+\n+    \/**\n+     * Returns a pseudorandomly chosen {@code double} value between the\n+     * specified origin (inclusive) and the specified bound (exclusive).\n+     *\n+     * @param origin the least value that can be returned\n+     * @param bound the upper bound (exclusive) for the returned value\n+     *\n+     * @return a pseudorandomly chosen {@code double} value between the\n+     *         origin (inclusive) and the bound (exclusive)\n+     *\n+     * @throws IllegalArgumentException if {@code origin} is not finite,\n+     *         or {@code bound} is not finite, or {@code origin}\n+     *         is greater than or equal to {@code bound}\n+     *\n+     * @implSpec The default implementation simply calls\n+     * {@link RandomSupport#checkBound checkBound}(bound) and then\n+     * {@link RandomSupport#boundedNextDouble boundedNextDouble}(this, bound).\n+     *\/\n+    default double nextDouble(double origin, double bound) {\n+        RandomSupport.checkRange(origin, bound);\n+\n+        return RandomSupport.boundedNextDouble(this, origin, bound);\n+    }\n+\n+    \/**\n+     * Returns a pseudorandomly chosen {@code int} value.\n+     *\n+     * @return a pseudorandomly chosen {@code int} value\n+     *\n+     * @implSpec The default implementation uses the 32 high-order bits from a call to\n+     * {@link RandomGenerator#nextLong nextLong}().\n+     *\/\n+    default int nextInt() {\n+        return (int)(nextLong() >>> 32);\n+    }\n+\n+    \/**\n+     * Returns a pseudorandomly chosen {@code int} value between zero\n+     * (inclusive) and the specified bound (exclusive).\n+     *\n+     * @param bound the upper bound (exclusive) for the returned value. Must be positive.\n+     *\n+     * @return a pseudorandomly chosen {@code int} value between\n+     *         zero (inclusive) and the bound (exclusive)\n+     *\n+     * @throws IllegalArgumentException if {@code bound} is not positive\n+     *\n+     * @implSpec The default implementation simply calls\n+     * {@link RandomSupport#checkBound checkBound}(bound) and then\n+     * {@link RandomSupport#boundedNextInt boundedNextInt}(this, bound).\n+     *\/\n+    default int nextInt(int bound) {\n+        RandomSupport.checkBound(bound);\n+\n+        return RandomSupport.boundedNextInt(this, bound);\n+    }\n+\n+    \/**\n+     * Returns a pseudorandomly chosen {@code int} value between the specified\n+     * origin (inclusive) and the specified bound (exclusive).\n+     *\n+     * @param origin the least value that can be returned\n+     * @param bound the upper bound (exclusive) for the returned value\n+     *\n+     * @return a pseudorandomly chosen {@code int} value between the\n+     *         origin (inclusive) and the bound (exclusive)\n+     *\n+     * @throws IllegalArgumentException if {@code origin} is greater than\n+     *         or equal to {@code bound}\n+     *\n+     * @implSpec The default implementation simply calls\n+     * {@link RandomSupport#checkBound(long) checkBound}(bound) and then\n+     * {@link RandomSupport#boundedNextInt(RandomGenerator, int) boundedNextInt}(this, bound).\n+     *\/\n+    default int nextInt(int origin, int bound) {\n+        RandomSupport.checkRange(origin, bound);\n+\n+        return RandomSupport.boundedNextInt(this, origin, bound);\n+    }\n+\n+    \/**\n+     * Returns a pseudorandomly chosen {@code long} value.\n+     *\n+     * @return a pseudorandomly chosen {@code long} value\n+     *\/\n+    long nextLong();\n+\n+    \/**\n+     * Returns a pseudorandomly chosen {@code long} value between zero\n+     * (inclusive) and the specified bound (exclusive).\n+     *\n+     * @param bound the upper bound (exclusive) for the returned value.  Must be positive.\n+     *\n+     * @return a pseudorandomly chosen {@code long} value between\n+     *         zero (inclusive) and the bound (exclusive)\n+     *\n+     * @throws IllegalArgumentException if {@code bound} is not positive\n+     *\n+     * @implSpec The default implementation simply calls\n+     * {@link RandomSupport#checkBound checkBound}(bound) and then\n+     * {@link RandomSupport#boundedNextLong boundedNextLong}(this, bound).\n+     *\/\n+    default long nextLong(long bound) {\n+        RandomSupport.checkBound(bound);\n+\n+        return RandomSupport.boundedNextLong(this, bound);\n+    }\n+\n+    \/**\n+     * Returns a pseudorandomly chosen {@code long} value between the\n+     * specified origin (inclusive) and the specified bound (exclusive).\n+     *\n+     * @param origin the least value that can be returned\n+     * @param bound the upper bound (exclusive) for the returned value\n+     *\n+     * @return a pseudorandomly chosen {@code long} value between the\n+     *         origin (inclusive) and the bound (exclusive)\n+     *\n+     * @throws IllegalArgumentException if {@code origin} is greater than\n+     *         or equal to {@code bound}\n+     *\n+     * @implSpec The default implementation simply calls\n+     * {@link RandomSupport#checkBound checkBound}(bound) and then\n+     * {@link RandomSupport#boundedNextLong boundedNextLong}(this, bound).\n+     *\/\n+    default long nextLong(long origin, long bound) {\n+        RandomSupport.checkRange(origin, bound);\n+\n+        return RandomSupport.boundedNextLong(this, origin, bound);\n+    }\n+\n+    \/**\n+     * Returns a {@code double} value pseudorandomly chosen from a Gaussian\n+     * (normal) distribution whose mean is 0 and whose standard deviation is 1.\n+     *\n+     * @return a {@code double} value pseudorandomly chosen from a\n+     *         Gaussian distribution\n+     *\n+     * @implSpec The default implementation uses McFarland's fast modified\n+     * ziggurat algorithm (largely table-driven, with rare cases handled by\n+     * computation and rejection sampling). Walker's alias method for sampling\n+     * a discrete distribution also plays a role.\n+     *\/\n+    default double nextGaussian() {\n+        \/\/ See Knuth, TAOCP, Vol. 2, 3rd edition, Section 3.4.1 Algorithm C.\n+        return RandomSupport.computeNextGaussian(this);\n+    }\n+\n+    \/**\n+     * Returns a {@code double} value pseudorandomly chosen from a Gaussian\n+     * (normal) distribution with a mean and standard deviation specified by the\n+     * arguments.\n+     *\n+     * @param mean the mean of the Gaussian distribution to be drawn from\n+     * @param stddev the standard deviation (square root of the variance)\n+     *        of the Gaussian distribution to be drawn from\n+     *\n+     * @return a {@code double} value pseudorandomly chosen from the\n+     *         specified Gaussian distribution\n+     *\n+     * @throws IllegalArgumentException if {@code stddev} is negative\n+     *\n+     * @implSpec The default implementation uses McFarland's fast modified\n+     * ziggurat algorithm (largely table-driven, with rare cases handled by\n+     * computation and rejection sampling). Walker's alias method for sampling\n+     * a discrete distribution also plays a role.\n+     *\/\n+    default double nextGaussian(double mean, double stddev) {\n+        if (stddev < 0.0) throw new IllegalArgumentException(\"standard deviation must be non-negative\");\n+\n+        return mean + stddev * RandomSupport.computeNextGaussian(this);\n+    }\n+\n+    \/**\n+     * Returns a nonnegative {@code double} value pseudorandomly chosen from\n+     * an exponential distribution whose mean is 1.\n+     *\n+     * @return a nonnegative {@code double} value pseudorandomly chosen from an\n+     *         exponential distribution\n+     *\n+     * @implSpec The default implementation uses McFarland's fast modified\n+     * ziggurat algorithm (largely table-driven, with rare cases handled by\n+     * computation and rejection sampling). Walker's alias method for sampling\n+     * a discrete distribution also plays a role.\n+     *\/\n+    default double nextExponential() {\n+        return RandomSupport.computeNextExponential(this);\n+    }\n+\n+    \/**\n+     * The {@link StreamableGenerator} interface augments the\n+     * {@link RandomGenerator} interface to provide methods that return streams\n+     * of {@link RandomGenerator} objects. Ideally, such a stream of objects\n+     * would have the property that the behavior of each object is statistically\n+     * independent of all the others. In practice, one may have to settle for\n+     * some approximation to this property.\n+     *\n+     * <p> A generator that implements interface {@link SplittableGenerator} may\n+     * choose to use its {@link SplittableGenerator#splits splits}() method to\n+     * implement the {@link StreamableGenerator#rngs rngs}() method required by this\n+     * interface.\n+     *\n+     * <p> A generator that implements interface {@link JumpableGenerator} may\n+     * choose to use its {@link JumpableGenerator#jumps() jumps}() method to implement the\n+     * {@link StreamableGenerator#rngs() rngs}() method required by this interface.\n+     *\n+     * <p> A generator that implements interface {@link LeapableGenerator} may\n+     * choose to use its {@link LeapableGenerator#leaps() leaps}() method to\n+     * implement the {@link StreamableGenerator#rngs() rngs}() method required by this\n+     * interface.\n+     *\n+     * <p> Objects that implement {@link StreamableGenerator} are typically not\n+     * cryptographically secure. Consider instead using {@link SecureRandom} to\n+     * get a cryptographically secure pseudo-random number generator for use by\n+     * security-sensitive applications.\n+     *\/\n+    interface StreamableGenerator extends RandomGenerator {\n+\n+        \/**\n+         * Returns an instance of {@link StreamableGenerator} that utilizes the\n+         * {@code name} <a href=\"package-summary.html#algorithms\">algorithm<\/a>.\n+         *\n+         * @param name  Name of random number generator\n+         *              <a href=\"package-summary.html#algorithms\">algorithm<\/a>\n+         *\n+         * @return An instance of {@link StreamableGenerator}\n+         *\n+         * @throws NullPointerException if name is null\n+         * @throws IllegalArgumentException if the named algorithm is not found\n+         *\/\n+        static StreamableGenerator of(String name) {\n+            Objects.requireNonNull(name);\n+\n+            return RandomGeneratorFactory.of(name, StreamableGenerator.class);\n+        }\n+\n+        \/**\n+         * Returns an effectively unlimited stream of objects, each of which\n+         * implements the {@link RandomGenerator} interface. Ideally the\n+         * generators in the stream will appear to be statistically independent.\n+         * The new generators are of the same\n+         * <a href=\"package-summary.html#algorithms\">algorithm<\/a> as this generator.\n+         *\n+         * @return a stream of objects that implement the {@link RandomGenerator} interface\n+         *\n+         * @implNote It is permitted to implement this method in a manner\n+         *           equivalent to {@link StreamableGenerator#rngs(long) rngs}\n+         *           ({@link Long#MAX_VALUE Long.MAX_VALUE}).\n+         *\/\n+        Stream<RandomGenerator> rngs();\n+\n+        \/**\n+         * Returns an effectively unlimited stream of objects, each of which\n+         * implements the {@link RandomGenerator} interface. Ideally the\n+         * generators in the stream will appear to be statistically independent.\n+         * The new generators are of the same\n+         * <a href=\"package-summary.html#algorithms\">algorithm<\/a> as this generator.\n+         *\n+         * @param streamSize the number of generators to generate\n+         *\n+         * @return a stream of objects that implement the {@link RandomGenerator} interface\n+         *\n+         * @throws IllegalArgumentException if {@code streamSize} is\n+         *         less than zero\n+         *\n+         * @implSpec The default implementation calls {@link StreamableGenerator#rngs() rngs}() and\n+         * then limits its length to {@code streamSize}.\n+         *\/\n+        default Stream<RandomGenerator> rngs(long streamSize) {\n+            RandomSupport.checkStreamSize(streamSize);\n+\n+            return rngs().limit(streamSize);\n+        }\n+    }\n+\n+    \/**\n+     * This interface is designed to provide a common protocol for objects that\n+     * generate sequences of pseudorandom values and can be <i>split<\/i> into\n+     * two objects (the original one and a new one) each of which obey that same\n+     * protocol (and therefore can be recursively split indefinitely).\n+     *\n+     * <p> Ideally, all {@link SplittableGenerator} objects produced by\n+     * recursive splitting from a single original {@link SplittableGenerator}\n+     * object are statistically independent of one another and individually\n+     * uniform. Therefore we would expect the set of values collectively\n+     * generated by a set of such objects to have the same statistical\n+     * properties as if the same quantity of values were generated by a single\n+     * thread using a single {@link SplittableGenerator} object. In practice,\n+     * one must settle for some approximation to independence and uniformity.\n+     *\n+     * <p> Methods are provided to perform a single splitting operation and also\n+     * to produce a stream of generators split off from the original (by either\n+     * iterative or recursive splitting, or a combination).\n+     *\n+     * <p> Objects that implement {@link SplittableGenerator} are typically not\n+     * cryptographically secure. Consider instead using {@link SecureRandom} to\n+     * get a cryptographically secure pseudo-random number generator for use by\n+     * security-sensitive applications.\n+     *\/\n+    interface SplittableGenerator extends StreamableGenerator {\n+\n+        \/**\n+         * Returns an instance of {@link SplittableGenerator} that utilizes the\n+         * {@code name} <a href=\"package-summary.html#algorithms\">algorithm<\/a>.\n+         *\n+         * @implNote Availability is determined by RandomGeneratorFactory using the\n+         * service provider API to locate implementations of the RandomGenerator\n+         * interface and filtering on the SplittableGenerator interface.\n+         *\n+         * @param name  Name of random number generator\n+         *              <a href=\"package-summary.html#algorithms\">algorithm<\/a>\n+         *\n+         * @return An instance of {@link SplittableGenerator}\n+         *\n+         * @throws NullPointerException if name is null\n+         * @throws IllegalArgumentException if the named algorithm is not found\n+         *\/\n+        static SplittableGenerator of(String name) {\n+            Objects.requireNonNull(name);\n+\n+            return RandomGeneratorFactory.of(name, SplittableGenerator.class);\n+        }\n+\n+        \/**\n+         * Returns a new pseudorandom number generator, split off from this one,\n+         * that implements the {@link RandomGenerator} and\n+         * {@link SplittableGenerator} interfaces.\n+         *\n+         * <p> This pseudorandom number generator may be used as a source of\n+         * pseudorandom bits used to initialize the state of the new one.\n+         *\n+         * @return a new object that implements the {@link RandomGenerator} and\n+         *         {@link SplittableGenerator} interfaces\n+         *\/\n+        SplittableGenerator split();\n+\n+        \/**\n+         * Returns a new pseudorandom number generator, split off from this one,\n+         * that implements the {@link RandomGenerator} and\n+         * {@link SplittableGenerator} interfaces.\n+         *\n+         * @param source a {@link SplittableGenerator} instance to be used instead\n+         *               of this one as a source of pseudorandom bits used to\n+         *               initialize the state of the new ones.\n+         *\n+         * @return an object that implements the {@link RandomGenerator} and\n+         *         {@link SplittableGenerator} interfaces\n+         *\n+         * @throws NullPointerException if source is null\n+         *\/\n+        SplittableGenerator split(SplittableGenerator source);\n+\n+        \/**\n+         * Returns an effectively unlimited stream of new pseudorandom number\n+         * generators, each of which implements the {@link SplittableGenerator}\n+         * interface.\n+         *\n+         * <p> This pseudorandom number generator may be used as a source of\n+         * pseudorandom bits used to initialize the state the new ones.\n+         *\n+         * @implNote It is permitted to implement this method in a manner\n+         * equivalent to {@link SplittableGenerator#splits(long) splits}\n+         * ({@link Long#MAX_VALUE Long.MAX_VALUE}).\n+         *\n+         * @return a stream of {@link SplittableGenerator} objects\n+         *\n+         * @implSpec The default implementation invokes\n+         * {@link SplittableGenerator#splits(SplittableGenerator) splits(this)}.\n+         *\/\n+        default Stream<SplittableGenerator> splits() {\n+            return this.splits(this);\n+        }\n+\n+        \/**\n+         * Returns a stream producing the given {@code streamSize} number of new\n+         * pseudorandom number generators, each of which implements the\n+         * {@link SplittableGenerator} interface.\n+         *\n+         * <p> This pseudorandom number generator may be used as a source of\n+         * pseudorandom bits used to initialize the state the new ones.\n+         *\n+         * @param streamSize the number of values to generate\n+         *\n+         * @return a stream of {@link SplittableGenerator} objects\n+         *\n+         * @throws IllegalArgumentException if {@code streamSize} is\n+         *         less than zero\n+         *\/\n+        Stream<SplittableGenerator> splits(long streamSize);\n+\n+        \/**\n+         * Returns an effectively unlimited stream of new pseudorandom number\n+         * generators, each of which implements the {@link SplittableGenerator}\n+         * interface.\n+         *\n+         * @param source a {@link SplittableGenerator} instance to be used instead\n+         *               of this one as a source of pseudorandom bits used to\n+         *               initialize the state of the new ones.\n+         *\n+         * @return a stream of {@link SplittableGenerator} objects\n+         *\n+         * @implNote It is permitted to implement this method in a manner\n+         *           equivalent to {@link SplittableGenerator#splits(long, SplittableGenerator) splits}\n+         *           ({@link Long#MAX_VALUE Long.MAX_VALUE}, source).\n+         *\n+         * @throws NullPointerException if source is null\n+         *\/\n+        Stream<SplittableGenerator> splits(SplittableGenerator source);\n+\n+        \/**\n+         * Returns a stream producing the given {@code streamSize} number of new\n+         * pseudorandom number generators, each of which implements the\n+         * {@link SplittableGenerator} interface.\n+         *\n+         * @param streamSize the number of values to generate\n+         * @param source a {@link SplittableGenerator} instance to be used instead\n+         *               of this one as a source of pseudorandom bits used to\n+         *               initialize the state of the new ones.\n+         *\n+         * @return a stream of {@link SplittableGenerator} objects\n+         *\n+         * @throws IllegalArgumentException if {@code streamSize} is\n+         *         less than zero\n+         * @throws NullPointerException if source is null\n+         *\/\n+        Stream<SplittableGenerator> splits(long streamSize, SplittableGenerator source);\n+\n+        \/**\n+         * Returns an effectively unlimited stream of new pseudorandom number\n+         * generators, each of which implements the {@link RandomGenerator}\n+         * interface. Ideally the generators in the stream will appear to be\n+         * statistically independent.\n+         *\n+         * @return a stream of objects that implement the {@link RandomGenerator} interface\n+         *\n+         * @implSpec The default implementation calls {@link SplittableGenerator#splits() splits}().\n+         *\/\n+        default Stream<RandomGenerator> rngs() {\n+            return this.splits().map(x -> x);\n+        }\n+\n+        \/**\n+         * Returns a stream producing the given {@code streamSize} number of new\n+         * pseudorandom number generators, each of which implements the\n+         * {@link RandomGenerator} interface. Ideally the generators in the\n+         * stream will appear to be statistically independent.\n+         *\n+         * @param streamSize the number of generators to generate\n+         *\n+         * @return a stream of objects that implement the {@link RandomGenerator} interface\n+         *\n+         * @throws IllegalArgumentException if {@code streamSize} is\n+         *         less than zero\n+         *\n+         * @implSpec The default implementation calls {@link SplittableGenerator#splits(long) splits}(streamSize).\n+         *\/\n+        default Stream<RandomGenerator> rngs(long streamSize) {\n+            return this.splits(streamSize).map(x -> x);\n+        }\n+    }\n+\n+    \/**\n+     * This interface is designed to provide a common protocol for objects that\n+     * generate pseudorandom values and can easily <i>jump<\/i> forward, by a\n+     * moderate amount (ex. 2<sup>64<\/sup>) to a distant point in the state cycle.\n+     *\n+     * <p> Ideally, all {@link JumpableGenerator} objects produced by iterative\n+     * jumping from a single original {@link JumpableGenerator} object are\n+     * statistically independent of one another and individually uniform. In\n+     * practice, one must settle for some approximation to independence and\n+     * uniformity. In particular, a specific implementation may assume that each\n+     * generator in a stream produced by the\n+     * {@link JumpableGenerator#jump jump()} method is used to produce a number\n+     * of values no larger than either 2<sup>64<\/sup> or the square root of its\n+     * period. Implementors are advised to use algorithms whose period is at\n+     * least 2<sup>127<\/sup>.\n+     *\n+     * <p> Methods are provided to perform a single jump operation and also to\n+     * produce a stream of generators produced from the original by iterative\n+     * copying and jumping of internal state. A typical strategy for a\n+     * multithreaded application is to create a single {@link JumpableGenerator}\n+     * object, calls its {@link JumpableGenerator#jump jump}() method exactly\n+     * once, and then parcel out generators from the resulting stream, one to\n+     * each thread. It is generally not a good idea to call\n+     * {@link JumpableGenerator#jump jump}() on a generator that was itself\n+     * produced by the {@link JumpableGenerator#jump jump}() method, because the\n+     * result may be a generator identical to another generator already produce\n+     * by that call to the {@link JumpableGenerator#jump jump}() method. For\n+     * this reason, the return type of the {@link JumpableGenerator#jumps jumps}()\n+     * method is {@link Stream<RandomGenerator>} rather than\n+     * {@link Stream<JumpableGenerator>}, even though the actual generator\n+     * objects in that stream likely do also implement the\n+     * {@link JumpableGenerator} interface.\n+     *\n+     * <p> Objects that implement {@link JumpableGenerator} are typically not\n+     * cryptographically secure. Consider instead using {@link SecureRandom} to\n+     * get a cryptographically secure pseudo-random number generator for use by\n+     * security-sensitive applications.\n+     *\/\n+    interface JumpableGenerator extends StreamableGenerator {\n+\n+        \/**\n+         * Returns an instance of {@link JumpableGenerator} that utilizes the\n+         * {@code name} <a href=\"package-summary.html#algorithms\">algorithm<\/a>.\n+         *\n+         * @param name  Name of random number generator\n+         *              <a href=\"package-summary.html#algorithms\">algorithm<\/a>\n+         *\n+         * @return An instance of {@link JumpableGenerator}\n+         *\n+         * @throws NullPointerException if name is null\n+         * @throws IllegalArgumentException if the named algorithm is not found\n+         *\/\n+        static JumpableGenerator of(String name) {\n+            Objects.requireNonNull(name);\n+\n+            return RandomGeneratorFactory.of(name, JumpableGenerator.class);\n+        }\n+\n+        \/**\n+         * Returns a new generator whose internal state is an exact copy of this\n+         * generator (therefore their future behavior should be identical if\n+         * subjected to the same series of operations).\n+         *\n+         * @return a new object that is a copy of this generator\n+         *\/\n+        JumpableGenerator copy();\n+\n+        \/**\n+         * Alter the state of this pseudorandom number generator so as to jump\n+         * forward a large, fixed distance (typically 2<sup>64<\/sup> or more)\n+         * within its state cycle.\n+         *\/\n+        void jump();\n+\n+        \/**\n+         * Returns the distance by which the\n+         * {@link JumpableGenerator#jump jump}() method will jump forward within\n+         * the state cycle of this generator object.\n+         *\n+         * @return the default jump distance (as a {@code double} value)\n+         *\/\n+        double jumpDistance();\n+\n+        \/**\n+         * Returns an effectively unlimited stream of new pseudorandom number\n+         * generators, each of which implements the {@link RandomGenerator}\n+         * interface.\n+         *\n+         * @return a stream of objects that implement the {@link RandomGenerator} interface\n+         *\n+         * @implNote It is permitted to implement this method in a manner equivalent to\n+         * {@link JumpableGenerator#jumps(long) jumps}\n+         * ({@link Long#MAX_VALUE Long.MAX_VALUE}).\n+         *\n+         * @implSpec The default implementation produces a sequential stream that  repeatedly\n+         * calls {@link JumpableGenerator#copy copy}() and {@link JumpableGenerator#jump jump}()\n+         * on this generator, and the copies become the generators produced by the stream.\n+         *\/\n+        default Stream<RandomGenerator> jumps() {\n+            return Stream.generate(this::copyAndJump).sequential();\n+        }\n+\n+        \/**\n+         * Returns a stream producing the given {@code streamSize} number of new\n+         * pseudorandom number generators, each of which implements the\n+         * {@link RandomGenerator} interface.\n+         *\n+         * @param streamSize the number of generators to generate\n+         *\n+         * @return a stream of objects that implement the {@link RandomGenerator} interface\n+         *\n+         * @throws IllegalArgumentException if {@code streamSize} is less than zero\n+         *\n+         * @implSpec The default implementation produces a sequential stream that  repeatedly\n+         * calls {@link JumpableGenerator#copy copy}() and {@link JumpableGenerator#jump jump}()\n+         * on this generator, and the copies become the generators produced by the stream.\n+         *\/\n+        default Stream<RandomGenerator> jumps(long streamSize) {\n+            return jumps().limit(streamSize);\n+        }\n+\n+        \/**\n+         * Returns an effectively unlimited stream of new pseudorandom number\n+         * generators, each of which implements the {@link RandomGenerator}\n+         * interface. Ideally the generators in the stream will appear to be\n+         * statistically independent.\n+         *\n+         * @return a stream of objects that implement the {@link RandomGenerator} interface\n+         *\n+         * @implSpec The default implementation calls {@link JumpableGenerator#jump jump}().\n+         *\/\n+        default Stream<RandomGenerator> rngs() {\n+            return this.jumps();\n+        }\n+\n+        \/**\n+         * Returns a stream producing the given {@code streamSize} number of new\n+         * pseudorandom number generators, each of which implements the\n+         * {@link RandomGenerator} interface. Ideally the generators in the\n+         * stream will appear to be statistically independent.\n+         *\n+         * @param streamSize the number of generators to generate\n+         *\n+         * @return a stream of objects that implement the {@link RandomGenerator} interface\n+         *\n+         * @throws IllegalArgumentException if {@code streamSize} is less than zero\n+         *\n+         * @implSpec The default implementation calls {@link JumpableGenerator#jumps(long) jumps}(streamSize).\n+         *\/\n+        default Stream<RandomGenerator> rngs(long streamSize) {\n+            return this.jumps(streamSize);\n+        }\n+\n+        \/**\n+         * Copy this generator, jump this generator forward, then return the\n+         * copy.\n+         *\n+         * @return a copy of this generator object before the jump occurred\n+         *\n+         * @implSpec The default implementation copies this, jumps and then\n+         * returns the copy.\n+         *\/\n+        default RandomGenerator copyAndJump() {\n+            RandomGenerator result = copy();\n+            jump();\n+\n+            return result;\n+        }\n+\n+    }\n+\n+    \/**\n+     * This interface is designed to provide a common protocol for objects that\n+     * generate sequences of pseudorandom values and can easily not only jump\n+     * but also <i>leap<\/i> forward, by a large amount (ex. 2<sup>128<\/sup>), to\n+     * a very distant point in the state cycle.\n+     *\n+     * Typically one will construct a series of {@link LeapableGenerator}\n+     * objects by iterative leaping from a single original\n+     * {@link LeapableGenerator} object, and then for each such object produce a\n+     * subseries of objects by iterative jumping. There is little conceptual\n+     * difference between leaping and jumping, but typically a leap will be a\n+     * very long jump in the state cycle (perhaps distance 2<sup>128<\/sup> or\n+     * so).\n+     *\n+     * <p> Ideally, all {@link LeapableGenerator} objects produced by iterative\n+     * leaping and jumping from a single original {@link LeapableGenerator}\n+     * object are statistically independent of one another and individually\n+     * uniform. In practice, one must settle for some approximation to\n+     * independence and uniformity. In particular, a specific implementation may\n+     * assume that each generator in a stream produced by the {@code leaps}\n+     * method is used to produce (by jumping) a number of objects no larger than\n+     * 2<sup>64<\/sup>. Implementors are advised to use algorithms whose period\n+     * is at least 2<sup>191<\/sup>.\n+     *\n+     * <p> Methods are provided to perform a single leap operation and also to\n+     * produce a stream of generators produced from the original by iterative\n+     * copying and leaping of internal state. The generators produced must\n+     * implement the {@link JumpableGenerator} interface but need not also\n+     * implement the {@link LeapableGenerator} interface. A typical strategy for\n+     * a multithreaded application is to create a single\n+     * {@link LeapableGenerator} object, calls its {@code leaps} method exactly\n+     * once, and then parcel out generators from the resulting stream, one to\n+     * each thread. Then the {@link JumpableGenerator#jump() jump}() method of\n+     * each such generator be called to produce a substream of generator\n+     * objects.\n+     *\n+     * <p> Objects that implement {@link LeapableGenerator} are typically not\n+     * cryptographically secure. Consider instead using {@link SecureRandom} to\n+     * get a cryptographically secure pseudo-random number generator for use by\n+     * security-sensitive applications.\n+     *\/\n+    interface LeapableGenerator extends JumpableGenerator {\n+\n+        \/**\n+         * Returns an instance of {@link LeapableGenerator} that utilizes the\n+         * {@code name} <a href=\"package-summary.html#algorithms\">algorithm<\/a>.\n+         *\n+         * @param name  Name of random number generator\n+         *              <a href=\"package-summary.html#algorithms\">algorithm<\/a>\n+         *\n+         * @return An instance of {@link LeapableGenerator}\n+         *\n+         * @throws NullPointerException if name is null\n+         * @throws IllegalArgumentException if the named algorithm is not found\n+         *\/\n+        static LeapableGenerator of(String name) {\n+            Objects.requireNonNull(name);\n+\n+            return RandomGeneratorFactory.of(name, LeapableGenerator.class);\n+        }\n+\n+        \/**\n+         * Returns a new generator whose internal state is an exact copy of this\n+         * generator (therefore their future behavior should be identical if\n+         * subjected to the same series of operations).\n+         *\n+         * @return a new object that is a copy of this generator\n+         *\/\n+        LeapableGenerator copy();\n+\n+        \/**\n+         * Alter the state of this pseudorandom number generator so as to leap\n+         * forward a large, fixed distance (typically 2<sup>96<\/sup> or more)\n+         * within its state cycle.\n+         *\/\n+        void leap();\n+\n+        \/**\n+         * Returns the distance by which the\n+         * {@link LeapableGenerator#leap() leap}() method will leap forward within\n+         * the state cycle of this generator object.\n+         *\n+         * @return the default leap distance (as a {@code double} value)\n+         *\/\n+        double leapDistance();\n+\n+        \/**\n+         * Returns an effectively unlimited stream of new pseudorandom number\n+         * generators, each of which implements the {@link JumpableGenerator}\n+         * interface.\n+         *\n+         * @return a stream of objects that implement the {@link JumpableGenerator} interface\n+         *\n+         * @implNote It is permitted to implement this method in a manner equivalent to\n+         * {@link LeapableGenerator#leaps(long) leaps}\n+         * ({@link  Long#MAX_VALUE Long.MAX_VALUE}).\n+         *\n+         * @implSpec The default implementation produces a sequential stream that  repeatedly\n+         * calls {@link LeapableGenerator#copy() copy}() and {@link LeapableGenerator#leap() leap}()\n+         * on this generator, and the copies become the generators produced by the stream.\n+         *\/\n+        default Stream<JumpableGenerator> leaps() {\n+            return Stream.generate(this::copyAndLeap).sequential();\n+        }\n+\n+        \/**\n+         * Returns a stream producing the given {@code streamSize} number of new\n+         * pseudorandom number generators, each of which implements the\n+         * {@link JumpableGenerator} interface.\n+         *\n+         * @param streamSize the number of generators to generate\n+         *\n+         * @return a stream of objects that implement the {@link JumpableGenerator} interface\n+         *\n+         * @throws IllegalArgumentException if {@code streamSize} is less than zero\n+         *\n+         * @implSpec The default implementation produces a sequential stream that  repeatedly\n+         *           calls {@link LeapableGenerator#copy() copy}() and {@link LeapableGenerator#leap() leap}()\n+         *           on this generator, and the copies become the generators produced by the stream.\n+         *\/\n+        default Stream<JumpableGenerator> leaps(long streamSize) {\n+            return leaps().limit(streamSize);\n+        }\n+\n+        \/**\n+         * Copy this generator, leap this generator forward, then return the\n+         * copy.\n+         *\n+         * @return a copy of this generator object before the leap occurred\n+         *\n+         * @implSpec The default implementation copies this, leaps and then\n+         * returns the copy.\n+         *\/\n+        default JumpableGenerator copyAndLeap() {\n+            JumpableGenerator result = copy();\n+            leap();\n+            return result;\n+        }\n+\n+    }\n+\n+    \/**\n+     * This interface is designed to provide a common protocol for objects that\n+     * generate sequences of pseudorandom values and can easily <i>jump<\/i>\n+     * forward, by an arbitrary amount, to a distant point in the state cycle.\n+     *\n+     * <p> Ideally, all {@link ArbitrarilyJumpableGenerator} objects produced by\n+     * iterative jumping from a single original\n+     * {@link ArbitrarilyJumpableGenerator} object are statistically independent\n+     * of one another and individually uniform, provided that they do not\n+     * traverse overlapping portions of the state cycle. In practice, one must\n+     * settle for some approximation to independence and uniformity. In\n+     * particular, a specific implementation may assume that each generator in a\n+     * stream produced by the {@link JumpableGenerator#jump() jump}() method is\n+     * used to produce a number of values no larger than the jump distance\n+     * specified. Implementors are advised to use algorithms whose period is at\n+     * least 2<sup>127<\/sup>.\n+     *\n+     * <p> For many applications, it suffices to jump forward by a power of two\n+     * or some small multiple of a power of two, but this power of two may not\n+     * be representable as a {@code long} value. To avoid the use of\n+     * {@link BigInteger} values as jump distances, {@code double} values are\n+     * used instead.\n+     *\n+     * <p> Methods are provided to perform a single jump operation and also to\n+     * produce a stream of generators produced from the original by iterative\n+     * copying and jumping of internal state. A typical strategy for a\n+     * multithreaded application is to create a single\n+     * {@link ArbitrarilyJumpableGenerator} object, call its\n+     * {@link JumpableGenerator#jump() jump}() method exactly once, and then\n+     * parcel out generators from the resulting stream, one to each thread.\n+     * However, each generator produced also has type\n+     * {@link ArbitrarilyJumpableGenerator}; with care, different jump distances\n+     * can be used to traverse the entire state cycle in various ways.\n+     *\n+     * <p> Objects that implement {@link ArbitrarilyJumpableGenerator} are\n+     * typically not cryptographically secure. Consider instead using\n+     * {@link SecureRandom} to get a cryptographically secure pseudo-random\n+     * number generator for use by security-sensitive applications.\n+     *\/\n+    interface ArbitrarilyJumpableGenerator extends LeapableGenerator {\n+\n+        \/**\n+         * Returns an instance of {@link ArbitrarilyJumpableGenerator} that\n+         * utilizes the {@code name} <a href=\"package-summary.html#algorithms\">algorithm<\/a>.\n+         *\n+         * @param name  Name of random number generator\n+         *              <a href=\"package-summary.html#algorithms\">algorithm<\/a>\n+         *\n+         * @return An instance of {@link ArbitrarilyJumpableGenerator}\n+         *\n+         * @throws NullPointerException if name is null\n+         * @throws IllegalArgumentException if the named algorithm is not found\n+         *\/\n+        static ArbitrarilyJumpableGenerator of(String name) {\n+            Objects.requireNonNull(name);\n+\n+            return RandomGeneratorFactory.of(name, ArbitrarilyJumpableGenerator.class);\n+        }\n+\n+        \/**\n+         * Returns a new generator whose internal state is an exact copy of this\n+         * generator (therefore their future behavior should be identical if\n+         * subjected to the same series of operations).\n+         *\n+         * @return a new object that is a copy of this generator\n+         *\/\n+        ArbitrarilyJumpableGenerator copy();\n+\n+        \/**\n+         * Alter the state of this pseudorandom number generator so as to jump\n+         * forward a distance equal to 2<sup>{@code logDistance}<\/sup> within\n+         * its state cycle.\n+         *\n+         * @param logDistance the base-2 logarithm of the distance to jump forward within the state\n+         *                    cycle\n+         *\n+         * @throws IllegalArgumentException if {@code logDistance} is\n+         *                                  2<sup>{@code logDistance}<\/sup> is\n+         *                                  greater than the period of this generator\n+         *\/\n+        void jumpPowerOfTwo(int logDistance);\n+\n+        \/**\n+         * Alter the state of this pseudorandom number generator so as to jump\n+         * forward a specified distance within its state cycle.\n+         *\n+         * @param distance the distance to jump forward within the state cycle\n+         *\n+         * @throws IllegalArgumentException if {@code distance} is not greater than\n+         *                                  or equal to 0.0, or is greater than the\n+         *                                  period of this generator\n+         *\/\n+        void jump(double distance);\n+\n+        \/**\n+         * Alter the state of this pseudorandom number generator so as to jump\n+         * forward a large, fixed distance (typically 2<sup>64<\/sup> or more)\n+         * within its state cycle. The distance used is that returned by method\n+         * {@link ArbitrarilyJumpableGenerator#jumpDistance() jumpDistance}().\n+         *\n+         * @implSpec The default implementation invokes jump(jumpDistance()).\n+         *\/\n+        default void jump() { jump(jumpDistance()); }\n+\n+        \/**\n+         * Returns an effectively unlimited stream of new pseudorandom number\n+         * generators, each of which implements the\n+         * {@link ArbitrarilyJumpableGenerator} interface, produced by jumping\n+         * copies of this generator by different integer multiples of the\n+         * specified jump distance.\n+         *\n+         * @param distance a distance to jump forward within the state cycle\n+         *\n+         * @return a stream of objects that implement the {@link RandomGenerator} interface\n+         *\n+         * @throws IllegalArgumentException if {@code distance} is not greater than\n+         *                                  or equal to 0.0, or is greater than the\n+         *                                  period of this generator\n+         *\n+         * @implSpec The default implementation is equivalent to\n+         * {@link ArbitrarilyJumpableGenerator#jumps(long) jumps}\n+         * ({@link Long#MAX_VALUE Long.MAX_VALUE}).\n+         *\/\n+        default Stream<ArbitrarilyJumpableGenerator> jumps(double distance) {\n+            return Stream.generate(() -> copyAndJump(distance)).sequential();\n+        }\n+\n+        \/**\n+         * Returns a stream producing the given {@code streamSize} number of new\n+         * pseudorandom number generators, each of which implements the\n+         * {@link ArbitrarilyJumpableGenerator} interface, produced by jumping\n+         * copies of this generator by different integer multiples of the\n+         * specified jump distance.\n+         *\n+         * @param streamSize the number of generators to generate\n+         * @param distance   a distance to jump forward within the state cycle\n+         *\n+         * @return a stream of objects that implement the {@link RandomGenerator} interface\n+         *\n+         * @throws IllegalArgumentException if {@code streamSize} is less than zero or if\n+         *                                  {@code distance} is not greater than\n+         *                                  or equal to 0.0, or is greater than the\n+         *                                  period of this generator\n+         *\n+         * @implSpec The default implementation is equivalent to\n+         * jumps(distance).limit(streamSize).\n+         *\/\n+        default Stream<ArbitrarilyJumpableGenerator> jumps(long streamSize, double distance) {\n+            return jumps(distance).limit(streamSize);\n+        }\n+\n+        \/**\n+         * Alter the state of this pseudorandom number generator so as to jump\n+         * forward a very large, fixed distance (typically 2<sup>128<\/sup> or\n+         * more) within its state cycle. The distance used is that returned by\n+         * method\n+         * {@link ArbitrarilyJumpableGenerator#leapDistance() leapDistance}().\n+         *\/\n+        default void leap() { jump(leapDistance()); }\n+\n+        \/**\n+         * Copy this generator, jump this generator forward, then return the\n+         * copy.\n+         *\n+         * @param distance a distance to jump forward within the state cycle\n+         *\n+         * @return a copy of this generator object before the jump occurred\n+         *\n+         * @throws IllegalArgumentException if {@code distance} is not greater than\n+         *                                  or equal to 0.0, or is greater than the\n+         *                                  period of this generator\n+         *\n+         * @implSpec The default implementation copies this, jumps(distance) and then\n+         * returns the copy.\n+         *\/\n+        default ArbitrarilyJumpableGenerator copyAndJump(double distance) {\n+            ArbitrarilyJumpableGenerator result = copy();\n+            jump(distance);\n+\n+            return result;\n+        }\n+\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGenerator.java","additions":1546,"deletions":0,"binary":false,"changes":1546,"status":"added"},{"patch":"@@ -0,0 +1,636 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util.random;\n+\n+import java.lang.reflect.Constructor;\n+import java.math.BigInteger;\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.Map;\n+import java.util.random.RandomGenerator.ArbitrarilyJumpableGenerator;\n+import java.util.random.RandomGenerator.JumpableGenerator;\n+import java.util.random.RandomGenerator.LeapableGenerator;\n+import java.util.random.RandomGenerator.SplittableGenerator;\n+import java.util.random.RandomGenerator.StreamableGenerator;\n+import java.util.ServiceLoader;\n+import java.util.ServiceLoader.Provider;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n+\n+\/**\n+ * This is a factory class for generating multiple random number generators\n+ * of a specific <a href=\"package-summary.html#algorithms\">algorithm<\/a>.\n+ * {@link RandomGeneratorFactory} also provides\n+ * methods for selecting random number generator algorithms.\n+ *\n+ * A specific {@link RandomGeneratorFactory} can be located by using the\n+ * {@link RandomGeneratorFactory#of(String)} method, where the argument string\n+ * is the name of the <a href=\"package-summary.html#algorithms\">algorithm<\/a>\n+ * required. The method\n+ * {@link RandomGeneratorFactory#all()} produces a non-empty {@link Stream} of all available\n+ * {@link RandomGeneratorFactory RandomGeneratorFactorys} that can be searched\n+ * to locate a {@link RandomGeneratorFactory} suitable to the task.\n+ *\n+ * There are three methods for constructing a RandomGenerator instance,\n+ * depending on the type of initial seed required.\n+ * {@link RandomGeneratorFactory#create(long)} is used for long\n+ * seed construction,\n+ * {@link RandomGeneratorFactory#create(byte[])} is used for byte[]\n+ * seed construction, and\n+ * {@link RandomGeneratorFactory#create()} is used for random seed\n+ * construction. Example;\n+ *\n+ * <pre>{@code\n+ *    RandomGeneratorFactory<RandomGenerator> factory = RandomGeneratorFactory.of(\"Random\");\n+ *\n+ *     for (int i = 0; i < 10; i++) {\n+ *         new Thread(() -> {\n+ *             RandomGenerator random = factory.create(100L);\n+ *             System.out.println(random.nextDouble());\n+ *         }).start();\n+ *     }\n+ * }<\/pre>\n+ *\n+ * RandomGeneratorFactory also provides methods describing the attributes (or properties)\n+ * of a generator and can be used to select random number generator\n+ * <a href=\"package-summary.html#algorithms\">algorithms<\/a>.\n+ * These methods are typically used in\n+ * conjunction with {@link RandomGeneratorFactory#all()}. In this example, the code\n+ * locates the {@link RandomGeneratorFactory} that produces\n+ * {@link RandomGenerator RandomGenerators}\n+ * with the highest number of state bits.\n+ *\n+ * <pre>{@code\n+ *     RandomGeneratorFactory<RandomGenerator> best = RandomGeneratorFactory.all()\n+ *         .sorted(Comparator.comparingInt(RandomGenerator::stateBits).reversed())\n+ *         .findFirst()\n+ *         .orElse(RandomGeneratorFactory.of(\"Random\"));\n+ *     System.out.println(best.name() + \" in \" + best.group() + \" was selected\");\n+ *\n+ *     RandomGenerator rng = best.create();\n+ *     System.out.println(rng.nextLong());\n+ * }<\/pre>\n+ *\n+ * @since 17\n+ *\n+ * @see java.util.random\n+ *\n+ *\/\n+public final class RandomGeneratorFactory<T extends RandomGenerator> {\n+    \/**\n+     * Instance provider class of random number algorithm.\n+     *\/\n+    private final Provider<? extends RandomGenerator> provider;\n+\n+    \/**\n+     * Provider RandomGeneratorProperties annotation.\n+     *\/\n+    private volatile RandomGeneratorProperties properties;\n+\n+    \/**\n+     * Default provider constructor.\n+     *\/\n+    private volatile Constructor<T> ctor;\n+\n+    \/**\n+     * Provider constructor with long seed.\n+     *\/\n+    private Constructor<T> ctorLong;\n+\n+    \/**\n+     * Provider constructor with byte[] seed.\n+     *\/\n+    private Constructor<T> ctorBytes;\n+\n+\n+    private static class FactoryMapHolder {\n+        static final Map<String, Provider<? extends RandomGenerator>> FACTORY_MAP = createFactoryMap();\n+\n+        \/**\n+         * Returns the factory map, lazily constructing map on first use.\n+         *\n+         * @return Map of RandomGeneratorFactory classes.\n+         *\/\n+        private static Map<String, Provider<? extends RandomGenerator>> createFactoryMap() {\n+            return ServiceLoader\n+                .load(RandomGenerator.class)\n+                .stream()\n+                .filter(p -> !p.type().isInterface())\n+                .collect(Collectors.toMap(p -> p.type().getSimpleName(), Function.identity()));\n+        }\n+    }\n+\n+    \/**\n+     * Private constructor.\n+     *\n+     * @param provider  Provider class to wrap.\n+     *\/\n+    private RandomGeneratorFactory(Provider<? extends RandomGenerator> provider) {\n+        this.provider = provider;\n+    }\n+\n+    \/**\n+     * Returns the factory map, lazily constructing map on first call.\n+     *\n+     * @return Map of RandomGeneratorFactory classes.\n+     *\/\n+    private static Map<String, Provider<? extends RandomGenerator>> getFactoryMap() {\n+        return FactoryMapHolder.FACTORY_MAP;\n+    }\n+\n+    \/**\n+     * Return the annotation for the specified provider.\n+     *\n+     * @return RandomGeneratorProperties annotation for the specified provider.\n+     *\/\n+     private RandomGeneratorProperties getProperties() {\n+        if (properties == null) {\n+            synchronized (provider) {\n+                if (properties == null) {\n+                    properties = provider.type().getDeclaredAnnotation(RandomGeneratorProperties.class);\n+                    Objects.requireNonNull(properties, provider.type() + \" missing annotation\");\n+                }\n+            }\n+        }\n+\n+        return properties;\n+    }\n+\n+    \/**\n+     * Return true if the provider is a subclass of the category.\n+     *\n+     * @param category Interface category, sub-interface of {@link RandomGenerator}.\n+     *\n+     * @return true if the provider is a subclass of the category.\n+     *\/\n+    private boolean isSubclass(Class<? extends RandomGenerator> category) {\n+        return isSubclass(category, provider);\n+    }\n+\n+    \/**\n+     * Return true if the provider is a subclass of the category.\n+     *\n+     * @param category Interface category, sub-interface of {@link RandomGenerator}.\n+     * @param provider Provider that is being filtered.\n+     *\n+     * @return true if the provider is a subclass of the category.\n+     *\/\n+    private static boolean isSubclass(Class<? extends RandomGenerator> category,\n+                                      Provider<? extends RandomGenerator> provider) {\n+        return provider != null && category.isAssignableFrom(provider.type());\n+    }\n+\n+    \/**\n+     * Returns the provider matching name and category.\n+     *\n+     * @param name      Name of RandomGenerator\n+     * @param category  Interface category, sub-interface of {@link RandomGenerator}.\n+     *\n+     * @return A provider matching name and category.\n+     *\n+     * @throws IllegalArgumentException if provider is not a subclass of category.\n+     *\/\n+    private static Provider<? extends RandomGenerator> findProvider(String name,\n+                                                                    Class<? extends RandomGenerator> category)\n+            throws IllegalArgumentException {\n+        Map<String, Provider<? extends RandomGenerator>> fm = getFactoryMap();\n+        Provider<? extends RandomGenerator> provider = fm.get(name);\n+        if (provider == null) {\n+            throw new IllegalArgumentException(\"No implementation of the random number generator algorithm \\\"\" +\n+                                                name +\n+                                                \"\\\" is available\");\n+        } else if (!isSubclass(category, provider)) {\n+            throw new IllegalArgumentException(\"The random number generator algorithm \\\"\" +\n+                                                name +\n+                                                \"\\\" is not implemented with the interface \\\"\" +\n+                                                category.getSimpleName() +\n+                                                \"\\\"\");\n+        }\n+        return provider;\n+    }\n+\n+    \/**\n+     * Returns a {@link RandomGenerator} that utilizes the {@code name}\n+     * <a href=\"package-summary.html#algorithms\">algorithm<\/a>.\n+     *\n+     * @param name      Name of random number algorithm to use\n+     * @param category  Sub-interface of {@link RandomGenerator} to type check\n+     * @param <T>       Sub-interface of {@link RandomGenerator} to produce\n+     *\n+     * @return An instance of {@link RandomGenerator}\n+     *\n+     * @throws IllegalArgumentException when either the name or category is null\n+     *\/\n+    static <T extends RandomGenerator> T of(String name, Class<T> category)\n+            throws IllegalArgumentException {\n+        @SuppressWarnings(\"unchecked\")\n+        T uncheckedRandomGenerator = (T)findProvider(name, category).get();\n+        return uncheckedRandomGenerator;\n+    }\n+\n+    \/**\n+     * Returns a {@link RandomGeneratorFactory} that will produce instances\n+     * of {@link RandomGenerator} that utilizes the named algorithm.\n+     *\n+     * @param name  Name of random number algorithm to use\n+     * @param category Sub-interface of {@link RandomGenerator} to type check\n+     * @param <T> Sub-interface of {@link RandomGenerator} to produce\n+     *\n+     * @return Factory of {@link RandomGenerator}\n+     *\n+     * @throws IllegalArgumentException when either the name or category is null\n+     *\/\n+    static <T extends RandomGenerator> RandomGeneratorFactory<T> factoryOf(String name, Class<T> category)\n+            throws IllegalArgumentException {\n+        Provider<? extends RandomGenerator> uncheckedProvider = findProvider(name, category);\n+        return new RandomGeneratorFactory<>(uncheckedProvider);\n+    }\n+\n+    \/**\n+     * Fetch the required constructors for class of random number algorithm.\n+     *\n+     * @param randomGeneratorClass class of random number algorithm (provider)\n+     *\/\n+    private void getConstructors(Class<? extends RandomGenerator> randomGeneratorClass) {\n+        if (ctor == null) {\n+            synchronized (provider) {\n+                if (ctor == null) {\n+                    PrivilegedExceptionAction<Constructor<?>[]> ctorAction = randomGeneratorClass::getConstructors;\n+                    try {\n+                        Constructor<?>[] ctors = AccessController.doPrivileged(ctorAction);\n+\n+                        Constructor<T> tmpCtor = null;\n+                        Constructor<T> tmpCtorLong = null;\n+                        Constructor<T> tmpCtorBytes = null;\n+\n+\n+                        for (Constructor<?> ctorGeneric : ctors) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            Constructor<T> ctorSpecific = (Constructor<T>) ctorGeneric;\n+                            final Class<?>[] parameterTypes = ctorSpecific.getParameterTypes();\n+\n+                            if (parameterTypes.length == 0) {\n+                                tmpCtor = ctorSpecific;\n+                            } else if (parameterTypes.length == 1) {\n+                                Class<?> argType = parameterTypes[0];\n+\n+                                if (argType == long.class) {\n+                                    tmpCtorLong = ctorSpecific;\n+                                } else if (argType == byte[].class) {\n+                                    tmpCtorBytes = ctorSpecific;\n+                                }\n+                            }\n+                        }\n+\n+                        if (tmpCtor == null) {\n+                            throw new IllegalStateException(\"Random algorithm \" + name() + \" is missing a default constructor\");\n+                        }\n+\n+                        \/\/ Store specialized constructors first, guarded by ctor\n+                        ctorBytes = tmpCtorBytes;\n+                        ctorLong = tmpCtorLong;\n+                        ctor = tmpCtor;\n+                    } catch (PrivilegedActionException ex) {\n+                        \/\/ Do nothing\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Ensure all the required constructors are fetched.\n+     *\/\n+    private void ensureConstructors() {\n+        getConstructors(provider.type());\n+    }\n+\n+    \/**\n+     * Returns a {@link RandomGeneratorFactory} that can produce instances of\n+     * {@link RandomGenerator} that utilize the {@code name}\n+     * <a href=\"package-summary.html#algorithms\">algorithm<\/a>.\n+     *\n+     * @implNote Availability is determined by RandomGeneratorFactory using the\n+     * service provider API to locate implementations of the RandomGenerator interface.\n+     *\n+     * @param name  Name of random number generator\n+     * <a href=\"package-summary.html#algorithms\">algorithm<\/a>\n+     *\n+     * @return {@link RandomGeneratorFactory} of {@link RandomGenerator}\n+     *\n+     * @throws NullPointerException if name is null\n+     * @throws IllegalArgumentException if the named algorithm is not found\n+     *\/\n+    public static RandomGeneratorFactory<RandomGenerator> of(String name) {\n+        Objects.requireNonNull(name);\n+\n+        return factoryOf(name, RandomGenerator.class);\n+    }\n+\n+    \/**\n+     * Returns a {@link RandomGeneratorFactory} meeting the minimal requirement\n+     * of having an algorithm whose state bits are greater than or equal 64.\n+     *\n+     * @implSpec  Since algorithms will improve over time, there is no\n+     * guarantee that this method will return the same algorithm over time.\n+     *\n+     * @return a {@link RandomGeneratorFactory}\n+     *\/\n+    public static RandomGeneratorFactory<RandomGenerator> getDefault() {\n+        return factoryOf(\"L32X64MixRandom\", RandomGenerator.class);\n+    }\n+\n+    \/**\n+     * Returns a stream of matching Providers.\n+     *\n+     * @param category  {@link RandomGenerator} sub-interface class to filter\n+     * @param <T>       {@link RandomGenerator} sub-interface return type\n+     *\n+     * @implNote Availability is determined by RandomGeneratorFactory using the service provider API\n+     * to locate implementations of the RandomGenerator interface.\n+     *\n+     * @return Stream of matching {@link RandomGeneratorFactory RandomGeneratorFactory(s)}.\n+     *\/\n+    public static <T extends RandomGenerator> Stream<RandomGeneratorFactory<T>> all(Class<T> category) {\n+        Map<String, Provider<? extends RandomGenerator>> fm = getFactoryMap();\n+        return fm.values()\n+                 .stream()\n+                 .filter(p -> isSubclass(category, p) &&\n+                              !p.type().isAnnotationPresent(Deprecated.class) &&\n+                              p.type().isAnnotationPresent(RandomGeneratorProperties.class))\n+                 .map(RandomGeneratorFactory::new);\n+    }\n+\n+    \/**\n+     * Returns a a non-empty stream of all available {@link RandomGeneratorFactory RandomGeneratorFactory(s)}.\n+     *\n+     * @implNote Availability is determined by RandomGeneratorFactory using the service provider API\n+     * to locate implementations of the RandomGenerator interface. RandomGenerators that are marked\n+     * as deprecated are not included in the result.\n+     *\n+     * @return a non-empty stream of all available {@link RandomGeneratorFactory RandomGeneratorFactory(s)}.\n+     *\/\n+    public static Stream<RandomGeneratorFactory<RandomGenerator>> all() {\n+        Map<String, Provider<? extends RandomGenerator>> fm = getFactoryMap();\n+        return fm.values()\n+                 .stream()\n+                 .filter(p -> !p.type().isAnnotationPresent(Deprecated.class) &&\n+                              p.type().isAnnotationPresent(RandomGeneratorProperties.class))\n+                 .map(RandomGeneratorFactory::new);\n+    }\n+\n+    \/**\n+     * Return the name of the <a href=\"package-summary.html#algorithms\">algorithm<\/a>\n+     * used by the random number generator.\n+     *\n+     * @implNote Availability is determined by RandomGeneratorFactory using the service provider API\n+     * to locate implementations of the RandomGenerator interface. RandomGenerators that are marked\n+     * as deprecated are not included in the result.\n+     *\n+     * @return Name of the <a href=\"package-summary.html#algorithms\">algorithm<\/a>.\n+     *\/\n+    public String name() {\n+        return provider.type().getSimpleName();\n+    }\n+\n+    \/**\n+     * Return the group name of the <a href=\"package-summary.html#algorithms\">algorithm<\/a>\n+     * used by the random number generator.\n+     *\n+     * @return Group name of the <a href=\"package-summary.html#algorithms\">algorithm<\/a>.\n+     *\/\n+    public String group() {\n+        return getProperties().group();\n+    }\n+\n+    \/**\n+     * Returns number of bits used by the <a href=\"package-summary.html#algorithms\">algorithm<\/a>\n+     * to maintain state of seed.\n+     *\n+     * @return number of bits used by the <a href=\"package-summary.html#algorithms\">algorithm<\/a>\n+     *         to maintain state of seed.\n+     *\/\n+    public int stateBits() {\n+        RandomGeneratorProperties properties = getProperties();\n+        int i = properties.i();\n+        int k = properties.k();\n+\n+        return i == 0 && k == 0 ? Integer.MAX_VALUE : i + k;\n+    }\n+\n+    \/**\n+     * Returns the equidistribution of the <a href=\"package-summary.html#algorithms\">algorithm<\/a>.\n+     *\n+     * @return the equidistribution of the <a href=\"package-summary.html#algorithms\">algorithm<\/a>.\n+     *\/\n+    public int equidistribution() {\n+        return getProperties().equidistribution();\n+    }\n+\n+    \/**\n+     * Return the period of the <a href=\"package-summary.html#algorithms\">algorithm<\/a>\n+     * used by the random number generator.\n+     * Returns BigInteger.ZERO if period is not determinable.\n+     *\n+     * @return BigInteger period.\n+     *\/\n+    public BigInteger period() {\n+        RandomGeneratorProperties properties = getProperties();\n+        int i = properties.i();\n+        int j = properties.j();\n+        int k = properties.k();\n+\n+        if (i == 0 && j == 0 && k == 0) {\n+            return BigInteger.ZERO;\n+        } else {\n+            return BigInteger.ONE.shiftLeft(i).subtract(BigInteger.valueOf(j)).shiftLeft(k);\n+        }\n+    }\n+\n+    \/**\n+     * Return true if random generator is computed using an arithmetic\n+     * <a href=\"package-summary.html#algorithms\">algorithm<\/a>\n+     * and is statistically deterministic.\n+     *\n+     * @return true if random generator is statistical.\n+     *\/\n+    public boolean isStatistical() {\n+        return !getProperties().isStochastic();\n+    }\n+\n+    \/**\n+     * Return true if random generator is computed using external or entropic\n+     * sources as inputs.\n+     *\n+     * @return true if random generator is stochastic.\n+     *\/\n+    public boolean isStochastic() {\n+        return getProperties().isStochastic();\n+    }\n+\n+    \/**\n+     * Return true if random generator uses a hardware device (HRNG) to produce\n+     * entropic input.\n+     *\n+     * @return true if random generator is generated by hardware.\n+     *\/\n+    public boolean isHardware() {\n+        return getProperties().isHardware();\n+    }\n+\n+    \/**\n+     * Return true if random generator can jump an arbitrarily specified distant\n+     * point in the state cycle.\n+     *\n+     * @return true if random generator is arbitrarily jumpable.\n+     *\/\n+    public boolean isArbitrarilyJumpable() {\n+        return isSubclass(ArbitrarilyJumpableGenerator.class);\n+    }\n+\n+    \/**\n+     * Return true if random generator can jump a specified distant point in\n+     * the state cycle.\n+     *\n+     * @return true if random generator is jumpable.\n+     *\/\n+    public boolean isJumpable() {\n+        return isSubclass(JumpableGenerator.class);\n+    }\n+\n+    \/**\n+     * Return true if random generator is jumpable and can leap to a very distant\n+     * point in the state cycle.\n+     *\n+     * @return true if random generator is leapable.\n+     *\/\n+    public boolean isLeapable() {\n+        return isSubclass(LeapableGenerator.class);\n+    }\n+\n+    \/**\n+     * Return true if random generator can be cloned into a separate object with\n+     * the same properties but positioned further in the state cycle.\n+     *\n+     * @return true if random generator is splittable.\n+     *\/\n+    public boolean isSplittable() {\n+        return isSubclass(SplittableGenerator.class);\n+    }\n+\n+    \/**\n+     * Return true if random generator can be used to create\n+     * {@link java.util.stream.Stream Streams} of random numbers.\n+     *\n+     * @return true if random generator is streamable.\n+     *\/\n+    public boolean isStreamable() {\n+        return isSubclass(StreamableGenerator.class);\n+    }\n+\n+    \/**\n+     * Return true if the implementation of RandomGenerator (algorithm) has been\n+     * marked for deprecation.\n+     *\n+     * @implNote Random number generator algorithms evolve over time; new\n+     *           algorithms will be introduced and old algorithms will\n+     *           lose standing. If an older algorithm is deemed unsuitable\n+     *           for continued use, it will be marked as deprecated to indicate\n+     *           that it may be removed at some point in the future.\n+     *\n+     * @return true if the implementation of RandomGenerator (algorithm) has been\n+     *         marked for deprecation\n+     *\/\n+     public boolean isDeprecated() {\n+        return provider.type().isAnnotationPresent(Deprecated.class);\n+     }\n+\n+    \/**\n+     * Create an instance of {@link RandomGenerator} based on\n+     * <a href=\"package-summary.html#algorithms\">algorithm<\/a> chosen.\n+     *\n+     * @return new in instance of {@link RandomGenerator}.\n+     *\n+     *\/\n+    public T create() {\n+        try {\n+            ensureConstructors();\n+            return ctor.newInstance();\n+        } catch (Exception ex) {\n+            \/\/ Should never happen.\n+            throw new IllegalStateException(\"Random algorithm \" + name() + \" is missing a default constructor\", ex);\n+        }\n+    }\n+\n+    \/**\n+     * Create an instance of {@link RandomGenerator} based on\n+     * <a href=\"package-summary.html#algorithms\">algorithm<\/a> chosen\n+     * providing a starting long seed. If long seed is not supported by an\n+     * algorithm then the no argument form of create is used.\n+     *\n+     * @param seed long random seed value.\n+     *\n+     * @return new in instance of {@link RandomGenerator}.\n+     *\/\n+    public T create(long seed) {\n+        try {\n+            ensureConstructors();\n+            return ctorLong.newInstance(seed);\n+        } catch (Exception ex) {\n+            return create();\n+        }\n+    }\n+\n+    \/**\n+     * Create an instance of {@link RandomGenerator} based on\n+     * <a href=\"package-summary.html#algorithms\">algorithm<\/a> chosen\n+     * providing a starting byte[] seed. If byte[] seed is not supported by an\n+     * <a href=\"package-summary.html#algorithms\">algorithm<\/a> then the no\n+     * argument form of create is used.\n+     *\n+     * @param seed byte array random seed value.\n+     *\n+     * @return new in instance of {@link RandomGenerator}.\n+     *\n+     * @throws NullPointerException if seed is null.\n+     *\/\n+    public T create(byte[] seed) {\n+        Objects.requireNonNull(seed, \"seed must not be null\");\n+        try {\n+            ensureConstructors();\n+            return ctorBytes.newInstance(seed);\n+        } catch (Exception ex) {\n+            return create();\n+        }\n+    }\n+\n+}\n+\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGeneratorFactory.java","additions":636,"deletions":0,"binary":false,"changes":636,"status":"added"},{"patch":"@@ -0,0 +1,628 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * This package contains classes and interfaces that support a generic API\n+ * for random number generation.\n+ *\n+ * <p>These classes and interfaces that support the definition and use of \"random\n+ * generators\", a term that is meant to cover what have traditionally been\n+ * called \"random number generators\" as well as generators of other sorts of\n+ * randomly chosen values, and also to cover not only deterministic\n+ * (pseudorandom) algorithms but also generators of values that use some \"truly\n+ * random\" physical source (perhaps making use of thermal noise, for example, or\n+ * quantum-mechanical effects).\n+ *\n+ * <p> The principal interface is {@link RandomGenerator}, which provides\n+ * methods for requesting individual values of type {@code int}, {@code long},\n+ * {@code float}, {@code double}, or {@code boolean} chosen pseudorandomly\n+ * from a uniform distribution; methods for requesting values of type\n+ * {@code double} chosen pseudorandomly from a normal distribution or from an\n+ * exponential distribution; and methods for creating streams of values of type\n+ * {@code int}, {@code long}, or {@code double} chosen pseudorandomly from a\n+ * uniform distribution (such streams are spliterator-based, allowing for\n+ * parallel processing of their elements). There are also static factory methods\n+ * for creating an instance of a specific random number generator algorithm\n+ * given its name.\n+ *\n+ * <p> The principal supporting class is {@link RandomGeneratorFactory}. This\n+ * can be used to generate multiple random number generators for a specific\n+ * algorithm. {@link RandomGeneratorFactory} also provides methods for\n+ * selecting random number generator algorithms. RandomGeneratorFactory\n+ * registers implementations of {@link RandomGenerator} interface using the\n+ * service provider API.\n+ *\n+ * <p> An important subsidiary interface is\n+ * {@link RandomGenerator.StreamableGenerator}, which provides methods for\n+ * creating spliterator-based streams of {@link RandomGenerator} objects,\n+ * allowing for parallel processing of these objects using multiple threads.\n+ * Unlike {@link java.util.Random}, most implementations of\n+ * {@link RandomGenerator} are <i>not<\/i> thread-safe. The intent is that\n+ * instances should not be shared among threads; rather, each thread should have\n+ * its own random generator(s) to use. The various pseudorandom algorithms\n+ * provided by this package are designed so that multiple instances will (with\n+ * very high probability) behave as if statistically independent.\n+ *\n+ * <p> For many purposes, these are the only two interfaces that a consumer of\n+ * pseudorandom values will need. There are also some more specialized\n+ * interfaces that describe more specialized categories of random number\n+ * generators {@link RandomGenerator.SplittableGenerator SplittableGenerator},\n+ * {@link RandomGenerator.JumpableGenerator JumpableGenerator},\n+ * {@link RandomGenerator.LeapableGenerator LeapableGenerator}, and\n+ * {@link RandomGenerator.ArbitrarilyJumpableGenerator ArbitrarilyJumpableGenerator}\n+ * that have specific strategies for creating statistically independent instances.\n+ *\n+ * <h2>Using the Random Number Generator Interfaces<\/h2>\n+ *\n+ * To get started, an application should first create one instance of a\n+ * generator class. Assume that the contents of the package\n+ * {@link java.util.random} has been imported:\n+ *\n+ * <blockquote>{@code import java.util.random.*;}<\/blockquote>\n+ *\n+ * Then one can choose a specific implementation by giving the name of a generator\n+ * algorithm to the static method {@link RandomGenerator#of}, in which case the\n+ * no-arguments constructor for that implementation is used:\n+ *\n+ * <blockquote>{@code RandomGenerator g = RandomGenerator.of(\"L64X128MixRandom\");}<\/blockquote>\n+ *\n+ * For a single-threaded application, this is all that is needed. One can then\n+ * invoke methods of {@code g} such as\n+ * {@link RandomGenerator#nextLong nextLong()},\n+ * {@link RandomGenerator#nextInt nextInt()},\n+ * {@link RandomGenerator#nextFloat nextFloat()},\n+ * {@link RandomGenerator#nextDouble nextDouble()} and\n+ * {@link RandomGenerator#nextBoolean nextBoolean()} to generate individual\n+ * randomly chosen values. One can also use the methods\n+ * {@link RandomGenerator#ints ints()}, {@link RandomGenerator#longs longs()}\n+ * and {@link RandomGenerator#doubles doubles()} to create streams of randomly\n+ * chosen values. The methods\n+ * {@link RandomGenerator#nextGaussian nextGaussian()} and\n+ * {@link RandomGenerator#nextExponential nextExponential()} draw floating-point\n+ * values from nonuniform distributions. The method\n+ *\n+ * <p> For a multi-threaded application, one can repeat the preceding steps\n+ * to create additional {@linkplain RandomGenerator RandomGenerators}, but\n+ * often it is preferable to use methods of the one single initially\n+ * created generator to create others like it. (One reason is that some\n+ * generator algorithms, if asked to create a new set of generators all at\n+ * once, can make a special effort to ensure that the new generators are\n+ * statistically independent.) If the initial generator implements the\n+ * interface {@link RandomGenerator.StreamableGenerator}, then the method\n+ * {@link RandomGenerator.StreamableGenerator#rngs rngs()} can be used to\n+ * create a stream of generators. If this is a parallel stream, then it is\n+ * easy to get parallel execution by using the\n+ * {@link java.util.stream.Stream#map map()} method on the stream.\n+ * <p> For a multi-threaded application that forks new threads dynamically,\n+ * another approach is to use an initial generator that implements the interface\n+ * {@link RandomGenerator.SplittableGenerator}, which is then considered to\n+ * \"belong\" to the initial thread for its exclusive use; then whenever any\n+ * thread needs to fork a new thread, it first uses the\n+ * {@link RandomGenerator.SplittableGenerator#split split()} method of its own\n+ * generator to create a new generator, which is then passed to the newly\n+ * created thread for exclusive use by that new thread.\n+ *\n+ *\n+ * <h2>Choosing a Random Number Generator Algorithm<\/h2>\n+ *\n+ * <p> There are three groups of random number generator algorithm provided\n+ * in Java; Legacy group, LXM group and Xoroshiro\/Xoshiro group.\n+ *\n+ * <p> The legacy group includes random number generators that existed\n+ * before JDK 17; Random, ThreadLocalRandom, SplittableRandom and\n+ * SecureRandom. Random (LCG) is the weakest of available algorithms and it\n+ * is recommended that users migrate to newer algorithms. If an application\n+ * requires a random number generator algorithm that is cryptographically\n+ * secure, then it should continue to use an instance of the class {@link\n+ * java.security.SecureRandom}.\n+ *\n+ * <p> The algorithms in the LXM group use a similar algorithm. The parameters\n+ * of the algorithm can be found in algorithm name. The numbers indicate the\n+ * number of bits in the lower and upper state bits respectively. Mix indicates\n+ * the algorithm uses mix congruency. StarStar indicates use a double\n+ * multiplier.\n+ *\n+ * <p> The algorithms in the Xoroshiro\/Xoshiro are more traditional algorithms\n+ * where the number in the name indicates the period.\n+ *\n+ * <p> For applications (such as physical simulation, machine learning, and\n+ * games) that do not require a cryptographically secure algorithm, this package\n+ * provides multiple implementations of interface {@link RandomGenerator} that\n+ * provide trade-offs among speed, space, period, accidental correlation, and\n+ * equidistribution properties.\n+ *\n+ * <p> For applications with no special requirements,\n+ * {@code L64X128MixRandom} has a good balance among speed, space,\n+ * and period, and is suitable for both single-threaded and multi-threaded\n+ * applications when used properly (a separate instance for each thread).\n+ *\n+ * <p> If the application uses only a single thread, then\n+ * {@code Xoroshiro128PlusPlus} is even smaller and faster, and\n+ * certainly has a sufficiently long period.\n+ *\n+ * <p> For an application running in a 32-bit hardware environment and using\n+ * only one thread or a small number of threads, {@code L32X64MixRandom} may be a good\n+ * choice.\n+ *\n+ * <p> For an application that uses many threads that are allocated in one batch\n+ * at the start of the computation, either a \"jumpable\" generator such as\n+ * {@code Xoroshiro128PlusPlus} or\n+ * {@code Xoshiro256PlusPlus} may be used, or a \"splittable\"\n+ * generator such as {@code L64X128MixRandom} or\n+ * {@code L64X256MixRandom} may be used.\n+ *\n+ * <p> For an application that creates many threads dynamically, perhaps through\n+ * the use of spliterators, a \"splittable\" generator such as\n+ * {@code L64X128MixRandom} or {@code L64X256MixRandom} is\n+ * recommended. If the number of generators created dynamically may\n+ * be very large (millions or more), then using generators such as\n+ * {@code L128X128MixRandom} or {@code L128X256MixRandom},\n+ * which use a 128-bit parameter rather than a 64-bit parameter for their LCG\n+ * subgenerator, will make it much less likely that two instances use the same\n+ * state cycle.\n+ *\n+ * <p> For an application that uses tuples of consecutively generated values, it\n+ * may be desirable to use a generator that is <i>k<\/i>-equidistributed such\n+ * that <i>k<\/i> is at least as large as the length of the tuples being\n+ * generated. The generator {@code L64X256MixRandom} is provably\n+ * 4-equidistributed, and {@code L64X1024MixRandom} is provably\n+ * 16-equidistributed.\n+ *\n+ * <p> For applications that generate large permutations, it may be best to use\n+ * a generator whose period is much larger than the total number of possible\n+ * permutations; otherwise it will be impossible to generate some of the\n+ * intended permutations. For example, if the goal is to shuffle a deck of 52\n+ * cards, the number of possible permutations is 52! (52 factorial), \\ which is\n+ * larger than 2<sup>225<\/sup> (but smaller than 2<sup>226<\/sup>), so it may be\n+ * best to use a generator whose period at least 2<sup>256<\/sup>, such as\n+ * {@code L64X256MixRandom} or {@code L64X1024MixRandom}\n+ * or {@code L128X256MixRandom} or\n+ * {@code L128X1024MixRandom}. (It is of course also necessary to\n+ * provide sufficiently many seed bits when the generator is initialized, or\n+ * else it will still be impossible to generate some of the intended\n+ * permutations.)\n+ *\n+ *\n+ * <h2><a id=\"algorithms\">Random Number Generator Algorithms Available.<\/a><\/h2>\n+ *\n+ * These algorithms [in the table below] must be found with the current version\n+ * of Java SE. A particular JDK implementation may recognize additional\n+ * algorithms; check the JDK's documentation for details. The set of algorithm\n+ * required by Java SE may be updated by changes to the Java SE specification.\n+ * Over time, new algorithms may be added and old algorithms may be removed.\n+ * <p>In addition, as another life-cycle phase, an algorithm may be {@linkplain\n+ * RandomGeneratorFactory#isDeprecated() deprecated}. A deprecated algorithm is\n+ * not recommended for use. If a required algorithm is deprecated, it may be\n+ * removed in a future release. Due to advances in random number generator\n+ * algorithm development and analysis, an algorithm may be deprecated during the\n+ * lifetime of a particular Java SE release. Changing the deprecation status of\n+ * an algorithm is <em>not<\/em> a specification change.\n+ *\n+ * <table style=\"padding:0px 20px 0px 0px\">\n+ *  <caption>Available Algorithms<\/caption>\n+ *  <thead>\n+ *  <tr>\n+ *      <th style=\"text-align:left\">Algorithm<\/th>\n+ *      <th style=\"text-align:left\">Group<\/th>\n+ *      <th style=\"text-align:left\">Period<\/th>\n+ *      <th style=\"text-align:right\">StateBits<\/th>\n+ *      <th style=\"text-align:right\">Equidistribution<\/th>\n+ *  <\/tr>\n+ *  <\/thead>\n+ *  <tbody>\n+ *  <tr>\n+ *      <td style=\"text-align:left\">L128X1024MixRandom<\/td>\n+ *      <td style=\"text-align:left\">LXM<\/td>\n+ *      <td style=\"text-align:left\">BigInteger.ONE.shiftLeft(N*64).subtract(BigInteger.ONE).shiftLeft(128)<\/td>\n+ *      <td style=\"text-align:right\">1152<\/td>\n+ *      <td style=\"text-align:right\">1<\/td>\n+ *  <\/tr>\n+ *  <tr>\n+ *      <td style=\"text-align:left\">L128X128MixRandom<\/td>\n+ *      <td style=\"text-align:left\">LXM<\/td>\n+ *      <td style=\"text-align:left\">BigInteger.ONE.shiftLeft(128).subtract(BigInteger.ONE).shiftLeft(128)<\/td>\n+ *      <td style=\"text-align:right\">256<\/td>\n+ *      <td style=\"text-align:right\">1<\/td>\n+ *  <\/tr>\n+ *  <tr>\n+ *      <td style=\"text-align:left\">L128X256MixRandom<\/td>\n+ *      <td style=\"text-align:left\">LXM<\/td>\n+ *      <td style=\"text-align:left\">BigInteger.ONE.shiftLeft(256).subtract(BigInteger.ONE).shiftLeft(128)<\/td>\n+ *      <td style=\"text-align:right\">384<\/td>\n+ *      <td style=\"text-align:right\">1<\/td>\n+ *  <\/tr>\n+ *  <tr>\n+ *      <td style=\"text-align:left\">L32X64MixRandom<\/td>\n+ *      <td style=\"text-align:left\">LXM<\/td>\n+ *      <td style=\"text-align:left\">BigInteger.ONE.shiftLeft(64).subtract(BigInteger.ONE).shiftLeft(32)<\/td>\n+ *      <td style=\"text-align:right\">96<\/td>\n+ *      <td style=\"text-align:right\">1<\/td>\n+ *  <\/tr>\n+ *  <tr>\n+ *      <td style=\"text-align:left\">L64X1024MixRandom<\/td>\n+ *      <td style=\"text-align:left\">LXM<\/td>\n+ *      <td style=\"text-align:left\">BigInteger.ONE.shiftLeft(N*64).subtract(BigInteger.ONE).shiftLeft(64)<\/td>\n+ *      <td style=\"text-align:right\">1088<\/td>\n+ *      <td style=\"text-align:right\">16<\/td>\n+ *  <\/tr>\n+ *  <tr>\n+ *      <td style=\"text-align:left\">L64X128MixRandom<\/td>\n+ *      <td style=\"text-align:left\">LXM<\/td>\n+ *      <td style=\"text-align:left\">BigInteger.ONE.shiftLeft(128).subtract(BigInteger.ONE).shiftLeft(64)<\/td>\n+ *      <td style=\"text-align:right\">192<\/td>\n+ *      <td style=\"text-align:right\">1<\/td>\n+ *  <\/tr>\n+ *  <tr>\n+ *      <td style=\"text-align:left\">L64X128StarStarRandom<\/td>\n+ *      <td style=\"text-align:left\">LXM<\/td>\n+ *      <td style=\"text-align:left\">BigInteger.ONE.shiftLeft(128).subtract(BigInteger.ONE).shiftLeft(64)<\/td>\n+ *      <td style=\"text-align:right\">192<\/td>\n+ *      <td style=\"text-align:right\">1<\/td>\n+ *  <\/tr>\n+ *  <tr>\n+ *      <td style=\"text-align:left\">L64X256MixRandom<\/td>\n+ *      <td style=\"text-align:left\">LXM<\/td>\n+ *      <td style=\"text-align:left\">BigInteger.ONE.shiftLeft(256).subtract(BigInteger.ONE).shiftLeft(64)<\/td>\n+ *      <td style=\"text-align:right\">320<\/td>\n+ *      <td style=\"text-align:right\">4<\/td>\n+ *  <\/tr>\n+ *  <tr>\n+ *      <td style=\"text-align:left\">Random<\/td>\n+ *      <td style=\"text-align:left\">Legacy<\/td>\n+ *      <td style=\"text-align:left\">BigInteger.ONE.shiftLeft(48)<\/td>\n+ *      <td style=\"text-align:right\">48<\/td>\n+ *      <td style=\"text-align:right\">0<\/td>\n+ *  <\/tr>\n+ *  <tr>\n+ *      <td style=\"text-align:left\">SplittableRandom<\/td>\n+ *      <td style=\"text-align:left\">Legacy<\/td>\n+ *      <td style=\"text-align:left\">BigInteger.ONE.shiftLeft(64)<\/td>\n+ *      <td style=\"text-align:right\">64<\/td>\n+ *      <td style=\"text-align:right\">1<\/td>\n+ *  <\/tr>\n+ *  <tr>\n+ *      <td style=\"text-align:left\">ThreadLocalRandom <sup>*<\/sup><\/td>\n+ *      <td style=\"text-align:left\">Legacy<\/td>\n+ *      <td style=\"text-align:left\">BigInteger.ONE.shiftLeft(64)<\/td>\n+ *      <td style=\"text-align:right\">64<\/td>\n+ *      <td style=\"text-align:right\">1<\/td>\n+ *  <\/tr>\n+ *  <tr>\n+ *      <td style=\"text-align:left\">Xoroshiro128PlusPlus<\/td>\n+ *      <td style=\"text-align:left\">Xoroshiro<\/td>\n+ *      <td style=\"text-align:left\">BigInteger.ONE.shiftLeft(128).subtract(BigInteger.ONE)<\/td>\n+ *      <td style=\"text-align:right\">128<\/td>\n+ *      <td style=\"text-align:right\">2<\/td>\n+ *  <\/tr>\n+ *  <tr>\n+ *      <td style=\"text-align:left\">Xoshiro256PlusPlus<\/td>\n+ *      <td style=\"text-align:left\">Xoshiro<\/td>\n+ *      <td style=\"text-align:left\">BigInteger.ONE.shiftLeft(256).subtract(BigInteger.ONE)<\/td>\n+ *      <td style=\"text-align:right\">256<\/td>\n+ *      <td style=\"text-align:right\">4<\/td>\n+ *  <\/tr>\n+ *  <\/tbody>\n+ * <\/table>\n+ *\n+ * <p><sup>*<\/sup> ThreadLocalRandom can only be accessed via\n+ * {@link java.util.concurrent.ThreadLocalRandom#current()}.\n+ *\n+ * <h2>Categories of Random Number Generator Algorithms<\/h2>\n+ *\n+ * Historically, most pseudorandom generator algorithms have been based on some\n+ * sort of finite-state machine with a single, large cycle of states; when it is\n+ * necessary to have multiple threads use the same algorithm simultaneously, the\n+ * usual technique is to arrange for each thread to traverse a different region\n+ * of the state cycle. These regions may be doled out to threads by starting\n+ * with a single initial state and then using a \"jump function\" that travels a\n+ * long distance around the cycle (perhaps 2<sup>64<\/sup> steps or more); the\n+ * jump function is applied repeatedly and sequentially, to identify widely\n+ * spaced states that are then doled out, one to each thread, to serve as the\n+ * initial state for the generator to be used by that thread. This strategy is\n+ * supported by the interface {@link RandomGenerator.JumpableGenerator}.\n+ * Sometimes it is desirable to support two levels of jumping (by long distances\n+ * and by <i>really<\/i> long distances); this strategy is supported by the\n+ * interface {@link RandomGenerator.LeapableGenerator}. There is also an interface\n+ * {@link RandomGenerator.ArbitrarilyJumpableGenerator} for algorithms that allow\n+ * jumping along the state cycle by any user-specified distance. In this package,\n+ * implementations of these interfaces include\n+ * \"Xoroshiro128PlusPlus\", and\n+ * \"Xoshiro256PlusPlus\".\n+ *\n+ * <p> A more recent category of \"splittable\" pseudorandom generator algorithms\n+ * uses a large family of state cycles and makes some attempt to ensure that\n+ * distinct instances use different state cycles; but even if two instances\n+ * \"accidentally\" use the same state cycle, they are highly likely to traverse\n+ * different regions parts of that shared state cycle. This strategy is\n+ * supported by the interface {@link RandomGenerator.SplittableGenerator}.\n+ * In this package, implementations of this interface include\n+ * \"L32X64MixRandom\",\n+ * \"L64X128StarStarRandom\",\n+ * \"L64X128MixRandom\",\n+ * \"L64X256MixRandom\",\n+ * \"L64X1024MixRandom\",\n+ * \"L128X128MixRandom\",\n+ * \"L128X256MixRandom\", and\n+ * \"L128X1024MixRandom\"; note that the class\n+ * {@link java.util.SplittableRandom} also implements this interface.\n+ *\n+ *\n+ * <h2>The LXM Family of Random Number Generator Algorithms<\/h2>\n+ *\n+ * The structure of the central nextLong (or nextInt) method of an LXM\n+ * algorithm follows a suggestion in December 2017 by Sebastiano Vigna\n+ * that using one LCG subgenerator and one xor-based subgenerator (rather\n+ * than two LCG subgenerators) would provide a longer period, superior\n+ * equidistribution, scalability, and better quality.  Each of the\n+ * specific implementations here combines one of the best currently known\n+ * xor-based generators (xoroshiro or xoshiro, described by Blackman and\n+ * Vigna in \"Scrambled Linear Pseudorandom Number Generators\", ACM\n+ * Trans. Math. Softw., 2021) with an LCG that uses one of the best\n+ * currently known multipliers (found by a search for better multipliers\n+ * in 2019 by Steele and Vigna), and then applies a mixing function\n+ * identified by Doug Lea. Testing has confirmed that the LXM algorithm\n+ * is far superior in quality to the SplitMix algorithm (2014) used by\n+ * SplittableRandom.\n+ *\n+ * Each class with a name of the form {@code L}<i>p<\/i>{@code X}<i>q<\/i>{@code\n+ * SomethingRandom} uses some specific member of the LXM family of random number\n+ * algorithms; \"LXM\" is short for \"LCG, Xorshift, Mixing function\". Every LXM\n+ * generator consists of two subgenerators; one is an LCG (Linear Congruential\n+ * Generator) and the other is an Xorshift generator. Each output of an LXM\n+ * generator is the result of combining state from the LCG with state from the\n+ * Xorshift generator by using a Mixing function (and then the state of the LCG\n+ * and the state of the Xorshift generator are advanced).\n+ *\n+ * <p> The LCG subgenerator has an update step of the form {@code s = m*s + a},\n+ * where {@code s}, {@code m}, and {@code a} are all binary integers of the same\n+ * size, each having <i>p<\/i> bits; {@code s} is the mutable state, the\n+ * multiplier {@code m} is fixed (the same for all instances of a class) and the\n+ * addend {@code a} is a parameter (a final field of the instance). The\n+ * parameter {@code a} is required to be odd (this allows the LCG to have the\n+ * maximal period, namely 2<sup><i>p<\/i><\/sup>); therefore there are\n+ * 2<sup><i>p<\/i>&minus;1<\/sup> distinct choices of parameter. (When the size of\n+ * {@code s} is 128 bits, then we use the name \"{@code sh}\" below to refer to\n+ * the high half of {@code s}, that is, the high-order 64 bits of {@code s}.)\n+ *\n+ * <p> The Xorshift subgenerator can in principle be any one of a wide variety\n+ * of xorshift algorithms; in this package it is always either\n+ * {@code xoroshiro128}, {@code xoshiro256}, or {@code xoroshiro1024}, in each\n+ * case without any final scrambler such as \"+\" or \"**\". Its state consists of\n+ * some fixed number of {@code int} or {@code long} fields, generally named\n+ * {@code x0}, {@code x1}, and so on, which can take on any values provided that\n+ * they are not all zero. The collective total size of these fields is <i>q<\/i>\n+ * bits; therefore the period of this subgenerator is\n+ * 2<sup><i>q<\/i><\/sup>&minus;1.\n+ *\n+ * <p> Because the periods 2<sup><i>p<\/i><\/sup> and 2<sup><i>q<\/i><\/sup>&minus;1\n+ * of the two subgenerators are relatively prime, the <em>period<\/em> of any\n+ * single instance of an LXM algorithm (the length of the series of generated\n+ * values before it repeats) is the product of the periods of the subgenerators,\n+ * that is, 2<sup><i>p<\/i><\/sup>(2<sup><i>q<\/i><\/sup>&minus;1), which is just\n+ * slightly smaller than 2<sup>(<i>p<\/i>+<i>q<\/i>)<\/sup>. Moreover, if two\n+ * distinct instances of the same LXM algorithm have different {@code a}\n+ * parameters, then their cycles of produced values will be different.\n+ *\n+ * <p> Generally speaking, among the \"{@code L}<i>p<\/i>{@code X}<i>q<\/i>\"\n+ * generators, the memory required for an instance is 2<i>p<\/i>+<i>q<\/i> bits.\n+ * (If <i>q<\/i> is 1024 or larger, the Xorshift state is represented as an\n+ * array, so additional bits are needed for the array object header, and another\n+ * 32 bits are used for an array index.)\n+ *\n+ * <p> Larger values of <i>p<\/i> imply a lower probability that two distinct\n+ * instances will traverse the same state cycle, and larger values of <i>q<\/i>\n+ * imply that the generator is equidistributed in a larger number of dimensions\n+ * (this is provably true when <i>p<\/i> is 64, and conjectured to be\n+ * approximately true when <i>p<\/i> is 128). A class with \"{@code Mix}\" in its\n+ * name uses a fairly strong mixing function with excellent avalanche\n+ * characteristics; a class with \"{@code StarStar}\" in its name uses a weaker\n+ * but faster mixing function.\n+ *\n+ * <p> The specific LXM algorithms used in this package are all chosen so that\n+ * the 64-bit values produced by the {@link RandomGenerator#nextLong nextLong()}\n+ * method are exactly equidistributed (for example, for any specific instance of\n+ * \"L64X128MixRandom\", over the course of its cycle each of the\n+ * 2<sup>64<\/sup> possible {@code long} values will be produced\n+ * 2<sup>128<\/sup>&minus;1 times). The values produced by the\n+ * {@link RandomGenerator#nextInt nextInt()},\n+ * {@link RandomGenerator#nextFloat nextFloat()}, and\n+ * {@link RandomGenerator#nextDouble nextDouble()} methods are likewise exactly\n+ * equidistributed. Some algorithms provide a further guarantee of\n+ * <i>k<\/i>-equidistribution for some <i>k<\/i> greater than 1, meaning that successive\n+ * non-overlapping <i>k<\/i>-tuples of 64-bit values produced by the\n+ * {@link RandomGenerator#nextLong nextLong()} method are exactly\n+ * equidistributed (equally likely to occur).\n+ *\n+ * <p> The following table gives the period, state size (in bits), parameter\n+ * size (in bits, including the low-order bit that is required always to be a\n+ * 1-bit), and equidistribution property for each of the specific LXM algorithms\n+ * used in this package.\n+ *\n+ * <table style=\"padding:0px 20px 0px 0px\">\n+ * <caption>Algorithm Properties<\/caption>\n+ * <thead>\n+ *   <tr><th style=\"text-align:left\">Implementation<\/th>\n+ *       <th style=\"text-align:right\">Period<\/th>\n+ *       <th style=\"text-align:right\">State size<\/th>\n+ *       <th style=\"text-align:right\">Parameter size<\/th>\n+ *       <th style=\"text-align:left\">{@link RandomGenerator#nextLong nextLong()} values are<\/th><\/tr>\n+ * <\/thead>\n+ * <tbody>\n+ *   <tr><td style=\"text-align:left\">\"L32X64MixRandom\"<\/td>\n+ *       <td style=\"text-align:right\">2<sup>32<\/sup>(2<sup>64<\/sup>&minus;1)<\/td>\n+ *       <td style=\"text-align:right\">96 bits<\/td>\n+ *       <td style=\"text-align:right\">32 bits<\/td>\n+ *       <td style=\"text-align:left\"><\/td><\/tr>\n+ *   <tr><td style=\"text-align:left\">\"L64X128StarStarRandom\"<\/td>\n+ *       <td style=\"text-align:right\">2<sup>64<\/sup>(2<sup>128<\/sup>&minus;1)<\/td>\n+ *       <td style=\"text-align:right\">192 bits<\/td>\n+ *       <td style=\"text-align:right\">64 bits<\/td>\n+ *       <td style=\"text-align:left\">2-equidistributed and exactly equidistributed<\/td><\/tr>\n+ *   <tr><td style=\"text-align:left\">\"L64X128MixRandom\"<\/td>\n+ *       <td style=\"text-align:right\">2<sup>64<\/sup>(2<sup>128<\/sup>&minus;1)<\/td>\n+ *       <td style=\"text-align:right\">192 bits<\/td>\n+ *       <td style=\"text-align:right\">64 bits<\/td>\n+ *       <td style=\"text-align:left\">2-equidistributed and exactly equidistributed<\/td><\/tr>\n+ *   <tr><td style=\"text-align:left\">\"L64X256MixRandom\"<\/td>\n+ *       <td style=\"text-align:right\">2<sup>64<\/sup>(2<sup>256<\/sup>&minus;1)<\/td>\n+ *       <td style=\"text-align:right\">320 bits<\/td>\n+ *       <td style=\"text-align:right\">64 bits<\/td>\n+ *       <td style=\"text-align:left\">4-equidistributed and exactly equidistributed<\/td><\/tr>\n+ *   <tr><td style=\"text-align:left\">\"L64X1024MixRandom\"<\/td>\n+ *       <td style=\"text-align:right\">2<sup>64<\/sup>(2<sup>1024<\/sup>&minus;1)<\/td>\n+ *       <td style=\"text-align:right\">1088 bits<\/td>\n+ *       <td style=\"text-align:right\">64 bits<\/td>\n+ *       <td style=\"text-align:left\">16-equidistributed and exactly equidistributed<\/td><\/tr>\n+ *   <tr><td style=\"text-align:left\">\"L128X128MixRandom\"<\/td>\n+ *       <td style=\"text-align:right\">2<sup>128<\/sup>(2<sup>128<\/sup>&minus;1)<\/td>\n+ *       <td style=\"text-align:right\">256 bits<\/td>\n+ *       <td style=\"text-align:right\">128 bits<\/td>\n+ *       <td style=\"text-align:left\">exactly equidistributed<\/td><\/tr>\n+ *   <tr><td style=\"text-align:left\">\"L128X256MixRandom\"<\/td>\n+ *       <td style=\"text-align:right\">2<sup>128<\/sup>(2<sup>256<\/sup>&minus;1)<\/td>\n+ *       <td style=\"text-align:right\">384 bits<\/td>\n+ *       <td style=\"text-align:right\">128 bits<\/td>\n+ *       <td style=\"text-align:left\">exactly equidistributed<\/td><\/tr>\n+ *   <tr><td style=\"text-align:left\">\"L128X1024MixRandom\"<\/td>\n+ *       <td style=\"text-align:right\">2<sup>128<\/sup>(2<sup>1024<\/sup>&minus;1)<\/td>\n+ *       <td style=\"text-align:right\">1152 bits<\/td>\n+ *       <td style=\"text-align:right\">128 bits<\/td>\n+ *       <td style=\"text-align:left\">exactly equidistributed<\/td><\/tr>\n+ * <\/tbody>\n+ * <\/table>\n+ *\n+ * For the algorithms listed above whose names begin with {@code L32}, the\n+ * 32-bit values produced by the {@link RandomGenerator#nextInt nextInt()}\n+ * method are exactly equidistributed, but the 64-bit values produced by the\n+ * {@link RandomGenerator#nextLong nextLong()} method are not exactly\n+ * equidistributed.\n+ *\n+ * <p> For the algorithms listed above whose names begin with {@code L64} or\n+ * {@code L128}, the 64-bit values produced by the\n+ * {@link RandomGenerator#nextLong nextLong()} method are <i>exactly\n+ * equidistributed<\/i>: every instance, over the course of its cycle, will\n+ * produce each of the 2<sup>64<\/sup> possible {@code long} values exactly the\n+ * same number of times. For example, any specific instance of\n+ * \"L64X256MixRandom\", over the course of its cycle each of the\n+ * 2<sup>64<\/sup> possible {@code long} values will be produced\n+ * 2<sup>256<\/sup>&minus;1 times. The values produced by the\n+ * {@link RandomGenerator#nextInt nextInt()},\n+ * {@link RandomGenerator#nextFloat nextFloat()}, and\n+ * {@link RandomGenerator#nextDouble nextDouble()} methods are likewise exactly\n+ * equidistributed.\n+ *\n+ * <p> In addition, for the algorithms listed above whose names begin with\n+ * {@code L64}, the 64-bit values produced by the\n+ * {@link RandomGenerator#nextLong nextLong()} method are\n+ * <i>k<\/i>-equidistributed (but not exactly <i>k<\/i>-equidistributed). To be\n+ * precise, and taking \"L64X256MixRandom\" as an example: for\n+ * any specific instance of \"L64X256MixRandom\", consider the\n+ * (overlapping) length-4 subsequences of the cycle of 64-bit values produced by\n+ * {@link RandomGenerator#nextLong nextLong()} (assuming no other methods are\n+ * called that would affect the state). There are\n+ * 2<sup>64<\/sup>(2<sup>256<\/sup>&minus;1) such subsequences, and each\n+ * subsequence, which consists of 4 64-bit values, can have one of\n+ * 2<sup>256<\/sup> values. Of those 2<sup>256<\/sup> subsequence values, nearly\n+ * all of them (2<sup>256<\/sup>%minus;2<sup>64<\/sup>) occur 2<sup>64<\/sup> times\n+ * over the course of the entire cycle, and the other 2<sup>64<\/sup> subsequence\n+ * values occur only 2<sup>64<\/sup>&minus;1 times. So the ratio of the\n+ * probability of getting any specific one of the less common subsequence values\n+ * and the probability of getting any specific one of the more common\n+ * subsequence values is 1&minus;2<sup>-64<\/sup>. (Note that the set of\n+ * 2<sup>64<\/sup> less-common subsequence values will differ from one instance\n+ * of \"L64X256MixRandom\" to another, as a function of the\n+ * additive parameter of the LCG.) The values produced by the\n+ * {@link RandomGenerator#nextInt nextInt()},\n+ * {@link RandomGenerator#nextFloat nextFloat()}, and\n+ * {@link RandomGenerator#nextDouble nextDouble()} methods are likewise\n+ * 4-equidistributed (but not exactly 4-equidistributed).\n+ *\n+ * <p> The next table gives the LCG multiplier value, the name of the specific\n+ * Xorshift algorithm used, the specific numeric parameters for that Xorshift\n+ * algorithm, and the mixing function for each of the specific LXM algorithms\n+ * used in this package. (Note that the multiplier used for the 128-bit LCG\n+ * cases is 65 bits wide, so the constant {@code 0x1d605bbb58c8abbfdL} shown in\n+ * the table cannot actually be used in code; instead, only the 64 low-order\n+ * bits {@code 0xd605bbb58c8abbfdL} are represented in the source code, and the\n+ * missing 1-bit is handled through special coding of the multiply-add algorithm\n+ * used in the LCG.)\n+ *\n+ * <table style=\"padding:0px 20px 0px 0px\">\n+ * <caption>LXM Multipliers<\/caption>\n+ * <thead>\n+ *   <tr><th style=\"text-align:left\">Implementation<\/th>\n+ *       <th style=\"text-align:right\">LCG multiplier {@code m}<\/th>\n+ *       <th style=\"text-align:left\">Xorshift algorithm<\/th>\n+ *       <th style=\"text-align:left\">Xorshift parameters<\/th>\n+ *       <th style=\"text-align:left\">Mixing function<\/th><\/tr>\n+ * <\/thead>\n+ * <tbody>\n+ *   <tr><td style=\"text-align:left\">\"L32X64MixRandom\"<\/td>\n+ *       <td style=\"text-align:right\">{@code 0xadb4a92d}<\/td>\n+ *       <td style=\"text-align:left\">{@code xoroshiro64}, version 1.0<\/td>\n+ *       <td style=\"text-align:left\">{@code (26, 9, 13)}<\/td>\n+ *       <td style=\"text-align:left\">mixLea32{@code (s+x0)}<\/td><\/tr>\n+ *   <tr><td style=\"text-align:left\">\"L64X128StarStarRandom\" <\/td>\n+ *       <td style=\"text-align:right\">{@code 0xd1342543de82ef95L}<\/td>\n+ *       <td style=\"text-align:left\">{@code xoroshiro128}, version 1.0<\/td>\n+ *       <td style=\"text-align:left\">{@code (24, 16, 37)}<\/td>\n+ *       <td style=\"text-align:left\">{@code Long.rotateLeft((s+x0)* 5, 7) * 9}<\/td><\/tr>\n+ *   <tr><td style=\"text-align:left\">\"L64X128MixRandom\"<\/td>\n+ *       <td style=\"text-align:right\">{@code 0xd1342543de82ef95L}<\/td>\n+ *       <td style=\"text-align:left\">{@code xoroshiro128}, version 1.0<\/td>\n+ *       <td style=\"text-align:left\">{@code (24, 16, 37)}<\/td>\n+ *       <td style=\"text-align:left\">mixLea32{@code (s+x0)}<\/td><\/tr>\n+ *   <tr><td style=\"text-align:left\">\"L64X256MixRandom\"<\/td>\n+ *       <td style=\"text-align:right\">{@code 0xd1342543de82ef95L}<\/td>\n+ *       <td style=\"text-align:left\">{@code xoshiro256}, version 1.0<\/td>\n+ *       <td style=\"text-align:left\">{@code (17, 45)}<\/td>\n+ *       <td style=\"text-align:left\">mixLea32{@code (s+x0)}<\/td><\/tr>\n+ *   <tr><td style=\"text-align:left\">\"L64X1024MixRandom\"<\/td>\n+ *       <td style=\"text-align:right\">{@code 0xd1342543de82ef95L}<\/td>\n+ *       <td style=\"text-align:left\">{@code xoroshiro1024}, version 1.0<\/td>\n+ *       <td style=\"text-align:left\">{@code (25, 27, 36)}<\/td>\n+ *       <td style=\"text-align:left\">mixLea32{@code (s+x0)}<\/td><\/tr>\n+ *   <tr><td style=\"text-align:left\">\"L128X128MixRandom\"<\/td>\n+ *       <td style=\"text-align:right\">{@code 0x1d605bbb58c8abbfdL}<\/td>\n+ *       <td style=\"text-align:left\">{@code xoroshiro128}, version 1.0<\/td>\n+ *       <td style=\"text-align:left\">{@code (24, 16, 37)}<\/td>\n+ *       <td style=\"text-align:left\">mixLea32{@code (sh+x0)}<\/td><\/tr>\n+ *   <tr><td style=\"text-align:left\">\"L128X256MixRandom\"<\/td>\n+ *       <td style=\"text-align:right\">{@code 0x1d605bbb58c8abbfdL}<\/td>\n+ *       <td style=\"text-align:left\">{@code xoshiro256}, version 1.0<\/td>\n+ *       <td style=\"text-align:left\">{@code (17, 45)}<\/td>\n+ *       <td style=\"text-align:left\">mixLea32{@code (sh+x0)}<\/td><\/tr>\n+ *   <tr><td style=\"text-align:left\">\"L128X1024MixRandom\"<\/td>\n+ *       <td style=\"text-align:right\">{@code 0x1d605bbb58c8abbfdL}<\/td>\n+ *       <td style=\"text-align:left\">{@code xoroshiro1024}, version 1.0<\/td>\n+ *       <td style=\"text-align:left\">{@code (25, 27, 36)}<\/td>\n+ *       <td style=\"text-align:left\">mixLea32{@code (sh+x0)}<\/td><\/tr>\n+ * <\/tbody>\n+ * <\/table>\n+ *\n+ * @since   17\n+ *\/\n+package java.util.random;\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/package-info.java","additions":628,"deletions":0,"binary":false,"changes":628,"status":"added"},{"patch":"@@ -0,0 +1,3075 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.util.random;\n+\n+import java.lang.annotation.*;\n+import java.math.BigInteger;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.DoubleConsumer;\n+import java.util.function.IntConsumer;\n+import java.util.function.LongConsumer;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGenerator.SplittableGenerator;\n+import java.util.Spliterator;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+\/**\n+ * Low-level utility methods helpful for implementing pseudorandom number\n+ * generators.\n+ *\n+ * <p> This class is mostly for library writers creating specific\n+ * implementations of the interface {@link RandomGenerator}. As an\n+ * internal package it is not intended for general use.\n+ *\n+ * @since 17\n+ * @hidden\n+ *\n+ *\/\n+public class RandomSupport {\n+    \/**\n+     * Annotation providing RandomGenerator properties.\n+     *\/\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.TYPE)\n+    public @interface RandomGeneratorProperties {\n+        \/**\n+         * Name of algorithm.\n+         *\/\n+        String name();\n+\n+        \/**\n+         * Category of algorithm.\n+         *\/\n+        String group() default \"Legacy\";\n+\n+        \/**\n+         * Algorithm period defined as:\n+         *\n+         * BigInteger.ONE.shiftLeft(i)\n+         *               .subtract(j)\n+         *               .shiftLeft(k)\n+         *\/\n+        int i() default 0;\n+        int j() default 0;\n+        int k() default 0;\n+\n+        \/**\n+         * The equidistribution of the algorithm.\n+         *\/\n+        int equidistribution() default Integer.MAX_VALUE;\n+\n+        \/**\n+         * Is the algorithm based on entropy (true random.)\n+         *\/\n+        boolean isStochastic() default false;\n+\n+        \/**\n+         * Is the algorithm assisted by hardware (fast true random.)\n+         *\/\n+        boolean isHardware() default false;\n+    }\n+\n+    \/*\n+     * Implementation Overview.\n+     *\n+     * This class provides utility methods and constants frequently\n+     * useful in the implementation of pseudorandom number generators\n+     * that satisfy the interface {@link RandomGenerator}.\n+     *\n+     * File organization: First some message strings, then the main\n+     * public methods, followed by a non-public base spliterator class.\n+     *\/\n+\n+    \/\/ IllegalArgumentException messages\n+    public static final String BAD_SIZE = \"size must be non-negative\";\n+    public static final String BAD_DISTANCE = \"jump distance must be finite, positive, and an exact integer\";\n+    public static final String BAD_BOUND = \"bound must be positive\";\n+    public static final String BAD_FLOATING_BOUND = \"bound must be finite and positive\";\n+    public static final String BAD_RANGE = \"bound must be greater than origin\";\n+\n+    \/* ---------------- explicit constructor ---------------- *\/\n+\n+    \/**\n+     * Explicit constructor.\n+     *\/\n+    protected RandomSupport() {\n+    }\n+\n+    \/* ---------------- public methods ---------------- *\/\n+\n+    \/**\n+     * Check a {@code long} proposed stream size for validity.\n+     *\n+     * @param streamSize the proposed stream size\n+     *\n+     * @throws IllegalArgumentException if {@code streamSize} is negative\n+     *\/\n+    public static void checkStreamSize(long streamSize) {\n+        if (streamSize < 0L) {\n+            throw new IllegalArgumentException(BAD_SIZE);\n+        }\n+    }\n+\n+    \/**\n+     * Checks a {@code float} upper bound value for validity.\n+     *\n+     * @param bound the upper bound (exclusive)\n+     *\n+     * @throws IllegalArgumentException if {@code bound} fails to be positive and finite\n+     *\/\n+    public static void checkBound(float bound) {\n+        if (!(bound > 0.0 && bound < Float.POSITIVE_INFINITY)) {\n+            throw new IllegalArgumentException(BAD_FLOATING_BOUND);\n+        }\n+    }\n+\n+    \/**\n+     * Checks a {@code double} upper bound value for validity.\n+     *\n+     * @param bound the upper bound (exclusive)\n+     *\n+     * @throws IllegalArgumentException if {@code bound} fails to be positive and finite\n+     *\/\n+    public static void checkBound(double bound) {\n+        if (!(bound > 0.0 && bound < Double.POSITIVE_INFINITY)) {\n+            throw new IllegalArgumentException(BAD_FLOATING_BOUND);\n+        }\n+    }\n+\n+    \/**\n+     * Checks an {@code int} upper bound value for validity.\n+     *\n+     * @param bound the upper bound (exclusive)\n+     *\n+     * @throws IllegalArgumentException if {@code bound} is not positive\n+     *\/\n+    public static void checkBound(int bound) {\n+        if (bound <= 0) {\n+            throw new IllegalArgumentException(BAD_BOUND);\n+        }\n+    }\n+\n+    \/**\n+     * Checks a {@code long} upper bound value for validity.\n+     *\n+     * @param bound the upper bound (exclusive)\n+     *\n+     * @throws IllegalArgumentException if {@code bound} is not positive\n+     *\/\n+    public static void checkBound(long bound) {\n+        if (bound <= 0) {\n+            throw new IllegalArgumentException(BAD_BOUND);\n+        }\n+    }\n+\n+    \/**\n+     * Checks a {@code float} range for validity.\n+     *\n+     * @param origin the least value (inclusive) in the range\n+     * @param bound  the upper bound (exclusive) of the range\n+     *\n+     * @throws IllegalArgumentException if {@code origin} is not finite, {@code bound} is not finite,\n+     *                                  or {@code bound - origin} is not finite\n+     *\/\n+    public static void checkRange(float origin, float bound) {\n+        if (!(origin < bound && (bound - origin) < Float.POSITIVE_INFINITY)) {\n+            throw new IllegalArgumentException(BAD_RANGE);\n+        }\n+    }\n+\n+    \/**\n+     * Checks a {@code double} range for validity.\n+     *\n+     * @param origin the least value (inclusive) in the range\n+     * @param bound  the upper bound (exclusive) of the range\n+     *\n+     * @throws IllegalArgumentException if {@code origin} is not finite, {@code bound} is not finite,\n+     *                                  or {@code bound - origin} is not finite\n+     *\/\n+    public static void checkRange(double origin, double bound) {\n+        if (!(origin < bound && (bound - origin) < Double.POSITIVE_INFINITY)) {\n+            throw new IllegalArgumentException(BAD_RANGE);\n+        }\n+    }\n+\n+    \/**\n+     * Checks an {@code int} range for validity.\n+     *\n+     * @param origin the least value that can be returned\n+     * @param bound  the upper bound (exclusive) for the returned value\n+     *\n+     * @throws IllegalArgumentException if {@code origin} is greater than or equal to {@code bound}\n+     *\/\n+    public static void checkRange(int origin, int bound) {\n+        if (origin >= bound) {\n+            throw new IllegalArgumentException(BAD_RANGE);\n+        }\n+    }\n+\n+    \/**\n+     * Checks a {@code long} range for validity.\n+     *\n+     * @param origin the least value that can be returned\n+     * @param bound  the upper bound (exclusive) for the returned value\n+     *\n+     * @throws IllegalArgumentException if {@code origin} is greater than or equal to {@code bound}\n+     *\/\n+    public static void checkRange(long origin, long bound) {\n+        if (origin >= bound) {\n+            throw new IllegalArgumentException(BAD_RANGE);\n+        }\n+    }\n+\n+    \/**\n+     * Given an array of seed bytes of any length, construct an array of\n+     * {@code long} seed values of length {@code n}, such that the last\n+     * {@code z} values are not all zero.\n+     *\n+     * @param seed an array of {@code byte} values\n+     * @param n the length of the result array (should be nonnegative)\n+     * @param z the number of trailing result elements that are required\n+     *        to be not all zero (should be nonnegative but not larger\n+     *        than {@code n})\n+     *\n+     * @return an array of length {@code n} containing {@code long} seed values\n+     *\/\n+    public static long[] convertSeedBytesToLongs(byte[] seed, int n, int z) {\n+        final long[] result = new long[n];\n+        final int m = Math.min(seed.length, n << 3);\n+        \/\/ Distribute seed bytes into the words to be formed.\n+        for (int j = 0; j < m; j++) {\n+            result[j>>3] = (result[j>>3] << 8) | seed[j];\n+        }\n+        \/\/ If there aren't enough seed bytes for all the words we need,\n+        \/\/ use a SplitMix-style PRNG to fill in the rest.\n+        long v = result[0];\n+        for (int j = (m + 7) >> 3; j < n; j++) {\n+            result[j] = mixMurmur64(v += SILVER_RATIO_64);\n+        }\n+        \/\/ Finally, we need to make sure the last z words are not all zero.\n+        search: {\n+            for (int j = n - z; j < n; j++) {\n+                if (result[j] != 0) break search;\n+            }\n+            \/\/ If they are, fill in using a SplitMix-style PRNG.\n+            \/\/ Using \"& ~1L\" in the next line defends against the case z==1\n+            \/\/ by guaranteeing that the first generated value will be nonzero.\n+            long w = result[0] & ~1L;\n+            for (int j = n - z; j < n; j++) {\n+                result[j] = mixMurmur64(w += SILVER_RATIO_64);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    \/**\n+     * Given an array of seed bytes of any length, construct an array of\n+     * {@code int} seed values of length {@code n}, such that the last {@code z}\n+     * values are not all zero.\n+     *\n+     * @param seed an array of {@code byte} values\n+     * @param n the length of the result array (should be nonnegative)\n+     * @param z the number of trailing result elements that are required\n+     *        to be not all zero (should be nonnegative but not larger\n+     *        than {@code n})\n+     *\n+     * @return an array of length {@code n} containing {@code int} seed values\n+     *\/\n+    public static int[] convertSeedBytesToInts(byte[] seed, int n, int z) {\n+        final int[] result = new int[n];\n+        final int m = Math.min(seed.length, n << 2);\n+        \/\/ Distribute seed bytes into the words to be formed.\n+        for (int j = 0; j < m; j++) {\n+            result[j>>2] = (result[j>>2] << 8) | seed[j];\n+        }\n+        \/\/ If there aren't enough seed bytes for all the words we need,\n+        \/\/ use a SplitMix-style PRNG to fill in the rest.\n+        int v = result[0];\n+        for (int j = (m + 3) >> 2; j < n; j++) {\n+            result[j] = mixMurmur32(v += SILVER_RATIO_32);\n+        }\n+        \/\/ Finally, we need to make sure the last z words are not all zero.\n+        search: {\n+            for (int j = n - z; j < n; j++) {\n+                if (result[j] != 0) break search;\n+            }\n+            \/\/ If they are, fill in using a SplitMix-style PRNG.\n+            \/\/ Using \"& ~1\" in the next line defends against the case z==1\n+            \/\/ by guaranteeing that the first generated value will be nonzero.\n+            int w = result[0] & ~1;\n+            for (int j = n - z; j < n; j++) {\n+                result[j] = mixMurmur32(w += SILVER_RATIO_32);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    \/*\n+     * Bounded versions of nextX methods used by streams, as well as\n+     * the public nextX(origin, bound) methods.  These exist mainly to\n+     * avoid the need for multiple versions of stream spliterators\n+     * across the different exported forms of streams.\n+     *\/\n+\n+    \/**\n+     * This is the form of {@link RandomGenerator#nextLong() nextLong}() used by\n+     * a {@link LongStream} {@link Spliterator} and by the public method\n+     * {@link RandomGenerator#nextLong(long, long) nextLong}(origin, bound). If\n+     * {@code origin} is greater than {@code bound}, then this method simply\n+     * calls the unbounded version of\n+     * {@link RandomGenerator#nextLong() nextLong}(), choosing pseudorandomly\n+     * from among all 2<sup>64<\/sup> possible {@code long} values}, and\n+     * otherwise uses one or more calls to\n+     * {@link RandomGenerator#nextLong() nextLong}() to choose a value\n+     * pseudorandomly from the possible values between {@code origin}\n+     * (inclusive) and {@code bound} (exclusive).\n+     *\n+     * @implNote This method first calls {@code nextLong()} to obtain\n+     * a {@code long} value that is assumed to be pseudorandomly\n+     * chosen uniformly and independently from the 2<sup>64<\/sup>\n+     * possible {@code long} values (that is, each of the 2<sup>64<\/sup>\n+     * possible long values is equally likely to be chosen).\n+     * Under some circumstances (when the specified range is not\n+     * a power of 2), {@code nextLong()} may be called additional times\n+     * to ensure that that the values in the specified range are\n+     * equally likely to be chosen (provided the assumption holds).\n+     *\n+     * The implementation considers four cases:\n+     * <ol>\n+     *\n+     * <li> If the {@code} bound} is less than or equal to the {@code origin}\n+     * (indicated an unbounded form), the 64-bit {@code long} value obtained\n+     * from {@link RandomGenerator#nextLong() nextLong}() is returned directly.\n+     * <\/li>\n+     *\n+     * <li> Otherwise, if the length <i>n<\/i> of the specified range is an\n+     * exact power of two 2<sup><i>m<\/i><\/sup> for some integer\n+     *      <i>m<\/i>, then return the sum of {@code origin} and the\n+     *      <i>m<\/i> lowest-order bits of the value from {@code nextLong()}.\n+     * <\/li>\n+     *\n+     * <li> Otherwise, if the length <i>n<\/i> of the specified range\n+     * is less than 2<sup>63<\/sup>, then the basic idea is to use the remainder\n+     * modulo <i>n<\/i> of the value from\n+     * {@link RandomGenerator#nextLong() nextLong}(), but with this approach\n+     * some values will be over-represented. Therefore a loop is used to avoid\n+     * potential bias by rejecting candidates that are too large. Assuming that\n+     * the results from {@link RandomGenerator#nextLong() nextLong}() are truly\n+     * chosen uniformly and independently, the expected number of iterations\n+     * will be somewhere between 1 and 2, depending on the precise value of\n+     * <i>n<\/i>.<\/li>\n+     *\n+     * <li> Otherwise, the length <i>n<\/i> of the specified range\n+     * cannot be represented as a positive {@code long} value. A loop repeatedly\n+     * calls {@link RandomGenerator#nextLong() nextLong}() until obtaining a\n+     * suitable candidate, Again, the expected number of iterations is less than\n+     * 2.<\/li>\n+     *\n+     * <\/ol>\n+     *\n+     * @param rng a random number generator to be used as a\n+     *        source of pseudorandom {@code long} values\n+     * @param origin the least value that can be produced,\n+     *        unless greater than or equal to {@code bound}\n+     * @param bound the upper bound (exclusive), unless {@code origin}\n+     *        is greater than or equal to {@code bound}\n+     *\n+     * @return a pseudorandomly chosen {@code long} value,\n+     *         which will be between {@code origin} (inclusive) and\n+     *         {@code bound} exclusive unless {@code origin}\n+     *         is greater than or equal to {@code bound}\n+     *\/\n+    public static long boundedNextLong(RandomGenerator rng, long origin, long bound) {\n+        long r = rng.nextLong();\n+        if (origin < bound) {\n+            \/\/ It's not case (1).\n+            final long n = bound - origin;\n+            final long m = n - 1;\n+            if ((n & m) == 0L) {\n+                \/\/ It is case (2): length of range is a power of 2.\n+                r = (r & m) + origin;\n+            } else if (n > 0L) {\n+                \/\/ It is case (3): need to reject over-represented candidates.\n+                \/* This loop takes an unlovable form (but it works):\n+                   because the first candidate is already available,\n+                   we need a break-in-the-middle construction,\n+                   which is concisely but cryptically performed\n+                   within the while-condition of a body-less for loop. *\/\n+                for (long u = r >>> 1;            \/\/ ensure nonnegative\n+                     u + m - (r = u % n) < 0L;    \/\/ rejection check\n+                     u = rng.nextLong() >>> 1) \/\/ retry\n+                    ;\n+                r += origin;\n+            }\n+            else {\n+                \/\/ It is case (4): length of range not representable as long.\n+                while (r < origin || r >= bound)\n+                    r = rng.nextLong();\n+            }\n+        }\n+        return r;\n+    }\n+\n+    \/**\n+     * This is the form of {@link RandomGenerator#nextLong() nextLong}() used by\n+     * the public method {@link RandomGenerator#nextLong(long) nextLong}(bound).\n+     * This is essentially a version of\n+     * {@link RandomSupport#boundedNextLong(RandomGenerator, long, long) boundedNextLong}(rng, origin, bound)\n+     * that has been specialized for the case where the {@code origin} is zero\n+     * and the {@code bound} is greater than zero. The value returned is chosen\n+     * pseudorandomly from nonnegative integer values less than {@code bound}.\n+     *\n+     * @implNote This method first calls {@code nextLong()} to obtain\n+     * a {@code long} value that is assumed to be pseudorandomly\n+     * chosen uniformly and independently from the 2<sup>64<\/sup>\n+     * possible {@code long} values (that is, each of the 2<sup>64<\/sup>\n+     * possible long values is equally likely to be chosen).\n+     * Under some circumstances (when the specified range is not\n+     * a power of 2), {@code nextLong()} may be called additional times\n+     * to ensure that that the values in the specified range are\n+     * equally likely to be chosen (provided the assumption holds).\n+     *\n+     * The implementation considers two cases:\n+     * <ol>\n+     *\n+     * <li> If {@code bound} is an exact power of two 2<sup><i>m<\/i><\/sup>\n+     * for some integer <i>m<\/i>, then return the sum of {@code origin} and the\n+     * <i>m<\/i> lowest-order bits of the value from\n+     * {@link RandomGenerator#nextLong() nextLong}().<\/li>\n+     *\n+     * <li> Otherwise, the basic idea is to use the remainder modulo\n+     *      <i>bound<\/i> of the value from {@code nextLong()},\n+     * but with this approach some values will be over-represented. Therefore a\n+     * loop is used to avoid potential bias by rejecting candidates that vare\n+     * too large. Assuming that the results from\n+     * {@link RandomGenerator#nextLong() nextLong}() are truly chosen uniformly\n+     * and independently, the expected number of iterations will be somewhere\n+     * between 1 and 2, depending on the precise value of <i>bound<\/i>.<\/li>\n+     *\n+     * <\/ol>\n+     *\n+     * @param rng a random number generator to be used as a\n+     *        source of pseudorandom {@code long} values\n+     * @param bound the upper bound (exclusive); must be greater than zero\n+     *\n+     * @return a pseudorandomly chosen {@code long} value\n+     *\/\n+    public static long boundedNextLong(RandomGenerator rng, long bound) {\n+        \/\/ Specialize boundedNextLong for origin == 0, bound > 0\n+        final long m = bound - 1;\n+        long r = rng.nextLong();\n+        if ((bound & m) == 0L) {\n+            \/\/ The bound is a power of 2.\n+            r &= m;\n+        } else {\n+            \/\/ Must reject over-represented candidates\n+            \/* This loop takes an unlovable form (but it works):\n+               because the first candidate is already available,\n+               we need a break-in-the-middle construction,\n+               which is concisely but cryptically performed\n+               within the while-condition of a body-less for loop. *\/\n+            for (long u = r >>> 1;\n+                 u + m - (r = u % bound) < 0L;\n+                 u = rng.nextLong() >>> 1)\n+                ;\n+        }\n+        return r;\n+    }\n+\n+    \/**\n+     * This is the form of {@link RandomGenerator#nextInt() nextInt}() used by\n+     * an {@link IntStream} {@link Spliterator} and by the public method\n+     * {@link RandomGenerator#nextInt(int, int) nextInt}(origin, bound). If\n+     * {@code origin} is greater than {@code bound}, then this method simply\n+     * calls the unbounded version of\n+     * {@link RandomGenerator#nextInt() nextInt}(), choosing pseudorandomly\n+     * from among all 2<sup>64<\/sup> possible {@code int} values}, and otherwise\n+     * uses one or more calls to {@link RandomGenerator#nextInt() nextInt}() to\n+     * choose a value pseudorandomly from the possible values between\n+     * {@code origin} (inclusive) and {@code bound} (exclusive).\n+     *\n+     * @param rng a random number generator to be used as a\n+     *        source of pseudorandom {@code int} values\n+     * @param origin the least value that can be produced,\n+     *        unless greater than or equal to {@code bound}\n+     * @param bound the upper bound (exclusive), unless {@code origin}\n+     *        is greater than or equal to {@code bound}\n+     *\n+     * @return a pseudorandomly chosen {@code int} value,\n+     *         which will be between {@code origin} (inclusive) and\n+     *         {@code bound} exclusive unless {@code origin}\n+     *         is greater than or equal to {@code bound}\n+     *\n+     * @implNote The implementation of this method is identical to\n+     *           the implementation of {@code nextLong(origin, bound)}\n+     *           except that {@code int} values and the {@code nextInt()}\n+     *           method are used rather than {@code long} values and the\n+     *           {@code nextLong()} method.\n+     *\/\n+    public static int boundedNextInt(RandomGenerator rng, int origin, int bound) {\n+        int r = rng.nextInt();\n+        if (origin < bound) {\n+            \/\/ It's not case (1).\n+            final int n = bound - origin;\n+            final int m = n - 1;\n+            if ((n & m) == 0) {\n+                \/\/ It is case (2): length of range is a power of 2.\n+                r = (r & m) + origin;\n+            } else if (n > 0) {\n+                \/\/ It is case (3): need to reject over-represented candidates.\n+                for (int u = r >>> 1;\n+                     u + m - (r = u % n) < 0;\n+                     u = rng.nextInt() >>> 1)\n+                    ;\n+                r += origin;\n+            }\n+            else {\n+                \/\/ It is case (4): length of range not representable as long.\n+                while (r < origin || r >= bound) {\n+                    r = rng.nextInt();\n+                }\n+            }\n+        }\n+        return r;\n+    }\n+\n+    \/**\n+     * This is the form of {@link RandomGenerator#nextInt() nextInt}() used by\n+     * the public method {@link RandomGenerator#nextInt(int) nextInt}(bound).\n+     * This is essentially a version of\n+     * {@link RandomSupport#boundedNextInt(RandomGenerator, int, int) boundedNextInt}(rng, origin, bound)\n+     * that has been specialized for the case where the {@code origin} is zero\n+     * and the {@code bound} is greater than zero. The value returned is chosen\n+     * pseudorandomly from nonnegative integer values less than {@code bound}.\n+     *\n+     * @param rng a random number generator to be used as a\n+     *        source of pseudorandom {@code long} values\n+     * @param bound the upper bound (exclusive); must be greater than zero\n+     *\n+     * @return a pseudorandomly chosen {@code long} value\n+     *\n+     * @implNote The implementation of this method is identical to\n+     *           the implementation of {@code nextLong(bound)}\n+     *           except that {@code int} values and the {@code nextInt()}\n+     *           method are used rather than {@code long} values and the\n+     *           {@code nextLong()} method.\n+     *\/\n+    public static int boundedNextInt(RandomGenerator rng, int bound) {\n+        \/\/ Specialize boundedNextInt for origin == 0, bound > 0\n+        final int m = bound - 1;\n+        int r = rng.nextInt();\n+        if ((bound & m) == 0) {\n+            \/\/ The bound is a power of 2.\n+            r &= m;\n+        } else {\n+            \/\/ Must reject over-represented candidates\n+            for (int u = r >>> 1;\n+                 u + m - (r = u % bound) < 0;\n+                 u = rng.nextInt() >>> 1)\n+                ;\n+        }\n+        return r;\n+    }\n+\n+    \/**\n+     * This is the form of {@link RandomGenerator#nextDouble() nextDouble}()\n+     * used by a {@link DoubleStream} {@link Spliterator} and by the public\n+     * method\n+     * {@link RandomGenerator#nextDouble(double, double) nextDouble}(origin, bound).\n+     * If {@code origin} is greater than {@code bound}, then this method simply\n+     * calls the unbounded version of\n+     * {@link RandomGenerator#nextDouble() nextDouble}(), and otherwise scales\n+     * and translates the result of a call to\n+     * {@link RandomGenerator#nextDouble() nextDouble}() so that it lies between\n+     * {@code origin} (inclusive) and {@code bound} (exclusive).\n+     *\n+     * @implNote The implementation considers two cases:\n+     * <ol>\n+     *\n+     * <li> If the {@code bound} is less than or equal to the {@code origin}\n+     * (indicated an unbounded form), the 64-bit {@code double} value obtained\n+     * from {@link RandomGenerator#nextDouble() nextDouble}() is returned\n+     * directly.\n+     *\n+     * <li> Otherwise, the result of a call to {@code nextDouble} is\n+     * multiplied by {@code (bound - origin)}, then {@code origin} is added, and\n+     * then if this this result is not less than {@code bound} (which can\n+     * sometimes occur because of rounding), it is replaced with the largest\n+     * {@code double} value that is less than {@code bound}.\n+     *\n+     * <\/ol>\n+     *\n+     * @param rng a random number generator to be used as a\n+     *        source of pseudorandom {@code double} values\n+     * @param origin the least value that can be produced,\n+     *        unless greater than or equal to {@code bound}; must be finite\n+     * @param bound the upper bound (exclusive), unless {@code origin}\n+     *        is greater than or equal to {@code bound}; must be finite\n+     * @return a pseudorandomly chosen {@code double} value,\n+     *         which will be between {@code origin} (inclusive) and\n+     *         {@code bound} exclusive unless {@code origin}\n+     *         is greater than or equal to {@code bound},\n+     *         in which case it will be between 0.0 (inclusive)\n+     *         and 1.0 (exclusive)\n+     *\/\n+    public static double boundedNextDouble(RandomGenerator rng, double origin, double bound) {\n+        double r = rng.nextDouble();\n+        if (origin < bound) {\n+            r = r * (bound - origin) + origin;\n+            if (r >= bound)  \/\/ may need to correct a rounding problem\n+                r = Double.longBitsToDouble(Double.doubleToLongBits(bound) - 1);\n+        }\n+        return r;\n+    }\n+\n+    \/**\n+     * This is the form of {@link RandomGenerator#nextDouble() nextDouble}()\n+     * used by the public method\n+     * {@link RandomGenerator#nextDouble(double) nextDouble}(bound). This is\n+     * essentially a version of\n+     * {@link RandomSupport#boundedNextDouble(RandomGenerator, double, double) boundedNextDouble}(rng, origin, bound)\n+     * that has been specialized for the case where the {@code origin} is zero\n+     * and the {@code bound} is greater than zero.\n+     *\n+     * @implNote The result of a call to {@code nextDouble} is\n+     *      multiplied by {@code bound}, and then if this result is\n+     *      not less than {@code bound} (which can sometimes occur\n+     *      because of rounding), it is replaced with the largest\n+     *      {@code double} value that is less than {@code bound}.\n+     *\n+     * @param rng a random number generator to be used as a\n+     *        source of pseudorandom {@code double} values\n+     * @param bound the upper bound (exclusive); must be finite and\n+     *        greater than zero\n+     * @return a pseudorandomly chosen {@code double} value\n+     *         between zero (inclusive) and {@code bound} (exclusive)\n+     *\/\n+    public static double boundedNextDouble(RandomGenerator rng, double bound) {\n+        \/\/ Specialize boundedNextDouble for origin == 0, bound > 0\n+        double r = rng.nextDouble();\n+        r = r * bound;\n+        if (r >= bound)  \/\/ may need to correct a rounding problem\n+            r = Double.longBitsToDouble(Double.doubleToLongBits(bound) - 1);\n+        return r;\n+    }\n+\n+    \/**\n+     * This is the form of {@link RandomGenerator#nextFloat() nextFloat}() used\n+     * by a {@link Stream<Float>} {@link Spliterator} (if there were any) and by\n+     * the public method\n+     * {@link RandomGenerator#nextFloat(float, float) nextFloat}(origin, bound).\n+     * If {@code origin} is greater than {@code bound}, then this method simply\n+     * calls the unbounded version of\n+     * {@link RandomGenerator#nextFloat() nextFloat}(), and otherwise scales and\n+     * translates the result of a call to\n+     * {@link RandomGenerator#nextFloat() nextFloat}() so that it lies between\n+     * {@code origin} (inclusive) and {@code bound} (exclusive).\n+     *\n+     * @implNote The implementation of this method is identical to\n+     *     the implementation of {@code nextDouble(origin, bound)}\n+     *     except that {@code float} values and the {@code nextFloat()}\n+     *     method are used rather than {@code double} values and the\n+     *     {@code nextDouble()} method.\n+     *\n+     * @param rng a random number generator to be used as a\n+     *        source of pseudorandom {@code float} values\n+     * @param origin the least value that can be produced,\n+     *        unless greater than or equal to {@code bound}; must be finite\n+     * @param bound the upper bound (exclusive), unless {@code origin}\n+     *        is greater than or equal to {@code bound}; must be finite\n+     * @return a pseudorandomly chosen {@code float} value,\n+     *         which will be between {@code origin} (inclusive) and\n+     *         {@code bound} exclusive unless {@code origin}\n+     *         is greater than or equal to {@code bound},\n+     *         in which case it will be between 0.0 (inclusive)\n+     *         and 1.0 (exclusive)\n+     *\/\n+    public static float boundedNextFloat(RandomGenerator rng, float origin, float bound) {\n+        float r = rng.nextFloat();\n+        if (origin < bound) {\n+            r = r * (bound - origin) + origin;\n+            if (r >= bound) \/\/ may need to correct a rounding problem\n+                r = Float.intBitsToFloat(Float.floatToIntBits(bound) - 1);\n+        }\n+        return r;\n+    }\n+\n+    \/**\n+     * This is the form of {@link RandomGenerator#nextFloat() nextFloat}() used\n+     * by the public method\n+     * {@link RandomGenerator#nextFloat(float) nextFloat}(bound). This is\n+     * essentially a version of\n+     * {@link RandomSupport#boundedNextFloat(RandomGenerator, float, float) boundedNextFloat}(rng, origin, bound)\n+     * that has been specialized for the case where the {@code origin} is zero\n+     * and the {@code bound} is greater than zero.\n+     *\n+     * @implNote The implementation of this method is identical to\n+     *     the implementation of {@code nextDouble(bound)}\n+     *     except that {@code float} values and the {@code nextFloat()}\n+     *     method are used rather than {@code double} values and the\n+     *     {@code nextDouble()} method.\n+     *\n+     * @param rng a random number generator to be used as a\n+     *        source of pseudorandom {@code float} values\n+     * @param bound the upper bound (exclusive); must be finite and\n+     *        greater than zero\n+     * @return a pseudorandomly chosen {@code float} value\n+     *         between zero (inclusive) and {@code bound} (exclusive)\n+     *\/\n+    public static float boundedNextFloat(RandomGenerator rng, float bound) {\n+        \/\/ Specialize boundedNextFloat for origin == 0, bound > 0\n+        float r = rng.nextFloat();\n+        r = r * bound;\n+        if (r >= bound) \/\/ may need to correct a rounding problem\n+            r = Float.intBitsToFloat(Float.floatToIntBits(bound) - 1);\n+        return r;\n+    }\n+\n+    \/\/ The following decides which of two strategies initialSeed() will use.\n+    private static boolean secureRandomSeedRequested() {\n+        String pp = java.security.AccessController.doPrivileged(\n+                new sun.security.action.GetPropertyAction(\n+                        \"java.util.secureRandomSeed\"));\n+        return (pp != null && pp.equalsIgnoreCase(\"true\"));\n+    }\n+\n+    private static final boolean useSecureRandomSeed = secureRandomSeedRequested();\n+\n+    \/**\n+     * Returns a {@code long} value (chosen from some machine-dependent entropy\n+     * source) that may be useful for initializing a source of seed values for\n+     * instances of {@link RandomGenerator} created by zero-argument\n+     * constructors. (This method should\n+     * <i>not<\/i> be called repeatedly, once per constructed\n+     * object; at most it should be called once per class.)\n+     *\n+     * @return a {@code long} value, randomly chosen using\n+     *         appropriate environmental entropy\n+     *\/\n+    public static long initialSeed() {\n+        if (useSecureRandomSeed) {\n+            byte[] seedBytes = java.security.SecureRandom.getSeed(8);\n+            long s = (long)(seedBytes[0]) & 0xffL;\n+            for (int i = 1; i < 8; ++i)\n+                s = (s << 8) | ((long)(seedBytes[i]) & 0xffL);\n+            return s;\n+        }\n+        return (mixStafford13(System.currentTimeMillis()) ^\n+                mixStafford13(System.nanoTime()));\n+    }\n+\n+    \/**\n+     * The first 32 bits of the golden ratio (1+sqrt(5))\/2, forced to be odd.\n+     * Useful for producing good Weyl sequences or as an arbitrary nonzero odd\n+     * value.\n+     *\/\n+    public static final int  GOLDEN_RATIO_32 = 0x9e3779b9;\n+\n+    \/**\n+     * The first 64 bits of the golden ratio (1+sqrt(5))\/2, forced to be odd.\n+     * Useful for producing good Weyl sequences or as an arbitrary nonzero odd\n+     * value.\n+     *\/\n+    public static final long GOLDEN_RATIO_64 = 0x9e3779b97f4a7c15L;\n+\n+    \/**\n+     * The first 32 bits of the silver ratio 1+sqrt(2), forced to be odd. Useful\n+     * for producing good Weyl sequences or as an arbitrary nonzero odd value.\n+     *\/\n+    public static final int  SILVER_RATIO_32 = 0x6A09E667;\n+\n+    \/**\n+     * The first 64 bits of the silver ratio 1+sqrt(2), forced to be odd. Useful\n+     * for producing good Weyl sequences or as an arbitrary nonzero odd value.\n+     *\/\n+    public static final long SILVER_RATIO_64 = 0x6A09E667F3BCC909L;\n+\n+    \/**\n+     * Computes the 64-bit mixing function for MurmurHash3. This is a 64-bit\n+     * hashing function with excellent avalanche statistics.\n+     * https:\/\/github.com\/aappleby\/smhasher\/wiki\/MurmurHash3\n+     *\n+     * <p> Note that if the argument {@code z} is 0, the result is 0.\n+     *\n+     * @param z any long value\n+     *\n+     * @return the result of hashing z\n+     *\/\n+    public static long mixMurmur64(long z) {\n+        z = (z ^ (z >>> 33)) * 0xff51afd7ed558ccdL;\n+        z = (z ^ (z >>> 33)) * 0xc4ceb9fe1a85ec53L;\n+        return z ^ (z >>> 33);\n+    }\n+\n+    \/**\n+     * Computes Stafford variant 13 of the 64-bit mixing function for\n+     * MurmurHash3. This is a 64-bit hashing function with excellent avalanche\n+     * statistics.\n+     * http:\/\/zimbry.blogspot.com\/2011\/09\/better-bit-mixing-improving-on.html\n+     *\n+     * <p> Note that if the argument {@code z} is 0, the result is 0.\n+     *\n+     * @param z any long value\n+     *\n+     * @return the result of hashing z\n+     *\/\n+    public static long mixStafford13(long z) {\n+        z = (z ^ (z >>> 30)) * 0xbf58476d1ce4e5b9L;\n+        z = (z ^ (z >>> 27)) * 0x94d049bb133111ebL;\n+        return z ^ (z >>> 31);\n+    }\n+\n+    \/**\n+     * Computes Doug Lea's 64-bit mixing function. This is a 64-bit hashing\n+     * function with excellent avalanche statistics. It has the advantages of\n+     * using the same multiplicative constant twice and of using only 32-bit\n+     * shifts.\n+     *\n+     * <p> Note that if the argument {@code z} is 0, the result is 0.\n+     *\n+     * @param z any long value\n+     *\n+     * @return the result of hashing z\n+     *\/\n+    public static long mixLea64(long z) {\n+        z = (z ^ (z >>> 32)) * 0xdaba0b6eb09322e3L;\n+        z = (z ^ (z >>> 32)) * 0xdaba0b6eb09322e3L;\n+        return z ^ (z >>> 32);\n+    }\n+\n+    \/**\n+     * Computes the 32-bit mixing function for MurmurHash3. This is a 32-bit\n+     * hashing function with excellent avalanche statistics.\n+     * https:\/\/github.com\/aappleby\/smhasher\/wiki\/MurmurHash3\n+     *\n+     * <p> Note that if the argument {@code z} is 0, the result is 0.\n+     *\n+     * @param z any long value\n+     *\n+     * @return the result of hashing z\n+     *\/\n+    public static int mixMurmur32(int z) {\n+        z = (z ^ (z >>> 16)) * 0x85ebca6b;\n+        z = (z ^ (z >>> 13)) * 0xc2b2ae35;\n+        return z ^ (z >>> 16);\n+    }\n+\n+    \/**\n+     * Computes Doug Lea's 32-bit mixing function. This is a 32-bit hashing\n+     * function with excellent avalanche statistics. It has the advantages of\n+     * using the same multiplicative constant twice and of using only 16-bit\n+     * shifts.\n+     *\n+     * <p> Note that if the argument {@code z} is 0, the result is 0.\n+     *\n+     * @param z any long value\n+     *\n+     * @return the result of hashing z\n+     *\/\n+    public static int mixLea32(int z) {\n+        z = (z ^ (z >>> 16)) * 0xd36d884b;\n+        z = (z ^ (z >>> 16)) * 0xd36d884b;\n+        return z ^ (z >>> 16);\n+    }\n+\n+    \/\/ Non-public (package only) support for spliterators needed by AbstractSplittableGenerator\n+    \/\/ and AbstractArbitrarilyJumpableGenerator and AbstractSharedGenerator\n+\n+    \/**\n+     * Base class for making Spliterator classes for streams of randomly chosen\n+     * values.\n+     *\/\n+    public abstract static class RandomSpliterator {\n+\n+        \/** low range value *\/\n+       public long index;\n+\n+       \/** high range value *\/\n+       public final long fence;\n+\n+       \/** Constructor\n+        *\n+        * @param index  low range value\n+        * @param fence  high range value\n+        *\/\n+        public RandomSpliterator(long index, long fence) {\n+            this.index = index; this.fence = fence;\n+        }\n+\n+        \/**\n+         * Returns estimated size.\n+         *\n+         * @return estimated size\n+         *\/\n+        public long estimateSize() {\n+            return fence - index;\n+        }\n+\n+        \/**\n+         * Returns characteristics.\n+         *\n+         * @return characteristics\n+         *\/\n+        public int characteristics() {\n+            return (Spliterator.SIZED | Spliterator.SUBSIZED |\n+                    Spliterator.NONNULL | Spliterator.IMMUTABLE);\n+        }\n+    }\n+\n+    \/**\n+     * Spliterators for int streams. These are based on abstract spliterator\n+     * classes provided by class AbstractSpliteratorGenerator. Each one needs to\n+     * define only a constructor and two methods.\n+     *\/\n+    public static class RandomIntsSpliterator extends RandomSupport.RandomSpliterator\n+            implements Spliterator.OfInt {\n+        final AbstractSpliteratorGenerator generatingGenerator;\n+        final int origin;\n+        final int bound;\n+\n+        \/**\n+         * RandomIntsSpliterator constructor.\n+         *\n+         * @param generatingGenerator base AbstractSpliteratorGenerator\n+         * @param index the (inclusive) lower bound on traversal positions\n+         * @param fence the (exclusive) upper bound on traversal positions\n+         * @param origin the (inclusive) lower bound on the pseudorandom values to be generated\n+         * @param bound the (exclusive) upper bound on the pseudorandom values to be generated\n+         *\/\n+        public RandomIntsSpliterator(AbstractSpliteratorGenerator generatingGenerator,\n+                                     long index, long fence, int origin, int bound) {\n+            super(index, fence);\n+            this.generatingGenerator = generatingGenerator;\n+            this.origin = origin; this.bound = bound;\n+        }\n+\n+        public Spliterator.OfInt trySplit() {\n+            long i = index, m = (i + fence) >>> 1;\n+            if (m <= i) return null;\n+            index = m;\n+            \/\/ The same generatingGenerator is used, with no splitting or copying.\n+            return new RandomIntsSpliterator(generatingGenerator, i, m, origin, bound);\n+        }\n+\n+        public boolean tryAdvance(IntConsumer consumer) {\n+            Objects.requireNonNull(consumer);\n+            long i = index, f = fence;\n+            if (i < f) {\n+                consumer.accept(RandomSupport.boundedNextInt(generatingGenerator, origin, bound));\n+                index = i + 1;\n+                return true;\n+            }\n+            else return false;\n+        }\n+\n+        public void forEachRemaining(IntConsumer consumer) {\n+            Objects.requireNonNull(consumer);\n+            long i = index, f = fence;\n+            if (i < f) {\n+                index = f;\n+                RandomGenerator r = generatingGenerator;\n+                int o = origin, b = bound;\n+                do {\n+                    consumer.accept(RandomSupport.boundedNextInt(r, o, b));\n+                } while (++i < f);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Spliterator for long streams.\n+     *\/\n+    public static class RandomLongsSpliterator extends RandomSupport.RandomSpliterator\n+            implements Spliterator.OfLong {\n+        final AbstractSpliteratorGenerator generatingGenerator;\n+        final long origin;\n+        final long bound;\n+\n+        \/**\n+         * RandomLongsSpliterator constructor.\n+         *\n+         * @param generatingGenerator base AbstractSpliteratorGenerator\n+         * @param index the (inclusive) lower bound on traversal positions\n+         * @param fence the (exclusive) upper bound on traversal positions\n+         * @param origin the (inclusive) lower bound on the pseudorandom values to be generated\n+         * @param bound the (exclusive) upper bound on the pseudorandom values to be generated\n+         *\/\n+        public RandomLongsSpliterator(AbstractSpliteratorGenerator generatingGenerator,\n+                                      long index, long fence, long origin, long bound) {\n+            super(index, fence);\n+            this.generatingGenerator = generatingGenerator;\n+            this.origin = origin; this.bound = bound;\n+        }\n+\n+        public Spliterator.OfLong trySplit() {\n+            long i = index, m = (i + fence) >>> 1;\n+            if (m <= i) return null;\n+            index = m;\n+            \/\/ The same generatingGenerator is used, with no splitting or copying.\n+            return new RandomLongsSpliterator(generatingGenerator, i, m, origin, bound);\n+        }\n+\n+        public boolean tryAdvance(LongConsumer consumer) {\n+            Objects.requireNonNull(consumer);\n+            long i = index, f = fence;\n+            if (i < f) {\n+                consumer.accept(RandomSupport.boundedNextLong(generatingGenerator, origin, bound));\n+                index = i + 1;\n+                return true;\n+            }\n+            else return false;\n+        }\n+\n+        public void forEachRemaining(LongConsumer consumer) {\n+            Objects.requireNonNull(consumer);\n+            long i = index, f = fence;\n+            if (i < f) {\n+                index = f;\n+                RandomGenerator r = generatingGenerator;\n+                long o = origin, b = bound;\n+                do {\n+                    consumer.accept(RandomSupport.boundedNextLong(r, o, b));\n+                } while (++i < f);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Spliterator for double streams.\n+     *\/\n+    public static class RandomDoublesSpliterator extends RandomSupport.RandomSpliterator\n+            implements Spliterator.OfDouble {\n+        final AbstractSpliteratorGenerator generatingGenerator;\n+        final double origin;\n+        final double bound;\n+\n+        \/**\n+         * RandomDoublesSpliterator constructor.\n+         *\n+         * @param generatingGenerator base AbstractSpliteratorGenerator\n+         * @param index the (inclusive) lower bound on traversal positions\n+         * @param fence the (exclusive) upper bound on traversal positions\n+         * @param origin the (inclusive) lower bound on the pseudorandom values to be generated\n+         * @param bound the (exclusive) upper bound on the pseudorandom values to be generated\n+         *\/\n+        public RandomDoublesSpliterator(AbstractSpliteratorGenerator generatingGenerator,\n+                                        long index, long fence, double origin, double bound) {\n+            super(index, fence);\n+            this.generatingGenerator = generatingGenerator;\n+            this.origin = origin; this.bound = bound;\n+        }\n+\n+        public Spliterator.OfDouble trySplit() {\n+            long i = index, m = (i + fence) >>> 1;\n+            if (m <= i) return null;\n+            index = m;\n+            \/\/ The same generatingGenerator is used, with no splitting or copying.\n+            return new RandomDoublesSpliterator(generatingGenerator, i, m, origin, bound);\n+        }\n+\n+        public boolean tryAdvance(DoubleConsumer consumer) {\n+            Objects.requireNonNull(consumer);\n+            long i = index, f = fence;\n+            if (i < f) {\n+                consumer.accept(RandomSupport.boundedNextDouble(generatingGenerator, origin, bound));\n+                index = i + 1;\n+                return true;\n+            }\n+            else return false;\n+        }\n+\n+        public void forEachRemaining(DoubleConsumer consumer) {\n+            Objects.requireNonNull(consumer);\n+            long i = index, f = fence;\n+            if (i < f) {\n+                index = f;\n+                RandomGenerator r = generatingGenerator;\n+                double o = origin, b = bound;\n+                do {\n+                    consumer.accept(RandomSupport.boundedNextDouble(r, o, b));\n+                } while (++i < f);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Implementation support for the {@code nextExponential} method of\n+     * {@link java.util.random.RandomGenerator}.\n+     *\n+     * Certain details of the algorithm used in this method may depend critically\n+     * on the quality of the low-order bits delivered by {@code nextLong()}.  This method\n+     * should not be used with RNG algorithms (such as a simple Linear Congruential\n+     * Generator) whose low-order output bits do not have good statistical quality.\n+     *\n+     * @implNote The reference implementation uses McFarland's fast modified\n+     * ziggurat algorithm (largely table-driven, with rare cases handled by\n+     * computation and rejection sampling). Walker's alias method for sampling\n+     * a discrete distribution also plays a role.\n+     *\n+     * @param rng an instance of {@code RandomGenerator}, used to generate uniformly\n+     *            pseudorandomly chosen {@code long} values\n+     *\n+     * @return a nonnegative {@code double} value chosen pseudorandomly\n+     *         from an exponential distribution whose mean is 1\n+     *\/\n+    public static double computeNextExponential(RandomGenerator rng) {\n+        \/*\n+         * The tables themselves, as well as a number of associated parameters, are\n+         * defined in class DoubleZigguratTables, which is automatically\n+         * generated by the program create_ziggurat_tables.c (which takes only a\n+         * few seconds to run).\n+         *\n+         * For more information about the algorithm, see these articles:\n+         *\n+         * Christopher D. McFarland.  2016 (published online 24 Jun 2015).  A modified ziggurat\n+         * algorithm for generating exponentially and normally distributed pseudorandom numbers.\n+         * Journal of Statistical Computation and Simulation 86 (7), pages 1281-1294.\n+         * https:\/\/www.tandfonline.com\/doi\/abs\/10.1080\/00949655.2015.1060234\n+         * Also at https:\/\/arxiv.org\/abs\/1403.6870 (26 March 2014).\n+         *\n+         * Alastair J. Walker.  1977.  An efficient method for generating discrete random\n+         * variables with general distributions. ACM Trans. Math. Software 3, 3\n+         * (September 1977), 253-256. DOI: https:\/\/doi.org\/10.1145\/355744.355749\n+         *\n+         *\/\n+        long U1 = rng.nextLong();\n+        \/\/ Experimentation on a variety of machines indicates that it is overall much faster\n+        \/\/ to do the following & and < operations on longs rather than first cast U1 to int\n+        \/\/ (but then we need to cast to int before doing the array indexing operation).\n+        long i = U1 & DoubleZigguratTables.exponentialLayerMask;\n+        if (i < DoubleZigguratTables.exponentialNumberOfLayers) {\n+            \/\/ This is the fast path (occurring more than 98% of the time).  Make an early exit.\n+            return DoubleZigguratTables.exponentialX[(int)i] * (U1 >>> 1);\n+        }\n+        \/\/ We didn't use the upper part of U1 after all.  We'll be able to use it later.\n+\n+        for (double extra = 0.0; ; ) {\n+            \/\/ Use Walker's alias method to sample an (unsigned) integer j from a discrete\n+            \/\/ probability distribution that includes the tail and all the ziggurat overhangs;\n+            \/\/ j will be less than DoubleZigguratTables.exponentialNumberOfLayers + 1.\n+            long UA = rng.nextLong();\n+            int j = (int)UA & DoubleZigguratTables.exponentialAliasMask;\n+            if (UA >= DoubleZigguratTables.exponentialAliasThreshold[j]) {\n+                j = DoubleZigguratTables.exponentialAliasMap[j] &\n+                        DoubleZigguratTables.exponentialSignCorrectionMask;\n+            }\n+            if (j > 0) {   \/\/ Sample overhang j\n+                \/\/ For the exponential distribution, every overhang is convex.\n+                final double[] X = DoubleZigguratTables.exponentialX;\n+                final double[] Y = DoubleZigguratTables.exponentialY;\n+                for (;; U1 = (rng.nextLong() >>> 1)) {\n+                    long U2 = (rng.nextLong() >>> 1);\n+                    \/\/ Compute the actual x-coordinate of the randomly chosen point.\n+                    double x = (X[j] * 0x1.0p63) + ((X[j-1] - X[j]) * (double)U1);\n+                    \/\/ Does the point lie below the curve?\n+                    long Udiff = U2 - U1;\n+                    if (Udiff < 0) {\n+                        \/\/ We picked a point in the upper-right triangle.  None of those can be\n+                        \/\/ accepted.  So remap the point into the lower-left triangle and try that.\n+                        \/\/ In effect, we swap U1 and U2, and invert the sign of Udiff.\n+                        Udiff = -Udiff;\n+                        U2 = U1;\n+                        U1 -= Udiff;\n+                    }\n+                    if (Udiff >= DoubleZigguratTables.exponentialConvexMargin) {\n+                        return x + extra;   \/\/ The chosen point is way below the curve; accept it.\n+                    }\n+                    \/\/ Compute the actual y-coordinate of the randomly chosen point.\n+                    double y = (Y[j] * 0x1.0p63) + ((Y[j] - Y[j-1]) * (double)U2);\n+                    \/\/ Now see how that y-coordinate compares to the curve\n+                    if (y <= Math.exp(-x)) {\n+                        return x + extra;   \/\/ The chosen point is below the curve; accept it.\n+                    }\n+                    \/\/ Otherwise, we reject this sample and have to try again.\n+                }\n+            }\n+            \/\/ We are now committed to sampling from the tail.  We could do a recursive call\n+            \/\/ and then add X[0], but we save some time and stack space by using an iterative loop.\n+            extra += DoubleZigguratTables.exponentialX0;\n+            \/\/ This is like the first five lines of this method, but if it returns, it first adds \"extra\".\n+            U1 = rng.nextLong();\n+            i = U1 & DoubleZigguratTables.exponentialLayerMask;\n+            if (i < DoubleZigguratTables.exponentialNumberOfLayers) {\n+                return DoubleZigguratTables.exponentialX[(int)i] * (U1 >>> 1) + extra;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Implementation support for the {@code nextGaussian} methods of\n+     * {@link java.util.random.RandomGenerator}.\n+     *\n+     * Certain details of the algorithm used in this method may depend critically\n+     * on the quality of the low-order bits delivered by {@code nextLong()}.  This method\n+     * should not be used with RNG algorithms (such as a simple Linear Congruential\n+     * Generator) whose low-order output bits do not have good statistical quality.\n+     *\n+     * @implNote The reference implementation uses McFarland's fast modified\n+     * ziggurat algorithm (largely table-driven, with rare cases handled by\n+     * computation and rejection sampling). Walker's alias method for sampling\n+     * a discrete distribution also plays a role.\n+     *\n+     * @param rng an instance of {@code RandomGenerator}, used to generate uniformly\n+     *            pseudorandomly chosen {@code long} values\n+     *\n+     * @return a nonnegative {@code double} value chosen pseudorandomly\n+     *         from a Gaussian (normal) distribution whose mean is 0 and whose\n+     *         standard deviation is 1.\n+     *\/\n+    public static double computeNextGaussian(RandomGenerator rng) {\n+        \/*\n+         * The tables themselves, as well as a number of associated parameters, are\n+         * defined in class java.util.DoubleZigguratTables, which is automatically\n+         * generated by the program create_ziggurat_tables.c (which takes only a\n+         * few seconds to run).\n+         *\n+         * For more information about the algorithm, see these articles:\n+         *\n+         * Christopher D. McFarland.  2016 (published online 24 Jun 2015).  A modified ziggurat\n+         * algorithm for generating exponentially and normally distributed pseudorandom numbers.\n+         * Journal of Statistical Computation and Simulation 86 (7), pages 1281-1294.\n+         * https:\/\/www.tandfonline.com\/doi\/abs\/10.1080\/00949655.2015.1060234\n+         * Also at https:\/\/arxiv.org\/abs\/1403.6870 (26 March 2014).\n+         *\n+         * Alastair J. Walker.  1977.  An efficient method for generating discrete random\n+         * variables with general distributions. ACM Trans. Math. Software 3, 3\n+         * (September 1977), 253-256. DOI: https:\/\/doi.org\/10.1145\/355744.355749\n+         *\n+         *\/\n+        long U1 = rng.nextLong();\n+        \/\/ Experimentation on a variety of machines indicates that it is overall much faster\n+        \/\/ to do the following & and < operations on longs rather than first cast U1 to int\n+        \/\/ (but then we need to cast to int before doing the array indexing operation).\n+        long i = U1 & DoubleZigguratTables.normalLayerMask;\n+\n+        if (i < DoubleZigguratTables.normalNumberOfLayers) {\n+            \/\/ This is the fast path (occurring more than 98% of the time).  Make an early exit.\n+            return DoubleZigguratTables.normalX[(int)i] * U1;   \/\/ Note that the sign bit of U1 is used here.\n+        }\n+        \/\/ We didn't use the upper part of U1 after all.\n+        \/\/ Pull U1 apart into a sign bit and a 63-bit value for later use.\n+        double signBit = (U1 >= 0) ? 1.0 : -1.0;\n+        U1 = (U1 << 1) >>> 1;\n+\n+        \/\/ Use Walker's alias method to sample an (unsigned) integer j from a discrete\n+        \/\/ probability distribution that includes the tail and all the ziggurat overhangs;\n+        \/\/ j will be less than DoubleZigguratTables.normalNumberOfLayers + 1.\n+        long UA = rng.nextLong();\n+        int j = (int)UA & DoubleZigguratTables.normalAliasMask;\n+        if (UA >= DoubleZigguratTables.normalAliasThreshold[j]) {\n+            j = DoubleZigguratTables.normalAliasMap[j] & DoubleZigguratTables.normalSignCorrectionMask;\n+        }\n+\n+        double x;\n+        \/\/ Now the goal is to choose the result, which will be multiplied by signBit just before return.\n+\n+        \/\/ There are four kinds of overhangs:\n+        \/\/\n+        \/\/  j == 0                          :  Sample from tail\n+        \/\/  0 < j < normalInflectionIndex   :  Overhang is convex; can reject upper-right triangle\n+        \/\/  j == normalInflectionIndex      :  Overhang includes the inflection point\n+        \/\/  j > normalInflectionIndex       :  Overhang is concave; can accept point in lower-left triangle\n+        \/\/\n+        \/\/ Choose one of four loops to compute x, each specialized for a specific kind of overhang.\n+        \/\/ Conditional statements are arranged such that the more likely outcomes are first.\n+\n+        \/\/ In the three cases other than the tail case:\n+        \/\/ U1 represents a fraction (scaled by 2**63) of the width of rectangle measured from the left.\n+        \/\/ U2 represents a fraction (scaled by 2**63) of the height of rectangle measured from the top.\n+        \/\/ Together they indicate a randomly chosen point within the rectangle.\n+\n+        final double[] X = DoubleZigguratTables.normalX;\n+        final double[] Y = DoubleZigguratTables.normalY;\n+        if (j > DoubleZigguratTables.normalInflectionIndex) {   \/\/ Concave overhang\n+            for (;; U1 = (rng.nextLong() >>> 1)) {\n+                long U2 = (rng.nextLong() >>> 1);\n+                \/\/ Compute the actual x-coordinate of the randomly chosen point.\n+                x = (X[j] * 0x1.0p63) + ((X[j-1] - X[j]) * (double)U1);\n+                \/\/ Does the point lie below the curve?\n+                long Udiff = U2 - U1;\n+                if (Udiff >= 0) {\n+                    break;   \/\/ The chosen point is in the lower-left triangle; accept it.\n+                }\n+                if (Udiff <= -DoubleZigguratTables.normalConcaveMargin) {\n+                    continue;   \/\/ The chosen point is way above the curve; reject it.\n+                }\n+                \/\/ Compute the actual y-coordinate of the randomly chosen point.\n+                double y = (Y[j] * 0x1.0p63) + ((Y[j] - Y[j-1]) * (double)U2);\n+                \/\/ Now see how that y-coordinate compares to the curve\n+                if (y <= Math.exp(-0.5*x*x)) {\n+                    break;   \/\/ The chosen point is below the curve; accept it.\n+                }\n+                \/\/ Otherwise, we reject this sample and have to try again.\n+            }\n+        } else if (j == 0) {   \/\/ Tail\n+            \/\/ Tail-sampling method of Marsaglia and Tsang.  See any one of:\n+            \/\/ Marsaglia and Tsang. 1984. A fast, easily implemented method for sampling from decreasing\n+            \/\/    or symmetric unimodal density functions. SIAM J. Sci. Stat. Comput. 5, 349-359.\n+            \/\/ Marsaglia and Tsang. 1998. The Monty Python method for generating random variables.\n+            \/\/    ACM Trans. Math. Softw. 24, 3 (September 1998), 341-350.  See page 342, step (4).\n+            \/\/    http:\/\/doi.org\/10.1145\/292395.292453\n+            \/\/ Thomas, Luk, Leong, and Villasenor. 2007. Gaussian random number generators.\n+            \/\/    ACM Comput. Surv. 39, 4, Article 11 (November 2007).  See Algorithm 16.\n+            \/\/    http:\/\/doi.org\/10.1145\/1287620.1287622\n+            \/\/ Compute two separate random exponential samples and then compare them in certain way.\n+            do {\n+                x = (1.0 \/ DoubleZigguratTables.normalX0) * computeNextExponential(rng);\n+            } while (computeNextExponential(rng) < 0.5*x*x);\n+            x += DoubleZigguratTables.normalX0;\n+        } else if (j < DoubleZigguratTables.normalInflectionIndex) {   \/\/ Convex overhang\n+            for (;; U1 = (rng.nextLong() >>> 1)) {\n+                long U2 = (rng.nextLong() >>> 1);\n+                \/\/ Compute the actual x-coordinate of the randomly chosen point.\n+                x = (X[j] * 0x1.0p63) + ((X[j-1] - X[j]) * (double)U1);\n+                \/\/ Does the point lie below the curve?\n+                long Udiff = U2 - U1;\n+                if (Udiff < 0) {\n+                    \/\/ We picked a point in the upper-right triangle.  None of those can be accepted.\n+                    \/\/ So remap the point into the lower-left triangle and try that.\n+                    \/\/ In effect, we swap U1 and U2, and invert the sign of Udiff.\n+                    Udiff = -Udiff;\n+                    U2 = U1;\n+                    U1 -= Udiff;\n+                }\n+                if (Udiff >= DoubleZigguratTables.normalConvexMargin) {\n+                    break;   \/\/ The chosen point is way below the curve; accept it.\n+                }\n+                \/\/ Compute the actual y-coordinate of the randomly chosen point.\n+                double y = (Y[j] * 0x1.0p63) + ((Y[j] - Y[j-1]) * (double)U2);\n+                \/\/ Now see how that y-coordinate compares to the curve\n+                if (y <= Math.exp(-0.5*x*x)) break; \/\/ The chosen point is below the curve; accept it.\n+                \/\/ Otherwise, we reject this sample and have to try again.\n+            }\n+        } else {\n+            \/\/ The overhang includes the inflection point, so the curve is both convex and concave\n+            for (;; U1 = (rng.nextLong() >>> 1)) {\n+                long U2 = (rng.nextLong() >>> 1);\n+                \/\/ Compute the actual x-coordinate of the randomly chosen point.\n+                x = (X[j] * 0x1.0p63) + ((X[j-1] - X[j]) * (double)U1);\n+                \/\/ Does the point lie below the curve?\n+                long Udiff = U2 - U1;\n+                if (Udiff >= DoubleZigguratTables.normalConvexMargin) {\n+                    break;   \/\/ The chosen point is way below the curve; accept it.\n+                }\n+                if (Udiff <= -DoubleZigguratTables.normalConcaveMargin) {\n+                    continue;   \/\/ The chosen point is way above the curve; reject it.\n+                }\n+                \/\/ Compute the actual y-coordinate of the randomly chosen point.\n+                double y = (Y[j] * 0x1.0p63) + ((Y[j] - Y[j-1]) * (double)U2);\n+                \/\/ Now see how that y-coordinate compares to the curve\n+                if (y <= Math.exp(-0.5*x*x)) {\n+                    break;   \/\/ The chosen point is below the curve; accept it.\n+                }\n+                \/\/ Otherwise, we reject this sample and have to try again.\n+            }\n+        }\n+        return signBit*x;\n+    }\n+\n+    \/**\n+     * This class overrides the stream-producing methods (such as\n+     * {@link RandomGenerator#ints() ints}()) in class {@link RandomGenerator}\n+     * to provide {@link Spliterator}-based implmentations that support\n+     * potentially parallel execution.\n+     *\n+     * <p> To implement a pseudorandom number generator, the programmer needs\n+     * only to extend this class and provide implementations for the methods\n+     * {@link RandomGenerator#nextInt() nextInt}(),\n+     * {@link RandomGenerator#nextLong() nextLong}(),\n+     * {@link AbstractSpliteratorGenerator#makeIntsSpliterator(long, long, int, int) makeIntsSpliterator}(index, fence, origin, bound),\n+     * {@link AbstractSpliteratorGenerator#makeLongsSpliterator(long, long, long, long) makeLongsSpliterator}(index, fence, origin, bound),\n+     * and\n+     * {@link AbstractSpliteratorGenerator#makeDoublesSpliterator(long, long, double, double) makeDoublesSpliterator}(index, fence, origin, bound).\n+     *\n+     * <p> This class is not public; it provides shared code to the public\n+     * classes {@link AbstractSplittableGenerator}, and\n+     * {@link AbstractArbitrarilyJumpableGenerator}.\n+     *\n+     * @since 17\n+     * @hidden\n+     *\/\n+    public abstract static class AbstractSpliteratorGenerator implements RandomGenerator {\n+        \/*\n+         * Implementation Overview.\n+         *\n+         * This class provides most of the \"user API\" methods needed to\n+         * satisfy the interface RandomGenerator.  An implementation of this\n+         * interface need only extend this class and provide implementations\n+         * of six methods: nextInt, nextLong, and nextDouble (the versions\n+         * that take no arguments) and makeIntsSpliterator,\n+         * makeLongsSpliterator, and makeDoublesSpliterator.\n+         *\n+         * File organization: First the non-public abstract methods needed\n+         * to create spliterators, then the main public methods.\n+         *\/\n+\n+        \/**\n+         * Explicit constructor.\n+         *\/\n+        protected AbstractSpliteratorGenerator() {\n+        }\n+\n+        \/**\n+         * Create an instance of {@link Spliterator.OfInt} that for each\n+         * traversal position between the specified index (inclusive) and the\n+         * specified fence (exclusive) generates a pseudorandomly chosen\n+         * {@code int} value between the specified origin (inclusive) and the\n+         * specified bound (exclusive).\n+         *\n+         * @param index the (inclusive) lower bound on traversal positions\n+         * @param fence the (exclusive) upper bound on traversal positions\n+         * @param origin the (inclusive) lower bound on the pseudorandom values to be generated\n+         * @param bound the (exclusive) upper bound on the pseudorandom values to be generated\n+         *\n+         * @return an instance of {@link Spliterator.OfInt}\n+         *\n+         * @hidden\n+         *\/\n+        public abstract Spliterator.OfInt makeIntsSpliterator(long index, long fence, int origin, int bound);\n+\n+        \/**\n+         * Create an instance of {@link Spliterator.OfLong} that for each\n+         * traversal position between the specified index (inclusive) and the\n+         * specified fence (exclusive) generates a pseudorandomly chosen\n+         * {@code long} value between the specified origin (inclusive) and the\n+         * specified bound (exclusive).\n+         *\n+         * @param index the (inclusive) lower bound on traversal positions\n+         * @param fence the (exclusive) upper bound on traversal positions\n+         * @param origin the (inclusive) lower bound on the pseudorandom values to be generated\n+         * @param bound the (exclusive) upper bound on the pseudorandom values to be generated\n+         *\n+         * @return an instance of {@link Spliterator.OfLong}\n+         *\n+         * @hidden\n+         *\/\n+        public abstract Spliterator.OfLong makeLongsSpliterator(long index, long fence, long origin, long bound);\n+\n+        \/**\n+         * Create an instance of {@link Spliterator.OfDouble} that for each\n+         * traversal position between the specified index (inclusive) and the\n+         * specified fence (exclusive) generates a pseudorandomly chosen\n+         * {@code double} value between the specified origin (inclusive) and the\n+         * specified bound (exclusive).\n+         *\n+         * @param index the (inclusive) lower bound on traversal positions\n+         * @param fence the (exclusive) upper bound on traversal positions\n+         * @param origin the (inclusive) lower bound on the pseudorandom values to be generated\n+         * @param bound the (exclusive) upper bound on the pseudorandom values to be generated\n+         *\n+         * @return an instance of {@link Spliterator.OfDouble}\n+         *\n+         * @hidden\n+         *\/\n+        public abstract Spliterator.OfDouble makeDoublesSpliterator(long index, long fence, double origin, double bound);\n+\n+        \/* ---------------- public methods ---------------- *\/\n+\n+        \/\/ stream methods, coded in a way intended to better isolate for\n+        \/\/ maintenance purposes the small differences across forms.\n+\n+        private static IntStream intStream(Spliterator.OfInt srng) {\n+            return StreamSupport.intStream(srng, false);\n+        }\n+\n+        private static LongStream longStream(Spliterator.OfLong srng) {\n+            return StreamSupport.longStream(srng, false);\n+        }\n+\n+        private static DoubleStream doubleStream(Spliterator.OfDouble srng) {\n+            return StreamSupport.doubleStream(srng, false);\n+        }\n+\n+        @Override\n+        public IntStream ints(long streamSize) {\n+            RandomSupport.checkStreamSize(streamSize);\n+            return intStream(makeIntsSpliterator(0L, streamSize, Integer.MAX_VALUE, 0));\n+        }\n+\n+        @Override\n+        public IntStream ints() {\n+            return intStream(makeIntsSpliterator(0L, Long.MAX_VALUE, Integer.MAX_VALUE, 0));\n+        }\n+\n+        @Override\n+        public IntStream ints(long streamSize, int randomNumberOrigin, int randomNumberBound) {\n+            RandomSupport.checkStreamSize(streamSize);\n+            RandomSupport.checkRange(randomNumberOrigin, randomNumberBound);\n+            return intStream(makeIntsSpliterator(0L, streamSize, randomNumberOrigin, randomNumberBound));\n+        }\n+\n+        @Override\n+        public IntStream ints(int randomNumberOrigin, int randomNumberBound) {\n+            RandomSupport.checkRange(randomNumberOrigin, randomNumberBound);\n+            return intStream(makeIntsSpliterator(0L, Long.MAX_VALUE, randomNumberOrigin, randomNumberBound));\n+        }\n+\n+        @Override\n+        public LongStream longs(long streamSize) {\n+            RandomSupport.checkStreamSize(streamSize);\n+            return longStream(makeLongsSpliterator(0L, streamSize, Long.MAX_VALUE, 0L));\n+        }\n+\n+        @Override\n+        public LongStream longs() {\n+            return longStream(makeLongsSpliterator(0L, Long.MAX_VALUE, Long.MAX_VALUE, 0L));\n+        }\n+\n+        @Override\n+        public LongStream longs(long streamSize, long randomNumberOrigin,\n+                                long randomNumberBound) {\n+            RandomSupport.checkStreamSize(streamSize);\n+            RandomSupport.checkRange(randomNumberOrigin, randomNumberBound);\n+            return longStream(makeLongsSpliterator(0L, streamSize, randomNumberOrigin, randomNumberBound));\n+        }\n+\n+        @Override\n+        public LongStream longs(long randomNumberOrigin, long randomNumberBound) {\n+            RandomSupport.checkRange(randomNumberOrigin, randomNumberBound);\n+            return StreamSupport.longStream\n+                    (makeLongsSpliterator(0L, Long.MAX_VALUE, randomNumberOrigin, randomNumberBound),\n+                            false);\n+        }\n+\n+        @Override\n+        public DoubleStream doubles(long streamSize) {\n+            RandomSupport.checkStreamSize(streamSize);\n+            return doubleStream(makeDoublesSpliterator(0L, streamSize, Double.MAX_VALUE, 0.0));\n+        }\n+\n+        @Override\n+        public DoubleStream doubles() {\n+            return doubleStream(makeDoublesSpliterator(0L, Long.MAX_VALUE, Double.MAX_VALUE, 0.0));\n+        }\n+\n+        @Override\n+        public DoubleStream doubles(long streamSize, double randomNumberOrigin, double randomNumberBound) {\n+            RandomSupport.checkStreamSize(streamSize);\n+            RandomSupport.checkRange(randomNumberOrigin, randomNumberBound);\n+            return doubleStream(makeDoublesSpliterator(0L, streamSize, randomNumberOrigin, randomNumberBound));\n+        }\n+\n+        @Override\n+        public DoubleStream doubles(double randomNumberOrigin, double randomNumberBound) {\n+            RandomSupport.checkRange(randomNumberOrigin, randomNumberBound);\n+            return doubleStream(makeDoublesSpliterator(0L, Long.MAX_VALUE, randomNumberOrigin, randomNumberBound));\n+        }\n+\n+    }\n+\n+    \/**\n+     * This class provides much of the implementation of the\n+     * {@link ArbitrarilyJumpableGenerator} interface, to minimize the effort\n+     * required to implement that interface.\n+     *\n+     * <p> To implement a pseudorandom number generator, the programmer needs\n+     * only to extend this class and provide implementations for the methods\n+     * {@link RandomGenerator#nextInt() nextInt}(),\n+     * {@link RandomGenerator#nextLong() nextLong}(),\n+     * {@link ArbitrarilyJumpableGenerator#copy() copy}(),\n+     * {@link JumpableGenerator#jumps(long) jumps}(long),\n+     * {@link ArbitrarilyJumpableGenerator#jumpPowerOfTwo(int) jumpPowerOfTwo}(logDistance),\n+     * {@link JumpableGenerator#jumpDistance() jumpDistance}(),\n+     * and\n+     * {@link LeapableGenerator#leapDistance() leapDistance}().\n+     *\n+     * <p> (If the pseudorandom number generator also has the ability to\n+     * split, then the programmer may wish to consider instead extending\n+     * {@link AbstractSplittableGenerator}.)\n+     *\n+     * <p> The programmer should generally provide at least three constructors:\n+     * one that takes no arguments, one that accepts a {@code long} seed value,\n+     * and one that accepts an array of seed {@code byte} values. This class\n+     * provides a public {@link RandomSupport#initialSeed() initialSeed}()\n+     * method that may be useful in initializing some static state from which to\n+     * derive defaults seeds for use by the no-argument constructor.\n+     *\n+     * <p> For the stream methods (such as {@link RandomGenerator#ints() ints}()\n+     * and {@link SplittableGenerator#splits() splits}()), this class provides\n+     * {@link Spliterator}-based implementations that allow parallel execution\n+     * when appropriate. In this respect {@link ArbitrarilyJumpableGenerator}\n+     * differs from {@link JumpableGenerator}, which provides very simple\n+     * implementations that produce sequential streams only.\n+     *\n+     * <p> An implementation of the {@link AbstractArbitrarilyJumpableGenerator}\n+     * class must provide concrete definitions for the methods\n+     * {@link RandomGenerator#nextInt() nextInt}(),\n+     * {@link RandomGenerator#nextLong() nextLong}(),\n+     * {@link AbstractArbitrarilyJumpableGenerator#jumps(double) jumps}(double),\n+     * {@link JumpableGenerator#jumpDistance() jumpDistance}(),\n+     * and\n+     * {@link LeapableGenerator#leapDistance() leapDistance}().\n+     * Default implementations are provided for all other methods.\n+     *\n+     * <p> The documentation for each non-abstract method in this class\n+     * describes its implementation in detail. Each of these methods may be\n+     * overridden if the pseudorandom number generator being implemented\n+     * admits a more efficient implementation.\n+     *\n+     * @since 17\n+     * @hidden\n+     *\/\n+    public abstract static class AbstractArbitrarilyJumpableGenerator\n+            extends AbstractSpliteratorGenerator implements RandomGenerator.ArbitrarilyJumpableGenerator {\n+\n+        \/*\n+         * Implementation Overview.\n+         *\n+         * This class provides most of the \"user API\" methods needed to satisfy\n+         * the interface ArbitrarilyJumpableGenerator.  Most of these methods\n+         * are in turn inherited from AbstractGenerator and the non-public class\n+         * AbstractSpliteratorGenerator; this file implements four versions of the\n+         * jumps method and defines the spliterators necessary to support them.\n+         *\n+         * File organization: First the non-public methods needed by the class\n+         * AbstractSpliteratorGenerator, then the main public methods, followed by some\n+         * custom spliterator classes needed for stream methods.\n+         *\/\n+\n+        \/**\n+         * Explicit constructor.\n+         *\/\n+        protected AbstractArbitrarilyJumpableGenerator() {\n+        }\n+\n+        \/\/ Methods required by class AbstractSpliteratorGenerator\n+\n+        public Spliterator.OfInt makeIntsSpliterator(long index, long fence, int origin, int bound) {\n+            return new RandomIntsSpliterator(this, index, fence, origin, bound);\n+        }\n+\n+        public Spliterator.OfLong makeLongsSpliterator(long index, long fence, long origin, long bound) {\n+            return new RandomLongsSpliterator(this, index, fence, origin, bound);\n+        }\n+\n+        public Spliterator.OfDouble makeDoublesSpliterator(long index, long fence, double origin, double bound) {\n+            return new RandomDoublesSpliterator(this, index, fence, origin, bound);\n+        }\n+\n+        \/\/ Similar methods used by this class\n+\n+        Spliterator<RandomGenerator> makeJumpsSpliterator(long index, long fence, double distance) {\n+            return new RandomJumpsSpliterator(this, index, fence, distance);\n+        }\n+\n+        Spliterator<JumpableGenerator> makeLeapsSpliterator(long index, long fence, double distance) {\n+            return new RandomLeapsSpliterator(this, index, fence, distance);\n+        }\n+\n+        Spliterator<ArbitrarilyJumpableGenerator> makeArbitraryJumpsSpliterator(long index, long fence, double distance) {\n+            return new RandomArbitraryJumpsSpliterator(this, index, fence, distance);\n+        }\n+\n+        \/* ---------------- public methods ---------------- *\/\n+\n+        \/**\n+         * Returns a new generator whose internal state is an exact copy of this\n+         * generator (therefore their future behavior should be identical if\n+         * subjected to the same series of operations).\n+         *\n+         * @return a new object that is a copy of this generator\n+         *\/\n+        public abstract AbstractArbitrarilyJumpableGenerator copy();\n+\n+        \/\/ Stream methods for jumping\n+\n+        private static <T> Stream<T> stream(Spliterator<T> srng) {\n+            return StreamSupport.stream(srng, false);\n+        }\n+\n+        @Override\n+        public Stream<RandomGenerator> jumps() {\n+            return stream(makeJumpsSpliterator(0L, Long.MAX_VALUE, jumpDistance()));\n+        }\n+\n+        @Override\n+        public Stream<RandomGenerator> jumps(long streamSize) {\n+            RandomSupport.checkStreamSize(streamSize);\n+            return stream(makeJumpsSpliterator(0L, streamSize, jumpDistance()));\n+        }\n+\n+        @Override\n+        public Stream<ArbitrarilyJumpableGenerator> jumps(double distance) {\n+            return stream(makeArbitraryJumpsSpliterator(0L, Long.MAX_VALUE, distance));\n+        }\n+\n+        @Override\n+        public Stream<ArbitrarilyJumpableGenerator> jumps(long streamSize, double distance) {\n+            RandomSupport.checkStreamSize(streamSize);\n+            return stream(makeArbitraryJumpsSpliterator(0L, streamSize, distance));\n+        }\n+\n+        @Override\n+        public void leap() {\n+            jump(leapDistance());\n+        }\n+\n+        \/\/ Stream methods for leaping\n+\n+        @Override\n+        public Stream<JumpableGenerator> leaps() {\n+            return stream(makeLeapsSpliterator(0L, Long.MAX_VALUE, leapDistance()));\n+        }\n+\n+        @Override\n+        public Stream<JumpableGenerator> leaps(long streamSize) {\n+            return stream(makeLeapsSpliterator(0L, streamSize, leapDistance()));\n+        }\n+\n+\n+        \/**\n+         * Spliterator for int streams. We multiplex the four int versions into\n+         * one class by treating a bound less than origin as unbounded, and also\n+         * by treating \"infinite\" as equivalent to\n+         * {@link Long#MAX_VALUE Long.MAX_VALUE}. For splits, we choose to\n+         * override the method {@code trySplit()} to try to optimize execution\n+         * speed: instead of dividing a range in half, it breaks off the largest\n+         * possible chunk whose size is a power of two such that the remaining\n+         * chunk is not empty. In this way, the necessary jump distances will\n+         * tend to be powers of two. The long and double versions of this class\n+         * are identical except for types.\n+         *\/\n+        static class RandomIntsSpliterator extends RandomSupport.RandomSpliterator implements Spliterator.OfInt {\n+            final ArbitrarilyJumpableGenerator generatingGenerator;\n+            final int origin;\n+            final int bound;\n+\n+            RandomIntsSpliterator(ArbitrarilyJumpableGenerator generatingGenerator, long index, long fence, int origin, int bound) {\n+                super(index, fence);\n+                this.origin = origin; this.bound = bound;\n+                this.generatingGenerator = generatingGenerator;\n+            }\n+\n+            public Spliterator.OfInt trySplit() {\n+                long i = index, delta = Long.highestOneBit((fence - i) - 1), m = i + delta;\n+                if (m <= i) return null;\n+                index = m;\n+                ArbitrarilyJumpableGenerator r = generatingGenerator;\n+                return new RandomIntsSpliterator(r.copyAndJump((double)delta), i, m, origin, bound);\n+            }\n+\n+            public boolean tryAdvance(IntConsumer consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    consumer.accept(RandomSupport.boundedNextInt(generatingGenerator, origin, bound));\n+                    index = i + 1;\n+                    return true;\n+                }\n+                else return false;\n+            }\n+\n+            public void forEachRemaining(IntConsumer consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    index = f;\n+                    ArbitrarilyJumpableGenerator r = generatingGenerator;\n+                    int o = origin, b = bound;\n+                    do {\n+                        consumer.accept(RandomSupport.boundedNextInt(r, o, b));\n+                    } while (++i < f);\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Spliterator for long streams.\n+         *\/\n+        static class RandomLongsSpliterator extends RandomSupport.RandomSpliterator implements Spliterator.OfLong {\n+            final ArbitrarilyJumpableGenerator generatingGenerator;\n+            final long origin;\n+            final long bound;\n+\n+            RandomLongsSpliterator(ArbitrarilyJumpableGenerator generatingGenerator, long index, long fence, long origin, long bound) {\n+                super(index, fence);\n+                this.generatingGenerator = generatingGenerator;\n+                this.origin = origin; this.bound = bound;\n+            }\n+\n+            public Spliterator.OfLong trySplit() {\n+                long i = index, delta = Long.highestOneBit((fence - i) - 1), m = i + delta;\n+                if (m <= i) return null;\n+                index = m;\n+                ArbitrarilyJumpableGenerator r = generatingGenerator;\n+                return new RandomLongsSpliterator(r.copyAndJump((double)delta), i, m, origin, bound);\n+            }\n+\n+            public boolean tryAdvance(LongConsumer consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    consumer.accept(RandomSupport.boundedNextLong(generatingGenerator, origin, bound));\n+                    index = i + 1;\n+                    return true;\n+                }\n+                else return false;\n+            }\n+\n+            public void forEachRemaining(LongConsumer consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    index = f;\n+                    ArbitrarilyJumpableGenerator r = generatingGenerator;\n+                    long o = origin, b = bound;\n+                    do {\n+                        consumer.accept(RandomSupport.boundedNextLong(r, o, b));\n+                    } while (++i < f);\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Spliterator for double streams.\n+         *\/\n+        static class RandomDoublesSpliterator extends RandomSupport.RandomSpliterator implements Spliterator.OfDouble {\n+            final ArbitrarilyJumpableGenerator generatingGenerator;\n+            final double origin;\n+            final double bound;\n+\n+            RandomDoublesSpliterator(ArbitrarilyJumpableGenerator generatingGenerator, long index, long fence, double origin, double bound) {\n+                super(index, fence);\n+                this.generatingGenerator = generatingGenerator;\n+                this.origin = origin; this.bound = bound;\n+            }\n+\n+            public Spliterator.OfDouble trySplit() {\n+\n+                long i = index, delta = Long.highestOneBit((fence - i) - 1), m = i + delta;\n+                if (m <= i) return null;\n+                index = m;\n+                ArbitrarilyJumpableGenerator r = generatingGenerator;\n+                return new RandomDoublesSpliterator(r.copyAndJump((double)delta), i, m, origin, bound);\n+            }\n+\n+            public boolean tryAdvance(DoubleConsumer consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    consumer.accept(RandomSupport.boundedNextDouble(generatingGenerator, origin, bound));\n+                    index = i + 1;\n+                    return true;\n+                }\n+                else return false;\n+            }\n+\n+            public void forEachRemaining(DoubleConsumer consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    index = f;\n+                    ArbitrarilyJumpableGenerator r = generatingGenerator;\n+                    double o = origin, b = bound;\n+                    do {\n+                        consumer.accept(RandomSupport.boundedNextDouble(r, o, b));\n+                    } while (++i < f);\n+                }\n+            }\n+        }\n+\n+        \/\/ Spliterators for producing new generators by jumping or leaping.  The\n+        \/\/ complete implementation of each of these spliterators is right here.\n+        \/\/ In the same manner as for the preceding spliterators, the method trySplit() is\n+        \/\/ coded to optimize execution speed: instead of dividing a range\n+        \/\/ in half, it breaks off the largest possible chunk whose\n+        \/\/ size is a power of two such that the remaining chunk is not\n+        \/\/ empty.  In this way, the necessary jump distances will tend to be\n+        \/\/ powers of two.\n+\n+        \/**\n+         * Spliterator for stream of generators of type RandomGenerator produced\n+         * by jumps.\n+         *\/\n+        static class RandomJumpsSpliterator extends RandomSupport.RandomSpliterator implements Spliterator<RandomGenerator> {\n+            ArbitrarilyJumpableGenerator generatingGenerator;\n+            final double distance;\n+\n+            RandomJumpsSpliterator(ArbitrarilyJumpableGenerator generatingGenerator, long index, long fence, double distance) {\n+                super(index, fence);\n+                this.generatingGenerator = generatingGenerator; this.distance = distance;\n+            }\n+\n+            public Spliterator<RandomGenerator> trySplit() {\n+                long i = index, delta = Long.highestOneBit((fence - i) - 1), m = i + delta;\n+                if (m <= i) return null;\n+                index = m;\n+                ArbitrarilyJumpableGenerator r = generatingGenerator;\n+                \/\/ Because delta is a power of two, (distance * (double)delta) can always be computed exactly.\n+                return new RandomJumpsSpliterator(r.copyAndJump(distance * (double)delta), i, m, distance);\n+            }\n+\n+            public boolean tryAdvance(Consumer<? super RandomGenerator> consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    consumer.accept(generatingGenerator.copyAndJump(distance));\n+                    index = i + 1;\n+                    return true;\n+                }\n+                return false;\n+            }\n+\n+            public void forEachRemaining(Consumer<? super RandomGenerator> consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    index = f;\n+                    ArbitrarilyJumpableGenerator r = generatingGenerator;\n+                    do {\n+                        consumer.accept(r.copyAndJump(distance));\n+                    } while (++i < f);\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Spliterator for stream of generators of type RandomGenerator produced\n+         * by leaps.\n+         *\/\n+        static class RandomLeapsSpliterator extends RandomSupport.RandomSpliterator implements Spliterator<JumpableGenerator> {\n+            ArbitrarilyJumpableGenerator generatingGenerator;\n+            final double distance;\n+\n+            RandomLeapsSpliterator(ArbitrarilyJumpableGenerator generatingGenerator, long index, long fence, double distance) {\n+                super(index, fence);\n+                this.generatingGenerator = generatingGenerator; this.distance = distance;\n+            }\n+\n+            public Spliterator<JumpableGenerator> trySplit() {\n+                long i = index, delta = Long.highestOneBit((fence - i) - 1), m = i + delta;\n+                if (m <= i) return null;\n+                index = m;\n+                \/\/ Because delta is a power of two, (distance * (double)delta) can always be computed exactly.\n+                return new RandomLeapsSpliterator(generatingGenerator.copyAndJump(distance * (double)delta), i, m, distance);\n+            }\n+\n+            public boolean tryAdvance(Consumer<? super JumpableGenerator> consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    consumer.accept(generatingGenerator.copyAndJump(distance));\n+                    index = i + 1;\n+                    return true;\n+                }\n+                return false;\n+            }\n+\n+            public void forEachRemaining(Consumer<? super JumpableGenerator> consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    index = f;\n+                    ArbitrarilyJumpableGenerator r = generatingGenerator;\n+                    do {\n+                        consumer.accept(r.copyAndJump(distance));\n+                    } while (++i < f);\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Spliterator for stream of generators of type RandomGenerator produced\n+         * by arbitrary jumps.\n+         *\/\n+        static class RandomArbitraryJumpsSpliterator extends RandomSupport.RandomSpliterator implements Spliterator<ArbitrarilyJumpableGenerator> {\n+            ArbitrarilyJumpableGenerator generatingGenerator;\n+            final double distance;\n+\n+            RandomArbitraryJumpsSpliterator(ArbitrarilyJumpableGenerator generatingGenerator, long index, long fence, double distance) {\n+                super(index, fence);\n+                this.generatingGenerator = generatingGenerator; this.distance = distance;\n+            }\n+\n+            public Spliterator<ArbitrarilyJumpableGenerator> trySplit() {\n+                long i = index, delta = Long.highestOneBit((fence - i) - 1), m = i + delta;\n+                if (m <= i) return null;\n+                index = m;\n+                \/\/ Because delta is a power of two, (distance * (double)delta) can always be computed exactly.\n+                return new RandomArbitraryJumpsSpliterator(generatingGenerator.copyAndJump(distance * (double)delta), i, m, distance);\n+            }\n+\n+            public boolean tryAdvance(Consumer<? super ArbitrarilyJumpableGenerator> consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    consumer.accept(generatingGenerator.copyAndJump(distance));\n+                    index = i + 1;\n+                    return true;\n+                }\n+                return false;\n+            }\n+\n+            public void forEachRemaining(Consumer<? super ArbitrarilyJumpableGenerator> consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    index = f;\n+                    ArbitrarilyJumpableGenerator r = generatingGenerator;\n+                    do {\n+                        consumer.accept(r.copyAndJump(distance));\n+                    } while (++i < f);\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    \/**\n+     * This class provides much of the implementation of the\n+     * {@link SplittableGenerator} interface, to minimize the effort required to\n+     * implement this interface.\n+     *\n+     * <p> To implement a pseudorandom number generator, the programmer needs\n+     * only to extend this class and provide implementations for the methods\n+     * {@link RandomGenerator#nextInt() nextInt}(),\n+     * {@link RandomGenerator#nextLong() nextLong}(),\n+     * {@link SplittableGenerator#split(SplittableGenerator) split}(splittable).\n+     *\n+     * <p> (If the pseudorandom number generator also has the ability to jump\n+     * an arbitrary specified distance, then the programmer may wish to consider\n+     * instead extending the class {@link AbstractArbitrarilyJumpableGenerator}.\n+     * See also the class {@link AbstractSplittableWithBrineGenerator}.)\n+     *\n+     * <p> The programmer should generally provide at least three constructors:\n+     * one that takes no arguments, one that accepts a {@code long} seed value,\n+     * and one that accepts an array of seed {@code byte} values. This class\n+     * provides a public {@link RandomSupport#initialSeed() initialSeed}()\n+     * method that may be useful in initializing some static state from which to\n+     * derive defaults seeds for use by the no-argument constructor.\n+     *\n+     * <p> For the stream methods (such as {@link RandomGenerator#ints() ints}()\n+     * and {@link SplittableGenerator#splits() splits}()), this class provides\n+     * {@link Spliterator}-based implementations that allow parallel execution\n+     * when appropriate.\n+     *\n+     * <p> The documentation for each non-abstract method in this class\n+     * describes its implementation in detail. Each of these methods may be\n+     * overridden if the pseudorandom number generator being implemented\n+     * admits a more efficient implementation.\n+     *\n+     * @since 17\n+     * @hidden\n+     *\/\n+    public abstract static class AbstractSplittableGenerator extends AbstractSpliteratorGenerator implements SplittableGenerator {\n+\n+        \/*\n+         * Implementation Overview.\n+         *\n+         * This class provides most of the \"user API\" methods needed to\n+         * satisfy the interface SplittableGenerator.  Most of these methods\n+         * are in turn inherited from AbstractGenerator and the non-public class\n+         * AbstractSpliteratorGenerator; this class provides two versions of the\n+         * splits method and defines the spliterators necessary to support\n+         * them.\n+         *\n+         * File organization: First the non-public methods needed by the class\n+         * AbstractSpliteratorGenerator, then the main public methods, followed by some\n+         * custom spliterator classes.\n+         *\/\n+\n+        \/**\n+         * Explicit constructor.\n+         *\/\n+        protected AbstractSplittableGenerator() {\n+        }\n+\n+        public Spliterator.OfInt makeIntsSpliterator(long index, long fence, int origin, int bound) {\n+            return new RandomIntsSpliterator(this, index, fence, origin, bound);\n+        }\n+\n+        public Spliterator.OfLong makeLongsSpliterator(long index, long fence, long origin, long bound) {\n+            return new RandomLongsSpliterator(this, index, fence, origin, bound);\n+        }\n+\n+        public Spliterator.OfDouble makeDoublesSpliterator(long index, long fence, double origin, double bound) {\n+            return new RandomDoublesSpliterator(this, index, fence, origin, bound);\n+        }\n+\n+        Spliterator<SplittableGenerator> makeSplitsSpliterator(long index, long fence, SplittableGenerator source) {\n+            return new RandomSplitsSpliterator(source, index, fence, this);\n+        }\n+\n+        \/* ---------------- public methods ---------------- *\/\n+\n+        \/**\n+         * Implements the @code{split()} method as\n+         * {@link SplittableGenerator#split(SplittableGenerator) split}(this).\n+         *\n+         * @return the new {@link SplittableGenerator} instance\n+         *\/\n+        public SplittableGenerator split() {\n+            return this.split(this);\n+        }\n+\n+        \/\/ Stream methods for splittings\n+\n+        @Override\n+        public Stream<SplittableGenerator> splits() {\n+            return this.splits(Long.MAX_VALUE, this);\n+        }\n+\n+        @Override\n+        public Stream<SplittableGenerator> splits(long streamSize) {\n+            return this.splits(streamSize, this);\n+        }\n+\n+        @Override\n+        public Stream<SplittableGenerator> splits(SplittableGenerator source) {\n+            return this.splits(Long.MAX_VALUE, source);\n+        }\n+\n+        @Override\n+        public Stream<SplittableGenerator> splits(long streamSize, SplittableGenerator source) {\n+            RandomSupport.checkStreamSize(streamSize);\n+            return StreamSupport.stream(makeSplitsSpliterator(0L, streamSize, source), false);\n+        }\n+\n+        \/**\n+         * Spliterator for int streams. We multiplex the four int versions into\n+         * one class by treating a bound less than origin as unbounded, and also\n+         * by treating \"infinite\" as equivalent to\n+         * {@link Long#MAX_VALUE Long.MAX_VALUE}. For splits, it uses the\n+         * standard divide-by-two approach. The long and double versions of this\n+         * class are identical except for types.\n+         *\/\n+        static class RandomIntsSpliterator extends RandomSupport.RandomSpliterator implements Spliterator.OfInt {\n+            final SplittableGenerator generatingGenerator;\n+            final int origin;\n+            final int bound;\n+\n+            RandomIntsSpliterator(SplittableGenerator generatingGenerator, long index, long fence, int origin, int bound) {\n+                super(index, fence);\n+                this.generatingGenerator = generatingGenerator;\n+                this.origin = origin; this.bound = bound;\n+            }\n+\n+            public Spliterator.OfInt trySplit() {\n+                long i = index, m = (i + fence) >>> 1;\n+                if (m <= i) return null;\n+                index = m;\n+                return new RandomIntsSpliterator(generatingGenerator.split(), i, m, origin, bound);\n+            }\n+\n+            public boolean tryAdvance(IntConsumer consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    consumer.accept(RandomSupport.boundedNextInt(generatingGenerator, origin, bound));\n+                    index = i + 1;\n+                    return true;\n+                }\n+                else return false;\n+            }\n+\n+            public void forEachRemaining(IntConsumer consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    index = f;\n+                    RandomGenerator r = generatingGenerator;\n+                    int o = origin, b = bound;\n+                    do {\n+                        consumer.accept(RandomSupport.boundedNextInt(r, o, b));\n+                    } while (++i < f);\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Spliterator for long streams.\n+         *\/\n+        static class RandomLongsSpliterator extends RandomSupport.RandomSpliterator implements Spliterator.OfLong {\n+            final SplittableGenerator generatingGenerator;\n+            final long origin;\n+            final long bound;\n+\n+            RandomLongsSpliterator(SplittableGenerator generatingGenerator, long index, long fence, long origin, long bound) {\n+                super(index, fence);\n+                this.generatingGenerator = generatingGenerator;\n+                this.origin = origin; this.bound = bound;\n+            }\n+\n+            public Spliterator.OfLong trySplit() {\n+                long i = index, m = (i + fence) >>> 1;\n+                if (m <= i) return null;\n+                index = m;\n+                return new RandomLongsSpliterator(generatingGenerator.split(), i, m, origin, bound);\n+            }\n+\n+            public boolean tryAdvance(LongConsumer consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    consumer.accept(RandomSupport.boundedNextLong(generatingGenerator, origin, bound));\n+                    index = i + 1;\n+                    return true;\n+                }\n+                else return false;\n+            }\n+\n+            public void forEachRemaining(LongConsumer consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    index = f;\n+                    RandomGenerator r = generatingGenerator;\n+                    long o = origin, b = bound;\n+                    do {\n+                        consumer.accept(RandomSupport.boundedNextLong(r, o, b));\n+                    } while (++i < f);\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Spliterator for double streams.\n+         *\/\n+        static class RandomDoublesSpliterator extends RandomSupport.RandomSpliterator implements Spliterator.OfDouble {\n+            final SplittableGenerator generatingGenerator;\n+            final double origin;\n+            final double bound;\n+\n+            RandomDoublesSpliterator(SplittableGenerator generatingGenerator, long index, long fence, double origin, double bound) {\n+                super(index, fence);\n+                this.generatingGenerator = generatingGenerator;\n+                this.origin = origin; this.bound = bound;\n+            }\n+\n+            public Spliterator.OfDouble trySplit() {\n+                long i = index, m = (i + fence) >>> 1;\n+                if (m <= i) return null;\n+                index = m;\n+                return new RandomDoublesSpliterator(generatingGenerator.split(), i, m, origin, bound);\n+            }\n+\n+            public boolean tryAdvance(DoubleConsumer consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    consumer.accept(RandomSupport.boundedNextDouble(generatingGenerator, origin, bound));\n+                    index = i + 1;\n+                    return true;\n+                }\n+                else return false;\n+            }\n+\n+            public void forEachRemaining(DoubleConsumer consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    index = f;\n+                    RandomGenerator r = generatingGenerator;\n+                    double o = origin, b = bound;\n+                    do {\n+                        consumer.accept(RandomSupport.boundedNextDouble(r, o, b));\n+                    } while (++i < f);\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Spliterator for stream of generators of type SplittableGenerator. We\n+         * multiplex the two versions into one class by treating \"infinite\" as\n+         * equivalent to Long.MAX_VALUE. For splits, it uses the standard\n+         * divide-by-two approach.\n+         *\/\n+        static class RandomSplitsSpliterator extends RandomSpliterator implements Spliterator<SplittableGenerator> {\n+            final SplittableGenerator generatingGenerator;\n+            final SplittableGenerator constructingGenerator;\n+\n+            RandomSplitsSpliterator(SplittableGenerator generatingGenerator,\n+                                    long index, long fence,\n+                                    SplittableGenerator constructingGenerator) {\n+                super(index, fence);\n+                this.generatingGenerator = generatingGenerator;\n+                this.constructingGenerator = constructingGenerator;\n+            }\n+\n+            public Spliterator<SplittableGenerator> trySplit() {\n+                long i = index, m = (i + fence) >>> 1;\n+                if (m <= i) return null;\n+                index = m;\n+                return new RandomSplitsSpliterator(generatingGenerator.split(), i, m, constructingGenerator);\n+            }\n+\n+            public boolean tryAdvance(Consumer<? super SplittableGenerator> consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    consumer.accept(constructingGenerator.split(generatingGenerator));\n+                    index = i + 1;\n+                    return true;\n+                }\n+                else return false;\n+            }\n+\n+            public void forEachRemaining(Consumer<? super SplittableGenerator> consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    index = f;\n+                    SplittableGenerator c = constructingGenerator;\n+                    SplittableGenerator r = generatingGenerator;\n+                    do {\n+                        consumer.accept(c.split(r));\n+                    } while (++i < f);\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    \/**\n+     * This class provides much of the implementation of the\n+     * {@link SplittableGenerator} interface, to minimize the effort required to\n+     * implement this interface. It is similar to the class\n+     * {@link AbstractSplittableGenerator} but makes use of the brine technique\n+     * for ensuring that distinct generators created by a single call to a\n+     * {@link SplittableGenerator#splits() splits}() method have distinct state\n+     * cycles.\n+     *\n+     * <p> To implement a pseudorandom number generator, the programmer needs\n+     * only to extend this class and provide implementations for the methods\n+     * {@link RandomGenerator#nextInt() nextInt}(),\n+     * {@link RandomGenerator#nextLong() nextLong}(),\n+     * {@link RandomSplitsSpliteratorWithSalt#split(SplittableGenerator, long) split}(splittable, brine).\n+     *\n+     * <p> The programmer should generally provide at least three constructors:\n+     * one that takes no arguments, one that accepts a {@code long} seed value,\n+     * and one that accepts an array of seed {@code byte} values. This class\n+     * provides a public {@link RandomSupport#initialSeed() initialSeed}()\n+     * method that may be useful in initializing some static state from which to\n+     * derive defaults seeds for use by the no-argument constructor.\n+     *\n+     * <p> For the stream methods (such as {@link RandomGenerator#ints() ints}()\n+     * and {@link SplittableGenerator#splits() splits}()), this class provides\n+     * {@link Spliterator}-based implementations that allow parallel execution\n+     * when appropriate.\n+     *\n+     * <p> The documentation for each non-abstract method in this class\n+     * describes its implementation in detail. Each of these methods may be\n+     * overridden if the pseudorandom number generator being implemented\n+     * admits a more efficient implementation.\n+     *\n+     * @since 17\n+     * @hidden\n+     *\/\n+    public abstract static class AbstractSplittableWithBrineGenerator\n+            extends AbstractSplittableGenerator {\n+\n+        \/*\n+         * Implementation Overview.\n+         *\n+         * This class provides most of the \"user API\" methods needed to\n+         * satisfy the interface SplittableGenerator.  Most of these methods\n+         * are in turn inherited from AbstractSplittableGenerator and the non-public class\n+         * AbstractSpliteratorGenerator; this class provides four versions of the\n+         * splits method and defines the spliterators necessary to support\n+         * them.\n+         *\n+         * File organization: First the non-public methods needed by the class\n+         * AbstractSplittableWithBrineGenerator, then the main public methods,\n+         * followed by some custom spliterator classes needed for stream methods.\n+         *\/\n+\n+        \/**\n+         * Explicit constructor.\n+         *\/\n+        protected AbstractSplittableWithBrineGenerator() {\n+        }\n+\n+        \/\/ The salt consists groups of bits each SALT_SHIFT in size, starting from\n+        \/\/ the left-hand (high-order) end of the word.  We can regard them as\n+        \/\/ digits base (1 << SALT_SHIFT).  If SALT_SHIFT does not divide 64\n+        \/\/ evenly, then any leftover bits at the low end of the word are zero.\n+        \/\/ The lowest digit of the salt is set to the largest possible digit\n+        \/\/ (all 1-bits, or ((1 << SALT_SHIFT) - 1)); all other digits are set\n+        \/\/ to a randomly chosen value less than that largest possible digit.\n+        \/\/ The salt may be shifted left by SALT_SHIFT any number of times.\n+        \/\/ If any salt remains in the word, its right-hand end can be identified\n+        \/\/ by searching from left to right for an occurrence of a digit that is\n+        \/\/ all 1-bits (not that we ever do that; this is simply a proof that one\n+        \/\/ can identify the boundary between the salt and the index if any salt\n+        \/\/ remains in the word).  The idea is that before computing the bitwise OR\n+        \/\/ of an index and the salt, one can first check to see whether the\n+        \/\/ bitwise AND is nonzero; if so, one can shift the salt left by\n+        \/\/ SALT_SHIFT and try again.  In this way, when the bitwise OR is\n+        \/\/ computed, if the salt is nonzero then its rightmost 1-bit is to the\n+        \/\/ left of the leftmost 1-bit of the index.\n+\n+        \/\/ We need 2 <= SALT_SHIFT <= 63 (3 through 8 are good values; 4 is probably best)\n+        static final int SALT_SHIFT = 4;\n+\n+        \/\/ Methods required by class AbstractSpliteratorGenerator (override)\n+        Spliterator<SplittableGenerator> makeSplitsSpliterator(long index, long fence, SplittableGenerator source) {\n+            \/\/ This little algorithm to generate a new salt value is carefully\n+            \/\/ designed to work even if SALT_SHIFT does not evenly divide 64\n+            \/\/ (the number of bits in a long value).\n+            long bits = nextLong();\n+            long multiplier = (1 << SALT_SHIFT) - 1;\n+            long salt = multiplier << (64 - SALT_SHIFT);\n+            while ((salt & multiplier) != 0) {\n+                long digit = Math.multiplyHigh(bits, multiplier);\n+                salt = (salt >>> SALT_SHIFT) | (digit << (64 - SALT_SHIFT));\n+                bits *= multiplier;\n+            }\n+            \/\/ This is the point at which newly generated salt gets injected into\n+            \/\/ the root of a newly created brine-generating splits-spliterator.\n+            return new RandomSplitsSpliteratorWithSalt(source, index, fence, this, salt);\n+        }\n+\n+        \/* ---------------- public methods ---------------- *\/\n+\n+        \/\/ Stream methods for splitting\n+\n+        \/**\n+         * Constructs and returns a new instance of\n+         * {@link AbstractSplittableWithBrineGenerator} that shares no mutable\n+         * state with this instance. However, with very high probability, the\n+         * set of values collectively generated by the two objects should have\n+         * the same statistical properties as if the same quantity of values\n+         * were generated by a single thread using a single may be\n+         * {@link AbstractSplittableWithBrineGenerator} object. Either or both\n+         * of the two objects further split using the\n+         * {@link SplittableGenerator#split() split}() method, and the same\n+         * expected statistical properties apply to the entire set of generators\n+         * constructed by such recursive splitting.\n+         *\n+         * @param brine a long value, of which the low 63 bits provide a unique id\n+         * among calls to this method for constructing a single series of Generator objects.\n+         *\n+         * @return the new {@code AbstractSplittableWithBrineGenerator} instance\n+         *\/\n+        public SplittableGenerator split(long brine) {\n+            return this.split(this, brine);\n+        }\n+\n+        @Override\n+        public SplittableGenerator split(SplittableGenerator source) {\n+            \/\/ It's a one-off: supply randomly chosen brine\n+            return this.split(source, source.nextLong());\n+        }\n+\n+        public abstract SplittableGenerator split(SplittableGenerator source, long brine);\n+\n+\n+        \/* ---------------- spliterator ---------------- *\/\n+        \/**\n+         * Alternate spliterator for stream of generators of type\n+         * SplittableGenerator. We multiplex the two versions into one class by\n+         * treating \"infinite\" as equivalent to Long.MAX_VALUE. For splits, it\n+         * uses the standard divide-by-two approach.\n+         *\n+         * <p> This differs from\n+         * {@link AbstractSplittableGenerator.RandomSplitsSpliterator} in that it\n+         * provides a brine argument (a mixture of salt and an index) when\n+         * calling the {@link SplittableGenerator#split() split}() method.\n+         *\/\n+        static class RandomSplitsSpliteratorWithSalt\n+                extends RandomSpliterator implements Spliterator<SplittableGenerator> {\n+\n+            final SplittableGenerator generatingGenerator;\n+            final AbstractSplittableWithBrineGenerator constructingGenerator;\n+            long salt;\n+\n+            \/\/ Important invariant: 0 <= index <= fence\n+\n+            \/\/ Important invariant: if salt and index are both nonzero,\n+            \/\/ the rightmost 1-bit of salt is to the left of the leftmost 1-bit of index.\n+            \/\/ If necessary, the salt can be leftshifted by SALT_SHIFT as many times as\n+            \/\/ necessary to maintain the invariant.\n+\n+            RandomSplitsSpliteratorWithSalt(SplittableGenerator generatingGenerator, long index, long fence,\n+                                            AbstractSplittableWithBrineGenerator constructingGenerator, long salt) {\n+                super(index, fence);\n+                this.generatingGenerator = generatingGenerator;\n+                this.constructingGenerator = constructingGenerator;\n+                while ((salt != 0) && (Long.compareUnsigned(salt & -salt, index) <= 0)) {\n+                    salt = salt << SALT_SHIFT;\n+                }\n+                this.salt = salt;\n+            }\n+\n+            public Spliterator<SplittableGenerator> trySplit() {\n+                long i = index, m = (i + fence) >>> 1;\n+                if (m <= i) return null;\n+                RandomSplitsSpliteratorWithSalt result =\n+                        new RandomSplitsSpliteratorWithSalt(generatingGenerator.split(), i, m, constructingGenerator, salt);\n+                index = m;\n+                while ((salt != 0) && (Long.compareUnsigned(salt & -salt, index) <= 0)) {\n+                    salt = salt << SALT_SHIFT;\n+                }\n+                return result;\n+            }\n+\n+            public boolean tryAdvance(Consumer<? super SplittableGenerator> consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    consumer.accept(constructingGenerator.split(generatingGenerator, salt | i));\n+                    ++i;\n+                    index = i;\n+                    if ((i & salt) != 0) salt <<= SALT_SHIFT;\n+                    return true;\n+                }\n+                return false;\n+            }\n+\n+            public void forEachRemaining(Consumer<? super SplittableGenerator> consumer) {\n+                Objects.requireNonNull(consumer);\n+                long i = index, f = fence;\n+                if (i < f) {\n+                    index = f;\n+                    AbstractSplittableWithBrineGenerator c = constructingGenerator;\n+                    SplittableGenerator r = generatingGenerator;\n+                    do {\n+                        consumer.accept(c.split(r, salt | i));\n+                        ++i;\n+                        if ((i & salt) != 0) salt <<= SALT_SHIFT;\n+                    } while (i < f);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Implementation support for modified-ziggurat implementation of\n+     * nextExponential()\n+     *\n+     * <p> This Java class was generated automatically by a program\n+     * `create_ziggurat_tables.c`.\n+     *\n+     * <p> Fraction of the area under the curve that lies outside the layer\n+     * boxes: 0.0156 Fraction of non-box area that lies in the tail of the\n+     * distribution: 0.0330\n+     *\/\n+    static final class DoubleZigguratTables {\n+\n+        static final int exponentialNumberOfLayers = 252;\n+        static final int exponentialLayerMask = 0xff;\n+        static final int exponentialAliasMask = 0xff;\n+        static final int exponentialSignCorrectionMask = 0xff;\n+        static final double exponentialX0 = 7.56927469414806264;\n+        static final long exponentialConvexMargin = 853965788476313645L;   \/\/ unscaled convex margin = 0.0926\n+\n+        \/\/ exponential_X[i] = length of ziggurat layer i for exponential distribution, scaled by 2**(-63)\n+        static final double[] exponentialX = {      \/\/ 253 entries, which is exponential_number_of_layers+1\n+                8.2066240675348816e-19,  7.3973732351607284e-19,  6.9133313377915293e-19,  6.5647358820964533e-19,\n+                6.2912539959818508e-19,  6.0657224129604964e-19,  5.8735276103737269e-19,  5.7058850528536941e-19,\n+                5.5570945691622390e-19,  5.4232438903743953e-19,  5.3015297696508776e-19,  5.1898739257708062e-19,\n+                5.0866922617998330e-19,  4.9907492938796469e-19,  4.9010625894449536e-19,  4.8168379010649187e-19,\n+                4.7374238653644714e-19,  4.6622795807196824e-19,  4.5909509017784048e-19,  4.5230527790658154e-19,\n+                4.4582558816353960e-19,  4.3962763126368381e-19,  4.3368675967106470e-19,  4.2798143618469714e-19,\n+                4.2249273027064889e-19,  4.1720391253464110e-19,  4.1210012522465616e-19,  4.0716811225869233e-19,\n+                4.0239599631006903e-19,  3.9777309342877357e-19,  3.9328975785334499e-19,  3.8893725129310323e-19,\n+                3.8470763218720385e-19,  3.8059366138180143e-19,  3.7658872138544730e-19,  3.7268674692030177e-19,\n+                3.6888216492248162e-19,  3.6516984248800068e-19,  3.6154504153287473e-19,  3.5800337915318032e-19,\n+                3.5454079284533432e-19,  3.5115350988784242e-19,  3.4783802030030962e-19,  3.4459105288907336e-19,\n+                3.4140955396563316e-19,  3.3829066838741162e-19,  3.3523172262289001e-19,  3.3223020958685874e-19,\n+                3.2928377502804472e-19,  3.2639020528202049e-19,  3.2354741622810815e-19,  3.2075344331080789e-19,\n+                3.1800643250478609e-19,  3.1530463211820845e-19,  3.1264638534265134e-19,  3.1003012346934211e-19,\n+                3.0745435970137301e-19,  3.0491768350005559e-19,  3.0241875541094565e-19,  2.9995630232144550e-19,\n+                2.9752911310742592e-19,  2.9513603463113224e-19,  2.9277596805684267e-19,  2.9044786545442563e-19,\n+                2.8815072666416712e-19,  2.8588359639906928e-19,  2.8364556156331615e-19,  2.8143574876779799e-19,\n+                2.7925332202553125e-19,  2.7709748061152879e-19,  2.7496745707320232e-19,  2.7286251537873397e-19,\n+                2.7078194919206054e-19,  2.6872508026419050e-19,  2.6669125693153442e-19,  2.6467985271278891e-19,\n+                2.6269026499668434e-19,  2.6072191381359757e-19,  2.5877424068465143e-19,  2.5684670754248168e-19,\n+                2.5493879571835479e-19,  2.5305000499077481e-19,  2.5117985269112710e-19,  2.4932787286227806e-19,\n+                2.4749361546638660e-19,  2.4567664563848669e-19,  2.4387654298267842e-19,  2.4209290090801527e-19,\n+                2.4032532600140538e-19,  2.3857343743505147e-19,  2.3683686640614648e-19,  2.3511525560671253e-19,\n+                2.3340825872163284e-19,  2.3171553995306794e-19,  2.3003677356958333e-19,  2.2837164347843482e-19,\n+                2.2671984281957174e-19,  2.2508107358001938e-19,  2.2345504622739592e-19,  2.2184147936140775e-19,\n+                2.2024009938224424e-19,  2.1865064017486842e-19,  2.1707284280826716e-19,  2.1550645524878675e-19,\n+                2.1395123208673778e-19,  2.1240693427550640e-19,  2.1087332888245875e-19,  2.0935018885097035e-19,\n+                2.0783729277295508e-19,  2.0633442467130712e-19,  2.0484137379170616e-19,  2.0335793440326865e-19,\n+                2.0188390560756090e-19,  2.0041909115551697e-19,  1.9896329927183254e-19,  1.9751634248643090e-19,\n+                1.9607803747261946e-19,  1.9464820489157862e-19,  1.9322666924284314e-19,  1.9181325872045647e-19,\n+                1.9040780507449479e-19,  1.8901014347767504e-19,  1.8762011239677479e-19,  1.8623755346860768e-19,\n+                1.8486231138030984e-19,  1.8349423375370566e-19,  1.8213317103353295e-19,  1.8077897637931708e-19,\n+                1.7943150556069476e-19,  1.7809061685599652e-19,  1.7675617095390567e-19,  1.7542803085801941e-19,\n+                1.7410606179414531e-19,  1.7279013112017240e-19,  1.7148010823836362e-19,  1.7017586450992059e-19,\n+                1.6887727317167824e-19,  1.6758420925479093e-19,  1.6629654950527621e-19,  1.6501417230628659e-19,\n+                1.6373695760198277e-19,  1.6246478682288560e-19,  1.6119754281258616e-19,  1.5993510975569615e-19,\n+                1.5867737310692309e-19,  1.5742421952115544e-19,  1.5617553678444595e-19,  1.5493121374578016e-19,\n+                1.5369114024951992e-19,  1.5245520706841019e-19,  1.5122330583703858e-19,  1.4999532898563561e-19,\n+                1.4877116967410352e-19,  1.4755072172615974e-19,  1.4633387956347966e-19,  1.4512053813972103e-19,\n+                1.4391059287430991e-19,  1.4270393958586506e-19,  1.4150047442513381e-19,  1.4030009380730888e-19,\n+                1.3910269434359025e-19,  1.3790817277185197e-19,  1.3671642588626657e-19,  1.3552735046573446e-19,\n+                1.3434084320095729e-19,  1.3315680061998685e-19,  1.3197511901207148e-19,  1.3079569434961214e-19,\n+                1.2961842220802957e-19,  1.2844319768333099e-19,  1.2726991530715219e-19,  1.2609846895903523e-19,\n+                1.2492875177568625e-19,  1.2376065605693940e-19,  1.2259407316813331e-19,  1.2142889343858445e-19,\n+                1.2026500605581765e-19,  1.1910229895518744e-19,  1.1794065870449425e-19,  1.1677997038316715e-19,\n+                1.1562011745554883e-19,  1.1446098163777869e-19,  1.1330244275772562e-19,  1.1214437860737343e-19,\n+                1.1098666478700728e-19,  1.0982917454048923e-19,  1.0867177858084351e-19,  1.0751434490529747e-19,\n+                1.0635673859884002e-19,  1.0519882162526621e-19,  1.0404045260457141e-19,  1.0288148657544097e-19,\n+                1.0172177474144965e-19,  1.0056116419943559e-19,  9.9399497648346677e-20,  9.8236613076667446e-20,\n+                9.7072343426320094e-20,  9.5906516230690634e-20,  9.4738953224154196e-20,  9.3569469920159036e-20,\n+                9.2397875154569468e-20,  9.1223970590556472e-20,  9.0047550180852874e-20,  8.8868399582647627e-20,\n+                8.7686295519767450e-20,  8.6501005086071005e-20,  8.5312284983141187e-20,  8.4119880684385214e-20,\n+                8.2923525516513420e-20,  8.1722939648034506e-20,  8.0517828972839211e-20,  7.9307883875099226e-20,\n+                7.8092777859524425e-20,  7.6872166028429042e-20,  7.5645683383965122e-20,  7.4412942930179128e-20,\n+                7.3173533545093332e-20,  7.1927017587631075e-20,  7.0672928197666785e-20,  6.9410766239500362e-20,\n+                6.8139996829256425e-20,  6.6860045374610234e-20,  6.5570293040210081e-20,  6.4270071533368528e-20,\n+                6.2958657080923559e-20,  6.1635263438143136e-20,  6.0299033732151700e-20,  5.8949030892850181e-20,\n+                5.7584226359885930e-20,  5.6203486669597397e-20,  5.4805557413499315e-20,  5.3389043909003295e-20,\n+                5.1952387717989917e-20,  5.0493837866338355e-20,  4.9011415222629489e-20,  4.7502867933366117e-20,\n+                4.5965615001265455e-20,  4.4396673897997565e-20,  4.2792566302148588e-20,  4.1149193273430015e-20,\n+                3.9461666762606287e-20,  3.7724077131401685e-20,  3.5929164086204360e-20,  3.4067836691100565e-20,\n+                3.2128447641564046e-20,  3.0095646916399994e-20,  2.7948469455598328e-20,  2.5656913048718645e-20,\n+                2.3175209756803909e-20,  2.0426695228251291e-20,  1.7261770330213485e-20,  1.3281889259442578e-20,\n+                0.0000000000000000e+00 };\n+\n+        \/\/ exponential_Y[i] = value of the exponential distribution function at exponential_X[i], scaled by 2**(-63)\n+        static final double[] exponentialY = {      \/\/ 253 entries, which is exponential_number_of_layers+1\n+                5.5952054951127360e-23,  1.1802509982703313e-22,  1.8444423386735829e-22,  2.5439030466698309e-22,\n+                3.2737694311509334e-22,  4.0307732132706715e-22,  4.8125478319495115e-22,  5.6172914896583308e-22,\n+                6.4435820540443526e-22,  7.2902662343463681e-22,  8.1563888456321941e-22,  9.0411453683482223e-22,\n+                9.9438488486399206e-22,  1.0863906045969114e-21,  1.1800799775461269e-21,  1.2754075534831208e-21,\n+                1.3723331176377290e-21,  1.4708208794375214e-21,  1.5708388257440445e-21,  1.6723581984374566e-21,\n+                1.7753530675030514e-21,  1.8797999785104595e-21,  1.9856776587832504e-21,  2.0929667704053244e-21,\n+                2.2016497009958240e-21,  2.3117103852306179e-21,  2.4231341516125464e-21,  2.5359075901420891e-21,\n+                2.6500184374170538e-21,  2.7654554763660391e-21,  2.8822084483468604e-21,  3.0002679757547711e-21,\n+                3.1196254936130377e-21,  3.2402731888801749e-21,  3.3622039464187092e-21,  3.4854113007409036e-21,\n+                3.6098893927859475e-21,  3.7356329310971768e-21,  3.8626371568620053e-21,  3.9908978123552837e-21,\n+                4.1204111123918948e-21,  4.2511737184488913e-21,  4.3831827151633737e-21,  4.5164355889510656e-21,\n+                4.6509302085234806e-21,  4.7866648071096003e-21,  4.9236379662119969e-21,  5.0618486007478993e-21,\n+                5.2012959454434732e-21,  5.3419795423648946e-21,  5.4838992294830959e-21,  5.6270551301806347e-21,\n+                5.7714476436191935e-21,  5.9170774358950678e-21,  6.0639454319177027e-21,  6.2120528079531677e-21,\n+                6.3614009847804375e-21,  6.5119916214136427e-21,  6.6638266093481696e-21,  6.8169080672926277e-21,\n+                6.9712383363524377e-21,  7.1268199756340822e-21,  7.2836557582420336e-21,  7.4417486676430174e-21,\n+                7.6011018943746355e-21,  7.7617188330775411e-21,  7.9236030798322572e-21,  8.0867584297834842e-21,\n+                8.2511888750363333e-21,  8.4168986028103258e-21,  8.5838919938383098e-21,  8.7521736209986459e-21,\n+                8.9217482481700712e-21,  9.0926208292996504e-21,  9.2647965076751277e-21,  9.4382806153938292e-21,\n+                9.6130786730210328e-21,  9.7891963894314161e-21,  9.9666396618278840e-21,  1.0145414575932636e-20,\n+                1.0325527406345955e-20,  1.0506984617068672e-20,  1.0689792862184811e-20,  1.0873958986701341e-20,\n+                1.1059490027542400e-20,  1.1246393214695825e-20,  1.1434675972510121e-20,  1.1624345921140471e-20,\n+                1.1815410878142659e-20,  1.2007878860214202e-20,  1.2201758085082226e-20,  1.2397056973538040e-20,\n+                1.2593784151618565e-20,  1.2791948452935152e-20,  1.2991558921150600e-20,  1.3192624812605428e-20,\n+                1.3395155599094805e-20,  1.3599160970797774e-20,  1.3804650839360727e-20,  1.4011635341137284e-20,\n+                1.4220124840587164e-20,  1.4430129933836705e-20,  1.4641661452404201e-20,  1.4854730467093280e-20,\n+                1.5069348292058084e-20,  1.5285526489044050e-20,  1.5503276871808626e-20,  1.5722611510726402e-20,\n+                1.5943542737583543e-20,  1.6166083150566702e-20,  1.6390245619451956e-20,  1.6616043290999594e-20,\n+                1.6843489594561079e-20,  1.7072598247904713e-20,  1.7303383263267072e-20,  1.7535858953637607e-20,\n+                1.7770039939284241e-20,  1.8005941154528286e-20,  1.8243577854777398e-20,  1.8482965623825808e-20,\n+                1.8724120381431627e-20,  1.8967058391181452e-20,  1.9211796268653192e-20,  1.9458350989888484e-20,\n+                1.9706739900186868e-20,  1.9956980723234356e-20,  2.0209091570579904e-20,  2.0463090951473895e-20,\n+                2.0718997783083593e-20,  2.0976831401101350e-20,  2.1236611570762130e-20,  2.1498358498287976e-20,\n+                2.1762092842777868e-20,  2.2027835728562592e-20,  2.2295608758045219e-20,  2.2565434025049041e-20,\n+                2.2837334128696004e-20,  2.3111332187840010e-20,  2.3387451856080863e-20,  2.3665717337386111e-20,\n+                2.3946153402349610e-20,  2.4228785405117410e-20,  2.4513639301013211e-20,  2.4800741664897764e-20,\n+                2.5090119710298442e-20,  2.5381801309347597e-20,  2.5675815013570500e-20,  2.5972190075566336e-20,\n+                2.6270956471628253e-20,  2.6572144925351523e-20,  2.6875786932281841e-20,  2.7181914785659148e-20,\n+                2.7490561603315974e-20,  2.7801761355793055e-20,  2.8115548895739172e-20,  2.8431959988666534e-20,\n+                2.8751031345137833e-20,  2.9072800654466307e-20,  2.9397306620015486e-20,  2.9724588996191657e-20,\n+                3.0054688627228112e-20,  3.0387647487867642e-20,  3.0723508726057078e-20,  3.1062316707775905e-20,\n+                3.1404117064129991e-20,  3.1748956740850969e-20,  3.2096884050352357e-20,  3.2447948726504914e-20,\n+                3.2802201982306013e-20,  3.3159696570631373e-20,  3.3520486848272230e-20,  3.3884628843476888e-20,\n+                3.4252180327233346e-20,  3.4623200888548644e-20,  3.4997752014001677e-20,  3.5375897171869060e-20,\n+                3.5757701901149035e-20,  3.6143233905835799e-20,  3.6532563154827400e-20,  3.6925761987883572e-20,\n+                3.7322905228086981e-20,  3.7724070301302117e-20,  3.8129337363171041e-20,  3.8538789434235234e-20,\n+                3.8952512543827862e-20,  3.9370595883442399e-20,  3.9793131970351439e-20,  4.0220216822325769e-20,\n+                4.0651950144388133e-20,  4.1088435528630944e-20,  4.1529780668232712e-20,  4.1976097586926582e-20,\n+                4.2427502885307452e-20,  4.2884118005513604e-20,  4.3346069515987453e-20,  4.3813489418210257e-20,\n+                4.4286515477520838e-20,  4.4765291580372353e-20,  4.5249968120658306e-20,  4.5740702418054417e-20,\n+                4.6237659171683015e-20,  4.6741010952818368e-20,  4.7250938740823415e-20,  4.7767632507051219e-20,\n+                4.8291291852069895e-20,  4.8822126702292804e-20,  4.9360358072933852e-20,  4.9906218905182021e-20,\n+                5.0459954986625539e-20,  5.1021825965285324e-20,  5.1592106469178258e-20,  5.2171087345169234e-20,\n+                5.2759077033045284e-20,  5.3356403093325858e-20,  5.3963413910399511e-20,  5.4580480596259246e-20,\n+                5.5207999124535584e-20,  5.5846392729873830e-20,  5.6496114614193770e-20,  5.7157651009290713e-20,\n+                5.7831524654956632e-20,  5.8518298763794323e-20,  5.9218581558791713e-20,  5.9933031488338700e-20,\n+                6.0662363246796887e-20,  6.1407354758435000e-20,  6.2168855320499763e-20,  6.2947795150103727e-20,\n+                6.3745196643214394e-20,  6.4562187737537985e-20,  6.5400017881889097e-20,  6.6260077263309343e-20,\n+                6.7143920145146620e-20,  6.8053293447301698e-20,  6.8990172088133000e-20,  6.9956803158564498e-20,\n+                7.0955761794878430e-20,  7.1990022788945080e-20,  7.3063053739105458e-20,  7.4178938266266893e-20,\n+                7.5342542134173124e-20,  7.6559742171142969e-20,  7.7837749863412850e-20,  7.9185582674029512e-20,\n+                8.0614775537353300e-20,  8.2140502769818073e-20,  8.3783445978280519e-20,  8.5573129249678161e-20,\n+                8.7554459669590100e-20,  8.9802388057706877e-20,  9.2462471421151086e-20,  9.5919641344951721e-20,\n+                1.0842021724855044e-19 };\n+\n+        \/\/ alias_threshold[j] is a threshold for the probability mass function that has been\n+        \/\/ scaled by (2**64 - 1), translated by -(2**63), and represented as a long value;\n+        \/\/ in this way it can be directly compared to a randomly chosen long value.\n+        static final long[] exponentialAliasThreshold = {    \/\/ 256 entries\n+                9223372036854775807L,  1623796909450829958L,  2664290944894281002L,  7387971354164055035L,\n+                6515064486552722205L,  8840508362680707094L,  6099647593382923818L,  7673130333659514446L,\n+                6220332867583438718L,  5045979640552814279L,  4075305837223956071L,  3258413672162525964L,\n+                2560664887087763045L,  1957224924672900129L,  1429800935350578000L,   964606309710808688L,\n+                551043923599587587L,   180827629096889062L,  -152619738120023316L,  -454588624410291246L,\n+                -729385126147774679L,  -980551509819444511L, -1211029700667463575L, -1423284293868546830L,\n+                -1619396356369066372L, -1801135830956194794L, -1970018048575634032L, -2127348289059688469L,\n+                -2274257249303687482L, -2411729520096654942L, -2540626634159182211L, -2661705860113406183L,\n+                -2775635634532464842L, -2883008316030448462L, -2984350790383654449L, -3080133339198118132L,\n+                -3170777096303105047L, -3256660348483802362L, -3338123885075135933L, -3415475560473298752L,\n+                -3488994201966444258L, -3558932970354456420L, -3625522261068040742L, -3688972217741991689L,\n+                -3749474917563779627L, -3807206277531072172L, -3862327722496826830L, -3914987649156779312L,\n+                -3965322714631864882L, -4013458973776911635L, -4059512885612766613L, -4103592206186240662L,\n+                -4145796782586127736L, -4186219260694346585L, -4224945717447274810L, -4262056226866285147L,\n+                -4297625367836519229L, -4331722680528536958L, -4364413077437472159L, -4395757214229421760L,\n+                -4425811824915119137L, -4454630025296932322L, -4482261588141294467L, -4508753193105275908L,\n+                -4534148654077813412L, -4558489126279965349L, -4581813295192216486L, -4604157549138252679L,\n+                -4625556137145250151L, -4646041313519109096L, -4665643470413305673L, -4684391259530342697L,\n+                -4702311703971745066L, -4719430301145102986L, -4735771117539946027L, -4751356876102086987L,\n+                -4766209036859150188L, -4780347871385996716L, -4793792531638885869L, -4806561113635132333L,\n+                -4818670716409312334L, -4830137496634465358L, -4840976719260854030L, -4851202804490332239L,\n+                -4860829371376476047L, -4869869278311650511L, -4878334660640770576L, -4886236965617426832L,\n+                -4893586984900802224L, -4900394884772702384L, -4906670234238884945L, -4912422031164489009L,\n+                -4917658726580135697L, -4922388247283531793L, -4926618016851042065L, -4930354975163351025L,\n+                -4933605596540650674L, -4936375906575303186L, -4938671497741357106L, -4940497543854583186L,\n+                -4941858813449628882L, -4942759682136114354L, -4943204143989086194L, -4943195822025527282L,\n+                -4942737977813222130L, -4941833520255011698L, -4940485013586759090L, -4938694684624342322L,\n+                -4936464429291795314L, -4933795818458824946L, -4930690103114057265L, -4927148218896863345L,\n+                -4923170790008291569L, -4918758132519196401L, -4913910257091661489L, -4908626871126522161L,\n+                -4902907380349538608L, -4896750889844272240L, -4890156204540530416L, -4883121829162570096L,\n+                -4875645967641780528L, -4867726521994909999L, -4859361090668119087L, -4850546966345102383L,\n+                -4841281133215538414L, -4831560263698491374L, -4821380714613452974L, -4810738522790065581L,\n+                -4799629400105481389L, -4788048727936296621L, -4775991551010524588L, -4763452570642113772L,\n+                -4750426137329493931L, -4736906242696388587L, -4722886510751367403L, -4708360188440104938L,\n+                -4693320135461420394L, -4677758813316098089L, -4661668273553495721L, -4645040145179234152L,\n+                -4627865621182771687L, -4610135444140936871L, -4591839890849352486L, -4572968755929944934L,\n+                -4553511334358213029L, -4533456402849109028L, -4512792200036270244L, -4491506405372580067L,\n+                -4469586116675401954L, -4447017826233099938L, -4423787395382284961L, -4399880027458416864L,\n+                -4375280239014124063L, -4349971829190464606L, -4323937847117722654L, -4297160557210942813L,\n+                -4269621402214950684L, -4241300963840750107L, -4212178920821854874L, -4182234004204445017L,\n+                -4151443949668869272L, -4119785446662323159L, -4087234084103169942L, -4053764292396165205L,\n+                -4019349281473092435L, -3983960974549686930L, -3947569937258414993L, -3910145301787337104L,\n+                -3871654685619049615L, -3832064104425389837L, -3791337878631529676L, -3749438533114328651L,\n+                -3706326689447979465L, -3661960950051859912L, -3616297773528542022L, -3569291340409179909L,\n+                -3520893408440947267L, -3471053156460649921L, -3419717015797783872L, -3366828488034801534L,\n+                -3312327947826461820L, -3256152429334023226L, -3198235394669709240L, -3138506482563174262L,\n+                -3076891235255164340L, -3013310801389715890L, -2947681612411392816L, -2879915029671670702L,\n+                -2809916959107519276L, -2737587429961855017L, -2662820133571332903L, -2585501917733374884L,\n+                -2505512231579392929L, -2422722515205190175L, -2336995527534106140L, -2248184604988712345L,\n+                -2156132842510782614L, -2060672187261016979L, -1961622433929380112L, -1858790108950090508L,\n+                -1751967229002904073L, -1640929916937134981L, -1525436855617591297L, -1405227557075245821L,\n+                -1280020420662651897L, -1149510549536605301L, -1013367289578706928L,  -871231448632089708L,\n+                -722712146453677415L,  -567383236774421729L,  -404779231966956764L,  -234390647591531478L,\n+                -55658667960121553L,   132030985907831093L,   329355128892817467L,   537061298001091010L,\n+                755977262693561929L,   987022116608030929L,  1231219266829437401L,  1489711711346524770L,\n+                1763780090187559275L,  2054864117341782772L,  2364588157623782527L,  2694791916990482441L,\n+                3047567482883491349L,  3425304305830820514L,  3830744187097285423L,  4267048975685836605L,\n+                4737884547990014029L,  5247525842199011422L,  5800989391535342064L,  6404202162993303300L,\n+                7064218894258526746L,  7789505049452354354L,  8590309807749425484L,  7643763810684501605L,\n+                8891950541491453167L,  5457384281016234818L,  9083704440929285914L,  7976211653914461751L,\n+                8178631350487124609L,  2821287825726757492L,  6322989683301736617L,  4309503753387630347L,\n+                4685170734960191673L,  8404845967535252693L,  7330522972447610419L,  1960945799077061994L,\n+                4742910674644933674L,  -751799822533438695L,  7023456603742021660L,  3843116882594755262L,\n+                3927231442413889375L, -9223372036854775807L, -9223372036854775807L, -9223372036854775807L };\n+\n+        static final byte[] exponentialAliasMap = {    \/\/ 256 entries\n+                (byte)  0, (byte)  0, (byte)  1, (byte)235, (byte)  3, (byte)  4, (byte)  5, (byte)  0,\n+                (byte)  0, (byte)  0, (byte)  0, (byte)  0, (byte)  0, (byte)  0, (byte)  0, (byte)  0,\n+                (byte)  0, (byte)  0, (byte)  1, (byte)  1, (byte)  1, (byte)  1, (byte)  2, (byte)  2,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)251, (byte)251, (byte)251, (byte)251, (byte)251, (byte)251, (byte)251,\n+                (byte)251, (byte)251, (byte)251, (byte)251, (byte)251, (byte)251, (byte)250, (byte)250,\n+                (byte)250, (byte)250, (byte)250, (byte)250, (byte)250, (byte)249, (byte)249, (byte)249,\n+                (byte)249, (byte)249, (byte)249, (byte)248, (byte)248, (byte)248, (byte)248, (byte)247,\n+                (byte)247, (byte)247, (byte)247, (byte)246, (byte)246, (byte)246, (byte)245, (byte)245,\n+                (byte)244, (byte)244, (byte)243, (byte)243, (byte)242, (byte)241, (byte)241, (byte)240,\n+                (byte)239, (byte)237, (byte)  3, (byte)  3, (byte)  4, (byte)  4, (byte)  6, (byte)  0,\n+                (byte)  0, (byte)  0, (byte)  0, (byte)236, (byte)237, (byte)238, (byte)239, (byte)240,\n+                (byte)241, (byte)242, (byte)243, (byte)244, (byte)245, (byte)246, (byte)247, (byte)248,\n+                (byte)249, (byte)250, (byte)251, (byte)252, (byte)  2, (byte)  0, (byte)  0, (byte)  0 };\n+\n+        \/\/ Implementation support for modified-ziggurat implementation of nextGaussian()\n+\n+        \/\/ Fraction of the area under the curve that lies outside the layer boxes: 0.0117\n+        \/\/ Fraction of non-box area that lies in the tail of the distribution: 0.0236\n+\n+        static final int normalNumberOfLayers = 253;\n+        static final int normalLayerMask = 0xff;\n+        static final int normalAliasMask = 0xff;\n+        static final int normalSignCorrectionMask = 0xff;\n+        static final double normalX0 = 3.63600662550094578;\n+        static final int normalInflectionIndex = 204;\n+        static final long normalConvexMargin = 760463704284035183L;   \/\/ unscaled convex margin = 0.0824\n+        static final long normalConcaveMargin = 2269182951627976012L;   \/\/ unscaled concave margin = 0.2460\n+\n+        \/\/ normal_X[i] = length of ziggurat layer i for normal distribution, scaled by 2**(-63)\n+        static final double[] normalX = {      \/\/ 254 entries, which is normal_number_of_layers+1\n+                3.9421662825398133e-19,  3.7204945004119012e-19,  3.5827024480628678e-19,  3.4807476236540249e-19,\n+                3.3990177171882136e-19,  3.3303778360340139e-19,  3.2709438817617550e-19,  3.2183577132495100e-19,\n+                3.1710758541840432e-19,  3.1280307407034065e-19,  3.0884520655804019e-19,  3.0517650624107352e-19,\n+                3.0175290292584600e-19,  2.9853983440705320e-19,  2.9550967462801797e-19,  2.9263997988491663e-19,\n+                2.8991225869977476e-19,  2.8731108780226291e-19,  2.8482346327101335e-19,  2.8243831535194389e-19,\n+                2.8014613964727031e-19,  2.7793871261807797e-19,  2.7580886921411212e-19,  2.7375032698308758e-19,\n+                2.7175754543391047e-19,  2.6982561247538484e-19,  2.6795015188771505e-19,  2.6612724730440033e-19,\n+                2.6435337927976633e-19,  2.6262537282028438e-19,  2.6094035335224142e-19,  2.5929570954331002e-19,\n+                2.5768906173214726e-19,  2.5611823497719608e-19,  2.5458123593393361e-19,  2.5307623292372459e-19,\n+                2.5160153867798400e-19,  2.5015559533646191e-19,  2.4873696135403158e-19,  2.4734430003079206e-19,\n+                2.4597636942892726e-19,  2.4463201347912450e-19,  2.4331015411139206e-19,  2.4200978427132955e-19,\n+                2.4072996170445879e-19,  2.3946980340903347e-19,  2.3822848067252674e-19,  2.3700521461931801e-19,\n+                2.3579927220741330e-19,  2.3460996262069972e-19,  2.3343663401054455e-19,  2.3227867054673840e-19,\n+                2.3113548974303765e-19,  2.3000654002704238e-19,  2.2889129852797606e-19,  2.2778926905921897e-19,\n+                2.2669998027527321e-19,  2.2562298398527416e-19,  2.2455785360727260e-19,  2.2350418274933911e-19,\n+                2.2246158390513294e-19,  2.2142968725296249e-19,  2.2040813954857555e-19,  2.1939660310297601e-19,\n+                2.1839475483749618e-19,  2.1740228540916853e-19,  2.1641889840016519e-19,  2.1544430956570613e-19,\n+                2.1447824613540345e-19,  2.1352044616350571e-19,  2.1257065792395107e-19,  2.1162863934653125e-19,\n+                2.1069415749082026e-19,  2.0976698805483467e-19,  2.0884691491567363e-19,  2.0793372969963634e-19,\n+                2.0702723137954107e-19,  2.0612722589717129e-19,  2.0523352580895635e-19,  2.0434594995315797e-19,\n+                2.0346432313698148e-19,  2.0258847584216418e-19,  2.0171824394771313e-19,  2.0085346846857531e-19,\n+                1.9999399530912015e-19,  1.9913967503040585e-19,  1.9829036263028144e-19,  1.9744591733545175e-19,\n+                1.9660620240469857e-19,  1.9577108494251485e-19,  1.9494043572246307e-19,  1.9411412901962161e-19,\n+                1.9329204245152935e-19,  1.9247405682708168e-19,  1.9166005600287074e-19,  1.9084992674649826e-19,\n+                1.9004355860642340e-19,  1.8924084378793725e-19,  1.8844167703488436e-19,  1.8764595551677749e-19,\n+                1.8685357872097450e-19,  1.8606444834960934e-19,  1.8527846822098793e-19,  1.8449554417517928e-19,\n+                1.8371558398354868e-19,  1.8293849726199566e-19,  1.8216419538767393e-19,  1.8139259141898448e-19,\n+                1.8062360001864453e-19,  1.7985713737964743e-19,  1.7909312115393845e-19,  1.7833147038364200e-19,\n+                1.7757210543468428e-19,  1.7681494793266395e-19,  1.7605992070083140e-19,  1.7530694770004409e-19,\n+                1.7455595397057217e-19,  1.7380686557563475e-19,  1.7305960954655264e-19,  1.7231411382940904e-19,\n+                1.7157030723311378e-19,  1.7082811937877138e-19,  1.7008748065025788e-19,  1.6934832214591352e-19,\n+                1.6861057563126349e-19,  1.6787417349268046e-19,  1.6713904869190636e-19,  1.6640513472135291e-19,\n+                1.6567236556010242e-19,  1.6494067563053266e-19,  1.6420999975549115e-19,  1.6348027311594532e-19,\n+                1.6275143120903661e-19,  1.6202340980646725e-19,  1.6129614491314931e-19,  1.6056957272604589e-19,\n+                1.5984362959313479e-19,  1.5911825197242491e-19,  1.5839337639095554e-19,  1.5766893940370800e-19,\n+                1.5694487755235889e-19,  1.5622112732380261e-19,  1.5549762510837070e-19,  1.5477430715767271e-19,\n+                1.5405110954198330e-19,  1.5332796810709688e-19,  1.5260481843056974e-19,  1.5188159577726683e-19,\n+                1.5115823505412761e-19,  1.5043467076406199e-19,  1.4971083695888395e-19,  1.4898666719118714e-19,\n+                1.4826209446506113e-19,  1.4753705118554365e-19,  1.4681146910669830e-19,  1.4608527927820112e-19,\n+                1.4535841199031451e-19,  1.4463079671711862e-19,  1.4390236205786415e-19,  1.4317303567630177e-19,\n+                1.4244274423783481e-19,  1.4171141334433217e-19,  1.4097896746642792e-19,  1.4024532987312287e-19,\n+                1.3951042255849034e-19,  1.3877416616527576e-19,  1.3803647990516385e-19,  1.3729728147547174e-19,\n+                1.3655648697200824e-19,  1.3581401079782068e-19,  1.3506976556752901e-19,  1.3432366200692418e-19,\n+                1.3357560884748263e-19,  1.3282551271542047e-19,  1.3207327801488087e-19,  1.3131880680481524e-19,\n+                1.3056199866908076e-19,  1.2980275057923788e-19,  1.2904095674948608e-19,  1.2827650848312727e-19,\n+                1.2750929400989213e-19,  1.2673919831340482e-19,  1.2596610294799512e-19,  1.2518988584399374e-19,\n+                1.2441042110056523e-19,  1.2362757876504165e-19,  1.2284122459762072e-19,  1.2205121982017852e-19,\n+                1.2125742084782245e-19,  1.2045967900166973e-19,  1.1965784020118020e-19,  1.1885174463419555e-19,\n+                1.1804122640264091e-19,  1.1722611314162064e-19,  1.1640622560939109e-19,  1.1558137724540874e-19,\n+                1.1475137369333185e-19,  1.1391601228549047e-19,  1.1307508148492592e-19,  1.1222836028063025e-19,\n+                1.1137561753107903e-19,  1.1051661125053526e-19,  1.0965108783189755e-19,  1.0877878119905372e-19,\n+                1.0789941188076655e-19,  1.0701268599703640e-19,  1.0611829414763286e-19,  1.0521591019102928e-19,\n+                1.0430518990027552e-19,  1.0338576948035472e-19,  1.0245726392923699e-19,  1.0151926522209310e-19,\n+                1.0057134029488235e-19,  9.9613028799672809e-20,  9.8643840599459914e-20,  9.7663252964755816e-20,\n+                9.6670707427623454e-20,  9.5665606240866670e-20,  9.4647308380433213e-20,  9.3615125017323508e-20,\n+                9.2568314370887282e-20,  9.1506075837638774e-20,  9.0427543267725716e-20,  8.9331777233763680e-20,\n+                8.8217756102327883e-20,  8.7084365674892319e-20,  8.5930387109612162e-20,  8.4754482764244349e-20,\n+                8.3555179508462343e-20,  8.2330848933585364e-20,  8.1079683729129853e-20,  7.9799669284133864e-20,\n+                7.8488549286072745e-20,  7.7143783700934692e-20,  7.5762496979467566e-20,  7.4341413578485329e-20,\n+                7.2876776807378431e-20,  7.1364245443525374e-20,  6.9798760240761066e-20,  6.8174368944799054e-20,\n+                6.6483992986198539e-20,  6.4719110345162767e-20,  6.2869314813103699e-20,  6.0921687548281263e-20,\n+                5.8859873575576818e-20,  5.6662675116090981e-20,  5.4301813630894571e-20,  5.1738171744494220e-20,\n+                4.8915031722398545e-20,  4.5744741890755301e-20,  4.2078802568583416e-20,  3.7625986722404761e-20,\n+                3.1628589805881879e-20,  0.0000000000000000e+00 };\n+\n+        \/\/ normal_Y[i] = value of the normal distribution function at normal_X[i], scaled by 2**(-63)\n+        static final double[] normalY = {      \/\/ 254 entries, which is normal_number_of_layers+1\n+                1.4598410796619063e-22,  3.0066613427942797e-22,  4.6129728815103466e-22,  6.2663350049234362e-22,\n+                7.9594524761881544e-22,  9.6874655021705039e-22,  1.1446877002379439e-21,  1.3235036304379167e-21,\n+                1.5049857692053131e-21,  1.6889653000719298e-21,  1.8753025382711626e-21,  2.0638798423695191e-21,\n+                2.2545966913644708e-21,  2.4473661518801799e-21,  2.6421122727763533e-21,  2.8387681187879908e-21,\n+                3.0372742567457284e-21,  3.2375775699986589e-21,  3.4396303157948780e-21,  3.6433893657997798e-21,\n+                3.8488155868912312e-21,  4.0558733309492775e-21,  4.2645300104283590e-21,  4.4747557422305067e-21,\n+                4.6865230465355582e-21,  4.8998065902775257e-21,  5.1145829672105489e-21,  5.3308305082046173e-21,\n+                5.5485291167031758e-21,  5.7676601252690476e-21,  5.9882061699178461e-21,  6.2101510795442221e-21,\n+                6.4334797782257209e-21,  6.6581781985713897e-21,  6.8842332045893181e-21,  7.1116325227957095e-21,\n+                7.3403646804903092e-21,  7.5704189502886418e-21,  7.8017853001379744e-21,  8.0344543481570017e-21,\n+                8.2684173217333118e-21,  8.5036660203915022e-21,  8.7401927820109521e-21,  8.9779904520281901e-21,\n+                9.2170523553061439e-21,  9.4573722703928820e-21,  9.6989444059269430e-21,  9.9417633789758424e-21,\n+                1.0185824195119818e-20,  1.0431122230114770e-20,  1.0677653212987396e-20,  1.0925413210432004e-20,\n+                1.1174398612392891e-20,  1.1424606118728715e-20,  1.1676032726866302e-20,  1.1928675720361027e-20,\n+                1.2182532658289373e-20,  1.2437601365406785e-20,  1.2693879923010674e-20,  1.2951366660454145e-20,\n+                1.3210060147261461e-20,  1.3469959185800733e-20,  1.3731062804473644e-20,  1.3993370251385596e-20,\n+                1.4256880988463136e-20,  1.4521594685988369e-20,  1.4787511217522902e-20,  1.5054630655196170e-20,\n+                1.5322953265335218e-20,  1.5592479504415048e-20,  1.5863210015310328e-20,  1.6135145623830982e-20,\n+                1.6408287335525592e-20,  1.6682636332737932e-20,  1.6958193971903124e-20,  1.7234961781071113e-20,\n+                1.7512941457646084e-20,  1.7792134866331487e-20,  1.8072544037271070e-20,  1.8354171164377277e-20,\n+                1.8637018603838945e-20,  1.8921088872801004e-20,  1.9206384648209468e-20,  1.9492908765815636e-20,\n+                1.9780664219333857e-20,  2.0069654159747839e-20,  2.0359881894760859e-20,  2.0651350888385696e-20,\n+                2.0944064760670539e-20,  2.1238027287557466e-20,  2.1533242400870487e-20,  2.1829714188430474e-20,\n+                2.2127446894294597e-20,  2.2426444919118270e-20,  2.2726712820637798e-20,  2.3028255314272276e-20,\n+                2.3331077273843558e-20,  2.3635183732413286e-20,  2.3940579883236352e-20,  2.4247271080830277e-20,\n+                2.4555262842160330e-20,  2.4864560847940368e-20,  2.5175170944049622e-20,  2.5487099143065929e-20,\n+                2.5800351625915997e-20,  2.6114934743643687e-20,  2.6430855019297323e-20,  2.6748119149937411e-20,\n+                2.7066734008766247e-20,  2.7386706647381193e-20,  2.7708044298153558e-20,  2.8030754376735269e-20,\n+                2.8354844484695747e-20,  2.8680322412291631e-20,  2.9007196141372126e-20,  2.9335473848423219e-20,\n+                2.9665163907753988e-20,  2.9996274894828624e-20,  3.0328815589748056e-20,  3.0662794980885287e-20,\n+                3.0998222268678760e-20,  3.1335106869588609e-20,  3.1673458420220558e-20,  3.2013286781622988e-20,\n+                3.2354602043762612e-20,  3.2697414530184806e-20,  3.3041734802864950e-20,  3.3387573667257349e-20,\n+                3.3734942177548938e-20,  3.4083851642125208e-20,  3.4434313629256243e-20,  3.4786339973011376e-20,\n+                3.5139942779411164e-20,  3.5495134432826171e-20,  3.5851927602632460e-20,  3.6210335250134172e-20,\n+                3.6570370635764384e-20,  3.6932047326575882e-20,  3.7295379204034252e-20,  3.7660380472126401e-20,\n+                3.8027065665798284e-20,  3.8395449659736649e-20,  3.8765547677510167e-20,  3.9137375301086406e-20,\n+                3.9510948480742172e-20,  3.9886283545385430e-20,  4.0263397213308566e-20,  4.0642306603393541e-20,\n+                4.1023029246790967e-20,  4.1405583099096438e-20,  4.1789986553048817e-20,  4.2176258451776819e-20,\n+                4.2564418102621759e-20,  4.2954485291566197e-20,  4.3346480298300118e-20,  4.3740423911958146e-20,\n+                4.4136337447563716e-20,  4.4534242763218286e-20,  4.4934162278076256e-20,  4.5336118991149025e-20,\n+                4.5740136500984466e-20,  4.6146239026271279e-20,  4.6554451427421133e-20,  4.6964799229185088e-20,\n+                4.7377308644364938e-20,  4.7792006598684169e-20,  4.8208920756888113e-20,  4.8628079550147814e-20,\n+                4.9049512204847653e-20,  4.9473248772842596e-20,  4.9899320163277674e-20,  5.0327758176068971e-20,\n+                5.0758595537153414e-20,  5.1191865935622696e-20,  5.1627604062866059e-20,  5.2065845653856416e-20,\n+                5.2506627530725194e-20,  5.2949987648783448e-20,  5.3395965145159426e-20,  5.3844600390237576e-20,\n+                5.4295935042099358e-20,  5.4750012104183868e-20,  5.5206875986405073e-20,  5.5666572569983821e-20,\n+                5.6129149276275792e-20,  5.6594655139902476e-20,  5.7063140886520563e-20,  5.7534659015596918e-20,\n+                5.8009263888591218e-20,  5.8487011822987583e-20,  5.8967961192659803e-20,  5.9452172535103471e-20,\n+                5.9939708666122605e-20,  6.0430634802618929e-20,  6.0925018694200531e-20,  6.1422930764402860e-20,\n+                6.1924444262401531e-20,  6.2429635426193939e-20,  6.2938583658336214e-20,  6.3451371715447563e-20,\n+                6.3968085912834963e-20,  6.4488816345752736e-20,  6.5013657128995346e-20,  6.5542706656731714e-20,\n+                6.6076067884730717e-20,  6.6613848637404196e-20,  6.7156161942412980e-20,  6.7703126395950580e-20,\n+                6.8254866562246408e-20,  6.8811513411327825e-20,  6.9373204799659681e-20,  6.9940085998959109e-20,\n+                7.0512310279279503e-20,  7.1090039553397167e-20,  7.1673445090644796e-20,  7.2262708309655784e-20,\n+                7.2858021661057338e-20,  7.3459589613035800e-20,  7.4067629754967553e-20,  7.4682374037052817e-20,\n+                7.5304070167226666e-20,  7.5932983190698547e-20,  7.6569397282483754e-20,  7.7213617789487678e-20,\n+                7.7865973566417016e-20,  7.8526819659456755e-20,  7.9196540403850560e-20,  7.9875553017037968e-20,\n+                8.0564311788901630e-20,  8.1263312996426176e-20,  8.1973100703706304e-20,  8.2694273652634034e-20,\n+                8.3427493508836792e-20,  8.4173494807453416e-20,  8.4933097052832066e-20,  8.5707219578230905e-20,\n+                8.6496899985930695e-20,  8.7303317295655327e-20,  8.8127821378859504e-20,  8.8971970928196666e-20,\n+                8.9837583239314064e-20,  9.0726800697869543e-20,  9.1642181484063544e-20,  9.2586826406702765e-20,\n+                9.3564561480278864e-20,  9.4580210012636175e-20,  9.5640015550850358e-20,  9.6752334770503130e-20,\n+                9.7928851697808831e-20,  9.9186905857531331e-20,  1.0055456271343397e-19,  1.0208407377305566e-19,\n+                1.0390360993240711e-19,  1.0842021724855044e-19 };\n+\n+        \/\/ alias_threshold[j] is a threshold for the probability mass function that has been\n+        \/\/ scaled by (2**64 - 1), translated by -(2**63), and represented as a long value;\n+        \/\/ in this way it can be directly compared to a randomly chosen long value.\n+        static final long[] normalAliasThreshold = {    \/\/ 256 entries\n+                9223372036854775732L,  1100243796470199922L,  7866600928967318259L,  6788754710669718688L,\n+                9022865200207136940L,  6522434035182564354L,  4723064097388367094L,  3360495653202227820L,\n+                2289663232347306830L,  1423968905585875379L,   708364817795238883L,   106102487338962592L,\n+                -408333464668584328L,  -853239722790494085L, -1242095211827090004L, -1585059631108655444L,\n+                -1889943050267333598L, -2162852901996526266L, -2408637386596951353L, -2631196530256993348L,\n+                -2833704942542501760L, -3018774289008775598L, -3188573753501888049L, -3344920681670389334L,\n+                -3489349705095933019L, -3623166100045386711L, -3747487436861293578L, -3863276422709141026L,\n+                -3971367044055496571L, -4072485557008423504L, -4167267476835653997L, -4256271432259158584L,\n+                -4339990541931699221L, -4418861817116128356L, -4493273980399812066L, -4563574004455583972L,\n+                -4630072609765608272L, -4693048910437239656L, -4752754358851355990L, -4809416110064308151L,\n+                -4863239903553549801L, -4914412541525462120L, -4963104028438393907L, -5009469424783376781L,\n+                -5053650458852410933L, -5095776932714599237L, -5135967952538787362L, -5174333008440005397L,\n+                -5210972924976812191L, -5245980700089102084L, -5279442247516610920L, -5311437055455710870L,\n+                -5342038772315685218L, -5371315728848281940L, -5399331404596850615L, -5426144845492958401L,\n+                -5451811038482575296L, -5476381248268660540L, -5499903320574200237L, -5522421955754019296L,\n+                -5543978956088644891L, -5564613449670076120L, -5584362093426489951L, -5603259257517942559L,\n+                -5621337193067953247L, -5638626184957155131L, -5655154691206501482L, -5670949470299055313L,\n+                -5686035697633988263L, -5700437072176015065L, -5714175914241450413L, -5727273255262198220L,\n+                -5739748920276454057L, -5751621603817308582L, -5762908939796390234L, -5773627565922293024L,\n+                -5783793183134813122L, -5793420610488485693L, -5802523835876777512L, -5811116062947540603L,\n+                -5819209754528321254L, -5826816672847738703L, -5833947916812588598L, -5840613956576464230L,\n+                -5846824665611918318L, -5852589350480860931L, -5857916778478181241L, -5862815203308620040L,\n+                -5867292388942958035L, -5871355631785040459L, -5875011781271709877L, -5878267259014830525L,\n+                -5881128076587168793L, -5883599852042383670L, -5885687825255517495L, -5887396872158140520L,\n+                -5888731517940791413L, -5889695949285098191L, -5890294025685452079L, -5890529289913339019L,\n+                -5890404977673728891L, -5889924026498433105L, -5889089083917111413L, -5887902514943630556L,\n+                -5886366408911444323L, -5884482585689698188L, -5882252601307215732L, -5879677753010810505L,\n+                -5876759083779777633L, -5873497386319005871L, -5869893206546653493L, -5865946846595933526L,\n+                -5861658367342436656L, -5857027590471882377L, -5852054100098427498L, -5846737243942430862L,\n+                -5841076134076202917L, -5835069647242632620L, -5828716424752710909L, -5822014871963881822L,\n+                -5814963157341321336L, -5807559211102860368L, -5799800723445392235L, -5791685142351319976L,\n+                -5783209670970726741L, -5774371264573181466L, -5765166627063894671L, -5755592207054728713L,\n+                -5745644193480823967L, -5735318510752045177L, -5724610813425415465L, -5713516480385581414L,\n+                -5702030608515423737L, -5690148005840583288L, -5677863184127162093L, -5665170350911168791L,\n+                -5652063400935782694L, -5638535906971010691L, -5624581109986711207L, -5610191908648783765L,\n+                -5595360848105231304L, -5580080108024969737L, -5564341489852042876L, -5548136403231016978L,\n+                -5531455851558564459L, -5514290416611714856L, -5496630242199355791L, -5478465016777918644L,\n+                -5459783954970839371L, -5440575777921757436L, -5420828692410297267L, -5400530368650229789L,\n+                -5379667916685479525L, -5358227861290596404L, -5336196115276119372L, -5313557951090901350L,\n+                -5290297970603367798L, -5266400072934326313L, -5241847420204395031L, -5216622401044877639L,\n+                -5190706591710560934L, -5164080714616987256L, -5136724594109421094L, -5108617109256031912L,\n+                -5079736143434386281L, -5050058530465123570L, -5019559997019987907L, -4988215101007960589L,\n+                -4955997165616088151L, -4922878208649305943L, -4888828866781574127L, -4853818314291958392L,\n+                -4817814175818125756L, -4780782432613346925L, -4742687321741700014L, -4703491227589533028L,\n+                -4663154565006030194L, -4621635653315226847L, -4578890580363657638L, -4534873055674290590L,\n+                -4489534251682380820L, -4442822631912146606L, -4394683764829968681L, -4345060121963632469L,\n+                -4293890858720706245L, -4241111576152819891L, -4186654061709945180L, -4130446006793453666L,\n+                -4072410698652140640L, -4012466683862855933L, -3950527400292573339L, -3886500774045756804L,\n+                -3820288777448438119L, -3751786943603804843L, -3680883832458819395L, -3607460442634330728L,\n+                -3531389562479403081L, -3452535052892669800L, -3370751053387208615L, -3285881101636362572L,\n+                -3197757155290696249L, -3106198503163967069L, -3011010550898974052L, -2911983463889090176L,\n+                -2808890647471134035L, -2701487041141521265L, -2589507199668960785L, -2472663129352313038L,\n+                -2350641842148622058L, -2223102583752258356L, -2089673683718520949L, -1949948966041670625L,\n+                -1803483646850545328L, -1649789631543398131L, -1488330106106063370L, -1318513295716695859L,\n+                -1139685236949889721L,  -951121376566993538L,  -752016768187462359L,  -541474585679321485L,\n+                -318492605702529265L,   -81947227237782935L,   169425512586600501L,   437052607251310002L,\n+                722551297576808029L,  1027761939321803391L,  1354787941562529921L,  1706044619231670700L,\n+                2084319374410687061L,  2492846399585974279L,  2935400169364870493L,  3416413484632185639L,\n+                3941127949845221101L,  4515787798750242711L,  5147892401460631081L,  5846529325404347588L,\n+                6622819682189677227L,  7490522659877439279L,  8466869998300400224L,  8216968526327386835L,\n+                4550693915429835301L,  7628019504075715697L,  6605080500885794707L,  7121156327618549405L,\n+                2484871780310660533L,  7179104797025802172L,  7066086283790288107L,  1516500120772178463L,\n+                216305945406470492L,  6295963418490399062L,  2889316805640753770L, -2712587580563247199L,\n+                6562498853480442900L,  7975754821117214681L, -9223372036854775807L, -9223372036854775807L };\n+\n+        static final byte[] normalAliasMap = {    \/\/ 256 entries\n+                (byte)  0, (byte)  0, (byte)239, (byte)  2, (byte)  0, (byte)  0, (byte)  0, (byte)  0,\n+                (byte)  0, (byte)  0, (byte)  0, (byte)  0, (byte)  1, (byte)  1, (byte)  1, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253, (byte)253,\n+                (byte)253, (byte)253, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252, (byte)252,\n+                (byte)252, (byte)252, (byte)252, (byte)252, (byte)251, (byte)251, (byte)251, (byte)251,\n+                (byte)251, (byte)251, (byte)251, (byte)250, (byte)250, (byte)250, (byte)250, (byte)250,\n+                (byte)249, (byte)249, (byte)249, (byte)248, (byte)248, (byte)248, (byte)247, (byte)247,\n+                (byte)247, (byte)246, (byte)246, (byte)245, (byte)244, (byte)244, (byte)243, (byte)242,\n+                (byte)240, (byte)  2, (byte)  2, (byte)  3, (byte)  3, (byte)  0, (byte)  0, (byte)240,\n+                (byte)241, (byte)242, (byte)243, (byte)244, (byte)245, (byte)246, (byte)247, (byte)248,\n+                (byte)249, (byte)250, (byte)251, (byte)252, (byte)253, (byte)  1, (byte)  0, (byte)  0 };\n+\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/random\/RandomSupport.java","additions":3075,"deletions":0,"binary":false,"changes":3075,"status":"added"},{"patch":"@@ -116,0 +116,1 @@\n+    exports java.util.random;\n@@ -251,0 +252,2 @@\n+    exports jdk.internal.util.random to\n+        jdk.random;\n@@ -359,1 +362,0 @@\n-\n@@ -380,0 +382,1 @@\n+    uses java.util.random.RandomGenerator;\n@@ -403,0 +406,6 @@\n+\n+    provides java.util.random.RandomGenerator with\n+        java.security.SecureRandom,\n+        java.util.Random,\n+        java.util.SplittableRandom;\n+\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,688 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+\/\/ This program computes the parameters and arrays needed by the modified-ziggurat algorithm\n+\/\/ for sampling from either an exponential distribution with mean 1 or a normal distribution\n+\/\/ with mean 0 and standad deviation 1.  The four arrays needed for either kind of sampler are:\n+\/\/\n+\/\/    X[i] is the horizontal width of ziggurat layer i\n+\/\/    Y[i] is f(X[i]), where f is the function for the exponential or normal curve\n+\/\/    alias_threshold is the table of probability mass thresholds for Walker's alias method,\n+\/\/       with one entry for the tail of the distributon and one entry for each overhang region\n+\/\/    alias_map is the table of forwarding indices used for Walker's alias method\n+\/\/\n+\/\/ The four parameters needed by the exponential sampler are:\n+\/\/\n+\/\/    exponential_number_of_layers   the number of layers in the ziggurat\n+\/\/    exponential_X_0                the width of the box in layer 0 (which is the x-coordinate of the left end of the tail)\n+\/\/    exponential_convex_margin      the maximum discrepancy between the curve and a certain diagonal line above it\n+\/\/\n+\/\/ The five parameters needed by the normal sampler are:\n+\/\/\n+\/\/    normal_number_of_layers        the number of layers in the ziggurat\n+\/\/    normal_X_0                     the width of the box in layer 0 (which is the x-coordinate of the left end of the tail)\n+\/\/    normal_inflection_index        the index of the layer containing the inflection point\n+\/\/    normal_convex_margin           the maximum discrepancy between the curve and a certain diagonal line above it\n+\/\/    normal_concave_margin          the maximum discrepancy between the curve and a certain diagonal line below it\n+\/\/\n+\/\/ After computing the parameters and tables, the program prints (to standard output)\n+\/\/ a complete Java source code file for a class named either FloatZigguratTables or\n+\/\/ DoubleZigguratTables, according to which precision has been requested.\n+\n+\/\/ The only reason this program has been written as C code rather than Java code is that\n+\/\/ most of the calculations need to be performed in long double precision in order to\n+\/\/ be able to calculate double values of sufficient accuracy.  This code relies on\n+\/\/ long double math functions sqrtl, powl, expl, logl, log2l, erfl, ceill, and copysignl.\n+\n+\/\/ The overall modified ziggurat algorithm closely follows the description in:\n+\/\/\n+\/\/     Christopher D. McFarland.  2016 (published online 24 Jun 2015).  A modified ziggurat\n+\/\/     algorithm for generating exponentially and normally distributed pseudorandom numbers.\n+\/\/     Journal of Statistical Computation and Simulation 86 (7), pages 1281-1294.\n+\/\/     https:\/\/www.tandfonline.com\/doi\/abs\/10.1080\/00949655.2015.1060234\n+\/\/     Also at https:\/\/arxiv.org\/abs\/1403.6870 (26 March 2014).\n+\/\/\n+\/\/ This paper in turn refers to code available at https:\/\/bitbucket.org\/cdmcfarland\/fast_prng.\n+\/\/ This includes a file create_layers.py of Python code for constructing the tables.\n+\/\/ The C code here loosely follows the organization of that Python code.  However, the Python\n+\/\/ code appears to contain a number of errors and infelicities that have been corrected here:\n+\/\/\n+\/\/ (1) On line 211, 1 is added to i_inflection, causing the value 205 to be printed when\n+\/\/     table size is 256.  Adding 1 is not correct; the correct value for printing is 204.\n+\/\/\n+\/\/ (2) On line 203, 3 values are dropped from the front of the array E when computing iE_max,\n+\/\/     with no explanation given.  We believe this is incorrect; E[3:] should be simply E.\n+\/\/\n+\/\/ (3) When the table elements are converted to printable strings using \"map(str,data)\",\n+\/\/     precision is lost because the Python str function produces only 12 decimal digits.\n+\/\/     In this C code, we print table entries using 17 decimal digits (format %23.16e),\n+\/\/     because 17 decimal digits suffice to preserve the value of any double precision\n+\/\/     value (and 16 decimal digits do not always suffice).\n+\/\/\n+\/\/ (4) At lines 215-223, the Python code computes only a single E value for the\n+\/\/     rectangle containing the inflection point of the normal distribution curve.\n+\/\/     We believe it is conceptually more correct to compute two such E values,\n+\/\/     one for the concave part of the curve (to the left of the inflection point)\n+\/\/     and one for the convex part of the curve (to the right of the inflection point).\n+\/\/\n+\/\/ We also observe that the McFarland paper asserts that the solver uses Brent's method,\n+\/\/ but the solver in the Python code does not implement Brent's method.  A proper\n+\/\/ implementation of Brent's method (or its predecessor, Dekker's method) alternates\n+\/\/ between use of the Secant Method and use of the Bisection Method according to various\n+\/\/ criteria, but the Python code merely tries the Secant Method for a fixed number of\n+\/\/ iterations and then switches to the Bisection Method for a calculated number of iterations.\n+\/\/ Here we have translated Brent's Method into C from the Algol code in Brent's original paper.\n+\n+#include <float.h>\n+#include <math.h>\n+#include <stdio.h>\n+#include <assert.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+\/\/ The SIZE may be any power of 2 not greater than 2048; 128, 256, 512, and 1024\n+\/\/ are all plausible choices, but 256 probably makes the best space\/time tradeoff.\n+\/\/ The number of layers in the constructed ziggurat will be slightly smaller than this.\n+#ifndef SIZE\n+#define SIZE 256\n+#endif\n+\n+\/\/ Set USE_DOUBLE to 1 for Java routines that compute results of type double, or to 0 for float.\n+#ifndef USE_DOUBLE\n+#define USE_DOUBLE 1\n+#endif\n+\n+\n+#if USE_DOUBLE\n+\n+typedef int64_t int_type;\n+typedef uint64_t uint_type;\n+typedef double float_type;\n+#define int_bits 64\n+#define max_int 0x7fffffffffffffff\n+#define max_uint 0xffffffffffffffff\n+#define java_int_type \"long\"\n+#define java_float_type \"double\"\n+#define java_capitalized_float_type \"Double\"\n+\n+#else\n+\n+typedef int32_t int_type;\n+typedef uint32_t uint_type;\n+typedef float float_type;\n+#define int_bits 32\n+#define max_int 0x7fffffff\n+#define max_uint 0xffffffff\n+#define java_int_type \"int\"\n+#define java_float_type \"float\"\n+#define java_capitalized_float_type \"Float\"\n+\n+#endif\n+\n+\/\/ We set SOLVER_TOLERANCE quite tight\n+#define SOLVER_TOLERANCE 1.0e-19L\n+\n+#define PI (3.1415926535897932384626433832795L)\n+\n+\/\/ Assert that two long double values are equal to within double (not long double) precision\n+#define check_equal(x, y) do assert(((x)>=(y) ? (x)-(y) : (y)-(x)) < DBL_EPSILON); while (0)\n+\n+\/\/ The best way to compute the absolute value of a long double.\n+long double absl(long double x) {\n+  return copysignl(x, 1.0);\n+}\n+\n+\/\/ The type of a function that accepts one long double argument and returns a long double result.\n+typedef long double (*longdoublefn)(long double);\n+\n+\/\/ The functions we will traffic in for solving need an argument but also two\n+\/\/ or three parameters, of which the first is a longdoublefn and the others are\n+\/\/ long double values.  Because vanilla C doesn't have closures, we just arrange\n+\/\/ for the solver to accept three parameters and pass them in each time.\n+typedef long double (*solverfn)(long double, longdoublefn, long double, long double);\n+\n+\n+\/\/ The solver: find a root of function g (which has f, p1, and p2 as parameters).\n+\/\/ Returns a value x within bounds [a, b] such that g(x) is (close to) zero.\n+\/\/ Returns NaN if either a >= b or g(a) and g(b) have the same sign;\n+\/\/ this information can help the caller to adjust the bounds and try again.\n+\/\/\n+\/\/ This solver uses Brent's Method, as it appears in:\n+\/\/\n+\/\/    R. P. Brent.  1971.  An algorithm with guaranteed convergence for finding a zero of a function.\n+\/\/    The Computer Journal, Volume 14, Issue 4, 422425.  https:\/\/doi.org\/10.1093\/comjnl\/14.4.422\n+\/\/\n+\/\/ We assume that LDBL_EPSILON is the correct value to use for \"macheps\" as used in the Algol code.\n+\n+long double fsolve(solverfn g, longdoublefn f, long double p1, long double p2,\n+          long double a, long double b) {\n+  \/\/ Check the required conditions on the arguments.\n+  if (a >= b) return NAN;\n+  long double ga = g(a, f, p1, p2), gb = g(b, f, p1, p2);\n+  if (copysignl(1.0, ga) == copysignl(1.0, gb)) return NAN;\n+  \/\/ Here is Brent's Method, translated from Algol to C.  We have replaced the uses\n+  \/\/ of \"goto\" with \"for\" loops and have scoped the variable declarations more tightly.\n+  for (;;) {   \/\/ label \"int:\" in the Algol code\n+    long double c = a, gc = ga;\n+    long double e = b - a;\n+    long double d = e;\n+    for (;;) {   \/\/ label \"ext:\" in the Algol code\n+      if (absl(gc) < absl(gb)) {\n+   a = b; b = c; c = a;\n+   ga = gb; gb = gc; gc = ga;\n+      }\n+      long double tol = 2 * LDBL_EPSILON * absl(b) + SOLVER_TOLERANCE;\n+      long double m = (c - b)\/2.0L;\n+      if (absl(m) < tol || gb == 0.0L) return b;\n+      \/\/ See if a bisection is forced\n+      if (absl(e) < tol || absl(ga) <= absl(gb)) {\n+   d = e = m;   \/\/ Yes, it is\n+      } else {\n+   long double s = gb\/ga;\n+   long double p, q;\n+   if (a == c) {\n+     \/\/ Linear interpolation\n+     p = 2.0L * m * s;\n+     q = 1.0L - s;\n+   } else {\n+     \/\/ Inverse quadratic interpolation\n+     long double z = ga\/gc, r = gb\/gc;\n+     p = s * (2.0L*m*z*(z-r) - (b - a)*(r - 1.0L));\n+     q = (z - 1.0L) * (r - 1.0L) * (s - 1.0L);\n+   }\n+   if (p > 0.0L) { q = -q; } else { p = -p; }\n+   s = e; e = d;\n+   if ((2.0L*p < 3.0L*m*q - absl(tol*q)) && (p < absl(0.5L*s*q))) {\n+     d = p\/q;\n+   } else {\n+     d = e = m;\n+   }\n+      }\n+      a = b; ga = gb;\n+      b = b + (absl(d) > tol ? d : (m > 0.0L ? tol : -tol));\n+      gb = g(b, f, p1, p2);\n+      if ((gb > 0.0L) == (gc > 0.0L)) break;  \/\/ That is, goto \"int:\"\n+      \/\/ Otherwise, goto \"ext:\"\n+    }\n+  }\n+}\n+\n+\/\/ This routine accepts a discrete probability mass function P (represented as an array),\n+\/\/ a second array A, and an integer N that indicates their common length.\n+\/\/ It computes two outputs: a table of probability thresholds (returned in P) and\n+\/\/ a table of forwarding indices (returned in A).\n+\/\/ These tables are suitable for use with Walker's alias algorithm for sampling from\n+\/\/ the originally specified discrete probability mass function.\n+\/\/ For the original description of Walker's alias method, see:\n+\/\/    Alastair J. Walker.  1977.  An efficient method for generating discrete random\n+\/\/    variables with general distributions. ACM Trans. Math. Software 3, 3\n+\/\/    (September 1977), 253-256. DOI: https:\/\/doi.org\/10.1145\/355744.355749\n+\/\/ However, his original version of the routine for building the tables runs in O(N**2) time.\n+\/\/ Following McFarland, we use a variant technique that is O(N), as described by Smith:\n+\/\/    Warren D. Smith.  2002.  How to sample from a probability distribution.\n+\/\/    Unpublished.  http:\/\/scorevoting.net\/WarrenSmithPages\/homepage\/sampling.ps\n+\n+void build_sampler(long double *P, int *A, int N) {\n+  long double *X = malloc((N+1)*sizeof(long double));\n+  int *B = malloc((N+1)*sizeof(int));\n+  \/\/ First step: normalize the given probability distribution and scale by N.\n+  long double sum = 0.0L;\n+  for (int k = 0; k < N; k++) sum += P[k];\n+  for (int k = 0; k < N; k++) P[k] = (P[k] \/ sum) * N;\n+  \/\/ Copy P into X, and add a sentinel value.\n+  for (int k = 0; k < N; k++) X[k] = P[k];\n+  X[N] = 2.0L;  \/\/ sentinel value\n+  \/\/ A will become the table of forwarding indices.\n+  \/\/ B will eventually describe a permutation on X such that every element less than 1.0\n+  \/\/ has a lower index than any element that is not less than 1.0.\n+  \/\/ Initally each is the identity map (element k contains the value k).\n+  for (int k = 0; k < N; k++) A[k] = k;\n+  for (int k = 0; k < N+1; k++) B[k] = k;\n+  \/\/ This next step is reminiscent of a Quicksort partition: i and j are two fingers\n+  \/\/ moving toward each other from opposite ends of X, and when i lands on an element\n+  \/\/ not less than 1.0 and j lands on an element less than 1.0, they are _logically_\n+  \/\/ swapped, not by updating X, but by updating the permutation in B.\n+  int i = 0;\n+  int j = N;\n+  for (;;) {\n+    while (X[B[i]] < 1.0L) i += 1;\n+    while (X[B[j]] >= 1.0L) j -= 1;\n+    if (i >= j) break;\n+    int temp = B[i]; B[i] = B[j]; B[j] = temp;\n+  }\n+  i = j;\n+  j += 1;\n+  \/\/ At this point, X[B[k]] < 1.0L for all k <= i, and X[B[k]] >= 1.0L for all k >= j == i+1.\n+  \/\/ This invariant will be maintained by the next loop, which moves i back out to the left\n+  \/\/ and j back out to the right.\n+  while (i >= 0) {\n+    while (X[B[j]] <= 1.0L) j += 1;\n+    if (j >= N) break;\n+    \/\/ At this point, X[B[i]] is \"overfunded\" and X[B[j]] is \"underfunded\".\n+    \/\/ During the sampling process, if the randomly chosen value in [0,1) is not\n+    \/\/ less than X[B[i]], it will be construed as a choice of B[j] rather than of j.\n+    \/\/ This is indicated by storing B[j] in A[B[i]].  In addition, X[B[j]] is updated\n+    \/\/ to reflect that fact that X[B[i]] has \"funded\" 1-X[B[i]] of its desired\n+    \/\/ probability mass.\n+    A[B[i]] = B[j];\n+    X[B[j]] -= (1.0L - X[B[i]]);\n+    \/\/ It may be that the \"generosity\" of X[B[i]] has caused X[B[j]] to become overfunded.\n+    \/\/ In that case, the two can be swapped (and j is incremented so that the former X[B[i]],\n+    \/\/ now become X[B[j]], will not be further examined).  Otherwise, i is decremented.\n+    \/\/ In either case, i will then indicate a new overfunded slot to be considered.\n+    if (X[B[j]] < 1.0L) {\n+      int temp = B[i]; B[i] = B[j]; B[j] = temp;\n+      j += 1;\n+    } else {\n+      i -= 1;\n+    }\n+  }\n+  \/\/ All done!  Now a sanity check.\n+  long double *Q = malloc(N*sizeof(long double));\n+  for (int k = 0; k < N; k++) Q[k] = X[k];\n+  for (int k = 0; k < N; k++) Q[A[k]] += (1.0L - X[k]);\n+  for (int k = 0; k < N; k++) check_equal(Q[k], P[k]);\n+  \/\/ Copy the result table in X back out into the argument P.\n+  for (int k = 0; k < N; k++) P[k] = X[k];\n+  free(Q); free(B); free(X);\n+}\n+\n+\/\/ The function that describes the exponential distribution with mean 1.\n+\/\/ See https:\/\/en.wikipedia.org\/wiki\/Exponential_distribution\n+long double exponential_f(long double x) {\n+  return expl(-x);\n+}\n+\n+\/\/ The cumulative distribution function for the exponential distribution with mean 1.\n+long double exponential_cdf(long double x) {\n+  return 1.0L - expl(-x);\n+}\n+\n+\/\/ The function that describes the normal distribution with mean 0 and standard deviation 1, scaled by sqrtl(0.5L*PI).\n+\/\/ See https:\/\/en.wikipedia.org\/wiki\/Normal_distribution\n+long double normal_f(long double x) {\n+  return expl(-0.5L*x*x);\n+}\n+\n+\/\/ The cumulative distribution function for the (right half of the) normal distribution with mean 0 and standard deviation 1.\n+long double normal_cdf(long double x) {\n+  return sqrtl(0.5L*PI) * erfl(sqrtl(0.5L)*x);\n+}\n+\n+\/\/ A function that will be zero at an x such that the new box will have area box_area.\n+long double box_g(long double x, longdoublefn f, long double last_Y_i, long double box_area) {\n+  return x*(f(x) - last_Y_i) - box_area;\n+}\n+\n+\/\/ A function that will be zero at an x such that, if f is normal_f, the tangent at point (x, f(x)) has slope m.\n+long double normal_tangent_g(long double x, longdoublefn f, long double m, long double unused) {\n+  return x*f(x) - m;\n+}\n+\n+\/\/ This routine generates all the parameters and tables for one kind of sampler.\n+void generate_tables(char *kind) {\n+  \/\/ kind may be \"normal\" or \"exponential\"\n+  assert(!strcmp(kind, \"exponential\") || !strcmp(kind, \"normal\"));\n+\n+  \/\/ SIZE must be a power of 2 (the code for Walker's alias method depends on it)\n+  assert((SIZE & -SIZE) == SIZE);\n+  \/\/ We require that SIZE <= 2048 because one place in the algorithm uses the\n+  \/\/ high 53 bits of a randomly chosen 64-bit integer to make a floating-point\n+  \/\/ (double) value after having already used the low bits to choose an integer\n+  \/\/ in the range [0,SIZE), and it is important that these two values be independent.\n+  \/\/ One consequence is that a value less than SIZE will certainly fit in a short\n+  \/\/ (and we will use a byte instead if SIZE <= 256).\n+  assert(SIZE <= 2048);\n+\n+  \/\/ A number of parameters need to be declared and then filled in according to the kind.\n+  \/\/ The total area under the probability curve for x >= 0:\n+  long double total_area_under_curve;\n+  \/\/ The function for the probability curve and also its cumulative distribution function:\n+  longdoublefn f, cdf;\n+  \/\/ Heuristic initial bounds for using the solver to calculate the X values:\n+  long double initial_lower_bound, initial_upper_bound;\n+  if (!strcmp(kind, \"exponential\")) {\n+    printf(\"    \/\/ Implementation support for modified-ziggurat implementation of nextExponential()\\n\\n\");\n+    total_area_under_curve = 1.0L;\n+    f = exponential_f; cdf = exponential_cdf;\n+    initial_lower_bound = 1.0L; initial_upper_bound = 10.0L;\n+  } else if (!strcmp(kind, \"normal\")) {\n+    printf(\"    \/\/ Implementation support for modified-ziggurat implementation of nextGaussian()\\n\\n\");\n+    \/\/ The \"total area under curve\" is for x >= 0 only, so we divide sqrtl(2.0L*PI) by 2.\n+    total_area_under_curve = sqrtl(2.0L*PI)\/2.0L;\n+    f = normal_f; cdf = normal_cdf;\n+    initial_lower_bound = 1.0L; initial_upper_bound = 4.0L;\n+  }\n+  \/\/ Make sure the claimed area under the curve is correct\n+  \/\/ (or think of it as a sanity check on the cdf).\n+  check_equal(total_area_under_curve, cdf(INFINITY) - cdf(0.0L));\n+\n+  \/\/ The first task is to compute the boxes of the modified ziggurat.\n+  \/\/ The X values are found by an iterative solving process; after that the Y values are easy.\n+  long double X[SIZE], Y[SIZE];\n+  long double box_area = total_area_under_curve \/ ((long double)SIZE);\n+  long double lower_bound = initial_lower_bound;\n+  long double upper_bound = initial_upper_bound;\n+  long double last_Y_i = 0.0L;\n+  int i = 0;\n+  while(lower_bound * f(0.0L) > box_area) {\n+    \/\/ There are two solutions for X_i (a tall-skinny box and a long-flat box).\n+    \/\/ We want the latter, so lower_bound is reduced gradually to avoid solving\n+    \/\/ for the tall-skinny box.  The two values of 0.9L are purely heuristic.\n+    X[i] = fsolve(box_g, f, last_Y_i, box_area, lower_bound, upper_bound);\n+    if (isnan(X[i])) {\n+      lower_bound *= 0.9L;\n+    } else {\n+      last_Y_i = f(X[i]);\n+      upper_bound = X[i];\n+      lower_bound = 0.9L*X[i];\n+      ++i;\n+    }\n+  }\n+  int number_of_layers = i;\n+  \/\/ One _could_ think of there being an extra layer at the top with a box of width 0.\n+  \/\/ However, to be consistent with McFarland's description, we will not call that a layer.\n+  \/\/ Also, what McFarland calls an \"overhanging box\", we will call a \"rectangle\";\n+  \/\/ each rectangle contains part of the curve, and the rest of the curve is above the tail.\n+  \/\/ So there are number_of_layers boxes, numbered from 0 through (number_of_layers - 1);\n+  \/\/ number_of_layers rectangles (one of which, the topmost, has no box to its left),\n+  \/\/ numbered from 1 through number_of_layers; and a tail (which is to the right of box 0).\n+  \/\/ For 1 <= k < number_of_layers, rectangle i is to the right of box i.\n+  X[i] = 0.0L;\n+  \/\/ We have all the X values; nocompute the corresponding Y values.\n+  for (int k = 0; k < number_of_layers + 1; k++) Y[k] = f(X[k]);\n+  \/\/ Now we have (number_of_layers + 1) X values and (number_of_layers + 1) Y values.\n+  \/\/ For each i, 0 <= i <= number_of_layers, the point (X[i], Y[i]) lies on the curve.\n+\n+  \/\/ The next step is to compute the differences dX and dY.\n+  long double dX[SIZE], dY[SIZE];\n+  \/\/ Note that dX is calculated one way and dY the other way;\n+  \/\/ that way all the difference values are positive.\n+  for (int k = 0; k < number_of_layers; k++) dX[k] = X[k] - X[k+1];\n+  for (int k = 0; k < number_of_layers; k++) dY[k] = Y[k+1] - Y[k];\n+  \/\/ Sanity check to ensure all the boxes have the correct area\n+  check_equal(X[0]*Y[0], box_area);\n+  for (int k = 0; k < number_of_layers - 1; k++) check_equal(X[k+1]*dY[k], box_area);\n+  \/\/ Now we can say that box i (0 <= i <= (number_of_layers - 1)) has width X[i] and height dY[i],\n+  \/\/ and rectangle i (1 <= i <= number_of_layers) has width dX[i-1] and height dY[i-1].\n+\n+  \/\/ The next step is to construct a discrete probability distribution V\n+  \/\/ that encompasses the tail and all the overhang areas (in the rectangles).\n+  long double V[SIZE];\n+  V[0] = cdf(INFINITY) - cdf(X[0]);\n+  for (int k = 0; k < number_of_layers; k++) {\n+    V[k+1] = (cdf(X[k]) - cdf(X[k+1])) - Y[k]*dX[k];\n+  }\n+  for (int k = number_of_layers + 1; k < SIZE; k++) V[k] = 0.0L;\n+  \/\/ Now V[0] is the area of the tail, and V[i] (1 <= i <= number_of_layers)\n+  \/\/ is the area within rectangle i that lies under the curve.\n+  \/\/ Remaining entries are zero.  (The only reason for this zero padding\n+  \/\/ is to make the length of V be a power of 2, which allows generation\n+  \/\/ of a randomly chosen index into V to be faster, using a masking operation\n+  \/\/ rather than a modulus operator.)\n+\n+  \/\/ Sanity check that all area under the curve is accounted for.\n+  long double V_sum = 0.0L;\n+  for (int k = 0; k < number_of_layers + 1; k++) V_sum += V[k];\n+  check_equal((double long)(SIZE - number_of_layers), V_sum\/box_area);\n+  \/\/ Report some interesting statistics.\n+  printf(\"    \/\/ Fraction of the area under the curve that lies outside the layer boxes: %.4f\\n\", (double)(SIZE - number_of_layers)\/(double)SIZE);\n+  printf(\"    \/\/ Fraction of non-box area that lies in the tail of the distribution: %.4f\\n\", (double)(V[0]\/V_sum));\n+  printf(\"\\n\");\n+\n+  \/\/ Use V to construct tables called \"alias_threshold\" and \"alias_map\" for use with\n+  \/\/ Walker's alias method for sampling a discrete distribution efficiently.\n+  long double alias_threshold[SIZE];\n+  int alias_map[SIZE];\n+  \/\/ Routine build_sampler normalizes V and then turns it into thresholds,\n+  \/\/ and also constructs the alias_map table.\n+  build_sampler(V, alias_map, SIZE);\n+  \/\/ Now produce the alias_threshold table from V by scaling it and converting to integer values.\n+  \/\/ This is a trick that allows direct comparison with randomly chosen integer values,\n+  \/\/ rather than requiring generation of a randomly chosen floating-point value.\n+  for (int k = 0; k < SIZE; k++) {\n+    if (V[k] >= 1.0L) {\n+      \/\/ This \"shouldn't happen\", but rounding errors are possible, so we defend against it\n+      alias_threshold[k] = max_int;\n+    } else {\n+      alias_threshold[k] = (int_type)(V[k] * max_uint - max_int);\n+    }\n+  }\n+\n+  \/\/ Here each m[k] is computed as a positive value, which is therefore the negative of the\n+  \/\/ true slope of the diagonal line (within rectangle k+1) whose endpoints lie on the curve.\n+  long double m[SIZE];\n+  for (int k = 0; k < number_of_layers; k++) m[k] = dY[k]\/dX[k];\n+\n+  \/\/ Now it is time to compute and output all the parameters.\n+  \/\/ It is really important that each parameter be declared \"final\"; it allows\n+  \/\/ a huge speed improvement because the Java compiler can then inline the constants.\n+  printf(\"    static final int %sNumberOfLayers = %d;\\n\", kind, number_of_layers);\n+  printf(\"    static final int %sLayerMask = 0x%x;\\n\", kind, SIZE-1);\n+  printf(\"    static final int %sAliasMask = 0x%x;\\n\", kind, SIZE-1);\n+  printf(\"    static final int %sSignCorrectionMask = 0x%x;\\n\", kind, (SIZE == 256) ? 0xff : 0xffffffff);\n+  printf(\"    static final %s %sX0 = %19.17f;\\n\", java_float_type, kind, (double)(float_type)X[0]);\n+  if (!strcmp(kind, \"exponential\")) {\n+    \/\/ Within each rectangle, we want to find a point on the curve where the tangent\n+    \/\/ is parallel to the diagonal line of the rectangle whose slope is m.\n+\n+    \/\/ The first derivative of the exponential function exp(-x) is -exp(-x), whose value\n+    \/\/ at X[k] is -exp(-X[k]) which is -Y[k].  So we can compare m values and Y values directly.\n+    \/\/ Sanity check: we expect Y[k+1] > m > Y[k].\n+    for (int k = 0; k < number_of_layers; k++) {\n+      assert(m[k] > Y[k]);\n+      assert(Y[k+1] > m[k]);\n+    }\n+    \/\/ Now for some math.  Within rectangle k+1, the point on the curve where the\n+    \/\/ tangent is parallel to that diagonal must have coordinates (-log(m[k]), m[k]).\n+    \/\/ The point on the diagonal directly above it (with the same x-coordinate) is\n+    \/\/ (-log(m[k]), Y[k+1]-m[k]*(-log(m[k])-X[k+1])).  The vertical distance between\n+    \/\/ them is therefore Y[k+1] - m[k]*(-log(m[k])-X[k+1]) - m[k].  We can then divide\n+    \/\/ this by dY[k] to normalize it to a fraction of the height of the rectangle.\n+    \/\/ We could have a table of all these fractions, so that we would have just the\n+    \/\/ right fraction for use with each rectangle; but it saves space (and loses very\n+    \/\/ little time) to just compute the maximum such fraction over all rectangles,\n+    \/\/ and then use that maximum fraction whenever processing any rectangle.\n+    long double convex_margin = -INFINITY;\n+    for (int k = 0; k < number_of_layers; k++) {\n+      long double X_tangent = -logl(m[k]);\n+      long double E = (Y[k+1] - m[k]*(X_tangent - X[k+1]) - m[k]) \/ dY[k];\n+      convex_margin = (convex_margin > E) ? convex_margin : E;\n+    }\n+    int_type scaled_convex_margin = (int_type)(convex_margin * (long double)max_int);\n+    printf(\"    static final %s %sConvexMargin = %lldL;   \/\/ unscaled convex margin = %.4f\\n\",\n+      java_int_type, kind, (long long)scaled_convex_margin, (double)convex_margin);\n+  } else if (!strcmp(kind, \"normal\")) {\n+    \/\/ Within each rectangle, we want to find a point on the curve where the tangent\n+    \/\/ is parallel to the diagonal line of the rectangle whose slope is m.\n+\n+    long double inflection_point_x = 1.0L;\n+    int normal_inflection_index = 0;\n+    for (int k = 0; k < number_of_layers + 1; k++) {\n+      if (X[k] > inflection_point_x) ++normal_inflection_index;\n+    }\n+    \/\/ The inflection point lies within rectangle normal_inflection_index.\n+    \/\/ The x-coordinate of the inflection point lies between\n+    \/\/ X[normal_inflection_index] and X[normal_inflection_index - 1].\n+\n+    \/\/ In principle we could have trouble if the inflection point lies exactly\n+    \/\/ on corner of a box (but it doesn't happen in practice).\n+    assert(X[normal_inflection_index] < inflection_point_x);\n+    printf(\"    static final int normalInflectionIndex = %d;\\n\", normal_inflection_index);\n+\n+    \/\/ Now for some math.  The first derivative of the normal curve function exp(-x*x\/2)\n+    \/\/ at X[k] is -X[k]*exp(-X[k]*X[k]\/2) which is -X[k]*f(X[k]).  We use the function\n+    \/\/ normal_tangent_g with the solver to find the x-coordinate of a point on the\n+    \/\/ curve within rectangle k+1 where the tangent has slope m[k].  The rectangle that\n+    \/\/ contains the inflection point will have two such points, so that rectangle gets\n+    \/\/ special processing.\n+    \/\/ For each such tangent point, the idea is to compute the vertical distance between\n+    \/\/ that point and the diagonal, then divide by the height of the rectangle to normalize.\n+    \/\/ We could have a table of all these fractions, so that we would have just the\n+    \/\/ right fraction(s) for use with each rectangle; but it saves space (and loses very\n+    \/\/ little time) to just compute the maximum such fraction over a set of rectangles,\n+    \/\/ and then conservatively use that maximum fraction whenever processing any rectangle.\n+    \/\/ Instead of taking the maximum fraction over all rectangles (as we do for the\n+    \/\/ exponential function) we compute two separate maxima: one over all tangent points\n+    \/\/ below the diagonal (where the curve is convex) and one over all tangent points\n+    \/\/ above the diagonal (where the curve is concave).  Note that the rectangle containing\n+    \/\/ the inflection point has one of each.\n+    long double convex_margin = -INFINITY, concave_margin = -INFINITY;\n+    for (int k = 0; k < number_of_layers; k++) {\n+      \/\/ Process rectangle k+1\n+      if ((k+1) <= normal_inflection_index) {\n+   \/\/ The rectangle has a convex portion of the curve\n+   long double lower_bound = ((k+1) == normal_inflection_index) ? inflection_point_x : X[k+1];\n+   long double X_tangent = fsolve(normal_tangent_g, f, m[k], 0.0, lower_bound, X[k]);\n+   long double E = (Y[k+1] - m[k]*(X_tangent - X[k+1]) - f(X_tangent)) \/ dY[k];\n+       convex_margin = (convex_margin > E) ? convex_margin : E;\n+      }\n+      if ((k+1) >= normal_inflection_index) {\n+   \/\/ The rectangle has a concave portion of the curve\n+   long double upper_bound = ((k+1) == normal_inflection_index) ? inflection_point_x : X[k];\n+   long double X_tangent = fsolve(normal_tangent_g, f, m[k], 0.0, X[k+1], upper_bound);\n+   long double E = - (Y[k+1] - m[k]*(X_tangent - X[k+1]) - f(X_tangent)) \/ dY[k];\n+       concave_margin = (concave_margin > E) ? concave_margin : E;\n+      }\n+    }\n+    int_type scaled_convex_margin = (int_type)(convex_margin * (long double)max_int);\n+    int_type scaled_concave_margin = (int_type)(concave_margin * (long double)max_int);\n+    printf(\"    static final %s %sConvexMargin = %lldL;   \/\/ unscaled convex margin = %.4f\\n\",\n+      java_int_type, kind, (long long)scaled_convex_margin, (double)convex_margin);\n+    printf(\"    static final %s %sConcaveMargin = %lldL;   \/\/ unscaled concave margin = %.4f\\n\",\n+      java_int_type, kind, (long long)scaled_concave_margin, (double)concave_margin);\n+  }\n+  printf(\"\\n\");\n+\n+  \/\/ Output the X array\n+  printf(\"    \/\/ %s_X[i] = length of ziggurat layer i for %s distribution, scaled by 2**(-%d)\\n\", kind, kind, int_bits-1);\n+  printf(\"    static final %s[] %sX = {      \/\/ %d entries, which is %s_number_of_layers+1\\n\", java_float_type, kind, number_of_layers+1, kind);\n+  for (int k = 0; k < number_of_layers+1; k++) {\n+    if ((k & 0x3) == 0) printf(\"        \");\n+    printf(\"%23.16e\", (float_type)X[k] \/ (float_type)max_int);\n+    if (k < number_of_layers) {\n+      printf(\",\");\n+      if ((k & 0x3) < 3) printf(\" \");\n+      else printf(\"\\n\");\n+    } else {\n+      printf(\" };\\n\");\n+    }\n+  }\n+  printf(\"\\n\");\n+\n+  \/\/ Output the Y array\n+  printf(\"    \/\/ %s_Y[i] = value of the %s distribution function at %s_X[i], scaled by 2**(-%d)\\n\", kind, kind, kind, int_bits-1);\n+  printf(\"    static final %s[] %sY = {      \/\/ %d entries, which is %s_number_of_layers+1\\n\", java_float_type, kind, number_of_layers+1, kind);\n+  for (int k = 0; k < number_of_layers+1; k++) {\n+    if ((k & 0x3) == 0) printf(\"        \");\n+    printf(\"%23.16e\", (float_type)Y[k] \/ (float_type)max_int);\n+    if (k < number_of_layers) {\n+      printf(\",\");\n+      if ((k & 0x3) < 3) printf(\" \");\n+      else printf(\"\\n\");\n+    } else {\n+      printf(\" };\\n\");\n+    }\n+  }\n+  printf(\"\\n\");\n+\n+  \/\/ Output the alias_threshold array\n+  printf(\"    \/\/ alias_threshold[j] is a threshold for the probability mass function that has been\\n\");\n+  printf(\"    \/\/ scaled by (2**%d - 1), translated by -(2**%d), and represented as a %s value;\\n\", int_bits, int_bits-1, java_int_type);\n+  printf(\"    \/\/ in this way it can be directly compared to a randomly chosen %s value.\\n\", java_int_type);\n+  printf(\"    static final long[] %sAliasThreshold = {    \/\/ %d entries\\n\", kind, SIZE);\n+  for (int k = 0; k < SIZE; k++) {\n+    if ((k & 0x3) == 0) printf(\"        \");\n+    printf(\"%20lldL\", (long long)alias_threshold[k]);\n+    if (k < (SIZE - 1)) {\n+      printf(\",\");\n+      if ((k & 0x3) < 3) printf(\" \");\n+      else printf(\"\\n\");\n+    } else {\n+      printf(\" };\\n\");\n+    }\n+  }\n+  printf(\"\\n\");\n+\n+  \/\/ Output the alias_map array\n+  char *small_int_type = (SIZE <= 256) ? \"byte\" : \"short\";\n+  int map_items_per_line = (SIZE == 256) ? 8 : 16;\n+  printf(\"    static final %s[] %sAliasMap = {    \/\/ %d entries\\n\", small_int_type, kind, SIZE);\n+  for (int k = 0; k < SIZE; k++) {\n+    if ((k % map_items_per_line) == 0) printf(\"        \");\n+    if (SIZE == 256) printf(\"(byte)\");\n+    printf(\"%3d\", alias_map[k]);\n+    if (k < (SIZE - 1)) {\n+      printf(\",\");\n+      if ((k % map_items_per_line) < (map_items_per_line - 1)) printf(\" \");\n+      else printf(\"\\n\");\n+    } else {\n+      printf(\" };\\n\");\n+    }\n+  }\n+  printf(\"\\n\");\n+}\n+\n+int main(int argc, char *argv[]) {\n+  printf(\"\/\/ This Java source file is generated automatically by the program `create_ziggurat_tables.c`.\\n\");\n+  printf(\"\\n\");\n+  printf(\"\/*\\n\");\n+  printf(\" * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\\n\");\n+  printf(\" * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\\n\");\n+  printf(\" *\\n\");\n+  printf(\" * This code is free software; you can redistribute it and\/or modify it\\n\");\n+  printf(\" * under the terms of the GNU General Public License version 2 only, as\\n\");\n+  printf(\" * published by the Free Software Foundation.  Oracle designates this\\n\");\n+  printf(\" * particular file as subject to the \\\"Classpath\\\" exception as provided\\n\");\n+  printf(\" * by Oracle in the LICENSE file that accompanied this code.\\n\");\n+  printf(\" *\\n\");\n+  printf(\" * This code is distributed in the hope that it will be useful, but WITHOUT\\n\");\n+  printf(\" * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\\n\");\n+  printf(\" * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\\n\");\n+  printf(\" * version 2 for more details (a copy is included in the LICENSE file that\\n\");\n+  printf(\" * accompanied this code).\\n\");\n+  printf(\" *\\n\");\n+  printf(\" * You should have received a copy of the GNU General Public License version\\n\");\n+  printf(\" * 2 along with this work; if not, write to the Free Software Foundation,\\n\");\n+  printf(\" * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\\n\");\n+  printf(\" *\\n\");\n+  printf(\" * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\\n\");\n+  printf(\" * or visit www.oracle.com if you need additional information or have any\\n\");\n+  printf(\" * questions.\\n\");\n+  printf(\" *\/\\n\");\n+  printf(\"package java.util;\\n\");\n+  printf(\"\\n\");\n+  printf(\"class %sZigguratTables {\\n\", java_capitalized_float_type);\n+  printf(\"\\n\");\n+  generate_tables(\"exponential\");\n+  generate_tables(\"normal\");\n+  printf(\"}\\n\");\n+}\n","filename":"src\/java.base\/share\/native\/random\/create_ziggurat_tables.c","additions":688,"deletions":0,"binary":false,"changes":688,"status":"added"},{"patch":"@@ -0,0 +1,348 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.random;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.random.RandomGenerator;\n+import jdk.internal.util.random.RandomSupport;\n+import jdk.internal.util.random.RandomSupport.AbstractSplittableWithBrineGenerator;\n+import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n+\n+\/**\n+ * A \"splittable\" pseudorandom number generator (PRNG) whose period\n+ * is roughly 2<sup>1152<\/sup>.  Class {@link L128X1024MixRandom} implements\n+ * interfaces {@link RandomGenerator} and {@link SplittableGenerator},\n+ * and therefore supports methods for producing pseudorandomly chosen\n+ * values of type {@code int}, {@code long}, {@code float}, {@code double},\n+ * and {@code boolean} (and for producing streams of pseudorandomly chosen\n+ * numbers of type {@code int}, {@code long}, and {@code double}),\n+ * as well as methods for creating new split-off {@link L128X1024MixRandom}\n+ * objects or streams of such objects.\n+ *\n+ * <p>The {@link L128X1024MixRandom} algorithm is a specific member of\n+ * the LXM family of algorithms for pseudorandom number generators;\n+ * for more information, see the documentation for package\n+ * {@link jdk.random}.  Each instance of {@link L128X1024MixRandom}\n+ * has 1152 bits of state plus one 128-bit instance-specific parameter.\n+ *\n+ * <p>If two instances of {@link L128X1024MixRandom} are created with\n+ * the same seed within the same program execution, and the same\n+ * sequence of method calls is made for each, they will generate and\n+ * return identical sequences of values.\n+ *\n+ * <p>As with {@link java.util.SplittableRandom}, instances of\n+ * {@link L128X1024MixRandom} are <em>not<\/em> thread-safe.  They are\n+ * designed to be split, not shared, across threads (see the {@link #split}\n+ * method). For example, a {@link java.util.concurrent.ForkJoinTask}\n+ * fork\/join-style computation using random numbers might include a\n+ * construction of the form\n+ * {@code new Subtask(someL128X1024MixRandom.split()).fork()}.\n+ *\n+ * <p>This class provides additional methods for generating random\n+ * streams, that employ the above techniques when used in\n+ * {@code stream.parallel()} mode.\n+ *\n+ * <p>Instances of {@link L128X1024MixRandom} are not cryptographically\n+ * secure.  Consider instead using {@link java.security.SecureRandom}\n+ * in security-sensitive applications. Additionally,\n+ * default-constructed instances do not use a cryptographically random\n+ * seed unless the {@linkplain System#getProperty system property}\n+ * {@code java.util.secureRandomSeed} is set to {@code true}.\n+ *\n+ * @since   17\n+ *\n+ *\/\n+@RandomGeneratorProperties(\n+        name = \"L128X1024MixRandom\",\n+        group = \"LXM\",\n+        i = 1024, j = 1, k = 128,\n+        equidistribution = 1\n+)\n+public final class L128X1024MixRandom extends AbstractSplittableWithBrineGenerator {\n+\n+    \/*\n+     * Implementation Overview.\n+     *\n+     * The 128-bit parameter `a` is represented as two long fields `ah` and `al`.\n+     * The 128-bit state variable `s` is represented as two long fields `sh` and `sl`.\n+     *\n+     * The split operation uses the current generator to choose 20\n+     * new 64-bit long values that are then used to initialize the\n+     * parameters `ah` and `al`, the state variables `sh`, `sl`,\n+     * and the array `x` for a newly constructed generator.\n+     *\n+     * With extremely high probability, no two generators so chosen\n+     * will have the same `a` parameter, and testing has indicated\n+     * that the values generated by two instances of {@link L128X1024MixRandom}\n+     * will be (approximately) independent if have different values for `a`.\n+     *\n+     * The default (no-argument) constructor, in essence, uses\n+     * \"defaultGen\" to generate 20 new 64-bit values for the same\n+     * purpose.  Multiple generators created in this way will certainly\n+     * differ in their `a` parameters.  The defaultGen state must be accessed\n+     * in a thread-safe manner, so we use an AtomicLong to represent\n+     * this state.  To bootstrap the defaultGen, we start off using a\n+     * seed based on current time unless the\n+     * java.util.secureRandomSeed property is set. This serves as a\n+     * slimmed-down (and insecure) variant of SecureRandom that also\n+     * avoids stalls that may occur when using \/dev\/random.\n+     *\n+     * File organization: First static fields, then instance\n+     * fields, then constructors, then instance methods.\n+     *\/\n+\n+    \/* ---------------- static fields ---------------- *\/\n+\n+    \/*\n+     * The length of the array x.\n+     *\/\n+\n+    private static final int N = 16;\n+\n+    \/**\n+     * The seed generator for default constructors.\n+     *\/\n+    private static final AtomicLong defaultGen = new AtomicLong(RandomSupport.initialSeed());\n+\n+    \/*\n+     * Low half of multiplier used in the LCG portion of the algorithm;\n+     * the overall multiplier is (2**64 + ML).\n+     * Chosen based on research by Sebastiano Vigna and Guy Steele (2019).\n+     * The spectral scores for dimensions 2 through 8 for the multiplier 0x1d605bbb58c8abbfdLL\n+     * are [0.991889, 0.907938, 0.830964, 0.837980, 0.780378, 0.797464, 0.761493].\n+     *\/\n+\n+    private static final long ML = 0xd605bbb58c8abbfdL;\n+\n+    \/* ---------------- instance fields ---------------- *\/\n+\n+    \/**\n+     * The parameter that is used as an additive constant for the LCG.\n+     * Must be odd (therefore al must be odd).\n+     *\/\n+    private final long ah, al;\n+\n+    \/**\n+     * The per-instance state: sh and sl for the LCG; the array x for the xorshift;\n+     * p is the rotating pointer into the array x.\n+     * At least one of the 16 elements of the array x must be nonzero.\n+     *\/\n+    private long sh, sl;\n+    private final long[] x;\n+    private int p = N - 1;\n+\n+    \/* ---------------- constructors ---------------- *\/\n+\n+    \/**\n+     * Basic constructor that initializes all fields from parameters.\n+     * It then adjusts the field values if necessary to ensure that\n+     * all constraints on the values of fields are met.\n+     *\n+     * @param ah high half of the additive parameter for the LCG\n+     * @param al low half of the additive parameter for the LCG\n+     * @param sh high half of the initial state for the LCG\n+     * @param sl low half of the initial state for the LCG\n+     * @param x0 first word of the initial state for the xorshift generator\n+     * @param x1 second word of the initial state for the xorshift generator\n+     * @param x2 third word of the initial state for the xorshift generator\n+     * @param x3 fourth word of the initial state for the xorshift generator\n+     * @param x4 fifth word of the initial state for the xorshift generator\n+     * @param x5 sixth word of the initial state for the xorshift generator\n+     * @param x6 seventh word of the initial state for the xorshift generator\n+     * @param x7 eight word of the initial state for the xorshift generator\n+     * @param x8 ninth word of the initial state for the xorshift generator\n+     * @param x9 tenth word of the initial state for the xorshift generator\n+     * @param x10 eleventh word of the initial state for the xorshift generator\n+     * @param x11 twelfth word of the initial state for the xorshift generator\n+     * @param x12 thirteenth word of the initial state for the xorshift generator\n+     * @param x13 fourteenth word of the initial state for the xorshift generator\n+     * @param x14 fifteenth word of the initial state for the xorshift generator\n+     * @param x15 sixteenth word of the initial state for the xorshift generator\n+     *\/\n+    public L128X1024MixRandom(long ah, long al, long sh, long sl,\n+                 long x0, long x1, long x2, long x3,\n+                 long x4, long x5, long x6, long x7,\n+                 long x8, long x9, long x10, long x11,\n+                 long x12, long x13, long x14, long x15) {\n+        \/\/ Force a to be odd.\n+   this.ah = ah;\n+        this.al = al | 1;\n+        this.sh = sh;\n+        this.sl = sl;\n+        this.x = new long[N];\n+        this.x[0] = x0;\n+        this.x[1] = x1;\n+        this.x[2] = x2;\n+        this.x[3] = x3;\n+        this.x[4] = x4;\n+        this.x[5] = x5;\n+        this.x[6] = x6;\n+        this.x[7] = x7;\n+        this.x[8] = x8;\n+        this.x[9] = x9;\n+        this.x[10] = x10;\n+        this.x[11] = x11;\n+        this.x[12] = x12;\n+        this.x[13] = x13;\n+        this.x[14] = x14;\n+        this.x[15] = x15;\n+        \/\/ If x0, x1, ..., x15 are all zero (very unlikely), we must choose nonzero values.\n+        if ((x0 | x1 | x2 | x3 | x4 | x5 | x6 | x7 | x8 | x9 | x10 | x11 | x12 | x13 | x14 | x15) == 0) {\n+       long v = sh;\n+            \/\/ At least fifteen of the sixteen values generated here will be nonzero.\n+            for (int j = 0; j < N; j++) {\n+                this.x[j] = RandomSupport.mixStafford13(v += RandomSupport.GOLDEN_RATIO_64);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L128X1024MixRandom} using the\n+     * specified {@code long} value as the initial seed. Instances of\n+     * {@link L128X1024MixRandom} created with the same seed in the same\n+     * program execution generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public L128X1024MixRandom(long seed) {\n+        \/\/ Using a value with irregularly spaced 1-bits to xor the seed\n+        \/\/ argument tends to improve \"pedestrian\" seeds such as 0 or\n+        \/\/ other small integers.  We may as well use SILVER_RATIO_64.\n+        \/\/\n+        \/\/ The seed is hashed by mixMurmur64 to produce the `a` parameter.\n+        \/\/ The seed is hashed by mixStafford13 to produce the initial `x[0]`,\n+        \/\/ which will then be used to produce the first generated value.\n+        \/\/ The other x values are filled in as if by a SplitMix PRNG with\n+        \/\/ GOLDEN_RATIO_64 as the gamma value and mixStafford13 as the mixer.\n+        this(RandomSupport.mixMurmur64(seed ^= RandomSupport.SILVER_RATIO_64),\n+             RandomSupport.mixMurmur64(seed += RandomSupport.GOLDEN_RATIO_64),\n+             0,\n+             1,\n+             RandomSupport.mixStafford13(seed),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed + RandomSupport.GOLDEN_RATIO_64));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L128X1024MixRandom} that is likely to\n+     * generate sequences of values that are statistically independent\n+     * of those of any other instances in the current program execution,\n+     * but may, and typically does, vary across program invocations.\n+     *\/\n+    public L128X1024MixRandom() {\n+        \/\/ Using GOLDEN_RATIO_64 here gives us a good Weyl sequence of values.\n+        this(defaultGen.getAndAdd(RandomSupport.GOLDEN_RATIO_64));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L128X1024MixRandom} using the specified array of\n+     * initial seed bytes. Instances of {@link L128X1024MixRandom} created with the same\n+     * seed array in the same program execution generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public L128X1024MixRandom(byte[] seed) {\n+        \/\/ Convert the seed to 20 long values, of which the last 16 are not all zero.\n+        long[] data = RandomSupport.convertSeedBytesToLongs(seed, 20, 16);\n+   long ah = data[0], al = data[1], sh = data[2], sl = data[3];\n+        \/\/ Force a to be odd.\n+        this.ah = ah;\n+        this.al = al | 1;\n+        this.sh = sh;\n+        this.sl = sl;\n+        this.x = new long[N];\n+        for (int j = 0; j < N; j++) {\n+            this.x[j] = data[4+j];\n+        }\n+    }\n+\n+    \/* ---------------- public methods ---------------- *\/\n+\n+    @Override\n+    public SplittableGenerator split(SplittableGenerator source, long brine) {\n+       \/\/ Pick a new instance \"at random\", but use the brine for (the low half of) `a`.\n+        return new L128X1024MixRandom(source.nextLong(), brine << 1,\n+                     source.nextLong(), source.nextLong(),\n+                     source.nextLong(), source.nextLong(),\n+                     source.nextLong(), source.nextLong(),\n+                     source.nextLong(), source.nextLong(),\n+                     source.nextLong(), source.nextLong(),\n+                     source.nextLong(), source.nextLong(),\n+                     source.nextLong(), source.nextLong(),\n+                     source.nextLong(), source.nextLong(),\n+                     source.nextLong(), source.nextLong());\n+    }\n+\n+    @Override\n+    public long nextLong() {\n+        \/\/ First part of xoroshiro1024: fetch array data\n+        final int q = p;\n+        final long s0 = x[p = (p + 1) & (N - 1)];\n+        long s15 = x[q];\n+\n+       \/\/ Compute the result based on current state information\n+       \/\/ (this allows the computation to be overlapped with state update).\n+        final long result = RandomSupport.mixLea64(sh + s0);\n+\n+       \/\/ Update the LCG subgenerator\n+        \/\/ The LCG is, in effect, s = ((1LL << 64) + ML) * s + a, if only we had 128-bit arithmetic.\n+        final long u = ML * sl;\n+\n+        \/\/ Note that Math.multiplyHigh computes the high half of the product of signed values,\n+        \/\/ but what we need is the high half of the product of unsigned values; for this we use the\n+        \/\/ formula \"unsignedMultiplyHigh(a, b) = multiplyHigh(a, b) + ((a >> 63) & b) + ((b >> 63) & a)\";\n+        \/\/ in effect, each operand is added to the result iff the sign bit of the other operand is 1.\n+        \/\/ (See Henry S. Warren, Jr., _Hacker's Delight_ (Second Edition), Addison-Wesley (2013),\n+        \/\/ Section 8-3, p. 175; or see the First Edition, Addison-Wesley (2003), Section 8-3, p. 133.)\n+        \/\/ If Math.unsignedMultiplyHigh(long, long) is ever implemented, the following line can become:\n+        \/\/         sh = (ML * sh) + Math.unsignedMultiplyHigh(ML, sl) + sl + ah;\n+        \/\/ and this entire comment can be deleted.\n+        sh = (ML * sh) + (Math.multiplyHigh(ML, sl) + ((ML >> 63) & sl) + ((sl >> 63) & ML)) + sl + ah;\n+        sl = u + al;\n+        if (Long.compareUnsigned(sl, u) < 0) ++sh;  \/\/ Handle the carry propagation from low half to high half.\n+\n+        \/\/ Second part of xoroshiro1024: update array data\n+        s15 ^= s0;\n+        x[q] = Long.rotateLeft(s0, 25) ^ s15 ^ (s15 << 27);\n+        x[p] = Long.rotateLeft(s15, 36);\n+\n+        return result;\n+    }\n+\n+}\n","filename":"src\/jdk.random\/share\/classes\/jdk\/random\/L128X1024MixRandom.java","additions":348,"deletions":0,"binary":false,"changes":348,"status":"added"},{"patch":"@@ -0,0 +1,277 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.random;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.random.RandomGenerator;\n+import jdk.internal.util.random.RandomSupport;\n+import jdk.internal.util.random.RandomSupport.AbstractSplittableWithBrineGenerator;\n+import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n+\n+\/**\n+ * A \"splittable\" pseudorandom number generator (PRNG) whose period\n+ * is roughly 2<sup>256<\/sup>.  Class {@link L128X128MixRandom} implements\n+ * interfaces {@link RandomGenerator} and {@link SplittableGenerator},\n+ * and therefore supports methods for producing pseudorandomly chosen\n+ * values of type {@code int}, {@code long}, {@code float}, {@code double},\n+ * and {@code boolean} (and for producing streams of pseudorandomly chosen\n+ * numbers of type {@code int}, {@code long}, and {@code double}),\n+ * as well as methods for creating new split-off {@link L128X128MixRandom}\n+ * objects or streams of such objects.\n+ *\n+ * <p>The {@link L128X128MixRandom} algorithm is a specific member of\n+ * the LXM family of algorithms for pseudorandom number generators;\n+ * for more information, see the documentation for package\n+ * {@link jdk.random}.  Each instance of {@link L128X128MixRandom}\n+ * has 256 bits of state plus one 128-bit instance-specific parameter.\n+ *\n+ * <p>If two instances of {@link L128X128MixRandom} are created with\n+ * the same seed within the same program execution, and the same\n+ * sequence of method calls is made for each, they will generate and\n+ * return identical sequences of values.\n+ *\n+ * <p>As with {@link java.util.SplittableRandom}, instances of\n+ * {@link L128X128MixRandom} are <em>not<\/em> thread-safe.  They are\n+ * designed to be split, not shared, across threads (see the {@link #split}\n+ * method). For example, a {@link java.util.concurrent.ForkJoinTask}\n+ * fork\/join-style computation using random numbers might include a\n+ * construction of the form\n+ * {@code new Subtask(someL128X128MixRandom.split()).fork()}.\n+ *\n+ * <p>This class provides additional methods for generating random\n+ * streams, that employ the above techniques when used in\n+ * {@code stream.parallel()} mode.\n+ *\n+ * <p>Instances of {@link L128X128MixRandom} are not cryptographically\n+ * secure.  Consider instead using {@link java.security.SecureRandom}\n+ * in security-sensitive applications. Additionally,\n+ * default-constructed instances do not use a cryptographically random\n+ * seed unless the {@linkplain System#getProperty system property}\n+ * {@code java.util.secureRandomSeed} is set to {@code true}.\n+ *\n+ * @since   17\n+ *\n+ *\/\n+@RandomGeneratorProperties(\n+        name = \"L128X128MixRandom\",\n+        group = \"LXM\",\n+        i = 128, j = 1, k = 128,\n+        equidistribution = 1\n+)\n+public final class L128X128MixRandom extends AbstractSplittableWithBrineGenerator {\n+\n+    \/*\n+     * Implementation Overview.\n+     *\n+     * The split operation uses the current generator to choose four new 64-bit\n+     * long values that are then used to initialize the parameter `a` and the\n+     * state variables `s`, `x0`, and `x1` for a newly constructed generator.\n+     *\n+     * With extremely high probability, no two generators so chosen\n+     * will have the same `a` parameter, and testing has indicated\n+     * that the values generated by two instances of {@link L128X128MixRandom}\n+     * will be (approximately) independent if have different values for `a`.\n+     *\n+     * The default (no-argument) constructor, in essence, uses\n+     * \"defaultGen\" to generate four new 64-bit values for the same\n+     * purpose.  Multiple generators created in this way will certainly\n+     * differ in their `a` parameters.  The defaultGen state must be accessed\n+     * in a thread-safe manner, so we use an AtomicLong to represent\n+     * this state.  To bootstrap the defaultGen, we start off using a\n+     * seed based on current time unless the\n+     * java.util.secureRandomSeed property is set. This serves as a\n+     * slimmed-down (and insecure) variant of SecureRandom that also\n+     * avoids stalls that may occur when using \/dev\/random.\n+     *\n+     * File organization: First static fields, then instance\n+     * fields, then constructors, then instance methods.\n+     *\/\n+\n+    \/* ---------------- static fields ---------------- *\/\n+\n+    \/**\n+     * The seed generator for default constructors.\n+     *\/\n+    private static final AtomicLong defaultGen = new AtomicLong(RandomSupport.initialSeed());\n+\n+    \/*\n+     * Low half of multiplier used in the LCG portion of the algorithm;\n+     * the overall multiplier is (2**64 + ML).\n+     * Chosen based on research by Sebastiano Vigna and Guy Steele (2019).\n+     * The spectral scores for dimensions 2 through 8 for the multiplier 0x1d605bbb58c8abbfdLL\n+     * are [0.991889, 0.907938, 0.830964, 0.837980, 0.780378, 0.797464, 0.761493].\n+     *\/\n+\n+    private static final long ML = 0xd605bbb58c8abbfdL;\n+\n+    \/* ---------------- instance fields ---------------- *\/\n+\n+    \/**\n+     * The parameter that is used as an additive constant for the LCG.\n+     * Must be odd (therefore al must be odd).\n+     *\/\n+    private final long ah, al;\n+\n+    \/**\n+     * The per-instance state: sh and sl for the LCG; x0 and x1 for the xorshift.\n+     * At least one of x0 and x1 must be nonzero.\n+     *\/\n+    private long sh, sl, x0, x1;\n+\n+    \/* ---------------- constructors ---------------- *\/\n+\n+    \/**\n+     * Basic constructor that initializes all fields from parameters.\n+     * It then adjusts the field values if necessary to ensure that\n+     * all constraints on the values of fields are met.\n+     *\n+     * @param ah high half of the additive parameter for the LCG\n+     * @param al low half of the additive parameter for the LCG\n+     * @param sh high half of the initial state for the LCG\n+     * @param sl low half of the initial state for the LCG\n+     * @param x0 first word of the initial state for the xorshift generator\n+     * @param x1 second word of the initial state for the xorshift generator\n+     *\/\n+    public L128X128MixRandom(long ah, long al, long sh, long sl, long x0, long x1) {\n+        \/\/ Force a to be odd.\n+        this.ah = ah;\n+        this.al = al | 1;\n+        this.sh = sh;\n+        this.sl = sl;\n+        this.x0 = x0;\n+        this.x1 = x1;\n+        \/\/ If x0 and x1 are both zero, we must choose nonzero values.\n+        if ((x0 | x1) == 0) {\n+       long v = sh;\n+            \/\/ At least one of the two values generated here will be nonzero.\n+            this.x0 = RandomSupport.mixStafford13(v += RandomSupport.GOLDEN_RATIO_64);\n+            this.x1 = RandomSupport.mixStafford13(v + RandomSupport.GOLDEN_RATIO_64);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L128X128MixRandom} using the\n+     * specified {@code long} value as the initial seed. Instances of\n+     * {@link L128X128MixRandom} created with the same seed in the same\n+     * program generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public L128X128MixRandom(long seed) {\n+        \/\/ Using a value with irregularly spaced 1-bits to xor the seed\n+        \/\/ argument tends to improve \"pedestrian\" seeds such as 0 or\n+        \/\/ other small integers.  We may as well use SILVER_RATIO_64.\n+        \/\/\n+        \/\/ The seed is hashed by mixMurmur64 to produce the `a` parameter.\n+        \/\/ The seed is hashed by mixStafford13 to produce the initial `x0`,\n+        \/\/ which will then be used to produce the first generated value.\n+        \/\/ Then x1 is filled in as if by a SplitMix PRNG with\n+        \/\/ GOLDEN_RATIO_64 as the gamma value and mixStafford13 as the mixer.\n+        this(RandomSupport.mixMurmur64(seed ^= RandomSupport.SILVER_RATIO_64),\n+             RandomSupport.mixMurmur64(seed += RandomSupport.GOLDEN_RATIO_64),\n+             0,\n+             1,\n+             RandomSupport.mixStafford13(seed),\n+             RandomSupport.mixStafford13(seed + RandomSupport.GOLDEN_RATIO_64));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L128X128MixRandom} that is likely to\n+     * generate sequences of values that are statistically independent\n+     * of those of any other instances in the current program execution,\n+     * but may, and typically does, vary across program invocations.\n+     *\/\n+    public L128X128MixRandom() {\n+        \/\/ Using GOLDEN_RATIO_64 here gives us a good Weyl sequence of values.\n+        this(defaultGen.getAndAdd(RandomSupport.GOLDEN_RATIO_64));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L128X128MixRandom} using the specified array of\n+     * initial seed bytes. Instances of {@link L128X128MixRandom} created with the same\n+     * seed array in the same program execution generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public L128X128MixRandom(byte[] seed) {\n+        \/\/ Convert the seed to 6 long values, of which the last 2 are not all zero.\n+        long[] data = RandomSupport.convertSeedBytesToLongs(seed, 6, 2);\n+        long ah = data[0], al = data[1], sh = data[2], sl = data[3], x0 = data[4], x1 = data[5];\n+        \/\/ Force a to be odd.\n+        this.ah = ah;\n+        this.al = al | 1;\n+        this.sh = sh;\n+        this.sl = sl;\n+        this.x0 = x0;\n+        this.x1 = x1;\n+    }\n+\n+    \/* ---------------- public methods ---------------- *\/\n+\n+    @Override\n+    public SplittableGenerator split(SplittableGenerator source, long brine) {\n+       \/\/ Pick a new instance \"at random\", but use the brine for (the low half of) `a`.\n+        return new L128X128MixRandom(source.nextLong(), brine << 1,\n+                    source.nextLong(), source.nextLong(),\n+                    source.nextLong(), source.nextLong());\n+    }\n+\n+    @Override\n+    public long nextLong() {\n+       \/\/ Compute the result based on current state information\n+       \/\/ (this allows the computation to be overlapped with state update).\n+        final long result = RandomSupport.mixLea64(sh + x0);\n+\n+       \/\/ Update the LCG subgenerator\n+        \/\/ The LCG is, in effect, s = ((1LL << 64) + ML) * s + a, if only we had 128-bit arithmetic.\n+        final long u = ML * sl;\n+       \/\/ Note that Math.multiplyHigh computes the high half of the product of signed values,\n+       \/\/ but what we need is the high half of the product of unsigned values; for this we use the\n+       \/\/ formula \"unsignedMultiplyHigh(a, b) = multiplyHigh(a, b) + ((a >> 63) & b) + ((b >> 63) & a)\";\n+       \/\/ in effect, each operand is added to the result iff the sign bit of the other operand is 1.\n+       \/\/ (See Henry S. Warren, Jr., _Hacker's Delight_ (Second Edition), Addison-Wesley (2013),\n+       \/\/ Section 8-3, p. 175; or see the First Edition, Addison-Wesley (2003), Section 8-3, p. 133.)\n+       \/\/ If Math.unsignedMultiplyHigh(long, long) is ever implemented, the following line can become:\n+       \/\/         sh = (ML * sh) + Math.unsignedMultiplyHigh(ML, sl) + sl + ah;\n+       \/\/ and this entire comment can be deleted.\n+        sh = (ML * sh) + (Math.multiplyHigh(ML, sl) + ((ML >> 63) & sl) + ((sl >> 63) & ML)) + sl + ah;\n+        sl = u + al;\n+        if (Long.compareUnsigned(sl, u) < 0) ++sh;  \/\/ Handle the carry propagation from low half to high half.\n+\n+        long q0 = x0, q1 = x1;\n+       \/\/ Update the Xorshift subgenerator\n+        {   \/\/ xoroshiro128v1_0\n+            q1 ^= q0;\n+            q0 = Long.rotateLeft(q0, 24);\n+            q0 = q0 ^ q1 ^ (q1 << 16);\n+            q1 = Long.rotateLeft(q1, 37);\n+        }\n+        x0 = q0; x1 = q1;\n+\n+        return result;\n+    }\n+\n+}\n","filename":"src\/jdk.random\/share\/classes\/jdk\/random\/L128X128MixRandom.java","additions":277,"deletions":0,"binary":false,"changes":277,"status":"added"},{"patch":"@@ -0,0 +1,301 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.random;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.random.RandomGenerator;\n+import jdk.internal.util.random.RandomSupport;\n+import jdk.internal.util.random.RandomSupport.AbstractSplittableWithBrineGenerator;\n+import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n+\n+\/**\n+ * A \"splittable\" pseudorandom number generator (PRNG) whose period\n+ * is roughly 2<sup>384<\/sup>.  Class {@link L128X256MixRandom} implements\n+ * interfaces {@link RandomGenerator} and {@link SplittableGenerator},\n+ * and therefore supports methods for producing pseudorandomly chosen\n+ * values of type {@code int}, {@code long}, {@code float}, {@code double},\n+ * and {@code boolean} (and for producing streams of pseudorandomly chosen\n+ * numbers of type {@code int}, {@code long}, and {@code double}),\n+ * as well as methods for creating new split-off {@link L128X256MixRandom}\n+ * objects or streams of such objects.\n+ *\n+ * <p>The {@link L128X256MixRandom} algorithm is a specific member of\n+ * the LXM family of algorithms for pseudorandom number generators;\n+ * for more information, see the documentation for package\n+ * {@link jdk.random}.  Each instance of {@link L128X256MixRandom}\n+ * has 384 bits of state plus one 128-bit instance-specific parameter.\n+ *\n+ * <p>If two instances of {@link L128X256MixRandom} are created with\n+ * the same seed within the same program execution, and the same\n+ * sequence of method calls is made for each, they will generate and\n+ * return identical sequences of values.\n+ *\n+ * <p>As with {@link java.util.SplittableRandom}, instances of\n+ * {@link L128X256MixRandom} are <em>not<\/em> thread-safe.  They are\n+ * designed to be split, not shared, across threads (see the {@link #split}\n+ * method). For example, a {@link java.util.concurrent.ForkJoinTask}\n+ * fork\/join-style computation using random numbers might include a\n+ * construction of the form\n+ * {@code new Subtask(someL128X256MixRandom.split()).fork()}.\n+ *\n+ * <p>This class provides additional methods for generating random\n+ * streams, that employ the above techniques when used in\n+ * {@code stream.parallel()} mode.\n+ *\n+ * <p>Instances of {@link L128X256MixRandom} are not cryptographically\n+ * secure.  Consider instead using {@link java.security.SecureRandom}\n+ * in security-sensitive applications. Additionally,\n+ * default-constructed instances do not use a cryptographically random\n+ * seed unless the {@linkplain System#getProperty system property}\n+ * {@code java.util.secureRandomSeed} is set to {@code true}.\n+ *\n+ * @since   17\n+ *\n+ *\/\n+@RandomGeneratorProperties(\n+        name = \"L128X256MixRandom\",\n+        group = \"LXM\",\n+        i = 256, j = 1, k = 128,\n+        equidistribution = 1\n+)\n+public final class L128X256MixRandom extends AbstractSplittableWithBrineGenerator {\n+\n+    \/*\n+     * Implementation Overview.\n+     *\n+     * The 128-bit parameter `a` is represented as two long fields `ah` and `al`.\n+     * The 128-bit state variable `s` is represented as two long fields `sh` and `sl`.\n+     *\n+     * The split operation uses the current generator to choose eight\n+     * new 64-bit long values that are then used to initialize the\n+     * parameters `ah` and `al` and the state variables `sh`, `sl`,\n+     * `x0`, `x1`, `x2`, and `x3` for a newly constructed generator.\n+     *\n+     * With extremely high probability, no two generators so chosen\n+     * will have the same `a` parameter, and testing has indicated\n+     * that the values generated by two instances of {@link L128X256MixRandom}\n+     * will be (approximately) independent if have different values for `a`.\n+     *\n+     * The default (no-argument) constructor, in essence, uses\n+     * \"defaultGen\" to generate eight new 64-bit values for the same\n+     * purpose.  Multiple generators created in this way will certainly\n+     * differ in their `a` parameters.  The defaultGen state must be accessed\n+     * in a thread-safe manner, so we use an AtomicLong to represent\n+     * this state.  To bootstrap the defaultGen, we start off using a\n+     * seed based on current time unless the\n+     * java.util.secureRandomSeed property is set. This serves as a\n+     * slimmed-down (and insecure) variant of SecureRandom that also\n+     * avoids stalls that may occur when using \/dev\/random.\n+     *\n+     * File organization: First static fields, then instance\n+     * fields, then constructors, then instance methods.\n+     *\/\n+\n+    \/* ---------------- static fields ---------------- *\/\n+\n+    \/**\n+     * The seed generator for default constructors.\n+     *\/\n+    private static final AtomicLong defaultGen = new AtomicLong(RandomSupport.initialSeed());\n+\n+    \/*\n+     * The equidistribution of the algorithm.\n+     *\/\n+    private static final int EQUIDISTRIBUTION = 1;\n+\n+    \/*\n+     * Low half of multiplier used in the LCG portion of the algorithm;\n+     * the overall multiplier is (2**64 + ML).\n+     * Chosen based on research by Sebastiano Vigna and Guy Steele (2019).\n+     * The spectral scores for dimensions 2 through 8 for the multiplier 0x1d605bbb58c8abbfdLL\n+     * are [0.991889, 0.907938, 0.830964, 0.837980, 0.780378, 0.797464, 0.761493].\n+     *\/\n+\n+    private static final long ML = 0xd605bbb58c8abbfdL;\n+\n+    \/* ---------------- instance fields ---------------- *\/\n+\n+    \/**\n+     * The parameter that is used as an additive constant for the LCG.\n+     * Must be odd (therefore al must be odd).\n+     *\/\n+    private final long ah, al;\n+\n+    \/**\n+     * The per-instance state: sh and sl for the LCG; x0, x1, x2, and x3 for the xorshift.\n+     * At least one of the four fields x0, x1, x2, and x3 must be nonzero.\n+     *\/\n+    private long sh, sl, x0, x1, x2, x3;\n+\n+    \/* ---------------- constructors ---------------- *\/\n+\n+    \/**\n+     * Basic constructor that initializes all fields from parameters.\n+     * It then adjusts the field values if necessary to ensure that\n+     * all constraints on the values of fields are met.\n+     *\n+     * @param ah high half of the additive parameter for the LCG\n+     * @param al low half of the additive parameter for the LCG\n+     * @param sh high half of the initial state for the LCG\n+     * @param sl low half of the initial state for the LCG\n+     * @param x0 first word of the initial state for the xorshift generator\n+     * @param x1 second word of the initial state for the xorshift generator\n+     * @param x2 third word of the initial state for the xorshift generator\n+     * @param x3 fourth word of the initial state for the xorshift generator\n+     *\/\n+    public L128X256MixRandom(long ah, long al, long sh, long sl, long x0, long x1, long x2, long x3) {\n+        \/\/ Force a to be odd.\n+        this.ah = ah;\n+        this.al = al | 1;\n+        this.sh = sh;\n+        this.sl = sl;\n+        this.x0 = x0;\n+        this.x1 = x1;\n+        this.x2 = x2;\n+        this.x3 = x3;\n+        \/\/ If x0, x1, x2, and x3 are all zero, we must choose nonzero values.\n+        if ((x0 | x1 | x2 | x3) == 0) {\n+       long v = sh;\n+            \/\/ At least three of the four values generated here will be nonzero.\n+            this.x0 = RandomSupport.mixStafford13(v += RandomSupport.GOLDEN_RATIO_64);\n+            this.x1 = RandomSupport.mixStafford13(v += RandomSupport.GOLDEN_RATIO_64);\n+            this.x2 = RandomSupport.mixStafford13(v += RandomSupport.GOLDEN_RATIO_64);\n+            this.x3 = RandomSupport.mixStafford13(v + RandomSupport.GOLDEN_RATIO_64);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L128X256MixRandom} using the\n+     * specified {@code long} value as the initial seed. Instances of\n+     * {@link L128X256MixRandom} created with the same seed in the same\n+     * program generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public L128X256MixRandom(long seed) {\n+        \/\/ Using a value with irregularly spaced 1-bits to xor the seed\n+        \/\/ argument tends to improve \"pedestrian\" seeds such as 0 or\n+        \/\/ other small integers.  We may as well use SILVER_RATIO_64.\n+        \/\/\n+        \/\/ The seed is hashed by mixMurmur64 to produce the `a` parameter.\n+        \/\/ The seed is hashed by mixStafford13 to produce the initial `x0`,\n+        \/\/ which will then be used to produce the first generated value.\n+        \/\/ The other x values are filled in as if by a SplitMix PRNG with\n+        \/\/ GOLDEN_RATIO_64 as the gamma value and mixStafford13 as the mixer.\n+        this(RandomSupport.mixMurmur64(seed ^= RandomSupport.SILVER_RATIO_64),\n+             RandomSupport.mixMurmur64(seed += RandomSupport.GOLDEN_RATIO_64),\n+             0,\n+             1,\n+             RandomSupport.mixStafford13(seed),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed + RandomSupport.GOLDEN_RATIO_64));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L128X256MixRandom} that is likely to\n+     * generate sequences of values that are statistically independent\n+     * of those of any other instances in the current program execution,\n+     * but may, and typically does, vary across program invocations.\n+     *\/\n+    public L128X256MixRandom() {\n+        \/\/ Using GOLDEN_RATIO_64 here gives us a good Weyl sequence of values.\n+        this(defaultGen.getAndAdd(RandomSupport.GOLDEN_RATIO_64));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L128X256MixRandom} using the specified array of\n+     * initial seed bytes. Instances of {@link L128X256MixRandom} created with the same\n+     * seed array in the same program execution generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public L128X256MixRandom(byte[] seed) {\n+        \/\/ Convert the seed to 6 long values, of which the last 4 are not all zero.\n+        long[] data = RandomSupport.convertSeedBytesToLongs(seed, 6, 4);\n+        long ah = data[0], al = data[1], sh = data[2], sl = data[3],\n+             x0 = data[4], x1 = data[5], x2 = data[6], x3 = data[7];\n+        \/\/ Force a to be odd.\n+        this.ah = ah;\n+        this.al = al | 1;\n+        this.sh = sh;\n+        this.sl = sl;\n+        this.x0 = x0;\n+        this.x1 = x1;\n+        this.x2 = x2;\n+        this.x3 = x3;\n+    }\n+\n+    \/* ---------------- public methods ---------------- *\/\n+\n+    @Override\n+    public SplittableGenerator split(SplittableGenerator source, long brine) {\n+       \/\/ Pick a new instance \"at random\", but use the brine for (the low half of) `a`.\n+        return new L128X256MixRandom(source.nextLong(), brine << 1,\n+                    source.nextLong(), source.nextLong(),\n+                    source.nextLong(), source.nextLong(),\n+                    source.nextLong(), source.nextLong());\n+    }\n+\n+    @Override\n+    public long nextLong() {\n+       \/\/ Compute the result based on current state information\n+       \/\/ (this allows the computation to be overlapped with state update).\n+        final long result = RandomSupport.mixLea64(sh + x0);\n+\n+       \/\/ Update the LCG subgenerator\n+        \/\/ The LCG is, in effect, s = ((1LL << 64) + ML) * s + a, if only we had 128-bit arithmetic.\n+        final long u = ML * sl;\n+       \/\/ Note that Math.multiplyHigh computes the high half of the product of signed values,\n+       \/\/ but what we need is the high half of the product of unsigned values; for this we use the\n+       \/\/ formula \"unsignedMultiplyHigh(a, b) = multiplyHigh(a, b) + ((a >> 63) & b) + ((b >> 63) & a)\";\n+       \/\/ in effect, each operand is added to the result iff the sign bit of the other operand is 1.\n+       \/\/ (See Henry S. Warren, Jr., _Hacker's Delight_ (Second Edition), Addison-Wesley (2013),\n+       \/\/ Section 8-3, p. 175; or see the First Edition, Addison-Wesley (2003), Section 8-3, p. 133.)\n+       \/\/ If Math.unsignedMultiplyHigh(long, long) is ever implemented, the following line can become:\n+       \/\/         sh = (ML * sh) + Math.unsignedMultiplyHigh(ML, sl) + sl + ah;\n+       \/\/ and this entire comment can be deleted.\n+        sh = (ML * sh) + (Math.multiplyHigh(ML, sl) + ((ML >> 63) & sl) + ((sl >> 63) & ML)) + sl + ah;\n+        sl = u + al;\n+        if (Long.compareUnsigned(sl, u) < 0) ++sh;  \/\/ Handle the carry propagation from low half to high half.\n+\n+       \/\/ Update the Xorshift subgenerator\n+        long q0 = x0, q1 = x1, q2 = x2, q3 = x3;\n+        {   \/\/ xoshiro256 1.0\n+            long t = q1 << 17;\n+            q2 ^= q0;\n+            q3 ^= q1;\n+            q1 ^= q2;\n+            q0 ^= q3;\n+            q2 ^= t;\n+            q3 = Long.rotateLeft(q3, 45);\n+        }\n+        x0 = q0; x1 = q1; x2 = q2; x3 = q3;\n+\n+        return result;\n+    }\n+\n+}\n","filename":"src\/jdk.random\/share\/classes\/jdk\/random\/L128X256MixRandom.java","additions":301,"deletions":0,"binary":false,"changes":301,"status":"added"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.random;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.random.RandomGenerator;\n+import jdk.internal.util.random.RandomSupport;\n+import jdk.internal.util.random.RandomSupport.AbstractSplittableWithBrineGenerator;\n+import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n+\n+\/**\n+ * A \"splittable\" pseudorandom number generator (PRNG) whose period\n+ * is roughly 2<sup>96<\/sup>.  Class {@link L32X64MixRandom} implements\n+ * interfaces {@link RandomGenerator} and {@link SplittableGenerator},\n+ * and therefore supports methods for producing pseudorandomly chosen\n+ * values of type {@code int}, {@code long}, {@code float}, {@code double},\n+ * and {@code boolean} (and for producing streams of pseudorandomly chosen\n+ * numbers of type {@code int}, {@code long}, and {@code double}),\n+ * as well as methods for creating new split-off {@link L32X64MixRandom}\n+ * objects or streams of such objects.\n+ *\n+ * <p>The {@link L32X64MixRandom} algorithm is a specific member of\n+ * the LXM family of algorithms for pseudorandom number generators;\n+ * for more information, see the documentation for package\n+ * {@link jdk.random}.  Each instance of {@link L32X64MixRandom}\n+ * has 96 bits of state plus one 32-bit instance-specific parameter.\n+ *\n+ * <p>If two instances of {@link L32X64MixRandom} are created with\n+ * the same seed within the same program execution, and the same\n+ * sequence of method calls is made for each, they will generate and\n+ * return identical sequences of values.\n+ *\n+ * <p>As with {@link java.util.SplittableRandom}, instances of\n+ * {@link L32X64MixRandom} are <em>not<\/em> thread-safe.  They are\n+ * designed to be split, not shared, across threads (see the {@link #split}\n+ * method). For example, a {@link java.util.concurrent.ForkJoinTask}\n+ * fork\/join-style computation using random numbers might include a\n+ * construction of the form\n+ * {@code new Subtask(someL32X64MixRandom.split()).fork()}.\n+ *\n+ * <p>This class provides additional methods for generating random\n+ * streams, that employ the above techniques when used in\n+ * {@code stream.parallel()} mode.\n+ *\n+ * <p>Instances of {@link L32X64MixRandom} are not cryptographically\n+ * secure.  Consider instead using {@link java.security.SecureRandom}\n+ * in security-sensitive applications. Additionally,\n+ * default-constructed instances do not use a cryptographically random\n+ * seed unless the {@linkplain System#getProperty system property}\n+ * {@code java.util.secureRandomSeed} is set to {@code true}.\n+ *\n+ * @since   17\n+ *\n+ *\/\n+@RandomGeneratorProperties(\n+        name = \"L32X64MixRandom\",\n+        group = \"LXM\",\n+        i = 64, j = 1, k = 32,\n+        equidistribution = 1\n+)\n+public final class L32X64MixRandom extends AbstractSplittableWithBrineGenerator {\n+    \/*\n+     * Implementation Overview.\n+     *\n+     * The split operation uses the current generator to choose four new 32-bit\n+     * int values that are then used to initialize the parameter `a` and the\n+     * state variables `s`, `x0`, and `x1` for a newly constructed generator.\n+     *\n+     * With high probability, no two generators so chosen will have the same\n+     * `a` parameter, and testing has indicated that the values generated by\n+     * two instances of {@link L32X64MixRandom} will be (approximately)\n+     * independent if the two instances have different values for `a`.\n+     *\n+     * The default (no-argument) constructor, in essence, uses\n+     * \"defaultGen\" to generate four new 32-bit values for the same\n+     * purpose.  Multiple generators created in this way will certainly\n+     * differ in their `a` parameters.  The defaultGen state must be accessed\n+     * in a thread-safe manner, so we use an AtomicLong to represent\n+     * this state.  To bootstrap the defaultGen, we start off using a\n+     * seed based on current time unless the\n+     * java.util.secureRandomSeed property is set. This serves as a\n+     * slimmed-down (and insecure) variant of SecureRandom that also\n+     * avoids stalls that may occur when using \/dev\/random.\n+     *\n+     * File organization: First static fields, then instance\n+     * fields, then constructors, then instance methods.\n+     *\/\n+\n+    \/* ---------------- static fields ---------------- *\/\n+\n+    \/**\n+     * The seed generator for default constructors.\n+     *\/\n+    private static final AtomicLong defaultGen = new AtomicLong(RandomSupport.initialSeed());\n+\n+    \/*\n+     * Multiplier used in the LCG portion of the algorithm.\n+     * Chosen based on research by Sebastiano Vigna and Guy Steele (2019).\n+     * The spectral scores for dimensions 2 through 8 for the multiplier 0xadb4a92d\n+     * are [0.975884, 0.936244, 0.755793, 0.877642, 0.751300, 0.789333, 0.728869].\n+     *\/\n+\n+    private static final int M = 0xadb4a92d;\n+\n+    \/* ---------------- instance fields ---------------- *\/\n+\n+    \/**\n+     * The parameter that is used as an additive constant for the LCG.\n+     * Must be odd.\n+     *\/\n+    private final int a;\n+\n+    \/**\n+     * The per-instance state: s for the LCG; x0 and x1 for the xorshift.\n+     * At least one of x0 and x1 must be nonzero.\n+     *\/\n+    private int s, x0, x1;\n+\n+    \/* ---------------- constructors ---------------- *\/\n+\n+    \/**\n+     * Basic constructor that initializes all fields from parameters.\n+     * It then adjusts the field values if necessary to ensure that\n+     * all constraints on the values of fields are met.\n+     *\n+     * @param a additive parameter for the LCG\n+     * @param s initial state for the LCG\n+     * @param x0 first word of the initial state for the xorshift generator\n+     * @param x1 second word of the initial state for the xorshift generator\n+     *\/\n+    public L32X64MixRandom(int a, int s, int x0, int x1) {\n+        \/\/ Force a to be odd.\n+        this.a = a | 1;\n+        this.s = s;\n+        \/\/ If x0 and x1 are both zero, we must choose nonzero values.\n+        if ((x0 | x1) == 0) {\n+       int v = s;\n+            \/\/ At least one of the two values generated here will be nonzero.\n+            this.x0 = RandomSupport.mixMurmur32(v += RandomSupport.GOLDEN_RATIO_32);\n+            this.x1 = RandomSupport.mixMurmur32(v + RandomSupport.GOLDEN_RATIO_32);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L32X64MixRandom} using the\n+     * specified {@code long} value as the initial seed. Instances of\n+     * {@link L32X64MixRandom} created with the same seed in the same\n+     * program generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public L32X64MixRandom(long seed) {\n+        \/\/ Using a value with irregularly spaced 1-bits to xor the seed\n+        \/\/ argument tends to improve \"pedestrian\" seeds such as 0 or\n+        \/\/ other small integers.  We may as well use SILVER_RATIO_64.\n+        \/\/\n+        \/\/ The high half of the seed is hashed by mixMurmur32 to produce the `a` parameter.\n+        \/\/ The low half of the seed is hashed by mixLea32 to produce the initial `x0`,\n+        \/\/ which will then be used to produce the first generated value.\n+        \/\/ Then x1 is filled in as if by a SplitMix PRNG with\n+        \/\/ GOLDEN_RATIO_32 as the gamma value and mixLea32 as the mixer.\n+        this(RandomSupport.mixMurmur32((int)((seed ^= RandomSupport.SILVER_RATIO_64) >>> 32)),\n+             1,\n+             RandomSupport.mixLea32((int)(seed)),\n+             RandomSupport.mixLea32((int)(seed) + RandomSupport.GOLDEN_RATIO_32));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L32X64MixRandom} that is likely to\n+     * generate sequences of values that are statistically independent\n+     * of those of any other instances in the current program execution,\n+     * but may, and typically does, vary across program invocations.\n+     *\/\n+    public L32X64MixRandom() {\n+        \/\/ Using GOLDEN_RATIO_64 here gives us a good Weyl sequence of values.\n+        this(defaultGen.getAndAdd(RandomSupport.GOLDEN_RATIO_64));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L32X64MixRandom} using the specified array of\n+     * initial seed bytes. Instances of {@link L32X64MixRandom} created with the same\n+     * seed array in the same program execution generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public L32X64MixRandom(byte[] seed) {\n+        \/\/ Convert the seed to 4 int values, of which the last 2 are not all zero.\n+        int[] data = RandomSupport.convertSeedBytesToInts(seed, 4, 2);\n+        int a = data[0], s = data[1], x0 = data[2], x1 = data[3];\n+        \/\/ Force a to be odd.\n+        this.a = a | 1;\n+        this.s = s;\n+        this.x0 = x0;\n+        this.x1 = x1;\n+    }\n+\n+    \/* ---------------- public methods ---------------- *\/\n+\n+    @Override\n+    public SplittableGenerator split(SplittableGenerator source, long brine) {\n+       \/\/ Pick a new instance \"at random\", but use (the low 31 bits of) the brine for `a`.\n+        return new L32X64MixRandom((int)brine << 1, source.nextInt(),\n+                   source.nextInt(), source.nextInt());\n+    }\n+\n+    @Override\n+    public int nextInt() {\n+       \/\/ Compute the result based on current state information\n+       \/\/ (this allows the computation to be overlapped with state update).\n+        final int result = RandomSupport.mixLea32(s + x0);\n+\n+       \/\/ Update the LCG subgenerator\n+        s = M * s + a;\n+\n+       \/\/ Update the Xorshift subgenerator\n+        int q0 = x0, q1 = x1;\n+        {   \/\/ xoroshiro64\n+            q1 ^= q0;\n+            q0 = Integer.rotateLeft(q0, 26);\n+            q0 = q0 ^ q1 ^ (q1 << 9);\n+            q1 = Integer.rotateLeft(q1, 13);\n+        }\n+        x0 = q0; x1 = q1;\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public long nextLong() {\n+        return ((long)nextInt() << 32) ^ (long)nextInt();\n+    }\n+\n+}\n","filename":"src\/jdk.random\/share\/classes\/jdk\/random\/L32X64MixRandom.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -0,0 +1,321 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.random;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.random.RandomGenerator;\n+import jdk.internal.util.random.RandomSupport;\n+import jdk.internal.util.random.RandomSupport.AbstractSplittableWithBrineGenerator;\n+import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n+\n+\/**\n+ * A \"splittable\" pseudorandom number generator (PRNG) whose period\n+ * is roughly 2<sup>1088<\/sup>.  Class {@link L64X1024MixRandom} implements\n+ * interfaces {@link RandomGenerator} and {@link SplittableGenerator},\n+ * and therefore supports methods for producing pseudorandomly chosen\n+ * values of type {@code int}, {@code long}, {@code float}, {@code double},\n+ * and {@code boolean} (and for producing streams of pseudorandomly chosen\n+ * numbers of type {@code int}, {@code long}, and {@code double}),\n+ * as well as methods for creating new split-off {@link L64X1024MixRandom}\n+ * objects or streams of such objects.\n+ *\n+ * <p>The {@link L64X1024MixRandom} algorithm is a specific member of\n+ * the LXM family of algorithms for pseudorandom number generators;\n+ * for more information, see the documentation for package\n+ * {@link jdk.random}.  Each instance of {@link L64X1024MixRandom}\n+ * has 1088 bits of state plus one 64-bit instance-specific parameter.\n+ *\n+ * <p>If two instances of {@link L64X1024MixRandom} are created with\n+ * the same seed within the same program execution, and the same\n+ * sequence of method calls is made for each, they will generate and\n+ * return identical sequences of values.\n+ *\n+ * <p>As with {@link java.util.SplittableRandom}, instances of\n+ * {@link L64X1024MixRandom} are <em>not<\/em> thread-safe.  They are\n+ * designed to be split, not shared, across threads (see the {@link #split}\n+ * method). For example, a {@link java.util.concurrent.ForkJoinTask}\n+ * fork\/join-style computation using random numbers might include a\n+ * construction of the form\n+ * {@code new Subtask(someL64X1024MixRandom.split()).fork()}.\n+ *\n+ * <p>This class provides additional methods for generating random\n+ * streams, that employ the above techniques when used in\n+ * {@code stream.parallel()} mode.\n+ *\n+ * <p>Instances of {@link L64X1024MixRandom} are not cryptographically\n+ * secure.  Consider instead using {@link java.security.SecureRandom}\n+ * in security-sensitive applications. Additionally,\n+ * default-constructed instances do not use a cryptographically random\n+ * seed unless the {@linkplain System#getProperty system property}\n+ * {@code java.util.secureRandomSeed} is set to {@code true}.\n+ *\n+ * @since   17\n+ *\n+ *\/\n+@RandomGeneratorProperties(\n+        name = \"L64X1024MixRandom\",\n+        group = \"LXM\",\n+        i = 1024, j = 1, k = 64,\n+        equidistribution = 16\n+)\n+public final class L64X1024MixRandom extends AbstractSplittableWithBrineGenerator {\n+\n+    \/*\n+     * Implementation Overview.\n+     *\n+     * The split() operation uses the current generator to choose 18 new 64-bit\n+     * long values that are then used to initialize the parameter `a`, the\n+     * state variable `s`, and the array `x` for a newly constructed generator.\n+     *\n+     * With extremely high probability, no two generators so chosen\n+     * will have the same `a` parameter, and testing has indicated\n+     * that the values generated by two instances of {@link L64X1024MixRandom}\n+     * will be (approximately) independent if have different values for `a`.\n+     *\n+     * The default (no-argument) constructor, in essence, uses\n+     * \"defaultGen\" to generate 18 new 64-bit values for the same\n+     * purpose.  Multiple generators created in this way will certainly\n+     * differ in their `a` parameters.  The defaultGen state must be accessed\n+     * in a thread-safe manner, so we use an AtomicLong to represent\n+     * this state.  To bootstrap the defaultGen, we start off using a\n+     * seed based on current time unless the\n+     * java.util.secureRandomSeed property is set. This serves as a\n+     * slimmed-down (and insecure) variant of SecureRandom that also\n+     * avoids stalls that may occur when using \/dev\/random.\n+     *\n+     * File organization: First static fields, then instance\n+     * fields, then constructors, then instance methods.\n+     *\/\n+\n+    \/* ---------------- static fields ---------------- *\/\n+\n+    \/*\n+     * The length of the array x.\n+     *\/\n+\n+    private static final int N = 16;\n+\n+    \/**\n+     * The seed generator for default constructors.\n+     *\/\n+    private static final AtomicLong defaultGen = new AtomicLong(RandomSupport.initialSeed());\n+\n+    \/*\n+     * Multiplier used in the LCG portion of the algorithm.\n+     * Chosen based on research by Sebastiano Vigna and Guy Steele (2019).\n+     * The spectral scores for dimensions 2 through 8 for the multiplier 0xd1342543de82ef95\n+     * are [0.958602, 0.937479, 0.870757, 0.822326, 0.820405, 0.813065, 0.760215].\n+     *\/\n+\n+    private static final long M = 0xd1342543de82ef95L;\n+\n+    \/* ---------------- instance fields ---------------- *\/\n+\n+    \/**\n+     * The parameter that is used as an additive constant for the LCG.\n+     * Must be odd.\n+     *\/\n+    private final long a;\n+\n+    \/**\n+     * The per-instance state: s for the LCG; the array x for the xorshift;\n+     * p is the rotating pointer into the array x.\n+     * At least one of the 16 elements of the array x must be nonzero.\n+     *\/\n+    private long s;\n+    private final long[] x;\n+    private int p = N - 1;\n+\n+    \/* ---------------- constructors ---------------- *\/\n+\n+    \/**\n+     * Basic constructor that initializes all fields from parameters.\n+     * It then adjusts the field values if necessary to ensure that\n+     * all constraints on the values of fields are met.\n+     *\n+     * @param a additive parameter for the LCG\n+     * @param s initial state for the LCG\n+     * @param x0 first word of the initial state for the xorshift generator\n+     * @param x1 second word of the initial state for the xorshift generator\n+     * @param x2 third word of the initial state for the xorshift generator\n+     * @param x3 fourth word of the initial state for the xorshift generator\n+     * @param x4 fifth word of the initial state for the xorshift generator\n+     * @param x5 sixth word of the initial state for the xorshift generator\n+     * @param x6 seventh word of the initial state for the xorshift generator\n+     * @param x7 eight word of the initial state for the xorshift generator\n+     * @param x8 ninth word of the initial state for the xorshift generator\n+     * @param x9 tenth word of the initial state for the xorshift generator\n+     * @param x10 eleventh word of the initial state for the xorshift generator\n+     * @param x11 twelfth word of the initial state for the xorshift generator\n+     * @param x12 thirteenth word of the initial state for the xorshift generator\n+     * @param x13 fourteenth word of the initial state for the xorshift generator\n+     * @param x14 fifteenth word of the initial state for the xorshift generator\n+     * @param x15 sixteenth word of the initial state for the xorshift generator\n+     *\/\n+    public L64X1024MixRandom(long a, long s,\n+                             long x0, long x1, long x2, long x3,\n+                             long x4, long x5, long x6, long x7,\n+                             long x8, long x9, long x10, long x11,\n+                             long x12, long x13, long x14, long x15) {\n+        \/\/ Force a to be odd.\n+        this.a = a | 1;\n+        this.s = s;\n+        this.x = new long[N];\n+        this.x[0] = x0;\n+        this.x[1] = x1;\n+        this.x[2] = x2;\n+        this.x[3] = x3;\n+        this.x[4] = x4;\n+        this.x[5] = x5;\n+        this.x[6] = x6;\n+        this.x[7] = x7;\n+        this.x[8] = x8;\n+        this.x[9] = x9;\n+        this.x[10] = x10;\n+        this.x[11] = x11;\n+        this.x[12] = x12;\n+        this.x[13] = x13;\n+        this.x[14] = x14;\n+        this.x[15] = x15;\n+        \/\/ If x0, x1, ..., x15 are all zero (very unlikely), we must choose nonzero values.\n+        if ((x0 | x1 | x2 | x3 | x4 | x5 | x6 | x7 | x8 | x9 | x10 | x11 | x12 | x13 | x14 | x15) == 0) {\n+       long v = s;\n+            \/\/ At least fifteen of the sixteen values generated here will be nonzero.\n+            for (int j = 0; j < N; j++) {\n+                this.x[j] = RandomSupport.mixStafford13(v += RandomSupport.GOLDEN_RATIO_64);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L64X1024MixRandom} using the\n+     * specified {@code long} value as the initial seed. Instances of\n+     * {@link L64X1024MixRandom} created with the same seed in the same\n+     * program execution generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public L64X1024MixRandom(long seed) {\n+        \/\/ Using a value with irregularly spaced 1-bits to xor the seed\n+        \/\/ argument tends to improve \"pedestrian\" seeds such as 0 or\n+        \/\/ other small integers.  We may as well use SILVER_RATIO_64.\n+        \/\/\n+        \/\/ The seed is hashed by mixMurmur64 to produce the `a` parameter.\n+        \/\/ The seed is hashed by mixStafford13 to produce the initial `x[0]`,\n+        \/\/ which will then be used to produce the first generated value.\n+        \/\/ The other x values are filled in as if by a SplitMix PRNG with\n+        \/\/ GOLDEN_RATIO_64 as the gamma value and mixStafford13 as the mixer.\n+        this(RandomSupport.mixMurmur64(seed ^= RandomSupport.SILVER_RATIO_64),\n+             1,\n+             RandomSupport.mixStafford13(seed),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed + RandomSupport.GOLDEN_RATIO_64));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L64X1024MixRandom} that is likely to\n+     * generate sequences of values that are statistically independent\n+     * of those of any other instances in the current program execution,\n+     * but may, and typically does, vary across program invocations.\n+     *\/\n+    public L64X1024MixRandom() {\n+        \/\/ Using GOLDEN_RATIO_64 here gives us a good Weyl sequence of values.\n+        this(defaultGen.getAndAdd(RandomSupport.GOLDEN_RATIO_64));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L64X1024MixRandom} using the specified array of\n+     * initial seed bytes. Instances of {@link L64X1024MixRandom} created with the same\n+     * seed array in the same program execution generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public L64X1024MixRandom(byte[] seed) {\n+        \/\/ Convert the seed to 18 long values, of which the last 16 are not all zero.\n+        long[] data = RandomSupport.convertSeedBytesToLongs(seed, 18, 16);\n+        long a = data[0], s = data[1];\n+        \/\/ Force a to be odd.\n+        this.a = a | 1;\n+        this.s = s;\n+        this.x = new long[N];\n+        for (int j = 0; j < N; j++) {\n+            this.x[j] = data[2+j];\n+        }\n+    }\n+\n+    \/* ---------------- public methods ---------------- *\/\n+\n+    @Override\n+    public SplittableGenerator split(SplittableGenerator source, long brine) {\n+       \/\/ Pick a new instance \"at random\", but use the brine for `a`.\n+        return new L64X1024MixRandom(brine << 1, source.nextLong(),\n+                    source.nextLong(), source.nextLong(),\n+                                     source.nextLong(), source.nextLong(),\n+                                     source.nextLong(), source.nextLong(),\n+                                     source.nextLong(), source.nextLong(),\n+                                     source.nextLong(), source.nextLong(),\n+                                     source.nextLong(), source.nextLong(),\n+                                     source.nextLong(), source.nextLong(),\n+                                     source.nextLong(), source.nextLong());\n+    }\n+\n+    @Override\n+    public long nextLong() {\n+        \/\/ First part of xoroshiro1024: fetch array data\n+        final int q = p;\n+        final long s0 = x[p = (p + 1) & (N - 1)];\n+        long s15 = x[q];\n+\n+       \/\/ Compute the result based on current state information\n+       \/\/ (this allows the computation to be overlapped with state update).\n+\n+       final long result = RandomSupport.mixLea64(s + s0);\n+\n+       \/\/ Update the LCG subgenerator\n+        s = M * s + a;  \/\/ LCG\n+\n+        \/\/ Second part of xoroshiro1024: update array data\n+        s15 ^= s0;\n+        x[q] = Long.rotateLeft(s0, 25) ^ s15 ^ (s15 << 27);\n+        x[p] = Long.rotateLeft(s15, 36);\n+\n+        return result;\n+    }\n+\n+}\n","filename":"src\/jdk.random\/share\/classes\/jdk\/random\/L64X1024MixRandom.java","additions":321,"deletions":0,"binary":false,"changes":321,"status":"added"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.random;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.random.RandomGenerator;\n+import jdk.internal.util.random.RandomSupport;\n+import jdk.internal.util.random.RandomSupport.AbstractSplittableWithBrineGenerator;\n+import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n+\n+\/**\n+ * A \"splittable\" pseudorandom number generator (PRNG) whose period\n+ * is roughly 2<sup>192<\/sup>.  Class {@link L64X128MixRandom} implements\n+ * interfaces {@link RandomGenerator} and {@link SplittableGenerator},\n+ * and therefore supports methods for producing pseudorandomly chosen\n+ * values of type {@code int}, {@code long}, {@code float}, {@code double},\n+ * and {@code boolean} (and for producing streams of pseudorandomly chosen\n+ * numbers of type {@code int}, {@code long}, and {@code double}),\n+ * as well as methods for creating new split-off {@link L64X128MixRandom}\n+ * objects or streams of such objects.\n+ *\n+ * <p>The {@link L64X128MixRandom} algorithm is a specific member of\n+ * the LXM family of algorithms for pseudorandom number generators;\n+ * for more information, see the documentation for package\n+ * {@link jdk.random}.  Each instance of {@link L64X128MixRandom}\n+ * has 192 bits of state plus one 64-bit instance-specific parameter.\n+ *\n+ * <p>If two instances of {@link L64X128MixRandom} are created with\n+ * the same seed within the same program execution, and the same\n+ * sequence of method calls is made for each, they will generate and\n+ * return identical sequences of values.\n+ *\n+ * <p>As with {@link java.util.SplittableRandom}, instances of\n+ * {@link L64X128MixRandom} are <em>not<\/em> thread-safe.  They are\n+ * designed to be split, not shared, across threads (see the {@link #split}\n+ * method). For example, a {@link java.util.concurrent.ForkJoinTask}\n+ * fork\/join-style computation using random numbers might include a\n+ * construction of the form\n+ * {@code new Subtask(someL64X128MixRandom.split()).fork()}.\n+ *\n+ * <p>This class provides additional methods for generating random\n+ * streams, that employ the above techniques when used in\n+ * {@code stream.parallel()} mode.\n+ *\n+ * <p>Instances of {@link L64X128MixRandom} are not cryptographically\n+ * secure.  Consider instead using {@link java.security.SecureRandom}\n+ * in security-sensitive applications. Additionally,\n+ * default-constructed instances do not use a cryptographically random\n+ * seed unless the {@linkplain System#getProperty system property}\n+ * {@code java.util.secureRandomSeed} is set to {@code true}.\n+ *\n+ * @since   17\n+ *\n+ *\/\n+@RandomGeneratorProperties(\n+        name = \"L64X128MixRandom\",\n+        group = \"LXM\",\n+        i = 128, j = 1, k = 64,\n+        equidistribution = 1\n+)\n+public final class L64X128MixRandom extends AbstractSplittableWithBrineGenerator {\n+\n+    \/*\n+     * Implementation Overview.\n+     *\n+     * The split operation uses the current generator to choose four new 64-bit\n+     * long values that are then used to initialize the parameter `a` and the\n+     * state variables `s`, `x0`, and `x1` for a newly constructed generator.\n+     *\n+     * With extremely high probability, no two generators so chosen\n+     * will have the same `a` parameter, and testing has indicated\n+     * that the values generated by two instances of {@link L64X128MixRandom}\n+     * will be (approximately) independent if have different values for `a`.\n+     *\n+     * The default (no-argument) constructor, in essence, uses\n+     * \"defaultGen\" to generate four new 64-bit values for the same\n+     * purpose.  Multiple generators created in this way will certainly\n+     * differ in their `a` parameters.  The defaultGen state must be accessed\n+     * in a thread-safe manner, so we use an AtomicLong to represent\n+     * this state.  To bootstrap the defaultGen, we start off using a\n+     * seed based on current time unless the\n+     * java.util.secureRandomSeed property is set. This serves as a\n+     * slimmed-down (and insecure) variant of SecureRandom that also\n+     * avoids stalls that may occur when using \/dev\/random.\n+     *\n+     * File organization: First static fields, then instance\n+     * fields, then constructors, then instance methods.\n+     *\/\n+\n+    \/* ---------------- static fields ---------------- *\/\n+\n+    \/**\n+     * The seed generator for default constructors.\n+     *\/\n+    private static final AtomicLong defaultGen = new AtomicLong(RandomSupport.initialSeed());\n+\n+    \/*\n+     * Multiplier used in the LCG portion of the algorithm.\n+     * Chosen based on research by Sebastiano Vigna and Guy Steele (2019).\n+     * The spectral scores for dimensions 2 through 8 for the multiplier 0xd1342543de82ef95L\n+     * are [0.958602, 0.937479, 0.870757, 0.822326, 0.820405, 0.813065, 0.760215].\n+     *\/\n+\n+    private static final long M = 0xd1342543de82ef95L;\n+\n+    \/* ---------------- instance fields ---------------- *\/\n+\n+    \/**\n+     * The parameter that is used as an additive constant for the LCG.\n+     * Must be odd.\n+     *\/\n+    private final long a;\n+\n+    \/**\n+     * The per-instance state: s for the LCG; x0 and x1 for the xorshift.\n+     * At least one of x0 and x1 must be nonzero.\n+     *\/\n+    private long s, x0, x1;\n+\n+    \/* ---------------- constructors ---------------- *\/\n+\n+    \/**\n+     * Basic constructor that initializes all fields from parameters.\n+     * It then adjusts the field values if necessary to ensure that\n+     * all constraints on the values of fields are met.\n+     *\n+     * @param a additive parameter for the LCG\n+     * @param s initial state for the LCG\n+     * @param x0 first word of the initial state for the xorshift generator\n+     * @param x1 second word of the initial state for the xorshift generator\n+     *\/\n+    public L64X128MixRandom(long a, long s, long x0, long x1) {\n+        \/\/ Force a to be odd.\n+        this.a = a | 1;\n+        this.s = s;\n+        this.x0 = x0;\n+        this.x1 = x1;\n+        \/\/ If x0 and x1 are both zero, we must choose nonzero values.\n+        if ((x0 | x1) == 0) {\n+       long v = s;\n+            \/\/ At least one of the two values generated here will be nonzero.\n+            this.x0 = RandomSupport.mixStafford13(v += RandomSupport.GOLDEN_RATIO_64);\n+            this.x1 = RandomSupport.mixStafford13(v + RandomSupport.GOLDEN_RATIO_64);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L64X128MixRandom} using the\n+     * specified {@code long} value as the initial seed. Instances of\n+     * {@link L64X128MixRandom} created with the same seed in the same\n+     * program generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public L64X128MixRandom(long seed) {\n+        \/\/ Using a value with irregularly spaced 1-bits to xor the seed\n+        \/\/ argument tends to improve \"pedestrian\" seeds such as 0 or\n+        \/\/ other small integers.  We may as well use SILVER_RATIO_64.\n+        \/\/\n+        \/\/ The seed is hashed by mixMurmur64 to produce the `a` parameter.\n+        \/\/ The seed is hashed by mixStafford13 to produce the initial `x0`,\n+        \/\/ which will then be used to produce the first generated value.\n+        \/\/ Then x1 is filled in as if by a SplitMix PRNG with\n+        \/\/ GOLDEN_RATIO_64 as the gamma value and mixStafford13 as the mixer.\n+        this(RandomSupport.mixMurmur64(seed ^= RandomSupport.SILVER_RATIO_64),\n+             1,\n+             RandomSupport.mixStafford13(seed),\n+             RandomSupport.mixStafford13(seed + RandomSupport.GOLDEN_RATIO_64));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L64X128MixRandom} that is likely to\n+     * generate sequences of values that are statistically independent\n+     * of those of any other instances in the current program execution,\n+     * but may, and typically does, vary across program invocations.\n+     *\/\n+    public L64X128MixRandom() {\n+        \/\/ Using GOLDEN_RATIO_64 here gives us a good Weyl sequence of values.\n+        this(defaultGen.getAndAdd(RandomSupport.GOLDEN_RATIO_64));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L64X128MixRandom} using the specified array of\n+     * initial seed bytes. Instances of {@link L64X128MixRandom} created with the same\n+     * seed array in the same program execution generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public L64X128MixRandom(byte[] seed) {\n+        \/\/ Convert the seed to 4 long values, of which the last 2 are not all zero.\n+        long[] data = RandomSupport.convertSeedBytesToLongs(seed, 4, 2);\n+        long a = data[0], s = data[1], x0 = data[2], x1 = data[3];\n+        \/\/ Force a to be odd.\n+        this.a = a | 1;\n+        this.s = s;\n+        this.x0 = x0;\n+        this.x1 = x1;\n+    }\n+\n+    \/* ---------------- public methods ---------------- *\/\n+\n+    @Override\n+    public SplittableGenerator split(SplittableGenerator source, long brine) {\n+       \/\/ Pick a new instance \"at random\", but use the brine for `a`.\n+        return new L64X128MixRandom(brine << 1, source.nextLong(),\n+                   source.nextLong(), source.nextLong());\n+    }\n+\n+    @Override\n+    public long nextLong() {\n+       \/\/ Compute the result based on current state information\n+       \/\/ (this allows the computation to be overlapped with state update).\n+        final long result = RandomSupport.mixLea64(s + x0);\n+\n+       \/\/ Update the LCG subgenerator\n+        s = M * s + a;\n+\n+       \/\/ Update the Xorshift subgenerator\n+        long q0 = x0, q1 = x1;\n+        {   \/\/ xoroshiro128v1_0\n+            q1 ^= q0;\n+            q0 = Long.rotateLeft(q0, 24);\n+            q0 = q0 ^ q1 ^ (q1 << 16);\n+            q1 = Long.rotateLeft(q1, 37);\n+        }\n+        x0 = q0; x1 = q1;\n+\n+        return result;\n+    }\n+\n+}\n","filename":"src\/jdk.random\/share\/classes\/jdk\/random\/L64X128MixRandom.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.random;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.random.RandomGenerator;\n+import jdk.internal.util.random.RandomSupport;\n+import jdk.internal.util.random.RandomSupport.AbstractSplittableWithBrineGenerator;\n+import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n+\n+\/**\n+ * A \"splittable\" pseudorandom number generator (PRNG) whose period\n+ * is roughly 2<sup>192<\/sup>.  Class {@link L64X128StarStarRandom} implements\n+ * interfaces {@link RandomGenerator} and {@link SplittableGenerator},\n+ * and therefore supports methods for producing pseudorandomly chosen\n+ * values of type {@code int}, {@code long}, {@code float}, {@code double},\n+ * and {@code boolean} (and for producing streams of pseudorandomly chosen\n+ * numbers of type {@code int}, {@code long}, and {@code double}),\n+ * as well as methods for creating new split-off {@link L64X128StarStarRandom}\n+ * objects or streams of such objects.\n+ *\n+ * <p>The {@link L64X128StarStarRandom} algorithm is a specific member of\n+ * the LXM family of algorithms for pseudorandom number generators;\n+ * for more information, see the documentation for package\n+ * {@link jdk.random}.  Each instance of {@link L64X128StarStarRandom}\n+ * has 192 bits of state plus one 64-bit instance-specific parameter.\n+ *\n+ * <p>If two instances of {@link L64X128StarStarRandom} are created with\n+ * the same seed within the same program execution, and the same\n+ * sequence of method calls is made for each, they will generate and\n+ * return identical sequences of values.\n+ *\n+ * <p>As with {@link java.util.SplittableRandom}, instances of\n+ * {@link L64X128StarStarRandom} are <em>not<\/em> thread-safe.  They are\n+ * designed to be split, not shared, across threads (see the {@link #split}\n+ * method). For example, a {@link java.util.concurrent.ForkJoinTask}\n+ * fork\/join-style computation using random numbers might include a\n+ * construction of the form\n+ * {@code new Subtask(someL64X128StarStarRandom.split()).fork()}.\n+ *\n+ * <p>This class provides additional methods for generating random\n+ * streams, that employ the above techniques when used in\n+ * {@code stream.parallel()} mode.\n+ *\n+ * <p>Instances of {@link L64X128StarStarRandom} are not cryptographically\n+ * secure.  Consider instead using {@link java.security.SecureRandom}\n+ * in security-sensitive applications. Additionally,\n+ * default-constructed instances do not use a cryptographically random\n+ * seed unless the {@linkplain System#getProperty system property}\n+ * {@code java.util.secureRandomSeed} is set to {@code true}.\n+ *\n+ * @since   17\n+ *\n+ *\/\n+@RandomGeneratorProperties(\n+        name = \"L64X128StarStarRandom\",\n+        group = \"LXM\",\n+        i = 128, j = 1, k = 64,\n+        equidistribution = 1\n+)\n+public final class L64X128StarStarRandom extends AbstractSplittableWithBrineGenerator {\n+\n+    \/*\n+     * Implementation Overview.\n+     *\n+     * The split operation uses the current generator to choose four new 64-bit\n+     * long values that are then used to initialize the parameter `a` and the\n+     * state variables `s`, `x0`, and `x1` for a newly constructed generator.\n+     *\n+     * With extremely high probability, no two generators so chosen\n+     * will have the same `a` parameter, and testing has indicated\n+     * that the values generated by two instances of {@link L64X128StarStarRandom}\n+     * will be (approximately) independent if have different values for `a`.\n+     *\n+     * The default (no-argument) constructor, in essence, uses\n+     * \"defaultGen\" to generate four new 64-bit values for the same\n+     * purpose.  Multiple generators created in this way will certainly\n+     * differ in their `a` parameters.  The defaultGen state must be accessed\n+     * in a thread-safe manner, so we use an AtomicLong to represent\n+     * this state.  To bootstrap the defaultGen, we start off using a\n+     * seed based on current time unless the\n+     * java.util.secureRandomSeed property is set. This serves as a\n+     * slimmed-down (and insecure) variant of SecureRandom that also\n+     * avoids stalls that may occur when using \/dev\/random.\n+     *\n+     * File organization: First static fields, then instance\n+     * fields, then constructors, then instance methods.\n+     *\/\n+\n+    \/* ---------------- static fields ---------------- *\/\n+\n+    \/**\n+     * The seed generator for default constructors.\n+     *\/\n+    private static final AtomicLong defaultGen = new AtomicLong(RandomSupport.initialSeed());\n+\n+    \/*\n+     * Multiplier used in the LCG portion of the algorithm.\n+     * Chosen based on research by Sebastiano Vigna and Guy Steele (2019).\n+     * The spectral scores for dimensions 2 through 8 for the multiplier 0xd1342543de82ef95\n+     * are [0.958602, 0.937479, 0.870757, 0.822326, 0.820405, 0.813065, 0.760215].\n+     *\/\n+\n+    private static final long M = 0xd1342543de82ef95L;\n+\n+    \/* ---------------- instance fields ---------------- *\/\n+\n+    \/**\n+     * The parameter that is used as an additive constant for the LCG.\n+     * Must be odd.\n+     *\/\n+    private final long a;\n+\n+    \/**\n+     * The per-instance state: s for the LCG; x0 and x1 for the xorshift.\n+     * At least one of x0 and x1 must be nonzero.\n+     *\/\n+    private long s, x0, x1;\n+\n+    \/* ---------------- constructors ---------------- *\/\n+\n+    \/**\n+     * Basic constructor that initializes all fields from parameters.\n+     * It then adjusts the field values if necessary to ensure that\n+     * all constraints on the values of fields are met.\n+     *\n+     * @param a additive parameter for the LCG\n+     * @param s initial state for the LCG\n+     * @param x0 first word of the initial state for the xorshift generator\n+     * @param x1 second word of the initial state for the xorshift generator\n+     *\/\n+    public L64X128StarStarRandom(long a, long s, long x0, long x1) {\n+        \/\/ Force a to be odd.\n+        this.a = a | 1;\n+        this.s = s;\n+        this.x0 = x0;\n+        this.x1 = x1;\n+        \/\/ If x0 and x1 are both zero, we must choose nonzero values.\n+        if ((x0 | x1) == 0) {\n+       long v = s;\n+            \/\/ At least one of the two values generated here will be nonzero.\n+            this.x0 = RandomSupport.mixStafford13(v += RandomSupport.GOLDEN_RATIO_64);\n+            this.x1 = RandomSupport.mixStafford13(v + RandomSupport.GOLDEN_RATIO_64);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L64X128StarStarRandom} using the\n+     * specified {@code long} value as the initial seed. Instances of\n+     * {@link L64X128StarStarRandom} created with the same seed in the same\n+     * program generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public L64X128StarStarRandom(long seed) {\n+        \/\/ Using a value with irregularly spaced 1-bits to xor the seed\n+        \/\/ argument tends to improve \"pedestrian\" seeds such as 0 or\n+        \/\/ other small integers.  We may as well use SILVER_RATIO_64.\n+        \/\/\n+        \/\/ The seed is hashed by mixMurmur64 to produce the `a` parameter.\n+        \/\/ The seed is hashed by mixStafford13 to produce the initial `x0`,\n+        \/\/ which will then be used to produce the first generated value.\n+        \/\/ Then x1 is filled in as if by a SplitMix PRNG with\n+        \/\/ GOLDEN_RATIO_64 as the gamma value and mixStafford13 as the mixer.\n+        this(RandomSupport.mixMurmur64(seed ^= RandomSupport.SILVER_RATIO_64),\n+             1,\n+             RandomSupport.mixStafford13(seed),\n+             RandomSupport.mixStafford13(seed + RandomSupport.GOLDEN_RATIO_64));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L64X128StarStarRandom} that is likely to\n+     * generate sequences of values that are statistically independent\n+     * of those of any other instances in the current program execution,\n+     * but may, and typically does, vary across program invocations.\n+     *\/\n+    public L64X128StarStarRandom() {\n+        \/\/ Using GOLDEN_RATIO_64 here gives us a good Weyl sequence of values.\n+        this(defaultGen.getAndAdd(RandomSupport.GOLDEN_RATIO_64));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L64X128StarStarRandom} using the specified array of\n+     * initial seed bytes. Instances of {@link L64X128StarStarRandom} created with the same\n+     * seed array in the same program execution generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public L64X128StarStarRandom(byte[] seed) {\n+        \/\/ Convert the seed to 4 long values, of which the last 2 are not all zero.\n+        long[] data = RandomSupport.convertSeedBytesToLongs(seed, 4, 2);\n+        long a = data[0], s = data[1], x0 = data[2], x1 = data[3];\n+        \/\/ Force a to be odd.\n+        this.a = a | 1;\n+        this.s = s;\n+        this.x0 = x0;\n+        this.x1 = x1;\n+    }\n+\n+    \/* ---------------- public methods ---------------- *\/\n+\n+    @Override\n+    public SplittableGenerator split(SplittableGenerator source, long brine) {\n+       \/\/ Pick a new instance \"at random\", but use the brine for `a`.\n+        return new L64X128StarStarRandom(brine << 1, source.nextLong(),\n+                    source.nextLong(), source.nextLong());\n+    }\n+\n+    @Override\n+    public long nextLong() {\n+       \/\/ Compute the result based on current state information\n+       \/\/ (this allows the computation to be overlapped with state update).\n+        final long result = Long.rotateLeft((s + x0) * 5, 7) * 9;  \/\/ \"starstar\" scrambler\n+\n+       \/\/ Update the LCG subgenerator\n+        s = M * s + a;\n+\n+       \/\/ Update the Xorshift subgenerator\n+        long q0 = x0, q1 = x1;\n+        {   \/\/ xoroshiro128v1_0\n+            q1 ^= q0;\n+            q0 = Long.rotateLeft(q0, 24);\n+            q0 = q0 ^ q1 ^ (q1 << 16);\n+            q1 = Long.rotateLeft(q1, 37);\n+        }\n+        x0 = q0; x1 = q1;\n+\n+        return result;\n+    }\n+\n+}\n","filename":"src\/jdk.random\/share\/classes\/jdk\/random\/L64X128StarStarRandom.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -0,0 +1,269 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.random;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.random.RandomGenerator;\n+import jdk.internal.util.random.RandomSupport;\n+import jdk.internal.util.random.RandomSupport.AbstractSplittableWithBrineGenerator;\n+import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n+\n+\/**\n+ * A \"splittable\" pseudorandom number generator (PRNG) whose period\n+ * is roughly 2<sup>320<\/sup>.  Class {@link L64X256MixRandom} implements\n+ * interfaces {@link RandomGenerator} and {@link SplittableGenerator},\n+ * and therefore supports methods for producing pseudorandomly chosen\n+ * values of type {@code int}, {@code long}, {@code float}, {@code double},\n+ * and {@code boolean} (and for producing streams of pseudorandomly chosen\n+ * numbers of type {@code int}, {@code long}, and {@code double}),\n+ * as well as methods for creating new split-off {@link L64X256MixRandom}\n+ * objects or streams of such objects.\n+ *\n+ * <p>The {@link L64X256MixRandom} algorithm is a specific member of\n+ * the LXM family of algorithms for pseudorandom number generators;\n+ * for more information, see the documentation for package\n+ * {@link jdk.random}.  Each instance of {@link L64X256MixRandom}\n+ * has 320 bits of state plus one 64-bit instance-specific parameter.\n+ *\n+ * <p>If two instances of {@link L64X256MixRandom} are created with\n+ * the same seed within the same program execution, and the same\n+ * sequence of method calls is made for each, they will generate and\n+ * return identical sequences of values.\n+ *\n+ * <p>As with {@link java.util.SplittableRandom}, instances of\n+ * {@link L64X256MixRandom} are <em>not<\/em> thread-safe.  They are\n+ * designed to be split, not shared, across threads (see the {@link #split}\n+ * method). For example, a {@link java.util.concurrent.ForkJoinTask}\n+ * fork\/join-style computation using random numbers might include a\n+ * construction of the form\n+ * {@code new Subtask(someL64X256MixRandom.split()).fork()}.\n+ *\n+ * <p>This class provides additional methods for generating random\n+ * streams, that employ the above techniques when used in\n+ * {@code stream.parallel()} mode.\n+ *\n+ * <p>Instances of {@link L64X256MixRandom} are not cryptographically\n+ * secure.  Consider instead using {@link java.security.SecureRandom}\n+ * in security-sensitive applications. Additionally,\n+ * default-constructed instances do not use a cryptographically random\n+ * seed unless the {@linkplain System#getProperty system property}\n+ * {@code java.util.secureRandomSeed} is set to {@code true}.\n+ *\n+ * @since   17\n+ *\n+ *\/\n+@RandomGeneratorProperties(\n+        name = \"L64X256MixRandom\",\n+        group = \"LXM\",\n+        i = 256, j = 1, k = 64,\n+        equidistribution = 4\n+)\n+public final class L64X256MixRandom extends AbstractSplittableWithBrineGenerator {\n+\n+    \/*\n+     * Implementation Overview.\n+     *\n+     * The split operation uses the current generator to choose six new 64-bit\n+     * long values that are then used to initialize the parameter `a` and the\n+     * state variables `s`, `x0`, `x1`, `x2`, and `x3` for a newly constructed\n+     * generator.\n+     *\n+     * With extremely high probability, no two generators so chosen\n+     * will have the same `a` parameter, and testing has indicated\n+     * that the values generated by two instances of {@link L64X256MixRandom}\n+     * will be (approximately) independent if have different values for `a`.\n+     *\n+     * The default (no-argument) constructor, in essence, uses\n+     * \"defaultGen\" to generate six new 64-bit values for the same\n+     * purpose.  Multiple generators created in this way will certainly\n+     * differ in their `a` parameters.  The defaultGen state must be accessed\n+     * in a thread-safe manner, so we use an AtomicLong to represent\n+     * this state.  To bootstrap the defaultGen, we start off using a\n+     * seed based on current time unless the\n+     * java.util.secureRandomSeed property is set. This serves as a\n+     * slimmed-down (and insecure) variant of SecureRandom that also\n+     * avoids stalls that may occur when using \/dev\/random.\n+     *\n+     * File organization: First static fields, then instance\n+     * fields, then constructors, then instance methods.\n+     *\/\n+\n+    \/* ---------------- static fields ---------------- *\/\n+\n+    \/**\n+     * The seed generator for default constructors.\n+     *\/\n+    private static final AtomicLong defaultGen = new AtomicLong(RandomSupport.initialSeed());\n+\n+    \/*\n+     * Multiplier used in the LCG portion of the algorithm.\n+     * Chosen based on research by Sebastiano Vigna and Guy Steele (2019).\n+     * The spectral scores for dimensions 2 through 8 for the multiplier 0xd1342543de82ef95\n+     * are [0.958602, 0.937479, 0.870757, 0.822326, 0.820405, 0.813065, 0.760215].\n+     *\/\n+\n+    private static final long M = 0xd1342543de82ef95L;\n+\n+    \/* ---------------- instance fields ---------------- *\/\n+\n+    \/**\n+     * The parameter that is used as an additive constant for the LCG.\n+     * Must be odd.\n+     *\/\n+    private final long a;\n+\n+    \/**\n+     * The per-instance state: s for the LCG; x0, x1, x2, and x3 for the xorshift.\n+     * At least one of the four fields x0, x1, x2, and x3 must be nonzero.\n+     *\/\n+    private long s, x0, x1, x2, x3;\n+\n+    \/* ---------------- constructors ---------------- *\/\n+\n+    \/**\n+     * Basic constructor that initializes all fields from parameters.\n+     * It then adjusts the field values if necessary to ensure that\n+     * all constraints on the values of fields are met.\n+     *\n+     * @param a additive parameter for the LCG\n+     * @param s initial state for the LCG\n+     * @param x0 first word of the initial state for the xorshift generator\n+     * @param x1 second word of the initial state for the xorshift generator\n+     * @param x2 third word of the initial state for the xorshift generator\n+     * @param x3 fourth word of the initial state for the xorshift generator\n+     *\/\n+    public L64X256MixRandom(long a, long s, long x0, long x1, long x2, long x3) {\n+        \/\/ Force a to be odd.\n+        this.a = a | 1;\n+        this.s = s;\n+        this.x0 = x0;\n+        this.x1 = x1;\n+        this.x2 = x2;\n+        this.x3 = x3;\n+        \/\/ If x0, x1, x2, and x3 are all zero, we must choose nonzero values.\n+        if ((x0 | x1 | x2 | x3) == 0) {\n+       long v = s;\n+            \/\/ At least three of the four values generated here will be nonzero.\n+            this.x0 = RandomSupport.mixStafford13(v += RandomSupport.GOLDEN_RATIO_64);\n+            this.x1 = RandomSupport.mixStafford13(v += RandomSupport.GOLDEN_RATIO_64);\n+            this.x2 = RandomSupport.mixStafford13(v += RandomSupport.GOLDEN_RATIO_64);\n+            this.x3 = RandomSupport.mixStafford13(v + RandomSupport.GOLDEN_RATIO_64);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L64X256MixRandom} using the\n+     * specified {@code long} value as the initial seed. Instances of\n+     * {@link L64X256MixRandom} created with the same seed in the same\n+     * program generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public L64X256MixRandom(long seed) {\n+        \/\/ Using a value with irregularly spaced 1-bits to xor the seed\n+        \/\/ argument tends to improve \"pedestrian\" seeds such as 0 or\n+        \/\/ other small integers.  We may as well use SILVER_RATIO_64.\n+        \/\/\n+        \/\/ The seed is hashed by mixMurmur64 to produce the `a` parameter.\n+        \/\/ The seed is hashed by mixStafford13 to produce the initial `x0`,\n+        \/\/ which will then be used to produce the first generated value.\n+        \/\/ The other x values are filled in as if by a SplitMix PRNG with\n+        \/\/ GOLDEN_RATIO_64 as the gamma value and mixStafford13 as the mixer.\n+        this(RandomSupport.mixMurmur64(seed ^= RandomSupport.SILVER_RATIO_64),\n+             1,\n+             RandomSupport.mixStafford13(seed),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed + RandomSupport.GOLDEN_RATIO_64));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L64X256MixRandom} that is likely to\n+     * generate sequences of values that are statistically independent\n+     * of those of any other instances in the current program execution,\n+     * but may, and typically does, vary across program invocations.\n+     *\/\n+    public L64X256MixRandom() {\n+        \/\/ Using GOLDEN_RATIO_64 here gives us a good Weyl sequence of values.\n+        this(defaultGen.getAndAdd(RandomSupport.GOLDEN_RATIO_64));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link L64X256MixRandom} using the specified array of\n+     * initial seed bytes. Instances of {@link L64X256MixRandom} created with the same\n+     * seed array in the same program execution generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public L64X256MixRandom(byte[] seed) {\n+        \/\/ Convert the seed to 6 long values, of which the last 4 are not all zero.\n+        long[] data = RandomSupport.convertSeedBytesToLongs(seed, 6, 4);\n+        long a = data[0], s = data[1], x0 = data[2], x1 = data[3], x2 = data[4], x3 = data[5];\n+        \/\/ Force a to be odd.\n+        this.a = a | 1;\n+        this.s = s;\n+        this.x0 = x0;\n+        this.x1 = x1;\n+        this.x2 = x2;\n+        this.x3 = x3;\n+    }\n+\n+    \/* ---------------- public methods ---------------- *\/\n+\n+    @Override\n+    public SplittableGenerator split(SplittableGenerator source, long brine) {\n+       \/\/ Pick a new instance \"at random\", but use the brine for `a`.\n+        return new L64X256MixRandom(brine << 1, source.nextLong(),\n+                   source.nextLong(), source.nextLong(),\n+                   source.nextLong(), source.nextLong());\n+    }\n+\n+    @Override\n+    public long nextLong() {\n+       \/\/ Compute the result based on current state information\n+       \/\/ (this allows the computation to be overlapped with state update).\n+        final long result = RandomSupport.mixLea64(s + x0);\n+\n+       \/\/ Update the LCG subgenerator\n+        s = M * s + a;\n+\n+       \/\/ Update the Xorshift subgenerator\n+        long q0 = x0, q1 = x1, q2 = x2, q3 = x3;\n+        {   \/\/ xoshiro256 1.0\n+            long t = q1 << 17;\n+            q2 ^= q0;\n+            q3 ^= q1;\n+            q1 ^= q2;\n+            q0 ^= q3;\n+            q2 ^= t;\n+            q3 = Long.rotateLeft(q3, 45);\n+        }\n+        x0 = q0; x1 = q1; x2 = q2; x3 = q3;\n+\n+        return result;\n+    }\n+\n+ }\n","filename":"src\/jdk.random\/share\/classes\/jdk\/random\/L64X256MixRandom.java","additions":269,"deletions":0,"binary":false,"changes":269,"status":"added"},{"patch":"@@ -0,0 +1,284 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.random;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGenerator.LeapableGenerator;\n+import jdk.internal.util.random.RandomSupport;\n+import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n+\n+\/**\n+ * A \"jumpable and leapable\" pseudorandom number generator (PRNG) whose period\n+ * is roughly 2<sup>128<\/sup>.  Class {@link Xoroshiro128PlusPlus} implements\n+ * interfaces {@link RandomGenerator} and {@link LeapableGenerator},\n+ * and therefore supports methods for producing pseudorandomly chosen\n+ * numbers of type {@code int}, {@code long}, {@code float}, and {@code double}\n+ * as well as creating new {@link Xoroshiro128PlusPlus} objects\n+ * by \"jumping\" or \"leaping\".\n+ * <p>\n+ * The class {@link Xoroshiro128PlusPlus} uses the {@code xoroshiro128} algorithm\n+ * (parameters 49, 21, 28) with the \"++\" scrambler that computes\n+ * {@code Long.rotateLeft(s0 + s1, 17) + s0}.\n+ * Its state consists of two {@code long} fields {@code x0} and {@code x1},\n+ * which can take on any values provided that they are not both zero.\n+ * The period of this generator is 2<sup>128<\/sup>-1.\n+ * <p>\n+ * The 64-bit values produced by the {@code nextLong()} method are equidistributed.\n+ * To be precise, over the course of the cycle of length 2<sup>128<\/sup>-1,\n+ * each nonzero {@code long} value is generated 2<sup>64<\/sup> times,\n+ * but the value 0 is generated only 2<sup>64<\/sup>-1 times.\n+ * The values produced by the {@code nextInt()}, {@code nextFloat()}, and {@code nextDouble()}\n+ * methods are likewise equidistributed.\n+ * <p>\n+ * Instances {@link Xoroshiro128PlusPlus} are <em>not<\/em> thread-safe.\n+ * They are designed to be used so that each thread as its own instance.\n+ * The methods {@link #jump} and {@link #leap} and {@link #jumps} and {@link #leaps}\n+ * can be used to construct new instances of {@link Xoroshiro128PlusPlus} that traverse\n+ * other parts of the state cycle.\n+ * <p>\n+ * Instances of {@link Xoroshiro128PlusPlus} are not cryptographically\n+ * secure.  Consider instead using {@link java.security.SecureRandom}\n+ * in security-sensitive applications. Additionally,\n+ * default-constructed instances do not use a cryptographically random\n+ * seed unless the {@linkplain System#getProperty system property}\n+ * {@code java.util.secureRandomSeed} is set to {@code true}.\n+ *\n+ * @since   17\n+ *\n+ *\/\n+@RandomGeneratorProperties(\n+        name = \"Xoroshiro128PlusPlus\",\n+        group = \"Xoroshiro\",\n+        i = 128, j = 1, k = 0,\n+        equidistribution = 2\n+)\n+public final class Xoroshiro128PlusPlus implements LeapableGenerator {\n+\n+    \/*\n+     * Implementation Overview.\n+     *\n+     * This is an implementation of the xoroshiro128++ algorithm version 1.0,\n+     * written in 2019 by David Blackman and Sebastiano Vigna (vigna@acm.org).\n+     * See http:\/\/xoshiro.di.unimi.it and these two papers:\n+     *\n+     *    Sebastiano Vigna. 2016. An Experimental Exploration of Marsaglia's\n+     *    xorshift Generators, Scrambled. ACM Transactions on Mathematical\n+     *    Software 42, 4, Article 30 (June 2016), 23 pages.\n+     *    https:\/\/doi.org\/10.1145\/2845077\n+     *\n+     *    David Blackman and Sebastiano Vigna.  2018.  Scrambled Linear\n+     *    Pseudorandom Number Generators.  Computing Research Repository (CoRR).\n+     *    http:\/\/arxiv.org\/abs\/1805.01407\n+     *\n+     * The jump operation moves the current generator forward by 2*64\n+     * steps; this has the same effect as calling nextLong() 2**64\n+     * times, but is much faster.  Similarly, the leap operation moves\n+     * the current generator forward by 2*96 steps; this has the same\n+     * effect as calling nextLong() 2**96 times, but is much faster.\n+     * The copy method may be used to make a copy of the current\n+     * generator.  Thus one may repeatedly and cumulatively copy and\n+     * jump to produce a sequence of generators whose states are well\n+     * spaced apart along the overall state cycle (indeed, the jumps()\n+     * and leaps() methods each produce a stream of such generators).\n+     * The generators can then be parceled out to other threads.\n+     *\n+     * File organization: First the non-public methods that constitute the\n+     * main algorithm, then the public methods.  Note that many methods are\n+     * defined by classes {@link AbstractJumpableGenerator} and {@link AbstractGenerator}.\n+     *\/\n+\n+    \/* ---------------- static fields ---------------- *\/\n+\n+    \/**\n+     * Group name.\n+     *\/\n+    private static final String GROUP = \"Xoroshiro\";\n+\n+    \/**\n+     * The seed generator for default constructors.\n+     *\/\n+    private static final AtomicLong defaultGen = new AtomicLong(RandomSupport.initialSeed());\n+\n+    \/* ---------------- instance fields ---------------- *\/\n+\n+    \/**\n+     * The per-instance state.\n+     * At least one of the two fields x0 and x1 must be nonzero.\n+     *\/\n+    private long x0, x1;\n+\n+    \/* ---------------- constructors ---------------- *\/\n+\n+    \/**\n+     * Basic constructor that initializes all fields from parameters.\n+     * It then adjusts the field values if necessary to ensure that\n+     * all constraints on the values of fields are met.\n+     *\n+     * @param x0 first word of the initial state\n+     * @param x1 second word of the initial state\n+     *\/\n+    public Xoroshiro128PlusPlus(long x0, long x1) {\n+        this.x0 = x0;\n+        this.x1 = x1;\n+        \/\/ If x0 and x1 are both zero, we must choose nonzero values.\n+        if ((x0 | x1) == 0) {\n+            this.x0 = RandomSupport.GOLDEN_RATIO_64;\n+            this.x1 = RandomSupport.SILVER_RATIO_64;\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link Xoroshiro128PlusPlus} using the\n+     * specified {@code long} value as the initial seed. Instances of\n+     * {@link Xoroshiro128PlusPlus} created with the same seed in the same\n+     * program generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public Xoroshiro128PlusPlus(long seed) {\n+        \/\/ Using a value with irregularly spaced 1-bits to xor the seed\n+        \/\/ argument tends to improve \"pedestrian\" seeds such as 0 or\n+        \/\/ other small integers.  We may as well use SILVER_RATIO_64.\n+        \/\/\n+        \/\/ The x values are then filled in as if by a SplitMix PRNG with\n+        \/\/ GOLDEN_RATIO_64 as the gamma value and Stafford13 as the mixer.\n+        this(RandomSupport.mixStafford13(seed ^= RandomSupport.SILVER_RATIO_64),\n+             RandomSupport.mixStafford13(seed + RandomSupport.GOLDEN_RATIO_64));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link Xoroshiro128PlusPlus} that is likely to\n+     * generate sequences of values that are statistically independent\n+     * of those of any other instances in the current program execution,\n+     * but may, and typically does, vary across program invocations.\n+     *\/\n+    public Xoroshiro128PlusPlus() {\n+        \/\/ Using GOLDEN_RATIO_64 here gives us a good Weyl sequence of values.\n+        this(defaultGen.getAndAdd(RandomSupport.GOLDEN_RATIO_64));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link Xoroshiro128PlusPlus} using the specified array of\n+     * initial seed bytes. Instances of {@link Xoroshiro128PlusPlus} created with the same\n+     * seed array in the same program execution generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public Xoroshiro128PlusPlus(byte[] seed) {\n+        \/\/ Convert the seed to 2 long values, which are not both zero.\n+        long[] data = RandomSupport.convertSeedBytesToLongs(seed, 2, 2);\n+        long x0 = data[0], x1 = data[1];\n+        this.x0 = x0;\n+        this.x1 = x1;\n+    }\n+\n+    \/* ---------------- public methods ---------------- *\/\n+\n+    public Xoroshiro128PlusPlus copy() {\n+        return new Xoroshiro128PlusPlus(x0, x1);\n+    }\n+\n+    \/*\n+     * The following two comments are quoted from http:\/\/prng.di.unimi.it\/xoroshiro128plusplus.c\n+     *\/\n+\n+    \/*\n+     * To the extent possible under law, the author has dedicated all copyright\n+     * and related and neighboring rights to this software to the public domain\n+     * worldwide. This software is distributed without any warranty.\n+     * <p>\n+     * See http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/.\n+     *\/\n+\n+    \/*\n+     * This is xoroshiro128++ 1.0, one of our all-purpose, rock-solid,\n+     * small-state generators. It is extremely (sub-ns) fast and it passes all\n+     * tests we are aware of, but its state space is large enough only for\n+     * mild parallelism.\n+     * <p>\n+     * For generating just floating-point numbers, xoroshiro128+ is even\n+     * faster (but it has a very mild bias, see notes in the comments).\n+     * <p>\n+     * The state must be seeded so that it is not everywhere zero. If you have\n+     * a 64-bit seed, we suggest to seed a splitmix64 generator and use its\n+     * output to fill s.\n+     *\/\n+\n+    @Override\n+    public long nextLong() {\n+        final long s0 = x0;\n+        long s1 = x1;\n+   \/\/ Compute the result based on current state information\n+   \/\/ (this allows the computation to be overlapped with state update).\n+   final long result = Long.rotateLeft(s0 + s1, 17) + s0;  \/\/ \"plusplus\" scrambler\n+\n+        s1 ^= s0;\n+        x0 = Long.rotateLeft(s0, 49) ^ s1 ^ (s1 << 21); \/\/ a, b\n+        x1 = Long.rotateLeft(s1, 28); \/\/ c\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public double jumpDistance() {\n+        return 0x1.0p64;\n+    }\n+\n+    @Override\n+    public double leapDistance() {\n+        return 0x1.0p96;\n+    }\n+\n+    private static final long[] JUMP_TABLE = { 0x2bd7a6a6e99c2ddcL, 0x0992ccaf6a6fca05L };\n+\n+    private static final long[] LEAP_TABLE = { 0x360fd5f2cf8d5d99L, 0x9c6e6877736c46e3L };\n+\n+    @Override\n+    public void jump() {\n+        jumpAlgorithm(JUMP_TABLE);\n+    }\n+\n+    @Override\n+    public void leap() {\n+        jumpAlgorithm(LEAP_TABLE);\n+    }\n+\n+    private void jumpAlgorithm(long[] table) {\n+        long s0 = 0, s1 = 0;\n+        for (int i = 0; i < table.length; i++) {\n+            for (int b = 0; b < 64; b++) {\n+                if ((table[i] & (1L << b)) != 0) {\n+                    s0 ^= x0;\n+                    s1 ^= x1;\n+                }\n+                nextLong();\n+            }\n+        }\n+       x0 = s0;\n+       x1 = s1;\n+    }\n+}\n","filename":"src\/jdk.random\/share\/classes\/jdk\/random\/Xoroshiro128PlusPlus.java","additions":284,"deletions":0,"binary":false,"changes":284,"status":"added"},{"patch":"@@ -0,0 +1,315 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.random;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGenerator.LeapableGenerator;\n+import jdk.internal.util.random.RandomSupport;\n+import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n+\n+\/**\n+ * A \"jumpable and leapable\" pseudorandom number generator (PRNG) whose period\n+ * is roughly 2<sup>256<\/sup>.  Class {@link Xoshiro256PlusPlus} implements\n+ * interfaces {@link RandomGenerator} and {@link LeapableGenerator},\n+ * and therefore supports methods for producing pseudorandomly chosen\n+ * values of type {@code int}, {@code long}, {@code float}, {@code double},\n+ * and {@code boolean} (and for producing streams of pseudorandomly chosen\n+ * numbers of type {@code int}, {@code long}, and {@code double}),\n+ * as well as methods for creating new {@link Xoshiro256PlusPlus} objects\n+ * by moving forward either a large distance (2<sup>128<\/sup>) or a very large\n+ * distance (2<sup>192<\/sup>) around the state cycle.\n+ * <p>\n+ * Series of generated values pass the TestU01 BigCrush and PractRand test suites\n+ * that measure independence and uniformity properties of random number generators.\n+ * (Most recently validated with\n+ * <a href=\"http:\/\/simul.iro.umontreal.ca\/testu01\/tu01.html\">version 1.2.3 of TestU01<\/a>\n+ * and <a href=\"http:\/\/pracrand.sourceforge.net\">version 0.90 of PractRand<\/a>.\n+ * Note that TestU01 BigCrush was used to test not only values produced by the {@code nextLong()}\n+ * method but also the result of bit-reversing each value produced by {@code nextLong()}.)\n+ * These tests validate only the methods for certain\n+ * types and ranges, but similar properties are expected to hold, at\n+ * least approximately, for others as well.\n+ * <p>\n+ * The class {@link Xoshiro256PlusPlus} uses the {@code xoshiro256} algorithm,\n+ * version 1.0 (parameters 17, 45), with the \"++\" scrambler that computes\n+ * {@code Long.rotateLeft(s0 + s3, 23) + s0}.\n+ * Its state consists of four {@code long} fields {@code x0}, {@code x1}, {@code x2},\n+ * and {@code x3}, which can take on any values provided that they are not all zero.\n+ * The period of this generator is 2<sup>256<\/sup>-1.\n+ * <p>\n+ * The 64-bit values produced by the {@code nextLong()} method are equidistributed.\n+ * To be precise, over the course of the cycle of length 2<sup>256<\/sup>-1,\n+ * each nonzero {@code long} value is generated 2<sup>192<\/sup> times,\n+ * but the value 0 is generated only 2<sup>192<\/sup>-1 times.\n+ * The values produced by the {@code nextInt()}, {@code nextFloat()}, and {@code nextDouble()}\n+ * methods are likewise equidistributed.\n+ * Moreover, the 64-bit values produced by the {@code nextLong()} method are 3-equidistributed.\n+ * <p>\n+ * Instances {@link Xoshiro256PlusPlus} are <em>not<\/em> thread-safe.\n+ * They are designed to be used so that each thread as its own instance.\n+ * The methods {@link #jump} and {@link #leap} and {@link #jumps} and {@link #leaps}\n+ * can be used to construct new instances of {@link Xoshiro256PlusPlus} that traverse\n+ * other parts of the state cycle.\n+ * <p>\n+ * Instances of {@link Xoshiro256PlusPlus} are not cryptographically\n+ * secure.  Consider instead using {@link java.security.SecureRandom}\n+ * in security-sensitive applications. Additionally,\n+ * default-constructed instances do not use a cryptographically random\n+ * seed unless the {@linkplain System#getProperty system property}\n+ * {@code java.util.secureRandomSeed} is set to {@code true}.\n+ *\n+ * @since   17\n+ *\n+ *\/\n+@RandomGeneratorProperties(\n+        name = \"Xoshiro256PlusPlus\",\n+        group = \"Xoshiro\",\n+        i = 256, j = 1, k = 0,\n+        equidistribution = 4\n+)\n+public final class Xoshiro256PlusPlus implements LeapableGenerator {\n+\n+    \/*\n+     * Implementation Overview.\n+     *\n+     * This is an implementation of the xoroshiro128++ algorithm version 1.0,\n+     * written in 2019 by David Blackman and Sebastiano Vigna (vigna@acm.org).\n+     * See http:\/\/xoshiro.di.unimi.it and these two papers:\n+     *\n+     *    Sebastiano Vigna. 2016. An Experimental Exploration of Marsaglia's\n+     *    xorshift Generators, Scrambled. ACM Transactions on Mathematical\n+     *    Software 42, 4, Article 30 (June 2016), 23 pages.\n+     *    https:\/\/doi.org\/10.1145\/2845077\n+     *\n+     *    David Blackman and Sebastiano Vigna.  2018.  Scrambled Linear\n+     *    Pseudorandom Number Generators.  Computing Research Repository (CoRR).\n+     *    http:\/\/arxiv.org\/abs\/1805.01407\n+     *\n+     * The jump operation moves the current generator forward by 2*128\n+     * steps; this has the same effect as calling nextLong() 2**128\n+     * times, but is much faster.  Similarly, the leap operation moves\n+     * the current generator forward by 2*192 steps; this has the same\n+     * effect as calling nextLong() 2**192 times, but is much faster.\n+     * The copy method may be used to make a copy of the current\n+     * generator.  Thus one may repeatedly and cumulatively copy and\n+     * jump to produce a sequence of generators whose states are well\n+     * spaced apart along the overall state cycle (indeed, the jumps()\n+     * and leaps() methods each produce a stream of such generators).\n+     * The generators can then be parceled out to other threads.\n+     *\n+     * File organization: First static fields, then instance\n+     * fields, then constructors, then instance methods.\n+     *\/\n+\n+    \/* ---------------- static fields ---------------- *\/\n+\n+    \/**\n+     * The seed generator for default constructors.\n+     *\/\n+    private static final AtomicLong DEFAULT_GEN = new AtomicLong(RandomSupport.initialSeed());\n+\n+    \/* ---------------- instance fields ---------------- *\/\n+\n+    \/**\n+     * The per-instance state.\n+     * At least one of the four fields x0, x1, x2, and x3 must be nonzero.\n+     *\/\n+    private long x0, x1, x2, x3;\n+\n+    \/* ---------------- constructors ---------------- *\/\n+\n+    \/**\n+     * Basic constructor that initializes all fields from parameters.\n+     * It then adjusts the field values if necessary to ensure that\n+     * all constraints on the values of fields are met.\n+     *\n+     * @param x0 first word of the initial state\n+     * @param x1 second word of the initial state\n+     * @param x2 third word of the initial state\n+     * @param x3 fourth word of the initial state\n+     *\/\n+    public Xoshiro256PlusPlus(long x0, long x1, long x2, long x3) {\n+        this.x0 = x0;\n+        this.x1 = x1;\n+        this.x2 = x2;\n+        this.x3 = x3;\n+        \/\/ If x0, x1, x2, and x3 are all zero, we must choose nonzero values.\n+        if ((x0 | x1 | x2 | x3) == 0) {\n+            \/\/ At least three of the four values generated here will be nonzero.\n+            this.x0 = RandomSupport.mixStafford13(x0 += RandomSupport.GOLDEN_RATIO_64);\n+            this.x1 = (x0 += RandomSupport.GOLDEN_RATIO_64);\n+            this.x2 = (x0 += RandomSupport.GOLDEN_RATIO_64);\n+            this.x3 = (x0 += RandomSupport.GOLDEN_RATIO_64);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link Xoshiro256PlusPlus} using the\n+     * specified {@code long} value as the initial seed. Instances of\n+     * {@link Xoshiro256PlusPlus} created with the same seed in the same\n+     * program generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public Xoshiro256PlusPlus(long seed) {\n+        \/\/ Using a value with irregularly spaced 1-bits to xor the seed\n+        \/\/ argument tends to improve \"pedestrian\" seeds such as 0 or\n+        \/\/ other small integers.  We may as well use SILVER_RATIO_64.\n+        \/\/\n+        \/\/ The x values are then filled in as if by a SplitMix PRNG with\n+        \/\/ GOLDEN_RATIO_64 as the gamma value and Stafford13 as the mixer.\n+        this(RandomSupport.mixStafford13(seed ^= RandomSupport.SILVER_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed += RandomSupport.GOLDEN_RATIO_64),\n+             RandomSupport.mixStafford13(seed + RandomSupport.GOLDEN_RATIO_64));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link Xoshiro256PlusPlus} that is likely to\n+     * generate sequences of values that are statistically independent\n+     * of those of any other instances in the current program execution,\n+     * but may, and typically does, vary across program invocations.\n+     *\/\n+    public Xoshiro256PlusPlus() {\n+        \/\/ Using GOLDEN_RATIO_64 here gives us a good Weyl sequence of values.\n+        this(DEFAULT_GEN.getAndAdd(RandomSupport.GOLDEN_RATIO_64));\n+    }\n+\n+    \/**\n+     * Creates a new instance of {@link Xoshiro256PlusPlus} using the specified array of\n+     * initial seed bytes. Instances of {@link Xoshiro256PlusPlus} created with the same\n+     * seed array in the same program execution generate identical sequences of values.\n+     *\n+     * @param seed the initial seed\n+     *\/\n+    public Xoshiro256PlusPlus(byte[] seed) {\n+        \/\/ Convert the seed to 4 long values, which are not all zero.\n+        long[] data = RandomSupport.convertSeedBytesToLongs(seed, 4, 4);\n+        long x0 = data[0], x1 = data[1], x2 = data[2], x3 = data[3];\n+        this.x0 = x0;\n+        this.x1 = x1;\n+        this.x2 = x2;\n+        this.x3 = x3;\n+    }\n+\n+    \/* ---------------- public methods ---------------- *\/\n+\n+    public Xoshiro256PlusPlus copy() {\n+        return new Xoshiro256PlusPlus(x0, x1, x2, x3);\n+    }\n+\n+    \/*\n+     * The following two comments are quoted from http:\/\/prng.di.unimi.it\/xoshiro256plusplus.c\n+     *\/\n+\n+    \/*\n+     * To the extent possible under law, the author has dedicated all copyright\n+     * and related and neighboring rights to this software to the public domain\n+     * worldwide. This software is distributed without any warranty.\n+     * <p>\n+     * See http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/.\n+     *\/\n+\n+    \/*\n+     * This is xoshiro256++ 1.0, one of our all-purpose, rock-solid generators.\n+     * It has excellent (sub-ns) speed, a state (256 bits) that is large\n+     * enough for any parallel application, and it passes all tests we are\n+     * aware of.\n+     *\n+     * For generating just floating-point numbers, xoshiro256+ is even faster.\n+     *\n+     * The state must be seeded so that it is not everywhere zero. If you have\n+     * a 64-bit seed, we suggest to seed a splitmix64 generator and use its\n+     * output to fill s.\n+     *\/\n+\n+    @Override\n+    public long nextLong() {\n+        \/\/ Compute the result based on current state information\n+        \/\/ (this allows the computation to be overlapped with state update).\n+        final long result = Long.rotateLeft(x0 + x3, 23) + x0;  \/\/ \"plusplus\" scrambler\n+\n+        long q0 = x0, q1 = x1, q2 = x2, q3 = x3;\n+        {   \/\/ xoshiro256 1.0\n+            long t = q1 << 17;\n+            q2 ^= q0;\n+            q3 ^= q1;\n+            q1 ^= q2;\n+            q0 ^= q3;\n+            q2 ^= t;\n+            q3 = Long.rotateLeft(q3, 45);\n+        }\n+        x0 = q0; x1 = q1; x2 = q2; x3 = q3;\n+        return result;\n+    }\n+\n+    @Override\n+    public double jumpDistance() {\n+        return 0x1.0p128;\n+    }\n+\n+    @Override\n+    public double leapDistance() {\n+        return 0x1.0p192;\n+    }\n+\n+    private static final long[] JUMP_TABLE = {\n+        0x180ec6d33cfd0abaL, 0xd5a61266f0c9392cL, 0xa9582618e03fc9aaL, 0x39abdc4529b1661cL };\n+\n+    private static final long[] LEAP_TABLE = {\n+        0x76e15d3efefdcbbfL, 0xc5004e441c522fb3L, 0x77710069854ee241L, 0x39109bb02acbe635L };\n+\n+    @Override\n+    public void jump() {\n+        jumpAlgorithm(JUMP_TABLE);\n+    }\n+\n+    @Override\n+    public void leap() {\n+        jumpAlgorithm(LEAP_TABLE);\n+    }\n+\n+    private void jumpAlgorithm(long[] table) {\n+        long s0 = 0, s1 = 0, s2 = 0, s3 = 0;\n+        for (int i = 0; i < table.length; i++) {\n+            for (int b = 0; b < 64; b++) {\n+                if ((table[i] & (1L << b)) != 0) {\n+                    s0 ^= x0;\n+                    s1 ^= x1;\n+                    s2 ^= x2;\n+                    s3 ^= x3;\n+                }\n+                nextLong();\n+            }\n+        }\n+   x0 = s0;\n+   x1 = s1;\n+   x2 = s2;\n+   x3 = s3;\n+    }\n+\n+}\n","filename":"src\/jdk.random\/share\/classes\/jdk\/random\/Xoshiro256PlusPlus.java","additions":315,"deletions":0,"binary":false,"changes":315,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.util.random.RandomSupport;\n+\n+\/**\n+ * Defines implementations of the\n+ * {@linkplain java.util.random.RandomGenerator RandomGenerator Interface}.\n+ *\n+ * @provides jdk.random.L128X1024MixRandom\n+ * @provides jdk.random.L128X128MixRandom\n+ * @provides jdk.random.L128X256MixRandom\n+ * @provides jdk.random.L32X64MixRandom\n+ * @provides jdk.random.L64X1024MixRandom\n+ * @provides jdk.random.L64X128MixRandom\n+ * @provides jdk.random.L64X128StarStarRandom\n+ * @provides jdk.random.L64X256MixRandom\n+ * @provides jdk.random.Xoroshiro128PlusPlus\n+ * @provides jdk.random.Xoshiro256PlusPlus\n+ *\n+ * @use java.util.random.RandomGenerator\n+ * @use jdk.internal.util.random.RandomSupport\n+ *\n+ * @moduleGraph\n+ * @since 16\n+ *\/\n+module jdk.random {\n+    exports jdk.random to\n+            java.base;\n+\n+    provides java.util.random.RandomGenerator with\n+        jdk.random.L32X64MixRandom,\n+        jdk.random.L64X128MixRandom,\n+        jdk.random.L64X128StarStarRandom,\n+        jdk.random.L64X256MixRandom,\n+        jdk.random.L64X1024MixRandom,\n+        jdk.random.L128X128MixRandom,\n+        jdk.random.L128X256MixRandom,\n+        jdk.random.L128X1024MixRandom,\n+        jdk.random.Xoroshiro128PlusPlus,\n+        jdk.random.Xoshiro256PlusPlus;\n+}\n","filename":"src\/jdk.random\/share\/classes\/module-info.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2020 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Comparator;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGenerator.*;\n+import java.util.random.RandomGeneratorFactory;\n+\n+\/**\n+ * @test\n+ * @summary test bit sequences produced by clases that implement interface RandomGenerator\n+ * @bug 8248862\n+ * @run main RandomCanaryPi\n+ * @key randomness\n+ *\/\n+\n+public class RandomCanaryPi {\n+   static double pi(RandomGenerator rng) {\n+        int N = 10000000;\n+        int k = 0;\n+\n+        for (int i = 0; i < N; i++) {\n+            double x = rng.nextDouble();\n+            double y = rng.nextDouble();\n+\n+            if (x * x + y * y <= 1.0) {\n+                k++;\n+            }\n+        }\n+\n+        return 4.0 * (double)k \/ (double)N;\n+    }\n+\n+    static int failed = 0;\n+\n+    public static void main(String[] args) {\n+        RandomGeneratorFactory.all()\n+                .sorted(Comparator.comparing(RandomGeneratorFactory::name))\n+                .forEach(factory -> {\n+                    RandomGenerator rng = factory.create();\n+                    double pi = pi(rng);\n+                    double delta = Math.abs(Math.PI - pi);\n+                    boolean pass = delta < 1E-2;\n+\n+                    if (!pass) {\n+                        System.err.println(\"Algorithm    = \" + factory.name() + \" failed\");\n+                        System.err.println(\"Actual       = \" + Math.PI);\n+                        System.err.println(\"Monte Carlo  = \" + pi);\n+                        System.err.println(\"Delta        = \" + delta);\n+                        System.err.println();\n+\n+                        failed++;\n+                    }\n+                });\n+        if (failed != 0) {\n+            throw new RuntimeException(failed + \" tests failed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Random\/RandomCanaryPi.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,454 @@\n+\/*\n+ * Copyright (c) 2012, 2020 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.PrimitiveIterator;\n+\n+import java.util.random.*;\n+\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.IntSupplier;\n+import java.util.function.LongSupplier;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toSet;\n+\n+\/**\n+ * @test\n+ * @summary test bit sequences produced by clases that implement interface RandomGenerator\n+ * @bug 8248862\n+ * @run main RandomTestBsi1999\n+ * @key randomness\n+ *\/\n+\n+public class RandomTestBsi1999 {\n+\n+    \/* A set of tests for pseudorandom number generators inspired by this report:\n+     *\n+     *   Werner Schindler.  Functionality Classes and Evaluation Methodology for\n+     *   Deterministic Random Number Generators, Version 2.0.\n+     *   Bundesamt fur Sicherheit in der Informationstechnik (BSI).  December 2, 1999.\n+     *   https:\/\/www.bsi.bund.de\/SharedDocs\/Downloads\/DE\/BSI\/Zertifizierung\/Interpretationen\/AIS_20_Functionality_Classes_Evaluation_Methodology_DRNG_e.pdf\n+     *\n+     * Section F of this report (pp. 19-20) recommends the use of five tests to evaluate a\n+     * sequence of bits:\n+     *\n+     *        Monobit test\n+     *        Poker test\n+     *        Run test\n+     *        Long run test\n+     *        Autocorrelation test\n+     *\n+     * The first four of these tests are in turn taken from this report:\n+     *\n+     *   National Institute of Standards and Technology (NIST),\n+     *   U.S. Department of Commerce.  Security Requirements for\n+     *   Cryptographic Modules.  Federal Information Processing\n+     *   Standard (FIPS) 140-1, January 11, 1994.\n+     *   https:\/\/csrc.nist.gov\/csrc\/media\/publications\/fips\/140\/1\/archive\/1994-01-11\/documents\/fips1401.pdf\n+     *\n+     * The BSI report appears to contain a few typos in transcribing the FIPS 140-1\n+     * requirements (pp. 44-45); specifically, the last three intervals for the runs test\n+     * (for lengths 4, 5, and 6+) are given as \"223 - 402, 90 - 223, 90 - 223\" in the FIPS\n+     * standard but as \"233-402, 90-223, 90-233\" in the BSI publication.  A quick\n+     * mathematical check indicates that the FIPS 140-1 values are correct; therefore we\n+     * use those values here. In addition, the BSI report specifies a test interval of\n+     * 2326-2674 for the autocorrelation test, which provides an appropriately small\n+     * rejection rate if the test were done for only a single value of tau; but because we\n+     * wish to perform 5000 distinct tests, one for each value of tau in the range 1-5000,\n+     * that test interval produces too many false positives.  Some calculation shows that\n+     * the interval 2267-2733 used by the FIPS 140-1 run test for runs of length 1 is\n+     * appropriate, so we use that interval here for each of the 5000 individual\n+     * autocorrelation tests.\n+     *\n+     * Each of the four FIPS 140-1 tests examines a sequence of 20000 bits.  The\n+     * autocorrelation test examines a sequence of 10000 bits.  It is convenient to\n+     * generate a sequence of 20000 bits (which we represent as an array of 20000 bytes)\n+     * and then apply all five tests, knowing that the autocorrelation test will examine\n+     * only the first half of the byte array.\n+     *\n+     * The descriptions of the tests are quoted from the FIPS 140-1 and BSI reports\n+     * (with some adjustments of punctuation and mathematical symbols, as well as\n+     * for our specific choices of test intervals).\n+     *\/\n+\n+    static String currentRNG = \"\";\n+    static int failCount = 0;\n+\n+    static void exceptionOnFail() {\n+        if (failCount != 0) {\n+            throw new RuntimeException(failCount + \" fails detected\");\n+        }\n+    }\n+\n+    static void setRNG(String rng) {\n+        currentRNG = rng;\n+    }\n+\n+    static void fail(String format, Object... args) {\n+        if (currentRNG.length() != 0) {\n+            System.err.println(currentRNG);\n+            currentRNG = \"\";\n+        }\n+\n+        System.err.format(\"  \" + format, args);\n+        failCount++;\n+    }\n+\n+    private static final int SEQUENCE_SIZE = 20000;\n+\n+    \/* The Monobit Test\n+     *\n+     *   1. Count the number of ones in the 20,000 bit stream.  Denote this quantity by X.\n+     *\n+     *   2. The test is passed if 9,654 < X < 10,346.\n+     *\/\n+    static int monobitTest(String id, byte[] s) {\n+       \/\/ System.out.println(\"monobit test\");\n+       int count = 0;\n+       for (int j = 0; j < s.length; j++) {\n+           count += s[j];\n+       }\n+       int monobitFailure = ((9654 < count) && (count < 10346)) ? 0 : 1;\n+       if (monobitFailure != 0) fail(\"monobit test failure for %s: count=%d (should be in [9654,10346])\\n\", id, count);\n+       return monobitFailure;\n+    }\n+\n+    \/* The Poker Test\n+     *\n+     *   1.  Divide the 20,000 bit stream into 5,000 contiguous 4-bit segments.  Count and\n+     *   store the number of occurrences of each of the 16 possible 4-bit values.  Denote\n+     *   f(i) as the number of each 4-bit value i where 0 <= i <= 15.\n+     *\n+     *   2.  Evaluate the following: X = (16\/5000)(sum[i=0,15] (f(i))**2) - 5000\n+     *\n+     *   3.  The test is passed if 1.03 < X < 57.4.\n+     *\/\n+\n+    static int pokerTest(String id, byte[] s) {\n+       \/\/ System.out.println(\"poker test\");\n+       \/\/ Divide the bit sequence into 4-bit chunks, and count the number of times each 4-bit value appears.\n+       int[] stats = new int[16];\n+       int v = 0;\n+       for (int j = 0; j < s.length; j++) {\n+           v = (v << 1) | s[j];\n+           if ((j & 3) == 3) {\n+           ++stats[v];\n+           v = 0;\n+           }\n+       }\n+       int z = 0;\n+       for (int k = 0; k < stats.length; k++) {\n+           z += stats[k]*stats[k];\n+       }\n+       double x = (16.0 \/ (s.length \/ 4)) * z - (s.length \/ 4);\n+       int pokerFailure = ((1.03 < x) && (x < 57.4)) ? 0 : 1;\n+       if (pokerFailure != 0) fail(\"poker test failure for %s: x=%g (should be in [1.03,57.4])\\n\", id, x);\n+       return pokerFailure;\n+    }\n+\n+    \/* The Runs Test\n+     *\n+     *   1.  A run is defined as a maximal sequence of consecutive bits of either all ones\n+     *   or all zeros, which is part of the 20,000 bit sample stream.  The incidences of\n+     *   runs (for both consecutive zeros and consecutive ones) of all lengths (>= 1) in\n+     *   the sample stream should be counted and stored.\n+     *\n+     *   2.  The test is passed if the number of runs that occur (of lengths 1 through 6)\n+     *   is each within the corresponding interval specified below.  This must hold for\n+     *   both the zeros and ones; that is, all 12 counts must lie in the specified\n+     *   interval.  For the purpose of this test, runs of greater than 6 are considered to\n+     *   be of length 6.\n+     *\n+     *        Length of run       Required Interval\n+     *             1                2,267 - 2,733\n+     *             2                1,079 - 1,421\n+     *             3                  502 - 748\n+     *             4                  223 - 402\n+     *             5                   90 - 223\n+     *             6+                  90 - 223\n+     *\n+     * The Long Run Test\n+     *\n+     *   1 . A long run is defined to be a run of length 34 or more (of either zeros or ones).\n+     *\n+     *   2.  On the sample of 20,000 bits, the test is passed if there are NO long runs.\n+     *\/\n+    static int runTestAndLongRunTest(String id, byte[] s) {\n+       \/\/ System.out.println(\"run test\");\n+       int[][] stats = new int[2][8];\n+       int count = 0;\n+       for (int j = 0; j < s.length; j++) {\n+           ++count;\n+           if ((j == (s.length - 1)) || (s[j+1] != s[j])) {\n+           ++stats[s[j]][(count < 6) ? count : (count < 34) ? 6 : 7];\n+           count = 0;\n+           }\n+       }\n+       stats[0][6] += stats[0][7];\n+       stats[1][6] += stats[1][7];\n+       int runFailure = checkRunStats(stats[0]) | checkRunStats(stats[1]);\n+       if (runFailure != 0) fail(\"run test failure for %s\\n\", id);\n+       int longRunFailure = ((stats[0][7] == 0) && (stats[1][7] == 0)) ? 0 : 1;\n+       if (longRunFailure != 0) fail(\"long run test failure for %s\\n\", id);\n+       return (runFailure + longRunFailure);\n+    }\n+\n+    static int checkRunStats(int[] stats) {\n+       int runFailure = 0;\n+       runFailure |= ((2267 <= stats[1]) && (stats[1] <= 2733)) ? 0 : 1;\n+       runFailure |= ((1079 <= stats[2]) && (stats[2] <= 1421)) ? 0 : 1;\n+       runFailure |= (( 502 <= stats[3]) && (stats[3] <=  748)) ? 0 : 1;\n+       runFailure |= (( 223 <= stats[4]) && (stats[4] <=  402)) ? 0 : 1;\n+       runFailure |= ((  90 <= stats[5]) && (stats[5] <=  223)) ? 0 : 1;\n+       runFailure |= ((  90 <= stats[6]) && (stats[6] <=  223)) ? 0 : 1;\n+       return runFailure;\n+        }\n+\n+        \/* Autocorrelation Test\n+         *\n+         *   For tau in {1, ..., 5000}, Z[tau] := sum[j=1,5000] (b[j] ^ b[j+tau]).\n+         *\n+         *   The sequence passes the autocorrelation test if every Z[tau] lies within the\n+         *   interval 2267-2733.\n+         *\/\n+        static int autocorrelationTest(String id, byte[] s) {\n+       \/\/ System.out.println(\"autocorrelation test\");\n+       int autocorrelationFailure = 0;\n+       int N = s.length \/ 4;\n+       for (int tau = 1; tau <= N; tau++) {\n+           int count = 0;\n+           for (int j = 0; j < N; j++) {\n+           count += (s[j] ^ s[j+tau]);\n+           }\n+           \/\/ We intentionally use bounds [2267, 2733], which are wider than\n+           \/\/ the bounds [2326, 2674] specified by BSI for this test.\n+           \/\/ The latter bounds produce way too many false positives.\n+           int singleAutocorrelationFailure = ((2267 < count) && (count < 2733)) ? 0 : 1;\n+           if (singleAutocorrelationFailure != 0) {\n+           if (autocorrelationFailure < 8) {\n+               fail(\"autocorrelation failure for %s: count=%d (should be in [2267,2733]), tau=%d\\n\", id, count, tau);\n+               if (count < 100 || count > 4900) {\n+                    System.out.print(\"    \");\n+               for (int q = 0; q < 50; q++) System.out.print(s[q]);\n+                    System.out.println();\n+               }\n+           }\n+           }\n+           autocorrelationFailure += singleAutocorrelationFailure;\n+       }\n+       return (autocorrelationFailure == 0) ? 0 : 1;\n+    }\n+\n+    static int entireBsi1999Test(String id, byte[] s) {\n+       return (monobitTest(id, s) +\n+           pokerTest(id, s) +\n+           runTestAndLongRunTest(id, s) +\n+           autocorrelationTest(id, s)\n+           );\n+    }\n+\n+    \/* To test a sequence of boolean values from a BooleanSupplier,\n+     * sequentially extract 20000 boolean values, convert to an array\n+     * of bytes, and feed them to method {@code entireBsi1999Test}.\n+     *\/\n+\n+    static int testRngBsi1999BooleanOnce(String id, BooleanSupplier theSupplier) {\n+       int failureCount = 0;\n+       byte[] s = new byte[SEQUENCE_SIZE];\n+       \/\/ Take the next SEQUENCE_SIZE booleans and test them\n+       for (int j = 0; j < s.length; j++) {\n+           s[j] = (theSupplier.getAsBoolean() ? (byte)1 : (byte)0);\n+       }\n+       failureCount += entireBsi1999Test(id  + \" consecutive\", s);\n+       return failureCount;\n+    }\n+\n+    \/* To test a sequence of long values from a LongSupplier,\n+     * two kinds of tests are performed.\n+     *\n+     * The first kind of test extracts 313=ceiling(20000\/64) long\n+     * values and concatenates all their bits; the first 20000 bits\n+     * are converted to a byte array of bits to be tested.  This test is\n+     * repeated 64 times.\n+     *\n+     * The second kind of test focuses on one bit position m (0 <= m < 64);\n+     * it extracts 20000 long values and uses just bit m from each value\n+     * to produce an array of bytes to be tested.  This test is performed\n+     * once for each possible value of m (64 times in all).\n+     *\/\n+    static int testRngBsi1999LongOnce(String id, LongSupplier theSupplier) {\n+       int failureCount = 0;\n+       byte[] s = new byte[SEQUENCE_SIZE];\n+       \/\/ Part 1: 64 times, take the next SEQUENCE_SIZE bits and test them\n+       for (int m = 0; m < 64; m++) {\n+           long bits = 0;\n+           int bitCount = 0;\n+           for (int j = 0; j < s.length; j++) {\n+           if ((j & 0x3f) == 0) {\n+               bits = theSupplier.getAsLong();\n+               \/\/ System.out.printf(\"0x%016x\\n\", bits);\n+               bitCount += Long.bitCount((j == (20000 - 32)) ? ((bits << 32) >>> 32) : bits);\n+           }\n+           s[j] = (byte)(bits & 1);\n+           bits >>>= 1;\n+           }\n+           \/\/ System.out.println(m + \": \" + bitCount + \" 1-bits\");\n+           failureCount += entireBsi1999Test(id + \" consecutive (\" + bitCount + \" 1-bits)\", s);\n+       }\n+       \/\/ Part 2: for 0 <= m < 64, use bit m from each of the next SEQUENCE_SIZE longs\n+       for (int m = 0; m < 64; m++) {\n+           for (int j = 0; j < s.length; j++) {\n+           s[j] = (byte)((theSupplier.getAsLong() >>> m) & 1);\n+           }\n+           failureCount += entireBsi1999Test(id + \" bit \" + m, s);\n+       }\n+       return failureCount;\n+    }\n+\n+    \/* To test a sequence of ing values from an IntSupplier,\n+     * two kinds of tests are performed.\n+     *\n+     * The first kind of test extracts 625=20000\/32 int values and\n+     * concatenates all their bits; these 20000 bits are converted to\n+     * a byte array of bits to be tested.  This test is repeated 64\n+     * times.\n+     *\n+     * The second kind of test focuses on one bit position m (0 <= m < 32);\n+     * it extracts 20000 int values and uses just bit m from each value\n+     * to produce an array of bytes to be tested.  This test is performed\n+     * once for each possible value of m (32 times in all).\n+     *\/\n+    static int testRngBsi1999IntOnce(String id, IntSupplier theSupplier) {\n+       int failureCount = 0;\n+       byte[] s = new byte[SEQUENCE_SIZE];\n+       \/\/ Part 1: 64 times, take the next SEQUENCE_SIZE bits and test them\n+       for (int m = 0; m < 64; m++) {\n+           int bits = 0;\n+           int bitCount = 0;\n+           for (int j = 0; j < s.length; j++) {\n+           if ((j & 0x1f) == 0) {\n+               bits = theSupplier.getAsInt();\n+               bitCount += Integer.bitCount(bits);\n+           }\n+           s[j] = (byte)(bits & 1);\n+           bits >>>= 1;\n+           }\n+           \/\/ System.out.println(m + \": \" + bitCount + \" 1-bits\");\n+           failureCount += entireBsi1999Test(id + \" consecutive (\" + bitCount + \" 1-bits)\", s);\n+       }\n+       \/\/ Part 2: for 0 <= m < 32, use bit m from each of the next SEQUENCE_SIZE ints\n+       for (int m = 0; m < 32; m++) {\n+           for (int j = 0; j < s.length; j++) {\n+           s[j] = (byte)((theSupplier.getAsInt() >>> m) & 1);\n+           }\n+           failureCount += entireBsi1999Test(id + \" bit \" + m, s);\n+       }\n+       return failureCount;\n+    }\n+\n+    \/* A call to {@code entireBsi1999Test} may report failure even if the source of random\n+     * bits is quite good, because the test is statistical in nature.  To make the testing\n+     * procedure more robust, if the first call to {@code entireBsi1999Test} fails, then\n+     * the failure is ignored if two more calls to {@code entireBsi1999Test} both succeed.\n+    *\/\n+\n+    static boolean testRngBsi1999Boolean(String id, BooleanSupplier theSupplier, int failureTolerance) {\n+       if (testRngBsi1999BooleanOnce(id, theSupplier) <= failureTolerance) return true;\n+       fail(\"testRngBsi1999Boolean glitch\");\n+       return ((testRngBsi1999BooleanOnce(id, theSupplier) <= failureTolerance) &&\n+           (testRngBsi1999BooleanOnce(id, theSupplier) <= failureTolerance));\n+    }\n+\n+    static boolean testRngBsi1999Long(String id, LongSupplier theSupplier, int failureTolerance) {\n+       if (testRngBsi1999LongOnce(id, theSupplier) <= failureTolerance) return true;\n+       fail(\"testRngBsi1999Long glitch\");\n+       return ((testRngBsi1999LongOnce(id, theSupplier) <= failureTolerance) &&\n+           (testRngBsi1999LongOnce(id, theSupplier) <= failureTolerance));\n+    }\n+\n+    static boolean testRngBsi1999Int(String id, IntSupplier theSupplier, int failureTolerance) {\n+       if (testRngBsi1999IntOnce(id, theSupplier) <= failureTolerance) return true;\n+       fail(\"testRngBsi1999Int glitch\");\n+       return ((testRngBsi1999IntOnce(id, theSupplier) <= failureTolerance) &&\n+           (testRngBsi1999IntOnce(id, theSupplier) <= failureTolerance));\n+    }\n+\n+    static void tryIt(RandomGenerator rng, String id, BooleanSupplier theSupplier) {\n+       System.out.printf(\"Testing %s %s\\n\", rng.getClass().getName(), id);\n+       boolean success = theSupplier.getAsBoolean();\n+       if (!success) {\n+           fail(\"*** Failure of %s %s\\n\", rng.getClass().getName(), id);\n+       }\n+    }\n+\n+    static void testOneRng(RandomGenerator rng, int failureTolerance) {\n+       String name = rng.getClass().getName();\n+       tryIt(rng, \"nextInt\", () -> testRngBsi1999Int(name + \" nextInt\", rng::nextInt, failureTolerance));\n+       tryIt(rng, \"nextLong\", () -> testRngBsi1999Long(name + \" nextLong\", rng::nextLong, failureTolerance));\n+       tryIt(rng, \"nextBoolean\", () -> testRngBsi1999Boolean(name + \" nextBoolean\", rng::nextBoolean, failureTolerance));\n+       tryIt(rng, \"ints\", () -> testRngBsi1999Int(name + \" ints\", rng.ints().iterator()::next, failureTolerance));\n+       tryIt(rng, \"longs\", () -> testRngBsi1999Long(name + \" longs\", rng.longs().iterator()::next, failureTolerance));\n+       {\n+           PrimitiveIterator.OfDouble iter = rng.doubles().iterator();\n+           tryIt(rng, \"doubles\",\n+             () -> testRngBsi1999Int(name + \" doubles\",\n+                         () -> (int)(long)Math.floor(iter.next() * 0x1.0p32),\n+                         failureTolerance));\n+       }\n+       tryIt(rng, \"nextDouble\",\n+             () -> testRngBsi1999Int(name + \" nextDouble\",\n+                         () -> (int)(long)Math.floor(rng.nextDouble() * 0x1.0p32),\n+                         failureTolerance));\n+       tryIt(rng, \"nextFloat\",\n+             () -> testRngBsi1999Int(name + \" nextFloat\",\n+                         () -> (((int)(long)Math.floor(rng.nextFloat() * 0x1.0p16f) << 16)\n+                            | (int)(long)Math.floor(rng.nextFloat() * 0x1.0p16f)),\n+                         failureTolerance));\n+    }\n+\n+    public static void main(String[] args) {\n+        RandomGeneratorFactory.all().forEach(factory -> {\n+            setRNG(factory.name());\n+\n+            if (factory.name().equals(\"Random\")) {\n+                \/\/ testOneRng(factory.create(59), 1);\n+                \/\/ autocorrelation failure for java.util.Random longs bit 0: count=2207 (should be in [2267,2733]), tau=2819\n+\n+            } else {\n+                testOneRng(factory.create(59), 0);\n+            }\n+        });\n+\n+        exceptionOnFail();\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/util\/Random\/RandomTestBsi1999.java","additions":454,"deletions":0,"binary":false,"changes":454,"status":"added"},{"patch":"@@ -0,0 +1,241 @@\n+\/*\n+ * Copyright (c) 2012, 2013, 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.PrimitiveIterator;\n+\n+import java.util.random.*;\n+\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.IntSupplier;\n+import java.util.function.LongSupplier;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Supplier;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toSet;\n+\n+\/**\n+ * @test\n+ * @summary test bit sequences produced by clases that implement interface RandomGenerator\n+ * @bug 8248862\n+ * @run main RandomTestChiSquared\n+ * @key randomness\n+ *\/\n+\n+public class RandomTestChiSquared {\n+\n+    static String currentRNG = \"\";\n+    static int failCount = 0;\n+\n+    static void exceptionOnFail() {\n+        if (failCount != 0) {\n+            throw new RuntimeException(failCount + \" fails detected\");\n+        }\n+    }\n+\n+    static void setRNG(String rng) {\n+        currentRNG = rng;\n+    }\n+\n+    static void fail(String format, Object... args) {\n+        if (currentRNG.length() != 0) {\n+            System.err.println(currentRNG);\n+            currentRNG = \"\";\n+        }\n+\n+        System.err.format(\"  \" + format, args);\n+        failCount++;\n+    }\n+\n+    \/\/ Some simple chi-squared tests similar to that used for the FIPS 140 poker test,\n+    \/\/ but intended primarily to test production of random values from ranges.\n+\n+    private static final int SEQUENCE_SIZE = 20000;\n+\n+    \/\/ Entry k of this table was computed in Microsoft Excel using the formulae\n+    \/\/ =CHISQ.INV(0.0000000777517,k) and =CHISQ.INV.RT(0.00000142611,k)\n+    \/\/ (except that entry 0 is a dummy and should never be used).\n+    static final double[][] chiSquaredBounds = {\n+       { 0.0, 0.0 },\n+       { 9.49598E-15, 23.24513154 },\n+       { 1.55503E-07, 26.92112020 },\n+       { 4.40485E-05, 29.93222467 },\n+       { 0.000788782, 32.62391510 },\n+       { 0.004636947, 35.11665045 },\n+       { 0.015541535, 37.46947634 },\n+       { 0.037678318, 39.71667636 },\n+       { 0.074471919, 41.88031518 },\n+       { 0.128297057, 43.97561646 },\n+       { 0.200566433, 46.01362542 },\n+       { 0.291944952, 48.00266676 },\n+       { 0.402564694, 49.94920504 },\n+       { 0.532199236, 51.85838271 },\n+       { 0.680392565, 53.73437242 },\n+       { 0.846549931, 55.58061674 },\n+       { 1.030000010, 57.39999630 },\n+       { 1.230036580, 59.19495111 },\n+       { 1.445945898, 60.96756998 },\n+       { 1.677024296, 62.71965780 },\n+       { 1.922589129, 64.45278706 },\n+       { 2.181985238, 66.16833789 },\n+       { 2.454588423, 67.86752964 },\n+       { 2.739806923, 69.55144602 },\n+       { 3.037081611, 71.22105544 },\n+       { 3.345885349, 72.87722754 },\n+       { 3.665721841, 74.52074682 },\n+       { 3.996124178, 76.15232388 },\n+       { 4.336653242, 77.77260487 },\n+       { 4.686896041, 79.38217943 },\n+       { 5.046464051, 80.98158736 },\n+       { 5.414991603, 82.57132439 }\n+    };\n+\n+\n+\n+    \/\/ N is the number of categories; every element of s ought to be in [0,N).\n+    \/\/ N must be in [1,31].\n+    static boolean chiSquaredTest(String id, int N, IntSupplier theSupplier) {\n+       int[] stats = new int[N];\n+       for (int j = 0; j < SEQUENCE_SIZE; j++) {\n+           int v = theSupplier.getAsInt();\n+           \/\/ assert((0 <= v) && (v < N));\n+           ++stats[v];\n+       }\n+       int z = 0;\n+       for (int k = 0; k < stats.length; k++) {\n+           z += stats[k]*stats[k];\n+       }\n+       double x = ((double)N \/ (double)SEQUENCE_SIZE) * (double)z - (double)SEQUENCE_SIZE;\n+       double lo = chiSquaredBounds[N][0];\n+       double hi = chiSquaredBounds[N][1];\n+       boolean chiSquaredSuccess = ((lo < x) && (x < hi));\n+       if (!chiSquaredSuccess) fail(\"chi-squared test failure for %s: x=%g (should be in [%g,%g])\\n\", id, x, lo, hi);\n+       return chiSquaredSuccess;\n+    }\n+\n+    static boolean testRngChiSquared(String id, int N, IntSupplier theSupplier) {\n+       if (chiSquaredTest(id, N, theSupplier)) return true;\n+       fail(\"testRngChiSquared glitch\");\n+       return chiSquaredTest(id, N, theSupplier) && chiSquaredTest(id, N, theSupplier);\n+    }\n+\n+    static void tryIt(RandomGenerator rng, String kind, Function<String,BooleanSupplier> f) {\n+       String id = rng.getClass().getName() + \" \" + kind;\n+       \/\/ System.out.printf(\"Testing %s\\n\", id);\n+       boolean success = f.apply(id).getAsBoolean();\n+       if (!success) {\n+           fail(\"*** Failure of %s\\n\", id);\n+       }\n+    }\n+\n+    \/\/ To test one instance of an RandomGenerator with the BSI test suite, we test:\n+    \/\/    nextInt()\n+    \/\/    nextLong()\n+    \/\/    nextBoolean()\n+    \/\/    ints()\n+    \/\/    longs()\n+    \/\/    doubles()\n+    \/\/    nextDouble()\n+    \/\/    nextFloat()\n+\n+    static final int[] testSizes = { 11, 13, 16, 17, 19, 23, 24 };\n+\n+    static void testOneRng(RandomGenerator rng, int failureTolerance) {\n+        String name = rng.getClass().getName();\n+        for (int j = 0; j < testSizes.length; j++) {\n+            int N = testSizes[j];\n+            tryIt(rng, \"nextInt(\" + N + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> rng.nextInt(N)));\n+            tryIt(rng, \"nextInt(43, \" + (N+43) + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> rng.nextInt(43, N+43) - 43));\n+            tryIt(rng, \"nextInt(-59, \" + (N-59) + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> rng.nextInt(-59, N-59) + 59));\n+        }\n+        for (int j = 0; j < testSizes.length; j++) {\n+            int N = testSizes[j];\n+            tryIt(rng, \"nextLong(\" + N + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> (int)(rng.nextLong(N))));\n+            tryIt(rng, \"nextLong(43, \" + (N+43) + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> (int)(rng.nextLong(43, N+43) - 43)));\n+            tryIt(rng, \"nextLong(-59, \" + (N-59) + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> (int)(rng.nextLong(-59, N-59) + 59)));\n+        }\n+        for (int j = 0; j < testSizes.length; j++) {\n+            int N = testSizes[j];\n+            tryIt(rng, \"nextFloat(\" + N + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> (int)(rng.nextFloat(N)) % N));\n+            tryIt(rng, \"nextFloat(43, \" + (N+43) + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> (int)(rng.nextFloat(43, N+43) - 43) % N));\n+            tryIt(rng, \"nextFloat(-59, \" + (N-59) + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> (int)(rng.nextFloat(-59, N-59) + 59) % N));\n+        }\n+        for (int j = 0; j < testSizes.length; j++) {\n+            int N = testSizes[j];\n+            tryIt(rng, \"nextDouble(\" + N + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> (int)(rng.nextDouble(N)) % N));\n+            tryIt(rng, \"nextDouble(43, \" + (N+43) + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> (int)(rng.nextDouble(43, N+43) - 43) % N));\n+            tryIt(rng, \"nextDouble(-59, \" + (N-59) + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> (int)(rng.nextDouble(-59, N-59) + 59) % N));\n+        }\n+        for (int j = 0; j < testSizes.length; j++) {\n+            int N = testSizes[j];\n+            PrimitiveIterator.OfInt iter1 = rng.ints(0, N).iterator();\n+            tryIt(rng, \"ints(0, \" + N + \")\", (String id) -> () -> testRngChiSquared(id, N, iter1::next));\n+            PrimitiveIterator.OfInt iter2 = rng.ints(43, N+43).iterator();\n+            tryIt(rng, \"ints(43, \" + (N+43) + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> iter2.next() - 43));\n+            PrimitiveIterator.OfInt iter3 = rng.ints(-59, N-59).iterator();\n+            tryIt(rng, \"ints(-59, \" + (N-59) + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> iter3.next() + 59));\n+        }\n+        for (int j = 0; j < testSizes.length; j++) {\n+            int N = testSizes[j];\n+            PrimitiveIterator.OfLong iter1 = rng.longs(0, N).iterator();\n+            tryIt(rng, \"longs(0, \" + N + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> (int)(iter1.next() + 0)));\n+            PrimitiveIterator.OfLong iter2 = rng.longs(43, N+43).iterator();\n+            tryIt(rng, \"longs(43, \" + (N+43) + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> (int)(iter2.next() - 43)));\n+            PrimitiveIterator.OfLong iter3 = rng.longs(-59, N-59).iterator();\n+            tryIt(rng, \"longs(-59, \" + (N-59) + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> (int)(iter3.next() + 59)));\n+        }\n+        for (int j = 0; j < testSizes.length; j++) {\n+            int N = testSizes[j];\n+            PrimitiveIterator.OfDouble iter1 = rng.doubles(0, N).iterator();\n+            tryIt(rng, \"doubles(0, \" + N + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> (int)(iter1.next() + 0) % N));\n+            PrimitiveIterator.OfDouble iter2 = rng.doubles(43, N+43).iterator();\n+            tryIt(rng, \"doubles(43, \" + (N+43) + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> (int)(iter2.next() - 43) % N));\n+            PrimitiveIterator.OfDouble iter3 = rng.doubles(-59, N-59).iterator();\n+            tryIt(rng, \"doubles(-59, \" + (N-59) + \")\", (String id) -> () -> testRngChiSquared(id, N, () -> (int)(iter3.next() + 59) % N));\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        RandomGeneratorFactory.all().forEach(factory -> {\n+            setRNG(factory.name());\n+\n+            if (factory.name().equals(\"Random\")) {\n+                testOneRng(factory.create(417), 1);\n+            } else {\n+                testOneRng(factory.create(417), 0);\n+            }\n+        });\n+\n+        exceptionOnFail();\n+    }\n+\n+}\n+\n","filename":"test\/jdk\/java\/util\/Random\/RandomTestChiSquared.java","additions":241,"deletions":0,"binary":false,"changes":241,"status":"added"},{"patch":"@@ -0,0 +1,191 @@\n+import java.math.BigInteger;\n+import java.security.SecureRandom;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGenerator.ArbitrarilyJumpableGenerator;\n+import java.util.random.RandomGenerator.JumpableGenerator;\n+import java.util.random.RandomGenerator.LeapableGenerator;\n+import java.util.random.RandomGenerator.SplittableGenerator;\n+import java.util.random.RandomGenerator.StreamableGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * @test\n+ * @summary Ensure that all implementations of RandomGenerator supply required methods.\n+ * @bug 8248862\n+ * @run main RandomTestCoverage\n+ * @key randomness\n+ *\/\n+\n+\n+public class RandomTestCoverage {\n+    static void coverRandomGenerator(RandomGenerator rng) {\n+        boolean bool = rng.nextBoolean();\n+        byte[] bytes = new byte[8];\n+        rng.nextBytes(bytes);\n+\n+        int i1 = rng.nextInt();\n+        int i2 = rng.nextInt(10);\n+        int i3 = rng.nextInt(5, 10);\n+\n+        long l1 = rng.nextLong();\n+        long l2 = rng.nextLong(10L);\n+        long l3 = rng.nextLong(5L, 10L);\n+\n+        float f1 = rng.nextFloat();\n+        float f2 = rng.nextFloat(1.0f);\n+        float f3 = rng.nextFloat(0.5f, 1.0f);\n+\n+        double d1 = rng.nextDouble();\n+        double d2 = rng.nextDouble(1.0);\n+        double d3 = rng.nextDouble(0.5, 1.0);\n+\n+        double exp = rng.nextExponential();\n+        double gauss1 = rng.nextGaussian();\n+        double gauss2 = rng.nextGaussian(0.5, 2.0);\n+\n+        IntStream intStream1 = rng.ints();\n+        IntStream intStream2 = rng.ints(5, 10);\n+        IntStream intStream3 = rng.ints(5L);\n+        IntStream intStream4 = rng.ints(5L, 5, 10);\n+\n+        LongStream longStream1 = rng.longs();\n+        LongStream longStream2 = rng.longs(5L, 10L);\n+        LongStream longStream3 = rng.longs(5L);\n+        LongStream longStream4 = rng.longs(5L, 5L, 10L);\n+\n+        DoubleStream doubleStream1 = rng.doubles();\n+        DoubleStream doubleStream2 = rng.doubles(0.5, 1.0);\n+        DoubleStream doubleStream3 = rng.doubles(5);\n+        DoubleStream doubleStream4 = rng.doubles(5, 0.5, 1.0);\n+    }\n+\n+    static void checkPredicates(RandomGeneratorFactory factory) {\n+        RandomGenerator rng = factory.create();\n+        if (rng instanceof ArbitrarilyJumpableGenerator != factory.isArbitrarilyJumpable()) {\n+            throw new RuntimeException(\"isArbitrarilyJumpable failing\");\n+        }\n+        if (rng instanceof JumpableGenerator != factory.isJumpable()) {\n+            throw new RuntimeException(\"isJumpable failing\");\n+        }\n+        if (rng instanceof LeapableGenerator != factory.isLeapable()) {\n+            throw new RuntimeException(\"isLeapable failing\");\n+        }\n+        if (rng instanceof SplittableGenerator != factory.isSplittable()) {\n+            throw new RuntimeException(\"isArbitrarilyJumpable failing\");\n+        }\n+        if (rng instanceof StreamableGenerator != factory.isStreamable()) {\n+            throw new RuntimeException(\"isArbitrarilyJumpable failing\");\n+        }\n+    }\n+\n+    static void coverStreamable(StreamableGenerator rng) {\n+        Stream<RandomGenerator> rngs1 = rng.rngs();\n+        Stream<RandomGenerator> rngs2 = rng.rngs(5L);\n+    }\n+\n+    static void coverSplittable(SplittableGenerator rng) {\n+        SplittableGenerator s1 = rng.split();\n+        SplittableGenerator s2 = rng.split(rng);\n+        Stream<SplittableGenerator> s3 = rng.splits();\n+        Stream<SplittableGenerator> s4 = rng.splits(5L);\n+        Stream<SplittableGenerator> s5 = rng.splits(rng);\n+        Stream<SplittableGenerator> s6 = rng.splits(5L, rng);\n+    }\n+\n+    static void coverJumpable(JumpableGenerator rng) {\n+        JumpableGenerator j1 = rng.copy();\n+        rng.jump();\n+        RandomGenerator j2 = rng.copyAndJump();\n+        double d = rng.jumpDistance();\n+        Stream<RandomGenerator> j3 = rng.jumps();\n+        Stream<RandomGenerator> j4 = rng.jumps(5L);\n+    }\n+\n+    static void coverLeapable(LeapableGenerator rng) {\n+        LeapableGenerator l1 = rng.copy();\n+        rng.leap();\n+        JumpableGenerator l2 = rng.copyAndLeap();\n+        double d = rng.leapDistance();\n+        Stream<JumpableGenerator> l3 = rng.leaps();\n+        Stream<JumpableGenerator> l4 = rng.leaps(5L);\n+    }\n+\n+    static void coverArbitrarilyJumpable(ArbitrarilyJumpableGenerator rng) {\n+        ArbitrarilyJumpableGenerator a1 = rng.copy();\n+        rng.jump();\n+        rng.leap();\n+        rng.jump(1.2345);\n+        rng.jumpPowerOfTwo(4);\n+        RandomGenerator a2 = rng.copyAndJump();\n+        RandomGenerator a3 = rng.copyAndJump(1.2345);\n+        Stream<ArbitrarilyJumpableGenerator> a4 = rng.jumps(1.2345);\n+        Stream<ArbitrarilyJumpableGenerator> a5 = rng.jumps(5L, 1.2345);\n+\n+    }\n+\n+    static void coverOf(String name) {\n+        coverRandomGenerator(RandomGenerator.of(name));\n+        coverFactory(RandomGeneratorFactory.of(name));\n+    }\n+\n+    static void coverFactory(RandomGeneratorFactory factory) {\n+        String name = factory.name();\n+        String group = factory.group();\n+        int stateBits = factory.stateBits();\n+        int equidistribution = factory.equidistribution();\n+        BigInteger period = factory.period();\n+        boolean isStatistical = factory.isStatistical();\n+        boolean isStochastic = factory.isStochastic();\n+        boolean isHardware = factory.isHardware();\n+        boolean isArbitrarilyJumpable = factory.isArbitrarilyJumpable();\n+        boolean isJumpable = factory.isJumpable();\n+        boolean isLeapable = factory.isLeapable();\n+        boolean isSplittable = factory.isSplittable();\n+\n+        coverRandomGenerator(factory.create());\n+        coverRandomGenerator(factory.create(12345L));\n+        coverRandomGenerator(factory.create(new byte[] {1, 2, 3, 4, 5, 6, 7, 8}));\n+    }\n+\n+    static void coverDefaults() {\n+        RandomGeneratorFactory<RandomGenerator> factory =\n+            RandomGeneratorFactory.getDefault();\n+        RandomGenerator rng = RandomGenerator.getDefault();\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        RandomGeneratorFactory.all()\n+                .forEach(factory -> {\n+                    coverFactory(factory);\n+                    coverOf(factory.name());\n+                 });\n+        RandomGeneratorFactory.all(StreamableGenerator.class)\n+                .forEach(factory -> {\n+                    coverStreamable(factory.create());\n+                });\n+        RandomGeneratorFactory.all(SplittableGenerator.class)\n+                .forEach(factory -> {\n+                    coverSplittable(factory.create());\n+                });\n+        RandomGeneratorFactory.all(JumpableGenerator.class)\n+                .forEach(factory -> {\n+                    coverJumpable(factory.create());\n+                });\n+        RandomGeneratorFactory.all(LeapableGenerator.class)\n+                .forEach(factory -> {\n+                    coverLeapable(factory.create());\n+                });\n+        RandomGeneratorFactory.all(ArbitrarilyJumpableGenerator.class)\n+                .forEach(factory -> {\n+                    coverArbitrarilyJumpable(factory.create());\n+                });\n+\n+        coverRandomGenerator(new SecureRandom());\n+        coverRandomGenerator(ThreadLocalRandom.current());\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Random\/RandomTestCoverage.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2012, 2013, 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import java.util.random.*;\n+\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.DoubleSupplier;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toSet;\n+\n+\/**\n+ * @test\n+ * @summary test bit sequences produced by clases that implement interface RandomGenerator\n+ * @bug 8248862\n+ * @run main RandomTestMoments\n+ * @author Guy Steele\n+ * @key randomness\n+ *\/\n+\n+public class RandomTestMoments {\n+\n+    static String currentRNG = \"\";\n+    static int failCount = 0;\n+\n+    static void exceptionOnFail() {\n+        if (failCount != 0) {\n+            throw new RuntimeException(failCount + \" fails detected\");\n+        }\n+    }\n+\n+    static void setRNG(String rng) {\n+        currentRNG = rng;\n+    }\n+\n+    static void fail(String format, Object... args) {\n+        if (currentRNG.length() != 0) {\n+            System.err.println(currentRNG);\n+            currentRNG = \"\";\n+        }\n+\n+        System.err.format(\"  \" + format, args);\n+        failCount++;\n+    }\n+\n+    static final int SEQUENCE_SIZE = 50000;\n+\n+    \/\/ Moment k of uniform distribution over [0.0,1.0) is 1.0\/(1+k).\n+\n+    static double[][] momentsUniform = {\n+       { 1.00000, 1.00000, 0.01000 },\n+       { 0.500000, 0.500000, 0.0266265 },\n+       { 0.333333, 0.333333, 0.0391128 },\n+       { 0.250000, 0.250000, 0.0477151 },\n+       { 0.200000, 0.200000, 0.0540496 },\n+       { 0.166667, 0.166667, 0.0589355 },\n+       { 0.142857, 0.142857, 0.0628462 },\n+       { 0.125000, 0.125000, 0.0660693 },\n+       { 0.111111, 0.111111, 0.0688036 },\n+       { 0.100000, 0.100000, 0.0712002 },\n+       { 0.0909091, 0.0909091, 0.0733755 },\n+       { 0.0833333, 0.0833333, 0.0754172 },\n+       { 0.0769231, 0.0769231, 0.0773868 },\n+       { 0.0714286, 0.0714286, 0.0793244 },\n+       { 0.0666667, 0.0666667, 0.0812526 },\n+       { 0.0625000, 0.0625000, 0.0831806 },\n+    };\n+\n+    \/\/ Moment k of exponential distribution with mean 1 is k!.\n+\n+    static double[][] momentsExponential = {\n+       { 1.00000, 1.00000, 0.01000 },\n+       { 1.00000, 1.00000, 0.0718997 },\n+       { 2.00000, 2.00000, 0.153241 },\n+       { 6.00000, 6.00000, 0.282813 },\n+       { 24.0000, 24.0000, 0.503707 },\n+    };\n+\n+\n+    \/\/ Absolute moment k of Gaussian distribution with mean 0 and stddev 1 is\n+    \/\/    pow(2.0,k\/2.0)*gamma((k+1)\/2.0)\/sqrt(PI)\n+    \/\/ https:\/\/arxiv.org\/pdf\/1209.4340.pdf, equation (18)\n+\n+    static double[][] absoluteMomentsGaussian = {\n+       { 1.00000, 1.00000, 0.01 },\n+       { 0.797885, 0.797885, 0.1 },\n+       { 1.00000, 1.00000, 0.1 },\n+       { 1.59577, 1.59577, 0.2 },\n+       { 3.00000, 3.00000, 0.2 },\n+       { 6.38308, 6.38308, 0.2 },\n+       { 15.0000, 15.0000, 0.2 },\n+       { 38.2985, 38.2985, 0.2 },\n+       { 105.000, 105.000, 0.4 },\n+    };\n+\n+    static void checkMoments(String test, double[] measurements, double[][] standard) {\n+       for (int j = 0; j < measurements.length; j++) {\n+           double actual = measurements[j];\n+           double expected = standard[j][0];\n+           double basis = standard[j][1];\n+           double tolerance = standard[j][2];\n+           if (!(Math.abs(actual - expected)\/basis < tolerance)) {\n+               fail(\"%s fail: actual=%f, expected=%f, basis=%f, tolerance=%f\\n\",\n+                     test, actual, expected, basis, tolerance);\n+           }\n+       }\n+    }\n+\n+    static void testMomentsGaussian(DoubleSupplier theSupplier) {\n+       int m = absoluteMomentsGaussian.length;\n+       double[] absoluteMoments = new double[m];\n+       for (int j = 0; j < SEQUENCE_SIZE; j++) {\n+           double v = theSupplier.getAsDouble();\n+           double z = 1.0;\n+           for (int k = 0; k < m; k++) {\n+               absoluteMoments[k] += Math.abs(z);\n+               z *= v;\n+           }\n+       }\n+       for (int k = 0; k < m; k++) {\n+           absoluteMoments[k] \/= SEQUENCE_SIZE;\n+       }\n+       checkMoments(\"Gaussian\", absoluteMoments, absoluteMomentsGaussian);\n+    }\n+\n+    static void testMomentsExponential(DoubleSupplier theSupplier) {\n+       int m = momentsExponential.length;\n+       double[] moments = new double[m];\n+       for (int j = 0; j < SEQUENCE_SIZE; j++) {\n+           double v = theSupplier.getAsDouble();\n+           double z = 1.0;\n+           for (int k = 0; k < m; k++) {\n+               moments[k] += z;\n+               z *= v;\n+           }\n+       }\n+       for (int k = 0; k < m; k++) {\n+           moments[k] \/= SEQUENCE_SIZE;\n+       }\n+       checkMoments(\"Exponential\", moments, momentsExponential);\n+    }\n+\n+    static void testMomentsUniform(DoubleSupplier theSupplier) {\n+       int m = momentsUniform.length;\n+       double[] moments = new double[m];\n+       for (int j = 0; j < SEQUENCE_SIZE; j++) {\n+           double v = theSupplier.getAsDouble();\n+           double z = 1.0;\n+           for (int k = 0; k < m; k++) {\n+               moments[k] += z;\n+               z *= v;\n+           }\n+       }\n+       for (int k = 0; k < m; k++) {\n+           moments[k] \/= SEQUENCE_SIZE;\n+       }\n+       checkMoments(\"Uniform\", moments, momentsUniform);\n+    }\n+\n+    static void testOneRng(RandomGenerator rng) {\n+        testMomentsGaussian(rng::nextGaussian);\n+        testMomentsExponential(rng::nextExponential);\n+        testMomentsUniform(rng::nextDouble);\n+        testMomentsUniform(rng.doubles().iterator()::next);\n+    }\n+\n+    public static void main(String[] args) {\n+        RandomGeneratorFactory.all()\n+             .forEach(factory -> {\n+                setRNG(factory.name());\n+                testOneRng(factory.create(325) );\n+            });\n+\n+        exceptionOnFail();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/Random\/RandomTestMoments.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"}]}