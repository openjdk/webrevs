{"files":[{"patch":"@@ -3285,0 +3285,1 @@\n+      register_new_survivor_region_with_region_attr(new_alloc_region);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -609,0 +609,1 @@\n+  inline void register_new_survivor_region_with_region_attr(HeapRegion* r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -186,0 +186,4 @@\n+void G1CollectedHeap::register_new_survivor_region_with_region_attr(HeapRegion* r) {\n+  _region_attr.set_new_survivor_region(r->hrm_index());\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1584,0 +1584,1 @@\n+    BarrierEnqueueDiscoveredFieldClosure enqueue;\n@@ -1585,1 +1586,1 @@\n-    _rp_task->rp_work(worker_id, &is_alive, &keep_alive, &complete_gc);\n+    _rp_task->rp_work(worker_id, &is_alive, &keep_alive, &enqueue, &complete_gc);\n@@ -1698,0 +1699,1 @@\n+  BarrierEnqueueDiscoveredFieldClosure enqueue;\n@@ -1709,0 +1711,1 @@\n+                                     &enqueue,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"gc\/g1\/g1RedirtyCardsQueue.hpp\"\n@@ -41,39 +40,0 @@\n-class UpdateLogBuffersDeferred : public BasicOopIterateClosure {\n-private:\n-  G1CollectedHeap* _g1h;\n-  G1RedirtyCardsLocalQueueSet* _rdc_local_qset;\n-  G1CardTable*    _ct;\n-\n-  \/\/ Remember the last enqueued card to avoid enqueuing the same card over and over;\n-  \/\/ since we only ever handle a card once, this is sufficient.\n-  size_t _last_enqueued_card;\n-\n-public:\n-  UpdateLogBuffersDeferred(G1RedirtyCardsLocalQueueSet* rdc_local_qset) :\n-    _g1h(G1CollectedHeap::heap()),\n-    _rdc_local_qset(rdc_local_qset),\n-    _ct(_g1h->card_table()),\n-    _last_enqueued_card(SIZE_MAX) {}\n-\n-  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n-  virtual void do_oop(      oop* p) { do_oop_work(p); }\n-  template <class T> void do_oop_work(T* p) {\n-    assert(_g1h->heap_region_containing(p)->is_in_reserved(p), \"paranoia\");\n-    assert(!_g1h->heap_region_containing(p)->is_survivor(), \"Unexpected evac failure in survivor region\");\n-\n-    T const o = RawAccess<>::oop_load(p);\n-    if (CompressedOops::is_null(o)) {\n-      return;\n-    }\n-\n-    if (HeapRegion::is_in_same_region(p, CompressedOops::decode(o))) {\n-      return;\n-    }\n-    size_t card_index = _ct->index_for(p);\n-    if (card_index != _last_enqueued_card) {\n-      _rdc_local_qset->enqueue(_ct->byte_for_index(card_index));\n-      _last_enqueued_card = card_index;\n-    }\n-  }\n-};\n-\n@@ -86,1 +46,0 @@\n-  UpdateLogBuffersDeferred* _log_buffer_cl;\n@@ -93,1 +52,0 @@\n-                                 UpdateLogBuffersDeferred* log_buffer_cl,\n@@ -101,1 +59,0 @@\n-    _log_buffer_cl(log_buffer_cl),\n@@ -146,9 +103,0 @@\n-      \/\/ During evacuation failure we do not record inter-region\n-      \/\/ references referencing regions that need a remembered set\n-      \/\/ update originating from young regions (including eden) that\n-      \/\/ failed evacuation. Make up for that omission now by rescanning\n-      \/\/ these failed objects.\n-      if (_is_young) {\n-        obj->oop_iterate(_log_buffer_cl);\n-      }\n-\n@@ -203,3 +151,0 @@\n-  G1RedirtyCardsLocalQueueSet _rdc_local_qset;\n-  UpdateLogBuffersDeferred _log_buffer_cl;\n-\n@@ -210,2 +155,1 @@\n-  RemoveSelfForwardPtrHRClosure(G1RedirtyCardsQueueSet* rdcqs,\n-                                uint worker_id,\n+  RemoveSelfForwardPtrHRClosure(uint worker_id,\n@@ -216,2 +160,0 @@\n-    _rdc_local_qset(rdcqs),\n-    _log_buffer_cl(&_rdc_local_qset),\n@@ -222,4 +164,0 @@\n-  ~RemoveSelfForwardPtrHRClosure() {\n-    _rdc_local_qset.flush();\n-  }\n-\n@@ -229,1 +167,0 @@\n-                                        &_log_buffer_cl,\n@@ -268,2 +205,1 @@\n-G1ParRemoveSelfForwardPtrsTask::G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs,\n-                                                               G1EvacFailureRegions* evac_failure_regions) :\n+G1ParRemoveSelfForwardPtrsTask::G1ParRemoveSelfForwardPtrsTask(G1EvacFailureRegions* evac_failure_regions) :\n@@ -272,1 +208,0 @@\n-  _rdcqs(rdcqs),\n@@ -278,1 +213,1 @@\n-  RemoveSelfForwardPtrHRClosure rsfp_cl(_rdcqs, worker_id, &_num_failed_regions, _evac_failure_regions);\n+  RemoveSelfForwardPtrHRClosure rsfp_cl(worker_id, &_num_failed_regions, _evac_failure_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":3,"deletions":68,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-class G1RedirtyCardsQueueSet;\n@@ -42,1 +41,0 @@\n-  G1RedirtyCardsQueueSet* _rdcqs;\n@@ -49,1 +47,1 @@\n-  G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs, G1EvacFailureRegions* evac_failure_regions);\n+  G1ParRemoveSelfForwardPtrsTask(G1EvacFailureRegions* evac_failure_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -251,0 +251,1 @@\n+    BarrierEnqueueDiscoveredFieldClosure enqueue;\n@@ -252,1 +253,1 @@\n-    _rp_task->rp_work(worker_id, &is_alive, &keep_alive, complete_gc);\n+    _rp_task->rp_work(worker_id, &is_alive, &keep_alive, &enqueue, complete_gc);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,2 +60,3 @@\n-  static const region_type_t Optional     =  -3;    \/\/ The region is optional not in the current collection set.\n-  static const region_type_t Humongous    =  -2;    \/\/ The region is a humongous candidate not in the current collection set.\n+  static const region_type_t Optional     =  -4;    \/\/ The region is optional not in the current collection set.\n+  static const region_type_t Humongous    =  -3;    \/\/ The region is a humongous candidate not in the current collection set.\n+  static const region_type_t NewSurvivor  =  -2;    \/\/ The region is a new (ly allocated) survivor region.\n@@ -79,0 +80,1 @@\n+      case NewSurvivor: return \"NewSurvivor\";\n@@ -88,0 +90,1 @@\n+  void set_new_survivor()              { _type = NewSurvivor; }\n@@ -99,0 +102,1 @@\n+  bool is_new_survivor() const         { return type() == NewSurvivor; }\n@@ -131,0 +135,6 @@\n+  void set_new_survivor_region(uintptr_t index) {\n+    assert(get_by_index(index).is_default(),\n+           \"Region attributes at index \" INTPTR_FORMAT \" should be default but is %s\", index, get_by_index(index).get_type_str());\n+    get_ref_by_index(index)->set_new_survivor();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionAttr.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  friend class G1ScanInYoungSetter;\n+  friend class G1SkipCardEnqueueSetter;\n@@ -90,1 +90,1 @@\n-  enum ScanningInYoungValues {\n+  enum SkipCardEnqueueTristate {\n@@ -96,1 +96,1 @@\n-  ScanningInYoungValues _scanning_in_young;\n+  SkipCardEnqueueTristate _skip_card_enqueue;\n@@ -100,1 +100,1 @@\n-    G1ScanClosureBase(g1h, par_scan_state), _scanning_in_young(Uninitialized) { }\n+    G1ScanClosureBase(g1h, par_scan_state), _skip_card_enqueue(Uninitialized) { }\n@@ -114,2 +114,1 @@\n-\/\/ RAII object to properly set the _scanning_in_young field in G1ScanEvacuatedObjClosure.\n-class G1ScanInYoungSetter : public StackObj {\n+class G1SkipCardEnqueueSetter : public StackObj {\n@@ -119,3 +118,3 @@\n-  G1ScanInYoungSetter(G1ScanEvacuatedObjClosure* closure, bool new_value) : _closure(closure) {\n-    assert(_closure->_scanning_in_young == G1ScanEvacuatedObjClosure::Uninitialized, \"Must not be set\");\n-    _closure->_scanning_in_young = new_value ? G1ScanEvacuatedObjClosure::True : G1ScanEvacuatedObjClosure::False;\n+  G1SkipCardEnqueueSetter(G1ScanEvacuatedObjClosure* closure, bool skip_card_enqueue) : _closure(closure) {\n+    assert(_closure->_skip_card_enqueue == G1ScanEvacuatedObjClosure::Uninitialized, \"Must not be set\");\n+    _closure->_skip_card_enqueue = skip_card_enqueue ? G1ScanEvacuatedObjClosure::True : G1ScanEvacuatedObjClosure::False;\n@@ -124,2 +123,2 @@\n-  ~G1ScanInYoungSetter() {\n-    DEBUG_ONLY(_closure->_scanning_in_young = G1ScanEvacuatedObjClosure::Uninitialized;)\n+  ~G1SkipCardEnqueueSetter() {\n+    DEBUG_ONLY(_closure->_skip_card_enqueue = G1ScanEvacuatedObjClosure::Uninitialized;)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.hpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-\n+  assert(!_g1h->heap_region_containing(obj)->is_humongous(), \"trying to push humongous object \" PTR_FORMAT, p2i(obj));\n@@ -91,2 +91,2 @@\n-    assert(_scanning_in_young != Uninitialized, \"Scan location has not been initialized.\");\n-    if (_scanning_in_young == True) {\n+    assert(_skip_card_enqueue != Uninitialized, \"Scan location has not been initialized.\");\n+    if (_skip_card_enqueue == True) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -213,8 +213,1 @@\n-  assert(obj != NULL, \"Must be\");\n-  if (HeapRegion::is_in_same_region(p, obj)) {\n-    return;\n-  }\n-  HeapRegion* from = _g1h->heap_region_containing(p);\n-  if (!from->is_young()) {\n-    enqueue_card_if_tracked(_g1h->region_attr(obj), p, obj);\n-  }\n+  enqueue_card_after_barrier_filters(p, obj);\n@@ -244,2 +237,2 @@\n-  HeapRegion* hr = _g1h->heap_region_containing(to_array);\n-  G1ScanInYoungSetter x(&_scanner, hr->is_young());\n+  G1HeapRegionAttr dest_attr = _g1h->region_attr(to_array);\n+  G1SkipCardEnqueueSetter x(&_scanner, dest_attr.is_new_survivor());\n@@ -277,1 +270,6 @@\n-  G1ScanInYoungSetter x(&_scanner, dest_attr.is_young());\n+  \/\/ Skip the card enqueue iff the objective (to_array) is in survivor region.\n+  \/\/ However, HeapRegion::is_survivor() is too expensive here.\n+  \/\/ Instead, we use dest_attr.is_young() because the two values are always\n+  \/\/ equal: successfully allocated young regions must be survivor regions.\n+  assert(dest_attr.is_young() == _g1h->heap_region_containing(to_array)->is_survivor(), \"must be\");\n+  G1SkipCardEnqueueSetter x(&_scanner, dest_attr.is_young());\n@@ -522,1 +520,6 @@\n-    G1ScanInYoungSetter x(&_scanner, dest_attr.is_young());\n+    \/\/ Skip the card enqueue iff the objective (obj) is in survivor region.\n+    \/\/ However, HeapRegion::is_survivor() is too expensive here.\n+    \/\/ Instead, we use dest_attr.is_young() because the two values are always\n+    \/\/ equal: successfully allocated young regions must be survivor regions.\n+    assert(dest_attr.is_young() == _g1h->heap_region_containing(obj)->is_survivor(), \"must be\");\n+    G1SkipCardEnqueueSetter x(&_scanner, dest_attr.is_young());\n@@ -609,1 +612,8 @@\n-    G1ScanInYoungSetter x(&_scanner, r->is_young());\n+    \/\/ For iterating objects that failed evacuation currently we can reuse the\n+    \/\/ existing closure to scan evacuated objects because:\n+    \/\/ - for objects into the collection set we do not need to gather cards at this\n+    \/\/ time. The regions they are in will be unconditionally turned to old regions\n+    \/\/ without remembered sets.\n+    \/\/ - since we are iterating from a collection set region (i.e. never a Survivor\n+    \/\/ region), we always need to gather cards for this case.\n+    G1SkipCardEnqueueSetter x(&_scanner, false \/* skip_enqueue_cards *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":23,"deletions":13,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -133,0 +133,8 @@\n+  \/\/ Enqueue card of p if the barrier or other reasons (same region, not from survivor,\n+  \/\/ not into evacuation failed region) do not find that it is not required.\n+  \/\/ To be called if nothing particular about p and obj are known.\n+  template <class T> void enqueue_card_after_barrier_filters(T* p, oop obj);\n+\n+  \/\/ Enqueue the card if the reference's target region's remembered set is tracked.\n+  \/\/ Assumes that a significant amount of pre-filtering (like done by\n+  \/\/ enqueue_card_after_barrier_filters()) has already been performed.\n@@ -135,1 +143,4 @@\n-    assert(!_g1h->heap_region_containing(p)->is_young(), \"Should have filtered out from-young references already.\");\n+    assert(!_g1h->heap_region_containing(p)->is_survivor(), \"Should have filtered out from-survivor references already.\");\n+    \/\/ We relabel all regions that failed evacuation as old gen without remembered,\n+    \/\/ and so pre-filter them out in the caller.\n+    assert(!_g1h->heap_region_containing(o)->in_collection_set(), \"Should not try to enqueue reference into collection set region\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -98,0 +98,21 @@\n+template <class T>\n+void G1ParScanThreadState::enqueue_card_after_barrier_filters(T* p, oop obj) {\n+  assert(obj != nullptr, \"Must be\");\n+  if (HeapRegion::is_in_same_region(p, obj)) {\n+    return;\n+  }\n+  G1HeapRegionAttr from_attr = _g1h->region_attr(p);\n+  \/\/ If this is a reference from (current) survivor regions, we do not need\n+  \/\/ to track references from it.\n+  if (from_attr.is_new_survivor()) {\n+    return;\n+  }\n+  G1HeapRegionAttr dest_attr = _g1h->region_attr(obj);\n+  \/\/ References to the current collection set are references to objects that failed\n+  \/\/ evacuation. Currently these regions are always relabelled as old without\n+  \/\/ remembered sets, so skip them.\n+  if (!dest_attr.is_in_cset()) {\n+    enqueue_card_if_tracked(dest_attr, p, obj);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.inline.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -898,0 +899,27 @@\n+  \/\/ Special closure for enqueuing discovered fields: during enqueue the card table\n+  \/\/ may not be in shape to properly handle normal barrier calls (e.g. card marks\n+  \/\/ in regions that failed evacuation, scribbling of various values by card table\n+  \/\/ scan code). Additionally the regular barrier enqueues into the \"global\"\n+  \/\/ DCQS, but during GC we need these to-be-refined entries in the GC local queue\n+  \/\/ so that after clearing the card table, the redirty cards phase will properly\n+  \/\/ mark all dirty cards to be picked up by refinement.\n+  class G1EnqueueDiscoveredFieldClosure : public EnqueueDiscoveredFieldClosure {\n+    G1CollectedHeap* _g1h;\n+    G1ParScanThreadState* _pss;\n+\n+  public:\n+    G1EnqueueDiscoveredFieldClosure(G1CollectedHeap* g1h, G1ParScanThreadState* pss) : _g1h(g1h), _pss(pss) { }\n+\n+    void enqueue(oop reference, oop value) override {\n+      HeapWord* discovered_addr = java_lang_ref_Reference::discovered_addr_raw(reference);\n+\n+      \/\/ Store the value first, whatever it is.\n+      RawAccess<>::oop_store(discovered_addr, value);\n+\n+      if (value == nullptr) {\n+        return;\n+      }\n+      _pss->enqueue_card_after_barrier_filters(discovered_addr, value);\n+    }\n+  };\n+\n@@ -915,0 +943,1 @@\n+    G1EnqueueDiscoveredFieldClosure enqueue(&_g1h, pss);\n@@ -916,1 +945,1 @@\n-    _rp_task->rp_work(worker_id, &is_alive, &keep_alive, &complete_gc);\n+    _rp_task->rp_work(worker_id, &is_alive, &keep_alive, &enqueue, &complete_gc);\n@@ -1033,2 +1062,2 @@\n-  _concurrent_operation_is_full_mark(false),\n-  _evac_failure_regions(evac_failure_regions)\n+  _evac_failure_regions(evac_failure_regions),\n+  _concurrent_operation_is_full_mark(false)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":32,"deletions":3,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+  G1EvacFailureRegions* _evac_failure_regions;\n@@ -127,2 +128,0 @@\n-  G1EvacFailureRegions* _evac_failure_regions;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    add_parallel_task(new RemoveSelfForwardPtrsTask(per_thread_states->rdcqs(), evac_failure_regions));\n+    add_parallel_task(new RemoveSelfForwardPtrsTask(evac_failure_regions));\n@@ -104,3 +104,1 @@\n-G1PostEvacuateCollectionSetCleanupTask1::\n-    RemoveSelfForwardPtrsTask::RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs,\n-                                                         G1EvacFailureRegions* evac_failure_regions) :\n+G1PostEvacuateCollectionSetCleanupTask1::RemoveSelfForwardPtrsTask::RemoveSelfForwardPtrsTask(G1EvacFailureRegions* evac_failure_regions) :\n@@ -108,1 +106,1 @@\n-  _task(rdcqs, evac_failure_regions),\n+  _task(evac_failure_regions),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-class G1RedirtyCardsQueueSet;\n@@ -89,1 +88,1 @@\n-  RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs, G1EvacFailureRegions* evac_failure_regions);\n+  RemoveSelfForwardPtrsTask(G1EvacFailureRegions* evac_failure_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2070,0 +2070,1 @@\n+    BarrierEnqueueDiscoveredFieldClosure enqueue;\n@@ -2071,1 +2072,1 @@\n-    _rp_task->rp_work(worker_id, PSParallelCompact::is_alive_closure(), &keep_alive, &complete_gc);\n+    _rp_task->rp_work(worker_id, PSParallelCompact::is_alive_closure(), &keep_alive, &enqueue, &complete_gc);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -212,1 +212,2 @@\n-    PSKeepAliveClosure keep_alive(promotion_manager);;\n+    PSKeepAliveClosure keep_alive(promotion_manager);\n+    BarrierEnqueueDiscoveredFieldClosure enqueue;\n@@ -214,1 +215,1 @@\n-    _rp_task->rp_work(worker_id, &is_alive, &keep_alive, &complete_gc);\n+    _rp_task->rp_work(worker_id, &is_alive, &keep_alive, &enqueue, &complete_gc);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,1 +44,2 @@\n-    _rp_task->rp_work(worker_id, &_is_alive, &_keep_alive, &_complete_gc);\n+    BarrierEnqueueDiscoveredFieldClosure enqueue;\n+    _rp_task->rp_work(worker_id, &_is_alive, &_keep_alive, &enqueue, &_complete_gc);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialGcRefProcProxyTask.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -221,0 +221,6 @@\n+void BarrierEnqueueDiscoveredFieldClosure::enqueue(oop reference, oop value) {\n+  HeapAccess<AS_NO_KEEPALIVE>::oop_store_at(reference,\n+                                            java_lang_ref_Reference::discovered_offset(),\n+                                            value);\n+}\n+\n@@ -274,3 +280,1 @@\n-  HeapAccess<AS_NO_KEEPALIVE>::oop_store_at(_current_discovered,\n-                                            java_lang_ref_Reference::discovered_offset(),\n-                                            _next_discovered);\n+  _enqueue->enqueue(_current_discovered, _next_discovered);\n@@ -280,1 +284,1 @@\n-  if (_prev_discovered != NULL) {\n+  if (_prev_discovered != nullptr) {\n@@ -285,1 +289,1 @@\n-    HeapAccess<AS_NO_KEEPALIVE>::oop_store_at(_prev_discovered, java_lang_ref_Reference::discovered_offset(), old);\n+    _enqueue->enqueue(_prev_discovered, old);\n@@ -310,0 +314,1 @@\n+                                                        EnqueueDiscoveredFieldClosure* enqueue,\n@@ -311,1 +316,1 @@\n-  DiscoveredListIterator iter(refs_list, keep_alive, is_alive);\n+  DiscoveredListIterator iter(refs_list, keep_alive, is_alive, enqueue);\n@@ -353,2 +358,3 @@\n-                                                         OopClosure*     keep_alive) {\n-  DiscoveredListIterator iter(refs_list, keep_alive, NULL);\n+                                                         OopClosure*     keep_alive,\n+                                                         EnqueueDiscoveredFieldClosure* enqueue) {\n+  DiscoveredListIterator iter(refs_list, keep_alive, NULL, enqueue);\n@@ -424,1 +430,2 @@\n-                                          OopClosure* keep_alive) {\n+                                          OopClosure* keep_alive,\n+                                          EnqueueDiscoveredFieldClosure* enqueue) {\n@@ -456,0 +463,1 @@\n+                                                                       enqueue,\n@@ -471,0 +479,1 @@\n+               EnqueueDiscoveredFieldClosure* enqueue,\n@@ -474,1 +483,1 @@\n-    process_discovered_list(worker_id, REF_SOFT, is_alive, keep_alive);\n+    process_discovered_list(worker_id, REF_SOFT, is_alive, keep_alive, enqueue);\n@@ -476,1 +485,1 @@\n-    process_discovered_list(worker_id, REF_WEAK, is_alive, keep_alive);\n+    process_discovered_list(worker_id, REF_WEAK, is_alive, keep_alive, enqueue);\n@@ -478,1 +487,1 @@\n-    process_discovered_list(worker_id, REF_FINAL, is_alive, keep_alive);\n+    process_discovered_list(worker_id, REF_FINAL, is_alive, keep_alive, enqueue);\n@@ -496,0 +505,1 @@\n+               EnqueueDiscoveredFieldClosure* enqueue,\n@@ -498,1 +508,1 @@\n-    _ref_processor.process_final_keep_alive_work(_ref_processor._discoveredFinalRefs[worker_id], keep_alive);\n+    _ref_processor.process_final_keep_alive_work(_ref_processor._discoveredFinalRefs[worker_id], keep_alive, enqueue);\n@@ -514,0 +524,1 @@\n+               EnqueueDiscoveredFieldClosure* enqueue,\n@@ -515,1 +526,1 @@\n-    process_discovered_list(worker_id, REF_PHANTOM, is_alive, keep_alive);\n+    process_discovered_list(worker_id, REF_PHANTOM, is_alive, keep_alive, enqueue);\n@@ -1042,0 +1053,1 @@\n+                                                        EnqueueDiscoveredFieldClosure* enqueue,\n@@ -1056,1 +1068,1 @@\n-                                      keep_alive, complete_gc, yield)) {\n+                                      keep_alive, enqueue, complete_gc, yield)) {\n@@ -1073,1 +1085,1 @@\n-                                      keep_alive, complete_gc, yield)) {\n+                                      keep_alive, enqueue, complete_gc, yield)) {\n@@ -1090,1 +1102,1 @@\n-                                      keep_alive, complete_gc, yield)) {\n+                                      keep_alive, enqueue, complete_gc, yield)) {\n@@ -1107,1 +1119,1 @@\n-                                      keep_alive, complete_gc, yield)) {\n+                                      keep_alive, enqueue, complete_gc, yield)) {\n@@ -1127,0 +1139,1 @@\n+                                                     EnqueueDiscoveredFieldClosure* enqueue,\n@@ -1129,1 +1142,1 @@\n-  DiscoveredListIterator iter(refs_list, keep_alive, is_alive);\n+  DiscoveredListIterator iter(refs_list, keep_alive, is_alive, enqueue);\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":32,"deletions":19,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -41,0 +41,20 @@\n+\/\/ Provides a callback to the garbage collector to set the given value to the\n+\/\/ discovered field of the j.l.ref.Reference instance. This is called during STW\n+\/\/ reference processing when iterating over the discovered lists for all\n+\/\/ discovered references.\n+\/\/ Typically garbage collectors may just call the barrier, but for some garbage\n+\/\/ collectors the barrier environment (e.g. card table) may not be set up correctly\n+\/\/ at the point of invocation.\n+class EnqueueDiscoveredFieldClosure {\n+public:\n+  \/\/ For the given j.l.ref.Reference reference, set the discovered field to value.\n+  virtual void enqueue(oop reference, oop value) = 0;\n+};\n+\n+\/\/ EnqueueDiscoveredFieldClosure that executes the default barrier on the discovered\n+\/\/ field of the j.l.ref.Reference reference with the given value.\n+class BarrierEnqueueDiscoveredFieldClosure : public EnqueueDiscoveredFieldClosure {\n+public:\n+  void enqueue(oop reference, oop value) override;\n+};\n+\n@@ -69,1 +89,0 @@\n-private:\n@@ -81,0 +100,1 @@\n+  EnqueueDiscoveredFieldClosure* _enqueue;\n@@ -92,1 +112,2 @@\n-                                BoolObjectClosure* is_alive);\n+                                BoolObjectClosure* is_alive,\n+                                EnqueueDiscoveredFieldClosure* enqueue);\n@@ -258,0 +279,1 @@\n+                                      EnqueueDiscoveredFieldClosure* enqueue,\n@@ -263,1 +285,2 @@\n-                                       OopClosure* keep_alive);\n+                                       OopClosure* keep_alive,\n+                                       EnqueueDiscoveredFieldClosure* enqueue);\n@@ -294,0 +317,1 @@\n+                                      EnqueueDiscoveredFieldClosure* enqueue,\n@@ -310,0 +334,1 @@\n+                                   EnqueueDiscoveredFieldClosure* enqueue,\n@@ -545,1 +570,2 @@\n-                               OopClosure* keep_alive);\n+                               OopClosure* keep_alive,\n+                               EnqueueDiscoveredFieldClosure* enqueue);\n@@ -555,0 +581,1 @@\n+                       EnqueueDiscoveredFieldClosure* enqueue,\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -63,1 +63,2 @@\n-                                               BoolObjectClosure* is_alive):\n+                                               BoolObjectClosure* is_alive,\n+                                               EnqueueDiscoveredFieldClosure* enqueue):\n@@ -73,0 +74,1 @@\n+  _enqueue(enqueue),\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.inline.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}