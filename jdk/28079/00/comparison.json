{"files":[{"patch":"@@ -46,0 +46,1 @@\n+import java.lang.reflect.GenericSignatureFormatError;\n@@ -1448,1 +1449,0 @@\n-            \/\/ Descriptor already validated by VM\n@@ -1536,2 +1536,9 @@\n-        String getDescriptor() { return descriptor; }\n-\n+        String getDescriptor() {\n+            \/\/ hotspot validates this descriptor to be either a field or method\n+            \/\/ descriptor as the \"type\" in a NameAndType in verification.\n+            \/\/ So this can still be a field descriptor\n+            if (descriptor.isEmpty() || descriptor.charAt(0) != '(') {\n+                throw new GenericSignatureFormatError(\"Bad method signature: \" + descriptor);\n+            }\n+            return descriptor;\n+        }\n@@ -1570,1 +1577,0 @@\n-            \/\/ Descriptor already validated by VM\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1197,4 +1197,0 @@\n-        if (!descriptor.startsWith(\"(\") ||  \/\/ also generates NPE if needed\n-            descriptor.indexOf(')') < 0 ||\n-            descriptor.indexOf('.') >= 0)\n-            throw newIllegalArgumentException(\"not a method descriptor: \"+descriptor);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,11 +66,2 @@\n-        return parseMethod(descriptor, 0, descriptor.length(), loader);\n-    }\n-\n-    \/**\n-     * @param loader the class loader in which to look up the types (null means\n-     *               bootstrap class loader)\n-     *\/\n-    static List<Class<?>> parseMethod(String bytecodeSignature,\n-            int start, int end, ClassLoader loader) {\n-        String str = bytecodeSignature;\n-        int[] i = {start};\n+        int end = descriptor.length(); \/\/ implicit null check\n+        int[] i = {0};\n@@ -78,1 +69,1 @@\n-        if (i[0] < end && str.charAt(i[0]) == '(') {\n+        if (i[0] < end && descriptor.charAt(i[0]) == '(') {\n@@ -80,2 +71,2 @@\n-            while (i[0] < end && str.charAt(i[0]) != ')') {\n-                Class<?> pt = parseSig(str, i, end, loader);\n+            while (i[0] < end && descriptor.charAt(i[0]) != ')') {\n+                Class<?> pt = parseSig(descriptor, i, end, loader);\n@@ -83,1 +74,1 @@\n-                    parseError(str, \"bad argument type\");\n+                    parseError(descriptor, \"bad argument type\");\n@@ -88,1 +79,1 @@\n-            parseError(str, \"not a method type\");\n+            parseError(descriptor, \"not a method type\");\n@@ -90,1 +81,1 @@\n-        Class<?> rtype = parseSig(str, i, end, loader);\n+        Class<?> rtype = parseSig(descriptor, i, end, loader);\n@@ -92,1 +83,1 @@\n-            parseError(str, \"bad return type\");\n+            parseError(descriptor, \"bad return type\");\n@@ -118,2 +109,16 @@\n-            int begc = i[0], endc = str.indexOf(';', begc);\n-            if (endc < 0)  return null;\n+            int begc = i[0];\n+            int identifierStart = begc;\n+            int endc;\n+            while (true) {\n+                int next = nextNonIdentifier(str, identifierStart, end);\n+                if (identifierStart == next || next >= end) return null;  \/\/ Empty name segment, or the end\n+                char ch = str.charAt(next);\n+                if (ch == ';') {\n+                    endc = next;\n+                    break;\n+                } else if (ch == '\/') {\n+                    identifierStart = next + 1;  \/\/ Next name segment\n+                } else {\n+                    return null;  \/\/ Bad char [ or .\n+                }\n+            }\n@@ -151,0 +156,17 @@\n+    private static final int CHECK_OFFSET = 32;\n+    private static final long NON_IDENTIFIER_MASK = (1L << ('.' - CHECK_OFFSET))\n+            | (1L << ('\/' - CHECK_OFFSET))\n+            | (1L << (';' - CHECK_OFFSET))\n+            | (1L << ('[' - CHECK_OFFSET));\n+\n+    private static int nextNonIdentifier(String str, int index, int end) {\n+        while (index < end) {\n+            int check = str.charAt(index) - CHECK_OFFSET;\n+            if ((check & -Long.SIZE) == 0 && (NON_IDENTIFIER_MASK & (1L << check)) != 0) {\n+                break;\n+            }\n+            index++;\n+        }\n+        return index;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":42,"deletions":20,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.reflect.GenericSignatureFormatError;\n@@ -96,2 +97,10 @@\n-        assertThrows(ClassFormatError.class, () -> loadTestClass(\"methodName\", \"(L[;)V\"));\n-        assertThrows(ClassFormatError.class, () -> loadTestClass(INIT_NAME, \"(L[;)V\"));\n+        assertThrowsExactly(ClassFormatError.class, () -> loadTestClass(\"methodName\", \"(L[;)V\"));\n+        assertThrowsExactly(ClassFormatError.class, () -> loadTestClass(INIT_NAME, \"(L[;)V\"));\n+        assertThrowsExactly(ClassFormatError.class, () -> loadTestClass(INIT_NAME, \"(Lmissing\/;)V\"));\n+        assertThrowsExactly(ClassFormatError.class, () -> loadTestClass(INIT_NAME, \"()L\/Missing;\"));\n+        \/\/ only throw if the query type match the method\/constructor type\n+        assertDoesNotThrow(() -> loadTestClass(INIT_NAME, \"Ljava\/lang\/Object;\").getEnclosingMethod());\n+        assertDoesNotThrow(() -> loadTestClass(\"method\", \"[I\").getEnclosingConstructor());\n+        \/\/ We have to manually intercept field-typed \"methods\"\n+        assertThrows(GenericSignatureFormatError.class, () -> loadTestClass(INIT_NAME, \"Ljava\/lang\/Object;\").getEnclosingConstructor());\n+        assertThrows(GenericSignatureFormatError.class, () -> loadTestClass(\"method\", \"[I\").getEnclosingMethod());\n","filename":"test\/jdk\/java\/lang\/Class\/getEnclosingMethod\/BadEnclosingMethodTest.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -44,0 +47,2 @@\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n@@ -59,0 +64,16 @@\n+    static Stream<String> badFieldDescriptors() {\n+        return Arrays.stream(new String[] {\n+                \"Not a_descriptor\",\n+                \"()V\",\n+                \"Ljava\/lang\/Object\",\n+                \"Ljava\/\",\n+                \"Ljava\/util\/Map.Entry;\",\n+                \"[\".repeat(256) + \"I\",\n+                \"Lbad.Name;\",\n+                \"Lbad[Name;\",\n+                \"L;\",\n+                \"L\/Missing;\",\n+                \"Lmissing\/;\",\n+        });\n+    }\n+\n@@ -64,3 +85,9 @@\n-    @Test\n-    void testMalformedClassValue() throws Exception {\n-        var badDescString = \"Not a_descriptor\";\n+    @ParameterizedTest\n+    @MethodSource(\"badFieldDescriptors\")\n+    void testMalformedClassValue(String badDescString) throws Exception {\n+        var cl = spinClass(badDescString);\n+        var ex = assertThrows(GenericSignatureFormatError.class, () -> cl.getDeclaredAnnotation(ClassCarrier.class));\n+        assertTrue(ex.getMessage().contains(badDescString), () -> \"Uninformative error: \" + ex);\n+    }\n+\n+    private static Class<?> spinClass(String desc) throws Exception {\n@@ -71,1 +98,1 @@\n-                                        .constantPool().utf8Entry(badDescString))))\n+                                        .constantPool().utf8Entry(desc))))\n@@ -73,3 +100,17 @@\n-        var cl = new ByteCodeLoader(\"Test\", bytes, MalformedAnnotationTest.class.getClassLoader()).loadClass(\"Test\");\n-        var ex = assertThrows(GenericSignatureFormatError.class, () -> cl.getDeclaredAnnotation(ClassCarrier.class));\n-        assertTrue(ex.getMessage().contains(badDescString), () -> \"Uninformative error: \" + ex);\n+        return new ByteCodeLoader(\"Test\", bytes, ClassCarrier.class.getClassLoader()).loadClass(\"Test\");\n+    }\n+\n+    static Stream<String> goodFieldDescriptors() {\n+        return Arrays.stream(new String[] {\n+                \"Ljava\/lang\/Object<*>;\", \/\/ previously MalformedParameterizedTypeException\n+                \"[Ljava\/util\/Optional<*>;\", \/\/ previously ClassCastException\n+                \"Ljava\/util\/Map$Entry<**>;\", \/\/ previously ClassCastException\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"goodFieldDescriptors\")\n+    void testLegalClassValue(String goodDescString) throws Exception {\n+        var cl = spinClass(goodDescString);\n+        var anno = cl.getDeclaredAnnotation(ClassCarrier.class);\n+        assertThrows(TypeNotPresentException.class, anno::value);\n","filename":"test\/jdk\/java\/lang\/annotation\/MalformedAnnotationTest.java","additions":48,"deletions":7,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -233,0 +233,5 @@\n+                \"()Lbad.Name;\",\n+                \"()Lbad[Name;\",\n+                \"(L;)V\",\n+                \"(L\/Missing;)I\",\n+                \"(Lmissing\/;)Z\",\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodTypeTest.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -82,0 +82,3 @@\n+        assertThrows(IllegalArgumentException.class, () -> BytecodeDescriptor.parseClass(\"java.lang.Object\", null),    \"binary name\");\n+        assertThrows(IllegalArgumentException.class, () -> BytecodeDescriptor.parseClass(\"L[a;\", null),                \"bad class or interface\");\n+        assertThrows(IllegalArgumentException.class, () -> BytecodeDescriptor.parseClass(\"Ljava.lang.Object;\", null),  \"bad class or interface\");\n@@ -83,0 +86,3 @@\n+        assertThrows(IllegalArgumentException.class, () -> BytecodeDescriptor.parseClass(\"L;\", null),                  \"empty name\");\n+        assertThrows(IllegalArgumentException.class, () -> BytecodeDescriptor.parseClass(\"Lmissing\/;\", null),          \"empty name part\");\n+        assertThrows(IllegalArgumentException.class, () -> BytecodeDescriptor.parseClass(\"L\/Missing;\", null),          \"empty name part\");\n@@ -113,0 +119,15 @@\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"(Ljava.lang.Object;)V\", null),\n+                     \"bad arg\");\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"(Ljava\/lang[Object;)V\", null),\n+                     \"bad arg\");\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"(L;)V\", null),\n+                     \"bad arg\");\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"(Ljava\/lang\/;)V\", null),\n+                     \"bad arg\");\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"(L\/Object;)V\", null),\n+                     \"bad arg\");\n","filename":"test\/jdk\/sun\/invoke\/util\/BytecodeDescriptorTest.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}