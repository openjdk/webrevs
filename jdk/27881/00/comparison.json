{"files":[{"patch":"@@ -0,0 +1,672 @@\n+\/*\n+ * Copyright (c) 2025 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+public class StrictMathExtraBench {\n+\n+    public static final int SIZE = 1022;\n+\n+    private static final Random rnd = new Random(42);\n+\n+    @State(Scope.Thread)\n+    public static class RangeState {\n+        final double[] values = new double[SIZE];\n+        final double min, max;\n+        final boolean signed;\n+\n+        public RangeState(boolean signed, double min, double max) {\n+            this.min = min;\n+            this.max = max;\n+            this.signed = signed;\n+        }\n+\n+        public RangeState(double min, double max) {\n+            this(true, min, max);\n+        }\n+\n+        @Setup\n+        public void setup() {\n+            for (int i = 0; i < values.length; i++) {\n+                values[i] = rnd.nextDouble(min, max);\n+                if (rnd.nextBoolean()) {\n+                    values[i] = -values[i];\n+                }\n+            }\n+        }\n+    }\n+\n+    public static class RangeSubnormal extends RangeState {\n+        public RangeSubnormal() {\n+            super(0, Double.MIN_NORMAL);\n+        }\n+    }\n+\n+    public static class RangeNormal extends RangeState {\n+        public RangeNormal() {\n+            super(Double.MIN_NORMAL, Double.MAX_VALUE);\n+        }\n+    }\n+\n+    public static class RangePositiveSubnormal extends RangeState {\n+        public RangePositiveSubnormal() {\n+            super(false, 0, Double.MIN_NORMAL);\n+        }\n+    }\n+\n+    public static class RangePositiveNormal extends RangeState {\n+        public RangePositiveNormal() {\n+            super(false, Double.MIN_NORMAL, Double.MAX_VALUE);\n+        }\n+    }\n+\n+    public static class RangePiQuarter extends RangeState {\n+        public RangePiQuarter() {\n+            super(Double.MIN_NORMAL, Math.PI \/ 4);\n+        }\n+    }\n+\n+    public static class RangePiQuarterTo3PiQuarter extends RangeState {\n+        public RangePiQuarterTo3PiQuarter() {\n+            super(Math.PI \/ 4, 3 * Math.PI \/ 4);\n+        }\n+    }\n+\n+    public static class Range3PiQuarterToPiHalfTwo19 extends RangeState {\n+        public Range3PiQuarterToPiHalfTwo19() {\n+            super(3 * Math.PI \/ 4, 0x1.0p19 * Math.PI \/ 2);\n+        }\n+    }\n+\n+    public static class RangeBeyondPiHalfTwo19 extends RangeState {\n+        public RangeBeyondPiHalfTwo19() {\n+            super(0x1.0p19 * Math.PI \/ 2, Double.MAX_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void sin_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.sin(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void sin_pi_quarter(Blackhole bh, RangePiQuarter r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.sin(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void sin_3pi_quarter(Blackhole bh, RangePiQuarterTo3PiQuarter r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.sin(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void sin_pi_half_two19(Blackhole bh, Range3PiQuarterToPiHalfTwo19 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.sin(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void sin_beyond_pi_half_two19(Blackhole bh, RangeBeyondPiHalfTwo19 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.sin(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cos_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cos(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cos_pi_quarter(Blackhole bh, RangePiQuarter r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cos(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cos_3pi_quarter(Blackhole bh, RangePiQuarterTo3PiQuarter r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cos(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cos_pi_half_two19(Blackhole bh, Range3PiQuarterToPiHalfTwo19 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cos(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cos_beyond_pi_half_two19(Blackhole bh, RangeBeyondPiHalfTwo19 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cos(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void tan_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.tan(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void tan_pi_quarter(Blackhole bh, RangePiQuarter r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.tan(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void tan_3pi_quarter(Blackhole bh, RangePiQuarterTo3PiQuarter r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.tan(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void tan_pi_half_two19(Blackhole bh, Range3PiQuarterToPiHalfTwo19 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.tan(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void tan_beyond_pi_half_two19(Blackhole bh, RangeBeyondPiHalfTwo19 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.tan(v));\n+        }\n+    }\n+\n+    public static class RangeHalf extends RangeState {\n+        public RangeHalf() {\n+            super(Double.MIN_NORMAL, 0.5);\n+        }\n+    }\n+\n+    public static class RangeHalfToOne extends RangeState {\n+        public RangeHalfToOne() {\n+            super(0.5, 1.0);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void asin_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.asin(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void asin_half(Blackhole bh, RangeHalf r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.asin(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void asin_one(Blackhole bh, RangeHalfToOne r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.asin(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void acos_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.acos(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void acos_half(Blackhole bh, RangeHalf r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.acos(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void acos_one(Blackhole bh, RangeHalfToOne r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.acos(v));\n+        }\n+    }\n+\n+    public static class RangeTwo66 extends RangeState {\n+        public RangeTwo66() {\n+            super(Double.MIN_NORMAL, 0x1.0p66);\n+        }\n+    }\n+\n+    public static class RangeBeyondTwo66 extends RangeState {\n+        public RangeBeyondTwo66() {\n+            super(0x1.0p66, Double.MAX_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void atan_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.atan(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void atan_two66(Blackhole bh, RangeTwo66 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.atan(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void atan_beyond_two66(Blackhole bh, RangeBeyondTwo66 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.atan(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void atan2_subnormal(Blackhole bh, RangeSubnormal r0, RangeSubnormal r1) {\n+        double[] values0 = r0.values;\n+        double[] values1 = r1.values;\n+        for (int i = 0; i < values0.length; i++) {\n+            bh.consume(StrictMath.atan2(values0[i], values1[i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void atan2_normal(Blackhole bh, RangeNormal r0, RangeNormal r1) {\n+        double[] values0 = r0.values;\n+        double[] values1 = r1.values;\n+        for (int i = 0; i < values0.length; i++) {\n+            bh.consume(StrictMath.atan2(values0[i], values1[i]));\n+        }\n+    }\n+\n+    public static class RangeHalfLn2 extends RangeState {\n+        public RangeHalfLn2() {\n+            super(Double.MIN_NORMAL, 0.34657359);\n+        }\n+    }\n+\n+    public static class RangeBeyondHalfLn2 extends RangeState {\n+        public RangeBeyondHalfLn2() {\n+            super(0.34657359, Double.MAX_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void exp_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.exp(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void exp_half_ln2(Blackhole bh, RangeHalfLn2 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.exp(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void exp_beyond_half_ln2(Blackhole bh, RangeBeyondHalfLn2 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.exp(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void log_subnormal(Blackhole bh, RangePositiveSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.log(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void log_normal(Blackhole bh, RangePositiveNormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.log(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void log10_subnormal(Blackhole bh, RangePositiveSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.log10(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void log10_normal(Blackhole bh, RangePositiveNormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.log10(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void log1p_subnormal(Blackhole bh, RangePositiveSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.log1p(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void log1p_normal(Blackhole bh, RangePositiveNormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.log1p(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cbrt_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cbrt(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cbrt_normal(Blackhole bh, RangeNormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cbrt(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void pow_subnormal(Blackhole bh, RangeSubnormal r0, RangeSubnormal r1) {\n+        double[] values0 = r0.values;\n+        double[] values1 = r1.values;\n+        for (int i = 0; i < values0.length; i++) {\n+            bh.consume(StrictMath.pow(values0[i], values1[i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void pow_normal(Blackhole bh, RangeNormal r0, RangeNormal r1) {\n+        double[] values0 = r0.values;\n+        double[] values1 = r1.values;\n+        for (int i = 0; i < values0.length; i++) {\n+            bh.consume(StrictMath.pow(values0[i], values1[i]));\n+        }\n+    }\n+\n+    public static class Range22 extends RangeState {\n+        public Range22() {\n+            super(Double.MIN_NORMAL, 22);\n+        }\n+    }\n+\n+    public static class RangeBeyond22 extends RangeState {\n+        public RangeBeyond22() {\n+            super(22, Double.MAX_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void sinh_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.sinh(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void sinh_22(Blackhole bh, RangeTwoNeg54 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.sinh(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void sinh_beyond_22(Blackhole bh, RangeBeyond22 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.sinh(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cosh_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cosh(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cosh_22(Blackhole bh, RangeTwoNeg54 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cosh(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cosh_beyond_22(Blackhole bh, RangeBeyond22 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cosh(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void tanh_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.tanh(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void tanh_22(Blackhole bh, RangeTwoNeg54 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.tanh(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void hypot_subnormal(Blackhole bh, RangeSubnormal r0, RangeSubnormal r1) {\n+        double[] values0 = r0.values;\n+        double[] values1 = r1.values;\n+        for (int i = 0; i < values0.length; i++) {\n+            bh.consume(StrictMath.hypot(values0[i], values1[i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void hypot_normal(Blackhole bh, RangeNormal r0, RangeNormal r1) {\n+        double[] values0 = r0.values;\n+        double[] values1 = r1.values;\n+        for (int i = 0; i < values0.length; i++) {\n+            bh.consume(StrictMath.hypot(values0[i], values1[i]));\n+        }\n+    }\n+\n+    public static class RangeTwoNeg54 extends RangeState {\n+        public RangeTwoNeg54() {\n+            super(Double.MIN_NORMAL, 0x1.0p-54);\n+        }\n+    }\n+\n+    public static class RangeTwoNeg54ToHalfLn2 extends RangeState {\n+        public RangeTwoNeg54ToHalfLn2() {\n+            super(0x1.0p-54, 0.34657359);\n+        }\n+    }\n+\n+    public static class RangeHalfLn2To56Ln2 extends RangeState {\n+        public RangeHalfLn2To56Ln2() {\n+            super(0.34657359, 38.8162421);\n+        }\n+    }\n+\n+    public static class RangeBeyond56Ln2 extends RangeState {\n+        public RangeBeyond56Ln2() {\n+            super(38.8162421, Double.MAX_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void expm1_two_neg_54(Blackhole bh, RangeTwoNeg54 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.expm1(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void expm1_half_ln2(Blackhole bh, RangeTwoNeg54ToHalfLn2 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.expm1(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void expm1_56ln2(Blackhole bh, RangeHalfLn2To56Ln2 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.expm1(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void expm1_beyond_56ln2(Blackhole bh, RangeBeyond56Ln2 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.expm1(v));\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StrictMathExtraBench.java","additions":672,"deletions":0,"binary":false,"changes":672,"status":"added"}]}