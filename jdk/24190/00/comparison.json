{"files":[{"patch":"@@ -44,0 +44,1 @@\n+import java.util.HashSet;\n@@ -48,0 +49,1 @@\n+import java.util.Set;\n@@ -77,0 +79,1 @@\n+    private final Map<String, Set<String>> altHashSums;\n@@ -89,0 +92,3 @@\n+     * @param altHashSums A map of alternative hash sums for files in\n+     *                    a module, possibly empty.\n+     * @param taskHelper The task helper reference.\n@@ -94,0 +100,1 @@\n+               Map<String, Set<String>> altHashSums,\n@@ -108,0 +115,1 @@\n+        this.altHashSums = altHashSums;\n@@ -220,1 +228,15 @@\n-                        if (shaSumMismatch(path, m.hashOrTarget, m.symlink)) {\n+                        \/\/ Allow for additional hash sums so as to support\n+                        \/\/ file modifications done after jlink has run at build\n+                        \/\/ time. For example for Windows builds done with\n+                        \/\/ --with-external-symbols-in-bundles=public or\n+                        \/\/ distribution builds, where some post-processing happens\n+                        \/\/ on produced binaries and libraries invalidating the\n+                        \/\/ hash sum included in the jdk.jlink module for those\n+                        \/\/ files at jlink-time\n+                        Set<String> shaSums = new HashSet<>();\n+                        shaSums.add(m.hashOrTarget);\n+                        Set<String> extra = altHashSums.get(m.resPath);\n+                        if (extra != null) {\n+                            shaSums.addAll(extra);\n+                        }\n+                        if (shaSumMismatch(path, shaSums, m.symlink)) {\n@@ -242,1 +264,1 @@\n-    static boolean shaSumMismatch(Path res, String expectedSha, boolean isSymlink) {\n+    static boolean shaSumMismatch(Path res, Set<String> expectedShas, boolean isSymlink) {\n@@ -248,2 +270,0 @@\n-            HexFormat format = HexFormat.of();\n-            byte[] expected = format.parseHex(expectedSha);\n@@ -259,1 +279,3 @@\n-            return !MessageDigest.isEqual(expected, actual);\n+            \/\/ Convert actual to string\n+            String strActual = HexFormat.of().formatHex(actual);\n+            return !expectedShas.contains(strActual);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JRTArchive.java","additions":27,"deletions":5,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-        private final boolean ignoreModifiedRuntime;\n+        private final LinkableRuntimeImage.Config runtimeImageConfig;\n@@ -165,1 +165,1 @@\n-                                  boolean ignoreModifiedRuntime,\n+                                  LinkableRuntimeImage.Config runtimeImageConfig,\n@@ -171,1 +171,1 @@\n-            this.ignoreModifiedRuntime = ignoreModifiedRuntime;\n+            this.runtimeImageConfig = runtimeImageConfig;\n@@ -201,2 +201,2 @@\n-        public boolean ignoreModifiedRuntime() {\n-            return ignoreModifiedRuntime;\n+        public LinkableRuntimeImage.Config runtimeImageConfig() {\n+            return runtimeImageConfig;\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Jlink.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -194,1 +194,29 @@\n-        }, true, \"--generate-linkable-runtime\")\n+        }, true, \"--generate-linkable-runtime\"),\n+        new Option<JlinkTask>(true, (task, opt, arg) -> {\n+            if (arg.startsWith(\"@\")) {\n+                \/\/ Read overrides from file\n+                if (!task.options.shaOverrides.isEmpty()) {\n+                    \/\/ Only allow a single @file value\n+                    throw taskHelper.newBadArgs(\"err.sha.overrides.multiple\");\n+                }\n+                Path file = Paths.get(arg.substring(1));\n+                \/\/ Ignore non-existing sha overrides file.\n+                \/\/\n+                \/\/ This is to allow for custom builds needing to optionally\n+                \/\/ support run-time image links on (possibly) modified\n+                \/\/ binaries\/debuginfo files done after the JDK build\n+                if (Files.exists(file)) {\n+                    try {\n+                        Files.readAllLines(file).stream()\n+                            .forEach(task.options.shaOverrides::add);\n+                    } catch (IOException e) {\n+                        throw taskHelper.newBadArgs(\"err.sha.overrides.freaderr\", file.toString());\n+                    }\n+                }\n+            } else {\n+                \/\/ Allow multiple values, separated by comma in addition to\n+                \/\/ multiple times the same option.\n+                Arrays.asList(arg.split(\",\")).stream()\n+                    .forEach(task.options.shaOverrides::add);\n+            }\n+        }, true, \"--sha-overrides\"),\n@@ -238,0 +266,1 @@\n+        final Set<String> shaOverrides = new HashSet<>();\n@@ -462,0 +491,3 @@\n+        LinkableRuntimeImage.Config linkableRuntimeConfig = new LinkableRuntimeImage.Config(\n+                options.ignoreModifiedRuntime,\n+                isLinkFromRuntime ? buildShaSumMap(taskHelper, options.shaOverrides) : null);\n@@ -466,1 +498,1 @@\n-                                      options.ignoreModifiedRuntime,\n+                                      linkableRuntimeConfig,\n@@ -470,0 +502,24 @@\n+    private Map<String, Map<String, Set<String>>> buildShaSumMap(TaskHelper taskHelper,\n+                                                                 Set<String> shaOverrides) throws BadArgs {\n+        Map<String, Map<String, Set<String>>> moduleToFiles = new HashMap<>();\n+        for (String t: shaOverrides) {\n+            String trimmed = t.trim();\n+            if (trimmed.startsWith(\"#\")) {\n+                \/\/ skip comment lines\n+                continue;\n+            }\n+            String[] tokens = trimmed.split(\"\\\\|\");\n+            if (tokens.length != 3) {\n+                throw taskHelper.newBadArgs(\"err.sha.overrides.bad.format\", t);\n+            }\n+            \/\/ t is a '|'-separated item of (in that order):\n+            \/\/    <module-name>\n+            \/\/    <file-path>\n+            \/\/    <SHA-512-sum>\n+            Map<String, Set<String>> perModuleMap = moduleToFiles.computeIfAbsent(tokens[0], k -> new HashMap<>());\n+            Set<String> shaSumsPerFile = perModuleMap.computeIfAbsent(tokens[1], k -> new HashSet<>());\n+            shaSumsPerFile.add(tokens[2]);\n+        }\n+        return moduleToFiles;\n+    }\n+\n@@ -791,1 +847,1 @@\n-            return LinkableRuntimeImage.newArchive(module, path, config.ignoreModifiedRuntime(), taskHelper);\n+            return LinkableRuntimeImage.newArchive(module, path, config.runtimeImageConfig(), taskHelper);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":59,"deletions":3,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import java.util.Map;\n+import java.util.Set;\n@@ -70,1 +72,1 @@\n-                                     boolean ignoreModifiedRuntime,\n+                                     Config config,\n@@ -84,1 +86,7 @@\n-        return new JRTArchive(module, path, !ignoreModifiedRuntime, perModuleDiff, taskHelper);\n+        return new JRTArchive(module,\n+                              path,\n+                              !config.ignoreModifiedRuntime,\n+                              perModuleDiff,\n+                              \/\/ Empty map if no alternative sha sums\n+                              config.altHashSums.computeIfAbsent(module, k -> Map.of()),\n+                              taskHelper);\n@@ -87,1 +95,2 @@\n-\n+    static record Config(boolean ignoreModifiedRuntime,\n+                         Map<String, Map<String, Set<String>>> altHashSums) {}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/LinkableRuntimeImage.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -130,0 +130,6 @@\n+\n+# Linking from the run-time image, SHA sum handling\n+err.sha.overrides.multiple=option --sha-overrides does not allow @file and non-file combinations\n+err.sha.overrides.freaderr=Error reading file ''{0}'' passed with option --sha-overrides\n+err.sha.overrides.bad.format=Bad format in --sha-overrides. Token was {0}. Expected <module-name>|<file-path>|<sha-sum>\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-                false \/* ignore modified runtime *\/,\n+                null \/* run-time image link config *\/,\n","filename":"test\/jdk\/tools\/jlink\/IntegrationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.HexFormat;\n+import java.util.List;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jtreg.SkippedException;\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Verify no warnings are being produced on a modified file which\n+ *          gets the SHA override from CLI\/file\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g & os.family == \"linux\")\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g ModifiedFilesWithShaOverrideTest\n+ *\/\n+public class ModifiedFilesWithShaOverrideTest extends ModifiedFilesTest {\n+\n+    private static final String SHA_OVERRIDE_FLAG = \"--sha-overrides\";\n+\n+    public static void main(String[] args) throws Exception {\n+        ModifiedFilesWithShaOverrideTest test = new ModifiedFilesWithShaOverrideTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    String initialImageName() {\n+        return \"java-base-jlink-with-sha-override\";\n+    }\n+\n+    @Override\n+    protected Path modifyFileInImage(Path jmodLessImg) {\n+        try {\n+            Path libJVM = jmodLessImg.resolve(\"lib\").resolve(\"server\").resolve(System.mapLibraryName(\"jvm\"));\n+            String shaBefore = buildSHA512(libJVM);\n+            List<String> objcopy = new ArrayList<>();\n+            objcopy.add(\"objcopy\");\n+            \/\/ The OpenJDK build doesn't strip all symbols by default. In order\n+            \/\/ to get a different libjvm.so file, we strip everything. The\n+            \/\/ expectation is for the sha to be different before and after the\n+            \/\/ stripping of the file.\n+            objcopy.add(\"--strip-all\");\n+            objcopy.add(libJVM.toString());\n+            ProcessBuilder builder = new ProcessBuilder(objcopy);\n+            Process p = builder.start();\n+            int returnVal = p.waitFor();\n+            if (returnVal != 0) {\n+                throw new SkippedException(\"Stripping of libjvm failed. Is objcopy installed?\");\n+            }\n+            String shaAfter = buildSHA512(libJVM);\n+            if (shaBefore.equals(shaAfter)) {\n+                throw new SkippedException(\"Binary file would be the same before after - test skipped\");\n+            }\n+            return libJVM;\n+        } catch (IOException | InterruptedException e) {\n+            throw new SkippedException(\"Stripping of libjvm failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    void testAndAssert(Path modifiedFile, Helper helper, Path initialImage) throws Exception {\n+        String strippedSha = buildSHA512(modifiedFile);\n+        Path relativePath = initialImage.relativize(modifiedFile);\n+        String overrideVal = String.format(\"%s|%s|%s\", \"java.base\", relativePath.toString(), strippedSha);\n+        String extraJlinkOpt = SHA_OVERRIDE_FLAG + \"=\" + overrideVal;\n+        CapturingHandler handler = new CapturingHandler();\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(initialImage)\n+                                .name(\"java-base-jlink-with-sha-override-target\")\n+                                .addModule(\"java.base\")\n+                                .validatingModule(\"java.base\")\n+                                .extraJlinkOpt(extraJlinkOpt) \/\/ allow for the modified sha\n+                                .build(), handler);\n+        OutputAnalyzer out = handler.analyzer();\n+        \/\/ verify we don't get a warning message for the modified file\n+        out.stdoutShouldNotMatch(\".* has been modified\");\n+        out.stdoutShouldNotContain(\"java.lang.IllegalArgumentException\");\n+        out.stdoutShouldNotContain(\"IOException\");\n+    }\n+\n+    private String buildSHA512(Path modifiedFile) {\n+        try {\n+            MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n+            try (InputStream is = Files.newInputStream(modifiedFile)) {\n+                byte[] buf = new byte[1024];\n+                int readBytes = -1;\n+                while ((readBytes = is.read(buf)) != -1) {\n+                    digest.update(buf, 0, readBytes);\n+                }\n+            }\n+            byte[] actual = digest.digest();\n+            return HexFormat.of().formatHex(actual);\n+        } catch (Exception e) {\n+            throw new AssertionError(\"SHA-512 sum generation failed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/ModifiedFilesWithShaOverrideTest.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"}]}