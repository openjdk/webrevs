{"files":[{"patch":"@@ -726,1 +726,0 @@\n-java\/util\/stream\/GatherersTest.java                             8321124 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,391 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Semaphore;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.stream.*;\n+import java.util.stream.Gatherer;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.*;\n+\n+\/**\n+ * @test\n+ * @summary Testing the built-in Gatherer implementations and their contracts\n+ * @enablePreview\n+ * @run junit BuiltInGatherersTest\n+ *\/\n+\n+public class BuiltInGatherersTest {\n+\n+    record Config(int streamSize, boolean parallel) {\n+        Stream<Integer> stream() {\n+            return wrapStream(Stream.iterate(1, i -> i + 1).limit(streamSize));\n+        }\n+\n+        <R> Stream<R> wrapStream(Stream<R> stream) {\n+            stream = parallel ? stream.parallel() : stream.sequential();\n+            return stream;\n+        }\n+    }\n+\n+    final static Stream<Config> configurations() {\n+        return Stream.of(0,1,10,33,99,9999)\n+                     .flatMap(size ->\n+                             Stream.of(false, true)\n+                                   .map(parallel ->\n+                                               new Config(size, parallel))\n+                     );\n+    }\n+\n+    final class TestException extends RuntimeException {\n+        TestException(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testFixedWindowAPIandContract(Config config) {\n+        \/\/ Groups must be greater than 0\n+        assertThrows(IllegalArgumentException.class, () -> Gatherers.windowFixed(0));\n+\n+        final var streamSize = config.streamSize();\n+\n+        \/\/ We're already covering less-than-one scenarios above\n+        if (streamSize > 0) {\n+            \/\/Test creating a window of the same size as the stream\n+            {\n+                final var result = config.stream()\n+                        .gather(Gatherers.windowFixed(streamSize))\n+                        .toList();\n+                assertEquals(1, result.size());\n+                assertEquals(config.stream().toList(), result.get(0));\n+            }\n+\n+            \/\/Test nulls as elements\n+            {\n+                assertEquals(\n+                      config.stream()\n+                            .map(n -> Arrays.asList(null, null))\n+                            .toList(),\n+                      config.stream()\n+                            .flatMap(n -> Stream.of(null, null))\n+                            .gather(Gatherers.windowFixed(2))\n+                            .toList());\n+            }\n+\n+            \/\/ Test unmodifiability of windows\n+            {\n+                var window = config.stream()\n+                                   .gather(Gatherers.windowFixed(1))\n+                                   .findFirst()\n+                                   .get();\n+                assertThrows(UnsupportedOperationException.class,\n+                        () -> window.add(2));\n+            }\n+        }\n+\n+\n+        \/\/ Tests that the layout of the returned data is as expected\n+        for (var windowSize : List.of(1, 2, 3, 10)) {\n+            final var expectLastWindowSize = streamSize % windowSize == 0 ? windowSize : streamSize % windowSize;\n+            final var expectedSize = (streamSize \/ windowSize) + ((streamSize % windowSize == 0) ? 0 : 1);\n+\n+            final var expected = config.stream().toList().iterator();\n+\n+            final var result = config.stream()\n+                                     .gather(Gatherers.windowFixed(windowSize))\n+                                     .toList();\n+\n+            int currentWindow = 0;\n+            for (var window : result) {\n+                ++currentWindow;\n+                assertEquals(currentWindow < expectedSize ? windowSize : expectLastWindowSize, window.size());\n+                for (var element : window)\n+                    assertEquals(expected.next(), element);\n+            }\n+\n+            assertEquals(expectedSize, currentWindow);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testSlidingAPIandContract(Config config) {\n+        \/\/ Groups must be greater than 0\n+        assertThrows(IllegalArgumentException.class, () -> Gatherers.windowSliding(0));\n+\n+        final var streamSize = config.streamSize();\n+\n+        \/\/ We're already covering less-than-one scenarios above\n+        if (streamSize > 0) {\n+            \/\/Test greating a window larger than the size of the stream\n+            {\n+                final var result = config.stream()\n+                                         .gather(Gatherers.windowSliding(streamSize + 1))\n+                                         .toList();\n+                assertEquals(1, result.size());\n+                assertEquals(config.stream().toList(), result.get(0));\n+            }\n+\n+            \/\/Test nulls as elements\n+            {\n+                assertEquals(\n+                        List.of(\n+                                Arrays.asList(null, null),\n+                                Arrays.asList(null, null)\n+                        ),\n+                        config.wrapStream(Stream.of(null, null, null))\n+                            .gather(Gatherers.windowSliding(2))\n+                            .toList());\n+            }\n+\n+            \/\/ Test unmodifiability of windows\n+            {\n+                var window = config.stream()\n+                        .gather(Gatherers.windowSliding(1))\n+                        .findFirst()\n+                        .get();\n+                assertThrows(UnsupportedOperationException.class,\n+                        () -> window.add(2));\n+            }\n+        }\n+\n+        \/\/ Tests that the layout of the returned data is as expected\n+        for (var windowSize : List.of(1, 2, 3, 10)) {\n+            final var expectLastWindowSize = streamSize < windowSize ? streamSize : windowSize;\n+            final var expectedNumberOfWindows = streamSize == 0 ? 0 : Math.max(1, 1 + streamSize - windowSize);\n+\n+            int expectedElement = 0;\n+            int currentWindow = 0;\n+\n+            final var result = config.stream()\n+                                     .gather(Gatherers.windowSliding(windowSize))\n+                                     .toList();\n+\n+            for (var window : result) {\n+                ++currentWindow;\n+                assertEquals(currentWindow < expectedNumberOfWindows ? windowSize : expectLastWindowSize, window.size());\n+                for (var element : window) {\n+                    assertEquals(++expectedElement, element.intValue());\n+                }\n+                \/\/ rewind for the sliding motion\n+                expectedElement -= (window.size() - 1);\n+            }\n+\n+            assertEquals(expectedNumberOfWindows, currentWindow);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testFoldAPIandContract(Config config) {\n+        \/\/ Verify prereqs\n+        assertThrows(NullPointerException.class, () -> Gatherers.<String,String>fold(null, (state, next) -> state));\n+        assertThrows(NullPointerException.class, () -> Gatherers.<String,String>fold(() -> \"\", null));\n+\n+        final var expectedResult = List.of(\n+                                       config.stream()\n+                                             .sequential()\n+                                             .reduce(\"\", (acc, next) -> acc + next, (l,r) -> { throw new IllegalStateException(); })\n+                                   );\n+\n+        final var result = config.stream()\n+                                 .gather(Gatherers.fold(() -> \"\", (acc, next) -> acc + next))\n+                                 .toList();\n+\n+        assertEquals(expectedResult, result);\n+    }\n+\n+    private static void awaitSensibly(CountDownLatch latch) {\n+        try {\n+            assertTrue(latch.await(20, java.util.concurrent.TimeUnit.SECONDS));\n+        } catch (InterruptedException ie) {\n+            throw new IllegalStateException(ie);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void testMapConcurrentAPIandContract(Config config) throws InterruptedException {\n+        \/\/ Verify prereqs\n+        assertThrows(IllegalArgumentException.class, () -> Gatherers.<String, String>mapConcurrent(0, s -> s));\n+        assertThrows(NullPointerException.class, () -> Gatherers.<String, String>mapConcurrent(2, null));\n+\n+        \/\/ Test exception during processing\n+        {\n+            final var stream = config.parallel() ? Stream.of(1).parallel() : Stream.of(1);\n+\n+            assertThrows(RuntimeException.class,\n+                    () -> stream.gather(Gatherers.<Integer, Integer>mapConcurrent(2, x -> {\n+                        throw new RuntimeException();\n+                    })).toList());\n+        }\n+\n+        \/\/ Test cancellation after exception during processing\n+        if (config.streamSize > 2) { \/\/ We need streams of a minimum size to test this\n+            final var tasksToCancel = config.streamSize - 2;\n+            final var throwerReady = new CountDownLatch(1);\n+            final var initiateThrow = new CountDownLatch(1);\n+            final var tasksCancelled = new CountDownLatch(tasksToCancel);\n+\n+            final var tasksWaiting = new Semaphore(0);\n+\n+            try {\n+                config.stream()\n+                      .gather(\n+                            Gatherers.mapConcurrent(config.streamSize(), i -> {\n+                                switch (i) {\n+                                    case 1 -> {\n+                                        throwerReady.countDown();\n+                                        awaitSensibly(initiateThrow);\n+                                        throw new TestException(\"expected\");\n+                                    }\n+\n+                                    case Integer n when n == config.streamSize - 1 -> {\n+                                        awaitSensibly(throwerReady);\n+                                        while(tasksWaiting.getQueueLength() < tasksToCancel) {\n+                                            try {\n+                                                Thread.sleep(10);\n+                                            } catch (InterruptedException ie) {\n+                                                \/\/ Ignore\n+                                            }\n+                                        }\n+                                        initiateThrow.countDown();\n+                                    }\n+\n+                                    default -> {\n+                                        try {\n+                                            tasksWaiting.acquire();\n+                                        } catch (InterruptedException ie) {\n+                                            tasksCancelled.countDown(); \/\/ used to ensure that they all were interrupted\n+                                        }\n+                                    }\n+                                }\n+\n+                                return i;\n+                            })\n+                      )\n+                      .toList();\n+                fail(\"This should not be reached\");\n+            } catch (TestException te) {\n+                assertEquals(\"expected\", te.getMessage());\n+                awaitSensibly(tasksCancelled);\n+                return;\n+            }\n+\n+            fail(\"This should not be reached\");\n+        }\n+\n+        \/\/ Test cancellation during short-circuiting\n+        if (config.streamSize > 2) {\n+            final var tasksToCancel = config.streamSize - 2;\n+            final var firstReady = new CountDownLatch(1);\n+            final var lastDone = new CountDownLatch(1);\n+            final var tasksCancelled = new CountDownLatch(tasksToCancel);\n+\n+            final var tasksWaiting = new Semaphore(0);\n+\n+            final var result =\n+                config.stream()\n+                    .gather(\n+                            Gatherers.mapConcurrent(config.streamSize(), i -> {\n+                                switch (i) {\n+                                    case 1 -> {\n+                                        firstReady.countDown();\n+                                        awaitSensibly(lastDone);\n+                                    }\n+\n+                                    case Integer n when n == config.streamSize - 1 -> {\n+                                        awaitSensibly(firstReady);\n+                                        while(tasksWaiting.getQueueLength() < tasksToCancel) {\n+                                            try {\n+                                                Thread.sleep(10);\n+                                            } catch (InterruptedException ie) {\n+                                                \/\/ Ignore\n+                                            }\n+                                        }\n+                                        lastDone.countDown();\n+                                    }\n+\n+                                    default -> {\n+                                        try {\n+                                            tasksWaiting.acquire();\n+                                        } catch (InterruptedException ie) {\n+                                            tasksCancelled.countDown(); \/\/ used to ensure that they all were interrupted\n+                                        }\n+                                    }\n+                                }\n+\n+                                return i;\n+                            })\n+                    )\n+                    .limit(1)\n+                    .toList();\n+            awaitSensibly(tasksCancelled);\n+            assertEquals(List.of(1), result);\n+        }\n+\n+        for (var concurrency : List.of(1, 2, 3, 10, 1000)) {\n+            \/\/ Test normal operation\n+            {\n+                final var expectedResult = config.stream()\n+                                                 .map(x -> x * x)\n+                                                 .toList();\n+\n+                final var result = config.stream()\n+                                         .gather(Gatherers.mapConcurrent(concurrency, x -> x * x))\n+                                         .toList();\n+\n+                assertEquals(expectedResult, result);\n+            }\n+\n+            \/\/ Test short-circuiting\n+            {\n+                final var limitTo = Math.max(config.streamSize() \/ 2, 1);\n+\n+                final var expectedResult = config.stream()\n+                                                 .map(x -> x * x)\n+                                                 .limit(limitTo)\n+                                                 .toList();\n+\n+                final var result = config.stream()\n+                                         .gather(Gatherers.mapConcurrent(concurrency, x -> x * x))\n+                                         .limit(limitTo)\n+                                         .toList();\n+\n+                assertEquals(expectedResult, result);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/stream\/BuiltInGatherersTest.java","additions":391,"deletions":0,"binary":false,"changes":391,"status":"added"},{"patch":"@@ -352,1 +352,1 @@\n-        final int ITERATIONS = 512; \/\/ Total number of compositions is 1 + (iterations*2)\n+        final int ITERATIONS = 256; \/\/ Total number of compositions is 1 + (iterations*2)\n","filename":"test\/jdk\/java\/util\/stream\/GathererTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,368 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Semaphore;\n-import java.util.function.Predicate;\n-import java.util.function.Supplier;\n-import java.util.stream.*;\n-import java.util.stream.Gatherer;\n-\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-import static org.junit.jupiter.api.Assertions.*;\n-import static org.junit.jupiter.api.Assumptions.*;\n-\n-\/**\n- * @test\n- * @summary Testing the built-in Gatherer implementations and their contracts\n- * @enablePreview\n- * @run junit GatherersTest\n- *\/\n-\n-public class GatherersTest {\n-\n-    record Config(int streamSize, boolean parallel) {\n-        Stream<Integer> stream() {\n-            return wrapStream(Stream.iterate(1, i -> i + 1).limit(streamSize));\n-        }\n-\n-        <R> Stream<R> wrapStream(Stream<R> stream) {\n-            stream = parallel ? stream.parallel() : stream.sequential();\n-            return stream;\n-        }\n-    }\n-\n-    final static Stream<Config> configurations() {\n-        return Stream.of(0,1,10,33,99,9999)\n-                     .flatMap(size ->\n-                             Stream.of(false, true)\n-                                   .map(parallel ->\n-                                               new Config(size, parallel))\n-                     );\n-    }\n-\n-    final class TestException extends RuntimeException {\n-        TestException(String message) {\n-            super(message);\n-        }\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"configurations\")\n-    public void testFixedWindowAPIandContract(Config config) {\n-        \/\/ Groups must be greater than 0\n-        assertThrows(IllegalArgumentException.class, () -> Gatherers.windowFixed(0));\n-\n-        final var streamSize = config.streamSize();\n-\n-        \/\/ We're already covering less-than-one scenarios above\n-        if (streamSize > 0) {\n-            \/\/Test creating a window of the same size as the stream\n-            {\n-                final var result = config.stream()\n-                        .gather(Gatherers.windowFixed(streamSize))\n-                        .toList();\n-                assertEquals(1, result.size());\n-                assertEquals(config.stream().toList(), result.get(0));\n-            }\n-\n-            \/\/Test nulls as elements\n-            {\n-                assertEquals(\n-                      config.stream()\n-                            .map(n -> Arrays.asList(null, null))\n-                            .toList(),\n-                      config.stream()\n-                            .flatMap(n -> Stream.of(null, null))\n-                            .gather(Gatherers.windowFixed(2))\n-                            .toList());\n-            }\n-\n-            \/\/ Test unmodifiability of windows\n-            {\n-                var window = config.stream()\n-                                   .gather(Gatherers.windowFixed(1))\n-                                   .findFirst()\n-                                   .get();\n-                assertThrows(UnsupportedOperationException.class,\n-                        () -> window.add(2));\n-            }\n-        }\n-\n-\n-        \/\/ Tests that the layout of the returned data is as expected\n-        for (var windowSize : List.of(1, 2, 3, 10)) {\n-            final var expectLastWindowSize = streamSize % windowSize == 0 ? windowSize : streamSize % windowSize;\n-            final var expectedSize = (streamSize \/ windowSize) + ((streamSize % windowSize == 0) ? 0 : 1);\n-\n-            final var expected = config.stream().toList().iterator();\n-\n-            final var result = config.stream()\n-                                     .gather(Gatherers.windowFixed(windowSize))\n-                                     .toList();\n-\n-            int currentWindow = 0;\n-            for (var window : result) {\n-                ++currentWindow;\n-                assertEquals(currentWindow < expectedSize ? windowSize : expectLastWindowSize, window.size());\n-                for (var element : window)\n-                    assertEquals(expected.next(), element);\n-            }\n-\n-            assertEquals(expectedSize, currentWindow);\n-        }\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"configurations\")\n-    public void testSlidingAPIandContract(Config config) {\n-        \/\/ Groups must be greater than 0\n-        assertThrows(IllegalArgumentException.class, () -> Gatherers.windowSliding(0));\n-\n-        final var streamSize = config.streamSize();\n-\n-        \/\/ We're already covering less-than-one scenarios above\n-        if (streamSize > 0) {\n-            \/\/Test greating a window larger than the size of the stream\n-            {\n-                final var result = config.stream()\n-                                         .gather(Gatherers.windowSliding(streamSize + 1))\n-                                         .toList();\n-                assertEquals(1, result.size());\n-                assertEquals(config.stream().toList(), result.get(0));\n-            }\n-\n-            \/\/Test nulls as elements\n-            {\n-                assertEquals(\n-                        List.of(\n-                                Arrays.asList(null, null),\n-                                Arrays.asList(null, null)\n-                        ),\n-                        config.wrapStream(Stream.of(null, null, null))\n-                            .gather(Gatherers.windowSliding(2))\n-                            .toList());\n-            }\n-\n-            \/\/ Test unmodifiability of windows\n-            {\n-                var window = config.stream()\n-                        .gather(Gatherers.windowSliding(1))\n-                        .findFirst()\n-                        .get();\n-                assertThrows(UnsupportedOperationException.class,\n-                        () -> window.add(2));\n-            }\n-        }\n-\n-        \/\/ Tests that the layout of the returned data is as expected\n-        for (var windowSize : List.of(1, 2, 3, 10)) {\n-            final var expectLastWindowSize = streamSize < windowSize ? streamSize : windowSize;\n-            final var expectedNumberOfWindows = streamSize == 0 ? 0 : Math.max(1, 1 + streamSize - windowSize);\n-\n-            int expectedElement = 0;\n-            int currentWindow = 0;\n-\n-            final var result = config.stream()\n-                                     .gather(Gatherers.windowSliding(windowSize))\n-                                     .toList();\n-\n-            for (var window : result) {\n-                ++currentWindow;\n-                assertEquals(currentWindow < expectedNumberOfWindows ? windowSize : expectLastWindowSize, window.size());\n-                for (var element : window) {\n-                    assertEquals(++expectedElement, element.intValue());\n-                }\n-                \/\/ rewind for the sliding motion\n-                expectedElement -= (window.size() - 1);\n-            }\n-\n-            assertEquals(expectedNumberOfWindows, currentWindow);\n-        }\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"configurations\")\n-    public void testFoldAPIandContract(Config config) {\n-        \/\/ Verify prereqs\n-        assertThrows(NullPointerException.class, () -> Gatherers.<String,String>fold(null, (state, next) -> state));\n-        assertThrows(NullPointerException.class, () -> Gatherers.<String,String>fold(() -> \"\", null));\n-\n-        final var expectedResult = List.of(\n-                                       config.stream()\n-                                             .sequential()\n-                                             .reduce(\"\", (acc, next) -> acc + next, (l,r) -> { throw new IllegalStateException(); })\n-                                   );\n-\n-        final var result = config.stream()\n-                                 .gather(Gatherers.fold(() -> \"\", (acc, next) -> acc + next))\n-                                 .toList();\n-\n-        assertEquals(expectedResult, result);\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"configurations\")\n-    public void testMapConcurrentAPIandContract(Config config) throws InterruptedException {\n-        \/\/ Verify prereqs\n-        assertThrows(IllegalArgumentException.class, () -> Gatherers.<String, String>mapConcurrent(0, s -> s));\n-        assertThrows(NullPointerException.class, () -> Gatherers.<String, String>mapConcurrent(2, null));\n-\n-        \/\/ Test exception during processing\n-        {\n-            final var stream = config.parallel() ? Stream.of(1).parallel() : Stream.of(1);\n-\n-            assertThrows(RuntimeException.class,\n-                    () -> stream.gather(Gatherers.<Integer, Integer>mapConcurrent(2, x -> {\n-                        throw new RuntimeException();\n-                    })).toList());\n-        }\n-\n-        \/\/ Test cancellation after exception during processing\n-        if (config.streamSize > 2) { \/\/ We need streams of a minimum size to test this\n-            final var firstLatch = new CountDownLatch(1);\n-            final var secondLatch = new CountDownLatch(1);\n-            final var cancellationLatch = new CountDownLatch(config.streamSize - 2); \/\/ all but two will get cancelled\n-\n-            try {\n-                config.stream()\n-                      .gather(\n-                            Gatherers.mapConcurrent(config.streamSize(), i -> {\n-                                switch (i) {\n-                                    case 1 -> {\n-                                        try {\n-                                            firstLatch.await(); \/\/ the first waits for the last element to start\n-                                        } catch (InterruptedException ie) {\n-                                            throw new IllegalStateException(ie);\n-                                        }\n-                                        throw new TestException(\"expected\");\n-                                    }\n-\n-                                    case Integer n when n == config.streamSize - 1 -> { \/\/ last element\n-                                        firstLatch.countDown(); \/\/ ensure that the first element can now proceed\n-                                    }\n-\n-                                    default -> {\n-                                        try {\n-                                            secondLatch.await(); \/\/ These should all get interrupted\n-                                        } catch (InterruptedException ie) {\n-                                            cancellationLatch.countDown(); \/\/ used to ensure that they all were interrupted\n-                                        }\n-                                    }\n-                                }\n-\n-                                return i;\n-                            })\n-                      )\n-                      .toList();\n-                fail(\"This should not be reached\");\n-            } catch (RuntimeException re) {\n-                assertSame(TestException.class, re.getClass());\n-                assertEquals(\"expected\", re.getMessage());\n-                cancellationLatch.await();\n-                return;\n-            }\n-\n-            fail(\"This should not be reached\");\n-        }\n-\n-        \/\/ Test cancellation during short-circuiting\n-        if (config.streamSize > 2) {\n-            final var firstLatch = new CountDownLatch(1);\n-            final var secondLatch = new CountDownLatch(1);\n-            final var cancellationLatch = new CountDownLatch(config.streamSize - 2); \/\/ all but two will get cancelled\n-\n-            final var result =\n-                config.stream()\n-                      .gather(\n-                            Gatherers.mapConcurrent(config.streamSize(), i -> {\n-                                switch (i) {\n-                                    case 1 -> {\n-                                        try {\n-                                            firstLatch.await(); \/\/ the first waits for the last element to start\n-                                        } catch (InterruptedException ie) {\n-                                            throw new IllegalStateException(ie);\n-                                        }\n-                                    }\n-\n-                                    case Integer n when n == config.streamSize - 1 -> { \/\/ last element\n-                                        firstLatch.countDown(); \/\/ ensure that the first element can now proceed\n-                                    }\n-\n-                                    default -> {\n-                                        try {\n-                                            secondLatch.await(); \/\/ These should all get interrupted\n-                                        } catch (InterruptedException ie) {\n-                                            cancellationLatch.countDown(); \/\/ used to ensure that they all were interrupted\n-                                        }\n-                                    }\n-                                }\n-\n-                                return i;\n-                            })\n-                      )\n-                      .limit(2)\n-                      .toList();\n-            cancellationLatch.await(); \/\/ If this hangs, then we didn't cancel and interrupt the tasks\n-            assertEquals(List.of(1,2), result);\n-        }\n-\n-        for (var concurrency : List.of(1, 2, 3, 10, 1000)) {\n-            \/\/ Test normal operation\n-            {\n-                final var expectedResult = config.stream()\n-                                                 .map(x -> x * x)\n-                                                 .toList();\n-\n-                final var result = config.stream()\n-                                         .gather(Gatherers.mapConcurrent(concurrency, x -> x * x))\n-                                         .toList();\n-\n-                assertEquals(expectedResult, result);\n-            }\n-\n-            \/\/ Test short-circuiting\n-            {\n-                final var limitTo = Math.max(config.streamSize() \/ 2, 1);\n-\n-                final var expectedResult = config.stream()\n-                                                 .map(x -> x * x)\n-                                                 .limit(limitTo)\n-                                                 .toList();\n-\n-                final var result = config.stream()\n-                                         .gather(Gatherers.mapConcurrent(concurrency, x -> x * x))\n-                                         .limit(limitTo)\n-                                         .toList();\n-\n-                assertEquals(expectedResult, result);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/stream\/GatherersTest.java","additions":0,"deletions":368,"binary":false,"changes":368,"status":"deleted"},{"patch":"","filename":"test\/jdk\/java\/util\/stream\/TEST.properties","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/util\/concurrent\/TEST.properties","status":"copied"}]}