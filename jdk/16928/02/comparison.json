{"files":[{"patch":"@@ -726,1 +726,0 @@\n-java\/util\/stream\/GatherersTest.java                             8321124 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -352,1 +352,1 @@\n-        final int ITERATIONS = 512; \/\/ Total number of compositions is 1 + (iterations*2)\n+        final int ITERATIONS = 256; \/\/ Total number of compositions is 1 + (iterations*2)\n","filename":"test\/jdk\/java\/util\/stream\/GathererTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.List;\n+import java.util.stream.Gatherers;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.*;\n+\n+\/**\n+ * @test\n+ * @summary Tests the API and contract of Gatherers.fold\n+ * @enablePreview\n+ * @run junit GatherersFoldTest\n+ *\/\n+\n+public class GatherersFoldTest {\n+\n+    record Config(int streamSize, boolean parallel) {\n+        Stream<Integer> stream() {\n+            var stream = Stream.iterate(1, i -> i + 1).limit(streamSize);\n+            stream = parallel ? stream.parallel() : stream.sequential();\n+            return stream;\n+        }\n+    }\n+\n+    static final Stream<Integer> sizes(){\n+        return Stream.of(0,1,10,33,99,9999);\n+    }\n+\n+    static final Stream<Config> sequentialAndParallel(int size) {\n+        return Stream.of(false, true)\n+                .map(parallel ->\n+                        new Config(size, parallel));\n+    }\n+\n+    static final Stream<Config> configurations() {\n+        return sizes().flatMap(i -> sequentialAndParallel(i));\n+    }\n+\n+    @Test\n+    public void throwsNPEWhenStateSupplierIsNull() {\n+        assertThrows(NullPointerException.class, () -> Gatherers.<String, String>fold(null, (state, next) -> state));\n+    }\n+\n+    @Test\n+    public void throwsNPEWhenFolderFunctionIsNull() {\n+        assertThrows(NullPointerException.class, () -> Gatherers.<String, String>fold(() -> \"\", null));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void behavesAsExpected(Config config) {\n+        final var expectedResult = List.of(\n+            config.stream()\n+                    .sequential()\n+                    .reduce(0L, (acc, next) -> acc + next,(l, r) -> {\n+                        throw new IllegalStateException();\n+                    })\n+        );\n+\n+        final var result = config.stream()\n+                .gather(Gatherers.fold(() -> 0L, (acc, next) -> acc + next))\n+                .toList();\n+\n+        assertEquals(expectedResult, result);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/stream\/GatherersFoldTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,280 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n+import java.util.stream.Gatherer;\n+import java.util.stream.Gatherers;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.*;\n+\n+\/**\n+ * @test\n+ * @summary Tests the API and contract of Gatherers.mapConcurrent\n+ * @enablePreview\n+ * @run junit GatherersMapConcurrentTest\n+ *\/\n+\n+public class GatherersMapConcurrentTest {\n+\n+    record Config(int streamSize, boolean parallel) {\n+        Stream<Integer> stream() {\n+            var stream = Stream.iterate(1, i -> i + 1).limit(streamSize);\n+            stream = parallel ? stream.parallel() : stream.sequential();\n+            return stream;\n+        }\n+    }\n+\n+    static final Stream<Integer> sizes(){\n+        return Stream.of(0,1,10,33,99,9999);\n+    }\n+\n+    static final Stream<Config> sequentialAndParallel(int size) {\n+        return Stream.of(false, true)\n+                .map(parallel ->\n+                        new Config(size, parallel));\n+    }\n+\n+    static final Stream<Config> configurations() {\n+        return sizes().flatMap(i -> sequentialAndParallel(i));\n+    }\n+\n+    static final Stream<Config> small_atleast3_configurations() {\n+        return sizes().filter(i -> i > 2 && i < 100).flatMap(i -> sequentialAndParallel(i));\n+    }\n+\n+    static final class TestException extends RuntimeException {\n+        TestException(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = { Integer.MIN_VALUE, -999, -1, 0})\n+    public void throwsIAEWhenConcurrencyLevelIsLowerThanOne(int level) {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> Gatherers.<String, String>mapConcurrent(level, s -> s));\n+    }\n+\n+    @Test\n+    public void throwsNPEWhenMapperFunctionIsNull() {\n+        assertThrows(NullPointerException.class, () -> Gatherers.<String, String>mapConcurrent(2, null));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false } )\n+    public void rethrowsRuntimeExceptionsUnwrapped(boolean parallel) {\n+        final var stream = parallel ? Stream.of(1).parallel() : Stream.of(1);\n+\n+        var exception =\n+            assertThrows(\n+                RuntimeException.class,\n+                     () -> stream.gather(\n+                             Gatherers.<Integer, Integer>mapConcurrent(2, x -> {\n+                                 throw new RuntimeException(\"expected\");\n+                             })\n+                           ).toList()\n+            );\n+        assertEquals(\"expected\", exception.getMessage());\n+        assertNull(exception.getCause());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"small_atleast3_configurations\")\n+    public void cancelsStartedTasksIfExceptionDuringProcessingIsThrown(Config config) {\n+        final var streamSize = config.streamSize();\n+\n+        assertTrue(streamSize > 2, \"This test case won't work with tiny streams!\");\n+\n+        final var tasksToCancel = streamSize - 2;\n+        final var throwerReady = new CountDownLatch(1);\n+        final var initiateThrow = new CountDownLatch(1);\n+        final var tasksCancelled = new CountDownLatch(tasksToCancel);\n+\n+        final var tasksWaiting = new Semaphore(0);\n+\n+        try {\n+            config.stream()\n+                    .gather(\n+                            Gatherers.mapConcurrent(streamSize, i -> {\n+                                switch (i) {\n+                                    case 1 -> {\n+                                        throwerReady.countDown();\n+                                        try { initiateThrow.await(); }\n+                                        catch (InterruptedException ie) {\n+                                            fail(\"Unexpected\");\n+                                        }\n+                                        throw new TestException(\"expected\");\n+                                    }\n+\n+                                    case Integer n when n == streamSize -> {\n+                                        try { throwerReady.await(); }\n+                                        catch (InterruptedException ie) {\n+                                            fail(\"Unexpected\");\n+                                        }\n+                                        while(tasksWaiting.getQueueLength() < tasksToCancel) {\n+                                            try {\n+                                                Thread.sleep(10);\n+                                            } catch (InterruptedException ie) {\n+                                                \/\/ Ignore\n+                                            }\n+                                        }\n+                                        initiateThrow.countDown();\n+                                    }\n+\n+                                    default -> {\n+                                        try {\n+                                            tasksWaiting.acquire();\n+                                        } catch (InterruptedException ie) {\n+                                            tasksCancelled.countDown(); \/\/ used to ensure that they all were interrupted\n+                                        }\n+                                    }\n+                                }\n+\n+                                return i;\n+                            })\n+                    )\n+                    .toList();\n+            fail(\"This should not be reached\");\n+        } catch (TestException te) {\n+            assertEquals(\"expected\", te.getMessage());\n+            try { tasksCancelled.await(); }\n+            catch (InterruptedException ie) {\n+                fail(\"Unexpected\");\n+            }\n+            return;\n+        }\n+\n+        fail(\"This should not be reached\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"small_atleast3_configurations\")\n+    public void cancelsStartedTasksIfShortCircuited(Config config) {\n+        final var streamSize = config.streamSize();\n+\n+        assertTrue(streamSize > 2, \"This test case won't work with tiny streams!\");\n+\n+        final var tasksToCancel = streamSize - 2;\n+        final var firstReady = new CountDownLatch(1);\n+        final var lastDone = new CountDownLatch(1);\n+        final var tasksCancelled = new CountDownLatch(tasksToCancel);\n+\n+        final var tasksWaiting = new Semaphore(0);\n+\n+        final var result =\n+                config.stream().gather(\n+                    Gatherers.mapConcurrent(streamSize, i -> {\n+                        switch (i) {\n+                            case 1 -> {\n+                                firstReady.countDown();\n+                                try { lastDone.await(); }\n+                                catch (InterruptedException ie) {\n+                                    fail(\"Unexpected!\");\n+                                }\n+                            }\n+\n+                            case Integer n when n == streamSize -> {\n+                                try { firstReady.await(); }\n+                                catch (InterruptedException ie) {\n+                                    fail(\"Unexpected!\");\n+                                }\n+                                while(tasksWaiting.getQueueLength() < tasksToCancel) {\n+                                    try {\n+                                        Thread.sleep(10);\n+                                    } catch (InterruptedException ie) {\n+                                        \/\/ Ignore\n+                                    }\n+                                }\n+                                lastDone.countDown();\n+                            }\n+\n+                            default -> {\n+                                try {\n+                                    tasksWaiting.acquire();\n+                                } catch (InterruptedException ie) {\n+                                    System.out.println(\"Current count: \" + tasksCancelled.getCount());\n+                                    tasksCancelled.countDown(); \/\/ used to ensure that they all were interrupted\n+                                }\n+                            }\n+                        }\n+\n+                        return i;\n+                    })\n+            )\n+            .gather(Gatherer.of((unused, state, downstream) -> downstream.push(state) && false)) \/\/ emulate limit(1)\n+            .toList();\n+        assertEquals(List.of(1), result);\n+        try {\n+            if (!tasksCancelled.await(5, java.util.concurrent.TimeUnit.SECONDS)) {\n+                fail(\"Missed \" + tasksCancelled.getCount() + \" cancellations.\");\n+            }\n+        } catch (InterruptedException ie) {\n+            fail(\"Unexpected\");\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void behavesAsExpected(Config config) {\n+        for (var concurrency : List.of(1, 2, 3, 10, 1000)) {\n+            final var expectedResult = config.stream()\n+                    .map(x -> x * x)\n+                    .toList();\n+\n+            final var result = config.stream()\n+                    .gather(Gatherers.mapConcurrent(concurrency, x -> x * x))\n+                    .toList();\n+\n+            assertEquals(expectedResult, result);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void behavesAsExpectedWhenShortCircuited(Config config) {\n+        \/\/ Test short-circuiting\n+        for (var concurrency : List.of(1, 2, 3, 10, 1000)) {\n+            final var limitTo = Math.max(config.streamSize() \/ 2, 1);\n+\n+            final var expectedResult = config.stream()\n+                    .map(x -> x * x)\n+                    .limit(limitTo)\n+                    .toList();\n+\n+            final var result = config.stream()\n+                    .gather(Gatherers.mapConcurrent(concurrency, x -> x * x))\n+                    .limit(limitTo)\n+                    .toList();\n+\n+            assertEquals(expectedResult, result);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/stream\/GatherersMapConcurrentTest.java","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Gatherers;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.*;\n+\n+\/**\n+ * @test\n+ * @summary Tests the API and contract of Gatherers.scan\n+ * @enablePreview\n+ * @run junit GatherersScanTest\n+ *\/\n+\n+public class GatherersScanTest {\n+\n+    record Config(int streamSize, boolean parallel) {\n+        Stream<Integer> stream() {\n+            var stream = Stream.iterate(1, i -> i + 1).limit(streamSize);\n+            stream = parallel ? stream.parallel() : stream.sequential();\n+            return stream;\n+        }\n+    }\n+\n+    static final Stream<Integer> sizes(){\n+        return Stream.of(0,1,10,33,99,9999);\n+    }\n+\n+    static final Stream<Config> sequentialAndParallel(int size) {\n+        return Stream.of(false, true)\n+                .map(parallel ->\n+                        new Config(size, parallel));\n+    }\n+\n+    static final Stream<Config> configurations() {\n+        return sizes().flatMap(i -> sequentialAndParallel(i));\n+    }\n+\n+    @Test\n+    public void throwsNPEWhenStateSupplierIsNull() {\n+        assertThrows(NullPointerException.class,\n+                () -> Gatherers.<String, String>scan(null, (state, next) -> state));\n+    }\n+\n+    @Test\n+    public void throwsNPEWhenScannerFunctionIsNull() {\n+        assertThrows(NullPointerException.class,\n+                () -> Gatherers.<String, String>scan(() -> \"\", null));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void behavesAsExpected(Config config) {\n+        final List<Long> expectedResult;\n+        if (config.streamSize() == 0) {\n+            expectedResult = List.of();\n+        } else {\n+            expectedResult = config.stream()\n+                .sequential()\n+                .reduce(\n+                        new LinkedList<Long>(),\n+                        (acc, next) -> {\n+                            acc.addLast((acc.isEmpty() ? 0L : acc.getLast()) + next);\n+                            return acc;\n+                        },\n+                        (l, r) -> { throw new IllegalStateException(); }\n+                );\n+        }\n+\n+        final var result = config.stream()\n+                .gather(Gatherers.scan(() -> 0L, (acc, next) -> acc + next))\n+                .toList();\n+\n+        System.out.println(expectedResult);\n+        System.out.println(result);\n+        assertEquals(expectedResult, result);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/stream\/GatherersScanTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -1,368 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Semaphore;\n-import java.util.function.Predicate;\n-import java.util.function.Supplier;\n-import java.util.stream.*;\n-import java.util.stream.Gatherer;\n-\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-import static org.junit.jupiter.api.Assertions.*;\n-import static org.junit.jupiter.api.Assumptions.*;\n-\n-\/**\n- * @test\n- * @summary Testing the built-in Gatherer implementations and their contracts\n- * @enablePreview\n- * @run junit GatherersTest\n- *\/\n-\n-public class GatherersTest {\n-\n-    record Config(int streamSize, boolean parallel) {\n-        Stream<Integer> stream() {\n-            return wrapStream(Stream.iterate(1, i -> i + 1).limit(streamSize));\n-        }\n-\n-        <R> Stream<R> wrapStream(Stream<R> stream) {\n-            stream = parallel ? stream.parallel() : stream.sequential();\n-            return stream;\n-        }\n-    }\n-\n-    final static Stream<Config> configurations() {\n-        return Stream.of(0,1,10,33,99,9999)\n-                     .flatMap(size ->\n-                             Stream.of(false, true)\n-                                   .map(parallel ->\n-                                               new Config(size, parallel))\n-                     );\n-    }\n-\n-    final class TestException extends RuntimeException {\n-        TestException(String message) {\n-            super(message);\n-        }\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"configurations\")\n-    public void testFixedWindowAPIandContract(Config config) {\n-        \/\/ Groups must be greater than 0\n-        assertThrows(IllegalArgumentException.class, () -> Gatherers.windowFixed(0));\n-\n-        final var streamSize = config.streamSize();\n-\n-        \/\/ We're already covering less-than-one scenarios above\n-        if (streamSize > 0) {\n-            \/\/Test creating a window of the same size as the stream\n-            {\n-                final var result = config.stream()\n-                        .gather(Gatherers.windowFixed(streamSize))\n-                        .toList();\n-                assertEquals(1, result.size());\n-                assertEquals(config.stream().toList(), result.get(0));\n-            }\n-\n-            \/\/Test nulls as elements\n-            {\n-                assertEquals(\n-                      config.stream()\n-                            .map(n -> Arrays.asList(null, null))\n-                            .toList(),\n-                      config.stream()\n-                            .flatMap(n -> Stream.of(null, null))\n-                            .gather(Gatherers.windowFixed(2))\n-                            .toList());\n-            }\n-\n-            \/\/ Test unmodifiability of windows\n-            {\n-                var window = config.stream()\n-                                   .gather(Gatherers.windowFixed(1))\n-                                   .findFirst()\n-                                   .get();\n-                assertThrows(UnsupportedOperationException.class,\n-                        () -> window.add(2));\n-            }\n-        }\n-\n-\n-        \/\/ Tests that the layout of the returned data is as expected\n-        for (var windowSize : List.of(1, 2, 3, 10)) {\n-            final var expectLastWindowSize = streamSize % windowSize == 0 ? windowSize : streamSize % windowSize;\n-            final var expectedSize = (streamSize \/ windowSize) + ((streamSize % windowSize == 0) ? 0 : 1);\n-\n-            final var expected = config.stream().toList().iterator();\n-\n-            final var result = config.stream()\n-                                     .gather(Gatherers.windowFixed(windowSize))\n-                                     .toList();\n-\n-            int currentWindow = 0;\n-            for (var window : result) {\n-                ++currentWindow;\n-                assertEquals(currentWindow < expectedSize ? windowSize : expectLastWindowSize, window.size());\n-                for (var element : window)\n-                    assertEquals(expected.next(), element);\n-            }\n-\n-            assertEquals(expectedSize, currentWindow);\n-        }\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"configurations\")\n-    public void testSlidingAPIandContract(Config config) {\n-        \/\/ Groups must be greater than 0\n-        assertThrows(IllegalArgumentException.class, () -> Gatherers.windowSliding(0));\n-\n-        final var streamSize = config.streamSize();\n-\n-        \/\/ We're already covering less-than-one scenarios above\n-        if (streamSize > 0) {\n-            \/\/Test greating a window larger than the size of the stream\n-            {\n-                final var result = config.stream()\n-                                         .gather(Gatherers.windowSliding(streamSize + 1))\n-                                         .toList();\n-                assertEquals(1, result.size());\n-                assertEquals(config.stream().toList(), result.get(0));\n-            }\n-\n-            \/\/Test nulls as elements\n-            {\n-                assertEquals(\n-                        List.of(\n-                                Arrays.asList(null, null),\n-                                Arrays.asList(null, null)\n-                        ),\n-                        config.wrapStream(Stream.of(null, null, null))\n-                            .gather(Gatherers.windowSliding(2))\n-                            .toList());\n-            }\n-\n-            \/\/ Test unmodifiability of windows\n-            {\n-                var window = config.stream()\n-                        .gather(Gatherers.windowSliding(1))\n-                        .findFirst()\n-                        .get();\n-                assertThrows(UnsupportedOperationException.class,\n-                        () -> window.add(2));\n-            }\n-        }\n-\n-        \/\/ Tests that the layout of the returned data is as expected\n-        for (var windowSize : List.of(1, 2, 3, 10)) {\n-            final var expectLastWindowSize = streamSize < windowSize ? streamSize : windowSize;\n-            final var expectedNumberOfWindows = streamSize == 0 ? 0 : Math.max(1, 1 + streamSize - windowSize);\n-\n-            int expectedElement = 0;\n-            int currentWindow = 0;\n-\n-            final var result = config.stream()\n-                                     .gather(Gatherers.windowSliding(windowSize))\n-                                     .toList();\n-\n-            for (var window : result) {\n-                ++currentWindow;\n-                assertEquals(currentWindow < expectedNumberOfWindows ? windowSize : expectLastWindowSize, window.size());\n-                for (var element : window) {\n-                    assertEquals(++expectedElement, element.intValue());\n-                }\n-                \/\/ rewind for the sliding motion\n-                expectedElement -= (window.size() - 1);\n-            }\n-\n-            assertEquals(expectedNumberOfWindows, currentWindow);\n-        }\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"configurations\")\n-    public void testFoldAPIandContract(Config config) {\n-        \/\/ Verify prereqs\n-        assertThrows(NullPointerException.class, () -> Gatherers.<String,String>fold(null, (state, next) -> state));\n-        assertThrows(NullPointerException.class, () -> Gatherers.<String,String>fold(() -> \"\", null));\n-\n-        final var expectedResult = List.of(\n-                                       config.stream()\n-                                             .sequential()\n-                                             .reduce(\"\", (acc, next) -> acc + next, (l,r) -> { throw new IllegalStateException(); })\n-                                   );\n-\n-        final var result = config.stream()\n-                                 .gather(Gatherers.fold(() -> \"\", (acc, next) -> acc + next))\n-                                 .toList();\n-\n-        assertEquals(expectedResult, result);\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"configurations\")\n-    public void testMapConcurrentAPIandContract(Config config) throws InterruptedException {\n-        \/\/ Verify prereqs\n-        assertThrows(IllegalArgumentException.class, () -> Gatherers.<String, String>mapConcurrent(0, s -> s));\n-        assertThrows(NullPointerException.class, () -> Gatherers.<String, String>mapConcurrent(2, null));\n-\n-        \/\/ Test exception during processing\n-        {\n-            final var stream = config.parallel() ? Stream.of(1).parallel() : Stream.of(1);\n-\n-            assertThrows(RuntimeException.class,\n-                    () -> stream.gather(Gatherers.<Integer, Integer>mapConcurrent(2, x -> {\n-                        throw new RuntimeException();\n-                    })).toList());\n-        }\n-\n-        \/\/ Test cancellation after exception during processing\n-        if (config.streamSize > 2) { \/\/ We need streams of a minimum size to test this\n-            final var firstLatch = new CountDownLatch(1);\n-            final var secondLatch = new CountDownLatch(1);\n-            final var cancellationLatch = new CountDownLatch(config.streamSize - 2); \/\/ all but two will get cancelled\n-\n-            try {\n-                config.stream()\n-                      .gather(\n-                            Gatherers.mapConcurrent(config.streamSize(), i -> {\n-                                switch (i) {\n-                                    case 1 -> {\n-                                        try {\n-                                            firstLatch.await(); \/\/ the first waits for the last element to start\n-                                        } catch (InterruptedException ie) {\n-                                            throw new IllegalStateException(ie);\n-                                        }\n-                                        throw new TestException(\"expected\");\n-                                    }\n-\n-                                    case Integer n when n == config.streamSize - 1 -> { \/\/ last element\n-                                        firstLatch.countDown(); \/\/ ensure that the first element can now proceed\n-                                    }\n-\n-                                    default -> {\n-                                        try {\n-                                            secondLatch.await(); \/\/ These should all get interrupted\n-                                        } catch (InterruptedException ie) {\n-                                            cancellationLatch.countDown(); \/\/ used to ensure that they all were interrupted\n-                                        }\n-                                    }\n-                                }\n-\n-                                return i;\n-                            })\n-                      )\n-                      .toList();\n-                fail(\"This should not be reached\");\n-            } catch (RuntimeException re) {\n-                assertSame(TestException.class, re.getClass());\n-                assertEquals(\"expected\", re.getMessage());\n-                cancellationLatch.await();\n-                return;\n-            }\n-\n-            fail(\"This should not be reached\");\n-        }\n-\n-        \/\/ Test cancellation during short-circuiting\n-        if (config.streamSize > 2) {\n-            final var firstLatch = new CountDownLatch(1);\n-            final var secondLatch = new CountDownLatch(1);\n-            final var cancellationLatch = new CountDownLatch(config.streamSize - 2); \/\/ all but two will get cancelled\n-\n-            final var result =\n-                config.stream()\n-                      .gather(\n-                            Gatherers.mapConcurrent(config.streamSize(), i -> {\n-                                switch (i) {\n-                                    case 1 -> {\n-                                        try {\n-                                            firstLatch.await(); \/\/ the first waits for the last element to start\n-                                        } catch (InterruptedException ie) {\n-                                            throw new IllegalStateException(ie);\n-                                        }\n-                                    }\n-\n-                                    case Integer n when n == config.streamSize - 1 -> { \/\/ last element\n-                                        firstLatch.countDown(); \/\/ ensure that the first element can now proceed\n-                                    }\n-\n-                                    default -> {\n-                                        try {\n-                                            secondLatch.await(); \/\/ These should all get interrupted\n-                                        } catch (InterruptedException ie) {\n-                                            cancellationLatch.countDown(); \/\/ used to ensure that they all were interrupted\n-                                        }\n-                                    }\n-                                }\n-\n-                                return i;\n-                            })\n-                      )\n-                      .limit(2)\n-                      .toList();\n-            cancellationLatch.await(); \/\/ If this hangs, then we didn't cancel and interrupt the tasks\n-            assertEquals(List.of(1,2), result);\n-        }\n-\n-        for (var concurrency : List.of(1, 2, 3, 10, 1000)) {\n-            \/\/ Test normal operation\n-            {\n-                final var expectedResult = config.stream()\n-                                                 .map(x -> x * x)\n-                                                 .toList();\n-\n-                final var result = config.stream()\n-                                         .gather(Gatherers.mapConcurrent(concurrency, x -> x * x))\n-                                         .toList();\n-\n-                assertEquals(expectedResult, result);\n-            }\n-\n-            \/\/ Test short-circuiting\n-            {\n-                final var limitTo = Math.max(config.streamSize() \/ 2, 1);\n-\n-                final var expectedResult = config.stream()\n-                                                 .map(x -> x * x)\n-                                                 .limit(limitTo)\n-                                                 .toList();\n-\n-                final var result = config.stream()\n-                                         .gather(Gatherers.mapConcurrent(concurrency, x -> x * x))\n-                                         .limit(limitTo)\n-                                         .toList();\n-\n-                assertEquals(expectedResult, result);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/stream\/GatherersTest.java","additions":0,"deletions":368,"binary":false,"changes":368,"status":"deleted"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Gatherers;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.*;\n+\n+\/**\n+ * @test\n+ * @summary Tests the API and contract of Gatherers.windowFixed\n+ * @enablePreview\n+ * @run junit GatherersWindowFixedTest\n+ *\/\n+\n+public class GatherersWindowFixedTest {\n+\n+    record Config(int streamSize, boolean parallel) {\n+        Stream<Integer> stream() {\n+            var stream = Stream.iterate(1, i -> i + 1).limit(streamSize);\n+            stream = parallel ? stream.parallel() : stream.sequential();\n+            return stream;\n+        }\n+    }\n+\n+    static final Stream<Integer> sizes(){\n+        return Stream.of(0,1,10,33,99,9999);\n+    }\n+\n+    static final Stream<Config> sequentialAndParallel(int size) {\n+        return Stream.of(false, true)\n+                .map(parallel ->\n+                        new Config(size, parallel));\n+    }\n+\n+    static final Stream<Config> configurations() {\n+        return sizes().flatMap(i -> sequentialAndParallel(i));\n+    }\n+\n+    static final Stream<Config> nonempty_configurations() {\n+        return sizes().filter(i -> i > 0).flatMap(i -> sequentialAndParallel(i));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = { Integer.MIN_VALUE, -999, -1, 0})\n+    public void throwsIAEWhenWindowSizeIsSmallerThanOne(int windowSize) {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> Gatherers.windowFixed(windowSize));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonempty_configurations\")\n+    public void behavesAsExpectedWhenWindowSizeIsSizeOfStream(Config config) {\n+        final var streamSize = config.streamSize();\n+        final var result = config.stream()\n+                .gather(Gatherers.windowFixed(streamSize))\n+                .toList();\n+        assertEquals(1, result.size());\n+        assertEquals(config.stream().toList(), result.get(0));\n+    }\n+\n+    @Test\n+    public void toleratesNullElements() {\n+        assertEquals(\n+                List.of(Arrays.asList(null, null)),\n+                Stream.of(null, null)\n+                    .gather(Gatherers.windowFixed(2))\n+                    .toList());\n+    }\n+\n+    @Test\n+    public void throwsUOEWhenWindowsAreAttemptedToBeModified() {\n+        var window = Stream.of(1)\n+                .gather(Gatherers.windowFixed(1))\n+                .findFirst()\n+                .get();\n+        assertThrows(UnsupportedOperationException.class,\n+                () -> window.add(2));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void behavesAsExpected(Config config) {\n+        final var streamSize = config.streamSize();\n+        \/\/ Tests that the layout of the returned data is as expected\n+        for (var windowSize : List.of(1, 2, 3, 10)) {\n+            final var expectLastWindowSize = streamSize % windowSize == 0 ? windowSize : streamSize % windowSize;\n+            final var expectedSize = (streamSize \/ windowSize) + ((streamSize % windowSize == 0) ? 0 : 1);\n+\n+            final var expected = config.stream().toList().iterator();\n+\n+            final var result = config.stream()\n+                    .gather(Gatherers.windowFixed(windowSize))\n+                    .toList();\n+\n+            int currentWindow = 0;\n+            for (var window : result) {\n+                ++currentWindow;\n+                assertEquals(currentWindow < expectedSize ? windowSize : expectLastWindowSize, window.size());\n+                for (var element : window)\n+                    assertEquals(expected.next(), element);\n+            }\n+\n+            assertEquals(expectedSize, currentWindow);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/stream\/GatherersWindowFixedTest.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Gatherers;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.*;\n+\n+\/**\n+ * @test\n+ * @summary Tests the API and contract of Gatherers.windowSliding\n+ * @enablePreview\n+ * @run junit GatherersWindowSlidingTest\n+ *\/\n+\n+public class GatherersWindowSlidingTest {\n+\n+    record Config(int streamSize, boolean parallel) {\n+        Stream<Integer> stream() {\n+            var stream = Stream.iterate(1, i -> i + 1).limit(streamSize);\n+            stream = parallel ? stream.parallel() : stream.sequential();\n+            return stream;\n+        }\n+    }\n+\n+    static final Stream<Integer> sizes(){\n+        return Stream.of(0,1,10,33,99,9999);\n+    }\n+\n+    static final Stream<Config> sequentialAndParallel(int size) {\n+        return Stream.of(false, true)\n+                .map(parallel ->\n+                        new Config(size, parallel));\n+    }\n+\n+    static final Stream<Config> configurations() {\n+        return sizes().flatMap(i -> sequentialAndParallel(i));\n+    }\n+\n+    static final Stream<Config> nonempty_configurations() {\n+        return sizes().filter(i -> i > 0).flatMap(i -> sequentialAndParallel(i));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = { Integer.MIN_VALUE, -999, -1, 0})\n+    public void throwsIAEWhenWindowSizeIsSmallerThanOne(int windowSize) {\n+        assertThrows(IllegalArgumentException.class, () -> Gatherers.windowSliding(windowSize));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonempty_configurations\")\n+    public void behavesAsExpectedWhenWindowSizeIsLargerThanStreamSize(Config config) {\n+        final var streamSize = config.streamSize();\n+        final var result = config.stream()\n+                .gather(Gatherers.windowSliding(streamSize + 1))\n+                .toList();\n+        assertEquals(1, result.size());\n+        assertEquals(config.stream().toList(), result.get(0));\n+    }\n+\n+    @Test\n+    public void toleratesNullElements() {\n+        assertEquals(\n+                List.of(\n+                        Arrays.asList(null, null),\n+                        Arrays.asList(null, null)\n+                ),\n+                Stream.of(null, null, null)\n+                        .gather(Gatherers.windowSliding(2))\n+                        .toList());\n+    }\n+\n+    @Test\n+    public void throwsUOEWhenWindowsAreAttemptedToBeModified() {\n+        var window = Stream.of(1)\n+                .gather(Gatherers.windowSliding(1))\n+                .findFirst()\n+                .get();\n+        assertThrows(UnsupportedOperationException.class,\n+                () -> window.add(2));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    public void behavesAsExpected(Config config) {\n+        final var streamSize = config.streamSize();\n+        \/\/ Tests that the layout of the returned data is as expected\n+        for (var windowSize : List.of(1, 2, 3, 10)) {\n+            final var expectLastWindowSize = streamSize < windowSize ? streamSize : windowSize;\n+            final var expectedNumberOfWindows = streamSize == 0 ? 0 : Math.max(1, 1 + streamSize - windowSize);\n+\n+            int expectedElement = 0;\n+            int currentWindow = 0;\n+\n+            final var result = config.stream()\n+                    .gather(Gatherers.windowSliding(windowSize))\n+                    .toList();\n+\n+            for (var window : result) {\n+                ++currentWindow;\n+                assertEquals(currentWindow < expectedNumberOfWindows ? windowSize : expectLastWindowSize, window.size());\n+                for (var element : window) {\n+                    assertEquals(++expectedElement, element.intValue());\n+                }\n+                \/\/ rewind for the sliding motion\n+                expectedElement -= (window.size() - 1);\n+            }\n+\n+            assertEquals(expectedNumberOfWindows, currentWindow);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/stream\/GatherersWindowSlidingTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/util\/stream\/TEST.properties","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/util\/concurrent\/TEST.properties","status":"copied"}]}