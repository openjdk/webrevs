{"files":[{"patch":"@@ -214,1 +214,1 @@\n-            throw new RuntimeException(\" x = \" + Long.toHexString(x) + \", y = \" + Long.toHexString(y));\n+            throw new RuntimeException(\"expect x == y: x = \" + Long.toHexString(x) + \", y = \" + Long.toHexString(y));\n@@ -219,2 +219,11 @@\n-        if (x == x && y == y && x != y) {\n-            ck(x, y);\n+        \/\/ Check if x and y have identical values.\n+        \/\/ Remember: NaN == x is false for ANY x, including if x is NaN (IEEE standard).\n+        \/\/ Therefore, if x and y are NaN, x != y would return true, which is not what we want.\n+        \/\/ We do not want an Exception if both are NaN.\n+        \/\/ Hence, we only use x != y, if both are not NaN.\n+        \/\/ Additionally, we also check if exactly one of them is NaN, via XOR (^).\n+        if ((!Double.isNaN(x) && !Double.isNaN(y) && x != y) || (Double.isNaN(x) ^ Double.isNaN(y))) {\n+            throw new RuntimeException(\"expect x == y:\"\n+                                    + \"  x = \" + Double.toString(x) + \", y = \" + Double.toString(y)\n+                                    + \" (x = \" + Long.toHexString(Double.doubleToRawLongBits(x))\n+                                    + \", y = \" + Long.toHexString(Double.doubleToRawLongBits(y)) + \")\");\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/unsafe\/ByteBufferTest.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"}]}