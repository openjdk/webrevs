{"files":[{"patch":"@@ -1371,0 +1371,6 @@\n+  verify_type_stability(phase, t, ft);\n+\n+  \/\/ Deal with conversion problems found in data loops.\n+  ft = phase->saturate_and_maybe_push_to_igvn_worklist(this, ft);\n+  return ft;\n+}\n@@ -1373,15 +1379,8 @@\n-  const Type* ft_ = t->filter_speculative(ft);\n-  if (!Type::equals(ft, ft_)) {\n-    stringStream ss;\n-\n-    ss.print_cr(\"At node:\");\n-    this->dump(\"\\n\", false, &ss);\n-\n-    for (uint i = 1; i < req(); ++i) {\n-      ss.print(\"in(%d): \", i);\n-      if (r->in(i) != nullptr && phase->type(r->in(i)) == Type::CONTROL) {\n-        const Type* ti = phase->type(in(i));\n-        ti->dump_on(&ss);\n-      }\n-      ss.print_cr(\"\");\n-    }\n+\/\/ Makes sure that a newly computed type is stable when filtered against the incoming types.\n+\/\/ Otherwise, we may have IGVN verification failures. See PhiNode::Value, and the second\n+\/\/ filtering (enforcing stability), for details.\n+void PhiNode::verify_type_stability(const PhaseGVN* const phase, const Type* const union_of_input_types, const Type* const new_type) const {\n+  const Type* doubly_filtered_type = union_of_input_types->filter_speculative(new_type);\n+  if (Type::equals(new_type, doubly_filtered_type)) {\n+    return;\n+  }\n@@ -1389,3 +1388,1 @@\n-    ss.print(\"t: \");\n-    t->dump_on(&ss);\n-    ss.print_cr(\"\");\n+  stringStream ss;\n@@ -1393,3 +1390,2 @@\n-    ss.print(\"_type: \");\n-    _type->dump_on(&ss);\n-    ss.print_cr(\"\");\n+  ss.print_cr(\"At node:\");\n+  this->dump(\"\\n\", false, &ss);\n@@ -1397,5 +1393,7 @@\n-    ss.print(\"Filter once: \");\n-    ft->dump_on(&ss);\n-    ss.print_cr(\"\");\n-    ss.print(\"Filter twice: \");\n-    ft_->dump_on(&ss);\n+  const Node* region = in(Region);\n+  for (uint i = 1; i < req(); ++i) {\n+    ss.print(\"in(%d): \", i);\n+    if (region->in(i) != nullptr && phase->type(region->in(i)) == Type::CONTROL) {\n+      const Type* ti = phase->type(in(i));\n+      ti->dump_on(&ss);\n+    }\n@@ -1403,3 +1401,0 @@\n-    tty->print(\"%s\", ss.base());\n-    tty->flush();\n-    assert(false, \"computed type would not pass verification\");\n@@ -1407,1 +1402,0 @@\n-#endif\n@@ -1409,3 +1403,17 @@\n-  \/\/ Deal with conversion problems found in data loops.\n-  ft = phase->saturate_and_maybe_push_to_igvn_worklist(this, ft);\n-  return ft;\n+  ss.print(\"t: \");\n+  union_of_input_types->dump_on(&ss);\n+  ss.print_cr(\"\");\n+\n+  ss.print(\"_type: \");\n+  _type->dump_on(&ss);\n+  ss.print_cr(\"\");\n+\n+  ss.print(\"Filter once: \");\n+  new_type->dump_on(&ss);\n+  ss.print_cr(\"\");\n+  ss.print(\"Filter twice: \");\n+  doubly_filtered_type->dump_on(&ss);\n+  ss.print_cr(\"\");\n+  tty->print(\"%s\", ss.base());\n+  tty->flush();\n+  assert(false, \"computed type would not pass verification\");\n@@ -1413,0 +1421,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":42,"deletions":33,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -185,0 +185,1 @@\n+  void verify_type_stability(const PhaseGVN* phase, const Type* union_of_input_types, const Type* new_type) const NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}