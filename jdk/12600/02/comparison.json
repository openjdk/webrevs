{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2389,0 +2389,4 @@\n+     *\n+     * @apiNote An invocation of this method on a {@link String} {@code s}\n+     * is behaviorally equivalent to the invocation\n+     * {@code s.indexOf(ch, 0, s.length())}.\n@@ -2391,1 +2395,1 @@\n-        return indexOf(ch, 0);\n+        return indexOf(ch, 0, length());\n@@ -2432,0 +2436,4 @@\n+     *\n+     * @apiNote An invocation of this method on a {@link String} {@code s}\n+     * is behaviorally equivalent to the invocation\n+     * {@code s.indexOf(ch, fromIndex, s.length())}.\n@@ -2434,2 +2442,100 @@\n-        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex)\n-                          : StringUTF16.indexOf(value, ch, fromIndex);\n+        return indexOf(ch, fromIndex, length());\n+    }\n+\n+    \/**\n+     * Returns the index within this string of the first occurrence of the\n+     * specified character, starting the search at {@code fromIndex} and\n+     * stopping before {@code toIndex}.\n+     *\n+     * <p>If a character with value {@code ch} occurs in the\n+     * character sequence represented by this {@code String}\n+     * object at an index no smaller than {@code fromIndex} but smaller than\n+     * {@code toIndex}, then\n+     * the index of the first such occurrence is returned. For values\n+     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n+     * this is the smallest value <i>k<\/i> such that:\n+     * <blockquote><pre>\n+     * (this.charAt(<i>k<\/i>) == ch) &amp;&amp; (fromIndex &lt;= <i>k<\/i> &lt; toIndex)\n+     * <\/pre><\/blockquote>\n+     * is true. For other values of {@code ch}, it is the\n+     * smallest value <i>k<\/i> such that:\n+     * <blockquote><pre>\n+     * (this.codePointAt(<i>k<\/i>) == ch) &amp;&amp; (fromIndex &lt;= <i>k<\/i> &lt; toIndex)\n+     * <\/pre><\/blockquote>\n+     * is true. In either case, if no such character occurs in this\n+     * string at or after position {@code fromIndex} and before position\n+     * {@code toIndex}, then {@code -1} is returned.\n+     *\n+     * <p>There are no restrictions on the value of {@code fromIndex} and\n+     * {@code toIndex}. Negative values have the same effect as if they were zero.\n+     * Values greater than the length of this string have the same effect\n+     * as if they were equal to the length of this string.\n+     *\n+     * <p>As consequence of these rules, if {@code fromIndex} is greater than\n+     * or equal to {@code toIndex}, then {@code -1} is returned.\n+     *\n+     * <p>All indices are specified in {@code char} values\n+     * (Unicode code units).\n+     *\n+     * @param   ch          a character (Unicode code point).\n+     * @param   fromIndex   the index to start the search from (included).\n+     * @param   toIndex     the index to stop the search at (excluded).\n+     * @return  the index of the first occurrence of the character in the\n+     *          character sequence represented by this object that is greater\n+     *          than or equal to {@code fromIndex} and less than {@code toIndex},\n+     *          or {@code -1} if the character does not occur.\n+     * @since   21\n+     *\/\n+    public int indexOf(int ch, int fromIndex, int toIndex) {\n+        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex, toIndex)\n+                : StringUTF16.indexOf(value, ch, fromIndex, toIndex);\n+    }\n+\n+    \/**\n+     * Returns the index within this string of the first occurrence of the\n+     * specified character, starting the search at {@code fromIndex} and\n+     * stopping before {@code toIndex}.\n+     *\n+     * <p>If a character with value {@code ch} occurs in the\n+     * character sequence represented by this {@code String}\n+     * object at an index no smaller than {@code fromIndex} but smaller than\n+     * {@code toIndex}, then\n+     * the index of the first such occurrence is returned. For values\n+     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n+     * this is the smallest value <i>k<\/i> such that:\n+     * <blockquote><pre>\n+     * (this.charAt(<i>k<\/i>) == ch) &amp;&amp; (fromIndex &lt;= <i>k<\/i> &lt; toIndex)\n+     * <\/pre><\/blockquote>\n+     * is true. For other values of {@code ch}, it is the\n+     * smallest value <i>k<\/i> such that:\n+     * <blockquote><pre>\n+     * (this.codePointAt(<i>k<\/i>) == ch) &amp;&amp; (fromIndex &lt;= <i>k<\/i> &lt; toIndex)\n+     * <\/pre><\/blockquote>\n+     * is true. In either case, if no such character occurs in this\n+     * string at or after position {@code fromIndex} and before position\n+     * {@code toIndex}, then {@code -1} is returned.\n+     *\n+     * <p>All indices are specified in {@code char} values\n+     * (Unicode code units).\n+     *\n+     * @param   ch          a character (Unicode code point).\n+     * @param   fromIndex   the index to start the search from (included).\n+     * @param   toIndex     the index to stop the search at (excluded).\n+     * @return  the index of the first occurrence of the character in the\n+     *          character sequence represented by this object that is greater\n+     *          than or equal to {@code fromIndex} and less than {@code toIndex},\n+     *          or {@code -1} if the character does not occur.\n+     * @throws  StringIndexOutOfBoundsException if {@code fromIndex}\n+     *          is negative, or {@code toIndex} is larger than the length of\n+     *          this {@code String} object, or {@code fromIndex} is larger than\n+     *          {@code toIndex}.\n+     * @since   21\n+     *\n+     * @apiNote An invocation of this method on a {@link String} {@code s}\n+     * is behaviorally equivalent to first checking {@code fromIndex} and\n+     * {@code toIndex} as specified in the {@code @throws} clause, and then,\n+     * absent an exception, invoking {@code s.indexOf(ch, fromIndex, toIndex)}.\n+     *\/\n+    public int checkedIndexOf(int ch, int fromIndex, int toIndex) {\n+        checkBoundsBeginEnd(fromIndex, toIndex, length());\n+        return indexOf(ch, fromIndex, toIndex);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":110,"deletions":4,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -200,0 +200,4 @@\n+        return indexOf(value, ch, fromIndex, value.length);\n+    }\n+\n+    public static int indexOf(byte[] value, int ch, int fromIndex, int toIndex) {\n@@ -203,5 +207,3 @@\n-        int max = value.length;\n-        if (fromIndex < 0) {\n-            fromIndex = 0;\n-        } else if (fromIndex >= max) {\n-            \/\/ Note: fromIndex might be near -1>>>1.\n+        fromIndex = Math.max(fromIndex, 0);\n+        toIndex = Math.min(toIndex, value.length);\n+        if (fromIndex >= toIndex) {\n@@ -210,1 +212,1 @@\n-        return indexOfChar(value, ch, fromIndex, max);\n+        return indexOfChar(value, ch, fromIndex, toIndex);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -423,5 +423,7 @@\n-        int max = value.length >> 1;\n-        if (fromIndex < 0) {\n-            fromIndex = 0;\n-        } else if (fromIndex >= max) {\n-            \/\/ Note: fromIndex might be near -1>>>1.\n+        return indexOf(value, ch, fromIndex, value.length >> 1);\n+    }\n+\n+    public static int indexOf(byte[] value, int ch, int fromIndex, int toIndex) {\n+        fromIndex = Math.max(fromIndex, 0);\n+        toIndex = Math.min(toIndex, value.length >> 1);\n+        if (fromIndex >= toIndex) {\n@@ -433,1 +435,1 @@\n-            return indexOfChar(value, ch, fromIndex, max);\n+            return indexOfChar(value, ch, fromIndex, toIndex);\n@@ -435,1 +437,1 @@\n-            return indexOfSupplementary(value, ch, fromIndex, max);\n+            return indexOfSupplementary(value, ch, fromIndex, toIndex);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertThrows;\n+\n+\/*\n+ * @test\n+ * @bug 8302590\n+ * @summary This one is for String.indexOf(int,int,int).\n+ * @run testng\/othervm -XX:+CompactStrings IndexOfFromTo\n+ * @run testng\/othervm -XX:-CompactStrings IndexOfFromTo\n+ *\/\n+\n+public class IndexOfFromTo extends CompactString {\n+    private static final int MIN = Integer.MIN_VALUE;\n+    private static final int MAX = Integer.MAX_VALUE;\n+\n+    @DataProvider\n+    public Object[][] provider() {\n+        return new Object[][] {\n+\n+                new Object[] { STRING_EMPTY, (int) 'Z', MIN, MAX, -1 },\n+\n+                new Object[] { STRING_L1, (int) 'A', MIN, MAX, 0 },\n+                new Object[] { STRING_L1, (int) 'A', 1, MAX, -1 },\n+                new Object[] { STRING_L1, (int) 'A', MIN, 1, 0 },\n+                new Object[] { STRING_L1, (int) 'Z', MIN, MAX, -1 },\n+\n+                new Object[] { STRING_L2, (int) 'A', MIN, MAX, 0 },\n+                new Object[] { STRING_L2, (int) 'A', 0, 1, 0 },\n+                new Object[] { STRING_L2, (int) 'A', 1, 2, -1 },\n+                new Object[] { STRING_L2, (int) 'A', 1, MAX, -1 },\n+                new Object[] { STRING_L2, (int) 'B', MIN, MAX, 1 },\n+                new Object[] { STRING_L2, (int) 'B', 0, 1, -1 },\n+                new Object[] { STRING_L2, (int) 'B', 1, 2, 1 },\n+                new Object[] { STRING_L2, (int) 'B', 2, MAX, -1 },\n+                new Object[] { STRING_L2, (int) 'Z', MIN, MAX, -1 },\n+\n+                new Object[] { STRING_L4, (int) 'A', MIN, MAX, 0 },\n+                new Object[] { STRING_L4, (int) 'A', 0, 1, 0 },\n+                new Object[] { STRING_L4, (int) 'A', 1, 4, -1 },\n+                new Object[] { STRING_L4, (int) 'A', 1, MAX, -1 },\n+                new Object[] { STRING_L4, (int) 'D', MIN, MAX, 3 },\n+                new Object[] { STRING_L4, (int) 'D', 0, 3, -1 },\n+                new Object[] { STRING_L4, (int) 'D', 3, 4, 3 },\n+                new Object[] { STRING_L4, (int) 'D', 4, MAX, -1 },\n+                new Object[] { STRING_L4, (int) 'Z', MIN, MAX, -1 },\n+\n+                new Object[] { STRING_LLONG, (int) 'A', MIN, MAX, 0 },\n+                new Object[] { STRING_LLONG, (int) 'A', 0, 1, 0 },\n+                new Object[] { STRING_LLONG, (int) 'A', 1, 8, -1 },\n+                new Object[] { STRING_LLONG, (int) 'A', 1, MAX, -1 },\n+                new Object[] { STRING_LLONG, (int) 'H', MIN, MAX, 7 },\n+                new Object[] { STRING_LLONG, (int) 'H', 0, 7, -1 },\n+                new Object[] { STRING_LLONG, (int) 'H', 7, 8, 7 },\n+                new Object[] { STRING_LLONG, (int) 'H', 8, MAX, -1 },\n+                new Object[] { STRING_LLONG, (int) 'Z', MIN, MAX, -1 },\n+\n+                new Object[] { STRING_U1, (int) '\\uFF21', MIN, MAX, 0 },\n+                new Object[] { STRING_U1, (int) '\\uFF21', 1, MAX, -1 },\n+                new Object[] { STRING_U1, (int) '\\uFF21', MIN, 1, 0 },\n+                new Object[] { STRING_U1, (int) 'A', MIN, MAX, -1 },\n+\n+                new Object[] { STRING_U2, (int) '\\uFF21', MIN, MAX, 0 },\n+                new Object[] { STRING_U2, (int) '\\uFF21', 0, 1, 0 },\n+                new Object[] { STRING_U2, (int) '\\uFF21', 1, 2, -1 },\n+                new Object[] { STRING_U2, (int) '\\uFF21', 1, MAX, -1 },\n+                new Object[] { STRING_U2, (int) '\\uFF22', MIN, MAX, 1 },\n+                new Object[] { STRING_U2, (int) '\\uFF22', 0, 1, -1 },\n+                new Object[] { STRING_U2, (int) '\\uFF22', 1, 2, 1 },\n+                new Object[] { STRING_U2, (int) '\\uFF22', 2, MAX, -1 },\n+                new Object[] { STRING_U2, (int) '\\uFF3A', MIN, MAX, -1 },\n+\n+                new Object[] { STRING_LDUPLICATE, (int) 'A', MIN, MAX, 0 },\n+                new Object[] { STRING_LDUPLICATE, (int) 'A', 1, 3, 2 },\n+                new Object[] { STRING_LDUPLICATE, (int) 'A', 3, 5, 4 },\n+                new Object[] { STRING_LDUPLICATE, (int) 'B', MIN, MAX, 1 },\n+                new Object[] { STRING_LDUPLICATE, (int) 'B', 2, 4, 3 },\n+                new Object[] { STRING_LDUPLICATE, (int) 'B', 4, 6, 5 },\n+\n+                new Object[] { STRING_M11, (int) 'A', MIN, MAX, 0 },\n+                new Object[] { STRING_M11, (int) 'A', 0, 1, 0 },\n+                new Object[] { STRING_M11, (int) 'A', 1, 2, -1 },\n+                new Object[] { STRING_M11, (int) 'A', 2, MAX, -1 },\n+                new Object[] { STRING_M11, (int) '\\uFF21', MIN, MAX, 1 },\n+                new Object[] { STRING_M11, (int) '\\uFF21', 0, 1, -1 },\n+                new Object[] { STRING_M11, (int) '\\uFF21', 1, 2, 1 },\n+                new Object[] { STRING_M11, (int) '\\uFF21', 2, MAX, -1 },\n+                new Object[] { STRING_M11, (int) '\\uFF3A', MIN, MAX, -1 },\n+\n+                new Object[] { STRING_M12, (int) '\\uFF21', MIN, MAX, 0 },\n+                new Object[] { STRING_M12, (int) '\\uFF21', 0, 1, 0 },\n+                new Object[] { STRING_M12, (int) '\\uFF21', 1, 2, -1 },\n+                new Object[] { STRING_M12, (int) '\\uFF21', 2, MAX, -1 },\n+                new Object[] { STRING_M12, (int) 'A', MIN, MAX, 1 },\n+                new Object[] { STRING_M12, (int) 'A', 0, 1, -1 },\n+                new Object[] { STRING_M12, (int) 'A', 1, 2, 1 },\n+                new Object[] { STRING_M12, (int) 'A', 2, MAX, -1 },\n+                new Object[] { STRING_M12, (int) '\\uFF3A', MIN, MAX, -1 },\n+\n+                new Object[] { STRING_UDUPLICATE, (int) '\\uFF21', MIN, MAX, 0 },\n+                new Object[] { STRING_UDUPLICATE, (int) '\\uFF21', 1, 3, 2 },\n+                new Object[] { STRING_UDUPLICATE, (int) '\\uFF21', 3, 5, 4 },\n+                new Object[] { STRING_UDUPLICATE, (int) '\\uFF22', MIN, MAX, 1 },\n+                new Object[] { STRING_UDUPLICATE, (int) '\\uFF22', 2, 4, 3 },\n+                new Object[] { STRING_UDUPLICATE, (int) '\\uFF22', 4, 6, 5 },\n+\n+                new Object[] { STRING_SUPPLEMENTARY, 'A', MIN, MAX, 5 },\n+                new Object[] { STRING_SUPPLEMENTARY, 'A', 2, 6, 5 },\n+                new Object[] { STRING_SUPPLEMENTARY, 'A', 2, 4, -1 },\n+                new Object[] { STRING_SUPPLEMENTARY, '\\uFF21', MIN, MAX, 4 },\n+                new Object[] { STRING_SUPPLEMENTARY, '\\uFF21', 2, 6, 4 },\n+                new Object[] { STRING_SUPPLEMENTARY, '\\uFF21', 2, 4, -1 },\n+                new Object[] { STRING_SUPPLEMENTARY,\n+                        Character.toCodePoint('\\uD801', '\\uDC00'), MIN, MAX, 0 },\n+                new Object[] { STRING_SUPPLEMENTARY,\n+                        Character.toCodePoint('\\uD801', '\\uDC00'), 0, 3, 0 },\n+                new Object[] { STRING_SUPPLEMENTARY,\n+                        Character.toCodePoint('\\uD801', '\\uDC00'), 0, 1, -1 },\n+                new Object[] { STRING_SUPPLEMENTARY,\n+                        Character.toCodePoint('\\uD801', '\\uDC00'), 1, 4, -1 },\n+                new Object[] { STRING_SUPPLEMENTARY,\n+                        Character.toCodePoint('\\uD801', '\\uDC01'), MIN, MAX, 2 },\n+                new Object[] { STRING_SUPPLEMENTARY,\n+                        Character.toCodePoint('\\uD801', '\\uDC01'), 2, 5, 2 },\n+                new Object[] { STRING_SUPPLEMENTARY,\n+                        Character.toCodePoint('\\uD801', '\\uDC01'), 2, 3, -1 },\n+                new Object[] { STRING_SUPPLEMENTARY,\n+                        Character.toCodePoint('\\uD801', '\\uDC01'), 3, 6, -1 },\n+\n+                new Object[] { STRING_LDUPLICATE, 'A', 1, 0, -1},\n+                new Object[] { STRING_UDUPLICATE, 'A', 1, 0, -1},\n+                new Object[] { STRING_MDUPLICATE1, 'A', 1, 0, -1},\n+                new Object[] { STRING_MDUPLICATE2, 'A', 1, 0, -1},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"provider\")\n+    public void testIndexOf(String str, int ch, int from, int to, int expected) {\n+        map.get(str).forEach(\n+                (source, data) -> {\n+                    assertEquals(data.indexOf(ch, from, to), expected, String.format(\n+                            \"testing String(%s).indexOf(%d,%d,%d), source : %s, \",\n+                            escapeNonASCIIs(data), ch, from, to, source));\n+                });\n+    }\n+\n+    @Test(dataProvider = \"provider\")\n+    public void testCheckedIndexOf(String str, int ch, int from, int to, int expected) {\n+        map.get(str).forEach(\n+                (source, data) -> {\n+                    if (0 <= from && from <= to && to <= data.length()) {\n+                        assertEquals(data.checkedIndexOf(ch, from, to), expected,\n+                                String.format(\"testing String(%s).checkedIndexOf(%d,%d,%d), source : %s, \",\n+                                        escapeNonASCIIs(data), ch, from, to, source));\n+                    } else {\n+                        assertThrows(StringIndexOutOfBoundsException.class,\n+                                () -> data.checkedIndexOf(ch, from, to));\n+                    }\n+                });\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/String\/CompactString\/IndexOfFromTo.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"}]}