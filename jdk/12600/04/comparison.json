{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2432,0 +2432,9 @@\n+     *\n+     * @apiNote\n+     * Rather than throwing an exception, this method returns -1 when\n+     * {@code fromIndex} is larger than the length of the string. This result is\n+     * indistinguishable from a genuine absence of {@code ch} in the string.\n+     * If stricter behavior is needed, {@link #indexOf(int, int, int)}\n+     * should be considered instead. On a string {@code s}, for example,\n+     * {@code s.indexOf(ch, fromIndex, s.length())} would throw if\n+     * {@code fromIndex} were larger than the string length, or even negative.\n@@ -2434,2 +2443,48 @@\n-        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex)\n-                          : StringUTF16.indexOf(value, ch, fromIndex);\n+        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex, value.length)\n+                : StringUTF16.indexOf(value, ch, fromIndex, value.length >> 1);\n+    }\n+\n+    \/**\n+     * Returns the index within this string of the first occurrence of the\n+     * specified character, starting the search at {@code fromIndex} and\n+     * stopping before {@code toIndex}.\n+     *\n+     * <p>If a character with value {@code ch} occurs in the\n+     * character sequence represented by this {@code String}\n+     * object at an index no smaller than {@code fromIndex} but smaller than\n+     * {@code toIndex}, then\n+     * the index of the first such occurrence is returned. For values\n+     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n+     * this is the smallest value <i>k<\/i> such that:\n+     * <blockquote><pre>\n+     * (this.charAt(<i>k<\/i>) == ch) &amp;&amp; (fromIndex &lt;= <i>k<\/i> &lt; toIndex)\n+     * <\/pre><\/blockquote>\n+     * is true. For other values of {@code ch}, it is the\n+     * smallest value <i>k<\/i> such that:\n+     * <blockquote><pre>\n+     * (this.codePointAt(<i>k<\/i>) == ch) &amp;&amp; (fromIndex &lt;= <i>k<\/i> &lt; toIndex)\n+     * <\/pre><\/blockquote>\n+     * is true. In either case, if no such character occurs in this\n+     * string at or after position {@code fromIndex} and before position\n+     * {@code toIndex}, then {@code -1} is returned.\n+     *\n+     * <p>All indices are specified in {@code char} values\n+     * (Unicode code units).\n+     *\n+     * @param   ch          a character (Unicode code point).\n+     * @param   fromIndex   the index to start the search from (included).\n+     * @param   toIndex     the index to stop the search at (excluded).\n+     * @return  the index of the first occurrence of the character in the\n+     *          character sequence represented by this object that is greater\n+     *          than or equal to {@code fromIndex} and less than {@code toIndex},\n+     *          or {@code -1} if the character does not occur.\n+     * @throws  StringIndexOutOfBoundsException if {@code fromIndex}\n+     *          is negative, or {@code toIndex} is larger than the length of\n+     *          this {@code String} object, or {@code fromIndex} is larger than\n+     *          {@code toIndex}.\n+     * @since   21\n+     *\/\n+    public int indexOf(int ch, int fromIndex, int toIndex) {\n+        checkBoundsBeginEnd(fromIndex, toIndex, length());\n+        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex, toIndex)\n+                : StringUTF16.indexOf(value, ch, fromIndex, toIndex);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":58,"deletions":3,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-    public static int indexOf(byte[] value, int ch, int fromIndex) {\n+    public static int indexOf(byte[] value, int ch, int fromIndex, int toIndex) {\n@@ -203,5 +203,3 @@\n-        int max = value.length;\n-        if (fromIndex < 0) {\n-            fromIndex = 0;\n-        } else if (fromIndex >= max) {\n-            \/\/ Note: fromIndex might be near -1>>>1.\n+        fromIndex = Math.max(fromIndex, 0);\n+        toIndex = Math.min(toIndex, value.length);\n+        if (fromIndex >= toIndex) {\n@@ -210,1 +208,1 @@\n-        return indexOfChar(value, ch, fromIndex, max);\n+        return indexOfChar(value, ch, fromIndex, toIndex);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -422,6 +422,4 @@\n-    public static int indexOf(byte[] value, int ch, int fromIndex) {\n-        int max = value.length >> 1;\n-        if (fromIndex < 0) {\n-            fromIndex = 0;\n-        } else if (fromIndex >= max) {\n-            \/\/ Note: fromIndex might be near -1>>>1.\n+    public static int indexOf(byte[] value, int ch, int fromIndex, int toIndex) {\n+        fromIndex = Math.max(fromIndex, 0);\n+        toIndex = Math.min(toIndex, value.length >> 1);\n+        if (fromIndex >= toIndex) {\n@@ -433,1 +431,1 @@\n-            return indexOfChar(value, ch, fromIndex, max);\n+            return indexOfChar(value, ch, fromIndex, toIndex);\n@@ -435,1 +433,1 @@\n-            return indexOfSupplementary(value, ch, fromIndex, max);\n+            return indexOfSupplementary(value, ch, fromIndex, toIndex);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertThrows;\n+\n+\/*\n+ * @test\n+ * @bug 8302590\n+ * @summary This one is for String.indexOf(int,int,int).\n+ * @run testng\/othervm -XX:+CompactStrings IndexOfFromTo\n+ * @run testng\/othervm -XX:-CompactStrings IndexOfFromTo\n+ *\/\n+\n+public class IndexOfFromTo extends CompactString {\n+\n+    @DataProvider\n+    public Object[][] results() {\n+        return new Object[][] {\n+\n+                new Object[] { STRING_EMPTY, (int) 'Z', 0, 0, -1 },\n+\n+                new Object[] { STRING_L1, (int) 'A', 0, 1, 0 },\n+                new Object[] { STRING_L1, (int) 'A', 1, 1, -1 },\n+                new Object[] { STRING_L1, (int) 'Z', 0, 1, -1 },\n+\n+                new Object[] { STRING_L2, (int) 'A', 0, 2, 0 },\n+                new Object[] { STRING_L2, (int) 'A', 0, 1, 0 },\n+                new Object[] { STRING_L2, (int) 'A', 1, 1, -1 },\n+                new Object[] { STRING_L2, (int) 'A', 1, 2, -1 },\n+                new Object[] { STRING_L2, (int) 'B', 0, 2, 1 },\n+                new Object[] { STRING_L2, (int) 'B', 0, 1, -1 },\n+                new Object[] { STRING_L2, (int) 'B', 1, 1, -1 },\n+                new Object[] { STRING_L2, (int) 'B', 1, 2, 1 },\n+                new Object[] { STRING_L2, (int) 'B', 2, 2, -1 },\n+                new Object[] { STRING_L2, (int) 'Z', 0, 2, -1 },\n+\n+                new Object[] { STRING_L4, (int) 'A', 0, 4, 0 },\n+                new Object[] { STRING_L4, (int) 'A', 0, 1, 0 },\n+                new Object[] { STRING_L4, (int) 'A', 1, 4, -1 },\n+                new Object[] { STRING_L4, (int) 'D', 0, 4, 3 },\n+                new Object[] { STRING_L4, (int) 'D', 0, 3, -1 },\n+                new Object[] { STRING_L4, (int) 'D', 3, 4, 3 },\n+                new Object[] { STRING_L4, (int) 'D', 4, 4, -1 },\n+                new Object[] { STRING_L4, (int) 'Z', 0, 4, -1 },\n+\n+                new Object[] { STRING_LLONG, (int) 'A', 0, 8, 0 },\n+                new Object[] { STRING_LLONG, (int) 'A', 0, 1, 0 },\n+                new Object[] { STRING_LLONG, (int) 'A', 1, 1, -1 },\n+                new Object[] { STRING_LLONG, (int) 'A', 1, 8, -1 },\n+                new Object[] { STRING_LLONG, (int) 'H', 0, 8, 7 },\n+                new Object[] { STRING_LLONG, (int) 'H', 0, 7, -1 },\n+                new Object[] { STRING_LLONG, (int) 'H', 7, 8, 7 },\n+                new Object[] { STRING_LLONG, (int) 'H', 8, 8, -1 },\n+                new Object[] { STRING_LLONG, (int) 'Z', 0, 8, -1 },\n+\n+                new Object[] { STRING_U1, (int) '\\uFF21', 0, 1, 0 },\n+                new Object[] { STRING_U1, (int) '\\uFF21', 0, 0, -1 },\n+                new Object[] { STRING_U1, (int) '\\uFF21', 1, 1, -1 },\n+                new Object[] { STRING_U1, (int) 'A', 0, 1, -1 },\n+\n+                new Object[] { STRING_U2, (int) '\\uFF21', 0, 2, 0 },\n+                new Object[] { STRING_U2, (int) '\\uFF21', 0, 1, 0 },\n+                new Object[] { STRING_U2, (int) '\\uFF21', 1, 2, -1 },\n+                new Object[] { STRING_U2, (int) '\\uFF22', 0, 2, 1 },\n+                new Object[] { STRING_U2, (int) '\\uFF22', 0, 1, -1 },\n+                new Object[] { STRING_U2, (int) '\\uFF22', 1, 2, 1 },\n+                new Object[] { STRING_U2, (int) '\\uFF22', 2, 2, -1 },\n+                new Object[] { STRING_U2, (int) '\\uFF3A', 0, 2, -1 },\n+\n+                new Object[] { STRING_LDUPLICATE, (int) 'A', 0, 10, 0 },\n+                new Object[] { STRING_LDUPLICATE, (int) 'A', 1, 3, 2 },\n+                new Object[] { STRING_LDUPLICATE, (int) 'A', 3, 3, -1 },\n+                new Object[] { STRING_LDUPLICATE, (int) 'A', 3, 5, 4 },\n+                new Object[] { STRING_LDUPLICATE, (int) 'B', 0, 10, 1 },\n+                new Object[] { STRING_LDUPLICATE, (int) 'B', 2, 4, 3 },\n+                new Object[] { STRING_LDUPLICATE, (int) 'B', 4, 6, 5 },\n+\n+                new Object[] { STRING_M11, (int) 'A', 0, 2, 0 },\n+                new Object[] { STRING_M11, (int) 'A', 0, 1, 0 },\n+                new Object[] { STRING_M11, (int) 'A', 1, 2, -1 },\n+                new Object[] { STRING_M11, (int) 'A', 2, 2, -1 },\n+                new Object[] { STRING_M11, (int) '\\uFF21', 0, 2, 1 },\n+                new Object[] { STRING_M11, (int) '\\uFF21', 0, 1, -1 },\n+                new Object[] { STRING_M11, (int) '\\uFF21', 1, 2, 1 },\n+                new Object[] { STRING_M11, (int) '\\uFF21', 2, 2, -1 },\n+                new Object[] { STRING_M11, (int) '\\uFF3A', 0, 2, -1 },\n+\n+                new Object[] { STRING_M12, (int) '\\uFF21', 0, 2, 0 },\n+                new Object[] { STRING_M12, (int) '\\uFF21', 0, 1, 0 },\n+                new Object[] { STRING_M12, (int) '\\uFF21', 1, 2, -1 },\n+                new Object[] { STRING_M12, (int) '\\uFF21', 2, 2, -1 },\n+                new Object[] { STRING_M12, (int) 'A', 0, 2, 1 },\n+                new Object[] { STRING_M12, (int) 'A', 0, 1, -1 },\n+                new Object[] { STRING_M12, (int) 'A', 1, 2, 1 },\n+                new Object[] { STRING_M12, (int) 'A', 2, 2, -1 },\n+                new Object[] { STRING_M12, (int) '\\uFF3A', 0, 2, -1 },\n+\n+                new Object[] { STRING_UDUPLICATE, (int) '\\uFF21', 0, 10, 0 },\n+                new Object[] { STRING_UDUPLICATE, (int) '\\uFF21', 1, 3, 2 },\n+                new Object[] { STRING_UDUPLICATE, (int) '\\uFF21', 3, 3, -1 },\n+                new Object[] { STRING_UDUPLICATE, (int) '\\uFF21', 3, 5, 4 },\n+                new Object[] { STRING_UDUPLICATE, (int) '\\uFF22', 0, 10, 1 },\n+                new Object[] { STRING_UDUPLICATE, (int) '\\uFF22', 2, 4, 3 },\n+                new Object[] { STRING_UDUPLICATE, (int) '\\uFF22', 4, 6, 5 },\n+\n+                new Object[] { STRING_SUPPLEMENTARY, 'A', 0, 6, 5 },\n+                new Object[] { STRING_SUPPLEMENTARY, 'A', 2, 6, 5 },\n+                new Object[] { STRING_SUPPLEMENTARY, 'A', 2, 4, -1 },\n+                new Object[] { STRING_SUPPLEMENTARY, 'A', 4, 4, -1 },\n+                new Object[] { STRING_SUPPLEMENTARY, '\\uFF21', 0, 6, 4 },\n+                new Object[] { STRING_SUPPLEMENTARY, '\\uFF21', 2, 2, -1 },\n+                new Object[] { STRING_SUPPLEMENTARY, '\\uFF21', 2, 6, 4 },\n+                new Object[] { STRING_SUPPLEMENTARY, '\\uFF21', 2, 4, -1 },\n+                new Object[] { STRING_SUPPLEMENTARY,\n+                        Character.toCodePoint('\\uD801', '\\uDC00'), 0, 6, 0 },\n+                new Object[] { STRING_SUPPLEMENTARY,\n+                        Character.toCodePoint('\\uD801', '\\uDC00'), 0, 3, 0 },\n+                new Object[] { STRING_SUPPLEMENTARY,\n+                        Character.toCodePoint('\\uD801', '\\uDC00'), 0, 1, -1 },\n+                new Object[] { STRING_SUPPLEMENTARY,\n+                        Character.toCodePoint('\\uD801', '\\uDC00'), 1, 4, -1 },\n+                new Object[] { STRING_SUPPLEMENTARY,\n+                        Character.toCodePoint('\\uD801', '\\uDC01'), 0, 6, 2 },\n+                new Object[] { STRING_SUPPLEMENTARY,\n+                        Character.toCodePoint('\\uD801', '\\uDC01'), 2, 2, -1 },\n+                new Object[] { STRING_SUPPLEMENTARY,\n+                        Character.toCodePoint('\\uD801', '\\uDC01'), 2, 5, 2 },\n+                new Object[] { STRING_SUPPLEMENTARY,\n+                        Character.toCodePoint('\\uD801', '\\uDC01'), 2, 3, -1 },\n+                new Object[] { STRING_SUPPLEMENTARY,\n+                        Character.toCodePoint('\\uD801', '\\uDC01'), 3, 6, -1 },\n+        };\n+    }\n+\n+    @DataProvider\n+    public Object[][] exceptions() {\n+        return new Object[][]{\n+                new Object[]{STRING_LDUPLICATE, 'A', -1, 0},\n+                new Object[]{STRING_LDUPLICATE, 'A', 0, 100},\n+                new Object[]{STRING_LDUPLICATE, 'A', -1, 100},\n+                new Object[]{STRING_LDUPLICATE, 'A', 3, 1},\n+\n+                new Object[]{STRING_UDUPLICATE, 'A', -1, 0},\n+                new Object[]{STRING_UDUPLICATE, 'A', 0, 100},\n+                new Object[]{STRING_UDUPLICATE, 'A', -1, 100},\n+                new Object[]{STRING_UDUPLICATE, 'A', 3, 1},\n+\n+                new Object[]{STRING_MDUPLICATE1, 'A', -1, 0},\n+                new Object[]{STRING_MDUPLICATE1, 'A', 0, 100},\n+                new Object[]{STRING_MDUPLICATE1, 'A', -1, 100},\n+                new Object[]{STRING_MDUPLICATE1, 'A', 3, 1},\n+\n+                new Object[]{STRING_MDUPLICATE2, 'A', -1, 0},\n+                new Object[]{STRING_MDUPLICATE2, 'A', 0, 100},\n+                new Object[]{STRING_MDUPLICATE2, 'A', -1, 100},\n+                new Object[]{STRING_MDUPLICATE2, 'A', 3, 1},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"results\")\n+    public void testIndexOf(String str, int ch, int from, int to, int expected) {\n+        map.get(str).forEach(\n+                (source, data) -> {\n+                    assertEquals(data.indexOf(ch, from, to), expected,\n+                            String.format(\"testing String(%s).indexOf(%d,%d,%d), source : %s, \",\n+                                    escapeNonASCIIs(data), ch, from, to, source));\n+                });\n+    }\n+\n+    @Test(dataProvider = \"exceptions\")\n+    public void testIndexOf(String str, int ch, int from, int to) {\n+        map.get(str).forEach(\n+                (source, data) -> {\n+                    assertThrows(StringIndexOutOfBoundsException.class,\n+                            () -> data.indexOf(ch, from, to));\n+                });\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/String\/CompactString\/IndexOfFromTo.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"}]}