{"files":[{"patch":"@@ -1225,1 +1225,6 @@\n-            if (entryPos + nlen > cen.length - ENDHDR) {\n+            long headerSize = (long)CENHDR + nlen + clen + elen;\n+            \/\/ CEN header size + name length + comment length + extra length\n+            \/\/ should not exceed 65,535 bytes per the PKWare APP.NOTE\n+            \/\/ 4.4.10, 4.4.11, & 4.4.12.  Also check that current CEN header will\n+            \/\/ not exceed the length of the CEN array\n+            if (headerSize > 0xFFFF || pos + headerSize > cen.length - ENDHDR) {\n@@ -1230,5 +1235,1 @@\n-                long extraStartingOffset = pos + CENHDR + nlen;\n-                if ((int)extraStartingOffset != extraStartingOffset) {\n-                    zerror(\"invalid CEN header (bad extra offset)\");\n-                }\n-                checkExtraFields(pos, (int)extraStartingOffset, elen);\n+                checkExtraFields(pos, entryPos + nlen, elen);\n@@ -1295,1 +1296,1 @@\n-                int tagBlockEndingOffset = currentOffset + tagBlockSize;\n+                long tagBlockEndingOffset = (long)currentOffset + tagBlockSize;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1596,2 +1596,7 @@\n-            if (pos + CENHDR + nlen > limit) {\n-                throw new ZipException(\"invalid CEN header (bad header size)\");\n+            long headerSize = (long)CENHDR + nlen + clen + elen;\n+            \/\/ CEN header size + name length + comment length + extra length\n+            \/\/ should not exceed 65,535 bytes per the PKWare APP.NOTE\n+            \/\/ 4.4.10, 4.4.11, & 4.4.12.  Also check that current CEN header will\n+            \/\/ not exceed the length of the CEN array\n+            if (headerSize > 0xFFFF || pos + headerSize > limit) {\n+                zerror(\"invalid CEN header (bad header size)\");\n@@ -1663,1 +1668,1 @@\n-            int tagBlockEndingOffset = currentOffset + tagBlockSize;\n+            long tagBlockEndingOffset = (long)currentOffset + tagBlockSize;\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 4770745 6218846 6218848 6237956 8313765\n+ * @bug 4770745 6218846 6218848 6237956 8313765 8316141\n@@ -265,1 +265,1 @@\n-        assertZipException(\".*extra data field size too long.*\");\n+        assertZipException(\".*bad header size.*\");\n@@ -276,1 +276,1 @@\n-        assertZipException(\".*extra data field size too long.*\");\n+        assertZipException(\".*bad header size.*\");\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CorruptedZipFiles.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,312 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8316141\n+ * @summary test for correct detection and reporting of corrupted zip files\n+ * @run junit CorruptedZipFilesTest\n+ *\/\n+\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipOutputStream;\n+\n+import static java.util.zip.ZipFile.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class CorruptedZipFilesTest {\n+\n+    \/*\n+     * Byte array holding a valid template ZIP.\n+     *\n+     * The 'good' ZIP file has the following structure:\n+     *\n+     * 0000 LOCAL HEADER #1       04034B50\n+     * 0004 Extract Zip Spec      14 '2.0'\n+     * 0005 Extract OS            00 'MS-DOS'\n+     * 0006 General Purpose Flag  0808\n+     *      [Bits 1-2]            0 'Normal Compression'\n+     *      [Bit  3]              1 'Streamed'\n+     *      [Bit 11]              1 'Language Encoding'\n+     * 0008 Compression Method    0008 'Deflated'\n+     * 000A Last Mod Time         567F7D07 'Fri Mar 31 15:40:14 2023'\n+     * 000E CRC                   00000000\n+     * 0012 Compressed Length     00000000\n+     * 0016 Uncompressed Length   00000000\n+     * 001A Filename Length       0001\n+     * 001C Extra Length          0000\n+     * 001E Filename              'x'\n+     * 001F PAYLOAD               ...\n+     *\n+     * 0022 STREAMING DATA HEADER 08074B50\n+     * 0026 CRC                   8CDC1683\n+     * 002A Compressed Length     00000003\n+     * 002E Uncompressed Length   00000001\n+     *\n+     * 0032 CENTRAL HEADER #1     02014B50\n+     * 0036 Created Zip Spec      14 '2.0'\n+     * 0037 Created OS            00 'MS-DOS'\n+     * 0038 Extract Zip Spec      14 '2.0'\n+     * 0039 Extract OS            00 'MS-DOS'\n+     * 003A General Purpose Flag  0808\n+     *      [Bits 1-2]            0 'Normal Compression'\n+     *      [Bit  3]              1 'Streamed'\n+     *      [Bit 11]              1 'Language Encoding'\n+     * 003C Compression Method    0008 'Deflated'\n+     * 003E Last Mod Time         567F7D07 'Fri Mar 31 15:40:14 2023'\n+     * 0042 CRC                   8CDC1683\n+     * 0046 Compressed Length     00000003\n+     * 004A Uncompressed Length   00000001\n+     * 004E Filename Length       0001\n+     * 0050 Extra Length          0000\n+     * 0052 Comment Length        0000\n+     * 0054 Disk Start            0000\n+     * 0056 Int File Attributes   0000\n+     *      [Bit 0]               0 'Binary Data'\n+     * 0058 Ext File Attributes   00000000\n+     * 005C Local Header Offset   00000000\n+     * 0060 Filename              'x'\n+     *\n+     * 0061 END CENTRAL HEADER    06054B50\n+     * 0065 Number of this disk   0000\n+     * 0067 Central Dir Disk no   0000\n+     * 0069 Entries in this disk  0001\n+     * 006B Total Entries         0001\n+     * 006D Size of Central Dir   0000002F\n+     * 0071 Offset to Central Dir 00000032\n+     * 0075 Comment Length        0000\n+     *\n+     *\/\n+    private static byte[] template;\n+\n+    \/\/ Copy of the template ZIP for modification by each test\n+    private byte[] copy;\n+\n+    \/\/ Litte-endian ByteBuffer for manipulating the ZIP copy\n+    private ByteBuffer buffer;\n+\n+    \/\/ Some well-known locations in the ZIP\n+    private static int endpos, cenpos, locpos;\n+\n+    \/\/ The path used when reading\/writing the corrupted ZIP to disk\n+    private Path zip = Path.of(\"corrupted.zip\");\n+\n+    \/*\n+     * Make a sample ZIP and calculate some known offsets into this ZIP\n+     *\/\n+    @BeforeAll\n+    public static void setup() throws IOException {\n+        \/\/ Make a ZIP with a single entry\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        try (ZipOutputStream zos = new ZipOutputStream(out)) {\n+            ZipEntry e = new ZipEntry(\"x\");\n+            zos.putNextEntry(e);\n+            zos.write((int)'x');\n+        }\n+        template = out.toByteArray();\n+        \/\/ ByteBuffer for reading fields from the ZIP\n+        ByteBuffer buffer = ByteBuffer.wrap(template).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        \/\/ Calculate the offset of the End of central directory record\n+        endpos = template.length - ENDHDR;\n+        \/\/ Look up the offet of the Central directory header\n+        cenpos = buffer.getShort(endpos + ENDOFF);\n+        \/\/ Look up the offset of the corresponding Local file header\n+        locpos = buffer.getShort(cenpos + CENOFF);\n+\n+        \/\/ Run some sanity checks on the valid ZIP:\n+        assertEquals(ENDSIG, buffer.getInt(endpos),\"Where's ENDSIG?\");\n+        assertEquals(CENSIG, buffer.getInt(cenpos),\"Where's CENSIG?\");\n+        assertEquals(LOCSIG, buffer.getInt(locpos),\"Where's LOCSIG?\");\n+        assertEquals(buffer.getShort(cenpos+CENNAM),\n+                buffer.getShort(locpos+LOCNAM),\n+                \"Name field length mismatch\");\n+        assertEquals(buffer.getShort(cenpos+CENEXT),\n+                buffer.getShort( locpos+LOCEXT),\n+                \"Extra field length mismatch\");\n+    }\n+\n+    \/*\n+     * Make a copy safe to modify by each test\n+     *\/\n+    @BeforeEach\n+    public void makeCopy() {\n+        copy = template.clone();\n+        buffer = ByteBuffer.wrap(copy).order(ByteOrder.LITTLE_ENDIAN);\n+    }\n+\n+    \/*\n+     * Delete the ZIP file produced after each test method\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/*\n+     * A ZipException is thrown when the 'End of Central Directory'\n+     * (END) header has a CEN size exceeding past the offset of the END record\n+     *\/\n+    @Test\n+    public void excessiveCENSize() throws IOException {\n+        buffer.putInt(endpos+ENDSIZ, 0xff000000);\n+        assertZipException(\".*bad central directory size.*\");\n+    }\n+\n+    \/*\n+     * A ZipException is thrown when the 'End of Central Directory'\n+     * (END) header has a CEN offset with an invalid value.\n+     *\/\n+    @Test\n+    public void excessiveCENOffset() throws IOException {\n+        buffer.putInt(endpos+ENDOFF, 0xff000000);\n+        assertZipException(\".*bad central directory offset.*\");\n+    }\n+\n+    \/*\n+     * A ZipException is thrown when a CEN header has an unexpected signature\n+     *\/\n+    @Test\n+    public void invalidCENSignature() throws IOException {\n+        int existingSignature = buffer.getInt(cenpos);\n+        buffer.putInt(cenpos, existingSignature +1);\n+        assertZipException(\".*bad signature.*\");\n+    }\n+\n+    \/*\n+     * A ZipException is thrown when a CEN header has the\n+     * 'general purpose bit flag 0' ('encrypted') set.\n+     *\/\n+    @Test\n+    public void encryptedEntry() throws IOException {\n+        copy[cenpos+CENFLG] |= 1;\n+        assertZipException(\".*encrypted entry.*\");\n+    }\n+\n+    \/*\n+     * A ZipException is thrown when a CEN header has a file name\n+     *  length which makes the CEN header overflow into the\n+     * 'End of central directory' record.\n+     *\/\n+    @Test\n+    public void excessiveFileNameLength() throws IOException {\n+        short existingNameLength = buffer.getShort(cenpos + CENNAM);\n+        buffer.putShort(cenpos+CENNAM, (short) (existingNameLength + 1));\n+        assertZipException(\".*bad header size.*\");\n+    }\n+\n+    \/*\n+     * A ZipException is thrown when a CEN header has a\n+     * file name length which makes the CEN header overflow into the\n+     * 'End of central directory' record.\n+     *\/\n+    @Test\n+    public void excessiveFileNameLength2() throws IOException {\n+        buffer.putShort(cenpos + CENNAM, (short) 0xfdfd);\n+        assertZipException(\".*bad header size.*\");\n+    }\n+\n+    \/*\n+     * A ZipException is thrown if a CEN header has an\n+     * extra field length which makes the CEN header overflow into the\n+     * End of central directory record.\n+     *\/\n+    @Test\n+    public void excessiveExtraFieldLength() throws IOException {\n+        buffer.put(cenpos+CENEXT, (byte) 0xff);\n+        buffer.put(cenpos+CENEXT+1, (byte) 0xff);\n+        assertZipException(\".*bad header size.*\");\n+    }\n+\n+    \/*\n+     * A ZipException is thrown by Zip FS if a CEN header has an\n+     * extra field length which makes the CEN header overflow into the\n+     * End of central directory record.\n+     *\/\n+    @Test\n+    public void excessiveExtraFieldLength2() throws IOException {\n+        buffer.putShort(cenpos+CENEXT, (short) 0xfdfd);\n+        assertZipException(\".*bad header size.*\");\n+    }\n+\n+    \/*\n+     * A ZipException is thrown when a CEN header has a comment length\n+     * which overflows into the 'End of central directory' record\n+     *\/\n+    @Test\n+    public void excessiveCommentLength() throws IOException {\n+        short existingCommentLength = buffer.getShort(cenpos + CENCOM);\n+        buffer.putShort(cenpos+CENCOM, (short) (existingCommentLength + 1));\n+        assertZipException(\".*bad header size.*\");\n+    }\n+\n+    \/*\n+     * A ZipException is thrown when a CEN header has a\n+     * compression method field which is unsupported by the implementation\n+     *\/\n+    @Test\n+    public void unsupportedCompressionMethod() throws IOException {\n+        copy[cenpos+CENHOW] = 2;\n+        assertZipException(\".*unsupported compression method.*\");\n+    }\n+\n+    \/*\n+     * Assert that opening a ZIP file and consuming the entry's\n+     * InputStream using the ZipFile API fails with a ZipException\n+     * with a message matching the given pattern.\n+     *\n+     * The ZIP file opened is the contents of the 'copy' byte array.\n+     *\/\n+    void assertZipException(String msgPattern) throws IOException {\n+\n+        Files.write(zip, copy);\n+\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n+            try (FileSystem fs = FileSystems.newFileSystem(zip, Map.of())) {\n+                Path p = fs.getPath(\"x\");\n+                try (InputStream is = Files.newInputStream(p)) {\n+                    is.transferTo(OutputStream.nullOutputStream());\n+                }\n+            }\n+        });\n+        assertTrue(ex.getMessage().matches(msgPattern),\n+                \"Unexpected ZipException message: \" + ex.getMessage());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/CorruptedZipFilesTest.java","additions":312,"deletions":0,"binary":false,"changes":312,"status":"added"}]}