{"files":[{"patch":"@@ -707,0 +707,1 @@\n+    JVMCINMethodHandle& nmethod_handle,\n@@ -808,0 +809,2 @@\n+      guarantee(nm != nullptr, \"successful compile must produce an nmethod\");\n+      nmethod_handle.set_nmethod(nm);\n@@ -816,4 +819,2 @@\n-      if (nm != nullptr) {\n-        if (_nmethod_entry_patch_offset != -1) {\n-          err_msg msg(\"\");\n-          BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+      if (_nmethod_entry_patch_offset != -1) {\n+        BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n@@ -821,3 +822,3 @@\n-          if (!bs_nm->verify_barrier(nm, msg)) {\n-            JVMCI_THROW_MSG_(IllegalArgumentException, err_msg(\"nmethod entry barrier is malformed: %s\", msg.buffer()), JVMCI::ok);\n-          }\n+        err_msg msg(\"\");\n+        if (!bs_nm->verify_barrier(nm, msg)) {\n+          JVMCI_THROW_MSG_(IllegalArgumentException, err_msg(\"nmethod entry barrier is malformed: %s\", msg.buffer()), JVMCI::ok);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -335,0 +335,1 @@\n+                                   JVMCINMethodHandle& nmethod_handle,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n@@ -1118,0 +1119,1 @@\n+  JVMCINMethodHandle nmethod_handle(THREAD);\n@@ -1125,0 +1127,1 @@\n+      nmethod_handle,\n@@ -1216,1 +1219,2 @@\n-  nmethod* nm = JVMCIENV->get_nmethod(nmethod_mirror);\n+  JVMCINMethodHandle nmethod_handle(THREAD);\n+  nmethod* nm = JVMCIENV->get_nmethod(nmethod_mirror, nmethod_handle);\n@@ -1490,0 +1494,1 @@\n+  KeepStackGCProcessedMark keep_stack(THREAD);\n@@ -2775,1 +2780,2 @@\n-      nmethod* nm = JVMCIENV->get_nmethod(obj);\n+      JVMCINMethodHandle nmethod_handle(THREAD);\n+      nmethod* nm = JVMCIENV->get_nmethod(obj, nmethod_handle);\n@@ -2798,1 +2804,2 @@\n-      nmethod* nm = JVMCIENV->get_nmethod(obj);\n+      JVMCINMethodHandle nmethod_handle(THREAD);\n+      nmethod* nm = JVMCIENV->get_nmethod(obj, nmethod_handle);\n@@ -2850,1 +2857,2 @@\n-  JVMCIENV->get_nmethod(code);\n+  JVMCINMethodHandle nmethod_handle(THREAD);\n+  JVMCIENV->get_nmethod(code, nmethod_handle);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n@@ -1715,6 +1717,0 @@\n-  nmethod* nm = JVMCIENV->get_nmethod(mirror);\n-  if (nm == nullptr) {\n-    \/\/ Nothing to do\n-    return;\n-  }\n-\n@@ -1729,0 +1725,8 @@\n+  JavaThread* thread = JavaThread::cast(current);\n+  JVMCINMethodHandle nmethod_handle(thread);\n+  nmethod* nm = JVMCIENV->get_nmethod(mirror, nmethod_handle);\n+  if (nm == nullptr) {\n+    \/\/ Nothing to do\n+    return;\n+  }\n+\n@@ -1818,1 +1822,9 @@\n-nmethod* JVMCIEnv::get_nmethod(JVMCIObject obj) {\n+void JVMCINMethodHandle::set_nmethod(nmethod* nm) {\n+  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+  if (bs_nm != nullptr) {\n+    bs_nm->nmethod_entry_barrier(nm);\n+  }\n+  _thread->set_live_nmethod(nm);\n+}\n+\n+nmethod* JVMCIEnv::get_nmethod(JVMCIObject obj, JVMCINMethodHandle& nmethod_handle) {\n@@ -1821,1 +1833,5 @@\n-    return cb->as_nmethod_or_null();\n+    nmethod* nm = cb->as_nmethod_or_null();\n+    if (nm != nullptr) {\n+      nmethod_handle.set_nmethod(nm);\n+      return nm;\n+    }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -91,0 +91,15 @@\n+\/\/ A helper class to main a strong link to an nmethod that might not otherwise be referenced.  Only\n+\/\/ one nmethod can be kept alive in this manner.\n+class JVMCINMethodHandle : public StackObj {\n+  JavaThread* _thread;\n+\n+ public:\n+  JVMCINMethodHandle(JavaThread* thread): _thread(thread) {}\n+\n+  void set_nmethod(nmethod* nm);\n+\n+  ~JVMCINMethodHandle() {\n+    _thread->clear_live_nmethod();\n+  }\n+};\n+\n@@ -377,1 +392,1 @@\n-  nmethod* get_nmethod(JVMCIObject code);\n+  nmethod* get_nmethod(JVMCIObject code, JVMCINMethodHandle& nmethod_handle);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -461,0 +461,1 @@\n+  _live_nmethod(nullptr),\n@@ -1381,0 +1382,4 @@\n+\n+  if (_live_nmethod != nullptr && cf != nullptr) {\n+    cf->do_code_blob(_live_nmethod);\n+  }\n@@ -1436,0 +1441,6 @@\n+\n+#if INCLUDE_JVMCI\n+  if (_live_nmethod != nullptr) {\n+    cf->do_code_blob(_live_nmethod);\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -384,0 +384,3 @@\n+  \/\/ This field is used to keep an nmethod visible to the GC so that it can be kept alive\n+  nmethod*  _live_nmethod;\n+\n@@ -416,0 +419,9 @@\n+  void set_live_nmethod(nmethod* nm) {\n+    assert(_live_nmethod == nullptr, \"only one\");\n+    _live_nmethod = nm;\n+  }\n+\n+  void clear_live_nmethod() {\n+    _live_nmethod = nullptr;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}