{"files":[{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -207,6 +207,0 @@\n-      case Op_VectorLoadShuffle:\n-      case Op_VectorRearrange:\n-        if (vlen < 4) {\n-          return false;\n-        }\n-        break;\n@@ -6159,26 +6153,2 @@\n-\/\/ Here is an example that rearranges a NEON vector with 4 ints:\n-\/\/ Rearrange V1 int[a0, a1, a2, a3] to V2 int[a2, a3, a0, a1]\n-\/\/   1. Get the indices of V1 and store them as Vi byte[0, 1, 2, 3].\n-\/\/   2. Convert Vi byte[0, 1, 2, 3] to the indices of V2 and also store them as Vi byte[2, 3, 0, 1].\n-\/\/   3. Unsigned extend Long Vi from byte[2, 3, 0, 1] to int[2, 3, 0, 1].\n-\/\/   4. Multiply Vi int[2, 3, 0, 1] with constant int[0x04040404, 0x04040404, 0x04040404, 0x04040404]\n-\/\/      and get tbl base Vm int[0x08080808, 0x0c0c0c0c, 0x00000000, 0x04040404].\n-\/\/   5. Add Vm with constant int[0x03020100, 0x03020100, 0x03020100, 0x03020100]\n-\/\/      and get tbl index Vm int[0x0b0a0908, 0x0f0e0d0c, 0x03020100, 0x07060504]\n-\/\/   6. Use Vm as index register, and use V1 as table register.\n-\/\/      Then get V2 as the result by tbl NEON instructions.\n-\/\/ Notes:\n-\/\/   Step 1 matches VectorLoadConst.\n-\/\/   Step 3 matches VectorLoadShuffle.\n-\/\/   Step 4, 5, 6 match VectorRearrange.\n-\/\/   For VectorRearrange short\/int, the reason why such complex calculation is\n-\/\/   required is because NEON tbl supports bytes table only, so for short\/int, we\n-\/\/   need to lookup 2\/4 bytes as a group. For VectorRearrange long, we use bsl\n-\/\/   to implement rearrange.\n-\n-\/\/ Maybe move the shuffle preparation to VectorLoadShuffle\n-instruct rearrange_HS_neon(vReg dst, vReg src, vReg shuffle, vReg tmp1, vReg tmp2) %{\n-  predicate(UseSVE == 0 &&\n-            (Matcher::vector_element_basic_type(n) == T_SHORT ||\n-             (type2aelembytes(Matcher::vector_element_basic_type(n)) == 4 &&\n-              Matcher::vector_length_in_bytes(n) == 16)));\n+instruct rearrange_HSD_neon(vReg dst, vReg src, vReg shuffle, vReg tmp) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) != T_BYTE);\n@@ -6186,2 +6156,2 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n-  format %{ \"rearrange_HS_neon $dst, $src, $shuffle\\t# vector (4S\/8S\/4I\/4F). KILL $tmp1, $tmp2\" %}\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"rearrange_HSD_neon $dst, $src, $shuffle\\t# vector (4H\/8H\/2S\/4S\/2D). KILL $tmp\" %}\n@@ -6190,18 +6160,5 @@\n-    if (bt == T_SHORT) {\n-      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-      assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n-      Assembler::SIMD_Arrangement size1 = length_in_bytes == 16 ? __ T16B : __ T8B;\n-      Assembler::SIMD_Arrangement size2 = length_in_bytes == 16 ? __ T8H : __ T4H;\n-      __ mov($tmp1$$FloatRegister, size1, 0x02);\n-      __ mov($tmp2$$FloatRegister, size2, 0x0100);\n-      __ mulv($dst$$FloatRegister, size2, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n-      __ addv($dst$$FloatRegister, size1, $dst$$FloatRegister, $tmp2$$FloatRegister);\n-      __ tbl($dst$$FloatRegister, size1, $src$$FloatRegister, 1, $dst$$FloatRegister);\n-    } else {\n-      assert(bt == T_INT || bt == T_FLOAT, \"unsupported type\");\n-      __ mov($tmp1$$FloatRegister, __ T16B, 0x04);\n-      __ mov($tmp2$$FloatRegister, __ T4S, 0x03020100);\n-      __ mulv($dst$$FloatRegister, __ T4S, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n-      __ addv($dst$$FloatRegister, __ T16B, $dst$$FloatRegister, $tmp2$$FloatRegister);\n-      __ tbl($dst$$FloatRegister, __ T16B, $src$$FloatRegister, 1, $dst$$FloatRegister);\n-    }\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ neon_rearrange_hsd($dst$$FloatRegister, $src$$FloatRegister,\n+                          $shuffle$$FloatRegister, $tmp$$FloatRegister,\n+                          bt, length_in_bytes == 16);\n@@ -6213,1 +6170,1 @@\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE || UseSVE > 0);\n+  predicate(UseSVE > 0 || Matcher::vector_element_basic_type(n) == T_BYTE);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":11,"deletions":54,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,6 +197,0 @@\n-      case Op_VectorLoadShuffle:\n-      case Op_VectorRearrange:\n-        if (vlen < 4) {\n-          return false;\n-        }\n-        break;\n@@ -4406,26 +4400,2 @@\n-\/\/ Here is an example that rearranges a NEON vector with 4 ints:\n-\/\/ Rearrange V1 int[a0, a1, a2, a3] to V2 int[a2, a3, a0, a1]\n-\/\/   1. Get the indices of V1 and store them as Vi byte[0, 1, 2, 3].\n-\/\/   2. Convert Vi byte[0, 1, 2, 3] to the indices of V2 and also store them as Vi byte[2, 3, 0, 1].\n-\/\/   3. Unsigned extend Long Vi from byte[2, 3, 0, 1] to int[2, 3, 0, 1].\n-\/\/   4. Multiply Vi int[2, 3, 0, 1] with constant int[0x04040404, 0x04040404, 0x04040404, 0x04040404]\n-\/\/      and get tbl base Vm int[0x08080808, 0x0c0c0c0c, 0x00000000, 0x04040404].\n-\/\/   5. Add Vm with constant int[0x03020100, 0x03020100, 0x03020100, 0x03020100]\n-\/\/      and get tbl index Vm int[0x0b0a0908, 0x0f0e0d0c, 0x03020100, 0x07060504]\n-\/\/   6. Use Vm as index register, and use V1 as table register.\n-\/\/      Then get V2 as the result by tbl NEON instructions.\n-\/\/ Notes:\n-\/\/   Step 1 matches VectorLoadConst.\n-\/\/   Step 3 matches VectorLoadShuffle.\n-\/\/   Step 4, 5, 6 match VectorRearrange.\n-\/\/   For VectorRearrange short\/int, the reason why such complex calculation is\n-\/\/   required is because NEON tbl supports bytes table only, so for short\/int, we\n-\/\/   need to lookup 2\/4 bytes as a group. For VectorRearrange long, we use bsl\n-\/\/   to implement rearrange.\n-\n-\/\/ Maybe move the shuffle preparation to VectorLoadShuffle\n-instruct rearrange_HS_neon(vReg dst, vReg src, vReg shuffle, vReg tmp1, vReg tmp2) %{\n-  predicate(UseSVE == 0 &&\n-            (Matcher::vector_element_basic_type(n) == T_SHORT ||\n-             (type2aelembytes(Matcher::vector_element_basic_type(n)) == 4 &&\n-              Matcher::vector_length_in_bytes(n) == 16)));\n+instruct rearrange_HSD_neon(vReg dst, vReg src, vReg shuffle, vReg tmp) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) != T_BYTE);\n@@ -4433,2 +4403,2 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n-  format %{ \"rearrange_HS_neon $dst, $src, $shuffle\\t# vector (4S\/8S\/4I\/4F). KILL $tmp1, $tmp2\" %}\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"rearrange_HSD_neon $dst, $src, $shuffle\\t# vector (4H\/8H\/2S\/4S\/2D). KILL $tmp\" %}\n@@ -4437,18 +4407,5 @@\n-    if (bt == T_SHORT) {\n-      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-      assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n-      Assembler::SIMD_Arrangement size1 = length_in_bytes == 16 ? __ T16B : __ T8B;\n-      Assembler::SIMD_Arrangement size2 = length_in_bytes == 16 ? __ T8H : __ T4H;\n-      __ mov($tmp1$$FloatRegister, size1, 0x02);\n-      __ mov($tmp2$$FloatRegister, size2, 0x0100);\n-      __ mulv($dst$$FloatRegister, size2, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n-      __ addv($dst$$FloatRegister, size1, $dst$$FloatRegister, $tmp2$$FloatRegister);\n-      __ tbl($dst$$FloatRegister, size1, $src$$FloatRegister, 1, $dst$$FloatRegister);\n-    } else {\n-      assert(bt == T_INT || bt == T_FLOAT, \"unsupported type\");\n-      __ mov($tmp1$$FloatRegister, __ T16B, 0x04);\n-      __ mov($tmp2$$FloatRegister, __ T4S, 0x03020100);\n-      __ mulv($dst$$FloatRegister, __ T4S, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n-      __ addv($dst$$FloatRegister, __ T16B, $dst$$FloatRegister, $tmp2$$FloatRegister);\n-      __ tbl($dst$$FloatRegister, __ T16B, $src$$FloatRegister, 1, $dst$$FloatRegister);\n-    }\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ neon_rearrange_hsd($dst$$FloatRegister, $src$$FloatRegister,\n+                          $shuffle$$FloatRegister, $tmp$$FloatRegister,\n+                          bt, length_in_bytes == 16);\n@@ -4460,1 +4417,1 @@\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE || UseSVE > 0);\n+  predicate(UseSVE > 0 || Matcher::vector_element_basic_type(n) == T_BYTE);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":11,"deletions":54,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2552,0 +2552,58 @@\n+\/\/ VectorRearrange implementation for short\/int\/float\/long\/double types with NEON\n+\/\/ instructions. For VectorRearrange short\/int\/float, we use NEON tbl instruction.\n+\/\/ But since it supports bytes table only, we need to lookup 2\/4 bytes as a group.\n+\/\/ For VectorRearrange long\/double, we compare the shuffle input with iota indices,\n+\/\/ and use bsl to implement the operation.\n+void C2_MacroAssembler::neon_rearrange_hsd(FloatRegister dst, FloatRegister src,\n+                                           FloatRegister shuffle, FloatRegister tmp,\n+                                           BasicType bt, bool isQ) {\n+  assert_different_registers(dst, src, shuffle, tmp);\n+  SIMD_Arrangement size1 = isQ ? T16B : T8B;\n+  SIMD_Arrangement size2 = esize2arrangement((uint)type2aelembytes(bt), isQ);\n+\n+  \/\/ Here is an example that rearranges a NEON vector with 4 ints:\n+  \/\/ Rearrange V1 int[a0, a1, a2, a3] to V2 int[a2, a3, a0, a1]\n+  \/\/   1. We assume the shuffle input is Vi int[2, 3, 0, 1].\n+  \/\/   2. Multiply Vi int[2, 3, 0, 1] with constant int vector\n+  \/\/      [0x04040404, 0x04040404, 0x04040404, 0x04040404], and get\n+  \/\/      tbl base Vm int[0x08080808, 0x0c0c0c0c, 0x00000000, 0x04040404].\n+  \/\/   3. Add Vm with constant int[0x03020100, 0x03020100, 0x03020100, 0x03020100],\n+  \/\/      and get tbl index Vm int[0x0b0a0908, 0x0f0e0d0c, 0x03020100, 0x07060504]\n+  \/\/   4. Use Vm as index register, and use V1 as table register.\n+  \/\/      Then get V2 as the result by tbl NEON instructions.\n+  switch (bt) {\n+    case T_SHORT:\n+      mov(tmp, size1, 0x02);\n+      mulv(dst, size2, shuffle, tmp);\n+      mov(tmp, size2, 0x0100);\n+      addv(dst, size1, dst, tmp);\n+      tbl(dst, size1, src, 1, dst);\n+      break;\n+    case T_INT:\n+    case T_FLOAT:\n+      mov(tmp, size1, 0x04);\n+      mulv(dst, size2, shuffle, tmp);\n+      mov(tmp, size2, 0x03020100);\n+      addv(dst, size1, dst, tmp);\n+      tbl(dst, size1, src, 1, dst);\n+      break;\n+    case T_LONG:\n+    case T_DOUBLE:\n+      \/\/ Load the iota indices for Long type. The indices are ordered by\n+      \/\/ type B\/S\/I\/L\/F\/D, and the offset between two types is 16; Hence\n+      \/\/ the offset for L is 48.\n+      lea(rscratch1,\n+          ExternalAddress(StubRoutines::aarch64::vector_iota_indices() + 48));\n+      ldrq(tmp, rscratch1);\n+      \/\/ Check whether the input \"shuffle\" is the same with iota indices.\n+      \/\/ Return \"src\" if true, otherwise swap the two elements of \"src\".\n+      cm(EQ, dst, size2, shuffle, tmp);\n+      ext(tmp, size1, src, src, 8);\n+      bsl(dst, size1, src, tmp);\n+      break;\n+    default:\n+      assert(false, \"unsupported element type\");\n+      ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,0 +182,2 @@\n+  void neon_rearrange_hsd(FloatRegister dst, FloatRegister src, FloatRegister shuffle,\n+                          FloatRegister tmp, BasicType bt, bool isQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}