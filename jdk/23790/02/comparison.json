{"files":[{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -207,6 +207,0 @@\n-      case Op_VectorLoadShuffle:\n-      case Op_VectorRearrange:\n-        if (vlen < 4) {\n-          return false;\n-        }\n-        break;\n@@ -6159,26 +6153,2 @@\n-\/\/ Here is an example that rearranges a NEON vector with 4 ints:\n-\/\/ Rearrange V1 int[a0, a1, a2, a3] to V2 int[a2, a3, a0, a1]\n-\/\/   1. Get the indices of V1 and store them as Vi byte[0, 1, 2, 3].\n-\/\/   2. Convert Vi byte[0, 1, 2, 3] to the indices of V2 and also store them as Vi byte[2, 3, 0, 1].\n-\/\/   3. Unsigned extend Long Vi from byte[2, 3, 0, 1] to int[2, 3, 0, 1].\n-\/\/   4. Multiply Vi int[2, 3, 0, 1] with constant int[0x04040404, 0x04040404, 0x04040404, 0x04040404]\n-\/\/      and get tbl base Vm int[0x08080808, 0x0c0c0c0c, 0x00000000, 0x04040404].\n-\/\/   5. Add Vm with constant int[0x03020100, 0x03020100, 0x03020100, 0x03020100]\n-\/\/      and get tbl index Vm int[0x0b0a0908, 0x0f0e0d0c, 0x03020100, 0x07060504]\n-\/\/   6. Use Vm as index register, and use V1 as table register.\n-\/\/      Then get V2 as the result by tbl NEON instructions.\n-\/\/ Notes:\n-\/\/   Step 1 matches VectorLoadConst.\n-\/\/   Step 3 matches VectorLoadShuffle.\n-\/\/   Step 4, 5, 6 match VectorRearrange.\n-\/\/   For VectorRearrange short\/int, the reason why such complex calculation is\n-\/\/   required is because NEON tbl supports bytes table only, so for short\/int, we\n-\/\/   need to lookup 2\/4 bytes as a group. For VectorRearrange long, we use bsl\n-\/\/   to implement rearrange.\n-\n-\/\/ Maybe move the shuffle preparation to VectorLoadShuffle\n-instruct rearrange_HS_neon(vReg dst, vReg src, vReg shuffle, vReg tmp1, vReg tmp2) %{\n-  predicate(UseSVE == 0 &&\n-            (Matcher::vector_element_basic_type(n) == T_SHORT ||\n-             (type2aelembytes(Matcher::vector_element_basic_type(n)) == 4 &&\n-              Matcher::vector_length_in_bytes(n) == 16)));\n+instruct rearrange_HSD_neon(vReg dst, vReg src, vReg shuffle, vReg tmp) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) != T_BYTE);\n@@ -6186,2 +6156,2 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n-  format %{ \"rearrange_HS_neon $dst, $src, $shuffle\\t# vector (4S\/8S\/4I\/4F). KILL $tmp1, $tmp2\" %}\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"rearrange_HSD_neon $dst, $src, $shuffle\\t# vector (4H\/8H\/2S\/4S\/2D). KILL $tmp\" %}\n@@ -6190,18 +6160,5 @@\n-    if (bt == T_SHORT) {\n-      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-      assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n-      Assembler::SIMD_Arrangement size1 = length_in_bytes == 16 ? __ T16B : __ T8B;\n-      Assembler::SIMD_Arrangement size2 = length_in_bytes == 16 ? __ T8H : __ T4H;\n-      __ mov($tmp1$$FloatRegister, size1, 0x02);\n-      __ mov($tmp2$$FloatRegister, size2, 0x0100);\n-      __ mulv($dst$$FloatRegister, size2, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n-      __ addv($dst$$FloatRegister, size1, $dst$$FloatRegister, $tmp2$$FloatRegister);\n-      __ tbl($dst$$FloatRegister, size1, $src$$FloatRegister, 1, $dst$$FloatRegister);\n-    } else {\n-      assert(bt == T_INT || bt == T_FLOAT, \"unsupported type\");\n-      __ mov($tmp1$$FloatRegister, __ T16B, 0x04);\n-      __ mov($tmp2$$FloatRegister, __ T4S, 0x03020100);\n-      __ mulv($dst$$FloatRegister, __ T4S, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n-      __ addv($dst$$FloatRegister, __ T16B, $dst$$FloatRegister, $tmp2$$FloatRegister);\n-      __ tbl($dst$$FloatRegister, __ T16B, $src$$FloatRegister, 1, $dst$$FloatRegister);\n-    }\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ neon_rearrange_hsd($dst$$FloatRegister, $src$$FloatRegister,\n+                          $shuffle$$FloatRegister, $tmp$$FloatRegister,\n+                          bt, length_in_bytes == 16);\n@@ -6213,1 +6170,1 @@\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE || UseSVE > 0);\n+  predicate(UseSVE > 0 || Matcher::vector_element_basic_type(n) == T_BYTE);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":11,"deletions":54,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,6 +197,0 @@\n-      case Op_VectorLoadShuffle:\n-      case Op_VectorRearrange:\n-        if (vlen < 4) {\n-          return false;\n-        }\n-        break;\n@@ -4406,26 +4400,2 @@\n-\/\/ Here is an example that rearranges a NEON vector with 4 ints:\n-\/\/ Rearrange V1 int[a0, a1, a2, a3] to V2 int[a2, a3, a0, a1]\n-\/\/   1. Get the indices of V1 and store them as Vi byte[0, 1, 2, 3].\n-\/\/   2. Convert Vi byte[0, 1, 2, 3] to the indices of V2 and also store them as Vi byte[2, 3, 0, 1].\n-\/\/   3. Unsigned extend Long Vi from byte[2, 3, 0, 1] to int[2, 3, 0, 1].\n-\/\/   4. Multiply Vi int[2, 3, 0, 1] with constant int[0x04040404, 0x04040404, 0x04040404, 0x04040404]\n-\/\/      and get tbl base Vm int[0x08080808, 0x0c0c0c0c, 0x00000000, 0x04040404].\n-\/\/   5. Add Vm with constant int[0x03020100, 0x03020100, 0x03020100, 0x03020100]\n-\/\/      and get tbl index Vm int[0x0b0a0908, 0x0f0e0d0c, 0x03020100, 0x07060504]\n-\/\/   6. Use Vm as index register, and use V1 as table register.\n-\/\/      Then get V2 as the result by tbl NEON instructions.\n-\/\/ Notes:\n-\/\/   Step 1 matches VectorLoadConst.\n-\/\/   Step 3 matches VectorLoadShuffle.\n-\/\/   Step 4, 5, 6 match VectorRearrange.\n-\/\/   For VectorRearrange short\/int, the reason why such complex calculation is\n-\/\/   required is because NEON tbl supports bytes table only, so for short\/int, we\n-\/\/   need to lookup 2\/4 bytes as a group. For VectorRearrange long, we use bsl\n-\/\/   to implement rearrange.\n-\n-\/\/ Maybe move the shuffle preparation to VectorLoadShuffle\n-instruct rearrange_HS_neon(vReg dst, vReg src, vReg shuffle, vReg tmp1, vReg tmp2) %{\n-  predicate(UseSVE == 0 &&\n-            (Matcher::vector_element_basic_type(n) == T_SHORT ||\n-             (type2aelembytes(Matcher::vector_element_basic_type(n)) == 4 &&\n-              Matcher::vector_length_in_bytes(n) == 16)));\n+instruct rearrange_HSD_neon(vReg dst, vReg src, vReg shuffle, vReg tmp) %{\n+  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) != T_BYTE);\n@@ -4433,2 +4403,2 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n-  format %{ \"rearrange_HS_neon $dst, $src, $shuffle\\t# vector (4S\/8S\/4I\/4F). KILL $tmp1, $tmp2\" %}\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"rearrange_HSD_neon $dst, $src, $shuffle\\t# vector (4H\/8H\/2S\/4S\/2D). KILL $tmp\" %}\n@@ -4437,18 +4407,5 @@\n-    if (bt == T_SHORT) {\n-      uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-      assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n-      Assembler::SIMD_Arrangement size1 = length_in_bytes == 16 ? __ T16B : __ T8B;\n-      Assembler::SIMD_Arrangement size2 = length_in_bytes == 16 ? __ T8H : __ T4H;\n-      __ mov($tmp1$$FloatRegister, size1, 0x02);\n-      __ mov($tmp2$$FloatRegister, size2, 0x0100);\n-      __ mulv($dst$$FloatRegister, size2, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n-      __ addv($dst$$FloatRegister, size1, $dst$$FloatRegister, $tmp2$$FloatRegister);\n-      __ tbl($dst$$FloatRegister, size1, $src$$FloatRegister, 1, $dst$$FloatRegister);\n-    } else {\n-      assert(bt == T_INT || bt == T_FLOAT, \"unsupported type\");\n-      __ mov($tmp1$$FloatRegister, __ T16B, 0x04);\n-      __ mov($tmp2$$FloatRegister, __ T4S, 0x03020100);\n-      __ mulv($dst$$FloatRegister, __ T4S, $shuffle$$FloatRegister, $tmp1$$FloatRegister);\n-      __ addv($dst$$FloatRegister, __ T16B, $dst$$FloatRegister, $tmp2$$FloatRegister);\n-      __ tbl($dst$$FloatRegister, __ T16B, $src$$FloatRegister, 1, $dst$$FloatRegister);\n-    }\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    __ neon_rearrange_hsd($dst$$FloatRegister, $src$$FloatRegister,\n+                          $shuffle$$FloatRegister, $tmp$$FloatRegister,\n+                          bt, length_in_bytes == 16);\n@@ -4460,1 +4417,1 @@\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE || UseSVE > 0);\n+  predicate(UseSVE > 0 || Matcher::vector_element_basic_type(n) == T_BYTE);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":11,"deletions":54,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2548,0 +2548,58 @@\n+\/\/ VectorRearrange implementation for short\/int\/float\/long\/double types with NEON\n+\/\/ instructions. For VectorRearrange short\/int\/float, we use NEON tbl instruction.\n+\/\/ But since it supports bytes table only, we need to lookup 2\/4 bytes as a group.\n+\/\/ For VectorRearrange long\/double, we compare the shuffle input with iota indices,\n+\/\/ and use bsl to implement the operation.\n+void C2_MacroAssembler::neon_rearrange_hsd(FloatRegister dst, FloatRegister src,\n+                                           FloatRegister shuffle, FloatRegister tmp,\n+                                           BasicType bt, bool isQ) {\n+  assert_different_registers(dst, src, shuffle, tmp);\n+  SIMD_Arrangement size1 = isQ ? T16B : T8B;\n+  SIMD_Arrangement size2 = esize2arrangement((uint)type2aelembytes(bt), isQ);\n+\n+  \/\/ Here is an example that rearranges a NEON vector with 4 ints:\n+  \/\/ Rearrange V1 int[a0, a1, a2, a3] to V2 int[a2, a3, a0, a1]\n+  \/\/   1. We assume the shuffle input is Vi int[2, 3, 0, 1].\n+  \/\/   2. Multiply Vi int[2, 3, 0, 1] with constant int vector\n+  \/\/      [0x04040404, 0x04040404, 0x04040404, 0x04040404], and get\n+  \/\/      tbl base Vm int[0x08080808, 0x0c0c0c0c, 0x00000000, 0x04040404].\n+  \/\/   3. Add Vm with constant int[0x03020100, 0x03020100, 0x03020100, 0x03020100],\n+  \/\/      and get tbl index Vm int[0x0b0a0908, 0x0f0e0d0c, 0x03020100, 0x07060504]\n+  \/\/   4. Use Vm as index register, and use V1 as table register.\n+  \/\/      Then get V2 as the result by tbl NEON instructions.\n+  switch (bt) {\n+    case T_SHORT:\n+      mov(tmp, size1, 0x02);\n+      mulv(dst, size2, shuffle, tmp);\n+      mov(tmp, size2, 0x0100);\n+      addv(dst, size1, dst, tmp);\n+      tbl(dst, size1, src, 1, dst);\n+      break;\n+    case T_INT:\n+    case T_FLOAT:\n+      mov(tmp, size1, 0x04);\n+      mulv(dst, size2, shuffle, tmp);\n+      mov(tmp, size2, 0x03020100);\n+      addv(dst, size1, dst, tmp);\n+      tbl(dst, size1, src, 1, dst);\n+      break;\n+    case T_LONG:\n+    case T_DOUBLE:\n+      \/\/ Load the iota indices for Long type. The indices are ordered by\n+      \/\/ type B\/S\/I\/L\/F\/D, and the offset between two types is 16; Hence\n+      \/\/ the offset for L is 48.\n+      lea(rscratch1,\n+          ExternalAddress(StubRoutines::aarch64::vector_iota_indices() + 48));\n+      ldrq(tmp, rscratch1);\n+      \/\/ Check whether the input \"shuffle\" is the same with iota indices.\n+      \/\/ Return \"src\" if true, otherwise swap the two elements of \"src\".\n+      cm(EQ, dst, size2, shuffle, tmp);\n+      ext(tmp, size1, src, src, 8);\n+      bsl(dst, size1, src, tmp);\n+      break;\n+    default:\n+      assert(false, \"unsupported element type\");\n+      ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,0 +182,2 @@\n+  void neon_rearrange_hsd(FloatRegister dst, FloatRegister src, FloatRegister shuffle,\n+                          FloatRegister tmp, BasicType bt, bool isQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -337,0 +337,30 @@\n+    public static final String REARRANGE_VB = VECTOR_PREFIX + \"REARRANGE_VB\" + POSTFIX;\n+    static {\n+        vectorNode(REARRANGE_VB, \"VectorRearrange\", TYPE_BYTE);\n+    }\n+\n+    public static final String REARRANGE_VS = VECTOR_PREFIX + \"REARRANGE_VS\" + POSTFIX;\n+    static {\n+        vectorNode(REARRANGE_VS, \"VectorRearrange\", TYPE_SHORT);\n+    }\n+\n+    public static final String REARRANGE_VI = VECTOR_PREFIX + \"REARRANGE_VI\" + POSTFIX;\n+    static {\n+        vectorNode(REARRANGE_VI, \"VectorRearrange\", TYPE_INT);\n+    }\n+\n+    public static final String REARRANGE_VL = VECTOR_PREFIX + \"REARRANGE_VL\" + POSTFIX;\n+    static {\n+        vectorNode(REARRANGE_VL, \"VectorRearrange\", TYPE_LONG);\n+    }\n+\n+    public static final String REARRANGE_VF = VECTOR_PREFIX + \"REARRANGE_VF\" + POSTFIX;\n+    static {\n+        vectorNode(REARRANGE_VF, \"VectorRearrange\", TYPE_FLOAT);\n+    }\n+\n+    public static final String REARRANGE_VD = VECTOR_PREFIX + \"REARRANGE_VD\" + POSTFIX;\n+    static {\n+        vectorNode(REARRANGE_VD, \"VectorRearrange\", TYPE_DOUBLE);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8350463\n+ * @summary AArch64: Add vector rearrange support for small lane count vectors\n+ * @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx.*\") | os.arch==\"aarch64\"\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ *\n+ * @run driver compiler.vectorapi.VectorRearrangeTest\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.*;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class VectorRearrangeTest {\n+    private static final int LENGTH = 2048;\n+    private static final Random random = Utils.getRandomInstance();\n+\n+    private static final VectorSpecies<Byte> bspec128    = ByteVector.SPECIES_128;\n+    private static final VectorSpecies<Short> sspec128   = ShortVector.SPECIES_128;\n+    private static final VectorSpecies<Integer> ispec128 = IntVector.SPECIES_128;\n+    private static final VectorSpecies<Long> lspec128    = LongVector.SPECIES_128;\n+    private static final VectorSpecies<Float> fspec128   = FloatVector.SPECIES_128;\n+    private static final VectorSpecies<Double> dspec128  = DoubleVector.SPECIES_128;\n+    private static final VectorSpecies<Byte> bspec64     = ByteVector.SPECIES_64;\n+    private static final VectorSpecies<Short> sspec64    = ShortVector.SPECIES_64;\n+    private static final VectorSpecies<Integer> ispec64  = IntVector.SPECIES_64;\n+    private static final VectorSpecies<Float> fspec64    = FloatVector.SPECIES_64;\n+\n+    private static byte[]   bsrc;\n+    private static short[]  ssrc;\n+    private static int[]    isrc;\n+    private static long[]   lsrc;\n+    private static float[]  fsrc;\n+    private static double[] dsrc;\n+\n+    private static byte[]   bdst;\n+    private static short[]  sdst;\n+    private static int[]    idst;\n+    private static long[]   ldst;\n+    private static float[]  fdst;\n+    private static double[] ddst;\n+\n+    private static int[][] indexes;\n+\n+    static {\n+        bsrc = new byte[LENGTH];\n+        ssrc = new short[LENGTH];\n+        isrc = new int[LENGTH];\n+        lsrc = new long[LENGTH];\n+        fsrc = new float[LENGTH];\n+        dsrc = new double[LENGTH];\n+        bdst = new byte[LENGTH];\n+        sdst = new short[LENGTH];\n+        idst = new int[LENGTH];\n+        ldst = new long[LENGTH];\n+        fdst = new float[LENGTH];\n+        ddst = new double[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; ++i) {\n+            bsrc[i] = (byte)random.nextInt();\n+            ssrc[i] = (short)random.nextInt();\n+            isrc[i] = random.nextInt();\n+            lsrc[i] = random.nextLong();\n+            fsrc[i] = random.nextFloat();\n+            dsrc[i] = random.nextDouble();\n+        }\n+\n+        int[] nums = {2, 4, 8, 16};\n+        indexes = new int[4][];\n+        for (int i = 0; i < 4; i++) {\n+            indexes[i] = new int[nums[i]];\n+            for (int j = 0; j < nums[i]; j++) {\n+                indexes[i][j] = random.nextInt() & (nums[i] - 1);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VB, IRNode.VECTOR_SIZE_8, \" >0 \"})\n+    public void rearrange_byte64() {\n+        VectorShuffle<Byte> shuffle = VectorShuffle.fromArray(bspec64, indexes[2], 0);\n+        for (int i = 0; i < LENGTH; i += bspec64.length()) {\n+            ByteVector.fromArray(bspec64, bsrc, i)\n+                      .rearrange(shuffle)\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VB, IRNode.VECTOR_SIZE_16, \" >0 \"})\n+    public void rearrange_byte128() {\n+        VectorShuffle<Byte> shuffle = VectorShuffle.fromArray(bspec128, indexes[3], 0);\n+        for (int i = 0; i < LENGTH; i += bspec128.length()) {\n+            ByteVector.fromArray(bspec128, bsrc, i)\n+                      .rearrange(shuffle)\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VS, IRNode.VECTOR_SIZE_4, \" >0 \"})\n+    public void rearrange_short64() {\n+        VectorShuffle<Short> shuffle = VectorShuffle.fromArray(sspec64, indexes[1], 0);\n+        for (int i = 0; i < LENGTH; i += sspec64.length()) {\n+            ShortVector.fromArray(sspec64, ssrc, i)\n+                       .rearrange(shuffle)\n+                       .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VS, IRNode.VECTOR_SIZE_8, \" >0 \"})\n+    public void rearrange_short128() {\n+        VectorShuffle<Short> shuffle = VectorShuffle.fromArray(sspec128, indexes[2], 0);\n+        for (int i = 0; i < LENGTH; i += sspec128.length()) {\n+            ShortVector.fromArray(sspec128, ssrc, i)\n+                       .rearrange(shuffle)\n+                       .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VI, IRNode.VECTOR_SIZE_2, \" >0 \"}, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public void rearrange_int64() {\n+        VectorShuffle<Integer> shuffle = VectorShuffle.fromArray(ispec64, indexes[0], 0);\n+        for (int i = 0; i < LENGTH; i += ispec64.length()) {\n+            IntVector.fromArray(ispec64, isrc, i)\n+                     .rearrange(shuffle)\n+                     .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VI, IRNode.VECTOR_SIZE_4, \" >0 \"})\n+    public void rearrange_int128() {\n+        VectorShuffle<Integer> shuffle = VectorShuffle.fromArray(ispec128, indexes[1], 0);\n+        for (int i = 0; i < LENGTH; i += ispec128.length()) {\n+            IntVector.fromArray(ispec128, isrc, i)\n+                     .rearrange(shuffle)\n+                     .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VL, IRNode.VECTOR_SIZE_2, \" >0 \"}, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public void rearrange_long128() {\n+        VectorShuffle<Long> shuffle = VectorShuffle.fromArray(lspec128, indexes[0], 0);\n+        for (int i = 0; i < LENGTH; i += lspec128.length()) {\n+            LongVector.fromArray(lspec128, lsrc, i)\n+                      .rearrange(shuffle)\n+                      .intoArray(ldst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VF, IRNode.VECTOR_SIZE_2, \" >0 \"}, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public void rearrange_float64() {\n+        VectorShuffle<Float> shuffle = VectorShuffle.fromArray(fspec64, indexes[0], 0);\n+        for (int i = 0; i < LENGTH; i += fspec64.length()) {\n+            FloatVector.fromArray(fspec64, fsrc, i)\n+                       .rearrange(shuffle)\n+                       .intoArray(fdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VF, IRNode.VECTOR_SIZE_4, \" >0 \"})\n+    public void rearrange_float128() {\n+        VectorShuffle<Float> shuffle = VectorShuffle.fromArray(fspec128, indexes[1], 0);\n+        for (int i = 0; i < LENGTH; i += fspec128.length()) {\n+            FloatVector.fromArray(fspec128, fsrc, i)\n+                       .rearrange(shuffle)\n+                       .intoArray(fdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VD, IRNode.VECTOR_SIZE_2, \" >0 \"}, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public void rearrange_double128() {\n+        VectorShuffle<Double> shuffle = VectorShuffle.fromArray(dspec128, indexes[0], 0);\n+        for (int i = 0; i < LENGTH; i += dspec128.length()) {\n+            DoubleVector.fromArray(dspec128, dsrc, i)\n+                        .rearrange(shuffle)\n+                        .intoArray(ddst, i);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(10000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:-TieredCompilation\")\n+                     .start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorRearrangeTest.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"}]}