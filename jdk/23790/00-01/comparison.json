{"files":[{"patch":"@@ -332,0 +332,30 @@\n+    public static final String REARRANGE_VB = VECTOR_PREFIX + \"REARRANGE_VB\" + POSTFIX;\n+    static {\n+        vectorNode(REARRANGE_VB, \"VectorRearrange\", TYPE_BYTE);\n+    }\n+\n+    public static final String REARRANGE_VS = VECTOR_PREFIX + \"REARRANGE_VS\" + POSTFIX;\n+    static {\n+        vectorNode(REARRANGE_VS, \"VectorRearrange\", TYPE_SHORT);\n+    }\n+\n+    public static final String REARRANGE_VI = VECTOR_PREFIX + \"REARRANGE_VI\" + POSTFIX;\n+    static {\n+        vectorNode(REARRANGE_VI, \"VectorRearrange\", TYPE_INT);\n+    }\n+\n+    public static final String REARRANGE_VL = VECTOR_PREFIX + \"REARRANGE_VL\" + POSTFIX;\n+    static {\n+        vectorNode(REARRANGE_VL, \"VectorRearrange\", TYPE_LONG);\n+    }\n+\n+    public static final String REARRANGE_VF = VECTOR_PREFIX + \"REARRANGE_VF\" + POSTFIX;\n+    static {\n+        vectorNode(REARRANGE_VF, \"VectorRearrange\", TYPE_FLOAT);\n+    }\n+\n+    public static final String REARRANGE_VD = VECTOR_PREFIX + \"REARRANGE_VD\" + POSTFIX;\n+    static {\n+        vectorNode(REARRANGE_VD, \"VectorRearrange\", TYPE_DOUBLE);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8350463\n+ * @summary AArch64: Add vector rearrange support for small lane count vectors\n+ * @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx.*\") | os.arch==\"aarch64\"\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ *\n+ * @run driver compiler.vectorapi.VectorRearrangeTest\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.*;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class VectorRearrangeTest {\n+    private static final int LENGTH = 2048;\n+    private static final Random random = Utils.getRandomInstance();\n+\n+    private static final VectorSpecies<Byte> bspec128    = ByteVector.SPECIES_128;\n+    private static final VectorSpecies<Short> sspec128   = ShortVector.SPECIES_128;\n+    private static final VectorSpecies<Integer> ispec128 = IntVector.SPECIES_128;\n+    private static final VectorSpecies<Long> lspec128    = LongVector.SPECIES_128;\n+    private static final VectorSpecies<Float> fspec128   = FloatVector.SPECIES_128;\n+    private static final VectorSpecies<Double> dspec128  = DoubleVector.SPECIES_128;\n+    private static final VectorSpecies<Byte> bspec64     = ByteVector.SPECIES_64;\n+    private static final VectorSpecies<Short> sspec64    = ShortVector.SPECIES_64;\n+    private static final VectorSpecies<Integer> ispec64  = IntVector.SPECIES_64;\n+    private static final VectorSpecies<Float> fspec64    = FloatVector.SPECIES_64;\n+\n+    private static byte[]   bsrc;\n+    private static short[]  ssrc;\n+    private static int[]    isrc;\n+    private static long[]   lsrc;\n+    private static float[]  fsrc;\n+    private static double[] dsrc;\n+\n+    private static byte[]   bdst;\n+    private static short[]  sdst;\n+    private static int[]    idst;\n+    private static long[]   ldst;\n+    private static float[]  fdst;\n+    private static double[] ddst;\n+\n+    private static int[][] indexes;\n+\n+    static {\n+        bsrc = new byte[LENGTH];\n+        ssrc = new short[LENGTH];\n+        isrc = new int[LENGTH];\n+        lsrc = new long[LENGTH];\n+        fsrc = new float[LENGTH];\n+        dsrc = new double[LENGTH];\n+        bdst = new byte[LENGTH];\n+        sdst = new short[LENGTH];\n+        idst = new int[LENGTH];\n+        ldst = new long[LENGTH];\n+        fdst = new float[LENGTH];\n+        ddst = new double[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; ++i) {\n+            bsrc[i] = (byte)random.nextInt();\n+            ssrc[i] = (short)random.nextInt();\n+            isrc[i] = random.nextInt();\n+            lsrc[i] = random.nextLong();\n+            fsrc[i] = random.nextFloat();\n+            dsrc[i] = random.nextDouble();\n+        }\n+\n+        int[] nums = {2, 4, 8, 16};\n+        indexes = new int[4][];\n+        for (int i = 0; i < 4; i++) {\n+            indexes[i] = new int[nums[i]];\n+            for (int j = 0; j < nums[i]; j++) {\n+                indexes[i][j] = random.nextInt() & (nums[i] - 1);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VB, IRNode.VECTOR_SIZE_8, \" >0 \"})\n+    public void rearrange_byte64() {\n+        VectorShuffle<Byte> shuffle = VectorShuffle.fromArray(bspec64, indexes[2], 0);\n+        for (int i = 0; i < LENGTH; i += bspec64.length()) {\n+            ByteVector.fromArray(bspec64, bsrc, i)\n+                      .rearrange(shuffle)\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VB, IRNode.VECTOR_SIZE_16, \" >0 \"})\n+    public void rearrange_byte128() {\n+        VectorShuffle<Byte> shuffle = VectorShuffle.fromArray(bspec128, indexes[3], 0);\n+        for (int i = 0; i < LENGTH; i += bspec128.length()) {\n+            ByteVector.fromArray(bspec128, bsrc, i)\n+                      .rearrange(shuffle)\n+                      .intoArray(bdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VS, IRNode.VECTOR_SIZE_4, \" >0 \"})\n+    public void rearrange_short64() {\n+        VectorShuffle<Short> shuffle = VectorShuffle.fromArray(sspec64, indexes[1], 0);\n+        for (int i = 0; i < LENGTH; i += sspec64.length()) {\n+            ShortVector.fromArray(sspec64, ssrc, i)\n+                       .rearrange(shuffle)\n+                       .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VS, IRNode.VECTOR_SIZE_8, \" >0 \"})\n+    public void rearrange_short128() {\n+        VectorShuffle<Short> shuffle = VectorShuffle.fromArray(sspec128, indexes[2], 0);\n+        for (int i = 0; i < LENGTH; i += sspec128.length()) {\n+            ShortVector.fromArray(sspec128, ssrc, i)\n+                       .rearrange(shuffle)\n+                       .intoArray(sdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VI, IRNode.VECTOR_SIZE_2, \" >0 \"}, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public void rearrange_int64() {\n+        VectorShuffle<Integer> shuffle = VectorShuffle.fromArray(ispec64, indexes[0], 0);\n+        for (int i = 0; i < LENGTH; i += ispec64.length()) {\n+            IntVector.fromArray(ispec64, isrc, i)\n+                     .rearrange(shuffle)\n+                     .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VI, IRNode.VECTOR_SIZE_4, \" >0 \"})\n+    public void rearrange_int128() {\n+        VectorShuffle<Integer> shuffle = VectorShuffle.fromArray(ispec128, indexes[1], 0);\n+        for (int i = 0; i < LENGTH; i += ispec128.length()) {\n+            IntVector.fromArray(ispec128, isrc, i)\n+                     .rearrange(shuffle)\n+                     .intoArray(idst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VL, IRNode.VECTOR_SIZE_2, \" >0 \"}, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public void rearrange_long128() {\n+        VectorShuffle<Long> shuffle = VectorShuffle.fromArray(lspec128, indexes[0], 0);\n+        for (int i = 0; i < LENGTH; i += lspec128.length()) {\n+            LongVector.fromArray(lspec128, lsrc, i)\n+                      .rearrange(shuffle)\n+                      .intoArray(ldst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VF, IRNode.VECTOR_SIZE_2, \" >0 \"}, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public void rearrange_float64() {\n+        VectorShuffle<Float> shuffle = VectorShuffle.fromArray(fspec64, indexes[0], 0);\n+        for (int i = 0; i < LENGTH; i += fspec64.length()) {\n+            FloatVector.fromArray(fspec64, fsrc, i)\n+                       .rearrange(shuffle)\n+                       .intoArray(fdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VF, IRNode.VECTOR_SIZE_4, \" >0 \"})\n+    public void rearrange_float128() {\n+        VectorShuffle<Float> shuffle = VectorShuffle.fromArray(fspec128, indexes[1], 0);\n+        for (int i = 0; i < LENGTH; i += fspec128.length()) {\n+            FloatVector.fromArray(fspec128, fsrc, i)\n+                       .rearrange(shuffle)\n+                       .intoArray(fdst, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.REARRANGE_VD, IRNode.VECTOR_SIZE_2, \" >0 \"}, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public void rearrange_double128() {\n+        VectorShuffle<Double> shuffle = VectorShuffle.fromArray(dspec128, indexes[0], 0);\n+        for (int i = 0; i < LENGTH; i += dspec128.length()) {\n+            DoubleVector.fromArray(dspec128, dsrc, i)\n+                        .rearrange(shuffle)\n+                        .intoArray(ddst, i);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(10000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:-TieredCompilation\")\n+                     .start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorRearrangeTest.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"}]}