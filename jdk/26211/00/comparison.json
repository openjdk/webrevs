{"files":[{"patch":"@@ -41,1 +41,6 @@\n-@StackFilter({\"java.io.FileInputStream\", \"java.io.RandomAccessFile\", \"sun.nio.ch.FileChannelImpl\"})\n+@StackFilter({\"java.nio.channels.FileChannel\",\n+              \"java.io.DataInputStream\",\n+              \"java.io.FileInputStream\",\n+              \"java.io.InputStream\",\n+              \"java.io.RandomAccessFile\",\n+              \"sun.nio.ch.FileChannelImpl\"})\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/FileReadEvent.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,1 +41,5 @@\n-@StackFilter({\"java.io.FileOutputStream\", \"java.io.RandomAccessFile\", \"sun.nio.ch.FileChannelImpl\"})\n+@StackFilter({\"java.nio.channels.FileChannel\",\n+              \"java.io.DataOutputStream\",\n+              \"java.io.FileOutputStream\",\n+              \"java.io.RandomAccessFile\",\n+              \"sun.nio.ch.FileChannelImpl\"})\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/FileWriteEvent.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,0 +42,4 @@\n+@StackFilter({\"java.io.InputStream\",\n+              \"java.net.Socket$SocketInputStream\",\n+              \"java.nio.channels.SocketChannel\",\n+              \"sun.nio.ch.SocketInputStream\"})\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SocketReadEvent.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,4 @@\n+@StackFilter({\"java.io.OutputStream\",\n+              \"java.net.Socket$SocketOutputStream\",\n+              \"java.nio.channels.SocketChannel\",\n+              \"sun.nio.ch.SocketOutputStream\"})\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SocketWriteEvent.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,12 +98,0 @@\n-    private boolean isStaticCommit() {\n-        switch (getName()) {\n-            case Type.EVENT_NAME_PREFIX + \"SocketRead\"  :\n-            case Type.EVENT_NAME_PREFIX + \"SocketWrite\" :\n-            case Type.EVENT_NAME_PREFIX + \"FileRead\"    :\n-            case Type.EVENT_NAME_PREFIX + \"FileWrite\"   :\n-            case Type.EVENT_NAME_PREFIX + \"FileForce\"   :\n-                return true;\n-        }\n-        return false;\n-    }\n-\n@@ -119,3 +107,8 @@\n-            if (isStaticCommit()) {\n-                return 3;\n-            }\n+            return switch (getName()) {\n+                case Type.EVENT_NAME_PREFIX + \"SocketRead\",\n+                     Type.EVENT_NAME_PREFIX + \"SocketWrite\",\n+                     Type.EVENT_NAME_PREFIX + \"FileRead\",\n+                     Type.EVENT_NAME_PREFIX + \"FileWrite\" -> 6;\n+                case Type.EVENT_NAME_PREFIX + \"FileForce\" -> 5;\n+                default -> 3;\n+            };\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,336 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.io;\n+\n+import static java.nio.file.StandardOpenOption.READ;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.nio.channels.AsynchronousFileChannel;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordedStackTrace;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+\/**\n+ * @test TestIOTopFrame\n+ * @summary Tests that the top frames of I\/O events are as expected.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.event.io.TestIOTopFrame\n+ *\/\n+\n+\/\/ Lines commented with a number indicate that they are the nth event for that\n+\/\/ top frame. The invocation of the methods RandomAccessFile::readUTF(),\n+\/\/ SocketInputStream::readNBytes(...) and FileInputStream::readAllBytes()\n+\/\/ results in 2-3 events.\n+public class TestIOTopFrame {\n+    private static final String EVENT_FILE_READ = \"jdk.FileRead\";\n+    private static final String EVENT_FILE_FORCE = \"jdk.FileForce\";\n+    private static final String EVENT_FILE_WRITE = \"jdk.FileWrite\";\n+    private static final String EVENT_SOCKET_READ = \"jdk.SocketRead\";\n+    private static final String EVENT_SOCKET_WRITE = \"jdk.SocketWrite\";\n+\n+    public static void main(String... args) throws Exception {\n+        testFileRead();\n+        testFileWrite();\n+        testSocketStreams();\n+        testSocketChannels();\n+    }\n+\n+    private static void testFileRead() throws Exception {\n+        printTestDescription(EVENT_FILE_READ, \"RandomAccessFile and FileInputStream\");\n+        File f1 = new File(\"testFileRead-1.bin\");\n+        writeRAF(f1);\n+        File f2 = new File(\"testFileRead-2.bin\");\n+        writeStream(f2);\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_FILE_READ).withStackTrace();\n+            r.start();\n+            readRAF(f1);\n+            readStream(f2);\n+            r.stop();\n+            assertTopFrames(r, \"readRAF\", 20, \"readStream\", 8);\n+        }\n+    }\n+\n+    private static void testFileWrite() throws Exception {\n+        printTestDescription(EVENT_FILE_WRITE + \", \" + EVENT_FILE_FORCE, \"RandomAccessFile and FileInputStream\");\n+        File f = new File(\"testFileWrite.bin\");\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_FILE_WRITE).withStackTrace();\n+            r.enable(EVENT_FILE_FORCE).withStackTrace();\n+            r.start();\n+            writeRAF(f);\n+            writeStream(f);\n+            writeAsync(f);\n+            r.stop();\n+            assertTopFrames(r, \"writeRAF\", 17, \"writeStream\", 3, \"writeAsync\", 1);\n+        }\n+    }\n+\n+    private static void writeAsync(File file) throws Exception {\n+        AsynchronousFileChannel channel = AsynchronousFileChannel.open(file.toPath(), READ, WRITE);\n+        ByteBuffer[] buffers = createBuffers();\n+        channel.force(true);\n+    }\n+\n+    private static void writeStream(File f) throws Exception {\n+        byte[] bytes = new byte[200];\n+        try (FileOutputStream fos = new FileOutputStream(f)) {\n+            fos.write(67); \/\/ 1\n+            fos.write(bytes); \/\/ 2\n+            fos.write(bytes, 0, 1); \/\/ 3\n+        }\n+    }\n+\n+    private static void writeRAF(File file) throws Exception {\n+        ByteBuffer[] buffers = createBuffers();\n+        byte[] bytes = new byte[100];\n+        try (RandomAccessFile raf = new RandomAccessFile(file, \"rw\")) {\n+            raf.writeUTF(\"o\\n\"); \/\/ 1\n+            raf.writeUTF(\"hello\"); \/\/ 2\n+            raf.write(23); \/\/ 3\n+            raf.write(bytes); \/\/ 4\n+            raf.write(bytes, 0, 50); \/\/ 5\n+            raf.writeBoolean(true); \/\/ 6\n+            raf.writeByte(23); \/\/ 7\n+            raf.writeBytes(\"hello\"); \/\/ 8\n+            raf.writeChar('h'); \/\/ 9\n+            raf.writeChars(\"hello\"); \/\/ 10\n+            raf.writeDouble(76.0); \/\/ 11\n+            raf.writeFloat(21.7f); \/\/ 12\n+            raf.writeInt(4711); \/\/ 13\n+            raf.writeLong(Long.MAX_VALUE); \/\/ 14\n+            FileChannel fc = raf.getChannel();\n+            fc.write(buffers[0]); \/\/ 15\n+            fc.write(buffers); \/\/ 16\n+            fc.force(true); \/\/ 17\n+        }\n+    }\n+\n+    private static void readStream(File f) throws Exception {\n+        byte[] bytes = new byte[10];\n+        try (FileInputStream fis = new FileInputStream(f)) {\n+            fis.read(); \/\/ 1\n+            fis.read(bytes); \/\/ 2\n+            fis.read(bytes, 0, 3); \/\/ 3\n+            fis.readNBytes(2); \/\/ 4\n+            fis.readNBytes(bytes, 0, 1); \/\/ 5\n+            byte[] leftOver = fis.readAllBytes(); \/\/ 6, 7, 8\n+            if (leftOver.length < 1) {\n+                throw new Exception(\"Expected some bytes to be read\");\n+            }\n+        }\n+    }\n+\n+    private static void readRAF(File file) throws Exception {\n+        ByteBuffer[] buffers = createBuffers();\n+        byte[] bytes = new byte[100];\n+        try (RandomAccessFile raf = new RandomAccessFile(file, \"r\")) {\n+            raf.readLine(); \/\/ 1\n+            raf.readUTF(); \/\/ 2, 3 (size and content)\n+            raf.read(); \/\/ 4\n+            raf.read(bytes); \/\/ 5\n+            raf.read(bytes, 0, 0); \/\/ 6\n+            raf.readBoolean(); \/\/ 7\n+            raf.readByte(); \/\/ 8\n+            raf.readChar(); \/\/ 9\n+            raf.readDouble(); \/\/ 10\n+            raf.readFloat(); \/\/ 11\n+            raf.seek(0);\n+            raf.readFully(bytes); \/\/ 12\n+            raf.seek(0);\n+            raf.readFully(bytes, 10, 10); \/\/ 13\n+            raf.readInt(); \/\/ 14\n+            raf.readLong(); \/\/ 15\n+            raf.readShort(); \/\/ 16\n+            raf.readUnsignedByte(); \/\/ 17\n+            raf.readUnsignedShort(); \/\/ 18\n+            FileChannel fc = raf.getChannel();\n+            fc.read(buffers[0]); \/\/ 19\n+            if (fc.read(buffers) < 1) { \/\/ 20\n+                throw new Exception(\"Expected som bytes to be read\");\n+            };\n+        }\n+    }\n+\n+    private static void testSocketChannels() throws Exception {\n+        printTestDescription(EVENT_SOCKET_READ + \", \" + EVENT_SOCKET_WRITE, \"SocketChannel and Socket adapters\");\n+        try (Recording r = new Recording()) {\n+            try (ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+                ssc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+                r.enable(EVENT_SOCKET_READ).withStackTrace();\n+                r.enable(EVENT_SOCKET_WRITE).withStackTrace();\n+                r.start();\n+                Thread readerThread = Thread.ofPlatform().start(() -> readSocketChannel(ssc));\n+                writeSocketChannel(ssc);\n+                readerThread.join();\n+                r.stop();\n+                assertTopFrames(r, \"readSocket\", 6, \"readSocketChannel\", 2, \"writeSocket\", 3, \"writeSocketChannel\", 2);\n+            }\n+        }\n+    }\n+\n+    private static void readSocketChannel(ServerSocketChannel ssc) {\n+        ByteBuffer[] buffers = createBuffers();\n+        try (SocketChannel sc = ssc.accept()) {\n+            sc.read(buffers[0]); \/\/ 1\n+            sc.read(buffers); \/\/ 2\n+            try (InputStream is = sc.socket().getInputStream();) {\n+                readSocket(is);\n+            }\n+        } catch (Exception ioe) {\n+            throw new RuntimeException(ioe);\n+        }\n+    }\n+\n+    private static void writeSocketChannel(ServerSocketChannel ssc) throws Exception {\n+        ByteBuffer[] buffers = createBuffers();\n+        try (SocketChannel sc = SocketChannel.open(ssc.getLocalAddress())) {\n+            sc.write(buffers[0]); \/\/ 1\n+            sc.write(buffers); \/\/ 2\n+            try (OutputStream out = sc.socket().getOutputStream()) {\n+                writeSocket(out);\n+            }\n+        }\n+    }\n+\n+    private static void testSocketStreams() throws Exception {\n+        printTestDescription(EVENT_SOCKET_READ + \", \" + EVENT_SOCKET_WRITE, \"SocketInputStream and SocketOutputStream\");\n+        try (ServerSocket serverSocket = new ServerSocket(0);\n+             Socket client = new Socket(\"localhost\", serverSocket.getLocalPort());\n+             Socket server = serverSocket.accept();\n+             OutputStream socketOut = client.getOutputStream();\n+             InputStream socketIn = server.getInputStream();\n+             Recording r = new Recording()) {\n+            r.enable(EVENT_SOCKET_READ).withStackTrace();\n+            r.enable(EVENT_SOCKET_WRITE).withStackTrace();\n+            r.start();\n+            Thread readerThread = Thread.ofPlatform().start(() -> readSocket(socketIn));\n+            writeSocket(socketOut);\n+            readerThread.join();\n+            r.stop();\n+            assertTopFrames(r, \"readSocket\", 6, \"writeSocket\", 3);\n+        }\n+    }\n+\n+    private static void writeSocket(OutputStream socketOut) throws Exception {\n+        byte[] bytes = \"hello, world!\".getBytes();\n+        socketOut.write(bytes); \/\/ 1\n+        socketOut.write(4711); \/\/ 2\n+        socketOut.write(bytes, 0, 3); \/\/ 3\n+    }\n+\n+    private static void readSocket(InputStream socketIn) {\n+        try {\n+            byte[] bytes = new byte[100];\n+            socketIn.read(); \/\/ 1\n+            socketIn.read(bytes, 0, 3); \/\/ 2\n+            socketIn.readNBytes(3); \/\/ 3, 4\n+            socketIn.readNBytes(bytes, 0, 2); \/\/ 5\n+            if (socketIn.read(bytes) < 1) { \/\/ 6\n+                throw new RuntimeException(\"Expected some bytes to be read\");\n+            }\n+        } catch (IOException ioe) {\n+            throw new RuntimeException(ioe);\n+        }\n+    }\n+\n+    private static void assertTopFrames(Recording r, Object... frameCount) throws Exception {\n+        TreeMap<String, Integer> expected = new TreeMap<>();\n+        for (int i = 0; i < frameCount.length; i += 2) {\n+            String method = TestIOTopFrame.class.getName() + \"::\" + frameCount[i];\n+            Integer count = (Integer) frameCount[i + 1];\n+            expected.put(method, count);\n+        }\n+        Path dumpFile = Path.of(\"test-top-frame-\" + r.getId() + \".jfr\");\n+        r.dump(dumpFile);\n+        List<RecordedEvent> events = RecordingFile.readAllEvents(dumpFile);\n+        TreeMap<String, Integer> actual = new TreeMap<>();\n+        for (RecordedEvent e : events) {\n+            RecordedStackTrace st = e.getStackTrace();\n+            RecordedMethod topMethod = st.getFrames().get(0).getMethod();\n+            String methodName = topMethod.getType().getName() + \"::\" + topMethod.getName();\n+            actual.merge(methodName, 1, Integer::sum);\n+        }\n+\n+        printMap(\"Expected\", expected);\n+        printMap(\"Actual\", actual);\n+        if (!expected.equals(actual)) {\n+            System.out.println(events);\n+            throw new Exception(\"Top methods are not as expected\");\n+        }\n+        Files.delete(dumpFile);\n+    }\n+\n+    private static void printTestDescription(String eventNames, String components) {\n+        String title = \"Testing top frames for events: \" + eventNames + \" (\" + components + \")\";\n+        System.out.println(title);\n+        System.out.println(\"*\".repeat(title.length()));\n+    }\n+\n+    private static void printMap(String title, TreeMap<String, Integer> map) {\n+        System.out.println(title + \":\");\n+        for (var entry : map.entrySet()) {\n+            System.out.println(entry.getKey() + \"\\t\" + entry.getValue());\n+        }\n+        System.out.println();\n+    }\n+\n+    private static ByteBuffer[] createBuffers() {\n+        byte[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n+        ByteBuffer buffer = ByteBuffer.wrap(data);\n+        ByteBuffer[] buffers = new ByteBuffer[2];\n+        buffers[0] = buffer.duplicate();\n+        buffers[1] = buffer.duplicate();\n+        return buffers;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestIOTopFrame.java","additions":336,"deletions":0,"binary":false,"changes":336,"status":"added"}]}