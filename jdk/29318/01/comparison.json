{"files":[{"patch":"@@ -1271,1 +1271,0 @@\n-  inline static bool is_obj_filler(const oop obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"gc\/shared\/collectedHeap.inline.hpp\"\n@@ -232,5 +233,0 @@\n-inline bool G1CollectedHeap::is_obj_filler(const oop obj) {\n-  Klass* k = obj->klass_without_asserts();\n-  return k == Universe::fillerArrayKlass() || k == vmClasses::FillerObject_klass();\n-}\n-\n@@ -241,1 +237,1 @@\n-    return is_obj_filler(obj);\n+    return is_filler_object(obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+#include \"gc\/shared\/collectedHeap.inline.hpp\"\n@@ -935,0 +936,11 @@\n+void PSParallelCompact::report_object_count_after_gc() {\n+  GCTraceTime(Debug, gc, phases) tm(\"Report Object Count\", &_gc_timer);\n+  \/\/ The heap is compacted, all objects are iterable. However there may be\n+  \/\/ filler objects in the heap which we should ignore.\n+  class SkipFillerObjectClosure : public BoolObjectClosure {\n+  public:\n+    bool do_object_b(oop obj) override { return !CollectedHeap::is_filler_object(obj); }\n+  } cl;\n+  _gc_tracer.report_object_count_after_gc(&cl, &ParallelScavengeHeap::heap()->workers());\n+}\n+\n@@ -1030,0 +1042,2 @@\n+    report_object_count_after_gc();\n+\n@@ -1277,4 +1291,0 @@\n-  {\n-    GCTraceTime(Debug, gc, phases) tm(\"Report Object Count\", &_gc_timer);\n-    _gc_tracer.report_object_count_after_gc(is_alive_closure(), &ParallelScavengeHeap::heap()->workers());\n-  }\n@@ -1838,2 +1848,1 @@\n-        Klass* k = cast_to_oop(cur_addr)->klass();\n-        assert(k == Universe::fillerArrayKlass() || k == vmClasses::FillerObject_klass(), \"inv\");\n+        assert(CollectedHeap::is_filler_object(cast_to_oop(cur_addr)), \"inv\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -752,0 +752,1 @@\n+  static void report_object_count_after_gc();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -312,0 +312,2 @@\n+  inline static bool is_filler_object(oop obj);\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"memory\/universe.hpp\"\n@@ -53,0 +55,5 @@\n+inline bool CollectedHeap::is_filler_object(oop obj) {\n+  Klass* k = obj->klass_without_asserts();\n+  return k == Universe::fillerArrayKlass() || k == vmClasses::FillerObject_klass();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.inline.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.parallel;\n+\n+\/*\n+ * @test TestObjectCountAfterGC\n+ * @bug 8375314\n+ * @summary Verifies that the HeapInspection VM operation for the ObjectCountAfterGC JFR event does not crash the VM.\n+ *          Creates a set of custom classes that are about to be unloaded to cause metaspace to uncommit pages. When\n+ *          the execution of the heap inspection iterates over the heap, it will come across these unloaded classes\n+ *          referencing uncommitted memory, crashing.\n+ * @requires vm.gc.Parallel\n+ * @requires vm.opt.final.ClassUnloading\n+ * @library \/test\/lib\n+ * @library \/testlibrary\/asm\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -XX:+UseParallelGC -Xlog:gc=debug,metaspace=info -XX:StartFlightRecording:gc=all,duration=1s,filename=myrecording.jfr\n+ *                   gc.parallel.TestObjectCountAfterGC\n+ *\/\n+\n+import java.lang.ref.Reference;\n+\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+\n+public class TestObjectCountAfterGC {\n+\n+    static final String className = \"ClassToLoadUnload\";\n+\n+    public static void main(String args[]) throws Exception {\n+        final int KEEPALIVE_LENGTH = 100;\n+\n+        Object[] keepalive = new Object[KEEPALIVE_LENGTH];\n+\n+        for (int i = 1; i < 1000; i++) {\n+            ClassLoader cl = new MyClassLoader();\n+            Object o = null;\n+            \/\/ Create some random kept alive objects so that the\n+            \/\/ compaction regions are not totally empty and the\n+            \/\/ heap inspection VM operation needs to iterate them.\n+            keepalive[(i \/ KEEPALIVE_LENGTH) % KEEPALIVE_LENGTH] = new int[100];\n+            o = cl.loadClass(className + i).newInstance();\n+\n+            cl = null;\n+            o = null;\n+        }\n+\n+        \/\/ There is heap inspection VM operation for the ObjectCountAfterGC event\n+        \/\/ when JFR stops recording.\n+\n+        Reference.reachabilityFence(keepalive);\n+    }\n+}\n+\n+class MyClassLoader extends ClassLoader {\n+\n+    \/\/ Create a class of the given name with a default constructor.\n+    public byte[] createClass(String name) {\n+        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);\n+        cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER, name, null, \"java\/lang\/Object\", null);\n+        \/\/ Add default constructor that just calls the super class constructor.\n+        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n+        mv.visitCode();\n+        mv.visitVarInsn(Opcodes.ALOAD, 0);\n+        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n+        mv.visitInsn(Opcodes.RETURN);\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+        return cw.toByteArray();\n+    }\n+\n+    \/\/ If the given name starts with \"TestObjectCountAfterGC\" create a new class on the fly,\n+    \/\/ delegate otherwise.\n+    public Class<?> loadClass(String name) throws ClassNotFoundException {\n+        if (!name.startsWith(TestObjectCountAfterGC.className)) {\n+            return super.loadClass(name);\n+        }\n+        byte[] cls = createClass(name);\n+        return defineClass(name, cls, 0, cls.length, null);\n+    }\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/gc\/parallel\/TestObjectCountAfterGC.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"}]}