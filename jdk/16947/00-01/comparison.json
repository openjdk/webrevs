{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import java.nio.file.Path;\n@@ -35,0 +36,1 @@\n+import java.lang.classfile.ClassHierarchyResolver;\n@@ -36,0 +38,2 @@\n+import java.lang.classfile.CodeModel;\n+import java.lang.classfile.MethodModel;\n@@ -56,0 +60,26 @@\n+\n+    @Test\n+    void testFailed() throws IOException {\n+        Path path = FileSystems.getFileSystem(URI.create(\"jrt:\/\")).getPath(\"modules\/java.base\/java\/util\/HashMap.class\");\n+        var cc = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(\n+                className -> ClassHierarchyResolver.ClassHierarchyInfo.ofClass(null)));\n+        var classModel = cc.parse(path);\n+        byte[] brokenClassBytes = cc.transform(classModel,\n+                (clb, cle) -> {\n+                    if (cle instanceof MethodModel mm) {\n+                        clb.transformMethod(mm, (mb, me) -> {\n+                            if (me instanceof CodeModel cm) {\n+                                mb.withCode(cob -> cm.forEachElement(cob));\n+                            }\n+                            else\n+                                mb.with(me);\n+                        });\n+                    }\n+                    else\n+                        clb.with(cle);\n+                });\n+        StringBuilder sb = new StringBuilder();\n+        if (ClassFile.of().verify(brokenClassBytes).isEmpty()) {\n+            throw new AssertionError(\"expected verification failure\");\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/VerifierSelfTest.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"}]}