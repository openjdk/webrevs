{"files":[{"patch":"@@ -46,0 +46,1 @@\n+import java.util.List;\n@@ -484,0 +485,27 @@\n+    \/**\n+     * Verify a classfile.  Any verification errors found will be returned.\n+     * @param model the class model to verify\n+     * @return a list of verification errors, or an empty list if no errors are\n+     * found\n+     *\/\n+    List<VerifyError> verify(ClassModel model);\n+\n+    \/**\n+     * Verify a classfile.  Any verification errors found will be returned.\n+     * @param bytes the classfile bytes to verify\n+     * @return a list of verification errors, or an empty list if no errors are\n+     * found\n+     *\/\n+    List<VerifyError> verify(byte[] bytes);\n+\n+    \/**\n+     * Verify a classfile.  Any verification errors found will be returned.\n+     * @param path the classfile path to verify\n+     * @return a list of verification errors, or an empty list if no errors are\n+     * found\n+     * @throws java.io.IOException if an I\/O error occurs\n+     *\/\n+    default List<VerifyError> verify(Path path) throws IOException {\n+        return verify(Files.readAllBytes(path));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -81,25 +81,0 @@\n-\n-    \/**\n-     * Verify this classfile.  Any verification errors found will be returned.\n-     *\n-     * @param debugOutput handler to receive debug information\n-     * @return a list of verification errors, or an empty list if no errors are\n-     * found\n-     *\/\n-    default List<VerifyError> verify(Consumer<String> debugOutput) {\n-        return VerifierImpl.verify(this, debugOutput);\n-    }\n-\n-    \/**\n-     * Verify this classfile.  Any verification errors found will be returned.\n-     *\n-     * @param debugOutput handler to receive debug information\n-     * @param classHierarchyResolver class hierarchy resolver to provide\n-     *                               additional information about the class hierarchy\n-     * @return a list of verification errors, or an empty list if no errors are\n-     * found\n-     *\/\n-    default List<VerifyError> verify(ClassHierarchyResolver classHierarchyResolver,\n-                                     Consumer<String> debugOutput) {\n-        return VerifierImpl.verify(this, classHierarchyResolver, debugOutput);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassModel.java","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -280,2 +280,2 @@\n- * More complex verification of a classfile can be achieved by explicit invocation\n- * of {@link java.lang.classfile.ClassModel#verify}.\n+ * More complex verification of a classfile can be achieved by invocation of\n+ * {@link java.lang.classfile.ClassFile#verify}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.internal.classfile.impl.verifier.VerifierImpl;\n@@ -131,0 +132,15 @@\n+\n+    @Override\n+    public List<VerifyError> verify(ClassModel model) {\n+        return VerifierImpl.verify(model, classHierarchyResolverOption().classHierarchyResolver(), null);\n+    }\n+\n+    @Override\n+    public List<VerifyError> verify(byte[] bytes) {\n+        try {\n+            return verify(parse(bytes));\n+        } catch (IllegalArgumentException parsingError) {\n+            return List.of(new VerifyError(parsingError.getMessage()));\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassFileImpl.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-            List<VerifyError> errors = ClassFile.of().parse(bytes).verify(null);\n+            List<VerifyError> errors = ClassFile.of().verify(bytes);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-            var remapped = cc.parse(cc.transform(clm, (clb, cle) -> {\n+            cc.verify(cc.transform(clm, (clb, cle) -> {\n@@ -102,1 +102,0 @@\n-            remapped.verify(null);\n@@ -118,1 +117,1 @@\n-            assertEmpty(remapped.verify(\n+            assertEmpty(ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(\n@@ -123,1 +122,1 @@\n-                    , null)); \/\/System.out::print));\n+                    )).verify(remapped));\n@@ -242,1 +241,1 @@\n-        assertEmpty(cc.parse(instrumentedBytes).verify(null)); \/\/System.out::print));\n+        assertEmpty(cc.verify(instrumentedBytes));\n","filename":"test\/jdk\/jdk\/classfile\/AdvancedTransformationsTest.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-        var errors = ClassFile.of().parse(newBytes).verify(null);\n+        var errors = ClassFile.of().verify(newBytes);\n","filename":"test\/jdk\/jdk\/classfile\/ClassHierarchyInfoTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-        assertEmpty(newModel.verify(null));\n+        assertEmpty(cc.verify(newModel));\n","filename":"test\/jdk\/jdk\/classfile\/CorpusTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-         assertEmpty(cc.parse(cc.transform(\n+         assertEmpty(cc.verify(cc.transform(\n@@ -235,2 +235,1 @@\n-                                                  .andThen(ClassTransform.endHandler(clb -> clb.withVersion(50, 0)))))\n-                              .verify(null));\n+                                                  .andThen(ClassTransform.endHandler(clb -> clb.withVersion(50, 0))))));\n@@ -274,1 +273,1 @@\n-        assertEmpty(cc.parse(transformedBytes).verify(null));\n+        assertEmpty(cc.verify(transformedBytes));\n","filename":"test\/jdk\/jdk\/classfile\/StackMapsTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.nio.file.Path;\n@@ -36,1 +35,0 @@\n-import java.lang.classfile.ClassHierarchyResolver;\n@@ -38,2 +36,0 @@\n-import java.lang.classfile.CodeModel;\n-import java.lang.classfile.MethodModel;\n@@ -54,1 +50,1 @@\n-                            ClassFile.of().parse(path).verify(null);\n+                            ClassFile.of().verify(path);\n@@ -60,31 +56,0 @@\n-\n-    @Test\n-    void testFailedDump() throws IOException {\n-        Path path = FileSystems.getFileSystem(URI.create(\"jrt:\/\")).getPath(\"modules\/java.base\/java\/util\/HashMap.class\");\n-        var cc = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(\n-                className -> ClassHierarchyResolver.ClassHierarchyInfo.ofClass(null)));\n-        var classModel = cc.parse(path);\n-        byte[] brokenClassBytes = cc.transform(classModel,\n-                (clb, cle) -> {\n-                    if (cle instanceof MethodModel mm) {\n-                        clb.transformMethod(mm, (mb, me) -> {\n-                            if (me instanceof CodeModel cm) {\n-                                mb.withCode(cob -> cm.forEachElement(cob));\n-                            }\n-                            else\n-                                mb.with(me);\n-                        });\n-                    }\n-                    else\n-                        clb.with(cle);\n-                });\n-        StringBuilder sb = new StringBuilder();\n-        if (ClassFile.of().parse(brokenClassBytes).verify(sb::append).isEmpty()) {\n-            throw new AssertionError(\"expected verification failure\");\n-        }\n-        String output = sb.toString();\n-        if (!output.contains(\"- method name: \")) {\n-            System.out.println(output);\n-            throw new AssertionError(\"failed method not dumped to output\");\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/classfile\/VerifierSelfTest.java","additions":1,"deletions":36,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-        var errors = ClassFile.of().parse(clazz).verify(\n+        var errors = ClassFile.of(\n@@ -228,2 +228,2 @@\n-                cls -> ClassHierarchyResolver.ClassHierarchyInfo.ofInterface(),\n-                null);\n+                ClassFile.ClassHierarchyResolverOption.of(cls -> ClassHierarchyResolver.ClassHierarchyInfo.ofInterface()))\n+                .verify(clazz);\n","filename":"test\/jdk\/tools\/lib\/tests\/JImageValidator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}