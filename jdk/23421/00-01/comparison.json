{"files":[{"patch":"@@ -417,2 +417,0 @@\n-  \/\/ Refer to the comments in synchronizer.cpp for how we might encode extra\n-  \/\/ state in _succ so we can avoid fetching entry_list.\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -331,1 +331,1 @@\n-  volatile_nonstatic_field(ObjectMonitor,      _entry_list,                                    ObjectWaiter*)                        \\\n+  volatile_nonstatic_field(ObjectMonitor,      _entry_list,                                   ObjectWaiter*)                         \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3779,1 +3779,1 @@\n-  OopHandle& list_head = ObjectMonitor::vthread_cxq_head();\n+  OopHandle& list_head = ObjectMonitor::vthread_list_head();\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-OopHandle ObjectMonitor::_vthread_cxq_head;\n+OopHandle ObjectMonitor::_vthread_list_head;\n@@ -161,6 +161,18 @@\n-\/\/   The entry_list is a linked list, the first contending thread that\n-\/\/   \"pushed\" itself onto entry_list, will be the last thread in the\n-\/\/   list. Each newly pushed thread in entry_list will be linked trough\n-\/\/   its next pointer, and have its prev pointer set to null. Thus\n-\/\/   pushing six threads A-F (in that order) onto entry_list, will\n-\/\/   form a singly-linked list, see 1) below.\n+\/\/ * The entry_list forms a queue of threads stalled trying to acquire\n+\/\/   the lock. Within the entry_list the next pointers always form a\n+\/\/   consistent singly linked list. At unlock-time when the unlocking\n+\/\/   thread notices that the tail of the entry_list is not known, we\n+\/\/   convert the singly linked entry_list into a doubly linked list by\n+\/\/   assigning the prev pointers and the entry_list_tail pointer.\n+\/\/\n+\/\/   Example:\n+\/\/\n+\/\/   The first contending thread that \"pushed\" itself onto entry_list,\n+\/\/   will be the last thread in the list. Each newly pushed thread in\n+\/\/   entry_list will be linked through its next pointer, and have its\n+\/\/   prev pointer set to null. Thus pushing six threads A-F (in that\n+\/\/   order) onto entry_list, will form a singly linked list, see 1)\n+\/\/   below.\n+\/\/\n+\/\/      1)  entry_list       ->F->E->D->C->B->A->null\n+\/\/          entry_list_tail  ->null\n@@ -174,18 +186,0 @@\n-\/\/   Once we have formed a doubly linked list it's easy to find the\n-\/\/   successor, wake it up, have it remove itself, and update the\n-\/\/   tail pointer, as seen in 2) and 3) below.\n-\/\/\n-\/\/   At any time new threads can add themselves to the entry_list, see\n-\/\/   4) and 5).\n-\/\/\n-\/\/   If the thread that removes itself from the end of the list hasn't\n-\/\/   got any prev pointer, we just set the tail pointer to null, see\n-\/\/   5) and 6).\n-\/\/\n-\/\/   Next time we need to find the successor and the tail is null, we\n-\/\/   just start walking from the entry_list head again forming a new\n-\/\/   doubly linked list, see 6) and 7) below.\n-\/\/\n-\/\/      1)  entry_list       ->F->E->D->C->B->A->null\n-\/\/          entry_list_tail  ->null\n-\/\/\n@@ -195,0 +189,4 @@\n+\/\/   Once we have formed a doubly linked list it's easy to find the\n+\/\/   successor (A), wake it up, have it remove itself, and update the\n+\/\/   tail pointer, as seen in and 3) below.\n+\/\/\n@@ -198,2 +196,9 @@\n-\/\/      4)  entry_list       ->F->null\n-\/\/          entry_list_tail  --^\n+\/\/   At any time new threads can add themselves to the entry_list, see\n+\/\/   4) below.\n+\/\/\n+\/\/      4)  entry_list       ->I->H->G->F<=>E<=>D->null\n+\/\/          entry_list_tail  -------------------^\n+\/\/\n+\/\/   If the thread (F) that removes itself from the end of the list\n+\/\/   hasn't got any prev pointer, we just set the tail pointer to\n+\/\/   null, see 5) and 6) below.\n@@ -207,0 +212,4 @@\n+\/\/   Next time we need to find the successor and the tail is null, we\n+\/\/   just start walking from the entry_list head again, forming a new\n+\/\/   doubly linked list, see 7) below.\n+\/\/\n@@ -210,6 +219,4 @@\n-\/\/ * Concurrency invariants:\n-\/\/\n-\/\/   -- only the monitor owner may assign prev pointers in entry_list.\n-\/\/      The mutex property of the monitor itself protects the entry_list\n-\/\/      from concurrent interference.\n-\/\/   -- Only the monitor owner may detach nodes from the entry_list.\n+\/\/ * The monitor itself protects all of the operations on the\n+\/\/   entry_list except for the CAS of a new arrival to the head. Only\n+\/\/   the monitor owner can read or write the prev links (e.g. to\n+\/\/   remove itself) or update the tail.\n@@ -222,11 +229,3 @@\n-\/\/ * The entry_list can have multiple concurrent \"pushers\" but only one\n-\/\/   concurrent detaching thread. This mechanism is immune from the\n-\/\/   ABA corruption. More precisely, the CAS-based \"push\" onto\n-\/\/   entry_list is ABA-oblivious.\n-\/\/\n-\/\/ * The entry_list form a queue of threads stalled trying to acquire\n-\/\/   the lock. Within the entry_list the next pointers always form a\n-\/\/   consistent singly-linked list. At unlock-time when the unlocking\n-\/\/   thread notices that the tail of the entry_list is not known, we\n-\/\/   convert the singly-linked entry_list into a doubly linked list by\n-\/\/   assigning the prev pointers and the entry_list_tail pointer.\n+\/\/ * The entry_list can have multiple concurrent \"pushers\" but only\n+\/\/   one concurrent detaching thread. There is no ABA-problem with\n+\/\/   this usage of CAS.\n@@ -234,1 +233,1 @@\n-\/\/   As long as the entry_list_tail is known the odds are good that we\n+\/\/ * As long as the entry_list_tail is known the odds are good that we\n@@ -239,1 +238,1 @@\n-\/\/   monitor lock holds times.  Note that even a small amount of fixed\n+\/\/   monitor lock holds times. Note that even a small amount of fixed\n@@ -247,1 +246,1 @@\n-\/\/   the singly-linked entry_list into a doubly linked list to find the\n+\/\/   the singly linked entry_list into a doubly linked list to find the\n@@ -252,2 +251,2 @@\n-\/\/   park-unpark abstraction.  See the comments in os_posix.cpp regarding\n-\/\/   the semantics of park-unpark.  Put another way, this monitor implementation\n+\/\/   park-unpark abstraction. See the comments in os_posix.cpp regarding\n+\/\/   the semantics of park-unpark. Put another way, this monitor implementation\n@@ -260,1 +259,1 @@\n-\/\/   to either the entry_list. Subsequent exit() operations will\n+\/\/   to the entry_list. Subsequent exit() operations will\n@@ -697,1 +696,1 @@\n-\/\/ Push \"current\" onto the front of the _entry_list. Once on _entry_list,\n+\/\/ Push \"current\" onto the head of the _entry_list. Once on _entry_list,\n@@ -704,4 +703,3 @@\n-    ObjectWaiter* front = Atomic::load(&_entry_list);\n-\n-    node->_next = front;\n-    if (Atomic::cmpxchg(&_entry_list, front, node) == front) {\n+    ObjectWaiter* head = Atomic::load(&_entry_list);\n+    node->_next = head;\n+    if (Atomic::cmpxchg(&_entry_list, head, node) == head) {\n@@ -713,1 +711,1 @@\n-\/\/ Push \"current\" onto the front of the entry_list.\n+\/\/ Push \"current\" onto the head of the entry_list.\n@@ -723,4 +721,3 @@\n-    ObjectWaiter* front = Atomic::load(&_entry_list);\n-\n-    node->_next = front;\n-    if (Atomic::cmpxchg(&_entry_list, front, node) == front) {\n+    ObjectWaiter* head = Atomic::load(&_entry_list);\n+    node->_next = head;\n+    if (Atomic::cmpxchg(&_entry_list, head, node) == head) {\n@@ -730,2 +727,2 @@\n-    \/\/ Interference - the CAS failed because _entry_list changed.  Just retry.\n-    \/\/ As an optional optimization we retry the lock.\n+    \/\/ Interference - the CAS failed because _entry_list changed.  Before\n+    \/\/ retrying the CAS retry taking the lock as it may now be free.\n@@ -810,1 +807,2 @@\n-  guarantee(_entry_list == nullptr,\n+  ObjectWaiter* w = Atomic::load(&_entry_list);\n+  guarantee(w == nullptr,\n@@ -812,1 +810,1 @@\n-            p2i(_entry_list));\n+            p2i(w));\n@@ -1283,3 +1281,2 @@\n-\/\/ By convention we unlink a contending thread from _entry_list immediately\n-\/\/ after the thread acquires the lock in ::enter().  Equally, we could defer\n-\/\/ unlinking the thread until ::exit()-time.\n+\/\/ By convention we unlink a contending thread from _entry_list\n+\/\/ immediately after the thread acquires the lock in ::enter().\n@@ -1299,2 +1296,2 @@\n-    ObjectWaiter* v = Atomic::load(&_entry_list);\n-    if (v == currentNode) {\n+    ObjectWaiter* w = Atomic::load(&_entry_list);\n+    if (w == currentNode) {\n@@ -1302,1 +1299,1 @@\n-      if (Atomic::cmpxchg(&_entry_list, v, (ObjectWaiter*)nullptr) == v) {\n+      if (Atomic::cmpxchg(&_entry_list, w, (ObjectWaiter*)nullptr) == w) {\n@@ -1309,1 +1306,1 @@\n-      \/\/ building the doubly-linked list.\n+      \/\/ building the doubly linked list.\n@@ -1335,1 +1332,1 @@\n-  \/\/ Check if we are in the singly-linked portion of the\n+  \/\/ Check if we are in the singly linked portion of the\n@@ -1337,1 +1334,1 @@\n-  \/\/ else we convert to the doubly-linked list.\n+  \/\/ else we convert to the doubly linked list.\n@@ -1339,1 +1336,1 @@\n-    ObjectWaiter* v = Atomic::load(&_entry_list);\n+    ObjectWaiter* w = Atomic::load(&_entry_list);\n@@ -1341,2 +1338,2 @@\n-    assert(v != nullptr, \"invariant\");\n-    if (v == currentNode) {\n+    assert(w != nullptr, \"invariant\");\n+    if (w == currentNode) {\n@@ -1345,1 +1342,1 @@\n-      if (Atomic::cmpxchg(&_entry_list, v, next) == v) {\n+      if (Atomic::cmpxchg(&_entry_list, w, next) == w) {\n@@ -1348,1 +1345,1 @@\n-        assert(_entry_list != v, \"invariant\");\n+        assert(_entry_list != w, \"invariant\");\n@@ -1356,1 +1353,1 @@\n-        \/\/ list. Fall-through to building the doubly-linked list.\n+        \/\/ list. Fall-through to building the doubly linked list.\n@@ -1585,1 +1582,1 @@\n-  } else if (java_lang_VirtualThread::set_onWaitingList(vthread, vthread_cxq_head())) {\n+  } else if (java_lang_VirtualThread::set_onWaitingList(vthread, vthread_list_head())) {\n@@ -2012,7 +2009,5 @@\n-\n-\/\/ The current implementation of notifyAll() transfers the waiters one-at-a-time\n-\/\/ from the waitset to the entry_list. This could be done more efficiently with a\n-\/\/ single bulk transfer but in practice it's not time-critical. Beware too,\n-\/\/ that in prepend-mode we invert the order of the waiters. Let's say that the\n-\/\/ waitset is \"ABCD\" and the entry_list is \"XYZ\". After a notifyAll() in prepend\n-\/\/ mode the waitset will be empty and the entry_list will be \"DCBAXYZ\".\n+\/\/ notifyAll() transfers the waiters one-at-a-time from the waitset to\n+\/\/ the entry_list. If the waitset is \"ABCD\" (where A was added first\n+\/\/ and D last) and the entry_list is ->X->Y->Z. After a notifyAll()\n+\/\/ the waitset will be empty and the entry_list will be\n+\/\/ ->D->C->B->A->X->Y->Z, and the next choosen successor will be Z.\n@@ -2524,1 +2519,1 @@\n-  _vthread_cxq_head = OopHandle(JavaThread::thread_oop_storage(), nullptr);\n+  _vthread_list_head = OopHandle(JavaThread::thread_oop_storage(), nullptr);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":83,"deletions":88,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-    \/\/ Diagnostic hygiene ...\n@@ -161,1 +160,1 @@\n-  static OopHandle _vthread_cxq_head;\n+  static OopHandle _vthread_list_head;\n@@ -195,1 +194,1 @@\n-                                       \/\/ The list is actually composed of WaitNodes,\n+                                       \/\/ The list is actually composed of wait-nodes,\n@@ -219,1 +218,1 @@\n-  static OopHandle& vthread_cxq_head() { return _vthread_cxq_head; }\n+  static OopHandle& vthread_list_head() { return _vthread_list_head; }\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}