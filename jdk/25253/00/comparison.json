{"files":[{"patch":"@@ -674,21 +674,12 @@\n-\/\/ Load\/store register (all modes)\n-#define INSN(NAME, op, funct3)                                                                     \\\n-  void NAME(Register Rd, Register Rs, const int32_t offset) {                                      \\\n-    guarantee(is_simm12(offset), \"offset is invalid.\");                                            \\\n-    unsigned insn = 0;                                                                             \\\n-    int32_t val = offset & 0xfff;                                                                  \\\n-    patch((address)&insn, 6, 0, op);                                                               \\\n-    patch((address)&insn, 14, 12, funct3);                                                         \\\n-    patch_reg((address)&insn, 15, Rs);                                                             \\\n-    patch_reg((address)&insn, 7, Rd);                                                              \\\n-    patch((address)&insn, 31, 20, val);                                                            \\\n-    emit(insn);                                                                                    \\\n-  }\n-\n-  INSN(lb,  0b0000011, 0b000);\n-  INSN(_lbu, 0b0000011, 0b100);\n-  INSN(_lh,  0b0000011, 0b001);\n-  INSN(_lhu, 0b0000011, 0b101);\n-  INSN(_lw, 0b0000011, 0b010);\n-  INSN(lwu, 0b0000011, 0b110);\n-  INSN(_ld, 0b0000011, 0b011);\n+ private:\n+  \/\/ Load\n+  enum LoadWidthFunct3 : uint8_t {\n+    LOAD_WIDTH_BYTE              = 0b000,\n+    LOAD_WIDTH_HALFWORD          = 0b001,\n+    LOAD_WIDTH_WORD              = 0b010,\n+    LOAD_WIDTH_DOUBLEWORD        = 0b011,\n+    LOAD_WIDTH_BYTE_UNSIGNED     = 0b100,\n+    LOAD_WIDTH_HALFWORD_UNSIGNED = 0b101,\n+    LOAD_WIDTH_WORD_UNSIGNED     = 0b110,\n+    \/\/ 0b111 is reserved\n+  };\n@@ -696,1 +687,44 @@\n-#undef INSN\n+  static constexpr uint32_t OP_LOAD_MAJOR = 0b0000011;\n+\n+  template <LoadWidthFunct3 width>\n+  void load_base(Register Rd, Register Rs, const int32_t offset) {\n+    guarantee(is_simm12(offset), \"offset is invalid.\");\n+    unsigned insn = 0;\n+    int32_t val = offset & 0xfff;\n+    patch((address)&insn,  6,  0, OP_LOAD_MAJOR);\n+    patch_reg((address)&insn,  7, Rd);\n+    patch((address)&insn, 14, 12, width);\n+    patch_reg((address)&insn, 15, Rs);\n+    patch((address)&insn, 31, 20, val);\n+    emit(insn);\n+  }\n+\n+ public:\n+\n+  void lb(Register Rd, Register Rs, const int32_t offset) {\n+    load_base<LOAD_WIDTH_BYTE>(Rd, Rs, offset);\n+  }\n+\n+  void _lbu(Register Rd, Register Rs, const int32_t offset) {\n+    load_base<LOAD_WIDTH_BYTE_UNSIGNED>(Rd, Rs, offset);\n+  }\n+\n+  void _lh(Register Rd, Register Rs, const int32_t offset) {\n+    load_base<LOAD_WIDTH_HALFWORD>(Rd, Rs, offset);\n+  }\n+\n+  void _lhu(Register Rd, Register Rs, const int32_t offset) {\n+    load_base<LOAD_WIDTH_HALFWORD_UNSIGNED>(Rd, Rs, offset);\n+  }\n+\n+  void _lw(Register Rd, Register Rs, const int32_t offset) {\n+    load_base<LOAD_WIDTH_WORD>(Rd, Rs, offset);\n+  }\n+\n+  void lwu(Register Rd, Register Rs, const int32_t offset) {\n+    load_base<LOAD_WIDTH_WORD_UNSIGNED>(Rd, Rs, offset);\n+  }\n+\n+  void _ld(Register Rd, Register Rs, const int32_t offset) {\n+    load_base<LOAD_WIDTH_DOUBLEWORD>(Rd, Rs, offset);\n+  }\n@@ -727,15 +761,1 @@\n-#define INSN(NAME, REGISTER, op, funct3)                                                                    \\\n-  void NAME(REGISTER Rs1, Register Rs2, const int32_t offset) {                                             \\\n-    guarantee(is_simm12(offset), \"offset is invalid.\");                                                     \\\n-    unsigned insn = 0;                                                                                      \\\n-    uint32_t val  = offset & 0xfff;                                                                         \\\n-    uint32_t low  = val & 0x1f;                                                                             \\\n-    uint32_t high = (val >> 5) & 0x7f;                                                                      \\\n-    patch((address)&insn, 6, 0, op);                                                                        \\\n-    patch((address)&insn, 14, 12, funct3);                                                                  \\\n-    patch_reg((address)&insn, 15, Rs2);                                                                     \\\n-    patch_reg((address)&insn, 20, Rs1);                                                                     \\\n-    patch((address)&insn, 11, 7, low);                                                                      \\\n-    patch((address)&insn, 31, 25, high);                                                                    \\\n-    emit(insn);                                                                                             \\\n-  }                                                                                                         \\\n+ private:\n@@ -743,6 +763,7 @@\n-  INSN(_sb,   Register,      0b0100011, 0b000);\n-  INSN(_sh,   Register,      0b0100011, 0b001);\n-  INSN(_sw,  Register,      0b0100011, 0b010);\n-  INSN(_sd,  Register,      0b0100011, 0b011);\n-  INSN(fsw,  FloatRegister, 0b0100111, 0b010);\n-  INSN(_fsd, FloatRegister, 0b0100111, 0b011);\n+  enum StoreWidthFunct3 : uint8_t {\n+    STORE_WIDTH_BYTE        = 0b000,\n+    STORE_WIDTH_HALFWORD    = 0b001,\n+    STORE_WIDTH_WORD        = 0b010,\n+    STORE_WIDTH_DOUBLEWORD  = 0b011,\n+    \/\/ 0b100 to 0b111 are reserved for this opcode\n+  };\n@@ -750,1 +771,44 @@\n-#undef INSN\n+  static constexpr uint32_t OP_STORE_MAJOR    = 0b0100011;\n+  static constexpr uint32_t OP_FP_STORE_MAJOR = 0b0100111;\n+\n+  template <uint8_t op_code, StoreWidthFunct3 width>\n+  void store_base(uint8_t Rs2, Register Rs1, const int32_t offset) {\n+    guarantee(is_simm12(offset), \"offset is invalid.\");\n+    unsigned insn = 0;\n+    uint32_t val  = offset & 0xfff;\n+    uint32_t low  = val & 0x1f;\n+    uint32_t high = (val >> 5) & 0x7f;\n+    patch((address)&insn,  6,  0, op_code);\n+    patch((address)&insn, 11,  7, low);\n+    patch((address)&insn, 14, 12, width);\n+    patch_reg((address)&insn, 15, Rs1);\n+    patch((address)&insn, 24, 20, Rs2);\n+    patch((address)&insn, 31, 25, high);\n+    emit(insn);\n+  }\n+\n+ public:\n+\n+  void _sb(Register Rs2, Register Rs1, const int32_t offset) {\n+    store_base<OP_STORE_MAJOR, STORE_WIDTH_BYTE>(Rs2->raw_encoding(), Rs1, offset);\n+  }\n+\n+  void _sh(Register Rs2, Register Rs1, const int32_t offset) {\n+    store_base<OP_STORE_MAJOR, STORE_WIDTH_HALFWORD>(Rs2->raw_encoding(), Rs1, offset);\n+  }\n+\n+  void _sw(Register Rs2, Register Rs1, const int32_t offset) {\n+    store_base<OP_STORE_MAJOR, STORE_WIDTH_WORD>(Rs2->raw_encoding(), Rs1, offset);\n+  }\n+\n+  void _sd(Register Rs2, Register Rs1, const int32_t offset) {\n+    store_base<OP_STORE_MAJOR, STORE_WIDTH_DOUBLEWORD>(Rs2->raw_encoding(), Rs1, offset);\n+  }\n+\n+  void fsw(FloatRegister Rs2, Register Rs1, const int32_t offset) {\n+    store_base<OP_FP_STORE_MAJOR, STORE_WIDTH_WORD>(Rs2->raw_encoding(), Rs1, offset);\n+  }\n+\n+  void _fsd(FloatRegister Rs2, Register Rs1, const int32_t offset) {\n+    store_base<OP_FP_STORE_MAJOR, STORE_WIDTH_DOUBLEWORD>(Rs2->raw_encoding(), Rs1, offset);\n+  }\n@@ -3288,13 +3352,12 @@\n-#define INSN(NAME)                                                                           \\\n-  void NAME(FloatRegister Rd, Register Rs, const int32_t offset) {                           \\\n-    \/* fsd -> c.fsdsp\/c.fsd *\/                                                               \\\n-    if (do_compress()) {                                                                     \\\n-      if (is_c_fldsdsp(Rs, offset)) {                                                        \\\n-        c_fsdsp(Rd, offset);                                                                 \\\n-        return;                                                                              \\\n-      } else if (is_c_fldsd(Rs, Rd, offset)) {                                               \\\n-        c_fsd(Rd, Rs, offset);                                                               \\\n-        return;                                                                              \\\n-      }                                                                                      \\\n-    }                                                                                        \\\n-    _fsd(Rd, Rs, offset);                                                                    \\\n+  void fsd(FloatRegister Rd, Register Rs, const int32_t offset) {\n+    \/* fsd -> c.fsdsp\/c.fsd *\/\n+    if (do_compress()) {\n+      if (is_c_fldsdsp(Rs, offset)) {\n+        c_fsdsp(Rd, offset);\n+        return;\n+      } else if (is_c_fldsd(Rs, Rd, offset)) {\n+        c_fsd(Rd, Rs, offset);\n+        return;\n+      }\n+    }\n+    _fsd(Rd, Rs, offset);\n@@ -3303,4 +3366,0 @@\n-  INSN(fsd);\n-\n-#undef INSN\n-\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":120,"deletions":61,"binary":false,"changes":181,"status":"modified"}]}