{"files":[{"patch":"@@ -0,0 +1,250 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Test that Ideal transformations of AddINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.AddINodeIdealizationTests\n+ *\/\n+public class AddINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"additions\", \"xMinusX\", \"test1\",\n+                 \"test2\", \"test3\", \"test4\",\n+                 \"test5\", \"test6\", \"test7\",\n+                 \"test8\", \"test9\", \"test10\",\n+                 \"test11\", \"test12\", \"test13\",\n+                 \"test14\", \"test15\", \"test16\",\n+                 \"test17\", \"test18\", \"test19\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+        int b = RunInfo.getRandom().nextInt();\n+        int c = RunInfo.getRandom().nextInt();\n+        int d = RunInfo.getRandom().nextInt();\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0, 0, 0);\n+        assertResult(a, b, c, d);\n+        assertResult(min, min, min, min);\n+        assertResult(max, max, max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b, int c, int d) {\n+        Asserts.assertEQ(((a+a) + (a+a))  , additions(a));\n+        Asserts.assertEQ(0                , xMinusX(a));\n+        Asserts.assertEQ(a + 1 + 2        , test1(a));\n+        Asserts.assertEQ((a + 2021) + b   , test2(a, b));\n+        Asserts.assertEQ(a + (b + 2021)   , test3(a, b));\n+        Asserts.assertEQ((1 - a) + 2      , test4(a));\n+        Asserts.assertEQ((a - b) + (c - d), test5(a, b, c, d));\n+        Asserts.assertEQ((a - b) + (b + c), test6(a, b, c));\n+        Asserts.assertEQ((a - b) + (c + b), test7(a, b, c));\n+        Asserts.assertEQ((a - b) + (b - c), test8(a, b, c));\n+        Asserts.assertEQ((a - b) + (c - a), test9(a, b, c));\n+        Asserts.assertEQ(a + (0 - b)      , test10(a, b));\n+        Asserts.assertEQ((0 - b) + a      , test11(a, b));\n+        Asserts.assertEQ((a - b) + b      , test12(a, b));\n+        Asserts.assertEQ(b + (a - b)      , test13(a, b));\n+        Asserts.assertEQ(a + 0            , test14(a));\n+        Asserts.assertEQ(0 + a            , test15(a));\n+        Asserts.assertEQ(a*b + a*c        , test16(a, b, c));\n+        Asserts.assertEQ(a*b + b*c        , test17(a, b, c));\n+        Asserts.assertEQ(a*c + b*c        , test18(a, b, c));\n+        Asserts.assertEQ(a*b + c*a        , test19(a, b, c));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks (x + x) + (x + x) => a=(x + x); r=a+a\n+    public int additions(int x) {\n+        return (x + x) + (x + x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks (x - x) + (x - x) => 0\n+    public int xMinusX(int x) {\n+        return (x - x) + (x - x);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x + c1) + c2 => x + c3 where c3 = c1 + c2\n+    public int test1(int x) {\n+        return (x + 1) + 2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks (x + c1) + y => (x + y) + c1\n+    public int test2(int x, int y) {\n+        return (x + 2021) + y;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks x + (y + c1) => (x + y) + c1\n+    public int test3(int x, int y) {\n+        return x + (y + 2021);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (c1 - x) + c2 => c3 - x where c3 = c1 + c2\n+    public int test4(int x) {\n+        return (1 - x) + 2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"2\",\n+                 })\n+    \/\/ Checks (a - b) + (c - d) => (a + c) - (b + d)\n+    public int test5(int a, int b, int c, int d) {\n+        return (a - b) + (c - d);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (b + c) => (a + c)\n+    public int test6(int a, int b, int c) {\n+        return (a - b) + (b + c);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (c + b) => (a + c)\n+    public int test7(int a, int b, int c) {\n+        return (a - b) + (c + b);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a - b) + (b - c) => (a - c)\n+    public int test8(int a, int b, int c) {\n+        return (a - b) + (b - c);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a - b) + (c - a) => (c - b)\n+    public int test9(int a, int b, int c) {\n+        return (a - b) + (c - a);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x + (0 - y) => (x - y)\n+    public int test10(int x, int y) {\n+        return x + (0 - y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (0 - y) + x => (x - y)\n+    public int test11(int x, int y) {\n+        return (0 - y) + x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks (x - y) + y => x\n+    public int test12(int x, int y) {\n+        return (x - y) + y;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks y + (x - y) => x\n+    public int test13(int x, int y) {\n+        return y + (x - y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    \/\/ Checks x + 0 => x\n+    public int test14(int x) {\n+        return x + 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    \/\/ Checks 0 + x => x\n+    public int test15(int x) {\n+        return 0 + x;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks \"a*b + a*c => a*(b+c)\n+    public int test16(int a, int b, int c) {\n+        return a*b + a*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a*b + b*c => b*(a+c)\n+    public int test17(int a, int b, int c) {\n+        return a*b + b*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a*c + b*c => (a+b)*c\n+    public int test18(int a, int b, int c) {\n+        return a*c + b*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a*b + c*a => a*(b+c)\n+    public int test19(int a, int b, int c) {\n+        return a*b + c*a;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AddINodeIdealizationTests.java","additions":250,"deletions":0,"binary":false,"changes":250,"status":"added"},{"patch":"@@ -0,0 +1,241 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Test that Ideal transformations of AddLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.AddLNodeIdealizationTests\n+ *\/\n+public class AddLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"additions\", \"xMinusX\", \"test1\",\n+                 \"test2\", \"test3\", \"test4\",\n+                 \"test5\", \"test6\", \"test7\",\n+                 \"test8\", \"test9\", \"test10\",\n+                 \"test11\", \"test12\", \"test13\",\n+                 \"test14\", \"test15\", \"test16\",\n+                 \"test17\", \"test18\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        long b = RunInfo.getRandom().nextLong();\n+        long c = RunInfo.getRandom().nextLong();\n+        long d = RunInfo.getRandom().nextLong();\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0, 0, 0);\n+        assertResult(a, b, c, d);\n+        assertResult(min, min, min, min);\n+        assertResult(max, max, max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b, long c, long d) {\n+        Asserts.assertEQ(((a+a) + (a+a))  , additions(a));\n+        Asserts.assertEQ(0L               , xMinusX(a));\n+        Asserts.assertEQ(a + 1 + 2        , test1(a));\n+        Asserts.assertEQ((a + 2021) + b   , test2(a, b));\n+        Asserts.assertEQ(a + (b + 2021)   , test3(a, b));\n+        Asserts.assertEQ((1 - a) + 2      , test4(a));\n+        Asserts.assertEQ((a - b) + (c - d), test5(a, b, c, d));\n+        Asserts.assertEQ((a - b) + (b + c), test6(a, b, c));\n+        Asserts.assertEQ((a - b) + (c + b), test7(a, b, c));\n+        Asserts.assertEQ((a - b) + (c - a), test8(a, b, c));\n+        Asserts.assertEQ(a + (0 - b)      , test9(a, b));\n+        Asserts.assertEQ((0 - b) + a      , test10(a, b));\n+        Asserts.assertEQ((a - b) + b      , test11(a, b));\n+        Asserts.assertEQ(b + (a - b)      , test12(a, b));\n+        Asserts.assertEQ(a + 0            , test13(a));\n+        Asserts.assertEQ(0 + a            , test14(a));\n+        Asserts.assertEQ(a*b + a*c        , test15(a, b, c));\n+        Asserts.assertEQ(a*b + b*c        , test16(a, b, c));\n+        Asserts.assertEQ(a*c + b*c        , test17(a, b, c));\n+        Asserts.assertEQ(a*b + c*a        , test18(a, b, c));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks (x + x) + (x + x) => a=(x + x); r=a+a\n+    public long additions(long x) {\n+        return (x + x) + (x + x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks (x - x) => 0 and 0 - 0 => 0\n+    public long xMinusX(long x) {\n+        return (x - x) + (x - x);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x + c1) + c2 => x + c3 where c3 = c1 + c2\n+    public long test1(long x) {\n+        return (x + 1) + 2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks (x + c1) + y => (x + y) + c1\n+    public long test2(long x, long y) {\n+        return (x + 2021) + y;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks x + (y + c1) => (x + y) + c1\n+    public long test3(long x, long y) {\n+        return x + (y + 2021);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (c1 - x) + c2 => c3 - x where c3 = c1 + c2\n+    public long test4(long x) {\n+        return (1 - x) + 2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"2\",\n+                 })\n+    \/\/ Checks (a - b) + (c - d) => (a + c) - (b + d)\n+    public long test5(long a, long b, long c, long d) {\n+        return (a - b) + (c - d);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (b + c) => (a + c)\n+    public long test6(long a, long b, long c) {\n+        return (a - b) + (b + c);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (c + b) => (a + c)\n+    public long test7(long a, long b, long c) {\n+        return (a - b) + (c + b);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a - b) + (c - a) => (c - b)\n+    public long test8(long a, long b, long c) {\n+        return (a - b) + (c - a);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x + (0 - y) => (x - y)\n+    public long test9(long x, long y) {\n+        return x + (0 - y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (0 - y) + x => (x - y)\n+    public long test10(long x, long y) {\n+        return (0 - y) + x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks (x - y) + y => x\n+    public long test11(long x, long y) {\n+        return (x - y) + y;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks y + (x - y) => x\n+    public long test12(long x, long y) {\n+        return y + (x - y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    \/\/ Checks x + 0 => x\n+    public long test13(long x) {\n+        return x + 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    \/\/ Checks 0 + x => x\n+    public long test14(long x) {\n+        return 0 + x;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks \"a*b + a*c => a*(b+c)\n+    public long test15(long a, long b, long c) {\n+        return a*b + a*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a*b + b*c => b*(a+c)\n+    public long test16(long a, long b, long c) {\n+        return a*b + b*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a*c + b*c => (a+b)*c\n+    public long test17(long a, long b, long c) {\n+        return a*c + b*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a*b + c*a => a*(b+c)\n+    public long test18(long a, long b, long c) {\n+        return a*b + c*a;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AddLNodeIdealizationTests.java","additions":241,"deletions":0,"binary":false,"changes":241,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Test that Ideal transformations of DivINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.DivINodeIdealizationTests\n+ *\/\n+public class DivINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constant\", \"identity\", \"identityAgain\", \"identityThird\",\n+                 \"retainDenominator\", \"divByNegOne\", \"divByPow2And\",\n+                 \"divByPow2And1\",  \"divByPow2\", \"divByNegPow2\",\n+                 \"magicDiv\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+            a = (a == 0) ? 1 : a;\n+        int b = RunInfo.getRandom().nextInt();\n+            b = (b == 0) ? 1 : b;\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(a \/ a, constant(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(a \/ (b \/ b), identityThird(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ((a * b) \/ b, retainDenominator(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(a \/ 1        , identity(a));\n+        Asserts.assertEQ(a \/ (13 \/ 13), identityAgain(a));\n+        Asserts.assertEQ(a \/ -1       , divByNegOne(a));\n+        Asserts.assertEQ((a & -4) \/ 2 , divByPow2And(a));\n+        Asserts.assertEQ((a & -2) \/ 2 , divByPow2And1(a));\n+        Asserts.assertEQ(a \/ 8        , divByPow2(a));\n+        Asserts.assertEQ(a \/ -8       , divByNegPow2(a));\n+        Asserts.assertEQ(a \/ 13       , magicDiv(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.TRAP, \"1\"})\n+    \/\/ Checks x \/ x => 1\n+    public int constant(int x) {\n+        return x \/ x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    \/\/ Checks x \/ 1 => x\n+    public int identity(int x) {\n+        return x \/ 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public int identityAgain(int x) {\n+        return x \/ (13 \/ 13);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.TRAP, \"1\"})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public int identityThird(int x, int y) {\n+        return x \/ (y \/ y);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.DIV, \"1\",\n+                  IRNode.TRAP, \"1\"\n+                 })\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public int retainDenominator(int x, int y) {\n+        return (x * y) \/ y;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    \/\/ Checks x \/ -1 => 0 - x\n+    public int divByNegOne(int x) {\n+        return x \/ -1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.AND, \"1\",\n+                  IRNode.RSHIFT, \"1\",\n+                 })\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c1 => (x >> c1) & (2^c0 >> c1) => (x >> c1) & c3 where 2^c0 > |2^c1| and c3 = 2^c0 >> c1\n+    \/\/ Having a large enough and in the dividend removes the need to account for rounding when converting to shifts and multiplies as in divByPow2()\n+    public int divByPow2And(int x) {\n+        return (x & -4) \/ 2;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV, IRNode.AND})\n+    @IR(counts = {IRNode.RSHIFT, \"1\"})\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c0 => x >> c0\n+    \/\/ If the negative of the constant within the & equals the divisor then the and can be removed as it only affects bits that will be shifted off\n+    public int divByPow2And1(int x) {\n+        return (x & -2) \/ 2;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD_I, \"1\",\n+                 })\n+    \/\/ Checks x \/ 2^c0 => x + ((x >> (32-1)) >>> (32 - c0)) >> c0 => x + ((x >> 31) >>> c1) >> c0 where c1 = 32 - c0\n+    \/\/ An additional (dividend - 1) needs to be added to the shift to account for rounding when dealing with negative numbers.\n+    \/\/ Since x may be negative in this method, an additional add, logical right shift, and signed shift are needed to account for rounding.\n+    public int divByPow2(int x) {\n+        return x \/ 8;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD_I, \"1\",\n+                  IRNode.SUB_I, \"1\",\n+                 })\n+    \/\/ Checks x \/ -(2^c0) =>0 - (x + ((x >> (32-1)) >>> (32 - c0)) >> c0) => 0 -  (x + ((x >> 31) >>> c1) >> c0) where c1 = 32 - c0\n+    \/\/ Similar to divByPow2() except a negative divisor turns positive.\n+    \/\/ After the transformations, 0 is subtracted by the whole expression\n+    \/\/ to account for the negative.\n+    public int divByNegPow2(int x) {\n+        return x \/ -8;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.MUL, \"1\",\n+                  IRNode.CONVI2L, \"1\",\n+                  IRNode.CONVL2I, \"1\",\n+                 })\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ More tests can be made to cover the specific cases for differences in the\n+    \/\/ graph that depend upon different values for the \"magic constant\" and the\n+    \/\/ \"shift constant\"\n+    public int magicDiv(int x) {\n+        return x \/ 13;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DivINodeIdealizationTests.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Test that Ideal transformations of DivLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.DivLNodeIdealizationTests\n+ *\/\n+public class DivLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constant\", \"identity\", \"identityAgain\", \"identityThird\",\n+                 \"retainDenominator\", \"divByNegOne\", \"divByPow2And\",\n+                 \"divByPow2And1\",  \"divByPow2\", \"divByNegPow2\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+             a = (a == 0) ? 1 : a;\n+        long b = RunInfo.getRandom().nextLong();\n+             b = (b == 0) ? 1 : b;\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(a \/ a, constant(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ((a * b) \/ b, retainDenominator(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(a \/ (b \/ b), identityThird(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(a \/ 1        , identity(a));\n+        Asserts.assertEQ(a \/ (13 \/ 13), identityAgain(a));\n+        Asserts.assertEQ(a \/ -1       , divByNegOne(a));\n+        Asserts.assertEQ((a & -4) \/ 2 , divByPow2And(a));\n+        Asserts.assertEQ((a & -2) \/ 2 , divByPow2And1(a));\n+        Asserts.assertEQ(a \/ 8        , divByPow2(a));\n+        Asserts.assertEQ(a \/ -8       , divByNegPow2(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.TRAP, \"1\"})\n+    \/\/ Checks x \/ x => 1\n+    public long constant(long x) {\n+        return x \/ x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    \/\/ Checks x \/ 1 => x\n+    public long identity(long x) {\n+        return x \/ 1L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public long identityAgain(long x) {\n+        return x \/ (13L \/ 13L);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.TRAP, \"1\"})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public long identityThird(long x, long y) {\n+        return x \/ (y \/ y);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.DIV_L, \"1\",\n+                  IRNode.TRAP, \"1\"\n+                 })\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public long retainDenominator(long x, long y) {\n+        return (x * y) \/ y;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x \/ -1 => 0 - x\n+    public long divByNegOne(long x) {\n+        return x \/ -1L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.AND, \"1\",\n+                  IRNode.RSHIFT, \"1\",\n+                 })\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c1 => (x >> c1) & (2^c0 >> c1) => (x >> c1) & c3 where 2^c0 > |2^c1| and c3 = 2^c0 >> c1\n+    \/\/ Having a large enough and in the dividend removes the need to account for\n+    \/\/ rounding when converting to shifts and multiplies as in divByPow2()\n+    public long divByPow2And(long x) {\n+        return (x & -4L) \/ 2L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV, IRNode.AND})\n+    @IR(counts = {IRNode.RSHIFT, \"1\"})\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c0 => x >> c0\n+    \/\/ If the negative of the constant within the & equals the divisor then\n+    \/\/ the and can be removed as it only affects bits that will be shifted off\n+    public long divByPow2And1(long x) {\n+        return (x & -2L) \/ 2L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks x \/ 2^c0 => x + ((x >>)ith negative numbers. Since x may be negative\n+    \/\/ in this method, an additional add, logical right shift, and signed shift\n+    \/\/ are needed to account for rounding.\n+    public long divByPow2(long x) {\n+        return x \/ 8L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD, \"1\",\n+                  IRNode.SUB, \"1\",\n+                 })\n+    \/\/ Checks x \/ -(2^c0) =>0 - (x + ((x >> (32-1)) >>> (32 - c0)) >> c0) => 0 -  (x + ((x >> 31) >>> c1) >> c0) where c1 = 32 - c0\n+    \/\/ Similar to divByPow2() except a negative divisor turns positive.\n+    \/\/ After the transformations, 0 is subtracted by the whole expression\n+    \/\/ to account for the negative.\n+    public long divByNegPow2(long x) {\n+        return x \/ -8L;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DivLNodeIdealizationTests.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Test that Ideal transformations of MulINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.MulINodeIdealizationTests\n+ *\/\n+public class MulINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"combineConstants\", \"moveConstants\", \"moveConstantsAgain\",\n+                 \"multiplyZero\", \"multiplyZeroAgain\", \"distribute\",\n+                 \"identity\",  \"identityAgain\", \"powerTwo\",\n+                 \"powerTwoAgain\", \"powerTwoPlusOne\", \"powerTwoMinusOne\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+        int b = RunInfo.getRandom().nextInt();\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b) {\n+        Asserts.assertEQ((a * 13) * 14 , combineConstants(a));\n+        Asserts.assertEQ((a * 13) * b  , moveConstants(a, b));\n+        Asserts.assertEQ(a * (b * 13)  , moveConstantsAgain(a, b));\n+        Asserts.assertEQ(0 * a         , multiplyZero(a));\n+        Asserts.assertEQ(a * 0         , multiplyZeroAgain(a));\n+        Asserts.assertEQ((13 + a) * 14 , distribute(a));\n+        Asserts.assertEQ(1 * a         , identity(a));\n+        Asserts.assertEQ(a * 1         , identityAgain(a));\n+        Asserts.assertEQ(a * 64        , powerTwo(a));\n+        Asserts.assertEQ(a * (1025 - 1), powerTwoAgain(a));\n+        Asserts.assertEQ(a * (64 + 1)  , powerTwoPlusOne(a));\n+        Asserts.assertEQ(a * (64 - 1)  , powerTwoMinusOne(a));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\"})\n+    \/\/Checks (x * c1) * c2 => x * c3 where c3 = c1 * c2\n+    public int combineConstants(int x){\n+        return (x * 13) * 14;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"2\"})\n+    \/\/ Checks (x * c1) * y => (x * y) * c1\n+    public int moveConstants(int x, int y) {\n+        return (x * 13) * y;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"2\"})\n+    \/\/ Checks x * (y * c1) => (x * y) * c1\n+    public int moveConstantsAgain(int x, int y) {\n+        return x * (y * 13);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    \/\/ Checks 0 * x => 0\n+    public int multiplyZero(int x) {\n+        return 0 * x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    \/\/ Checks x * 0 => 0\n+    public int multiplyZeroAgain(int x) {\n+        return x * 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks (c1 + x) * c2 => x * c2 + c3 where c3 = c1 * c2\n+    public int distribute(int x) {\n+        return (13 + x) * 14;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    \/\/ Checks 1 * x => x\n+    public int identity(int x) {\n+        return 1 * x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    \/\/ Checks x * 1 => x\n+    public int identityAgain(int x) {\n+        return x * 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x * 2^n => x << n\n+    public int powerTwo(int x) {\n+        return x * 64;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x * 2^n => x << n\n+    public int powerTwoAgain(int x) {\n+        return x * (1025 - 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks x * (2^n + 1) => (x << n) + x\n+    public int powerTwoPlusOne(int x) {\n+        return x * (64 + 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\",\n+                  IRNode.SUB, \"1\",\n+                 })\n+    \/\/ Checks x * (2^n - 1) => (x << n) - x\n+    public int powerTwoMinusOne(int x) {\n+        return x * (64 - 1);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MulINodeIdealizationTests.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Test that Ideal transformations of MulLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.MulLNodeIdealizationTests\n+ *\/\n+public class MulLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"combineConstants\", \"moveConstants\", \"moveConstantsAgain\",\n+                 \"multiplyZero\", \"multiplyZeroAgain\", \"distribute\",\n+                 \"identity\",  \"identityAgain\", \"powerTwo\",\n+                 \"powerTwoAgain\", \"powerTwoPlusOne\", \"powerTwoMinusOne\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        long b = RunInfo.getRandom().nextLong();\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b) {\n+        Asserts.assertEQ((a * 13) * 14 * 15, combineConstants(a));\n+        Asserts.assertEQ((a * 13) * b      , moveConstants(a, b));\n+        Asserts.assertEQ(a * (b * 13)      , moveConstantsAgain(a, b));\n+        Asserts.assertEQ(0 * a             , multiplyZero(a));\n+        Asserts.assertEQ(a * 0             , multiplyZeroAgain(a));\n+        Asserts.assertEQ((13 + a) * 14     , distribute(a));\n+        Asserts.assertEQ(1 * a             , identity(a));\n+        Asserts.assertEQ(a * 1             , identityAgain(a));\n+        Asserts.assertEQ(a * 64            , powerTwo(a));\n+        Asserts.assertEQ(a * (1025 - 1)    , powerTwoAgain(a));\n+        Asserts.assertEQ(a * (64 + 1)      , powerTwoPlusOne(a));\n+        Asserts.assertEQ(a * (64 - 1)      , powerTwoMinusOne(a));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\"})\n+    \/\/Checks (x * c1) * c2 => x * c3 where c3 = c1 * c2\n+    public long combineConstants(long x){\n+        return (x * 13) * 14 * 15;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"2\"})\n+    \/\/ Checks (x * c1) * y => (x * y) * c1\n+    public long moveConstants(long x, long y) {\n+        return (x * 13) * y;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"2\"})\n+    \/\/ Checks x * (y * c1) => (x * y) * c1\n+    public long moveConstantsAgain(long x, long y) {\n+        return x * (y * 13);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    \/\/ Checks 0 * x => 0\n+    public long multiplyZero(long x) {\n+        return 0 * x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    \/\/ Checks x * 0 => 0\n+    public long multiplyZeroAgain(long x) {\n+        return x * 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks (c1 + x) * c2 => x * c2 + c3 where c3 = c1 * c2\n+    public long distribute(long x) {\n+        return (13 + x) * 14;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    \/\/ Checks 1 * x => x\n+    public long identity(long x) {\n+        return 1 * x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    \/\/ Checks x * 1 => x\n+    public long identityAgain(long x) {\n+        return x * 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x * 2^n => x << n\n+    public long powerTwo(long x) {\n+        return x * 64;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x * 2^n => x << n\n+    public long powerTwoAgain(long x) {\n+        return x * (1025 - 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks x * (2^n + 1) => (x << n) + x\n+    public long powerTwoPlusOne(long x) {\n+        return x * (64 + 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\",\n+                  IRNode.SUB, \"1\",\n+                 })\n+    \/\/ Checks x * (2^n - 1) => (x << n) - x\n+    public long powerTwoMinusOne(long x) {\n+        return x * (64 - 1);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MulLNodeIdealizationTests.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,252 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Test that Ideal transformations of SubINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.SubINodeIdealizationTests\n+ *\/\n+public class SubINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"test1\", \"test2\", \"test3\",\n+                 \"test4\", \"test5\", \"test6\",\n+                 \"test7\", \"test8\", \"test9\",\n+                 \"test10\", \"test11\", \"test12\",\n+                 \"test13\", \"test14\", \"test15\",\n+                 \"test16\", \"test17\", \"test18\",\n+                 \"test19\", \"test20\", \"test21\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+        int b = RunInfo.getRandom().nextInt();\n+        int c = RunInfo.getRandom().nextInt();\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0, 0);\n+        assertResult(a, b, c);\n+        assertResult(min, min, min);\n+        assertResult(max, max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b, int c) {\n+        Asserts.assertEQ(a - 1            , test1(a));\n+        Asserts.assertEQ((a + 1) - b      , test2(a, b));\n+        Asserts.assertEQ(a - (b + 2021)   , test3(a, b));\n+        Asserts.assertEQ(a - (a + b)      , test4(a, b));\n+        Asserts.assertEQ((a - b) - a      , test5(a, b));\n+        Asserts.assertEQ(a - (b + a)      , test6(a, b));\n+        Asserts.assertEQ(0 - (a - b)      , test7(a, b));\n+        Asserts.assertEQ(0 - (a + 2021)   , test8(a));\n+        Asserts.assertEQ((a + b) - (a + c), test9(a, b, c));\n+        Asserts.assertEQ((b + a) - (c + a), test10(a, b, c));\n+        Asserts.assertEQ((b + a) - (a + c), test11(a, b, c));\n+        Asserts.assertEQ((a + b) - (c + a), test12(a, b, c));\n+        Asserts.assertEQ(a - (b - c)      , test13(a, b, c));\n+        Asserts.assertEQ(0 - (a >> 31)    , test14(a));\n+        Asserts.assertEQ(0 - (0 - a)      , test15(a));\n+        Asserts.assertEQ((a + b) - b      , test16(a, b));\n+        Asserts.assertEQ((a + b) - a      , test17(a, b));\n+        Asserts.assertEQ(a*b - a*c        , test18(a, b, c));\n+        Asserts.assertEQ(a*b - b*c        , test19(a, b, c));\n+        Asserts.assertEQ(a*c - b*c        , test20(a, b, c));\n+        Asserts.assertEQ(a*b - c*a        , test21(a, b, c));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x - c0) => x + (-c0)\n+    public int test1(int x) {\n+        return (x - 1);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"1\",\n+                  IRNode.SUB, \"1\"\n+                 })\n+    \/\/ Checks (x + c0) - y => (x - y) + c0\n+    public int test2(int x, int y) {\n+        return (x + 1) - y;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks x - (y + c0) => (x - y) + (-c0)\n+    public int test3(int x, int y) {\n+        return x - (y + 2021);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (x + y) => -y\n+    public int test4(int x, int y) {\n+        return x - (x + y);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x - y) - x => -y\n+    public int test5(int x, int y) {\n+        return (x - y) - x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (y + x) => -y\n+    public int test6(int x, int y) {\n+        return x - (y + x);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x - y) => y - x\n+    public int test7(int x, int y) {\n+        return 0 - (x - y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x + 2021) => -2021 - x\n+    public int test8(int x) {\n+        return 0 - (x + 2021);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (x + b) => a - b;\n+    public int test9(int x, int a, int b) {\n+        return (x + a) - (x + b);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (b + x) => a - b\n+    public int test10(int x, int a, int b) {\n+        return (a + x) - (b + x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (x + b) => a - b\n+    public int test11(int x, int a, int b) {\n+        return (a + x) - (x + b);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (b + x) => a - b\n+    public int test12(int x, int a, int b) {\n+        return (x + a) - (b + x);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a - (b - c) => (a + c) - b\n+    public int test13(int a, int b, int c) {\n+        return a - (b - c);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.RSHIFT_I})\n+    @IR(counts = {IRNode.URSHIFT_I, \"1\"})\n+    \/\/ Checks 0 - (a >> 31) => a >>> 31\n+    \/\/        signed ^^          ^^^ unsigned\n+    public int test14(int a) {\n+        return 0 - (a >> 31);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB})\n+    \/\/ Checks 0 - (0 - x) => x\n+    public int test15(int x) {\n+        return 0 - (0 - x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks (x + y) - y => y\n+    public int test16(int x, int y) {\n+        return (x + y) - y;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks (x + y) - x => y\n+    public int test17(int x, int y) {\n+        return (x + y) - x;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.SUB, \"1\"})\n+    \/\/ Checks \"a*b-a*c => a*(b-c)\n+    public int test18(int a, int b, int c) {\n+        return a*b - a*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.SUB, \"1\"})\n+    \/\/ Checks a*b-b*c => b*(a-c)\n+    public int test19(int a, int b, int c) {\n+        return a*b - b*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.SUB, \"1\"})\n+    \/\/ Checks a*c-b*c => (a-b)*c\n+    public int test20(int a, int b, int c) {\n+        return a*c - b*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.SUB, \"1\"})\n+    \/\/ Checks a*b-c*a => a*(b-c)\n+    public int test21(int a, int b, int c) {\n+        return a*b - c*a;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/SubINodeIdealizationTests.java","additions":252,"deletions":0,"binary":false,"changes":252,"status":"added"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Test that Ideal transformations of SubLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.SubLNodeIdealizationTests\n+ *\/\n+public class SubLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"test1\", \"test2\", \"test3\",\n+                 \"test4\", \"test5\", \"test6\",\n+                 \"test7\", \"test8\", \"test9\",\n+                 \"test10\", \"test11\", \"test12\",\n+                 \"test13\", \"test14\", \"test15\",\n+                 \"test16\", \"test17\", \"test18\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        long b = RunInfo.getRandom().nextLong();\n+        long c = RunInfo.getRandom().nextLong();\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0, 0);\n+        assertResult(a, b, c);\n+        assertResult(min, min, min);\n+        assertResult(max, max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b, long c) {\n+        Asserts.assertEQ(a - 1            , test1(a));\n+        Asserts.assertEQ((a + 1) - b      , test2(a, b));\n+        Asserts.assertEQ(a - (b + 2021)   , test3(a, b));\n+        Asserts.assertEQ(a - (a + b)      , test4(a, b));\n+        Asserts.assertEQ(a - (b + a)      , test5(a, b));\n+        Asserts.assertEQ(0 - (a - b)      , test6(a, b));\n+        Asserts.assertEQ(0 - (a + 2021)   , test7(a, b));\n+        Asserts.assertEQ((a + b) - (a + c), test8(a, b, c));\n+        Asserts.assertEQ((b + a) - (c + a), test9(a, b, c));\n+        Asserts.assertEQ((b + a) - (a + c), test10(a, b, c));\n+        Asserts.assertEQ((a + b) - (c + a), test11(a, b, c));\n+        Asserts.assertEQ(a - (b - c)      , test12(a, b, c));\n+        Asserts.assertEQ(0 - (a >> 63)    , test13(a));\n+        Asserts.assertEQ(0 - (0 - a)      , test14(a));\n+        Asserts.assertEQ(a*b - a*c        , test15(a, b, c));\n+        Asserts.assertEQ(a*b - b*c        , test16(a, b, c));\n+        Asserts.assertEQ(a*c - b*c        , test17(a, b, c));\n+        Asserts.assertEQ(a*b - c*a        , test18(a, b, c));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x - c0) => x + (-c0)\n+    public long test1(long x) {\n+        return (x - 1);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"1\",\n+                  IRNode.SUB, \"1\"\n+                 })\n+    \/\/ Checks (x + c0) - y => (x - y) + c0\n+    public long test2(long x, long y) {\n+        return (x + 1) - y;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks x - (y + c0) => (x - y) + (-c0)\n+    public long test3(long x, long y) {\n+        return x - (y + 2021);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (x + y) => 0 - y\n+    public long test4(long x, long y) {\n+        return x - (x + y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (y + x) => 0 - y\n+    public long test5(long x, long y) {\n+        return x - (y + x);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x - y) => y - x\n+    public long test6(long x, long y) {\n+        return 0 - (x - y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x + 2021) => -2021 - x\n+    public long test7(long x, long y) {\n+        return 0 - (x + 2021);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (x + b) => a - b;\n+    public long test8(long x, long a, long b) {\n+        return (x + a) - (x + b);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (b + x) => a - b\n+    public long test9(long x, long a, long b) {\n+        return (a + x) - (b + x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (x + b) => a - b\n+    public long test10(long x, long a, long b) {\n+        return (a + x) - (x + b);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (b + x) => a - b\n+    public long test11(long x, long a, long b) {\n+        return (x + a) - (b + x);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a - (b - c) => (a + c) - b\n+    public long test12(long a, long b, long c) {\n+        return a - (b - c);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.RSHIFT_L})\n+    @IR(counts = {IRNode.URSHIFT_L, \"1\"})\n+    \/\/ Checks 0 - (a >> 63) => a >>> 63\n+    \/\/        signed ^^          ^^^ unsigned\n+    public long test13(long a) {\n+        return 0 - (a >> 63);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB})\n+    \/\/ Checks 0 - (0 - x) => x\n+    public long test14(long x) {\n+        return 0 - (0 - x);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.SUB, \"1\"})\n+    \/\/ Checks \"a*b-a*c => a*(b-c)\n+    public long test15(long a, long b, long c) {\n+        return a*b - a*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.SUB, \"1\"})\n+    \/\/ Checks a*b-b*c => b*(a-c)\n+    public long test16(long a, long b, long c) {\n+        return a*b - b*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.SUB, \"1\"})\n+    \/\/ Checks a*c-b*c => (a-b)*c\n+    public long test17(long a, long b, long c) {\n+        return a*c - b*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.SUB, \"1\"})\n+    \/\/ Checks a*b-c*a => a*(b-c)\n+    public long test18(long a, long b, long c) {\n+        return a*b - c*a;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/SubLNodeIdealizationTests.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests.loopOpts;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Test that Ideal transformations of CountedLoopNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.loopOpts.LoopIdealizationTests\n+ *\/\n+public class LoopIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @DontInline\n+    private void blackhole() { }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.CALL})\n+    \/\/ Checks that a for loop with 0 iterations is removed\n+    public void zeroIterForLoop() {\n+        for (int i = 0; i < 0; i++) {\n+            System.out.println(13 \/ 17 * 23 + 1);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.CALL})\n+    \/\/ Checks that a for loop with 1 iteration doesn't have CountedLoop nodes\n+    public void iterOneBreakForLoop() {\n+        for (int i = 0; i < 500; i++) {\n+            break;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/ Checks that a for loop with 1 iteration is simplified to straight code\n+    public void oneIterForLoop() {\n+        for (int i = 0; i < 1; i++) {\n+            this.blackhole();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/ Checks that a for loop with 1 iteration is simplified to straight code\n+    public void oneIterForLoop1() {\n+        for (int i = 0; i < 500; i++) {\n+            this.blackhole();\n+            break;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/ Checks that a for loop with 1 iteration is simplified to straight code\n+    public void oneIterForLoop2() {\n+        for (int i = 0; i < 500; i++) {\n+            this.blackhole();\n+            if (i == 0){\n+                break;\n+           }\n+           else {\n+               this.blackhole();\n+               i++;\n+           }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOOP, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/ Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterWhileLoop() {\n+        while (true) {\n+            this.blackhole();\n+            break;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/ Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterWhileLoop1() {\n+        int i = 0;\n+        while (i < 1) {\n+            this.blackhole();\n+            i++;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/ Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterWhileLoop2() {\n+        int i = 0;\n+        while (i < 500){\n+            this.blackhole();\n+            if (i == 0){\n+                 break;\n+            }\n+            else {\n+                this.blackhole();\n+                i++;\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOOP, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/ Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterDoWhileLoop() {\n+        do {\n+            this.blackhole();\n+            break;\n+        } while (true);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOOP, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/ Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterDoWhileLoop1() {\n+        do {\n+            this.blackhole();\n+        } while (false);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/ Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterDoWhileLoop2() {\n+        int i = 0;\n+        do {\n+            this.blackhole();\n+            i++;\n+        } while (i == -1);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/loopOpts\/LoopIdealizationTests.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests.scalarReplacement;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Tests that Escape Analysis and Scalar Replacement is able to handle some simple cases.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.scalarReplacement.ScalarReplacementTests\n+ *\/\n+public class ScalarReplacementTests {\n+    private class Person {\n+        private String name;\n+        private int age;\n+\n+        public Person(Person p) {\n+            this.name = p.getName();\n+            this.age = p.getAge();\n+        }\n+\n+        public Person(String name, int age) {\n+            this.name = name;\n+            this.age = age;\n+        }\n+\n+        public String getName() { return name; }\n+        public int getAge() { return age; }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS, IRNode.ALLOC})\n+    public String stringConstant(int age) {\n+        Person p = new Person(\"Java\", age);\n+        return p.getName();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS, IRNode.ALLOC})\n+    public int intConstant(int age) {\n+        Person p = new Person(\"Java\", age);\n+        return p.getAge();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS, IRNode.ALLOC})\n+    public String nestedStringConstant(int age) {\n+        Person p1 = new Person(\"Java\", age);\n+        Person p2 = new Person(p1);\n+        return p2.getName();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS, IRNode.ALLOC})\n+    public int nestedIntConstant(int age) {\n+        Person p1 = new Person(\"Java\", age);\n+        Person p2 = new Person(p1);\n+        return p2.getAge();\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS, IRNode.ALLOC})\n+    public int nestedConstants(int age1, int age2) {\n+        Person p = new Person(\n+                        new Person(\"Java\", age1).getName(),\n+                        new Person(\"Java\", age2).getAge());\n+        return p.getAge();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/ScalarReplacementTests.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"}]}