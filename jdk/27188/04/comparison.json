{"files":[{"patch":"@@ -7084,1 +7084,1 @@\n-                    vReg tmp3, vReg tmp4, pReg ptmp, pRegGov pgtmp) %{\n+                    vReg tmp3, pReg ptmp, pRegGov pgtmp) %{\n@@ -7086,1 +7086,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ptmp, TEMP pgtmp);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP ptmp, TEMP pgtmp);\n@@ -7088,1 +7088,1 @@\n-  format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, tmp4, $ptmp, $pgtmp\" %}\n+  format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, $ptmp, $pgtmp\" %}\n@@ -7090,0 +7090,1 @@\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -7091,3 +7092,2 @@\n-                         $tmp1$$FloatRegister,$tmp2$$FloatRegister,\n-                         $tmp3$$FloatRegister,$tmp4$$FloatRegister,\n-                         $ptmp$$PRegister, $pgtmp$$PRegister);\n+                         $tmp1$$FloatRegister, $tmp2$$FloatRegister, $tmp3$$FloatRegister,\n+                         $ptmp$$PRegister, $pgtmp$$PRegister, length_in_bytes);\n@@ -7098,2 +7098,1 @@\n-instruct vcompressS(vReg dst, vReg src, pReg pg,\n-                    vReg tmp1, vReg tmp2, pRegGov pgtmp) %{\n+instruct vcompressS(vReg dst, vReg src, pReg pg, vReg tmp1, vReg tmp2, pRegGov pgtmp) %{\n@@ -7105,0 +7104,2 @@\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ sve_dup($tmp1$$FloatRegister, __ H, 0);\n@@ -7106,1 +7107,2 @@\n-                          $tmp1$$FloatRegister,$tmp2$$FloatRegister, $pgtmp$$PRegister);\n+                          $tmp1$$FloatRegister, $tmp2$$FloatRegister, $pgtmp$$PRegister,\n+                          length_in_bytes);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -5072,1 +5072,1 @@\n-                    vReg tmp3, vReg tmp4, pReg ptmp, pRegGov pgtmp) %{\n+                    vReg tmp3, pReg ptmp, pRegGov pgtmp) %{\n@@ -5074,1 +5074,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ptmp, TEMP pgtmp);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP ptmp, TEMP pgtmp);\n@@ -5076,1 +5076,1 @@\n-  format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, tmp4, $ptmp, $pgtmp\" %}\n+  format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, $ptmp, $pgtmp\" %}\n@@ -5078,0 +5078,1 @@\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -5079,3 +5080,2 @@\n-                         $tmp1$$FloatRegister,$tmp2$$FloatRegister,\n-                         $tmp3$$FloatRegister,$tmp4$$FloatRegister,\n-                         $ptmp$$PRegister, $pgtmp$$PRegister);\n+                         $tmp1$$FloatRegister, $tmp2$$FloatRegister, $tmp3$$FloatRegister,\n+                         $ptmp$$PRegister, $pgtmp$$PRegister, length_in_bytes);\n@@ -5086,2 +5086,1 @@\n-instruct vcompressS(vReg dst, vReg src, pReg pg,\n-                    vReg tmp1, vReg tmp2, pRegGov pgtmp) %{\n+instruct vcompressS(vReg dst, vReg src, pReg pg, vReg tmp1, vReg tmp2, pRegGov pgtmp) %{\n@@ -5093,0 +5092,2 @@\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ sve_dup($tmp1$$FloatRegister, __ H, 0);\n@@ -5094,1 +5095,2 @@\n-                          $tmp1$$FloatRegister,$tmp2$$FloatRegister, $pgtmp$$PRegister);\n+                          $tmp1$$FloatRegister, $tmp2$$FloatRegister, $pgtmp$$PRegister,\n+                          length_in_bytes);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3489,0 +3489,1 @@\n+  INSN(sve_splice,0b00000101, 0b101100100); \/\/ splice two vectors under predicate control, destructive\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2206,1 +2206,1 @@\n-\/\/ Preserves: src, mask\n+\/\/ Preserves: mask, vzr\n@@ -2208,2 +2208,2 @@\n-                                           FloatRegister vtmp1, FloatRegister vtmp2,\n-                                           PRegister pgtmp) {\n+                                           FloatRegister vzr, FloatRegister vtmp,\n+                                           PRegister pgtmp, unsigned vector_length_in_bytes) {\n@@ -2211,1 +2211,3 @@\n-  assert_different_registers(dst, src, vtmp1, vtmp2);\n+  \/\/ When called by sve_compress_byte, src and vtmp may be the same register.\n+  assert_different_registers(dst, src, vzr);\n+  assert_different_registers(dst, vtmp, vzr);\n@@ -2213,5 +2215,4 @@\n-\n-  \/\/ Example input:   src   = 8888 7777 6666 5555 4444 3333 2222 1111\n-  \/\/                  mask  = 0001 0000 0000 0001 0001 0000 0001 0001\n-  \/\/ Expected result: dst   = 0000 0000 0000 8888 5555 4444 2222 1111\n-  sve_dup(vtmp2, H, 0);\n+  \/\/ high <-- low\n+  \/\/ Example input:   src   = hh gg ff ee dd cc bb aa, one character is 8 bits.\n+  \/\/                  mask  = 01 00 00 01 01 00 01 01, one character is 1 bit.\n+  \/\/ Expected result: dst   = 00 00 00 hh ee dd bb aa\n@@ -2220,1 +2221,1 @@\n-  \/\/ dst = 00004444 00003333 00002222 00001111\n+  \/\/ dst   =  00dd  00cc  00bb  00aa\n@@ -2222,1 +2223,1 @@\n-  \/\/ pgtmp = 00000001 00000000 00000001 00000001\n+  \/\/ pgtmp =  0001  0000  0001  0001\n@@ -2226,1 +2227,1 @@\n-  \/\/ dst = 00000000 00004444 00002222 00001111\n+  \/\/ dst   =  0000  00dd  00bb  00aa\n@@ -2229,2 +2230,9 @@\n-  \/\/ dst = 0000 0000 0000 0000 0000 4444 2222 1111\n-  sve_uzp1(dst, H, dst, vtmp2);\n+  \/\/ dst   = 00 00 00 00 00 dd bb aa\n+  sve_uzp1(dst, H, dst, vzr);\n+\n+  \/\/ Return if the vector length is no more than MaxVectorSize\/2, since the\n+  \/\/ highest half is invalid.\n+  if (vector_length_in_bytes <= (MaxVectorSize >> 1)) {\n+    return;\n+  }\n+\n@@ -2236,1 +2244,1 @@\n-  \/\/ pgtmp = 00000001 00000000 00000000 00000001\n+  \/\/ pgtmp =  0001  0000  0000  0001\n@@ -2238,20 +2246,14 @@\n-  \/\/ vtmp1 = 00008888 00007777 00006666 00005555\n-  sve_uunpkhi(vtmp1, S, src);\n-  \/\/ vtmp1 = 00000000 00000000 00008888 00005555\n-  sve_compact(vtmp1, S, vtmp1, pgtmp);\n-  \/\/ vtmp1 = 0000 0000 0000 0000 0000 0000 8888 5555\n-  sve_uzp1(vtmp1, H, vtmp1, vtmp2);\n-\n-  \/\/ Compressed low:   dst   = 0000 0000 0000 0000 0000 4444 2222 1111\n-  \/\/ Compressed high:  vtmp1 = 0000 0000 0000 0000 0000 0000 8888  5555\n-  \/\/ Left shift(cross lane) compressed high with TRUE_CNT lanes,\n-  \/\/ TRUE_CNT is the number of active elements in the compressed low.\n-  neg(rscratch1, rscratch1);\n-  \/\/ vtmp2 = {4 3 2 1 0 -1 -2 -3}\n-  sve_index(vtmp2, H, rscratch1, 1);\n-  \/\/ vtmp1 = 0000 0000 0000 8888 5555 0000 0000 0000\n-  sve_tbl(vtmp1, H, vtmp1, vtmp2);\n-\n-  \/\/ Combine the compressed high(after shifted) with the compressed low.\n-  \/\/ dst = 0000 0000 0000 8888 5555 4444 2222 1111\n-  sve_orr(dst, dst, vtmp1);\n+  \/\/ vtmp  =  00hh  00gg  00ff  00ee\n+  sve_uunpkhi(vtmp, S, src);\n+  \/\/ vtmp  =  0000  0000  00hh  00ee\n+  sve_compact(vtmp, S, vtmp, pgtmp);\n+  \/\/ vtmp  = 00 00 00 00 00 00 hh ee\n+  sve_uzp1(vtmp, H, vtmp, vzr);\n+\n+  \/\/ pgtmp = 00 00 00 00 00 01 01 01\n+  sve_whilelt(pgtmp, H, zr, rscratch1);\n+  \/\/ Compressed low:  dst  = 00 00 00 00 00 dd bb aa\n+  \/\/ Compressed high: vtmp = 00 00 00 00 00 00 hh ee\n+  \/\/ Combine the compressed low with the compressed high:\n+  \/\/                  dst  = 00 00 00 hh ee dd bb aa\n+  sve_splice(dst, H, pgtmp, vtmp);\n@@ -2263,3 +2265,2 @@\n-                                          FloatRegister vtmp1, FloatRegister vtmp2,\n-                                          FloatRegister vtmp3, FloatRegister vtmp4,\n-                                          PRegister ptmp, PRegister pgtmp) {\n+                                          FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3,\n+                                          PRegister ptmp, PRegister pgtmp, unsigned vector_length_in_bytes) {\n@@ -2267,1 +2268,1 @@\n-  assert_different_registers(dst, src, vtmp1, vtmp2, vtmp3, vtmp4);\n+  assert_different_registers(dst, src, vtmp1, vtmp2, vtmp3);\n@@ -2269,3 +2270,6 @@\n-  \/\/ Example input:   src   = 88 77 66 55 44 33 22 11\n-  \/\/                  mask  = 01 00 00 01 01 00 01 01\n-  \/\/ Expected result: dst   = 00 00 00 88 55 44 22 11\n+  \/\/ high <-- low\n+  \/\/ Example input:   src   = q p n m l k j i h g f e d c b a, one character is 8 bits.\n+  \/\/                  mask  = 0 1 0 0 0 0 0 1 0 1 0 0 0 1 0 1, one character is 1 bit.\n+  \/\/ Expected result: dst   = 0 0 0 0 0 0 0 0 0 0 0 p i g c a\n+  FloatRegister vzr = vtmp3;\n+  sve_dup(vzr, B, 0);\n@@ -2273,1 +2277,0 @@\n-  sve_dup(vtmp4, B, 0);\n@@ -2275,1 +2278,1 @@\n-  \/\/ vtmp1 = 0044 0033 0022 0011\n+  \/\/ vtmp1 =  0h  0g  0f  0e  0d  0c  0b  0a\n@@ -2277,1 +2280,1 @@\n-  \/\/ ptmp = 0001 0000 0001 0001\n+  \/\/ ptmp  =  00  01  00  00  00  01  00  01\n@@ -2279,3 +2282,0 @@\n-  \/\/ Count the active elements of lowest half.\n-  \/\/ rscratch2 = 3\n-  sve_cntp(rscratch2, H, ptrue, ptmp);\n@@ -2284,2 +2284,3 @@\n-  \/\/ dst = 0000 0044 0022 0011\n-  sve_compress_short(dst, vtmp1, ptmp, vtmp2, vtmp3, pgtmp);\n+  \/\/ dst   =  00  00  00  00  00  0g  0c  0a\n+  unsigned extended_size = vector_length_in_bytes << 1;\n+  sve_compress_short(dst, vtmp1, ptmp, vzr, vtmp2, pgtmp, extended_size > MaxVectorSize ? MaxVectorSize : extended_size);\n@@ -2287,2 +2288,11 @@\n-  \/\/ dst = 00 00 00 00 00 44 22 11\n-  sve_uzp1(dst, B, dst, vtmp4);\n+  \/\/ dst   = 0 0 0 0 0 0 0 0 0 0 0 0 0 g c a\n+  sve_uzp1(dst, B, dst, vzr);\n+\n+  \/\/ Return if the vector length is no more than MaxVectorSize\/2, since the\n+  \/\/ highest half is invalid.\n+  if (vector_length_in_bytes <= (MaxVectorSize >> 1)) {\n+    return;\n+  }\n+  \/\/ Count the active elements of lowest half.\n+  \/\/ rscratch2 = 3\n+  sve_cntp(rscratch2, H, ptrue, ptmp);\n@@ -2291,1 +2301,1 @@\n-  \/\/ ptmp = 0001 0000 0000 0001\n+  \/\/ ptmp  =  00  01  00  00  00  00  00  01\n@@ -2293,1 +2303,1 @@\n-  \/\/ vtmp1 = 0088 0077 0066 0055\n+  \/\/ vtmp2 =  0q  0p  0n  0m  0l  0k  0j  0i\n@@ -2295,19 +2305,12 @@\n-  \/\/ vtmp1 = 0000 0000 0088 0055\n-  sve_compress_short(vtmp1, vtmp2, ptmp, vtmp3, vtmp4, pgtmp);\n-\n-  sve_dup(vtmp4, B, 0);\n-  \/\/ vtmp1 = 00 00 00 00 00 00 88 55\n-  sve_uzp1(vtmp1, B, vtmp1, vtmp4);\n-\n-  \/\/ Compressed low:   dst   = 00 00 00 00 00 44 22 11\n-  \/\/ Compressed high:  vtmp1 = 00 00 00 00 00 00 88 55\n-  \/\/ Left shift(cross lane) compressed high with TRUE_CNT lanes,\n-  \/\/ TRUE_CNT is the number of active elements in the compressed low.\n-  neg(rscratch2, rscratch2);\n-  \/\/ vtmp2 = {4 3 2 1 0 -1 -2 -3}\n-  sve_index(vtmp2, B, rscratch2, 1);\n-  \/\/ vtmp1 = 00 00 00 88 55 00 00 00\n-  sve_tbl(vtmp1, B, vtmp1, vtmp2);\n-  \/\/ Combine the compressed high(after shifted) with the compressed low.\n-  \/\/ dst = 00 00 00 88 55 44 22 11\n-  sve_orr(dst, dst, vtmp1);\n+  \/\/ vtmp1 =  00  00  00  00  00  00  0p  0i\n+  sve_compress_short(vtmp1, vtmp2, ptmp, vzr, vtmp2, pgtmp, extended_size - MaxVectorSize);\n+  \/\/ vtmp1 = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 p i\n+  sve_uzp1(vtmp1, B, vtmp1, vzr);\n+\n+  \/\/ ptmp  = 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1\n+  sve_whilelt(ptmp, B, zr, rscratch2);\n+  \/\/ Compressed low:  dst   = 0 0 0 0 0 0 0 0 0 0 0 0 0 g c a\n+  \/\/ Compressed high: vtmp1 = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 p i\n+  \/\/ Combine the compressed low with the compressed high:\n+  \/\/                  dst   = 0 0 0 0 0 0 0 0 0 0 0 p i g c a\n+  sve_splice(dst, B, ptmp, vtmp1);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":76,"deletions":73,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -176,3 +176,2 @@\n-                         FloatRegister vtmp1, FloatRegister vtmp2,\n-                         FloatRegister vtmp3, FloatRegister vtmp4,\n-                         PRegister ptmp, PRegister pgtmp);\n+                         FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3,\n+                         PRegister ptmp, PRegister pgtmp, unsigned vector_length_in_bytes);\n@@ -181,2 +180,2 @@\n-                          FloatRegister vtmp1, FloatRegister vtmp2,\n-                          PRegister pgtmp);\n+                          FloatRegister vzr, FloatRegister vtmp,\n+                          PRegister pgtmp, unsigned vector_length_in_bytes);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2146,0 +2146,4 @@\n+                        [\"splice\",   \"__ sve_splice(z0, __ B, p0, z1);\",                   \"splice\\tz0.b, p0, z0.b, z1.b\"],\n+                        [\"splice\",   \"__ sve_splice(z0, __ H, p0, z1);\",                   \"splice\\tz0.h, p0, z0.h, z1.h\"],\n+                        [\"splice\",   \"__ sve_splice(z0, __ S, p0, z1);\",                   \"splice\\tz0.s, p0, z0.s, z1.s\"],\n+                        [\"splice\",   \"__ sve_splice(z0, __ D, p0, z1);\",                   \"splice\\tz0.d, p0, z0.d, z1.d\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1159,0 +1159,4 @@\n+    __ sve_splice(z0, __ B, p0, z1);                   \/\/       splice  z0.b, p0, z0.b, z1.b\n+    __ sve_splice(z0, __ H, p0, z1);                   \/\/       splice  z0.h, p0, z0.h, z1.h\n+    __ sve_splice(z0, __ S, p0, z1);                   \/\/       splice  z0.s, p0, z0.s, z1.s\n+    __ sve_splice(z0, __ D, p0, z1);                   \/\/       splice  z0.d, p0, z0.d, z1.d\n@@ -1448,7 +1452,7 @@\n-    0x14000000,     0x17ffffd7,     0x140004b7,     0x94000000,\n-    0x97ffffd4,     0x940004b4,     0x3400000a,     0x34fffa2a,\n-    0x3400962a,     0x35000008,     0x35fff9c8,     0x350095c8,\n-    0xb400000b,     0xb4fff96b,     0xb400956b,     0xb500001d,\n-    0xb5fff91d,     0xb500951d,     0x10000013,     0x10fff8b3,\n-    0x100094b3,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36309436,     0x3758000c,     0x375ff7cc,     0x375893cc,\n+    0x14000000,     0x17ffffd7,     0x140004bb,     0x94000000,\n+    0x97ffffd4,     0x940004b8,     0x3400000a,     0x34fffa2a,\n+    0x340096aa,     0x35000008,     0x35fff9c8,     0x35009648,\n+    0xb400000b,     0xb4fff96b,     0xb40095eb,     0xb500001d,\n+    0xb5fff91d,     0xb500959d,     0x10000013,     0x10fff8b3,\n+    0x10009533,     0x90000013,     0x36300016,     0x3637f836,\n+    0x363094b6,     0x3758000c,     0x375ff7cc,     0x3758944c,\n@@ -1459,13 +1463,13 @@\n-    0x540091a0,     0x54000001,     0x54fff541,     0x54009141,\n-    0x54000002,     0x54fff4e2,     0x540090e2,     0x54000002,\n-    0x54fff482,     0x54009082,     0x54000003,     0x54fff423,\n-    0x54009023,     0x54000003,     0x54fff3c3,     0x54008fc3,\n-    0x54000004,     0x54fff364,     0x54008f64,     0x54000005,\n-    0x54fff305,     0x54008f05,     0x54000006,     0x54fff2a6,\n-    0x54008ea6,     0x54000007,     0x54fff247,     0x54008e47,\n-    0x54000008,     0x54fff1e8,     0x54008de8,     0x54000009,\n-    0x54fff189,     0x54008d89,     0x5400000a,     0x54fff12a,\n-    0x54008d2a,     0x5400000b,     0x54fff0cb,     0x54008ccb,\n-    0x5400000c,     0x54fff06c,     0x54008c6c,     0x5400000d,\n-    0x54fff00d,     0x54008c0d,     0x5400000e,     0x54ffefae,\n-    0x54008bae,     0x5400000f,     0x54ffef4f,     0x54008b4f,\n+    0x54009220,     0x54000001,     0x54fff541,     0x540091c1,\n+    0x54000002,     0x54fff4e2,     0x54009162,     0x54000002,\n+    0x54fff482,     0x54009102,     0x54000003,     0x54fff423,\n+    0x540090a3,     0x54000003,     0x54fff3c3,     0x54009043,\n+    0x54000004,     0x54fff364,     0x54008fe4,     0x54000005,\n+    0x54fff305,     0x54008f85,     0x54000006,     0x54fff2a6,\n+    0x54008f26,     0x54000007,     0x54fff247,     0x54008ec7,\n+    0x54000008,     0x54fff1e8,     0x54008e68,     0x54000009,\n+    0x54fff189,     0x54008e09,     0x5400000a,     0x54fff12a,\n+    0x54008daa,     0x5400000b,     0x54fff0cb,     0x54008d4b,\n+    0x5400000c,     0x54fff06c,     0x54008cec,     0x5400000d,\n+    0x54fff00d,     0x54008c8d,     0x5400000e,     0x54ffefae,\n+    0x54008c2e,     0x5400000f,     0x54ffef4f,     0x54008bcf,\n@@ -1692,1 +1696,2 @@\n-    0x6585c891,     0x65c5c891,     0x45b0c210,     0x45f1c231,\n+    0x6585c891,     0x65c5c891,     0x052c8020,     0x056c8020,\n+    0x05ac8020,     0x05ec8020,     0x45b0c210,     0x45f1c231,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":26,"deletions":21,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2838,0 +2838,30 @@\n+    public static final String COMPRESS_VB = VECTOR_PREFIX + \"COMPRESS_VB\" + POSTFIX;\n+    static {\n+        vectorNode(COMPRESS_VB, \"CompressV\", TYPE_BYTE);\n+    }\n+\n+    public static final String COMPRESS_VS = VECTOR_PREFIX + \"COMPRESS_VS\" + POSTFIX;\n+    static {\n+        vectorNode(COMPRESS_VS, \"CompressV\", TYPE_SHORT);\n+    }\n+\n+    public static final String COMPRESS_VI = VECTOR_PREFIX + \"COMPRESS_VI\" + POSTFIX;\n+    static {\n+        vectorNode(COMPRESS_VI, \"CompressV\", TYPE_INT);\n+    }\n+\n+    public static final String COMPRESS_VL = VECTOR_PREFIX + \"COMPRESS_VL\" + POSTFIX;\n+    static {\n+        vectorNode(COMPRESS_VL, \"CompressV\", TYPE_LONG);\n+    }\n+\n+    public static final String COMPRESS_VF = VECTOR_PREFIX + \"COMPRESS_VF\" + POSTFIX;\n+    static {\n+        vectorNode(COMPRESS_VF, \"CompressV\", TYPE_FLOAT);\n+    }\n+\n+    public static final String COMPRESS_VD = VECTOR_PREFIX + \"COMPRESS_VD\" + POSTFIX;\n+    static {\n+        vectorNode(COMPRESS_VD, \"CompressV\", TYPE_DOUBLE);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+        \"avx512_vbmi2\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.generators.*;\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @bug 8366333\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @summary IR test for VectorAPI compress\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorCompressTest\n+ *\/\n+\n+public class VectorCompressTest {\n+    static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n+    static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_MAX;\n+    static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n+    static final VectorSpecies<Float> F_SPECIES = FloatVector.SPECIES_MAX;\n+    static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+    static final VectorSpecies<Double> D_SPECIES = DoubleVector.SPECIES_MAX;\n+    static final int LENGTH = 512;\n+    static final Generators RD = Generators.G;\n+    static byte[] ba, bb;\n+    static short[] sa, sb;\n+    static int[] ia, ib;\n+    static long[] la, lb;\n+    static float[] fa, fb;\n+    static double[] da, db;\n+    static boolean[] ma;\n+\n+    static {\n+        ba = new byte[LENGTH];\n+        bb = new byte[LENGTH];\n+        sa = new short[LENGTH];\n+        sb = new short[LENGTH];\n+        ia = new int[LENGTH];\n+        ib = new int[LENGTH];\n+        la = new long[LENGTH];\n+        lb = new long[LENGTH];\n+        fa = new float[LENGTH];\n+        fb = new float[LENGTH];\n+        da = new double[LENGTH];\n+        db = new double[LENGTH];\n+        ma = new boolean[LENGTH];\n+\n+        Generator<Integer> iGen = RD.ints();\n+        Generator<Long> lGen = RD.longs();\n+        Generator<Float> fGen = RD.floats();\n+        Generator<Double> dGen = RD.doubles();\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ba[i] = iGen.next().byteValue();\n+            sa[i] = iGen.next().shortValue();\n+            ma[i] = iGen.next() % 2 == 0;\n+        }\n+        RD.fill(iGen, ia);\n+        RD.fill(lGen, la);\n+        RD.fill(fGen, fa);\n+        RD.fill(dGen, da);\n+    }\n+\n+    @DontInline\n+    static void verifyVectorCompressByte(int vlen) {\n+        int index = 0;\n+        for (int i = 0; i < vlen; i++) {\n+            if (ma[i]) {\n+                Asserts.assertEquals(ba[i], bb[index++]);\n+            }\n+        }\n+        for (int i = index; i < vlen; i++) {\n+            Asserts.assertEquals((byte)0, bb[i]);\n+        }\n+    }\n+\n+    @DontInline\n+    static void verifyVectorCompressShort(int vlen) {\n+        int index = 0;\n+        for (int i = 0; i < vlen; i++) {\n+            if (ma[i]) {\n+                Asserts.assertEquals(sa[i], sb[index++]);\n+            }\n+        }\n+        for (int i = index; i < vlen; i++) {\n+            Asserts.assertEquals((short)0, sb[i]);\n+        }\n+    }\n+\n+    @DontInline\n+    static void verifyVectorCompressInteger(int vlen) {\n+        int index = 0;\n+        for (int i = 0; i < vlen; i++) {\n+            if (ma[i]) {\n+                Asserts.assertEquals(ia[i], ib[index++]);\n+            }\n+        }\n+        for (int i = index; i < vlen; i++) {\n+            Asserts.assertEquals(0, ib[i]);\n+        }\n+    }\n+\n+    @DontInline\n+    static void verifyVectorCompressLong(int vlen) {\n+        int index = 0;\n+        for (int i = 0; i < vlen; i++) {\n+            if (ma[i]) {\n+                Asserts.assertEquals(la[i], lb[index++]);\n+            }\n+        }\n+        for (int i = index; i < vlen; i++) {\n+            Asserts.assertEquals(0L, lb[i]);\n+        }\n+    }\n+\n+    @DontInline\n+    static void verifyVectorCompressFloat(int vlen) {\n+        int index = 0;\n+        for (int i = 0; i < vlen; i++) {\n+            if (ma[i]) {\n+                Asserts.assertEquals(fa[i], fb[index++]);\n+            }\n+        }\n+        for (int i = index; i < vlen; i++) {\n+            Asserts.assertEquals(0.0f, fb[i]);\n+        }\n+    }\n+\n+    @DontInline\n+    static void verifyVectorCompressDouble(int vlen) {\n+        int index = 0;\n+        for (int i = 0; i < vlen; i++) {\n+            if (ma[i]) {\n+                Asserts.assertEquals(da[i], db[index++]);\n+            }\n+        }\n+        for (int i = index; i < vlen; i++) {\n+            Asserts.assertEquals(0.0, db[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COMPRESS_VB, \"= 1\" },\n+        applyIfCPUFeature = { \"sve\", \"true\" })\n+    @IR(counts = { IRNode.COMPRESS_VB, \"= 1\" },\n+        applyIfCPUFeatureAnd = {\"avx512_vbmi2\", \"true\", \"avx512vl\", \"true\"})\n+    public static void testVectorCompressByte() {\n+        ByteVector av = ByteVector.fromArray(B_SPECIES, ba, 0);\n+        VectorMask<Byte> m = VectorMask.fromArray(B_SPECIES, ma, 0);\n+        av.compress(m).intoArray(bb, 0);\n+        verifyVectorCompressByte(B_SPECIES.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COMPRESS_VS, \"= 1\" },\n+        applyIfCPUFeature = { \"sve\", \"true\" })\n+    @IR(counts = { IRNode.COMPRESS_VS, \"= 1\" },\n+        applyIfCPUFeatureAnd = {\"avx512_vbmi2\", \"true\", \"avx512vl\", \"true\"})\n+    public static void testVectorCompressShort() {\n+        ShortVector av = ShortVector.fromArray(S_SPECIES, sa, 0);\n+        VectorMask<Short> m = VectorMask.fromArray(S_SPECIES, ma, 0);\n+        av.compress(m).intoArray(sb, 0);\n+        verifyVectorCompressShort(S_SPECIES.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COMPRESS_VI, \"= 1\" },\n+        applyIfCPUFeature = { \"sve\", \"true\" })\n+    @IR(counts = { IRNode.COMPRESS_VI, \"= 1\" },\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx512vl\", \"true\"})\n+    public static void testVectorCompressInt() {\n+        IntVector av = IntVector.fromArray(I_SPECIES, ia, 0);\n+        VectorMask<Integer> m = VectorMask.fromArray(I_SPECIES, ma, 0);\n+        av.compress(m).intoArray(ib, 0);\n+        verifyVectorCompressInteger(I_SPECIES.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COMPRESS_VL, \"= 1\" },\n+        applyIfCPUFeature = { \"sve\", \"true\" })\n+    @IR(counts = { IRNode.COMPRESS_VL, \"= 1\" },\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx512vl\", \"true\"})\n+    public static void testVectorCompressLong() {\n+        LongVector av = LongVector.fromArray(L_SPECIES, la, 0);\n+        VectorMask<Long> m = VectorMask.fromArray(L_SPECIES, ma, 0);\n+        av.compress(m).intoArray(lb, 0);\n+        verifyVectorCompressLong(L_SPECIES.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COMPRESS_VF, \"= 1\" },\n+        applyIfCPUFeature = { \"sve\", \"true\" })\n+    @IR(counts = { IRNode.COMPRESS_VF, \"= 1\" },\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx512vl\", \"true\"})\n+    public static void testVectorCompressFloat() {\n+        FloatVector av = FloatVector.fromArray(F_SPECIES, fa, 0);\n+        VectorMask<Float> m = VectorMask.fromArray(F_SPECIES, ma, 0);\n+        av.compress(m).intoArray(fb, 0);\n+        verifyVectorCompressFloat(F_SPECIES.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COMPRESS_VD, \"= 1\" },\n+        applyIfCPUFeature = { \"sve\", \"true\" })\n+    @IR(counts = { IRNode.COMPRESS_VD, \"= 1\" },\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx512vl\", \"true\"})\n+    public static void testVectorCompressDouble() {\n+        DoubleVector av = DoubleVector.fromArray(D_SPECIES, da, 0);\n+        VectorMask<Double> m = VectorMask.fromArray(D_SPECIES, ma, 0);\n+        av.compress(m).intoArray(db, 0);\n+        verifyVectorCompressDouble(D_SPECIES.length());\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(10000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCompressTest.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"}]}