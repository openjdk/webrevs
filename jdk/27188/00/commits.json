[{"commit":{"message":"8366333: AArch64: Enhance SVE subword type implementation of vector compress\n\nThe AArch64 SVE and SVE2 architectures lack an instruction suitable for\nsubword-type `compress` operations. Therefore, the current implementation\nuses the 32-bit SVE `compact` instruction to compress subword types by\nfirst widening the high and low parts to 32 bits, compressing them, and\nthen narrowing them back to their original type. Finally, the high and\nlow parts are merged using the `index + tbl` instructions.\n\nThis approach is significantly slower compared to architectures with native\nsupport. After evaluating all available AArch64 SVE instructions and\nexperimenting with various implementations—such as looping over the active\nelements, extraction, and insertion—I confirmed that the existing algorithm\nis optimal given the instruction set. However, there is still room for\noptimization in the following two aspects:\n1. Merging with `index + tbl` is suboptimal due to the high latency of\nthe `index` instruction.\n2. For partial subword types, operations to the highest half are unnecessary\nbecause those bits are invalid.\n\nThis pull request introduces the following changes:\n1. Replaces `index + tbl` with the `whilelt + splice` instructions, which\noffer lower latency and higher throughput.\n2. Eliminates unnecessary compress operations for partial subword type cases.\n3. For `sve_compress_byte`, one less temporary register is used to alleviate\npotential register pressure.\n\nBenchmark results demonstrate that these changes significantly improve performance.\n\nBenchmarks on Nvidia Grace machine with 128-bit SVE:\n```\nBenchmark\t        Unit\tBefore\t Error\tAfter\t Error\tUplift\nByte128Vector.compress\tops\/ms\t4846.97\t 26.23\t6638.56\t 31.60\t1.36\nByte64Vector.compress\tops\/ms\t2447.69\t 12.95\t7167.68\t 34.49\t2.92\nShort128Vector.compress\tops\/ms\t7174.88\t 40.94\t8398.45\t 9.48\t1.17\nShort64Vector.compress\tops\/ms\t3618.72\t 3.04\t8618.22\t 10.91\t2.38\n```\n\nThis PR was tested on 128-bit, 256-bit, and 512-bit SVE environments,\nand all tests passed."},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad"},{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4"},{"filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp"},{"filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py"},{"filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h"},{"filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCompressTest.java"}],"sha":"ed7d6fc8d4c72b00ef22e9b00cd0beeabdc8dd54"}]