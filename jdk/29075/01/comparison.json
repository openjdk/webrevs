{"files":[{"patch":"@@ -2861,1 +2861,1 @@\n-    public boolean overridesObjectMethod(TypeSymbol origin, Symbol msym) {\n+    public Symbol overriddenObjectMethod(TypeSymbol origin, Symbol msym) {\n@@ -2864,1 +2864,1 @@\n-                return true;\n+                return sym;\n@@ -2867,1 +2867,5 @@\n-        return false;\n+        return null;\n+    }\n+\n+    public boolean overridesObjectMethod(TypeSymbol origin, Symbol msym) {\n+        return overriddenObjectMethod(origin, msym) != null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -705,7 +705,8 @@\n-        Symbol baseMethod = refSym.baseSymbol();\n-        Symbol origMethod = baseMethod.baseSymbol();\n-        if (baseMethod != origMethod && origMethod.owner == syms.objectType.tsym) {\n-            \/\/the implementation method is a java.lang.Object method transferred to an\n-            \/\/interface that does not declare it. Runtime will refer to this method as to\n-            \/\/a java.lang.Object method, so do the same:\n-            refSym = ((MethodSymbol) origMethod).asHandle();\n+        if (refSym.enclClass().isInterface()) {\n+            Symbol baseMethod = types.overriddenObjectMethod(refSym.enclClass(), refSym);\n+            if (baseMethod != null) {\n+                \/\/ The implementation method is a java.lang.Object method, runtime will resolve this method to\n+                \/\/ a java.lang.Object method, so do the same.\n+                \/\/ This case can be removed if JDK-8172817 is fixed.\n+                refSym = ((MethodSymbol) baseMethod).asHandle();\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2026, Google LLC and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary test lambda deserialization for Object method references on interfaces\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jdeps\/com.sun.tools.javap\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main SerializableObjectMethodReferencesOnInterfaces\n+ *\/\n+\n+import java.io.Serializable;\n+import java.lang.classfile.*;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.instruction.ConstantInstruction;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.net.URL;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Iterator;\n+\n+public class SerializableObjectMethodReferencesOnInterfaces {\n+\n+    public static void main(String... args) throws Exception {\n+        new SerializableObjectMethodReferencesOnInterfaces().run();\n+    }\n+\n+    static class Test {\n+        interface I1 extends Serializable {}\n+\n+        interface I2 extends I1 {\n+            @Override\n+            public int hashCode();\n+        }\n+\n+        interface F<T, R> extends Serializable {\n+            R apply(T t);\n+        }\n+\n+        enum E {\n+            ONE\n+        }\n+\n+        void f() throws Exception {\n+            F<I1, Integer> f1 = I1::hashCode;\n+            F<I2, Integer> f2 = I2::hashCode;\n+            F<E, Integer> f3 = E::hashCode;\n+            F<Object, Integer> f4 = Object::hashCode;\n+        }\n+    }\n+\n+    public void run() throws Exception {\n+        URL url =\n+                SerializableObjectMethodReferencesOnInterfaces.class.getResource(\n+                        \"SerializableObjectMethodReferencesOnInterfaces$Test.class\");\n+        Path file = Paths.get(url.toURI());\n+\n+        ClassModel cf = ClassFile.of().parse(file);\n+        String actual = printDeserializationTests(cf);\n+        String expected =\n+                \"\"\"\n+                getImplMethodKind 5\n+                getFunctionalInterfaceClass SerializableObjectMethodReferencesOnInterfaces$Test$F\n+                getFunctionalInterfaceMethodName apply\n+                getFunctionalInterfaceMethodSignature (Ljava\/lang\/Object;)Ljava\/lang\/Object;\n+                getImplClass java\/lang\/Object\n+                getImplMethodSignature ()I\n+                getImplMethodKind 5\n+                getFunctionalInterfaceClass SerializableObjectMethodReferencesOnInterfaces$Test$F\n+                getFunctionalInterfaceMethodName apply\n+                getFunctionalInterfaceMethodSignature (Ljava\/lang\/Object;)Ljava\/lang\/Object;\n+                getImplClass java\/lang\/Object\n+                getImplMethodSignature ()I\n+                getImplMethodKind 5\n+                getFunctionalInterfaceClass SerializableObjectMethodReferencesOnInterfaces$Test$F\n+                getFunctionalInterfaceMethodName apply\n+                getFunctionalInterfaceMethodSignature (Ljava\/lang\/Object;)Ljava\/lang\/Object;\n+                getImplClass java\/lang\/Enum\n+                getImplMethodSignature ()I\n+                getImplMethodKind 5\n+                getFunctionalInterfaceClass SerializableObjectMethodReferencesOnInterfaces$Test$F\n+                getFunctionalInterfaceMethodName apply\n+                getFunctionalInterfaceMethodSignature (Ljava\/lang\/Object;)Ljava\/lang\/Object;\n+                getImplClass java\/lang\/Object\n+                getImplMethodSignature ()I\n+                \"\"\";\n+        if (!actual.equals(expected)) {\n+            throw new AssertionError(\n+                    \"Unexpected deserialization tests, expected:\\n\"\n+                            + expected\n+                            + \"\\nactual:\\n\"\n+                            + actual);\n+        }\n+    }\n+\n+    private static String printDeserializationTests(ClassModel cf) {\n+        MethodModel m =\n+                cf.methods().stream()\n+                        .filter(\n+                                x ->\n+                                        x.methodName()\n+                                                .stringValue()\n+                                                .contentEquals(\"$deserializeLambda$\"))\n+                        .findFirst()\n+                        .get();\n+        Iterator<CodeElement> it = m.code().get().iterator();\n+        StringBuilder sb = new StringBuilder();\n+        while (it.hasNext()) {\n+            CodeElement curr = it.next();\n+            if (curr instanceof InvokeInstruction i\n+                    && i.method()\n+                            .owner()\n+                            .asInternalName()\n+                            .contentEquals(\"java\/lang\/invoke\/SerializedLambda\")) {\n+                CodeElement next = it.next();\n+                if (next instanceof ConstantInstruction c) {\n+                    sb.append(\n+                            i.method().name().stringValue()\n+                                    + \" \"\n+                                    + c.constantValue().toString()\n+                                    + \"\\n\");\n+                }\n+            }\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/SerializableObjectMethodReferencesOnInterfaces.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"}]}