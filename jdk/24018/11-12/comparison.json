{"files":[{"patch":"@@ -248,1 +248,1 @@\n-  ArenaStatCounter(const CompileTask* task, size_t limit);\n+  ArenaStatCounter(CompileTask* task, size_t limit);\n","filename":"src\/hotspot\/share\/compiler\/compilationMemStatInternals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-ArenaStatCounter::ArenaStatCounter(const CompileTask* task, size_t limit) :\n+ArenaStatCounter::ArenaStatCounter(CompileTask* task, size_t limit) :\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n@@ -150,0 +151,7 @@\n+bool CompileTask::is_safe() {\n+  return _method_handle.is_safe() && _hot_method_handle.is_safe();\n+}\n+\n+\/\/ ------------------------------------------------------------------\n+\/\/ RedefineClasses support\n+\n@@ -151,3 +159,0 @@\n-  if (!is_safe()) {\n-    return;\n-  }\n@@ -155,3 +160,7 @@\n-  _method_handle.method()->set_on_stack(true);\n-  if (_hot_method_handle.method() != nullptr) {\n-    _hot_method_handle.method()->set_on_stack(true);\n+  \/\/ Redefinition runs in VM thread, which cannot ask about the method\n+  \/\/ safety. This is why we end up asking for method unsafely.\n+  assert_at_safepoint();\n+  assert(Thread::current()->is_VM_thread(), \"Sanity\");\n+  _method_handle.method_unsafe()->set_on_stack(true);\n+  if (_hot_method_handle.method_unsafe() != nullptr) {\n+    _hot_method_handle.method_unsafe()->set_on_stack(true);\n@@ -161,5 +170,0 @@\n-bool CompileTask::is_safe() const {\n-  return _method_handle.is_safe() && _hot_method_handle.is_safe();\n-}\n-\n-\/\/ RedefineClasses support\n@@ -167,6 +171,7 @@\n-  if (!is_safe()) {\n-    return;\n-  }\n-  f->do_metadata(method());\n-  if (hot_method() != nullptr && hot_method() != method()) {\n-    f->do_metadata(hot_method());\n+  \/\/ Redefinition runs in VM thread, which cannot ask about the method\n+  \/\/ safety. This is why we end up asking for method unsafely.\n+  assert_at_safepoint();\n+  assert(Thread::current()->is_VM_thread(), \"Sanity\");\n+  f->do_metadata(_method_handle.method_unsafe());\n+  if (_hot_method_handle.method_unsafe() != nullptr) {\n+    f->do_metadata(_hot_method_handle.method_unsafe());\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -130,2 +130,2 @@\n-  inline Method* method() const;\n-  inline Method* hot_method() const;\n+  inline Method* method();\n+  inline Method* hot_method();\n@@ -216,1 +216,1 @@\n-  bool         is_safe() const;\n+  bool         is_safe();\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-inline Method* CompileTask::method() const {\n+inline Method* CompileTask::method() {\n@@ -36,1 +36,1 @@\n-inline Method* CompileTask::hot_method() const {\n+inline Method* CompileTask::hot_method() {\n","filename":"src\/hotspot\/share\/compiler\/compileTask.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,0 +88,17 @@\n+  DEBUG_ONLY(volatile Thread* _spin_lock_owner;)\n+\n+  class Lock : StackObj {\n+  private:\n+    UnloadableMethodHandle* const _handle;\n+\n+  public:\n+    Lock(UnloadableMethodHandle* handle) : _handle(handle) {\n+      assert(_handle->_spin_lock_owner != Thread::current(), \"Re-entering already owned lock, about to deadlock\");\n+      Thread::SpinAcquire(&_handle->_spin_lock);\n+      DEBUG_ONLY(_handle->_spin_lock_owner = Thread::current();)\n+    }\n+    ~Lock() {\n+      DEBUG_ONLY(_handle->_spin_lock_owner = nullptr;)\n+      Thread::SpinRelease(&_handle->_spin_lock);\n+    }\n+  };\n@@ -102,1 +119,2 @@\n-  inline Method* method() const;\n+  inline Method* method();\n+  inline Method* method_unsafe();\n@@ -104,1 +122,1 @@\n-  inline bool is_safe() const;\n+  inline bool is_safe();\n","filename":"src\/hotspot\/share\/oops\/unloadableMethodHandle.hpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -35,1 +36,2 @@\n-inline UnloadableMethodHandle::UnloadableMethodHandle() : _spin_lock(0), _method(nullptr) {\n+inline UnloadableMethodHandle::UnloadableMethodHandle() :\n+  _spin_lock(0), _spin_lock_owner(nullptr), _method(nullptr) {\n@@ -39,1 +41,2 @@\n-inline UnloadableMethodHandle::UnloadableMethodHandle(Method* method) : _spin_lock(0), _method(method) {\n+inline UnloadableMethodHandle::UnloadableMethodHandle(Method* method) :\n+  _spin_lock(0), _spin_lock_owner(nullptr), _method(method) {\n@@ -41,0 +44,1 @@\n+\n@@ -82,5 +86,1 @@\n-    case STRONG:\n-    case WEAK: {\n-      _strong_handle.release(Universe::vm_global());\n-      _weak_handle.release(Universe::vm_weak());\n-      _method = nullptr;\n+    case EMPTY: {\n@@ -90,2 +90,11 @@\n-    case EMPTY: {\n-      set_state(RELEASED);\n+    case STRONG:\n+    case WEAK: {\n+      \/\/ Release only once.\n+      \/\/ This also coordinates with is_safe check.\n+      Lock lock(this);\n+      if (get_state() == STRONG || get_state() == WEAK) {\n+        _strong_handle.release(Universe::vm_global());\n+        _weak_handle.release(Universe::vm_weak());\n+        _method = nullptr;\n+        set_state(RELEASED);\n+      }\n@@ -101,1 +110,1 @@\n-bool UnloadableMethodHandle::is_safe() const {\n+bool UnloadableMethodHandle::is_safe() {\n@@ -113,2 +122,1 @@\n-      \/\/ Safe only if weak handle was not cleared by GC.\n-      \/\/ This is only trustworthy if caller is a Java thread in proper state.\n+      \/\/ Safety 1: Caller should be a Java thread in proper state.\n@@ -118,4 +126,4 @@\n-      if (t->is_Java_thread() &&\n-          (JavaThread::cast(t)->thread_state() != _thread_in_native) &&\n-          (_weak_handle.peek() != nullptr)) {\n-        return true;\n+      if (!t->is_Java_thread() || JavaThread::cast(t)->thread_state() == _thread_in_native) {\n+        \/\/ Unable to figure out safety, give a pessimistic answer.\n+        assert(false, \"Cannot figure out safety, check the thread lifecycle, or use method_unsafe()\");\n+        return false;\n@@ -123,1 +131,11 @@\n-      return false;\n+\n+      \/\/ Safety 2: Need to take a lock to coordinate with concurrent\n+      \/\/ release that would change the weak handle state.\n+      Lock lock(this);\n+      if (get_state() != WEAK) {\n+        \/\/ State changed. Circle back to act accordingly.\n+        return is_safe();\n+      }\n+\n+      \/\/ Finally, see if the handle was cleared by GC.\n+      return _weak_handle.peek() != nullptr;\n@@ -136,4 +154,1 @@\n-    case STRONG: {\n-      \/\/ Already safe.\n-      break;\n-    }\n+    case STRONG:\n@@ -141,1 +156,1 @@\n-      assert(false, \"Cannot be RELEASED: check lifecycle\");\n+      \/\/ No action is needed.\n@@ -145,4 +160,3 @@\n-      \/\/ Need to capture holder strongly. Under concurrent calls, we need to make\n-      \/\/ sure we create the strong handle only once, otherwise we can leak some.\n-      \/\/ This path is normally uncontended, so a simple spin lock would do.\n-      Thread::SpinAcquire(&_spin_lock);\n+      \/\/ Transition WEAK -> STRONG only once.\n+      \/\/ Otherwise, this leaks strong handles.\n+      Lock lock(this);\n@@ -154,2 +168,0 @@\n-      } else {\n-        assert(get_state() == STRONG, \"Should be otherwise\");\n@@ -157,1 +169,0 @@\n-      Thread::SpinRelease(&_spin_lock);\n@@ -167,1 +178,1 @@\n-inline Method* UnloadableMethodHandle::method() const {\n+inline Method* UnloadableMethodHandle::method() {\n@@ -172,0 +183,4 @@\n+inline Method* UnloadableMethodHandle::method_unsafe() {\n+  return _method;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/unloadableMethodHandle.inline.hpp","additions":45,"deletions":30,"binary":false,"changes":75,"status":"modified"}]}