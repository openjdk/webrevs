{"files":[{"patch":"@@ -48,2 +48,2 @@\n-                         bool is_blocking) {\n-  Thread* thread = Thread::current();\n+                         bool is_blocking) :\n+  _method_handle(method()) {\n@@ -51,1 +51,0 @@\n-  _method_handle = UnloadableMethodHandle(method());\n@@ -84,1 +83,0 @@\n-  _method_handle.release();\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,4 +37,2 @@\n-\/\/ This handle can be in 4 states:\n-\/\/  1. Empty. There is no Method* inside. All methods are safe to call.\n-\/\/     This is a convenience state to allow easy initializations.\n-\/\/  2. Weak. Method* is present, but its holder is only weakly-reachable, and can\n+\/\/ This handle can be in 2 states:\n+\/\/  1. Unsafe (weak). Method* is present, but its holder is only weakly-reachable, and can\n@@ -45,1 +43,1 @@\n-\/\/  3. Strong. Method* holder is strongly reachable, cannot be unloaded.\n+\/\/  2. Safe (strong). Method* holder is strongly reachable, cannot be unloaded.\n@@ -47,2 +45,0 @@\n-\/\/  4. Released. Method* is in unknown state, and cannot be accessed.\n-\/\/     method() is unsafe to call in this state.\n@@ -51,3 +47,1 @@\n-\/\/    weak   --(make_always_safe) --> strong\n-\/\/    weak   ------(release) -------> released\n-\/\/    strong ------(release) -------> released\n+\/\/    unsafe (weak) --(make_always_safe) --> safe (strong)\n@@ -55,3 +49,4 @@\n-\/\/ Additionally, when handle is empty, it stays empty:\n-\/\/    empty  --(make_always_safe) --> empty\n-\/\/    empty  ------(release) -------> empty\n+\/\/ There are internal shortcuts that bypass this mechanics when handle knows\n+\/\/ the method holder is permanent and would not be unloaded. This is an implementation\n+\/\/ detail, it does not change any external contract. Using this handle for permanent\n+\/\/ method holders provides future safety.\n@@ -61,2 +56,1 @@\n-\/\/   UnloadableMethodHandle mh;           \/\/ Initially empty.\n-\/\/   mh = UnloadableMethodHandle(method); \/\/ Now in weak state.\n+\/\/   UnloadableMethodHandle mh(method);   \/\/ Now in unsafe (weak) state.\n@@ -66,2 +60,1 @@\n-\/\/     mh.release();                      \/\/ No! Release the handle and exit.\n-\/\/     return;\n+\/\/     return;                            \/\/ Nope!\n@@ -70,1 +63,1 @@\n-\/\/   mh.make_always_safe();               \/\/ Now in safe state.\n+\/\/   mh.make_always_safe();               \/\/ Now in safe (strong) state.\n@@ -73,1 +66,0 @@\n-\/\/   mh.release();                        \/\/ Release the handle.\n@@ -81,2 +73,1 @@\n-  enum State {\n-    EMPTY,\n+  enum class State {\n@@ -87,16 +78,0 @@\n-  } volatile _state;\n-\n-  \/\/ There are lots of writes to this field in common (WEAK) state.\n-  \/\/ Protect the adjacent fields from false sharing to optimize state queries.\n-  DEFINE_PAD_MINUS_SIZE(0, DEFAULT_PADDING_SIZE, 0);\n-  mutable volatile int _spin_lock;\n-  DEBUG_ONLY(mutable volatile Thread* _spin_lock_owner;)\n-  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_PADDING_SIZE, 0);\n-\n-  class SpinLocker : StackObj {\n-  private:\n-    const UnloadableMethodHandle* const _handle;\n-\n-  public:\n-    SpinLocker(const UnloadableMethodHandle* handle);\n-    ~SpinLocker();\n@@ -105,0 +80,2 @@\n+  State volatile _state;\n+\n@@ -110,1 +87,2 @@\n-  inline void set_state(State s);\n+  inline void set_state(State to);\n+  inline bool transit_state(State from, State to);\n@@ -114,1 +92,0 @@\n-  UnloadableMethodHandle();\n@@ -116,1 +93,1 @@\n-  inline void release();\n+  ~UnloadableMethodHandle();\n","filename":"src\/hotspot\/share\/oops\/unloadableMethodHandle.hpp","additions":17,"deletions":40,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -36,5 +36,0 @@\n-inline UnloadableMethodHandle::UnloadableMethodHandle() :\n-  _spin_lock(0) DEBUG_ONLY(COMMA _spin_lock_owner(nullptr)), _method(nullptr) {\n-  set_state(EMPTY);\n-}\n-\n@@ -42,1 +37,1 @@\n-  _spin_lock(0) DEBUG_ONLY(COMMA _spin_lock_owner(nullptr)), _method(method) {\n+  _method(method) {\n@@ -48,1 +43,1 @@\n-    set_state(WEAK);\n+    set_state(State::WEAK);\n@@ -50,1 +45,1 @@\n-    set_state(PERMANENT);\n+    set_state(State::PERMANENT);\n@@ -52,0 +47,1 @@\n+\n@@ -55,0 +51,26 @@\n+inline UnloadableMethodHandle::~UnloadableMethodHandle() {\n+  switch (get_state()) {\n+    case State::STRONG: {\n+      _strong_handle.release(Universe::vm_global());\n+    }\n+    case State::WEAK: {\n+      _weak_handle.release(Universe::vm_weak());\n+    }\n+    case State::PERMANENT: {\n+      _method = nullptr;\n+      set_state(State::RELEASED);\n+    }\n+    case State::RELEASED: {\n+      \/\/ Nothing to do.\n+      break;\n+    }\n+    default:\n+      assert(false, \"Should not be here\");\n+  }\n+\n+  assert(_method == nullptr, \"Should be\");\n+  assert(_weak_handle.is_empty(), \"Should be\");\n+  assert(_strong_handle.is_empty(), \"Should be\");\n+  assert(!is_safe(), \"Should not be\");\n+}\n+\n@@ -59,2 +81,6 @@\n-inline void UnloadableMethodHandle::set_state(State s) {\n-  Atomic::release_store_fence(&_state, s);\n+inline void UnloadableMethodHandle::set_state(State to) {\n+  Atomic::release_store(&_state, to);\n+}\n+\n+inline bool UnloadableMethodHandle::transit_state(State from, State to) {\n+  return Atomic::cmpxchg(&_state, from, to, memory_order_release) == from;\n@@ -80,37 +106,0 @@\n-void UnloadableMethodHandle::release() {\n-  switch (get_state()) {\n-    case RELEASED: {\n-      \/\/ Nothing to do.\n-      break;\n-    }\n-    case EMPTY: {\n-      set_state(RELEASED);\n-      break;\n-    }\n-    case PERMANENT: {\n-      _method = nullptr;\n-      set_state(RELEASED);\n-      break;\n-    }\n-    case STRONG:\n-    case WEAK: {\n-      \/\/ Release handles only once.\n-      SpinLocker locker(this);\n-      if (get_state() != RELEASED) {\n-        _weak_handle.release(Universe::vm_weak());\n-        _strong_handle.release(Universe::vm_global());\n-        _method = nullptr;\n-        set_state(RELEASED);\n-      }\n-      break;\n-    }\n-    default:\n-      ShouldNotReachHere();\n-  }\n-\n-  assert(_method == nullptr, \"Should be\");\n-  assert(_weak_handle.is_empty(), \"Should be\");\n-  assert(_strong_handle.is_empty(), \"Should be\");\n-  assert(!is_safe(), \"Should not be\");\n-}\n-\n@@ -119,3 +108,2 @@\n-    case EMPTY:\n-    case PERMANENT:\n-    case STRONG: {\n+    case State::PERMANENT:\n+    case State::STRONG: {\n@@ -125,1 +113,1 @@\n-    case RELEASED: {\n+    case State::RELEASED: {\n@@ -129,2 +117,2 @@\n-    case WEAK: {\n-      \/\/ Safety 1: Caller should be a Java thread in proper state.\n+    case State::WEAK: {\n+      \/\/ Safety: Caller should be a Java thread in proper state.\n@@ -140,8 +128,0 @@\n-      \/\/ Safety 2: Need to take a lock to coordinate with weak handle\n-      \/\/ modifications at release or make_always_safe.\n-      SpinLocker locker(this);\n-      if (get_state() != WEAK) {\n-        \/\/ State changed. Circle back to act accordingly.\n-        return is_safe();\n-      }\n-\n@@ -152,1 +132,1 @@\n-      ShouldNotReachHere();\n+      assert(false, \"Should not be here\");\n@@ -161,4 +141,3 @@\n-    case EMPTY:\n-    case PERMANENT:\n-    case STRONG:\n-    case RELEASED: {\n+    case State::PERMANENT:\n+    case State::STRONG:\n+    case State::RELEASED: {\n@@ -168,4 +147,3 @@\n-    case WEAK: {\n-      \/\/ Transition WEAK -> STRONG only once.\n-      SpinLocker locker(this);\n-      if (get_state() == WEAK) {\n+    case State::WEAK: {\n+      if (transit_state(State::WEAK, State::STRONG)) {\n+        \/\/ Do this only once, otherwise it leaks handles.\n@@ -175,1 +153,0 @@\n-        set_state(STRONG);\n@@ -180,1 +157,1 @@\n-      ShouldNotReachHere();\n+      assert(false, \"Should not be here\");\n@@ -195,11 +172,0 @@\n-inline UnloadableMethodHandle::SpinLocker::SpinLocker(const UnloadableMethodHandle* handle) : _handle(handle) {\n-  assert(_handle->_spin_lock_owner != Thread::current(), \"Re-entering already owned lock, about to deadlock\");\n-  Thread::SpinAcquire(&_handle->_spin_lock);\n-  DEBUG_ONLY(_handle->_spin_lock_owner = Thread::current();)\n-}\n-\n-inline UnloadableMethodHandle::SpinLocker::~SpinLocker() {\n-  DEBUG_ONLY(_handle->_spin_lock_owner = nullptr;)\n-  Thread::SpinRelease(&_handle->_spin_lock);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/unloadableMethodHandle.inline.hpp","additions":49,"deletions":83,"binary":false,"changes":132,"status":"modified"}]}