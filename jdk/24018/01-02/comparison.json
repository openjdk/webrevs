{"files":[{"patch":"@@ -47,1 +47,1 @@\n-#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compileTask.inline.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compileTask.inline.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"compiler\/compileTask.inline.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"compiler\/compileTask.inline.hpp\"\n@@ -1697,1 +1698,0 @@\n-  methodHandle method(thread, task->method());\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compileTask.inline.hpp\"\n@@ -37,1 +37,0 @@\n-#include \"runtime\/methodUnloadBlocker.inline.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"runtime\/unloadableMethodHandle.inline.hpp\"\n@@ -70,2 +70,2 @@\n-    task->_method_unload_blocker.release();\n-    task->_hot_method_unload_blocker.release();\n+    task->_method_handle.release();\n+    task->_hot_method_handle.release();\n@@ -95,2 +95,1 @@\n-  _method = method();\n-  _method_unload_blocker = MethodUnloadBlocker(_method);\n+  _method_handle = UnloadableMethodHandle(method());\n@@ -109,1 +108,0 @@\n-  _hot_method = nullptr;\n@@ -124,8 +122,3 @@\n-    if (hot_method.not_null()) {\n-      if (hot_method == method) {\n-        _hot_method = _method;\n-      } else {\n-        _hot_method = hot_method();\n-        \/\/ Only do capture unload blocker if _hot_method is different from _method.\n-        _hot_method_unload_blocker = MethodUnloadBlocker(_hot_method);\n-      }\n+    if (hot_method.not_null() && hot_method() != method()) {\n+      \/\/ Only do capture unload blocker if _hot_method is different from _method.\n+      _hot_method_handle = UnloadableMethodHandle(hot_method());\n@@ -152,2 +145,2 @@\n-  _method_unload_blocker.block_unloading();\n-  _hot_method_unload_blocker.block_unloading();\n+  _method_handle.block_unloading();\n+  _hot_method_handle.block_unloading();\n@@ -163,3 +156,3 @@\n-  _method->set_on_stack(true);\n-  if (_hot_method != nullptr) {\n-    _hot_method->set_on_stack(true);\n+  _method_handle.method()->set_on_stack(true);\n+  if (_hot_method_handle.method() != nullptr) {\n+    _hot_method_handle.method()->set_on_stack(true);\n@@ -170,1 +163,1 @@\n-  return _method_unload_blocker.is_unloaded();\n+  return _method_handle.is_unloaded();\n@@ -320,2 +313,2 @@\n-  if (_hot_method != nullptr && _hot_method != _method) {\n-    xtty->method(_hot_method);\n+  if (_hot_method_handle.method() != nullptr) {\n+    xtty->method(_hot_method_handle.method());\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":16,"deletions":23,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/methodUnloadBlocker.hpp\"\n+#include \"runtime\/unloadableMethodHandle.hpp\"\n@@ -89,2 +89,1 @@\n-  Method*              _method;\n-  MethodUnloadBlocker  _method_unload_blocker;\n+  UnloadableMethodHandle _method_handle;\n@@ -112,2 +111,1 @@\n-  Method*              _hot_method;   \/\/ which method actually triggered this task\n-  MethodUnloadBlocker  _hot_method_unload_blocker;\n+  UnloadableMethodHandle _hot_method_handle;  \/\/ which method actually triggered this task\n@@ -134,0 +132,3 @@\n+  inline Method* method() const;\n+  inline Method* hot_method() const;\n+\n@@ -135,2 +136,0 @@\n-  Method*      method() const                    { return _method; }\n-  Method*      hot_method() const                { return _hot_method; }\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_COMPILER_COMPILETASK_INLINE_HPP\n+#define SHARE_COMPILER_COMPILETASK_INLINE_HPP\n+\n+#include \"compiler\/compileTask.hpp\"\n+\n+#include \"runtime\/unloadableMethodHandle.inline.hpp\"\n+\n+inline Method* CompileTask::method() const {\n+  return _method_handle.method();\n+}\n+\n+inline Method* CompileTask::hot_method() const {\n+  return _hot_method_handle.method();\n+}\n+\n+#endif \/\/ SHARE_COMPILER_COMPILETASK_INLINE_HPP\n","filename":"src\/hotspot\/share\/compiler\/compileTask.inline.hpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compileTask.inline.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_RUNTIME_METHOD_UNLOAD_BLOCKER_HANDLE_HPP\n-#define SHARE_RUNTIME_METHOD_UNLOAD_BLOCKER_HANDLE_HPP\n-\n-#include \"oops\/klass.hpp\"\n-#include \"oops\/oopHandle.hpp\"\n-#include \"oops\/weakHandle.hpp\"\n-\n-\/\/ Method unload blocker.\n-\/\/\n-\/\/ Useful when one needs to hold to Method* without delaying class unloading.\n-\/\/ There is normally an associated Method* that is associated with this blocker.\n-\/\/\n-\/\/ This blocker can be in 3 states:\n-\/\/  1. Initial weak state. Relevant Method* is only weakly-reachable, can be cleared\n-\/\/     by class unloading.\n-\/\/  2. Accessible strong state. Relevant Method* is strongly reachable, cannot be\n-\/\/     cleared by class unloading.\n-\/\/  3. Final released state. Relevant Method* is in unknown state, and cannot be\n-\/\/     accessed.\n-\/\/\n-\/\/ Users should call block_unloading() to reach accessible state before accessing\n-\/\/ associated Method*.\n-\/\/\n-class MethodUnloadBlocker {\n-  Method* _method;\n-  WeakHandle _weak_handle;   \/\/ oop that can be used to block unloading\n-  OopHandle  _strong_handle; \/\/ oop that *is* used to block unloading\n-\n-  inline oop get_unload_blocker(Method* method);\n-\n-public:\n-  MethodUnloadBlocker() : _method(nullptr) {}; \/\/ initialization\n-  MethodUnloadBlocker(Method* method);\n-\n-  \/*\n-   * Release the handle.\n-   *\/\n-  inline void release();\n-\n-  \/*\n-   * Check if method holder is unloaded.\n-   *\/\n-  inline bool is_unloaded() const;\n-\n-  \/*\n-   * Return the method. Only safe when !is_unloaded().\n-   *\/\n-  inline Method* method() const;\n-\n-  \/*\n-   * Block unloading, allow method() calls.\n-   *\/\n-  void block_unloading();\n-};\n-\n-#endif \/\/ SHARE_RUNTIME_METHOD_UNLOAD_BLOCKER_HANDLE_HPP\n","filename":"src\/hotspot\/share\/runtime\/methodUnloadBlocker.hpp","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_RUNTIME_METHOD_UNLOAD_BLOCKER_HANDLE_INLINE_HPP\n-#define SHARE_RUNTIME_METHOD_UNLOAD_BLOCKER_HANDLE_INLINE_HPP\n-\n-#include \"runtime\/methodUnloadBlocker.hpp\"\n-\n-#include \"memory\/universe.hpp\"\n-#include \"oops\/klass.inline.hpp\"\n-#include \"oops\/oopHandle.inline.hpp\"\n-#include \"oops\/weakHandle.inline.hpp\"\n-\n-inline MethodUnloadBlocker::MethodUnloadBlocker(Method* method) {\n-  _method = method;\n-  oop obj = get_unload_blocker(method);\n-  if (obj != nullptr) {\n-    _weak_handle = WeakHandle(Universe::vm_weak(), obj);\n-  }\n-}\n-\n-oop MethodUnloadBlocker::get_unload_blocker(Method* method) {\n-  assert(method != nullptr, \"Should be\");\n-  InstanceKlass* ik = method->method_holder();\n-  oop klass_holder = ik->klass_holder();\n-  if (klass_holder != nullptr) {\n-    \/\/ Normal class, return the holder that would block unloading.\n-    \/\/ This would be either classloader oop for non-hidden classes,\n-    \/\/ or Java mirror oop for hidden classes.\n-    return klass_holder;\n-  }\n-\n-  \/\/ Null holder, the relevant class would not be unloaded.\n-  return nullptr;\n-}\n-\n-void MethodUnloadBlocker::release() {\n-  _method = nullptr;\n-  _weak_handle.release(Universe::vm_weak());\n-  _strong_handle.release(Universe::vm_global());\n-}\n-\n-bool MethodUnloadBlocker::is_unloaded() const {\n-  \/\/ Unloaded if weak handle was set, but now had been cleared by GC.\n-  return !_weak_handle.is_empty() && _weak_handle.peek() == nullptr;\n-}\n-\n-inline void MethodUnloadBlocker::block_unloading() {\n-  assert(!is_unloaded(), \"Pre-condition: should not be unloaded\");\n-\n-  if (!_weak_handle.is_empty()) {\n-    assert(_weak_handle.peek() != nullptr, \"Should not be cleared\");\n-    assert(_method->method_holder()->is_loader_alive(), \"Should be alive\");\n-    assert(_strong_handle.is_empty(), \"Should be empty\");\n-    oop obj = get_unload_blocker(_method);\n-    if (obj != nullptr) {\n-      _strong_handle = OopHandle(Universe::vm_global(), obj);\n-    }\n-    \/\/ Release the weak handle right away, so that is_unloaded() does not touch\n-    \/\/ peek() when thread is in the wrong state.\n-    _weak_handle.release(Universe::vm_weak());\n-  }\n-\n-  assert(!is_unloaded(), \"Post-condition: should not be unloaded\");\n-}\n-\n-inline Method* MethodUnloadBlocker::method() const {\n-  assert(!is_unloaded(), \"Should not be unloaded\");\n-  assert(_method != nullptr, \"Should be\");\n-  return _method;\n-}\n-\n-#endif \/\/ SHARE_RUNTIME_METHOD_UNLOAD_BLOCKER_HANDLE_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/methodUnloadBlocker.inline.hpp","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_UNLOADABLE_METHOD_HANDLE_HPP\n+#define SHARE_RUNTIME_UNLOADABLE_METHOD_HANDLE_HPP\n+\n+#include \"oops\/klass.hpp\"\n+#include \"oops\/oopHandle.hpp\"\n+#include \"oops\/weakHandle.hpp\"\n+\n+\/\/ Unloadable method handle.\n+\/\/\n+\/\/ Useful when one needs to hold to Method* without delaying class unloading.\n+\/\/\n+\/\/ This handle can be in 3 states:\n+\/\/  1. Initial weak state. Relevant Method* is only weakly-reachable, can be cleared\n+\/\/     by class unloading.\n+\/\/  2. Accessible strong state. Relevant Method* is strongly reachable, cannot be\n+\/\/     cleared by class unloading.\n+\/\/  3. Final released state. Relevant Method* is in unknown state, and cannot be\n+\/\/     accessed.\n+\/\/\n+\/\/ Users should call block_unloading() to reach accessible state before unwrapping\n+\/\/ method().\n+\/\/\n+class UnloadableMethodHandle {\n+  Method* _method;\n+  WeakHandle _weak_handle;   \/\/ oop that can be used to block unloading\n+  OopHandle  _strong_handle; \/\/ oop that *is* used to block unloading\n+\n+  inline oop get_unload_blocker(Method* method);\n+\n+public:\n+  UnloadableMethodHandle() : _method(nullptr) {}; \/\/ initialization\n+  UnloadableMethodHandle(Method* method);\n+\n+  \/*\n+   * Release the handle.\n+   *\/\n+  inline void release();\n+\n+  \/*\n+   * Check if method holder is unloaded.\n+   *\/\n+  inline bool is_unloaded() const;\n+\n+  \/*\n+   * Return the method. Only safe when !is_unloaded().\n+   *\/\n+  inline Method* method() const;\n+\n+  \/*\n+   * Block unloading, allow method() calls.\n+   *\/\n+  void block_unloading();\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_UNLOADABLE_METHOD_HANDLE_HPP\n","filename":"src\/hotspot\/share\/runtime\/unloadableMethodHandle.hpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_METHOD_UNLOAD_BLOCKER_HANDLE_INLINE_HPP\n+#define SHARE_RUNTIME_METHOD_UNLOAD_BLOCKER_HANDLE_INLINE_HPP\n+\n+#include \"runtime\/unloadableMethodHandle.hpp\"\n+\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"oops\/oopHandle.inline.hpp\"\n+#include \"oops\/weakHandle.inline.hpp\"\n+\n+inline UnloadableMethodHandle::UnloadableMethodHandle(Method* method) {\n+  _method = method;\n+  if (method != nullptr) {\n+    oop obj = get_unload_blocker(method);\n+    if (obj != nullptr) {\n+      _weak_handle = WeakHandle(Universe::vm_weak(), obj);\n+    }\n+  }\n+}\n+\n+oop UnloadableMethodHandle::get_unload_blocker(Method* method) {\n+  assert(method != nullptr, \"Should be\");\n+  InstanceKlass* ik = method->method_holder();\n+  oop klass_holder = ik->klass_holder();\n+  if (klass_holder != nullptr) {\n+    \/\/ Normal class, return the holder that would block unloading.\n+    \/\/ This would be either classloader oop for non-hidden classes,\n+    \/\/ or Java mirror oop for hidden classes.\n+    return klass_holder;\n+  }\n+\n+  \/\/ Null holder, the relevant class would not be unloaded.\n+  return nullptr;\n+}\n+\n+void UnloadableMethodHandle::release() {\n+  if (_method != nullptr) {\n+    _method = nullptr;\n+    _weak_handle.release(Universe::vm_weak());\n+    _strong_handle.release(Universe::vm_global());\n+  }\n+}\n+\n+bool UnloadableMethodHandle::is_unloaded() const {\n+  \/\/ Unloaded if weak handle was set, but now had been cleared by GC.\n+  return !_weak_handle.is_empty() && _weak_handle.peek() == nullptr;\n+}\n+\n+inline void UnloadableMethodHandle::block_unloading() {\n+  assert(!is_unloaded(), \"Pre-condition: should not be unloaded\");\n+\n+  if (!_weak_handle.is_empty()) {\n+    assert(_weak_handle.peek() != nullptr, \"Should not be cleared\");\n+    assert(_method->method_holder()->is_loader_alive(), \"Should be alive\");\n+    assert(_strong_handle.is_empty(), \"Should be empty\");\n+    oop obj = get_unload_blocker(_method);\n+    if (obj != nullptr) {\n+      _strong_handle = OopHandle(Universe::vm_global(), obj);\n+    }\n+    \/\/ Release the weak handle right away, so that is_unloaded() does not touch\n+    \/\/ peek() when thread is in the wrong state.\n+    _weak_handle.release(Universe::vm_weak());\n+  }\n+\n+  assert(!is_unloaded(), \"Post-condition: should not be unloaded\");\n+}\n+\n+inline Method* UnloadableMethodHandle::method() const {\n+  assert(!is_unloaded(), \"Should not be unloaded\");\n+  return _method;\n+}\n+\n+#endif \/\/ SHARE_RUNTIME_METHOD_UNLOAD_BLOCKER_HANDLE_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/unloadableMethodHandle.inline.hpp","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -772,1 +772,0 @@\n-  nonstatic_field(CompileTask,                 _method,                                       Method*)                               \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    methodField = type.getAddressField(\"_method\");\n+    methodField = type.getAddressField(\"_method\"); \/\/ FIXME.\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/compiler\/CompileTask.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}