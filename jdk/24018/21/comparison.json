{"files":[{"patch":"@@ -47,1 +47,1 @@\n-#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compileTask.inline.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compileTask.inline.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compileTask.inline.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"compiler\/compileTask.inline.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"compiler\/compileTask.inline.hpp\"\n@@ -1710,1 +1711,2 @@\n-  methodHandle method(thread, task->method());\n+  methodHandle method(thread, task->is_unloaded() ? nullptr : task->method());\n+\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compileTask.inline.hpp\"\n@@ -35,0 +35,1 @@\n+#include \"oops\/unloadableMethodHandle.inline.hpp\"\n@@ -50,2 +51,1 @@\n-  _method = method();\n-  _method_holder = JNIHandles::make_weak_global(Handle(thread, method->method_holder()->klass_holder()));\n+  _method_handle = UnloadableMethodHandle(method());\n@@ -84,5 +84,1 @@\n-  if (_method_holder != nullptr && JNIHandles::is_weak_global_handle(_method_holder)) {\n-    JNIHandles::destroy_weak_global(_method_holder);\n-  } else {\n-    JNIHandles::destroy_global(_method_holder);\n-  }\n+  _method_handle.release();\n@@ -115,1 +111,0 @@\n-\/\/ Replace weak handles by strong handles to avoid unloading during compilation.\n@@ -117,3 +112,3 @@\n-  if (is_unloaded()) {\n-    \/\/ Guard against concurrent class unloading\n-    return nullptr;\n+  if (_method_handle.is_safe()) {\n+    _method_handle.make_always_safe();\n+    return this;\n@@ -121,14 +116,1 @@\n-  Thread* thread = Thread::current();\n-  assert(_method->method_holder()->is_loader_alive(), \"should be alive\");\n-  Handle method_holder(thread, _method->method_holder()->klass_holder());\n-  JNIHandles::destroy_weak_global(_method_holder);\n-  _method_holder = JNIHandles::make_global(method_holder);\n-  return this;\n-}\n-\n-void CompileTask::mark_on_stack() {\n-  if (is_unloaded()) {\n-    return;\n-  }\n-  \/\/ Mark these methods as something redefine classes cannot remove.\n-  _method->set_on_stack(true);\n+  return nullptr;\n@@ -138,1 +120,1 @@\n-  return _method_holder != nullptr && JNIHandles::is_weak_global_handle(_method_holder) && JNIHandles::is_weak_global_cleared(_method_holder);\n+  return !_method_handle.is_safe();\n@@ -141,0 +123,1 @@\n+\/\/ ------------------------------------------------------------------\n@@ -142,0 +125,10 @@\n+\n+void CompileTask::mark_on_stack() {\n+  \/\/ Mark these methods as something redefine classes cannot remove.\n+  \/\/ Redefinition runs in VM thread, which cannot ask about the method\n+  \/\/ safety. This is why we end up asking for method unsafely.\n+  assert_at_safepoint();\n+  assert(Thread::current()->is_VM_thread(), \"Sanity\");\n+  _method_handle.method_unsafe()->set_on_stack(true);\n+}\n+\n@@ -143,4 +136,5 @@\n-  if (is_unloaded()) {\n-    return;\n-  }\n-  f->do_metadata(method());\n+  \/\/ Redefinition runs in VM thread, which cannot ask about the method\n+  \/\/ safety. This is why we end up asking for method unsafely.\n+  assert_at_safepoint();\n+  assert(Thread::current()->is_VM_thread(), \"Sanity\");\n+  f->do_metadata(_method_handle.method_unsafe());\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":25,"deletions":31,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/unloadableMethodHandle.hpp\"\n@@ -87,2 +88,1 @@\n-  Method*              _method;\n-  jobject              _method_holder;\n+  UnloadableMethodHandle _method_handle;\n@@ -123,0 +123,2 @@\n+  inline Method* method() const;\n+\n@@ -124,1 +126,0 @@\n-  Method*      method() const                    { return _method; }\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_COMPILER_COMPILETASK_INLINE_HPP\n+#define SHARE_COMPILER_COMPILETASK_INLINE_HPP\n+\n+#include \"compiler\/compileTask.hpp\"\n+\n+#include \"oops\/unloadableMethodHandle.inline.hpp\"\n+\n+inline Method* CompileTask::method() const {\n+  return _method_handle.method();\n+}\n+\n+#endif \/\/ SHARE_COMPILER_COMPILETASK_INLINE_HPP\n","filename":"src\/hotspot\/share\/compiler\/compileTask.inline.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compileTask.inline.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compileTask.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/trainingData.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_UNLOADABLE_METHOD_HANDLE_HPP\n+#define SHARE_OOPS_UNLOADABLE_METHOD_HANDLE_HPP\n+\n+#include \"memory\/padded.hpp\"\n+#include \"oops\/oopHandle.hpp\"\n+#include \"oops\/weakHandle.hpp\"\n+\n+\/\/ Unloadable method handle.\n+\/\/\n+\/\/ This handle allows holding to Method* safely without delaying class unloading\n+\/\/ of its holder.\n+\/\/\n+\/\/ This handle can be in 4 states:\n+\/\/  1. Empty. There is no Method* inside. All methods are safe to call.\n+\/\/     This is a convenience state to allow easy initializations.\n+\/\/  2. Weak. Method* is present, but its holder is only weakly-reachable, and can\n+\/\/     be unloaded. Users need to check is_safe() before calling method().\n+\/\/     method() is safe to call iff we have not crossed a safepoint since construction\n+\/\/     or last is_safe() check. Calling make_always_safe() after is_safe() check\n+\/\/     moves handle to the strong state.\n+\/\/  3. Strong. Method* holder is strongly reachable, cannot be unloaded.\n+\/\/     Calling method() is always safe in this state.\n+\/\/  4. Released. Method* is in unknown state, and cannot be accessed.\n+\/\/     method() is unsafe to call in this state.\n+\/\/\n+\/\/ The handle transitions are one-shot:\n+\/\/    weak   --(make_always_safe) --> strong\n+\/\/    weak   ------(release) -------> released\n+\/\/    strong ------(release) -------> released\n+\/\/\n+\/\/ Additionally, when handle is empty, it stays empty:\n+\/\/    empty  --(make_always_safe) --> empty\n+\/\/    empty  ------(release) -------> empty\n+\/\/\n+\/\/ Common usage pattern:\n+\/\/\n+\/\/   UnloadableMethodHandle mh;           \/\/ Initially empty.\n+\/\/   mh = UnloadableMethodHandle(method); \/\/ Now in weak state.\n+\/\/   mh.method()->print_on(tty);          \/\/ method() is good until the next safepoint.\n+\/\/   <safepoint>\n+\/\/   if (!mh.is_safe()) {                 \/\/ Safe to use method()?\n+\/\/     mh.release();                      \/\/ No! Release the handle and exit.\n+\/\/     return;\n+\/\/   }\n+\/\/   mh.method()->print_on(tty);          \/\/ method() is good until the next safepoint.\n+\/\/   mh.make_always_safe();               \/\/ Now in safe state.\n+\/\/   <safepoint>\n+\/\/   mh.method()->print_on(tty);          \/\/ method() is always safe now.\n+\/\/   mh.release();                        \/\/ Release the handle.\n+\/\/\n+\n+class Method;\n+\n+class UnloadableMethodHandle {\n+  friend class VMStructs;\n+private:\n+  enum State {\n+    EMPTY,\n+    PERMANENT,\n+    WEAK,\n+    STRONG,\n+    RELEASED,\n+  } volatile _state;\n+\n+  \/\/ There are lots of writes to this field in common (WEAK) state.\n+  \/\/ Protect the adjacent fields from false sharing to optimize state queries.\n+  DEFINE_PAD_MINUS_SIZE(0, DEFAULT_PADDING_SIZE, 0);\n+  mutable volatile int _spin_lock;\n+  DEBUG_ONLY(mutable volatile Thread* _spin_lock_owner;)\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_PADDING_SIZE, 0);\n+\n+  class SpinLocker : StackObj {\n+  private:\n+    const UnloadableMethodHandle* const _handle;\n+\n+  public:\n+    SpinLocker(const UnloadableMethodHandle* handle);\n+    ~SpinLocker();\n+  };\n+\n+  Method* _method;\n+  WeakHandle _weak_handle;\n+  OopHandle _strong_handle;\n+\n+  inline State get_state() const;\n+  inline void set_state(State s);\n+  inline oop get_unload_blocker(Method* method);\n+\n+public:\n+  UnloadableMethodHandle();\n+  UnloadableMethodHandle(Method* method);\n+  inline void release();\n+\n+  inline Method* method() const;\n+  inline Method* method_unsafe() const;\n+\n+  inline bool is_safe() const;\n+  void make_always_safe();\n+};\n+\n+#endif \/\/ SHARE_OOPS_UNLOADABLE_METHOD_HANDLE_HPP\n","filename":"src\/hotspot\/share\/oops\/unloadableMethodHandle.hpp","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,206 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_UNLOADABLE_METHOD_HANDLE_INLINE_HPP\n+#define SHARE_OOPS_UNLOADABLE_METHOD_HANDLE_INLINE_HPP\n+\n+#include \"unloadableMethodHandle.hpp\"\n+\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"oops\/oopHandle.inline.hpp\"\n+#include \"oops\/weakHandle.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+\n+inline UnloadableMethodHandle::UnloadableMethodHandle() :\n+  _spin_lock(0) DEBUG_ONLY(COMMA _spin_lock_owner(nullptr)), _method(nullptr) {\n+  set_state(EMPTY);\n+}\n+\n+inline UnloadableMethodHandle::UnloadableMethodHandle(Method* method) :\n+  _spin_lock(0) DEBUG_ONLY(COMMA _spin_lock_owner(nullptr)), _method(method) {\n+  assert(method != nullptr, \"Should be\");\n+\n+  oop obj = get_unload_blocker(method);\n+  if (obj != nullptr) {\n+    _weak_handle = WeakHandle(Universe::vm_weak(), obj);\n+    set_state(WEAK);\n+  } else {\n+    set_state(PERMANENT);\n+  }\n+  assert(is_safe(), \"Should be\");\n+}\n+\n+inline UnloadableMethodHandle::State UnloadableMethodHandle::get_state() const {\n+  return Atomic::load_acquire(&_state);\n+}\n+\n+inline void UnloadableMethodHandle::set_state(State s) {\n+  Atomic::release_store_fence(&_state, s);\n+}\n+\n+oop UnloadableMethodHandle::get_unload_blocker(Method* method) {\n+  assert(method != nullptr, \"Should be\");\n+\n+  InstanceKlass* holder = method->method_holder();\n+  if (holder->class_loader_data()->is_permanent_class_loader_data()) {\n+    \/\/ Method holder class cannot be unloaded.\n+    return nullptr;\n+  }\n+\n+  \/\/ Return the holder that would block unloading.\n+  \/\/ This would be either classloader oop for non-hidden classes,\n+  \/\/ or Java mirror oop for hidden classes.\n+  oop klass_holder = holder->klass_holder();\n+  assert(klass_holder != nullptr, \"Should be\");\n+  return klass_holder;\n+}\n+\n+void UnloadableMethodHandle::release() {\n+  switch (get_state()) {\n+    case RELEASED: {\n+      \/\/ Nothing to do.\n+      break;\n+    }\n+    case EMPTY: {\n+      set_state(RELEASED);\n+      break;\n+    }\n+    case PERMANENT: {\n+      _method = nullptr;\n+      set_state(RELEASED);\n+      break;\n+    }\n+    case STRONG:\n+    case WEAK: {\n+      \/\/ Release handles only once.\n+      SpinLocker locker(this);\n+      if (get_state() != RELEASED) {\n+        _weak_handle.release(Universe::vm_weak());\n+        _strong_handle.release(Universe::vm_global());\n+        _method = nullptr;\n+        set_state(RELEASED);\n+      }\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  assert(_method == nullptr, \"Should be\");\n+  assert(_weak_handle.is_empty(), \"Should be\");\n+  assert(_strong_handle.is_empty(), \"Should be\");\n+  assert(!is_safe(), \"Should not be\");\n+}\n+\n+bool UnloadableMethodHandle::is_safe() const {\n+  switch (get_state()) {\n+    case EMPTY:\n+    case PERMANENT:\n+    case STRONG: {\n+      \/\/ Definitely safe.\n+      return true;\n+    }\n+    case RELEASED: {\n+      \/\/ Definitely unsafe.\n+      return false;\n+    }\n+    case WEAK: {\n+      \/\/ Safety 1: Caller should be a Java thread in proper state.\n+      \/\/ Otherwise, unloading can happen without coordinating with this thread.\n+      \/\/ (Access API would assert this too, but do not rely on it.)\n+      Thread* t = Thread::current();\n+      if (!t->is_Java_thread() || JavaThread::cast(t)->thread_state() == _thread_in_native) {\n+        \/\/ Unable to figure out safety, give a pessimistic answer.\n+        assert(false, \"Cannot figure out safety, check the thread lifecycle, or use method_unsafe()\");\n+        return false;\n+      }\n+\n+      \/\/ Safety 2: Need to take a lock to coordinate with weak handle\n+      \/\/ modifications at release or make_always_safe.\n+      SpinLocker locker(this);\n+      if (get_state() != WEAK) {\n+        \/\/ State changed. Circle back to act accordingly.\n+        return is_safe();\n+      }\n+\n+      \/\/ Finally, see if the handle was cleared by GC.\n+      return _weak_handle.peek() != nullptr;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+      return false;\n+  }\n+}\n+\n+inline void UnloadableMethodHandle::make_always_safe() {\n+  assert(is_safe(), \"Should be\");\n+\n+  switch (get_state()) {\n+    case EMPTY:\n+    case PERMANENT:\n+    case STRONG:\n+    case RELEASED: {\n+      \/\/ No action is needed.\n+      break;\n+    }\n+    case WEAK: {\n+      \/\/ Transition WEAK -> STRONG only once.\n+      SpinLocker locker(this);\n+      if (get_state() == WEAK) {\n+        oop obj = get_unload_blocker(_method);\n+        assert(obj != nullptr, \"Should have one\");\n+        _strong_handle = OopHandle(Universe::vm_global(), obj);\n+        set_state(STRONG);\n+      }\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  assert(is_safe(), \"Should be\");\n+}\n+\n+inline Method* UnloadableMethodHandle::method() const {\n+  assert(is_safe(), \"Should be\");\n+  return _method;\n+}\n+\n+inline Method* UnloadableMethodHandle::method_unsafe() const {\n+  return _method;\n+}\n+\n+inline UnloadableMethodHandle::SpinLocker::SpinLocker(const UnloadableMethodHandle* handle) : _handle(handle) {\n+  assert(_handle->_spin_lock_owner != Thread::current(), \"Re-entering already owned lock, about to deadlock\");\n+  Thread::SpinAcquire(&_handle->_spin_lock);\n+  DEBUG_ONLY(_handle->_spin_lock_owner = Thread::current();)\n+}\n+\n+inline UnloadableMethodHandle::SpinLocker::~SpinLocker() {\n+  DEBUG_ONLY(_handle->_spin_lock_owner = nullptr;)\n+  Thread::SpinRelease(&_handle->_spin_lock);\n+}\n+\n+#endif \/\/ SHARE_OOPS_UNLOADABLE_METHOD_HANDLE_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/unloadableMethodHandle.inline.hpp","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"},{"patch":"@@ -775,1 +775,1 @@\n-  nonstatic_field(CompileTask,                 _method,                                       Method*)                               \\\n+  nonstatic_field(CompileTask,                 _method_handle,                                UnloadableMethodHandle)                \\\n@@ -783,0 +783,2 @@\n+  nonstatic_field(UnloadableMethodHandle,      _method,                                       Method*)                               \\\n+                                                                                                                                     \\\n@@ -1269,0 +1271,1 @@\n+  declare_toplevel_type(UnloadableMethodHandle)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}