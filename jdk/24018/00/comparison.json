{"files":[{"patch":"@@ -69,8 +69,4 @@\n-    if ((task->_method_holder != nullptr && JNIHandles::is_weak_global_handle(task->_method_holder)) ||\n-        (task->_hot_method_holder != nullptr && JNIHandles::is_weak_global_handle(task->_hot_method_holder))) {\n-      JNIHandles::destroy_weak_global(task->_method_holder);\n-      JNIHandles::destroy_weak_global(task->_hot_method_holder);\n-    } else {\n-      JNIHandles::destroy_global(task->_method_holder);\n-      JNIHandles::destroy_global(task->_hot_method_holder);\n-    }\n+    task->_method_unload_blocker_strong.release(Universe::vm_global());\n+    task->_method_unload_blocker_weak.release(Universe::vm_weak());\n+    task->_hot_method_unload_blocker_strong.release(Universe::vm_global());\n+    task->_hot_method_unload_blocker_weak.release(Universe::vm_weak());\n@@ -89,0 +85,31 @@\n+oop CompileTask::get_unload_blocker(Method* method) {\n+  assert(method != nullptr, \"Should be\");\n+  InstanceKlass* ik = method->method_holder();\n+  oop klass_holder = ik->klass_holder();\n+  if (klass_holder != nullptr) {\n+    \/\/ Normal class, return the holder that would block unloading.\n+    \/\/ This would be either classloader oop for non-hidden classes,\n+    \/\/ or Java mirror oop for hidden classes.\n+    return klass_holder;\n+  }\n+\n+  \/\/ Null holder, the relevant class would not be unloaded.\n+  return nullptr;\n+}\n+\n+WeakHandle CompileTask::get_unload_blocker_weak(Method* method) {\n+  oop obj = get_unload_blocker(method);\n+  if (obj != nullptr) {\n+    return WeakHandle(Universe::vm_weak(), obj);\n+  }\n+  return WeakHandle();\n+}\n+\n+OopHandle CompileTask::get_unload_blocker_strong(Method* method) {\n+  oop obj = get_unload_blocker(method);\n+  if (obj != nullptr) {\n+    return OopHandle(Universe::vm_global(), obj);\n+  }\n+  return OopHandle();\n+}\n+\n@@ -99,1 +126,0 @@\n-  Thread* thread = Thread::current();\n@@ -102,1 +128,1 @@\n-  _method_holder = JNIHandles::make_weak_global(Handle(thread, method->method_holder()->klass_holder()));\n+  _method_unload_blocker_weak = get_unload_blocker_weak(_method);\n@@ -116,1 +142,0 @@\n-  _hot_method_holder = nullptr;\n@@ -136,2 +161,2 @@\n-        \/\/ only add loader or mirror if different from _method_holder\n-        _hot_method_holder = JNIHandles::make_weak_global(Handle(thread, hot_method->method_holder()->klass_holder()));\n+        \/\/ Only do capture unload blocker if _hot_method is different from _method.\n+        _hot_method_unload_blocker_weak = get_unload_blocker_weak(_hot_method);\n@@ -152,1 +177,0 @@\n-\/\/ Replace weak handles by strong handles to avoid unloading during compilation.\n@@ -158,8 +182,7 @@\n-  Thread* thread = Thread::current();\n-  assert(_method->method_holder()->is_loader_alive(), \"should be alive\");\n-  Handle method_holder(thread, _method->method_holder()->klass_holder());\n-  JNIHandles::destroy_weak_global(_method_holder);\n-  JNIHandles::destroy_weak_global(_hot_method_holder);\n-  _method_holder = JNIHandles::make_global(method_holder);\n-  if (_hot_method != nullptr) {\n-    _hot_method_holder = JNIHandles::make_global(Handle(thread, _hot_method->method_holder()->klass_holder()));\n+\n+  \/\/ Capture method holder by strong handle to avoid unloading during compilation.\n+  if (!_method_unload_blocker_weak.is_empty()) {\n+    assert(_method_unload_blocker_weak.peek() != nullptr, \"Should not be cleared\");\n+    assert(_method->method_holder()->is_loader_alive(), \"Should be alive\");\n+    assert(_method_unload_blocker_strong.is_empty(), \"Should be empty\");\n+    _method_unload_blocker_strong = get_unload_blocker_strong(_method);\n@@ -167,0 +190,13 @@\n+\n+  \/\/ See if hot method holder is still alive. If so, capture it by strong handle.\n+  \/\/ If not, reset it to nullptr, so downstream logging code does not crash.\n+  if (!_hot_method_unload_blocker_weak.is_empty()) {\n+    if (_hot_method_unload_blocker_weak.peek() != nullptr) {\n+      assert(_hot_method->method_holder()->is_loader_alive(), \"Should be alive\");\n+      assert(_hot_method_unload_blocker_strong.is_empty(), \"Should be empty\");\n+      _hot_method_unload_blocker_strong = get_unload_blocker_strong(_hot_method);\n+    } else {\n+      _hot_method = nullptr;\n+    }\n+  }\n+\n@@ -182,1 +218,2 @@\n-  return _method_holder != nullptr && JNIHandles::is_weak_global_handle(_method_holder) && JNIHandles::is_weak_global_cleared(_method_holder);\n+  \/\/ Unloaded if weakly referenced blocker was set, but now had been cleared by GC.\n+  return !_method_unload_blocker_weak.is_empty() && _method_unload_blocker_weak.peek() == nullptr;\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":60,"deletions":23,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+#include \"oops\/oopHandle.hpp\"\n+#include \"oops\/weakHandle.hpp\"\n@@ -87,1 +89,2 @@\n-  jobject              _method_holder;\n+  WeakHandle           _method_unload_blocker_weak; \/\/ oop that can be used to block unloading method\n+  OopHandle            _method_unload_blocker_strong; \/\/ oop that *is* used to block unloading method\n@@ -110,1 +113,2 @@\n-  jobject              _hot_method_holder;\n+  WeakHandle           _hot_method_unload_blocker_weak; \/\/ oop that can be used to block unloading hot method\n+  OopHandle            _hot_method_unload_blocker_strong; \/\/ oop that *is* used to block unloading hot method\n@@ -226,0 +230,4 @@\n+  static WeakHandle get_unload_blocker_weak(Method* method);\n+  static OopHandle get_unload_blocker_strong(Method* method);\n+  static oop get_unload_blocker(Method* method);\n+\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"}]}