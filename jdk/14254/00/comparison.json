{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -730,1 +730,1 @@\n-     * @param privateKey signer's private ky\n+     * @param privateKey signer's private key\n@@ -753,1 +753,1 @@\n-                signer, sigalg, privateKey, directsign);\n+                signer, sigalg, privateKey, signerChain[0].getPublicKey(), directsign);\n@@ -847,59 +847,0 @@\n-    \/**\n-     * Assembles a PKCS #7 signed data message that optionally includes a\n-     * signature timestamp.\n-     *\n-     * @param signature the signature bytes\n-     * @param signerChain the signer's X.509 certificate chain\n-     * @param content the content that is signed; specify null to not include\n-     *        it in the PKCS7 data\n-     * @param signatureAlgorithm the name of the signature algorithm\n-     * @param tsaURI the URI of the Timestamping Authority; or null if no\n-     *         timestamp is requested\n-     * @param tSAPolicyID the TSAPolicyID of the Timestamping Authority as a\n-     *         numerical object identifier; or null if we leave the TSA server\n-     *         to choose one. This argument is only used when tsaURI is provided\n-     * @return the bytes of the encoded PKCS #7 signed data message\n-     * @throws NoSuchAlgorithmException The exception is thrown if the signature\n-     *         algorithm is unrecognised.\n-     * @throws CertificateException The exception is thrown if an error occurs\n-     *         while processing the signer's certificate or the TSA's\n-     *         certificate.\n-     * @throws IOException The exception is thrown if an error occurs while\n-     *         generating the signature timestamp or while generating the signed\n-     *         data message.\n-     *\/\n-    @Deprecated(since=\"16\", forRemoval=true)\n-    public static byte[] generateSignedData(byte[] signature,\n-                                            X509Certificate[] signerChain,\n-                                            byte[] content,\n-                                            String signatureAlgorithm,\n-                                            URI tsaURI,\n-                                            String tSAPolicyID,\n-                                            String tSADigestAlg)\n-        throws CertificateException, IOException, NoSuchAlgorithmException\n-    {\n-\n-        \/\/ Generate the timestamp token\n-        PKCS9Attributes unauthAttrs = null;\n-        if (tsaURI != null) {\n-            \/\/ Timestamp the signature\n-            HttpTimestamper tsa = new HttpTimestamper(tsaURI);\n-            byte[] tsToken = generateTimestampToken(\n-                    tsa, tSAPolicyID, tSADigestAlg, signature);\n-\n-            \/\/ Insert the timestamp token into the PKCS #7 signer info element\n-            \/\/ (as an unsigned attribute)\n-            unauthAttrs =\n-                new PKCS9Attributes(new PKCS9Attribute[]{\n-                    new PKCS9Attribute(\n-                        PKCS9Attribute.SIGNATURE_TIMESTAMP_TOKEN_OID,\n-                        tsToken)});\n-        }\n-\n-        return constructToken(signature, signerChain, content,\n-                null,\n-                unauthAttrs,\n-                AlgorithmId.get(SignatureUtil.extractDigestAlgFromDwithE(signatureAlgorithm)),\n-                AlgorithmId.get(signatureAlgorithm));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS7.java","additions":3,"deletions":62,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -401,2 +401,1 @@\n-                    digestEncryptionAlgorithmId,\n-                    authenticatedAttributes == null);\n+                    digestEncryptionAlgorithmId);\n@@ -425,0 +424,6 @@\n+            algorithmsConformanceCheck(\n+                    digestAlgorithmId,\n+                    digestEncryptionAlgorithmId,\n+                    key,\n+                    authenticatedAttributes == null);\n+\n@@ -474,13 +479,2 @@\n-     * Derives the signature algorithm name from the digest algorithm\n-     * and the encryption algorithm inside a PKCS7 SignerInfo.\n-     *\n-     * The digest algorithm is in the form \"DIG\", and the encryption\n-     * algorithm can be in any of the 3 forms:\n-     *\n-     * 1. Old style key algorithm like RSA, DSA, EC, this method returns\n-     *    DIGwithKEY.\n-     * 2. New style signature algorithm in the form of HASHwithKEY, this\n-     *    method returns DIGwithKEY. Please note this is not HASHwithKEY.\n-     * 3. Modern signature algorithm like RSASSA-PSS and EdDSA, this method\n-     *    returns the signature algorithm itself but ensures digAlgId is\n-     *    compatible with the algorithm as described in RFC 4056 and 8419.\n+     * Checks if the digest algorithm and encryption algorithm combination\n+     * inside a PKCS7 SignerInfo is legal.\n@@ -490,0 +484,1 @@\n+     * @param key the public key for verification\n@@ -493,1 +488,2 @@\n-    public static String makeSigAlg(AlgorithmId digAlgId, AlgorithmId encAlgId,\n+    public static void algorithmsConformanceCheck(\n+            AlgorithmId digAlgId, AlgorithmId encAlgId, PublicKey key,\n@@ -512,1 +508,1 @@\n-                return encAlg;\n+                break;\n@@ -517,1 +513,1 @@\n-                return encAlg;\n+                break;\n@@ -528,0 +524,35 @@\n+                break;\n+            case \"HSS\/LMS\":\n+                \/\/ RFC 8708 requires the same hash algorithm used as in the HSS\/LMS algorithm\n+                \/\/ Currently RFC 8554 only supports SHA-256.\n+                if (!digAlgId.equals(AlgorithmId.get(KeyUtil.hashAlgFromHSS(key)))) {\n+                    throw new NoSuchAlgorithmException(\"Incompatible digest algorithm\");\n+                }\n+                break;\n+        }\n+    }\n+\n+    \/**\n+     * Derives the signature algorithm name from the digest algorithm\n+     * and the encryption algorithm inside a PKCS7 SignerInfo.\n+     *\n+     * The digest algorithm is in the form \"DIG\", and the encryption\n+     * algorithm can be in any of the 3 forms:\n+     *\n+     * 1. Old style key algorithm like RSA, DSA, EC, this method returns\n+     *    DIGwithKEY.\n+     * 2. New style signature algorithm in the form of HASHwithKEY, this\n+     *    method returns DIGwithKEY. Please note this is not HASHwithKEY.\n+     * 3. Modern signature algorithm like RSASSA-PSS and EdDSA, this method\n+     *    returns the signature algorithm itself.\n+     *\n+     * @param digAlgId the digest algorithm\n+     * @param encAlgId the encryption algorithm\n+     *\/\n+    public static String makeSigAlg(AlgorithmId digAlgId, AlgorithmId encAlgId) {\n+        String encAlg = encAlgId.getName();\n+        switch (encAlg) {\n+            case \"RSASSA-PSS\":\n+            case \"Ed25519\":\n+            case \"Ed448\":\n+            case \"HSS\/LMS\":\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/SignerInfo.java","additions":49,"deletions":18,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -29,4 +30,1 @@\n-import java.security.AlgorithmParameters;\n-import java.security.InvalidKeyException;\n-import java.security.Key;\n-import java.security.SecureRandom;\n+import java.security.*;\n@@ -406,0 +404,27 @@\n+    \/**\n+     * Finds the hash algorithm from an HSS\/LMS public key.\n+     *\n+     * @param publicKey the HSS\/LMS public key\n+     * @return the hash algorithm\n+     * @throws NoSuchAlgorithmException if key is from an unknown configuration\n+     *\/\n+    public static String hashAlgFromHSS(PublicKey publicKey)\n+            throws NoSuchAlgorithmException {\n+        try {\n+            DerValue val = new DerValue(publicKey.getEncoded());\n+            val.data.getDerValue();\n+            byte[] rawKey = new DerValue(val.data.getBitString()).getOctetString();\n+            if (rawKey.length < 8) {\n+                throw new NoSuchAlgorithmException(\"Cannot decode public key\");\n+            }\n+            int num = ((rawKey[4] & 0xff) << 24) + ((rawKey[5] & 0xff) << 16)\n+                    + ((rawKey[6] & 0xff) << 8) + (rawKey[7] & 0xff);\n+            return switch (num) {\n+                \/\/ RFC 8554 only supports SHA_256 hash algorithm\n+                case 5, 6, 7, 8, 9 -> \"SHA-256\";\n+                default -> throw new NoSuchAlgorithmException(\"Unknown LMS type: \" + num);\n+            };\n+        } catch (IOException e) {\n+            throw new NoSuchAlgorithmException(\"Cannot decode public key\", e);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -180,0 +180,5 @@\n+     * Returns \"DSA\" for unknown algorithms. This is safe because the\n+     * signature verification process actually does not require the\n+     * extension matches the key algorithm as long as it's one of\n+     * \"RSA\", \"DSA\", and \"EC\".\n+     *\n@@ -185,10 +190,5 @@\n-        String keyAlgorithm = key.getAlgorithm().toUpperCase(Locale.ENGLISH);\n-        if (keyAlgorithm.equals(\"RSASSA-PSS\")) {\n-            return \"RSA\";\n-        } else if (keyAlgorithm.equals(\"EDDSA\")\n-                || keyAlgorithm.equals(\"ED25519\")\n-                || keyAlgorithm.equals(\"ED448\")) {\n-            return \"EC\";\n-        } else {\n-            return keyAlgorithm;\n-        }\n+        return switch (key.getAlgorithm().toUpperCase(Locale.ENGLISH)) {\n+            case \"RSA\", \"RSASSA-PSS\" -> \"RSA\";\n+            case \"EC\", \"EDDSA\", \"ED25519\", \"ED448\" -> \"EC\";\n+            default -> \"DSA\";\n+        };\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureFileVerifier.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,0 +215,1 @@\n+     * @param publicKey key tells you HSS\/LMS hash algorithm\n@@ -220,1 +221,1 @@\n-            Signature signer, String sigalg, PrivateKey privateKey, boolean directsign)\n+            Signature signer, String sigalg, PrivateKey privateKey, PublicKey publicKey, boolean directsign)\n@@ -246,11 +247,7 @@\n-        } else {\n-            if (sigalg.equalsIgnoreCase(\"RSASSA-PSS\")) {\n-                try {\n-                    digAlgID = AlgorithmId.get(signer.getParameters()\n-                            .getParameterSpec(PSSParameterSpec.class)\n-                            .getDigestAlgorithm());\n-                } catch (InvalidParameterSpecException e) {\n-                    throw new AssertionError(\"Should not happen\", e);\n-                }\n-            } else {\n-                digAlgID = AlgorithmId.get(extractDigestAlgFromDwithE(sigalg));\n+        } else if (sigalg.equalsIgnoreCase(\"RSASSA-PSS\")) {\n+            try {\n+                digAlgID = AlgorithmId.get(signer.getParameters()\n+                        .getParameterSpec(PSSParameterSpec.class)\n+                        .getDigestAlgorithm());\n+            } catch (InvalidParameterSpecException e) {\n+                throw new AssertionError(\"Should not happen\", e);\n@@ -258,0 +255,4 @@\n+        } else if (sigalg.equalsIgnoreCase(\"HSS\/LMS\")) {\n+            digAlgID = AlgorithmId.get(KeyUtil.hashAlgFromHSS(publicKey));\n+        } else {\n+            digAlgID = AlgorithmId.get(extractDigestAlgFromDwithE(sigalg));\n@@ -487,0 +488,1 @@\n+            case \"DH\", \"XDH\", \"X25519\", \"X448\" -> null;\n@@ -493,2 +495,2 @@\n-            case \"RSASSA-PSS\", \"ED25519\", \"ED448\" -> kAlg;\n-            default -> null;\n+            default -> kAlg; \/\/ All modern signature algorithms,\n+                             \/\/ RSASSA-PSS, ED25519, ED448, HSS\/LMS, etc\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureUtil.java","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1007,2 +1007,1 @@\n-                                    si.getDigestEncryptionAlgorithmId(),\n-                                    si.getAuthenticatedAttributes() == null);\n+                                    si.getDigestEncryptionAlgorithmId());\n@@ -1023,2 +1022,1 @@\n-                                        tsSi.getDigestEncryptionAlgorithmId(),\n-                                        tsSi.getAuthenticatedAttributes() == null);\n+                                        tsSi.getDigestEncryptionAlgorithmId());\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-                AlgorithmId.get(d), AlgorithmId.get(s), false));\n+                AlgorithmId.get(d), AlgorithmId.get(s)));\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs7\/NewSigAlg.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -222,1 +222,2 @@\n-                            signature, sigAlgo, signerEntry.privateKey, false),\n+                            signature, sigAlgo, signerEntry.privateKey,\n+                            signerEntry.cert.getPublicKey(), false),\n","filename":"test\/lib\/jdk\/test\/lib\/security\/timestamp\/TsaSigner.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}