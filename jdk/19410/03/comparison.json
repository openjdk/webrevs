{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -29,1 +30,0 @@\n-import java.lang.classfile.constantpool.*;\n@@ -31,6 +31,1 @@\n-import sun.security.action.GetBooleanAction;\n-\n-import java.io.IOException;\n-import static java.lang.classfile.ClassFile.*;\n-import java.lang.classfile.attribute.StackMapFrameInfo;\n-import java.lang.classfile.attribute.StackMapTableAttribute;\n+import java.lang.classfile.constantpool.*;\n@@ -38,1 +33,0 @@\n-import static java.lang.constant.ConstantDescs.*;\n@@ -43,1 +37,0 @@\n-import java.util.Arrays;\n@@ -49,1 +42,9 @@\n-import java.util.function.IntFunction;\n+import jdk.internal.constant.ConstantUtils;\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n+import sun.security.action.GetBooleanAction;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -61,10 +62,12 @@\n-            CD_ClassLoader = ClassDesc.ofInternalName(\"java\/lang\/ClassLoader\"),\n-            CD_ClassNotFoundException = ClassDesc.ofInternalName(\"java\/lang\/ClassNotFoundException\"),\n-            CD_IllegalAccessException = ClassDesc.ofInternalName(\"java\/lang\/IllegalAccessException\"),\n-            CD_InvocationHandler = ClassDesc.ofInternalName(\"java\/lang\/reflect\/InvocationHandler\"),\n-            CD_Method = ClassDesc.ofInternalName(\"java\/lang\/reflect\/Method\"),\n-            CD_NoClassDefFoundError = ClassDesc.ofInternalName(\"java\/lang\/NoClassDefFoundError\"),\n-            CD_NoSuchMethodError = ClassDesc.ofInternalName(\"java\/lang\/NoSuchMethodError\"),\n-            CD_NoSuchMethodException = ClassDesc.ofInternalName(\"java\/lang\/NoSuchMethodException\"),\n-            CD_Proxy = ClassDesc.ofInternalName(\"java\/lang\/reflect\/Proxy\"),\n-            CD_UndeclaredThrowableException = ClassDesc.ofInternalName(\"java\/lang\/reflect\/UndeclaredThrowableException\");\n+            CD_Class_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Class;\"),\n+            CD_ClassLoader = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/ClassLoader;\"),\n+            CD_ClassNotFoundException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/ClassNotFoundException;\"),\n+            CD_IllegalAccessException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/IllegalAccessException;\"),\n+            CD_InvocationHandler = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/InvocationHandler;\"),\n+            CD_Method = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Method;\"),\n+            CD_NoClassDefFoundError = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoClassDefFoundError;\"),\n+            CD_NoSuchMethodError = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodError;\"),\n+            CD_NoSuchMethodException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodException;\"),\n+            CD_Object_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\"),\n+            CD_Proxy = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Proxy;\"),\n+            CD_UndeclaredThrowableException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/UndeclaredThrowableException;\");\n@@ -73,12 +76,12 @@\n-            MTD_boolean = MethodTypeDesc.of(CD_boolean),\n-            MTD_void_InvocationHandler = MethodTypeDesc.of(CD_void, CD_InvocationHandler),\n-            MTD_void_String = MethodTypeDesc.of(CD_void, CD_String),\n-            MTD_void_Throwable = MethodTypeDesc.of(CD_void, CD_Throwable),\n-            MTD_Class = MethodTypeDesc.of(CD_Class),\n-            MTD_Class_String_boolean_ClassLoader = MethodTypeDesc.of(CD_Class, CD_String, CD_boolean, CD_ClassLoader),\n-            MTD_ClassLoader = MethodTypeDesc.of(CD_ClassLoader),\n-            MTD_MethodHandles$Lookup = MethodTypeDesc.of(CD_MethodHandles_Lookup),\n-            MTD_MethodHandles$Lookup_MethodHandles$Lookup = MethodTypeDesc.of(CD_MethodHandles_Lookup, CD_MethodHandles_Lookup),\n-            MTD_Method_String_ClassArray = MethodTypeDesc.of(CD_Method, CD_String, CD_Class.arrayType()),\n-            MTD_Object_Object_Method_ObjectArray = MethodTypeDesc.of(CD_Object, CD_Object, CD_Method, CD_Object.arrayType()),\n-            MTD_String = MethodTypeDesc.of(CD_String);\n+            MTD_boolean = MethodTypeDescImpl.ofValidated(CD_boolean, ConstantUtils.EMPTY_CLASSDESC),\n+            MTD_void_InvocationHandler = MethodTypeDescImpl.ofValidated(CD_void, new ClassDesc[]{CD_InvocationHandler}),\n+            MTD_void_String = MethodTypeDescImpl.ofValidated(CD_void, new ClassDesc[]{CD_String}),\n+            MTD_void_Throwable = MethodTypeDescImpl.ofValidated(CD_void, new ClassDesc[]{CD_Throwable}),\n+            MTD_Class = MethodTypeDescImpl.ofValidated(CD_Class, ConstantUtils.EMPTY_CLASSDESC),\n+            MTD_Class_String_boolean_ClassLoader = MethodTypeDescImpl.ofValidated(CD_Class, new ClassDesc[]{CD_String, CD_boolean, CD_ClassLoader}),\n+            MTD_ClassLoader = MethodTypeDescImpl.ofValidated(CD_ClassLoader, ConstantUtils.EMPTY_CLASSDESC),\n+            MTD_MethodHandles$Lookup = MethodTypeDescImpl.ofValidated(CD_MethodHandles_Lookup, ConstantUtils.EMPTY_CLASSDESC),\n+            MTD_MethodHandles$Lookup_MethodHandles$Lookup = MethodTypeDescImpl.ofValidated(CD_MethodHandles_Lookup, new ClassDesc[]{CD_MethodHandles_Lookup}),\n+            MTD_Method_String_ClassArray = MethodTypeDescImpl.ofValidated(CD_Method, new ClassDesc[]{CD_String, CD_Class_array}),\n+            MTD_Object_Object_Method_ObjectArray = MethodTypeDescImpl.ofValidated(CD_Object, new ClassDesc[]{CD_Object, CD_Method, CD_Object_array}),\n+            MTD_String = MethodTypeDescImpl.ofValidated(CD_String, ConstantUtils.EMPTY_CLASSDESC);\n@@ -93,1 +96,1 @@\n-    private static final String handlerFieldName = \"h\";\n+    private static final String NAME_HANDLER_FIELD = \"h\";\n@@ -99,1 +102,1 @@\n-    private static final boolean saveGeneratedFiles =\n+    private static final boolean SAVE_GENERATED_FILES =\n@@ -105,35 +108,3 @@\n-    private static final ProxyMethod hashCodeMethod;\n-    private static final ProxyMethod equalsMethod;\n-    private static final ProxyMethod toStringMethod;\n-\n-    private static final ClassModel TEMPLATE;\n-\n-    private static final ClassEntry CE_Class;\n-    private static final ClassEntry CE_ClassNotFoundException;\n-    private static final ClassEntry CE_NoClassDefFoundError;\n-    private static final ClassEntry CE_NoSuchMethodError;\n-    private static final ClassEntry CE_NoSuchMethodException;\n-    private static final ClassEntry CE_Object;\n-    private static final ClassEntry CE_Throwable;\n-    private static final ClassEntry CE_UndeclaredThrowableException;\n-\n-    private static final FieldRefEntry FRE_Proxy_h;\n-\n-    private static final InterfaceMethodRefEntry IMRE_InvocationHandler_invoke;\n-\n-    private static final MethodRefEntry MRE_Class_forName;\n-    private static final MethodRefEntry MRE_Class_getClassLoader;\n-    private static final MethodRefEntry MRE_Class_getMethod;\n-    private static final MethodRefEntry MRE_NoClassDefFoundError_init;\n-    private static final MethodRefEntry MRE_NoSuchMethodError_init;\n-    private static final MethodRefEntry MRE_Throwable_getMessage;\n-    private static final MethodRefEntry MRE_UndeclaredThrowableException_init;\n-\n-    private static final Utf8Entry UE_Method;\n-\n-    private static final List<StackMapFrameInfo.VerificationTypeInfo> THROWABLE_STACK;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T extends PoolEntry> T entryByIndex(int index) {\n-        return (T) TEMPLATE.constantPool().entryByIndex(index);\n-    }\n+    private static final ProxyMethod HASH_CODE_METHOD;\n+    private static final ProxyMethod EQUALS_METHOD;\n+    private static final ProxyMethod TO_STRING_METHOD;\n@@ -142,62 +113,0 @@\n-        \/\/ static template ClassModel holds pre-defined constant pool entries\n-        \/\/ proxy transformed from the template shares the template constant pool\n-        \/\/ each direct use of the template pool entry is significantly faster\n-        var cc = ClassFile.of();\n-        var ei = new int[21];\n-        TEMPLATE = cc.parse(cc.build(CD_Proxy, clb -> {\n-            clb.withSuperclass(CD_Proxy);\n-            generateConstructor(clb);\n-            generateLookupAccessor(clb);\n-            var cp = clb.constantPool();\n-\n-            ei[0] = cp.classEntry(CD_Class).index();\n-            ei[1] = cp.classEntry(CD_ClassNotFoundException).index();\n-            ei[2] = cp.classEntry(CD_NoClassDefFoundError).index();\n-            ei[3] = cp.classEntry(CD_NoSuchMethodError).index();\n-            ei[4] = cp.classEntry(CD_NoSuchMethodException).index();\n-            ei[5] = cp.classEntry(CD_Object).index();\n-            ei[6] = cp.classEntry(CD_Throwable).index();\n-            ei[7] = cp.classEntry(CD_UndeclaredThrowableException).index();\n-\n-            ei[8] = cp.fieldRefEntry(CD_Proxy, handlerFieldName, CD_InvocationHandler).index();\n-\n-            ei[9] = cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray).index();\n-\n-            ei[10] = cp.methodRefEntry(CD_Class, \"forName\", MTD_Class_String_boolean_ClassLoader).index();\n-            ei[11] = cp.methodRefEntry(CD_Class, \"getClassLoader\", MTD_ClassLoader).index();\n-            ei[12] = cp.methodRefEntry(CD_Class, \"getMethod\", MTD_Method_String_ClassArray).index();\n-            ei[13] = cp.methodRefEntry(CD_NoClassDefFoundError, INIT_NAME, MTD_void_String).index();\n-            ei[14] = cp.methodRefEntry(CD_NoSuchMethodError, INIT_NAME, MTD_void_String).index();\n-            ei[15] = cp.methodRefEntry(CD_Throwable, \"getMessage\", MTD_String).index();\n-            ei[16] = cp.methodRefEntry(CD_UndeclaredThrowableException, INIT_NAME, MTD_void_Throwable).index();\n-\n-            ei[17] = cp.utf8Entry(CD_Method).index();\n-\n-            ei[18] = cp.utf8Entry(\"m0\").index();\n-            ei[19] = cp.utf8Entry(\"m1\").index();\n-            ei[20] = cp.utf8Entry(\"m2\").index();\n-        }));\n-\n-        CE_Class = entryByIndex(ei[0]);\n-        CE_ClassNotFoundException = entryByIndex(ei[1]);\n-        CE_NoClassDefFoundError = entryByIndex(ei[2]);\n-        CE_NoSuchMethodError = entryByIndex(ei[3]);\n-        CE_NoSuchMethodException = entryByIndex(ei[4]);\n-        CE_Object = entryByIndex(ei[5]);\n-        CE_Throwable = entryByIndex(ei[6]);\n-        CE_UndeclaredThrowableException = entryByIndex(ei[7]);\n-\n-        FRE_Proxy_h = entryByIndex(ei[8]);\n-\n-        IMRE_InvocationHandler_invoke = entryByIndex(ei[9]);\n-\n-        MRE_Class_forName = entryByIndex(ei[10]);\n-        MRE_Class_getClassLoader = entryByIndex(ei[11]);\n-        MRE_Class_getMethod = entryByIndex(ei[12]);\n-        MRE_NoClassDefFoundError_init = entryByIndex(ei[13]);\n-        MRE_NoSuchMethodError_init = entryByIndex(ei[14]);\n-        MRE_Throwable_getMessage = entryByIndex(ei[15]);\n-        MRE_UndeclaredThrowableException_init = entryByIndex(ei[16]);\n-\n-        UE_Method = entryByIndex(ei[17]);\n-\n@@ -205,3 +114,3 @@\n-            hashCodeMethod = new ProxyMethod(Object.class.getMethod(\"hashCode\"), entryByIndex(ei[18]));\n-            equalsMethod = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class), entryByIndex(ei[19]));\n-            toStringMethod = new ProxyMethod(Object.class.getMethod(\"toString\"), entryByIndex(ei[20]));\n+            HASH_CODE_METHOD = new ProxyMethod(Object.class.getMethod(\"hashCode\"), \"m0\");\n+            EQUALS_METHOD = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class), \"m1\");\n+            TO_STRING_METHOD = new ProxyMethod(Object.class.getMethod(\"toString\"), \"m2\");\n@@ -211,2 +120,0 @@\n-\n-        THROWABLE_STACK = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(CE_Throwable));\n@@ -220,0 +127,7 @@\n+    private final List<StackMapFrameInfo.VerificationTypeInfo> throwableStack;\n+    private final NameAndTypeEntry exInit;\n+    private final ClassEntry clazz, object, proxy, ute;\n+    private final FieldRefEntry handlerField;\n+    private final InterfaceMethodRefEntry invoke;\n+    private final MethodRefEntry forName, getMethod, uteInit;\n+\n@@ -262,2 +176,2 @@\n-        this.cp = ConstantPoolBuilder.of(TEMPLATE);\n-        this.classEntry = cp.classEntry(ClassDesc.of(className));\n+        this.cp = ConstantPoolBuilder.of();\n+        this.classEntry = cp.classEntry(ReferenceClassDescImpl.ofValidatedBinaryName(className));\n@@ -266,0 +180,11 @@\n+        this.throwableStack = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(cp.classEntry(CD_Throwable)));\n+        this.exInit = cp.nameAndTypeEntry(INIT_NAME, MTD_void_String);\n+        this.clazz = cp.classEntry(CD_Class);\n+        this.forName = cp.methodRefEntry(clazz, cp.nameAndTypeEntry(\"forName\", MTD_Class_String_boolean_ClassLoader));\n+        this.getMethod = cp.methodRefEntry(clazz, cp.nameAndTypeEntry(\"getMethod\", MTD_Method_String_ClassArray));\n+        this.object = cp.classEntry(CD_Object);\n+        this.proxy = cp.classEntry(CD_Proxy);\n+        this.handlerField = cp.fieldRefEntry(proxy, cp.nameAndTypeEntry(NAME_HANDLER_FIELD, CD_InvocationHandler));\n+        this.invoke = cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray);\n+        this.ute = cp.classEntry(CD_UndeclaredThrowableException);\n+        this.uteInit = cp.methodRefEntry(ute, cp.nameAndTypeEntry(INIT_NAME, MTD_void_Throwable));\n@@ -284,1 +209,1 @@\n-        if (saveGeneratedFiles) {\n+        if (SAVE_GENERATED_FILES) {\n@@ -315,4 +240,4 @@\n-    private static ClassEntry[] toClassEntries(ConstantPoolBuilder cp, List<Class<?>> types) {\n-        var ces = new ClassEntry[types.size()];\n-        for (int i = 0; i < ces.length; i++)\n-            ces[i] = cp.classEntry(cp.utf8Entry(types.get(i).getName().replace('.', '\/')));\n+    private static List<ClassEntry> toClassEntries(ConstantPoolBuilder cp, List<Class<?>> types) {\n+        var ces = new ArrayList<ClassEntry>(types.size());\n+        for (var t : types)\n+            ces.add(cp.classEntry(ReferenceClassDescImpl.ofValidatedBinaryName(t.getName())));\n@@ -532,3 +457,3 @@\n-        addProxyMethod(hashCodeMethod);\n-        addProxyMethod(equalsMethod);\n-        addProxyMethod(toStringMethod);\n+        addProxyMethod(HASH_CODE_METHOD);\n+        addProxyMethod(EQUALS_METHOD);\n+        addProxyMethod(TO_STRING_METHOD);\n@@ -542,1 +467,1 @@\n-                    addProxyMethod(m, intf, cp);\n+                    addProxyMethod(m, intf);\n@@ -556,1 +481,1 @@\n-            TEMPLATE.forEach(clb);\n+            clb.withSuperclass(proxy);\n@@ -559,0 +484,1 @@\n+            generateConstructor(clb);\n@@ -563,1 +489,1 @@\n-                    clb.withField(pm.methodFieldName, UE_Method, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+                    clb.withField(pm.methodFieldName, CD_Method, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n@@ -566,1 +492,1 @@\n-                    pm.generateMethod(clb, classEntry);\n+                    pm.generateMethod(this, clb);\n@@ -571,0 +497,1 @@\n+            generateLookupAccessor(clb);\n@@ -587,1 +514,1 @@\n-    private void addProxyMethod(Method m, Class<?> fromClass, ConstantPoolBuilder cp) {\n+    private void addProxyMethod(Method m, Class<?> fromClass) {\n@@ -612,2 +539,1 @@\n-                exceptionTypes, fromClass,\n-                cp.utf8Entry(\"m\" + proxyMethodCount++)));\n+                exceptionTypes, fromClass, \"m\" + proxyMethodCount++));\n@@ -631,1 +557,1 @@\n-    private static void generateConstructor(ClassBuilder clb) {\n+    private void generateConstructor(ClassBuilder clb) {\n@@ -633,3 +559,3 @@\n-               .aload(cob.receiverSlot())\n-               .aload(cob.parameterSlot(0))\n-               .invokespecial(CD_Proxy, INIT_NAME, MTD_void_InvocationHandler)\n+               .aload(0)\n+               .aload(1)\n+               .invokespecial(cp.methodRefEntry(proxy, cp.nameAndTypeEntry(INIT_NAME, MTD_void_InvocationHandler)))\n@@ -647,1 +573,1 @@\n-               .invokevirtual(MRE_Class_getClassLoader)\n+               .invokevirtual(CD_Class, \"getClassLoader\", MTD_ClassLoader)\n@@ -649,1 +575,1 @@\n-            var ts = cob.newBoundLabel();\n+            Label ts = cob.newBoundLabel();\n@@ -652,1 +578,1 @@\n-                    pm.codeFieldInitialization(cob, classEntry);\n+                    pm.codeFieldInitialization(cob, this);\n@@ -656,3 +582,6 @@\n-            var c1 = cob.newBoundLabel();\n-            cob.exceptionCatch(ts, c1, c1, CE_NoSuchMethodException)\n-               .new_(CE_NoSuchMethodError)\n+            Label c1 = cob.newBoundLabel();\n+            ClassEntry nsme = cp.classEntry(CD_NoSuchMethodError);\n+            ClassEntry ncdfe = cp.classEntry(CD_NoClassDefFoundError);\n+            MethodRefEntry tgm = cp.methodRefEntry(CD_Throwable, \"getMessage\", MTD_String);\n+            cob.exceptionCatch(ts, c1, c1, CD_NoSuchMethodException)\n+               .new_(nsme)\n@@ -661,2 +590,2 @@\n-               .invokevirtual(MRE_Throwable_getMessage)\n-               .invokespecial(MRE_NoSuchMethodError_init)\n+               .invokevirtual(tgm)\n+               .invokespecial(cp.methodRefEntry(nsme, exInit))\n@@ -664,3 +593,3 @@\n-            var c2 = cob.newBoundLabel();\n-            cob.exceptionCatch(ts, c1, c2, CE_ClassNotFoundException)\n-               .new_(CE_NoClassDefFoundError)\n+            Label c2 = cob.newBoundLabel();\n+            cob.exceptionCatch(ts, c1, c2, CD_ClassNotFoundException)\n+               .new_(ncdfe)\n@@ -669,2 +598,2 @@\n-               .invokevirtual(MRE_Throwable_getMessage)\n-               .invokespecial(MRE_NoClassDefFoundError_init)\n+               .invokevirtual(tgm)\n+               .invokespecial(cp.methodRefEntry(ncdfe, exInit))\n@@ -673,2 +602,2 @@\n-                     StackMapFrameInfo.of(c1, List.of(), THROWABLE_STACK),\n-                     StackMapFrameInfo.of(c2, List.of(), THROWABLE_STACK))));\n+                      StackMapFrameInfo.of(c1, List.of(), throwableStack),\n+                      StackMapFrameInfo.of(c2, List.of(), throwableStack))));\n@@ -683,1 +612,1 @@\n-    private static void generateLookupAccessor(ClassBuilder clb) {\n+    private void generateLookupAccessor(ClassBuilder clb) {\n@@ -688,17 +617,25 @@\n-                        .withCode(cob -> cob\n-                            .block(blockBuilder -> blockBuilder\n-                                    .aload(cob.parameterSlot(0))\n-                                    .invokevirtual(CD_MethodHandles_Lookup, \"lookupClass\", MTD_Class)\n-                                    .ldc(CD_Proxy)\n-                                    .if_acmpne(blockBuilder.breakLabel())\n-                                    .aload(cob.parameterSlot(0))\n-                                    .invokevirtual(CD_MethodHandles_Lookup, \"hasFullPrivilegeAccess\", MTD_boolean)\n-                                    .ifeq(blockBuilder.breakLabel())\n-                                    .invokestatic(CD_MethodHandles, \"lookup\", MTD_MethodHandles$Lookup)\n-                                    .areturn())\n-                            .new_(CD_IllegalAccessException)\n-                            .dup()\n-                            .aload(cob.parameterSlot(0))\n-                            .invokevirtual(CD_MethodHandles_Lookup, \"toString\", MTD_String)\n-                            .invokespecial(CD_IllegalAccessException, INIT_NAME, MTD_void_String)\n-                            .athrow()));\n+                        .withCode(cob -> {\n+                            Label failLabel = cob.newLabel();\n+                            ClassEntry mhl = cp.classEntry(CD_MethodHandles_Lookup);\n+                            ClassEntry iae = cp.classEntry(CD_IllegalAccessException);\n+                            cob.aload(cob.parameterSlot(0))\n+                               .invokevirtual(cp.methodRefEntry(mhl, cp.nameAndTypeEntry(\"lookupClass\", MTD_Class)))\n+                               .ldc(proxy)\n+                               .if_acmpne(failLabel)\n+                               .aload(cob.parameterSlot(0))\n+                               .invokevirtual(cp.methodRefEntry(mhl, cp.nameAndTypeEntry(\"hasFullPrivilegeAccess\", MTD_boolean)))\n+                               .ifeq(failLabel)\n+                               .invokestatic(CD_MethodHandles, \"lookup\", MTD_MethodHandles$Lookup)\n+                               .areturn()\n+                               .labelBinding(failLabel)\n+                               .new_(iae)\n+                               .dup()\n+                               .aload(cob.parameterSlot(0))\n+                               .invokevirtual(cp.methodRefEntry(mhl, cp.nameAndTypeEntry(\"toString\", MTD_String)))\n+                               .invokespecial(cp.methodRefEntry(iae, exInit))\n+                               .athrow()\n+                               .with(StackMapTableAttribute.of(List.of(\n+                                       StackMapFrameInfo.of(failLabel,\n+                                               List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(mhl)),\n+                                               List.of()))));\n+                        }));\n@@ -719,1 +656,1 @@\n-        private final Utf8Entry methodFieldName;\n+        private final String methodFieldName;\n@@ -724,1 +661,1 @@\n-                            Class<?> fromClass, Utf8Entry methodFieldName) {\n+                            Class<?> fromClass, String methodFieldName) {\n@@ -740,1 +677,1 @@\n-        private ProxyMethod(Method method, Utf8Entry methodFieldName) {\n+        private ProxyMethod(Method method, String methodFieldName) {\n@@ -749,4 +686,7 @@\n-        private void generateMethod(ClassBuilder clb, ClassEntry className) {\n-            var cp = clb.constantPool();\n-            MethodTypeDesc desc = MethodTypeDesc.of(toClassDesc(returnType),\n-                    Arrays.stream(parameterTypes).map(ProxyGenerator::toClassDesc).toArray(ClassDesc[]::new));\n+        private void generateMethod(ProxyGenerator pg, ClassBuilder clb) {\n+            var cp = pg.cp;\n+            var pTypes = new ClassDesc[parameterTypes.length];\n+            for (int i = 0; i < pTypes.length; i++) {\n+                pTypes[i] = toClassDesc(parameterTypes[i]);\n+            }\n+            MethodTypeDesc desc = MethodTypeDescImpl.ofTrusted(toClassDesc(returnType), pTypes);\n@@ -760,1 +700,1 @@\n-                           .getfield(FRE_Proxy_h)\n+                           .getfield(pg.handlerField)\n@@ -762,1 +702,1 @@\n-                           .getstatic(cp.fieldRefEntry(className, cp.nameAndTypeEntry(methodFieldName, UE_Method)));\n+                           .getstatic(cp.fieldRefEntry(pg.classEntry, cp.nameAndTypeEntry(methodFieldName, CD_Method)));\n@@ -767,1 +707,1 @@\n-                               .anewarray(CE_Object);\n+                               .anewarray(pg.object);\n@@ -778,1 +718,1 @@\n-                        cob.invokeinterface(IMRE_InvocationHandler_invoke);\n+                        cob.invokeinterface(pg.invoke);\n@@ -794,1 +734,1 @@\n-                               .new_(CE_UndeclaredThrowableException)\n+                               .new_(pg.ute)\n@@ -797,1 +737,1 @@\n-                               .invokespecial(MRE_UndeclaredThrowableException_init)\n+                               .invokespecial(pg.uteInit)\n@@ -800,2 +740,2 @@\n-                                    StackMapFrameInfo.of(c1, List.of(), THROWABLE_STACK),\n-                                    StackMapFrameInfo.of(c2, List.of(), THROWABLE_STACK))));\n+                                       StackMapFrameInfo.of(c1, List.of(), pg.throwableStack),\n+                                       StackMapFrameInfo.of(c2, List.of(), pg.throwableStack))));\n@@ -816,1 +756,1 @@\n-                cob.invokestatic(prim.wrapperMethodRef);\n+                cob.invokestatic(prim.wrapperMethodRef(cob.constantPool()));\n@@ -832,1 +772,1 @@\n-                   .invokevirtual(prim.unwrapMethodRef)\n+                   .invokevirtual(prim.unwrapMethodRef(cob.constantPool()))\n@@ -845,1 +785,1 @@\n-        private void codeFieldInitialization(CodeBuilder cob, ClassEntry className) {\n+        private void codeFieldInitialization(CodeBuilder cob, ProxyGenerator pg) {\n@@ -847,1 +787,1 @@\n-            codeClassForName(cob, fromClass);\n+            codeClassForName(cob, fromClass, pg);\n@@ -851,1 +791,1 @@\n-               .anewarray(CE_Class);\n+               .anewarray(pg.clazz);\n@@ -859,1 +799,1 @@\n-                    cob.getstatic(prim.typeFieldRef);\n+                    cob.getstatic(prim.typeFieldRef(cob.constantPool()));\n@@ -861,1 +801,1 @@\n-                    codeClassForName(cob, parameterTypes[i]);\n+                    codeClassForName(cob, parameterTypes[i], pg);\n@@ -866,2 +806,2 @@\n-            cob.invokevirtual(MRE_Class_getMethod)\n-               .putstatic(cp.fieldRefEntry(className, cp.nameAndTypeEntry(methodFieldName, UE_Method)));\n+            cob.invokevirtual(pg.getMethod)\n+               .putstatic(cp.fieldRefEntry(pg.classEntry, cp.nameAndTypeEntry(methodFieldName, CD_Method)));\n@@ -881,1 +821,1 @@\n-        private void codeClassForName(CodeBuilder cob, Class<?> cl) {\n+        private void codeClassForName(CodeBuilder cob, Class<?> cl, ProxyGenerator pg) {\n@@ -885,1 +825,1 @@\n-               .invokestatic(MRE_Class_forName);\n+               .invokestatic(pg.forName);\n@@ -894,1 +834,0 @@\n-    private static final ConstantPoolBuilder CP = ConstantPoolBuilder.of();\n@@ -911,1 +850,1 @@\n-         * CP entry of corresponding wrapper class\n+         * wrapper class\n@@ -913,1 +852,1 @@\n-        private final ClassEntry wrapperClass;\n+        private final ClassDesc wrapperClass;\n@@ -915,1 +854,1 @@\n-         * CP entry for wrapper class \"valueOf\" factory method\n+         * wrapper factory method type\n@@ -917,1 +856,1 @@\n-        private final MethodRefEntry wrapperMethodRef;\n+        private final MethodTypeDesc wrapperMethodType;\n@@ -919,1 +858,1 @@\n-         * CP entry of wrapper class method for retrieving primitive value\n+         * wrapper class method name for retrieving primitive value\n@@ -921,1 +860,1 @@\n-        private final MethodRefEntry unwrapMethodRef;\n+        private final String unwrapMethodName;\n@@ -923,1 +862,1 @@\n-         * CP entry of wrapper class TYPE field\n+         * wrapper class method type for retrieving primitive value\n@@ -925,1 +864,1 @@\n-        private final FieldRefEntry typeFieldRef;\n+        private final MethodTypeDesc unwrapMethodType;\n@@ -929,4 +868,4 @@\n-            this.wrapperClass = CP.classEntry(wrapperClass);\n-            this.wrapperMethodRef = CP.methodRefEntry(wrapperClass, \"valueOf\", MethodTypeDesc.of(wrapperClass, baseType));\n-            this.unwrapMethodRef = CP.methodRefEntry(wrapperClass, primitiveClass.getName() + \"Value\", MethodTypeDesc.of(baseType));\n-            this.typeFieldRef = CP.fieldRefEntry(wrapperClass, \"TYPE\", CD_Class);\n+            this.wrapperClass = wrapperClass;\n+            this.wrapperMethodType = MethodTypeDescImpl.ofValidated(wrapperClass, new ClassDesc[]{baseType});\n+            this.unwrapMethodName = primitiveClass.getName() + \"Value\";\n+            this.unwrapMethodType = MethodTypeDescImpl.ofValidated(baseType, ConstantUtils.EMPTY_CLASSDESC);\n@@ -947,0 +886,12 @@\n+\n+        public MethodRefEntry wrapperMethodRef(ConstantPoolBuilder cp) {\n+            return cp.methodRefEntry(wrapperClass, \"valueOf\", wrapperMethodType);\n+        }\n+\n+        public MethodRefEntry unwrapMethodRef(ConstantPoolBuilder cp) {\n+            return cp.methodRefEntry(wrapperClass, unwrapMethodName, unwrapMethodType);\n+        }\n+\n+        public FieldRefEntry typeFieldRef(ConstantPoolBuilder cp) {\n+            return cp.fieldRefEntry(wrapperClass, \"TYPE\", CD_Class);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":181,"deletions":230,"binary":false,"changes":411,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,7 @@\n+import java.lang.classfile.BufWriter;\n+import java.lang.classfile.ClassReader;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapFrameInfo.*;\n+import java.lang.classfile.constantpool.ClassEntry;\n@@ -32,0 +39,1 @@\n+import java.util.Objects;\n@@ -33,6 +41,0 @@\n-import java.lang.classfile.BufWriter;\n-\n-import java.lang.classfile.constantpool.ClassEntry;\n-import java.lang.classfile.attribute.StackMapFrameInfo;\n-import java.lang.classfile.attribute.StackMapFrameInfo.*;\n-import java.lang.classfile.ClassReader;\n@@ -41,2 +43,0 @@\n-import java.lang.classfile.Label;\n-import java.lang.classfile.MethodModel;\n@@ -246,0 +246,14 @@\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o instanceof ObjectVerificationTypeInfoImpl that) {\n+                return Objects.equals(className, that.className);\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(className);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"}]}