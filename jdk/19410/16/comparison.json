{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -29,1 +30,0 @@\n-import java.lang.classfile.constantpool.*;\n@@ -31,6 +31,1 @@\n-import sun.security.action.GetBooleanAction;\n-\n-import java.io.IOException;\n-import static java.lang.classfile.ClassFile.*;\n-import java.lang.classfile.attribute.StackMapFrameInfo;\n-import java.lang.classfile.attribute.StackMapTableAttribute;\n+import java.lang.classfile.constantpool.*;\n@@ -38,1 +33,0 @@\n-import static java.lang.constant.ConstantDescs.*;\n@@ -43,1 +37,0 @@\n-import java.util.Arrays;\n@@ -49,1 +42,12 @@\n-import java.util.function.IntFunction;\n+import jdk.internal.constant.ConstantUtils;\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n+import sun.security.action.GetBooleanAction;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n+import java.lang.constant.ConstantDescs;\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n@@ -60,0 +64,3 @@\n+    private static final ClassFile CF_CONTEXT =\n+            ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS);\n+\n@@ -61,10 +68,9 @@\n-            CD_ClassLoader = ClassDesc.ofInternalName(\"java\/lang\/ClassLoader\"),\n-            CD_ClassNotFoundException = ClassDesc.ofInternalName(\"java\/lang\/ClassNotFoundException\"),\n-            CD_IllegalAccessException = ClassDesc.ofInternalName(\"java\/lang\/IllegalAccessException\"),\n-            CD_InvocationHandler = ClassDesc.ofInternalName(\"java\/lang\/reflect\/InvocationHandler\"),\n-            CD_Method = ClassDesc.ofInternalName(\"java\/lang\/reflect\/Method\"),\n-            CD_NoClassDefFoundError = ClassDesc.ofInternalName(\"java\/lang\/NoClassDefFoundError\"),\n-            CD_NoSuchMethodError = ClassDesc.ofInternalName(\"java\/lang\/NoSuchMethodError\"),\n-            CD_NoSuchMethodException = ClassDesc.ofInternalName(\"java\/lang\/NoSuchMethodException\"),\n-            CD_Proxy = ClassDesc.ofInternalName(\"java\/lang\/reflect\/Proxy\"),\n-            CD_UndeclaredThrowableException = ClassDesc.ofInternalName(\"java\/lang\/reflect\/UndeclaredThrowableException\");\n+            CD_Class_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Class;\"),\n+            CD_IllegalAccessException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/IllegalAccessException;\"),\n+            CD_InvocationHandler = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/InvocationHandler;\"),\n+            CD_Method = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Method;\"),\n+            CD_NoSuchMethodError = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodError;\"),\n+            CD_NoSuchMethodException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodException;\"),\n+            CD_Object_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\"),\n+            CD_Proxy = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Proxy;\"),\n+            CD_UndeclaredThrowableException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/UndeclaredThrowableException;\");\n@@ -73,12 +79,11 @@\n-            MTD_boolean = MethodTypeDesc.of(CD_boolean),\n-            MTD_void_InvocationHandler = MethodTypeDesc.of(CD_void, CD_InvocationHandler),\n-            MTD_void_String = MethodTypeDesc.of(CD_void, CD_String),\n-            MTD_void_Throwable = MethodTypeDesc.of(CD_void, CD_Throwable),\n-            MTD_Class = MethodTypeDesc.of(CD_Class),\n-            MTD_Class_String_boolean_ClassLoader = MethodTypeDesc.of(CD_Class, CD_String, CD_boolean, CD_ClassLoader),\n-            MTD_ClassLoader = MethodTypeDesc.of(CD_ClassLoader),\n-            MTD_MethodHandles$Lookup = MethodTypeDesc.of(CD_MethodHandles_Lookup),\n-            MTD_MethodHandles$Lookup_MethodHandles$Lookup = MethodTypeDesc.of(CD_MethodHandles_Lookup, CD_MethodHandles_Lookup),\n-            MTD_Method_String_ClassArray = MethodTypeDesc.of(CD_Method, CD_String, CD_Class.arrayType()),\n-            MTD_Object_Object_Method_ObjectArray = MethodTypeDesc.of(CD_Object, CD_Object, CD_Method, CD_Object.arrayType()),\n-            MTD_String = MethodTypeDesc.of(CD_String);\n+            MTD_boolean = MethodTypeDescImpl.ofValidated(CD_boolean, ConstantUtils.EMPTY_CLASSDESC),\n+            MTD_void_InvocationHandler = MethodTypeDescImpl.ofValidated(CD_void, new ClassDesc[]{CD_InvocationHandler}),\n+            MTD_void_String = MethodTypeDescImpl.ofValidated(CD_void, new ClassDesc[]{CD_String}),\n+            MTD_void_Throwable = MethodTypeDescImpl.ofValidated(CD_void, new ClassDesc[]{CD_Throwable}),\n+            MTD_Class = MethodTypeDescImpl.ofValidated(CD_Class, ConstantUtils.EMPTY_CLASSDESC),\n+            MTD_Class_array = MethodTypeDescImpl.ofValidated(CD_Class_array, ConstantUtils.EMPTY_CLASSDESC),\n+            MTD_Method_String_Class_array = MethodTypeDescImpl.ofValidated(CD_Method, new ClassDesc[]{ConstantDescs.CD_String, CD_Class_array}),\n+            MTD_MethodHandles$Lookup = MethodTypeDescImpl.ofValidated(CD_MethodHandles_Lookup, ConstantUtils.EMPTY_CLASSDESC),\n+            MTD_MethodHandles$Lookup_MethodHandles$Lookup = MethodTypeDescImpl.ofValidated(CD_MethodHandles_Lookup, new ClassDesc[]{CD_MethodHandles_Lookup}),\n+            MTD_Object_Object_Method_ObjectArray = MethodTypeDescImpl.ofValidated(CD_Object, new ClassDesc[]{CD_Object, CD_Method, CD_Object_array}),\n+            MTD_String = MethodTypeDescImpl.ofValidated(CD_String, ConstantUtils.EMPTY_CLASSDESC);\n@@ -93,1 +98,1 @@\n-    private static final String handlerFieldName = \"h\";\n+    private static final String NAME_HANDLER_FIELD = \"h\";\n@@ -99,1 +104,1 @@\n-    private static final boolean saveGeneratedFiles =\n+    private static final boolean SAVE_GENERATED_FILES =\n@@ -105,35 +110,3 @@\n-    private static final ProxyMethod hashCodeMethod;\n-    private static final ProxyMethod equalsMethod;\n-    private static final ProxyMethod toStringMethod;\n-\n-    private static final ClassModel TEMPLATE;\n-\n-    private static final ClassEntry CE_Class;\n-    private static final ClassEntry CE_ClassNotFoundException;\n-    private static final ClassEntry CE_NoClassDefFoundError;\n-    private static final ClassEntry CE_NoSuchMethodError;\n-    private static final ClassEntry CE_NoSuchMethodException;\n-    private static final ClassEntry CE_Object;\n-    private static final ClassEntry CE_Throwable;\n-    private static final ClassEntry CE_UndeclaredThrowableException;\n-\n-    private static final FieldRefEntry FRE_Proxy_h;\n-\n-    private static final InterfaceMethodRefEntry IMRE_InvocationHandler_invoke;\n-\n-    private static final MethodRefEntry MRE_Class_forName;\n-    private static final MethodRefEntry MRE_Class_getClassLoader;\n-    private static final MethodRefEntry MRE_Class_getMethod;\n-    private static final MethodRefEntry MRE_NoClassDefFoundError_init;\n-    private static final MethodRefEntry MRE_NoSuchMethodError_init;\n-    private static final MethodRefEntry MRE_Throwable_getMessage;\n-    private static final MethodRefEntry MRE_UndeclaredThrowableException_init;\n-\n-    private static final Utf8Entry UE_Method;\n-\n-    private static final List<StackMapFrameInfo.VerificationTypeInfo> THROWABLE_STACK;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T extends PoolEntry> T entryByIndex(int index) {\n-        return (T) TEMPLATE.constantPool().entryByIndex(index);\n-    }\n+    private static final ProxyMethod HASH_CODE_METHOD;\n+    private static final ProxyMethod EQUALS_METHOD;\n+    private static final ProxyMethod TO_STRING_METHOD;\n@@ -142,62 +115,0 @@\n-        \/\/ static template ClassModel holds pre-defined constant pool entries\n-        \/\/ proxy transformed from the template shares the template constant pool\n-        \/\/ each direct use of the template pool entry is significantly faster\n-        var cc = ClassFile.of();\n-        var ei = new int[21];\n-        TEMPLATE = cc.parse(cc.build(CD_Proxy, clb -> {\n-            clb.withSuperclass(CD_Proxy);\n-            generateConstructor(clb);\n-            generateLookupAccessor(clb);\n-            var cp = clb.constantPool();\n-\n-            ei[0] = cp.classEntry(CD_Class).index();\n-            ei[1] = cp.classEntry(CD_ClassNotFoundException).index();\n-            ei[2] = cp.classEntry(CD_NoClassDefFoundError).index();\n-            ei[3] = cp.classEntry(CD_NoSuchMethodError).index();\n-            ei[4] = cp.classEntry(CD_NoSuchMethodException).index();\n-            ei[5] = cp.classEntry(CD_Object).index();\n-            ei[6] = cp.classEntry(CD_Throwable).index();\n-            ei[7] = cp.classEntry(CD_UndeclaredThrowableException).index();\n-\n-            ei[8] = cp.fieldRefEntry(CD_Proxy, handlerFieldName, CD_InvocationHandler).index();\n-\n-            ei[9] = cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray).index();\n-\n-            ei[10] = cp.methodRefEntry(CD_Class, \"forName\", MTD_Class_String_boolean_ClassLoader).index();\n-            ei[11] = cp.methodRefEntry(CD_Class, \"getClassLoader\", MTD_ClassLoader).index();\n-            ei[12] = cp.methodRefEntry(CD_Class, \"getMethod\", MTD_Method_String_ClassArray).index();\n-            ei[13] = cp.methodRefEntry(CD_NoClassDefFoundError, INIT_NAME, MTD_void_String).index();\n-            ei[14] = cp.methodRefEntry(CD_NoSuchMethodError, INIT_NAME, MTD_void_String).index();\n-            ei[15] = cp.methodRefEntry(CD_Throwable, \"getMessage\", MTD_String).index();\n-            ei[16] = cp.methodRefEntry(CD_UndeclaredThrowableException, INIT_NAME, MTD_void_Throwable).index();\n-\n-            ei[17] = cp.utf8Entry(CD_Method).index();\n-\n-            ei[18] = cp.utf8Entry(\"m0\").index();\n-            ei[19] = cp.utf8Entry(\"m1\").index();\n-            ei[20] = cp.utf8Entry(\"m2\").index();\n-        }));\n-\n-        CE_Class = entryByIndex(ei[0]);\n-        CE_ClassNotFoundException = entryByIndex(ei[1]);\n-        CE_NoClassDefFoundError = entryByIndex(ei[2]);\n-        CE_NoSuchMethodError = entryByIndex(ei[3]);\n-        CE_NoSuchMethodException = entryByIndex(ei[4]);\n-        CE_Object = entryByIndex(ei[5]);\n-        CE_Throwable = entryByIndex(ei[6]);\n-        CE_UndeclaredThrowableException = entryByIndex(ei[7]);\n-\n-        FRE_Proxy_h = entryByIndex(ei[8]);\n-\n-        IMRE_InvocationHandler_invoke = entryByIndex(ei[9]);\n-\n-        MRE_Class_forName = entryByIndex(ei[10]);\n-        MRE_Class_getClassLoader = entryByIndex(ei[11]);\n-        MRE_Class_getMethod = entryByIndex(ei[12]);\n-        MRE_NoClassDefFoundError_init = entryByIndex(ei[13]);\n-        MRE_NoSuchMethodError_init = entryByIndex(ei[14]);\n-        MRE_Throwable_getMessage = entryByIndex(ei[15]);\n-        MRE_UndeclaredThrowableException_init = entryByIndex(ei[16]);\n-\n-        UE_Method = entryByIndex(ei[17]);\n-\n@@ -205,3 +116,3 @@\n-            hashCodeMethod = new ProxyMethod(Object.class.getMethod(\"hashCode\"), entryByIndex(ei[18]));\n-            equalsMethod = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class), entryByIndex(ei[19]));\n-            toStringMethod = new ProxyMethod(Object.class.getMethod(\"toString\"), entryByIndex(ei[20]));\n+            HASH_CODE_METHOD = new ProxyMethod(Object.class.getMethod(\"hashCode\"));\n+            EQUALS_METHOD = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class));\n+            TO_STRING_METHOD = new ProxyMethod(Object.class.getMethod(\"toString\"));\n@@ -211,2 +122,0 @@\n-\n-        THROWABLE_STACK = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(CE_Throwable));\n@@ -215,4 +124,0 @@\n-    \/**\n-     * Classfile context\n-     *\/\n-    private final ClassFile classfileContext;\n@@ -220,0 +125,8 @@\n+    private final List<StackMapFrameInfo.VerificationTypeInfo> throwableStack;\n+    private final NameAndTypeEntry exInit;\n+    private final ClassEntry object, proxy, ute;\n+    private final FieldRefEntry handlerField;\n+    private final InterfaceMethodRefEntry invoke;\n+    private final MethodRefEntry uteInit;\n+    private final DirectMethodHandleDesc bsm;\n+\n@@ -243,6 +156,0 @@\n-    \/**\n-     * Ordinal of next ProxyMethod object added to proxyMethods.\n-     * Indexes are reserved for hashcode(0), equals(1), toString(2).\n-     *\/\n-    private int proxyMethodCount = 3;\n-\n@@ -258,6 +165,2 @@\n-        this.classfileContext = ClassFile.of(\n-                ClassFile.StackMapsOption.DROP_STACK_MAPS,\n-                ClassFile.ClassHierarchyResolverOption.of(\n-                        ClassHierarchyResolver.ofClassLoading(loader).cached()));\n-        this.cp = ConstantPoolBuilder.of(TEMPLATE);\n-        this.classEntry = cp.classEntry(ClassDesc.of(className));\n+        this.cp = ConstantPoolBuilder.of();\n+        this.classEntry = cp.classEntry(ReferenceClassDescImpl.ofValidatedBinaryName(className));\n@@ -266,0 +169,9 @@\n+        this.throwableStack = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(cp.classEntry(CD_Throwable)));\n+        this.exInit = cp.nameAndTypeEntry(INIT_NAME, MTD_void_String);\n+        this.object = cp.classEntry(CD_Object);\n+        this.proxy = cp.classEntry(CD_Proxy);\n+        this.handlerField = cp.fieldRefEntry(proxy, cp.nameAndTypeEntry(NAME_HANDLER_FIELD, CD_InvocationHandler));\n+        this.invoke = cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray);\n+        this.ute = cp.classEntry(CD_UndeclaredThrowableException);\n+        this.uteInit = cp.methodRefEntry(ute, cp.nameAndTypeEntry(INIT_NAME, MTD_void_Throwable));\n+        this.bsm = ConstantDescs.ofConstantBootstrap(classEntry.asSymbol(), \"$getMethod\", CD_Method, CD_Class, CD_String, CD_MethodType);\n@@ -284,1 +196,1 @@\n-        if (saveGeneratedFiles) {\n+        if (SAVE_GENERATED_FILES) {\n@@ -315,4 +227,4 @@\n-    private static ClassEntry[] toClassEntries(ConstantPoolBuilder cp, List<Class<?>> types) {\n-        var ces = new ClassEntry[types.size()];\n-        for (int i = 0; i < ces.length; i++)\n-            ces[i] = cp.classEntry(cp.utf8Entry(types.get(i).getName().replace('.', '\/')));\n+    private static List<ClassEntry> toClassEntries(ConstantPoolBuilder cp, List<Class<?>> types) {\n+        var ces = new ArrayList<ClassEntry>(types.size());\n+        for (var t : types)\n+            ces.add(cp.classEntry(ReferenceClassDescImpl.ofValidatedBinaryName(t.getName())));\n@@ -532,3 +444,3 @@\n-        addProxyMethod(hashCodeMethod);\n-        addProxyMethod(equalsMethod);\n-        addProxyMethod(toStringMethod);\n+        addProxyMethod(HASH_CODE_METHOD);\n+        addProxyMethod(EQUALS_METHOD);\n+        addProxyMethod(TO_STRING_METHOD);\n@@ -542,1 +454,1 @@\n-                    addProxyMethod(m, intf, cp);\n+                    addProxyMethod(m, intf);\n@@ -555,2 +467,2 @@\n-        return classfileContext.build(classEntry, cp, clb -> {\n-            TEMPLATE.forEach(clb);\n+        return CF_CONTEXT.build(classEntry, cp, clb -> {\n+            clb.withSuperclass(proxy);\n@@ -559,0 +471,1 @@\n+            generateConstructor(clb);\n@@ -562,3 +475,0 @@\n-                    \/\/ add static field for the Method object\n-                    clb.withField(pm.methodFieldName, UE_Method, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n-\n@@ -566,1 +476,1 @@\n-                    pm.generateMethod(clb, classEntry);\n+                    pm.generateMethod(this, clb);\n@@ -570,1 +480,2 @@\n-            generateStaticInitializer(clb);\n+            generateBootstrapMethod(clb);\n+            generateLookupAccessor(clb);\n@@ -587,1 +498,1 @@\n-    private void addProxyMethod(Method m, Class<?> fromClass, ConstantPoolBuilder cp) {\n+    private void addProxyMethod(Method m, Class<?> fromClass) {\n@@ -612,2 +523,1 @@\n-                exceptionTypes, fromClass,\n-                cp.utf8Entry(\"m\" + proxyMethodCount++)));\n+                exceptionTypes, fromClass));\n@@ -631,1 +541,1 @@\n-    private static void generateConstructor(ClassBuilder clb) {\n+    private void generateConstructor(ClassBuilder clb) {\n@@ -633,3 +543,3 @@\n-               .aload(cob.receiverSlot())\n-               .aload(cob.parameterSlot(0))\n-               .invokespecial(CD_Proxy, INIT_NAME, MTD_void_InvocationHandler)\n+               .aload(0)\n+               .aload(1)\n+               .invokespecial(cp.methodRefEntry(proxy, cp.nameAndTypeEntry(INIT_NAME, MTD_void_InvocationHandler)))\n@@ -640,1 +550,1 @@\n-     * Generate the static initializer method for the proxy class.\n+     * Generate CONDY bootstrap method for the proxy class to retrieve {@link Method} instances.\n@@ -642,17 +552,12 @@\n-    private void generateStaticInitializer(ClassBuilder clb) {\n-        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n-            \/\/ Put ClassLoader at local variable index 0, used by\n-            \/\/ Class.forName(String, boolean, ClassLoader) calls\n-            cob.ldc(classEntry)\n-               .invokevirtual(MRE_Class_getClassLoader)\n-               .astore(0);\n-            var ts = cob.newBoundLabel();\n-            for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n-                for (ProxyMethod pm : sigmethods) {\n-                    pm.codeFieldInitialization(cob, classEntry);\n-                }\n-            }\n-            cob.return_();\n-            var c1 = cob.newBoundLabel();\n-            cob.exceptionCatch(ts, c1, c1, CE_NoSuchMethodException)\n-               .new_(CE_NoSuchMethodError)\n+    private void generateBootstrapMethod(ClassBuilder clb) {\n+        clb.withMethodBody(bsm.methodName(), bsm.invocationType(), ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC, cob -> {\n+            cob.aload(3) \/\/interface Class\n+               .aload(4) \/\/interface method name String\n+               .aload(5) \/\/interface MethodType\n+               .invokevirtual(CD_MethodType, \"parameterArray\", MTD_Class_array)\n+               .invokevirtual(ConstantDescs.CD_Class, \"getMethod\", MTD_Method_String_Class_array)\n+               .areturn();\n+            Label failLabel = cob.newBoundLabel();\n+            ClassEntry nsme = cp.classEntry(CD_NoSuchMethodError);\n+            cob.exceptionCatch(cob.startLabel(), failLabel, failLabel, CD_NoSuchMethodException)\n+               .new_(nsme)\n@@ -661,10 +566,2 @@\n-               .invokevirtual(MRE_Throwable_getMessage)\n-               .invokespecial(MRE_NoSuchMethodError_init)\n-               .athrow();\n-            var c2 = cob.newBoundLabel();\n-            cob.exceptionCatch(ts, c1, c2, CE_ClassNotFoundException)\n-               .new_(CE_NoClassDefFoundError)\n-               .dup_x1()\n-               .swap()\n-               .invokevirtual(MRE_Throwable_getMessage)\n-               .invokespecial(MRE_NoClassDefFoundError_init)\n+               .invokevirtual(cp.methodRefEntry(CD_Throwable, \"getMessage\", MTD_String))\n+               .invokespecial(cp.methodRefEntry(nsme, exInit))\n@@ -673,2 +570,1 @@\n-                     StackMapFrameInfo.of(c1, List.of(), THROWABLE_STACK),\n-                     StackMapFrameInfo.of(c2, List.of(), THROWABLE_STACK))));\n+                       StackMapFrameInfo.of(failLabel, List.of(), throwableStack))));\n@@ -683,1 +579,1 @@\n-    private static void generateLookupAccessor(ClassBuilder clb) {\n+    private void generateLookupAccessor(ClassBuilder clb) {\n@@ -688,17 +584,25 @@\n-                        .withCode(cob -> cob\n-                            .block(blockBuilder -> blockBuilder\n-                                    .aload(cob.parameterSlot(0))\n-                                    .invokevirtual(CD_MethodHandles_Lookup, \"lookupClass\", MTD_Class)\n-                                    .ldc(CD_Proxy)\n-                                    .if_acmpne(blockBuilder.breakLabel())\n-                                    .aload(cob.parameterSlot(0))\n-                                    .invokevirtual(CD_MethodHandles_Lookup, \"hasFullPrivilegeAccess\", MTD_boolean)\n-                                    .ifeq(blockBuilder.breakLabel())\n-                                    .invokestatic(CD_MethodHandles, \"lookup\", MTD_MethodHandles$Lookup)\n-                                    .areturn())\n-                            .new_(CD_IllegalAccessException)\n-                            .dup()\n-                            .aload(cob.parameterSlot(0))\n-                            .invokevirtual(CD_MethodHandles_Lookup, \"toString\", MTD_String)\n-                            .invokespecial(CD_IllegalAccessException, INIT_NAME, MTD_void_String)\n-                            .athrow()));\n+                        .withCode(cob -> {\n+                            Label failLabel = cob.newLabel();\n+                            ClassEntry mhl = cp.classEntry(CD_MethodHandles_Lookup);\n+                            ClassEntry iae = cp.classEntry(CD_IllegalAccessException);\n+                            cob.aload(cob.parameterSlot(0))\n+                               .invokevirtual(cp.methodRefEntry(mhl, cp.nameAndTypeEntry(\"lookupClass\", MTD_Class)))\n+                               .ldc(proxy)\n+                               .if_acmpne(failLabel)\n+                               .aload(cob.parameterSlot(0))\n+                               .invokevirtual(cp.methodRefEntry(mhl, cp.nameAndTypeEntry(\"hasFullPrivilegeAccess\", MTD_boolean)))\n+                               .ifeq(failLabel)\n+                               .invokestatic(CD_MethodHandles, \"lookup\", MTD_MethodHandles$Lookup)\n+                               .areturn()\n+                               .labelBinding(failLabel)\n+                               .new_(iae)\n+                               .dup()\n+                               .aload(cob.parameterSlot(0))\n+                               .invokevirtual(cp.methodRefEntry(mhl, cp.nameAndTypeEntry(\"toString\", MTD_String)))\n+                               .invokespecial(cp.methodRefEntry(iae, exInit))\n+                               .athrow()\n+                               .with(StackMapTableAttribute.of(List.of(\n+                                       StackMapFrameInfo.of(failLabel,\n+                                               List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(mhl)),\n+                                               List.of()))));\n+                        }));\n@@ -719,1 +623,0 @@\n-        private final Utf8Entry methodFieldName;\n@@ -724,1 +627,1 @@\n-                            Class<?> fromClass, Utf8Entry methodFieldName) {\n+                            Class<?> fromClass) {\n@@ -731,1 +634,0 @@\n-            this.methodFieldName = methodFieldName;\n@@ -740,1 +642,1 @@\n-        private ProxyMethod(Method method, Utf8Entry methodFieldName) {\n+        private ProxyMethod(Method method) {\n@@ -743,1 +645,1 @@\n-                 method.getSharedExceptionTypes(), method.getDeclaringClass(), methodFieldName);\n+                 method.getSharedExceptionTypes(), method.getDeclaringClass());\n@@ -749,4 +651,7 @@\n-        private void generateMethod(ClassBuilder clb, ClassEntry className) {\n-            var cp = clb.constantPool();\n-            MethodTypeDesc desc = MethodTypeDesc.of(toClassDesc(returnType),\n-                    Arrays.stream(parameterTypes).map(ProxyGenerator::toClassDesc).toArray(ClassDesc[]::new));\n+        private void generateMethod(ProxyGenerator pg, ClassBuilder clb) {\n+            var cp = pg.cp;\n+            var pTypes = new ClassDesc[parameterTypes.length];\n+            for (int i = 0; i < pTypes.length; i++) {\n+                pTypes[i] = toClassDesc(parameterTypes[i]);\n+            }\n+            MethodTypeDesc desc = MethodTypeDescImpl.ofTrusted(toClassDesc(returnType), pTypes);\n@@ -759,5 +664,7 @@\n-                        cob.aload(cob.receiverSlot())\n-                           .getfield(FRE_Proxy_h)\n-                           .aload(cob.receiverSlot())\n-                           .getstatic(cp.fieldRefEntry(className, cp.nameAndTypeEntry(methodFieldName, UE_Method)));\n-\n+                        cob.aload(0)\n+                           .getfield(pg.handlerField)\n+                           .aload(0)\n+                           .ldc(DynamicConstantDesc.of(pg.bsm,\n+                                toClassDesc(fromClass),\n+                                method.getName(),\n+                                desc));\n@@ -767,1 +674,1 @@\n-                               .anewarray(CE_Object);\n+                               .anewarray(pg.object);\n@@ -778,1 +685,1 @@\n-                        cob.invokeinterface(IMRE_InvocationHandler_invoke);\n+                        cob.invokeinterface(pg.invoke);\n@@ -794,1 +701,1 @@\n-                               .new_(CE_UndeclaredThrowableException)\n+                               .new_(pg.ute)\n@@ -797,1 +704,1 @@\n-                               .invokespecial(MRE_UndeclaredThrowableException_init)\n+                               .invokespecial(pg.uteInit)\n@@ -800,2 +707,2 @@\n-                                    StackMapFrameInfo.of(c1, List.of(), THROWABLE_STACK),\n-                                    StackMapFrameInfo.of(c2, List.of(), THROWABLE_STACK))));\n+                                       StackMapFrameInfo.of(c1, List.of(), pg.throwableStack),\n+                                       StackMapFrameInfo.of(c2, List.of(), pg.throwableStack))));\n@@ -816,1 +723,1 @@\n-                cob.invokestatic(prim.wrapperMethodRef);\n+                cob.invokestatic(prim.wrapperMethodRef(cob.constantPool()));\n@@ -832,1 +739,1 @@\n-                   .invokevirtual(prim.unwrapMethodRef)\n+                   .invokevirtual(prim.unwrapMethodRef(cob.constantPool()))\n@@ -840,48 +747,0 @@\n-        \/**\n-         * Generate code for initializing the static field that stores\n-         * the Method object for this proxy method. A class loader is\n-         * anticipated at local variable index 0.\n-         *\/\n-        private void codeFieldInitialization(CodeBuilder cob, ClassEntry className) {\n-            var cp = cob.constantPool();\n-            codeClassForName(cob, fromClass);\n-\n-            cob.ldc(method.getName())\n-               .loadConstant(parameterTypes.length)\n-               .anewarray(CE_Class);\n-\n-            \/\/ Construct an array with the parameter types mapping primitives to Wrapper types\n-            for (int i = 0; i < parameterTypes.length; i++) {\n-                cob.dup()\n-                   .loadConstant(i);\n-                if (parameterTypes[i].isPrimitive()) {\n-                    PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(parameterTypes[i]);\n-                    cob.getstatic(prim.typeFieldRef);\n-                } else {\n-                    codeClassForName(cob, parameterTypes[i]);\n-                }\n-                cob.aastore();\n-            }\n-            \/\/ lookup the method\n-            cob.invokevirtual(MRE_Class_getMethod)\n-               .putstatic(cp.fieldRefEntry(className, cp.nameAndTypeEntry(methodFieldName, UE_Method)));\n-        }\n-\n-        \/*\n-         * =============== Code Generation Utility Methods ===============\n-         *\/\n-\n-        \/**\n-         * Generate code to invoke the Class.forName with the name of the given\n-         * class to get its Class object at runtime.  The code is written to\n-         * the supplied stream.  Note that the code generated by this method\n-         * may cause the checked ClassNotFoundException to be thrown. A class\n-         * loader is anticipated at local variable index 0.\n-         *\/\n-        private void codeClassForName(CodeBuilder cob, Class<?> cl) {\n-            cob.ldc(cl.getName())\n-               .iconst_0() \/\/ false\n-               .aload(0)\/\/ classLoader\n-               .invokestatic(MRE_Class_forName);\n-        }\n-\n@@ -894,1 +753,0 @@\n-    private static final ConstantPoolBuilder CP = ConstantPoolBuilder.of();\n@@ -911,1 +769,1 @@\n-         * CP entry of corresponding wrapper class\n+         * wrapper class\n@@ -913,1 +771,1 @@\n-        private final ClassEntry wrapperClass;\n+        private final ClassDesc wrapperClass;\n@@ -915,1 +773,1 @@\n-         * CP entry for wrapper class \"valueOf\" factory method\n+         * wrapper factory method type\n@@ -917,1 +775,1 @@\n-        private final MethodRefEntry wrapperMethodRef;\n+        private final MethodTypeDesc wrapperMethodType;\n@@ -919,1 +777,1 @@\n-         * CP entry of wrapper class method for retrieving primitive value\n+         * wrapper class method name for retrieving primitive value\n@@ -921,1 +779,1 @@\n-        private final MethodRefEntry unwrapMethodRef;\n+        private final String unwrapMethodName;\n@@ -923,1 +781,1 @@\n-         * CP entry of wrapper class TYPE field\n+         * wrapper class method type for retrieving primitive value\n@@ -925,1 +783,1 @@\n-        private final FieldRefEntry typeFieldRef;\n+        private final MethodTypeDesc unwrapMethodType;\n@@ -929,4 +787,4 @@\n-            this.wrapperClass = CP.classEntry(wrapperClass);\n-            this.wrapperMethodRef = CP.methodRefEntry(wrapperClass, \"valueOf\", MethodTypeDesc.of(wrapperClass, baseType));\n-            this.unwrapMethodRef = CP.methodRefEntry(wrapperClass, primitiveClass.getName() + \"Value\", MethodTypeDesc.of(baseType));\n-            this.typeFieldRef = CP.fieldRefEntry(wrapperClass, \"TYPE\", CD_Class);\n+            this.wrapperClass = wrapperClass;\n+            this.wrapperMethodType = MethodTypeDescImpl.ofValidated(wrapperClass, new ClassDesc[]{baseType});\n+            this.unwrapMethodName = primitiveClass.getName() + \"Value\";\n+            this.unwrapMethodType = MethodTypeDescImpl.ofValidated(baseType, ConstantUtils.EMPTY_CLASSDESC);\n@@ -947,0 +805,8 @@\n+\n+        public MethodRefEntry wrapperMethodRef(ConstantPoolBuilder cp) {\n+            return cp.methodRefEntry(wrapperClass, \"valueOf\", wrapperMethodType);\n+        }\n+\n+        public MethodRefEntry unwrapMethodRef(ConstantPoolBuilder cp) {\n+            return cp.methodRefEntry(wrapperClass, unwrapMethodName, unwrapMethodType);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":173,"deletions":307,"binary":false,"changes":480,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,7 @@\n+import java.lang.classfile.BufWriter;\n+import java.lang.classfile.ClassReader;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapFrameInfo.*;\n+import java.lang.classfile.constantpool.ClassEntry;\n@@ -32,0 +39,1 @@\n+import java.util.Objects;\n@@ -33,6 +41,0 @@\n-import java.lang.classfile.BufWriter;\n-\n-import java.lang.classfile.constantpool.ClassEntry;\n-import java.lang.classfile.attribute.StackMapFrameInfo;\n-import java.lang.classfile.attribute.StackMapFrameInfo.*;\n-import java.lang.classfile.ClassReader;\n@@ -41,2 +43,0 @@\n-import java.lang.classfile.Label;\n-import java.lang.classfile.MethodModel;\n@@ -246,0 +246,14 @@\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o instanceof ObjectVerificationTypeInfoImpl that) {\n+                return Objects.equals(className, that.className);\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(className);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.reflect;\n+\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.SingleShotTime)\n+@Fork(1)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 10, time = 2)\n+@State(Scope.Benchmark)\n+public class ProxyGenBench {\n+\n+    static final Class<?>[] INTF = new Class<?>[]{Interfaze.class};\n+    static final IHandler HANDLER = new IHandler();\n+\n+    @Benchmark\n+    public void generate100Proxies() {\n+        for (int i = 0; i < 100; i++) {\n+            Proxy.newProxyInstance(new ClsLoader(), INTF, HANDLER);\n+        }\n+    }\n+\n+    public interface Interfaze {\n+        default int sum(int a, int b, int c) {\n+            return a + b + c;\n+        }\n+    }\n+\n+    static class IHandler implements InvocationHandler {\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    static class ClsLoader extends ClassLoader {\n+\n+        public ClsLoader() {\n+            super(Interfaze.class.getClassLoader());\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new ProxyGenBench().generate100Proxies();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/ProxyGenBench.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"}]}