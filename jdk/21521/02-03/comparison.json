{"files":[{"patch":"@@ -359,2 +359,2 @@\n-          \"if >0, auto-vectorization detects possible store-to-load\"        \\\n-          \"forwarding failures. The number specifies over how many\"         \\\n+          \"if >0, auto-vectorization detects possible store-to-load \"       \\\n+          \"forwarding failures. The number specifies over how many \"        \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -186,3 +186,3 @@\n-      int r1_inva_idx = r1->invar() == nullptr ? 0 : r1->invar()->_idx;\n-      int r2_inva_idx = r2->invar() == nullptr ? 0 : r2->invar()->_idx;\n-      RETURN_CMP_VALUE_IF_NOT_EQUAL(r1_inva_idx,      r2_inva_idx);\n+      int r1_invar_idx = r1->invar() == nullptr ? 0 : r1->invar()->_idx;\n+      int r2_invar_idx = r2->invar() == nullptr ? 0 : r2->invar()->_idx;\n+      RETURN_CMP_VALUE_IF_NOT_EQUAL(r1_invar_idx,      r2_invar_idx);\n@@ -234,1 +234,1 @@\n-\/\/ Generally, Store-to-load forwarding works if the load and store memory regions match\n+\/\/ Generally, store-to-load-forwarding works if the load and store memory regions match\n@@ -237,2 +237,2 @@\n-\/\/ all such partial overlaps lead to a store-to-load-forwarding failure, which means the\n-\/\/ load has to stall until the store goes from the store-buffer into the L1 cache, incuring\n+\/\/ all such partial overlaps lead to a store-to-load-forwarding failures, which means the\n+\/\/ load has to stall until the store goes from the store-buffer into the L1 cache, incurring\n@@ -247,1 +247,1 @@\n-\/\/ Assume we have a 2-element vectors (2*4 = 8 bytes). This gives us this machine code:\n+\/\/ Assume we have 2-element vectors (2*4 = 8 bytes). This gives us this machine code:\n@@ -259,3 +259,3 @@\n-\/\/ Preferrably, we would have some latency-based cost-model that accounts for such forwarding\n-\/\/ failures, and decides if vectorization with forwarding failures is still profitable. For\n-\/\/ now we go with a simpler huristic: we simply forbid vectorization if we can PROVE that\n+\/\/ Preferably, we would have some latency-based cost-model that accounts for such forwarding\n+\/\/ failures, and decide if vectorization with forwarding failures is still profitable. For\n+\/\/ now we go with a simpler heuristic: we simply forbid vectorization if we can PROVE that\n@@ -263,0 +263,1 @@\n+\/\/\n@@ -271,1 +272,1 @@\n-\/\/      to different arrays, where we would have no forwarding failures.\n+\/\/      to different arrays (i.e. no aliasing), where we would have no forwarding failures.\n@@ -297,1 +298,1 @@\n-  int order = 0;\n+  int schedule_order = 0;\n@@ -307,1 +308,1 @@\n-          records.push(VPointerRecord(p, iv_offset, vector_length, order++));\n+          records.push(VPointerRecord(p, iv_offset, vector_length, schedule_order++));\n@@ -313,1 +314,1 @@\n-  \/\/ Sort the pointers by group (same base, invar and stride), and by offset.\n+  \/\/ Sort the pointers by group (same base, invar and stride), and then by offset.\n@@ -328,1 +329,1 @@\n-  \/\/ For all pairs of pointers in the same group, check if they have partial overlap.\n+  \/\/ For all pairs of pointers in the same group, check if they have a partial overlap.\n@@ -332,1 +333,1 @@\n-    for(int j = i + 1; j < records.length(); j++) {\n+    for (int j = i + 1; j < records.length(); j++) {\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -138,1 +138,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorStoreToLoadForwarding.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}