{"files":[{"patch":"@@ -69,0 +69,1 @@\n+define_pd_global(uint, SuperWordStoreToLoadForwardingFailureDetection, 8);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_globals_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+define_pd_global(uint, SuperWordStoreToLoadForwardingFailureDetection, 16);\n","filename":"src\/hotspot\/cpu\/arm\/c2_globals_arm.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+define_pd_global(uint, SuperWordStoreToLoadForwardingFailureDetection, 16);\n","filename":"src\/hotspot\/cpu\/ppc\/c2_globals_ppc.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+define_pd_global(uint, SuperWordStoreToLoadForwardingFailureDetection, 16);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_globals_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+define_pd_global(uint, SuperWordStoreToLoadForwardingFailureDetection, 16);\n","filename":"src\/hotspot\/cpu\/s390\/c2_globals_s390.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+define_pd_global(uint, SuperWordStoreToLoadForwardingFailureDetection, 16);\n","filename":"src\/hotspot\/cpu\/x86\/c2_globals_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -358,0 +358,6 @@\n+  product_pd(uint, SuperWordStoreToLoadForwardingFailureDetection, DIAGNOSTIC, \\\n+          \"if >0, auto-vectorization detects possible store-to-load\"        \\\n+          \"forwarding failures. The number specifies over how many\"         \\\n+          \"loop iterations this detection spans.\")                          \\\n+          range(0, 4096)                                                    \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1871,0 +1871,1 @@\n+  if (vtransform.has_store_to_load_forwarding_failure()) { return false; }\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-static void print_con_or_idx(const Node* n) {\n+void VPointer::print_con_or_idx(const Node* n) {\n@@ -1372,1 +1372,1 @@\n-  print_con_or_idx(_base);\n+  VPointer::print_con_or_idx(_base);\n@@ -1377,1 +1377,1 @@\n-  print_con_or_idx(_invar);\n+  VPointer::print_con_or_idx(_invar);\n@@ -2171,1 +2171,1 @@\n-    print_con_or_idx(_init_node);\n+    VPointer::print_con_or_idx(_init_node);\n@@ -2177,1 +2177,1 @@\n-    print_con_or_idx(_base);\n+    VPointer::print_con_or_idx(_base);\n@@ -2179,1 +2179,1 @@\n-    print_con_or_idx(_invar);\n+    VPointer::print_con_or_idx(_invar);\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -873,0 +873,1 @@\n+  NOT_PRODUCT( static void print_con_or_idx(const Node* n); )\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -147,0 +147,218 @@\n+\/\/ We use two comparisons, because a subtraction could underflow.\n+#define RETURN_CMP_VALUE_IF_NOT_EQUAL(a, b) \\\n+  if (a < b) { return -1; }                 \\\n+  if (a > b) { return  1; }\n+\n+\/\/ Helper-class for VTransformGraph::has_store_to_load_forwarding_failure.\n+\/\/ It represents a memory region: [ptr, ptr + memory_size)\n+class VPointerRecord : public StackObj {\n+private:\n+  Node* _base;        \/\/ ptr = base + offset + invar + scale * iv\n+  int _scale;\n+  Node* _invar;\n+  int _offset;\n+  uint _memory_size;\n+  bool _is_load;      \/\/ load or store?\n+  uint _order;        \/\/ order in schedule\n+\n+public:\n+  VPointerRecord() {} \/\/ empty constructor for GrowableArray\n+  VPointerRecord(const VPointer& vpointer, int iv_offset, int vector_length, uint order) :\n+    _base(vpointer.base()),\n+    _scale(vpointer.scale_in_bytes()),\n+    _invar(vpointer.invar()),\n+    _offset(vpointer.offset_in_bytes() + _scale * iv_offset),\n+    _memory_size(vpointer.memory_size() * vector_length),\n+    _is_load(vpointer.mem()->is_Load()),\n+    _order(order) {}\n+\n+    Node* base()       const { return _base; }\n+    int scale()        const { return _scale; }\n+    Node* invar()      const { return _invar; }\n+    int offset()       const { return _offset; }\n+    uint memory_size() const { return _memory_size; }\n+    bool is_load()     const { return _is_load; }\n+    uint order()       const { return _order; }\n+\n+    static int cmp_for_sort_by_group(VPointerRecord* r1, VPointerRecord* r2) {\n+      RETURN_CMP_VALUE_IF_NOT_EQUAL(r1->base()->_idx, r2->base()->_idx);\n+      RETURN_CMP_VALUE_IF_NOT_EQUAL(r1->scale(),      r2->scale());\n+      int r1_inva_idx = r1->invar() == nullptr ? 0 : r1->invar()->_idx;\n+      int r2_inva_idx = r2->invar() == nullptr ? 0 : r2->invar()->_idx;\n+      RETURN_CMP_VALUE_IF_NOT_EQUAL(r1_inva_idx,      r2_inva_idx);\n+      return 0; \/\/ equal\n+    }\n+\n+    static int cmp_for_sort(VPointerRecord* r1, VPointerRecord* r2) {\n+      int cmp_group = cmp_for_sort_by_group(r1, r2);\n+      if (cmp_group != 0) { return cmp_group; }\n+\n+      RETURN_CMP_VALUE_IF_NOT_EQUAL(r1->offset(),     r2->offset());\n+      return 0; \/\/ equal\n+    }\n+\n+    enum Aliasing { DIFFERENT_GROUP, BEFORE, EXACT_OVERLAP, PARTIAL_OVERLAP, AFTER };\n+\n+    Aliasing aliasing(VPointerRecord& other) {\n+      VPointerRecord* p1 = this;\n+      VPointerRecord* p2 = &other;\n+      if (cmp_for_sort_by_group(p1, p2) != 0) { return DIFFERENT_GROUP; }\n+\n+      jlong offset1 = p1->offset();\n+      jlong offset2 = p2->offset();\n+      jlong memory_size1 = p1->memory_size();\n+      jlong memory_size2 = p2->memory_size();\n+\n+      if (offset1 >= offset2 + memory_size2) { return AFTER; }\n+      if (offset2 >= offset1 + memory_size1) { return BEFORE; }\n+      if (offset1 == offset2 && memory_size1 == memory_size2) { return EXACT_OVERLAP; }\n+      return PARTIAL_OVERLAP;\n+    }\n+\n+#ifndef PRODUCT\n+  void print() const {\n+    tty->print(\"VPointerRecord[%s %dbytes, order(%4d), base\",\n+               _is_load ? \"load \" : \"store\", _memory_size, _order);\n+    VPointer::print_con_or_idx(_base);\n+    tty->print(\" + offset(%4d)\", _offset);\n+    tty->print(\" + invar\");\n+    VPointer::print_con_or_idx(_invar);\n+    tty->print_cr(\" + scale(%4d) * iv]\", _scale);\n+  }\n+#endif\n+};\n+\n+\/\/ Store-to-load-forwarding is a CPU memory optimization, where a load can directly fetch\n+\/\/ its value from the store-buffer, rather than from the L1 cache. This is many CPU cycles\n+\/\/ faster. However, this optimization comes with some restrictions, depending on the CPU.\n+\/\/ Generally, Store-to-load forwarding works if the load and store memory regions match\n+\/\/ exactly (same start and width). Generally problematic are partial overlaps - though\n+\/\/ some CPU's can handle even some subsets of these cases. We conservatively assume that\n+\/\/ all such partial overlaps lead to a store-to-load-forwarding failure, which means the\n+\/\/ load has to stall until the store goes from the store-buffer into the L1 cache, incuring\n+\/\/ a penalty of many CPU cycles.\n+\/\/\n+\/\/ Unfortunately, vectorization can introduce such store-to-load-forwarding failures.\n+\/\/ Example:\n+\/\/   for (int i = 10; i < SIZE; i++) {\n+\/\/       aI[i] = aI[i - 3] + 1;\n+\/\/   }\n+\/\/\n+\/\/ Assume we have a 2-element vectors (2*4 = 8 bytes). This gives us this machine code:\n+\/\/   load_8_bytes( ptr + -12)\n+\/\/   store_8_bytes(ptr + 0)\n+\/\/   load_8_bytes( ptr + -4)\n+\/\/   store_8_bytes(ptr + 8)\n+\/\/   load_8_bytes( ptr + 4)\n+\/\/   store_8_bytes(ptr + 16)\n+\/\/   ...\n+\/\/\n+\/\/ We see that eventually all loads are dependent on earlier stores, but the values cannot\n+\/\/ be forwarded because there is some partial overlap.\n+\/\/\n+\/\/ Preferrably, we would have some latency-based cost-model that accounts for such forwarding\n+\/\/ failures, and decides if vectorization with forwarding failures is still profitable. For\n+\/\/ now we go with a simpler huristic: we simply forbid vectorization if we can PROVE that\n+\/\/ there will be a forwarding failure. This approach has at least 2 possible weaknesses:\n+\/\/  (1) There may be forwarding failures in cases where we cannot prove it.\n+\/\/      Example:\n+\/\/        for (int i = 10; i < SIZE; i++) {\n+\/\/            bI[i] = aI[i - 3] + 1;\n+\/\/        }\n+\/\/\n+\/\/      We do not know if aI and bI refer to the same array or not. However, it is reasonable\n+\/\/      to assume that if we have two different array references, that they most likely refer\n+\/\/      to different arrays, where we would have no forwarding failures.\n+\/\/  (2) There could be some loops where vectorization introduces forwarding failures, and thus\n+\/\/      the latency of the loop body is high, but this does not matter because it is dominated\n+\/\/      by other latency\/throughput based costs in the loop body.\n+\/\/\n+\/\/ Performance measurements with the JMH benchmark StoreToLoadForwarding.java have indicated\n+\/\/ that there is some iteration threshold: if the failure happens between a store and load that\n+\/\/ have an iteration distance below this threshold, the latency is the limiting factor, and we\n+\/\/ should not vectorize to avoid the latency penalty of store-to-load-forwarding failures. If\n+\/\/ the iteration distance is larger than this threshold, the throughput is the limiting factor,\n+\/\/ and we should vectorize in these cases to improve throughput.\n+\/\/\n+bool VTransformGraph::has_store_to_load_forwarding_failure(const VLoopAnalyzer& vloop_analyzer) const {\n+  if (SuperWordStoreToLoadForwardingFailureDetection == 0) { return false; }\n+\n+  \/\/ Collect all pointers for scalar and vector loads\/stores.\n+  ResourceMark rm;\n+  GrowableArray<VPointerRecord> records;\n+\n+  \/\/ To detect store-to-load-forwarding failures at the iteration threshold or below, we\n+  \/\/ simulate a super-unrolling to reach SuperWordStoreToLoadForwardingFailureDetection\n+  \/\/ iterations at least.\n+  int simulated_unrolling_count = SuperWordStoreToLoadForwardingFailureDetection;\n+  int unrolled_count = vloop_analyzer.vloop().cl()->unrolled_count();\n+  uint simulated_super_unrolling_count = MAX2(1, simulated_unrolling_count \/ unrolled_count);\n+  int iv_stride = vloop_analyzer.vloop().iv_stride();\n+  int order = 0;\n+  for (uint k = 0; k < simulated_super_unrolling_count; k++) {\n+    int iv_offset = k * iv_stride; \/\/ virtual super-unrolling\n+    for (int i = 0; i < _schedule.length(); i++) {\n+      VTransformNode* vtn = _schedule.at(i);\n+      if (vtn->is_load_or_store_in_loop()) {\n+        const VPointer& p = vtn->vpointer(vloop_analyzer);\n+        if (p.valid()) {\n+          VTransformVectorNode* vector = vtn->isa_Vector();\n+          uint vector_length = vector != nullptr ? vector->nodes().length() : 1;\n+          records.push(VPointerRecord(p, iv_offset, vector_length, order++));\n+        }\n+      }\n+    }\n+  }\n+\n+  \/\/ Sort the pointers by group (same base, invar and stride), and by offset.\n+  records.sort(VPointerRecord::cmp_for_sort);\n+\n+#ifndef PRODUCT\n+  if (_trace._verbose) {\n+    tty->print_cr(\"VTransformGraph::has_store_to_load_forwarding_failure:\");\n+    tty->print_cr(\"  simulated_unrolling_count = %d\", simulated_unrolling_count);\n+    tty->print_cr(\"  simulated_super_unrolling_count = %d\", simulated_super_unrolling_count);\n+    for (int i = 0; i < records.length(); i++) {\n+      VPointerRecord& record = records.at(i);\n+      record.print();\n+    }\n+  }\n+#endif\n+\n+  \/\/ For all pairs of pointers in the same group, check if they have partial overlap.\n+  for (int i = 0; i < records.length(); i++) {\n+    VPointerRecord& record1 = records.at(i);\n+\n+    for(int j = i + 1; j < records.length(); j++) {\n+      VPointerRecord& record2 = records.at(j);\n+\n+      const VPointerRecord::Aliasing aliasing = record1.aliasing(record2);\n+      if (aliasing == VPointerRecord::Aliasing::DIFFERENT_GROUP ||\n+          aliasing == VPointerRecord::Aliasing::BEFORE) {\n+        break; \/\/ We have reached the next group or pointers that are always after.\n+      } else if (aliasing == VPointerRecord::Aliasing::EXACT_OVERLAP) {\n+        continue;\n+      } else {\n+        assert(aliasing == VPointerRecord::Aliasing::PARTIAL_OVERLAP, \"no other case can happen\");\n+        if ((record1.is_load() && !record2.is_load() && record1.order() > record2.order()) ||\n+            (!record1.is_load() && record2.is_load() && record1.order() < record2.order())) {\n+          \/\/ We predict that this leads to a store-to-load-forwarding failure penalty.\n+#ifndef PRODUCT\n+          if (_trace._rejections) {\n+            tty->print_cr(\"VTransformGraph::has_store_to_load_forwarding_failure:\");\n+            tty->print_cr(\"  Partial overlap of store->load. We predict that this leads to\");\n+            tty->print_cr(\"  a store-to-load-forwarding failure penalty which makes\");\n+            tty->print_cr(\"  vectorization unprofitable. These are the two pointers:\");\n+            record1.print();\n+            record2.print();\n+          }\n+#endif\n+          return true;\n+        }\n+      }\n+    }\n+  }\n+\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":218,"deletions":0,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+class VTransformLoadVectorNode;\n+class VTransformStoreVectorNode;\n@@ -160,0 +162,1 @@\n+  bool has_store_to_load_forwarding_failure(const VLoopAnalyzer& vloop_analyzer) const;\n@@ -224,0 +227,1 @@\n+  bool has_store_to_load_forwarding_failure() const { return _graph.has_store_to_load_forwarding_failure(_vloop_analyzer); }\n@@ -313,0 +317,5 @@\n+  virtual VTransformLoadVectorNode* isa_LoadVector() { return nullptr; }\n+  virtual VTransformStoreVectorNode* isa_StoreVector() { return nullptr; }\n+\n+  virtual bool is_load_or_store_in_loop() const { return false; }\n+  virtual const VPointer& vpointer(const VLoopAnalyzer& vloop_analyzer) const { ShouldNotReachHere(); }\n@@ -336,0 +345,2 @@\n+  virtual bool is_load_or_store_in_loop() const override { return _node->is_Load() || _node->is_Store(); }\n+  virtual const VPointer& vpointer(const VLoopAnalyzer& vloop_analyzer) const override { return vloop_analyzer.vpointers().vpointer(node()->as_Mem()); }\n@@ -350,0 +361,1 @@\n+  virtual bool is_load_or_store_in_loop() const override { return false; }\n@@ -475,0 +487,3 @@\n+  virtual VTransformLoadVectorNode* isa_LoadVector() override { return this; }\n+  virtual bool is_load_or_store_in_loop() const override { return true; }\n+  virtual const VPointer& vpointer(const VLoopAnalyzer& vloop_analyzer) const override { return vloop_analyzer.vpointers().vpointer(nodes().at(0)->as_Mem()); }\n@@ -485,0 +500,3 @@\n+  virtual VTransformStoreVectorNode* isa_StoreVector() override { return this; }\n+  virtual bool is_load_or_store_in_loop() const override { return true; }\n+  virtual const VPointer& vpointer(const VLoopAnalyzer& vloop_analyzer) const override { return vloop_analyzer.vpointers().vpointer(nodes().at(0)->as_Mem()); }\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -171,0 +171,3 @@\n+        tests.put(\"test14dB\",    () -> { return test14dB(aB.clone()); });\n+        tests.put(\"test14eB\",    () -> { return test14eB(aB.clone()); });\n+        tests.put(\"test14fB\",    () -> { return test14fB(aB.clone()); });\n@@ -242,0 +245,3 @@\n+                 \"test14dB\",\n+                 \"test14eB\",\n+                 \"test14fB\",\n@@ -1131,3 +1137,3 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n-                  IRNode.ADD_VB, \"> 0\",\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n@@ -1146,0 +1152,3 @@\n+            \/\/ Since the stride is shorter than the vector length, there will be always\n+            \/\/ partial overlap of loads with previous stores, this leads to failure in\n+            \/\/ store-to-load-forwarding -> vectorization not profitable.\n@@ -1167,3 +1176,3 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n-                  IRNode.ADD_VB, \"> 0\",\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n@@ -1182,0 +1191,3 @@\n+            \/\/ Since the stride is shorter than the vector length, there will be always\n+            \/\/ partial overlap of loads with previous stores, this leads to failure in\n+            \/\/ store-to-load-forwarding -> vectorization not profitable.\n@@ -1203,3 +1215,3 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n-                  IRNode.ADD_VB, \"> 0\",\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n@@ -1218,0 +1230,3 @@\n+            \/\/ Since the stride is shorter than the vector length, there will be always\n+            \/\/ partial overlap of loads with previous stores, this leads to failure in\n+            \/\/ store-to-load-forwarding -> vectorization not profitable.\n@@ -1238,0 +1253,84 @@\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_byte, 8)\", \"> 0\",\n+                  IRNode.ADD_VB,        IRNode.VECTOR_SIZE + \"min(max_byte, 8)\", \"> 0\",\n+                  IRNode.STORE_VECTOR,                                           \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test14dB(byte[] a) {\n+        \/\/ non-power-of-2 stride\n+        for (int i = 0; i < RANGE-20; i+=9) {\n+            a[i+0]++;\n+            a[i+1]++;\n+            a[i+2]++;\n+            a[i+3]++;\n+            a[i+4]++;\n+            a[i+5]++;\n+            a[i+6]++;\n+            a[i+7]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_byte, 8)\", \"> 0\",\n+                  IRNode.ADD_VB,        IRNode.VECTOR_SIZE + \"min(max_byte, 8)\", \"> 0\",\n+                  IRNode.STORE_VECTOR,                                           \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test14eB(byte[] a) {\n+        \/\/ non-power-of-2 stride\n+        for (int i = 0; i < RANGE-32; i+=11) {\n+            a[i+0]++;\n+            a[i+1]++;\n+            a[i+2]++;\n+            a[i+3]++;\n+            a[i+4]++;\n+            a[i+5]++;\n+            a[i+6]++;\n+            a[i+7]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE + \"min(max_byte, 8)\", \"> 0\",\n+                  IRNode.ADD_VB,        IRNode.VECTOR_SIZE + \"min(max_byte, 8)\", \"> 0\",\n+                  IRNode.STORE_VECTOR,                                           \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test14fB(byte[] a) {\n+        \/\/ non-power-of-2 stride\n+        for (int i = 0; i < RANGE-40; i+=12) {\n+            a[i+0]++;\n+            a[i+1]++;\n+            a[i+2]++;\n+            a[i+3]++;\n+            a[i+4]++;\n+            a[i+5]++;\n+            a[i+6]++;\n+            a[i+7]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVector.java","additions":108,"deletions":9,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -31,1 +31,6 @@\n- * @run driver TestCyclicDependency\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-AlignVector\n+ *                   TestCyclicDependency\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+AlignVector\n+ *                   TestCyclicDependency\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+AlignVector -XX:+VerifyAlignVector\n+ *                   TestCyclicDependency\n@@ -58,4 +63,14 @@\n-    int[] goldI7 = new int[RANGE];\n-    float[] goldF7 = new float[RANGE];\n-    int[] goldI8 = new int[RANGE];\n-    float[] goldF8 = new float[RANGE];\n+    int[] goldI7a = new int[RANGE];\n+    float[] goldF7a = new float[RANGE];\n+    int[] goldI7b = new int[RANGE];\n+    float[] goldF7b = new float[RANGE];\n+    float[] goldF7b_2 = new float[RANGE];\n+    int[] goldI7c = new int[RANGE];\n+    float[] goldF7c = new float[RANGE];\n+    int[] goldI8a = new int[RANGE];\n+    float[] goldF8a = new float[RANGE];\n+    int[] goldI8b = new int[RANGE];\n+    int[] goldI8b_2 = new int[RANGE];\n+    float[] goldF8b = new float[RANGE];\n+    int[] goldI8c = new int[RANGE];\n+    float[] goldF8c = new float[RANGE];\n@@ -98,6 +113,18 @@\n-        \/\/ test7\n-        init(goldI7, goldF7);\n-        test7(goldI7, goldF7);\n-        \/\/ test8\n-        init(goldI8, goldF8);\n-        test8(goldI8, goldF8);\n+        \/\/ test7a\n+        init(goldI7a, goldF7a);\n+        test7a(goldI7a, goldF7a);\n+        \/\/ test7b\n+        init(goldI7b, goldF7b, goldF7b_2);\n+        test7b(goldI7b, goldF7b, goldF7b_2);\n+        \/\/ test7c\n+        init(goldI7c, goldF7c);\n+        test7c(goldI7c, goldF7c, goldF7c);\n+        \/\/ test8a\n+        init(goldI8a, goldF8a);\n+        test8a(goldI8a, goldF8a);\n+        \/\/ test8b\n+        init(goldI8b, goldI8b_2, goldF8b);\n+        test8b(goldI8b, goldI8b_2, goldF8b);\n+        \/\/ test8c\n+        init(goldI8c, goldF8c);\n+        test8c(goldI8c, goldI8c, goldF8c);\n@@ -208,1 +235,1 @@\n-    @Run(test = \"test7\")\n+    @Run(test = \"test7a\")\n@@ -210,1 +237,1 @@\n-    public void runTest7() {\n+    public void runTest7a() {\n@@ -214,3 +241,3 @@\n-        test7(dataI, dataF);\n-        verifyI(\"test7\", dataI, goldI7);\n-        verifyF(\"test7\", dataF, goldF7);\n+        test7a(dataI, dataF);\n+        verifyI(\"test7a\", dataI, goldI7a);\n+        verifyF(\"test7a\", dataF, goldF7a);\n@@ -219,1 +246,1 @@\n-    @Run(test = \"test8\")\n+    @Run(test = \"test7b\")\n@@ -221,1 +248,49 @@\n-    public void runTest8() {\n+    public void runTest7b() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        float[] dataF_2 = new float[RANGE];\n+        init(dataI, dataF, dataF_2);\n+        test7b(dataI, dataF, dataF_2);\n+        verifyI(\"test7b\", dataI, goldI7b);\n+        verifyF(\"test7b\", dataF, goldF7b);\n+        verifyF(\"test7b\", dataF_2, goldF7b_2);\n+    }\n+\n+    @Run(test = \"test7c\")\n+    @Warmup(100)\n+    public void runTest7c() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test7c(dataI, dataF, dataF);\n+        verifyI(\"test7c\", dataI, goldI7c);\n+        verifyF(\"test7c\", dataF, goldF7c);\n+    }\n+\n+    @Run(test = \"test8a\")\n+    @Warmup(100)\n+    public void runTest8a() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test8a(dataI, dataF);\n+        verifyI(\"test8a\", dataI, goldI8a);\n+        verifyF(\"test8a\", dataF, goldF8a);\n+    }\n+\n+    @Run(test = \"test8b\")\n+    @Warmup(100)\n+    public void runTest8b() {\n+        int[] dataI = new int[RANGE];\n+        int[] dataI_2 = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataI_2, dataF);\n+        test8b(dataI, dataI_2, dataF);\n+        verifyI(\"test8b\", dataI, goldI8b);\n+        verifyI(\"test8b\", dataI_2, goldI8b_2);\n+        verifyF(\"test8b\", dataF, goldF8b);\n+    }\n+\n+    @Run(test = \"test8c\")\n+    @Warmup(100)\n+    public void runTest8c() {\n@@ -225,3 +300,3 @@\n-        test8(dataI, dataF);\n-        verifyI(\"test8\", dataI, goldI8);\n-        verifyF(\"test8\", dataF, goldF8);\n+        test8c(dataI, dataI, dataF);\n+        verifyI(\"test8c\", dataI, goldI8c);\n+        verifyF(\"test8c\", dataF, goldF8c);\n@@ -331,1 +406,2 @@\n-    @IR(counts = {IRNode.ADD_VI, \"> 0\"},\n+    @IR(counts = {IRNode.ADD_VI, \"= 0\",\n+                  IRNode.ADD_VF, \"= 0\"},\n@@ -334,0 +410,4 @@\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VF, \"= 0\"},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n@@ -335,1 +415,1 @@\n-    static void test7(int[] dataI, float[] dataF) {\n+    static void test7a(int[] dataI, float[] dataF) {\n@@ -338,2 +418,0 @@\n-            \/\/ write forward 3 -> cannot vectorize\n-            \/\/ separate types should make decision separately if they vectorize or not\n@@ -342,0 +420,6 @@\n+            \/\/ write forward 3:\n+            \/\/   AlignVector=true -> cannot vectorize because load and store cannot be both aligned\n+            \/\/   AlignVector=false -> could vectorize, but would get 2-element vectors where\n+            \/\/                        store-to-load-forwarding fails, because we have store-load\n+            \/\/                        dependencies that have partial overlap.\n+            \/\/                        -> all vectorization cancled.\n@@ -348,1 +432,28 @@\n-    @IR(counts = {IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\"},\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"2\", \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VF, \"= 0\"},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Some aarch64 machines have AlignVector == true, like ThunderX2\n+    static void test7b(int[] dataI, float[] dataF, float[] dataF_2) {\n+        for (int i = 0; i < RANGE - 32; i++) {\n+            \/\/ write forward 32 -> more than vector size -> can vectorize\n+            int v = dataI[i];\n+            dataI[i + 32] = v + 5;\n+            \/\/ write forward 3 to different array reference:\n+            \/\/   AlignVector=true -> cannot vectorize because load and store cannot be both aligned\n+            \/\/   AlignVector=false -> vectorizes because we cannot prove store-to-load forwarding\n+            \/\/                        failure. But we can only have 2-element vectors in case\n+            \/\/                        the two float-arrays reference the same array.\n+            \/\/                        Note: at runtime the float-arrays are always different.\n+            float f = dataF[i];\n+            dataF_2[i + 3] = f + 3.5f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"2\", \"> 0\"},\n@@ -351,0 +462,4 @@\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VF, \"= 0\"},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n@@ -352,1 +467,1 @@\n-    static void test8(int[] dataI, float[] dataF) {\n+    static void test7c(int[] dataI, float[] dataF, float[] dataF_2) {\n@@ -355,2 +470,31 @@\n-            \/\/ write forward 3 -> cannot vectorize\n-            \/\/ separate types should make decision separately if they vectorize or not\n+            int v = dataI[i];\n+            dataI[i + 32] = v + 5;\n+            \/\/ write forward 3 to different array reference:\n+            \/\/   AlignVector=true -> cannot vectorize because load and store cannot be both aligned\n+            \/\/   AlignVector=false -> vectorizes because we cannot prove store-to-load forwarding\n+            \/\/                        failure. But we can only have 2-element vectors in case\n+            \/\/                        the two float-arrays reference the same array.\n+            \/\/                        Note: at runtime the float-arrays are always the same.\n+            float f = dataF[i];\n+            dataF_2[i + 3] = f + 3.5f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"= 0\",\n+                  IRNode.ADD_VF, \"= 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, \"= 0\",\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\"},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Some aarch64 machines have AlignVector == true, like ThunderX2\n+    static void test8a(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE - 32; i++) {\n+            \/\/ write forward 3:\n+            \/\/   AlignVector=true -> cannot vectorize because load and store cannot be both aligned\n+            \/\/   AlignVector=false -> could vectorize, but would get 2-element vectors where\n+            \/\/                        store-to-load-forwarding fails, because we have store-load\n+            \/\/                        dependencies that have partial overlap.\n+            \/\/                        -> all vectorization cancled.\n@@ -359,0 +503,53 @@\n+            \/\/ write forward 32 -> more than vector size -> can vectorize\n+            float f = dataF[i];\n+            dataF[i + 32] = f + 3.5f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE + \"2\", \"> 0\",\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, \"= 0\",\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\"},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Some aarch64 machines have AlignVector == true, like ThunderX2\n+    static void test8b(int[] dataI, int[] dataI_2, float[] dataF) {\n+        for (int i = 0; i < RANGE - 32; i++) {\n+            \/\/ write forward 3 to different array reference:\n+            \/\/   AlignVector=true -> cannot vectorize because load and store cannot be both aligned\n+            \/\/   AlignVector=false -> vectorizes because we cannot prove store-to-load forwarding\n+            \/\/                        failure. But we can only have 2-element vectors in case\n+            \/\/                        the two float-arrays reference the same array.\n+            \/\/                        Note: at runtime the float-arrays are always different.\n+            int v = dataI[i];\n+            dataI_2[i + 3] = v + 5;\n+            \/\/ write forward 32 -> more than vector size -> can vectorize\n+            float f = dataF[i];\n+            dataF[i + 32] = f + 3.5f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE + \"2\", \"> 0\",\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, \"= 0\",\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\"},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Some aarch64 machines have AlignVector == true, like ThunderX2\n+    static void test8c(int[] dataI, int[] dataI_2, float[] dataF) {\n+        for (int i = 0; i < RANGE - 32; i++) {\n+            \/\/ write forward 3 to different array reference:\n+            \/\/   AlignVector=true -> cannot vectorize because load and store cannot be both aligned\n+            \/\/   AlignVector=false -> vectorizes because we cannot prove store-to-load forwarding\n+            \/\/                        failure. But we can only have 2-element vectors in case\n+            \/\/                        the two float-arrays reference the same array.\n+            \/\/                        Note: at runtime the float-arrays are always the same.\n+            int v = dataI[i];\n+            dataI_2[i + 3] = v + 5;\n+            \/\/ write forward 32 -> more than vector size -> can vectorize\n@@ -383,0 +580,16 @@\n+    public static void init(int[] dataI, float[] dataF, float[] dataF_2) {\n+        for (int j = 0; j < RANGE; j++) {\n+            dataI[j] = j;\n+            dataF[j] = j * 0.5f;\n+            dataF_2[j] = j * 0.3f;\n+        }\n+    }\n+\n+    public static void init(int[] dataI, int[] dataI_2, float[] dataF) {\n+        for (int j = 0; j < RANGE; j++) {\n+            dataI[j] = j;\n+            dataI_2[j] = 3*j - 42;\n+            dataF[j] = j * 0.5f;\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCyclicDependency.java","additions":242,"deletions":29,"binary":false,"changes":271,"status":"modified"},{"patch":"@@ -646,0 +646,6 @@\n+    enum ExpectVectorization {\n+        ALWAYS,    \/\/ -> positive \"count\" IR rule\n+        UNKNOWN,   \/\/ -> disable IR rule\n+        NEVER      \/\/ -> negative \"failOn\" IR rule\n+    };\n+\n@@ -659,0 +665,1 @@\n+            boolean isSingleArray;\n@@ -661,0 +668,1 @@\n+                isSingleArray = true;\n@@ -666,0 +674,1 @@\n+                isSingleArray = false;\n@@ -671,0 +680,1 @@\n+                isSingleArray = false;\n@@ -715,1 +725,1 @@\n-                   generateIRRules(),\n+                   generateIRRules(isSingleArray),\n@@ -729,1 +739,1 @@\n-        String generateIRRules() {\n+        String generateIRRules(boolean isSingleArray) {\n@@ -747,0 +757,2 @@\n+                int log2 = 31 - Integer.numberOfLeadingZeros(offset);\n+                int floorPow2Offset = 1 << log2;\n@@ -748,4 +760,2 @@\n-                    int log2 = 31 - Integer.numberOfLeadingZeros(offset);\n-                    int floorPow2 = 1 << log2;\n-                    maxVectorWidth = Math.min(maxVectorWidth, floorPow2 * type.size);\n-                    builder.append(\"    \/\/ Vectors must have at most \" + floorPow2 +\n+                    maxVectorWidth = Math.min(maxVectorWidth, floorPow2Offset * type.size);\n+                    builder.append(\"    \/\/ Vectors must have at most \" + floorPow2Offset +\n@@ -756,0 +766,43 @@\n+                ExpectVectorization expectVectorization = ExpectVectorization.ALWAYS;\n+                if (isSingleArray && 0 < offset && offset < 64) {\n+                    \/\/ In a store-forward case at iteration distances below a certain threshold, and not there\n+                    \/\/ is some partial overlap between the expected vector store and some vector load in a later\n+                    \/\/ iteration, we avoid vectorization to avoid the latency penalties of store-to-load\n+                    \/\/ forwarding failure. We only detect these failures in single-array cases.\n+                    \/\/\n+                    \/\/ Note: we currently never detect store-to-load-forwarding failures beyond 64 iterations,\n+                    \/\/       And so if the offset >= 64, we always expect vectorization.\n+                    \/\/\n+                    \/\/ The condition for partial overlap:\n+                    \/\/   offset % #elements != 0\n+                    \/\/\n+                    \/\/ But we do not know #elements exactly, only a range from min\/maxVectorWidth.\n+\n+                    int maxElements = maxVectorWidth \/ type.size;\n+                    int minElements = minVectorWidth \/ type.size;\n+                    boolean sometimesPartialOverlap = offset % maxElements != 0;\n+                    \/\/ If offset % minElements != 0, then it does also not hold for any larger vector.\n+                    boolean alwaysPartialOverlap = offset % minElements != 0;\n+\n+                    if (alwaysPartialOverlap) {\n+                        \/\/ It is a little tricky to know the exact threshold. On all platforms and in all\n+                        \/\/ unrolling cases, it is between 8 and 64. Hence, we have these 3 cases:\n+                        if (offset <= 8) {\n+                            builder.append(\"    \/\/ We always detect store-to-load-forwarding failures -> never vectorize.\\n\");\n+                            expectVectorization = ExpectVectorization.NEVER;\n+                        } else if (offset <= 64) {\n+                            builder.append(\"    \/\/ Unknown if detect store-to-load-forwarding failures -> maybe disable IR rules.\\n\");\n+                            expectVectorization = ExpectVectorization.UNKNOWN;\n+                        } else {\n+                            \/\/ offset > 64  -> offset too large, expect no store-to-load-failure detection\n+                            throw new RuntimeException(\"impossible\");\n+                        }\n+                    } else if (sometimesPartialOverlap && !alwaysPartialOverlap) {\n+                        builder.append(\"    \/\/ Partial overlap condition true: sometimes but not always -> maybe disable IR rules.\\n\");\n+                        expectVectorization = ExpectVectorization.UNKNOWN;\n+                    } else {\n+                        builder.append(\"    \/\/ Partial overlap never happens -> expect vectorization.\\n\");\n+                        expectVectorization = ExpectVectorization.ALWAYS;\n+                    }\n+                }\n+\n@@ -757,0 +810,1 @@\n+                ExpectVectorization expectVectorization1 = expectVectorization;\n@@ -763,1 +817,1 @@\n-                    r1.setNegative();\n+                    expectVectorization1 = ExpectVectorization.NEVER;\n@@ -767,0 +821,1 @@\n+                r1.setExpectVectVectorization(expectVectorization1);\n@@ -770,0 +825,1 @@\n+                ExpectVectorization expectVectorization2 = expectVectorization;\n@@ -794,1 +850,1 @@\n-                    r2.setNegative();\n+                    expectVectorization2 = ExpectVectorization.NEVER;\n@@ -796,2 +852,6 @@\n-                    builder.append(\"    \/\/ Alignment unknown -> disable IR rule.\\n\");\n-                    r2.disable();\n+                    if (expectVectorization2 != ExpectVectorization.NEVER) {\n+                        builder.append(\"    \/\/ Alignment unknown -> disable IR rule.\\n\");\n+                        expectVectorization2 = ExpectVectorization.UNKNOWN;\n+                    } else {\n+                        builder.append(\"    \/\/ Alignment unknown -> but already proved no vectorization above.\\n\");\n+                    }\n@@ -802,1 +862,1 @@\n-                    r2.setNegative();\n+                    expectVectorization2 = ExpectVectorization.NEVER;\n@@ -806,0 +866,1 @@\n+                r2.setExpectVectVectorization(expectVectorization2);\n@@ -849,6 +910,6 @@\n-        void setNegative() {\n-            this.isPositiveRule = false;\n-        }\n-\n-        void disable() {\n-            this.isEnabled = false;\n+        void setExpectVectVectorization(ExpectVectorization expectVectorization) {\n+            switch(expectVectorization) {\n+                case ExpectVectorization.NEVER   -> { this.isPositiveRule = false; }\n+                case ExpectVectorization.UNKNOWN -> { this.isEnabled = false; }\n+                case ExpectVectorization.ALWAYS  -> {}\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestDependencyOffsets.java","additions":78,"deletions":17,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\"},\n@@ -143,0 +143,3 @@\n+    \/\/ With sse2, the MulI does not vectorize. This means we have vectorized stores\n+    \/\/ to res1, but scalar loads from res1. The store-to-load-forwarding failure\n+    \/\/ detection catches this and rejects vectorization.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopCombinedOpTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,3694 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 1)\n+public abstract class VectorStoreToLoadForwarding {\n+    @Param({\"10000\"})\n+    public int SIZE;\n+\n+    public int START = 1000;\n+\n+    private byte[] aB;\n+    private short[] aS;\n+    private int[] aI;\n+    private long[] aL;\n+\n+    @Param(\"0\")\n+    private int seed;\n+    private Random r = new Random(seed);\n+\n+    @Setup\n+    public void init() {\n+        aB = new byte[SIZE];\n+        aS = new short[SIZE];\n+        aI = new int[SIZE];\n+        aL = new long[SIZE];\n+\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)r.nextInt();\n+            aS[i] = (short)r.nextInt();\n+            aI[i] = r.nextInt();\n+            aL[i] = r.nextLong();\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_000() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 0] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_001() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 1] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_002() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 2] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_003() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 3] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_004() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 4] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_005() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 5] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_006() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 6] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_007() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 7] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_008() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 8] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_009() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 9] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_010() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 10] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_011() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 11] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_012() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 12] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_013() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 13] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_014() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 14] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_015() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 15] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_016() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 16] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_017() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 17] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_018() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 18] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_019() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 19] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_020() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 20] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_021() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 21] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_022() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 22] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_023() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 23] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_024() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 24] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_025() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 25] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_026() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 26] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_027() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 27] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_028() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 28] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_029() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 29] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_030() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 30] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_031() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 31] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_032() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 32] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_033() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 33] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_034() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 34] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_035() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 35] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_036() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 36] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_037() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 37] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_038() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 38] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_039() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 39] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_040() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 40] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_041() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 41] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_042() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 42] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_043() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 43] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_044() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 44] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_045() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 45] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_046() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 46] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_047() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 47] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_048() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 48] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_049() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 49] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_050() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 50] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_051() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 51] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_052() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 52] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_053() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 53] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_054() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 54] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_055() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 55] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_056() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 56] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_057() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 57] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_058() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 58] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_059() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 59] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_060() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 60] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_061() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 61] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_062() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 62] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_063() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 63] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_064() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 64] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_065() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 65] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_066() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 66] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_067() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 67] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_068() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 68] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_069() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 69] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_070() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 70] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_071() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 71] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_072() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 72] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_073() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 73] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_074() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 74] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_075() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 75] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_076() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 76] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_077() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 77] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_078() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 78] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_079() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 79] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_080() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 80] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_081() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 81] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_082() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 82] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_083() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 83] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_084() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 84] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_085() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 85] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_086() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 86] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_087() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 87] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_088() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 88] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_089() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 89] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_090() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 90] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_091() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 91] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_092() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 92] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_093() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 93] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_094() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 94] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_095() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 95] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_096() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 96] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_097() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 97] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_098() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 98] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_099() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 99] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_100() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 100] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_101() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 101] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_102() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 102] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_103() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 103] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_104() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 104] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_105() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 105] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_106() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 106] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_107() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 107] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_108() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 108] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_109() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 109] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_110() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 110] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_111() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 111] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_112() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 112] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_113() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 113] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_114() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 114] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_115() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 115] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_116() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 116] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_117() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 117] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_118() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 118] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_119() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 119] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_120() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 120] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_121() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 121] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_122() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 122] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_123() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 123] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_124() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 124] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_125() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 125] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_126() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 126] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_127() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 127] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void byte_128() {\n+        for (int i = START; i < SIZE; i++) {\n+            aB[i] = (byte)(aB[i - 128] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_000() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 0] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_001() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 1] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_002() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 2] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_003() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 3] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_004() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 4] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_005() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 5] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_006() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 6] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_007() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 7] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_008() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 8] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_009() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 9] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_010() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 10] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_011() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 11] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_012() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 12] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_013() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 13] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_014() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 14] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_015() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 15] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_016() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 16] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_017() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 17] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_018() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 18] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_019() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 19] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_020() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 20] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_021() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 21] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_022() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 22] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_023() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 23] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_024() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 24] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_025() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 25] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_026() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 26] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_027() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 27] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_028() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 28] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_029() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 29] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_030() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 30] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_031() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 31] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_032() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 32] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_033() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 33] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_034() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 34] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_035() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 35] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_036() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 36] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_037() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 37] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_038() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 38] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_039() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 39] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_040() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 40] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_041() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 41] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_042() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 42] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_043() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 43] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_044() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 44] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_045() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 45] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_046() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 46] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_047() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 47] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_048() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 48] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_049() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 49] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_050() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 50] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_051() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 51] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_052() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 52] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_053() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 53] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_054() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 54] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_055() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 55] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_056() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 56] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_057() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 57] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_058() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 58] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_059() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 59] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_060() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 60] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_061() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 61] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_062() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 62] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_063() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 63] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_064() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 64] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_065() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 65] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_066() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 66] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_067() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 67] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_068() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 68] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_069() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 69] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_070() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 70] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_071() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 71] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_072() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 72] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_073() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 73] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_074() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 74] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_075() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 75] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_076() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 76] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_077() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 77] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_078() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 78] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_079() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 79] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_080() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 80] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_081() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 81] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_082() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 82] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_083() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 83] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_084() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 84] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_085() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 85] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_086() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 86] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_087() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 87] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_088() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 88] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_089() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 89] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_090() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 90] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_091() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 91] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_092() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 92] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_093() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 93] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_094() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 94] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_095() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 95] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_096() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 96] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_097() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 97] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_098() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 98] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_099() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 99] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_100() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 100] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_101() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 101] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_102() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 102] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_103() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 103] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_104() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 104] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_105() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 105] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_106() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 106] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_107() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 107] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_108() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 108] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_109() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 109] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_110() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 110] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_111() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 111] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_112() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 112] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_113() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 113] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_114() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 114] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_115() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 115] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_116() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 116] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_117() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 117] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_118() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 118] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_119() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 119] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_120() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 120] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_121() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 121] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_122() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 122] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_123() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 123] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_124() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 124] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_125() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 125] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_126() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 126] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_127() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 127] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void short_128() {\n+        for (int i = START; i < SIZE; i++) {\n+            aS[i] = (short)(aS[i - 128] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_000() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 0] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_001() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 1] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_002() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 2] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_003() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 3] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_004() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 4] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_005() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 5] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_006() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 6] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_007() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 7] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_008() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 8] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_009() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 9] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_010() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 10] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_011() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 11] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_012() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 12] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_013() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 13] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_014() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 14] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_015() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 15] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_016() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 16] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_017() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 17] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_018() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 18] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_019() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 19] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_020() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 20] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_021() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 21] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_022() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 22] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_023() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 23] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_024() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 24] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_025() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 25] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_026() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 26] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_027() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 27] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_028() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 28] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_029() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 29] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_030() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 30] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_031() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 31] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_032() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 32] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_033() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 33] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_034() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 34] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_035() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 35] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_036() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 36] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_037() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 37] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_038() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 38] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_039() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 39] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_040() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 40] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_041() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 41] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_042() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 42] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_043() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 43] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_044() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 44] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_045() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 45] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_046() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 46] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_047() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 47] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_048() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 48] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_049() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 49] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_050() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 50] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_051() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 51] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_052() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 52] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_053() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 53] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_054() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 54] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_055() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 55] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_056() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 56] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_057() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 57] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_058() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 58] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_059() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 59] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_060() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 60] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_061() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 61] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_062() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 62] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_063() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 63] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_064() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 64] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_065() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 65] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_066() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 66] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_067() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 67] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_068() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 68] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_069() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 69] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_070() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 70] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_071() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 71] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_072() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 72] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_073() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 73] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_074() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 74] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_075() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 75] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_076() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 76] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_077() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 77] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_078() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 78] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_079() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 79] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_080() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 80] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_081() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 81] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_082() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 82] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_083() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 83] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_084() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 84] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_085() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 85] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_086() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 86] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_087() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 87] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_088() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 88] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_089() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 89] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_090() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 90] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_091() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 91] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_092() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 92] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_093() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 93] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_094() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 94] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_095() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 95] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_096() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 96] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_097() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 97] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_098() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 98] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_099() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 99] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_100() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 100] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_101() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 101] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_102() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 102] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_103() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 103] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_104() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 104] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_105() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 105] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_106() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 106] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_107() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 107] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_108() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 108] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_109() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 109] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_110() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 110] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_111() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 111] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_112() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 112] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_113() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 113] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_114() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 114] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_115() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 115] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_116() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 116] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_117() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 117] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_118() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 118] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_119() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 119] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_120() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 120] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_121() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 121] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_122() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 122] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_123() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 123] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_124() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 124] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_125() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 125] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_126() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 126] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_127() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 127] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void int_128() {\n+        for (int i = START; i < SIZE; i++) {\n+            aI[i] = aI[i - 128] + 1;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_000() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 0] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_001() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 1] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_002() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 2] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_003() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 3] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_004() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 4] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_005() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 5] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_006() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 6] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_007() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 7] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_008() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 8] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_009() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 9] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_010() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 10] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_011() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 11] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_012() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 12] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_013() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 13] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_014() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 14] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_015() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 15] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_016() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 16] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_017() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 17] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_018() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 18] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_019() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 19] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_020() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 20] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_021() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 21] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_022() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 22] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_023() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 23] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_024() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 24] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_025() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 25] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_026() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 26] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_027() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 27] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_028() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 28] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_029() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 29] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_030() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 30] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_031() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 31] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_032() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 32] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_033() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 33] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_034() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 34] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_035() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 35] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_036() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 36] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_037() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 37] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_038() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 38] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_039() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 39] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_040() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 40] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_041() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 41] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_042() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 42] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_043() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 43] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_044() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 44] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_045() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 45] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_046() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 46] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_047() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 47] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_048() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 48] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_049() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 49] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_050() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 50] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_051() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 51] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_052() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 52] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_053() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 53] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_054() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 54] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_055() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 55] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_056() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 56] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_057() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 57] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_058() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 58] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_059() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 59] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_060() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 60] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_061() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 61] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_062() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 62] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_063() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 63] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_064() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 64] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_065() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 65] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_066() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 66] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_067() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 67] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_068() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 68] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_069() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 69] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_070() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 70] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_071() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 71] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_072() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 72] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_073() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 73] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_074() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 74] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_075() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 75] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_076() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 76] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_077() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 77] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_078() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 78] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_079() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 79] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_080() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 80] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_081() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 81] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_082() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 82] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_083() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 83] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_084() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 84] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_085() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 85] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_086() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 86] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_087() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 87] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_088() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 88] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_089() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 89] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_090() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 90] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_091() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 91] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_092() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 92] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_093() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 93] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_094() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 94] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_095() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 95] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_096() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 96] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_097() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 97] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_098() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 98] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_099() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 99] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_100() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 100] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_101() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 101] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_102() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 102] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_103() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 103] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_104() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 104] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_105() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 105] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_106() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 106] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_107() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 107] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_108() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 108] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_109() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 109] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_110() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 110] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_111() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 111] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_112() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 112] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_113() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 113] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_114() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 114] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_115() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 115] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_116() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 116] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_117() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 117] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_118() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 118] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_119() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 119] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_120() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 120] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_121() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 121] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_122() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 122] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_123() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 123] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_124() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 124] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_125() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 125] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_126() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 126] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_127() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 127] + 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void long_128() {\n+        for (int i = START; i < SIZE; i++) {\n+            aL[i] = (long)(aL[i - 128] + 1);\n+        }\n+    }\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UseSuperWord\"\n+    })\n+    public static class Default extends VectorStoreToLoadForwarding {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:-UseSuperWord\"\n+    })\n+    public static class NoVectorization extends VectorStoreToLoadForwarding {}\n+\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UseSuperWord\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:SuperWordStoreToLoadForwardingFailureDetection=0\"\n+    })\n+    public static class NoStoreToLoadForwardFailureDetection extends VectorStoreToLoadForwarding {}\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorStoreToLoadForwarding.java","additions":3694,"deletions":0,"binary":false,"changes":3694,"status":"added"}]}