{"files":[{"patch":"@@ -154,1 +154,1 @@\n-class VPointerRecord : public StackObj {\n+class VMemoryRegion : public StackObj {\n@@ -162,1 +162,1 @@\n-  uint _order;        \/\/ order in schedule\n+  uint _schedule_order;\n@@ -165,2 +165,2 @@\n-  VPointerRecord() {} \/\/ empty constructor for GrowableArray\n-  VPointerRecord(const VPointer& vpointer, int iv_offset, int vector_length, uint order) :\n+  VMemoryRegion() {} \/\/ empty constructor for GrowableArray\n+  VMemoryRegion(const VPointer& vpointer, int iv_offset, int vector_length, uint schedule_order) :\n@@ -173,1 +173,1 @@\n-    _order(order) {}\n+    _schedule_order(schedule_order) {}\n@@ -175,7 +175,7 @@\n-    Node* base()       const { return _base; }\n-    int scale()        const { return _scale; }\n-    Node* invar()      const { return _invar; }\n-    int offset()       const { return _offset; }\n-    uint memory_size() const { return _memory_size; }\n-    bool is_load()     const { return _is_load; }\n-    uint order()       const { return _order; }\n+    Node* base()          const { return _base; }\n+    int scale()           const { return _scale; }\n+    Node* invar()         const { return _invar; }\n+    int offset()          const { return _offset; }\n+    uint memory_size()    const { return _memory_size; }\n+    bool is_load()        const { return _is_load; }\n+    uint schedule_order() const { return _schedule_order; }\n@@ -183,1 +183,1 @@\n-    static int cmp_for_sort_by_group(VPointerRecord* r1, VPointerRecord* r2) {\n+    static int cmp_for_sort_by_group(VMemoryRegion* r1, VMemoryRegion* r2) {\n@@ -192,1 +192,1 @@\n-    static int cmp_for_sort(VPointerRecord* r1, VPointerRecord* r2) {\n+    static int cmp_for_sort(VMemoryRegion* r1, VMemoryRegion* r2) {\n@@ -202,3 +202,3 @@\n-    Aliasing aliasing(VPointerRecord& other) {\n-      VPointerRecord* p1 = this;\n-      VPointerRecord* p2 = &other;\n+    Aliasing aliasing(VMemoryRegion& other) {\n+      VMemoryRegion* p1 = this;\n+      VMemoryRegion* p2 = &other;\n@@ -220,2 +220,2 @@\n-    tty->print(\"VPointerRecord[%s %dbytes, order(%4d), base\",\n-               _is_load ? \"load \" : \"store\", _memory_size, _order);\n+    tty->print(\"VMemoryRegion[%s %dbytes, schedule_order(%4d), base\",\n+               _is_load ? \"load \" : \"store\", _memory_size, _schedule_order);\n@@ -289,1 +289,1 @@\n-  GrowableArray<VPointerRecord> records;\n+  GrowableArray<VMemoryRegion> memory_regions;\n@@ -308,1 +308,1 @@\n-          records.push(VPointerRecord(p, iv_offset, vector_length, schedule_order++));\n+          memory_regions.push(VMemoryRegion(p, iv_offset, vector_length, schedule_order++));\n@@ -315,1 +315,1 @@\n-  records.sort(VPointerRecord::cmp_for_sort);\n+  memory_regions.sort(VMemoryRegion::cmp_for_sort);\n@@ -322,3 +322,3 @@\n-    for (int i = 0; i < records.length(); i++) {\n-      VPointerRecord& record = records.at(i);\n-      record.print();\n+    for (int i = 0; i < memory_regions.length(); i++) {\n+      VMemoryRegion& region = memory_regions.at(i);\n+      region.print();\n@@ -330,2 +330,2 @@\n-  for (int i = 0; i < records.length(); i++) {\n-    VPointerRecord& record1 = records.at(i);\n+  for (int i = 0; i < memory_regions.length(); i++) {\n+    VMemoryRegion& region1 = memory_regions.at(i);\n@@ -333,2 +333,2 @@\n-    for (int j = i + 1; j < records.length(); j++) {\n-      VPointerRecord& record2 = records.at(j);\n+    for (int j = i + 1; j < memory_regions.length(); j++) {\n+      VMemoryRegion& region2 = memory_regions.at(j);\n@@ -336,3 +336,3 @@\n-      const VPointerRecord::Aliasing aliasing = record1.aliasing(record2);\n-      if (aliasing == VPointerRecord::Aliasing::DIFFERENT_GROUP ||\n-          aliasing == VPointerRecord::Aliasing::BEFORE) {\n+      const VMemoryRegion::Aliasing aliasing = region1.aliasing(region2);\n+      if (aliasing == VMemoryRegion::Aliasing::DIFFERENT_GROUP ||\n+          aliasing == VMemoryRegion::Aliasing::BEFORE) {\n@@ -340,1 +340,1 @@\n-      } else if (aliasing == VPointerRecord::Aliasing::EXACT_OVERLAP) {\n+      } else if (aliasing == VMemoryRegion::Aliasing::EXACT_OVERLAP) {\n@@ -343,3 +343,3 @@\n-        assert(aliasing == VPointerRecord::Aliasing::PARTIAL_OVERLAP, \"no other case can happen\");\n-        if ((record1.is_load() && !record2.is_load() && record1.order() > record2.order()) ||\n-            (!record1.is_load() && record2.is_load() && record1.order() < record2.order())) {\n+        assert(aliasing == VMemoryRegion::Aliasing::PARTIAL_OVERLAP, \"no other case can happen\");\n+        if ((region1.is_load() && !region2.is_load() && region1.schedule_order() > region2.schedule_order()) ||\n+            (!region1.is_load() && region2.is_load() && region1.schedule_order() < region2.schedule_order())) {\n@@ -353,2 +353,2 @@\n-            record1.print();\n-            record2.print();\n+            region1.print();\n+            region2.print();\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":38,"deletions":38,"binary":false,"changes":76,"status":"modified"}]}