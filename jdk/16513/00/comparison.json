{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,3 @@\n-            return ClassDesc.ofInternalName(className());\n+            var outer = outerType();\n+            return outer.isEmpty() ? ClassDesc.ofInternalName(className())\n+                    : outer.get().classDesc().nested(className());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Signature.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.IOException;\n@@ -35,0 +36,1 @@\n+import java.util.ArrayList;\n@@ -169,0 +171,18 @@\n+\n+    static class Outer<T1> {\n+        class Inner<T2> {}\n+    }\n+\n+    static class Observer extends ArrayList<Outer<String>.Inner<Long>>{}\n+\n+    @Test\n+    void testClassSignatureClassDesc() throws IOException {\n+        var observerCf = Classfile.of().parse(Path.of(System.getProperty(\"test.classes\"), \"SignaturesTest$Observer.class\"));\n+        var sig = observerCf.findAttribute(Attributes.SIGNATURE).orElseThrow().asClassSignature();\n+        var innerSig = (ClassTypeSig) ((ClassTypeSig) sig.superclassSignature()) \/\/ ArrayList\n+                .typeArgs().getFirst() \/\/ Outer<String>.Inner<Long>\n+                .boundType().orElseThrow(); \/\/ assert it's exact bound\n+        assertEquals(\"Inner\", innerSig.className(), \"simple name in signature\");\n+        assertEquals(Outer.Inner.class.describeConstable().orElseThrow(), innerSig.classDesc(),\n+                \"ClassDesc derived from signature\");\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/SignaturesTest.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"}]}