{"files":[{"patch":"@@ -54,1 +54,1 @@\n- * used with the same underlying {@code InputStream} instance.  Doing\n+ * used with the same underlying {@code InputStream} instance. Doing\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedInputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * used with the same underlying {@code OutputStream} instance.  Doing so can\n+ * used with the same underlying {@code OutputStream} instance. Doing so can\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedOutputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,2 +46,3 @@\n- * therefore advisable to wrap a BufferedReader around any Reader whose read()\n- * operations may be costly, such as FileReaders and InputStreamReaders.  For\n+ * therefore advisable to wrap a {@code BufferedReader} around any\n+ * {@code Reader} whose {@code read()} operations may be costly, such as\n+ * {@code FileReader}s and {@code InputStreamReader}s.  For\n@@ -55,3 +56,3 @@\n- * invocation of read() or readLine() could cause bytes to be read from the\n- * file, converted into characters, and then returned, which can be very\n- * inefficient.\n+ * invocation of {@code read()} or {@code readLine()} could cause bytes to be\n+ * read from the file, converted into characters, and then returned, which can\n+ * be very inefficient.\n@@ -59,2 +60,3 @@\n- * <p> Programs that use DataInputStreams for textual input can be localized by\n- * replacing each DataInputStream with an appropriate BufferedReader.\n+ * <p> Programs that use {@code DataInputStream}s for textual input can be\n+ * localized by replacing each {@code DataInputStream} with an appropriate\n+ * {@code BufferedReader}.\n@@ -62,4 +64,4 @@\n- * <p> More than one instance of BufferedReader should not be used with the\n- * same underlying Reader instance.  Doing so can cause the BufferedReader\n- * instances to return an incorrect result since each instance of\n- * BufferedReader maintains its own state.\n+ * <p> More than one instance of {@code BufferedReader} should not be used\n+ * with the same underlying Reader instance. Doing so can cause the\n+ * {@code BufferedReader} instances to return an incorrect result since each\n+ * instance of {@code BufferedReader} maintains its own state.\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedReader.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -40,5 +40,5 @@\n- * <p> A newLine() method is provided, which uses the platform's own notion of\n- * line separator as defined by the system property {@code line.separator}.\n- * Not all platforms use the newline character ('\\n') to terminate lines.\n- * Calling this method to terminate each output line is therefore preferred to\n- * writing a newline character directly.\n+ * <p> A {@code newLine()} method is provided, which uses the platform's own\n+ * notion of line separator as defined by the system property\n+ * {@linkplain System#lineSeparator() line.separator}. Not all platforms use the newline character ('\\n')\n+ * to terminate lines. Calling this method to terminate each output line is\n+ * therefore preferred to writing a newline character directly.\n@@ -46,4 +46,5 @@\n- * <p> In general, a Writer sends its output immediately to the underlying\n- * character or byte stream.  Unless prompt output is required, it is advisable\n- * to wrap a BufferedWriter around any Writer whose write() operations may be\n- * costly, such as FileWriters and OutputStreamWriters.  For example,\n+ * <p> In general, a {@code Writer} sends its output immediately to the\n+ * underlying character or byte stream.  Unless prompt output is required, it\n+ * is advisable to wrap a {@code BufferedWriter} around any {@code Writer} whose\n+ * {@code write()} operations may be costly, such as {@code FileWriter}s and\n+ * {@code OutputStreamWriter}s.  For example,\n@@ -55,4 +56,4 @@\n- * will buffer the PrintWriter's output to the file.  Without buffering, each\n- * invocation of a print() method would cause characters to be converted into\n- * bytes that would then be written immediately to the file, which can be very\n- * inefficient.\n+ * will buffer the {@code PrintWriter}'s output to the file.  Without buffering,\n+ * each invocation of a {@code print()} method would cause characters to be\n+ * converted into bytes that would then be written immediately to the file,\n+ * which can be very inefficient.\n@@ -60,4 +61,4 @@\n- * <p> More than one instance of BufferedWriter should not be used with the\n- * same underlying Writer instance.  Doing so can cause unpredictable results\n- * as each BufferedWriter maintains its own state and flushes its internal\n- * buffer according to that state.\n+ * <p> More than one instance of {@code BufferedWriter} should not be used with\n+ * the same underlying {@code Writer} instance. Doing so can cause unpredictable\n+ * results as each {@code BufferedWriter} maintains its own state and flushes\n+ * its internal buffer according to that state.\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedWriter.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"}]}