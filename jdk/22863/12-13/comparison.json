{"files":[{"patch":"@@ -71,1 +71,6 @@\n-  if (n->is_commutative_vector_operation()) {\n+  \/\/ Predicated vector operations are sensitive to ordering of inputs.\n+  \/\/ When the mask corresponding to a vector lane is false then\n+  \/\/ the result of the operation is corresponding lane of its first operand.\n+  \/\/   i.e. RES = VEC1.lanewise(OPER, VEC2, MASK) is semantically equivalent to\n+  \/\/        RES = VEC1.BLEND(VEC1.lanewise(OPER, VEC2), MASK)\n+  if (n->is_commutative_vector_operation() && !n->is_predicated_vector()) {\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    if (is_commutative_vector_operation()) {\n+    if (is_commutative_vector_operation() && !is_predicated_vector()) {\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -546,0 +546,28 @@\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeatureOr = {\"avx512vl\", \"true\", \"sve\", \"true\"})\n+    public void testVectorIRSharing19(int index) {\n+        VectorMask<Integer> VMASK = VectorMask.fromLong(I_SPECIES, ((1 << 4) - 1));\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ PRED:(vec1 + vec2) + PRED:(vec2 + vec1)\n+        vec1.lanewise(VectorOperators.ADD, vec2, VMASK)\n+            .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1, VMASK))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing19\")\n+    public void testVectorIRSharingDriver19() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing19(i);\n+        }\n+        checkVectorIRSharing19();\n+    }\n+\n+    public void checkVectorIRSharing19() {\n+        VectorMask<Integer> VMASK = VectorMask.fromLong(I_SPECIES, ((1 << 4) - 1));\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            boolean mask = VMASK.laneIsSet(i & (I_SPECIES.length() - 1));\n+            Verify.checkEQ(ir1[i], (mask ? ia[i] + ib[i] : ia[i]) + (mask ? ib[i] + ia[i] : ib[i]));\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCommutativeOperSharingTest.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"}]}