{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -835,0 +835,1 @@\n+    Flag_is_commutative_operation    = 1 << 18,\n@@ -1072,0 +1073,2 @@\n+  bool is_commutative_operation() const { return (_flags & Flag_is_commutative_operation) != 0; }\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,3 +140,13 @@\n-      for( uint i=0; i<req; i++ )\n-        if( n->in(i)!=k->in(i)) \/\/ Different inputs?\n-          goto collision;       \/\/ \"goto\" is a speed hack...\n+      \/\/ For commutative operation with same controlling edges\n+      \/\/ perform order agnostic input edge comparison to promote\n+      \/\/ node sharing.\n+      if (n->is_commutative_operation() && k->in(0) == n->in(0) && req == 3) {\n+        if (!((n->in(1) == k->in(1) && n->in(2) == k->in(2)) ||\n+              (n->in(1) == k->in(2) && n->in(2) == k->in(1)))) {\n+          goto collision;\n+        }\n+      } else {\n+        for( uint i=0; i<req; i++ )\n+          if( n->in(i)!=k->in(i)) \/\/ Different inputs?\n+            goto collision;       \/\/ \"goto\" is a speed hack...\n+      }\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -76,0 +76,8 @@\n+  virtual uint hash() const {\n+    if (is_commutative_operation()) {\n+      return (uintptr_t)in(1) + (uintptr_t)in(2) + Opcode();\n+    } else {\n+      return Node::hash();\n+    }\n+  }\n+\n@@ -171,1 +179,1 @@\n-  virtual uint hash() const { return Node::hash() + _is_unsigned; }\n+  virtual uint hash() const { return VectorNode::hash() + _is_unsigned; }\n@@ -180,1 +188,3 @@\n-  AddVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n+  AddVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n@@ -188,1 +198,3 @@\n-  AddVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n+  AddVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n@@ -196,1 +208,3 @@\n-  AddVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n+  AddVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n@@ -204,1 +218,3 @@\n-  AddVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  AddVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n@@ -212,1 +228,3 @@\n-  AddVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  AddVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n@@ -220,1 +238,3 @@\n-  AddVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  AddVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n@@ -390,1 +410,3 @@\n-  SaturatingAddVNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1, in2, vt, is_unsigned) {}\n+  SaturatingAddVNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1, in2, vt, is_unsigned) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n@@ -422,1 +444,3 @@\n-  MulVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  MulVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n@@ -430,1 +454,3 @@\n-  MulVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n+  MulVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n@@ -438,1 +464,3 @@\n-  MulVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n+  MulVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n@@ -448,0 +476,1 @@\n+    add_flag(Node::Flag_is_commutative_operation);\n@@ -458,1 +487,3 @@\n-  MulVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  MulVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n@@ -466,1 +497,3 @@\n-  MulVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  MulVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n@@ -608,1 +641,3 @@\n-  MinVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  MinVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n@@ -616,0 +651,1 @@\n+    add_flag(Node::Flag_is_commutative_operation);\n@@ -624,1 +660,3 @@\n-  MaxVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  MaxVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n@@ -632,0 +670,1 @@\n+    add_flag(Node::Flag_is_commutative_operation);\n@@ -904,1 +943,3 @@\n-  AndVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n+  AndVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n@@ -921,1 +962,3 @@\n-  OrVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n+  OrVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n@@ -938,1 +981,3 @@\n-  XorVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n+  XorVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n@@ -1346,1 +1391,3 @@\n-  AndVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : AndVNode(in1, in2, vt) {}\n+  AndVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : AndVNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n@@ -1353,1 +1400,3 @@\n-  OrVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : OrVNode(in1, in2, vt) {}\n+  OrVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : OrVNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n@@ -1360,1 +1409,3 @@\n-  XorVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : XorVNode(in1, in2, vt) {}\n+  XorVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : XorVNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_operation);\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":72,"deletions":21,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @test\n+ * @bug 8342393\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @summary Promote vector IR node sharing\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorCommutativeOperSharingTest\n+ *\/\n+\n+public class VectorCommutativeOperSharingTest {\n+    private static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_PREFERRED;\n+\n+    private static int LENGTH = 128;\n+    private static final Random RD = Utils.getRandomInstance();\n+\n+    private static int[] ia;\n+    private static int[] ib;\n+    private static int[] ir1;\n+    private static int[] ir2;\n+    private static int[] ir3;\n+    private static int[] ir4;\n+\n+    static {\n+        ia = new int[LENGTH];\n+        ib = new int[LENGTH];\n+        ir1 = new int[LENGTH];\n+        ir2 = new int[LENGTH];\n+        ir3 = new int[LENGTH];\n+        ir4 = new int[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ia[i] = RD.nextInt(25);\n+            ib[i] = RD.nextInt(25);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \" 2 \", IRNode.MUL_VI, \" 2 \", IRNode.MAX_VI, \" 2 \",\n+                  IRNode.MIN_VI, \" 2 \"})\n+    public void testVectorIRSharing1(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        vec1.lanewise(VectorOperators.ADD, vec2)\n+            .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+            .intoArray(ir1, index);\n+        vec1.lanewise(VectorOperators.MUL, vec2)\n+            .lanewise(VectorOperators.MUL, vec2.lanewise(VectorOperators.MUL, vec1))\n+            .intoArray(ir2, index);\n+        vec1.lanewise(VectorOperators.MAX, vec2)\n+            .lanewise(VectorOperators.MAX, vec2.lanewise(VectorOperators.MAX, vec1))\n+            .intoArray(ir3, index);\n+        vec1.lanewise(VectorOperators.MIN, vec2)\n+            .lanewise(VectorOperators.MIN, vec2.lanewise(VectorOperators.MIN, vec1))\n+            .intoArray(ir4, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing1\")\n+    public void testVectorIRSharingDriver1() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing1(i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.XOR_VI, \" 0 \", IRNode.OR_VI, \" 1 \", IRNode.AND_VI, \" 1 \"})\n+    public void testVectorIRSharing2(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        vec1.lanewise(VectorOperators.XOR, vec2)\n+            .lanewise(VectorOperators.XOR, vec2.lanewise(VectorOperators.XOR, vec1))\n+            .intoArray(ir1, index);\n+        vec1.lanewise(VectorOperators.AND, vec2)\n+            .lanewise(VectorOperators.AND, vec2.lanewise(VectorOperators.AND, vec1))\n+            .intoArray(ir2, index);\n+        vec1.lanewise(VectorOperators.OR, vec2)\n+            .lanewise(VectorOperators.OR, vec2.lanewise(VectorOperators.OR, vec1))\n+            .intoArray(ir3, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing2\")\n+    public void testVectorIRSharingDriver2() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing2(i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SATURATING_ADD_VI, \" 2 \"}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public void testVectorIRSharing3(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        vec1.lanewise(VectorOperators.SADD, vec2)\n+            .lanewise(VectorOperators.SADD, vec2.lanewise(VectorOperators.SADD, vec1))\n+            .intoArray(ir4, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing3\")\n+    public void testVectorIRSharingDriver3() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing3(i);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCommutativeOperSharingTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ *  Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.Random;\n+import java.util.Arrays;\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class VectorCommutativeOperSharingBenchmark {\n+    @Param({\"1024\",\"2048\"})\n+    int size;\n+\n+    byte[] bytesrc1;\n+    byte[] bytesrc2;\n+    byte[] byteres;\n+\n+    short[] shortsrc1;\n+    short[] shortsrc2;\n+    short[] shortres;\n+\n+    int[] intsrc1;\n+    int[] intsrc2;\n+    int[] intres;\n+\n+    long[] longsrc1;\n+    long[] longsrc2;\n+    long[] longres;\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        Random r = new Random(1024);\n+        bytesrc1 = new byte[size];\n+        bytesrc2 = new byte[size];\n+        byteres = new byte[size];\n+\n+        shortsrc1 = new short[size];\n+        shortsrc2 = new short[size];\n+        shortres = new short[size];\n+\n+        intsrc1 = new int[size];\n+        intsrc2 = new int[size];\n+        intres = new int[size];\n+\n+        longsrc1 = new long[size];\n+        longsrc2 = new long[size];\n+        longres = new long[size];\n+\n+        Arrays.fill(bytesrc1, (byte)1);\n+        Arrays.fill(bytesrc2, (byte)2);\n+\n+        Arrays.fill(shortsrc1, (short)1);\n+        Arrays.fill(shortsrc2, (short)2);\n+\n+        Arrays.fill(intsrc1, 1);\n+        Arrays.fill(intsrc2, 2);\n+\n+        Arrays.fill(longsrc1, 1);\n+        Arrays.fill(longsrc2, 2);\n+    }\n+\n+    @Benchmark\n+    public void commutativeByteOperationShairing() {\n+        for (int i = 0; i < size; i += ByteVector.SPECIES_PREFERRED.length()) {\n+            ByteVector vec1 = ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, bytesrc1, i);\n+            ByteVector vec2 = ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, bytesrc2, i);\n+            vec1.lanewise(VectorOperators.ADD, vec2)\n+                 .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+                 .lanewise(VectorOperators.MUL, vec1.lanewise(VectorOperators.MUL, vec2))\n+                 .lanewise(VectorOperators.MUL, vec2.lanewise(VectorOperators.MUL, vec1))\n+                 .lanewise(VectorOperators.AND, vec1.lanewise(VectorOperators.AND, vec2))\n+                 .lanewise(VectorOperators.AND, vec2.lanewise(VectorOperators.AND, vec1))\n+                 .lanewise(VectorOperators.OR, vec1.lanewise(VectorOperators.OR, vec2))\n+                 .lanewise(VectorOperators.OR, vec2.lanewise(VectorOperators.OR, vec1))\n+                 .intoArray(byteres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void commutativeShortOperationShairing() {\n+        for (int i = 0; i < size; i += ShortVector.SPECIES_PREFERRED.length()) {\n+            ShortVector vec1 = ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortsrc1, i);\n+            ShortVector vec2 = ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortsrc2, i);\n+            vec1.lanewise(VectorOperators.ADD, vec2)\n+                 .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+                 .lanewise(VectorOperators.MUL, vec1.lanewise(VectorOperators.MUL, vec2))\n+                 .lanewise(VectorOperators.MUL, vec2.lanewise(VectorOperators.MUL, vec1))\n+                 .lanewise(VectorOperators.AND, vec1.lanewise(VectorOperators.AND, vec2))\n+                 .lanewise(VectorOperators.AND, vec2.lanewise(VectorOperators.AND, vec1))\n+                 .lanewise(VectorOperators.OR, vec1.lanewise(VectorOperators.OR, vec2))\n+                 .lanewise(VectorOperators.OR, vec2.lanewise(VectorOperators.OR, vec1))\n+                 .intoArray(shortres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void commutativeIntOperationShairing() {\n+        for (int i = 0; i < size; i += IntVector.SPECIES_PREFERRED.length()) {\n+            IntVector vec1 = IntVector.fromArray(IntVector.SPECIES_PREFERRED, intsrc1, i);\n+            IntVector vec2 = IntVector.fromArray(IntVector.SPECIES_PREFERRED, intsrc2, i);\n+            vec1.lanewise(VectorOperators.ADD, vec2)\n+                 .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+                 .lanewise(VectorOperators.MUL, vec1.lanewise(VectorOperators.MUL, vec2))\n+                 .lanewise(VectorOperators.MUL, vec2.lanewise(VectorOperators.MUL, vec1))\n+                 .lanewise(VectorOperators.AND, vec1.lanewise(VectorOperators.AND, vec2))\n+                 .lanewise(VectorOperators.AND, vec2.lanewise(VectorOperators.AND, vec1))\n+                 .lanewise(VectorOperators.OR, vec1.lanewise(VectorOperators.OR, vec2))\n+                 .lanewise(VectorOperators.OR, vec2.lanewise(VectorOperators.OR, vec1))\n+                 .intoArray(intres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void commutativeLongOperationShairing() {\n+        for (int i = 0; i < size; i += LongVector.SPECIES_PREFERRED.length()) {\n+            LongVector vec1 = LongVector.fromArray(LongVector.SPECIES_PREFERRED, longsrc1, i);\n+            LongVector vec2 = LongVector.fromArray(LongVector.SPECIES_PREFERRED, longsrc2, i);\n+            vec1.lanewise(VectorOperators.ADD, vec2)\n+                 .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+                 .lanewise(VectorOperators.MUL, vec1.lanewise(VectorOperators.MUL, vec2))\n+                 .lanewise(VectorOperators.MUL, vec2.lanewise(VectorOperators.MUL, vec1))\n+                 .lanewise(VectorOperators.AND, vec1.lanewise(VectorOperators.AND, vec2))\n+                 .lanewise(VectorOperators.AND, vec2.lanewise(VectorOperators.AND, vec1))\n+                 .lanewise(VectorOperators.OR, vec1.lanewise(VectorOperators.OR, vec2))\n+                 .lanewise(VectorOperators.OR, vec2.lanewise(VectorOperators.OR, vec1))\n+                 .intoArray(longres, i);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/VectorCommutativeOperSharingBenchmark.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"}]}