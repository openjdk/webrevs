{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -835,1 +835,2 @@\n-    _last_flag                       = Flag_is_predicated_using_blend\n+    Flag_is_commutative_vector_op    = 1 << 18,\n+    _last_flag                       = Flag_is_commutative_vector_op\n@@ -1072,0 +1073,2 @@\n+  bool is_commutative_vector_operation() const { return (_flags & Flag_is_commutative_vector_op) != 0; }\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,25 @@\n+\/\/-----------------------------------------------------------------------------\n+\n+bool NodeHash::check_for_collision(const Node* n, const Node* k) const {\n+  \/\/ For commutative operations with same controlling edge\n+  \/\/ perform order agnostic input edge comparison to promote\n+  \/\/ node sharing.\n+  uint req = n->req();\n+  if (n->is_commutative_vector_operation()) {\n+    assert(req == 3, \"\");\n+    assert(k->is_commutative_vector_operation(), \"\");\n+    if ((k->in(0) != n->in(0)) ||\n+        ((k->in(1) != n->in(1) || k->in(2) != n->in(2)) &&\n+         (k->in(1) != n->in(2) || k->in(2) != n->in(1)))) {\n+      return true;\n+    }\n+  } else {\n+    for(uint i=0; i<req; i++) {\n+      if(n->in(i) != k->in(i)) { \/\/ Different inputs?\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -88,4 +113,2 @@\n-      for( uint i=0; i<req; i++ )\n-        if( n->in(i)!=k->in(i)) \/\/ Different inputs?\n-          goto collision;       \/\/ \"goto\" is a speed hack...\n-      if( n->cmp(*k) ) {        \/\/ Check for any special bits\n+      bool collision = check_for_collision(n, k);\n+      if (collision == false && n->cmp(*k)) {  \/\/ Check for any special bits\n@@ -96,1 +119,0 @@\n-  collision:\n@@ -140,4 +162,2 @@\n-      for( uint i=0; i<req; i++ )\n-        if( n->in(i)!=k->in(i)) \/\/ Different inputs?\n-          goto collision;       \/\/ \"goto\" is a speed hack...\n-      if( n->cmp(*k) ) {        \/\/ Check for any special bits\n+      bool collision = check_for_collision(n, k);\n+      if (collision == false && n->cmp(*k)) {        \/\/ Check for any special bits\n@@ -148,1 +168,0 @@\n-  collision:\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":30,"deletions":11,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+  bool   check_for_collision(const Node* n, const Node* k) const;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -76,0 +76,9 @@\n+  virtual uint hash() const {\n+    if (is_commutative_vector_operation()) {\n+      assert(req() == 3, \"\");\n+      return (uintptr_t)in(1) + (uintptr_t)in(2) + Opcode();\n+    } else {\n+      return Node::hash();\n+    }\n+  }\n+\n@@ -171,1 +180,1 @@\n-  virtual uint hash() const { return Node::hash() + _is_unsigned; }\n+  virtual uint hash() const { return VectorNode::hash() + _is_unsigned; }\n@@ -180,1 +189,3 @@\n-  AddVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n+  AddVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n@@ -188,1 +199,3 @@\n-  AddVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n+  AddVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n@@ -196,1 +209,3 @@\n-  AddVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n+  AddVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n@@ -204,1 +219,3 @@\n-  AddVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  AddVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n@@ -212,1 +229,3 @@\n-  AddVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  AddVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n@@ -220,1 +239,3 @@\n-  AddVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  AddVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n@@ -390,1 +411,3 @@\n-  SaturatingAddVNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1, in2, vt, is_unsigned) {}\n+  SaturatingAddVNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1, in2, vt, is_unsigned) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n@@ -422,1 +445,3 @@\n-  MulVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  MulVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n@@ -430,1 +455,3 @@\n-  MulVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n+  MulVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n@@ -438,1 +465,3 @@\n-  MulVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n+  MulVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n@@ -448,0 +477,1 @@\n+    add_flag(Node::Flag_is_commutative_vector_op);\n@@ -458,1 +488,3 @@\n-  MulVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  MulVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n@@ -466,1 +498,3 @@\n-  MulVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  MulVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n@@ -608,1 +642,3 @@\n-  MinVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  MinVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n@@ -616,0 +652,1 @@\n+    add_flag(Node::Flag_is_commutative_vector_op);\n@@ -624,1 +661,3 @@\n-  MaxVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  MaxVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n@@ -632,0 +671,1 @@\n+    add_flag(Node::Flag_is_commutative_vector_op);\n@@ -904,1 +944,3 @@\n-  AndVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n+  AndVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n@@ -921,1 +963,3 @@\n-  OrVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n+  OrVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n@@ -938,1 +982,3 @@\n-  XorVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n+  XorVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n@@ -1346,1 +1392,3 @@\n-  AndVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : AndVNode(in1, in2, vt) {}\n+  AndVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : AndVNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n@@ -1353,1 +1401,3 @@\n-  OrVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : OrVNode(in1, in2, vt) {}\n+  OrVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : OrVNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n@@ -1360,1 +1410,3 @@\n-  XorVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : XorVNode(in1, in2, vt) {}\n+  XorVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : XorVNode(in1, in2, vt) {\n+    add_flag(Node::Flag_is_commutative_vector_op);\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":73,"deletions":21,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -0,0 +1,546 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @test\n+ * @bug 8342393\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @summary Promote vector IR node sharing\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorCommutativeOperSharingTest\n+ *\/\n+\n+public class VectorCommutativeOperSharingTest {\n+    private static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_PREFERRED;\n+\n+    private static int LENGTH = 128;\n+    private static final Random RD = Utils.getRandomInstance();\n+\n+    private static int[] ia;\n+    private static int[] ib;\n+    private static int[] ir1;\n+    private static int[] ir2;\n+    private static int[] ir3;\n+    private static int[] ir4;\n+\n+    static {\n+        ia = new int[LENGTH];\n+        ib = new int[LENGTH];\n+        ir1 = new int[LENGTH];\n+        ir2 = new int[LENGTH];\n+        ir3 = new int[LENGTH];\n+        ir4 = new int[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ia[i] = RD.nextInt(Integer.MAX_VALUE);\n+            ib[i] = RD.nextInt(Integer.MAX_VALUE);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \",\n+                  IRNode.MUL_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \",\n+                  IRNode.MAX_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \",\n+                  IRNode.MIN_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"})\n+    public void testVectorIRSharing1(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        vec1.lanewise(VectorOperators.ADD, vec2)\n+            .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+            .intoArray(ir1, index);\n+        vec1.lanewise(VectorOperators.MUL, vec2)\n+            .lanewise(VectorOperators.MUL, vec2.lanewise(VectorOperators.MUL, vec1))\n+            .intoArray(ir2, index);\n+        vec1.lanewise(VectorOperators.MAX, vec2)\n+            .lanewise(VectorOperators.MAX, vec2.lanewise(VectorOperators.MAX, vec1))\n+            .intoArray(ir3, index);\n+        vec1.lanewise(VectorOperators.MIN, vec2)\n+            .lanewise(VectorOperators.MIN, vec2.lanewise(VectorOperators.MIN, vec1))\n+            .intoArray(ir4, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing1\")\n+    public void testVectorIRSharingDriver1() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing1(i);\n+        }\n+        checkVectorIRSharing1();\n+    }\n+\n+    public void checkVectorIRSharing1() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] + ib[i]) + (ib[i] + ia[i]));\n+            Verify.checkEQ(ir2[i], (ia[i] * ib[i]) * (ib[i] * ia[i]));\n+            Verify.checkEQ(ir3[i], Integer.max(Integer.max(ia[i], ib[i]), Integer.max(ib[i], ia[i])));\n+            Verify.checkEQ(ir4[i], Integer.min(Integer.max(ia[i], ib[i]), Integer.min(ib[i], ia[i])));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.XOR_VI, IRNode.VECTOR_SIZE_ANY, \" 0 \",\n+                  IRNode.OR_VI, IRNode.VECTOR_SIZE_ANY, \" 1 \",\n+                  IRNode.AND_VI, IRNode.VECTOR_SIZE_ANY, \" 1 \"})\n+    public void testVectorIRSharing2(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        vec1.lanewise(VectorOperators.XOR, vec2)\n+            .lanewise(VectorOperators.XOR, vec2.lanewise(VectorOperators.XOR, vec1))\n+            .intoArray(ir1, index);\n+        vec1.lanewise(VectorOperators.AND, vec2)\n+            .lanewise(VectorOperators.AND, vec2.lanewise(VectorOperators.AND, vec1))\n+            .intoArray(ir2, index);\n+        vec1.lanewise(VectorOperators.OR, vec2)\n+            .lanewise(VectorOperators.OR, vec2.lanewise(VectorOperators.OR, vec1))\n+            .intoArray(ir3, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing2\")\n+    public void testVectorIRSharingDriver2() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing2(i);\n+        }\n+        checkVectorIRSharing2();\n+    }\n+\n+    public void checkVectorIRSharing2() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] ^ ib[i]) ^ (ib[i] ^ ia[i]));\n+            Verify.checkEQ(ir2[i], (ia[i] & ib[i]) & (ib[i] & ia[i]));\n+            Verify.checkEQ(ir3[i], (ia[i] | ib[i]) | (ib[i] | ia[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SATURATING_ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public void testVectorIRSharing3(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        vec1.lanewise(VectorOperators.SADD, vec2)\n+            .lanewise(VectorOperators.SADD, vec2.lanewise(VectorOperators.SADD, vec1))\n+            .intoArray(ir4, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing3\")\n+    public void testVectorIRSharingDriver3() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing3(i);\n+        }\n+        checkVectorIRSharing3();\n+    }\n+\n+    public void checkVectorIRSharing3() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir4[i], VectorMath.addSaturating(VectorMath.addSaturating(ia[i], ib[i]),\n+                                                            VectorMath.addSaturating(ib[i], ia[i])));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"})\n+    public void testVectorIRSharing4(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec1 + vec1) + (vec1 + vec1)\n+        vec1.lanewise(VectorOperators.ADD, vec1)\n+            .lanewise(VectorOperators.ADD, vec1.lanewise(VectorOperators.ADD, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing4\")\n+    public void testVectorIRSharingDriver4() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing4(i);\n+        }\n+        checkVectorIRSharing4();\n+    }\n+\n+    public void checkVectorIRSharing4() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] + ia[i]) + (ia[i] + ia[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"})\n+    public void testVectorIRSharing5(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec1 + vec1) + (vec1 + vec2)\n+        vec1.lanewise(VectorOperators.ADD, vec1)\n+            .lanewise(VectorOperators.ADD, vec1.lanewise(VectorOperators.ADD, vec2))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing5\")\n+    public void testVectorIRSharingDriver5() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing5(i);\n+        }\n+        checkVectorIRSharing5();\n+    }\n+\n+    public void checkVectorIRSharing5() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] + ia[i]) + (ia[i] + ib[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"})\n+    public void testVectorIRSharing6(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec1 + vec1) + (vec2 + vec1)\n+        vec1.lanewise(VectorOperators.ADD, vec1)\n+            .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing6\")\n+    public void testVectorIRSharingDriver6() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing6(i);\n+        }\n+        checkVectorIRSharing6();\n+    }\n+\n+    public void checkVectorIRSharing6() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] + ia[i]) + (ib[i] + ia[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"})\n+    public void testVectorIRSharing7(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec1 + vec1) + (vec2 + vec2)\n+        vec1.lanewise(VectorOperators.ADD, vec1)\n+            .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec2))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing7\")\n+    public void testVectorIRSharingDriver7() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing7(i);\n+        }\n+        checkVectorIRSharing7();\n+    }\n+\n+    public void checkVectorIRSharing7() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] + ia[i]) + (ib[i] + ib[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"})\n+    public void testVectorIRSharing8(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec1 + vec2) + (vec1 + vec1)\n+        vec1.lanewise(VectorOperators.ADD, vec2)\n+            .lanewise(VectorOperators.ADD, vec1.lanewise(VectorOperators.ADD, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing8\")\n+    public void testVectorIRSharingDriver8() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing8(i);\n+        }\n+        checkVectorIRSharing8();\n+    }\n+\n+    public void checkVectorIRSharing8() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] + ib[i]) + (ia[i] + ia[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"})\n+    public void testVectorIRSharing9(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec1 + vec2) + (vec1 + vec2)\n+        vec1.lanewise(VectorOperators.ADD, vec2)\n+            .lanewise(VectorOperators.ADD, vec1.lanewise(VectorOperators.ADD, vec2))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing9\")\n+    public void testVectorIRSharingDriver9() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing9(i);\n+        }\n+        checkVectorIRSharing9();\n+    }\n+\n+    public void checkVectorIRSharing9() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] + ib[i]) + (ia[i] + ib[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"})\n+    public void testVectorIRSharing10(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec1 + vec2) + (vec2 + vec1)\n+        vec1.lanewise(VectorOperators.ADD, vec2)\n+            .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing10\")\n+    public void testVectorIRSharingDriver10() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing10(i);\n+        }\n+        checkVectorIRSharing10();\n+    }\n+\n+    public void checkVectorIRSharing10() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] + ib[i]) + (ib[i] + ia[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"})\n+    public void testVectorIRSharing11(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec1 + vec2) + (vec2 + vec2)\n+        vec1.lanewise(VectorOperators.ADD, vec2)\n+            .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec2))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing11\")\n+    public void testVectorIRSharingDriver11() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing11(i);\n+        }\n+        checkVectorIRSharing11();\n+    }\n+\n+    public void checkVectorIRSharing11() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] + ib[i]) + (ib[i] + ib[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"})\n+    public void testVectorIRSharing12(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec2 + vec1) + (vec1 + vec1)\n+        vec2.lanewise(VectorOperators.ADD, vec1)\n+            .lanewise(VectorOperators.ADD, vec1.lanewise(VectorOperators.ADD, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing12\")\n+    public void testVectorIRSharingDriver12() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing12(i);\n+        }\n+        checkVectorIRSharing12();\n+    }\n+\n+    public void checkVectorIRSharing12() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ib[i] + ia[i]) + (ia[i] + ia[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"})\n+    public void testVectorIRSharing13(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec2 + vec1) + (vec1 + vec2)\n+        vec2.lanewise(VectorOperators.ADD, vec1)\n+            .lanewise(VectorOperators.ADD, vec1.lanewise(VectorOperators.ADD, vec2))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing13\")\n+    public void testVectorIRSharingDriver13() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing13(i);\n+        }\n+        checkVectorIRSharing13();\n+    }\n+\n+    public void checkVectorIRSharing13() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ib[i] + ia[i]) + (ia[i] + ib[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"})\n+    public void testVectorIRSharing14(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec2 + vec1) + (vec2 + vec1)\n+        vec2.lanewise(VectorOperators.ADD, vec1)\n+            .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing14\")\n+    public void testVectorIRSharingDriver14() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing14(i);\n+        }\n+        checkVectorIRSharing14();\n+    }\n+\n+    public void checkVectorIRSharing14() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ib[i] + ia[i]) + (ib[i] + ia[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"})\n+    public void testVectorIRSharing15(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec2 + vec1) + (vec2 + vec2)\n+        vec2.lanewise(VectorOperators.ADD, vec1)\n+            .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec2))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing15\")\n+    public void testVectorIRSharingDriver15() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing15(i);\n+        }\n+        checkVectorIRSharing15();\n+    }\n+\n+    public void checkVectorIRSharing15() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ib[i] + ia[i]) + (ib[i] + ib[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"})\n+    public void testVectorIRSharing16(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec2 + vec2) + (vec1 + vec1)\n+        vec2.lanewise(VectorOperators.ADD, vec2)\n+            .lanewise(VectorOperators.ADD, vec1.lanewise(VectorOperators.ADD, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing16\")\n+    public void testVectorIRSharingDriver16() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing16(i);\n+        }\n+        checkVectorIRSharing16();\n+    }\n+\n+    public void checkVectorIRSharing16() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ib[i] + ib[i]) + (ia[i] + ia[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"})\n+    public void testVectorIRSharing17(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec2 + vec2) + (vec1 + vec2)\n+        vec2.lanewise(VectorOperators.ADD, vec2)\n+            .lanewise(VectorOperators.ADD, vec1.lanewise(VectorOperators.ADD, vec2))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing17\")\n+    public void testVectorIRSharingDriver17() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing17(i);\n+        }\n+        checkVectorIRSharing17();\n+    }\n+\n+    public void checkVectorIRSharing17() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ib[i] + ib[i]) + (ia[i] + ib[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"})\n+    public void testVectorIRSharing18(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec2 + vec2) + (vec2 + vec1)\n+        vec2.lanewise(VectorOperators.ADD, vec2)\n+            .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing18\")\n+    public void testVectorIRSharingDriver18() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing18(i);\n+        }\n+        checkVectorIRSharing18();\n+    }\n+\n+    public void checkVectorIRSharing18() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ib[i] + ib[i]) + (ib[i] + ia[i]));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCommutativeOperSharingTest.java","additions":546,"deletions":0,"binary":false,"changes":546,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ *  Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.Random;\n+import java.util.Arrays;\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class VectorCommutativeOperSharingBenchmark {\n+    @Param({\"1024\",\"2048\"})\n+    int size;\n+\n+    byte[] bytesrc1;\n+    byte[] bytesrc2;\n+    byte[] byteres;\n+\n+    short[] shortsrc1;\n+    short[] shortsrc2;\n+    short[] shortres;\n+\n+    int[] intsrc1;\n+    int[] intsrc2;\n+    int[] intres;\n+\n+    long[] longsrc1;\n+    long[] longsrc2;\n+    long[] longres;\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        Random r = new Random(1024);\n+        bytesrc1 = new byte[size];\n+        bytesrc2 = new byte[size];\n+        byteres = new byte[size];\n+\n+        shortsrc1 = new short[size];\n+        shortsrc2 = new short[size];\n+        shortres = new short[size];\n+\n+        intsrc1 = new int[size];\n+        intsrc2 = new int[size];\n+        intres = new int[size];\n+\n+        longsrc1 = new long[size];\n+        longsrc2 = new long[size];\n+        longres = new long[size];\n+\n+        Arrays.fill(bytesrc1, (byte)1);\n+        Arrays.fill(bytesrc2, (byte)2);\n+\n+        Arrays.fill(shortsrc1, (short)1);\n+        Arrays.fill(shortsrc2, (short)2);\n+\n+        Arrays.fill(intsrc1, 1);\n+        Arrays.fill(intsrc2, 2);\n+\n+        Arrays.fill(longsrc1, 1);\n+        Arrays.fill(longsrc2, 2);\n+    }\n+\n+    @Benchmark\n+    public void commutativeByteOperationShairing() {\n+        for (int i = 0; i < size; i += ByteVector.SPECIES_PREFERRED.length()) {\n+            ByteVector vec1 = ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, bytesrc1, i);\n+            ByteVector vec2 = ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, bytesrc2, i);\n+            vec1.lanewise(VectorOperators.ADD, vec2)\n+                 .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+                 .lanewise(VectorOperators.MUL, vec1.lanewise(VectorOperators.MUL, vec2))\n+                 .lanewise(VectorOperators.MUL, vec2.lanewise(VectorOperators.MUL, vec1))\n+                 .lanewise(VectorOperators.AND, vec1.lanewise(VectorOperators.AND, vec2))\n+                 .lanewise(VectorOperators.AND, vec2.lanewise(VectorOperators.AND, vec1))\n+                 .lanewise(VectorOperators.OR, vec1.lanewise(VectorOperators.OR, vec2))\n+                 .lanewise(VectorOperators.OR, vec2.lanewise(VectorOperators.OR, vec1))\n+                 .intoArray(byteres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void commutativeShortOperationShairing() {\n+        for (int i = 0; i < size; i += ShortVector.SPECIES_PREFERRED.length()) {\n+            ShortVector vec1 = ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortsrc1, i);\n+            ShortVector vec2 = ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortsrc2, i);\n+            vec1.lanewise(VectorOperators.ADD, vec2)\n+                 .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+                 .lanewise(VectorOperators.MUL, vec1.lanewise(VectorOperators.MUL, vec2))\n+                 .lanewise(VectorOperators.MUL, vec2.lanewise(VectorOperators.MUL, vec1))\n+                 .lanewise(VectorOperators.AND, vec1.lanewise(VectorOperators.AND, vec2))\n+                 .lanewise(VectorOperators.AND, vec2.lanewise(VectorOperators.AND, vec1))\n+                 .lanewise(VectorOperators.OR, vec1.lanewise(VectorOperators.OR, vec2))\n+                 .lanewise(VectorOperators.OR, vec2.lanewise(VectorOperators.OR, vec1))\n+                 .intoArray(shortres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void commutativeIntOperationShairing() {\n+        for (int i = 0; i < size; i += IntVector.SPECIES_PREFERRED.length()) {\n+            IntVector vec1 = IntVector.fromArray(IntVector.SPECIES_PREFERRED, intsrc1, i);\n+            IntVector vec2 = IntVector.fromArray(IntVector.SPECIES_PREFERRED, intsrc2, i);\n+            vec1.lanewise(VectorOperators.ADD, vec2)\n+                 .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+                 .lanewise(VectorOperators.MUL, vec1.lanewise(VectorOperators.MUL, vec2))\n+                 .lanewise(VectorOperators.MUL, vec2.lanewise(VectorOperators.MUL, vec1))\n+                 .lanewise(VectorOperators.AND, vec1.lanewise(VectorOperators.AND, vec2))\n+                 .lanewise(VectorOperators.AND, vec2.lanewise(VectorOperators.AND, vec1))\n+                 .lanewise(VectorOperators.OR, vec1.lanewise(VectorOperators.OR, vec2))\n+                 .lanewise(VectorOperators.OR, vec2.lanewise(VectorOperators.OR, vec1))\n+                 .intoArray(intres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void commutativeLongOperationShairing() {\n+        for (int i = 0; i < size; i += LongVector.SPECIES_PREFERRED.length()) {\n+            LongVector vec1 = LongVector.fromArray(LongVector.SPECIES_PREFERRED, longsrc1, i);\n+            LongVector vec2 = LongVector.fromArray(LongVector.SPECIES_PREFERRED, longsrc2, i);\n+            vec1.lanewise(VectorOperators.ADD, vec2)\n+                 .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+                 .lanewise(VectorOperators.MUL, vec1.lanewise(VectorOperators.MUL, vec2))\n+                 .lanewise(VectorOperators.MUL, vec2.lanewise(VectorOperators.MUL, vec1))\n+                 .lanewise(VectorOperators.AND, vec1.lanewise(VectorOperators.AND, vec2))\n+                 .lanewise(VectorOperators.AND, vec2.lanewise(VectorOperators.AND, vec1))\n+                 .lanewise(VectorOperators.OR, vec1.lanewise(VectorOperators.OR, vec2))\n+                 .lanewise(VectorOperators.OR, vec2.lanewise(VectorOperators.OR, vec1))\n+                 .intoArray(longres, i);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/VectorCommutativeOperSharingBenchmark.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"}]}