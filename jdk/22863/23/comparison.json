{"files":[{"patch":"@@ -1045,0 +1045,49 @@\n+bool VectorNode::should_swap_inputs_to_help_global_value_numbering() {\n+  \/\/ Predicated vector operations are sensitive to ordering of inputs.\n+  \/\/ When the mask corresponding to a vector lane is false then\n+  \/\/ the result of the operation is corresponding lane of its first operand.\n+  \/\/   i.e. RES = VEC1.lanewise(OPER, VEC2, MASK) is semantically equivalent to\n+  \/\/        RES = BLEND(VEC1, VEC1.lanewise(OPER, VEC2), MASK)\n+  if (is_predicated_vector()) {\n+    return false;\n+  }\n+\n+  switch(Opcode()) {\n+    case Op_AddVB:\n+    case Op_AddVS:\n+    case Op_AddVI:\n+    case Op_AddVL:\n+    case Op_AddVF:\n+    case Op_AddVD:\n+\n+    case Op_MulVB:\n+    case Op_MulVS:\n+    case Op_MulVI:\n+    case Op_MulVL:\n+    case Op_MulVF:\n+    case Op_MulVD:\n+\n+    case Op_MaxV:\n+    case Op_MinV:\n+    case Op_XorV:\n+    case Op_OrV:\n+    case Op_AndV:\n+    case Op_UMinV:\n+    case Op_UMaxV:\n+\n+    case Op_AndVMask:\n+    case Op_OrVMask:\n+    case Op_XorVMask:\n+\n+    case Op_SaturatingAddV:\n+      \/\/ For non-predicated commutative operations, sort the inputs in\n+      \/\/ increasing order of node indices.\n+      if (in(1)->_idx > in(2)->_idx) {\n+        return true;\n+      }\n+      \/\/ fallthrough\n+    default:\n+      return false;\n+  }\n+}\n+\n@@ -1049,0 +1098,5 @@\n+\n+  \/\/ Sort inputs of commutative non-predicated vector operations to help value numbering.\n+  if (should_swap_inputs_to_help_global_value_numbering()) {\n+    swap_edges(1, 2);\n+  }\n@@ -2079,1 +2133,1 @@\n-  return nullptr;\n+  return VectorNode::Ideal(phase, can_reshape);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -91,0 +91,2 @@\n+  bool should_swap_inputs_to_help_global_value_numbering();\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,576 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @test\n+ * @bug 8342393\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @summary Promote vector IR node sharing\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorCommutativeOperSharingTest\n+ *\/\n+\n+public class VectorCommutativeOperSharingTest {\n+    private static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_PREFERRED;\n+\n+    private static int LENGTH = 128;\n+    private static final Random RD = Utils.getRandomInstance();\n+\n+    private static int[] ia;\n+    private static int[] ib;\n+    private static int[] ir1;\n+    private static int[] ir2;\n+    private static int[] ir3;\n+    private static int[] ir4;\n+\n+    static {\n+        ia = new int[LENGTH];\n+        ib = new int[LENGTH];\n+        ir1 = new int[LENGTH];\n+        ir2 = new int[LENGTH];\n+        ir3 = new int[LENGTH];\n+        ir4 = new int[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ia[i] = RD.nextInt(Integer.MAX_VALUE);\n+            ib[i] = RD.nextInt(Integer.MAX_VALUE);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \",\n+                  IRNode.MUL_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \",\n+                  IRNode.MAX_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \",\n+                  IRNode.MIN_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"},\n+        applyIfCPUFeature = {\"avx\", \"true\"})\n+    public void testVectorIRSharing1(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        vec1.lanewise(VectorOperators.ADD, vec2)\n+            .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+            .intoArray(ir1, index);\n+        vec1.lanewise(VectorOperators.MUL, vec2)\n+            .lanewise(VectorOperators.MUL, vec2.lanewise(VectorOperators.MUL, vec1))\n+            .intoArray(ir2, index);\n+        vec1.lanewise(VectorOperators.MAX, vec2)\n+            .lanewise(VectorOperators.MAX, vec2.lanewise(VectorOperators.MAX, vec1))\n+            .intoArray(ir3, index);\n+        vec1.lanewise(VectorOperators.MIN, vec2)\n+            .lanewise(VectorOperators.MIN, vec2.lanewise(VectorOperators.MIN, vec1))\n+            .intoArray(ir4, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing1\")\n+    public void testVectorIRSharingDriver1() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing1(i);\n+        }\n+        checkVectorIRSharing1();\n+    }\n+\n+    public void checkVectorIRSharing1() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] + ib[i]) + (ib[i] + ia[i]));\n+            Verify.checkEQ(ir2[i], (ia[i] * ib[i]) * (ib[i] * ia[i]));\n+            Verify.checkEQ(ir3[i], Integer.max(Integer.max(ia[i], ib[i]), Integer.max(ib[i], ia[i])));\n+            Verify.checkEQ(ir4[i], Integer.min(Integer.max(ia[i], ib[i]), Integer.min(ib[i], ia[i])));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.XOR_VI, IRNode.VECTOR_SIZE_ANY, \" 0 \",\n+                  IRNode.OR_VI, IRNode.VECTOR_SIZE_ANY, \" 1 \",\n+                  IRNode.AND_VI, IRNode.VECTOR_SIZE_ANY, \" 1 \"},\n+        applyIfCPUFeature = {\"avx\", \"true\"})\n+    public void testVectorIRSharing2(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        vec1.lanewise(VectorOperators.XOR, vec2)\n+            .lanewise(VectorOperators.XOR, vec2.lanewise(VectorOperators.XOR, vec1))\n+            .intoArray(ir1, index);\n+        vec1.lanewise(VectorOperators.AND, vec2)\n+            .lanewise(VectorOperators.AND, vec2.lanewise(VectorOperators.AND, vec1))\n+            .intoArray(ir2, index);\n+        vec1.lanewise(VectorOperators.OR, vec2)\n+            .lanewise(VectorOperators.OR, vec2.lanewise(VectorOperators.OR, vec1))\n+            .intoArray(ir3, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing2\")\n+    public void testVectorIRSharingDriver2() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing2(i);\n+        }\n+        checkVectorIRSharing2();\n+    }\n+\n+    public void checkVectorIRSharing2() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] ^ ib[i]) ^ (ib[i] ^ ia[i]));\n+            Verify.checkEQ(ir2[i], (ia[i] & ib[i]) & (ib[i] & ia[i]));\n+            Verify.checkEQ(ir3[i], (ia[i] | ib[i]) | (ib[i] | ia[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SATURATING_ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"}, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public void testVectorIRSharing3(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        vec1.lanewise(VectorOperators.SADD, vec2)\n+            .lanewise(VectorOperators.SADD, vec2.lanewise(VectorOperators.SADD, vec1))\n+            .intoArray(ir4, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing3\")\n+    public void testVectorIRSharingDriver3() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing3(i);\n+        }\n+        checkVectorIRSharing3();\n+    }\n+\n+    public void checkVectorIRSharing3() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir4[i], VectorMath.addSaturating(VectorMath.addSaturating(ia[i], ib[i]),\n+                                                            VectorMath.addSaturating(ib[i], ia[i])));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    public void testVectorIRSharing4(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec1 + vec1) + (vec1 + vec1)\n+        vec1.lanewise(VectorOperators.ADD, vec1)\n+            .lanewise(VectorOperators.ADD, vec1.lanewise(VectorOperators.ADD, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing4\")\n+    public void testVectorIRSharingDriver4() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing4(i);\n+        }\n+        checkVectorIRSharing4();\n+    }\n+\n+    public void checkVectorIRSharing4() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] + ia[i]) + (ia[i] + ia[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    public void testVectorIRSharing5(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec1 + vec1) + (vec1 + vec2)\n+        vec1.lanewise(VectorOperators.ADD, vec1)\n+            .lanewise(VectorOperators.ADD, vec1.lanewise(VectorOperators.ADD, vec2))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing5\")\n+    public void testVectorIRSharingDriver5() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing5(i);\n+        }\n+        checkVectorIRSharing5();\n+    }\n+\n+    public void checkVectorIRSharing5() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] + ia[i]) + (ia[i] + ib[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    public void testVectorIRSharing6(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec1 + vec1) + (vec2 + vec1)\n+        vec1.lanewise(VectorOperators.ADD, vec1)\n+            .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing6\")\n+    public void testVectorIRSharingDriver6() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing6(i);\n+        }\n+        checkVectorIRSharing6();\n+    }\n+\n+    public void checkVectorIRSharing6() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] + ia[i]) + (ib[i] + ia[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    public void testVectorIRSharing7(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec1 + vec1) + (vec2 + vec2)\n+        vec1.lanewise(VectorOperators.ADD, vec1)\n+            .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec2))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing7\")\n+    public void testVectorIRSharingDriver7() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing7(i);\n+        }\n+        checkVectorIRSharing7();\n+    }\n+\n+    public void checkVectorIRSharing7() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] + ia[i]) + (ib[i] + ib[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    public void testVectorIRSharing8(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec1 + vec2) + (vec1 + vec1)\n+        vec1.lanewise(VectorOperators.ADD, vec2)\n+            .lanewise(VectorOperators.ADD, vec1.lanewise(VectorOperators.ADD, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing8\")\n+    public void testVectorIRSharingDriver8() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing8(i);\n+        }\n+        checkVectorIRSharing8();\n+    }\n+\n+    public void checkVectorIRSharing8() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] + ib[i]) + (ia[i] + ia[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    public void testVectorIRSharing9(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec1 + vec2) + (vec1 + vec2)\n+        vec1.lanewise(VectorOperators.ADD, vec2)\n+            .lanewise(VectorOperators.ADD, vec1.lanewise(VectorOperators.ADD, vec2))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing9\")\n+    public void testVectorIRSharingDriver9() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing9(i);\n+        }\n+        checkVectorIRSharing9();\n+    }\n+\n+    public void checkVectorIRSharing9() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] + ib[i]) + (ia[i] + ib[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    public void testVectorIRSharing10(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec1 + vec2) + (vec2 + vec1)\n+        vec1.lanewise(VectorOperators.ADD, vec2)\n+            .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing10\")\n+    public void testVectorIRSharingDriver10() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing10(i);\n+        }\n+        checkVectorIRSharing10();\n+    }\n+\n+    public void checkVectorIRSharing10() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] + ib[i]) + (ib[i] + ia[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    public void testVectorIRSharing11(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec1 + vec2) + (vec2 + vec2)\n+        vec1.lanewise(VectorOperators.ADD, vec2)\n+            .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec2))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing11\")\n+    public void testVectorIRSharingDriver11() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing11(i);\n+        }\n+        checkVectorIRSharing11();\n+    }\n+\n+    public void checkVectorIRSharing11() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ia[i] + ib[i]) + (ib[i] + ib[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    public void testVectorIRSharing12(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec2 + vec1) + (vec1 + vec1)\n+        vec2.lanewise(VectorOperators.ADD, vec1)\n+            .lanewise(VectorOperators.ADD, vec1.lanewise(VectorOperators.ADD, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing12\")\n+    public void testVectorIRSharingDriver12() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing12(i);\n+        }\n+        checkVectorIRSharing12();\n+    }\n+\n+    public void checkVectorIRSharing12() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ib[i] + ia[i]) + (ia[i] + ia[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    public void testVectorIRSharing13(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec2 + vec1) + (vec1 + vec2)\n+        vec2.lanewise(VectorOperators.ADD, vec1)\n+            .lanewise(VectorOperators.ADD, vec1.lanewise(VectorOperators.ADD, vec2))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing13\")\n+    public void testVectorIRSharingDriver13() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing13(i);\n+        }\n+        checkVectorIRSharing13();\n+    }\n+\n+    public void checkVectorIRSharing13() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ib[i] + ia[i]) + (ia[i] + ib[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    public void testVectorIRSharing14(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec2 + vec1) + (vec2 + vec1)\n+        vec2.lanewise(VectorOperators.ADD, vec1)\n+            .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing14\")\n+    public void testVectorIRSharingDriver14() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing14(i);\n+        }\n+        checkVectorIRSharing14();\n+    }\n+\n+    public void checkVectorIRSharing14() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ib[i] + ia[i]) + (ib[i] + ia[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    public void testVectorIRSharing15(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec2 + vec1) + (vec2 + vec2)\n+        vec2.lanewise(VectorOperators.ADD, vec1)\n+            .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec2))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing15\")\n+    public void testVectorIRSharingDriver15() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing15(i);\n+        }\n+        checkVectorIRSharing15();\n+    }\n+\n+    public void checkVectorIRSharing15() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ib[i] + ia[i]) + (ib[i] + ib[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    public void testVectorIRSharing16(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec2 + vec2) + (vec1 + vec1)\n+        vec2.lanewise(VectorOperators.ADD, vec2)\n+            .lanewise(VectorOperators.ADD, vec1.lanewise(VectorOperators.ADD, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing16\")\n+    public void testVectorIRSharingDriver16() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing16(i);\n+        }\n+        checkVectorIRSharing16();\n+    }\n+\n+    public void checkVectorIRSharing16() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ib[i] + ib[i]) + (ia[i] + ia[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    public void testVectorIRSharing17(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec2 + vec2) + (vec1 + vec2)\n+        vec2.lanewise(VectorOperators.ADD, vec2)\n+            .lanewise(VectorOperators.ADD, vec1.lanewise(VectorOperators.ADD, vec2))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing17\")\n+    public void testVectorIRSharingDriver17() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing17(i);\n+        }\n+        checkVectorIRSharing17();\n+    }\n+\n+    public void checkVectorIRSharing17() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ib[i] + ib[i]) + (ia[i] + ib[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    public void testVectorIRSharing18(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ (vec2 + vec2) + (vec2 + vec1)\n+        vec2.lanewise(VectorOperators.ADD, vec2)\n+            .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing18\")\n+    public void testVectorIRSharingDriver18() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing18(i);\n+        }\n+        checkVectorIRSharing18();\n+    }\n+\n+    public void checkVectorIRSharing18() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], (ib[i] + ib[i]) + (ib[i] + ia[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeatureOr = {\"avx512vl\", \"true\", \"sve\", \"true\"})\n+    public void testVectorIRSharing19(int index) {\n+        VectorMask<Integer> VMASK = VectorMask.fromLong(I_SPECIES, ((1 << 4) - 1));\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ PRED:(vec1 + vec2) + PRED:(vec2 + vec1)\n+        vec1.lanewise(VectorOperators.ADD, vec2, VMASK)\n+            .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1, VMASK))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing19\")\n+    public void testVectorIRSharingDriver19() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing19(i);\n+        }\n+        checkVectorIRSharing19();\n+    }\n+\n+    public void checkVectorIRSharing19() {\n+        VectorMask<Integer> VMASK = VectorMask.fromLong(I_SPECIES, ((1 << 4) - 1));\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            boolean mask = VMASK.laneIsSet(i & (I_SPECIES.length() - 1));\n+            Verify.checkEQ(ir1[i], (mask ? ia[i] + ib[i] : ia[i]) + (mask ? ib[i] + ia[i] : ib[i]));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCommutativeOperSharingTest.java","additions":576,"deletions":0,"binary":false,"changes":576,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ *  Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.Random;\n+import java.util.Arrays;\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class VectorCommutativeOperSharingBenchmark {\n+    @Param({\"1024\",\"2048\"})\n+    int size;\n+\n+    byte[] bytesrc1;\n+    byte[] bytesrc2;\n+    byte[] byteres;\n+\n+    short[] shortsrc1;\n+    short[] shortsrc2;\n+    short[] shortres;\n+\n+    int[] intsrc1;\n+    int[] intsrc2;\n+    int[] intres;\n+\n+    long[] longsrc1;\n+    long[] longsrc2;\n+    long[] longres;\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        Random r = new Random(1024);\n+        bytesrc1 = new byte[size];\n+        bytesrc2 = new byte[size];\n+        byteres = new byte[size];\n+\n+        shortsrc1 = new short[size];\n+        shortsrc2 = new short[size];\n+        shortres = new short[size];\n+\n+        intsrc1 = new int[size];\n+        intsrc2 = new int[size];\n+        intres = new int[size];\n+\n+        longsrc1 = new long[size];\n+        longsrc2 = new long[size];\n+        longres = new long[size];\n+\n+        Arrays.fill(bytesrc1, (byte)1);\n+        Arrays.fill(bytesrc2, (byte)2);\n+\n+        Arrays.fill(shortsrc1, (short)1);\n+        Arrays.fill(shortsrc2, (short)2);\n+\n+        Arrays.fill(intsrc1, 1);\n+        Arrays.fill(intsrc2, 2);\n+\n+        Arrays.fill(longsrc1, 1);\n+        Arrays.fill(longsrc2, 2);\n+    }\n+\n+    @Benchmark\n+    public void commutativeByteOperationShairing() {\n+        for (int i = 0; i < size; i += ByteVector.SPECIES_PREFERRED.length()) {\n+            ByteVector vec1 = ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, bytesrc1, i);\n+            ByteVector vec2 = ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, bytesrc2, i);\n+            vec1.lanewise(VectorOperators.ADD, vec2)\n+                 .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+                 .lanewise(VectorOperators.MUL, vec1.lanewise(VectorOperators.MUL, vec2))\n+                 .lanewise(VectorOperators.MUL, vec2.lanewise(VectorOperators.MUL, vec1))\n+                 .lanewise(VectorOperators.AND, vec1.lanewise(VectorOperators.AND, vec2))\n+                 .lanewise(VectorOperators.AND, vec2.lanewise(VectorOperators.AND, vec1))\n+                 .lanewise(VectorOperators.OR, vec1.lanewise(VectorOperators.OR, vec2))\n+                 .lanewise(VectorOperators.OR, vec2.lanewise(VectorOperators.OR, vec1))\n+                 .intoArray(byteres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void commutativeShortOperationShairing() {\n+        for (int i = 0; i < size; i += ShortVector.SPECIES_PREFERRED.length()) {\n+            ShortVector vec1 = ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortsrc1, i);\n+            ShortVector vec2 = ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortsrc2, i);\n+            vec1.lanewise(VectorOperators.ADD, vec2)\n+                 .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+                 .lanewise(VectorOperators.MUL, vec1.lanewise(VectorOperators.MUL, vec2))\n+                 .lanewise(VectorOperators.MUL, vec2.lanewise(VectorOperators.MUL, vec1))\n+                 .lanewise(VectorOperators.AND, vec1.lanewise(VectorOperators.AND, vec2))\n+                 .lanewise(VectorOperators.AND, vec2.lanewise(VectorOperators.AND, vec1))\n+                 .lanewise(VectorOperators.OR, vec1.lanewise(VectorOperators.OR, vec2))\n+                 .lanewise(VectorOperators.OR, vec2.lanewise(VectorOperators.OR, vec1))\n+                 .intoArray(shortres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void commutativeIntOperationShairing() {\n+        for (int i = 0; i < size; i += IntVector.SPECIES_PREFERRED.length()) {\n+            IntVector vec1 = IntVector.fromArray(IntVector.SPECIES_PREFERRED, intsrc1, i);\n+            IntVector vec2 = IntVector.fromArray(IntVector.SPECIES_PREFERRED, intsrc2, i);\n+            vec1.lanewise(VectorOperators.ADD, vec2)\n+                 .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+                 .lanewise(VectorOperators.MUL, vec1.lanewise(VectorOperators.MUL, vec2))\n+                 .lanewise(VectorOperators.MUL, vec2.lanewise(VectorOperators.MUL, vec1))\n+                 .lanewise(VectorOperators.AND, vec1.lanewise(VectorOperators.AND, vec2))\n+                 .lanewise(VectorOperators.AND, vec2.lanewise(VectorOperators.AND, vec1))\n+                 .lanewise(VectorOperators.OR, vec1.lanewise(VectorOperators.OR, vec2))\n+                 .lanewise(VectorOperators.OR, vec2.lanewise(VectorOperators.OR, vec1))\n+                 .intoArray(intres, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void commutativeLongOperationShairing() {\n+        for (int i = 0; i < size; i += LongVector.SPECIES_PREFERRED.length()) {\n+            LongVector vec1 = LongVector.fromArray(LongVector.SPECIES_PREFERRED, longsrc1, i);\n+            LongVector vec2 = LongVector.fromArray(LongVector.SPECIES_PREFERRED, longsrc2, i);\n+            vec1.lanewise(VectorOperators.ADD, vec2)\n+                 .lanewise(VectorOperators.ADD, vec2.lanewise(VectorOperators.ADD, vec1))\n+                 .lanewise(VectorOperators.MUL, vec1.lanewise(VectorOperators.MUL, vec2))\n+                 .lanewise(VectorOperators.MUL, vec2.lanewise(VectorOperators.MUL, vec1))\n+                 .lanewise(VectorOperators.AND, vec1.lanewise(VectorOperators.AND, vec2))\n+                 .lanewise(VectorOperators.AND, vec2.lanewise(VectorOperators.AND, vec1))\n+                 .lanewise(VectorOperators.OR, vec1.lanewise(VectorOperators.OR, vec2))\n+                 .lanewise(VectorOperators.OR, vec2.lanewise(VectorOperators.OR, vec1))\n+                 .intoArray(longres, i);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/VectorCommutativeOperSharingBenchmark.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"}]}