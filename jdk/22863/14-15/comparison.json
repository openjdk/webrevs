{"files":[{"patch":"@@ -64,31 +64,0 @@\n-\/\/-----------------------------------------------------------------------------\n-\n-bool NodeHash::have_equivalent_inputs(const Node* n, const Node* k) const {\n-  \/\/ For commutative operations with same controlling edge\n-  \/\/ perform order agnostic input edge comparison to promote\n-  \/\/ node sharing.\n-  uint req = n->req();\n-  \/\/ Predicated vector operations are sensitive to ordering of inputs.\n-  \/\/ When the mask corresponding to a vector lane is false then\n-  \/\/ the result of the operation is corresponding lane of its first operand.\n-  \/\/   i.e. RES = VEC1.lanewise(OPER, VEC2, MASK) is semantically equivalent to\n-  \/\/        RES = VEC1.BLEND(VEC1.lanewise(OPER, VEC2), MASK)\n-  \/\/ Here, first operand \"VEC1\" represents both source and destination vector.\n-  if (n->is_commutative_vector_operation() && !n->is_predicated_vector()) {\n-    assert(req == 3, \"\");\n-    assert(k->is_commutative_vector_operation(), \"\");\n-    if ((k->in(0) != n->in(0)) ||\n-        ((k->in(1) != n->in(1) || k->in(2) != n->in(2)) &&\n-         (k->in(1) != n->in(2) || k->in(2) != n->in(1)))) {\n-      return false;\n-    }\n-  } else {\n-    for (uint i = 0; i < req; i++) {\n-      if (n->in(i) != k->in(i)) { \/\/ Different inputs?\n-        return false;\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -118,1 +87,4 @@\n-      if (have_equivalent_inputs(n, k) && n->cmp(*k)) {  \/\/ Check for any special bits\n+      for( uint i=0; i<req; i++ )\n+        if( n->in(i)!=k->in(i)) \/\/ Different inputs?\n+          goto collision;       \/\/ \"goto\" is a speed hack...\n+      if( n->cmp(*k) ) {        \/\/ Check for any special bits\n@@ -123,1 +95,1 @@\n-    \/\/ k was not a hit. Find another candidate and try again.\n+  collision:\n@@ -167,1 +139,4 @@\n-      if (have_equivalent_inputs(n, k) && n->cmp(*k)) {  \/\/ Check for any special bits\n+      for( uint i=0; i<req; i++ )\n+        if( n->in(i)!=k->in(i)) \/\/ Different inputs?\n+          goto collision;       \/\/ \"goto\" is a speed hack...\n+      if( n->cmp(*k) ) {        \/\/ Check for any special bits\n@@ -172,1 +147,1 @@\n-    \/\/ k was not a hit. Find another candidate and try again.\n+  collision:\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":10,"deletions":35,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-  bool   have_equivalent_inputs(const Node* n, const Node* k) const;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1045,0 +1045,51 @@\n+bool VectorNode::can_swap_inputs() {\n+  \/\/ Must be a binary operation.\n+  if (req() != 3) {\n+    return false;\n+  }\n+\n+  \/\/ Predicated vector operations are sensitive to ordering of inputs.\n+  \/\/ When the mask corresponding to a vector lane is false then\n+  \/\/ the result of the operation is corresponding lane of its first operand.\n+  \/\/   i.e. RES = VEC1.lanewise(OPER, VEC2, MASK) is semantically equivalent to\n+  \/\/        RES = VEC1.BLEND(VEC1.lanewise(OPER, VEC2), MASK)\n+  \/\/ Here, first operand \"VEC1\" represents both source and destination vector.\n+  if (is_predicated_vector()) {\n+    return false;\n+  }\n+\n+  switch(Opcode()) {\n+    case Op_AddVB:\n+    case Op_AddVS:\n+    case Op_AddVI:\n+    case Op_AddVL:\n+    case Op_AddVF:\n+    case Op_AddVD:\n+\n+    case Op_MulVB:\n+    case Op_MulVS:\n+    case Op_MulVI:\n+    case Op_MulVL:\n+    case Op_MulVF:\n+    case Op_MulVD:\n+\n+    case Op_MaxV:\n+    case Op_MinV:\n+    case Op_XorV:\n+    case Op_OrV:\n+    case Op_AndV:\n+\n+    case Op_AndVMask:\n+    case Op_OrVMask:\n+    case Op_XorVMask:\n+\n+    case Op_SaturatingAddV:\n+      if (in(1)->_idx > in(2)->_idx) {\n+        return true;\n+      }\n+      \/\/ fallthrough\n+    default:\n+      return false;\n+  }\n+}\n+\n@@ -1049,0 +1100,4 @@\n+  \/\/ Sort inputs of commutative non-predicated vector operations to help value numbering.\n+  if (can_swap_inputs()) {\n+    swap_edges(1, 2);\n+  }\n@@ -2079,1 +2134,1 @@\n-  return nullptr;\n+  return VectorNode::Ideal(phase, can_reshape);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":56,"deletions":1,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -76,15 +76,0 @@\n-  virtual uint hash() const {\n-    \/\/ Predicated vector operations are sensitive to ordering of inputs.\n-    \/\/ When the mask corresponding to a vector lane is false then\n-    \/\/ the result of the operation is corresponding lane of its first operand.\n-    \/\/   i.e. RES = VEC1.lanewise(OPER, VEC2, MASK) is semantically equivalent to\n-    \/\/        RES = VEC1.BLEND(VEC1.lanewise(OPER, VEC2), MASK)\n-    \/\/ Here, first operand \"VEC1\" represents both source and destination vector.\n-    if (is_commutative_vector_operation() && !is_predicated_vector()) {\n-      assert(req() == 3, \"\");\n-      return (uintptr_t)in(1) + (uintptr_t)in(2) + Opcode();\n-    } else {\n-      return Node::hash();\n-    }\n-  }\n-\n@@ -106,0 +91,2 @@\n+  bool can_swap_inputs();\n+\n@@ -195,3 +182,1 @@\n-  AddVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  AddVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n@@ -205,3 +190,1 @@\n-  AddVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  AddVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n@@ -215,3 +198,1 @@\n-  AddVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  AddVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n@@ -225,3 +206,1 @@\n-  AddVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  AddVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n@@ -235,3 +214,1 @@\n-  AddVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  AddVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n@@ -245,3 +222,1 @@\n-  AddVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  AddVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n@@ -417,3 +392,1 @@\n-  SaturatingAddVNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1, in2, vt, is_unsigned) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  SaturatingAddVNode(Node* in1, Node* in2, const TypeVect* vt, bool is_unsigned) : SaturatingVectorNode(in1, in2, vt, is_unsigned) {}\n@@ -451,3 +424,1 @@\n-  MulVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  MulVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n@@ -461,3 +432,1 @@\n-  MulVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  MulVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n@@ -471,3 +440,1 @@\n-  MulVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  MulVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n@@ -483,1 +450,0 @@\n-    add_flag(Node::Flag_is_commutative_vector_op);\n@@ -494,3 +460,1 @@\n-  MulVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  MulVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n@@ -504,3 +468,1 @@\n-  MulVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  MulVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n@@ -648,3 +610,1 @@\n-  MinVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  MinVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n@@ -658,1 +618,0 @@\n-    add_flag(Node::Flag_is_commutative_vector_op);\n@@ -667,3 +626,1 @@\n-  MaxVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  MaxVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n@@ -677,1 +634,0 @@\n-    add_flag(Node::Flag_is_commutative_vector_op);\n@@ -950,3 +906,1 @@\n-  AndVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  AndVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n@@ -969,3 +923,1 @@\n-  OrVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  OrVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n@@ -988,3 +940,1 @@\n-  XorVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  XorVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n@@ -1398,3 +1348,1 @@\n-  AndVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : AndVNode(in1, in2, vt) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  AndVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : AndVNode(in1, in2, vt) {}\n@@ -1407,3 +1355,1 @@\n-  OrVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : OrVNode(in1, in2, vt) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  OrVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : OrVNode(in1, in2, vt) {}\n@@ -1416,3 +1362,1 @@\n-  XorVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : XorVNode(in1, in2, vt) {\n-    add_flag(Node::Flag_is_commutative_vector_op);\n-  }\n+  XorVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : XorVNode(in1, in2, vt) {}\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":22,"deletions":78,"binary":false,"changes":100,"status":"modified"}]}