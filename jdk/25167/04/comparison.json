{"files":[{"patch":"@@ -50,1 +50,1 @@\n-    DISABLED_WARNINGS := dangling-doc-comments options, \\\n+    DISABLED_WARNINGS := dangling-doc-comments options suppression, \\\n@@ -84,1 +84,1 @@\n-    DISABLED_WARNINGS := options, \\\n+    DISABLED_WARNINGS := options suppression, \\\n","filename":"make\/CompileToolsJdk.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    DISABLED_WARNINGS := dangling-doc-comments, \\\n+    DISABLED_WARNINGS := dangling-doc-comments suppression, \\\n","filename":"make\/GenerateLinkOptData.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    DISABLED_WARNINGS := options, \\\n+    DISABLED_WARNINGS := options suppression, \\\n","filename":"make\/JrtfsJar.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-#\n-# DISABLED_WARNINGS_java +=\n+\n+DISABLED_WARNINGS_java += suppression\n","filename":"make\/modules\/java.base\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-DISABLED_WARNINGS_java += dangling-doc-comments lossy-conversions this-escape\n+DISABLED_WARNINGS_java += dangling-doc-comments lossy-conversions this-escape suppression\n","filename":"make\/modules\/java.desktop\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-DISABLED_WARNINGS_java += dangling-doc-comments this-escape\n+DISABLED_WARNINGS_java += dangling-doc-comments this-escape suppression\n","filename":"make\/modules\/java.management\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-DISABLED_WARNINGS_java += dangling-doc-comments this-escape\n+DISABLED_WARNINGS_java += dangling-doc-comments this-escape suppression\n","filename":"make\/modules\/java.xml.crypto\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-DISABLED_WARNINGS_java += dangling-doc-comments lossy-conversions this-escape\n+DISABLED_WARNINGS_java += dangling-doc-comments lossy-conversions this-escape \\\n+    suppression\n","filename":"make\/modules\/java.xml\/Java.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-COPY += .txt\n+DISABLED_WARNINGS_java += suppression\n","filename":"make\/modules\/jdk.attach\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.md\/Java.gmk","status":"copied"},{"patch":"@@ -28,1 +28,1 @@\n-DISABLED_WARNINGS_java += dangling-doc-comments this-escape\n+DISABLED_WARNINGS_java += dangling-doc-comments this-escape suppression\n","filename":"make\/modules\/jdk.internal.le\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+DISABLED_WARNINGS_java += suppression\n+\n","filename":"make\/modules\/jdk.jlink\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-DISABLED_WARNINGS_java += dangling-doc-comments\n+DISABLED_WARNINGS_java += dangling-doc-comments suppression\n","filename":"make\/modules\/jdk.jpackage\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+DISABLED_WARNINGS_java += suppression\n+\n","filename":"make\/modules\/jdk.jshell\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-COPY += .txt\n+DISABLED_WARNINGS_java += suppression\n","filename":"make\/modules\/jdk.management.agent\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.md\/Java.gmk","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-COPY += .txt\n+DISABLED_WARNINGS_java += suppression\n","filename":"make\/modules\/jdk.management.jfr\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.internal.md\/Java.gmk","status":"copied"},{"patch":"@@ -28,1 +28,1 @@\n-DISABLED_WARNINGS_java += this-escape\n+DISABLED_WARNINGS_java += this-escape suppression\n","filename":"make\/modules\/jdk.management\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    DISABLED_WARNINGS := options serial try this-escape, \\\n+    DISABLED_WARNINGS := options serial try this-escape suppression, \\\n","filename":"make\/test\/BuildFailureHandler.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-        serial preview dangling-doc-comments, \\\n+        serial preview dangling-doc-comments suppression, \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+    DISABLED_WARNINGS := suppression, \\\n","filename":"make\/test\/BuildTestLib.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import com.sun.tools.javac.util.Log;\n@@ -83,0 +82,1 @@\n+        suppressions.removeIf(lc -> !lc.annotationSuppression);     \/\/ ignore categories that don't support @SuppressWarnings\n@@ -84,1 +84,1 @@\n-            Lint lint = new Lint(this);\n+            Lint lint = new Lint(this, sym);\n@@ -97,1 +97,1 @@\n-        Lint l = new Lint(this);\n+        Lint l = new Lint(this, symbol);\n@@ -108,1 +108,1 @@\n-        Lint l = new Lint(this);\n+        Lint l = new Lint(this, symbol);\n@@ -116,1 +116,1 @@\n-    private final Log log;\n+    private final LintMapper lintMapper;\n@@ -126,0 +126,4 @@\n+    \/\/ The symbol of the declaration this instance was created for, or null for the root instance\n+    private final Symbol symbol;\n+\n+    \/\/ LintCategory lookup by option string\n@@ -128,0 +132,1 @@\n+    \/\/ Instantiate the root instance\n@@ -133,1 +138,2 @@\n-        log = Log.instance(context);\n+        lintMapper = LintMapper.instance(context);\n+        symbol = null;\n@@ -137,2 +143,3 @@\n-    protected Lint(Lint other) {\n-        other.initializeRootIfNeeded();\n+    protected Lint(Lint other, Symbol symbol) {\n+        Assert.check(symbol != null);\n+        this.symbol = symbol;\n@@ -141,1 +148,1 @@\n-        this.log = other.log;\n+        this.lintMapper = other.lintMapper;\n@@ -176,1 +183,5 @@\n-        return \"Lint:[enable\" + values + \",suppress\" + suppressedValues + \"]\";\n+        return \"Lint[\"\n+          + (symbol != null ? \"sym=\" + symbol : \"ROOT\")\n+          + \",enable\" + values\n+          + \",suppress\" + suppressedValues\n+          + \"]\";\n@@ -355,0 +366,5 @@\n+        \/**\n+         * Warn about recognized {@code @SuppressWarnings} lint categories that don't actually suppress any warnings.\n+         *\/\n+        SUPPRESSION(\"suppression\"),\n+\n@@ -442,0 +458,16 @@\n+    \/**\n+     * Determine whether warnings in the given category need to be calculated within the current delcaration\n+     * because either (a) the category is enabled, or (b) lint category {@code \"suppression\"} is enabled.\n+     *\n+     * <p>\n+     * In case (b), warnings don't need to be calculated unless\/until the category is actually suppressed,\n+     * but that might not happen until some nested declaration, so we can't include a test for that here.\n+     *\n+     * <p>\n+     * Use of this method is never required; it simply helps avoid potentially useless work.\n+     *\/\n+    public boolean isActive(LintCategory lc) {\n+        initializeRootIfNeeded();\n+        return values.contains(lc) || values.contains(LintCategory.SUPPRESSION);\n+    }\n+\n@@ -446,0 +478,10 @@\n+     *\n+     * <p>\n+     * This method also optionally validates any warning suppression currently in scope.\n+     * If you just want to know the configuration of this instance, set {@code validate} to false.\n+     * If you are using the result of this method to control whether a warning is actually\n+     * generated, then set {@code validate} to true to ensure that any suppression of the\n+     * category in scope is validated (i.e., determined to actually be suppressing something).\n+     *\n+     * @param lc lint category\n+     * @param validateSuppression true to also validate any suppression of the category\n@@ -447,1 +489,1 @@\n-    public boolean isEnabled(LintCategory lc) {\n+    public boolean isEnabled(LintCategory lc, boolean validateSuppression) {\n@@ -449,0 +491,2 @@\n+        if (validateSuppression)\n+            validateSuppression(lc);\n@@ -457,0 +501,10 @@\n+     *\n+     * <p>\n+     * This method also optionally validates any warning suppression currently in scope.\n+     * If you just want to know the configuration of this instance, set {@code validate} to false.\n+     * If you are using the result of this method to control whether a warning is actually\n+     * generated, then set {@code validate} to true to ensure that any suppression of the\n+     * category in scope is validated (i.e., determined to actually be suppressing something).\n+     *\n+     * @param lc lint category\n+     * @param validateSuppression true to also validate any suppression of the category\n@@ -458,1 +512,1 @@\n-    public boolean isSuppressed(LintCategory lc) {\n+    public boolean isSuppressed(LintCategory lc, boolean validateSuppression) {\n@@ -460,0 +514,2 @@\n+        if (validateSuppression)\n+            validateSuppression(lc);\n@@ -480,0 +536,14 @@\n+    \/**\n+     * Retrieve the recognized lint categories suppressed by the given @SuppressWarnings annotation.\n+     *\n+     * @param annotation @SuppressWarnings annotation, or null\n+     * @return set of lint categories, possibly empty but never null\n+     *\/\n+    public EnumSet<LintCategory> suppressionsFrom(JCAnnotation annotation) {\n+        initializeSymbolsIfNeeded();\n+        if (annotation == null)\n+            return LintCategory.newEmptySet();\n+        Assert.check(annotation.attribute.type.tsym == syms.suppressWarningsType.tsym);\n+        return suppressionsFrom(Stream.of(annotation).map(anno -> anno.attribute));\n+    }\n+\n@@ -500,1 +570,0 @@\n-                  .filter(lc -> lc.annotationSuppression)\n@@ -507,0 +576,17 @@\n+    \/**\n+     * Validate any suppression of the given lint category currently in scope.\n+     *\n+     * <p>\n+     * Such a suppression will therefore <b>not<\/b> be declared as unnecessary by the\n+     * {@code \"suppression\"} warning.\n+     *\n+     * @param lc the lint category to be validated\n+     * @return this instance\n+     *\/\n+    public Lint validateSuppression(LintCategory lc) {\n+        initializeRootIfNeeded();\n+        if (values.contains(LintCategory.SUPPRESSION))\n+            lintMapper.validateSuppression(symbol, lc);\n+        return this;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":99,"deletions":13,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.Collection;\n+import java.util.EnumSet;\n@@ -35,0 +37,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -38,0 +42,3 @@\n+import com.sun.tools.javac.code.Lint.LintCategory;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -46,0 +53,1 @@\n+import com.sun.tools.javac.util.Log;\n@@ -60,0 +68,27 @@\n+ * <p>\n+ * This class also tracks which {@code @SuppressWarnings} suppressions actually suppress something;\n+ * any that don't are unnecessary and will generate warnings in the {@code \"suppression\"} category.\n+ * For this to work, this class must be notified any time a warning that is currently suppressed\n+ * <i>would have<\/i> been reported; this is termed the \"validation\" of the suppression. That notification\n+ * happens by invoking {@link #validateSuppression}.\n+ *\n+ * <p>\n+ * Validation events \"bubble up\" the source tree until either they are \"caught\" by a {@code @SuppressWarnings}\n+ * annotation, or they escape the file entirely. Being caught validates the corresponding suppression.\n+ * A suppression that is never caught (i.e., never validated) is unnecessary.\n+ *\n+ * <p>\n+ * Some additional nuances:\n+ * <ul>\n+ *  <li>Lint warnings can be suppressed at a module, package, class, method, or variable declaration\n+ *      (via {@code @SuppressWarnings}), or globally on the command line via {@code -Xlint:-key}.\n+ *  <li>Consequently, unnecessary suppression warnings can only be emitted at {@code @SuppressWarnings}\n+ *      annotations. Currently, we don't report unnecessary suppression via {@code -Xlint:-key} flags.\n+ *  <li>Some lint categories don't support suppression via the {@code @SuppressWarnings} annotations\n+ *      (e.g., {@code \"classfile\"}). Specifying such a category in a {@code @SuppressWarnings} annotation\n+ *      is always unnecessary and will trigger an unnecessary suppression warning (if enabled).\n+ *  <li>{@code @SuppressWarnings(\"suppression\")} is normal and valid: it means unnecessary suppression\n+ *      warnings won't occur for that annotation or any other {@code @SuppressWarnings} annotations within\n+ *      the scope of the annotated declaration.\n+ * <\/ul>\n+ *\n@@ -78,0 +113,2 @@\n+    private Symtab syms;\n+    private Log log;\n@@ -100,1 +137,1 @@\n-        if (rootLint == null)\n+        if (rootLint == null) {\n@@ -102,0 +139,3 @@\n+            syms = Symtab.instance(context);\n+            log = Log.instance(context);\n+        }\n@@ -139,1 +179,1 @@\n-        fileInfoMap.get(sourceFile).afterAttr(tree, endPositions);\n+        fileInfoMap.get(sourceFile).afterAttr(tree, endPositions, syms);\n@@ -167,0 +207,52 @@\n+\/\/ Suppression Tracking\n+\n+    \/**\n+     * Validate the given lint category within the scope of the given symbol's declaration.\n+     *\n+     * <p>\n+     * This indicates that any suppression of {@code category} currently in scope is necesssary.\n+     *\n+     * @param symbol innermost {@code @SuppressWarnings}-annotated symbol in scope, or null for global scope\n+     * @param category lint category to validate\n+     *\/\n+    public void validateSuppression(Symbol symbol, LintCategory category) {\n+        if (symbol != null)\n+            fileInfoMap.get(log.currentSourceFile()).validationsFor(symbol).add(category);\n+    }\n+\n+    \/**\n+     * Warn about unnecessary {@code @SuppressWarnings} suppressions within the given top-level declaration.\n+     *\n+     * <p>\n+     * All warnings within {@code tree} must have already been calculated when this method is invoked.\n+     *\n+     * @param sourceFile source file\n+     * @param tree top level declaration\n+     *\/\n+    public void reportUnnecessarySuppressionAnnotations(JavaFileObject sourceFile, JCTree tree) {\n+\n+        \/\/ Anything to do here?\n+        initializeIfNeeded();\n+        if (!rootLint.isEnabled(LintCategory.SUPPRESSION, false))\n+            return;\n+\n+        \/\/ Find the LintRange corresponding to \"tree\"\n+        FileInfo fileInfo = fileInfoMap.get(sourceFile);\n+        LintRange lintRange = fileInfo.rootRange.findChild(tree.pos());\n+\n+        \/\/ Propagate validations within \"tree\" to determine which suppressions therein never got validated\n+        fileInfo.propagateValidations(lintRange);\n+\n+        \/\/ Report unvalidated suppresions, except where SUPPRESSION is itself suppressed\n+        lintRange.stream()\n+          .filter(node -> node.lint.isEnabled(LintCategory.SUPPRESSION, false))\n+          .forEach(node -> {\n+            String unnecessaryCategoryNames = node.unvalidated.stream()\n+              .map(category -> category.option)\n+              .map(name -> \"\\\"\" + name + \"\\\"\")\n+              .collect(Collectors.joining(\", \"));\n+            if (!unnecessaryCategoryNames.isEmpty())\n+                log.warning(node.annotation.pos(), LintWarnings.UnnecessaryWarningSuppression(unnecessaryCategoryNames));\n+        });\n+    }\n+\n@@ -181,0 +273,2 @@\n+        final Map<Symbol, EnumSet<LintCategory>> validationsMap \/\/ maps declaration symbol to validations therein\n+          = new HashMap<>();\n@@ -192,1 +286,1 @@\n-        void afterAttr(JCTree tree, EndPosTable endPositions) {\n+        void afterAttr(JCTree tree, EndPosTable endPositions, Symtab syms) {\n@@ -195,1 +289,1 @@\n-                    rootRange.populateSubtree(tree, endPositions);\n+                    rootRange.populateSubtree(this, tree, endPositions, syms);\n@@ -212,0 +306,19 @@\n+        \/\/ Obtain the validation state for the given symbol\n+        EnumSet<LintCategory> validationsFor(Symbol symbol) {\n+            return validationsMap.computeIfAbsent(symbol, s -> LintCategory.newEmptySet());\n+        }\n+\n+        \/\/ Merge the validation sets for two variables declared together, thereby sharing any @SuppressWarnings annotation.\n+        \/\/ See \"annotationRepresentativeSymbolMap\" below for more detail on why this is needed.\n+        void mergeValidations(VarSymbol symbol1, VarSymbol symbol2) {\n+            EnumSet<LintCategory> validations1 = validationsFor(symbol1);\n+            EnumSet<LintCategory> validations2 = validationsFor(symbol2);\n+            Assert.check(validations1.equals(validations2));\n+            validationsMap.put(symbol2, validations1);          \/\/ now the two symbols share the same validation set\n+        }\n+\n+        \/\/ Propagate validations in the given top-level node\n+        EnumSet<LintCategory> propagateValidations(LintRange lintRange) {\n+            return lintRange.propagateValidations(validationsMap);\n+        }\n+\n@@ -250,0 +363,4 @@\n+        Symbol symbol,                                  \/\/ declaration symbol (null for root range)\n+        JCAnnotation annotation,                        \/\/ the @SuppressWarnings on this declaration, if any\n+        EnumSet<LintCategory> suppressions,             \/\/ categories suppressed by @SuppressWarnings\n+        EnumSet<LintCategory> unvalidated,              \/\/ categories suppressed by @SuppressWarnings that were never validated\n@@ -255,1 +372,1 @@\n-            this(Span.MAXIMAL, rootLint, new LinkedList<>());\n+            this(Span.MAXIMAL, rootLint, null, null, LintCategory.newEmptySet(), LintCategory.newEmptySet(), new LinkedList<>());\n@@ -259,2 +376,4 @@\n-        LintRange(JCTree tree, EndPosTable endPositions, Lint lint) {\n-            this(new Span(tree, endPositions), lint, new LinkedList<>());\n+        LintRange(JCTree tree, EndPosTable endPositions, Lint lint, Symbol symbol,\n+          JCAnnotation annotation, EnumSet<LintCategory> suppressions) {\n+            this(new Span(tree, endPositions), lint, symbol,\n+              annotation, suppressions, EnumSet.copyOf(suppressions), new LinkedList<>());\n@@ -278,0 +397,42 @@\n+        \/\/ Find the child containing the given position\n+        LintRange findChild(DiagnosticPosition pos) {\n+            return children.stream()\n+              .filter(node -> node.span.contains(pos))\n+              .findFirst()\n+              .orElseThrow(() -> new AssertionError(\"child not found\"));\n+        }\n+\n+        \/\/ Stream this node and all descendents via pre-order recursive descent\n+        Stream<LintRange> stream() {\n+            return Stream.concat(Stream.of(this), children.stream().flatMap(LintRange::stream));\n+        }\n+\n+        \/\/ Calculate the unvalidated suppressions in the subtree rooted at this node. We do this by recursively\n+        \/\/ propagating validations upward until they are \"caught\" by some matching suppression; this validates\n+        \/\/ the suppression. Validations that are never caught \"escape\" and are returned to the caller.\n+        public EnumSet<LintCategory> propagateValidations(Map<Symbol, EnumSet<LintCategory>> validationsMap) {\n+\n+            \/\/ Recurse on subtrees first and gather their uncaught validations\n+            EnumSet<LintCategory> validations = LintCategory.newEmptySet();\n+            children.stream()\n+              .map(child -> child.propagateValidations(validationsMap))\n+              .forEach(validations::addAll);\n+\n+            \/\/ Add in the validations that occurred at this node, if any\n+            Optional.of(symbol)\n+              .map(validationsMap::get)\n+              .ifPresent(validations::addAll);\n+\n+            \/\/ Apply (and then discard) validations that match any of this node's suppressions\n+            validations.removeIf(category -> {\n+                if (suppressions.contains(category)) {\n+                    unvalidated.remove(category);\n+                    return true;\n+                }\n+                return false;\n+            });\n+\n+            \/\/ Any remaining validations \"escape\" and propagate upward\n+            return validations;\n+        }\n+\n@@ -279,2 +440,4 @@\n-        \/\/ Only when the Lint configuration differs from the parent is a node added.\n-        void populateSubtree(JCTree tree, EndPosTable endPositions) {\n+        \/\/ Only \"interesting\" declarations are included:\n+        \/\/  - Declarations that have a different Lint configuration from their parent\n+        \/\/  - Declarations with a @SuppressWarnings annotation\n+        void populateSubtree(FileInfo fileInfo, JCTree tree, EndPosTable endPositions, Symtab syms) {\n@@ -283,0 +446,5 @@\n+                \/\/ Variables declared together (separated by commas) share any @SuppressWarnings annotation, so they must also\n+                \/\/ share the set of validated suppressions. That is, the suppression of a lint category is valid if a warning\n+                \/\/ would have been generated by *any* of the variables. We detect this particular scenario using this map.\n+                private final Map<JCAnnotation, VarSymbol> annotationRepresentativeSymbolMap = new HashMap<>();\n+\n@@ -287,1 +455,1 @@\n-                    scanDecl(tree, tree.sym, super::visitModuleDef);\n+                    scanDecl(tree, tree.sym, findAnnotation(tree.mods), super::visitModuleDef);\n@@ -291,1 +459,1 @@\n-                    scanDecl(tree, tree.packge, super::visitPackageDef);\n+                    scanDecl(tree, tree.packge, findAnnotation(tree.annotations), super::visitPackageDef);\n@@ -295,1 +463,1 @@\n-                    scanDecl(tree, tree.sym, super::visitClassDef);\n+                    scanDecl(tree, tree.sym, findAnnotation(tree.mods), super::visitClassDef);\n@@ -299,1 +467,1 @@\n-                    scanDecl(tree, tree.sym, super::visitMethodDef);\n+                    scanDecl(tree, tree.sym, findAnnotation(tree.mods), super::visitMethodDef);\n@@ -303,1 +471,1 @@\n-                    scanDecl(tree, tree.sym, super::visitVarDef);\n+                    scanDecl(tree, tree.sym, findAnnotation(tree.mods), super::visitVarDef);\n@@ -306,1 +474,2 @@\n-                private <T extends JCTree> void scanDecl(T tree, Symbol symbol, Consumer<? super T> recursor) {\n+                private <T extends JCTree> void scanDecl(T tree,\n+                  Symbol symbol, JCAnnotation annotation, Consumer<? super T> recursor) {\n@@ -314,1 +483,1 @@\n-                    \/\/ Update the Lint using the declaration; if there's no change, then we don't need a new node here\n+                    \/\/ Update the Lint using the declaration\n@@ -316,1 +485,16 @@\n-                    if (newLint == currentNode.lint) {  \/\/ note: lint.augment() returns the same instance if there's no change\n+\n+                    \/\/ Get the lint categories explicitly suppressed at this symbol's declaration by @SuppressedWarnings\n+                    EnumSet<LintCategory> suppressed = Optional.ofNullable(annotation)\n+                      .map(anno -> lint.suppressionsFrom(anno))\n+                      .orElseGet(LintCategory::newEmptySet);\n+\n+                    \/\/ Merge validation sets for variables that share the same declaration (and therefore @SuppressedWarnings)\n+                    if (annotation != null && symbol instanceof VarSymbol varSym) {\n+                        annotationRepresentativeSymbolMap.merge(annotation, varSym, (oldSymbol, newSymbol) -> {\n+                            fileInfo.mergeValidations(oldSymbol, newSymbol);\n+                            return oldSymbol;\n+                        });\n+                    }\n+\n+                    \/\/ If this declaration is not \"interesting\", then we don't need a new node here\n+                    if (newLint == currentNode.lint && currentNode.symbol != null && suppressed.isEmpty()) {\n@@ -323,1 +507,1 @@\n-                    currentNode = new LintRange(tree, endPositions, newLint);\n+                    currentNode = new LintRange(tree, endPositions, newLint, symbol, annotation, suppressed);\n@@ -331,0 +515,18 @@\n+\n+                \/\/ Retrieve the @SuppressWarnings annotation, if any, from the given modifiers\n+                private JCAnnotation findAnnotation(JCModifiers mods) {\n+                    return Optional.ofNullable(mods)\n+                      .map(m -> m.annotations)\n+                      .map(this::findAnnotation)\n+                      .orElse(null);\n+                }\n+\n+                \/\/ Retrieve the @SuppressWarnings annotation, if any, from the given list of annotations\n+                private JCAnnotation findAnnotation(Collection<JCAnnotation> annotations) {\n+                    return Optional.ofNullable(annotations)\n+                      .stream()\n+                      .flatMap(Collection::stream)\n+                      .filter(a -> a.attribute.type.tsym == syms.suppressWarningsType.tsym)\n+                      .findFirst()\n+                      .orElse(null);\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/LintMapper.java","additions":220,"deletions":18,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -5691,1 +5691,1 @@\n-        if (env.info.lint.isEnabled(LintCategory.SERIAL)\n+        if (env.info.lint.isActive(LintCategory.SERIAL)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2123,1 +2123,1 @@\n-        if (lint.isEnabled(LintCategory.OVERRIDES)) {\n+        if (lint.isActive(LintCategory.OVERRIDES)) {\n@@ -2175,1 +2175,1 @@\n-        if (lint.isEnabled(LintCategory.MODULE)) {\n+        if (lint.isActive(LintCategory.MODULE)) {\n@@ -2646,1 +2646,1 @@\n-        if (!lint.isEnabled(LintCategory.OVERLOADS))\n+        if (!lint.isActive(LintCategory.OVERLOADS))\n@@ -2659,4 +2659,0 @@\n-        \/\/ Allow site's own declared methods (only) to apply @SuppressWarnings(\"overloads\")\n-        methodGroups.forEach(list -> list.removeIf(\n-            m -> m.owner == site.tsym && !lint.augment(m).isEnabled(LintCategory.OVERLOADS)));\n-\n@@ -2670,0 +2666,10 @@\n+            \/\/ Allow the site's own declared methods (only) to apply @SuppressWarnings(\"overloads\").\n+            \/\/ Treat both methods equally so they \"share\" the validation of the warning suppression,\n+            \/\/ but also verify an annotation actually exists on a method before doing that, because\n+            \/\/ otherwise we could incorrectly validate an outer annotation.\n+            Predicate<MethodSymbol> methodSuppresses = m -> m.owner == site.tsym &&\n+              m.attribute(syms.suppressWarningsType.tsym) != null &&\n+              lint.augment(m).isSuppressed(LintCategory.OVERLOADS, true);\n+            if (methodSuppresses.test(m1) | methodSuppresses.test(m2))  \/\/ use \"|\" to validate @SuppressWarnings on BOTH methods\n+                return FIRST | SECOND;\n+\n@@ -3681,1 +3687,1 @@\n-        if (lint.isEnabled(LintCategory.DEP_ANN) && s.isDeprecatableViaAnnotation() &&\n+        if (lint.isActive(LintCategory.DEP_ANN) && s.isDeprecatableViaAnnotation() &&\n@@ -3688,1 +3694,1 @@\n-        if (lint.isEnabled(LintCategory.DEPRECATION) && !s.isDeprecatableViaAnnotation()) {\n+        if (lint.isActive(LintCategory.DEPRECATION) && !s.isDeprecatableViaAnnotation()) {\n@@ -4216,1 +4222,1 @@\n-        if (lint.isEnabled(LintCategory.MISSING_EXPLICIT_CTOR) &&\n+        if (lint.isActive(LintCategory.MISSING_EXPLICIT_CTOR) &&\n@@ -4434,1 +4440,1 @@\n-                    if (lint.isEnabled(LintCategory.EXPORTS)) {\n+                    if (lint.isActive(LintCategory.EXPORTS)) {\n@@ -4448,1 +4454,1 @@\n-                    if (lint.isEnabled(LintCategory.EXPORTS)) {\n+                    if (lint.isActive(LintCategory.EXPORTS)) {\n@@ -4467,1 +4473,1 @@\n-                    if (lint.isEnabled(LintCategory.EXPORTS)) {\n+                    if (lint.isActive(LintCategory.EXPORTS)) {\n@@ -4866,0 +4872,8 @@\n+        \/\/ Because runUnderLint() uses \"augment\" to customize the current Lint instance,\n+        \/\/ we must check if the warning category is enabled manually before logging a warning.\n+        private void logWarning(DiagnosticPosition pos, LintWarning warningKey) {\n+            if (lint.isEnabled(warningKey.getLintCategory(), true)) {\n+                log.warning(pos, warningKey);\n+            }\n+        }\n+\n@@ -4897,1 +4911,1 @@\n-                log.warning(p.pos(), LintWarnings.MissingSVUID(c));\n+                logWarning(p.pos(), LintWarnings.MissingSVUID(c));\n@@ -4924,3 +4938,2 @@\n-                                    log.warning(\n-                                            TreeInfo.diagnosticPositionFor(enclosed, tree),\n-                                                LintWarnings.NonSerializableInstanceField);\n+                                    logWarning(TreeInfo.diagnosticPositionFor(enclosed, tree),\n+                                            LintWarnings.NonSerializableInstanceField);\n@@ -4935,3 +4948,2 @@\n-                                        log.warning(\n-                                                TreeInfo.diagnosticPositionFor(enclosed, tree),\n-                                                    LintWarnings.NonSerializableInstanceFieldArray(elementType));\n+                                        logWarning(TreeInfo.diagnosticPositionFor(enclosed, tree),\n+                                                LintWarnings.NonSerializableInstanceFieldArray(elementType));\n@@ -5020,2 +5032,1 @@\n-                log.warning(tree.pos(),\n-                            LintWarnings.ExternalizableMissingPublicNoArgCtor);\n+                logWarning(tree.pos(), LintWarnings.ExternalizableMissingPublicNoArgCtor);\n@@ -5048,2 +5059,2 @@\n-                                    log.warning(tree.pos(),\n-                                                LintWarnings.SerializableMissingAccessNoArgCtor(supertype.getQualifiedName()));\n+                                    logWarning(tree.pos(),\n+                                            LintWarnings.SerializableMissingAccessNoArgCtor(supertype.getQualifiedName()));\n@@ -5067,3 +5078,1 @@\n-                 log.warning(\n-                         TreeInfo.diagnosticPositionFor(svuid, tree),\n-                             LintWarnings.ImproperSVUID((Symbol)e));\n+                 logWarning(TreeInfo.diagnosticPositionFor(svuid, tree), LintWarnings.ImproperSVUID((Symbol)e));\n@@ -5074,3 +5083,1 @@\n-                 log.warning(\n-                         TreeInfo.diagnosticPositionFor(svuid, tree),\n-                             LintWarnings.LongSVUID((Symbol)e));\n+                 logWarning(TreeInfo.diagnosticPositionFor(svuid, tree), LintWarnings.LongSVUID((Symbol)e));\n@@ -5080,3 +5087,1 @@\n-                 log.warning(\n-                         TreeInfo.diagnosticPositionFor(svuid, tree),\n-                             LintWarnings.ConstantSVUID((Symbol)e));\n+                 logWarning(TreeInfo.diagnosticPositionFor(svuid, tree), LintWarnings.ConstantSVUID((Symbol)e));\n@@ -5089,3 +5094,1 @@\n-                 log.warning(\n-                         TreeInfo.diagnosticPositionFor(spf, tree),\n-                             LintWarnings.ImproperSPF);\n+                 logWarning(TreeInfo.diagnosticPositionFor(spf, tree), LintWarnings.ImproperSPF);\n@@ -5095,3 +5098,1 @@\n-                 log.warning(\n-                         TreeInfo.diagnosticPositionFor(spf, tree),\n-                             LintWarnings.OSFArraySPF);\n+                 logWarning(TreeInfo.diagnosticPositionFor(spf, tree), LintWarnings.OSFArraySPF);\n@@ -5101,3 +5102,1 @@\n-                log.warning(\n-                        TreeInfo.diagnosticPositionFor(spf, tree),\n-                            LintWarnings.IneffectualSerialFieldExternalizable);\n+                logWarning(TreeInfo.diagnosticPositionFor(spf, tree), LintWarnings.IneffectualSerialFieldExternalizable);\n@@ -5113,2 +5112,1 @@\n-                     log.warning(initExpr.pos(),\n-                                 LintWarnings.SPFNullInit);\n+                     logWarning(initExpr.pos(), LintWarnings.SPFNullInit);\n@@ -5192,3 +5190,2 @@\n-                log.warning(\n-                        TreeInfo.diagnosticPositionFor(method, tree),\n-                            LintWarnings.IneffectualExternalizableMethodRecord(method.getSimpleName().toString()));\n+                logWarning(TreeInfo.diagnosticPositionFor(method, tree),\n+                        LintWarnings.IneffectualExternalizableMethodRecord(method.getSimpleName().toString()));\n@@ -5201,3 +5198,1 @@\n-                log.warning(\n-                        TreeInfo.diagnosticPositionFor(method, tree),\n-                            LintWarnings.SerialMethodNotPrivate(method.getSimpleName()));\n+                logWarning(TreeInfo.diagnosticPositionFor(method, tree), LintWarnings.SerialMethodNotPrivate(method.getSimpleName()));\n@@ -5207,3 +5202,1 @@\n-                log.warning(\n-                        TreeInfo.diagnosticPositionFor(method, tree),\n-                            LintWarnings.SerialMethodStatic(method.getSimpleName()));\n+                logWarning(TreeInfo.diagnosticPositionFor(method, tree), LintWarnings.SerialMethodStatic(method.getSimpleName()));\n@@ -5232,3 +5225,1 @@\n-                            log.warning(\n-                                    TreeInfo.diagnosticPositionFor(field, tree),\n-                                        LintWarnings.IneffectualSerialFieldEnum(name));\n+                            logWarning(TreeInfo.diagnosticPositionFor(field, tree), LintWarnings.IneffectualSerialFieldEnum(name));\n@@ -5241,3 +5232,1 @@\n-                            log.warning(\n-                                    TreeInfo.diagnosticPositionFor(method, tree),\n-                                        LintWarnings.IneffectualSerialMethodEnum(name));\n+                            logWarning(TreeInfo.diagnosticPositionFor(method, tree), LintWarnings.IneffectualSerialMethodEnum(name));\n@@ -5281,3 +5270,2 @@\n-                log.warning(\n-                        TreeInfo.diagnosticPositionFor(method, tree),\n-                            LintWarnings.IneffectualExternMethodEnum(method.getSimpleName().toString()));\n+                logWarning(TreeInfo.diagnosticPositionFor(method, tree),\n+                        LintWarnings.IneffectualExternMethodEnum(method.getSimpleName().toString()));\n@@ -5313,3 +5301,1 @@\n-                            log.warning(\n-                                    TreeInfo.diagnosticPositionFor(field, tree),\n-                                        LintWarnings.IneffectualSerialFieldInterface);\n+                            logWarning(TreeInfo.diagnosticPositionFor(field, tree), LintWarnings.IneffectualSerialFieldInterface);\n@@ -5353,3 +5339,1 @@\n-                log.warning(\n-                        TreeInfo.diagnosticPositionFor(method, tree),\n-                            LintWarnings.NonPrivateMethodWeakerAccess);\n+                logWarning(TreeInfo.diagnosticPositionFor(method, tree), LintWarnings.NonPrivateMethodWeakerAccess);\n@@ -5363,3 +5347,1 @@\n-                log.warning(\n-                        TreeInfo.diagnosticPositionFor(method, tree),\n-                            LintWarnings.DefaultIneffective);\n+                logWarning(TreeInfo.diagnosticPositionFor(method, tree), LintWarnings.DefaultIneffective);\n@@ -5410,3 +5392,1 @@\n-                            log.warning(\n-                                    TreeInfo.diagnosticPositionFor(field, tree),\n-                                        LintWarnings.IneffectualSerialFieldRecord);\n+                            logWarning(TreeInfo.diagnosticPositionFor(field, tree), LintWarnings.IneffectualSerialFieldRecord);\n@@ -5434,3 +5414,2 @@\n-                                log.warning(\n-                                        TreeInfo.diagnosticPositionFor(method, tree),\n-                                            LintWarnings.IneffectualSerialMethodRecord(name));\n+                                logWarning(TreeInfo.diagnosticPositionFor(method, tree),\n+                                        LintWarnings.IneffectualSerialMethodRecord(name));\n@@ -5448,3 +5427,2 @@\n-                    log.warning(\n-                            TreeInfo.diagnosticPositionFor(method, tree),\n-                                LintWarnings.SerialConcreteInstanceMethod(method.getSimpleName()));\n+                    logWarning(TreeInfo.diagnosticPositionFor(method, tree),\n+                            LintWarnings.SerialConcreteInstanceMethod(method.getSimpleName()));\n@@ -5465,3 +5443,2 @@\n-                log.warning(\n-                        TreeInfo.diagnosticPositionFor(method, tree),\n-                            LintWarnings.SerialMethodUnexpectedReturnType(method.getSimpleName(),\n+                logWarning(TreeInfo.diagnosticPositionFor(method, tree),\n+                        LintWarnings.SerialMethodUnexpectedReturnType(method.getSimpleName(),\n@@ -5481,3 +5458,2 @@\n-                log.warning(\n-                        TreeInfo.diagnosticPositionFor(method, tree),\n-                            LintWarnings.SerialMethodOneArg(method.getSimpleName(), parameters.size()));\n+                logWarning(TreeInfo.diagnosticPositionFor(method, tree),\n+                        LintWarnings.SerialMethodOneArg(method.getSimpleName(), parameters.size()));\n@@ -5489,3 +5465,2 @@\n-                log.warning(\n-                        TreeInfo.diagnosticPositionFor(method, tree),\n-                            LintWarnings.SerialMethodParameterType(method.getSimpleName(),\n+                logWarning(TreeInfo.diagnosticPositionFor(method, tree),\n+                        LintWarnings.SerialMethodParameterType(method.getSimpleName(),\n@@ -5510,3 +5485,2 @@\n-                log.warning(\n-                        TreeInfo.diagnosticPositionFor(parameters.get(0), tree),\n-                            LintWarnings.SerialMethodNoArgs(method.getSimpleName()));\n+                logWarning(TreeInfo.diagnosticPositionFor(parameters.get(0), tree),\n+                        LintWarnings.SerialMethodNoArgs(method.getSimpleName()));\n@@ -5519,3 +5493,2 @@\n-                log.warning(\n-                        TreeInfo.diagnosticPositionFor(method, tree),\n-                            LintWarnings.IneffectualSerialMethodExternalizable(method.getSimpleName()));\n+                logWarning(TreeInfo.diagnosticPositionFor(method, tree),\n+                        LintWarnings.IneffectualSerialMethodExternalizable(method.getSimpleName()));\n@@ -5548,4 +5521,2 @@\n-                        log.warning(\n-                                TreeInfo.diagnosticPositionFor(method, tree),\n-                                    LintWarnings.SerialMethodUnexpectedException(method.getSimpleName(),\n-                                                                             thrownType));\n+                        logWarning(TreeInfo.diagnosticPositionFor(method, tree),\n+                                LintWarnings.SerialMethodUnexpectedException(method.getSimpleName(), thrownType));\n@@ -5563,1 +5534,1 @@\n-                if (lint.isEnabled(LintCategory.SERIAL)) {\n+                if (lint.isActive(LintCategory.SERIAL)) {\n@@ -5665,1 +5636,1 @@\n-                lint.isEnabled(LintCategory.IDENTITY)) {\n+                lint.isActive(LintCategory.IDENTITY)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":72,"deletions":101,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -1354,1 +1354,1 @@\n-        if (lint.isEnabled(LintCategory.INCUBATING)) {\n+        if (lint.isActive(LintCategory.INCUBATING)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-        if (!lintMapper.lintAt(env.toplevel.sourcefile, env.tree.pos()).get().isEnabled(THIS_ESCAPE))\n+        if (!lintMapper.lintAt(env.toplevel.sourcefile, env.tree.pos()).get().isActive(THIS_ESCAPE))\n@@ -345,1 +345,1 @@\n-        \/\/ Manually apply any Lint suppression\n+        \/\/ Manually apply (and validate) any Lint suppression\n@@ -1725,1 +1725,1 @@\n-            return suppressible && !lint().isEnabled(THIS_ESCAPE);\n+            return suppressible && !lint().isEnabled(THIS_ESCAPE, true);\n@@ -1790,6 +1790,6 @@\n-        \/\/ Determine whether this warning is suppressed. A single \"this-escape\" warning involves multiple source code\n-        \/\/ positions, so we must determine suppression manually. We do this as follows: A warning is suppressed if\n-        \/\/ \"this-escape\" is disabled at any position in the stack where that stack frame corresponds to a constructor\n-        \/\/ or field initializer in the target class. That means, for example, @SuppressWarnings(\"this-escape\") annotations\n-        \/\/ on regular methods are ignored. Here we work our way back up the call stack from the point of the leak until\n-        \/\/ we encounter a suppressible stack frame.\n+        \/\/ Determine whether this warning is suppressed and, if so, validate that suppression. A single \"this-escape\"\n+        \/\/ warning involves multiple source code positions, so we must determine and validate suppression manually.\n+        \/\/ We do this as follows: A warning is suppressed if \"this-escape\" is disabled at any position in the stack\n+        \/\/ where that stack frame corresponds to a constructor or field initializer in the target class. That means,\n+        \/\/ for example, @SuppressWarnings(\"this-escape\") annotations on regular methods are ignored. We work our way\n+        \/\/ back up the call stack from the point of the leak until we encounter a suppressible stack frame.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.tools.javac.code.LintMapper;\n@@ -45,0 +46,1 @@\n+    private final LintMapper lintMapper;\n@@ -58,0 +60,1 @@\n+        lintMapper = LintMapper.instance(context);\n@@ -62,0 +65,3 @@\n+\n+        \/\/ This one should go last\n+        lintMapper.reportUnnecessarySuppressionAnnotations(env.toplevel.sourcefile, env.tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/WarningAnalyzer.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -522,1 +522,1 @@\n-        if (!lint.isEnabled(LintCategory.OUTPUT_FILE_CLASH))\n+        if (!lint.isActive(LintCategory.OUTPUT_FILE_CLASH))\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/BaseFileManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2275,0 +2275,5 @@\n+# 0: string\n+# lint: suppression\n+compiler.warn.unnecessary.warning.suppression=\\\n+    unnecessary warning suppression: {0}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -221,0 +221,3 @@\n+javac.opt.Xlint.desc.suppression=\\\n+    Warn about recognized @SuppressWarnings values that don''t actually suppress any warnings.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+                Lint theRootLint = rootLint();\n@@ -149,1 +150,3 @@\n-                    if (!rootLint().isEnabled(category) &&\n+                    \/\/ But if tracking SUPPRESSION, skip this optimization because it might cause a validation to be missed.\n+                    if (!theRootLint.isEnabled(category, false) &&\n+                      !theRootLint.isEnabled(SUPPRESSION, false) &&\n@@ -160,1 +163,1 @@\n-                    lint = rootLint();\n+                    lint = theRootLint;\n@@ -171,1 +174,1 @@\n-            if (diag.getCode().equals(RequiresTransitiveAutomatic.key()) && !lint.isEnabled(REQUIRES_TRANSITIVE_AUTOMATIC)) {\n+            if (diag.getCode().equals(RequiresTransitiveAutomatic.key()) && !lint.isEnabled(REQUIRES_TRANSITIVE_AUTOMATIC, true)) {\n@@ -181,1 +184,1 @@\n-                  lint.isEnabled(category) :                            \/\/ then emit if the category is enabled\n+                  lint.isEnabled(category, false) :                     \/\/ then emit if the category is enabled\n@@ -183,1 +186,1 @@\n-                    !lint.isSuppressed(category) :                      \/\/ ...suppression happens via @SuppressWarnings\n+                    !lint.isSuppressed(category, false) :               \/\/ ...suppression happens via @SuppressWarnings\n@@ -185,1 +188,2 @@\n-                if (!emit)\n+                if (!emit) {\n+                    validateSuppression(new SuppressionValidation(lint, diag));     \/\/ validate any suppression\n@@ -187,0 +191,1 @@\n+                }\n@@ -198,0 +203,5 @@\n+        \/**\n+         * Validate a lint suppression.\n+         *\/\n+        protected abstract void validateSuppression(SuppressionValidation validation);\n+\n@@ -233,0 +243,7 @@\n+\n+        \/\/ Represents the operation by which the suppression of a lint category is validated\n+        protected record SuppressionValidation(Lint lint, JCDiagnostic diag) {\n+            void apply() {\n+                lint.validateSuppression(diag.getLintCategory());\n+            }\n+        }\n@@ -245,0 +262,3 @@\n+\n+        @Override\n+        protected void validateSuppression(SuppressionValidation validation) { }\n@@ -256,0 +276,1 @@\n+        private List<SuppressionValidation> validatedSuppressions = new ArrayList<>();\n@@ -294,0 +315,9 @@\n+        @Override\n+        protected void validateSuppression(SuppressionValidation validation) {\n+            if (deferrable(validation.diag)) {\n+                validatedSuppressions.add(validation);\n+            } else {\n+                prev.validateSuppression(validation);\n+            }\n+        }\n+\n@@ -318,0 +348,6 @@\n+\n+            \/\/ Flush matching suppression validations to the previous handler\n+            validatedSuppressions.stream()\n+              .filter(vs -> accepter.test(vs.diag))\n+              .forEach(prev::validateSuppression);\n+            validatedSuppressions = null; \/\/ prevent accidental ongoing use\n@@ -950,2 +986,6 @@\n-                    boolean verbose = lintFor(diagnostic).isEnabled(category);\n-                    if (!aggregatorFor(category).aggregate(diagnostic, verbose))\n+                    Lint lint = lintFor(diagnostic);\n+                    boolean verbose = lint.isEnabled(category, false);\n+                    if (!aggregatorFor(category).aggregate(diagnostic, verbose)) {\n+\n+                        \/\/ Aggregation effectively suppresses the warning, so validate that suppression\n+                        validateSuppression(new SuppressionValidation(lint, diagnostic));\n@@ -953,0 +993,1 @@\n+                    }\n@@ -985,0 +1026,5 @@\n+\n+        @Override\n+        protected void validateSuppression(SuppressionValidation validation) {\n+            validation.apply();     \/\/ make it real\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Log.java","additions":54,"deletions":8,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,0 +188,1 @@\n+ * <tr><th scope=\"row\">{@code suppression}          <td>unnecessary suppressions in {@code @SuppressWarnings} annotations\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -660,0 +660,3 @@\n+    -   `suppression`: Warns about recognized `@SuppressWarnings` values that\n+        don't actually suppress any warnings.\n+\n","filename":"src\/jdk.compiler\/share\/man\/javac.md","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.unnecessary.warning.suppression\n+\/\/ options: -Xlint:suppression\n+\n+@SuppressWarnings(\"unchecked\")\n+class X {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/WarnUnnecessaryLintSuppression.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,1085 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8344159\n+ * @summary Test \"suppression\" lint warnings\n+ * @library \/tools\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.code\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask toolbox.JarTask\n+ * @run main SuppressionWarningTest\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.LinkOption;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import com.sun.tools.javac.code.Lint;\n+import com.sun.tools.javac.code.Lint.LintCategory;\n+import com.sun.tools.javac.code.Source;\n+\n+import toolbox.JarTask;\n+import toolbox.JavacTask;\n+import toolbox.Task.Mode;\n+import toolbox.Task;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+import static com.sun.tools.javac.code.Lint.LintCategory.*;\n+\n+public class SuppressionWarningTest extends TestRunner {\n+\n+    \/\/ Test cases for testSuppressWarnings(). Each test case triggers a warning the the corresponding\n+    \/\/ lint category at a point in the source template which is nested inside two possible @SuppressWarnings\n+    \/\/ annotations locations which are marked by \"@INNER@\" and \"@OUTER@\" markers.\n+    public static final List<SuppressTest> SUPPRESS_WARNINGS_TEST_CASES = Stream.of(LintCategory.values())\n+      .map(category -> switch (category) {\n+        case AUXILIARYCLASS -> new SuppressTest(category,\n+            \"compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file\",\n+            null,\n+            \"\"\"\n+            public class Class1 { }\n+            class AuxClass { }\n+            \"\"\",\n+            \"\"\"\n+            @OUTER@\n+            public class Class2 {\n+                @INNER@\n+                public Object obj = new AuxClass();\n+            }\n+            \"\"\"\n+        );\n+\n+        case CAST -> new SuppressTest(category,\n+            \"compiler.warn.redundant.cast\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                @INNER@\n+                public Object obj = (Object)new Object();\n+            }\n+            \"\"\"\n+        );\n+\n+        case CLASSFILE -> null; \/\/ skip, too hard to simluate\n+\n+        case DANGLING_DOC_COMMENTS -> new SuppressTest(category,\n+            \"compiler.warn.dangling.doc.comment\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                \/** Dangling comment *\/\n+                \/** Javadoc comment *\/\n+                @INNER@\n+                public void foo() {\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case DEPRECATION -> new SuppressTest(category,\n+            \"compiler.warn.has.been.deprecated\",\n+            null,\n+            \"\"\"\n+            public class Super {\n+                @Deprecated\n+                public void foo() { }\n+            }\n+            \"\"\",\n+            \"\"\"\n+            @OUTER@\n+            public class Sub extends Super {\n+                @INNER@\n+                @Override\n+                public void foo() { }\n+            }\n+            \"\"\"\n+        );\n+\n+        case DEP_ANN -> new SuppressTest(category,\n+            \"compiler.warn.missing.deprecated.annotation\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                @INNER@\n+                public class TestSub {\n+                    \/** @deprecated *\/\n+                    public void method() { }\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case DIVZERO -> new SuppressTest(category,\n+            \"compiler.warn.div.zero\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                @INNER@\n+                public int method() {\n+                    return 1\/0;\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case EMPTY -> new SuppressTest(category,\n+            \"compiler.warn.empty.if\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                @INNER@\n+                public void method(boolean x) {\n+                    if (x);\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case EXPORTS -> new SuppressTest(category,\n+            \"compiler.warn.leaks.not.accessible\",\n+            null,\n+            \"\"\"\n+            module mod {\n+                exports pkg1;\n+            }\n+            \"\"\",\n+            \"\"\"\n+            \/\/ @MODULE@:mod\n+            package pkg1;\n+            @OUTER@\n+            public class Class1 {\n+                @INNER@\n+                public pkg2.Class2 obj2;    \/\/ warning here\n+            }\n+            \"\"\",\n+            \"\"\"\n+            \/\/ @MODULE@:mod\n+            package pkg2;\n+            public class Class2 {\n+            }\n+            \"\"\"\n+        );\n+\n+        case FALLTHROUGH -> new SuppressTest(category,\n+            \"compiler.warn.possible.fall-through.into.case\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                @INNER@\n+                public void method(int x) {\n+                    switch (x) {\n+                    case 1:\n+                        System.out.println(1);\n+                    default:\n+                        System.out.println(0);\n+                    }\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case FINALLY -> new SuppressTest(category,\n+            \"compiler.warn.finally.cannot.complete\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                @INNER@\n+                public void method(int x) {\n+                    try {\n+                        System.out.println(x);\n+                    } finally {\n+                        throw new RuntimeException();\n+                    }\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case INCUBATING -> null; \/\/ skip, too hard to simluate reliably over time\n+\n+        case LOSSY_CONVERSIONS -> new SuppressTest(category,\n+            \"compiler.warn.possible.loss.of.precision\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                @INNER@\n+                public void method() {\n+                    long b = 1L;\n+                    b += 0.1 * 3L;\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case MISSING_EXPLICIT_CTOR -> new SuppressTest(category,\n+            \"compiler.warn.missing-explicit-ctor\",\n+            null,\n+            \"\"\"\n+            module mod {\n+                exports pkg1;\n+            }\n+            \"\"\",\n+            \"\"\"\n+            package pkg1;\n+            @OUTER@\n+            public class Class1 {\n+                public Class1(int x) {\n+                }\n+                @INNER@\n+                public static class Sub {\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case MODULE -> new SuppressTest(category,\n+            \"compiler.warn.poor.choice.for.module.name\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            module mod0 {\n+            }\n+            \"\"\"\n+        );\n+\n+        case OPENS -> new SuppressTest(category,\n+            \"compiler.warn.package.empty.or.not.found\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            module mod {\n+                opens pkg1;\n+            }\n+            \"\"\"\n+        );\n+\n+        case OPTIONS -> new SuppressTest(category,\n+            \"compiler.warn.addopens.ignored\",\n+            new String[] { \"--add-opens\", \"foo\/bar=ALL-UNNAMED\" },\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                @INNER@\n+                public class Test2 {\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        \/\/ This test case only works on MacOS\n+        case OUTPUT_FILE_CLASH ->\n+            System.getProperty(\"os.name\").startsWith(\"Mac\") ?\n+              new SuppressTest(category,\n+                \"compiler.warn.output.file.clash\",\n+                null,\n+                \"\"\"\n+                @OUTER@\n+                public class Test {\n+                    interface Cafe\\u0301 {      \/\/ macos normalizes \"e\" + U0301 -> U00e9\n+                    }\n+                    interface Caf\\u00e9 {\n+                    }\n+                }\n+                \"\"\"\n+              ) : null;\n+\n+        case OVERLOADS -> new SuppressTest(category,\n+            \"compiler.warn.potentially.ambiguous.overload\",\n+            null,\n+            \"\"\"\n+            import java.util.function.*;\n+            @OUTER@\n+            public class Super {\n+                public void foo(IntConsumer c) {\n+                }\n+                @INNER@\n+                public void foo(Consumer<Integer> c) {\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case OVERRIDES -> new SuppressTest(category,\n+            \"compiler.warn.override.equals.but.not.hashcode\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                @INNER@\n+                public class Test2 {\n+                    public boolean equals(Object obj) {\n+                        return false;\n+                    }\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case PATH -> new SuppressTest(category,\n+            \"compiler.warn.path.element.not.found\",\n+            new String[] { \"-classpath\", \"\/nonigzistint\" },\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                @INNER@\n+                public class Test2 {\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case PROCESSING -> null;    \/\/ skip for now\n+\n+        case RAW -> new SuppressTest(category,\n+            \"compiler.warn.raw.class.use\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                @INNER@\n+                public void foo() {\n+                    Iterable i = null;\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case REMOVAL -> new SuppressTest(category,\n+            \"compiler.warn.has.been.deprecated.for.removal\",\n+            null,\n+            \"\"\"\n+            public class Super {\n+                @Deprecated(forRemoval = true)\n+                public void foo() { }\n+            }\n+            \"\"\",\n+            \"\"\"\n+            @OUTER@\n+            public class Sub extends Super {\n+                @INNER@\n+                @Override\n+                public void foo() { }\n+            }\n+            \"\"\"\n+        );\n+\n+        \/\/ This test case requires special module support; see testSuppressWarnings()\n+        case REQUIRES_AUTOMATIC -> new SuppressTest(category,\n+            \"compiler.warn.requires.automatic\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            module m1x {\n+                requires randomjar;\n+            }\n+            \"\"\"\n+        );\n+\n+        \/\/ This test case requires special module support; see testSuppressWarnings()\n+        case REQUIRES_TRANSITIVE_AUTOMATIC -> new SuppressTest(category,\n+            \"compiler.warn.requires.transitive.automatic\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            module m1x {\n+                requires transitive randomjar;\n+            }\n+            \"\"\"\n+        );\n+\n+        case SERIAL -> new SuppressTest(category,\n+            \"compiler.warn.missing.SVUID\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                @INNER@\n+                public static class Inner implements java.io.Serializable {\n+                    public int x;\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case STATIC -> new SuppressTest(category,\n+            \"compiler.warn.static.not.qualified.by.type\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                public static void foo() {\n+                }\n+                @INNER@\n+                public void bar() {\n+                    this.foo();\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case STRICTFP -> new SuppressTest(category,\n+            \"compiler.warn.strictfp\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                @INNER@\n+                public strictfp void foo() {\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case SUPPRESSION -> new SuppressTest(category,\n+            \"compiler.warn.unnecessary.warning.suppression\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                @INNER@\n+                public class Inner1 {\n+                    @SuppressWarnings(\"unchecked\")\n+                    public void foo() {\n+                    }\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case IDENTITY -> new SuppressTest(category,\n+            \"compiler.warn.attempt.to.synchronize.on.instance.of.value.based.class\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Outer {\n+                @INNER@\n+                public void foo() {\n+                    Integer i = 42;\n+                    synchronized (i) {\n+                    }\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case TEXT_BLOCKS -> new SuppressTest(category,\n+            \"compiler.warn.trailing.white.space.will.be.removed\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                public void foo() {\n+                    String s =\n+                        \\\"\\\"\\\"\n+                        add trailing spaces here:\n+                        \\\"\\\"\\\";\n+                }\n+            }\n+            \"\"\".replaceAll(\"add trailing spaces here:\", \"$0    \")\n+        );\n+\n+        case THIS_ESCAPE -> new SuppressTest(category,\n+            \"compiler.warn.possible.this.escape\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Outer {\n+                @INNER@\n+                public static class Inner {\n+                    public Inner() {\n+                        leak();\n+                    }\n+                    public void leak() { }\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case TRY -> new SuppressTest(category,\n+            \"compiler.warn.try.explicit.close.call\",\n+            null,\n+            \"\"\"\n+            import java.io.*;\n+            @OUTER@\n+            public class Outer {\n+                @INNER@\n+                public void foo() throws IOException {\n+                    try (InputStream in = new FileInputStream(\"x\")) {\n+                        in.close();\n+                    }\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case UNCHECKED -> new SuppressTest(category,\n+            \"compiler.warn.prob.found.req: (compiler.misc.unchecked.cast.to.type)\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                public void foo() {\n+                    Iterable<?> c = null;\n+                    @INNER@\n+                    Iterable<Short> t = (Iterable<Short>)c, s = null;\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case VARARGS -> new SuppressTest(category,\n+            \"compiler.warn.varargs.unsafe.use.varargs.param\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                @INNER@\n+                @SafeVarargs\n+                public static <T> void bar(final T... barArgs) {\n+                    baz(barArgs);\n+                }\n+                public static <T> void baz(final T[] bazArgs) {\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case PREVIEW -> new SuppressTest(category,\n+            \"compiler.warn.preview.feature.use\",\n+            new String[] {\n+                \"--enable-preview\",\n+                \"-XDforcePreview\"\n+            },\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                @INNER@\n+                public Test(Object x) {\n+                    int value = x instanceof Integer i ? i : -1;\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        case RESTRICTED -> new SuppressTest(category,\n+            \"compiler.warn.restricted.method\",\n+            null,\n+            \"\"\"\n+            @OUTER@\n+            public class Test {\n+                @INNER@\n+                public void foo() {\n+                    System.load(\"\");\n+                }\n+            }\n+            \"\"\"\n+        );\n+\n+        default -> throw new AssertionError(\"missing test case for \" + category);\n+\n+      })\n+      .filter(Objects::nonNull)         \/\/ skip categories with no test case defined\n+      .collect(Collectors.toList());\n+\n+    protected final ToolBox tb;\n+\n+    public SuppressionWarningTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new SuppressionWarningTest().runTests(m -> new Object[0]);\n+    }\n+\n+\/\/ Tests\n+\n+    @Test\n+    public void testSuppressWarnings() throws Exception {\n+        testAll(\"testSuppressWarnings\", this::testSuppressWarnings, SUPPRESS_WARNINGS_TEST_CASES);\n+    }\n+\n+    \/\/ We are testing all combinations of nested @SuppressWarning annotations and lint flags\n+    public void testSuppressWarnings(SuppressTest test) throws Exception {\n+\n+        \/\/ Setup directories\n+        Path base = Paths.get(\"testSuppressWarnings\");\n+        resetCompileDirectories(base);\n+\n+        \/\/ Detect if any modules are being compiled; if so we need to create an extra source directory level\n+        Pattern moduleDecl = Pattern.compile(\"module\\\\s+(\\\\S*).*\");\n+        Set<String> moduleNames = test.sources.stream()\n+          .flatMap(source -> Stream.of(source.split(\"\\\\n\")))\n+          .map(moduleDecl::matcher)\n+          .filter(Matcher::matches)\n+          .map(matcher -> matcher.group(1))\n+          .collect(Collectors.toSet());\n+\n+        \/\/ Special JAR file support for REQUIRES_AUTOMATIC and REQUIRES_TRANSITIVE_AUTOMATIC\n+        Path modulePath = base.resolve(\"modules\");\n+        resetDirectory(modulePath);\n+        LintCategory category = test.category;\n+        switch (category) {\n+        case REQUIRES_AUTOMATIC:\n+        case REQUIRES_TRANSITIVE_AUTOMATIC:\n+\n+            \/\/ Compile a simple automatic module (randomjar-1.0)\n+            Path randomJarBase = base.resolve(\"randomjar\");\n+            tb.writeJavaFiles(getSourcesDir(randomJarBase), \"package api; public class Api {}\");\n+            List<String> log = compile(randomJarBase, Task.Expect.SUCCESS, \"-Werror\");\n+            if (!log.isEmpty()) {\n+                throw new AssertionError(String.format(\n+                  \"non-empty log output:%n  %s\", log.stream().collect(Collectors.joining(\"\\n  \"))));\n+            }\n+\n+            \/\/ JAR it up\n+            Path automaticJar = modulePath.resolve(\"randomjar-1.0.jar\");\n+            new JarTask(tb, automaticJar)\n+              .baseDir(getClassesDir(randomJarBase))\n+              .files(\"api\/Api.class\")\n+              .run();\n+            break;\n+\n+        default:\n+            modulePath = null;\n+            break;\n+        };\n+\n+        \/\/ Create a @SuppressWarnings annotation\n+        String annotation = String.format(\"@SuppressWarnings(\\\"%s\\\")\", category.option);\n+\n+        \/\/ See which annotation substitutions this test supports\n+        boolean hasOuterAnnotation = test.sources.stream().anyMatch(source -> source.contains(\"@OUTER@\"));\n+        boolean hasInnerAnnotation = test.sources.stream().anyMatch(source -> source.contains(\"@INNER@\"));\n+\n+        \/\/ Try all combinations of inner and outer @SuppressWarnings\n+        boolean[] booleans = new boolean[] { false, true };\n+        for (boolean outerAnnotation : booleans) { for (boolean innerAnnotation : booleans) {\n+\n+          \/\/ Skip this scenario if not supported by test case\n+          if ((outerAnnotation && !hasOuterAnnotation) || (innerAnnotation && !hasInnerAnnotation))\n+              continue;\n+\n+          \/\/ Insert or comment out the @SuppressWarnings annotations in the source templates\n+          String[] sources = test.sources.stream()\n+            .map(source -> source.replace(\"@OUTER@\",\n+              String.format(\"%s@SuppressWarnings(\\\"%s\\\")\", outerAnnotation ? \"\" : \"\/\/\", category.option)))\n+            .map(source -> source.replace(\"@INNER@\",\n+              String.format(\"%s@SuppressWarnings(\\\"%s\\\")\", innerAnnotation ? \"\" : \"\/\/\", category.option)))\n+            .toArray(String[]::new);\n+          for (String source : sources) {\n+              Path pkgRoot = getSourcesDir(base);\n+              String moduleName = Optional.of(\"@MODULE@:(\\\\S+)\")\n+                                  .map(Pattern::compile)\n+                                  .map(p -> p.matcher(source))\n+                                  .filter(Matcher::find)\n+                                  .map(m -> m.group(1))\n+                                  .orElse(null);\n+              if (moduleName != null) {                                     \/\/ add an extra directory for module\n+                  if (!moduleNames.contains(moduleName))\n+                      throw new AssertionError(String.format(\"unknown module \\\"%s\\\" in %s\", moduleName, category));\n+                  pkgRoot = pkgRoot.resolve(moduleName);\n+              }\n+              tb.writeJavaFiles(pkgRoot, source);\n+          }\n+\n+          \/\/ Try all combinations of lint flags for <category> and SUPPRESSION\n+          for (boolean enableCategory : booleans) {                         \/\/ [-]category\n+            for (boolean enableSuppression : booleans) {                    \/\/ [-]suppression\n+\n+                \/\/ Special case when category is SUPPRESSION itself: avoid a contradiction\n+                if (category == LintCategory.SUPPRESSION && enableCategory != enableSuppression)\n+                    continue;\n+\n+                \/\/ Should we expect the \"test.warningKey\" warning to be emitted?\n+                boolean expectCategoryWarning = category.annotationSuppression ?\n+                  enableCategory && !outerAnnotation && !innerAnnotation :      \/\/ the warning must be enabled and not suppressed\n+                  enableCategory;                                               \/\/ @SuppressWarnings has no effect at all\n+\n+                \/\/ Should we expect the SUPPRESSION warning to be emitted?\n+                boolean expectSuppressionWarning = category.annotationSuppression ?\n+                  enableSuppression && outerAnnotation && innerAnnotation :     \/\/ only if both (then outer is redundant)\n+                  enableSuppression && (outerAnnotation || innerAnnotation);    \/\/ either one is always redundant\n+\n+                \/\/ Prepare command line flags\n+                ArrayList<String> flags = new ArrayList<>();\n+                if (modulePath != null) {\n+                    flags.add(\"--module-path\");\n+                    flags.add(modulePath.toString());\n+                }\n+                if (!test.compileFlags.contains(\"--release\")) {\n+                    flags.add(\"--release\");\n+                    flags.add(Source.DEFAULT.name);\n+                }\n+                flags.addAll(test.compileFlags);\n+\n+                \/\/ Add the -Xlint flag (if any)\n+                LinkedHashSet<String> lints = new LinkedHashSet<>();\n+                lints.add(String.format(\"%s%s\", enableCategory ? \"\" : \"-\", category.option));\n+                if (enableSuppression)\n+                    lints.add(SUPPRESSION.option);\n+                if (!lints.isEmpty())\n+                    flags.add(\"-Xlint:\" + lints.stream().collect(Collectors.joining(\",\")));\n+\n+                \/\/ Test case description\n+                String description = String.format(\"[%s] outer=%s inner=%s enable=%s flags=\\\"%s\\\"\",\n+                  category, outerAnnotation, innerAnnotation, enableCategory, flags.stream().collect(Collectors.joining(\" \")));\n+\n+                \/\/ Only print log if test case fails\n+                StringWriter buf = new StringWriter();\n+                PrintWriter log = new PrintWriter(buf);\n+                try {\n+\n+                    \/\/ Logging\n+                    log.println(String.format(\">>> Test  START: %s\", description));\n+                    Stream.of(sources).forEach(log::println);\n+                    log.println(String.format(\">>> expectCategoryWarning=%s\", expectCategoryWarning));\n+                    log.println(String.format(\">>> expectSuppressionWarning=%s\", expectSuppressionWarning));\n+\n+                    \/\/ Compile sources and get log output\n+                    List<String> output = compile(base, Task.Expect.SUCCESS, flags.toArray(new String[0]));\n+\n+                    \/\/ Scrub insignificant log output\n+                    output.removeIf(line -> line.matches(\"[0-9]+ (error|warning)s?\"));\n+                    output.removeIf(line -> line.contains(\"compiler.err.warnings.and.werror\"));\n+                    output.removeIf(line -> line.matches(\"- compiler\\\\.note\\\\..*\"));   \/\/ mandatory warning \"recompile\" etc.\n+\n+                    \/\/ See if the category warning appeared as expected\n+                    boolean foundCategoryWarning = output.removeIf(line -> line.contains(test.warningKey));\n+                    if (foundCategoryWarning != expectCategoryWarning) {\n+                        throw new AssertionError(String.format(\"%s: category warning: found=%s but expected=%s\",\n+                          description, foundCategoryWarning, expectCategoryWarning));\n+                    }\n+\n+                    \/\/ See if the suppression warning appeared as expected (but skip redundant check for SUPPRESSION)\n+                    if (category != LintCategory.SUPPRESSION) {\n+                        boolean foundSuppressionWarning = output.removeIf(\n+                          line -> line.contains(\"compiler.warn.unnecessary.warning.suppression\"));\n+                        if (foundSuppressionWarning != expectSuppressionWarning) {\n+                            throw new AssertionError(String.format(\"%s: \\\"%s\\\" warning: found=%s but expected=%s\",\n+                              description, SUPPRESSION.option, foundSuppressionWarning, expectSuppressionWarning));\n+                        }\n+                    }\n+\n+                    \/\/ There shouldn't be any other warnings\n+                    if (!output.isEmpty()) {\n+                        throw new AssertionError(String.format(\n+                          \"%s: %d unexpected warning(s): %s\", description, output.size(), output));\n+                    }\n+\n+                    \/\/ Done\n+                    log.println(String.format(\"<<< Test PASSED: %s\", description));\n+                } catch (AssertionError e) {\n+                    log.println(String.format(\"<<< Test FAILED: %s\", description));\n+                    log.flush();\n+                    out.print(buf);\n+                    throw e;\n+                }\n+            }\n+          }\n+        } }\n+    }\n+\n+    @Test\n+    public void testUselessAnnotation() throws Exception {\n+        testAll(\"testUselessAnnotation\", this::testUselessAnnotation, List.of(LintCategory.values()));\n+    }\n+\n+    \/\/ Test a @SuppressWarning annotation that suppresses nothing\n+    private void testUselessAnnotation(LintCategory category) throws Exception {\n+        String warningKey = category != LintCategory.SUPPRESSION ?      \/\/ @SuppressWarnings(\"suppression\") can never be useless!\n+          \"compiler.warn.unnecessary.warning.suppression\" : null;\n+        compileAndExpect(\n+          warningKey,\n+          String.format(\n+            \"\"\"\n+                @SuppressWarnings(\\\"%s\\\")\n+                public class Test { }\n+            \"\"\",\n+            category.option),\n+          String.format(\"-Xlint:%s\", SUPPRESSION.option));\n+    }\n+\n+    @Test\n+    public void testSelfSuppression() throws Exception {\n+        testAll(\"testSelfSuppression\", this::testSelfSuppression, List.of(LintCategory.values()));\n+    }\n+\n+    \/\/ Test the suppression of SUPPRESSION itself, which should always work,\n+    \/\/ even when the same annotation uselessly suppresses some other category.\n+    private void testSelfSuppression(LintCategory category) throws Exception {\n+\n+        \/\/ Test category and SUPPRESSION in the same annotation\n+        compileAndExpectSuccess(\n+          String.format(\n+            \"\"\"\n+                @SuppressWarnings({ \\\"%s\\\", \\\"%s\\\" })\n+                public class Test { }\n+            \"\"\",\n+            category.option,        \/\/ this is actually a useless suppression\n+            SUPPRESSION.option),    \/\/ but this prevents us from reporting it\n+          String.format(\"-Xlint:%s\", SUPPRESSION.option));\n+\n+        \/\/ Test category and SUPPRESSION in nested annotations\n+        compileAndExpectSuccess(\n+          String.format(\n+            \"\"\"\n+                @SuppressWarnings(\\\"%s\\\")       \/\/ suppress useless suppression warnings\n+                public class Test {\n+                    @SuppressWarnings(\\\"%s\\\")   \/\/ a useless suppression\n+                    public class Sub { }\n+                }\n+            \"\"\",\n+            SUPPRESSION.option,     \/\/ this prevents us from reporting the nested useless suppression\n+            category.option),       \/\/ this is a useless suppression\n+          String.format(\"-Xlint:%s\", SUPPRESSION.option));\n+    }\n+\n+    \/\/ Test OVERLOADS which has tricky \"either-or\" suppression\n+    @Test\n+    public void testOverloads() throws Exception {\n+        compileAndExpectSuccess(\n+          \"\"\"\n+          import java.util.function.*;\n+          public class Super {\n+              @SuppressWarnings(\"overloads\")\n+              public void foo(IntConsumer c) {\n+              }\n+              @SuppressWarnings(\"overloads\")\n+              public void foo(Consumer<Integer> c) {\n+              }\n+          }\n+          \"\"\",\n+          String.format(\"-Xlint:%s\", OVERLOADS.option),\n+          String.format(\"-Xlint:%s\", SUPPRESSION.option));\n+    }\n+\n+    \/\/ Test THIS_ESCAPE which has tricky constructor control-flow based suppression\n+    @Test\n+    public void testThisEscape1() throws Exception {\n+        compileAndExpectSuccess(\n+          \"\"\"\n+          public class Test {\n+              @SuppressWarnings(\"this-escape\")\n+              private int y = leak();\n+              public Test() {\n+                  this(0);\n+              }\n+              @SuppressWarnings(\"this-escape\")\n+              private Test(int x) {\n+                  this.leak();\n+              }\n+              protected int leak() {\n+                  return 0;\n+              }\n+          }\n+          \"\"\",\n+          String.format(\"-Xlint:%s\", THIS_ESCAPE.option),\n+          String.format(\"-Xlint:%s\", SUPPRESSION.option));\n+    }\n+\n+    @Test\n+    public void testThisEscape2() throws Exception {\n+        compileAndExpect(\n+          \"compiler.warn.unnecessary.warning.suppression\",\n+          \"\"\"\n+          public class Test {\n+              public Test() {\n+                  this.leak();\n+              }\n+              @SuppressWarnings(\"this-escape\")  \/\/ this does nothing -> \"suppression\" warning here\n+              protected int leak() {\n+                  return 0;\n+              }\n+          }\n+          \"\"\",\n+          String.format(\"-Xlint:%s\", THIS_ESCAPE.option),\n+          String.format(\"-Xlint:%s\", SUPPRESSION.option));\n+    }\n+\n+\/\/ Support Stuff\n+\n+    \/\/ Run a test on a sequence of test cases\n+    private <T> void testAll(String testName, ThrowingConsumer<T> test, Iterable<T> testCases) throws Exception {\n+        int totalCount = 0;\n+        int errorCount = 0;\n+        for (T testCase : testCases) {\n+            try {\n+                test.accept(testCase);\n+                out.println(String.format(\"%s: %s: %s\", testName, \"PASSED\", testCase));\n+            } catch (Exception e) {\n+                out.println(String.format(\"%s: %s: %s: %s\", testName, \"FAILED\", testCase, e));\n+                errorCount++;\n+            }\n+            totalCount++;\n+        }\n+        if (errorCount > 0)\n+            throw new Exception(String.format(\"%s: %d\/%d test case(s) failed\", testName, errorCount, totalCount));\n+    }\n+\n+    public void compileAndExpectSuccess(String source, String... flags) throws Exception {\n+        compileAndExpect(null, source, flags);\n+    }\n+\n+    public void compileAndExpect(String warningKey, String source, String... flags) throws Exception {\n+\n+        \/\/ Setup source & destination diretories\n+        Path base = Paths.get(\"compileAndExpect\");\n+        resetCompileDirectories(base);\n+\n+        \/\/ Write source file\n+        tb.writeJavaFiles(getSourcesDir(base), source);\n+\n+        \/\/ Add -Werror flag so any warning causes compilation to fail\n+        flags = Stream.concat(Stream.of(flags), Stream.of(\"-Werror\")).toArray(String[]::new);\n+\n+        \/\/ Compile sources and verify we got the expected result\n+        boolean expectSuccess = warningKey == null;\n+        List<String> log = compile(base, expectSuccess ? Task.Expect.SUCCESS : Task.Expect.FAIL, flags);\n+\n+        \/\/ A successful compilation should not log any warnings\n+        if (expectSuccess && !log.isEmpty()) {\n+            throw new AssertionError(String.format(\n+              \"non-empty log output:%n  %s\", log.stream().collect(Collectors.joining(\"\\n  \"))));\n+        }\n+\n+        \/\/ A failed compilation should log the expected warning\n+        if (!expectSuccess && log.stream().noneMatch(line -> line.contains(warningKey))) {\n+            throw new AssertionError(String.format(\n+              \"did not find \\\"%s\\\" in log output:%n  %s\",\n+              warningKey, log.stream().collect(Collectors.joining(\"\\n  \"))));\n+        }\n+    }\n+\n+    private List<String> compile(Path base, Task.Expect expectation, String... flags) throws Exception {\n+        ArrayList<String> options = new ArrayList<>();\n+        options.add(\"-XDrawDiagnostics\");\n+        Stream.of(flags).forEach(options::add);\n+        List<String> log;\n+        try {\n+            log = new JavacTask(tb, Mode.CMDLINE)\n+              .options(options.toArray(new String[0]))\n+              .files(tb.findJavaFiles(getSourcesDir(base)))\n+              .outdir(getClassesDir(base))\n+              .run(expectation)\n+              .writeAll()\n+              .getOutputLines(Task.OutputKind.DIRECT);\n+        } catch (Task.TaskError e) {\n+            throw new AssertionError(String.format(\n+              \"compile in %s failed: %s\", getSourcesDir(base), e.getMessage()), e);\n+        }\n+        log.removeIf(line -> line.trim().isEmpty());\n+        return log;\n+    }\n+\n+    private Path getSourcesDir(Path base) {\n+        return base.resolve(\"sources\");\n+    }\n+\n+    private Path getClassesDir(Path base) {\n+        return base.resolve(\"classes\");\n+    }\n+\n+    private void resetCompileDirectories(Path base) throws IOException {\n+        for (Path dir : List.of(getSourcesDir(base), getClassesDir(base)))\n+            resetDirectory(dir);\n+    }\n+\n+    private void resetDirectory(Path dir) throws IOException {\n+        if (Files.exists(dir, LinkOption.NOFOLLOW_LINKS))\n+            Files.walkFileTree(dir, new Deleter());\n+        Files.createDirectories(dir);\n+    }\n+\n+\/\/ ThrowingConsumer\n+\n+    @FunctionalInterface\n+    private interface ThrowingConsumer<T> {\n+        void accept(T testCase) throws Exception;\n+    }\n+\n+\/\/ SuppressTest\n+\n+    \/\/ A test case for testSuppressWarnings()\n+    private record SuppressTest(\n+        LintCategory category,          \/\/ The Lint category being tested\n+        String warningKey,              \/\/ Expected warning message key in compiler.properties\n+        List<String> compileFlags,      \/\/ Any required compilation flags\n+        List<String> sources            \/\/ Source files with @MODULE@, @OUTER@ and @INNER@ placeholders\n+    ) {\n+        SuppressTest(LintCategory category, String warningKey, String[] compileFlags, String... sources) {\n+            this(category, warningKey, List.of(compileFlags != null ? compileFlags : new String[0]), List.of(sources));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SuppressTest[\" + category + \"]\";\n+        }\n+    }\n+\n+\/\/ Deleter\n+\n+    private static class Deleter extends SimpleFileVisitor<Path> {\n+\n+        @Override\n+        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+            Files.delete(file);\n+            return FileVisitResult.CONTINUE;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lint\/SuppressionWarningTest.java","additions":1085,"deletions":0,"binary":false,"changes":1085,"status":"added"},{"patch":"@@ -4,1 +4,1 @@\n- * @compile\/ref=DepAnn.out -XDrawDiagnostics -Xlint:all,-dangling-doc-comments DepAnn.java\n+ * @compile\/ref=DepAnn.out -XDrawDiagnostics -Xlint:all,-dangling-doc-comments,-suppression DepAnn.java\n","filename":"test\/langtools\/tools\/javac\/warnings\/DepAnn.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}