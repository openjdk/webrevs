{"files":[{"patch":"@@ -48,5 +48,1 @@\n-\/\/\/ be at risk from user final field modifications.\n-\/\/\/\n-\/\/\/ See `constant-folding.md` design document in the same directory as this file\n-\/\/\/ for an overview and the best practices around constant folding, including\n-\/\/\/ for this annotation.\n+\/\/\/ be at risk from final field modifications such as serialization.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/TrustFinalFields.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,104 +0,0 @@\n-Constant Folding\n-===\n-\n-Hotspot compiler can fold constant field value access when it constructs its IR\n-(intermediate representation), unlocking significant performance improvements.\n-However, it is implemented as a dangerous primitive that can lead to incorrect\n-programs if used incorrectly.\n-\n-## What is constant folding?\n-\n-Constant folding means a read of a variable of a constant value can be replaced\n-by the read constant value, during the construction of an IR graph.  The\n-related logic resides in `ci\/ciField.hpp` (compiler interface field).\n-\n-For example, if a field `int a` has a constant value `4` and a field `int b` has\n-constant value `5`, the constant folding will replace the `a + b` in the IR with\n-a value of `9`.\n-\n-## How is a value determined to be constant?\n-\n-Constantness is decided on a per-variable and per-value basis.  This includes\n-the location of the variable so that a variable might have a constant value,\n-and the value of the variable so the read value is constant.\n-\n-### Field constants\n-\n-Whether a field may have a constant value is determined by the\n-`ciField::is_constant()` method in Hotspot.  The value of `_is_constant` is\n-determined in `ciField::initialize_from`.  It is roughly as follows:\n-\n-1. A field may be constant if it is stable.\n-2. Before Java 9, `putfield`  in `<clinit>` could write to an instance final\n-   field and `putstatic` in `<init>` could write to a static final field.  Such\n-   written final fields from pre-53-major classes are considered never constant.\n-3. Otherwise, if a static final field is not `System.in`, `System.out`, or\n-   `System.err`, it may be constant.\n-4. If an instance final field comes from a record class, a hidden class, it may\n-   be constant.\n-5. If an instance final field is declared in a system class that is either:\n-\n-   1. Marked `@TrustFinalFields`\n-   2. In one of the trusted system packages specified in\n-      `trust_final_non_static_fields` in `ciField.cpp`\n-\n-   It may be constant.  Note that such a field is not protected from reflective\n-   modification through core reflection `Field.set`.\n-6. If the field is `CallSite.target`, it may be constant. (This has extra\n-   treatments like nmethod dependency, so is not quite as other constant\n-   fields)\n-\n-A `ciField` models a field declaration in the JVM, so an inherited field (as\n-in a field reference, static or instance) in a subclass or subinterface shares\n-the constantness settings.\n-\n-After a field is considered to be possibly constant, its value is fetched from\n-the runtime and examined.  If the field is stable, and the value is zero or null\n-(the default value), this read value is not constant.  Only non-stable final\n-fields can have their zero or null values considered constant.\n-\n-### Array constants\n-\n-If an array field is stable, the type system in the compiler of Hotspot marks\n-the array to be stable up to its declared level.  (See the code of the most\n-generic variant of `Type::make_constant_from_field`)  As a result, access to\n-nested array components _with a constant index_ can be treated as a constant\n-value, if the read value is not zero or null (the default value).\n-\n-This means the stable annotation is not as helpful for random access (it only\n-elides loading the array reference), and null components in an \"immutable\" array\n-may cause surprising slowdowns.\n-\n-## How can I verify constant folding?\n-\n-Since constant folding makes a huge difference in API performance characteristics,\n-tests are necessary to guarantee they happen.\n-\n-The most reliable way to ensure folding is IR tests in the compiler; we can\n-expect compiler to eliminate known foldable IR structures when its inputs are\n-eligible.  For example, in the initial constant folding example of `a + b`, an\n-IR test can verify the int addition is eliminated in the resulting IR by\n-constant folding.\n-\n-An example test is `compiler.c2.irTests.constantFold.TestOptional`.  Note that\n-IR tests need to be run in a debug (fastdebug) configure profile, which is not\n-used for most jdk library tests.\n-\n-JMH benchmarks can be another way to verify, except they are costly to run and\n-their trend is hard to track.  Prefer the compiler tests instead.\n-\n-## Relation to final mechanisms\n-\n-### `Field.trustedFinal` property\n-\n-A `Field` object has a `trustedFinal` field, which when set to `true`, prevents\n-core reflection or method handles from creating a setter for this field in any\n-scenario.  This is derived from `fieldDescriptor::is_trusted_final()`, which\n-designates final fields that are static, declared in a record class, or declared\n-in a hidden class as `trustedFinal`.  This rule is different from the \"may be\n-constant variable\" rule from above; in particular, it does not protect the\n-instance final fields in eligible system classes per rule 5 above.\n-\n-Note that a `Field` object also models a field declaration in the JVM like a\n-`ciField`, so an inherited field in a subclass or subinterface shares the\n-`trustedFinal` setting.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/constant-folding.md","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"}]}