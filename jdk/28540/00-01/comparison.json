{"files":[{"patch":"@@ -32,2 +32,0 @@\n-import java.lang.invoke.*;\n-import java.lang.reflect.Field;\n@@ -35,2 +33,2 @@\n-\/\/\/ Indicates all instance final fields in the annotated class should be trusted\n-\/\/\/ as constants by compilers in `ciField::is_constant`.\n+\/\/\/ Indicates all instance final fields declared in the annotated class should\n+\/\/\/ be trusted as constants by compilers in `ciField::is_constant`.\n@@ -41,1 +39,2 @@\n-\/\/\/ the boot class loader also have their instance final fields trusted.\n+\/\/\/ the boot class loader also have their instance final fields trusted.  This\n+\/\/\/ annotation is not necessary in these cases.\n@@ -44,2 +43,2 @@\n-\/\/\/ zero or null value.  In comparison, a final instance field trusted by this\n-\/\/\/ annotation can trust zero and null values.\n+\/\/\/ zero or null value.  In comparison, a non-stable final instance field\n+\/\/\/ trusted by this annotation can treat zero and null values as constants.\n@@ -47,3 +46,3 @@\n-\/\/\/ As a result, this should be used on classes where package-wide trusting is\n-\/\/\/ not possible due to backward compatibility concerns, such as for `java.util`\n-\/\/\/ classes.\n+\/\/\/ This annotation is suitable when constant treatment of final fields is\n+\/\/\/ performance sensitive, yet package-wide final field constant treatment may\n+\/\/\/ be at risk from user final field modifications.\n@@ -51,9 +50,3 @@\n-\/\/\/ A separate flag [Field#isTrustedFinal()] prevents core reflection from\n-\/\/\/ modifying the value of a field via [Field#set].  ([VarHandle] already blocks\n-\/\/\/ modification for all `final` fields, and [MethodHandle] setter for trusted\n-\/\/\/ final fields can only be created with the `IMPL_LOOKUP`)  This is currently\n-\/\/\/ handled by `fieldDescriptor::is_trusted_final`, distinct from the trusting\n-\/\/\/ mechanism in the compiler.  This mechanism protects the static final fields\n-\/\/\/ and instance final fields in record and hidden classes, but does not cover\n-\/\/\/ stable fields, final fields in the classes in the select packages, or final\n-\/\/\/ fields in classes specified by this annotation.\n+\/\/\/ See `constant-folding.md` design document in the same directory as this file\n+\/\/\/ for an overview and the best practices around constant folding, including\n+\/\/\/ for this annotation.\n@@ -61,1 +54,2 @@\n-\/\/\/ This annotation is only recognized on privileged code and is ignored elsewhere.\n+\/\/\/ This annotation is only recognized on classes from the boot and platform\n+\/\/\/ class loaders and is ignored elsewhere.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/TrustFinalFields.java","additions":14,"deletions":20,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+Constant Folding in the Hotspot Compiler\n+===\n+\n+Hotspot compiler can fold constant field value access when it constructs its IR\n+(intermediate representation), unlocking significant performance improvements.\n+However, it is implemented as a dangerous primitive that can lead to incorrect\n+programs if used incorrectly.\n+\n+## What is constant folding?\n+\n+Constant folding means a read of a variable of a constant value can be replaced\n+by the read constant value, during the construction of an IR graph.  The\n+related logic resides in `ci\/ciField.hpp` (compiler interface field).\n+\n+For example, if a field `int a` has a constant value `4` and a field `int b` has\n+constant value `5`, the constant folding will replace the `a + b` in the IR with\n+a value of `9`.\n+\n+## How is a value determined to be constant?\n+\n+Constantness is decided on a per-variable and per-value basis.  This includes\n+the location of the variable so that a variable might have a constant value,\n+and the value of the variable so the read value is constant.\n+\n+### Field constants\n+\n+Whether a field may have a constant value is determined by the\n+`ciField::is_constant()` method in Hotspot.  The value of `_is_constant` is\n+determined in `ciField::initialize_from`.  It is roughly as follows:\n+\n+1. A field may be constant if it is stable.\n+2. Before Java 9, `putfield`  in `<clinit>` could write to an instance final\n+   field and `putstatic` in `<init>` could write to a static final field.  Such\n+   written final fields from pre-53-major classes are considered never constant.\n+3. Otherwise, if a static final field is not `System.in`, `System.out`, or\n+   `System.err`, it may be constant.\n+4. If an instance final field comes from a record class, a hidden class, it may\n+   be constant.\n+5. If an instance final field is declared in a system class that is either:\n+\n+   1. Marked `@TrustFinalFields`\n+   2. In one of the trusted system packages specified in\n+      `trust_final_non_static_fields` in `ciField.cpp`\n+\n+   It may be constant.  Note that such a field is not protected from reflective\n+   modification through core reflection `Field.set`.\n+6. If the field is `CallSite.target`, it may be constant. (This has extra\n+   treatments like nmethod dependency, so is not quite as other constant\n+   fields)\n+\n+A `ciField` models a field declaration in the JVM, so an inherited field (as\n+in a field reference, static or instance) in a subclass or subinterface shares\n+the constantness settings.\n+\n+After a field is considered to be possibly constant, its value is fetched from\n+the runtime and examined.  If the field is stable, and the value is zero or null\n+(the default value), this read value is not constant.  Only non-stable final\n+fields can have their zero or null values considered constant.\n+\n+### Array constants\n+\n+If an array field is stable, the type system in the compiler of Hotspot marks\n+the array to be stable up to its declared level.  (See the code of the most\n+generic variant of `Type::make_constant_from_field`)  As a result, access to\n+nested array components _with a constant index_ can be treated as a constant\n+value, if the read value is not zero or null (the default value).\n+\n+This means the stable annotation is not as helpful for random access (it only\n+elides loading the array reference), and null components in an \"immutable\" array\n+may cause surprising slowdowns.\n+\n+## How can I verify constant folding?\n+\n+Since constant folding makes a huge difference in API performance characteristics,\n+tests are necessary to guarantee they happen.\n+\n+The most reliable way to ensure folding is IR tests in the compiler; we can\n+expect compiler to eliminate known foldable IR structures when its inputs are\n+eligible.  For example, in the initial constant folding example of `a + b`, an\n+IR test can verify the int addition is eliminated in the resulting IR by\n+constant folding.\n+\n+An example test is `compiler.c2.irTests.constantFold.TestOptional`.  Note that\n+IR tests need to be run in a debug (fastdebug) configure profile, which is not\n+used for most jdk library tests.\n+\n+JMH benchmarks can be another way to verify, except they are costly to run and\n+their trend is hard to track.  Prefer the compiler tests instead.\n+\n+## Relation to final mechanisms\n+\n+### `Field.trustedFinal` property\n+\n+A `Field` object has a `trustedFinal` field, which when set to `true`, prevents\n+core reflection or method handles from creating a setter for this field in any\n+scenario.  This is derived from `fieldDescriptor::is_trusted_final()`, which\n+designates final fields that are static, declared in a record class, or declared\n+in a hidden class as `trustedFinal`.  This rule is different from the \"may be\n+constant variable\" rule from above; in particular, it does not protect the\n+instance final fields in eligible system classes per rule 5 above.\n+\n+Note that a `Field` object also models a field declaration in the JVM like a\n+`ciField`, so an inherited field in a subclass or subinterface shares the\n+`trustedFinal` setting.\n+\n+### Make Final Mean Final\n+\n+As noted for `Field.trustedFinal`, protections are missing for some system\n+classes.  The effort to make final mean final, that all illegal final field\n+modifications must use `--enable-final-field-mutation` and `--add-opens`,\n+represents a step toward this goal.\n+\n+In JEP 500, when `--illegal-final-field-mutation=deny`, a final field `f` is\n+still mutable if for some module `M` (including the unnamed module) that could\n+perform final field mutation, one of the following stands:\n+\n+1. `f` is a public field declared in a public class, and the package\n+   of the declaring class is exported by the containing module to `M`.\n+2. The package of the declaring class of `f` is open to `M`.\n+3. `f` is in `M`.\n+\n+This set of rules is more complex than the existing logic in `fieldDescriptor`,\n+and being in `jdk.internal.module.ModuleBootstrap`, is not easy to export to\n+the JVM runtime.  In addition, the performance implication of enabling final\n+field mutation on the command line may also be concerning to users.\n+\n+In conclusion, trusting based on final field mutation settings is possible, but\n+whether the cost is worth the return is under investigation.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/constant-folding.md","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}