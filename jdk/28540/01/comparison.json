{"files":[{"patch":"@@ -219,0 +219,3 @@\n+  \/\/ Explicit opt-in from system classes\n+  if (holder->trust_final_fields())\n+    return true;\n@@ -233,8 +236,0 @@\n-  \/\/ Trust Atomic*FieldUpdaters: they are very important for performance, and make up one\n-  \/\/ more reason not to use Unsafe, if their final fields are trusted. See more in JDK-8140483.\n-  if (holder->name() == ciSymbols::java_util_concurrent_atomic_AtomicIntegerFieldUpdater_Impl() ||\n-      holder->name() == ciSymbols::java_util_concurrent_atomic_AtomicLongFieldUpdater_CASUpdater() ||\n-      holder->name() == ciSymbols::java_util_concurrent_atomic_AtomicLongFieldUpdater_LockedUpdater() ||\n-      holder->name() == ciSymbols::java_util_concurrent_atomic_AtomicReferenceFieldUpdater_Impl()) {\n-    return true;\n-  }\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+  _trust_final_fields = ik->trust_final_fields();\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  bool                   _trust_final_fields;\n@@ -206,0 +207,4 @@\n+  bool trust_final_fields() const {\n+    return _trust_final_fields;\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -947,0 +947,1 @@\n+    _jdk_internal_vm_annotation_TrustFinalFields,\n@@ -1882,0 +1883,5 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_TrustFinalFields_signature): {\n+      if (_location != _in_class)   break;  \/\/ only allow for classes\n+      if (!privileged)              break;  \/\/ only allow in privileged code\n+      return _jdk_internal_vm_annotation_TrustFinalFields;\n+    }\n@@ -1996,0 +2002,3 @@\n+  if (has_annotation(_jdk_internal_vm_annotation_TrustFinalFields)) {\n+    ik->set_trust_final_fields(true);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -248,4 +248,0 @@\n-  template(java_util_concurrent_atomic_AtomicIntegerFieldUpdater_Impl,       \"java\/util\/concurrent\/atomic\/AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl\") \\\n-  template(java_util_concurrent_atomic_AtomicLongFieldUpdater_CASUpdater,    \"java\/util\/concurrent\/atomic\/AtomicLongFieldUpdater$CASUpdater\") \\\n-  template(java_util_concurrent_atomic_AtomicLongFieldUpdater_LockedUpdater, \"java\/util\/concurrent\/atomic\/AtomicLongFieldUpdater$LockedUpdater\") \\\n-  template(java_util_concurrent_atomic_AtomicReferenceFieldUpdater_Impl,     \"java\/util\/concurrent\/atomic\/AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl\") \\\n@@ -305,0 +301,1 @@\n+  template(jdk_internal_vm_annotation_TrustFinalFields_signature, \"Ljdk\/internal\/vm\/annotation\/TrustFinalFields;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -338,0 +338,3 @@\n+  bool trust_final_fields()                { return _misc_flags.trust_final_fields(); }\n+  void set_trust_final_fields(bool value)  { _misc_flags.set_trust_final_fields(value); }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+    flag(trust_final_fields                 , 1 << 14) \/* All instance final fields in this class should be trusted *\/ \\\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.internal.vm.annotation.Stable;\n+import jdk.internal.vm.annotation.TrustFinalFields;\n@@ -65,0 +65,1 @@\n+@TrustFinalFields\n@@ -74,1 +75,0 @@\n-    @Stable\n","filename":"src\/java.base\/share\/classes\/java\/util\/Optional.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import jdk.internal.vm.annotation.TrustFinalFields;\n+\n@@ -374,0 +376,1 @@\n+    @TrustFinalFields\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicIntegerFieldUpdater.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import jdk.internal.vm.annotation.TrustFinalFields;\n+\n@@ -371,0 +373,1 @@\n+    @TrustFinalFields\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicLongFieldUpdater.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import jdk.internal.vm.annotation.TrustFinalFields;\n+\n@@ -315,0 +317,1 @@\n+    @TrustFinalFields\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicReferenceFieldUpdater.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.vm.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/\/\/ Indicates all instance final fields declared in the annotated class should\n+\/\/\/ be trusted as constants by compilers in `ciField::is_constant`.\n+\/\/\/\n+\/\/\/ The compiler already treats static final fields and instance final fields in\n+\/\/\/ record classes and hidden classes as constant.  All classes in select\n+\/\/\/ packages (Defined in `trust_final_non_static_fields` in `ciField.cpp`) in\n+\/\/\/ the boot class loader also have their instance final fields trusted.  This\n+\/\/\/ annotation is not necessary in these cases.\n+\/\/\/\n+\/\/\/ The [Stable] annotation treats fields as constants once they are not the\n+\/\/\/ zero or null value.  In comparison, a non-stable final instance field\n+\/\/\/ trusted by this annotation can treat zero and null values as constants.\n+\/\/\/\n+\/\/\/ This annotation is suitable when constant treatment of final fields is\n+\/\/\/ performance sensitive, yet package-wide final field constant treatment may\n+\/\/\/ be at risk from user final field modifications.\n+\/\/\/\n+\/\/\/ See `constant-folding.md` design document in the same directory as this file\n+\/\/\/ for an overview and the best practices around constant folding, including\n+\/\/\/ for this annotation.\n+\/\/\/\n+\/\/\/ This annotation is only recognized on classes from the boot and platform\n+\/\/\/ class loaders and is ignored elsewhere.\n+\/\/\/\n+\/\/\/ @since 26\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.TYPE)\n+public @interface TrustFinalFields {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/TrustFinalFields.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+Constant Folding in the Hotspot Compiler\n+===\n+\n+Hotspot compiler can fold constant field value access when it constructs its IR\n+(intermediate representation), unlocking significant performance improvements.\n+However, it is implemented as a dangerous primitive that can lead to incorrect\n+programs if used incorrectly.\n+\n+## What is constant folding?\n+\n+Constant folding means a read of a variable of a constant value can be replaced\n+by the read constant value, during the construction of an IR graph.  The\n+related logic resides in `ci\/ciField.hpp` (compiler interface field).\n+\n+For example, if a field `int a` has a constant value `4` and a field `int b` has\n+constant value `5`, the constant folding will replace the `a + b` in the IR with\n+a value of `9`.\n+\n+## How is a value determined to be constant?\n+\n+Constantness is decided on a per-variable and per-value basis.  This includes\n+the location of the variable so that a variable might have a constant value,\n+and the value of the variable so the read value is constant.\n+\n+### Field constants\n+\n+Whether a field may have a constant value is determined by the\n+`ciField::is_constant()` method in Hotspot.  The value of `_is_constant` is\n+determined in `ciField::initialize_from`.  It is roughly as follows:\n+\n+1. A field may be constant if it is stable.\n+2. Before Java 9, `putfield`  in `<clinit>` could write to an instance final\n+   field and `putstatic` in `<init>` could write to a static final field.  Such\n+   written final fields from pre-53-major classes are considered never constant.\n+3. Otherwise, if a static final field is not `System.in`, `System.out`, or\n+   `System.err`, it may be constant.\n+4. If an instance final field comes from a record class, a hidden class, it may\n+   be constant.\n+5. If an instance final field is declared in a system class that is either:\n+\n+   1. Marked `@TrustFinalFields`\n+   2. In one of the trusted system packages specified in\n+      `trust_final_non_static_fields` in `ciField.cpp`\n+\n+   It may be constant.  Note that such a field is not protected from reflective\n+   modification through core reflection `Field.set`.\n+6. If the field is `CallSite.target`, it may be constant. (This has extra\n+   treatments like nmethod dependency, so is not quite as other constant\n+   fields)\n+\n+A `ciField` models a field declaration in the JVM, so an inherited field (as\n+in a field reference, static or instance) in a subclass or subinterface shares\n+the constantness settings.\n+\n+After a field is considered to be possibly constant, its value is fetched from\n+the runtime and examined.  If the field is stable, and the value is zero or null\n+(the default value), this read value is not constant.  Only non-stable final\n+fields can have their zero or null values considered constant.\n+\n+### Array constants\n+\n+If an array field is stable, the type system in the compiler of Hotspot marks\n+the array to be stable up to its declared level.  (See the code of the most\n+generic variant of `Type::make_constant_from_field`)  As a result, access to\n+nested array components _with a constant index_ can be treated as a constant\n+value, if the read value is not zero or null (the default value).\n+\n+This means the stable annotation is not as helpful for random access (it only\n+elides loading the array reference), and null components in an \"immutable\" array\n+may cause surprising slowdowns.\n+\n+## How can I verify constant folding?\n+\n+Since constant folding makes a huge difference in API performance characteristics,\n+tests are necessary to guarantee they happen.\n+\n+The most reliable way to ensure folding is IR tests in the compiler; we can\n+expect compiler to eliminate known foldable IR structures when its inputs are\n+eligible.  For example, in the initial constant folding example of `a + b`, an\n+IR test can verify the int addition is eliminated in the resulting IR by\n+constant folding.\n+\n+An example test is `compiler.c2.irTests.constantFold.TestOptional`.  Note that\n+IR tests need to be run in a debug (fastdebug) configure profile, which is not\n+used for most jdk library tests.\n+\n+JMH benchmarks can be another way to verify, except they are costly to run and\n+their trend is hard to track.  Prefer the compiler tests instead.\n+\n+## Relation to final mechanisms\n+\n+### `Field.trustedFinal` property\n+\n+A `Field` object has a `trustedFinal` field, which when set to `true`, prevents\n+core reflection or method handles from creating a setter for this field in any\n+scenario.  This is derived from `fieldDescriptor::is_trusted_final()`, which\n+designates final fields that are static, declared in a record class, or declared\n+in a hidden class as `trustedFinal`.  This rule is different from the \"may be\n+constant variable\" rule from above; in particular, it does not protect the\n+instance final fields in eligible system classes per rule 5 above.\n+\n+Note that a `Field` object also models a field declaration in the JVM like a\n+`ciField`, so an inherited field in a subclass or subinterface shares the\n+`trustedFinal` setting.\n+\n+### Make Final Mean Final\n+\n+As noted for `Field.trustedFinal`, protections are missing for some system\n+classes.  The effort to make final mean final, that all illegal final field\n+modifications must use `--enable-final-field-mutation` and `--add-opens`,\n+represents a step toward this goal.\n+\n+In JEP 500, when `--illegal-final-field-mutation=deny`, a final field `f` is\n+still mutable if for some module `M` (including the unnamed module) that could\n+perform final field mutation, one of the following stands:\n+\n+1. `f` is a public field declared in a public class, and the package\n+   of the declaring class is exported by the containing module to `M`.\n+2. The package of the declaring class of `f` is open to `M`.\n+3. `f` is in `M`.\n+\n+This set of rules is more complex than the existing logic in `fieldDescriptor`,\n+and being in `jdk.internal.module.ModuleBootstrap`, is not easy to export to\n+the JVM runtime.  In addition, the performance implication of enabling final\n+field mutation on the command line may also be concerning to users.\n+\n+In conclusion, trusting based on final field mutation settings is possible, but\n+whether the cost is worth the return is under investigation.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/constant-folding.md","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests.constantFold;\n+\n+import java.util.Optional;\n+\n+import compiler.lib.ir_framework.Check;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+\n+\/*\n+ * @test\n+ * @bug 8372696\n+ * @summary Verify constant folding for Optional\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.irTests.constantFold.TestOptional\n+ *\/\n+public class TestOptional {\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=inline,java.util.Optional::orElse\",\n+            \"-XX:CompileCommand=inline,java.lang.Integer::intValue\",\n+            \"-XX:CompileCommand=inline,java.lang.Integer::valueOf\"\n+        );\n+    }\n+\n+    \/\/ Ensure both present and empty values can fold\n+    static final Optional<Integer> ONE = Optional.of(5), TWO = Optional.empty();\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_I})\n+    public int testSum() {\n+        return ONE.orElse(7) + TWO.orElse(12);\n+    }\n+\n+    @Check(test = \"testSum\")\n+    public static void checkTestSum(int res) {\n+        if (res != 5 + 12) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/constantFold\/TestOptional.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"}]}