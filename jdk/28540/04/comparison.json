{"files":[{"patch":"@@ -219,0 +219,4 @@\n+  if (holder->trust_final_fields()) {\n+    \/\/ Explicit opt-in from system classes\n+    return true;\n+  }\n@@ -233,8 +237,0 @@\n-  \/\/ Trust Atomic*FieldUpdaters: they are very important for performance, and make up one\n-  \/\/ more reason not to use Unsafe, if their final fields are trusted. See more in JDK-8140483.\n-  if (holder->name() == ciSymbols::java_util_concurrent_atomic_AtomicIntegerFieldUpdater_Impl() ||\n-      holder->name() == ciSymbols::java_util_concurrent_atomic_AtomicLongFieldUpdater_CASUpdater() ||\n-      holder->name() == ciSymbols::java_util_concurrent_atomic_AtomicLongFieldUpdater_LockedUpdater() ||\n-      holder->name() == ciSymbols::java_util_concurrent_atomic_AtomicReferenceFieldUpdater_Impl()) {\n-    return true;\n-  }\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+  _trust_final_fields = ik->trust_final_fields();\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  bool                   _trust_final_fields;\n@@ -210,0 +211,4 @@\n+  bool trust_final_fields() const {\n+    return _trust_final_fields;\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -946,0 +946,1 @@\n+    _jdk_internal_vm_annotation_TrustFinalFields,\n@@ -1881,0 +1882,5 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_TrustFinalFields_signature): {\n+      if (_location != _in_class)   break;  \/\/ only allow for classes\n+      if (!privileged)              break;  \/\/ only allow in privileged code\n+      return _jdk_internal_vm_annotation_TrustFinalFields;\n+    }\n@@ -1994,0 +2000,3 @@\n+  }\n+  if (has_annotation(_jdk_internal_vm_annotation_TrustFinalFields)) {\n+    ik->set_trust_final_fields(true);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -248,4 +248,0 @@\n-  template(java_util_concurrent_atomic_AtomicIntegerFieldUpdater_Impl,       \"java\/util\/concurrent\/atomic\/AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl\") \\\n-  template(java_util_concurrent_atomic_AtomicLongFieldUpdater_CASUpdater,    \"java\/util\/concurrent\/atomic\/AtomicLongFieldUpdater$CASUpdater\") \\\n-  template(java_util_concurrent_atomic_AtomicLongFieldUpdater_LockedUpdater, \"java\/util\/concurrent\/atomic\/AtomicLongFieldUpdater$LockedUpdater\") \\\n-  template(java_util_concurrent_atomic_AtomicReferenceFieldUpdater_Impl,     \"java\/util\/concurrent\/atomic\/AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl\") \\\n@@ -305,0 +301,1 @@\n+  template(jdk_internal_vm_annotation_TrustFinalFields_signature, \"Ljdk\/internal\/vm\/annotation\/TrustFinalFields;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -356,0 +356,3 @@\n+  bool trust_final_fields()                { return _misc_flags.trust_final_fields(); }\n+  void set_trust_final_fields(bool value)  { _misc_flags.set_trust_final_fields(value); }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+    flag(trust_final_fields                 , 1 << 14) \/* All instance final fields in this class should be trusted *\/ \\\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.internal.vm.annotation.Stable;\n+import jdk.internal.vm.annotation.TrustFinalFields;\n@@ -65,0 +65,1 @@\n+@TrustFinalFields\n@@ -74,1 +75,0 @@\n-    @Stable\n","filename":"src\/java.base\/share\/classes\/java\/util\/Optional.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import jdk.internal.vm.annotation.TrustFinalFields;\n+\n@@ -374,0 +376,1 @@\n+    @TrustFinalFields\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicIntegerFieldUpdater.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import jdk.internal.vm.annotation.TrustFinalFields;\n+\n@@ -371,0 +373,1 @@\n+    @TrustFinalFields\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicLongFieldUpdater.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import jdk.internal.vm.annotation.TrustFinalFields;\n+\n@@ -315,0 +317,1 @@\n+    @TrustFinalFields\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicReferenceFieldUpdater.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.vm.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/\/\/ Indicates all instance final fields declared in the annotated class should\n+\/\/\/ be trusted as constants by compilers in `ciField::is_constant`.\n+\/\/\/\n+\/\/\/ The compiler already treats static final fields and instance final fields in\n+\/\/\/ record classes and hidden classes as constant.  All classes in select\n+\/\/\/ packages (Defined in `trust_final_non_static_fields` in `ciField.cpp`) in\n+\/\/\/ the boot class loader also have their instance final fields trusted.  This\n+\/\/\/ annotation is not necessary in these cases.\n+\/\/\/\n+\/\/\/ The [Stable] annotation treats fields as constants once they are not the\n+\/\/\/ zero or null value.  In comparison, a non-stable final instance field\n+\/\/\/ trusted by this annotation can treat zero and null values as constants.\n+\/\/\/\n+\/\/\/ This annotation is suitable when constant treatment of final fields is\n+\/\/\/ performance sensitive, yet package-wide final field constant treatment may\n+\/\/\/ be at risk from final field modifications such as serialization.\n+\/\/\/\n+\/\/\/ This annotation is only recognized on classes from the boot and platform\n+\/\/\/ class loaders and is ignored elsewhere.\n+\/\/\/\n+\/\/\/ @since 26\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.TYPE)\n+public @interface TrustFinalFields {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/TrustFinalFields.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests.constantFold;\n+\n+import java.util.Optional;\n+\n+import compiler.lib.ir_framework.Check;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+\n+\/*\n+ * @test\n+ * @bug 8372696\n+ * @summary Verify constant folding for Optional\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.irTests.constantFold.TestOptional\n+ *\/\n+public class TestOptional {\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=inline,java.util.Optional::orElse\",\n+            \"-XX:CompileCommand=inline,java.lang.Integer::intValue\",\n+            \"-XX:CompileCommand=inline,java.lang.Integer::valueOf\"\n+        );\n+    }\n+\n+    \/\/ Ensure both present and empty values can fold\n+    static final Optional<Integer> ONE = Optional.of(5), TWO = Optional.empty();\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD_I})\n+    public int testSum() {\n+        return ONE.orElse(7) + TWO.orElse(12);\n+    }\n+\n+    @Check(test = \"testSum\")\n+    public static void checkTestSum(int res) {\n+        if (res != 5 + 12) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/constantFold\/TestOptional.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"}]}