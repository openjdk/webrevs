{"files":[{"patch":"@@ -3498,9 +3498,7 @@\n-        if(scale==0) {\n-            if(intCompact!=INFLATED) {\n-                return Long.toString(intCompact);\n-            } else {\n-                return intVal.toString();\n-            }\n-        }\n-        if(this.scale<0) { \/\/ No decimal point\n-            if(signum()==0) {\n+        int scale = this.scale;\n+        if (scale == 0)\n+            return unscaledString();\n+\n+        int signum = signum();\n+        if (scale < 0) { \/\/ No decimal point\n+            if (signum == 0)\n@@ -3508,5 +3506,2 @@\n-            }\n-            int trailingZeros = checkScaleNonZero((-(long)scale));\n-            String str = intCompact != INFLATED\n-                ? Long.toString(intCompact)\n-                : intVal.toString();\n+            int trailingZeros = checkScaleNonZero((-(long) scale));\n+            String str = unscaledString();\n@@ -3517,4 +3512,4 @@\n-            StringBuilder buf = new StringBuilder(len);\n-            buf.append(str);\n-            buf.repeat('0', trailingZeros);\n-            return buf.toString();\n+            return new StringBuilder(len)\n+                    .append(str)\n+                    .repeat('0', trailingZeros)\n+                    .toString();\n@@ -3522,5 +3517,58 @@\n-        String str;\n-        if(intCompact!=INFLATED) {\n-            str = Long.toString(Math.abs(intCompact));\n-        } else {\n-            str = intVal.abs().toString();\n+\n+        long intCompact = this.intCompact;\n+        \/\/ currency fast path\n+        if (intCompact != INFLATED) {\n+            long intCompactAbs = Math.abs(intCompact);\n+            if (scale == 2 & (int) intCompact == intCompactAbs) { \/\/ intCompact >= 0 && intCompact <= Integer.MAX_VALUE\n+                return scale2((int) intCompact);\n+            }\n+            return getValueString(signum, intCompactAbs, DecimalDigits.stringSize(intCompactAbs), scale);\n+        }\n+\n+        return getValueString(signum, intVal.abs().toString(), scale);\n+    }\n+\n+    private static String getValueString(int signum, long intCompactAbs, int intCompactAbsSize, int scale) {\n+        \/* Insert decimal point *\/\n+        int insertionPoint = intCompactAbsSize - scale;\n+        byte[] buf;\n+        if (insertionPoint == 0) {  \/* Point goes just before intVal *\/\n+            buf = new byte[intCompactAbsSize + (signum < 0 ? 3 : 2)];\n+            int off = 0;\n+            if(signum < 0) {\n+                buf[0] = '-';\n+                off = 1;\n+            }\n+            buf[off    ] = '0';\n+            buf[off + 1] = '.';\n+            DecimalDigits.getCharsLatin1(intCompactAbs, buf.length, buf);\n+        } else if (insertionPoint > 0) { \/* Point goes inside intVal *\/\n+            buf = new byte[intCompactAbsSize + (signum < 0 ? 2 : 1)];\n+            if (signum < 0) {\n+                buf[0] = '-';\n+                insertionPoint++;\n+            }\n+            long power = LONG_TEN_POWERS_TABLE[scale];\n+            long highInt = intCompactAbs \/ power;\n+            long small = Math.abs(intCompactAbs - highInt * power);\n+            DecimalDigits.getCharsLatin1(highInt, insertionPoint, buf);\n+            buf[insertionPoint] = '.';\n+            int smallStart = DecimalDigits.getCharsLatin1(small, buf.length, buf);\n+            if (smallStart > insertionPoint + 1) { \/\/ fill zeros\n+                Arrays.fill(buf, insertionPoint + 1, smallStart, (byte) '0');\n+            }\n+        } else { \/* We must insert zeros between point and intVal *\/\n+            int len = (signum < 0 ? 3 : 2) + scale;\n+            if (len < 0) {\n+                throw new OutOfMemoryError(\"too large to fit in a String\");\n+            }\n+            buf = new byte[len];\n+            int off = 0;\n+            if(signum < 0) {\n+                buf[0] = '-';\n+                off = 1;\n+            }\n+            buf[off    ] = '0';\n+            buf[off + 1] = '.';\n+            Arrays.fill(buf, off + 2, off + 2 - insertionPoint, (byte) '0');\n+            DecimalDigits.getCharsLatin1(intCompactAbs, buf.length, buf);\n@@ -3528,1 +3576,1 @@\n-        return getValueString(signum(), str, scale);\n+        return newStringNoRepl(buf);\n@@ -3534,1 +3582,0 @@\n-        StringBuilder buf;\n@@ -3537,1 +3584,1 @@\n-            return (signum<0 ? \"-0.\" : \"0.\") + intString;\n+            return (signum < 0 ? \"-0.\" : \"0.\").concat(intString);\n@@ -3539,4 +3586,8 @@\n-            buf = new StringBuilder(intString);\n-            buf.insert(insertionPoint, '.');\n-            if (signum < 0)\n-                buf.insert(0, '-');\n+            StringBuilder buf = new StringBuilder();\n+            if (signum < 0) {\n+                buf.append('-');\n+                insertionPoint++;\n+            }\n+            return buf.append(intString)\n+                      .insert(insertionPoint, '.')\n+                      .toString();\n@@ -3548,4 +3599,5 @@\n-            buf = new StringBuilder(len);\n-            buf.append(signum<0 ? \"-0.\" : \"0.\");\n-            buf.repeat('0', -insertionPoint);  \/\/ insertionPoint != MIN_VALUE\n-            buf.append(intString);\n+            return new StringBuilder(len)\n+                    .append(signum<0 ? \"-0.\" : \"0.\")\n+                    .repeat('0', -insertionPoint)  \/\/ insertionPoint != MIN_VALUE\n+                    .append(intString)\n+                    .toString();\n@@ -3553,1 +3605,0 @@\n-        return buf.toString();\n@@ -4185,1 +4236,0 @@\n-        long intCompact = this.intCompact;\n@@ -4188,19 +4238,1 @@\n-            return (intCompact != INFLATED) ?\n-                Long.toString(intCompact):\n-                intVal.toString();\n-        if (scale == 2  &&\n-            intCompact >= 0 && intCompact < Integer.MAX_VALUE) {\n-            \/\/ currency fast path\n-            int lowInt = (int)intCompact % 100;\n-            int highInt = (int)intCompact \/ 100;\n-            int highIntSize = DecimalDigits.stringSize(highInt);\n-            byte[] buf = new byte[highIntSize + 3];\n-            DecimalDigits.getCharsLatin1(highInt, highIntSize, buf);\n-            buf[highIntSize] = '.';\n-            DecimalDigits.putPairLatin1(buf, highIntSize + 1, lowInt);\n-            try {\n-                return JLA.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n-            } catch (CharacterCodingException cce) {\n-                throw new AssertionError(cce);\n-            }\n-        }\n+            return unscaledString();\n@@ -4208,3 +4240,4 @@\n-        char[] coeff;\n-        int offset;  \/\/ offset is the starting index for coeff array\n-        \/\/ Get the significand as an absolute value\n+        long intCompact = this.intCompact;\n+        int signum, coeffLen;\n+        \/\/ the significand as an absolute value\n+        String coeff;\n@@ -4212,3 +4245,13 @@\n-            \/\/ All non negative longs can be made to fit into 19 character array.\n-            coeff = new char[19];\n-            offset = DecimalDigits.getChars(Math.abs(intCompact), coeff.length, coeff);\n+            long intCompactAbs = Math.abs(intCompact);\n+            if (scale == 2 && (int) intCompact == intCompactAbs) { \/\/ intCompact >= 0 && intCompact <= Integer.MAX_VALUE\n+                return scale2((int) intCompact);\n+            }\n+            coeffLen = DecimalDigits.stringSize(intCompactAbs);\n+            signum = signum();\n+            long adjusted = -(long)scale + (coeffLen -1);\n+            if ((scale >= 0) & (adjusted >= -6)) { \/\/ plain number\n+                return getValueString(signum, intCompactAbs, coeffLen, scale);\n+            }\n+            byte[] buf = new byte[coeffLen];\n+            DecimalDigits.getCharsLatin1(intCompactAbs, buf.length, buf);\n+            coeff = newStringNoRepl(buf);\n@@ -4216,2 +4259,3 @@\n-            offset = 0;\n-            coeff  = intVal.abs().toString().toCharArray();\n+            signum = signum();\n+            coeff = intVal.abs().toString();\n+            coeffLen = coeff.length();\n@@ -4224,5 +4268,1 @@\n-        StringBuilder buf = new StringBuilder(32);;\n-        if (signum() < 0)             \/\/ prefix '-' if negative\n-            buf.append('-');\n-        int coeffLen = coeff.length - offset;\n-        long adjusted = -(long)scale + (coeffLen -1);\n+        long adjusted = -(long) scale + (coeffLen - 1);\n@@ -4230,12 +4270,16 @@\n-            int pad = scale - coeffLen;         \/\/ count of padding zeros\n-            if (pad >= 0) {                     \/\/ 0.xxx form\n-                buf.append('0');\n-                buf.append('.');\n-                for (; pad>0; pad--) {\n-                    buf.append('0');\n-                }\n-                buf.append(coeff, offset, coeffLen);\n-            } else {                         \/\/ xx.xx form\n-                buf.append(coeff, offset, -pad);\n-                buf.append('.');\n-                buf.append(coeff, -pad + offset, scale);\n+            return getValueString(signum, coeff, scale);\n+        }\n+        \/\/ E-notation is needed\n+        return layoutCharsE(sci, coeff, coeffLen, adjusted);\n+    }\n+\n+    private String layoutCharsE(boolean sci, String coeff, int coeffLen, long adjusted) {\n+        StringBuilder buf = new StringBuilder(coeffLen + 14);\n+        int signum = signum();\n+        if (signum < 0)                  \/\/ prefix '-' if negative\n+            buf.append('-');\n+        if (sci) {                       \/\/ Scientific notation\n+            buf.append(coeff.charAt(0)); \/\/ first character\n+            if (coeffLen > 1) {          \/\/ more to come\n+                buf.append('.')\n+                   .append(coeff, 1, coeffLen);\n@@ -4243,15 +4287,8 @@\n-        } else { \/\/ E-notation is needed\n-            if (sci) {                       \/\/ Scientific notation\n-                buf.append(coeff[offset]);   \/\/ first character\n-                if (coeffLen > 1) {          \/\/ more to come\n-                    buf.append('.');\n-                    buf.append(coeff, offset + 1, coeffLen - 1);\n-                }\n-            } else {                         \/\/ Engineering notation\n-                int sig = (int)(adjusted % 3);\n-                if (sig < 0)\n-                    sig += 3;                \/\/ [adjusted was negative]\n-                adjusted -= sig;             \/\/ now a multiple of 3\n-                sig++;\n-                if (signum() == 0) {\n-                    switch (sig) {\n+        } else {                         \/\/ Engineering notation\n+            int sig = (int)(adjusted % 3);\n+            if (sig < 0)\n+                sig += 3;                \/\/ [adjusted was negative]\n+            adjusted -= sig;             \/\/ now a multiple of 3\n+            sig++;\n+            if (signum == 0) {\n+                switch (sig) {\n@@ -4271,11 +4308,0 @@\n-                    }\n-                } else if (sig >= coeffLen) {   \/\/ significand all in integer\n-                    buf.append(coeff, offset, coeffLen);\n-                    \/\/ may need some zeros, too\n-                    for (int i = sig - coeffLen; i > 0; i--) {\n-                        buf.append('0');\n-                    }\n-                } else {                     \/\/ xx.xxE form\n-                    buf.append(coeff, offset, sig);\n-                    buf.append('.');\n-                    buf.append(coeff, offset + sig, coeffLen - sig);\n@@ -4283,6 +4309,7 @@\n-            }\n-            if (adjusted != 0) {             \/\/ [!sci could have made 0]\n-                buf.append('E');\n-                if (adjusted > 0)            \/\/ force sign for positive\n-                    buf.append('+');\n-                buf.append(adjusted);\n+            } else if (sig >= coeffLen) {\/\/ significand all in integer\n+                buf.append(coeff, 0, coeffLen)\n+                   .repeat('0', sig - coeffLen); \/\/ may need some zeros, too\n+            } else {                     \/\/ xx.xxE form\n+                buf.append(coeff, 0, sig)\n+                   .append('.')\n+                   .append(coeff, sig, coeffLen);\n@@ -4291,0 +4318,6 @@\n+        if (adjusted != 0) {             \/\/ [!sci could have made 0]\n+            buf.append('E');\n+            if (adjusted > 0)            \/\/ force sign for positive\n+                buf.append('+');\n+            buf.append(adjusted);\n+        }\n@@ -4294,0 +4327,25 @@\n+    private static String scale2(int intCompact) {\n+        int highInt = intCompact \/ 100;\n+        int lowInt = intCompact - highInt * 100;\n+        int highIntSize = DecimalDigits.stringSize(highInt);\n+        byte[] buf = new byte[highIntSize + 3];\n+        DecimalDigits.putPairLatin1(buf, highIntSize + 1, lowInt);\n+        buf[highIntSize] = '.';\n+        DecimalDigits.getCharsLatin1(highInt, highIntSize, buf);\n+        return newStringNoRepl(buf);\n+    }\n+\n+    private static String newStringNoRepl(byte[] buf) {\n+        try {\n+            return JLA.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException cce) {\n+            throw new AssertionError(cce);\n+        }\n+    }\n+\n+    private String unscaledString() {\n+        return intCompact != INFLATED\n+                ? Long.toString(intCompact)\n+                : intVal.toString();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":170,"deletions":112,"binary":false,"changes":282,"status":"modified"},{"patch":"@@ -338,64 +338,0 @@\n-    \/**\n-     * This is a variant of {@link DecimalDigits#getCharsUTF16(long, int, byte[])}, but for\n-     * UTF-16 coder.\n-     *\n-     * @param i     value to convert\n-     * @param index next index, after the least significant digit\n-     * @param buf   target buffer, UTF16-coded.\n-     * @return index of the most significant digit or minus sign, if present\n-     *\/\n-    public static int getChars(long i, int index, char[] buf) {\n-        \/\/ Used by trusted callers.  Assumes all necessary bounds checks have been done by the caller.\n-        long q;\n-        int charPos = index;\n-\n-        boolean negative = (i < 0);\n-        if (!negative) {\n-            i = -i;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n-        while (i < Integer.MIN_VALUE) {\n-            q = i \/ 100;\n-            charPos -= 2;\n-            putPair(buf, charPos, (int)((q * 100) - i));\n-            i = q;\n-        }\n-\n-        \/\/ Get 2 digits\/iteration using ints\n-        int q2;\n-        int i2 = (int)i;\n-        while (i2 <= -100) {\n-            q2 = i2 \/ 100;\n-            charPos -= 2;\n-            putPair(buf, charPos, (q2 * 100) - i2);\n-            i2 = q2;\n-        }\n-\n-        \/\/ We know there are at most two digits left at this point.\n-        if (i2 <= -10) {\n-            charPos -= 2;\n-            putPair(buf, charPos, -i2);\n-        } else {\n-            buf[--charPos] = (char) ('0' - i2);\n-        }\n-\n-        if (negative) {\n-            buf[--charPos] = '-';\n-        }\n-        return charPos;\n-    }\n-\n-    \/**\n-     * Insert the 2-chars integer into the buf as 2 decimal digit ASCII chars,\n-     * only least significant 16 bits of {@code v} are used.\n-     * @param buf byte buffer to copy into\n-     * @param charPos insert point\n-     * @param v to convert\n-     *\/\n-    public static void putPair(char[] buf, int charPos, int v) {\n-        int packed = DIGITS[v];\n-        buf[charPos    ] = (char) (packed & 0xFF);\n-        buf[charPos + 1] = (char) (packed >> 8);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -38,0 +39,1 @@\n+import java.lang.invoke.*;\n@@ -48,1 +50,1 @@\n-@Fork(value = 3)\n+@Fork(value = 3, jvmArgs = {\"--add-opens\", \"java.base\/java.math=ALL-UNNAMED\"})\n@@ -63,1 +65,3 @@\n-    private BigDecimal[] hugeArray, largeArray, smallArray;\n+    private BigDecimal[] hugeArray;\n+    private BigDecimal[] large2Array, small2Array;\n+    private BigDecimal[] large3Array, small3Array;\n@@ -99,3 +103,4 @@\n-        * Large numbers less than MAX_LONG but larger than MAX_INT\n-        *\/\n-        largeArray = new BigDecimal[TEST_SIZE];\n+         * Large numbers less than MAX_LONG but larger than MAX_INT\n+         *\/\n+        large2Array = new BigDecimal[TEST_SIZE];\n+        large3Array = new BigDecimal[TEST_SIZE];\n@@ -104,3 +109,4 @@\n-        * Small number less than MAX_INT\n-        *\/\n-        smallArray = new BigDecimal[TEST_SIZE];\n+         * Small number less than MAX_INT\n+         *\/\n+        small2Array = new BigDecimal[TEST_SIZE];\n+        small3Array = new BigDecimal[TEST_SIZE];\n@@ -113,2 +119,6 @@\n-            largeArray[i] = new BigDecimal(\"\" + ((long) value + (long) Integer.MAX_VALUE) + \".55\");\n-            smallArray[i] = new BigDecimal(\"\" + ((long) value \/ 1000) + \".55\");\n+\n+            large2Array[i] = new BigDecimal(\"\" + ((long) value + (long) Integer.MAX_VALUE) + \".55\");\n+            large3Array[i] = new BigDecimal(\"\" + ((long) value + (long) Integer.MAX_VALUE) + \".555\");\n+\n+            small2Array[i] = new BigDecimal(\"\" + ((long) value \/ 1000) + \".55\");\n+            small3Array[i] = new BigDecimal(\"\" + ((long) value \/ 1000) + \".555\");\n@@ -188,1 +198,11 @@\n-    \/** Test divide with huge\/small numbers *\/\n+    \/** Invokes the compareTo method of BigDecimal with various different values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE - 1)\n+    public void testCompareTo(Blackhole bh) {\n+        BigDecimal c = bigDecimals[0];\n+        for (BigDecimal s : bigDecimals) {\n+            bh.consume(c.compareTo(s));\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toString() with large numbers (scale 2) less than MAX_LONG but larger than MAX_INT *\/\n@@ -190,2 +210,2 @@\n-    @OperationsPerInvocation(TEST_SIZE * TEST_SIZE)\n-    public void testHugeSmallDivide(Blackhole bh) {\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void hugeLayoutCharsToString(Blackhole bh) throws Throwable {\n@@ -193,3 +213,1 @@\n-            for (BigDecimal t : smallArray) {\n-                bh.consume(s.divide(t, RoundingMode.DOWN));\n-            }\n+            bh.consume((String) BigDecimalAccess.layoutChars.invokeExact(s, true));\n@@ -199,1 +217,1 @@\n-    \/** Test divide with large\/small numbers *\/\n+    \/** Test BigDecimal.toEngineeringString() with huge numbers larger than MAX_LONG *\/\n@@ -201,6 +219,4 @@\n-    @OperationsPerInvocation(TEST_SIZE * TEST_SIZE)\n-    public void testLargeSmallDivide(Blackhole bh) {\n-        for (BigDecimal s : largeArray) {\n-            for (BigDecimal t : smallArray) {\n-                bh.consume(s.divide(t, RoundingMode.DOWN));\n-            }\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void hugeEngineeringToString(Blackhole bh) {\n+        for (BigDecimal s : hugeArray) {\n+            bh.consume(s.toEngineeringString());\n@@ -210,1 +226,1 @@\n-    \/** Test divide with huge\/large numbers *\/\n+    \/** Test BigDecimal.toEngineeringString() with huge numbers larger than MAX_LONG *\/\n@@ -212,2 +228,2 @@\n-    @OperationsPerInvocation(TEST_SIZE * TEST_SIZE)\n-    public void testHugeLargeDivide(Blackhole bh) {\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void hugePlainToString(Blackhole bh) {\n@@ -215,3 +231,1 @@\n-            for (BigDecimal t : largeArray) {\n-                bh.consume(s.divide(t, RoundingMode.DOWN));\n-            }\n+            bh.consume(s.toPlainString());\n@@ -221,1 +235,1 @@\n-    \/** Invokes the compareTo method of BigDecimal with various different values. *\/\n+    \/** Test BigDecimal.toString() with large numbers (scale 2) less than MAX_LONG but larger than MAX_INT *\/\n@@ -223,5 +237,116 @@\n-    @OperationsPerInvocation(TEST_SIZE - 1)\n-    public void testCompareTo(Blackhole bh) {\n-        BigDecimal c = bigDecimals[0];\n-        for (BigDecimal s : bigDecimals) {\n-            bh.consume(c.compareTo(s));\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void largeScale2LayoutCharsToString(Blackhole bh) throws Throwable {\n+        for (BigDecimal s : large2Array) {\n+            bh.consume((String) BigDecimalAccess.layoutChars.invokeExact(s, true));\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toEngineeringString() with large numbers (scale 2) less than MAX_LONG but larger than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void largeScale2EngineeringToString(Blackhole bh) {\n+        for (BigDecimal s : large2Array) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toPlainString() with large numbers (scale 2) less than MAX_LONG but larger than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void largeScale2PlainToString(Blackhole bh) {\n+        for (BigDecimal s : large2Array) {\n+            bh.consume(s.toPlainString());\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toString() with large numbers (scale 3) less than MAX_LONG but larger than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void largeScale3LayoutCharsToString(Blackhole bh) throws Throwable {\n+        for (BigDecimal s : large3Array) {\n+            bh.consume((String) BigDecimalAccess.layoutChars.invokeExact(s, true));\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toEngineeringString() with large numbers (scale 3) less than MAX_LONG but larger than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void largeScale3EngineeringToString(Blackhole bh) {\n+        for (BigDecimal s : large3Array) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n+\n+    \/** Test BigDecimal.toPlainString() with large numbers (scale 3) less than MAX_LONG but larger than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void largeScale3PlainToString(Blackhole bh) {\n+        for (BigDecimal s : large3Array) {\n+            bh.consume(s.toPlainString());\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toString() with small numbers (scale 2) less than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void smallScale2LayoutCharsToString(Blackhole bh) throws Throwable {\n+        for (BigDecimal s : small2Array) {\n+            bh.consume((String) BigDecimalAccess.layoutChars.invokeExact(s, true));\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toEngineeringString() with small numbers (scale 2) less than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void smallScale2EngineeringToString(Blackhole bh) {\n+        for (BigDecimal s : small2Array) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toPlainString() with small numbers (scale 3) less than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void smallScale2PlainToString(Blackhole bh) {\n+        for (BigDecimal s : small2Array) {\n+            bh.consume(s.toPlainString());\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toString() with small numbers (scale 3) less than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void smallScale3LayoutCharsToString(Blackhole bh) throws Throwable {\n+        for (BigDecimal s : small3Array) {\n+            bh.consume((String) BigDecimalAccess.layoutChars.invokeExact(s, true));\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toEngineeringString() with small numbers (scale 3) less than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void smallScale3EngineeringToString(Blackhole bh) {\n+        for (BigDecimal s : small3Array) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toPlainString() with small numbers (scale 3) less than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void smallScale3PlainToString(Blackhole bh) {\n+        for (BigDecimal s : small3Array) {\n+            bh.consume(s.toPlainString());\n+        }\n+    }\n+\n+    static class BigDecimalAccess {\n+        final static MethodHandle layoutChars;\n+        static {\n+            try {\n+                MethodHandles.Lookup lookup = MethodHandles.privateLookupIn(BigDecimal.class, MethodHandles.lookup());\n+                layoutChars = lookup.findVirtual(BigDecimal.class, \"layoutChars\", MethodType.methodType(String.class, boolean.class));\n+            } catch (Throwable e) {\n+                throw new AssertionError(e);\n+            }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigDecimals.java","additions":160,"deletions":35,"binary":false,"changes":195,"status":"modified"}]}