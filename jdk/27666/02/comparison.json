{"files":[{"patch":"@@ -5179,1 +5179,1 @@\n-      if (!head->is_BaseCountedLoop() || !lpt->is_innermost()) continue;\n+      if (!lpt->is_innermost()) continue;\n@@ -5182,7 +5182,5 @@\n-      if (head->is_CountedLoop()) {\n-        if (head->as_CountedLoop()->is_unroll_only()) {\n-          continue;\n-        } else {\n-          AutoNodeBudget node_budget(this);\n-          lpt->reassociate_invariants(this);\n-        }\n+      if (head->is_CountedLoop() && head->as_CountedLoop()->is_unroll_only()) {\n+        continue;\n+      } else {\n+        AutoNodeBudget node_budget(this);\n+        lpt->reassociate_invariants(this);\n@@ -5194,0 +5192,1 @@\n+          head->is_BaseCountedLoop() &&\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8369258\n+ * @summary C2: enable ReassociateInvariants for all loop types\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.TestReassociateInvariants\n+ *\/\n+\n+package compiler.loopopts;\n+\n+\n+import compiler.lib.ir_framework.*;\n+\n+import java.util.Objects;\n+\n+public class TestReassociateInvariants {\n+    private static long longStart = 0;\n+    private static long longStop = 1000;\n+    private static int intStart = 0;\n+    private static int intStop = 1000;\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:-ShortRunningLongLoop\");\n+    }\n+\n+    \/\/ The IR framework is not powerful enough to directly check\n+    \/\/ wether invariants are moved out of a loop so tests below rely on\n+    \/\/ some side effect that can be observed by the IR framework.\n+\n+    \/\/ Once a + (b + i) is transformed into i + (a + b), the a + b\n+    \/\/ before the loop and the one from inside the loop common and one\n+    \/\/ Add is removed.\n+    @Test\n+    @IR(counts = {IRNode.ADD_I, \"3\"})\n+    @Arguments(values = { Argument.NUMBER_42, Argument.NUMBER_42 })\n+    public int test1(int a, int b) {\n+        int v = a + b;\n+        for (int i = 1; i < 100; i *= 2) {\n+            v += a + (b + i);\n+        }\n+        return v;\n+    }\n+\n+    \/\/ Range Check Elimination only happens once a + (b + i) is\n+    \/\/ transformed into i + (a + b). With the range check eliminated,\n+    \/\/ the loop can be removed. At this point, C2 doesn't support\n+    \/\/ removal of long counted loop. The long counted loop is\n+    \/\/ transformed into a loop nest with an inner int counted\n+    \/\/ loop. That one is empty and is removed.\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.LONG_COUNTED_LOOP })\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @Arguments(values = { Argument.NUMBER_42, Argument.NUMBER_42 })\n+    public void test2(long a, long b) {\n+        for (long i = longStart; i < longStop; i++) {\n+            Objects.checkIndex(a + (b + i), Long.MAX_VALUE);\n+        }\n+    }\n+\n+    \/\/ Same here for an int counted loop with long range checks\n+    @Test\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @Arguments(values = { Argument.NUMBER_42, Argument.NUMBER_42 })\n+    public void test3(long a, long b) {\n+        for (int i = intStart; i < intStop; i++) {\n+            Objects.checkIndex(a + (b + i), Long.MAX_VALUE);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestReassociateInvariants.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.loopopts.superword;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n-\n-import compiler.lib.ir_framework.*;\n-\n-\/*\n- * @test\n- * @bug 8324751\n- * @summary Reported issue: JDK-8360204: C2 SuperWord: missing RCE with MemorySegment.getAtIndex\n- *          The examples are generated from TestAliasingFuzzer.java\n- *          So if you see something change here, you may want to investigate if we\n- *          can also tighten up the IR rules there.\n- * @library \/test\/lib \/\n- * @run driver compiler.loopopts.superword.TestMemorySegment_8360204\n- *\/\n-\n-public class TestMemorySegment_8360204 {\n-\n-    public static MemorySegment a = Arena.ofAuto().allocate(10_000);\n-    public static MemorySegment b = Arena.ofAuto().allocate(10_000);\n-\n-    private static long invar0_1159 = 0;\n-    private static long invar1_1159 = 0;\n-\n-    public static void main(String[] args) {\n-        TestFramework f = new TestFramework();\n-        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n-        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n-                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n-                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n-                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n-        f.start();\n-    }\n-\n-    @Setup\n-    static Object[] setup() {\n-        return new Object[] { a, -19125L, b, 71734L + 2_000L, 0, 1_000 };\n-    }\n-\n-    @Test\n-    @Arguments(setup = \"setup\")\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n-                  IRNode.STORE_VECTOR,  \"= 0\",\n-                  \".*multiversion.*\",   \"> 0\"}, \/\/ Sadly, we now multiversion\n-        phase = CompilePhase.PRINT_IDEAL,\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    \/\/ There is no aliasing, so we should compile without multiversioning.\n-    \/\/ But currently, there seems to be some issue with RCE, we peel and lose the predicate.\n-    \/\/ Then we multiversion.\n-    \/\/ We could imagine that this would eventually vectorize, but since one counts up, and the other down,\n-    \/\/ we would have to implement shuffle first.\n-    \/\/\n-    \/\/ If you see this IR rule fail: investigate JDK-8360204, possibly close it and fix this IR rule!\n-    \/\/ Also: consider renaming the file to something more descriptive: what have you fixed with this?\n-    \/\/ And: you may now be able to tighten IR rules in TestAliasingFuzzer.java\n-    public static void test(MemorySegment container_0, long invar0_0, MemorySegment container_1, long invar0_1, long ivLo, long ivHi) {\n-        for (long i = ivLo; i < ivHi; i+=1) {\n-            var v = container_0.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED, 19125L + 1L * i + 1L * invar0_0 + 0L * invar0_1159 + 1L * invar1_1159);\n-            container_1.setAtIndex(ValueLayout.JAVA_INT_UNALIGNED, -71734L + -1L * i + 1L * invar0_1 + 1L * invar0_1159 + 0L * invar1_1159, v);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_8360204.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.loopopts.superword;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n-\n-import compiler.lib.ir_framework.*;\n-\n-\/*\n- * @test\n- * @bug 8324751\n- * @summary Reported issue: JDK-8365982: C2 SuperWord: missing RCE \/ strange Multiversioning with MemorySegment.set\n- *          The examples are generated from TestAliasingFuzzer.java\n- *          So if you see something change here, you may want to investigate if we\n- *          can also tighten up the IR rules there.\n- * @library \/test\/lib \/\n- * @run driver compiler.loopopts.superword.TestMemorySegment_8365982\n- *\/\n-\n-public class TestMemorySegment_8365982 {\n-\n-    public static MemorySegment a = MemorySegment.ofArray(new short[100_000]);\n-    public static MemorySegment b = MemorySegment.ofArray(new short[100_000]);\n-\n-    private static long invar0_853 = 0;\n-    private static long invar1_853 = 0;\n-    private static long invar2_853 = 0;\n-\n-    public static void main(String[] args) {\n-        TestFramework f = new TestFramework();\n-        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n-        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n-                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n-                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n-                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n-        f.start();\n-    }\n-\n-    @Setup\n-    static Object[] setup() {\n-        return new Object[] { a, -50_000, b, -30_000, 0, 10_000 };\n-    }\n-\n-    @Test\n-    @Arguments(setup = \"setup\")\n-    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n-                  IRNode.REPLICATE_S,  \"> 0\",\n-                  \".*multiversion.*\",  \"= 0\"}, \/\/ Good: The AutoVectorization predicate suffices.\n-        phase = CompilePhase.PRINT_IDEAL,\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"ShortRunningLongLoop\", \"false\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    \/\/\n-    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n-                  IRNode.REPLICATE_S,  \"> 0\",\n-                  \".*multiversion.*\",  \"> 0\"}, \/\/ Bad: Sadly, we now multiversion\n-        phase = CompilePhase.PRINT_IDEAL,\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"ShortRunningLongLoop\", \"true\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Some but not all predicates are RCE'd at the beginning. After unrolling, we multiversion (why?).\n-    \/\/ After PreMainPost, we can do more RangeCheck. Now the main-loop of the multiversion_fast loop\n-    \/\/ does not have any range checks any more.\n-    \/\/ Now it vectorizes. That's good, but we should be able to vectorize without multiversioning.\n-    \/\/\n-    \/\/ If you see this IR rule fail: investigate JDK-8365982, possibly close it and fix this IR rule!\n-    \/\/ Also: consider renaming the file to something more descriptive: what have you fixed with this?\n-    \/\/ And: you may now be able to tighten IR rules in TestAliasingFuzzer.java\n-    public static void test(MemorySegment container_0, long invar0_0, MemorySegment container_1, long invar0_1, long ivLo, long ivHi) {\n-        for (long i = ivHi-1; i >= ivLo; i-=1) {\n-            container_0.set(ValueLayout.JAVA_CHAR_UNALIGNED, -47143L + -2L * i + -2L * invar0_0 + -1L * invar0_853 + -1L * invar1_853 + 0L * invar2_853, (char)0x0102030405060708L);\n-            container_1.set(ValueLayout.JAVA_CHAR_UNALIGNED, 74770L + 2L * i + 2L * invar0_1 + 0L * invar0_853 + 0L * invar1_853 + 0L * invar2_853, (char)0x1112131415161718L);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_8365982.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8324751 8369258\n+ * @summary Reported issue: JDK-8360204: C2 SuperWord: missing RCE with MemorySegment.getAtIndex\n+ *          The examples are generated from TestAliasingFuzzer.java\n+ *          So if you see something change here, you may want to investigate if we\n+ *          can also tighten up the IR rules there.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment_ReassociateInvariants1\n+ *\/\n+\n+public class TestMemorySegment_ReassociateInvariants1 {\n+\n+    public static MemorySegment a = Arena.ofAuto().allocate(10_000);\n+    public static MemorySegment b = Arena.ofAuto().allocate(10_000);\n+\n+    private static long invar0_1159 = 0;\n+    private static long invar1_1159 = 0;\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Setup\n+    static Object[] setup() {\n+        return new Object[] { a, -19125L, b, 71734L + 2_000L, 0, 1_000 };\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\",\n+                  \".*multiversion.*\",   \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We could imagine that this would eventually vectorize, but since one counts up, and the other down,\n+    \/\/ we would have to implement shuffle first.\n+    public static void test(MemorySegment container_0, long invar0_0, MemorySegment container_1, long invar0_1, long ivLo, long ivHi) {\n+        for (long i = ivLo; i < ivHi; i+=1) {\n+            var v = container_0.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED, 19125L + 1L * i + 1L * invar0_0 + 0L * invar0_1159 + 1L * invar1_1159);\n+            container_1.setAtIndex(ValueLayout.JAVA_INT_UNALIGNED, -71734L + -1L * i + 1L * invar0_1 + 1L * invar0_1159 + 0L * invar1_1159, v);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_ReassociateInvariants1.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8324751 8369258\n+ * @summary Reported issue: JDK-8365982: C2 SuperWord: missing RCE \/ strange Multiversioning with MemorySegment.set\n+ *          The examples are generated from TestAliasingFuzzer.java\n+ *          So if you see something change here, you may want to investigate if we\n+ *          can also tighten up the IR rules there.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment_ReassociateInvariants2\n+ *\/\n+\n+public class TestMemorySegment_ReassociateInvariants2 {\n+\n+    public static MemorySegment a = MemorySegment.ofArray(new short[100_000]);\n+    public static MemorySegment b = MemorySegment.ofArray(new short[100_000]);\n+\n+    private static long invar0_853 = 0;\n+    private static long invar1_853 = 0;\n+    private static long invar2_853 = 0;\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Setup\n+    static Object[] setup() {\n+        return new Object[] { a, -50_000, b, -30_000, 0, 10_000 };\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.REPLICATE_S,  \"> 0\",\n+                  \".*multiversion.*\",  \"= 0\"}, \/\/ Good: The AutoVectorization predicate suffices.\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"ShortRunningLongLoop\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.REPLICATE_S,  \"> 0\",\n+                  \".*multiversion.*\",  \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"ShortRunningLongLoop\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    public static void test(MemorySegment container_0, long invar0_0, MemorySegment container_1, long invar0_1, long ivLo, long ivHi) {\n+        for (long i = ivHi-1; i >= ivLo; i-=1) {\n+            container_0.set(ValueLayout.JAVA_CHAR_UNALIGNED, -47143L + -2L * i + -2L * invar0_0 + -1L * invar0_853 + -1L * invar1_853 + 0L * invar2_853, (char)0x0102030405060708L);\n+            container_1.set(ValueLayout.JAVA_CHAR_UNALIGNED, 74770L + 2L * i + 2L * invar0_1 + 0L * invar0_853 + 0L * invar1_853 + 0L * invar2_853, (char)0x1112131415161718L);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_ReassociateInvariants2.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"}]}