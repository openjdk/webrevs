{"files":[{"patch":"@@ -85,1 +85,8 @@\n-  _data[_head++] = request;\n+  u4 elementIndex;\n+  do {\n+    elementIndex = AtomicAccess::load_acquire(&_head);\n+    if (elementIndex >= _capacity) {\n+      return false;\n+    }\n+  } while (AtomicAccess::cmpxchg(&_head, elementIndex, elementIndex + 1) != elementIndex);\n+  _data[elementIndex] = request;\n@@ -97,1 +104,1 @@\n-  return _head;\n+  return AtomicAccess::load_acquire(&_head);\n@@ -101,1 +108,1 @@\n-  _head = size;\n+  AtomicAccess::release_store(&_head, size);\n@@ -105,1 +112,1 @@\n-  return _capacity;\n+  return AtomicAccess::load_acquire(&_capacity);\n@@ -109,1 +116,1 @@\n-  if (capacity == _capacity) {\n+  if (capacity == AtomicAccess::load(&_capacity)) {\n@@ -122,1 +129,1 @@\n-  _capacity = capacity;\n+  AtomicAccess::release_store(&_capacity, capacity);\n@@ -126,1 +133,1 @@\n-  return _head == 0;\n+  return AtomicAccess::load_acquire(&_head) == 0;\n@@ -130,1 +137,1 @@\n-  return _lost_samples;\n+  return AtomicAccess::load(&_lost_samples);\n@@ -139,1 +146,1 @@\n-  _lost_samples_due_to_queue_full++;\n+  AtomicAccess::inc(&_lost_samples_due_to_queue_full);\n@@ -147,3 +154,1 @@\n-  u4 lost = _lost_samples_due_to_queue_full;\n-  _lost_samples_due_to_queue_full = 0;\n-  return lost;\n+  return AtomicAccess::xchg(&_lost_samples_due_to_queue_full, (u4)0);\n@@ -157,1 +162,1 @@\n-  _head = 0;\n+  AtomicAccess::release_store(&_head, (u4)0);\n@@ -165,2 +170,3 @@\n-  if (_capacity < CPU_TIME_QUEUE_MAX_CAPACITY) {\n-    float ratio = (float)lost_samples_due_to_queue_full \/ (float)_capacity;\n+  u4 capacity = AtomicAccess::load(&_capacity);\n+  if (capacity < CPU_TIME_QUEUE_MAX_CAPACITY) {\n+    float ratio = (float)lost_samples_due_to_queue_full \/ (float)capacity;\n@@ -178,1 +184,1 @@\n-      u4 new_capacity = MIN2(CPU_TIME_QUEUE_MAX_CAPACITY, _capacity * factor);\n+      u4 new_capacity = MIN2(CPU_TIME_QUEUE_MAX_CAPACITY, capacity * factor);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -46,7 +46,0 @@\n-\/\/ The lock in question is the tri-state CPU time JFR lock in JfrThreadLocal\n-\/\/ This allows us to skip most of the atomic accesses and memory barriers,\n-\/\/ holding a lock acts as a memory barrier\n-\/\/ Only the _lost_samples property is atomic, as it can be accessed even after\n-\/\/ acquiring the lock failed.\n-\/\/ Important to note is that the queue is also only accessed under lock in signal\n-\/\/ handlers.\n@@ -55,0 +48,4 @@\n+  \/\/ the default queue capacity, scaled if the sampling period is smaller than 10ms\n+  \/\/ when the thread is started\n+  static const u4 CPU_TIME_QUEUE_CAPACITY = 500;\n+\n@@ -56,1 +53,1 @@\n-  u4 _capacity;\n+  volatile u4 _capacity;\n@@ -58,1 +55,1 @@\n-  u4 _head;\n+  volatile u4 _head;\n@@ -60,1 +57,0 @@\n-  \/\/ the only property accessible without a lock\n@@ -62,2 +58,1 @@\n-\n-  u4 _lost_samples_due_to_queue_full;\n+  volatile u4 _lost_samples_due_to_queue_full;\n@@ -90,1 +85,0 @@\n-  \/\/ the only method callable without holding a lock\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"}]}