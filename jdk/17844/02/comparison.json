{"files":[{"patch":"@@ -35,0 +35,7 @@\n+  nonstatic_field(Generation,                        _reserved,              MemRegion)                     \\\n+  nonstatic_field(Generation,                        _virtual_space,         VirtualSpace)                  \\\n+  nonstatic_field(Generation,                        _stat_record,           Generation::StatRecord)        \\\n+                                                                                                            \\\n+  nonstatic_field(Generation::StatRecord,            invocations,            int)                           \\\n+  nonstatic_field(Generation::StatRecord,            accumulated_time,       elapsedTimer)                  \\\n+                                                                                                            \\\n@@ -64,0 +71,2 @@\n+  declare_toplevel_type(Generation)                                           \\\n+  declare_toplevel_type(Generation::StatRecord)                               \\\n@@ -76,1 +85,3 @@\n-                                  declare_constant_with_value)\n+                                  declare_constant_with_value)                \\\n+  declare_constant(Generation::LogOfGenGrain)                                 \\\n+  declare_constant(Generation::GenGrain)\n","filename":"src\/hotspot\/share\/gc\/serial\/vmStructs_serial.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -104,7 +104,0 @@\n-  nonstatic_field(Generation,                  _reserved,                                     MemRegion)                             \\\n-  nonstatic_field(Generation,                  _virtual_space,                                VirtualSpace)                          \\\n-  nonstatic_field(Generation,                  _stat_record,                                  Generation::StatRecord)                \\\n-                                                                                                                                     \\\n-  nonstatic_field(Generation::StatRecord,      invocations,                                   int)                                   \\\n-  nonstatic_field(Generation::StatRecord,      accumulated_time,                              elapsedTimer)                          \\\n-                                                                                                                                     \\\n@@ -145,1 +138,0 @@\n-  declare_toplevel_type(Generation)                                       \\\n@@ -158,1 +150,0 @@\n-  declare_toplevel_type(Generation::StatRecord)                           \\\n@@ -215,3 +206,0 @@\n-                                                                            \\\n-  declare_constant(Generation::LogOfGenGrain)                               \\\n-  declare_constant(Generation::GenGrain)                                    \\\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1082,12 +1082,6 @@\n-                          for (int i = 0; i < heap.nGens(); i++) {\n-                            if (heap.getGen(i).isIn(handle)) {\n-                              if (i == 0) {\n-                                anno = \"NewGen \";\n-                              } else if (i == 1) {\n-                                anno = \"OldGen \";\n-                              } else {\n-                                anno = \"Gen \" + i + \" \";\n-                              }\n-                              bad = false;\n-                              break;\n-                            }\n+                          if (heap.youngGen().isIn(handle)) {\n+                            anno = \"NewGen \";\n+                            bad = false;\n+                          } else if (heap.oldGen().isIn(handle)) {\n+                            anno = \"OldGen \";\n+                            bad = false;\n@@ -1095,1 +1089,0 @@\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HSDB.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -87,6 +87,6 @@\n-  public void spaceIterate(SpaceClosure blk, boolean usedOnly) {\n-    blk.doSpace(eden());\n-    blk.doSpace(from());\n-    if (!usedOnly) {\n-      blk.doSpace(to());\n-    }\n+  \/* Returns \"TRUE\" iff \"p\" points into an allocated object in young\n+     generation. *\/\n+  public boolean isIn(Address p) {\n+    return eden().contains(p)\n+        || from().contains(p)\n+        || to().contains(p);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/serial\/DefNewGeneration.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.gc.serial;\n+\n+import java.io.*;\n+import java.util.*;\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.gc.shared.*;\n+import sun.jvm.hotspot.memory.*;\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.types.*;\n+import sun.jvm.hotspot.utilities.Observable;\n+import sun.jvm.hotspot.utilities.Observer;\n+\n+\/** <P> The (supported) Generation hierarchy currently looks like this: <\/P>\n+\n+    <ul>\n+    <li> Generation\n+      <ul>\n+      <li> TenuredGeneration\n+      <li> DefNewGeneration\n+      <\/ul>\n+    <\/ul>\n+*\/\n+\n+\n+public abstract class Generation extends VMObject {\n+  private static long          reservedFieldOffset;\n+  private static long          virtualSpaceFieldOffset;\n+  protected static final int  K = 1024;\n+  \/\/ Fields for class StatRecord\n+  private static Field         statRecordField;\n+  private static CIntegerField invocationField;\n+\n+  static {\n+    VM.registerVMInitializedObserver(new Observer() {\n+        public void update(Observable o, Object data) {\n+          initialize(VM.getVM().getTypeDataBase());\n+        }\n+      });\n+  }\n+\n+  private static synchronized void initialize(TypeDataBase db) {\n+    Type type = db.lookupType(\"Generation\");\n+\n+    reservedFieldOffset     = type.getField(\"_reserved\").getOffset();\n+    virtualSpaceFieldOffset = type.getField(\"_virtual_space\").getOffset();\n+    \/\/ StatRecord\n+    statRecordField         = type.getField(\"_stat_record\");\n+    type                    = db.lookupType(\"Generation::StatRecord\");\n+    invocationField         = type.getCIntegerField(\"invocations\");\n+  }\n+\n+  public Generation(Address addr) {\n+    super(addr);\n+  }\n+\n+  public int invocations() {\n+    return getStatRecord().getInvocations();\n+  }\n+\n+  \/** The maximum number of object bytes the generation can currently\n+      hold. *\/\n+  public abstract long capacity();\n+\n+  \/** The number of used bytes in the gen. *\/\n+  public abstract long used();\n+\n+  \/** The number of free bytes in the gen. *\/\n+  public abstract long free();\n+\n+  \/** The largest number of contiguous free words in the generation,\n+      including expansion. (VM's version assumes it is called at a\n+      safepoint.)  *\/\n+  public abstract long contiguousAvailable();\n+\n+  public MemRegion reserved() {\n+    return new MemRegion(addr.addOffsetTo(reservedFieldOffset));\n+  }\n+\n+  \/** Returns a region guaranteed to contain all the objects in the\n+      generation. *\/\n+  public MemRegion usedRegion() {\n+    return reserved();\n+  }\n+\n+  \/** Returns \"TRUE\" iff \"p\" points into the reserved area of the\n+     generation. *\/\n+  public boolean isInReserved(Address p) {\n+    return reserved().contains(p);\n+  }\n+\n+  protected VirtualSpace virtualSpace() {\n+    return VMObjectFactory.newObject(VirtualSpace.class, addr.addOffsetTo(virtualSpaceFieldOffset));\n+  }\n+\n+  public abstract String name();\n+\n+  \/** Iteration - do not use for time critical operations *\/\n+  public abstract void liveRegionsIterate(LiveRegionsClosure closure);\n+\n+  public void print() { printOn(System.out); }\n+  public abstract void printOn(PrintStream tty);\n+\n+  public static class StatRecord extends VMObject {\n+    public StatRecord(Address addr) {\n+      super(addr);\n+    }\n+\n+    public int getInvocations() {\n+      return (int) invocationField.getValue(addr);\n+    }\n+\n+  }\n+\n+  private StatRecord getStatRecord() {\n+    return VMObjectFactory.newObject(StatRecord.class, addr.addOffsetTo(statRecordField.getOffset()));\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/serial\/Generation.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import sun.jvm.hotspot.memory.MemRegion;\n@@ -67,2 +68,2 @@\n-  public int nGens() {\n-    return 2; \/\/ Young + Old\n+  public DefNewGeneration youngGen() {\n+    return VMObjectFactory.newObject(DefNewGeneration.class, youngGenField.getValue(addr));\n@@ -71,15 +72,2 @@\n-  public Generation getGen(int i) {\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that((i == 0) || (i == 1), \"Index \" + i +\n-                  \" out of range (should be 0 or 1)\");\n-    }\n-\n-    switch (i) {\n-    case 0:\n-      return genFactory.newObject(youngGenField.getValue(addr));\n-    case 1:\n-      return genFactory.newObject(oldGenField.getValue(addr));\n-    default:\n-      \/\/ no generation for i, and assertions disabled.\n-      return null;\n-    }\n+  public TenuredGeneration oldGen() {\n+    return VMObjectFactory.newObject(TenuredGeneration.class, oldGenField.getValue(addr));\n@@ -89,8 +77,1 @@\n-    for (int i = 0; i < nGens(); i++) {\n-      Generation gen = getGen(i);\n-      if (gen.isIn(a)) {\n-        return true;\n-      }\n-    }\n-\n-    return false;\n+    return youngGen().isIn(a) || oldGen().isIn(a);\n@@ -101,3 +82,2 @@\n-    for (int i = 0; i < nGens(); i++) {\n-      capacity += getGen(i).capacity();\n-    }\n+    capacity += youngGen().capacity();\n+    capacity += oldGen().capacity();\n@@ -109,3 +89,2 @@\n-    for (int i = 0; i < nGens(); i++) {\n-      used += getGen(i).used();\n-    }\n+    used += youngGen().used();\n+    used += oldGen().used();\n@@ -116,5 +95,2 @@\n-    \/\/ Run through all generations, obtaining bottom-top pairs.\n-    for (int i = 0; i < nGens(); i++) {\n-      Generation gen = getGen(i);\n-      gen.liveRegionsIterate(closure);\n-    }\n+    youngGen().liveRegionsIterate(closure);\n+    oldGen().liveRegionsIterate(closure);\n@@ -124,6 +100,9 @@\n-    for (int i = 0; i < nGens(); i++) {\n-      tty.print(\"Gen \" + i + \": \");\n-      getGen(i).printOn(tty);\n-      tty.println(\"Invocations: \" + getGen(i).invocations());\n-      tty.println();\n-    }\n+    tty.println(\"SerialHeap:\");\n+\n+    tty.println(\"Young Generation - Invocations: \" + youngGen().invocations());\n+    youngGen().printOn(tty);\n+    tty.println();\n+\n+    tty.println(\"Old Generation - Invocations: \" + oldGen().invocations());\n+    oldGen().printOn(tty);\n+    tty.println();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/serial\/SerialHeap.java","additions":21,"deletions":42,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -77,4 +77,0 @@\n-  public void spaceIterate(SpaceClosure blk, boolean usedOnly) {\n-    blk.doSpace(theSpace());\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/serial\/TenuredGeneration.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,154 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.gc.shared;\n-\n-import java.io.*;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.memory.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-\/** <P> The (supported) Generation hierarchy currently looks like this: <\/P>\n-\n-    <ul>\n-    <li> Generation\n-      <ul>\n-      <li> TenuredGeneration\n-      <li> DefNewGeneration\n-      <\/ul>\n-    <\/ul>\n-*\/\n-\n-\n-public abstract class Generation extends VMObject {\n-  private static long          reservedFieldOffset;\n-  private static long          virtualSpaceFieldOffset;\n-  protected static final int  K = 1024;\n-  \/\/ Fields for class StatRecord\n-  private static Field         statRecordField;\n-  private static CIntegerField invocationField;\n-\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    Type type = db.lookupType(\"Generation\");\n-\n-    reservedFieldOffset     = type.getField(\"_reserved\").getOffset();\n-    virtualSpaceFieldOffset = type.getField(\"_virtual_space\").getOffset();\n-    \/\/ StatRecord\n-    statRecordField         = type.getField(\"_stat_record\");\n-    type                    = db.lookupType(\"Generation::StatRecord\");\n-    invocationField         = type.getCIntegerField(\"invocations\");\n-  }\n-\n-  public Generation(Address addr) {\n-    super(addr);\n-  }\n-\n-  public int invocations() {\n-    return getStatRecord().getInvocations();\n-  }\n-\n-  \/** The maximum number of object bytes the generation can currently\n-      hold. *\/\n-  public abstract long capacity();\n-\n-  \/** The number of used bytes in the gen. *\/\n-  public abstract long used();\n-\n-  \/** The number of free bytes in the gen. *\/\n-  public abstract long free();\n-\n-  \/** The largest number of contiguous free words in the generation,\n-      including expansion. (VM's version assumes it is called at a\n-      safepoint.)  *\/\n-  public abstract long contiguousAvailable();\n-\n-  public MemRegion reserved() {\n-    return new MemRegion(addr.addOffsetTo(reservedFieldOffset));\n-  }\n-\n-  \/** Returns a region guaranteed to contain all the objects in the\n-      generation. *\/\n-  public MemRegion usedRegion() {\n-    return reserved();\n-  }\n-\n-  \/* Returns \"TRUE\" iff \"p\" points into an allocated object in the\n-     generation. *\/\n-  public boolean isIn(Address p) {\n-    GenerationIsInClosure blk = new GenerationIsInClosure(p);\n-    spaceIterate(blk);\n-    return (blk.space() != null);\n-  }\n-\n-  \/** Returns \"TRUE\" iff \"p\" points into the reserved area of the\n-     generation. *\/\n-  public boolean isInReserved(Address p) {\n-    return reserved().contains(p);\n-  }\n-\n-  protected VirtualSpace virtualSpace() {\n-    return VMObjectFactory.newObject(VirtualSpace.class, addr.addOffsetTo(virtualSpaceFieldOffset));\n-  }\n-\n-  public abstract String name();\n-\n-  \/** Equivalent to spaceIterate(blk, false) *\/\n-  public void spaceIterate(SpaceClosure blk) {\n-    spaceIterate(blk, false);\n-  }\n-\n-  \/** Iteration - do not use for time critical operations *\/\n-  public abstract void spaceIterate(SpaceClosure blk, boolean usedOnly);\n-  public abstract void liveRegionsIterate(LiveRegionsClosure closure);\n-\n-  public void print() { printOn(System.out); }\n-  public abstract void printOn(PrintStream tty);\n-\n-  public static class StatRecord extends VMObject {\n-    public StatRecord(Address addr) {\n-      super(addr);\n-    }\n-\n-    public int getInvocations() {\n-      return (int) invocationField.getValue(addr);\n-    }\n-\n-  }\n-\n-  private StatRecord getStatRecord() {\n-    return VMObjectFactory.newObject(StatRecord.class, addr.addOffsetTo(statRecordField.getOffset()));\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shared\/Generation.java","additions":0,"deletions":154,"binary":false,"changes":154,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.gc.shared;\n-\n-import sun.jvm.hotspot.debugger.*;\n-\n-\/** Should only be used once *\/\n-\n-class GenerationIsInClosure implements SpaceClosure {\n-  private Address p;\n-  private Space sp;\n-\n-  GenerationIsInClosure(Address p) {\n-    this.p = p;\n-  }\n-\n-  public void doSpace(Space s) {\n-    if (s.contains(p)) {\n-      sp = s;\n-    }\n-  }\n-\n-  Space space() {\n-    return sp;\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shared\/GenerationIsInClosure.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -98,21 +98,24 @@\n-         for (int n = 0; n < sh.nGens(); n++) {\n-            Generation gen = sh.getGen(n);\n-            if (gen instanceof DefNewGeneration) {\n-               System.out.println(\"New Generation (Eden + 1 Survivor Space):\");\n-               printGen(gen);\n-\n-               ContiguousSpace eden = ((DefNewGeneration)gen).eden();\n-               System.out.println(\"Eden Space:\");\n-               printSpace(eden);\n-\n-               ContiguousSpace from = ((DefNewGeneration)gen).from();\n-               System.out.println(\"From Space:\");\n-               printSpace(from);\n-\n-               ContiguousSpace to = ((DefNewGeneration)gen).to();\n-               System.out.println(\"To Space:\");\n-               printSpace(to);\n-            } else {\n-               System.out.println(gen.name() + \":\");\n-               printGen(gen);\n-            }\n+         {\n+           \/\/ youngGen\n+           DefNewGeneration youngGen = sh.youngGen();\n+\n+           System.out.println(\"New Generation (Eden + 1 Survivor Space):\");\n+           printGen(youngGen);\n+\n+           ContiguousSpace eden = youngGen.eden();\n+           System.out.println(\"Eden Space:\");\n+           printSpace(eden);\n+\n+           ContiguousSpace from = youngGen.from();\n+           System.out.println(\"From Space:\");\n+           printSpace(from);\n+\n+           ContiguousSpace to = youngGen.to();\n+           System.out.println(\"To Space:\");\n+           printSpace(to);\n+         }\n+         {\n+           \/\/ oldGen\n+           TenuredGeneration oldGen = sh.oldGen();\n+           System.out.println(oldGen.name() + \":\");\n+           printGen(oldGen);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/HeapSummary.java","additions":24,"deletions":21,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -109,6 +109,4 @@\n-        for (int i = 0; i < sh.nGens(); i++) {\n-          Generation g = sh.getGen(i);\n-          if (g.isIn(a)) {\n-            loc.gen = g;\n-            break;\n-          }\n+        if (sh.youngGen().isIn(a)) {\n+          loc.gen = sh.youngGen();\n+        } else if (sh.oldGen().isIn(a)) {\n+          loc.gen = sh.oldGen();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/PointerFinder.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-    return ((gen != null) && (gen.equals(((SerialHeap)heap).getGen(0))));\n+    return ((gen != null) && (gen.equals(((SerialHeap)heap).youngGen())));\n@@ -120,1 +120,1 @@\n-    return ((gen != null) && (gen.equals(((SerialHeap)heap).getGen(1))));\n+    return ((gen != null) && (gen.equals(((SerialHeap)heap).oldGen())));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/PointerLocation.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,2 @@\n-            expStrings.add(\"Gen 1:   old\");\n+            expStrings.add(\"SerialHeap\");\n+            expStrings.add(\"eden\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestUniverse.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}