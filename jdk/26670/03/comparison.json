{"files":[{"patch":"@@ -3162,1 +3162,1 @@\n-  collection_set()->prepare_groups_for_scan();\n+  collection_set()->prepare_for_scan();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-uint G1CollectionSet::selected_groups_cur_length() const {\n+uint G1CollectionSet::groups_cur_length() const {\n@@ -43,1 +43,1 @@\n-  return _collection_set_groups.length();\n+  return _groups.length();\n@@ -46,2 +46,2 @@\n-uint G1CollectionSet::collection_groups_increment_length() const {\n-  return selected_groups_cur_length() - _selected_groups_inc_part_start;\n+uint G1CollectionSet::groups_increment_length() const {\n+  return groups_cur_length() - _groups_inc_part_start;\n@@ -62,5 +62,4 @@\n-  _collection_set_regions(nullptr),\n-  _collection_set_cur_length(0),\n-  _collection_set_max_length(0),\n-  _collection_set_groups(),\n-  _selected_groups_inc_part_start(0),\n+  _regions(nullptr),\n+  _regions_max_length(0),\n+  _regions_cur_length(0),\n+  _groups(),\n@@ -71,2 +70,3 @@\n-  _inc_build_state(Inactive),\n-  _inc_part_start(0) {\n+  _inc_build_state(CSetBuildType::Inactive),\n+  _regions_inc_part_start(0),\n+  _groups_inc_part_start(0) {\n@@ -76,1 +76,1 @@\n-  FREE_C_HEAP_ARRAY(uint, _collection_set_regions);\n+  FREE_C_HEAP_ARRAY(uint, _regions);\n@@ -87,2 +87,2 @@\n-  assert((size_t)young_region_length() == _collection_set_cur_length,\n-         \"Young region length %u should match collection set length %u\", young_region_length(), _collection_set_cur_length);\n+  assert((size_t)young_region_length() == _regions_cur_length,\n+         \"Young region length %u should match collection set length %u\", young_region_length(), _regions_cur_length);\n@@ -96,3 +96,3 @@\n-  guarantee(_collection_set_regions == nullptr, \"Must only initialize once.\");\n-  _collection_set_max_length = max_region_length;\n-  _collection_set_regions = NEW_C_HEAP_ARRAY(uint, max_region_length, mtGC);\n+  guarantee(_regions == nullptr, \"Must only initialize once.\");\n+  _regions_max_length = max_region_length;\n+  _regions = NEW_C_HEAP_ARRAY(uint, max_region_length, mtGC);\n@@ -108,2 +108,2 @@\n-void G1CollectionSet::prepare_groups_for_scan () {\n-  collection_set_groups()->prepare_for_scan();\n+void G1CollectionSet::prepare_for_scan () {\n+  groups()->prepare_for_scan();\n@@ -115,1 +115,1 @@\n-  assert(_inc_build_state == Active,\n+  assert(_inc_build_state == CSetBuildType::Active,\n@@ -124,2 +124,2 @@\n-  assert(_collection_set_cur_length < _collection_set_max_length, \"Collection set now larger than maximum size.\");\n-  _collection_set_regions[_collection_set_cur_length++] = hr->hrm_index();\n+  assert(_regions_cur_length < _regions_max_length, \"Collection set now larger than maximum size.\");\n+  _regions[_regions_cur_length++] = hr->hrm_index();\n@@ -132,2 +132,2 @@\n-  assert(_collection_set_cur_length == 0, \"Collection set must be empty before starting a new collection set.\");\n-  assert(selected_groups_cur_length() == 0, \"Collection set groups must be empty before starting a new collection set.\");\n+  assert(_regions_cur_length == 0, \"Collection set must be empty before starting a new collection set.\");\n+  assert(groups_cur_length() == 0, \"Collection set groups must be empty before starting a new collection set.\");\n@@ -140,1 +140,1 @@\n-  assert(_inc_build_state == Inactive, \"Precondition\");\n+  assert(_inc_build_state == CSetBuildType::Inactive, \"Precondition\");\n@@ -142,2 +142,2 @@\n-  _inc_part_start = _collection_set_cur_length;\n-  _selected_groups_inc_part_start = selected_groups_cur_length();\n+  _regions_inc_part_start = _regions_cur_length;\n+  _groups_inc_part_start = groups_cur_length();\n@@ -149,1 +149,1 @@\n-  _inc_build_state = Inactive;\n+  _inc_build_state = CSetBuildType::Inactive;\n@@ -154,2 +154,2 @@\n-  _collection_set_cur_length = 0;\n-  _collection_set_groups.clear();\n+  _regions_cur_length = 0;\n+  _groups.clear();\n@@ -159,1 +159,1 @@\n-  size_t len = _collection_set_cur_length;\n+  size_t len = _regions_cur_length;\n@@ -163,1 +163,1 @@\n-    G1HeapRegion* r = _g1h->region_at(_collection_set_regions[i]);\n+    G1HeapRegion* r = _g1h->region_at(_regions[i]);\n@@ -190,1 +190,1 @@\n-  iterate_part_from(cl, hr_claimer, _inc_part_start, increment_length(), worker_id);\n+  iterate_part_from(cl, hr_claimer, _regions_inc_part_start, regions_cur_length(), worker_id);\n@@ -200,1 +200,1 @@\n-                                  &_collection_set_regions[offset],\n+                                  &_regions[offset],\n@@ -207,1 +207,1 @@\n-  assert(_inc_build_state == Active, \"Precondition\");\n+  assert(_inc_build_state == CSetBuildType::Active, \"Precondition\");\n@@ -213,3 +213,3 @@\n-  assert(_collection_set_cur_length < (UINT_MAX - 1),\n-         \"Collection set is too large with %u entries\", _collection_set_cur_length);\n-  hr->set_young_index_in_cset(_collection_set_cur_length + 1);\n+  assert(_regions_cur_length < (UINT_MAX - 1),\n+         \"Collection set is too large with %u entries\", _regions_cur_length);\n+  hr->set_young_index_in_cset(_regions_cur_length + 1);\n@@ -217,2 +217,2 @@\n-  assert(_collection_set_cur_length < _collection_set_max_length, \"Collection set larger than maximum allowed.\");\n-  _collection_set_regions[_collection_set_cur_length] = hr->hrm_index();\n+  assert(_regions_cur_length < _regions_max_length, \"Collection set larger than maximum allowed.\");\n+  _regions[_regions_cur_length] = hr->hrm_index();\n@@ -222,1 +222,1 @@\n-  _collection_set_cur_length++;\n+  _regions_cur_length++;\n@@ -304,1 +304,1 @@\n-  assert(_inc_build_state == Active, \"Precondition\");\n+  assert(_inc_build_state == CSetBuildType::Active, \"Precondition\");\n@@ -347,4 +347,0 @@\n-static int compare_region_idx(const uint a, const uint b) {\n-  return static_cast<int>(a-b);\n-}\n-\n@@ -629,1 +625,2 @@\n-  log_debug(gc, ergo, cset) (\"Completed with groups, selected %u\", num_regions_selected);\n+  log_debug(gc, ergo, cset)(\"Completed with groups, selected %u region in %u groups\",\n+                            num_regions_selected, num_groups_selected);\n@@ -638,1 +635,1 @@\n-uint G1CollectionSet::select_optional_collection_set_regions(double time_remaining_ms) {\n+uint G1CollectionSet::select_optional_groups(double time_remaining_ms) {\n@@ -673,1 +670,1 @@\n-  _collection_set_groups.append(gr);\n+  _groups.append(gr);\n@@ -683,2 +680,2 @@\n-  assert(_inc_part_start == 0, \"must be\");\n-  assert(_selected_groups_inc_part_start == 0, \"must be\");\n+  assert(_regions_inc_part_start == 0, \"must be\");\n+  assert(_groups_inc_part_start == 0, \"must be\");\n@@ -690,1 +687,0 @@\n-  QuickSort::sort(_collection_set_regions, _collection_set_cur_length, compare_region_idx);\n@@ -696,1 +692,1 @@\n-  uint num_regions_selected = select_optional_collection_set_regions(remaining_pause_time);\n+  uint num_regions_selected = select_optional_groups(remaining_pause_time);\n@@ -759,1 +755,1 @@\n-  G1VerifyYoungCSetIndicesClosure cl(_collection_set_cur_length);\n+  G1VerifyYoungCSetIndicesClosure cl(_regions_cur_length);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":50,"deletions":54,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -44,1 +44,2 @@\n-\/\/ The set of regions that are evacuated during an evacuation pause.\n+\/\/ The set of regions and candidate groups that were evacuated during an\n+\/\/ evacuation pause.\n@@ -46,2 +47,2 @@\n-\/\/ At the end of a collection, before freeing the collection set, this set\n-\/\/ contains all regions that were evacuated during this collection:\n+\/\/ At the end of a collection, before freeing it, this set contains all regions\n+\/\/ and collection set groups that were evacuated during this collection:\n@@ -53,4 +54,3 @@\n-\/\/ This set is built incrementally at mutator time as regions are retired, and\n-\/\/ if this had been a mixed gc, some additional (during gc) incrementally added\n-\/\/ old regions from the collection set candidates built during the concurrent\n-\/\/ cycle.\n+\/\/ This set is initially built at mutator time as regions are retired. If the\n+\/\/ collection is a mixed gc, it contains some additional (during the pause)\n+\/\/ incrementally added old regions from the collection set candidates.\n@@ -132,0 +132,1 @@\n+\/\/ Candidate groups are kept in sync with the contents of the collection set regions.\n@@ -140,2 +141,3 @@\n-  \/\/ All entries in _collection_set_regions below _collection_set_cur_length are\n-  \/\/ assumed to be part of the collection set.\n+  \/\/\n+  \/\/ All regions in _regions below _regions_cur_length are assumed to be part of the\n+  \/\/ collection set.\n@@ -143,5 +145,8 @@\n-  \/\/ concurrent readers. This means we are good with using storestore and loadload\n-  \/\/ barriers on the writer and reader respectively only.\n-  uint* _collection_set_regions;\n-  volatile uint _collection_set_cur_length;\n-  uint _collection_set_max_length;\n+  \/\/ concurrent readers. This means synchronization using storestore and loadload\n+  \/\/ barriers on the writer and reader respectively only are sufficient.\n+  \/\/\n+  \/\/ This corresponds to the regions referenced by the candidate groups further below.\n+  uint* _regions;\n+  uint _regions_max_length;\n+\n+  volatile uint _regions_cur_length;\n@@ -150,1 +155,1 @@\n-  G1CSetCandidateGroupList _collection_set_groups;\n+  G1CSetCandidateGroupList _groups;\n@@ -152,2 +157,1 @@\n-  uint selected_groups_cur_length() const;\n-  uint _selected_groups_inc_part_start;\n+  uint groups_cur_length() const;\n@@ -160,1 +164,2 @@\n-  \/\/ will be collected only if there is enough time. We call these optional (old) regions.\n+  \/\/ will be collected only if there is enough time. We call these optional (old)\n+  \/\/ groups. Regions are reachable via this list as well.\n@@ -163,1 +168,1 @@\n-  enum CSetBuildType {\n+  enum class CSetBuildType {\n@@ -169,1 +174,4 @@\n-  size_t _inc_part_start;\n+  \/\/ Index into the _regions indicating the start of the current collection set increment.\n+  size_t _regions_inc_part_start;\n+  \/\/ Index into the _groups indicating the start of the current collection set increment.\n+  uint _groups_inc_part_start;\n@@ -176,1 +184,0 @@\n-  \/\/ Update the incremental collection set information when adding a region.\n@@ -179,1 +186,1 @@\n-  \/\/ Add the given old region to the head of the current collection set.\n+  \/\/ Add the given old region to the current collection set.\n@@ -192,4 +199,4 @@\n-  \/\/ Select regions for evacuation from the optional candidates given the remaining time\n-  \/\/ and return the number  of actually selected regions.\n-  uint select_optional_collection_set_regions(double time_remaining_ms);\n-  double select_candidates_from_optional_groups(double time_remaining_ms, uint& num_regions_selected);\n+  \/\/ Select groups for evacuation from the optional candidates given the remaining time\n+  \/\/ and return the number of actually selected regions.\n+  uint select_optional_groups(double time_remaining_ms);\n+  double select_candidates_from_optional_groups(double time_remaining_ms, uint& num_groups_selected);\n@@ -199,1 +206,1 @@\n-  \/\/ will take.\n+  \/\/ will take. Returns the time remaining from the given target pause time.\n@@ -221,0 +228,1 @@\n+  \/\/ Drop all collection set candidates (only the candidates).\n@@ -226,2 +234,2 @@\n-  G1CSetCandidateGroupList* collection_set_groups() { return &_collection_set_groups; }\n-  const G1CSetCandidateGroupList* collection_set_groups() const { return &_collection_set_groups; }\n+  G1CSetCandidateGroupList* groups() { return &_groups; }\n+  const G1CSetCandidateGroupList* groups() const { return &_groups; }\n@@ -229,1 +237,1 @@\n-  void prepare_groups_for_scan();\n+  void prepare_for_scan();\n@@ -234,2 +242,3 @@\n-  uint region_length() const       { return young_region_length() +\n-                                            initial_old_region_length(); }\n+  \/\/ Total length of the initial collection set in regions.\n+  uint initial_region_length() const { return young_region_length() +\n+                                              initial_old_region_length(); }\n@@ -239,1 +248,1 @@\n-  uint eden_region_length() const     { return _eden_region_length; }\n+  uint eden_region_length() const { return _eden_region_length; }\n@@ -241,1 +250,1 @@\n-  uint initial_old_region_length() const      { return _initial_old_region_length; }\n+  uint initial_old_region_length() const { return _initial_old_region_length; }\n@@ -266,1 +275,1 @@\n-  size_t increment_length() const { return _collection_set_cur_length - _inc_part_start; }\n+  size_t regions_cur_length() const { return _regions_cur_length - _regions_inc_part_start; }\n@@ -268,1 +277,1 @@\n-  size_t cur_length() const { return _collection_set_cur_length; }\n+  size_t cur_length() const { return _regions_cur_length; }\n@@ -270,1 +279,1 @@\n-  uint collection_groups_increment_length() const;\n+  uint groups_increment_length() const;\n@@ -273,1 +282,1 @@\n-  \/\/ the given G1HeapRegionClosure on all of them.\n+  \/\/ the given G1HeapRegionClosure on all of the regions.\n@@ -281,1 +290,1 @@\n-  \/\/ Finalize the initial collection set consisting of all young regions potentially a\n+  \/\/ Finalize the initial collection set consisting of all young regions and potentially a\n@@ -285,0 +294,1 @@\n+  \/\/ Returns whether there still were some optional regions.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":49,"deletions":39,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-  uint length = collection_groups_increment_length();\n-  uint offset =  _selected_groups_inc_part_start;\n+  uint length = groups_increment_length();\n+  uint offset =  _groups_inc_part_start;\n@@ -44,1 +44,1 @@\n-    G1HeapRegionRemSet::iterate_for_merge(collection_set_groups()->at(offset + cur_pos)->card_set(), cl);\n+    G1HeapRegionRemSet::iterate_for_merge(groups()->at(offset + cur_pos)->card_set(), cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1429,1 +1429,1 @@\n-  size_t const increment_length = g1h->collection_set()->increment_length();\n+  size_t const increment_length = g1h->collection_set()->regions_cur_length();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-  evacuation_info->set_collection_set_regions(collection_set()->region_length() +\n+  evacuation_info->set_collection_set_regions(collection_set()->initial_region_length() +\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -890,1 +890,1 @@\n-  double worker_cost() const override { return G1CollectedHeap::heap()->collection_set()->region_length(); }\n+  double worker_cost() const override { return G1CollectedHeap::heap()->collection_set()->initial_region_length(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}