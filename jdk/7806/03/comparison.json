{"files":[{"patch":"@@ -998,0 +998,6 @@\n+  \/\/ Check for special case where there is a type conversion between different data size.\n+  int vectsize = max_vector_size_in_ud_chain(s);\n+  if (vectsize < Matcher::max_vector_size(btype)) {\n+    vw = MIN2(vectsize * type2aelembytes(btype), vw);\n+  }\n+\n@@ -1186,1 +1192,3 @@\n-  if (Matcher::max_vector_size(bt1) < 2) {\n+  BasicType longer_bt = longer_type_for_conversion(s1);\n+  if (Matcher::max_vector_size(bt1) < 2 ||\n+      (longer_bt != T_ILLEGAL && Matcher::max_vector_size(longer_bt) < 2)) {\n@@ -1431,2 +1439,1 @@\n-  int align = alignment(s1);\n-  NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"SuperWord::follow_use_defs: s1 %d, align %d\", s1->_idx, align);)\n+  NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"SuperWord::follow_use_defs: s1 %d, align %d\", s1->_idx, alignment(s1));)\n@@ -1437,0 +1444,1 @@\n+    int align = alignment(s1);\n@@ -1441,0 +1449,4 @@\n+    if (longer_type_for_conversion(s1) != T_ILLEGAL ||\n+        longer_type_for_conversion(t1) != T_ILLEGAL) {\n+      align = align \/ data_size(s1) * data_size(t1);\n+    }\n@@ -1484,1 +1496,6 @@\n-      if (stmts_can_pack(t1, t2, align)) {\n+      int adjusted_align = alignment(s1);\n+      if (longer_type_for_conversion(s1) != T_ILLEGAL ||\n+          longer_type_for_conversion(t1) != T_ILLEGAL) {\n+        adjusted_align = adjusted_align \/ data_size(s1) * data_size(t1);\n+      }\n+      if (stmts_can_pack(t1, t2, adjusted_align)) {\n@@ -1490,0 +1507,1 @@\n+          align = adjusted_align;\n@@ -1682,2 +1700,1 @@\n-      BasicType bt = velt_basic_type(p1->at(0));\n-      uint max_vlen = Matcher::max_vector_size(bt); \/\/ Max elements in vector\n+      uint max_vlen = max_vector_size_in_ud_chain(p1->at(0)); \/\/ Max elements in vector\n@@ -2006,0 +2023,2 @@\n+    } else if (VectorNode::is_convert_opcode(opc)) {\n+      retValue = VectorCastNode::implemented(opc, size, velt_basic_type(p0->in(1)), velt_basic_type(p0));\n@@ -2572,2 +2591,1 @@\n-      } else if (opc == Op_ConvI2F || opc == Op_ConvL2D ||\n-                 opc == Op_ConvF2I || opc == Op_ConvD2L) {\n+      } else if (VectorNode::is_convert_opcode(opc)) {\n@@ -2576,1 +2594,0 @@\n-        int vopc = VectorNode::opcode(opc, bt);\n@@ -2578,0 +2595,1 @@\n+        int vopc = VectorCastNode::opcode(in->bottom_type()->is_vect()->element_basic_type());\n@@ -3051,1 +3069,0 @@\n-\n@@ -3054,0 +3071,18 @@\n+\n+  if (longer_type_for_conversion(use) != T_ILLEGAL) {\n+    \/\/ type conversion takes a type of a kind of size and produces a type of\n+    \/\/ another size - hence the special checks on alignment and size.\n+    for (uint i = 0; i < u_pk->size(); i++) {\n+      Node* ui = u_pk->at(i);\n+      Node* di = d_pk->at(i);\n+      if (ui->in(u_idx) != di) {\n+        return false;\n+      }\n+      if (alignment(ui) \/ type2aelembytes(velt_basic_type(ui)) !=\n+          alignment(di) \/ type2aelembytes(velt_basic_type(di))) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n@@ -3286,0 +3321,57 @@\n+BasicType SuperWord::longer_type_for_conversion(Node* n) {\n+  int opcode = n->Opcode();\n+  switch (opcode) {\n+    case Op_ConvD2I:\n+    case Op_ConvI2D:\n+    case Op_ConvF2D:\n+    case Op_ConvD2F: return T_DOUBLE;\n+    case Op_ConvF2L:\n+    case Op_ConvL2F:\n+    case Op_ConvL2I:\n+    case Op_ConvI2L: return T_LONG;\n+    case Op_ConvI2F: {\n+      BasicType src_t = velt_basic_type(n->in(1));\n+      if (src_t == T_BYTE || src_t == T_SHORT) {\n+        return T_FLOAT;\n+      }\n+      return T_ILLEGAL;\n+    }\n+    case Op_ConvF2I: {\n+      BasicType dst_t = velt_basic_type(n);\n+      if (dst_t == T_BYTE || dst_t == T_SHORT) {\n+        return T_FLOAT;\n+      }\n+      return T_ILLEGAL;\n+    }\n+  }\n+  return T_ILLEGAL;\n+}\n+\n+int SuperWord::max_vector_size_in_ud_chain(Node* n) {\n+  BasicType bt = velt_basic_type(n);\n+  BasicType vt = bt;\n+\n+  \/\/ find the longest type among def nodes.\n+  uint start, end;\n+  VectorNode::vector_operands(n, &start, &end);\n+  for (uint i = start; i < end; ++i) {\n+    Node* input = n->in(i);\n+    if (!in_bb(input)) continue;\n+    BasicType newt = longer_type_for_conversion(input);\n+    vt = (newt == T_ILLEGAL) ? vt : newt;\n+  }\n+\n+  \/\/ find the longest type among use nodes.\n+  for (uint i = 0; i < n->outcnt(); ++i) {\n+    Node* output = n->raw_out(i);\n+    if (!in_bb(output)) continue;\n+    BasicType newt = longer_type_for_conversion(output);\n+    vt = (newt == T_ILLEGAL) ? vt : newt;\n+  }\n+\n+  int max = Matcher::max_vector_size(vt);\n+  \/\/ If now there is no vectors for the longest type, the nodes with the longest\n+  \/\/ type in the def-use chain are not packed in SuperWord::stmts_can_pack.\n+  return max < 2 ? Matcher::max_vector_size(bt) : max;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":102,"deletions":10,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -572,0 +572,4 @@\n+  \/\/ Return the longer type for type-conversion node and return illegal type for other nodes.\n+  BasicType longer_type_for_conversion(Node* n);\n+  \/\/ Find the longest type in def-use chain for packed nodes, and then compute the max vector size.\n+  int max_vector_size_in_ud_chain(Node* n);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -240,9 +240,0 @@\n-  case Op_ConvI2F:\n-    return Op_VectorCastI2X;\n-  case Op_ConvL2D:\n-    return Op_VectorCastL2X;\n-  case Op_ConvF2I:\n-    return Op_VectorCastF2X;\n-  case Op_ConvD2L:\n-    return Op_VectorCastD2X;\n-\n@@ -414,0 +405,20 @@\n+bool VectorNode::is_convert_opcode(int opc) {\n+  switch (opc) {\n+    case Op_ConvI2F:\n+    case Op_ConvL2D:\n+    case Op_ConvF2I:\n+    case Op_ConvD2L:\n+    case Op_ConvI2D:\n+    case Op_ConvL2F:\n+    case Op_ConvL2I:\n+    case Op_ConvI2L:\n+    case Op_ConvF2L:\n+    case Op_ConvD2F:\n+    case Op_ConvF2D:\n+    case Op_ConvD2I:\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n@@ -1175,1 +1186,1 @@\n-      assert(false, \"unknown type: %s\", type2name(bt));\n+      assert(bt == T_CHAR || bt == T_BOOLEAN, \"unknown type: %s\", type2name(bt));\n@@ -1180,0 +1191,10 @@\n+bool VectorCastNode::implemented(int opc, uint vlen, BasicType src_type, BasicType dst_type) {\n+  if (is_java_primitive(dst_type) &&\n+      (vlen > 1) && is_power_of_2(vlen) &&\n+      Matcher::vector_size_supported(dst_type, vlen)) {\n+    int vopc = VectorCastNode::opcode(src_type);\n+    return vopc > 0 && Matcher::match_rule_supported_vector(vopc, vlen, dst_type);\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":31,"deletions":10,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+  static bool is_convert_opcode(int opc);\n@@ -1483,1 +1484,1 @@\n-  static bool implemented(BasicType bt, uint vlen);\n+  static bool implemented(int opc, uint vlen, BasicType src_type, BasicType dst_type);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,26 @@\n+  private static final byte[] bspecial = {\n+    0, 0x8, 0xF, 0x3F, 0x7C, 0x7F, (byte)0x80, (byte)0x81, (byte)0x8F,\n+    (byte)0xF3, (byte)0xF8, (byte)0xFF, (byte)0x38FF, (byte)0x3FFF,\n+    (byte)0xFFFF, (byte)Integer.MAX_VALUE, (byte)Integer.MIN_VALUE\n+  };\n+\n+  private static final double[] dspecial = {\n+    0.0,\n+    -0.0,\n+    Double.MAX_VALUE,\n+    Double.MIN_VALUE,\n+    -Double.MAX_VALUE,\n+    -Double.MIN_VALUE,\n+    Double.NaN,\n+    Double.POSITIVE_INFINITY,\n+    Double.NEGATIVE_INFINITY,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    Long.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    -Long.MIN_VALUE,\n+    -Long.MAX_VALUE\n+  };\n+\n@@ -78,0 +108,2 @@\n+      test_conv_b2d(a1, b1);\n+      test_conv_d2b(a1, b1);\n@@ -341,0 +373,35 @@\n+      for (int j = 0; j < bspecial.length; j++) {\n+        byte bytevalue = bspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = bytevalue;\n+        }\n+        test_conv_b2d(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_b2d: b1\", i, b1[i], (double)bytevalue);\n+        }\n+      }\n+      for (int j = 0; j < dspecial.length; j++) {\n+        double doubleValue = dspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = doubleValue;\n+        }\n+        test_conv_d2b(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_d2b: a1\", i, a1[i], (byte)(doubleValue));\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (byte)r.nextInt();\n+      }\n+      test_conv_b2d(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_b2d: b1\", i, b1[i], (double)a1[i]);\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextDouble();\n+      }\n+      test_conv_d2b(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2b: a1\", i, a1[i], (byte)b1[i]);\n+      }\n@@ -451,0 +518,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_b2d(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_b2d: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_d2b(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_d2b: \" + (end - start));\n@@ -560,0 +639,12 @@\n+  static void test_conv_b2d(byte[] a, double[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (double) a[i];\n+    }\n+  }\n+\n+  static void test_conv_d2b(byte[] a, double[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (byte) b[i];\n+    }\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestByteDoubleVect.java","additions":93,"deletions":2,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,26 @@\n+  private static final byte[] bspecial = {\n+    0, 0x8, 0xF, 0x3F, 0x7C, 0x7F, (byte)0x80, (byte)0x81, (byte)0x8F,\n+    (byte)0xF3, (byte)0xF8, (byte)0xFF, (byte)0x38FF, (byte)0x3FFF,\n+    (byte)0xFFFF, (byte)Integer.MAX_VALUE, (byte)Integer.MIN_VALUE\n+  };\n+\n+  private static final float[] fspecial = {\n+    0.0f,\n+    -0.0f,\n+    Float.MAX_VALUE,\n+    Float.MIN_VALUE,\n+    -Float.MAX_VALUE,\n+    -Float.MIN_VALUE,\n+    Float.NaN,\n+    Float.POSITIVE_INFINITY,\n+    Float.NEGATIVE_INFINITY,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    Long.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    -Long.MIN_VALUE,\n+    -Long.MAX_VALUE\n+  };\n+\n@@ -78,0 +108,2 @@\n+      test_conv_b2f(a1, b1);\n+      test_conv_f2b(a1, b1);\n@@ -341,0 +373,35 @@\n+      for (int j = 0; j < bspecial.length; j++) {\n+        byte byteValue = bspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = byteValue;\n+        }\n+        test_conv_b2f(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_b2f: b1\", i, b1[i], (float)(byteValue));\n+        }\n+      }\n+      for (int j = 0; j < fspecial.length; j++) {\n+        float floatValue = fspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = floatValue;\n+        }\n+        test_conv_f2b(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_f2b: a1\", i, a1[i], (byte)floatValue);\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (byte)r.nextInt();\n+      }\n+      test_conv_b2f(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_b2f: b1\", i, b1[i], (float)a1[i]);\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextFloat();\n+      }\n+      test_conv_f2b(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2b: a1\", i, a1[i], (byte)b1[i]);\n+      }\n@@ -451,0 +518,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_b2f(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_b2f: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_f2b(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_f2b: \" + (end - start));\n@@ -560,0 +639,12 @@\n+  static void test_conv_b2f(byte[] a, float[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (float) a[i];\n+    }\n+  }\n+\n+  static void test_conv_f2b(byte[] a, float[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (byte) b[i];\n+    }\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestByteFloatVect.java","additions":93,"deletions":2,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,18 @@\n+  private static final byte[] bspecial = {\n+    0, 0x8, 0xF, 0x3F, 0x7C, 0x7F, (byte)0x80, (byte)0x81, (byte)0x8F,\n+    (byte)0xF3, (byte)0xF8, (byte)0xFF, (byte)0x38FF, (byte)0x3FFF,\n+    (byte)0xFFFF, (byte)Integer.MAX_VALUE, (byte)Integer.MIN_VALUE\n+  };\n+\n+  private static final long[] lspecial = {\n+    0,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    Long.MIN_VALUE,\n+    -Long.MAX_VALUE,\n+    -Long.MIN_VALUE\n+  };\n+\n@@ -78,0 +100,2 @@\n+      test_conv_b2l(a1, b1);\n+      test_conv_l2b(a1, b1);\n@@ -341,0 +365,35 @@\n+      for (int j = 0; j < bspecial.length; j++) {\n+        byte bytevalue = bspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = bytevalue;\n+        }\n+        test_conv_b2l(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_b2l: b1\", i, b1[i], (long)bytevalue);\n+        }\n+      }\n+      for (int j = 0; j < lspecial.length; j++) {\n+        long longValue = lspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = longValue;\n+        }\n+        test_conv_l2b(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_l2b: a1\", i, a1[i], (byte)longValue);\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (byte)r.nextInt();\n+      }\n+      test_conv_b2l(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_b2l: b1\", i, b1[i], (long)a1[i]);\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextLong();\n+      }\n+      test_conv_l2b(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_l2b: a1\", i, a1[i], (byte)b1[i]);\n+      }\n@@ -451,0 +510,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_b2l(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_b2l: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_l2b(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_l2b: \" + (end - start));\n@@ -560,0 +631,12 @@\n+  static void test_conv_b2l(byte[] a, long[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (long) a[i];\n+    }\n+  }\n+\n+  static void test_conv_l2b(byte[] a, long[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (byte) b[i];\n+    }\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestByteLongVect.java","additions":85,"deletions":2,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,40 @@\n+  private static float[] fspecial = {\n+    0.0f,\n+    -0.0f,\n+    Float.MAX_VALUE,\n+    Float.MIN_VALUE,\n+    -Float.MAX_VALUE,\n+    -Float.MIN_VALUE,\n+    Float.NaN,\n+    Float.POSITIVE_INFINITY,\n+    Float.NEGATIVE_INFINITY,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    Long.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    -Long.MIN_VALUE,\n+    -Long.MAX_VALUE\n+  };\n+\n+  private static double[] dspecial = {\n+    0.0,\n+    -0.0,\n+    Double.MAX_VALUE,\n+    Double.MIN_VALUE,\n+    -Double.MAX_VALUE,\n+    -Double.MIN_VALUE,\n+    Double.NaN,\n+    Double.POSITIVE_INFINITY,\n+    Double.NEGATIVE_INFINITY,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    Long.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    -Long.MIN_VALUE,\n+    -Long.MAX_VALUE\n+  };\n+\n@@ -78,0 +122,2 @@\n+      test_conv_f2d(a1, b1);\n+      test_conv_d2f(a1, b1);\n@@ -341,0 +387,35 @@\n+      for (int j = 0; j < fspecial.length; j++) {\n+        float floatValue = fspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = floatValue;\n+        }\n+        test_conv_f2d(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_f2d: b1\", i, b1[i], (double)floatValue);\n+        }\n+      }\n+      for (int j = 0; j < dspecial.length; j++) {\n+        double doubleValue = dspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = doubleValue;\n+        }\n+        test_conv_d2f(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_d2f: a1\", i, a1[i], (float)(doubleValue));\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = r.nextFloat();\n+      }\n+      test_conv_f2d(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2d: b1\", i, b1[i], (double)a1[i]);\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextDouble();\n+      }\n+      test_conv_d2f(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2f: a1\", i, a1[i], (float)b1[i]);\n+      }\n@@ -451,0 +532,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_f2d(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_f2d: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_d2f(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_d2f: \" + (end - start));\n@@ -560,0 +653,12 @@\n+  static void test_conv_f2d(float[] a, double[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (double) a[i];\n+    }\n+  }\n+\n+  static void test_conv_d2f(float[] a, double[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      a[i] = (float) b[i];\n+    }\n+  }\n+\n@@ -561,1 +666,1 @@\n-    if (elem != val) {\n+    if (elem != val && !(Float.isNaN(elem) && Float.isNaN(val))) {\n@@ -568,1 +673,1 @@\n-    if (elem != val) {\n+    if (elem != val && !(Double.isNaN(elem) && Double.isNaN(val))) {\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestFloatDoubleVect.java","additions":109,"deletions":4,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,30 @@\n+  private static double[] dspecial = {\n+    1.0,\n+    -1.0,\n+    0.0,\n+    -0.0,\n+    Double.MAX_VALUE,\n+    Double.MIN_VALUE,\n+    -Double.MAX_VALUE,\n+    -Double.MIN_VALUE,\n+    Double.NaN,\n+    Double.POSITIVE_INFINITY,\n+    Double.NEGATIVE_INFINITY,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    Long.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    -Long.MIN_VALUE,\n+    -Long.MAX_VALUE\n+  };\n+\n+  private static int[] ispecial = {\n+    0,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE\n+  };\n+\n@@ -78,0 +112,2 @@\n+      test_conv_i2d(a1, b1);\n+      test_conv_d2i(a1, b1);\n@@ -341,1 +377,35 @@\n-\n+      for (int j = 0; j < ispecial.length; j++) {\n+        int intValue = ispecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = intValue;\n+        }\n+        test_conv_i2d(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_i2d: b1\", i, b1[i], (double)intValue);\n+        }\n+      }\n+      for (int j = 0; j < dspecial.length; j++) {\n+        double doubleValue = dspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = doubleValue;\n+        }\n+        test_conv_d2i(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_d2i: a1\", i, a1[i], (int)doubleValue);\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = r.nextInt();\n+      }\n+      test_conv_i2d(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_i2d: b1\", i, b1[i], (double)a1[i]);\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextDouble();\n+      }\n+      test_conv_d2i(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2i: a1\", i, a1[i], (int)b1[i]);\n+      }\n@@ -451,0 +521,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_i2d(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_i2d: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_d2i(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_d2i: \" + (end - start));\n@@ -559,0 +641,10 @@\n+  static void test_conv_i2d(int[] a, double[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (double) a[i];\n+    }\n+  }\n+  static void test_conv_d2i(int[] a, double[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (int)b[i];\n+    }\n+  }\n@@ -568,1 +660,1 @@\n-    if (elem != val) {\n+    if (elem != val && !(Double.isNaN(elem) && Double.isNaN(val))) {\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestIntDoubleVect.java","additions":96,"deletions":4,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,20 @@\n+  private static int[] ispecial = {\n+    0,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE\n+  };\n+\n+  private static long[] lspecial = {\n+    0,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    Long.MIN_VALUE,\n+    -Long.MAX_VALUE,\n+    -Long.MIN_VALUE\n+  };\n+\n@@ -78,0 +102,2 @@\n+      test_conv_i2l(a1, b1);\n+      test_conv_l2i(a1, b1);\n@@ -341,0 +367,35 @@\n+      for (int j = 0; j < ispecial.length; j++) {\n+        int intValue = ispecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = intValue;\n+        }\n+        test_conv_i2l(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_i2l: b1\", i, b1[i], (long)intValue);\n+        }\n+      }\n+      for (int j = 0; j < lspecial.length; j++) {\n+        long longValue = lspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = longValue;\n+        }\n+        test_conv_l2i(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_l2i: a1\", i, a1[i], (int)longValue);\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = r.nextInt();\n+      }\n+      test_conv_i2l(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_i2l: b1\", i, b1[i], (long)a1[i]);\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextLong();\n+      }\n+      test_conv_l2i(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_l2i: a1\", i, a1[i], (int)b1[i]);\n+      }\n@@ -451,0 +512,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_i2l(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_cp_unalnsrc: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_l2i(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_cp_unalnsrc: \" + (end - start));\n@@ -560,0 +633,11 @@\n+  static void test_conv_i2l(int[] a, long[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (long)a[i];\n+    }\n+  }\n+  static void test_conv_l2i(int[] a, long[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (int)b[i];\n+    }\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestIntLongVect.java","additions":86,"deletions":2,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,34 @@\n+  private static float[] fspecial = {\n+    1.0f,\n+    -1.0f,\n+    0.0f,\n+    -0.0f,\n+    Float.MAX_VALUE,\n+    Float.MIN_VALUE,\n+    -Float.MAX_VALUE,\n+    -Float.MIN_VALUE,\n+    Float.NaN,\n+    Float.POSITIVE_INFINITY,\n+    Float.NEGATIVE_INFINITY,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    Long.MIN_VALUE,\n+    -Long.MAX_VALUE,\n+    -Long.MIN_VALUE\n+  };\n+\n+  private static long[] lspecial = {\n+    0,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    Long.MIN_VALUE,\n+    -Long.MAX_VALUE,\n+    -Long.MIN_VALUE\n+  };\n+\n@@ -78,0 +116,2 @@\n+      test_conv_l2f(a1, b1);\n+      test_conv_f2l(a1, b1);\n@@ -341,0 +381,35 @@\n+      for (int j = 0; j < lspecial.length; j++) {\n+        long longValue = lspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = longValue;\n+        }\n+        test_conv_l2f(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_l2f: b1\", i, b1[i], (float)longValue);\n+        }\n+      }\n+      for (int j = 0; j < fspecial.length; j++) {\n+        float floatValue = fspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = floatValue;\n+        }\n+        test_conv_f2l(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_f2l: a1\", i, a1[i], (long)floatValue);\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = r.nextLong();\n+      }\n+      test_conv_l2f(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_l2f: b1\", i, b1[i], (float)a1[i]);\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextFloat();\n+      }\n+      test_conv_f2l(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2l: a1\", i, a1[i], (long)b1[i]);\n+      }\n@@ -451,0 +526,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_f2l(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_f2l: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_l2f(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_l2f: \" + (end - start));\n@@ -559,0 +646,10 @@\n+  static void test_conv_l2f(long[] a, float[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (float)a[i];\n+    }\n+  }\n+  static void test_conv_f2l(long[] a, float[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (long)b[i];\n+    }\n+  }\n@@ -568,1 +665,1 @@\n-    if (elem != val) {\n+    if (elem != val && !(Float.isNaN(elem) && Float.isNaN(val))) {\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestLongFloatVect.java","additions":100,"deletions":3,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,28 @@\n+  private static final short[] sspecial = {\n+    0, 0x8, 0xF, 0x3F, 0x7C, 0x7F, 0x8F, 0xF3, 0xF8, 0xFF, 0x38FF, (short)0x8F8F,\n+    (short)0x8FFF, 0x7FF3, 0x7FFF, (short)0xFF33, (short)0xFFF8, (short)0xFFFF,\n+    (short)0xFFFFFF, (short)Integer.MAX_VALUE, (short)Integer.MIN_VALUE\n+  };\n+\n+  private static final double[] dspecial = {\n+    1.0,\n+    -1.0,\n+    0.0,\n+    -0.0,\n+    Double.MAX_VALUE,\n+    Double.MIN_VALUE,\n+    -Double.MAX_VALUE,\n+    -Double.MIN_VALUE,\n+    Double.NaN,\n+    Double.POSITIVE_INFINITY,\n+    Double.NEGATIVE_INFINITY,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    Long.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    -Long.MIN_VALUE,\n+    -Long.MAX_VALUE\n+  };\n+\n@@ -78,0 +110,2 @@\n+      test_conv_s2d(a1, b1);\n+      test_conv_d2s(a1, b1);\n@@ -341,1 +375,35 @@\n-\n+      for (int j = 0; j < sspecial.length; j++) {\n+        short shortValue = sspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = shortValue;\n+        }\n+        test_conv_s2d(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_s2d: b1\", i, b1[i], (double)shortValue);\n+        }\n+      }\n+      for (int j = 0; j < dspecial.length; j++) {\n+        double doubleValue = dspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = doubleValue;\n+        }\n+        test_conv_d2s(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_d2s: a1\", i, a1[i], (short)doubleValue);\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (short)r.nextInt();\n+      }\n+      test_conv_s2d(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_s2d: b1\", i, b1[i], (double)a1[i]);\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextDouble();\n+      }\n+      test_conv_d2s(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2s: a1\", i, a1[i], (short)b1[i]);\n+      }\n@@ -451,0 +519,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_s2d(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_s2d: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_d2s(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_d2s: \" + (end - start));\n@@ -559,0 +639,10 @@\n+  static void test_conv_s2d(short[] a, double[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (double) a[i];\n+    }\n+  }\n+  static void test_conv_d2s(short[] a, double[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (short) b[i];\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestShortDoubleVect.java","additions":93,"deletions":3,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,28 @@\n+  private static final short[] sspecial = {\n+    0, 0x8, 0xF, 0x3F, 0x7C, 0x7F, 0x8F, 0xF3, 0xF8, 0xFF, 0x38FF, (short)0x8F8F,\n+    (short)0x8FFF, 0x7FF3, 0x7FFF, (short)0xFF33, (short)0xFFF8, (short)0xFFFF,\n+    (short)0xFFFFFF, (short)Integer.MAX_VALUE, (short)Integer.MIN_VALUE\n+  };\n+\n+  private static final float[] fspecial = {\n+    1.0f,\n+    -1.0f,\n+    0.0f,\n+    -0.0f,\n+    Float.MAX_VALUE,\n+    Float.MIN_VALUE,\n+    -Float.MAX_VALUE,\n+    -Float.MIN_VALUE,\n+    Float.NaN,\n+    Float.POSITIVE_INFINITY,\n+    Float.NEGATIVE_INFINITY,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    Long.MIN_VALUE,\n+    -Long.MAX_VALUE,\n+    -Long.MIN_VALUE\n+  };\n+\n@@ -78,0 +110,2 @@\n+      test_conv_s2f(a1, b1);\n+      test_conv_f2s(a1, b1);\n@@ -341,0 +375,35 @@\n+      for (int j = 0; j < sspecial.length; j++) {\n+        short shortValue = sspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = shortValue;\n+        }\n+        test_conv_s2f(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_s2f: b1\", i, b1[i], (float)(shortValue));\n+        }\n+      }\n+      for (int j = 0; j < fspecial.length; j++) {\n+        float floatValue = fspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = floatValue;\n+        }\n+        test_conv_f2s(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_f2s: a1\", i, a1[i], (short)floatValue);\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (short)r.nextInt();\n+      }\n+      test_conv_s2f(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_s2f: b1\", i, b1[i], (float)(a1[i]));\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextFloat();\n+      }\n+      test_conv_f2s(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2s: a1\", i, a1[i], (short)(b1[i]));\n+      }\n@@ -451,0 +520,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_s2f(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_s2f: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_f2s(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_f2s: \" + (end - start));\n@@ -559,0 +640,10 @@\n+  static void test_conv_s2f(short[] a, float[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (float) a[i];\n+    }\n+  }\n+  static void test_conv_f2s(short[] a, float[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (short) b[i];\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestShortFloatVect.java","additions":93,"deletions":2,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -28,1 +29,1 @@\n- *\n+ * @library \/test\/lib\n@@ -36,0 +37,3 @@\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n@@ -44,0 +48,18 @@\n+  private static final short[] sspecial = {\n+    0, 0x8, 0xF, 0x3F, 0x7C, 0x7F, 0x8F, 0xF3, 0xF8, 0xFF, 0x38FF, (short)0x8F8F,\n+    (short)0x8FFF, 0x7FF3, 0x7FFF, (short)0xFF33, (short)0xFFF8, (short)0xFFFF,\n+    (short)0xFFFFFF, (short)Integer.MAX_VALUE, (short)Integer.MIN_VALUE\n+  };\n+\n+  private static long[] lspecial = {\n+    0,\n+    Integer.MAX_VALUE,\n+    Integer.MIN_VALUE,\n+    -Integer.MAX_VALUE,\n+    -Integer.MIN_VALUE,\n+    Long.MAX_VALUE,\n+    Long.MIN_VALUE,\n+    -Long.MAX_VALUE,\n+    -Long.MIN_VALUE\n+  };\n+\n@@ -78,0 +100,2 @@\n+      test_conv_s2l(a1, b1);\n+      test_conv_l2s(a1, b1);\n@@ -341,1 +365,35 @@\n-\n+      for (int j = 0; j < sspecial.length; j++) {\n+        short shortValue = sspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = shortValue;\n+        }\n+        test_conv_s2l(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_s2l: b1\", i, b1[i], (long)(shortValue));\n+        }\n+      }\n+      for (int j = 0; j < lspecial.length; j++) {\n+        long longValue = lspecial[j];\n+        for (int i = 0; i < ARRLEN; i++) {\n+          b1[i] = longValue;\n+        }\n+        test_conv_l2s(a1, b1);\n+        for (int i = 0; i < ARRLEN; i++) {\n+          errn += verify(\"test_conv_l2s: a1\", i, a1[i], (short)longValue);\n+        }\n+      }\n+      Random r = Utils.getRandomInstance();\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (short)r.nextInt();\n+      }\n+      test_conv_s2l(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_s2l: b1\", i, b1[i], (long)(a1[i]));\n+      }\n+      for (int i = 0; i < ARRLEN; i++) {\n+        b1[i] = r.nextLong();\n+      }\n+      test_conv_l2s(a1, b1);\n+      for (int i = 0; i < ARRLEN; i++) {\n+        errn += verify(\"test_conv_l2s: a1\", i, a1[i], (short)b1[i]);\n+      }\n@@ -451,0 +509,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_s2l(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_s2l: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i = 0; i < ITERS; i++) {\n+      test_conv_l2s(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_l2s: \" + (end - start));\n@@ -559,0 +629,10 @@\n+  static void test_conv_s2l(short[] a, long[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (long) a[i];\n+    }\n+  }\n+  static void test_conv_l2s(short[] a, long[] b) {\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (short) b[i];\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestShortLongVect.java","additions":83,"deletions":3,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -226,0 +226,56 @@\n+    @Benchmark\n+    public void convert_d2f() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resF[i] = (float) doubles[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convert_d2i() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resI[i] = (int) doubles[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convert_f2d() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resD[i] = (double) floats[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convert_f2l() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resL[i] = (long) floats[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convert_i2d() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resD[i] = (double) ints[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convert_i2l() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resL[i] = (long) ints[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convert_l2f() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resF[i] = (float) longs[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convert_l2i() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resI[i] = (int) longs[i];\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TypeVectorOperations.java","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"}]}