{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -2985,1 +2985,1 @@\n-    __ asm_assert_ne(\"unexpected null obj\", __LINE__);\n+    __ asm_assert(Assembler::bcondNotEqual, \"unexpected null obj\", __LINE__);\n@@ -2996,1 +2996,1 @@\n-      __ asm_assert_eq(\"exact klass and actual klass differ\", __LINE__);\n+      __ asm_assert(Assembler::bcondEqual, \"exact klass and actual klass differ\", __LINE__);\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2023 SAP SE. All rights reserved.\n@@ -180,1 +180,1 @@\n-    __ asm_assert_ne(\"null oop not allowed (G1 pre)\", 0x321); \/\/ Checked by caller.\n+    __ asm_assert(Assembler::bcondNotEqual, \"null oop not allowed (G1 pre)\", 0x321); \/\/ Checked by caller.\n@@ -292,1 +292,1 @@\n-    __ asm_assert_ne(\"null oop not allowed (G1 post)\", 0x322); \/\/ Checked by caller.\n+    __ asm_assert(Assembler::bcondNotEqual, \"null oop not allowed (G1 post)\", 0x322); \/\/ Checked by caller.\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"asm\/macroAssembler.hpp\"\n+#include \"asm\/macroAssembler.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -2059,1 +2059,1 @@\n-    asm_assert_eq(\"[old_sp]!=[Z_SP]\", 0x211);\n+    asm_assert(bcondEqual, \"[old_sp]!=[Z_SP]\", 0x211);\n@@ -5316,74 +5316,0 @@\n-#ifndef PRODUCT\n-\/\/ Assert if CC indicates \"not equal\" (check_equal==true) or \"equal\" (check_equal==false).\n-void MacroAssembler::asm_assert(bool check_equal, const char *msg, int id) {\n-  Label ok;\n-  if (check_equal) {\n-    z_bre(ok);\n-  } else {\n-    z_brne(ok);\n-  }\n-  stop(msg, id);\n-  bind(ok);\n-}\n-\n-\/\/ Assert if CC indicates \"low\".\n-void MacroAssembler::asm_assert_low(const char *msg, int id) {\n-  Label ok;\n-  z_brnl(ok);\n-  stop(msg, id);\n-  bind(ok);\n-}\n-\n-\/\/ Assert if CC indicates \"high\".\n-void MacroAssembler::asm_assert_high(const char *msg, int id) {\n-  Label ok;\n-  z_brnh(ok);\n-  stop(msg, id);\n-  bind(ok);\n-}\n-\n-\/\/ Assert if CC indicates \"not equal\" (check_equal==true) or \"equal\" (check_equal==false)\n-\/\/ generate non-relocatable code.\n-void MacroAssembler::asm_assert_static(bool check_equal, const char *msg, int id) {\n-  Label ok;\n-  if (check_equal) { z_bre(ok); }\n-  else             { z_brne(ok); }\n-  stop_static(msg, id);\n-  bind(ok);\n-}\n-\n-void MacroAssembler::asm_assert_mems_zero(bool check_equal, bool allow_relocation, int size, int64_t mem_offset,\n-                                          Register mem_base, const char* msg, int id) {\n-  switch (size) {\n-    case 4:\n-      load_and_test_int(Z_R0, Address(mem_base, mem_offset));\n-      break;\n-    case 8:\n-      load_and_test_long(Z_R0,  Address(mem_base, mem_offset));\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-  }\n-  if (allow_relocation) { asm_assert(check_equal, msg, id); }\n-  else                  { asm_assert_static(check_equal, msg, id); }\n-}\n-\n-\/\/ Check the condition\n-\/\/   expected_size == FP - SP\n-\/\/ after transformation:\n-\/\/   expected_size - FP + SP == 0\n-\/\/ Destroys Register expected_size if no tmp register is passed.\n-void MacroAssembler::asm_assert_frame_size(Register expected_size, Register tmp, const char* msg, int id) {\n-  if (tmp == noreg) {\n-    tmp = expected_size;\n-  } else {\n-    if (tmp != expected_size) {\n-      z_lgr(tmp, expected_size);\n-    }\n-    z_algr(tmp, Z_SP);\n-    z_slg(tmp, 0, Z_R0, Z_SP);\n-    asm_assert_eq(msg, id);\n-  }\n-}\n-#endif \/\/ !PRODUCT\n-\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":2,"deletions":76,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -867,5 +867,1 @@\n-  void asm_assert(bool check_equal, const char* msg, int id) PRODUCT_RETURN;\n-  void asm_assert_low(const char *msg, int id) PRODUCT_RETURN;\n-  void asm_assert_high(const char *msg, int id) PRODUCT_RETURN;\n-  void asm_assert_eq(const char* msg, int id) { asm_assert(true, msg, id); }\n-  void asm_assert_ne(const char* msg, int id) { asm_assert(false, msg, id); }\n+  inline void asm_assert(branch_condition cond, const char* msg, int id, bool is_static=true);\n@@ -873,1 +869,4 @@\n-  void asm_assert_static(bool check_equal, const char* msg, int id) PRODUCT_RETURN;\n+  \/\/ Assert if CC indicates \"not equal\" (check_equal==true) or \"equal\" (check_equal==false).\n+  inline void asm_assert(bool check_equal, const char* msg, int id) {\n+    asm_assert(check_equal ? bcondEqual : bcondNotEqual, msg, id);\n+  }\n@@ -877,2 +876,2 @@\n-  void asm_assert_mems_zero(bool check_equal, bool allow_relocation, int size, int64_t mem_offset,\n-                            Register mem_base, const char* msg, int id) PRODUCT_RETURN;\n+  inline void asm_assert_mems_zero(bool check_equal, bool allow_relocation, int size, int64_t mem_offset,\n+                            Register mem_base, const char* msg, int id);\n@@ -893,1 +892,0 @@\n-\n@@ -906,1 +904,1 @@\n-  void asm_assert_frame_size(Register expected_size, Register tmp, const char* msg, int id) PRODUCT_RETURN;\n+  inline void asm_assert_frame_size(Register expected_size, Register tmp, const char* msg, int id);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -314,0 +314,47 @@\n+inline void MacroAssembler::asm_assert(branch_condition cond, const char* msg, int id, bool is_static) {\n+#ifdef ASSERT\n+  Label ok;\n+  z_brc(cond, ok);\n+  is_static ? stop_static(msg, id) : stop(msg, id);\n+  bind(ok);\n+#endif \/\/ ASSERT\n+}\n+\n+inline void MacroAssembler::asm_assert_mems_zero(bool check_equal, bool allow_relocation, int size, int64_t mem_offset,\n+                                          Register mem_base, const char* msg, int id) {\n+#ifdef ASSERT\n+  switch (size) {\n+    case 4:\n+      load_and_test_int(Z_R0, Address(mem_base, mem_offset));\n+      break;\n+    case 8:\n+      load_and_test_long(Z_R0,  Address(mem_base, mem_offset));\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+  \/\/ if relocation is not allowed then stop_static() will be called otherwise call stop()\n+  asm_assert(check_equal ? bcondEqual : bcondNotEqual, msg, id, !allow_relocation);\n+#endif \/\/ ASSERT\n+}\n+\n+\/\/ Check the condition\n+\/\/   expected_size == FP - SP\n+\/\/ after transformation:\n+\/\/   expected_size - FP + SP == 0\n+\/\/ Destroys Register expected_size if no tmp register is passed.\n+inline void MacroAssembler::asm_assert_frame_size(Register expected_size, Register tmp, const char* msg, int id) {\n+#ifdef ASSERT\n+  if (tmp == noreg) {\n+    tmp = expected_size;\n+  } else {\n+    if (tmp != expected_size) {\n+      z_lgr(tmp, expected_size);\n+    }\n+    z_algr(tmp, Z_SP);\n+    z_slg(tmp, 0, Z_R0, Z_SP);\n+    asm_assert(bcondEqual, msg, id);\n+  }\n+#endif \/\/ ASSERT\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.inline.hpp","additions":49,"deletions":2,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"asm\/macroAssembler.hpp\"\n+#include \"asm\/macroAssembler.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-  __ asm_assert_ne(\"handler must not be NULL\", 0x852);\n+  __ asm_assert(Assembler::bcondNotEqual, \"handler must not be NULL\", 0x852);\n","filename":"src\/hotspot\/cpu\/s390\/runtime_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -2479,1 +2479,1 @@\n-  __ asm_assert_ne(\"array_size must be > 0\", 0x205);\n+  __ asm_assert(Assembler::bcondNotEqual, \"array_size must be > 0\", 0x205);\n@@ -2789,1 +2789,1 @@\n-  __ asm_assert_eq(\"SharedRuntime::generate_deopt_blob: expected Unpack_uncommon_trap\", 0);\n+  __ asm_assert(Assembler::bcondEqual, \"SharedRuntime::generate_deopt_blob: expected Unpack_uncommon_trap\", 0);\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -370,1 +370,1 @@\n-      __ asm_assert_low(assertMsg, 0x0234);\n+      __ asm_assert(Assembler::bcondNotLow, assertMsg, 0x0234);\n@@ -372,1 +372,1 @@\n-      __ asm_assert_high(assertMsg, 0x0235);\n+      __ asm_assert(Assembler::bcondNotHigh, assertMsg, 0x0235);\n@@ -738,1 +738,1 @@\n-    __ asm_assert_eq(\"missing zero extend\", 0xAFFE);\n+    __ asm_assert(Assembler::bcondEqual, \"missing zero extend\", 0xAFFE);\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2017 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -59,1 +59,1 @@\n-    __ asm_assert_eq(\"crc_table: external word relocation required for load_absolute_address\", 0x33);\n+    __ asm_assert(Assembler::bcondEqual, \"crc_table: external word relocation required for load_absolute_address\", 0x33);\n@@ -69,1 +69,1 @@\n-    __ asm_assert_eq(\"crc_table: address or contents seems to be messed up\", 0x22);\n+    __ asm_assert(Assembler::bcondEqual, \"crc_table: address or contents seems to be messed up\", 0x22);\n@@ -104,1 +104,1 @@\n-      __ asm_assert_eq(\"crc_table: external word relocation does not work for load_absolute_address\", 0x33);\n+      __ asm_assert(Assembler::bcondEqual, \"crc_table: external word relocation does not work for load_absolute_address\", 0x33);\n@@ -114,1 +114,1 @@\n-      __ asm_assert_eq(\"trot_table: address or contents seems to be messed up\", 0x22);\n+      __ asm_assert(Assembler::bcondEqual, \"trot_table: address or contents seems to be messed up\", 0x22);\n","filename":"src\/hotspot\/cpu\/s390\/stubRoutines_s390.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1085,1 +1085,1 @@\n-  NOT_PRODUCT(__ asm_assert_eq(\"killed Z_R14\", 0));\n+  NOT_PRODUCT(__ asm_assert(Assembler::bcondEqual, \"killed Z_R14\", 0));\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"asm\/macroAssembler.hpp\"\n+#include \"asm\/macroAssembler.inline.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"asm\/macroAssembler.hpp\"\n+#include \"asm\/macroAssembler.inline.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/interp_masm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}