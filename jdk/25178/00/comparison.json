{"files":[{"patch":"@@ -82,2 +82,9 @@\n-                                             .startsWith(\"Windows\");\n-    private static final byte[] ROOTPATH = new byte[] { '\/' };\n+            .startsWith(\"Windows\");\n+    private static final byte[] ROOTPATH = new byte[]{'\/'};\n+\n+    \/\/ Global access mode for \"mounted\" file system (\"readOnly\" or \"readWrite\").\n+    private static final String PROPERTY_ACCESS_MODE = \"accessMode\";\n+\n+    \/\/ Posix file permissions allow per-file access control in a posix-like fashion.\n+    \/\/ Note that using a \"readOnly\" access mode will force all files, and the\n+    \/\/ default permission, to lose any \"write\" permissions.\n@@ -90,0 +97,1 @@\n+\n@@ -94,2 +102,0 @@\n-    private static final Set<PosixFilePermission> DEFAULT_PERMISSIONS =\n-        PosixFilePermissions.fromString(\"rwxrwxrwx\");\n@@ -107,1 +113,2 @@\n-    private boolean readOnly; \/\/ readonly file system, false by default\n+    \/\/ Start readOnly (safe mode) and maybe reset at end of initialization.\n+    private boolean readOnly = true;\n@@ -132,0 +139,1 @@\n+    \/\/ Unmodifiable set.\n@@ -136,0 +144,36 @@\n+    \/\/ If it's decided to try and make access mode common to other file systems,\n+    \/\/ this could exist somewhere common, but if it's definitely never going to\n+    \/\/ be shared, it could be made public here.\n+    private enum AccessMode {\n+        \/\/ Creates a file system for read-write access.\n+        READ_WRITE(\"readWrite\"),\n+        \/\/ Creates a file system for read-only access.\n+        READ_ONLY(\"readOnly\");\n+\n+        private final String label;\n+\n+        AccessMode(String label) {\n+            this.label = label;\n+        }\n+\n+        \/\/ Parses the file system permission from an environmental parameter. While\n+        \/\/ the FileSystemAccessMode is private, we don't need to check if it was\n+        \/\/ given as an enum value. Returns null to indicate default behaviour.\n+        static AccessMode from(Object value) {\n+            switch (value) {\n+                case null -> {\n+                    return null;\n+                }\n+                case String label when READ_WRITE.label.equals(label) -> {\n+                    return READ_WRITE;\n+                }\n+                case String label when READ_ONLY.label.equals(label) -> {\n+                    return READ_ONLY;\n+                }\n+                default -> {\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Unknown file system access mode: \" + value);\n+        }\n+    }\n+\n@@ -147,0 +191,4 @@\n+\n+        AccessMode accessMode = AccessMode.from(env.get(PROPERTY_ACCESS_MODE));\n+        boolean forceReadOnly = (accessMode == AccessMode.READ_ONLY);\n+\n@@ -150,1 +198,1 @@\n-        this.defaultPermissions = supportPosix ? initPermissions(env) : null;\n+        this.defaultPermissions = supportPosix ? Collections.unmodifiableSet(initPermissions(env)) : null;\n@@ -152,1 +200,11 @@\n-            Set.of(\"basic\", \"posix\", \"zip\") : Set.of(\"basic\", \"zip\");\n+                Set.of(\"basic\", \"posix\", \"zip\") : Set.of(\"basic\", \"zip\");\n+\n+        \/\/ 'create=true' is semantically the same as StandardOpenOption.CREATE,\n+        \/\/ and can only be used to create a writable file system (whether the\n+        \/\/ underlying ZIP file exists or not), and is always incompatible with\n+        \/\/ 'accessMode=readOnly').\n+        boolean shouldCreate = isTrue(env, \"create\");\n+        if (shouldCreate && forceReadOnly) {\n+            throw new IllegalArgumentException(\n+                    \"Specifying 'accessMode=readOnly' is incompatible with 'create=true'\");\n+        }\n@@ -154,2 +212,1 @@\n-            \/\/ create a new zip if it doesn't exist\n-            if (isTrue(env, \"create\")) {\n+            if (shouldCreate) {\n@@ -164,3 +221,1 @@\n-        zfpath.getFileSystem().provider().checkAccess(zfpath, AccessMode.READ);\n-        boolean writeable = Files.isWritable(zfpath);\n-        this.readOnly = !writeable;\n+        zfpath.getFileSystem().provider().checkAccess(zfpath, java.nio.file.AccessMode.READ);\n@@ -168,1 +223,0 @@\n-        this.rootdir = new ZipPath(this, new byte[]{'\/'});\n@@ -183,1 +237,23 @@\n-        initializeReleaseVersion(env);\n+        \/\/ Determining a release version uses 'this' instance to read paths etc.\n+        \/\/ It requires 'entryLookup' and 'readOnly' to have safe defaults (which\n+        \/\/ is why they are the only non-final fields), and it requires that the\n+        \/\/ inode map has been initialized.\n+        Optional<Integer> multiReleaseVersion = determineReleaseVersion(env);\n+\n+        \/\/ Set the version-based lookup function for multi-release JARs.\n+        this.entryLookup =\n+                multiReleaseVersion.map(this::createVersionedLinks).orElse(Function.identity());\n+\n+        \/\/ We only allow read-write zip\/jar files if they are not multi-release\n+        \/\/ JARs and the underlying file is writable.\n+        this.readOnly = forceReadOnly || multiReleaseVersion.isPresent() || !Files.isWritable(zfpath);\n+        if (readOnly && accessMode == AccessMode.READ_WRITE) {\n+            String reason = Files.isWritable(zfpath)\n+                    ? \"A multi-release JAR file opened with a specified version is not writable\"\n+                    : \"The underlying ZIP file is not writable\";\n+            throw new IOException(\n+                    \"A writable ZIP file system could not be opened for: \" + zfpath + \"\\n\" + reason);\n+        }\n+\n+        \/\/ Pass \"this\" as a parameter after everything else is set up.\n+        this.rootdir = new ZipPath(this, new byte[]{'\/'});\n@@ -188,1 +264,1 @@\n-     * property {@code commpressionMethod} is set use its value to determine\n+     * property {@code compressionMethod} is set use its value to determine\n@@ -296,1 +372,1 @@\n-    \/\/ Initialize the default permissions for files inside the zip archive.\n+    \/\/ Return the default permissions for files inside the zip archive.\n@@ -301,1 +377,1 @@\n-            return DEFAULT_PERMISSIONS;\n+            return PosixFilePermissions.fromString(\"rwxrwxrwx\");\n@@ -349,4 +425,0 @@\n-    void setReadOnly() {\n-        this.readOnly = true;\n-    }\n-\n@@ -1386,1 +1458,1 @@\n-    private void initializeReleaseVersion(Map<String, ?> env) throws IOException {\n+    private Optional<Integer> determineReleaseVersion(Map<String, ?> env) throws IOException {\n@@ -1391,15 +1463,10 @@\n-        if (o != null && isMultiReleaseJar()) {\n-            int version;\n-            if (o instanceof String) {\n-                String s = (String)o;\n-                if (s.equals(\"runtime\")) {\n-                    version = Runtime.version().feature();\n-                } else if (s.matches(\"^[1-9][0-9]*$\")) {\n-                    version = Version.parse(s).feature();\n-                } else {\n-                    throw new IllegalArgumentException(\"Invalid runtime version\");\n-                }\n-            } else if (o instanceof Integer) {\n-                version = Version.parse(((Integer)o).toString()).feature();\n-            } else if (o instanceof Version) {\n-                version = ((Version)o).feature();\n+        if (o == null || !isMultiReleaseJar()) {\n+            return Optional.empty();\n+        }\n+        int version;\n+        if (o instanceof String) {\n+            String s = (String) o;\n+            if (s.equals(\"runtime\")) {\n+                version = Runtime.version().feature();\n+            } else if (s.matches(\"^[1-9][0-9]*$\")) {\n+                version = Version.parse(s).feature();\n@@ -1407,2 +1474,1 @@\n-                throw new IllegalArgumentException(\"env parameter must be String, \" +\n-                    \"Integer, or Version\");\n+                throw new IllegalArgumentException(\"Invalid runtime version\");\n@@ -1410,2 +1476,7 @@\n-            createVersionedLinks(version < 0 ? 0 : version);\n-            setReadOnly();\n+        } else if (o instanceof Integer) {\n+            version = Version.parse(((Integer) o).toString()).feature();\n+        } else if (o instanceof Version) {\n+            version = ((Version) o).feature();\n+        } else {\n+            throw new IllegalArgumentException(\"env parameter must be String, \" +\n+                    \"Integer, or Version\");\n@@ -1413,0 +1484,1 @@\n+        return Optional.of(Math.max(version, 0));\n@@ -1438,1 +1510,1 @@\n-    private void createVersionedLinks(int version) {\n+    private Function<byte[], byte[]> createVersionedLinks(int version) {\n@@ -1442,1 +1514,1 @@\n-            return;\n+            return Function.identity();\n@@ -1454,4 +1526,1 @@\n-        entryLookup = path -> {\n-            byte[] entry = aliasMap.get(IndexNode.keyOf(path));\n-            return entry == null ? path : entry;\n-        };\n+        return path -> aliasMap.getOrDefault(IndexNode.keyOf(path), path);\n@@ -3554,1 +3623,2 @@\n-            return storedPermissions().orElse(Set.copyOf(defaultPermissions));\n+            \/\/ supportPosix ==> (defaultPermissions != null)\n+            return storedPermissions().orElse(defaultPermissions);\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":118,"deletions":48,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -156,2 +156,5 @@\n- *       If the value is {@code true}, the ZIP file system provider\n- *       creates a new ZIP or JAR file if it does not exist.\n+ *       If the value is {@code true}, the ZIP file system provider creates a\n+ *       new ZIP or JAR file if it does not exist. The resulting file system\n+ *       will always be opened <em>read-write<\/em> (see {@code \"accessMode\"}\n+ *       below), regardless of whether the underlying ZIP already existed or\n+ *       not.\n@@ -268,1 +271,42 @@\n- *  <\/tbody>\n+ * <tr>\n+ *   <th scope=\"row\">accessMode<\/th>\n+ *   <td>{@link java.lang.String}<\/td>\n+ *   <td>null\/unset<\/td>\n+ *   <td>\n+ *       A value defining the desired read\/write access mode of the file system\n+ *       (either <em>read-write<\/em> or <em>read-only<\/em>).\n+ *       <p>\n+ *       Even if a zip file system is writable ({@code fs.isReadOnly() == false}),\n+ *       this says nothing about whether individual files can be created or\n+ *       modified, simply that it might be possible.\n+ *       <ul>\n+ *           <li>\n+ *               If no value is set, the file system is created <em>read-write<\/em>\n+ *               if possible. Use {@link java.nio.file.FileSystem#isReadOnly()\n+ *               isReadOnly()} to determine the actual access mode.\n+ *           <\/li>\n+ *           <li>\n+ *               If the value is {@code \"readOnly\"}, the file system is created\n+ *               <em>read-only<\/em>, and {@link java.nio.file.FileSystem#isReadOnly()\n+ *               isReadOnly()} will always return {@code true}. Creating a\n+ *               <em>read-only<\/em> file system requires the underlying ZIP file to\n+ *               already exist, and is incompatible with {@code \"create\"=true}.\n+ *               Specifying both will cause an {@code IllegalArgumentException}\n+ *               to be thrown.\n+ *           <\/li>\n+ *           <li>\n+ *               If the value is {@code \"readWrite\"}, the file system is created\n+ *               <em>read-write<\/em>, and {@link java.nio.file.FileSystem#isReadOnly()\n+ *               isReadOnly()} will always return {@code false}. If a writable file\n+ *               system cannot be created, an {@code IOException} will be thrown.\n+ *           <\/li>\n+ *           <li>\n+ *               Any other values will cause an {@code IllegalArgumentException}\n+ *               to be thrown.\n+ *           <\/li>\n+ *       <\/ul>\n+ *       The access mode has no effect on reported POSIX file permissions (in cases\n+ *       where POSIX support is enabled).\n+ *   <\/td>\n+ * <\/tr>\n+ * <\/tbody>\n","filename":"src\/jdk.zipfs\/share\/classes\/module-info.java","additions":47,"deletions":3,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.nio.file.NoSuchFileException;\n@@ -38,0 +39,1 @@\n+import static java.nio.charset.StandardCharsets.UTF_8;\n@@ -173,0 +175,99 @@\n+    \/**\n+     * Validate that without {@code \"create\" = true}, a ZIP file system cannot\n+     * be opened if the underlying file is missing.\n+     *\/\n+    @Test\n+    public void testNoSuchFileFailure() {\n+        Path noSuchZip = Path.of(\"no_such.zip\");\n+        assertThrows(NoSuchFileException.class,\n+                () -> FileSystems.newFileSystem(noSuchZip, Map.of()));\n+        assertThrows(NoSuchFileException.class,\n+                () -> FileSystems.newFileSystem(noSuchZip, Map.of(\"accessMode\", \"readOnly\")));\n+        assertThrows(NoSuchFileException.class,\n+                () -> FileSystems.newFileSystem(noSuchZip, Map.of(\"accessMode\", \"readWrite\")));\n+    }\n+\n+    \/**\n+     * Validate that even with {@code \"create\" = true}, a ZIP file system cannot\n+     * be opened for badly specified arguments. These errors occur before any\n+     * missing file checks.\n+     *\/\n+    @Test\n+    public void badArgumentsFailure() throws IOException {\n+        Path noSuchZip = Path.of(\"no_such.zip\");\n+        assertThrows(IllegalArgumentException.class,\n+                () -> FileSystems.newFileSystem(\n+                        noSuchZip,\n+                        Map.of(\"create\", true, \"accessMode\", \"readOnly\")));\n+        assertThrows(IllegalArgumentException.class,\n+                () -> FileSystems.newFileSystem(\n+                        noSuchZip,\n+                        Map.of(\"create\", true, \"accessMode\", \"badValue\")));\n+    }\n+\n+    \/**\n+     * Validate that multi-release JARs can be opened read-write if no release\n+     * version is specified.\n+     *\/\n+    @Test\n+    public void multiReleaseJarReadWriteSuccess() throws IOException {\n+        \/\/ Multi-release JARs, when opened with a specified version are inherently read-only.\n+        Path multiReleaseJar = createMultiReleaseJar();\n+        try (FileSystem fs = FileSystems.newFileSystem(multiReleaseJar, Map.of(\"accessMode\", \"readWrite\"))) {\n+            assertFalse(fs.isReadOnly());\n+            if (!\"Default version\".equals(Files.readString(fs.getPath(\"file.txt\"), UTF_8))) {\n+                throw new RuntimeException(\"unexpected file content\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Validate that when the underlying file is read-only, it cannot be opened in\n+     * read-write mode.\n+     *\/\n+    @Test\n+    public void readOnlyZipFileFailure() throws IOException {\n+        \/\/ Underlying file is read-only.\n+        Path readOnlyZip = Utils.createJarFile(\"read_only.zip\", Map.of(\"file.txt\", \"Hello World\"));\n+        readOnlyZip.toFile().setReadOnly();\n+        assertThrows(IOException.class,\n+                () -> FileSystems.newFileSystem(readOnlyZip, Map.of(\"accessMode\", \"readWrite\")));\n+    }\n+\n+    \/**\n+     * Validate that multi-release JAR is opened read-only by default if a release\n+     * version is specified.\n+     *\/\n+    @Test\n+    public void multiReleaseJarDefaultReadOnly() throws IOException {\n+        Path multiReleaseJar = createMultiReleaseJar();\n+        try (FileSystem fs = FileSystems.newFileSystem(multiReleaseJar, Map.of(\"releaseVersion\", \"1\"))) {\n+            assertTrue(fs.isReadOnly());\n+            if (!\"First version\".equals(Files.readString(fs.getPath(\"file.txt\"), UTF_8))) {\n+                throw new RuntimeException(\"unexpected file content\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Validate that multi-release JARs cannot be opened read-write if a release\n+     * version is specified.\n+     *\/\n+    @Test\n+    public void multiReleaseJarReadWriteFailure() throws IOException {\n+        Path multiReleaseJar = createMultiReleaseJar();\n+        assertThrows(IOException.class,\n+                () -> FileSystems.newFileSystem(\n+                        multiReleaseJar,\n+                        Map.of(\"accessMode\", \"readWrite\", \"releaseVersion\", \"1\")));\n+    }\n+\n+    private static Path createMultiReleaseJar() throws IOException {\n+        return Utils.createJarFile(\"multi_release.jar\", Map.of(\n+                \/\/ Newline required for attribute to be read from Manifest file.\n+                \"META-INF\/MANIFEST.MF\", \"Multi-Release: true\\n\",\n+                \"META-INF\/versions\/1\/file.txt\", \"First version\",\n+                \"META-INF\/versions\/2\/file.txt\", \"Second version\",\n+                \"file.txt\", \"Default version\"));\n+    }\n+\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/NewFileSystemTests.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.stream.Stream;\n@@ -53,0 +54,1 @@\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n@@ -55,0 +57,2 @@\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -99,0 +103,2 @@\n+    private static final Map<String, Object> ENV_READ_ONLY = Map.of(\"accessMode\", \"readOnly\");\n+    private static final Map<String, Object> ENV_POSIX_READ_ONLY = Map.of(\"enablePosixFileAttributes\", true, \"accessMode\", \"readOnly\");\n@@ -401,0 +407,31 @@\n+    private void checkReadOnlyFileSystem(FileSystem fs) throws IOException {\n+        assertTrue(fs.isReadOnly(), \"File system should be read-only\");\n+        Path root = fs.getPath(\"\/\");\n+\n+        \/\/ Rather than calling something like \"addOwnerRead(root)\", we walk all\n+        \/\/ files to ensure that all operations fail, not some arbitrary first one.\n+        Set<PosixFilePermission> badPerms = Set.of(OTHERS_EXECUTE, OTHERS_WRITE);\n+        FileTime anyTime = FileTime.from(Instant.now());\n+        try (Stream<Path> paths = Files.walk(root)) {\n+            paths.forEach(p -> {\n+                assertFalse(Files.isWritable(p), \"File should not be writable: \" + p);\n+                assertSame(fs, p.getFileSystem());\n+                assertThrows(\n+                        AccessDeniedException.class,\n+                        () -> fs.provider().checkAccess(p, AccessMode.WRITE));\n+                assertThrows(\n+                        ReadOnlyFileSystemException.class,\n+                        () -> fs.provider().setAttribute(p, \"zip:permissions\", badPerms));\n+\n+                \/\/ These fail because there is not corresponding File for a zip path (they will\n+                \/\/ currently fail for read-write ZIP file systems too, but we sanity-check here).\n+                assertThrows(UnsupportedOperationException.class,\n+                        () -> Files.setLastModifiedTime(p, anyTime));\n+                assertThrows(UnsupportedOperationException.class,\n+                        () -> Files.setAttribute(p, \"zip:permissions\", badPerms));\n+                assertThrows(UnsupportedOperationException.class,\n+                        () -> Files.setPosixFilePermissions(p, badPerms));\n+            });\n+        }\n+    }\n+\n@@ -434,1 +471,1 @@\n-        try (FileSystem zip = FileSystems.newFileSystem(ZIP_FILE, ENV_DEFAULT)) {\n+        try (FileSystem zip = FileSystems.newFileSystem(ZIP_FILE, ENV_READ_ONLY)) {\n@@ -436,0 +473,1 @@\n+            checkReadOnlyFileSystem(zip);\n@@ -438,1 +476,1 @@\n-        try (FileSystem zip = FileSystems.newFileSystem(ZIP_FILE, ENV_POSIX)) {\n+        try (FileSystem zip = FileSystems.newFileSystem(ZIP_FILE, ENV_POSIX_READ_ONLY)) {\n@@ -440,0 +478,1 @@\n+            checkReadOnlyFileSystem(zip);\n@@ -454,1 +493,1 @@\n-        try (FileSystem zip = FileSystems.newFileSystem(ZIP_FILE, ENV_DEFAULT)) {\n+        try (FileSystem zip = FileSystems.newFileSystem(ZIP_FILE, ENV_READ_ONLY)) {\n@@ -456,0 +495,1 @@\n+            checkReadOnlyFileSystem(zip);\n@@ -458,1 +498,1 @@\n-        try (FileSystem zip = FileSystems.newFileSystem(ZIP_FILE, ENV_POSIX)) {\n+        try (FileSystem zip = FileSystems.newFileSystem(ZIP_FILE, ENV_POSIX_READ_ONLY)) {\n@@ -460,0 +500,1 @@\n+            checkReadOnlyFileSystem(zip);\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/TestPosix.java","additions":45,"deletions":4,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.Map;\n@@ -31,0 +32,2 @@\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n@@ -32,1 +35,1 @@\n- * Utility class for zipfs tests.\n+ * Utility class for {@code ZipFileSystem} tests.\n@@ -34,3 +37,2 @@\n-\n-class Utils {\n-    private Utils() { }\n+final class Utils {\n+    private Utils() {}\n@@ -39,1 +41,2 @@\n-     * Creates a JAR file of the given name with 0 or more named entries.\n+     * Creates a JAR file of the given name with 0 or more named entries with\n+     * random content.\n@@ -41,1 +44,6 @@\n-     * @return Path to the newly created JAR file\n+     * <p>If an existing file of the same name already exists, it is silently\n+     * overwritten.\n+     *\n+     * @param name the file name of the jar file to create in the working directory.\n+     * @param entries a list of JAR entries to be populated with random bytes.\n+     * @return the absolute path to the newly created JAR file.\n@@ -44,1 +52,1 @@\n-        Path jarFile = Paths.get(\"basic.jar\");\n+        Path jarFile = Paths.get(name);\n@@ -59,1 +67,27 @@\n-        return jarFile;\n+        return jarFile.toAbsolutePath();\n+    }\n+\n+    \/**\n+     * Creates a JAR file of the given name with 0 or more entries with specified\n+     * content.\n+     *\n+     * <p>If an existing file of the same name already exists, it is silently\n+     * overwritten.\n+     *\n+     * @param name the file name of the jar file to create in the working directory.\n+     * @param entries a map of relative file name path strings to file content\n+     *               (stored as UTF-8 encoded bytes).\n+     * @return the absolute path to the newly created JAR file.\n+     *\/\n+    static Path createJarFile(String name, Map<String, String> entries) throws IOException {\n+        Path jarFile = Paths.get(name);\n+        try (OutputStream out = Files.newOutputStream(jarFile);\n+             JarOutputStream jout = new JarOutputStream(out)) {\n+            for (var entry : entries.entrySet()) {\n+                JarEntry je = new JarEntry(entry.getKey());\n+                jout.putNextEntry(je);\n+                jout.write(entry.getValue().getBytes(UTF_8));\n+                jout.closeEntry();\n+            }\n+        }\n+        return jarFile.toAbsolutePath();\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/Utils.java","additions":42,"deletions":8,"binary":false,"changes":50,"status":"modified"}]}