{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,7 @@\n+\n+    \/\/ Global access mode for \"mounted\" file system (\"readOnly\" or \"readWrite\").\n+    private static final String PROPERTY_ACCESS_MODE = \"accessMode\";\n+\n+    \/\/ Posix file permissions allow per-file access control in a posix-like fashion.\n+    \/\/ Using a \"readOnly\" access mode will change the posix permissions of any\n+    \/\/ underlying entries (they may still show as \"writable\", but will not be).\n@@ -90,0 +97,1 @@\n+\n@@ -94,2 +102,0 @@\n-    private static final Set<PosixFilePermission> DEFAULT_PERMISSIONS =\n-        PosixFilePermissions.fromString(\"rwxrwxrwx\");\n@@ -107,1 +113,2 @@\n-    private boolean readOnly; \/\/ readonly file system, false by default\n+    \/\/ Starts in readOnly (safe mode), but might be reset at the end of initialization.\n+    private boolean readOnly = true;\n@@ -132,0 +139,1 @@\n+    \/\/ Unmodifiable set.\n@@ -136,0 +144,26 @@\n+    private enum ZipAccessMode {\n+        \/\/ Creates a file system for read-write access.\n+        READ_WRITE(\"readWrite\"),\n+        \/\/ Creates a file system for read-only access.\n+        READ_ONLY(\"readOnly\");\n+\n+        private final String label;\n+\n+        ZipAccessMode(String label) {\n+            this.label = label;\n+        }\n+\n+        \/\/ Parses the access mode from an environmental parameter.\n+        \/\/ Returns null for missing value to indicate default behavior.\n+        static ZipAccessMode from(Object value) {\n+            if (value == null) {\n+                return null;\n+            } else if (READ_WRITE.label.equals(value)) {\n+                return ZipAccessMode.READ_WRITE;\n+            } else if (READ_ONLY.label.equals(value)) {\n+                return ZipAccessMode.READ_ONLY;\n+            }\n+            throw new IllegalArgumentException(\"Unknown file system access mode: \" + value);\n+        }\n+    }\n+\n@@ -147,0 +181,4 @@\n+\n+        ZipAccessMode accessMode = ZipAccessMode.from(env.get(PROPERTY_ACCESS_MODE));\n+        boolean forceReadOnly = (accessMode == ZipAccessMode.READ_ONLY);\n+\n@@ -150,1 +188,1 @@\n-        this.defaultPermissions = supportPosix ? initPermissions(env) : null;\n+        this.defaultPermissions = supportPosix ? Collections.unmodifiableSet(initPermissions(env)) : null;\n@@ -152,1 +190,11 @@\n-            Set.of(\"basic\", \"posix\", \"zip\") : Set.of(\"basic\", \"zip\");\n+                Set.of(\"basic\", \"posix\", \"zip\") : Set.of(\"basic\", \"zip\");\n+\n+        \/\/ 'create=true' is semantically the same as StandardOpenOption.CREATE,\n+        \/\/ and can only be used to create a writable file system (whether the\n+        \/\/ underlying ZIP file exists or not), and is always incompatible with\n+        \/\/ 'accessMode=readOnly').\n+        boolean shouldCreate = isTrue(env, \"create\");\n+        if (shouldCreate && forceReadOnly) {\n+            throw new IllegalArgumentException(\n+                    \"Specifying 'accessMode=readOnly' is incompatible with 'create=true'\");\n+        }\n@@ -154,2 +202,1 @@\n-            \/\/ create a new zip if it doesn't exist\n-            if (isTrue(env, \"create\")) {\n+            if (shouldCreate) {\n@@ -163,1 +210,1 @@\n-        \/\/ sm and existence check\n+        \/\/ Existence check\n@@ -165,2 +212,0 @@\n-        boolean writeable = Files.isWritable(zfpath);\n-        this.readOnly = !writeable;\n@@ -168,1 +213,0 @@\n-        this.rootdir = new ZipPath(this, new byte[]{'\/'});\n@@ -182,0 +226,8 @@\n+        this.rootdir = new ZipPath(this, new byte[]{'\/'});\n+\n+        \/\/ Determining a release version uses 'this' instance to read paths etc.\n+        Optional<Integer> multiReleaseVersion = determineReleaseVersion(env);\n+\n+        \/\/ Set the version-based lookup function for multi-release JARs.\n+        this.entryLookup =\n+                multiReleaseVersion.map(this::createVersionedLinks).orElse(Function.identity());\n@@ -183,1 +235,9 @@\n-        initializeReleaseVersion(env);\n+        \/\/ We only allow read-write zip\/jar files if they are not multi-release\n+        \/\/ JARs and the underlying file is writable.\n+        this.readOnly = forceReadOnly || multiReleaseVersion.isPresent() || !Files.isWritable(zfpath);\n+        if (readOnly && accessMode == ZipAccessMode.READ_WRITE) {\n+            String reason = multiReleaseVersion.isPresent()\n+                    ? \"the multi-release JAR file is not writable\"\n+                    : \"the ZIP file is not writable\";\n+            throw new IOException(reason);\n+        }\n@@ -188,1 +248,1 @@\n-     * property {@code commpressionMethod} is set use its value to determine\n+     * property {@code compressionMethod} is set use its value to determine\n@@ -296,1 +356,1 @@\n-    \/\/ Initialize the default permissions for files inside the zip archive.\n+    \/\/ Return the default permissions for files inside the zip archive.\n@@ -301,1 +361,1 @@\n-            return DEFAULT_PERMISSIONS;\n+            return PosixFilePermissions.fromString(\"rwxrwxrwx\");\n@@ -349,4 +409,0 @@\n-    void setReadOnly() {\n-        this.readOnly = true;\n-    }\n-\n@@ -1386,1 +1442,1 @@\n-    private void initializeReleaseVersion(Map<String, ?> env) throws IOException {\n+    private Optional<Integer> determineReleaseVersion(Map<String, ?> env) throws IOException {\n@@ -1391,15 +1447,10 @@\n-        if (o != null && isMultiReleaseJar()) {\n-            int version;\n-            if (o instanceof String) {\n-                String s = (String)o;\n-                if (s.equals(\"runtime\")) {\n-                    version = Runtime.version().feature();\n-                } else if (s.matches(\"^[1-9][0-9]*$\")) {\n-                    version = Version.parse(s).feature();\n-                } else {\n-                    throw new IllegalArgumentException(\"Invalid runtime version\");\n-                }\n-            } else if (o instanceof Integer) {\n-                version = Version.parse(((Integer)o).toString()).feature();\n-            } else if (o instanceof Version) {\n-                version = ((Version)o).feature();\n+        if (o == null || !isMultiReleaseJar()) {\n+            return Optional.empty();\n+        }\n+        int version;\n+        if (o instanceof String) {\n+            String s = (String) o;\n+            if (s.equals(\"runtime\")) {\n+                version = Runtime.version().feature();\n+            } else if (s.matches(\"^[1-9][0-9]*$\")) {\n+                version = Version.parse(s).feature();\n@@ -1407,2 +1458,1 @@\n-                throw new IllegalArgumentException(\"env parameter must be String, \" +\n-                    \"Integer, or Version\");\n+                throw new IllegalArgumentException(\"Invalid runtime version\");\n@@ -1410,2 +1460,7 @@\n-            createVersionedLinks(version < 0 ? 0 : version);\n-            setReadOnly();\n+        } else if (o instanceof Integer) {\n+            version = Version.parse(((Integer) o).toString()).feature();\n+        } else if (o instanceof Version) {\n+            version = ((Version) o).feature();\n+        } else {\n+            throw new IllegalArgumentException(\"env parameter must be String, \" +\n+                    \"Integer, or Version\");\n@@ -1413,0 +1468,1 @@\n+        return Optional.of(Math.max(version, 0));\n@@ -1438,1 +1494,1 @@\n-    private void createVersionedLinks(int version) {\n+    private Function<byte[], byte[]> createVersionedLinks(int version) {\n@@ -1442,1 +1498,1 @@\n-            return;\n+            return Function.identity();\n@@ -1454,4 +1510,1 @@\n-        entryLookup = path -> {\n-            byte[] entry = aliasMap.get(IndexNode.keyOf(path));\n-            return entry == null ? path : entry;\n-        };\n+        return path -> aliasMap.getOrDefault(IndexNode.keyOf(path), path);\n@@ -3554,1 +3607,2 @@\n-            return storedPermissions().orElse(Set.copyOf(defaultPermissions));\n+            \/\/ supportPosix ==> (defaultPermissions != null)\n+            return storedPermissions().orElse(defaultPermissions);\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":101,"deletions":47,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,2 +156,2 @@\n- *       If the value is {@code true}, the ZIP file system provider\n- *       creates a new ZIP or JAR file if it does not exist.\n+ *       If the value is {@code true}, the ZIP file system provider creates a\n+ *       new ZIP or JAR file if it does not exist.\n@@ -228,2 +228,2 @@\n- *               {@code IllegalArgumentException} will be thrown when the Zip\n- *               filesystem is created.\n+ *               {@code IllegalArgumentException} will be thrown when creating the\n+ *               ZIP file system.\n@@ -263,1 +263,2 @@\n- *               an {@code IllegalArgumentException} will be thrown.\n+ *               an {@code IllegalArgumentException} will be thrown when creating\n+ *               the ZIP file system.\n@@ -268,1 +269,41 @@\n- *  <\/tbody>\n+ * <tr>\n+ *   <th scope=\"row\">accessMode<\/th>\n+ *   <td>{@link java.lang.String}<\/td>\n+ *   <td>null\/unset<\/td>\n+ *   <td>\n+ *       A value defining the desired access mode of the file system.\n+ *       ZIP file systems can be created to allow for <em>read-write<\/em> or\n+ *       <em>read-only<\/em> access.\n+ *       <ul>\n+ *           <li>\n+ *               If no value is set, the file system is created <em>read-write<\/em>\n+ *               if possible. Use {@link java.nio.file.FileSystem#isReadOnly()\n+ *               isReadOnly()} to determine the actual access mode.\n+ *           <\/li>\n+ *           <li>\n+ *               If the value is {@code \"readOnly\"}, the file system is created\n+ *               <em>read-only<\/em>, and {@link java.nio.file.FileSystem#isReadOnly()\n+ *               isReadOnly()} will always return {@code true}. Creating a\n+ *               <em>read-only<\/em> file system requires the underlying ZIP file to\n+ *               already exist.\n+ *               Specifying {@code create} as {@code true} and {@code accessMode} as\n+ *               {@code readOnly} will cause an {@code IllegalArgumentException}\n+ *               to be thrown when creating the ZIP file system.\n+ *           <\/li>\n+ *           <li>\n+ *               If the value is {@code \"readWrite\"}, the file system is created\n+ *               <em>read-write<\/em>, and {@link java.nio.file.FileSystem#isReadOnly()\n+ *               isReadOnly()} will always return {@code false}. If a writable file\n+ *               system cannot be created, an {@code IOException} will be thrown\n+ *               when creating the ZIP file system.\n+ *           <\/li>\n+ *           <li>\n+ *               Any other values will cause an {@code IllegalArgumentException}\n+ *               to be thrown when creating the ZIP file system.\n+ *           <\/li>\n+ *       <\/ul>\n+ *       The {@code accessMode} property has no effect on reported POSIX file\n+ *       permissions (in cases where POSIX support is enabled).\n+ *   <\/td>\n+ * <\/tr>\n+ * <\/tbody>\n","filename":"src\/jdk.zipfs\/share\/classes\/module-info.java","additions":48,"deletions":7,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.nio.file.NoSuchFileException;\n@@ -38,1 +39,6 @@\n-import static org.testng.Assert.*;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertThrows;\n+import static org.testng.Assert.assertTrue;\n@@ -173,0 +179,90 @@\n+    \/**\n+     * Validate that without {@code \"create\" = true}, a ZIP file system cannot be\n+     * opened if the underlying file is missing, but even with this set, a ZIP\n+     * file system cannot be opened for conflicting or invalid access modes.\n+     *\/\n+    @DataProvider(name = \"badEnvMap\")\n+    protected Object[][] badEnvMap() {\n+        return new Object[][]{\n+                {Map.of(), NoSuchFileException.class},\n+                {Map.of(\"accessMode\", \"readOnly\"), NoSuchFileException.class},\n+                {Map.of(\"accessMode\", \"readWrite\"), NoSuchFileException.class},\n+                {Map.of(\"create\", true, \"accessMode\", \"readOnly\"), IllegalArgumentException.class},\n+                {Map.of(\"create\", true, \"accessMode\", \"badValue\"), IllegalArgumentException.class},\n+        };\n+    }\n+    @Test(dataProvider = \"badEnvMap\")\n+    public void badArgumentsFailure(Map<String, String> env, Class<? extends Throwable> exception) throws IOException {\n+        assertThrows(exception, () -> FileSystems.newFileSystem(Path.of(\"no_such.zip\"), env));\n+    }\n+\n+    \/**\n+     * Validate that multi-release JARs can be opened read-write if no release\n+     * version is specified.\n+     *\/\n+    @Test\n+    public void multiReleaseJarReadWriteSuccess() throws IOException {\n+        \/\/ Multi-release JARs, when opened with a specified version are inherently read-only.\n+        Path multiReleaseJar = createMultiReleaseJar();\n+        try (FileSystem fs = FileSystems.newFileSystem(multiReleaseJar, Map.of(\"accessMode\", \"readWrite\"))) {\n+            assertFalse(fs.isReadOnly());\n+            assertEquals(\n+                    Files.readString(fs.getPath(\"file.txt\"), UTF_8),\n+                    \"Default version\",\n+                    \"unexpected file content\");\n+        }\n+    }\n+\n+    \/**\n+     * Validate that when the underlying file is read-only, it cannot be opened in\n+     * read-write mode.\n+     *\/\n+    @Test\n+    public void readOnlyZipFileFailure() throws IOException {\n+        \/\/ Underlying file is read-only.\n+        Path readOnlyZip = Utils.createJarFile(\"read_only.zip\", Map.of(\"file.txt\", \"Hello World\"));\n+        \/\/ In theory this can fail, and we should avoid unwanted false-negatives.\n+        if (readOnlyZip.toFile().setReadOnly()) {\n+            assertThrows(IOException.class,\n+                    () -> FileSystems.newFileSystem(readOnlyZip, Map.of(\"accessMode\", \"readWrite\")));\n+        }\n+    }\n+\n+    \/**\n+     * Validate that multi-release JAR is opened read-only by default if a release\n+     * version is specified.\n+     *\/\n+    @Test\n+    public void multiReleaseJarDefaultReadOnly() throws IOException {\n+        Path multiReleaseJar = createMultiReleaseJar();\n+        try (FileSystem fs = FileSystems.newFileSystem(multiReleaseJar, Map.of(\"releaseVersion\", \"1\"))) {\n+            assertTrue(fs.isReadOnly());\n+            assertEquals(\n+                    Files.readString(fs.getPath(\"file.txt\"), UTF_8),\n+                    \"First version\",\n+                    \"unexpected file content\");\n+        }\n+    }\n+\n+    \/**\n+     * Validate that multi-release JARs cannot be opened read-write if a release\n+     * version is specified.\n+     *\/\n+    @Test\n+    public void multiReleaseJarReadWriteFailure() throws IOException {\n+        Path multiReleaseJar = createMultiReleaseJar();\n+        assertThrows(IOException.class,\n+                () -> FileSystems.newFileSystem(\n+                        multiReleaseJar,\n+                        Map.of(\"accessMode\", \"readWrite\", \"releaseVersion\", \"1\")));\n+    }\n+\n+    private static Path createMultiReleaseJar() throws IOException {\n+        return Utils.createJarFile(\"multi_release.jar\", Map.of(\n+                \/\/ Newline required for attribute to be read from Manifest file.\n+                \"META-INF\/MANIFEST.MF\", \"Multi-Release: true\\n\",\n+                \"META-INF\/versions\/1\/file.txt\", \"First version\",\n+                \"META-INF\/versions\/2\/file.txt\", \"Second version\",\n+                \"file.txt\", \"Default version\"));\n+    }\n+\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/NewFileSystemTests.java","additions":98,"deletions":2,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +39,1 @@\n+import java.util.stream.Stream;\n@@ -53,0 +55,1 @@\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n@@ -55,0 +58,2 @@\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -99,0 +104,2 @@\n+    private static final Map<String, Object> ENV_READ_ONLY = Map.of(\"accessMode\", \"readOnly\");\n+    private static final Map<String, Object> ENV_POSIX_READ_ONLY = Map.of(\"enablePosixFileAttributes\", true, \"accessMode\", \"readOnly\");\n@@ -401,0 +408,31 @@\n+    private void checkReadOnlyFileSystem(FileSystem fs) throws IOException {\n+        assertTrue(fs.isReadOnly(), \"File system should be read-only\");\n+        Path root = fs.getPath(\"\/\");\n+\n+        \/\/ Rather than calling something like \"addOwnerRead(root)\", we walk all\n+        \/\/ files to ensure that all operations fail, not some arbitrary first one.\n+        Set<PosixFilePermission> badPerms = Set.of(OTHERS_EXECUTE, OTHERS_WRITE);\n+        FileTime anyTime = FileTime.from(Instant.now());\n+        try (Stream<Path> paths = Files.walk(root)) {\n+            paths.forEach(p -> {\n+                assertFalse(Files.isWritable(p), \"File should not be writable: \" + p);\n+                assertSame(fs, p.getFileSystem());\n+                assertThrows(\n+                        AccessDeniedException.class,\n+                        () -> fs.provider().checkAccess(p, AccessMode.WRITE));\n+                assertThrows(\n+                        ReadOnlyFileSystemException.class,\n+                        () -> fs.provider().setAttribute(p, \"zip:permissions\", badPerms));\n+\n+                \/\/ These fail because there is not corresponding File for a zip path (they will\n+                \/\/ currently fail for read-write ZIP file systems too, but we sanity-check here).\n+                assertThrows(UnsupportedOperationException.class,\n+                        () -> Files.setLastModifiedTime(p, anyTime));\n+                assertThrows(UnsupportedOperationException.class,\n+                        () -> Files.setAttribute(p, \"zip:permissions\", badPerms));\n+                assertThrows(UnsupportedOperationException.class,\n+                        () -> Files.setPosixFilePermissions(p, badPerms));\n+            });\n+        }\n+    }\n+\n@@ -443,0 +481,19 @@\n+    \/**\n+     * As {@code testDefault()} but with {@code \"accessMode\"=\"readOnly\"}.\n+     *\/\n+    @Test\n+    public void testDefaultReadOnly() throws IOException {\n+        \/\/ create zip file using zipfs with default option\n+        createTestZipFile(ZIP_FILE, ENV_DEFAULT).close();\n+        \/\/ check entries on zipfs with read-only options\n+        try (FileSystem zip = FileSystems.newFileSystem(ZIP_FILE, ENV_READ_ONLY)) {\n+            checkEntries(zip, checkExpects.permsInZip);\n+            checkReadOnlyFileSystem(zip);\n+        }\n+        \/\/ check entries on zipfs with posix and read-only options\n+        try (FileSystem zip = FileSystems.newFileSystem(ZIP_FILE, ENV_POSIX_READ_ONLY)) {\n+            checkEntries(zip, checkExpects.permsPosix);\n+            checkReadOnlyFileSystem(zip);\n+        }\n+    }\n+\n@@ -463,0 +520,19 @@\n+    \/**\n+     * As {@code testPosix()} but with {@code \"accessMode\"=\"readOnly\"}.\n+     *\/\n+    @Test\n+    public void testPosixReadOnly() throws IOException {\n+        \/\/ create zip file using zipfs with posix option\n+        createTestZipFile(ZIP_FILE, ENV_POSIX).close();\n+        \/\/ check entries on zipfs with read-only options\n+        try (FileSystem zip = FileSystems.newFileSystem(ZIP_FILE, ENV_READ_ONLY)) {\n+            checkEntries(zip, checkExpects.permsInZip);\n+            checkReadOnlyFileSystem(zip);\n+        }\n+        \/\/ check entries on zipfs with posix and read-only options\n+        try (FileSystem zip = FileSystems.newFileSystem(ZIP_FILE, ENV_POSIX_READ_ONLY)) {\n+            checkEntries(zip, checkExpects.permsPosix);\n+            checkReadOnlyFileSystem(zip);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/TestPosix.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,3 @@\n-import java.nio.file.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n@@ -31,0 +33,2 @@\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n@@ -32,1 +36,1 @@\n- * Utility class for zipfs tests.\n+ * Utility class for {@code ZipFileSystem} tests.\n@@ -34,3 +38,2 @@\n-\n-class Utils {\n-    private Utils() { }\n+final class Utils {\n+    private Utils() {}\n@@ -39,1 +42,2 @@\n-     * Creates a JAR file of the given name with 0 or more named entries.\n+     * Creates a JAR file of the given name with 0 or more named entries with\n+     * random content.\n@@ -41,1 +45,7 @@\n-     * @return Path to the newly created JAR file\n+     * <p>If an existing file of the same name already exists, it is silently\n+     * overwritten.\n+     *\n+     * @param name the file name of the jar file to create in the working directory.\n+     * @param entries entries JAR file entry names, whose content will be populated\n+     *                with random bytes\n+     * @return the absolute path to the newly created JAR file.\n@@ -44,1 +54,1 @@\n-        Path jarFile = Paths.get(\"basic.jar\");\n+        Path jarFile = Path.of(name);\n@@ -59,1 +69,27 @@\n-        return jarFile;\n+        return jarFile.toAbsolutePath();\n+    }\n+\n+    \/**\n+     * Creates a JAR file of the given name with 0 or more entries with specified\n+     * content.\n+     *\n+     * <p>If an existing file of the same name already exists, it is silently\n+     * overwritten.\n+     *\n+     * @param name the file name of the jar file to create in the working directory.\n+     * @param entries a map of JAR file entry names to entry content (stored as\n+     *                UTF-8 encoded bytes).\n+     * @return the absolute path to the newly created JAR file.\n+     *\/\n+    static Path createJarFile(String name, Map<String, String> entries) throws IOException {\n+        Path jarFile = Path.of(name);\n+        try (OutputStream out = Files.newOutputStream(jarFile);\n+             JarOutputStream jout = new JarOutputStream(out)) {\n+            for (var entry : entries.entrySet()) {\n+                JarEntry je = new JarEntry(entry.getKey());\n+                jout.putNextEntry(je);\n+                jout.write(entry.getValue().getBytes(UTF_8));\n+                jout.closeEntry();\n+            }\n+        }\n+        return jarFile.toAbsolutePath();\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/Utils.java","additions":46,"deletions":10,"binary":false,"changes":56,"status":"modified"}]}