{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-\n@@ -32,0 +31,1 @@\n+    private static final int OTHER_THREAD_INDEX = -99;\n@@ -33,2 +33,4 @@\n-    private long[] elts;\n-    private int used = 0;\n+    private final int initialCapacity;\n+    private long[] threads;             \/\/ array of thread handles, created lazily\n+    private int used;                   \/\/ number of thread handles in threads array\n+    private int otherThreads;           \/\/ count of threads without a native thread handle\n@@ -38,1 +40,1 @@\n-        elts = new long[n];\n+        initialCapacity = n;\n@@ -42,1 +44,1 @@\n-     * Adds the current native thread to this set, returning its index so that\n+     * Adds the current thread handle to this set, returning an index so that\n@@ -46,4 +48,1 @@\n-        long th = NativeThread.currentNativeThread();\n-        \/\/ 0 and -1 are treated as placeholders, not real thread handles\n-        if (th == 0)\n-            th = -1;\n+        long th = NativeThread.current();\n@@ -51,0 +50,6 @@\n+            if (!NativeThread.isNativeThread(th)) {\n+                otherThreads++;\n+                return OTHER_THREAD_INDEX;\n+            }\n+\n+            \/\/ add native thread handle to array, creating or growing array if needed\n@@ -52,2 +57,4 @@\n-            if (used >= elts.length) {\n-                int on = elts.length;\n+            if (threads == null) {\n+                threads = new long[initialCapacity];\n+            } else if (used >= threads.length) {\n+                int on = threads.length;\n@@ -55,3 +62,3 @@\n-                long[] nelts = new long[nn];\n-                System.arraycopy(elts, 0, nelts, 0, on);\n-                elts = nelts;\n+                long[] nthreads = new long[nn];\n+                System.arraycopy(threads, 0, nthreads, 0, on);\n+                threads = nthreads;\n@@ -60,3 +67,3 @@\n-            for (int i = start; i < elts.length; i++) {\n-                if (elts[i] == 0) {\n-                    elts[i] = th;\n+            for (int i = start; i < threads.length; i++) {\n+                if (threads[i] == 0) {\n+                    threads[i] = th;\n@@ -67,2 +74,1 @@\n-            assert false;\n-            return -1;\n+            throw new InternalError();\n@@ -70,1 +76,0 @@\n-\n@@ -74,1 +79,1 @@\n-     * Removes the thread at the give index.\n+     * Removes the thread at the given index. A no-op if index is -1.\n@@ -78,4 +83,11 @@\n-            assert (elts[i] == NativeThread.currentNativeThread()) || (elts[i] == -1);\n-            elts[i] = 0;\n-            used--;\n-            if (used == 0 && waitingToEmpty)\n+            if (i >= 0) {\n+                assert threads[i] == NativeThread.current();\n+                threads[i] = 0;\n+                used--;\n+            } else if (i == OTHER_THREAD_INDEX) {\n+                otherThreads--;\n+            } else {\n+                assert i == -1;\n+                return;\n+            }\n+            if (used == 0 && otherThreads == 0 && waitingToEmpty) {\n@@ -83,0 +95,1 @@\n+            }\n@@ -86,2 +99,3 @@\n-    \/\/ Signals all threads in this set.\n-    \/\/\n+    \/**\n+     * Signals all native threads in the thread set and wait for the thread set to empty.\n+     *\/\n@@ -90,8 +104,5 @@\n-        while (used > 0) {\n-            int u = used;\n-            int n = elts.length;\n-            for (int i = 0; i < n; i++) {\n-                long th = elts[i];\n-                if (th == 0)\n-                    continue;\n-                if (th != -1)\n+        while (used > 0 || otherThreads > 0) {\n+            int u = used, i = 0;\n+            while (u > 0 && i < threads.length) {\n+                long th = threads[i];\n+                if (th != 0) {\n@@ -99,2 +110,3 @@\n-                if (--u == 0)\n-                    break;\n+                    u--;\n+                }\n+                i++;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NativeThreadSet.java","additions":50,"deletions":38,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,8 +55,0 @@\n-    \/**\n-     * Returns the id of the current native thread if the platform can signal\n-     * native threads, 0 if the platform can not signal native threads.\n-     *\/\n-    static long currentNativeThread() {\n-        return current0();\n-    }\n-\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/NativeThread.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,8 +48,0 @@\n-    \/**\n-     * Returns the id of the current native thread if the platform can signal\n-     * native threads, 0 if the platform can not signal native threads.\n-     *\/\n-    static long currentNativeThread() {\n-        return 0;\n-    }\n-\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/NativeThread.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"}]}