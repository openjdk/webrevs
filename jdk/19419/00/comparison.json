{"files":[{"patch":"@@ -38,3 +38,0 @@\n-  \/\/ Values returned by the iterate() methods.\n-  enum IterationStatus { incomplete, complete, full };\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/parMarkBitMap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2627,2 +2627,1 @@\n-MoveAndUpdateClosure::IterationStatus\n-MoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n+void MoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n@@ -2651,1 +2650,0 @@\n-  return is_full() ? ParMarkBitMap::full : ParMarkBitMap::incomplete;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -907,1 +907,0 @@\n-  typedef ParMarkBitMap::IterationStatus IterationStatus;\n@@ -917,4 +916,2 @@\n-  \/\/ destination, update the interior oops and the start array and return either\n-  \/\/ full (if the closure is full) or incomplete.  If the object will not fit,\n-  \/\/ return would_overflow.\n-  virtual IterationStatus do_addr(HeapWord* addr, size_t words);\n+  \/\/ destination, update the interior oops and the start array.\n+  void do_addr(HeapWord* addr, size_t words);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"}]}