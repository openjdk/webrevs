{"files":[{"patch":"@@ -39,1 +39,1 @@\n-  _reserved(heap), _offset_array(nullptr) {\n+  _reserved(heap), _offset_base(nullptr) {\n@@ -43,1 +43,1 @@\n-  _offset_array = (u_char*)bot_reserved.start();\n+  _offset_base = ((u_char*)bot_reserved.start() - (uintptr_t(_reserved.start()) >> CardTable::card_shift()));\n@@ -51,6 +51,8 @@\n-void G1BlockOffsetTable::check_index(size_t index, const char* msg) const {\n-  assert((index) < (_reserved.word_size() >> CardTable::card_shift_in_words()),\n-         \"%s - index: \" SIZE_FORMAT \", _vs.committed_size: \" SIZE_FORMAT,\n-         msg, (index), (_reserved.word_size() >> CardTable::card_shift_in_words()));\n-  assert(G1CollectedHeap::heap()->is_in(address_for_index_raw(index)),\n-         \"Index \" SIZE_FORMAT \" corresponding to \" PTR_FORMAT\n+void G1BlockOffsetTable::check_address(u_char* addr, const char* msg) const {\n+  u_char* start_addr = const_cast<u_char *>(_offset_base + (uintptr_t(_reserved.start()) >> CardTable::card_shift()));\n+  u_char* end_addr = const_cast<u_char *>(_offset_base + (uintptr_t(_reserved.end()) >> CardTable::card_shift()));\n+  assert(addr >= start_addr && addr <= end_addr,\n+         \"%s - offset address: \" PTR_FORMAT \", start address: \" PTR_FORMAT \", end address: \" PTR_FORMAT,\n+         msg, (p2i(addr)), (p2i(start_addr)), (p2i(end_addr)));\n+  assert(G1CollectedHeap::heap()->is_in(addr_for_entry(addr)),\n+         \"Offset address \" PTR_FORMAT \" corresponding to \" PTR_FORMAT\n@@ -58,3 +60,2 @@\n-         (index),\n-         p2i(address_for_index_raw(index)),\n-         G1CollectedHeap::heap()->addr_to_region(address_for_index_raw(index)));\n+         (p2i(addr)), p2i(addr_for_entry(addr)),\n+         G1CollectedHeap::heap()->addr_to_region(addr_for_entry(addr)));\n@@ -70,3 +71,1 @@\n-  _hr(hr)\n-{\n-}\n+  _hr(hr) {}\n@@ -99,1 +98,0 @@\n-\/\/      Find the index for the address\n@@ -107,1 +105,1 @@\n-void G1BlockOffsetTablePart::set_remainder_to_point_to_start_incl(size_t start_card, size_t end_card) {\n+void G1BlockOffsetTablePart::set_remainder_to_point_to_start_incl(u_char* start_card, u_char* end_card) {\n@@ -109,1 +107,1 @@\n-  assert(start_card > _bot->index_for(_hr->bottom()), \"Cannot be first card\");\n+  assert(start_card > _bot->entry_for_addr(_hr->bottom()), \"Cannot be first card\");\n@@ -112,1 +110,1 @@\n-  size_t start_card_for_region = start_card;\n+  u_char* start_card_for_region = start_card;\n@@ -118,1 +116,1 @@\n-    size_t reach = start_card - 1 + (BOTConstants::power_to_cards_back(i+1) - 1);\n+    u_char* reach = start_card - 1 + (BOTConstants::power_to_cards_back(i+1) - 1);\n@@ -136,2 +134,1 @@\n-void G1BlockOffsetTablePart::check_all_cards(size_t start_card, size_t end_card) const {\n-\n+void G1BlockOffsetTablePart::check_all_cards(u_char* start_card, u_char* end_card) const {\n@@ -142,1 +139,1 @@\n-  for (size_t c = start_card + 1; c <= end_card; c++ \/* yeah! *\/) {\n+  for (u_char* c = start_card + 1; c <= end_card; c++ \/* yeah! *\/) {\n@@ -144,1 +141,1 @@\n-    if (c - start_card > BOTConstants::power_to_cards_back(1)) {\n+    if ((unsigned)(c - start_card) > BOTConstants::power_to_cards_back(1)) {\n@@ -153,1 +150,1 @@\n-    size_t landing_card = c - backskip;\n+    u_char* landing_card = c - backskip;\n@@ -185,1 +182,1 @@\n-  size_t const index =  _bot->index_for_raw(cur_card_boundary);\n+  u_char* const offset_card =  _bot->entry_for_addr(cur_card_boundary);\n@@ -197,2 +194,2 @@\n-  assert(cur_card_boundary == _bot->_reserved.start() + index * CardTable::card_size_in_words(),\n-         \"index must agree with cur_card_boundary\");\n+  assert(cur_card_boundary == _bot->addr_for_entry(offset_card),\n+         \"Block offset table entry must agree with cur_card_boundary\");\n@@ -201,1 +198,1 @@\n-  _bot->set_offset_array(index, cur_card_boundary, blk_start);\n+  _bot->set_offset_array(offset_card, cur_card_boundary, blk_start);\n@@ -206,1 +203,1 @@\n-  size_t end_index = _bot->index_for(blk_end - 1);\n+  u_char* end_card = _bot->entry_for_addr(blk_end - 1);\n@@ -209,2 +206,2 @@\n-  if (index + 1 <= end_index) {\n-    set_remainder_to_point_to_start_incl(index + 1, end_index);\n+  if (offset_card + 1 <= end_card) {\n+    set_remainder_to_point_to_start_incl(offset_card + 1, end_card);\n@@ -216,1 +213,1 @@\n-  HeapWord* new_card_boundary = _bot->address_for_index(end_index) + CardTable::card_size_in_words();\n+  HeapWord* new_card_boundary = _bot->addr_for_entry(end_card) + CardTable::card_size_in_words();\n@@ -221,4 +218,4 @@\n-  size_t start_index = _bot->index_for(blk_start);\n-  HeapWord* boundary = _bot->address_for_index(start_index);\n-  assert((_bot->offset_array(index) == 0 && blk_start == boundary) ||\n-         (_bot->offset_array(index) > 0 && _bot->offset_array(index) < CardTable::card_size_in_words()),\n+  u_char* previous_card = _bot->entry_for_addr(blk_start);\n+  HeapWord* boundary = _bot->addr_for_entry(previous_card);\n+  assert((_bot->offset_array(offset_card) == 0 && blk_start == boundary) ||\n+         (_bot->offset_array(offset_card) > 0 && _bot->offset_array(offset_card) < CardTable::card_size_in_words()),\n@@ -229,1 +226,1 @@\n-         (uint)_bot->offset_array(index),\n+         (uint)_bot->offset_array(offset_card),\n@@ -231,1 +228,1 @@\n-  for (size_t j = index + 1; j <= end_index; j++) {\n+  for (u_char* j = offset_card + 1; j <= end_card; j++) {\n@@ -246,2 +243,2 @@\n-  size_t start_card = _bot->index_for(_hr->bottom());\n-  size_t end_card = _bot->index_for(_hr->top() - 1);\n+  u_char* start_card = _bot->entry_for_addr(_hr->bottom());\n+  u_char* end_card = _bot->entry_for_addr(_hr->top() - 1);\n@@ -249,1 +246,1 @@\n-  for (size_t current_card = start_card; current_card < end_card; current_card++) {\n+  for (u_char* current_card = start_card; current_card < end_card; current_card++) {\n@@ -255,1 +252,1 @@\n-      HeapWord* card_address = _bot->address_for_index(current_card);\n+      HeapWord* card_address = _bot->addr_for_entry(current_card);\n@@ -275,1 +272,1 @@\n-                start_card, current_card, backskip);\n+                p2i(start_card), p2i(current_card), backskip);\n@@ -277,1 +274,1 @@\n-      HeapWord* backskip_address = _bot->address_for_index(current_card - backskip);\n+      HeapWord* backskip_address = _bot->addr_for_entry(current_card - backskip);\n@@ -287,2 +284,2 @@\n-  size_t from_index = _bot->index_for(_hr->bottom());\n-  size_t to_index = _bot->index_for(_hr->end());\n+  u_char* from_card = _bot->entry_for_addr(_hr->bottom());\n+  u_char* to_card = _bot->entry_for_addr(_hr->end());\n@@ -291,2 +288,2 @@\n-                p2i(_hr->bottom()), p2i(_hr->end()), from_index, to_index);\n-  for (size_t i = from_index; i < to_index; ++i) {\n+                p2i(_hr->bottom()), p2i(_hr->end()), p2i(from_card), p2i(to_card));\n+  for (u_char* i = from_card; i < to_card; ++i) {\n@@ -294,1 +291,1 @@\n-                  i, p2i(_bot->address_for_index(i)),\n+                  p2i(i), p2i(_bot->addr_for_entry(i)),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.cpp","additions":46,"deletions":49,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -54,3 +54,2 @@\n-  \/\/ Array for keeping offsets for retrieving object start fast given an\n-  \/\/ address.\n-  volatile u_char* _offset_array;  \/\/ byte array keeping backwards offsets\n+  \/\/ Biased array-start of BOT array for fast BOT entry translation\n+  volatile u_char* _offset_base;\n@@ -66,1 +65,1 @@\n-  inline u_char offset_array(size_t index) const;\n+  inline u_char offset_array(u_char* addr) const;\n@@ -68,2 +67,2 @@\n-  inline void set_offset_array_raw(size_t index, u_char offset);\n-  inline void set_offset_array(size_t index, u_char offset);\n+  inline void set_offset_array_raw(u_char* addr, u_char offset);\n+  inline void set_offset_array(u_char* addr, u_char offset);\n@@ -71,1 +70,1 @@\n-  inline void set_offset_array(size_t index, HeapWord* high, HeapWord* low);\n+  inline void set_offset_array(u_char* addr, HeapWord* high, HeapWord* low);\n@@ -73,1 +72,1 @@\n-  inline void set_offset_array(size_t left, size_t right, u_char offset);\n+  inline void set_offset_array(u_char* left, u_char* right, u_char offset);\n@@ -75,1 +74,1 @@\n-  void check_index(size_t index, const char* msg) const NOT_DEBUG_RETURN;\n+  void check_address(u_char* addr, const char* msg) const NOT_DEBUG_RETURN;\n@@ -95,3 +94,2 @@\n-  \/\/ Return the appropriate index into \"_offset_array\" for \"p\".\n-  inline size_t index_for(const void* p) const;\n-  inline size_t index_for_raw(const void* p) const;\n+  \/\/ Mapping from address to object start array entry\n+  u_char* entry_for_addr(const void* const p) const;\n@@ -99,7 +97,2 @@\n-  \/\/ Return the address indicating the start of the region corresponding to\n-  \/\/ \"index\" in \"_offset_array\".\n-  inline HeapWord* address_for_index(size_t index) const;\n-  \/\/ Variant of address_for_index that does not check the index for validity.\n-  inline HeapWord* address_for_index_raw(size_t index) const {\n-    return _reserved.start() + (index << CardTable::card_shift_in_words());\n-  }\n+  \/\/ Mapping from object start array entry to address of first word\n+  HeapWord* addr_for_entry(const u_char* const p) const;\n@@ -120,1 +113,1 @@\n-  void set_remainder_to_point_to_start_incl(size_t start, size_t end);\n+  void set_remainder_to_point_to_start_incl(u_char* start, u_char* end);\n@@ -125,1 +118,1 @@\n-  void check_all_cards(size_t left_card, size_t right_card) const NOT_DEBUG_RETURN;\n+  void check_all_cards(u_char* left_card, u_char* right_card) const NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":14,"deletions":21,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-    u_char offset = _bot->offset_array(_bot->index_for(_hr->bottom()));\n+    u_char offset = _bot->offset_array(_bot->entry_for_addr(_hr->bottom()));\n@@ -47,3 +47,2 @@\n-  size_t index = _bot->index_for(addr);\n-\n-  u_char offset = _bot->offset_array(index);\n+  u_char* entry = _bot->entry_for_addr(addr);\n+  u_char offset = _bot->offset_array(entry);\n@@ -54,2 +53,2 @@\n-    index -= n_cards_back;\n-    offset = _bot->offset_array(index);\n+    entry -= n_cards_back;\n+    offset = _bot->offset_array(entry);\n@@ -58,2 +57,1 @@\n-\n-  HeapWord* q = _bot->address_for_index(index);\n+  HeapWord* q = _bot->addr_for_entry(entry);\n@@ -63,3 +61,3 @@\n-u_char G1BlockOffsetTable::offset_array(size_t index) const {\n-  check_index(index, \"index out of range\");\n-  return Atomic::load(&_offset_array[index]);\n+u_char G1BlockOffsetTable::offset_array(u_char* addr) const {\n+  check_address(addr, \"Block offset table address out of range\");\n+  return Atomic::load(addr);\n@@ -68,2 +66,2 @@\n-void G1BlockOffsetTable::set_offset_array_raw(size_t index, u_char offset) {\n-  Atomic::store(&_offset_array[index], offset);\n+void G1BlockOffsetTable::set_offset_array_raw(u_char* addr, u_char offset) {\n+  Atomic::store(addr, offset);\n@@ -72,3 +70,3 @@\n-void G1BlockOffsetTable::set_offset_array(size_t index, u_char offset) {\n-  check_index(index, \"index out of range\");\n-  set_offset_array_raw(index, offset);\n+void G1BlockOffsetTable::set_offset_array(u_char* addr, u_char offset) {\n+  check_address(addr, \"Block offset table address out of range\");\n+  set_offset_array_raw(addr, offset);\n@@ -77,2 +75,2 @@\n-void G1BlockOffsetTable::set_offset_array(size_t index, HeapWord* high, HeapWord* low) {\n-  check_index(index, \"index out of range\");\n+void G1BlockOffsetTable::set_offset_array(u_char* addr, HeapWord* high, HeapWord* low) {\n+  check_address(addr, \"Block offset table address out of range\");\n@@ -82,1 +80,1 @@\n-  set_offset_array(index, (u_char)offset);\n+  set_offset_array(addr, (u_char)offset);\n@@ -85,2 +83,2 @@\n-void G1BlockOffsetTable::set_offset_array(size_t left, size_t right, u_char offset) {\n-  check_index(right, \"right index out of range\");\n+void G1BlockOffsetTable::set_offset_array(u_char* left, u_char* right, u_char offset) {\n+  check_address(right, \"Right block offset table address out of range\");\n@@ -90,6 +88,1 @@\n-    (const_cast<u_char*> (&_offset_array[left]), offset, num_cards);\n-}\n-\n-\/\/ Variant of index_for that does not check the index for validity.\n-inline size_t G1BlockOffsetTable::index_for_raw(const void* p) const {\n-  return pointer_delta((char*)p, _reserved.start(), sizeof(char)) >> CardTable::card_shift();\n+    (const_cast<u_char*> (left), offset, num_cards);\n@@ -98,8 +91,4 @@\n-inline size_t G1BlockOffsetTable::index_for(const void* p) const {\n-  char* pc = (char*)p;\n-  assert(pc >= (char*)_reserved.start() &&\n-         pc <  (char*)_reserved.end(),\n-         \"p (\" PTR_FORMAT \") not in reserved [\" PTR_FORMAT \", \" PTR_FORMAT \")\",\n-         p2i(p), p2i(_reserved.start()), p2i(_reserved.end()));\n-  size_t result = index_for_raw(p);\n-  check_index(result, \"bad index from address\");\n+inline u_char* G1BlockOffsetTable::entry_for_addr(const void* const p) const {\n+  assert(_reserved.contains(p),\n+         \"out of bounds access to block offset table\");\n+  u_char* result = const_cast<u_char *>(&_offset_base[uintptr_t(p) >> CardTable::card_shift()]);\n@@ -109,7 +98,5 @@\n-inline HeapWord* G1BlockOffsetTable::address_for_index(size_t index) const {\n-  check_index(index, \"index out of range\");\n-  HeapWord* result = address_for_index_raw(index);\n-  assert(result >= _reserved.start() && result < _reserved.end(),\n-         \"bad address from index result \" PTR_FORMAT\n-         \" _reserved.start() \" PTR_FORMAT \" _reserved.end() \" PTR_FORMAT,\n-         p2i(result), p2i(_reserved.start()), p2i(_reserved.end()));\n+inline HeapWord* G1BlockOffsetTable::addr_for_entry(const u_char* const p) const {\n+  size_t delta = pointer_delta(p, _offset_base, sizeof(u_char));\n+  HeapWord* result = (HeapWord*) (delta << CardTable::card_shift());\n+  assert(_reserved.contains(result),\n+         \"out of bounds accessor from block offset table\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":29,"deletions":42,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -534,1 +534,1 @@\n-    HeapWord* scan_end = MIN2(card_start + (num_cards << CardTable::card_shift_in_words()), top);\n+    HeapWord* scan_end = MIN2(card_start + (num_cards << (CardTable::card_shift() - LogHeapWordSize)), top);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,9 +48,2 @@\n-\n-  uint8_t offset;\n-  while (true) {\n-    offset = *entry;\n-\n-    if (offset < CardTable::card_size_in_words()) {\n-      break;\n-    }\n-\n+  uint8_t offset = *entry;\n+  while (offset >= CardTable::card_size_in_words()) {\n@@ -61,0 +54,1 @@\n+    offset = *entry;\n@@ -62,1 +56,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.inline.hpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  _offset_array = (uint8_t*)_vs.low_boundary();\n+  _offset_base = (uint8_t*)(_vs.low_boundary() - (uintptr_t(reserved.start()) >> CardTable::card_shift()));\n@@ -105,1 +105,0 @@\n-\/\/      Find the index for the address\n@@ -116,1 +115,1 @@\n-  size_t const offset_card = _array->index_for(cur_card_boundary);\n+  uint8_t* const offset_card = _array->entry_for_addr(cur_card_boundary);\n@@ -122,1 +121,1 @@\n-  size_t end_card = _array->index_for(blk_end - 1);\n+  uint8_t* end_card = _array->entry_for_addr(blk_end - 1);\n@@ -127,1 +126,1 @@\n-    size_t start_card_for_region = offset_card + 1;\n+    uint8_t* start_card_for_region = offset_card + 1;\n@@ -131,1 +130,1 @@\n-      size_t reach = offset_card + BOTConstants::power_to_cards_back(i + 1) - 1;\n+      uint8_t* reach = offset_card + BOTConstants::power_to_cards_back(i + 1) - 1;\n@@ -148,10 +147,3 @@\n-  size_t index = _array->index_for(addr);\n-\n-  uint8_t offset;\n-  while (true) {\n-    offset = _array->offset_array(index);\n-\n-    if (offset < CardTable::card_size_in_words()) {\n-      break;\n-    }\n-\n+  uint8_t* entry = _array->entry_for_addr(addr);\n+  uint8_t offset = *entry;\n+  while (offset >= CardTable::card_size_in_words()) {\n@@ -161,1 +153,2 @@\n-    index -= n_cards_back;\n+    entry -= n_cards_back;\n+    offset = *entry;\n@@ -163,2 +156,1 @@\n-\n-  HeapWord* q = _array->address_for_index(index);\n+  HeapWord* q = _array->addr_for_entry(entry);\n@@ -171,2 +163,2 @@\n-  const size_t start_card = _array->index_for(align_up_by_card_size(blk_start));\n-  const size_t end_card = _array->index_for(blk_end - 1);\n+  uint8_t* start_card = _array->entry_for_addr(align_up_by_card_size(blk_start));\n+  uint8_t* end_card = _array->entry_for_addr(blk_end - 1);\n@@ -174,8 +166,8 @@\n-  assert(_array->offset_array(start_card) < CardTable::card_size_in_words(), \"offset card\");\n-\n-  for (size_t i = start_card + 1; i <= end_card; ++i) {\n-    const uint8_t prev  = _array->offset_array(i-1);\n-    const uint8_t value = _array->offset_array(i);\n-    if (prev != value) {\n-      assert(value >= prev, \"monotonic\");\n-      size_t n_cards_back = BOTConstants::entry_to_cards_back(value);\n+  assert(*start_card < CardTable::card_size_in_words(), \"offset card\");\n+\n+  for (uint8_t* i = start_card + 1; i <= end_card; ++i) {\n+    const uint8_t* prev  = i - 1;\n+    const uint8_t* value = i;\n+    if (*prev != *value) {\n+      assert(*value >= *prev, \"monotonic\");\n+      size_t n_cards_back = BOTConstants::entry_to_cards_back(*value);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.cpp","additions":21,"deletions":29,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-  uint8_t* _offset_array;          \/\/ byte array keeping backwards offsets\n@@ -51,4 +50,2 @@\n-  void fill_range(size_t start, size_t num_cards, uint8_t offset) {\n-    void* start_ptr = &_offset_array[start];\n-    memset(start_ptr, offset, num_cards);\n-  }\n+  \/\/ Biased array-start of BOT array for fast BOT entry translation\n+  uint8_t* _offset_base;\n@@ -56,3 +53,2 @@\n-  uint8_t offset_array(size_t index) const {\n-    assert(index < _vs.committed_size(), \"index out of range\");\n-    return _offset_array[index];\n+  void fill_range(const uint8_t* const start, size_t num_cards, uint8_t offset) {\n+    memset((void *) start, offset, num_cards);\n@@ -84,2 +80,2 @@\n-  \/\/ Return the appropriate index into \"_offset_array\" for \"p\".\n-  size_t index_for(const void* p) const;\n+  \/\/ Mapping from address to object start array entry\n+  uint8_t* entry_for_addr(const void* const p) const;\n@@ -87,3 +83,2 @@\n-  \/\/ Return the address indicating the start of the region corresponding to\n-  \/\/ \"index\" in \"_offset_array\".\n-  HeapWord* address_for_index(size_t index) const;\n+  \/\/ Mapping from object start array entry to address of first word\n+  HeapWord* addr_for_entry(const uint8_t* const p) const;\n@@ -91,2 +86,2 @@\n-  void set_offset_array(size_t index, HeapWord* high, HeapWord* low) {\n-    assert(index < _vs.committed_size(), \"index out of range\");\n+  void set_offset_array(uint8_t* const addr, HeapWord* high, HeapWord* low) {\n+    assert(_vs.contains(addr), \"Block offset address out of range\");\n@@ -95,1 +90,1 @@\n-    _offset_array[index] = checked_cast<uint8_t>(pointer_delta(high, low));\n+    *addr = checked_cast<uint8_t>(pointer_delta(high, low));\n@@ -98,2 +93,2 @@\n-  void set_offset_array(size_t left, size_t right, uint8_t offset) {\n-    assert(right < _vs.committed_size(), \"right address out of range\");\n+  void set_offset_array(uint8_t* const left, uint8_t* const right, uint8_t offset) {\n+    assert(_vs.contains(right), \"right address out of range\");\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.hpp","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,8 +30,4 @@\n-inline size_t SerialBlockOffsetSharedArray::index_for(const void* p) const {\n-  char* pc = (char*)p;\n-  assert(pc >= (char*)_reserved.start() &&\n-         pc <  (char*)_reserved.end(),\n-         \"p not in range.\");\n-  size_t delta = pointer_delta(pc, _reserved.start(), sizeof(char));\n-  size_t result = delta >> CardTable::card_shift();\n-  assert(result < _vs.committed_size(), \"bad index from address\");\n+inline uint8_t* SerialBlockOffsetSharedArray::entry_for_addr(const void* const p) const {\n+  assert(_reserved.contains(p),\n+         \"out of bounds access to block offset array\");\n+  uint8_t* result = &_offset_base[uintptr_t(p) >> CardTable::card_shift()];\n@@ -41,5 +37,5 @@\n-inline HeapWord* SerialBlockOffsetSharedArray::address_for_index(size_t index) const {\n-  assert(index < _vs.committed_size(), \"bad index\");\n-  HeapWord* result = _reserved.start() + (index << CardTable::card_shift_in_words());\n-  assert(result >= _reserved.start() && result < _reserved.end(),\n-         \"bad address from index\");\n+inline HeapWord* SerialBlockOffsetSharedArray::addr_for_entry(const uint8_t* const p) const {\n+  size_t delta = pointer_delta(p, _offset_base, sizeof(uint8_t));\n+  HeapWord* result = (HeapWord*) (delta << CardTable::card_shift());\n+  assert(_reserved.contains(result),\n+         \"out of bounds accessor from block offset array\");\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.inline.hpp","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  nonstatic_field(SerialBlockOffsetSharedArray,      _offset_array,          u_char*)                       \\\n+  nonstatic_field(SerialBlockOffsetSharedArray,      _offset_base,           u_char*)                       \\\n","filename":"src\/hotspot\/share\/gc\/serial\/vmStructs_serial.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-uint CardTable::_card_shift_in_words = 0;\n@@ -54,1 +53,0 @@\n-  _card_shift_in_words = _card_shift - LogHeapWordSize;\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,1 +76,0 @@\n-  static uint _card_shift_in_words;\n@@ -186,4 +185,0 @@\n-  static uint card_shift_in_words() {\n-    return _card_shift_in_words;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}