{"files":[{"patch":"@@ -1414,1 +1414,0 @@\n-  Node *pre_header= main_head->in(LoopNode::EntryControl);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1165,0 +1165,1 @@\n+  Node* const _new_init;\n@@ -1168,0 +1169,1 @@\n+                                 Node* new_init,\n@@ -1171,1 +1173,2 @@\n-      _phase(phase) {\n+      _phase(phase),\n+      _new_init(new_init) {\n@@ -1183,1 +1186,1 @@\n-    _clone_predicate_to_loop.clone_template_assertion_predicate(template_assertion_predicate);\n+    _clone_predicate_to_loop.clone_template_assertion_predicate_and_replace_init(template_assertion_predicate, _new_init);\n@@ -1188,0 +1191,21 @@\n+\/\/ For an int counted loop, try_make_short_running_loop() transforms the loop from:\n+\/\/     for (int = start; i < stop; i+= stride) { ... }\n+\/\/ to\n+\/\/     for (int = 0; i < stop - start; i+= stride) { ... }\n+\/\/ Template Assertion Predicates added so far were with an init value of start. They need to be updated with the new\n+\/\/ init value of 0 (otherwise when a template assertion predicate is turned into an initialized assertion predicate, it\n+\/\/ performs an incorrect check):\n+\/\/                                zero\n+\/\/        init                     |\n+\/\/         |           ===>   OpaqueLoopInit   init\n+\/\/  OpaqueLoopInit                         \\   \/\n+\/\/                                          AddI\n+\/\/\n+Node* PhaseIdealLoop::new_assertion_predicate_opaque_init(Node* entry_control, Node* init, Node* int_zero) {\n+  OpaqueLoopInitNode* new_opaque_init = new OpaqueLoopInitNode(C, int_zero);\n+  register_new_node(new_opaque_init, entry_control);\n+  Node* new_init = new AddINode(new_opaque_init, init);\n+  register_new_node(new_init, entry_control);\n+  return new_init;\n+}\n+\n@@ -1239,0 +1263,1 @@\n+  Node* int_zero = intcon(0);\n@@ -1264,0 +1289,2 @@\n+    Node* new_init = new_assertion_predicate_opaque_init(entry_control, init, int_zero);\n+\n@@ -1266,1 +1293,1 @@\n-    CloneShortLoopPredicateVisitor clone_short_loop_predicates_visitor(head, node_in_short_loop_body, this);\n+    CloneShortLoopPredicateVisitor clone_short_loop_predicates_visitor(head, new_init, node_in_short_loop_body, this);\n@@ -1314,0 +1341,4 @@\n+    PredicateIterator predicate_iterator(entry_control);\n+    Node* new_init = new_assertion_predicate_opaque_init(entry_control, init, int_zero);\n+    UpdateInitForTemplateAssertionPredicates update_init_for_template_assertion_predicates(new_init, this);\n+    predicate_iterator.for_each(update_init_for_template_assertion_predicates);\n@@ -1323,1 +1354,0 @@\n-  Node* int_zero = intcon(0);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":34,"deletions":4,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1966,0 +1966,2 @@\n+  Node* new_assertion_predicate_opaque_init(Node* entry_control, Node* init, Node* int_zero);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2179,1 +2179,4 @@\n-  virtual void target_node_action(Node* target_node) = 0;\n+  \/\/ To give more freedom, we pass the direct child node to the target node such that\n+  \/\/ child->in(i) == target node. This allows to also directly replace the target node instead\n+  \/\/ of only updating its inputs.\n+  virtual void target_node_action(Node* child, uint i) = 0;\n@@ -2201,1 +2204,1 @@\n-          _bfs_actions.target_node_action(input);\n+          _bfs_actions.target_node_action(next, j);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -201,1 +201,0 @@\n-  DEBUG_ONLY(verify();)\n@@ -204,0 +203,10 @@\n+  return clone_and_replace_init(new_control, new_opaque_init, new_loop_node, phase);\n+}\n+\n+\/\/ Clone this Template Assertion Predicate and replace the old OpaqueLoopInit node with 'new_init'.\n+\/\/ Note: 'new_init' could also have the 'OpaqueLoopInit` as parent node further up.\n+TemplateAssertionPredicate TemplateAssertionPredicate::clone_and_replace_init(Node* new_control,\n+                                                                              Node* new_init,\n+                                                                              CountedLoopNode* new_loop_node,\n+                                                                              PhaseIdealLoop* phase) const {\n+  DEBUG_ONLY(verify();)\n@@ -206,1 +215,1 @@\n-      template_assertion_expression.clone_and_replace_init(new_control, new_opaque_init, new_loop_node);\n+      template_assertion_expression.clone_and_replace_init(new_control, new_init, new_loop_node);\n@@ -241,2 +250,34 @@\n-  void target_node_action(Node* target_node) override {\n-    _igvn.replace_input_of(target_node, 1, _new_opaque_stride_input);\n+  void target_node_action(Node* child, uint i) override {\n+    assert(child->in(i)->is_OpaqueLoopStride(), \"must be OpaqueLoopStride\");\n+    _igvn.replace_input_of(child->in(i), 1, _new_opaque_stride_input);\n+  }\n+};\n+\n+\/\/ This class is used to replace the OpaqueLoopInitNode with a new node while leaving the other nodes\n+\/\/ unchanged.\n+class ReplaceOpaqueInitNode : public BFSActions {\n+  Node* _new_opaque_init_node;\n+  PhaseIterGVN& _igvn;\n+\n+  public:\n+  ReplaceOpaqueInitNode(Node* new_opaque_init_node, PhaseIterGVN& igvn)\n+      : _new_opaque_init_node(new_opaque_init_node),\n+        _igvn(igvn) {}\n+  NONCOPYABLE(ReplaceOpaqueInitNode);\n+\n+  void replace_for(OpaqueTemplateAssertionPredicateNode* opaque_node) {\n+    DataNodeBFS bfs(*this);\n+    bfs.run(opaque_node);\n+  }\n+\n+  bool should_visit(Node* node) const override {\n+    return TemplateAssertionExpressionNode::is_maybe_in_expression(node);\n+  }\n+\n+  bool is_target_node(Node* node) const override {\n+    return node->is_OpaqueLoopInit();\n+  }\n+\n+  void target_node_action(Node* child, uint i) override {\n+    assert(child->in(i)->is_OpaqueLoopInit(), \"must be old OpaqueLoopInit\");\n+    _igvn.replace_input_of(child, i, _new_opaque_init_node);\n@@ -253,0 +294,7 @@\n+\/\/ Replace the OpaqueLoopInitNode with 'new_init' and leave the other nodes unchanged.\n+void TemplateAssertionPredicate::replace_opaque_init_node(Node* new_init, PhaseIterGVN& igvn) const {\n+  DEBUG_ONLY(verify();)\n+  ReplaceOpaqueInitNode replace_opaque_init_node(new_init, igvn);\n+  replace_opaque_init_node.replace_for(opaque_node());\n+}\n+\n@@ -311,1 +359,2 @@\n-  void target_node_action(Node* target_node) override {\n+  void target_node_action(Node* child, uint i) override {\n+    Node* target_node = child->in(i);\n@@ -1097,0 +1146,12 @@\n+\/\/ Clones the provided Template Assertion Predicate to the head of the current predicate chain at the target loop and\n+\/\/ replaces the current OpaqueLoopInit with 'new_init'.\n+\/\/  Note: 'new_init' could also have the 'OpaqueLoopInit` as parent node further up.\n+void ClonePredicateToTargetLoop::clone_template_assertion_predicate_and_replace_init(\n+    const TemplateAssertionPredicate& template_assertion_predicate, Node* new_init) {\n+  TemplateAssertionPredicate cloned_template_assertion_predicate =\n+      template_assertion_predicate.clone_and_replace_init(_old_target_loop_entry, new_init, _target_loop_head->as_CountedLoop(), _phase);\n+  template_assertion_predicate.rewire_loop_data_dependencies(cloned_template_assertion_predicate.tail(),\n+                                                             _node_in_loop_body, _phase);\n+  _target_loop_predicate_chain.insert_predicate(cloned_template_assertion_predicate);\n+}\n+\n@@ -1185,0 +1246,4 @@\n+void UpdateInitForTemplateAssertionPredicates::visit(const TemplateAssertionPredicate& template_assertion_predicate) {\n+  template_assertion_predicate.replace_opaque_init_node(_new_init, _phase->igvn());\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":70,"deletions":5,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -441,0 +441,2 @@\n+  TemplateAssertionPredicate clone_and_replace_init(Node* new_control, Node* new_input,\n+                                                    CountedLoopNode* new_loop_node, PhaseIdealLoop* phase) const;\n@@ -442,0 +444,1 @@\n+  void replace_opaque_init_node(Node* new_init, PhaseIterGVN& igvn) const;\n@@ -1231,0 +1234,1 @@\n+  void clone_template_assertion_predicate_and_replace_init(const TemplateAssertionPredicate& template_assertion_predicate, Node* new_init);\n@@ -1303,0 +1307,16 @@\n+\/\/ This visitor replaces the OpaqueLoopInitNode for an Assertion Predicate with the expression passed as input.\n+class UpdateInitForTemplateAssertionPredicates : public PredicateVisitor {\n+  Node* const _new_init;\n+  PhaseIdealLoop* const _phase;\n+\n+public:\n+  UpdateInitForTemplateAssertionPredicates(Node* const new_init, PhaseIdealLoop* phase)\n+      : _new_init(new_init),\n+        _phase(phase) {}\n+  NONCOPYABLE(UpdateInitForTemplateAssertionPredicates);\n+\n+  using PredicateVisitor::visit;\n+\n+  void visit(const TemplateAssertionPredicate& template_assertion_predicate) override;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8366888\n+ * @summary C2: incorrect assertion predicate with short running long counted loop\n+  *\n+ * @run main\/othervm -XX:-BackgroundCompilation TestShortCountedLoopWithLongRCBadAssertPredicate\n+ * @run main TestShortCountedLoopWithLongRCBadAssertPredicate\n+ *\/\n+\n+import java.util.Objects;\n+\n+public class TestShortCountedLoopWithLongRCBadAssertPredicate {\n+    public static void main(String[] args) {\n+        float[] floatArray = new float[1000];\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(floatArray, 10000);\n+            test2(floatArray, 10000);\n+            test3(100, 1100, floatArray, 10000);\n+            test4(999, 0, floatArray, 10000);\n+        }\n+    }\n+\n+    private static float test1(float[] floatArray, long longRange) {\n+        float v = 0;\n+        for (int i = 100; i < 1100; i++) {\n+            v += floatArray[i - 100];\n+            Objects.checkIndex(i, longRange);\n+        }\n+        return v;\n+    }\n+\n+    private static float test2(float[] floatArray, long longRange) {\n+        float v = 0;\n+        for (int i = 999; i >= 0; i--) {\n+            v += floatArray[i];\n+            Objects.checkIndex(i, longRange);\n+        }\n+        return v;\n+    }\n+\n+    private static float test3(int start, int stop, float[] floatArray, long longRange) {\n+        float v = 0;\n+        for (int i = start; i < stop; i++) {\n+            v += floatArray[i - 100];\n+            Objects.checkIndex(i, longRange);\n+        }\n+        return v;\n+    }\n+\n+    private static float test4(int start, int stop, float[] floatArray, long longRange) {\n+        float v = 0;\n+        for (int i = start; i >= stop; i--) {\n+            v += floatArray[i];\n+            Objects.checkIndex(i, longRange);\n+        }\n+        return v;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestShortCountedLoopWithLongRCBadAssertPredicate.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8366888\n+ * @summary C2: incorrect assertion predicate with short running long counted loop\n+ *\n+ * @run main\/othervm -XX:CompileOnly=TestShortCountedLoopWithLongRCBadAssertPredicate2::test -Xbatch TestShortCountedLoopWithLongRCBadAssertPredicate2\n+ * @run main\/othervm TestShortCountedLoopWithLongRCBadAssertPredicate2\n+ *\/\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+public class TestShortCountedLoopWithLongRCBadAssertPredicate2 {\n+    private static MemorySegment ms = MemorySegment.ofArray(new byte[80000]);\n+    private static final ValueLayout.OfByte BYTE = ValueLayout.JAVA_BYTE;\n+    static byte[] bArr = new byte[80000];\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10000; i++) {\n+            test(i);\n+        }\n+    }\n+\n+    public static void test(int start) {\n+        int end = start + 100;\n+        int i = 0;\n+        while (start < end) {\n+            bArr[i++] = ms.get(BYTE, start++);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestShortCountedLoopWithLongRCBadAssertPredicate2.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"}]}