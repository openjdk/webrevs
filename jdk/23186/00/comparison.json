{"files":[{"patch":"@@ -143,2 +143,2 @@\n-  if (_full_gc && UseZGC) {\n-    \/\/ ZGC cannot perform a synchronous GC cycle from within the VM thread.\n+  if (_full_gc && (UseZGC || UseShenandoahGC)) {\n+    \/\/ ZGC and Shenandoah cannot perform a synchronous GC cycle from within the VM thread.\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1501,0 +1501,12 @@\n+void ShenandoahHeap::collect_as_vm_thread(GCCause::Cause cause) {\n+  \/\/ These requests are ignored because we can't easily have Shenandoah jump into\n+  \/\/ a synchronous (degenerated or full) cycle while it is in the middle of a concurrent\n+  \/\/ cycle. We _could_ cancel the concurrent cycle and then try to run a cycle directly\n+  \/\/ on the VM thread, but this would confuse the control thread mightily and doesn't\n+  \/\/ seem worth the trouble. Instead, we will have the caller thread run (and wait for) a\n+  \/\/ concurrent cycle in the prologue of the heap inspect\/dump operation. This is how\n+  \/\/ other concurrent collectors in the JVM handle this scenario as well.\n+  assert(Thread::current()->is_VM_thread(), \"Should be the VM thread\");\n+  guarantee(cause == GCCause::_heap_dump || cause == GCCause::_heap_inspection, \"Invalid cause\");\n+}\n+\n@@ -1585,1 +1597,3 @@\n-  assert(gc_cause()  == GCCause::_no_gc, \"Over-writing cause\");\n+  const GCCause::Cause current = gc_cause();\n+  assert(current == GCCause::_no_gc, \"Over-writing cause: %s, with: %s\",\n+         GCCause::to_string(current), GCCause::to_string(cause));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -637,0 +637,1 @@\n+  void collect_as_vm_thread(GCCause::Cause cause) override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2352,5 +2352,4 @@\n-  if (_gc_before_heap_dump && UseZGC) {\n-    \/\/ ZGC cannot perform a synchronous GC cycle from within the VM thread.\n-    \/\/ So ZCollectedHeap::collect_as_vm_thread() is a noop. To respect the\n-    \/\/ _gc_before_heap_dump flag a synchronous GC cycle is performed from\n-    \/\/ the caller thread in the prologue.\n+  if (_gc_before_heap_dump && (UseZGC || UseShenandoahGC)) {\n+    \/\/ ZGC and Shenandoah cannot perform a synchronous GC cycle from within the VM thread.\n+    \/\/ So collect_as_vm_thread() is a noop. To respect the _gc_before_heap_dump flag a\n+    \/\/ synchronous GC cycle is performed from the caller thread in the prologue.\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"}]}