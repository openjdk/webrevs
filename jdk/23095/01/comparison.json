{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,10 @@\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.FieldModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.MethodParameterInfo;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.classfile.attribute.ModuleExportInfo;\n+import java.lang.classfile.attribute.ModuleOpenInfo;\n+import java.lang.classfile.attribute.ModuleRequireInfo;\n+import java.lang.module.ModuleDescriptor;\n@@ -29,0 +39,1 @@\n+import java.util.List;\n@@ -32,1 +43,3 @@\n-import java.util.function.Function;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.reflect.ClassFileFormatVersion.*;\n@@ -96,5 +109,0 @@\n-    \/\/ Note to maintainers: anonymous class instances are used rather\n-    \/\/ than lambdas to initialize the functions used for the\n-    \/\/ cffvToLocations field to avoid using lambdas too early in JDK\n-    \/\/ initialization.\n-\n@@ -107,9 +115,2 @@\n-           Location.SET_PUBLIC_1,\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                       Location.SET_CLASS_FIELD_METHOD:\n-                       Location.SET_PUBLIC_1;\n-               }\n-           }),\n+           Location.SET_CLASS_FIELD_METHOD_INNER_CLASS,\n+           List.of(Map.entry(RELEASE_0, Location.SET_CLASS_FIELD_METHOD))),\n@@ -123,8 +124,1 @@\n-            new Function<ClassFileFormatVersion, Set<Location>>() {\n-                @Override\n-                    public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                    return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                        Location.SET_FIELD_METHOD:\n-                        Location.SET_FIELD_METHOD_INNER_CLASS;\n-                }\n-            }),\n+            List.of(Map.entry(RELEASE_0, Location.SET_FIELD_METHOD))),\n@@ -138,8 +132,1 @@\n-              new Function<ClassFileFormatVersion, Set<Location>>() {\n-                  @Override\n-                  public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                  return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                      Location.SET_FIELD_METHOD:\n-                      Location.SET_FIELD_METHOD_INNER_CLASS;\n-                  }\n-              }),\n+              List.of(Map.entry(RELEASE_0, Location.SET_FIELD_METHOD))),\n@@ -153,7 +140,1 @@\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                       Location.SET_FIELD_METHOD:\n-                       Location.SET_FIELD_METHOD_INNER_CLASS;}\n-           }),\n+           List.of(Map.entry(RELEASE_0, Location.SET_FIELD_METHOD))),\n@@ -168,12 +149,2 @@\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-              @Override\n-              public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                  if (cffv.compareTo(ClassFileFormatVersion.RELEASE_8) >= 0) {\n-                      return Location.SET_FINAL_8;\n-                  } else {\n-                      return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                          Location.SET_CLASS_FIELD_METHOD :\n-                          Location.SET_CLASS_FIELD_METHOD_INNER_CLASS;\n-                  }\n-              }\n-          }),\n+          List.of(Map.entry(RELEASE_7, Location.SET_CLASS_FIELD_METHOD_INNER_CLASS),\n+                  Map.entry(RELEASE_0, Location.SET_CLASS_FIELD_METHOD))),\n@@ -189,1 +160,1 @@\n-    SUPER(0x0000_0020, false, Location.SET_CLASS, null),\n+    SUPER(0x0000_0020, false, Location.SET_CLASS, List.of()),\n@@ -196,8 +167,2 @@\n-        OPEN(0x0000_0020, false, Location.SET_MODULE,\n-             new Function<ClassFileFormatVersion, Set<Location>>() {\n-                 @Override\n-                 public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                     return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n-                         Location.SET_MODULE:\n-                         Location.EMPTY_SET;}\n-             }),\n+    OPEN(0x0000_0020, false, Location.SET_MODULE,\n+         List.of(Map.entry(RELEASE_8, Location.EMPTY_SET))),\n@@ -211,7 +176,1 @@\n-               new Function<ClassFileFormatVersion, Set<Location>>() {\n-                   @Override\n-                   public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                       return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n-                           Location.SET_MODULE_REQUIRES:\n-                           Location.EMPTY_SET;}\n-               }),\n+               List.of(Map.entry(RELEASE_8, Location.EMPTY_SET))),\n@@ -224,1 +183,1 @@\n-    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Location.SET_METHOD, null),\n+    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Location.SET_METHOD, List.of()),\n@@ -232,9 +191,3 @@\n-                 new Function<ClassFileFormatVersion, Set<Location>>() {\n-                     @Override\n-                     public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                         return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n-                             Location.SET_MODULE_REQUIRES:\n-                             Location.EMPTY_SET;}\n-                 }),\n-\n-   \/**\n+                 List.of(Map.entry(RELEASE_8, Location.EMPTY_SET))),\n+\n+    \/**\n@@ -245,1 +198,1 @@\n-    VOLATILE(Modifier.VOLATILE, true, Location.SET_FIELD, null),\n+    VOLATILE(Modifier.VOLATILE, true, Location.SET_FIELD, List.of()),\n@@ -253,7 +206,1 @@\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n-                       Location.SET_METHOD:\n-                       Location.EMPTY_SET;}\n-           }),\n+           List.of(Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -266,1 +213,1 @@\n-    TRANSIENT(Modifier.TRANSIENT, true, Location.SET_FIELD, null),\n+    TRANSIENT(Modifier.TRANSIENT, true, Location.SET_FIELD, List.of()),\n@@ -270,1 +217,1 @@\n-     <code>{@value \"0x%04x\" Modifier#VARARGS}<\/code>.\n+     * <code>{@value \"0x%04x\" Modifier#VARARGS}<\/code>.\n@@ -274,7 +221,1 @@\n-            new Function<ClassFileFormatVersion, Set<Location>>() {\n-                @Override\n-                public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                    return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n-                        Location.SET_METHOD:\n-                        Location.EMPTY_SET;}\n-            }),\n+            List.of(Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -287,1 +228,1 @@\n-    NATIVE(Modifier.NATIVE, true, Location.SET_METHOD, null),\n+    NATIVE(Modifier.NATIVE, true, Location.SET_METHOD, List.of()),\n@@ -295,7 +236,1 @@\n-              new Function<ClassFileFormatVersion, Set<Location>>() {\n-                  @Override\n-                  public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                      return (cffv.compareTo(ClassFileFormatVersion.RELEASE_0) == 0 ) ?\n-                          Location.SET_CLASS:\n-                          Location.SET_CLASS_INNER_CLASS;}\n-              }),\n+              List.of(Map.entry(RELEASE_0, Location.SET_CLASS))),\n@@ -310,7 +245,1 @@\n-             new Function<ClassFileFormatVersion, Set<Location>>() {\n-                 @Override\n-                 public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                     return (cffv.compareTo(ClassFileFormatVersion.RELEASE_0) == 0 ) ?\n-                         Location.SET_CLASS_METHOD:\n-                         Location.SET_CLASS_METHOD_INNER_CLASS;}\n-             }),\n+             List.of(Map.entry(RELEASE_0, Location.SET_CLASS_METHOD))),\n@@ -329,8 +258,2 @@\n-             new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv.compareTo(ClassFileFormatVersion.RELEASE_2)  >= 0 &&\n-                           cffv.compareTo(ClassFileFormatVersion.RELEASE_16) <= 0) ?\n-                       Location.SET_METHOD:\n-                       Location.EMPTY_SET;}\n-           }),\n+           List.of(Map.entry(RELEASE_16, Location.SET_METHOD),\n+                   Map.entry(RELEASE_1, Location.EMPTY_SET))),\n@@ -346,15 +269,3 @@\n-              new Function<ClassFileFormatVersion, Set<Location>>() {\n-                  @Override\n-                  public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                      if (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 )\n-                          return Location.SET_SYNTHETIC_9;\n-                      else {\n-                          return\n-                              switch(cffv) {\n-                              case RELEASE_7 -> Location.SET_SYNTHETIC_7;\n-                              case RELEASE_8 -> Location.SET_SYNTHETIC_8;\n-                              default        -> Location.EMPTY_SET;\n-                              };\n-                      }\n-                  }\n-              }),\n+              List.of(Map.entry(RELEASE_8, Location.SET_SYNTHETIC_8),\n+                      Map.entry(RELEASE_7, Location.SET_SYNTHETIC_5),\n+                      Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -368,7 +279,1 @@\n-               new Function<ClassFileFormatVersion, Set<Location>>() {\n-                   @Override\n-                   public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                       return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n-                           Location.SET_CLASS_INNER_CLASS:\n-                           Location.EMPTY_SET;}\n-               }),\n+               List.of(Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -382,7 +287,1 @@\n-         new Function<ClassFileFormatVersion, Set<Location>>() {\n-             @Override\n-             public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                 return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n-                     Location.SET_CLASS_FIELD_INNER_CLASS:\n-                     Location.EMPTY_SET;}\n-         }),\n+         List.of(Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -395,12 +294,2 @@\n-             new Function<ClassFileFormatVersion, Set<Location>>() {\n-                 @Override\n-                 public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                     if (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) {\n-                         return Location.SET_MANDATED_9;\n-                     } else {\n-                         return (cffv == ClassFileFormatVersion.RELEASE_8) ?\n-                             Location.SET_METHOD_PARAM:\n-                             Location.EMPTY_SET;\n-                     }\n-                 }\n-             }),\n+             List.of(Map.entry(RELEASE_8, Location.SET_METHOD_PARAM),\n+                     Map.entry(RELEASE_7, Location.EMPTY_SET))),\n@@ -413,7 +302,1 @@\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n-                       Location.SET_CLASS:\n-                       Location.EMPTY_SET;}\n-           })\n+           List.of(Map.entry(RELEASE_8, Location.EMPTY_SET))),\n@@ -431,2 +314,2 @@\n-    \/\/ Lambda to implement locations(ClassFileFormatVersion cffv)\n-    private final Function<ClassFileFormatVersion, Set<Location>> cffvToLocations;\n+    \/\/ historical locations up to a given version\n+    private final List<Map.Entry<ClassFileFormatVersion, Set<Location>>> historicalLocations;\n@@ -437,1 +320,1 @@\n-                       Function<ClassFileFormatVersion, Set<Location>> cffvToLocations) {\n+                       List<Map.Entry<ClassFileFormatVersion, Set<Location>>> historicalLocations) {\n@@ -441,1 +324,1 @@\n-        this.cffvToLocations = cffvToLocations;\n+        this.historicalLocations = Location.ensureHistoryOrdered(historicalLocations);\n@@ -474,6 +357,1 @@\n-        Objects.requireNonNull(cffv);\n-        if (cffvToLocations == null) {\n-            return locations;\n-        } else {\n-            return cffvToLocations.apply(cffv);\n-        }\n+        return Location.findInHistory(locations, historicalLocations, cffv);\n@@ -490,0 +368,1 @@\n+     * @throws NullPointerException if {@code location} is {@code null}\n@@ -493,1 +372,1 @@\n-        for (var accessFlag : LocationToFlags.locationToFlags.get(location)) {\n+        for (var accessFlag : LocationToFlags.LOCATION_TO_FLAGS.get(location)) {\n@@ -519,1 +398,6 @@\n-         * @jvms 4.1 The ClassFile Structure\n+         *\n+         * @see Class#accessFlags()\n+         * @see ClassModel#flags()\n+         * @see Modifier#classModifiers()\n+         * @see Modifier#interfaceModifiers()\n+         * @jvms 4.1 The {@code ClassFile} Structure\n@@ -521,1 +405,11 @@\n-        CLASS,\n+        CLASS(ACC_PUBLIC | ACC_FINAL | ACC_SUPER |\n+              ACC_INTERFACE | ACC_ABSTRACT |\n+              ACC_SYNTHETIC | ACC_ANNOTATION |\n+              ACC_ENUM | ACC_MODULE,\n+              List.of(Map.entry(RELEASE_8, \/\/ no module\n+                                ACC_PUBLIC | ACC_FINAL | ACC_SUPER |\n+                                ACC_INTERFACE | ACC_ABSTRACT |\n+                                ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM),\n+                      Map.entry(RELEASE_4, \/\/ no synthetic, annotation, enum\n+                                ACC_PUBLIC | ACC_FINAL | ACC_SUPER |\n+                                ACC_INTERFACE | ACC_ABSTRACT))),\n@@ -525,0 +419,4 @@\n+         *\n+         * @see Field#accessFlags()\n+         * @see FieldModel#flags()\n+         * @see Modifier#fieldModifiers()\n@@ -527,1 +425,7 @@\n-        FIELD,\n+        FIELD(ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+              ACC_STATIC | ACC_FINAL | ACC_VOLATILE |\n+              ACC_TRANSIENT | ACC_SYNTHETIC | ACC_ENUM,\n+              List.of(Map.entry(RELEASE_4, \/\/ no synthetic, enum\n+                                ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                                ACC_STATIC | ACC_FINAL | ACC_VOLATILE |\n+                                ACC_TRANSIENT))),\n@@ -531,0 +435,5 @@\n+         *\n+         * @see Executable#accessFlags()\n+         * @see MethodModel#flags()\n+         * @see Modifier#methodModifiers()\n+         * @see Modifier#constructorModifiers()\n@@ -533,1 +442,17 @@\n-        METHOD,\n+        METHOD(ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+               ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED |\n+               ACC_BRIDGE | ACC_VARARGS | ACC_NATIVE |\n+               ACC_ABSTRACT | ACC_SYNTHETIC,\n+               List.of(Map.entry(RELEASE_16, \/\/ had strict\n+                                 ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                                 ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED |\n+                                 ACC_BRIDGE | ACC_VARARGS | ACC_NATIVE |\n+                                 ACC_ABSTRACT | ACC_STRICT | ACC_SYNTHETIC),\n+                       Map.entry(RELEASE_4, \/\/ no bridge, varargs, synthetic\n+                                 ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                                 ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED |\n+                                 ACC_NATIVE | ACC_ABSTRACT | ACC_STRICT),\n+                       Map.entry(RELEASE_1, \/\/ no strict\n+                                 ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                                 ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED |\n+                                 ACC_NATIVE | ACC_ABSTRACT))),\n@@ -537,1 +462,6 @@\n-         * @jvms 4.7.6 The InnerClasses Attribute\n+         *\n+         * @see Class#accessFlags()\n+         * @see InnerClassInfo#flags()\n+         * @see Modifier#classModifiers()\n+         * @see Modifier#interfaceModifiers()\n+         * @jvms 4.7.6 The {@code InnerClasses} Attribute\n@@ -539,1 +469,8 @@\n-        INNER_CLASS,\n+        INNER_CLASS(ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                    ACC_STATIC | ACC_FINAL | ACC_INTERFACE | ACC_ABSTRACT |\n+                    ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM,\n+                    List.of(Map.entry(RELEASE_4, \/\/ no synthetic, annotation, enum\n+                            ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                            ACC_STATIC | ACC_FINAL | ACC_INTERFACE |\n+                            ACC_ABSTRACT),\n+                            Map.entry(RELEASE_0, 0))), \/\/ did not exist\n@@ -543,1 +480,5 @@\n-         * @jvms 4.7.24 The MethodParameters Attribute\n+         *\n+         * @see Parameter#accessFlags()\n+         * @see MethodParameterInfo#flags()\n+         * @see Modifier#parameterModifiers()\n+         * @jvms 4.7.24 The {@code MethodParameters} Attribute\n@@ -545,1 +486,2 @@\n-        METHOD_PARAMETER,\n+        METHOD_PARAMETER(ACC_FINAL | ACC_SYNTHETIC | ACC_MANDATED,\n+                         List.of(Map.entry(RELEASE_7, 0))),  \/\/ did not exist\n@@ -548,2 +490,5 @@\n-         * Module location\n-         * @jvms 4.7.25 The Module Attribute\n+         * Module location.\n+         *\n+         * @see ModuleDescriptor#accessFlags()\n+         * @see ModuleAttribute#moduleFlags()\n+         * @jvms 4.7.25 The {@code Module} Attribute\n@@ -551,1 +496,2 @@\n-        MODULE,\n+        MODULE(ACC_OPEN | ACC_SYNTHETIC | ACC_MANDATED,\n+               List.of(Map.entry(RELEASE_8, 0))),  \/\/ did not exist\n@@ -554,2 +500,5 @@\n-         * Module requires location\n-         * @jvms 4.7.25 The Module Attribute\n+         * Module requires location.\n+         *\n+         * @see ModuleDescriptor.Requires#accessFlags()\n+         * @see ModuleRequireInfo#requiresFlags()\n+         * @jvms 4.7.25 The {@code Module} Attribute\n@@ -557,1 +506,2 @@\n-        MODULE_REQUIRES,\n+        MODULE_REQUIRES(ACC_TRANSITIVE | ACC_STATIC_PHASE | ACC_SYNTHETIC | ACC_MANDATED,\n+                        List.of(Map.entry(RELEASE_8, 0))),  \/\/ did not exist\n@@ -560,2 +510,5 @@\n-         * Module exports location\n-         * @jvms 4.7.25 The Module Attribute\n+         * Module exports location.\n+         *\n+         * @see ModuleDescriptor.Exports#accessFlags()\n+         * @see ModuleExportInfo#exportsFlags()\n+         * @jvms 4.7.25 The {@code Module} Attribute\n@@ -563,1 +516,2 @@\n-        MODULE_EXPORTS,\n+        MODULE_EXPORTS(ACC_SYNTHETIC | ACC_MANDATED,\n+                       List.of(Map.entry(RELEASE_8, 0))),  \/\/ did not exist\n@@ -566,2 +520,5 @@\n-         * Module opens location\n-         * @jvms 4.7.25 The Module Attribute\n+         * Module opens location.\n+         *\n+         * @see ModuleDescriptor.Opens#accessFlags()\n+         * @see ModuleOpenInfo#opensFlags()\n+         * @jvms 4.7.25 The {@code Module} Attribute\n@@ -569,1 +526,3 @@\n-        MODULE_OPENS;\n+        MODULE_OPENS(ACC_SYNTHETIC | ACC_MANDATED,\n+                     List.of(Map.entry(RELEASE_8, 0))),  \/\/ did not exist\n+        ;\n@@ -596,2 +555,0 @@\n-        private static final Set<Location> SET_PUBLIC_1 =\n-            Set.of(CLASS, FIELD, METHOD, INNER_CLASS);\n@@ -602,1 +559,1 @@\n-        private static final Set<Location> SET_SYNTHETIC_7 =\n+        private static final Set<Location> SET_SYNTHETIC_5 =\n@@ -609,1 +566,1 @@\n-              \/\/ Added as an access flag in 7\n+              \/\/ Added as an access flag in 5.0\n@@ -621,0 +578,98 @@\n+\n+        private final int flagsMask;\n+        private final List<Map.Entry<ClassFileFormatVersion, Integer>> historicalFlagsMasks;\n+\n+        Location(int flagsMask,\n+                 List<Map.Entry<ClassFileFormatVersion, Integer>> historicalFlagsMasks) {\n+            this.flagsMask = flagsMask;\n+            this.historicalFlagsMasks = ensureHistoryOrdered(historicalFlagsMasks);\n+        }\n+\n+        \/\/ Ensures the historical versions are from newest to oldest and do not include the latest\n+        \/\/ These 2 utilities reside in Location because Location must be initialized before AccessFlag\n+        private static <T> List<Map.Entry<ClassFileFormatVersion, T>> ensureHistoryOrdered(\n+                List<Map.Entry<ClassFileFormatVersion, T>> history) {\n+            var lastVersion = ClassFileFormatVersion.latest();\n+            for (var e : history) {\n+                var historyVersion = e.getKey();\n+                if (lastVersion.compareTo(historyVersion) <= 0) {\n+                    throw new IllegalArgumentException(\"Versions out of order\");\n+                }\n+                lastVersion = historyVersion;\n+            }\n+            return history;\n+        }\n+\n+        private static <T> T findInHistory(T candidate, List<Map.Entry<ClassFileFormatVersion, T>> history,\n+                                           ClassFileFormatVersion cffv) {\n+            Objects.requireNonNull(cffv);\n+            for (var e : history) {\n+                if (e.getKey().compareTo(cffv) < 0) {\n+                    \/\/ last version found was valid\n+                    return candidate;\n+                }\n+                candidate = e.getValue();\n+            }\n+            return candidate;\n+        }\n+\n+        \/**\n+         * {@return the union of integer masks of all access flags defined for\n+         * this location in the latest class file format version}  If {@code\n+         * mask & ~location.flagsMask() != 0}, then a bit mask {@code mask} has\n+         * one or more undefined bits set for {@code location}.  This union of\n+         * access flags mask may not itself be a valid flag value.\n+         *\n+         * @since 25\n+         *\/\n+        public int flagsMask() {\n+            return flagsMask;\n+        }\n+\n+        \/**\n+         * {@return the union of integer masks of all access flags defined for\n+         * this location in the given class file format version}  If {@code\n+         * mask & ~location.flagsMask(cffv) != 0}, then a bit mask {@code mask}\n+         * has one or more undefined bits set for {@code location} in {@code\n+         * cffv}.  This union of access flags mask may not itself be a valid\n+         * flag value.\n+         * <p>\n+         * This method may return {@code 0} if the structure did not exist in\n+         * the given {@code cffv}.\n+         *\n+         * @param cffv the class file format version\n+         * @throws NullPointerException if {@code cffv} is {@code null}\n+         * @since 25\n+         *\/\n+        public int flagsMask(ClassFileFormatVersion cffv) {\n+            return findInHistory(flagsMask, historicalFlagsMasks, cffv);\n+        }\n+\n+        \/**\n+         * {@return all access flags defined for this location, as a set of\n+         * flag enums}  This set may include mutually exclusive flags.\n+         *\n+         * @since 25\n+         *\/\n+        public Set<AccessFlag> flags() {\n+            if (this == METHOD) {\n+                return LocationToFlags.CURRENT_METHOD_FLAGS;\n+            }\n+            return LocationToFlags.LOCATION_TO_FLAGS.get(this);\n+        }\n+\n+        \/**\n+         * {@return all access flags defined for this location, as a set of flag\n+         * enums}  This set may include mutually exclusive flags.\n+         * <p>\n+         * This method may return an empty set if the structure did not exist in\n+         * the given {@code cffv}.\n+         *\n+         * @param cffv the class file format version\n+         * @throws NullPointerException if {@code cffv} is {@code null}\n+         * @since 25\n+         *\/\n+        public Set<AccessFlag> flags(ClassFileFormatVersion cffv) {\n+            int flagsMask = flagsMask(cffv); \/\/ implicit null check\n+            return maskToAccessFlags(flagsMask, this);\n+        }\n@@ -623,2 +678,3 @@\n-    private static class LocationToFlags {\n-        private static Map<Location, Set<AccessFlag>> locationToFlags =\n+    private static final class LocationToFlags {\n+        \/\/ A map from location to flags that ever existed on the location\n+        private static final Map<Location, Set<AccessFlag>> LOCATION_TO_FLAGS =\n@@ -653,0 +709,6 @@\n+        \/\/ Current recognized flags on method, which does not include strict\n+        private static final Set<AccessFlag> CURRENT_METHOD_FLAGS = Set.of(\n+                PUBLIC, PRIVATE, PROTECTED,\n+                STATIC, FINAL, SYNCHRONIZED,\n+                BRIDGE, VARARGS, NATIVE,\n+                ABSTRACT, SYNTHETIC);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":264,"deletions":202,"binary":false,"changes":466,"status":"modified"},{"patch":"@@ -451,0 +451,2 @@\n+     * @see AccessFlag.Location#CLASS\n+     * @see AccessFlag.Location#INNER_CLASS\n@@ -464,0 +466,2 @@\n+     * @see AccessFlag.Location#CLASS\n+     * @see AccessFlag.Location#INNER_CLASS\n@@ -477,0 +481,1 @@\n+     * @see AccessFlag.Location#METHOD\n@@ -490,0 +495,1 @@\n+     * @see AccessFlag.Location#METHOD\n@@ -503,0 +509,1 @@\n+     * @see AccessFlag.Location#FIELD\n@@ -516,0 +523,1 @@\n+     * @see AccessFlag.Location#METHOD_PARAMETER\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Modifier.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,0 +161,15 @@\n+\n+        for (var location : AccessFlag.Location.values()) {\n+            try {\n+                location.flags(null);\n+                throw new RuntimeException(\"Did not get NPE on \" + location + \".flags(null)\");\n+            } catch (NullPointerException npe ) {\n+                ; \/\/ Expected\n+            }\n+            try {\n+                location.flagsMask(null);\n+                throw new RuntimeException(\"Did not get NPE on \" + location + \".flagsMask(null)\");\n+            } catch (NullPointerException npe ) {\n+                ; \/\/ Expected\n+            }\n+        }\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/BasicAccessFlagTest.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import static java.lang.reflect.AccessFlag.*;\n+\n@@ -50,1 +52,1 @@\n-@ExpectedClassFlags(\"[PUBLIC, FINAL, SUPER]\")\n+@ExpectedClassFlags({PUBLIC, FINAL, SUPER})\n@@ -79,2 +81,4 @@\n-            String actual = clazz.accessFlags().toString();\n-            if (!expected.value().equals(actual)) {\n+            Set<AccessFlag> base = EnumSet.noneOf(AccessFlag.class);\n+            Collections.addAll(base, expected.value());\n+            Set<AccessFlag> actual = clazz.accessFlags();\n+            if (!base.equals(actual)) {\n@@ -82,1 +86,1 @@\n-                                           \" expected \" + expected.value() +\n+                                           \" expected \" + base +\n@@ -101,1 +105,1 @@\n-        var expected = Set.of(AccessFlag.PUBLIC,\n+        var expected = Set.of(PUBLIC,\n@@ -130,2 +134,2 @@\n-            if (flags.contains(AccessFlag.PUBLIC))\n-                accessLevel = AccessFlag.PUBLIC;\n+            if (flags.contains(PUBLIC))\n+                accessLevel = PUBLIC;\n@@ -148,1 +152,1 @@\n-                                Set.of(AccessFlag.PUBLIC,\n+                                Set.of(PUBLIC,\n@@ -164,1 +168,1 @@\n-    @ExpectedClassFlags(\"[PUBLIC, STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({PUBLIC, STATIC, INTERFACE, ABSTRACT})\n@@ -166,1 +170,1 @@\n-    @ExpectedClassFlags(\"[PROTECTED, STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({PROTECTED, STATIC, INTERFACE, ABSTRACT})\n@@ -168,1 +172,1 @@\n-    @ExpectedClassFlags(\"[PRIVATE, STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({PRIVATE, STATIC, INTERFACE, ABSTRACT})\n@@ -170,1 +174,1 @@\n-    @ExpectedClassFlags(\"[STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({STATIC, INTERFACE, ABSTRACT})\n@@ -173,1 +177,1 @@\n-    @ExpectedClassFlags(\"[FINAL]\")\n+    @ExpectedClassFlags({FINAL})\n@@ -176,1 +180,1 @@\n-    @ExpectedClassFlags(\"[ABSTRACT]\")\n+    @ExpectedClassFlags({ABSTRACT})\n@@ -179,1 +183,1 @@\n-    @ExpectedClassFlags(\"[STATIC, INTERFACE, ABSTRACT, ANNOTATION]\")\n+    @ExpectedClassFlags({STATIC, INTERFACE, ABSTRACT, ANNOTATION})\n@@ -182,1 +186,1 @@\n-    @ExpectedClassFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+    @ExpectedClassFlags({PUBLIC, STATIC, FINAL, ENUM})\n@@ -189,1 +193,1 @@\n-    @ExpectedClassFlags(\"[PROTECTED, STATIC, ABSTRACT, ENUM]\")\n+    @ExpectedClassFlags({PROTECTED, STATIC, ABSTRACT, ENUM})\n@@ -198,1 +202,1 @@\n-    @ExpectedClassFlags(\"[PRIVATE, ABSTRACT]\")\n+    @ExpectedClassFlags({PRIVATE, ABSTRACT})\n@@ -201,1 +205,1 @@\n-    @ExpectedClassFlags(\"[STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({STATIC, INTERFACE, ABSTRACT})\n@@ -206,1 +210,1 @@\n-@ExpectedClassFlags(\"[INTERFACE, ABSTRACT, ANNOTATION]\")\n+@ExpectedClassFlags({INTERFACE, ABSTRACT, ANNOTATION})\n@@ -208,1 +212,1 @@\n-    String value();\n+    AccessFlag[] value();\n@@ -211,1 +215,1 @@\n-@ExpectedClassFlags(\"[INTERFACE, ABSTRACT]\")\n+@ExpectedClassFlags({INTERFACE, ABSTRACT})\n@@ -215,1 +219,1 @@\n-@ExpectedClassFlags(\"[FINAL, SUPER, ENUM]\")\n+@ExpectedClassFlags({FINAL, SUPER, ENUM})\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/ClassAccessFlagTest.java","additions":28,"deletions":24,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,5 @@\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.Set;\n+\n+import static java.lang.reflect.AccessFlag.*;\n@@ -57,2 +62,4 @@\n-            String actual = field.accessFlags().toString();\n-            if (!expected.value().equals(actual)) {\n+            Set<AccessFlag> base = EnumSet.noneOf(AccessFlag.class);\n+            Collections.addAll(base, expected.value());\n+            Set<AccessFlag> actual = field.accessFlags();\n+            if (!base.equals(actual)) {\n@@ -60,2 +67,2 @@\n-                                           \" expected \" + expected.value() +\n-                                           \" got \" + actual);\n+                        \" expected \" + base +\n+                        \" got \" + actual);\n@@ -67,1 +74,1 @@\n-    @ExpectedFieldFlags(\"[PUBLIC, STATIC, FINAL]\")\n+    @ExpectedFieldFlags({PUBLIC, STATIC, FINAL})\n@@ -70,1 +77,1 @@\n-    @ExpectedFieldFlags(\"[PRIVATE, VOLATILE, TRANSIENT]\")\n+    @ExpectedFieldFlags({PRIVATE, VOLATILE, TRANSIENT})\n@@ -73,1 +80,1 @@\n-    @ExpectedFieldFlags(\"[PROTECTED]\")\n+    @ExpectedFieldFlags({PROTECTED})\n@@ -78,1 +85,1 @@\n-        @ExpectedFieldFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+        @ExpectedFieldFlags({PUBLIC, STATIC, FINAL, ENUM})\n@@ -81,1 +88,1 @@\n-        @ExpectedFieldFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+        @ExpectedFieldFlags({PUBLIC, STATIC, FINAL, ENUM})\n@@ -84,1 +91,1 @@\n-        @ExpectedFieldFlags(\"[PRIVATE]\") \/\/ no \"ENUM\"\n+        @ExpectedFieldFlags({PRIVATE}) \/\/ no \"ENUM\"\n@@ -90,1 +97,1 @@\n-        String value();\n+        AccessFlag[] value();\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/FieldAccessFlagTest.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,5 @@\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.Set;\n+\n+import static java.lang.reflect.AccessFlag.*;\n@@ -52,1 +57,1 @@\n-    @ExpectedMethodFlags(\"[PUBLIC, STATIC, VARARGS]\")\n+    @ExpectedMethodFlags({PUBLIC, STATIC, VARARGS})\n@@ -139,1 +144,1 @@\n-        ExpectedMethodFlags emf =\n+        ExpectedMethodFlags expected =\n@@ -141,3 +146,9 @@\n-        if (emf != null) {\n-            String actual = method.accessFlags().toString();\n-            checkString(method.toString(), emf.value(), actual);\n+        if (expected != null) {\n+            Set<AccessFlag> base = EnumSet.noneOf(AccessFlag.class);\n+            Collections.addAll(base, expected.value());\n+            Set<AccessFlag> actual = method.accessFlags();\n+            if (!base.equals(actual)) {\n+                throw new RuntimeException(\"On \" + method +\n+                        \" expected \" + base +\n+                        \" got \" + actual);\n+            }\n@@ -158,1 +169,1 @@\n-    @ExpectedMethodFlags(\"[PUBLIC]\")\n+    @ExpectedMethodFlags({PUBLIC})\n@@ -161,1 +172,1 @@\n-    @ExpectedMethodFlags(\"[PROTECTED]\")\n+    @ExpectedMethodFlags({PROTECTED})\n@@ -164,1 +175,1 @@\n-    @ExpectedMethodFlags(\"[PRIVATE]\")\n+    @ExpectedMethodFlags({PRIVATE})\n@@ -168,1 +179,1 @@\n-    @ExpectedMethodFlags(\"[PROTECTED, SYNCHRONIZED]\")\n+    @ExpectedMethodFlags({PROTECTED, SYNCHRONIZED})\n@@ -171,1 +182,1 @@\n-    @ExpectedMethodFlags(\"[PRIVATE]\")\n+    @ExpectedMethodFlags({PRIVATE})\n@@ -174,1 +185,1 @@\n-    @ExpectedMethodFlags(\"[ABSTRACT]\")\n+    @ExpectedMethodFlags({ABSTRACT})\n@@ -177,1 +188,1 @@\n-    @ExpectedMethodFlags(\"[PUBLIC, FINAL]\")\n+    @ExpectedMethodFlags({PUBLIC, FINAL})\n@@ -180,1 +191,1 @@\n-    @ExpectedMethodFlags(\"[NATIVE]\")\n+    @ExpectedMethodFlags({NATIVE})\n@@ -185,1 +196,1 @@\n-        String value();\n+        AccessFlag[] value();\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/MethodAccessFlagTest.java","additions":26,"deletions":15,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,5 @@\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.Set;\n+\n+import static java.lang.reflect.AccessFlag.*;\n@@ -45,1 +50,1 @@\n-    @ExpectedFlags(\"[PUBLIC, STATIC, VARARGS, STRICT]\")\n+    @ExpectedFlags({PUBLIC, STATIC, VARARGS, STRICT})\n@@ -62,2 +67,4 @@\n-            String actual = method.accessFlags().toString();\n-            if (!expected.value().equals(actual)) {\n+            Set<AccessFlag> base = EnumSet.noneOf(AccessFlag.class);\n+            Collections.addAll(base, expected.value());\n+            Set<AccessFlag> actual = method.accessFlags();\n+            if (!base.equals(actual)) {\n@@ -65,2 +72,2 @@\n-                                           \" expected \" + expected.value() +\n-                                           \" got \" + actual);\n+                        \" expected \" + base +\n+                        \" got \" + actual);\n@@ -72,1 +79,1 @@\n-    @ExpectedFlags(\"[PUBLIC, STRICT]\")\n+    @ExpectedFlags({PUBLIC, STRICT})\n@@ -77,1 +84,1 @@\n-        String value();\n+        AccessFlag[] value();\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/StrictAccessFlagTest.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- * @summary Tests of AccessFlag.locations(ClassFileFormatVersion)\n+ * @summary Tests of AccessFlag.locations(ClassFileFormatVersion) and\n+ *          accessors on AccessFlag.Location\n@@ -82,0 +83,2 @@\n+        testFlagVersionConsistency();\n+        testLocationMaskFlagConsistency();\n@@ -244,1 +247,1 @@\n-            if (cffv.compareTo(ClassFileFormatVersion.RELEASE_6) <= 0) {\n+            if (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) < 0) {\n@@ -249,1 +252,2 @@\n-                        case RELEASE_7 -> Set.of(Location.CLASS, Location.FIELD,\n+                        case RELEASE_5, RELEASE_6,\n+                             RELEASE_7 -> Set.of(Location.CLASS, Location.FIELD,\n@@ -288,0 +292,43 @@\n+    private static void testFlagVersionConsistency() {\n+        for (var flag : AccessFlag.values()) {\n+            for (var location : AccessFlag.Location.values()) {\n+                if (location.flags().contains(flag) != flag.locations().contains(location)) {\n+                    throw new RuntimeException(String.format(\"AccessFlag and Location inconsistency:\" +\n+                            \"flag %s and location %s are inconsistent for the latest version\"));\n+                }\n+            }\n+        }\n+        for (var cffv : ClassFileFormatVersion.values()) {\n+            for (var flag : AccessFlag.values()) {\n+                for (var location : AccessFlag.Location.values()) {\n+                    if (location.flags(cffv).contains(flag) != flag.locations(cffv).contains(location)) {\n+                        throw new RuntimeException(String.format(\"AccessFlag and Location inconsistency:\" +\n+                                \"flag %s and location %s are inconsistent for class file version %s\"));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void testLocationMaskFlagConsistency() {\n+        for (var location : AccessFlag.Location.values()) {\n+            if (!flagsAndMaskMatch(location.flags(), location.flagsMask())) {\n+                throw new RuntimeException(String.format(\"Flags and mask mismatch for %s\", location));\n+            }\n+            for (var cffv : ClassFileFormatVersion.values()) {\n+                if (!flagsAndMaskMatch(location.flags(cffv), location.flagsMask(cffv))) {\n+                    throw new RuntimeException(String.format(\"Flags and mask mismatch for %s in %s\", location, cffv));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean flagsAndMaskMatch(Set<AccessFlag> flags, int mask) {\n+        for (var flag : flags) {\n+            int bit = flag.mask();\n+            if (((mask & bit) == 0))\n+                return false;\n+            mask &= ~bit;\n+        }\n+        return mask == 0;\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/VersionedLocationsTest.java","additions":51,"deletions":4,"binary":false,"changes":55,"status":"modified"}]}