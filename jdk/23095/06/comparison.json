{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,18 @@\n-import java.util.Collections;\n-import java.util.Objects;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.function.Function;\n-import static java.util.Map.entry;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.FieldModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.MethodParameterInfo;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.classfile.attribute.ModuleExportInfo;\n+import java.lang.classfile.attribute.ModuleOpenInfo;\n+import java.lang.classfile.attribute.ModuleRequireInfo;\n+import java.lang.module.ModuleDescriptor;\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.reflect.ClassFileFormatVersion.*;\n@@ -96,5 +108,0 @@\n-    \/\/ Note to maintainers: anonymous class instances are used rather\n-    \/\/ than lambdas to initialize the functions used for the\n-    \/\/ cffvToLocations field to avoid using lambdas too early in JDK\n-    \/\/ initialization.\n-\n@@ -107,9 +114,2 @@\n-           Location.SET_PUBLIC_1,\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                       Location.SET_CLASS_FIELD_METHOD:\n-                       Location.SET_PUBLIC_1;\n-               }\n-           }),\n+           Location.SET_CLASS_FIELD_METHOD_INNER_CLASS,\n+           List.of(Map.entry(RELEASE_0, Location.SET_CLASS_FIELD_METHOD))),\n@@ -123,8 +123,1 @@\n-            new Function<ClassFileFormatVersion, Set<Location>>() {\n-                @Override\n-                    public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                    return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                        Location.SET_FIELD_METHOD:\n-                        Location.SET_FIELD_METHOD_INNER_CLASS;\n-                }\n-            }),\n+            List.of(Map.entry(RELEASE_0, Location.SET_FIELD_METHOD))),\n@@ -138,8 +131,1 @@\n-              new Function<ClassFileFormatVersion, Set<Location>>() {\n-                  @Override\n-                  public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                  return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                      Location.SET_FIELD_METHOD:\n-                      Location.SET_FIELD_METHOD_INNER_CLASS;\n-                  }\n-              }),\n+              List.of(Map.entry(RELEASE_0, Location.SET_FIELD_METHOD))),\n@@ -153,7 +139,1 @@\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                       Location.SET_FIELD_METHOD:\n-                       Location.SET_FIELD_METHOD_INNER_CLASS;}\n-           }),\n+           List.of(Map.entry(RELEASE_0, Location.SET_FIELD_METHOD))),\n@@ -168,12 +148,2 @@\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-              @Override\n-              public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                  if (cffv.compareTo(ClassFileFormatVersion.RELEASE_8) >= 0) {\n-                      return Location.SET_FINAL_8;\n-                  } else {\n-                      return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                          Location.SET_CLASS_FIELD_METHOD :\n-                          Location.SET_CLASS_FIELD_METHOD_INNER_CLASS;\n-                  }\n-              }\n-          }),\n+          List.of(Map.entry(RELEASE_7, Location.SET_CLASS_FIELD_METHOD_INNER_CLASS),\n+                  Map.entry(RELEASE_0, Location.SET_CLASS_FIELD_METHOD))),\n@@ -189,1 +159,1 @@\n-    SUPER(0x0000_0020, false, Location.SET_CLASS, null),\n+    SUPER(0x0000_0020, false, Location.SET_CLASS, List.of()),\n@@ -196,8 +166,2 @@\n-        OPEN(0x0000_0020, false, Location.SET_MODULE,\n-             new Function<ClassFileFormatVersion, Set<Location>>() {\n-                 @Override\n-                 public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                     return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n-                         Location.SET_MODULE:\n-                         Location.EMPTY_SET;}\n-             }),\n+    OPEN(0x0000_0020, false, Location.SET_MODULE,\n+         List.of(Map.entry(RELEASE_8, Location.EMPTY_SET))),\n@@ -211,7 +175,1 @@\n-               new Function<ClassFileFormatVersion, Set<Location>>() {\n-                   @Override\n-                   public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                       return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n-                           Location.SET_MODULE_REQUIRES:\n-                           Location.EMPTY_SET;}\n-               }),\n+               List.of(Map.entry(RELEASE_8, Location.EMPTY_SET))),\n@@ -224,1 +182,1 @@\n-    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Location.SET_METHOD, null),\n+    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Location.SET_METHOD, List.of()),\n@@ -232,9 +190,3 @@\n-                 new Function<ClassFileFormatVersion, Set<Location>>() {\n-                     @Override\n-                     public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                         return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n-                             Location.SET_MODULE_REQUIRES:\n-                             Location.EMPTY_SET;}\n-                 }),\n-\n-   \/**\n+                 List.of(Map.entry(RELEASE_8, Location.EMPTY_SET))),\n+\n+    \/**\n@@ -245,1 +197,1 @@\n-    VOLATILE(Modifier.VOLATILE, true, Location.SET_FIELD, null),\n+    VOLATILE(Modifier.VOLATILE, true, Location.SET_FIELD, List.of()),\n@@ -253,7 +205,1 @@\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n-                       Location.SET_METHOD:\n-                       Location.EMPTY_SET;}\n-           }),\n+           List.of(Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -266,1 +212,1 @@\n-    TRANSIENT(Modifier.TRANSIENT, true, Location.SET_FIELD, null),\n+    TRANSIENT(Modifier.TRANSIENT, true, Location.SET_FIELD, List.of()),\n@@ -270,1 +216,1 @@\n-     <code>{@value \"0x%04x\" Modifier#VARARGS}<\/code>.\n+     * <code>{@value \"0x%04x\" Modifier#VARARGS}<\/code>.\n@@ -274,7 +220,1 @@\n-            new Function<ClassFileFormatVersion, Set<Location>>() {\n-                @Override\n-                public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                    return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n-                        Location.SET_METHOD:\n-                        Location.EMPTY_SET;}\n-            }),\n+            List.of(Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -287,1 +227,1 @@\n-    NATIVE(Modifier.NATIVE, true, Location.SET_METHOD, null),\n+    NATIVE(Modifier.NATIVE, true, Location.SET_METHOD, List.of()),\n@@ -295,7 +235,1 @@\n-              new Function<ClassFileFormatVersion, Set<Location>>() {\n-                  @Override\n-                  public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                      return (cffv.compareTo(ClassFileFormatVersion.RELEASE_0) == 0 ) ?\n-                          Location.SET_CLASS:\n-                          Location.SET_CLASS_INNER_CLASS;}\n-              }),\n+              List.of(Map.entry(RELEASE_0, Location.SET_CLASS))),\n@@ -310,7 +244,1 @@\n-             new Function<ClassFileFormatVersion, Set<Location>>() {\n-                 @Override\n-                 public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                     return (cffv.compareTo(ClassFileFormatVersion.RELEASE_0) == 0 ) ?\n-                         Location.SET_CLASS_METHOD:\n-                         Location.SET_CLASS_METHOD_INNER_CLASS;}\n-             }),\n+             List.of(Map.entry(RELEASE_0, Location.SET_CLASS_METHOD))),\n@@ -329,8 +257,2 @@\n-             new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv.compareTo(ClassFileFormatVersion.RELEASE_2)  >= 0 &&\n-                           cffv.compareTo(ClassFileFormatVersion.RELEASE_16) <= 0) ?\n-                       Location.SET_METHOD:\n-                       Location.EMPTY_SET;}\n-           }),\n+           List.of(Map.entry(RELEASE_16, Location.SET_METHOD),\n+                   Map.entry(RELEASE_1, Location.EMPTY_SET))),\n@@ -346,15 +268,3 @@\n-              new Function<ClassFileFormatVersion, Set<Location>>() {\n-                  @Override\n-                  public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                      if (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 )\n-                          return Location.SET_SYNTHETIC_9;\n-                      else {\n-                          return\n-                              switch(cffv) {\n-                              case RELEASE_7 -> Location.SET_SYNTHETIC_7;\n-                              case RELEASE_8 -> Location.SET_SYNTHETIC_8;\n-                              default        -> Location.EMPTY_SET;\n-                              };\n-                      }\n-                  }\n-              }),\n+              List.of(Map.entry(RELEASE_8, Location.SET_SYNTHETIC_8),\n+                      Map.entry(RELEASE_7, Location.SET_SYNTHETIC_5),\n+                      Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -368,7 +278,1 @@\n-               new Function<ClassFileFormatVersion, Set<Location>>() {\n-                   @Override\n-                   public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                       return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n-                           Location.SET_CLASS_INNER_CLASS:\n-                           Location.EMPTY_SET;}\n-               }),\n+               List.of(Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -382,7 +286,1 @@\n-         new Function<ClassFileFormatVersion, Set<Location>>() {\n-             @Override\n-             public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                 return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n-                     Location.SET_CLASS_FIELD_INNER_CLASS:\n-                     Location.EMPTY_SET;}\n-         }),\n+         List.of(Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -395,12 +293,2 @@\n-             new Function<ClassFileFormatVersion, Set<Location>>() {\n-                 @Override\n-                 public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                     if (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) {\n-                         return Location.SET_MANDATED_9;\n-                     } else {\n-                         return (cffv == ClassFileFormatVersion.RELEASE_8) ?\n-                             Location.SET_METHOD_PARAM:\n-                             Location.EMPTY_SET;\n-                     }\n-                 }\n-             }),\n+             List.of(Map.entry(RELEASE_8, Location.SET_METHOD_PARAM),\n+                     Map.entry(RELEASE_7, Location.EMPTY_SET))),\n@@ -413,7 +301,1 @@\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n-                       Location.SET_CLASS:\n-                       Location.EMPTY_SET;}\n-           })\n+           List.of(Map.entry(RELEASE_8, Location.EMPTY_SET))),\n@@ -428,2 +310,1 @@\n-    \/\/ Intentionally using Set rather than EnumSet since EnumSet is\n-    \/\/ mutable.\n+    \/\/ immutable\n@@ -431,2 +312,2 @@\n-    \/\/ Lambda to implement locations(ClassFileFormatVersion cffv)\n-    private final Function<ClassFileFormatVersion, Set<Location>> cffvToLocations;\n+    \/\/ historical locations up to a given version; immutable\n+    private final List<Map.Entry<ClassFileFormatVersion, Set<Location>>> historicalLocations;\n@@ -437,1 +318,1 @@\n-                       Function<ClassFileFormatVersion, Set<Location>> cffvToLocations) {\n+                       List<Map.Entry<ClassFileFormatVersion, Set<Location>>> historicalLocations) {\n@@ -441,1 +322,1 @@\n-        this.cffvToLocations = cffvToLocations;\n+        this.historicalLocations = Location.ensureHistoryOrdered(historicalLocations);\n@@ -461,1 +342,4 @@\n-     * latest class file format version}\n+     * current class file format version}\n+     * <p>\n+     * This method may return an empty set if the flag is not defined in\n+     * the current class file format version.\n@@ -470,0 +354,4 @@\n+     * <p>\n+     * This method may return an empty set if the flag is not defined in\n+     * the given {@code cffv}.\n+     *\n@@ -474,6 +362,1 @@\n-        Objects.requireNonNull(cffv);\n-        if (cffvToLocations == null) {\n-            return locations;\n-        } else {\n-            return cffvToLocations.apply(cffv);\n-        }\n+        return Location.findInHistory(locations, historicalLocations, cffv);\n@@ -492,9 +375,5 @@\n-        Set<AccessFlag> result = java.util.EnumSet.noneOf(AccessFlag.class);\n-        for (var accessFlag : LocationToFlags.locationToFlags.get(location)) {\n-            int accessMask = accessFlag.mask();\n-            if ((mask &  accessMask) != 0) {\n-                result.add(accessFlag);\n-                mask = mask & ~accessMask;\n-            }\n-        }\n-        if (mask != 0) {\n+        var definition = findDefinition(location);\n+        int flagsMask = location.flagsMask();\n+        int parsingMask = location == Location.METHOD ? flagsMask | ACC_STRICT : flagsMask; \/\/ flagMask lacks strictfp\n+        int unmatchedMask = mask & (~parsingMask);\n+        if (unmatchedMask != 0) {\n@@ -502,2 +381,2 @@\n-                                               Integer.toHexString(mask) +\n-                                               \" for location \" + location);\n+                    Integer.toHexString(unmatchedMask) +\n+                    \" for location \" + location);\n@@ -505,1 +384,1 @@\n-        return Collections.unmodifiableSet(result);\n+        return new AccessFlagSet(definition, mask);\n@@ -519,1 +398,6 @@\n-         * @jvms 4.1 The ClassFile Structure\n+         *\n+         * @see Class#accessFlags()\n+         * @see ClassModel#flags()\n+         * @see Modifier#classModifiers()\n+         * @see Modifier#interfaceModifiers()\n+         * @jvms 4.1 The {@code ClassFile} Structure\n@@ -521,1 +405,11 @@\n-        CLASS,\n+        CLASS(ACC_PUBLIC | ACC_FINAL | ACC_SUPER |\n+              ACC_INTERFACE | ACC_ABSTRACT |\n+              ACC_SYNTHETIC | ACC_ANNOTATION |\n+              ACC_ENUM | ACC_MODULE,\n+              List.of(Map.entry(RELEASE_8, \/\/ no module\n+                                ACC_PUBLIC | ACC_FINAL | ACC_SUPER |\n+                                ACC_INTERFACE | ACC_ABSTRACT |\n+                                ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM),\n+                      Map.entry(RELEASE_4, \/\/ no synthetic, annotation, enum\n+                                ACC_PUBLIC | ACC_FINAL | ACC_SUPER |\n+                                ACC_INTERFACE | ACC_ABSTRACT))),\n@@ -525,0 +419,4 @@\n+         *\n+         * @see Field#accessFlags()\n+         * @see FieldModel#flags()\n+         * @see Modifier#fieldModifiers()\n@@ -527,1 +425,7 @@\n-        FIELD,\n+        FIELD(ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+              ACC_STATIC | ACC_FINAL | ACC_VOLATILE |\n+              ACC_TRANSIENT | ACC_SYNTHETIC | ACC_ENUM,\n+              List.of(Map.entry(RELEASE_4, \/\/ no synthetic, enum\n+                                ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                                ACC_STATIC | ACC_FINAL | ACC_VOLATILE |\n+                                ACC_TRANSIENT))),\n@@ -531,0 +435,5 @@\n+         *\n+         * @see Executable#accessFlags()\n+         * @see MethodModel#flags()\n+         * @see Modifier#methodModifiers()\n+         * @see Modifier#constructorModifiers()\n@@ -533,1 +442,17 @@\n-        METHOD,\n+        METHOD(ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+               ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED |\n+               ACC_BRIDGE | ACC_VARARGS | ACC_NATIVE |\n+               ACC_ABSTRACT | ACC_SYNTHETIC,\n+               List.of(Map.entry(RELEASE_16, \/\/ had strict\n+                                 ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                                 ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED |\n+                                 ACC_BRIDGE | ACC_VARARGS | ACC_NATIVE |\n+                                 ACC_ABSTRACT | ACC_STRICT | ACC_SYNTHETIC),\n+                       Map.entry(RELEASE_4, \/\/ no bridge, varargs, synthetic\n+                                 ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                                 ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED |\n+                                 ACC_NATIVE | ACC_ABSTRACT | ACC_STRICT),\n+                       Map.entry(RELEASE_1, \/\/ no strict\n+                                 ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                                 ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED |\n+                                 ACC_NATIVE | ACC_ABSTRACT))),\n@@ -537,1 +462,6 @@\n-         * @jvms 4.7.6 The InnerClasses Attribute\n+         *\n+         * @see Class#accessFlags()\n+         * @see InnerClassInfo#flags()\n+         * @see Modifier#classModifiers()\n+         * @see Modifier#interfaceModifiers()\n+         * @jvms 4.7.6 The {@code InnerClasses} Attribute\n@@ -539,1 +469,8 @@\n-        INNER_CLASS,\n+        INNER_CLASS(ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                    ACC_STATIC | ACC_FINAL | ACC_INTERFACE | ACC_ABSTRACT |\n+                    ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM,\n+                    List.of(Map.entry(RELEASE_4, \/\/ no synthetic, annotation, enum\n+                            ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                            ACC_STATIC | ACC_FINAL | ACC_INTERFACE |\n+                            ACC_ABSTRACT),\n+                            Map.entry(RELEASE_0, 0))), \/\/ did not exist\n@@ -543,1 +480,5 @@\n-         * @jvms 4.7.24 The MethodParameters Attribute\n+         *\n+         * @see Parameter#accessFlags()\n+         * @see MethodParameterInfo#flags()\n+         * @see Modifier#parameterModifiers()\n+         * @jvms 4.7.24 The {@code MethodParameters} Attribute\n@@ -545,1 +486,2 @@\n-        METHOD_PARAMETER,\n+        METHOD_PARAMETER(ACC_FINAL | ACC_SYNTHETIC | ACC_MANDATED,\n+                         List.of(Map.entry(RELEASE_7, 0))),  \/\/ did not exist\n@@ -548,2 +490,5 @@\n-         * Module location\n-         * @jvms 4.7.25 The Module Attribute\n+         * Module location.\n+         *\n+         * @see ModuleDescriptor#accessFlags()\n+         * @see ModuleAttribute#moduleFlags()\n+         * @jvms 4.7.25 The {@code Module} Attribute\n@@ -551,1 +496,2 @@\n-        MODULE,\n+        MODULE(ACC_OPEN | ACC_SYNTHETIC | ACC_MANDATED,\n+               List.of(Map.entry(RELEASE_8, 0))),  \/\/ did not exist\n@@ -554,2 +500,5 @@\n-         * Module requires location\n-         * @jvms 4.7.25 The Module Attribute\n+         * Module requires location.\n+         *\n+         * @see ModuleDescriptor.Requires#accessFlags()\n+         * @see ModuleRequireInfo#requiresFlags()\n+         * @jvms 4.7.25 The {@code Module} Attribute\n@@ -557,1 +506,2 @@\n-        MODULE_REQUIRES,\n+        MODULE_REQUIRES(ACC_TRANSITIVE | ACC_STATIC_PHASE | ACC_SYNTHETIC | ACC_MANDATED,\n+                        List.of(Map.entry(RELEASE_8, 0))),  \/\/ did not exist\n@@ -560,2 +510,5 @@\n-         * Module exports location\n-         * @jvms 4.7.25 The Module Attribute\n+         * Module exports location.\n+         *\n+         * @see ModuleDescriptor.Exports#accessFlags()\n+         * @see ModuleExportInfo#exportsFlags()\n+         * @jvms 4.7.25 The {@code Module} Attribute\n@@ -563,1 +516,2 @@\n-        MODULE_EXPORTS,\n+        MODULE_EXPORTS(ACC_SYNTHETIC | ACC_MANDATED,\n+                       List.of(Map.entry(RELEASE_8, 0))),  \/\/ did not exist\n@@ -566,2 +520,5 @@\n-         * Module opens location\n-         * @jvms 4.7.25 The Module Attribute\n+         * Module opens location.\n+         *\n+         * @see ModuleDescriptor.Opens#accessFlags()\n+         * @see ModuleOpenInfo#opensFlags()\n+         * @jvms 4.7.25 The {@code Module} Attribute\n@@ -569,1 +526,3 @@\n-        MODULE_OPENS;\n+        MODULE_OPENS(ACC_SYNTHETIC | ACC_MANDATED,\n+                     List.of(Map.entry(RELEASE_8, 0))),  \/\/ did not exist\n+        ;\n@@ -596,2 +555,0 @@\n-        private static final Set<Location> SET_PUBLIC_1 =\n-            Set.of(CLASS, FIELD, METHOD, INNER_CLASS);\n@@ -602,1 +559,1 @@\n-        private static final Set<Location> SET_SYNTHETIC_7 =\n+        private static final Set<Location> SET_SYNTHETIC_5 =\n@@ -609,1 +566,1 @@\n-              \/\/ Added as an access flag in 7\n+              \/\/ Added as an access flag in 5.0\n@@ -621,0 +578,105 @@\n+\n+        private final int flagsMask;\n+        private final List<Map.Entry<ClassFileFormatVersion, Integer>> historicalFlagsMasks;\n+\n+        Location(int flagsMask,\n+                 List<Map.Entry<ClassFileFormatVersion, Integer>> historicalFlagsMasks) {\n+            this.flagsMask = flagsMask;\n+            this.historicalFlagsMasks = ensureHistoryOrdered(historicalFlagsMasks);\n+        }\n+\n+        \/\/ Ensures the historical versions are from newest to oldest and do not include the latest\n+        \/\/ These 2 utilities reside in Location because Location must be initialized before AccessFlag\n+        private static <T> List<Map.Entry<ClassFileFormatVersion, T>> ensureHistoryOrdered(\n+                List<Map.Entry<ClassFileFormatVersion, T>> history) {\n+            ClassFileFormatVersion lastVersion = ClassFileFormatVersion.latest();\n+            for (var e : history) {\n+                var historyVersion = e.getKey();\n+                if (lastVersion.compareTo(historyVersion) <= 0) {\n+                    throw new IllegalArgumentException(\"Versions out of order\");\n+                }\n+                lastVersion = historyVersion;\n+            }\n+            return history;\n+        }\n+\n+        private static <T> T findInHistory(T candidate, List<Map.Entry<ClassFileFormatVersion, T>> history,\n+                                           ClassFileFormatVersion cffv) {\n+            Objects.requireNonNull(cffv);\n+            for (var e : history) {\n+                if (e.getKey().compareTo(cffv) < 0) {\n+                    \/\/ last version found was valid\n+                    return candidate;\n+                }\n+                candidate = e.getValue();\n+            }\n+            return candidate;\n+        }\n+\n+        \/**\n+         * {@return the union of integer masks of all access flags defined for\n+         * this location in the current class file format version}\n+         * <p>\n+         * This method may return {@code 0} if the structure does not exist in\n+         * the current class file format version.\n+         *\n+         * @since 25\n+         *\/\n+        public int flagsMask() {\n+            return flagsMask;\n+        }\n+\n+        \/**\n+         * {@return the union of integer masks of all access flags defined for\n+         * this location in the given class file format version}\n+         * <p>\n+         * This method may return {@code 0} if the structure does not exist in\n+         * the given {@code cffv}.\n+         *\n+         * @param cffv the class file format version\n+         * @throws NullPointerException if {@code cffv} is {@code null}\n+         * @since 25\n+         *\/\n+        public int flagsMask(ClassFileFormatVersion cffv) {\n+            return findInHistory(flagsMask, historicalFlagsMasks, cffv);\n+        }\n+\n+        \/**\n+         * {@return all access flags defined for this location, as a set of\n+         * flag enums, in the current class file format version}\n+         * <p>\n+         * This method may return an empty set if the structure does not exist\n+         * in the current class file format version.\n+         *\n+         * @since 25\n+         *\/\n+        public Set<AccessFlag> flags() {\n+            return new AccessFlagSet(findDefinition(this), flagsMask());\n+        }\n+\n+        \/**\n+         * {@return all access flags defined for this location, as a set of flag\n+         * enums, in the given class file format version}\n+         * <p>\n+         * This method may return an empty set if the structure does not exist\n+         * in the given {@code cffv}.\n+         *\n+         * @param cffv the class file format version\n+         * @throws NullPointerException if {@code cffv} is {@code null}\n+         * @since 25\n+         *\/\n+        public Set<AccessFlag> flags(ClassFileFormatVersion cffv) {\n+            \/\/ implicit null check cffv\n+            return new AccessFlagSet(findDefinition(this), flagsMask(cffv));\n+        }\n+    }\n+\n+    private static AccessFlag[] createDefinition(AccessFlag... known) {\n+        var ret = new AccessFlag[Character.SIZE];\n+        for (var flag : known) {\n+            var mask = flag.mask;\n+            int pos = Integer.numberOfTrailingZeros(mask);\n+            assert ret[pos] == null : ret[pos] + \" \" + flag;\n+            ret[pos] = flag;\n+        }\n+        return ret;\n@@ -623,30 +685,112 @@\n-    private static class LocationToFlags {\n-        private static Map<Location, Set<AccessFlag>> locationToFlags =\n-            Map.ofEntries(entry(Location.CLASS,\n-                                Set.of(PUBLIC, FINAL, SUPER,\n-                                       INTERFACE, ABSTRACT,\n-                                       SYNTHETIC, ANNOTATION,\n-                                       ENUM, AccessFlag.MODULE)),\n-                          entry(Location.FIELD,\n-                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n-                                       STATIC, FINAL, VOLATILE,\n-                                       TRANSIENT, SYNTHETIC, ENUM)),\n-                          entry(Location.METHOD,\n-                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n-                                       STATIC, FINAL, SYNCHRONIZED,\n-                                       BRIDGE, VARARGS, NATIVE,\n-                                       ABSTRACT, STRICT, SYNTHETIC)),\n-                          entry(Location.INNER_CLASS,\n-                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n-                                       STATIC, FINAL, INTERFACE, ABSTRACT,\n-                                       SYNTHETIC, ANNOTATION, ENUM)),\n-                          entry(Location.METHOD_PARAMETER,\n-                                Set.of(FINAL, SYNTHETIC, MANDATED)),\n-                          entry(Location.MODULE,\n-                                Set.of(OPEN, SYNTHETIC, MANDATED)),\n-                          entry(Location.MODULE_REQUIRES,\n-                                Set.of(TRANSITIVE, STATIC_PHASE, SYNTHETIC, MANDATED)),\n-                          entry(Location.MODULE_EXPORTS,\n-                                Set.of(SYNTHETIC, MANDATED)),\n-                          entry(Location.MODULE_OPENS,\n-                                Set.of(SYNTHETIC, MANDATED)));\n+    \/\/ Will take extra args in the future for valhalla switch\n+    private static AccessFlag[] findDefinition(Location location) {\n+        return switch (location) {\n+            case CLASS -> CLASS_FLAGS;\n+            case FIELD -> FIELD_FLAGS;\n+            case METHOD -> METHOD_FLAGS;\n+            case INNER_CLASS -> INNER_CLASS_FLAGS;\n+            case METHOD_PARAMETER -> METHOD_PARAMETER_FLAGS;\n+            case MODULE -> MODULE_FLAGS;\n+            case MODULE_REQUIRES -> MODULE_REQUIRES_FLAGS;\n+            case MODULE_EXPORTS -> MODULE_EXPORTS_FLAGS;\n+            case MODULE_OPENS -> MODULE_OPENS_FLAGS;\n+        };\n+    }\n+\n+    private static final @Stable AccessFlag[] \/\/ Can use stable array and lazy init in the future\n+            CLASS_FLAGS = createDefinition(PUBLIC, FINAL, SUPER, INTERFACE, ABSTRACT, SYNTHETIC, ANNOTATION, ENUM, MODULE),\n+            FIELD_FLAGS = createDefinition(PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, VOLATILE, TRANSIENT, SYNTHETIC, ENUM),\n+            METHOD_FLAGS = createDefinition(PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, SYNCHRONIZED, BRIDGE, VARARGS, NATIVE, ABSTRACT, STRICT, SYNTHETIC),\n+            INNER_CLASS_FLAGS = createDefinition(PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, INTERFACE, ABSTRACT, SYNTHETIC, ANNOTATION, ENUM),\n+            METHOD_PARAMETER_FLAGS = createDefinition(FINAL, SYNTHETIC, MANDATED),\n+            MODULE_FLAGS = createDefinition(OPEN, SYNTHETIC, MANDATED),\n+            MODULE_REQUIRES_FLAGS = createDefinition(TRANSITIVE, STATIC_PHASE, SYNTHETIC, MANDATED),\n+            MODULE_EXPORTS_FLAGS = createDefinition(SYNTHETIC, MANDATED),\n+            MODULE_OPENS_FLAGS = createDefinition(SYNTHETIC, MANDATED);\n+\n+    private static int undefinedMask(AccessFlag[] definition, int mask) {\n+        assert definition.length == Character.SIZE;\n+        int definedMask = 0;\n+        for (int i = 0; i < Character.SIZE; i++) {\n+            if (definition[i] != null) {\n+                definedMask |= 1 << i;\n+            }\n+        }\n+        return mask & ~definedMask;\n+    }\n+\n+    private static final class AccessFlagSet extends AbstractSet<AccessFlag> {\n+        private final @Stable AccessFlag[] definition;\n+        private final int mask;\n+\n+        \/\/ all mutating methods throw UnsupportedOperationException\n+        @Override public boolean add(AccessFlag e) { throw uoe(); }\n+        @Override public boolean addAll(Collection<? extends AccessFlag> c) { throw uoe(); }\n+        @Override public void    clear() { throw uoe(); }\n+        @Override public boolean remove(Object o) { throw uoe(); }\n+        @Override public boolean removeAll(Collection<?> c) { throw uoe(); }\n+        @Override public boolean removeIf(Predicate<? super AccessFlag> filter) { throw uoe(); }\n+        @Override public boolean retainAll(Collection<?> c) { throw uoe(); }\n+        private static UnsupportedOperationException uoe() { return new UnsupportedOperationException(); }\n+\n+        private AccessFlagSet(AccessFlag[] definition, int mask) {\n+            assert undefinedMask(definition, mask) == 0 : mask;\n+            this.definition = definition;\n+            this.mask = mask;\n+        }\n+\n+        @Override\n+        public Iterator<AccessFlag> iterator() {\n+            return new AccessFlagIterator(definition, mask);\n+        }\n+\n+        @Override\n+        public void forEach(Consumer<? super AccessFlag> action) {\n+            Objects.requireNonNull(action); \/\/ in case of empty\n+            for (int i = 0; i < Character.SIZE; i++) {\n+                if ((mask & (1 << i)) != 0) {\n+                    action.accept(definition[i]);\n+                }\n+            }\n+        }\n+\n+        private static final class AccessFlagIterator implements Iterator<AccessFlag> {\n+            private final @Stable AccessFlag[] definition;\n+            private int remainingMask;\n+\n+            private AccessFlagIterator(AccessFlag[] definition, int remainingMask) {\n+                this.definition = definition;\n+                this.remainingMask = remainingMask;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                return remainingMask != 0;\n+            }\n+\n+            @Override\n+            public AccessFlag next() {\n+                int flagBit = Integer.lowestOneBit(remainingMask);\n+                remainingMask &= ~flagBit;\n+                return definition[Integer.numberOfTrailingZeros(flagBit)];\n+            }\n+        }\n+\n+        @Override\n+        public int size() {\n+            return Integer.bitCount(mask);\n+        }\n+\n+        @Override\n+        public boolean contains(Object o) {\n+            if (Objects.requireNonNull(o) instanceof AccessFlag flag) {\n+                int bit = flag.mask;\n+                return (bit & mask) != 0 && definition[Integer.numberOfTrailingZeros(bit)] == flag;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return mask == 0;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":393,"deletions":249,"binary":false,"changes":642,"status":"modified"},{"patch":"@@ -451,0 +451,2 @@\n+     * @see AccessFlag.Location#CLASS\n+     * @see AccessFlag.Location#INNER_CLASS\n@@ -464,0 +466,2 @@\n+     * @see AccessFlag.Location#CLASS\n+     * @see AccessFlag.Location#INNER_CLASS\n@@ -477,0 +481,1 @@\n+     * @see AccessFlag.Location#METHOD\n@@ -490,0 +495,1 @@\n+     * @see AccessFlag.Location#METHOD\n@@ -503,0 +509,1 @@\n+     * @see AccessFlag.Location#FIELD\n@@ -516,0 +523,1 @@\n+     * @see AccessFlag.Location#METHOD_PARAMETER\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Modifier.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,0 +161,15 @@\n+\n+        for (var location : AccessFlag.Location.values()) {\n+            try {\n+                location.flags(null);\n+                throw new RuntimeException(\"Did not get NPE on \" + location + \".flags(null)\");\n+            } catch (NullPointerException npe ) {\n+                ; \/\/ Expected\n+            }\n+            try {\n+                location.flagsMask(null);\n+                throw new RuntimeException(\"Did not get NPE on \" + location + \".flagsMask(null)\");\n+            } catch (NullPointerException npe ) {\n+                ; \/\/ Expected\n+            }\n+        }\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/BasicAccessFlagTest.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import static java.lang.reflect.AccessFlag.*;\n+\n@@ -50,1 +52,1 @@\n-@ExpectedClassFlags(\"[PUBLIC, FINAL, SUPER]\")\n+@ExpectedClassFlags({PUBLIC, FINAL, SUPER})\n@@ -79,2 +81,4 @@\n-            String actual = clazz.accessFlags().toString();\n-            if (!expected.value().equals(actual)) {\n+            Set<AccessFlag> base = EnumSet.noneOf(AccessFlag.class);\n+            Collections.addAll(base, expected.value());\n+            Set<AccessFlag> actual = clazz.accessFlags();\n+            if (!base.equals(actual)) {\n@@ -82,1 +86,1 @@\n-                                           \" expected \" + expected.value() +\n+                                           \" expected \" + base +\n@@ -101,1 +105,1 @@\n-        var expected = Set.of(AccessFlag.PUBLIC,\n+        var expected = Set.of(PUBLIC,\n@@ -130,2 +134,2 @@\n-            if (flags.contains(AccessFlag.PUBLIC))\n-                accessLevel = AccessFlag.PUBLIC;\n+            if (flags.contains(PUBLIC))\n+                accessLevel = PUBLIC;\n@@ -148,1 +152,1 @@\n-                                Set.of(AccessFlag.PUBLIC,\n+                                Set.of(PUBLIC,\n@@ -164,1 +168,1 @@\n-    @ExpectedClassFlags(\"[PUBLIC, STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({PUBLIC, STATIC, INTERFACE, ABSTRACT})\n@@ -166,1 +170,1 @@\n-    @ExpectedClassFlags(\"[PROTECTED, STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({PROTECTED, STATIC, INTERFACE, ABSTRACT})\n@@ -168,1 +172,1 @@\n-    @ExpectedClassFlags(\"[PRIVATE, STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({PRIVATE, STATIC, INTERFACE, ABSTRACT})\n@@ -170,1 +174,1 @@\n-    @ExpectedClassFlags(\"[STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({STATIC, INTERFACE, ABSTRACT})\n@@ -173,1 +177,1 @@\n-    @ExpectedClassFlags(\"[FINAL]\")\n+    @ExpectedClassFlags({FINAL})\n@@ -176,1 +180,1 @@\n-    @ExpectedClassFlags(\"[ABSTRACT]\")\n+    @ExpectedClassFlags({ABSTRACT})\n@@ -179,1 +183,1 @@\n-    @ExpectedClassFlags(\"[STATIC, INTERFACE, ABSTRACT, ANNOTATION]\")\n+    @ExpectedClassFlags({STATIC, INTERFACE, ABSTRACT, ANNOTATION})\n@@ -182,1 +186,1 @@\n-    @ExpectedClassFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+    @ExpectedClassFlags({PUBLIC, STATIC, FINAL, ENUM})\n@@ -189,1 +193,1 @@\n-    @ExpectedClassFlags(\"[PROTECTED, STATIC, ABSTRACT, ENUM]\")\n+    @ExpectedClassFlags({PROTECTED, STATIC, ABSTRACT, ENUM})\n@@ -198,1 +202,1 @@\n-    @ExpectedClassFlags(\"[PRIVATE, ABSTRACT]\")\n+    @ExpectedClassFlags({PRIVATE, ABSTRACT})\n@@ -201,1 +205,1 @@\n-    @ExpectedClassFlags(\"[STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({STATIC, INTERFACE, ABSTRACT})\n@@ -206,1 +210,1 @@\n-@ExpectedClassFlags(\"[INTERFACE, ABSTRACT, ANNOTATION]\")\n+@ExpectedClassFlags({INTERFACE, ABSTRACT, ANNOTATION})\n@@ -208,1 +212,1 @@\n-    String value();\n+    AccessFlag[] value();\n@@ -211,1 +215,1 @@\n-@ExpectedClassFlags(\"[INTERFACE, ABSTRACT]\")\n+@ExpectedClassFlags({INTERFACE, ABSTRACT})\n@@ -215,1 +219,1 @@\n-@ExpectedClassFlags(\"[FINAL, SUPER, ENUM]\")\n+@ExpectedClassFlags({FINAL, SUPER, ENUM})\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/ClassAccessFlagTest.java","additions":28,"deletions":24,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,5 @@\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.Set;\n+\n+import static java.lang.reflect.AccessFlag.*;\n@@ -57,2 +62,4 @@\n-            String actual = field.accessFlags().toString();\n-            if (!expected.value().equals(actual)) {\n+            Set<AccessFlag> base = EnumSet.noneOf(AccessFlag.class);\n+            Collections.addAll(base, expected.value());\n+            Set<AccessFlag> actual = field.accessFlags();\n+            if (!base.equals(actual)) {\n@@ -60,2 +67,2 @@\n-                                           \" expected \" + expected.value() +\n-                                           \" got \" + actual);\n+                        \" expected \" + base +\n+                        \" got \" + actual);\n@@ -67,1 +74,1 @@\n-    @ExpectedFieldFlags(\"[PUBLIC, STATIC, FINAL]\")\n+    @ExpectedFieldFlags({PUBLIC, STATIC, FINAL})\n@@ -70,1 +77,1 @@\n-    @ExpectedFieldFlags(\"[PRIVATE, VOLATILE, TRANSIENT]\")\n+    @ExpectedFieldFlags({PRIVATE, VOLATILE, TRANSIENT})\n@@ -73,1 +80,1 @@\n-    @ExpectedFieldFlags(\"[PROTECTED]\")\n+    @ExpectedFieldFlags({PROTECTED})\n@@ -78,1 +85,1 @@\n-        @ExpectedFieldFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+        @ExpectedFieldFlags({PUBLIC, STATIC, FINAL, ENUM})\n@@ -81,1 +88,1 @@\n-        @ExpectedFieldFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+        @ExpectedFieldFlags({PUBLIC, STATIC, FINAL, ENUM})\n@@ -84,1 +91,1 @@\n-        @ExpectedFieldFlags(\"[PRIVATE]\") \/\/ no \"ENUM\"\n+        @ExpectedFieldFlags({PRIVATE}) \/\/ no \"ENUM\"\n@@ -90,1 +97,1 @@\n-        String value();\n+        AccessFlag[] value();\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/FieldAccessFlagTest.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,5 @@\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.Set;\n+\n+import static java.lang.reflect.AccessFlag.*;\n@@ -52,1 +57,1 @@\n-    @ExpectedMethodFlags(\"[PUBLIC, STATIC, VARARGS]\")\n+    @ExpectedMethodFlags({PUBLIC, STATIC, VARARGS})\n@@ -139,1 +144,1 @@\n-        ExpectedMethodFlags emf =\n+        ExpectedMethodFlags expected =\n@@ -141,3 +146,9 @@\n-        if (emf != null) {\n-            String actual = method.accessFlags().toString();\n-            checkString(method.toString(), emf.value(), actual);\n+        if (expected != null) {\n+            Set<AccessFlag> base = EnumSet.noneOf(AccessFlag.class);\n+            Collections.addAll(base, expected.value());\n+            Set<AccessFlag> actual = method.accessFlags();\n+            if (!base.equals(actual)) {\n+                throw new RuntimeException(\"On \" + method +\n+                        \" expected \" + base +\n+                        \" got \" + actual);\n+            }\n@@ -158,1 +169,1 @@\n-    @ExpectedMethodFlags(\"[PUBLIC]\")\n+    @ExpectedMethodFlags({PUBLIC})\n@@ -161,1 +172,1 @@\n-    @ExpectedMethodFlags(\"[PROTECTED]\")\n+    @ExpectedMethodFlags({PROTECTED})\n@@ -164,1 +175,1 @@\n-    @ExpectedMethodFlags(\"[PRIVATE]\")\n+    @ExpectedMethodFlags({PRIVATE})\n@@ -168,1 +179,1 @@\n-    @ExpectedMethodFlags(\"[PROTECTED, SYNCHRONIZED]\")\n+    @ExpectedMethodFlags({PROTECTED, SYNCHRONIZED})\n@@ -171,1 +182,1 @@\n-    @ExpectedMethodFlags(\"[PRIVATE]\")\n+    @ExpectedMethodFlags({PRIVATE})\n@@ -174,1 +185,1 @@\n-    @ExpectedMethodFlags(\"[ABSTRACT]\")\n+    @ExpectedMethodFlags({ABSTRACT})\n@@ -177,1 +188,1 @@\n-    @ExpectedMethodFlags(\"[PUBLIC, FINAL]\")\n+    @ExpectedMethodFlags({PUBLIC, FINAL})\n@@ -180,1 +191,1 @@\n-    @ExpectedMethodFlags(\"[NATIVE]\")\n+    @ExpectedMethodFlags({NATIVE})\n@@ -185,1 +196,1 @@\n-        String value();\n+        AccessFlag[] value();\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/MethodAccessFlagTest.java","additions":26,"deletions":15,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,5 @@\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.Set;\n+\n+import static java.lang.reflect.AccessFlag.*;\n@@ -45,1 +50,1 @@\n-    @ExpectedFlags(\"[PUBLIC, STATIC, VARARGS, STRICT]\")\n+    @ExpectedFlags({PUBLIC, STATIC, VARARGS, STRICT})\n@@ -62,2 +67,4 @@\n-            String actual = method.accessFlags().toString();\n-            if (!expected.value().equals(actual)) {\n+            Set<AccessFlag> base = EnumSet.noneOf(AccessFlag.class);\n+            Collections.addAll(base, expected.value());\n+            Set<AccessFlag> actual = method.accessFlags();\n+            if (!base.equals(actual)) {\n@@ -65,2 +72,2 @@\n-                                           \" expected \" + expected.value() +\n-                                           \" got \" + actual);\n+                        \" expected \" + base +\n+                        \" got \" + actual);\n@@ -72,1 +79,1 @@\n-    @ExpectedFlags(\"[PUBLIC, STRICT]\")\n+    @ExpectedFlags({PUBLIC, STRICT})\n@@ -77,1 +84,1 @@\n-        String value();\n+        AccessFlag[] value();\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/StrictAccessFlagTest.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- * @summary Tests of AccessFlag.locations(ClassFileFormatVersion)\n+ * @summary Tests of AccessFlag.locations(ClassFileFormatVersion) and\n+ *          accessors on AccessFlag.Location\n@@ -82,0 +83,2 @@\n+        testFlagVersionConsistency();\n+        testLocationMaskFlagConsistency();\n@@ -244,1 +247,1 @@\n-            if (cffv.compareTo(ClassFileFormatVersion.RELEASE_6) <= 0) {\n+            if (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) < 0) {\n@@ -249,1 +252,2 @@\n-                        case RELEASE_7 -> Set.of(Location.CLASS, Location.FIELD,\n+                        case RELEASE_5, RELEASE_6,\n+                             RELEASE_7 -> Set.of(Location.CLASS, Location.FIELD,\n@@ -288,0 +292,43 @@\n+    private static void testFlagVersionConsistency() {\n+        for (var flag : AccessFlag.values()) {\n+            for (var location : AccessFlag.Location.values()) {\n+                if (location.flags().contains(flag) != flag.locations().contains(location)) {\n+                    throw new RuntimeException(String.format(\"AccessFlag and Location inconsistency:\" +\n+                            \"flag %s and location %s are inconsistent for the latest version\"));\n+                }\n+            }\n+        }\n+        for (var cffv : ClassFileFormatVersion.values()) {\n+            for (var flag : AccessFlag.values()) {\n+                for (var location : AccessFlag.Location.values()) {\n+                    if (location.flags(cffv).contains(flag) != flag.locations(cffv).contains(location)) {\n+                        throw new RuntimeException(String.format(\"AccessFlag and Location inconsistency:\" +\n+                                \"flag %s and location %s are inconsistent for class file version %s\"));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void testLocationMaskFlagConsistency() {\n+        for (var location : AccessFlag.Location.values()) {\n+            if (!flagsAndMaskMatch(location.flags(), location.flagsMask())) {\n+                throw new RuntimeException(String.format(\"Flags and mask mismatch for %s\", location));\n+            }\n+            for (var cffv : ClassFileFormatVersion.values()) {\n+                if (!flagsAndMaskMatch(location.flags(cffv), location.flagsMask(cffv))) {\n+                    throw new RuntimeException(String.format(\"Flags and mask mismatch for %s in %s\", location, cffv));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean flagsAndMaskMatch(Set<AccessFlag> flags, int mask) {\n+        for (var flag : flags) {\n+            int bit = flag.mask();\n+            if (((mask & bit) == 0))\n+                return false;\n+            mask &= ~bit;\n+        }\n+        return mask == 0;\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/VersionedLocationsTest.java","additions":51,"deletions":4,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,0 +141,1 @@\n+        testImmutableSet(AccessFlag.maskToAccessFlags(Modifier.PUBLIC | Modifier.STATIC | Modifier.SYNCHRONIZED, AccessFlag.Location.METHOD), AccessFlag.ABSTRACT);\n","filename":"test\/jdk\/java\/util\/Collection\/MOAT.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}