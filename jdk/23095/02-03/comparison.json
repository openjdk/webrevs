{"files":[{"patch":"@@ -38,5 +38,5 @@\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Map;\n-import java.util.Set;\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+import jdk.internal.vm.annotation.Stable;\n@@ -46,1 +46,0 @@\n-import static java.util.Map.entry;\n@@ -371,9 +370,3 @@\n-        Set<AccessFlag> result = java.util.EnumSet.noneOf(AccessFlag.class);\n-        for (var accessFlag : LocationToFlags.LOCATION_TO_FLAGS.get(location)) {\n-            int accessMask = accessFlag.mask();\n-            if ((mask &  accessMask) != 0) {\n-                result.add(accessFlag);\n-                mask = mask & ~accessMask;\n-            }\n-        }\n-        if (mask != 0) {\n+        var definition = findDefinition(location);\n+        int unmatchedMask = mask & (~location.parsingMask()); \/\/ flagMask rejects strictfp\n+        if (unmatchedMask != 0) {\n@@ -381,2 +374,2 @@\n-                                               Integer.toHexString(mask) +\n-                                               \" for location \" + location);\n+                    Integer.toHexString(unmatchedMask) +\n+                    \" for location \" + location);\n@@ -384,1 +377,1 @@\n-        return Collections.unmodifiableSet(result);\n+        return new AccessFlagSet(definition, mask);\n@@ -629,0 +622,5 @@\n+        \/\/ Temporary shortcut to allow strict to be parsed\n+        private int parsingMask() {\n+            return this == METHOD ? flagsMask | ACC_STRICT : flagsMask;\n+        }\n+\n@@ -655,4 +653,1 @@\n-            if (this == METHOD) {\n-                return LocationToFlags.CURRENT_METHOD_FLAGS;\n-            }\n-            return LocationToFlags.LOCATION_TO_FLAGS.get(this);\n+            return new AccessFlagSet(findDefinition(this), flagsMask());\n@@ -673,2 +668,2 @@\n-            int flagsMask = flagsMask(cffv); \/\/ implicit null check\n-            return maskToAccessFlags(flagsMask, this);\n+            \/\/ implicit null check cffv\n+            return new AccessFlagSet(findDefinition(this), flagsMask(cffv));\n@@ -678,37 +673,123 @@\n-    private static final class LocationToFlags {\n-        \/\/ A map from location to flags that ever existed on the location\n-        private static final Map<Location, Set<AccessFlag>> LOCATION_TO_FLAGS =\n-            Map.ofEntries(entry(Location.CLASS,\n-                                Set.of(PUBLIC, FINAL, SUPER,\n-                                       INTERFACE, ABSTRACT,\n-                                       SYNTHETIC, ANNOTATION,\n-                                       ENUM, AccessFlag.MODULE)),\n-                          entry(Location.FIELD,\n-                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n-                                       STATIC, FINAL, VOLATILE,\n-                                       TRANSIENT, SYNTHETIC, ENUM)),\n-                          entry(Location.METHOD,\n-                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n-                                       STATIC, FINAL, SYNCHRONIZED,\n-                                       BRIDGE, VARARGS, NATIVE,\n-                                       ABSTRACT, STRICT, SYNTHETIC)),\n-                          entry(Location.INNER_CLASS,\n-                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n-                                       STATIC, FINAL, INTERFACE, ABSTRACT,\n-                                       SYNTHETIC, ANNOTATION, ENUM)),\n-                          entry(Location.METHOD_PARAMETER,\n-                                Set.of(FINAL, SYNTHETIC, MANDATED)),\n-                          entry(Location.MODULE,\n-                                Set.of(OPEN, SYNTHETIC, MANDATED)),\n-                          entry(Location.MODULE_REQUIRES,\n-                                Set.of(TRANSITIVE, STATIC_PHASE, SYNTHETIC, MANDATED)),\n-                          entry(Location.MODULE_EXPORTS,\n-                                Set.of(SYNTHETIC, MANDATED)),\n-                          entry(Location.MODULE_OPENS,\n-                                Set.of(SYNTHETIC, MANDATED)));\n-        \/\/ Current recognized flags on method, which does not include strict\n-        private static final Set<AccessFlag> CURRENT_METHOD_FLAGS = Set.of(\n-                PUBLIC, PRIVATE, PROTECTED,\n-                STATIC, FINAL, SYNCHRONIZED,\n-                BRIDGE, VARARGS, NATIVE,\n-                ABSTRACT, SYNTHETIC);\n+    private static AccessFlag[] createDefinition(AccessFlag... known) {\n+        var ret = new AccessFlag[Character.SIZE];\n+        for (var flag : known) {\n+            var mask = flag.mask;\n+            int pos = Integer.numberOfTrailingZeros(mask);\n+            assert ret[pos] == null : ret[pos] + \" \" + flag;\n+            ret[pos] = flag;\n+        }\n+        return ret;\n+    }\n+\n+    \/\/ Will take extra args in the future for valhalla switch\n+    private static AccessFlag[] findDefinition(Location location) {\n+        return switch (location) {\n+            case CLASS -> CLASS_FLAGS;\n+            case FIELD -> FIELD_FLAGS;\n+            case METHOD -> METHOD_FLAGS;\n+            case INNER_CLASS -> INNER_CLASS_FLAGS;\n+            case METHOD_PARAMETER -> METHOD_PARAMETER_FLAGS;\n+            case MODULE -> MODULE_FLAGS;\n+            case MODULE_REQUIRES -> MODULE_REQUIRES_FLAGS;\n+            case MODULE_EXPORTS -> MODULE_EXPORTS_FLAGS;\n+            case MODULE_OPENS -> MODULE_OPENS_FLAGS;\n+        };\n+    }\n+\n+    private static final @Stable AccessFlag[] \/\/ Can use stable array and lazy init in the future\n+            CLASS_FLAGS = createDefinition(PUBLIC, FINAL, SUPER, INTERFACE, ABSTRACT, SYNTHETIC, ANNOTATION, ENUM, AccessFlag.MODULE),\n+            FIELD_FLAGS = createDefinition(PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, VOLATILE, TRANSIENT, SYNTHETIC, ENUM),\n+            METHOD_FLAGS = createDefinition(PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, SYNCHRONIZED, BRIDGE, VARARGS, NATIVE, ABSTRACT, STRICT, SYNTHETIC),\n+            INNER_CLASS_FLAGS = createDefinition(PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, INTERFACE, ABSTRACT, SYNTHETIC, ANNOTATION, ENUM),\n+            METHOD_PARAMETER_FLAGS = createDefinition(FINAL, SYNTHETIC, MANDATED),\n+            MODULE_FLAGS = createDefinition(OPEN, SYNTHETIC, MANDATED),\n+            MODULE_REQUIRES_FLAGS = createDefinition(TRANSITIVE, STATIC_PHASE, SYNTHETIC, MANDATED),\n+            MODULE_EXPORTS_FLAGS = createDefinition(SYNTHETIC, MANDATED),\n+            MODULE_OPENS_FLAGS = createDefinition(SYNTHETIC, MANDATED);\n+\n+    private static int undefinedMask(AccessFlag[] definition, int mask) {\n+        assert definition.length == Character.SIZE;\n+        int definedMask = 0;\n+        for (int i = 0; i < Character.SIZE; i++) {\n+            if (definition[i] != null) {\n+                definedMask |= 1 << i;\n+            }\n+        }\n+        return mask & ~definedMask;\n+    }\n+\n+    private static final class AccessFlagSet extends AbstractSet<AccessFlag> {\n+        private final @Stable AccessFlag[] definition;\n+        private final int mask;\n+\n+        \/\/ all mutating methods throw UnsupportedOperationException\n+        @Override public boolean add(AccessFlag e) { throw uoe(); }\n+        @Override public boolean addAll(Collection<? extends AccessFlag> c) { throw uoe(); }\n+        @Override public void    clear() { throw uoe(); }\n+        @Override public boolean remove(Object o) { throw uoe(); }\n+        @Override public boolean removeAll(Collection<?> c) { throw uoe(); }\n+        @Override public boolean removeIf(Predicate<? super AccessFlag> filter) { throw uoe(); }\n+        @Override public boolean retainAll(Collection<?> c) { throw uoe(); }\n+        private static UnsupportedOperationException uoe() { return new UnsupportedOperationException(); }\n+\n+        private AccessFlagSet(AccessFlag[] definition, int mask) {\n+            assert undefinedMask(definition, mask) == 0 : mask;\n+            this.definition = definition;\n+            this.mask = mask;\n+        }\n+\n+        @Override\n+        public Iterator<AccessFlag> iterator() {\n+            return new AccessFlagIterator(definition, mask);\n+        }\n+\n+        @Override\n+        public void forEach(Consumer<? super AccessFlag> action) {\n+            Objects.requireNonNull(action); \/\/ in case of empty\n+            for (int i = 0; i < Character.SIZE; i++) {\n+                if ((mask & (1 << i)) != 0) {\n+                    action.accept(definition[i]);\n+                }\n+            }\n+        }\n+\n+        private static final class AccessFlagIterator implements Iterator<AccessFlag> {\n+            private final @Stable AccessFlag[] definition;\n+            private int remainingMask;\n+\n+            private AccessFlagIterator(AccessFlag[] definition, int remainingMask) {\n+                this.definition = definition;\n+                this.remainingMask = remainingMask;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                return remainingMask != 0;\n+            }\n+\n+            @Override\n+            public AccessFlag next() {\n+                int flagBit = Integer.lowestOneBit(remainingMask);\n+                remainingMask &= ~flagBit;\n+                return definition[Integer.numberOfTrailingZeros(flagBit)];\n+            }\n+        }\n+\n+        @Override\n+        public int size() {\n+            return Integer.bitCount(mask);\n+        }\n+\n+        @Override\n+        public boolean contains(Object o) {\n+            if (Objects.requireNonNull(o) instanceof AccessFlag flag) {\n+                int bit = flag.mask;\n+                return (bit & mask) != 0 && definition[Integer.numberOfTrailingZeros(bit)] == flag;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return mask == 0;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":142,"deletions":61,"binary":false,"changes":203,"status":"modified"}]}