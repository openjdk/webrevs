{"files":[{"patch":"@@ -711,0 +711,1 @@\n+  declare_constant(Deoptimization::Reason_auto_vectorization_check)       \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -349,0 +349,6 @@\n+  product(bool, LoopMultiversioning, true, DIAGNOSTIC,                      \\\n+          \"Enable loop multiversioning (for speculative compilation)\")      \\\n+                                                                            \\\n+  develop(bool, TraceLoopMultiversioning, false,                            \\\n+          \"Trace loop multiversioning\")                                     \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -431,1 +431,1 @@\n-  static IfNode* make_with_same_profile(IfNode* if_node_profile, Node* ctrl, BoolNode* bol);\n+  static IfNode* make_with_same_profile(IfNode* if_node_profile, Node* ctrl, Node* bol);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -280,0 +280,1 @@\n+macro(OpaqueMultiversioning)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4089,0 +4089,1 @@\n+  add_parse_predicate(Deoptimization::Reason_auto_vectorization_check, nargs);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -472,1 +472,1 @@\n-IfNode* IfNode::make_with_same_profile(IfNode* if_node_profile, Node* ctrl, BoolNode* bol) {\n+IfNode* IfNode::make_with_same_profile(IfNode* if_node_profile, Node* ctrl, Node* bol) {\n@@ -2180,0 +2180,1 @@\n+    case Deoptimization::Reason_auto_vectorization_check:\n@@ -2217,0 +2218,3 @@\n+    case Deoptimization::DeoptReason::Reason_auto_vectorization_check:\n+      st->print(\"Auto_Vectorization_Check \");\n+      break;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -748,0 +748,5 @@\n+      if (cl->is_multiversion()) {\n+        \/\/ Peeling also destroys the connection of the main loop\n+        \/\/ to the multiversion_if.\n+        cl->set_no_multiversion();\n+      }\n@@ -1177,2 +1182,3 @@\n-               bol->is_OpaqueInitializedAssertionPredicate(),\n-               \"Opaque node of a non-null-check or an Assertion Predicate\");\n+               bol->is_OpaqueInitializedAssertionPredicate() ||\n+               bol->is_OpaqueMultiversioning(),\n+               \"Opaque node of a non-null-check or an Assertion Predicate or Multiversioning\");\n@@ -3357,0 +3363,10 @@\n+  \/\/ If we are stalled, check if we can get unstalled.\n+  if (cl->is_multiversion_stalled_slow_loop() &&\n+      !phase->try_unstall_multiversion_stalled_slow_loop(this)) {\n+    \/\/ We are still stalled, waiting for the fast_loop to add runtime-checks\n+    \/\/ to the multiversion_if. We do not want to optimize, because we do not\n+    \/\/ know if such a runtime-check will ever be added. If not, this loop is\n+    \/\/ eventually folded away after loop-opts.\n+    return true;\n+  }\n+\n@@ -3416,0 +3432,6 @@\n+\n+      \/\/ We are going to add pre-loop and post-loop.\n+      \/\/ But should we also multi-version for auto-vectorization speculative\n+      \/\/ checks, i.e. fast and slow-paths?\n+      phase->maybe_multiversion_for_auto_vectorization_runtime_checks(this, old_new);\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,0 +35,17 @@\n+\/\/ Multiversioning:\n+\/\/ A loop is cloned, and a selector If decides which loop is taken at run-time: the true-path-loop (original) or the\n+\/\/ false-path-loop (cloned).\n+\/\/\n+\/\/ Use-cases:\n+\/\/ - Speculative compilation:\n+\/\/   The selector If checks some assumptions which allow stronger optimization in the true-path-loop. If the assumptions\n+\/\/   do not hold, we can still execute in the false-path-loop, although with fewer optimizations.\n+\/\/   See: PhaseIdealLoop::maybe_multiversion_for_auto_vectorization_runtime_checks\n+\/\/        PhaseIdealLoop::create_new_if_for_multiversion\n+\/\/\n+\/\/ - Unswitching:\n+\/\/   The selector If has the same (loop invariant) condition as some unswitching candidate If inside the loop. This\n+\/\/   allows us to constant-fold the unswitching candidate If to true in the true-path-loop and to false in the\n+\/\/   false-path-loop, thus eliminating the unswitching candidate If from the loop.\n+\/\/\n+\/\/\n@@ -148,4 +165,4 @@\n-\/\/ This class creates an If node (i.e. loop selector) that selects if the true-path-loop or the false-path-loop should be\n-\/\/ executed at runtime. This is done by finding an invariant and non-loop-exiting unswitch candidate If node (guaranteed\n-\/\/ to exist at this point) to perform Loop Unswitching on.\n-class UnswitchedLoopSelector : public StackObj {\n+\/\/ LoopSelector is used for loop multiversioning and unswitching. This class creates an If node (i.e. loop selector)\n+\/\/ that selects if the true-path-loop or the false-path-loop should be executed at runtime.\n+class LoopSelector : public StackObj {\n+  \/\/ Cached fields for construction.\n@@ -155,1 +172,3 @@\n-  IfNode* const _unswitch_candidate;\n+  const uint _dom_depth; \/\/ of original_loop_entry\n+\n+  \/\/ Constructed selector if with its projections.\n@@ -163,1 +182,2 @@\n-  UnswitchedLoopSelector(IdealLoopTree* loop)\n+  \/\/ For multiversioning: create a new selector (multiversion_if) from a bol condition.\n+  LoopSelector(IdealLoopTree* loop, Node* bol, float prob, float fcnt)\n@@ -167,2 +187,2 @@\n-        _unswitch_candidate(find_unswitch_candidate(loop)),\n-        _selector(create_selector_if()),\n+        _dom_depth(_phase->dom_depth(_original_loop_entry)),\n+        _selector(create_multiversioning_if(bol, prob, fcnt)), \/\/ multiversioning\n@@ -172,1 +192,0 @@\n-  NONCOPYABLE(UnswitchedLoopSelector);\n@@ -174,6 +193,18 @@\n- private:\n-  IfNode* find_unswitch_candidate(IdealLoopTree* loop) {\n-    IfNode* unswitch_candidate = _phase->find_unswitch_candidate(loop);\n-    assert(unswitch_candidate != nullptr, \"guaranteed to exist by policy_unswitching\");\n-    assert(_phase->is_member(loop, unswitch_candidate), \"must be inside original loop\");\n-    return unswitch_candidate;\n+  \/\/ For unswitching: create an unswitching if before the loop, from a pre-existing\n+  \/\/                  unswitching_candidate inside the loop.\n+  LoopSelector(IdealLoopTree* loop, IfNode* unswitch_candidate)\n+      : _phase(loop->_phase),\n+        _outer_loop(loop->skip_strip_mined()->_parent),\n+        _original_loop_entry(loop->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl)),\n+        _dom_depth(_phase->dom_depth(_original_loop_entry)),\n+        _selector(create_unswitching_if(unswitch_candidate)), \/\/ unswitching\n+        _true_path_loop_proj(create_proj_to_loop(TRUE_PATH)->as_IfTrue()),\n+        _false_path_loop_proj(create_proj_to_loop(FALSE_PATH)->as_IfFalse()) {\n+  }\n+  NONCOPYABLE(LoopSelector);\n+\n+  IfNode* create_multiversioning_if(Node* bol, float prob, float fcnt) {\n+    _phase->igvn().rehash_node_delayed(_original_loop_entry);\n+    IfNode* selector_if = new IfNode(_original_loop_entry, bol, prob, fcnt);\n+    _phase->register_node(selector_if, _outer_loop, _original_loop_entry, _dom_depth);\n+    return selector_if;\n@@ -182,2 +213,1 @@\n-  IfNode* create_selector_if() const {\n-    const uint dom_depth = _phase->dom_depth(_original_loop_entry);\n+  IfNode* create_unswitching_if(IfNode* unswitch_candidate) {\n@@ -185,2 +215,2 @@\n-    BoolNode* unswitch_candidate_bool = _unswitch_candidate->in(1)->as_Bool();\n-    IfNode* selector_if = IfNode::make_with_same_profile(_unswitch_candidate, _original_loop_entry,\n+    BoolNode* unswitch_candidate_bool = unswitch_candidate->in(1)->as_Bool();\n+    IfNode* selector_if = IfNode::make_with_same_profile(unswitch_candidate, _original_loop_entry,\n@@ -188,1 +218,1 @@\n-    _phase->register_node(selector_if, _outer_loop, _original_loop_entry, dom_depth);\n+    _phase->register_node(selector_if, _outer_loop, _original_loop_entry, _dom_depth);\n@@ -192,0 +222,1 @@\n+ private:\n@@ -193,1 +224,0 @@\n-    const uint dom_depth = _phase->dom_depth(_original_loop_entry);\n@@ -200,1 +230,1 @@\n-    _phase->register_node(proj_to_loop, _outer_loop, _selector, dom_depth);\n+    _phase->register_node(proj_to_loop, _outer_loop, _selector, _dom_depth);\n@@ -205,4 +235,0 @@\n-  IfNode* unswitch_candidate() const {\n-    return _unswitch_candidate;\n-  }\n-\n@@ -222,0 +248,31 @@\n+\/\/ This class creates an If node (i.e. loop selector) that selects if the true-path-loop or the false-path-loop should be\n+\/\/ executed at runtime. This is done by finding an invariant and non-loop-exiting unswitch candidate If node (guaranteed\n+\/\/ to exist at this point) to perform Loop Unswitching on.\n+class UnswitchedLoopSelector : public StackObj {\n+  IfNode* const _unswitch_candidate;\n+  const LoopSelector _loop_selector;\n+\n+ public:\n+  UnswitchedLoopSelector(IdealLoopTree* loop)\n+      : _unswitch_candidate(find_unswitch_candidate(loop)),\n+        _loop_selector(loop, _unswitch_candidate) {}\n+  NONCOPYABLE(UnswitchedLoopSelector);\n+\n+ private:\n+  static IfNode* find_unswitch_candidate(IdealLoopTree* loop) {\n+    IfNode* unswitch_candidate = loop->_phase->find_unswitch_candidate(loop);\n+    assert(unswitch_candidate != nullptr, \"guaranteed to exist by policy_unswitching\");\n+    assert(loop->_phase->is_member(loop, unswitch_candidate), \"must be inside original loop\");\n+    return unswitch_candidate;\n+  }\n+\n+ public:\n+  IfNode* unswitch_candidate() const {\n+    return _unswitch_candidate;\n+  }\n+\n+  const LoopSelector& loop_selector() const {\n+    return _loop_selector;\n+  }\n+};\n+\n@@ -241,0 +298,7 @@\n+    multiversion(unswitched_loop_selector.loop_selector());\n+    remove_unswitch_candidate_from_loops(unswitched_loop_selector);\n+  }\n+\n+  \/\/ Multiversion the original loop. The loop selector if selects between the original loop (true-path-loop), and\n+  \/\/ a copy of it (false-path-loop).\n+  void multiversion(const LoopSelector& loop_selector) {\n@@ -242,1 +306,1 @@\n-    clone_loop(unswitched_loop_selector);\n+    clone_loop(loop_selector);\n@@ -244,1 +308,1 @@\n-    move_parse_and_template_assertion_predicates_to_unswitched_loops(unswitched_loop_selector,\n+    move_parse_and_template_assertion_predicates_to_unswitched_loops(loop_selector,\n@@ -246,1 +310,1 @@\n-    DEBUG_ONLY(verify_unswitched_loop_versions(_loop->_head->as_Loop(), unswitched_loop_selector);)\n+    DEBUG_ONLY(verify_loop_versions(_loop->_head->as_Loop(), loop_selector);)\n@@ -249,1 +313,0 @@\n-    remove_unswitch_candidate_from_loops(unswitched_loop_selector);\n@@ -253,1 +316,1 @@\n-  void clone_loop(const UnswitchedLoopSelector& unswitched_loop_selector) {\n+  void clone_loop(const LoopSelector& loop_selector) {\n@@ -255,2 +318,2 @@\n-                       PhaseIdealLoop::CloneIncludesStripMined, unswitched_loop_selector.selector());\n-    fix_loop_entries(unswitched_loop_selector);\n+                       PhaseIdealLoop::CloneIncludesStripMined, loop_selector.selector());\n+    fix_loop_entries(loop_selector);\n@@ -259,2 +322,2 @@\n-  void fix_loop_entries(const UnswitchedLoopSelector& unswitched_loop_selector) {\n-    _phase->replace_loop_entry(_loop_head, unswitched_loop_selector.true_path_loop_proj());\n+  void fix_loop_entries(const LoopSelector& loop_selector) {\n+    _phase->replace_loop_entry(_loop_head, loop_selector.true_path_loop_proj());\n@@ -263,1 +326,1 @@\n-                               unswitched_loop_selector.false_path_loop_proj());\n+                               loop_selector.false_path_loop_proj());\n@@ -270,1 +333,1 @@\n-    const UnswitchedLoopSelector& unswitched_loop_selector, const uint first_false_path_loop_node_index) const {\n+    const LoopSelector& loop_selector, const uint first_false_path_loop_node_index) const {\n@@ -276,1 +339,1 @@\n-    Node* source_loop_entry = unswitched_loop_selector.selector()->in(0);\n+    Node* source_loop_entry = loop_selector.selector()->in(0);\n@@ -282,5 +345,6 @@\n-  void verify_unswitched_loop_versions(LoopNode* true_path_loop_head,\n-                                       const UnswitchedLoopSelector& unswitched_loop_selector) const {\n-    verify_unswitched_loop_version(true_path_loop_head, unswitched_loop_selector.true_path_loop_proj());\n-    verify_unswitched_loop_version(old_to_new(true_path_loop_head)->as_Loop(),\n-                                   unswitched_loop_selector.false_path_loop_proj());\n+  void verify_loop_versions(LoopNode* true_path_loop_head,\n+                            const LoopSelector& loop_selector) const {\n+    verify_loop_version(true_path_loop_head,\n+                        loop_selector.true_path_loop_proj());\n+    verify_loop_version(old_to_new(true_path_loop_head)->as_Loop(),\n+                        loop_selector.false_path_loop_proj());\n@@ -289,1 +353,1 @@\n-  static void verify_unswitched_loop_version(LoopNode* loop_head, IfProjNode* loop_selector_if_proj) {\n+  static void verify_loop_version(LoopNode* loop_head, IfProjNode* loop_selector_if_proj) {\n@@ -305,7 +369,8 @@\n-    IfNode* unswitching_candidate = unswitched_loop_selector.unswitch_candidate();\n-    _phase->igvn().rehash_node_delayed(unswitching_candidate);\n-    _phase->dominated_by(unswitched_loop_selector.true_path_loop_proj(), unswitching_candidate);\n-\n-    IfNode* unswitching_candidate_clone = _old_new[unswitching_candidate->_idx]->as_If();\n-    _phase->igvn().rehash_node_delayed(unswitching_candidate_clone);\n-    _phase->dominated_by(unswitched_loop_selector.false_path_loop_proj(), unswitching_candidate_clone);\n+    const LoopSelector& loop_selector = unswitched_loop_selector.loop_selector();;\n+    IfNode* unswitch_candidate        = unswitched_loop_selector.unswitch_candidate();\n+    _phase->igvn().rehash_node_delayed(unswitch_candidate);\n+    _phase->dominated_by(loop_selector.true_path_loop_proj(), unswitch_candidate);\n+\n+    IfNode* unswitch_candidate_clone = _old_new[unswitch_candidate->_idx]->as_If();\n+    _phase->igvn().rehash_node_delayed(unswitch_candidate_clone);\n+    _phase->dominated_by(loop_selector.false_path_loop_proj(), unswitch_candidate_clone);\n@@ -313,1 +378,0 @@\n-\n@@ -346,0 +410,165 @@\n+void PhaseIdealLoop::do_multiversioning(IdealLoopTree* lpt, Node_List& old_new) {\n+#ifndef PRODUCT\n+  if (TraceLoopOpts || TraceLoopMultiversioning) {\n+    tty->print(\"Multiversion \");\n+    lpt->dump_head();\n+  }\n+#endif\n+  assert(LoopMultiversioning, \"LoopMultiversioning must be enabled\");\n+\n+  CountedLoopNode* original_head = lpt->_head->as_CountedLoop();\n+  C->print_method(PHASE_BEFORE_LOOP_MULTIVERSIONING, 4, original_head);\n+\n+  Node* one = _igvn.intcon(1);\n+  set_ctrl(one, C->root());\n+  Node* opaque = new OpaqueMultiversioningNode(C, one);\n+  set_ctrl(opaque, C->root());\n+  _igvn.register_new_node_with_optimizer(opaque);\n+  _igvn.set_type(opaque, TypeInt::BOOL);\n+\n+  const LoopSelector loop_selector(lpt, opaque, PROB_LIKELY_MAG(3), COUNT_UNKNOWN);\n+  OriginalLoop original_loop(lpt, old_new);\n+  original_loop.multiversion(loop_selector);\n+\n+  add_unswitched_loop_version_bodies_to_igvn(lpt, old_new);\n+\n+  CountedLoopNode* new_head = old_new[original_head->_idx]->as_CountedLoop();\n+  original_head->set_multiversion_fast_loop();\n+  new_head->set_multiversion_stalled_slow_loop();\n+\n+  NOT_PRODUCT(trace_loop_multiversioning_result(loop_selector, original_head, new_head);)\n+  C->print_method(PHASE_AFTER_LOOP_MULTIVERSIONING, 4, new_head);\n+  C->set_major_progress();\n+}\n+\n+\/\/ Create a new if in the multiversioning pattern, adding an additional condition for the\n+\/\/ multiversioning fast-loop.\n+\/\/\n+\/\/ Before:\n+\/\/                       entry  opaque\n+\/\/                         |      |\n+\/\/                      multiversion_if\n+\/\/                         |      |\n+\/\/        +----------------+      +---------------+\n+\/\/        |                                       |\n+\/\/   multiversion_fast_proj          multiversion_slow_proj\n+\/\/                                                |\n+\/\/                                                +--------+\n+\/\/                                                         |\n+\/\/                                                      slow_path\n+\/\/\n+\/\/\n+\/\/ After:\n+\/\/                     entry  opaque <-- to be replaced by caller\n+\/\/                         |  |\n+\/\/                        new_if\n+\/\/                         |  |\n+\/\/                         |  +-----------------------------+\n+\/\/                         |                                |\n+\/\/                 new_if_true  opaque                new_if_false\n+\/\/                         |      |                         |\n+\/\/                      multiversion_if                     |\n+\/\/                         |      |                         |\n+\/\/        +----------------+      +---------------+         |\n+\/\/        |                                       |         |\n+\/\/   multiversion_fast_proj      new_multiversion_slow_proj |\n+\/\/                                                |         |\n+\/\/                                                +------+  |\n+\/\/                                                       |  |\n+\/\/                                                      region\n+\/\/                                                         |\n+\/\/                                                      slow_path\n+\/\/\n+IfTrueNode* PhaseIdealLoop::create_new_if_for_multiversion(IfTrueNode* multiversioning_fast_proj) {\n+  \/\/ Give all nodes in the old sub-graph a name.\n+  IfNode* multiversion_if = multiversioning_fast_proj->in(0)->as_If();\n+  Node* entry = multiversion_if->in(0);\n+  OpaqueMultiversioningNode* opaque = multiversion_if->in(1)->as_OpaqueMultiversioning();\n+  IfFalseNode* multiversion_slow_proj = multiversion_if->proj_out(0)->as_IfFalse();\n+  Node* slow_path = multiversion_slow_proj->unique_ctrl_out();\n+\n+  \/\/ Now that we have at least one condition for the multiversioning,\n+  \/\/ we should unstall the slow loop.\n+  opaque->unstall_slow_loop();\n+\n+  \/\/ Create new_if with its projections.\n+  IfNode* new_if = IfNode::make_with_same_profile(multiversion_if, entry, opaque);\n+  IdealLoopTree* lp = get_loop(entry);\n+  register_control(new_if, lp, entry);\n+\n+  IfTrueNode*  new_if_true  = new IfTrueNode(new_if);\n+  IfFalseNode* new_if_false = new IfFalseNode(new_if);\n+  register_control(new_if_true,  lp, new_if);\n+  register_control(new_if_false, lp, new_if);\n+\n+  \/\/ Hook new_if_true into multiversion_if.\n+  _igvn.replace_input_of(multiversion_if, 0, new_if_true);\n+\n+  \/\/ Clone multiversion_slow_path - this allows us to easily carry the dependencies to\n+  \/\/ the new region below.\n+  IfFalseNode* new_multiversion_slow_proj = multiversion_slow_proj->clone()->as_IfFalse();\n+  register_control(new_multiversion_slow_proj, lp, multiversion_if);\n+\n+  \/\/ Create new Region.\n+  RegionNode* region = new RegionNode(1);\n+  region->add_req(new_multiversion_slow_proj);\n+  region->add_req(new_if_false);\n+  register_control(region, lp, new_multiversion_slow_proj);\n+\n+  \/\/ Hook region into slow_path, in stead of the multiversion_slow_proj.\n+  \/\/ This also moves all other dependencies of the multiversion_slow_proj to the region.\n+  _igvn.replace_node(multiversion_slow_proj, region);\n+\n+  return new_if_true;\n+}\n+\n+OpaqueMultiversioningNode* find_multiversion_opaque_from_multiversion_if_false(Node* maybe_multiversion_if_false) {\n+  IfFalseNode* multiversion_if_false = maybe_multiversion_if_false->isa_IfFalse();\n+  if (multiversion_if_false == nullptr) { return nullptr; }\n+  IfNode* multiversion_if = multiversion_if_false->in(0)->isa_If();\n+  if (multiversion_if == nullptr) { return nullptr; }\n+  return multiversion_if->in(1)->isa_OpaqueMultiversioning();\n+}\n+\n+bool PhaseIdealLoop::try_unstall_multiversion_stalled_slow_loop(IdealLoopTree* lpt) {\n+  CountedLoopNode* cl = lpt->_head->as_CountedLoop();\n+  assert(cl->is_multiversion_stalled_slow_loop(), \"must currently be stalled\");\n+\n+  \/\/ Find multiversion_if.\n+  Node* entry = cl->skip_strip_mined()->in(LoopNode::EntryControl);\n+  const Predicates predicates(entry);\n+\n+  Node* slow_path = predicates.entry();\n+\n+  \/\/ Find opaque.\n+  OpaqueMultiversioningNode* opaque = nullptr;\n+  if (slow_path->is_Region()) {\n+    for (uint i = 1; i < slow_path->req(); i++) {\n+      Node* n = slow_path->in(i);\n+      opaque = find_multiversion_opaque_from_multiversion_if_false(n);\n+      if (opaque != nullptr) { break; }\n+    }\n+  } else {\n+    opaque = find_multiversion_opaque_from_multiversion_if_false(slow_path);\n+  }\n+  assert(opaque != nullptr, \"must have found multiversion opaque node\");\n+  if (opaque == nullptr) { return false; }\n+\n+  \/\/ We may still be stalled, if there were not yet any runtime-checks added\n+  \/\/ for the multiversioning. We may never add any, and then this loop would\n+  \/\/ fold away. So we wait until some runtime-checks are added, then we know\n+  \/\/ that this loop will be reachable and it is worth optimizing further.\n+  if (opaque->is_stall_slow_loop()) { return false; }\n+\n+  \/\/ Clear away the stalling.\n+  cl->set_no_multiversion();\n+  cl->set_multiversion_slow_loop();\n+#ifndef PRODUCT\n+  if (TraceLoopOpts) {\n+    tty->print(\"Unstall \");\n+    lpt->dump_head();\n+  }\n+#endif\n+  return true;\n+}\n+\n@@ -380,1 +609,1 @@\n-    IfNode* loop_selector = unswitched_loop_selector.selector();\n+    IfNode* loop_selector = unswitched_loop_selector.loop_selector().selector();\n@@ -388,0 +617,11 @@\n+\n+void PhaseIdealLoop::trace_loop_multiversioning_result(const LoopSelector& loop_selector,\n+                                                       const LoopNode* original_head, const LoopNode* new_head) {\n+  if (TraceLoopMultiversioning) {\n+    IfNode* selector_if = loop_selector.selector();\n+    tty->print_cr(\"Loop Multiversioning:\");\n+    tty->print_cr(\"- Loop-Selector-If: %d %s\", selector_if->_idx, selector_if->Name());\n+    tty->print_cr(\"- True-Path-Loop (=Orig \/ Fast): %d %s\", original_head->_idx, original_head->Name());\n+    tty->print_cr(\"- False-Path-Loop (=Clone \/ Slow): %d %s\", new_head->_idx, new_head->Name());\n+  }\n+}\n@@ -391,1 +631,1 @@\n-\/\/ post loop anymore after loop unswitching.\n+\/\/ post loop anymore after loop unswitching. We also lose the multiversion structure, with access to the multiversion_if.\n@@ -394,3 +634,3 @@\n-  if (cl != nullptr && !cl->is_normal_loop()) {\n-    cl->set_normal_loop();\n-  }\n+  if (cl == nullptr) { return; }\n+  if (!cl->is_normal_loop()) { cl->set_normal_loop(); }\n+  if (cl->is_multiversion()) { cl->set_no_multiversion(); }\n@@ -403,1 +643,1 @@\n-  IfNode* loop_selector = unswitched_loop_selector.selector();\n+  IfNode* loop_selector = unswitched_loop_selector.loop_selector().selector();\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":298,"deletions":58,"binary":false,"changes":356,"status":"modified"},{"patch":"@@ -1093,0 +1093,8 @@\n+\n+    \/\/ We only want to use the auto-vectorization check as a trap once per bci. And\n+    \/\/ PhaseIdealLoop::add_parse_predicate only checks trap limits per method, so\n+    \/\/ we do a custom check here.\n+    if (!C->too_many_traps(cloned_sfpt->jvms()->method(), cloned_sfpt->jvms()->bci(), Deoptimization::Reason_auto_vectorization_check)) {\n+      add_parse_predicate(Deoptimization::Reason_auto_vectorization_check, inner_head, outer_ilt, cloned_sfpt);\n+    }\n+\n@@ -2514,0 +2522,3 @@\n+  if (is_multiversion_fast_loop())         { st->print(\" multiversion_fast\"); }\n+  if (is_multiversion_slow_loop())         { st->print(\" multiversion_slow\"); }\n+  if (is_multiversion_stalled_slow_loop()) { st->print(\" multiversion_stalled_slow\"); }\n@@ -4306,0 +4317,3 @@\n+    if (cl->is_multiversion_fast_loop())         { tty->print(\" multiversion_fast\"); }\n+    if (cl->is_multiversion_slow_loop())         { tty->print(\" multiversion_slow\"); }\n+    if (cl->is_multiversion_stalled_slow_loop()) { tty->print(\" multiversion_stalled_slow\"); }\n@@ -4951,12 +4965,0 @@\n-  \/\/ Keep loop predicates and perform optimizations with them\n-  \/\/ until no more loop optimizations could be done.\n-  \/\/ After that switch predicates off and do more loop optimizations.\n-  if (!C->major_progress() && (C->parse_predicate_count() > 0)) {\n-    C->mark_parse_predicate_nodes_useless(_igvn);\n-    assert(C->parse_predicate_count() == 0, \"should be zero now\");\n-     if (TraceLoopOpts) {\n-       tty->print_cr(\"PredicatesOff\");\n-     }\n-     C->set_major_progress();\n-  }\n-\n@@ -4995,0 +4997,12 @@\n+\n+  \/\/ Keep loop predicates and perform optimizations with them\n+  \/\/ until no more loop optimizations could be done.\n+  \/\/ After that switch predicates off and do more loop optimizations.\n+  if (!C->major_progress() && (C->parse_predicate_count() > 0)) {\n+    C->mark_parse_predicate_nodes_useless(_igvn);\n+    assert(C->parse_predicate_count() == 0, \"should be zero now\");\n+    if (TraceLoopOpts) {\n+      tty->print_cr(\"PredicatesOff\");\n+    }\n+    C->set_major_progress();\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":26,"deletions":12,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+class LoopSelector;\n@@ -82,1 +83,6 @@\n-         LoopNestLongOuterLoop = 1<<16 };\n+         LoopNestLongOuterLoop = 1<<16,\n+         MultiversionFastLoop         = 1<<17,\n+         MultiversionSlowLoop         = 2<<17,\n+         MultiversionStalledSlowLoop  = 3<<17,\n+         MultiversionFlagsMask        = 3<<17,\n+       };\n@@ -318,0 +324,22 @@\n+  \/\/ Multiversioning allows us to duplicate a CountedLoop, and have two versions:\n+  \/\/ (1) fast_loop: we make speculative assumptions and add the corresponding\n+  \/\/                runtime-checks above the multiversion_if which is guarded\n+  \/\/                by a OpaqueMultiversioning.\n+  \/\/ (2) slow_loop: we make no assumptions. This loop is taken if any of the\n+  \/\/                runtime-checks fails. We keep this loop stalled as long\n+  \/\/                as there are no runtime-checks added. As long as it is stalled,\n+  \/\/                we do not perform any loop-opts on the slow_loop. If no\n+  \/\/                runtime-checks are everadded, this slow_loop is folded away\n+  \/\/                after loop-opts. The stalling means we do not waste and cycles\n+  \/\/                on a loop that may eventually be folded away. Once a runtime-check\n+  \/\/                is added, the slow_loop is unstalled, and more loop-opts can\n+  \/\/                be performed on it (but still without any speculative assumptions).\n+  bool is_multiversion()                   const { return (_loop_flags & MultiversionFlagsMask) != Normal; }\n+  bool is_multiversion_fast_loop()         const { return (_loop_flags & MultiversionFlagsMask) == MultiversionFastLoop; }\n+  bool is_multiversion_slow_loop()         const { return (_loop_flags & MultiversionFlagsMask) == MultiversionSlowLoop; }\n+  bool is_multiversion_stalled_slow_loop() const { return (_loop_flags & MultiversionFlagsMask) == MultiversionStalledSlowLoop; }\n+  void set_multiversion_fast_loop()         { assert(!is_multiversion(), \"\"); _loop_flags |= MultiversionFastLoop; }\n+  void set_multiversion_slow_loop()         { assert(!is_multiversion(), \"\"); _loop_flags |= MultiversionSlowLoop; }\n+  void set_multiversion_stalled_slow_loop() { assert(!is_multiversion(), \"\"); _loop_flags |= MultiversionStalledSlowLoop; }\n+  void set_no_multiversion()                { assert( is_multiversion(), \"\"); _loop_flags &= ~MultiversionFlagsMask; }\n+\n@@ -1460,0 +1488,2 @@\n+  static void trace_loop_multiversioning_result(const LoopSelector& loop_selector,\n+                                                const LoopNode* original_head, const LoopNode* new_head);\n@@ -1486,0 +1516,5 @@\n+  void maybe_multiversion_for_auto_vectorization_runtime_checks(IdealLoopTree* lpt, Node_List& old_new);\n+  void do_multiversioning(IdealLoopTree* lpt, Node_List& old_new);\n+  IfTrueNode* create_new_if_for_multiversion(IfTrueNode* multiversioning_fast_proj);\n+  bool try_unstall_multiversion_stalled_slow_loop(IdealLoopTree* lpt);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -4485,0 +4485,60 @@\n+\/\/ Just before insert_pre_post_loops, we can multi-version the loop:\n+\/\/\n+\/\/              multiversion_if\n+\/\/               |       |\n+\/\/         fast_loop   slow_loop\n+\/\/\n+\/\/ In the fast_loop we can make speculative assumptions, and put the\n+\/\/ conditions into the multiversion_if. If the conditions hold at runtime,\n+\/\/ we enter the fast_loop, if the conditions fail, we take the slow_loop\n+\/\/ instead which does not make any of the speculative assumptions.\n+\/\/\n+\/\/ Note: we only multiversion the loop if the loop does not have any\n+\/\/       auto vectorization check Predicate. If we have that predicate,\n+\/\/       then we can simply add the speculative assumption checks to\n+\/\/       that Predicate. This means we do not need to duplicate the\n+\/\/       loop - we have a smaller graph and save compile time. Should\n+\/\/       the conditions ever fail, then we deopt \/ trap at the Predicate\n+\/\/       and recompile without that Predicate. At that point we will\n+\/\/       multiversion the loop, so that we can still have speculative\n+\/\/       runtime checks.\n+\/\/\n+\/\/ We perform the multiversioning when the loop is still in its single\n+\/\/ iteration form, even before we insert pre and post loops. This makes\n+\/\/ the cloning much simpler. However, this means that both the fast\n+\/\/ and the slow loop have to be optimized independently (adding pre\n+\/\/ and post loops, unrolling the main loop, auto-vectorize etc.). And\n+\/\/ we may end up not needing any speculative assumptions in the fast_loop\n+\/\/ and then rejecting the slow_loop by constant folding the multiversion_if.\n+\/\/\n+\/\/ Therefore, we \"stall\" the optimization of the slow_loop until we add\n+\/\/ at least one speculative assumption for the fast_loop. If we never\n+\/\/ add such a speculative runtime check, the OpaqueMultiversioningNode\n+\/\/ of the multiversion_if constant folds to true after loop opts, and the\n+\/\/ multiversion_if folds away the \"stalled\" slow_loop. If we add any\n+\/\/ speculative assumption, then we mark the OpaqueMultiversioningNode\n+\/\/ with \"unstall_slow_loop\", so that the slow_loop can be optimized.\n+\/\/\n+\/\/ Note: new runtime checks can be added to the multiversion_if with\n+\/\/       PhaseIdealLoop::create_new_if_for_multiversion\n+void PhaseIdealLoop::maybe_multiversion_for_auto_vectorization_runtime_checks(IdealLoopTree* lpt, Node_List& old_new) {\n+  CountedLoopNode* cl = lpt->_head->as_CountedLoop();\n+  LoopNode* outer_loop = cl->skip_strip_mined();\n+  Node* entry = outer_loop->in(LoopNode::EntryControl);\n+\n+  \/\/ Check we have multiversioning enabled, and are not already multiversioned.\n+  if (!LoopMultiversioning || cl->is_multiversion()) { return; }\n+\n+  \/\/ Check that we do not have a parse-predicate where we can add the runtime checks\n+  \/\/ during auto-vectorization.\n+  const Predicates predicates(entry);\n+  const PredicateBlock* predicate_block = predicates.auto_vectorization_check_block();\n+  if (predicate_block->has_parse_predicate()) { return; }\n+\n+  \/\/ Check node budget.\n+  uint estimate = lpt->est_loop_clone_sz(2);\n+  if (!may_require_nodes(estimate)) { return; }\n+\n+  do_multiversioning(lpt, old_new);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -232,0 +232,1 @@\n+\/\/\n@@ -234,1 +235,3 @@\n-\/\/     assume that such base addresses are aligned (TODO: need to add this speculative check in JDK-8323582).\n+\/\/     assume that such base addresses are aligned. We performs such a speculative alignment runtime check\n+\/\/     in VTransform::add_speculative_alignment_check.\n+\/\/\n","filename":"src\/hotspot\/share\/opto\/mempointer.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+class OpaqueMultiversioningNode;\n@@ -803,0 +804,1 @@\n+      DEFINE_CLASS_ID(OpaqueMultiversioning, Opaque1, 2)\n@@ -985,0 +987,1 @@\n+  DEFINE_CLASS_QUERY(OpaqueMultiversioning)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -94,0 +94,20 @@\n+\/\/ This node is used to mark the auto vectorization Predicate, and\n+\/\/ allow the multiversion fast_loop to notify the slow_loop when\n+\/\/ the slow_loop is to be \"unstalled\".\n+\/\/ See PhaseIdealLoop::maybe_multiversion_for_auto_vectorization_runtime_checks\n+class OpaqueMultiversioningNode : public Opaque1Node {\n+private:\n+  bool _is_stall_slow_loop;\n+\n+public:\n+  OpaqueMultiversioningNode(Compile* C, Node* n) :\n+      Opaque1Node(C, n), _is_stall_slow_loop(true)\n+  {\n+    init_class_id(Class_OpaqueMultiversioning);\n+  }\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeInt::BOOL; }\n+  bool is_stall_slow_loop() const { return _is_stall_slow_loop; }\n+  void unstall_slow_loop() { _is_stall_slow_loop = false; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+  flags(BEFORE_LOOP_MULTIVERSIONING,    \"Before Loop Multiversioning\") \\\n+  flags(AFTER_LOOP_MULTIVERSIONING,     \"After Loop Multiversioning\") \\\n@@ -71,4 +73,5 @@\n-  flags(AUTO_VECTORIZATION1_BEFORE_APPLY,       \"AutoVectorization 1, Before Apply\") \\\n-  flags(AUTO_VECTORIZATION2_AFTER_REORDER,      \"AutoVectorization 2, After Apply Memop Reordering\") \\\n-  flags(AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT, \"AutoVectorization 3, After Adjusting Pre-Loop Limit\") \\\n-  flags(AUTO_VECTORIZATION4_AFTER_APPLY,        \"AutoVectorization 4, After Apply\") \\\n+  flags(AUTO_VECTORIZATION1_BEFORE_APPLY,                     \"AutoVectorization 1, Before Apply\") \\\n+  flags(AUTO_VECTORIZATION2_AFTER_REORDER,                    \"AutoVectorization 2, After Apply Memop Reordering\") \\\n+  flags(AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT,               \"AutoVectorization 3, After Adjusting Pre-Loop Limit\") \\\n+  flags(AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS, \"AutoVectorization 4, After Adding Speculative Runtime Checks\") \\\n+  flags(AUTO_VECTORIZATION5_AFTER_APPLY,                      \"AutoVectorization 5, After Apply\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+          deopt_reason == Deoptimization::Reason_auto_vectorization_check ||\n@@ -896,0 +897,2 @@\n+    tty->print_cr(\"- Auto Vectorization Check Block:\");\n+    _auto_vectorization_check_block.dump(\"  \");\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -737,0 +737,2 @@\n+    PredicateBlockIterator auto_vectorization_check_iterator(current, Deoptimization::Reason_auto_vectorization_check);\n+    current = auto_vectorization_check_iterator.for_each(predicate_visitor);\n@@ -909,0 +911,1 @@\n+  const PredicateBlock _auto_vectorization_check_block;\n@@ -917,1 +920,3 @@\n-        _profiled_loop_predicate_block(_loop_limit_check_predicate_block.entry(),\n+        _auto_vectorization_check_block(_loop_limit_check_predicate_block.entry(),\n+                                        Deoptimization::Reason_auto_vectorization_check),\n+        _profiled_loop_predicate_block(_auto_vectorization_check_block.entry(),\n@@ -938,0 +943,4 @@\n+  const PredicateBlock* auto_vectorization_check_block() const {\n+    return &_auto_vectorization_check_block;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1487,1 +1487,2 @@\n-                         iv_stride()\n+                         iv_stride(),\n+                         _vloop.are_speculative_checks_possible()\n@@ -1899,0 +1900,1 @@\n+                        _vloop.is_trace_speculative_runtime_checks(),\n@@ -1941,0 +1943,3 @@\n+  apply_speculative_runtime_checks();\n+  C->print_method(PHASE_AUTO_VECTORIZATION4_AFTER_SPECULATIVE_RUNTIME_CHECKS, 4, cl());\n+\n@@ -1942,1 +1947,1 @@\n-  C->print_method(PHASE_AUTO_VECTORIZATION4_AFTER_APPLY, 4, cl());\n+  C->print_method(PHASE_AUTO_VECTORIZATION5_AFTER_APPLY, 4, cl());\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,19 +32,20 @@\n-  flags(POINTER_PARSING,      \"Trace VPointer\/MemPointer parsing\") \\\n-  flags(POINTER_ALIASING,     \"Trace VPointer\/MemPointer aliasing\") \\\n-  flags(POINTER_ADJACENCY,    \"Trace VPointer\/MemPointer adjacency\") \\\n-  flags(POINTER_OVERLAP,      \"Trace VPointer\/MemPointer overlap\") \\\n-  flags(PRECONDITIONS,        \"Trace VLoop::check_preconditions\") \\\n-  flags(LOOP_ANALYZER,        \"Trace VLoopAnalyzer::setup_submodules\") \\\n-  flags(MEMORY_SLICES,        \"Trace VLoopMemorySlices\") \\\n-  flags(BODY,                 \"Trace VLoopBody\") \\\n-  flags(TYPES,                \"Trace VLoopTypes\") \\\n-  flags(POINTERS,             \"Trace VLoopPointers\") \\\n-  flags(DEPENDENCY_GRAPH,     \"Trace VLoopDependencyGraph\") \\\n-  flags(SW_ADJACENT_MEMOPS,   \"Trace SuperWord::find_adjacent_memop_pairs\") \\\n-  flags(SW_REJECTIONS,        \"Trace SuperWord rejections (non vectorizations)\") \\\n-  flags(SW_PACKSET,           \"Trace SuperWord packset at different stages\") \\\n-  flags(SW_INFO,              \"Trace SuperWord info (equivalent to TraceSuperWord)\") \\\n-  flags(SW_VERBOSE,           \"Trace SuperWord verbose (all SW tags enabled)\") \\\n-  flags(ALIGN_VECTOR,         \"Trace AlignVector\") \\\n-  flags(VTRANSFORM,           \"Trace VTransform Graph\") \\\n-  flags(ALL,                  \"Trace everything (very verbose)\")\n+  flags(POINTER_PARSING,            \"Trace VPointer\/MemPointer parsing\") \\\n+  flags(POINTER_ALIASING,           \"Trace VPointer\/MemPointer aliasing\") \\\n+  flags(POINTER_ADJACENCY,          \"Trace VPointer\/MemPointer adjacency\") \\\n+  flags(POINTER_OVERLAP,            \"Trace VPointer\/MemPointer overlap\") \\\n+  flags(PRECONDITIONS,              \"Trace VLoop::check_preconditions\") \\\n+  flags(LOOP_ANALYZER,              \"Trace VLoopAnalyzer::setup_submodules\") \\\n+  flags(MEMORY_SLICES,              \"Trace VLoopMemorySlices\") \\\n+  flags(BODY,                       \"Trace VLoopBody\") \\\n+  flags(TYPES,                      \"Trace VLoopTypes\") \\\n+  flags(POINTERS,                   \"Trace VLoopPointers\") \\\n+  flags(DEPENDENCY_GRAPH,           \"Trace VLoopDependencyGraph\") \\\n+  flags(SW_ADJACENT_MEMOPS,         \"Trace SuperWord::find_adjacent_memop_pairs\") \\\n+  flags(SW_REJECTIONS,              \"Trace SuperWord rejections (non vectorizations)\") \\\n+  flags(SW_PACKSET,                 \"Trace SuperWord packset at different stages\") \\\n+  flags(SW_INFO,                    \"Trace SuperWord info (equivalent to TraceSuperWord)\") \\\n+  flags(SW_VERBOSE,                 \"Trace SuperWord verbose (all SW tags enabled)\") \\\n+  flags(ALIGN_VECTOR,               \"Trace AlignVector\") \\\n+  flags(SPECULATIVE_RUNTIME_CHECKS, \"Trace VTransform::apply_speculative_runtime_checks\") \\\n+  flags(VTRANSFORM,                 \"Trace VTransform Graph\") \\\n+  flags(ALL,                        \"Trace everything (very verbose)\")\n","filename":"src\/hotspot\/share\/opto\/traceAutoVectorizationTag.hpp","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -96,2 +96,0 @@\n-  \/\/ To align vector memory accesses in the main-loop, we will have to adjust\n-  \/\/ the pre-loop limit.\n@@ -99,0 +97,2 @@\n+    \/\/ To align vector memory accesses in the main-loop, we will have to adjust\n+    \/\/ the pre-loop limit.\n@@ -108,0 +108,35 @@\n+\n+    \/\/ See if we find the infrastructure for speculative runtime-checks.\n+    \/\/  (1) Auto Vectorization Parse Predicate\n+    Node* pre_ctrl = pre_loop_head()->in(LoopNode::EntryControl);\n+    const Predicates predicates(pre_ctrl);\n+    const PredicateBlock* predicate_block = predicates.auto_vectorization_check_block();\n+    if (predicate_block->has_parse_predicate()) {\n+      _auto_vectorization_parse_predicate_proj = predicate_block->parse_predicate_success_proj();\n+    }\n+\n+    \/\/  (2) Multiversioning fast-loop projection\n+    IfTrueNode* before_predicates = predicates.entry()->isa_IfTrue();\n+    if (before_predicates != nullptr &&\n+        before_predicates->in(0)->is_If() &&\n+        before_predicates->in(0)->in(1)->is_OpaqueMultiversioning()) {\n+      _multiversioning_fast_proj = before_predicates;\n+    }\n+#ifndef PRODUCT\n+    if (is_trace_preconditions() || is_trace_speculative_runtime_checks()) {\n+      tty->print_cr(\" Infrastructure for speculative runtime-checks:\");\n+      if (_auto_vectorization_parse_predicate_proj != nullptr) {\n+        tty->print_cr(\"  auto_vectorization_parse_predicate_proj: speculate and trap\");\n+        _auto_vectorization_parse_predicate_proj->dump_bfs(5,0,\"\");\n+      } else if (_multiversioning_fast_proj != nullptr) {\n+        tty->print_cr(\"  multiversioning_fast_proj: speculate and multiversion\");\n+        _multiversioning_fast_proj->dump_bfs(5,0,\"\");\n+      } else {\n+        tty->print_cr(\"  Not found.\");\n+      }\n+    }\n+#endif\n+    assert(_auto_vectorization_parse_predicate_proj == nullptr ||\n+           _multiversioning_fast_proj == nullptr, \"we should only have at most one of these\");\n+    assert(_cl->is_multiversion_fast_loop() == (_multiversioning_fast_proj != nullptr),\n+           \"must find the multiversion selector IFF loop is a multiversion fast loop\");\n@@ -475,3 +510,19 @@\n-  \/\/   1) The \"base\" of the address is the address of a Java object (e.g. array),\n-  \/\/      and as such ObjectAlignmentInBytes (a power of 2) aligned. We have\n-  \/\/      defined aw = MIN(vector_width, ObjectAlignmentInBytes), which is also\n+  \/\/   1) The \"base\" of the address:\n+  \/\/        - For heap objects, this is the base of the object, and as such\n+  \/\/          ObjectAlignmentInBytes (a power of 2) aligned.\n+  \/\/        - For off-heap \/ native memory, the \"base\" has no alignment\n+  \/\/          gurantees. To ensure alignment we can do either of these:\n+  \/\/          - Add a runtime check to verify ObjectAlignmentInBytes alignment,\n+  \/\/            i.e. we can speculatively compile with an alignment assumption.\n+  \/\/            If we pass the check, we can go into the loop with the alignment\n+  \/\/            assumption, if we fail we have to trap\/deopt or take the other\n+  \/\/            loop version without alignment assumptions.\n+  \/\/          - If runtime checks are not possible, then we return an empty\n+  \/\/            solution, i.e. we do not vectorize the corresponding pack.\n+  \/\/\n+  \/\/      Let us assume we have an object \"base\", or passed the alignment\n+  \/\/      runtime check for native \"bases\", hence we know:\n+  \/\/\n+  \/\/        base % ObjectAlignmentInBytes = 0\n+  \/\/\n+  \/\/      We defined aw = MIN(vector_width, ObjectAlignmentInBytes), which is\n@@ -480,4 +531,1 @@\n-  \/\/        base % ObjectAlignmentInBytes = 0     ==>    base % aw = 0\n-  \/\/\n-  \/\/      TODO: Note: we have been assuming that this also holds for native memory base\n-  \/\/                  addresses. This is incorrect, see JDK-8323582.\n+  \/\/        base % ObjectAlignmentInBytes = 0     ==>    base % aw = 0              (BASE_ALIGNED)\n@@ -508,0 +556,7 @@\n+  \/\/ For native memory, we must add a runtime-check that \"base % ObjectAlignmentInBytes = \",\n+  \/\/ to ensure (BASE_ALIGNED). If we cannot add this runtime-check, we have no guarantee on\n+  \/\/ its alignment.\n+  if (!_vpointer.mem_pointer().base().is_object() && !_are_speculative_checks_possible) {\n+    return new EmptyAlignmentSolution(\"Cannot add speculative check for native memory alignment.\");\n+  }\n+\n@@ -524,2 +579,1 @@\n-  \/\/ TODO: Note: the following assumption is incorrect for native memory bases, see JDK-8323582.\n-  \/\/ Since \"base % aw = 0\", we only need to ensure alignment of the other 5 terms:\n+  \/\/ Since \"base % aw = 0\" (BASE_ALIGNED), we only need to ensure alignment of the other 5 terms:\n@@ -881,2 +935,1 @@\n-  \/\/   -> base aligned: base % aw = 0\n-  \/\/        TODO: Note: this assumption is incorrect for native memory bases, see JDK-8323582.\n+  \/\/   -> apply (BASE_ALIGNED): base % aw = 0\n@@ -961,1 +1014,1 @@\n-    tty->print(\" + invar + iv_scale(%d) * iv + con(%d)\", iv_scale(), _vpointer.con());\n+    tty->print_cr(\" + invar + iv_scale(%d) * iv + con(%d)\", iv_scale(), _vpointer.con());\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":67,"deletions":14,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -88,0 +88,8 @@\n+  \/\/ We can add speculative runtime-checks if we have one of these:\n+  \/\/  - Auto Vectorization Parse Predicate:\n+  \/\/      pass all checks or trap -> recompile without this predicate.\n+  \/\/  - Multiversioning fast-loop projection:\n+  \/\/      pass all checks or go to slow-path-loop, where we have no speculative assumptions.\n+  ParsePredicateSuccessProj* _auto_vectorization_parse_predicate_proj;\n+  IfTrueNode* _multiversioning_fast_proj;\n+\n@@ -107,1 +115,3 @@\n-    _pre_loop_end (nullptr)\n+    _pre_loop_end (nullptr),\n+    _auto_vectorization_parse_predicate_proj(nullptr),\n+    _multiversioning_fast_proj(nullptr)\n@@ -141,0 +151,13 @@\n+  ParsePredicateSuccessProj* auto_vectorization_parse_predicate_proj() const {\n+    return _auto_vectorization_parse_predicate_proj;\n+  }\n+\n+  IfTrueNode* multiversioning_fast_proj() const {\n+    return _multiversioning_fast_proj;\n+  }\n+\n+  bool are_speculative_checks_possible() const {\n+    return _auto_vectorization_parse_predicate_proj != nullptr ||\n+           _multiversioning_fast_proj != nullptr;\n+  }\n+\n@@ -179,0 +202,4 @@\n+\n+  bool is_trace_speculative_runtime_checks() const {\n+    return _vtrace.is_trace(TraceAutoVectorizationTag::SPECULATIVE_RUNTIME_CHECKS);\n+  }\n@@ -1299,0 +1326,8 @@\n+  \/\/ For native bases, we have no alignment guarantee. This means we cannot in\n+  \/\/ general guarantee alignment statically. But we can check alignment with a\n+  \/\/ speculative runtime check, see VTransform::apply_speculative_runtime_checks.\n+  \/\/ For this, we need find the Predicate for auto vectorization checks, or else\n+  \/\/ we need to find the multiversion_if. If we cannot find either, then we\n+  \/\/ cannot make any speculative runtime checks.\n+  const bool     _are_speculative_checks_possible;\n+\n@@ -1312,1 +1347,2 @@\n-                  const int main_stride\n+                  const int main_stride,\n+                  const bool are_speculative_checks_possible\n@@ -1321,1 +1357,2 @@\n-      _main_stride(       main_stride)\n+      _main_stride(       main_stride),\n+      _are_speculative_checks_possible(are_speculative_checks_possible)\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"opto\/castnode.hpp\"\n@@ -146,0 +147,88 @@\n+void VTransform::apply_speculative_runtime_checks() {\n+  if (VLoop::vectors_should_be_aligned()) {\n+#ifdef ASSERT\n+    if (_trace._align_vector || _trace._speculative_runtime_checks) {\n+      tty->print_cr(\"\\nVTransform::apply_speculative_runtime_checks: native memory alignment\");\n+    }\n+#endif\n+\n+    const GrowableArray<VTransformNode*>& vtnodes = _graph.vtnodes();\n+    for (int i = 0; i < vtnodes.length(); i++) {\n+      VTransformVectorNode* vtn = vtnodes.at(i)->isa_Vector();\n+      if (vtn == nullptr) { continue; }\n+      MemNode* p0 = vtn->nodes().at(0)->isa_Mem();\n+      if (p0 == nullptr) { continue; }\n+      const VPointer& vp = vpointer(p0);\n+      if (vp.mem_pointer().base().is_object()) { continue; }\n+      assert(vp.mem_pointer().base().is_native(), \"VPointer base must be object or native\");\n+\n+      \/\/ We have a native memory reference. Build a runtime check for it.\n+      \/\/ See: AlignmentSolver::solve\n+      \/\/ In a future RFE we may be able to speculate on invar alignment as\n+      \/\/ well, and allow vectorization of more cases.\n+      add_speculative_alignment_check(vp.mem_pointer().base().native(), ObjectAlignmentInBytes);\n+    }\n+  }\n+}\n+\n+#define TRACE_SPECULATIVE_ALIGNMENT_CHECK(node) {                     \\\n+  DEBUG_ONLY(                                                         \\\n+    if (_trace._align_vector || _trace._speculative_runtime_checks) { \\\n+      tty->print(\"  \" #node \": \");                                    \\\n+      node->dump();                                                   \\\n+    }                                                                 \\\n+  )                                                                   \\\n+}                                                                     \\\n+\n+\/\/ Check: (node % alignment) == 0.\n+void VTransform::add_speculative_alignment_check(Node* node, juint alignment) {\n+  TRACE_SPECULATIVE_ALIGNMENT_CHECK(node);\n+  Node* ctrl = phase()->get_ctrl(node);\n+\n+  \/\/ Cast adr\/long -> int\n+  if (node->bottom_type()->basic_type() == T_ADDRESS) {\n+    \/\/ adr -> int\/long\n+    node = new CastP2XNode(nullptr, node);\n+    phase()->register_new_node(node, ctrl);\n+    TRACE_SPECULATIVE_ALIGNMENT_CHECK(node);\n+  }\n+  if (node->bottom_type()->basic_type() == T_LONG) {\n+    \/\/ long -> int\n+    node  = new ConvL2INode(node);\n+    phase()->register_new_node(node, ctrl);\n+    TRACE_SPECULATIVE_ALIGNMENT_CHECK(node);\n+  }\n+\n+  Node* mask_alignment = igvn().intcon(alignment-1);\n+  Node* base_alignment = new AndINode(node, mask_alignment);\n+  phase()->register_new_node(base_alignment, ctrl);\n+  TRACE_SPECULATIVE_ALIGNMENT_CHECK(mask_alignment);\n+  TRACE_SPECULATIVE_ALIGNMENT_CHECK(base_alignment);\n+\n+  Node* zero = igvn().intcon(0);\n+  Node* cmp_alignment = CmpNode::make(base_alignment, zero, T_INT, false);\n+  BoolNode* bol_alignment = new BoolNode(cmp_alignment, BoolTest::eq);\n+  phase()->register_new_node(cmp_alignment, ctrl);\n+  phase()->register_new_node(bol_alignment, ctrl);\n+  TRACE_SPECULATIVE_ALIGNMENT_CHECK(cmp_alignment);\n+  TRACE_SPECULATIVE_ALIGNMENT_CHECK(bol_alignment);\n+\n+  add_speculative_check(bol_alignment);\n+}\n+\n+void VTransform::add_speculative_check(BoolNode* bol) {\n+  assert(_vloop.are_speculative_checks_possible(), \"otherwise we cannot make speculative assumptions\");\n+  ParsePredicateSuccessProj* parse_predicate_proj = _vloop.auto_vectorization_parse_predicate_proj();\n+  IfTrueNode* new_check_proj = nullptr;\n+  if (parse_predicate_proj != nullptr) {\n+    new_check_proj = phase()->create_new_if_for_predicate(parse_predicate_proj, nullptr,\n+                                                          Deoptimization::Reason_auto_vectorization_check,\n+                                                          Op_If);\n+  } else {\n+    new_check_proj = phase()->create_new_if_for_multiversion(_vloop.multiversioning_fast_proj());\n+  }\n+  Node* iff_speculate = new_check_proj->in(0);\n+  igvn().replace_input_of(iff_speculate, 1, bol);\n+  TRACE_SPECULATIVE_ALIGNMENT_CHECK(iff_speculate);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+  const bool _speculative_runtime_checks;\n@@ -117,0 +118,1 @@\n+                  const bool is_trace_speculative_runtime_checks,\n@@ -118,4 +120,5 @@\n-    _verbose     (vtrace.is_trace(TraceAutoVectorizationTag::ALL)),\n-    _rejections  (_verbose | is_trace_vtransform(vtrace) | is_trace_rejections),\n-    _align_vector(_verbose | is_trace_vtransform(vtrace) | is_trace_align_vector),\n-    _info        (_verbose | is_trace_vtransform(vtrace) | is_trace_info) {}\n+    _verbose                   (vtrace.is_trace(TraceAutoVectorizationTag::ALL)),\n+    _rejections                (_verbose | is_trace_vtransform(vtrace) | is_trace_rejections),\n+    _align_vector              (_verbose | is_trace_vtransform(vtrace) | is_trace_align_vector),\n+    _speculative_runtime_checks(_verbose | is_trace_vtransform(vtrace) | is_trace_speculative_runtime_checks),\n+    _info                      (_verbose | is_trace_vtransform(vtrace) | is_trace_info) {}\n@@ -248,0 +251,4 @@\n+  void apply_speculative_runtime_checks();\n+  void add_speculative_alignment_check(Node* node, juint alignment);\n+  void add_speculative_check(BoolNode* bol);\n+\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2720,0 +2720,1 @@\n+  \"auto_vectorization_check\",\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+    Reason_auto_vectorization_check, \/\/ compiler generated (speculative) auto vectorization checks failed\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2272,0 +2272,1 @@\n+  declare_constant(Deoptimization::Reason_auto_vectorization_check)       \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+import jdk.test.lib.Utils;\n+import java.nio.ByteBuffer;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.lang.foreign.*;\n+\n+\/*\n+ * @test id=byte-buffer-direct\n+ * @bug 8323582\n+ * @summary Test vectorization of loops over MemorySegment, with native memory where the address is not always aligned.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentUnalignedAddress ByteBufferDirect\n+ *\/\n+\n+\/*\n+ * @test id=byte-buffer-direct-AlignVector\n+ * @bug 8323582\n+ * @summary Test vectorization of loops over MemorySegment, with native memory where the address is not always aligned.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentUnalignedAddress ByteBufferDirect AlignVector\n+ *\/\n+\n+\/*\n+ * @test id=byte-buffer-direct-VerifyAlignVector\n+ * @bug 8323582\n+ * @summary Test vectorization of loops over MemorySegment, with native memory where the address is not always aligned.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentUnalignedAddress ByteBufferDirect VerifyAlignVector\n+ *\/\n+\n+\/*\n+ * @test id=native\n+ * @bug 8323582\n+ * @summary Test vectorization of loops over MemorySegment, with native memory where the address is not always aligned.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentUnalignedAddress Native\n+ *\/\n+\n+\/*\n+ * @test id=native-AlignVector\n+ * @bug 8323582\n+ * @summary Test vectorization of loops over MemorySegment, with native memory where the address is not always aligned.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentUnalignedAddress Native AlignVector\n+ *\/\n+\n+\/*\n+ * @test id=native-VerifyAlignVector\n+ * @bug 8323582\n+ * @summary Test vectorization of loops over MemorySegment, with native memory where the address is not always aligned.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentUnalignedAddress Native VerifyAlignVector\n+ *\/\n+\n+public class TestMemorySegmentUnalignedAddress {\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestMemorySegmentUnalignedAddressImpl.class);\n+        framework.addFlags(\"-DmemorySegmentProviderNameForTestVM=\" + args[0]);\n+        if (args.length > 1) {\n+            switch (args[1]) {\n+                case \"AlignVector\" ->       { framework.addFlags(\"-XX:+AlignVector\"); }\n+                case \"VerifyAlignVector\" -> { framework.addFlags(\"-XX:+AlignVector\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyAlignVector\"); }\n+                default ->                  { throw new RuntimeException(\"unexpected: \" + args[1]); }\n+            }\n+        }\n+        framework.setDefaultWarmup(100);\n+        framework.start();\n+    }\n+}\n+\n+class TestMemorySegmentUnalignedAddressImpl {\n+    static final int SIZE = 10_000;\n+    static final int BACKING_SIZE = 10_000 + 1;\n+    static final Random RANDOM = Utils.getRandomInstance();\n+\n+    interface TestFunction {\n+        Object run(int i);\n+    }\n+\n+    interface MemorySegmentProvider {\n+        MemorySegment newMemorySegment();\n+    }\n+\n+    static MemorySegmentProvider provider;\n+\n+    static {\n+        String providerName = System.getProperty(\"memorySegmentProviderNameForTestVM\");\n+        provider = switch (providerName) {\n+            case \"ByteBufferDirect\" -> TestMemorySegmentUnalignedAddressImpl::newMemorySegmentOfByteBufferDirect;\n+            case \"Native\"           -> TestMemorySegmentUnalignedAddressImpl::newMemorySegmentOfNative;\n+            default -> throw new RuntimeException(\"Test argument not recognized: \" + providerName);\n+        };\n+    }\n+\n+    \/\/ List of tests\n+    Map<String, TestFunction> tests = new HashMap<>();\n+\n+    \/\/ List of gold, the results from the first run before compilation\n+    Map<String, Object> golds = new HashMap<>();\n+\n+    public TestMemorySegmentUnalignedAddressImpl () {\n+        \/\/ Generate two MemorySegments as inputs\n+        MemorySegment a = sliceAligned(newMemorySegment());\n+        MemorySegment b = sliceAligned(newMemorySegment());\n+        fillRandom(a);\n+        fillRandom(b);\n+\n+        \/\/ Add all tests to list\n+        tests.put(\"testAlwaysAligned\", (int i) -> {\n+            MemorySegment ms = newMemorySegment();\n+            MemorySegment slice = sliceAligned(ms);\n+            copy(a, slice);\n+            return testAlwaysAligned(slice);\n+        });\n+        tests.put(\"testAlwaysUnaligned\", (int i) -> {\n+            MemorySegment ms = newMemorySegment();\n+            MemorySegment slice = sliceUnaligned(ms);\n+            copy(a, slice);\n+            return testAlwaysUnaligned(slice);\n+        });\n+        tests.put(\"testMixedAlignedAndUnaligned\", (int i) -> {\n+            MemorySegment ms = newMemorySegment();\n+            MemorySegment slice = (i % 2 == 0) ? sliceUnaligned(ms) : sliceAligned(ms);\n+            copy(a, slice);\n+            return testMixedAlignedAndUnaligned(slice);\n+        });\n+\n+        \/\/ Compute gold value for all test methods before compilation\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            Object gold = test.run(0);\n+            golds.put(name, gold);\n+        }\n+    }\n+\n+    MemorySegment sliceAligned(MemorySegment src) {\n+        return src.asSlice(0, SIZE);\n+    }\n+\n+    MemorySegment sliceUnaligned(MemorySegment src) {\n+        return src.asSlice(1, SIZE);\n+    }\n+\n+    MemorySegment newMemorySegment() {\n+        return provider.newMemorySegment();\n+    }\n+\n+    static void copy(MemorySegment src, MemorySegment dst) {\n+        MemorySegment.copy(src, 0, dst, 0, src.byteSize());\n+    }\n+\n+    static MemorySegment newMemorySegmentOfByteBufferDirect() {\n+        return MemorySegment.ofBuffer(ByteBuffer.allocateDirect(BACKING_SIZE));\n+    }\n+\n+    static MemorySegment newMemorySegmentOfNative() {\n+        \/\/ Auto arena: GC decides when there is no reference to the MemorySegment,\n+        \/\/ and then it deallocates the backing memory.\n+        return Arena.ofAuto().allocate(BACKING_SIZE, 1);\n+    }\n+\n+    static void fillRandom(MemorySegment data) {\n+        for (int i = 0; i < (int)data.byteSize(); i++) {\n+            data.set(ValueLayout.JAVA_BYTE, i, (byte)RANDOM.nextInt());\n+        }\n+    }\n+\n+    static void verify(String name, Object gold, Object result) {\n+        try {\n+            Verify.checkEQ(gold, result);\n+        } catch (VerifyException e) {\n+            throw new RuntimeException(\"Verify: wrong result in \" + name, e);\n+        }\n+    }\n+\n+    static int runInvocationCounter = 0;\n+\n+    @Run(test = {\"testAlwaysAligned\",\n+                 \"testAlwaysUnaligned\",\n+                 \"testMixedAlignedAndUnaligned\"})\n+    void runTests() {\n+        runInvocationCounter++;\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            \/\/ Recall gold value from before compilation\n+            Object gold = golds.get(name);\n+            \/\/ Compute new result\n+            Object result = test.run(runInvocationCounter);\n+            \/\/ Compare gold and new result\n+            verify(name, gold, result);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\",\n+                  \"multiversion\",       \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        phase = CompilePhase.PRINT_IDEAL)\n+    \/\/ We never fail the alignment check in the auto vectorization Predicate,\n+    \/\/ hence we never even create the multiversioned loops.\n+    static Object testAlwaysAligned(MemorySegment ms) {\n+        for (long i = 0; i < ms.byteSize(); i += 4) {\n+            int v = ms.get(ValueLayout.JAVA_INT_UNALIGNED, i);\n+            ms.set(ValueLayout.JAVA_INT_UNALIGNED, i, (int)(v + 1));\n+        }\n+        return new Object[]{ ms };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\",\n+                  \"multiversion_fast\",  \"= 4\",  \/\/ pre, main, drain, post\n+                  \"multiversion_slow\",  \"= 2\"}, \/\/ main, post\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        phase = CompilePhase.PRINT_IDEAL)\n+    \/\/ We add alignment checks to the auto vectorization Predicate. It fails\n+    \/\/ at runtime, deopts, and recompiles with multiversioning.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\",\n+                  \"multiversion_fast\",  \"= 0\",\n+                  \"multiversion_slow\",  \"= 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        phase = CompilePhase.PRINT_IDEAL)\n+    \/\/ We never add any conditions to the auto vectorization Predicate, so\n+    \/\/ we also never deopt and never end up multiversioning.\n+    static Object testAlwaysUnaligned(MemorySegment ms) {\n+        for (long i = 0; i < ms.byteSize(); i += 4) {\n+            int v = ms.get(ValueLayout.JAVA_INT_UNALIGNED, i);\n+            ms.set(ValueLayout.JAVA_INT_UNALIGNED, i, (int)(v + 1));\n+        }\n+        return new Object[]{ ms };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\",\n+                  \"multiversion_fast\",  \"= 4\",  \/\/ pre, main, drain, post\n+                  \"multiversion_slow\",  \"= 2\"}, \/\/ main, post\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        phase = CompilePhase.PRINT_IDEAL)\n+    \/\/ We add alignment checks to the auto vectorization Predicate. It fails\n+    \/\/ at runtime, deopts, and recompiles with multiversioning.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\",\n+                  \"multiversion_fast\",  \"= 0\",\n+                  \"multiversion_slow\",  \"= 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        phase = CompilePhase.PRINT_IDEAL)\n+    \/\/ We never add any conditions to the auto vectorization Predicate, so\n+    \/\/ we also never deopt and never end up multiversioning.\n+    static Object testMixedAlignedAndUnaligned(MemorySegment ms) {\n+        for (long i = 0; i < ms.byteSize(); i += 4) {\n+            int v = ms.get(ValueLayout.JAVA_INT_UNALIGNED, i);\n+            ms.set(ValueLayout.JAVA_INT_UNALIGNED, i, (int)(v + 1));\n+        }\n+        return new Object[]{ ms };\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentUnalignedAddress.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"}]}