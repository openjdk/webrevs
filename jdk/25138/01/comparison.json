{"files":[{"patch":"@@ -1594,6 +1594,4 @@\n-void C2_MacroAssembler::vgather8b_masked_offset(BasicType elem_bt,\n-                                                XMMRegister dst, Register base,\n-                                                Register idx_base,\n-                                                Register offset, Register mask,\n-                                                Register mask_idx, Register rtmp,\n-                                                int vlen_enc) {\n+void C2_MacroAssembler::vgather8b_masked(BasicType elem_bt, XMMRegister dst,\n+                                         Register base, Register idx_base,\n+                                         Register mask, Register mask_idx,\n+                                         Register rtmp, int vlen_enc) {\n@@ -1603,1 +1601,1 @@\n-      \/\/ dst[i] = mask[i] ? src[offset + idx_base[i]] : 0\n+      \/\/ dst[i] = mask[i] ? src[idx_base[i]] : 0\n@@ -1608,3 +1606,0 @@\n-      if (offset != noreg) {\n-        addl(rtmp, offset);\n-      }\n@@ -1618,1 +1613,1 @@\n-      \/\/ dst[i] = mask[i] ? src[offset + idx_base[i]] : 0\n+      \/\/ dst[i] = mask[i] ? src[idx_base[i]] : 0\n@@ -1623,3 +1618,0 @@\n-      if (offset != noreg) {\n-        addl(rtmp, offset);\n-      }\n@@ -1633,4 +1625,3 @@\n-void C2_MacroAssembler::vgather8b_offset(BasicType elem_bt, XMMRegister dst,\n-                                         Register base, Register idx_base,\n-                                         Register offset, Register rtmp,\n-                                         int vlen_enc) {\n+void C2_MacroAssembler::vgather8b(BasicType elem_bt, XMMRegister dst,\n+                                  Register base, Register idx_base,\n+                                  Register rtmp, int vlen_enc) {\n@@ -1640,1 +1631,1 @@\n-      \/\/ dst[i] = src[offset + idx_base[i]]\n+      \/\/ dst[i] = src[idx_base[i]]\n@@ -1642,3 +1633,0 @@\n-      if (offset != noreg) {\n-        addl(rtmp, offset);\n-      }\n@@ -1650,1 +1638,1 @@\n-      \/\/ dst[i] = src[offset + idx_base[i]]\n+      \/\/ dst[i] = src[idx_base[i]]\n@@ -1652,3 +1640,0 @@\n-      if (offset != noreg) {\n-        addl(rtmp, offset);\n-      }\n@@ -1683,5 +1668,4 @@\n-                                        Register offset, Register mask,\n-                                        XMMRegister xtmp1, XMMRegister xtmp2,\n-                                        XMMRegister temp_dst, Register rtmp,\n-                                        Register mask_idx, Register length,\n-                                        int vector_len, int vlen_enc) {\n+                                        Register mask, XMMRegister xtmp1,\n+                                        XMMRegister xtmp2, XMMRegister temp_dst,\n+                                        Register rtmp, Register mask_idx,\n+                                        Register length, int vector_len, int vlen_enc) {\n@@ -1701,1 +1685,1 @@\n-      vgather8b_offset(elem_ty, temp_dst, base, idx_base, offset, rtmp, vlen_enc);\n+      vgather8b(elem_ty, temp_dst, base, idx_base, rtmp, vlen_enc);\n@@ -1703,1 +1687,1 @@\n-      vgather8b_masked_offset(elem_ty, temp_dst, base, idx_base, offset, mask, mask_idx, rtmp, vlen_enc);\n+      vgather8b_masked(elem_ty, temp_dst, base, idx_base, mask, mask_idx, rtmp, vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":17,"deletions":33,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -495,2 +495,2 @@\n-  void vgather_subword(BasicType elem_ty, XMMRegister dst,  Register base, Register idx_base, Register offset,\n-                       Register mask, XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n+  void vgather_subword(BasicType elem_ty, XMMRegister dst,  Register base, Register idx_base, Register mask,\n+                       XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n@@ -499,5 +499,4 @@\n-  void vgather8b_masked_offset(BasicType elem_bt, XMMRegister dst, Register base, Register idx_base,\n-                               Register offset, Register mask, Register midx, Register rtmp, int vlen_enc);\n-\n-  void vgather8b_offset(BasicType elem_bt, XMMRegister dst, Register base, Register idx_base,\n-                              Register offset, Register rtmp, int vlen_enc);\n+  void vgather8b_masked(BasicType elem_bt, XMMRegister dst, Register base, Register idx_base,\n+                        Register mask, Register midx, Register rtmp, int vlen_enc);\n+  void vgather8b(BasicType elem_bt, XMMRegister dst, Register base, Register idx_base,\n+                 Register rtmp, int vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -4026,1 +4026,1 @@\n-instruct vgather_subwordLE8B(vec dst, memory mem, rRegP idx_base, immI_0 offset, rRegP tmp, rRegI rtmp) %{\n+instruct vgather_subwordLE8B(vec dst, memory mem, rRegP idx_base, rRegP tmp, rRegI rtmp) %{\n@@ -4028,1 +4028,1 @@\n-  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n+  match(Set dst (LoadVectorGather mem idx_base));\n@@ -4035,1 +4035,1 @@\n-    __ vgather8b_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, noreg, $rtmp$$Register, vlen_enc);\n+    __ vgather8b(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $rtmp$$Register, vlen_enc);\n@@ -4040,1 +4040,1 @@\n-instruct vgather_subwordGT8B(vec dst, memory mem, rRegP idx_base, immI_0 offset, rRegP tmp, rRegP idx_base_temp,\n+instruct vgather_subwordGT8B(vec dst, memory mem, rRegP idx_base, rRegP tmp, rRegP idx_base_temp,\n@@ -4043,1 +4043,1 @@\n-  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n+  match(Set dst (LoadVectorGather mem idx_base));\n@@ -4052,1 +4052,1 @@\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, noreg, noreg, $xtmp1$$XMMRegister,\n+    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, noreg, $xtmp1$$XMMRegister,\n@@ -4058,35 +4058,1 @@\n-instruct vgather_subwordLE8B_off(vec dst, memory mem, rRegP idx_base, rRegI offset, rRegP tmp, rRegI rtmp, rFlagsReg cr) %{\n-  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) <= 8);\n-  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n-  effect(TEMP tmp, TEMP rtmp, KILL cr);\n-  format %{ \"vector_gatherLE8_off $dst, $mem, $idx_base, $offset\\t! using $tmp and $rtmp as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ vgather8b_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $offset$$Register, $rtmp$$Register, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\n-instruct vgather_subwordGT8B_off(vec dst, memory mem, rRegP idx_base, rRegI offset, rRegP tmp, rRegP idx_base_temp,\n-                                 vec xtmp1, vec xtmp2, vec xtmp3, rRegI rtmp, rRegI length, rFlagsReg cr) %{\n-  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) > 8);\n-  match(Set dst (LoadVectorGather mem (Binary idx_base offset)));\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP idx_base_temp, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, TEMP length, KILL cr);\n-  format %{ \"vector_gatherGT8_off $dst, $mem, $idx_base, $offset\\t! using $tmp, $idx_base_temp, $xtmp1, $xtmp2, $xtmp3, $rtmp and $length as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    int vector_len = Matcher::vector_length(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ movptr($idx_base_temp$$Register, $idx_base$$Register);\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $offset$$Register, noreg, $xtmp1$$XMMRegister,\n-                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, noreg, $length$$Register, vector_len, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\n-instruct vgather_masked_subwordLE8B_avx3(vec dst, memory mem, rRegP idx_base, immI_0 offset, kReg mask, rRegL mask_idx, rRegP tmp, rRegI rtmp, rRegL rtmp2, rFlagsReg cr) %{\n+instruct vgather_masked_subwordLE8B_avx3(vec dst, memory mem, rRegP idx_base, kReg mask, rRegL mask_idx, rRegP tmp, rRegI rtmp, rRegL rtmp2, rFlagsReg cr) %{\n@@ -4094,1 +4060,1 @@\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base mask)));\n@@ -4103,1 +4069,1 @@\n-    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, noreg, $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n+    __ vgather8b_masked(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n@@ -4108,1 +4074,1 @@\n-instruct vgather_masked_subwordGT8B_avx3(vec dst, memory mem, rRegP idx_base, immI_0 offset, kReg mask, rRegP tmp, rRegP idx_base_temp,\n+instruct vgather_masked_subwordGT8B_avx3(vec dst, memory mem, rRegP idx_base, kReg mask, rRegP tmp, rRegP idx_base_temp,\n@@ -4111,1 +4077,1 @@\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base mask)));\n@@ -4122,1 +4088,1 @@\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, noreg, $rtmp2$$Register, $xtmp1$$XMMRegister,\n+    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $rtmp2$$Register, $xtmp1$$XMMRegister,\n@@ -4128,38 +4094,1 @@\n-instruct vgather_masked_subwordLE8B_off_avx3(vec dst, memory mem, rRegP idx_base, rRegI offset, kReg mask, rRegL mask_idx, rRegP tmp, rRegI rtmp, rRegL rtmp2, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) <= 8);\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n-  effect(TEMP mask_idx, TEMP tmp, TEMP rtmp, TEMP rtmp2, KILL cr);\n-  format %{ \"vector_masked_gatherLE8_off $dst, $mem, $idx_base, $offset, $mask\\t! using $mask_idx, $tmp, $rtmp and $rtmp2 as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ xorq($mask_idx$$Register, $mask_idx$$Register);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ kmovql($rtmp2$$Register, $mask$$KRegister);\n-    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $offset$$Register,\n-                                $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vgather_masked_subwordGT8B_off_avx3(vec dst, memory mem, rRegP idx_base, rRegI offset, kReg mask, rRegP tmp, rRegP idx_base_temp,\n-                                             vec xtmp1, vec xtmp2, vec xtmp3, rRegI rtmp, rRegL rtmp2, rRegL mask_idx, rRegI length, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512bw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) > 8);\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP idx_base_temp, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, TEMP rtmp2, TEMP mask_idx, TEMP length, KILL cr);\n-  format %{ \"vector_gatherGT8_masked_off $dst, $mem, $idx_base, $offset, $mask\\t! using $tmp, $idx_base_temp, $xtmp1, $xtmp2, $xtmp3, $rtmp, $rtmp2, $mask_idx and $length as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    int vector_len = Matcher::vector_length(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ xorq($mask_idx$$Register, $mask_idx$$Register);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ movptr($idx_base_temp$$Register, $idx_base$$Register);\n-    __ kmovql($rtmp2$$Register, $mask$$KRegister);\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $offset$$Register, $rtmp2$$Register, $xtmp1$$XMMRegister,\n-                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, $mask_idx$$Register, $length$$Register, vector_len, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vgather_masked_subwordLE8B_avx2(vec dst, memory mem, rRegP idx_base, immI_0 offset, vec mask, rRegI mask_idx, rRegP tmp, rRegI rtmp, rRegI rtmp2, rFlagsReg cr) %{\n+instruct vgather_masked_subwordLE8B_avx2(vec dst, memory mem, rRegP idx_base, vec mask, rRegI mask_idx, rRegP tmp, rRegI rtmp, rRegI rtmp2, rFlagsReg cr) %{\n@@ -4167,1 +4096,1 @@\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base mask)));\n@@ -4180,1 +4109,1 @@\n-    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, noreg, $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n+    __ vgather8b_masked(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n@@ -4185,1 +4114,1 @@\n-instruct vgather_masked_subwordGT8B_avx2(vec dst, memory mem, rRegP idx_base, immI_0 offset, vec mask, rRegP tmp, rRegP idx_base_temp,\n+instruct vgather_masked_subwordGT8B_avx2(vec dst, memory mem, rRegP idx_base, vec mask, rRegP tmp, rRegP idx_base_temp,\n@@ -4188,1 +4117,1 @@\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n+  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base mask)));\n@@ -4203,47 +4132,1 @@\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, noreg, $rtmp2$$Register, $xtmp1$$XMMRegister,\n-                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, $mask_idx$$Register, $length$$Register, vector_len, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vgather_masked_subwordLE8B_off_avx2(vec dst, memory mem, rRegP idx_base, rRegI offset, vec mask, rRegI mask_idx, rRegP tmp, rRegI rtmp, rRegI rtmp2, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512vlbw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) <= 8);\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n-  effect(TEMP mask_idx, TEMP tmp, TEMP rtmp, TEMP rtmp2, KILL cr);\n-  format %{ \"vector_masked_gatherLE8_off $dst, $mem, $idx_base, $offset, $mask\\t! using $mask_idx, $tmp, $rtmp and $rtmp2 as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ vpmovmskb($rtmp2$$Register, $mask$$XMMRegister, vlen_enc);\n-    if (elem_bt == T_SHORT) {\n-      __ movl($mask_idx$$Register, 0x55555555);\n-      __ pextl($rtmp2$$Register, $rtmp2$$Register, $mask_idx$$Register);\n-    }\n-    __ xorl($mask_idx$$Register, $mask_idx$$Register);\n-    __ vgather8b_masked_offset(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base$$Register, $offset$$Register,\n-                                $rtmp2$$Register, $mask_idx$$Register, $rtmp$$Register, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vgather_masked_subwordGT8B_off_avx2(vec dst, memory mem, rRegP idx_base, rRegI offset, vec mask, rRegP tmp, rRegP idx_base_temp,\n-                                             vec xtmp1, vec xtmp2, vec xtmp3, rRegI rtmp, rRegI rtmp2, rRegI mask_idx, rRegI length, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512vlbw() && is_subword_type(Matcher::vector_element_basic_type(n)) && Matcher::vector_length_in_bytes(n) > 8);\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx_base (Binary mask offset))));\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP idx_base_temp, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, TEMP rtmp2, TEMP mask_idx, TEMP length, KILL cr);\n-  format %{ \"vector_gatherGT8_masked_off $dst, $mem, $idx_base, $offset, $mask\\t! using $tmp, $idx_base_temp, $xtmp1, $xtmp2, $xtmp3, $rtmp, $rtmp2, $mask_idx and $length as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    int vector_len = Matcher::vector_length(this);\n-    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n-    __ xorl($mask_idx$$Register, $mask_idx$$Register);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ movptr($idx_base_temp$$Register, $idx_base$$Register);\n-    __ vpmovmskb($rtmp2$$Register, $mask$$XMMRegister, vlen_enc);\n-    if (elem_bt == T_SHORT) {\n-      __ movl($mask_idx$$Register, 0x55555555);\n-      __ pextl($rtmp2$$Register, $rtmp2$$Register, $mask_idx$$Register);\n-    }\n-    __ xorl($mask_idx$$Register, $mask_idx$$Register);\n-    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $offset$$Register, $rtmp2$$Register, $xtmp1$$XMMRegister,\n+    __ vgather_subword(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx_base_temp$$Register, $rtmp2$$Register, $xtmp1$$XMMRegister,\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":18,"deletions":135,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -1272,0 +1272,1 @@\n+                                     \"I\"                                                                                                       \\\n@@ -1275,0 +1276,3 @@\n+                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                           \\\n+                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                           \\\n+                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                           \\\n@@ -1289,0 +1293,1 @@\n+                                      \"I\"                                                                                                      \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2520,16 +2520,1 @@\n-    case Op_LoadVectorGather:\n-      if (is_subword_type(n->bottom_type()->is_vect()->element_basic_type())) {\n-        Node* pair = new BinaryNode(n->in(MemNode::ValueIn), n->in(MemNode::ValueIn+1));\n-        n->set_req(MemNode::ValueIn, pair);\n-        n->del_req(MemNode::ValueIn+1);\n-      }\n-      break;\n-    case Op_LoadVectorGatherMasked:\n-      if (is_subword_type(n->bottom_type()->is_vect()->element_basic_type())) {\n-        Node* pair2 = new BinaryNode(n->in(MemNode::ValueIn + 1), n->in(MemNode::ValueIn + 2));\n-        Node* pair1 = new BinaryNode(n->in(MemNode::ValueIn), pair2);\n-        n->set_req(MemNode::ValueIn, pair1);\n-        n->del_req(MemNode::ValueIn+2);\n-        n->del_req(MemNode::ValueIn+1);\n-        break;\n-      } \/\/ fall-through\n+    case Op_LoadVectorGatherMasked: \/\/ fall-through\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1206,12 +1206,13 @@\n-\/\/ <C,\n-\/\/  V extends Vector<?>,\n-\/\/  W extends Vector<Integer>,\n-\/\/  S extends VectorSpecies<E>,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/ V loadWithMap(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType, int length,\n-\/\/               Class<? extends Vector<Integer>> vectorIndexClass,\n-\/\/               Object base, long offset, \/\/ Unsafe addressing\n-\/\/               W index_vector, M m,\n-\/\/               C container, int index, int[] indexMap, int indexM, S s, \/\/ Arguments for default implementation\n-\/\/               LoadVectorOperationWithMap<C, V, E, S, M> defaultImpl)\n+\/\/\n+\/\/  <C,\n+\/\/   V extends Vector<?>,\n+\/\/   W extends Vector<Integer>,\n+\/\/   S extends VectorSpecies<E>,\n+\/\/   M extends VectorMask<E>,\n+\/\/   E>\n+\/\/   V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass, int length,\n+\/\/                 Class<? extends Vector<Integer>> vectorIndexClass, int indexLength,\n+\/\/                 Object base, long offset,\n+\/\/                 W indexVector1, W indexVector2, W indexVector3, W indexVector4,\n+\/\/                 M m, C container, int index, int[] indexMap, int indexM, S s,\n+\/\/                 LoadVectorOperationWithMap<C, V, S, M> defaultImpl)\n@@ -1224,5 +1225,6 @@\n-\/\/  void storeWithMap(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType,\n-\/\/                    int length, Class<? extends Vector<Integer>> vectorIndexClass, Object base, long offset,    \/\/ Unsafe addressing\n-\/\/                    W index_vector, V v, M m,\n-\/\/                    C container, int index, int[] indexMap, int indexM, \/\/ Arguments for default implementation\n-\/\/                    StoreVectorOperationWithMap<C, V, M, E> defaultImpl)\n+\/\/   void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass, int length,\n+\/\/                     Class<? extends Vector<Integer>> vectorIndexClass, int indexLength,\n+\/\/                     Object base, long offset, \/\/ Unsafe addressing\n+\/\/                     W indexVector, V v, M m,\n+\/\/                     C container, int index, int[] indexMap, int indexM, \/\/ Arguments for default implementation\n+\/\/                     StoreVectorOperationWithMap<C, V, M> defaultImpl)\n@@ -1236,0 +1238,1 @@\n+  const TypeInt*     idx_vlen         = gvn().type(argument(5))->isa_int();\n@@ -1240,2 +1243,3 @@\n-      vector_idx_klass == nullptr || vector_idx_klass->const_oop() == nullptr) {\n-    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s viclass=%s\",\n+      vector_idx_klass == nullptr || vector_idx_klass->const_oop() == nullptr ||\n+      idx_vlen         == nullptr || !idx_vlen->is_con()) {\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s viclass=%s idx_vlen=%s\",\n@@ -1245,1 +1249,2 @@\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(4)->Opcode()],\n+                    NodeClassNames[argument(5)->Opcode()]);\n@@ -1262,0 +1267,1 @@\n+  int idx_num_elem = idx_vlen->get_con();\n@@ -1263,1 +1269,2 @@\n-  const Type* vmask_type = gvn().type(is_scatter ? argument(10) : argument(9));\n+  Node* m = is_scatter ? argument(11) : argument(13);\n+  const Type* vmask_type = gvn().type(m);\n@@ -1301,5 +1308,5 @@\n-  if (!is_subword_type(elem_bt) && !arch_supports_vector(Op_LoadVector, num_elem, T_INT, VecMaskNotUsed)) {\n-      log_if_needed(\"  ** not supported: arity=%d op=%s\/loadindex vlen=%d etype=int is_masked_op=%d\",\n-                      is_scatter, is_scatter ? \"scatter\" : \"gather\",\n-                      num_elem, is_masked_op ? 1 : 0);\n-      return false; \/\/ not supported\n+  if (!is_subword_type(elem_bt) && !arch_supports_vector(Op_LoadVector, idx_num_elem, T_INT, VecMaskNotUsed)) {\n+    log_if_needed(\"  ** not supported: arity=%d op=%s\/loadindex vlen=%d etype=int is_masked_op=%d\",\n+                  is_scatter, is_scatter ? \"scatter\" : \"gather\",\n+                  idx_num_elem, is_masked_op ? 1 : 0);\n+    return false; \/\/ not supported\n@@ -1308,2 +1315,2 @@\n-  Node* base = argument(5);\n-  Node* offset = ConvL2X(argument(6));\n+  Node* base = argument(6);\n+  Node* offset = ConvL2X(argument(7));\n@@ -1315,1 +1322,11 @@\n-  Node* addr = make_unsafe_address(base, offset, elem_bt, true);\n+  Node* addr = nullptr;\n+  if (!is_subword_type(elem_bt)) {\n+    addr = make_unsafe_address(base, offset, elem_bt, true);\n+  } else {\n+    assert(!is_scatter, \"Only supports gather operation for subword types now\");\n+    uint header = arrayOopDesc::base_offset_in_bytes(elem_bt);\n+    assert(offset->is_Con() && offset->bottom_type()->is_long()->get_con() == header,\n+           \"offset must be the array base offset\");\n+    Node* index = argument(15);\n+    addr = array_element_address(base, index, elem_bt);\n+  }\n@@ -1317,1 +1334,1 @@\n-  const TypePtr *addr_type = gvn().type(addr)->isa_ptr();\n+  const TypePtr* addr_type = gvn().type(addr)->isa_ptr();\n@@ -1339,1 +1356,2 @@\n-  Node* index_vect = nullptr;\n+  \/\/ Get the indexes for gather\/scatter.\n+  Node* indexes = nullptr;\n@@ -1341,3 +1359,8 @@\n-  if (!is_subword_type(elem_bt)) {\n-    index_vect = unbox_vector(argument(8), vbox_idx_type, T_INT, num_elem);\n-    if (index_vect == nullptr) {\n+  if (is_subword_type(elem_bt)) {\n+    Node* indexMap = argument(16);\n+    Node* indexM   = argument(17);\n+    indexes = array_element_address(indexMap, indexM, T_INT);\n+  } else {\n+    \/\/ Get the first index vector.\n+    indexes = unbox_vector(argument(9), vbox_idx_type, T_INT, idx_num_elem);\n+    if (indexes == nullptr) {\n@@ -1350,0 +1373,1 @@\n+  \/\/ Get the vector mask value.\n@@ -1354,1 +1378,1 @@\n-    mask = unbox_vector(is_scatter ? argument(10) : argument(9), mbox_type, elem_bt, num_elem);\n+    mask = unbox_vector(m, mbox_type, elem_bt, num_elem);\n@@ -1356,3 +1380,1 @@\n-      log_if_needed(\"  ** unbox failed mask=%s\",\n-                    is_scatter ? NodeClassNames[argument(10)->Opcode()]\n-                               : NodeClassNames[argument(9)->Opcode()]);\n+      log_if_needed(\"  ** unbox failed mask=%s\", NodeClassNames[m->Opcode()]);\n@@ -1367,1 +1389,1 @@\n-    Node* val = unbox_vector(argument(9), vbox_type, elem_bt, num_elem);\n+    Node* val = unbox_vector(argument(10), vbox_type, elem_bt, num_elem);\n@@ -1377,1 +1399,1 @@\n-      vstore = gvn().transform(new StoreVectorScatterMaskedNode(control(), memory(addr), addr, addr_type, val, index_vect, mask));\n+      vstore = gvn().transform(new StoreVectorScatterMaskedNode(control(), memory(addr), addr, addr_type, val, indexes, mask));\n@@ -1379,1 +1401,1 @@\n-      vstore = gvn().transform(new StoreVectorScatterNode(control(), memory(addr), addr, addr_type, val, index_vect));\n+      vstore = gvn().transform(new StoreVectorScatterNode(control(), memory(addr), addr, addr_type, val, indexes));\n@@ -1384,3 +1406,0 @@\n-    Node* index    = argument(11);\n-    Node* indexMap = argument(12);\n-    Node* indexM   = argument(13);\n@@ -1388,6 +1407,1 @@\n-      if (is_subword_type(elem_bt)) {\n-        Node* index_arr_base = array_element_address(indexMap, indexM, T_INT);\n-        vload = gvn().transform(new LoadVectorGatherMaskedNode(control(), memory(addr), addr, addr_type, vector_type, index_arr_base, mask, index));\n-      } else {\n-        vload = gvn().transform(new LoadVectorGatherMaskedNode(control(), memory(addr), addr, addr_type, vector_type, index_vect, mask));\n-      }\n+      vload = gvn().transform(new LoadVectorGatherMaskedNode(control(), memory(addr), addr, addr_type, vector_type, indexes, mask));\n@@ -1395,6 +1409,1 @@\n-      if (is_subword_type(elem_bt)) {\n-        Node* index_arr_base = array_element_address(indexMap, indexM, T_INT);\n-        vload = gvn().transform(new LoadVectorGatherNode(control(), memory(addr), addr, addr_type, vector_type, index_arr_base, index));\n-      } else {\n-        vload = gvn().transform(new LoadVectorGatherNode(control(), memory(addr), addr, addr_type, vector_type, index_vect));\n-      }\n+      vload = gvn().transform(new LoadVectorGatherNode(control(), memory(addr), addr, addr_type, vector_type, indexes));\n@@ -1407,1 +1416,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":65,"deletions":57,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -1120,1 +1120,1 @@\n-  LoadVectorGatherNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* offset = nullptr)\n+  LoadVectorGatherNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices)\n@@ -1126,1 +1126,0 @@\n-    assert(is_subword || !offset, \"\");\n@@ -1128,3 +1127,0 @@\n-    if (offset) {\n-      add_req(offset);\n-    }\n@@ -1135,4 +1131,1 @@\n-     return idx == MemNode::Address ||\n-            idx == MemNode::ValueIn ||\n-            ((is_subword_type(vect_type()->element_basic_type())) &&\n-              idx == MemNode::ValueIn + 1);\n+     return idx == MemNode::Address || idx == MemNode::ValueIn;\n@@ -1257,1 +1250,1 @@\n-  LoadVectorGatherMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* mask, Node* offset = nullptr)\n+  LoadVectorGatherMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* mask)\n@@ -1263,3 +1256,1 @@\n-    if (is_subword_type(vt->element_basic_type())) {\n-      add_req(offset);\n-    }\n+    assert(is_subword_type(vt->element_basic_type()) || indices->bottom_type()->is_vect(), \"indices must be in vector\");\n@@ -1271,3 +1262,1 @@\n-                                                   idx == MemNode::ValueIn + 1 ||\n-                                                   (is_subword_type(vect_type()->is_vect()->element_basic_type()) &&\n-                                                   idx == MemNode::ValueIn + 2); }\n+                                                   idx == MemNode::ValueIn + 1; }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -494,2 +494,2 @@\n-                  Object base, long offset,\n-                  W index_vector,\n+                  int indexLength, Object base, long offset,\n+                  W indexVector1, W indexVector2, W indexVector3, W indexVector4,\n@@ -561,2 +561,2 @@\n-                      Object base, long offset,\n-                      W index_vector,\n+                      int indexLength, Object base, long offset,\n+                      W indexVector,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3123,5 +3123,18 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+        IntVector vix2 = null;\n+        IntVector vix3 = null;\n+        if (vlen == idx_vlen * 4) {\n+            vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);\n+            VectorIntrinsics.checkIndex(vix2, a.length);\n+            vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);\n+            VectorIntrinsics.checkIndex(vix3, a.length);\n@@ -3132,2 +3145,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, null,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, vix2, vix3, null,\n@@ -3885,5 +3898,18 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+        IntVector vix2 = null;\n+        IntVector vix3 = null;\n+        if (vlen == idx_vlen * 4) {\n+            vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);\n+            VectorIntrinsics.checkIndex(vix2, a.length);\n+            vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);\n+            VectorIntrinsics.checkIndex(vix3, a.length);\n@@ -3894,2 +3920,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, m,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, vix2, vix3, m,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":40,"deletions":14,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2940,2 +2940,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -3231,1 +3231,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -3426,2 +3426,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -3542,1 +3542,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2946,2 +2946,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -3218,1 +3218,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -3395,2 +3395,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -3492,1 +3492,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3100,2 +3100,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -3372,1 +3372,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -3549,2 +3549,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -3646,1 +3646,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2979,2 +2979,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -3270,1 +3270,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -3465,2 +3465,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -3581,1 +3581,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3124,5 +3124,9 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n@@ -3133,2 +3137,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, null,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, null,\n@@ -3871,5 +3875,9 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n@@ -3880,2 +3888,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, m,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, m,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -3766,5 +3766,19 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+#if[byte]\n+        IntVector vix2 = null;\n+        IntVector vix3 = null;\n+        if (vlen == idx_vlen * 4) {\n+            vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);\n+            VectorIntrinsics.checkIndex(vix2, a.length);\n+            vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);\n+            VectorIntrinsics.checkIndex(vix3, a.length);\n@@ -3775,2 +3789,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, null,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, vix2, vix3, null,\n@@ -3780,0 +3794,9 @@\n+#else[byte]\n+        return VectorSupport.loadWithMap(\n+            vectorType, null, $type$.class, vsp.laneCount(),\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, null,\n+            a, offset, indexMap, mapOffset, vsp,\n+            (c, idx, iMap, idy, s, vm) ->\n+            s.vOp(n -> c[idx + iMap[idy+n]]));\n+#end[byte]\n@@ -3827,2 +3850,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, null,\n@@ -4453,1 +4476,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n@@ -4974,5 +4997,19 @@\n-        for (int i = 0; i < vsp.length(); i += lsp.length()) {\n-            IntVector vix = IntVector\n-                .fromArray(lsp, indexMap, mapOffset + i)\n-                .add(offset);\n-            VectorIntrinsics.checkIndex(vix, a.length);\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+#if[byte]\n+        IntVector vix2 = null;\n+        IntVector vix3 = null;\n+        if (vlen == idx_vlen * 4) {\n+            vix2 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 2).add(offset);\n+            VectorIntrinsics.checkIndex(vix2, a.length);\n+            vix3 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen * 3).add(offset);\n+            VectorIntrinsics.checkIndex(vix3, a.length);\n@@ -4983,2 +5020,2 @@\n-            lsp.vectorType(),\n-            a, ARRAY_BASE, null, m,\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, vix2, vix3, m,\n@@ -4988,0 +5025,9 @@\n+#else[byte]\n+        return VectorSupport.loadWithMap(\n+            vectorType, maskClass, $type$.class, vsp.laneCount(),\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, m,\n+            a, offset, indexMap, mapOffset, vsp,\n+            (c, idx, iMap, idy, s, vm) ->\n+            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+#end[byte]\n@@ -5037,2 +5083,2 @@\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n+            isp.vectorType(), isp.length(),\n+            a, ARRAY_BASE, vix, null, null, null, m,\n@@ -5228,1 +5274,1 @@\n-            isp.vectorType(),\n+            isp.vectorType(), isp.length(),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":66,"deletions":20,"binary":false,"changes":86,"status":"modified"}]}