{"files":[{"patch":"@@ -241,1 +241,1 @@\n-  if(mask_type->is_con() && mask_type->get_con_as_long(bt) != -1L) {\n+  if (mask_type->is_con() && mask_type->get_con_as_long(bt) != -1L) {\n@@ -264,15 +264,0 @@\n-    int mask_max_bw;\n-    int max_bw = bt == T_INT ? 32 : 64;\n-    \/\/ Case 1) Mask value range includes -1.\n-    if ((mask_type->lo_as_long() < 0L && mask_type->hi_as_long() >= -1L)) {\n-      mask_max_bw = max_bw;\n-    \/\/ Case 2) Mask value range is less than -1.\n-    } else if (mask_type->hi_as_long() < -1L) {\n-      mask_max_bw = max_bw - 1;\n-    } else {\n-    \/\/ Case 3) Mask value range only includes +ve values.\n-      assert(mask_type->lo_as_long() >= 0, \"\");\n-      jlong clz = count_leading_zeros(mask_type->hi_as_long());\n-      clz = bt == T_INT ? clz - 32 : clz;\n-      mask_max_bw = max_bw - clz;\n-    }\n@@ -280,0 +265,20 @@\n+      int mask_max_bw;\n+      int max_bw = bt == T_INT ? 32 : 64;\n+      \/\/ Case 1) Mask value range includes -1, this negates the possibility of\n+      \/\/ strictly non-negative result value range.\n+      if ((mask_type->lo_as_long() < 0L && mask_type->hi_as_long() >= -1L)) {\n+        mask_max_bw = max_bw;\n+      \/\/ Case 2) Mask value range is less than -1, this indicates presence of at least\n+      \/\/ one zero bit in the mask value, there by constraining the result of compression to\n+      \/\/ a +ve value range.\n+      } else if (mask_type->hi_as_long() < -1L) {\n+        mask_max_bw = max_bw - 1;\n+      } else {\n+      \/\/ Case 3) Mask value range only includes +ve values, this can again be\n+      \/\/ used to ascertain known Zero bits of resultant value.\n+        assert(mask_type->lo_as_long() >= 0, \"\");\n+        jlong clz = count_leading_zeros(mask_type->hi_as_long());\n+        clz = bt == T_INT ? clz - 32 : clz;\n+        mask_max_bw = max_bw - clz;\n+      }\n+\n@@ -283,2 +288,7 @@\n-      \/\/ of participating mask value.\n-      hi = mask_max_bw < max_bw ? (1L << mask_max_bw) - 1 : src_type->hi_as_long();\n+      \/\/ of participating mask value. Thus bit compression can never\n+      \/\/ result into a value greater than original value.\n+      \/\/ For constant input we pessimistically set the upper bound\n+      \/\/ of result to max_int to prevent incorrect constant value in case\n+      \/\/ input equals lower bound of mask value range.\n+      hi = src_type->hi_as_long() == lo ? hi : src_type->hi_as_long();\n+      hi = mask_max_bw < max_bw ? (1L << mask_max_bw) - 1 : hi;\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":28,"deletions":18,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress randomness\n+ * @requires vm.compiler2.enabled & os.simpleArch == \"x64\"\n+ * @bug 8350896\n+ * @library \/test\/lib \/\n+ * @summary C2: wrong result: Integer\/Long.compress gets wrong type from CompressBitsNode::Value.\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 compiler.c2.TestBitCompressValueTransform\n+ *\/\n+package compiler.c2;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+public class TestBitCompressValueTransform {\n+\n+    public static final int  field_I = 0x400_0000;\n+    public static final long field_L = 0x400_0000_0000_0000L;\n+    public static final int  gold_I = Integer.valueOf(Integer.compress(0x8000_0000, field_I));\n+    public static final long gold_L = Long.valueOf(Long.compress(0x8000_0000_0000_0000L, field_L));\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test1(long value) {\n+        return Long.compress(0x8000_0000_0000_0000L, value);\n+    }\n+\n+    @Run(test = \"test1\")\n+    public void run1(RunInfo info) {\n+        long res = 0;\n+        for (int i = 0; i < 100000; i++) {\n+            res |= test1(field_L);\n+        }\n+        Asserts.assertEQ(res, gold_L);\n+    }\n+\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test2(int value) {\n+        return Integer.compress(0x8000_0000, value);\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void run2(RunInfo info) {\n+        int res = 0;\n+        for (int i = 0; i < 100000; i++) {\n+            res |= test2(field_I);\n+        }\n+        Asserts.assertEQ(res, gold_I);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \"} , failOn = { IRNode.UNSTABLE_IF_TRAP }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test3(int value) {\n+        int filter_bits = value & 0xF;\n+        int compress_bits = Integer.compress(15, filter_bits);\n+        if (compress_bits > 15) {\n+            value = -1;\n+        }\n+        return value;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void run3(RunInfo info) {\n+        int res = 0;\n+        for (int i = 1; i < 100000; i++) {\n+            res |= test3(i);\n+        }\n+        Asserts.assertGT(res, 0);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \"} , failOn = { IRNode.UNSTABLE_IF_TRAP }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test4(long value) {\n+        long filter_bits = value & 0xF;\n+        long compress_bits = Long.compress(15, filter_bits);\n+        if (compress_bits > 15) {\n+            value = -1;\n+        }\n+        return value;\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void run4(RunInfo info) {\n+        long res = 0;\n+        for (long i = 1; i < 100000; i++) {\n+            res |= test4(i);\n+        }\n+        Asserts.assertGT(res, 0L);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run(TestBitCompressValueTransform.class);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestBitCompressValueTransform.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -107,0 +107,1 @@\n+        \"bmi2\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}