{"files":[{"patch":"@@ -240,0 +240,1 @@\n+  assert(bt == T_INT || bt == T_LONG, \"\");\n@@ -241,1 +242,13 @@\n-  if(mask_type->is_con() && mask_type->get_con_as_long(bt) != -1L) {\n+  \/\/ Rule 1: Bit compression selects the source bits corresponding to true mask bits,\n+  \/\/ packs them and places them contiguously at destination bit positions\n+  \/\/ starting from least significant bit, remaining higher order bits are set\n+  \/\/ to zero.\n+\n+  \/\/ Rule 2: Bit expansion is a reverse process, which sequentially reads source bits\n+  \/\/ starting from LSB and places them at bit positions in result value where\n+  \/\/ corresponding mask bits are 1. Thus, bit expansion for non-negative mask\n+  \/\/ value will always generate a +ve value, this is because sign bit of result\n+  \/\/ will never be set to 1 as corresponding mask bit is always 0.\n+\n+  \/\/ Case A) Constant mask\n+  if (mask_type->is_con()) {\n@@ -243,1 +256,0 @@\n-    int bitcount = population_count(static_cast<julong>(bt == T_INT ? maskcon & 0xFFFFFFFFL : maskcon));\n@@ -245,7 +257,27 @@\n-      \/\/ Bit compression selects the source bits corresponding to true mask bits\n-      \/\/ and lays them out contiguously at destination bit positions starting from\n-      \/\/ LSB, remaining higher order bits are set to zero.\n-      \/\/ Thus, it will always generate a +ve value i.e. sign bit set to 0 if\n-      \/\/ any bit of constant mask value is zero.\n-      lo = 0L;\n-      hi = (1UL << bitcount) - 1;\n+      \/\/ Case A.1 bit compression:-\n+      \/\/ For an outlier mask value of -1 upper bound of the result equals\n+      \/\/ maximum integral value, for any other mask value its computed using\n+      \/\/ following formula\n+      \/\/       Result.Hi = 1 << popcount(mask_bits) - 1\n+      \/\/\n+      \/\/ For mask values other than -1, lower bound of the result is estimated\n+      \/\/ as zero, by assuming at least one mask bit is zero and corresponding source\n+      \/\/ bit will be masked, hence result of bit compression will always be\n+      \/\/ non-negative value. For outlier mask value of -1, assume all source bits\n+      \/\/ apart from most significant bit were set to 0, thereby resulting in\n+      \/\/ a minimum integral value.\n+      \/\/ e.g.\n+      \/\/  src = 0xXXXXXXXX (non-constant source)\n+      \/\/  mask = 0xEFFFFFFF (constant mask)\n+      \/\/  result.hi = 0x7FFFFFFF\n+      \/\/  result.lo = 0\n+      if (maskcon != -1L) {\n+        int bitcount = population_count(static_cast<julong>(bt == T_INT ? maskcon & 0xFFFFFFFFL : maskcon));\n+        hi = (1UL << bitcount) - 1;\n+        lo = 0L;\n+      } else {\n+        \/\/ preserve originally assigned hi (MAX_INT\/LONG) and lo (MIN_INT\/LONG) values\n+        \/\/ for unknown source bits.\n+        assert(hi == (bt == T_INT ? max_jint : max_jlong), \"\");\n+        assert(lo == (bt == T_INT ? min_jint : min_jlong), \"\");\n+      }\n@@ -253,0 +285,1 @@\n+      \/\/ Case A.2 bit expansion:-\n@@ -254,6 +287,31 @@\n-      \/\/ Expansion sequentially reads source bits starting from LSB\n-      \/\/ and places them over destination at bit positions corresponding\n-      \/\/ set mask bit. Thus bit expansion for non-negative mask value\n-      \/\/ will always generate a +ve value.\n-      hi = maskcon >= 0L ? maskcon : maskcon ^ lo;\n-      lo = maskcon >= 0L ? 0L : lo;\n+      if (maskcon >= 0L) {\n+        \/\/   Case A.2.1 constant mask >= 0\n+        \/\/     Result.Hi = mask, optimistically assuming all source bits\n+        \/\/     read starting from least significant bit positions are 1.\n+        \/\/     Result.Lo = 0, because at least one bit in mask is zero.\n+        \/\/   e.g.\n+        \/\/    src = 0xXXXXXXXX (non-constant source)\n+        \/\/    mask = 0x7FFFFFFF (constant mask >= 0)\n+        \/\/    result.hi = 0x7FFFFFFF\n+        \/\/    result.lo = 0\n+        hi = maskcon;\n+        lo = 0L;\n+      } else {\n+        \/\/   Case A.2.2) mask < 0\n+        \/\/     For constant mask strictly less than zero, the maximum result value will be\n+        \/\/     the same as the mask value with its sign bit flipped, assuming all source bits\n+        \/\/     except the MSB bit are set(one).\n+        \/\/\n+        \/\/     To compute minimum result value we assume all but last read source bit as zero,\n+        \/\/     this is because sign bit of result will always be set to 1 while other bit\n+        \/\/     corresponding to set mask bit should be zero.\n+        \/\/   e.g.\n+        \/\/    src = 0xXXXXXXXX (non-constant source)\n+        \/\/    mask = 0xEFFFFFFF (constant mask)\n+        \/\/    result.hi = 0xEFFFFFFF ^ 0x80000000 = 0x6FFFFFFF\n+        \/\/    result.lo = 0x80000000\n+        \/\/\n+        hi = maskcon ^ lo;\n+        \/\/ lo still retains MIN_INT\/LONG.\n+        assert(lo == (bt == T_INT ? min_jint : min_jlong), \"\");\n+      }\n@@ -263,0 +321,1 @@\n+  \/\/ Case B) Non-constant mask.\n@@ -264,15 +323,0 @@\n-    int mask_max_bw;\n-    int max_bw = bt == T_INT ? 32 : 64;\n-    \/\/ Case 1) Mask value range includes -1.\n-    if ((mask_type->lo_as_long() < 0L && mask_type->hi_as_long() >= -1L)) {\n-      mask_max_bw = max_bw;\n-    \/\/ Case 2) Mask value range is less than -1.\n-    } else if (mask_type->hi_as_long() < -1L) {\n-      mask_max_bw = max_bw - 1;\n-    } else {\n-    \/\/ Case 3) Mask value range only includes +ve values.\n-      assert(mask_type->lo_as_long() >= 0, \"\");\n-      jlong clz = count_leading_zeros(mask_type->hi_as_long());\n-      clz = bt == T_INT ? clz - 32 : clz;\n-      mask_max_bw = max_bw - clz;\n-    }\n@@ -280,5 +324,56 @@\n-      lo = mask_max_bw == max_bw ? lo : 0L;\n-      \/\/ Compress operation is inherently an unsigned operation and\n-      \/\/ result value range is primarily dependent on true count\n-      \/\/ of participating mask value.\n-      hi = mask_max_bw < max_bw ? (1L << mask_max_bw) - 1 : src_type->hi_as_long();\n+      int result_bit_width;\n+      int mask_bit_width = bt == T_INT ? 32 : 64;\n+      if ((mask_type->lo_as_long() < 0L && mask_type->hi_as_long() >= -1L)) {\n+        \/\/ Case B.1 The mask value range includes -1, hence we may use all bits,\n+        \/\/          the result has the whole value range.\n+        result_bit_width = mask_bit_width;\n+      } else if (mask_type->hi_as_long() < -1L) {\n+        \/\/ Case B.2 Mask value range is strictly less than -1, this indicates presence of at least\n+        \/\/ one unset(zero) bit in mask value, thus as per Rule 1, bit compression will always\n+        \/\/ result in a non-negative value. This guarantees that MSB bit of result value will\n+        \/\/ always be set to zero.\n+        result_bit_width = mask_bit_width - 1;\n+      } else {\n+        assert(mask_type->lo_as_long() >= 0, \"\");\n+        \/\/ Case B.3 Mask value range only includes non-negative values. Since all integral\n+        \/\/ types honours an invariant that TypeInteger._lo <= TypeInteger._hi, thus computing\n+        \/\/ leading zero bits of upper bound of mask value will allow us to ascertain\n+        \/\/ optimistic upper bound of result i.e. all the bits other than leading zero bits\n+        \/\/ can be assumed holding 1 value.\n+        jlong clz = count_leading_zeros(mask_type->hi_as_long());\n+        \/\/ Here, result of clz is w.r.t to long argument, hence for integer argument\n+        \/\/ we explicitly subtract 32 from the result.\n+        clz = bt == T_INT ? clz - 32 : clz;\n+        result_bit_width = mask_bit_width - clz;\n+      }\n+      \/\/ If the number of bits required to for the mask value range is less than the\n+      \/\/ full bit width of the integral type, then the MSB bit is guaranteed to be zero,\n+      \/\/ thus the compression result will never be a -ve value and we can safely set the\n+      \/\/ lower bound of the bit compression to zero.\n+      lo = result_bit_width == mask_bit_width ? lo : 0L;\n+\n+      assert(hi == (bt == T_INT ? max_jint : max_jlong), \"\");\n+      assert(lo == (bt == T_INT ? min_jint : min_jlong) || lo == 0, \"\");\n+\n+      if (src_type->lo_as_long() >= 0) {\n+        \/\/ Lemma 1: For strictly non-negative src, the result of the compression will never be\n+        \/\/ greater than src.\n+        \/\/ Proof: Since src is a non-negative value, its most significant bit is always 0.\n+        \/\/ Thus even if the corresponding MSB of the mask is one, the result will be a +ve\n+        \/\/ value. There are three possible cases\n+        \/\/   a. All the mask bits corresponding to set source bits are unset(zero).\n+        \/\/   b. All the mask bits corresponding to set source bits are set(one)\n+        \/\/   c. Some mask bits corresponding to set source bits are set(one) while others are unset(zero)\n+        \/\/\n+        \/\/ Case a. results into an allzero result, while Case b. gives us the upper bound which is equals source\n+        \/\/ value, while for Case c. the result will lie within [0, src]\n+        \/\/\n+        hi = src_type->hi_as_long();\n+      }\n+\n+      if (result_bit_width < mask_bit_width) {\n+        \/\/ Rule 3:\n+        \/\/ We can further constrain the upper bound of bit compression if the number of bits\n+        \/\/ which can be set(one) is less than the maximum number of bits of integral type.\n+        hi = MIN2((jlong)((1UL << result_bit_width) - 1L), hi);\n+      }\n@@ -288,0 +383,1 @@\n+      jlong min_mask = mask_type->lo_as_long();\n@@ -290,2 +386,14 @@\n-      lo = mask_type->lo_as_long() >= 0L ? 0L : lo;\n-      hi = mask_type->lo_as_long() >= 0L ? max_mask : hi;\n+      if (min_mask >= 0L) {\n+        \/\/ Lemma 2: Based on the integral type invariant ie. TypeInteger.lo <= TypeInteger.hi,\n+        \/\/ if the lower bound of non-constant mask is a non-negative value then result can never\n+        \/\/ be greater than the mask.\n+        \/\/ Proof: Since lower bound of the mask is a non-negative value, hence most significant\n+        \/\/ bit of its entire value must be unset(zero). If all the lower order 'n' source bits\n+        \/\/ where n corresponds to popcount of mask are set(ones) then upper bound of the result equals\n+        \/\/ mask. In order to compute the lower bound, we pssimistically assume all the lower order 'n'\n+        \/\/ source bits are unset(zero) there by resuling into a zero value.\n+        hi = max_mask;\n+        lo = 0;\n+      } else {\n+        \/\/ preserve the lo and hi bounds estimated till now.\n+      }\n@@ -332,0 +440,5 @@\n+  \/\/ Result is zero if src is zero irrespective of mask value.\n+  if (src_type == TypeInteger::zero(bt)) {\n+     return TypeInteger::zero(bt);\n+  }\n+\n@@ -368,0 +481,5 @@\n+  \/\/ Result is zero if src is zero irrespective of mask value.\n+  if (src_type == TypeInteger::zero(bt)) {\n+     return TypeInteger::zero(bt);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":155,"deletions":37,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -0,0 +1,676 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350896\n+ * @library \/test\/lib \/\n+ * @summary C2: wrong result: Integer\/Long.compress gets wrong type from CompressBitsNode::Value.\n+ * @run driver compiler.c2.gvn.TestBitCompressValueTransform\n+ *\/\n+package compiler.c2.gvn;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.generators.*;\n+\n+public class TestBitCompressValueTransform {\n+\n+    public static final int  field_I = 0x400_0000;\n+    public static final long field_L = 0x400_0000_0000_0000L;\n+    public static final int  gold_I = Integer.valueOf(Integer.compress(0x8000_0000, field_I));\n+    public static final long gold_L = Long.valueOf(Long.compress(0x8000_0000_0000_0000L, field_L));\n+\n+    public static RestrictableGenerator<Integer> GEN_I = Generators.G.ints();\n+    public static RestrictableGenerator<Long> GEN_L = Generators.G.longs();\n+\n+    public final int LIMIT_I1 = GEN_I.next();\n+    public final int LIMIT_I2 = GEN_I.next();\n+    public final int LIMIT_I3 = GEN_I.next();\n+    public final int LIMIT_I4 = GEN_I.next();\n+    public final int LIMIT_I5 = GEN_I.next();\n+    public final int LIMIT_I6 = GEN_I.next();\n+    public final int LIMIT_I7 = GEN_I.next();\n+    public final int LIMIT_I8 = GEN_I.next();\n+\n+    public final long LIMIT_L1 = GEN_L.next();\n+    public final long LIMIT_L2 = GEN_L.next();\n+    public final long LIMIT_L3 = GEN_L.next();\n+    public final long LIMIT_L4 = GEN_L.next();\n+    public final long LIMIT_L5 = GEN_L.next();\n+    public final long LIMIT_L6 = GEN_L.next();\n+    public final long LIMIT_L7 = GEN_L.next();\n+    public final long LIMIT_L8 = GEN_L.next();\n+\n+    public final int BOUND_LO_I = GEN_I.next();\n+    public final int BOUND_HI_I = GEN_I.next();\n+\n+    public final long BOUND_LO_L = GEN_L.next();\n+    public final long BOUND_HI_L = GEN_L.next();\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test1(long value) {\n+        return Long.compress(0x8000_0000_0000_0000L, value);\n+    }\n+\n+    @Run(test = \"test1\")\n+    public void run1(RunInfo info) {\n+        long res = 0;\n+        for (int i = 0; i < 10000; i++) {\n+            res |= test1(field_L);\n+        }\n+        Asserts.assertEQ(res, gold_L);\n+    }\n+\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test2(int value) {\n+        return Integer.compress(0x8000_0000, value);\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void run2(RunInfo info) {\n+        int res = 0;\n+        for (int i = 0; i < 10000; i++) {\n+            res |= test2(field_I);\n+        }\n+        Asserts.assertEQ(res, gold_I);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \"} , failOn = { IRNode.UNSTABLE_IF_TRAP }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test3(int value) {\n+        int filter_bits = value & 0xF;\n+        int compress_bits = Integer.compress(15, filter_bits);\n+        if (compress_bits > 15) {\n+            value = -1;\n+        }\n+        return value;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void run3(RunInfo info) {\n+        int res = 0;\n+        for (int i = 1; i < 10000; i++) {\n+            res |= test3(i);\n+        }\n+        Asserts.assertLTE(0, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \"} , failOn = { IRNode.UNSTABLE_IF_TRAP }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test4(long value) {\n+        long filter_bits = value & 0xFL;\n+        long compress_bits = Long.compress(15L, filter_bits);\n+        if (compress_bits > 15L) {\n+            value = -1;\n+        }\n+        return value;\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void run4(RunInfo info) {\n+        long res = 0;\n+        for (long i = 1; i < 10000; i++) {\n+            res |= test4(i);\n+        }\n+        Asserts.assertLTE(0L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test5(long value) {\n+        \/\/ Since value range includes -1 hence with mask\n+        \/\/ and value as -1 all the result bits will be set.\n+        long mask = Long.min(10000L, Long.max(-10000L, value));\n+        return Long.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void run5(RunInfo info) {\n+        long res = 0;\n+        for (int i = -10000; i < 10000; i++) {\n+            res |= test5((long)i);\n+        }\n+        Asserts.assertEQ(-1L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test6(long value) {\n+        \/\/ For mask within a strictly -ve value range less than -1,\n+        \/\/ result of compression will always be a +ve value.\n+        long mask = Long.min(-2L, Long.max(-10000L, value));\n+        return Long.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test6\")\n+    public void run6(RunInfo info) {\n+        long res = 0;\n+        for (int i = -10000; i < 10000; i++) {\n+            res |= test6((long)i);\n+        }\n+        Asserts.assertLTE(0L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test7(long value) {\n+        \/\/ For mask within a strictly +ve value range,\n+        \/\/ result of compression will always be a +ve value with\n+        \/\/ upper bound capped at max mask value.\n+        long mask = Long.min(10000L, Long.max(0L, value));\n+        return Long.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test7\")\n+    public void run7(RunInfo info) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = -10000; i < 10000; i++) {\n+            res = Long.max(test7((long)i), res);\n+        }\n+        Asserts.assertGTE(10000L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test8(int value) {\n+        \/\/ Since value range includes -1 hence with mask\n+        \/\/ and value as -1 all the result bits will be set.\n+        int mask = Integer.min(10000, Integer.max(-10000, value));\n+        return Integer.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void run8(RunInfo info) {\n+        int res = 0;\n+        for (int i = -10000; i < 10000; i++) {\n+            res |= test8(i);\n+        }\n+        Asserts.assertEQ(-1, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test9(int value) {\n+        \/\/ For mask within a strictly -ve value range less than -1,\n+        \/\/ result of compression will always be a +ve value.\n+        int mask = Integer.min(-2, Integer.max(-10000, value));\n+        return Integer.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void run9(RunInfo info) {\n+        int res = 0;\n+        for (int i = -10000; i < 10000; i++) {\n+            res |= test9(i);\n+        }\n+        Asserts.assertLTE(0, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test10(int value) {\n+        \/\/ For mask within a strictly +ve value range,\n+        \/\/ result of compression will always be a +ve value with\n+        \/\/ upper bound capped at max mask value.\n+        int mask = Integer.min(10000, Integer.max(0, value));\n+        return Integer.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test10\")\n+    public void run10(RunInfo info) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = -10000; i < 10000; i++) {\n+            res = Integer.max(test10(i), res);\n+        }\n+        Asserts.assertGTE(10000, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \" })\n+    public int test11(int value) {\n+        \/\/ For constant zero input, compress is folded to zero\n+        int mask = Integer.min(10000, Integer.max(0, value));\n+        return Integer.compress(0, mask);\n+    }\n+\n+    @Run(test = \"test11\")\n+    public void run11(RunInfo info) {\n+        int res = 0;\n+        for (int i = -10000; i < 10000; i++) {\n+            res |= test11(i);\n+        }\n+        Asserts.assertEQ(0, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \" })\n+    public long test12(long value) {\n+        \/\/ For constant zero input, compress is folded to zero\n+        long mask = Long.min(10000L, Long.max(0L, value));\n+        return Long.compress(0L, mask);\n+    }\n+\n+    @Run(test = \"test12\")\n+    public void run12(RunInfo info) {\n+        long res = 0;\n+        for (int i = -10000; i < 10000; i++) {\n+            res |= test12(i);\n+        }\n+        Asserts.assertEQ(0L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.EXPAND_BITS, \" 0 \" })\n+    public int test13(int value) {\n+        \/\/ For constant zero input, expand is folded to zero\n+        int mask = Integer.min(10000, Integer.max(0, value));\n+        return Integer.expand(0, mask);\n+    }\n+\n+    @Run(test = \"test13\")\n+    public void run13(RunInfo info) {\n+        int res = 0;\n+        for (int i = -10000; i < 10000; i++) {\n+            res |= test13(i);\n+        }\n+        Asserts.assertEQ(0, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.EXPAND_BITS, \" 0 \" })\n+    public long test14(long value) {\n+        \/\/ For constant zero input, compress is folded to zero\n+        long mask = Long.min(10000L, Long.max(0L, value));\n+        return Long.expand(0L, mask);\n+    }\n+\n+    @Run(test = \"test14\")\n+    public void run14(RunInfo info) {\n+        long res = 0;\n+        for (int i = -10000; i < 10000; i++) {\n+            res |= test14(i);\n+        }\n+        Asserts.assertEQ(0L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = {\"bmi2\" , \"true\"})\n+    public int test15(int src, int mask) {\n+        \/\/ src_type = [min_int + 1, -1]\n+        src = Math.max(Integer.MIN_VALUE + 1, Math.min(src, -1));\n+        return Integer.compress(src, mask);\n+    }\n+\n+    @Run (test = \"test15\")\n+    public void run15(RunInfo info) {\n+        int res = 0;\n+        for (int i = 0; i < 10000; i++) {\n+            res |= test15(0, 0);\n+        }\n+        Asserts.assertEQ(0, res);\n+    }\n+\n+    @DontCompile\n+    public int test16_interpreted(int src, int mask) {\n+        src = Math.max(BOUND_LO_I, Math.min(src, BOUND_HI_I));\n+        int res = Integer.compress(src, mask);\n+\n+        if (res > LIMIT_I1) {\n+            res += 1;\n+        }\n+        if (res > LIMIT_I2) {\n+            res += 2;\n+        }\n+        if (res > LIMIT_I3) {\n+            res += 4;\n+        }\n+        if (res > LIMIT_I4) {\n+            res += 8;\n+        }\n+        if (res > LIMIT_I5) {\n+            res += 16;\n+        }\n+        if (res > LIMIT_I6) {\n+            res += 32;\n+        }\n+        if (res > LIMIT_I7) {\n+            res += 64;\n+        }\n+        if (res > LIMIT_I8) {\n+            res += 128;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = {\"bmi2\" , \"true\"})\n+    public int test16(int src, int mask) {\n+        src = Math.max(BOUND_LO_I, Math.min(src, BOUND_HI_I));\n+        int res = Integer.compress(src, mask);\n+\n+        \/\/ Check the result with some random value ranges, if any of the\n+        \/\/ following conditions incorrectly constant folds the result will\n+        \/\/ not comply with the interpreter.\n+\n+        if (res > LIMIT_I1) {\n+            res += 1;\n+        }\n+        if (res > LIMIT_I2) {\n+            res += 2;\n+        }\n+        if (res > LIMIT_I3) {\n+            res += 4;\n+        }\n+        if (res > LIMIT_I4) {\n+            res += 8;\n+        }\n+        if (res > LIMIT_I5) {\n+            res += 16;\n+        }\n+        if (res > LIMIT_I6) {\n+            res += 32;\n+        }\n+        if (res > LIMIT_I7) {\n+            res += 64;\n+        }\n+        if (res > LIMIT_I8) {\n+            res += 128;\n+        }\n+        return res;\n+    }\n+\n+    @Run (test = \"test16\")\n+    public void run16(RunInfo info) {\n+        int actual = 0;\n+        int expected = 0;\n+\n+        for (int i = 0; i < 10000; i++) {\n+            int arg1 = GEN_I.next();\n+            int arg2 = GEN_I.next();\n+\n+            actual += test16(arg1, arg2);\n+            expected += test16_interpreted(arg1, arg2);\n+        }\n+        Asserts.assertEQ(actual, expected);\n+    }\n+\n+    @DontCompile\n+    public int test17_interpreted(int src, int mask) {\n+        src = Math.max(BOUND_LO_I, Math.min(src, BOUND_HI_I));\n+        int res = Integer.expand(src, mask);\n+\n+        if (res > LIMIT_I1) {\n+            res += 1;\n+        }\n+        if (res > LIMIT_I2) {\n+            res += 2;\n+        }\n+        if (res > LIMIT_I3) {\n+            res += 4;\n+        }\n+        if (res > LIMIT_I4) {\n+            res += 8;\n+        }\n+        if (res > LIMIT_I5) {\n+            res += 16;\n+        }\n+        if (res > LIMIT_I6) {\n+            res += 32;\n+        }\n+        if (res > LIMIT_I7) {\n+            res += 64;\n+        }\n+        if (res > LIMIT_I8) {\n+            res += 128;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.EXPAND_BITS, \" >0 \" }, applyIfCPUFeature = {\"bmi2\" , \"true\"})\n+    public int test17(int src, int mask) {\n+        src = Math.max(BOUND_LO_I, Math.min(src, BOUND_HI_I));\n+        int res = Integer.expand(src, mask);\n+\n+        \/\/ Check the result with some random value ranges, if any of the\n+        \/\/ following conditions incorrectly constant folds the result will\n+        \/\/ not comply with the interpreter.\n+\n+        if (res > LIMIT_I1) {\n+            res += 1;\n+        }\n+        if (res > LIMIT_I2) {\n+            res += 2;\n+        }\n+        if (res > LIMIT_I3) {\n+            res += 4;\n+        }\n+        if (res > LIMIT_I4) {\n+            res += 8;\n+        }\n+        if (res > LIMIT_I5) {\n+            res += 16;\n+        }\n+        if (res > LIMIT_I6) {\n+            res += 32;\n+        }\n+        if (res > LIMIT_I7) {\n+            res += 64;\n+        }\n+        if (res > LIMIT_I8) {\n+            res += 128;\n+        }\n+        return res;\n+    }\n+\n+    @Run (test = \"test17\")\n+    public void run17(RunInfo info) {\n+        int actual = 0;\n+        int expected = 0;\n+\n+        for (int i = 0; i < 10000; i++) {\n+            int arg1 = GEN_I.next();\n+            int arg2 = GEN_I.next();\n+\n+            actual += test16(arg1, arg2);\n+            expected += test16_interpreted(arg1, arg2);\n+        }\n+        Asserts.assertEQ(actual, expected);\n+    }\n+\n+    @DontCompile\n+    public long test18_interpreted(long src, long mask) {\n+        src = Math.max(BOUND_LO_L, Math.min(src, BOUND_HI_L));\n+        long res = Long.compress(src, mask);\n+\n+        if (res > LIMIT_L1) {\n+            res += 1;\n+        }\n+        if (res > LIMIT_L2) {\n+            res += 2;\n+        }\n+        if (res > LIMIT_L3) {\n+            res += 4;\n+        }\n+        if (res > LIMIT_L4) {\n+            res += 8;\n+        }\n+        if (res > LIMIT_L5) {\n+            res += 16;\n+        }\n+        if (res > LIMIT_L6) {\n+            res += 32;\n+        }\n+        if (res > LIMIT_L7) {\n+            res += 64;\n+        }\n+        if (res > LIMIT_L8) {\n+            res += 128;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = {\"bmi2\" , \"true\"})\n+    public long test18(long src, long mask) {\n+        src = Math.max(BOUND_LO_L, Math.min(src, BOUND_HI_L));\n+        long res = Long.compress(src, mask);\n+\n+        \/\/ Check the result with some random value ranges, if any of the\n+        \/\/ following conditions incorrectly constant folds the result will\n+        \/\/ not comply with the interpreter.\n+\n+        if (res > LIMIT_L1) {\n+            res += 1;\n+        }\n+        if (res > LIMIT_L2) {\n+            res += 2;\n+        }\n+        if (res > LIMIT_L3) {\n+            res += 4;\n+        }\n+        if (res > LIMIT_L4) {\n+            res += 8;\n+        }\n+        if (res > LIMIT_L5) {\n+            res += 16;\n+        }\n+        if (res > LIMIT_L6) {\n+            res += 32;\n+        }\n+        if (res > LIMIT_L7) {\n+            res += 64;\n+        }\n+        if (res > LIMIT_L8) {\n+            res += 128;\n+        }\n+        return res;\n+    }\n+\n+    @Run (test = \"test18\")\n+    public void run18(RunInfo info) {\n+        long actual = 0;\n+        long expected = 0;\n+\n+        for (int i = 0; i < 10000; i++) {\n+            long arg1 = GEN_L.next();\n+            long arg2 = GEN_L.next();\n+\n+            actual += test18(arg1, arg2);\n+            expected += test18_interpreted(arg1, arg2);\n+        }\n+        Asserts.assertEQ(actual, expected);\n+    }\n+\n+    @DontCompile\n+    public long test19_interpreted(long src, long mask) {\n+        src = Math.max(BOUND_LO_L, Math.min(src, BOUND_HI_L));\n+        long res = Long.expand(src, mask);\n+\n+        if (res > LIMIT_L1) {\n+            res += 1;\n+        }\n+        if (res > LIMIT_L2) {\n+            res += 2;\n+        }\n+        if (res > LIMIT_L3) {\n+            res += 4;\n+        }\n+        if (res > LIMIT_L4) {\n+            res += 8;\n+        }\n+        if (res > LIMIT_L5) {\n+            res += 16;\n+        }\n+        if (res > LIMIT_L6) {\n+            res += 32;\n+        }\n+        if (res > LIMIT_L7) {\n+            res += 64;\n+        }\n+        if (res > LIMIT_L8) {\n+            res += 128;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.EXPAND_BITS, \" >0 \" }, applyIfCPUFeature = {\"bmi2\" , \"true\"})\n+    public long test19(long src, long mask) {\n+        src = Math.max(BOUND_LO_L, Math.min(src, BOUND_HI_L));\n+        long res = Long.expand(src, mask);\n+\n+        \/\/ Check the result with some random value ranges, if any of the\n+        \/\/ following conditions incorrectly constant folds the result will\n+        \/\/ not comply with the interpreter.\n+\n+        if (res > LIMIT_L1) {\n+            res += 1;\n+        }\n+        if (res > LIMIT_L2) {\n+            res += 2;\n+        }\n+        if (res > LIMIT_L3) {\n+            res += 4;\n+        }\n+        if (res > LIMIT_L4) {\n+            res += 8;\n+        }\n+        if (res > LIMIT_L5) {\n+            res += 16;\n+        }\n+        if (res > LIMIT_L6) {\n+            res += 32;\n+        }\n+        if (res > LIMIT_L7) {\n+            res += 64;\n+        }\n+        if (res > LIMIT_L8) {\n+            res += 128;\n+        }\n+        return res;\n+    }\n+\n+    @Run (test = \"test19\")\n+    public void run19(RunInfo info) {\n+        long actual = 0;\n+        long expected = 0;\n+\n+        for (int i = 0; i < 10000; i++) {\n+            long arg1 = GEN_L.next();\n+            long arg2 = GEN_L.next();\n+\n+            actual += test19(arg1, arg2);\n+            expected += test19_interpreted(arg1, arg2);\n+        }\n+        Asserts.assertEQ(actual, expected);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run(TestBitCompressValueTransform.class);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestBitCompressValueTransform.java","additions":676,"deletions":0,"binary":false,"changes":676,"status":"added"},{"patch":"@@ -107,0 +107,1 @@\n+        \"bmi2\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}