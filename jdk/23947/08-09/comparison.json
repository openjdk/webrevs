{"files":[{"patch":"@@ -278,1 +278,1 @@\n-    \/\/     Result.Lo = 0\n+    \/\/     Result.Lo = 0, because at least one bit in mask is zero.\n@@ -286,3 +286,3 @@\n-    \/\/     For constant mask strictly less than zero, maximum result value will be\n-    \/\/     same as mask value with its sign bit flipped, assuming all but last read\n-    \/\/     source bits are set to 1.\n+    \/\/     For constant mask strictly less than zero, the maximum result value will be\n+    \/\/     the same as the mask value with its sign bit flipped, assuming all source bits but the last\n+    \/\/     are set to 1.\n@@ -311,4 +311,2 @@\n-        \/\/ Case B.1 Since mask value range includes -1 value, hence there is atleast one\n-        \/\/ mask value for which iff all corresponding input bits are set then bit compression\n-        \/\/ will result in a -ve value, therefore this case negates the possibility of\n-        \/\/ strictly non-negative bit compression result.\n+        \/\/ Case B.1 The mask value range includes -1, hence we may use all bits,\n+        \/\/          the result has the whole value range.\n@@ -323,0 +321,1 @@\n+        assert(mask_type->lo_as_long() >= 0, \"\");\n@@ -328,1 +327,0 @@\n-        assert(mask_type->lo_as_long() >= 0, \"\");\n@@ -335,4 +333,4 @@\n-      \/\/ If number of bits required to accommodated mask value range is less than the\n-      \/\/ full bit width of integral type, then MSB bit is guaranteed to be zero, thus\n-      \/\/ compression result will never be a -ve value and we can safely set the\n-      \/\/ lower bound of bit compression to zero.\n+      \/\/ If the number of bits required to for the mask value range is less than the\n+      \/\/ full bit width of the integral type, then the MSB bit is guaranteed to be zero,\n+      \/\/ thus the compression result will never be a -ve value and we can safely set the\n+      \/\/ lower bound of the bit compression to zero.\n@@ -344,26 +342,15 @@\n-      \/\/ As per Rule 1, bit compression packs the source bits corresponding to\n-      \/\/ set mask bits, hence for a non-negative input, result of compression will\n-      \/\/ always be less that equal to input.\n-      \/\/ e.g.\n-      \/\/    input = 0x0000F0F0\n-      \/\/    mask  = 0xFFFFFF00\n-      \/\/ Lemma 1: For strictly non-negative input, result of compression will never be greater\n-      \/\/ than input.\n-      \/\/ Proof: Since input is a non-negative value, hence, its most significant bit will\n-      \/\/ always be 0, thus even if corresponding MSB of mask is one results will be a +ve\n-      \/\/ value. Bit compression discards the input bits corresponding zero mask bits, hence\n-      \/\/ in order to consider all the set input bits, corresponding mask bits must also be\n-      \/\/ set. If a mask bit corresponding to set input bit is zero then that input bit will\n-      \/\/ not take part in bit compression, which means that maximum possible result value\n-      \/\/ can never be greater than non-negative input.\n-      \/\/\n-      \/\/ Rule 3:\n-      \/\/ We can further constrain the upper bound of bit compression if number of bits which\n-      \/\/ can be set to 1 is less than the maximum number of bits of integral type.\n-      \/\/ by using following equation.\n-      \/\/ res.hi = MIN(res.hi, (1UL << result_bit_width) - 1)\n-\n-      \/\/ Using Lemma 1, for non-negative input, upper bound of bit compression is equal to input.\n-      hi = src_type->hi_as_long() >= 0 ? src_type->hi_as_long() : hi;\n-      \/\/ Tightening upper bound of bit compression as per Rule 3.\n-      hi = result_bit_width < mask_bit_width ? MIN2((jlong)((1UL << result_bit_width) - 1L), hi) : hi;\n+      if (src_type->hi_as_long() >= 0) {\n+        \/\/ Lemma 1: For strictly non-negative src, the result of the compression will never be\n+        \/\/ greater than src.\n+        \/\/ Proof: Since src is a non-negative value, its most significant bit is always 0.\n+        \/\/ Thus even if the corresponding MSB of the mask is one, the result will be a +ve\n+        \/\/ value. <the actual proof>\n+        hi = src_type->hi_as_long();\n+      }\n+\n+      if (result_bit_width < mask_bit_width) {\n+        \/\/ Rule 3:\n+        \/\/ We can further constrain the upper bound of bit compression if the number of bits\n+        \/\/ which can be set to 1 is less than the maximum number of bits of integral type.\n+        hi = MIN2((jlong)((1UL << result_bit_width) - 1L), hi);\n+      }\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":26,"deletions":39,"binary":false,"changes":65,"status":"modified"}]}