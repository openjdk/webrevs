{"files":[{"patch":"@@ -240,2 +240,2 @@\n-\n-  if(mask_type->is_con() && mask_type->get_con_as_long(bt) != -1L) {\n+  assert(bt == T_INT || bt == T_LONG, \"\");\n+  if (mask_type->is_con() && mask_type->get_con_as_long(bt) != -1L) {\n@@ -264,15 +264,0 @@\n-    int mask_max_bw;\n-    int max_bw = bt == T_INT ? 32 : 64;\n-    \/\/ Case 1) Mask value range includes -1.\n-    if ((mask_type->lo_as_long() < 0L && mask_type->hi_as_long() >= -1L)) {\n-      mask_max_bw = max_bw;\n-    \/\/ Case 2) Mask value range is less than -1.\n-    } else if (mask_type->hi_as_long() < -1L) {\n-      mask_max_bw = max_bw - 1;\n-    } else {\n-    \/\/ Case 3) Mask value range only includes +ve values.\n-      assert(mask_type->lo_as_long() >= 0, \"\");\n-      jlong clz = count_leading_zeros(mask_type->hi_as_long());\n-      clz = bt == T_INT ? clz - 32 : clz;\n-      mask_max_bw = max_bw - clz;\n-    }\n@@ -280,5 +265,38 @@\n-      lo = mask_max_bw == max_bw ? lo : 0L;\n-      \/\/ Compress operation is inherently an unsigned operation and\n-      \/\/ result value range is primarily dependent on true count\n-      \/\/ of participating mask value.\n-      hi = mask_max_bw < max_bw ? (1L << mask_max_bw) - 1 : src_type->hi_as_long();\n+      \/\/ Pattern: Integer\/Long.compress(src_type, mask_type)\n+      int result_bit_width;\n+      int mask_bit_width = bt == T_INT ? 32 : 64;\n+      if ((mask_type->lo_as_long() < 0L && mask_type->hi_as_long() >= -1L)) {\n+        \/\/ Case 1) Mask value range includes -1, this negates the possibility of\n+        \/\/ strictly non-negative result value range.\n+        result_bit_width = mask_bit_width;\n+      } else if (mask_type->hi_as_long() < -1L) {\n+        \/\/ Case 2) Mask value range is less than -1, this indicates presence of at least\n+        \/\/ one zero bit in the mask value, thereby constraining the result of compression\n+        \/\/ to a +ve value range.\n+        result_bit_width = mask_bit_width - 1;\n+      } else {\n+        \/\/ Case 3) Mask value range only includes +ve values, thus we can\n+        \/\/ identify leading known zero bits of mask value and use this to\n+        \/\/ constrain upper bound of result value range.\n+        assert(mask_type->lo_as_long() >= 0, \"\");\n+        jlong clz = count_leading_zeros(mask_type->hi_as_long());\n+        \/\/ Here, result of clz is w.r.t to long argument, hence for integer argument\n+        \/\/ we explicitly subtract 32 from the result.\n+        clz = bt == T_INT ? clz - 32 : clz;\n+        result_bit_width = mask_bit_width - clz;\n+      }\n+      \/\/ If number of bits required to accommodated mask value range is less than the\n+      \/\/ full bit width of integral type, then MSB bit is guaranteed to be zero, thus\n+      \/\/ compression result will never be a -ve value and we can safely set the\n+      \/\/ lower bound of the result value range to zero.\n+      lo = result_bit_width == mask_bit_width ? lo : 0L;\n+\n+      assert(hi == (bt == T_INT) ? max_jint : max_jlong, \"\");\n+      assert((lo == (bt == T_INT) ? min_jint : min_jlong) || lo == 0, \"\");\n+\n+      \/\/ Following rules applies to upper bound estimation of results value range\n+      \/\/ res.hi = src.hi iff src.hi > 0 else max_value\n+      \/\/ if result_bit_width < mask_bit_width, then we can further constrain res.hi as follows.\n+      \/\/ res.hi = MIN(res.hi, (1L << result_bit_width) - 1)\n+      hi = src_type->hi_as_long() >= 0 ? src_type->hi_as_long() : hi;\n+      hi = result_bit_width < mask_bit_width ? MIN2((1L << result_bit_width) - 1, hi) : hi;\n@@ -332,0 +350,5 @@\n+  \/\/ Result is zero if src is zero irrespective of mask value.\n+  if (src_type == TypeInteger::zero(bt)) {\n+     return TypeInteger::zero(bt);\n+  }\n+\n@@ -368,0 +391,5 @@\n+  \/\/ Result is zero if src is zero irrespective of mask value.\n+  if (src_type == TypeInteger::zero(bt)) {\n+     return TypeInteger::zero(bt);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":50,"deletions":22,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -0,0 +1,295 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350896\n+ * @library \/test\/lib \/\n+ * @summary C2: wrong result: Integer\/Long.compress gets wrong type from CompressBitsNode::Value.\n+ * @run driver compiler.c2.gvn.TestBitCompressValueTransform\n+ *\/\n+package compiler.c2.gvn;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+public class TestBitCompressValueTransform {\n+\n+    public static final int  field_I = 0x400_0000;\n+    public static final long field_L = 0x400_0000_0000_0000L;\n+    public static final int  gold_I = Integer.valueOf(Integer.compress(0x8000_0000, field_I));\n+    public static final long gold_L = Long.valueOf(Long.compress(0x8000_0000_0000_0000L, field_L));\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test1(long value) {\n+        return Long.compress(0x8000_0000_0000_0000L, value);\n+    }\n+\n+    @Run(test = \"test1\")\n+    public void run1(RunInfo info) {\n+        long res = 0;\n+        for (int i = 0; i < 100000; i++) {\n+            res |= test1(field_L);\n+        }\n+        Asserts.assertEQ(res, gold_L);\n+    }\n+\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test2(int value) {\n+        return Integer.compress(0x8000_0000, value);\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void run2(RunInfo info) {\n+        int res = 0;\n+        for (int i = 0; i < 100000; i++) {\n+            res |= test2(field_I);\n+        }\n+        Asserts.assertEQ(res, gold_I);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \"} , failOn = { IRNode.UNSTABLE_IF_TRAP }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test3(int value) {\n+        int filter_bits = value & 0xF;\n+        int compress_bits = Integer.compress(15, filter_bits);\n+        if (compress_bits > 15) {\n+            value = -1;\n+        }\n+        return value;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void run3(RunInfo info) {\n+        int res = 0;\n+        for (int i = 1; i < 100000; i++) {\n+            res |= test3(i);\n+        }\n+        Asserts.assertLTE(0, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \"} , failOn = { IRNode.UNSTABLE_IF_TRAP }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test4(long value) {\n+        long filter_bits = value & 0xFL;\n+        long compress_bits = Long.compress(15L, filter_bits);\n+        if (compress_bits > 15L) {\n+            value = -1;\n+        }\n+        return value;\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void run4(RunInfo info) {\n+        long res = 0;\n+        for (long i = 1; i < 100000; i++) {\n+            res |= test4(i);\n+        }\n+        Asserts.assertLTE(0L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test5(long value) {\n+        \/\/ Since value range includes -1 hence with mask\n+        \/\/ and value as -1 all the result bits will be set.\n+        long mask = Long.min(10000L, Long.max(-10000L, value));\n+        return Long.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void run5(RunInfo info) {\n+        long res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test5((long)i);\n+        }\n+        Asserts.assertEQ(-1L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test6(long value) {\n+        \/\/ For mask within a strictly -ve value range less than -1,\n+        \/\/ result of compression will always be a +ve value.\n+        long mask = Long.min(-2L, Long.max(-10000L, value));\n+        return Long.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test6\")\n+    public void run6(RunInfo info) {\n+        long res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test6((long)i);\n+        }\n+        Asserts.assertLTE(0L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test7(long value) {\n+        \/\/ For mask within a strictly +ve value range,\n+        \/\/ result of compression will always be a +ve value with\n+        \/\/ upper bound capped at max mask value.\n+        long mask = Long.min(10000L, Long.max(0L, value));\n+        return Long.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test7\")\n+    public void run7(RunInfo info) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = -10000; i < 100000; i++) {\n+            res = Long.max(test7((long)i), res);\n+        }\n+        Asserts.assertGTE(10000L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test8(int value) {\n+        \/\/ Since value range includes -1 hence with mask\n+        \/\/ and value as -1 all the result bits will be set.\n+        int mask = Integer.min(10000, Integer.max(-10000, value));\n+        return Integer.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void run8(RunInfo info) {\n+        int res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test8(i);\n+        }\n+        Asserts.assertEQ(-1, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test9(int value) {\n+        \/\/ For mask within a strictly -ve value range less than -1,\n+        \/\/ result of compression will always be a +ve value.\n+        int mask = Integer.min(-2, Integer.max(-10000, value));\n+        return Integer.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void run9(RunInfo info) {\n+        int res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test9(i);\n+        }\n+        Asserts.assertLTE(0, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test10(int value) {\n+        \/\/ For mask within a strictly +ve value range,\n+        \/\/ result of compression will always be a +ve value with\n+        \/\/ upper bound capped at max mask value.\n+        int mask = Integer.min(10000, Integer.max(0, value));\n+        return Integer.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test10\")\n+    public void run10(RunInfo info) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = -10000; i < 100000; i++) {\n+            res = Integer.max(test10(i), res);\n+        }\n+        Asserts.assertGTE(10000, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \" })\n+    public int test11(int value) {\n+        \/\/ For constant zero input, compress is folded to zero\n+        int mask = Integer.min(10000, Integer.max(0, value));\n+        return Integer.compress(0, mask);\n+    }\n+\n+    @Run(test = \"test11\")\n+    public void run11(RunInfo info) {\n+        int res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test11(i);\n+        }\n+        Asserts.assertEQ(0, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \" })\n+    public long test12(long value) {\n+        \/\/ For constant zero input, compress is folded to zero\n+        long mask = Long.min(10000L, Long.max(0L, value));\n+        return Long.compress(0L, mask);\n+    }\n+\n+    @Run(test = \"test12\")\n+    public void run12(RunInfo info) {\n+        long res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test12(i);\n+        }\n+        Asserts.assertEQ(0L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.EXPAND_BITS, \" 0 \" })\n+    public int test13(int value) {\n+        \/\/ For constant zero input, expand is folded to zero\n+        int mask = Integer.min(10000, Integer.max(0, value));\n+        return Integer.expand(0, mask);\n+    }\n+\n+    @Run(test = \"test13\")\n+    public void run13(RunInfo info) {\n+        int res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test13(i);\n+        }\n+        Asserts.assertEQ(0, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.EXPAND_BITS, \" 0 \" })\n+    public long test14(long value) {\n+        \/\/ For constant zero input, compress is folded to zero\n+        long mask = Long.min(10000L, Long.max(0L, value));\n+        return Long.expand(0L, mask);\n+    }\n+\n+    @Run(test = \"test14\")\n+    public void run14(RunInfo info) {\n+        long res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test14(i);\n+        }\n+        Asserts.assertEQ(0L, res);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run(TestBitCompressValueTransform.class);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestBitCompressValueTransform.java","additions":295,"deletions":0,"binary":false,"changes":295,"status":"added"},{"patch":"@@ -107,0 +107,1 @@\n+        \"bmi2\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}