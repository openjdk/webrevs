{"files":[{"patch":"@@ -240,2 +240,28 @@\n-\n-  if(mask_type->is_con() && mask_type->get_con_as_long(bt) != -1L) {\n+  assert(bt == T_INT || bt == T_LONG, \"\");\n+\n+  \/\/ Rule 1: Bit compression selects the source bits corresponding to true mask bits,\n+  \/\/ packs them and places them contiguously at destination bit positions\n+  \/\/ starting from least significant bit, remaining higher order bits are set\n+  \/\/ to zero.\n+\n+  \/\/ Rule 2: Bit expansion is a reverse process, which sequentially reads source bits\n+  \/\/ starting from LSB and places them at bit positions in result value where\n+  \/\/ corresponding mask bits are 1. Thus, bit expansion for non-negative mask\n+  \/\/ value will always generate a +ve value, this is because sign bit of result\n+  \/\/ will never be set to 1 as corresponding mask bit is always 0.\n+\n+  \/\/ Case A) Constant mask\n+  if (mask_type->is_con()) {\n+    \/\/ Case A.1 bit compression:-\n+    \/\/ Result.Hi = popcount(1 << mask_bits - 1)\n+    \/\/ Result.Lo = min iff mask == -1 assuming all source bits apart from most\n+    \/\/                                significant bit were set to 0\n+    \/\/       else\n+    \/\/ Result.Lo = 0 iff atleast one mask bit is zero, corresponding source\n+    \/\/ bit will be masked, hence result of bit compression will be a +ve\n+    \/\/ value.\n+    \/\/ e.g.\n+    \/\/  src = 0xXXXXXXXX (non-constant source)\n+    \/\/  mask = 0xEFFFFFFF (constant mask)\n+    \/\/  result.hi = 0x7FFFFFFF\n+    \/\/  result.lo = 0\n@@ -243,1 +269,0 @@\n-    int bitcount = population_count(static_cast<julong>(bt == T_INT ? maskcon & 0xFFFFFFFFL : maskcon));\n@@ -245,7 +270,3 @@\n-      \/\/ Bit compression selects the source bits corresponding to true mask bits\n-      \/\/ and lays them out contiguously at destination bit positions starting from\n-      \/\/ LSB, remaining higher order bits are set to zero.\n-      \/\/ Thus, it will always generate a +ve value i.e. sign bit set to 0 if\n-      \/\/ any bit of constant mask value is zero.\n-      lo = 0L;\n-      hi = (1UL << bitcount) - 1;\n+      int bitcount = population_count(static_cast<julong>(bt == T_INT ? maskcon & 0xFFFFFFFFL : maskcon));\n+      hi = maskcon == -1L ? hi : (1UL << bitcount) - 1;\n+      lo = maskcon == -1L ? lo : 0L;\n@@ -253,0 +274,25 @@\n+    \/\/ Case A.2 bit expansion:-\n+    \/\/   Case A.2.1 constant mask >= 0\n+    \/\/     Result.Hi = mask, optimistically assuming all source bits\n+    \/\/     read starting from least significant bit positions are 1.\n+    \/\/     Result.Lo = 0\n+    \/\/   e.g.\n+    \/\/    src = 0xXXXXXXXX (non-constant source)\n+    \/\/    mask = 0x7FFFFFFF (constant mask >= 0)\n+    \/\/    result.hi = 0x7FFFFFFF\n+    \/\/    result.lo = 0\n+\n+    \/\/   Case A.2.2) mask < 0\n+    \/\/     For constant mask strictly less than zero, maximum result value will be\n+    \/\/     same as mask value with its sign bit flipped, assuming all but last read\n+    \/\/     source bits are set to 1.\n+    \/\/\n+    \/\/     To compute minimum result value we assume all but last read source bit as zero,\n+    \/\/     this is because sign bit of result will always be set to 1 while other bit\n+    \/\/     corresponding to set mask bit should be zero.\n+    \/\/   e.g.\n+    \/\/    src = 0xXXXXXXXX (non-constant source)\n+    \/\/    mask = 0xEFFFFFFF (constant mask)\n+    \/\/    result.hi = 0xEFFFFFFF ^ 0x80000000 = 0x6FFFFFFF\n+    \/\/    result.lo = 0x80000000\n+    \/\/\n@@ -254,4 +300,0 @@\n-      \/\/ Expansion sequentially reads source bits starting from LSB\n-      \/\/ and places them over destination at bit positions corresponding\n-      \/\/ set mask bit. Thus bit expansion for non-negative mask value\n-      \/\/ will always generate a +ve value.\n@@ -263,0 +305,1 @@\n+  \/\/ Case B) Non-constant mask.\n@@ -264,15 +307,0 @@\n-    int mask_max_bw;\n-    int max_bw = bt == T_INT ? 32 : 64;\n-    \/\/ Case 1) Mask value range includes -1.\n-    if ((mask_type->lo_as_long() < 0L && mask_type->hi_as_long() >= -1L)) {\n-      mask_max_bw = max_bw;\n-    \/\/ Case 2) Mask value range is less than -1.\n-    } else if (mask_type->hi_as_long() < -1L) {\n-      mask_max_bw = max_bw - 1;\n-    } else {\n-    \/\/ Case 3) Mask value range only includes +ve values.\n-      assert(mask_type->lo_as_long() >= 0, \"\");\n-      jlong clz = count_leading_zeros(mask_type->hi_as_long());\n-      clz = bt == T_INT ? clz - 32 : clz;\n-      mask_max_bw = max_bw - clz;\n-    }\n@@ -280,5 +308,62 @@\n-      lo = mask_max_bw == max_bw ? lo : 0L;\n-      \/\/ Compress operation is inherently an unsigned operation and\n-      \/\/ result value range is primarily dependent on true count\n-      \/\/ of participating mask value.\n-      hi = mask_max_bw < max_bw ? (1L << mask_max_bw) - 1 : src_type->hi_as_long();\n+      int result_bit_width;\n+      int mask_bit_width = bt == T_INT ? 32 : 64;\n+      if ((mask_type->lo_as_long() < 0L && mask_type->hi_as_long() >= -1L)) {\n+        \/\/ Case B.1 Since mask value range includes -1 value, hence there is atleast one\n+        \/\/ mask value for which iff all corresponding input bits are set then bit compression\n+        \/\/ will result in a -ve value, therefore this case negates the possibility of\n+        \/\/ strictly non-negative bit compression result.\n+        result_bit_width = mask_bit_width;\n+      } else if (mask_type->hi_as_long() < -1L) {\n+        \/\/ Case B.2 Mask value range is strictly less than -1, this indicates presence of at least\n+        \/\/ one unset(zero) bit in mask value, thus as per Rule 1, bit compression will always\n+        \/\/ result in a non-negative value. This guarantees that MSB bit of result value will\n+        \/\/ always be set to zero.\n+        result_bit_width = mask_bit_width - 1;\n+      } else {\n+        \/\/ Case B.3 Mask value range only includes non-negative values. Since all integral\n+        \/\/ types honours an invariant that TypeInteger._lo <= TypeInteger._hi, thus computing\n+        \/\/ leading zero bits of upper bound of mask value will allow us to ascertain\n+        \/\/ optimistic upper bound of result i.e. all the bits other than leading zero bits\n+        \/\/ can be assumed holding 1 value.\n+        assert(mask_type->lo_as_long() >= 0, \"\");\n+        jlong clz = count_leading_zeros(mask_type->hi_as_long());\n+        \/\/ Here, result of clz is w.r.t to long argument, hence for integer argument\n+        \/\/ we explicitly subtract 32 from the result.\n+        clz = bt == T_INT ? clz - 32 : clz;\n+        result_bit_width = mask_bit_width - clz;\n+      }\n+      \/\/ If number of bits required to accommodated mask value range is less than the\n+      \/\/ full bit width of integral type, then MSB bit is guaranteed to be zero, thus\n+      \/\/ compression result will never be a -ve value and we can safely set the\n+      \/\/ lower bound of bit compression to zero.\n+      lo = result_bit_width == mask_bit_width ? lo : 0L;\n+\n+      assert(hi == (bt == T_INT) ? max_jint : max_jlong, \"\");\n+      assert((lo == (bt == T_INT) ? min_jint : min_jlong) || lo == 0, \"\");\n+\n+      \/\/ As per Rule 1, bit compression packs the source bits corresponding to\n+      \/\/ set mask bits, hence for a non-negative input, result of compression will\n+      \/\/ always be less that equal to input.\n+      \/\/ e.g.\n+      \/\/    input = 0x0000F0F0\n+      \/\/    mask  = 0xFFFFFF00\n+      \/\/ Lemma 1: For strictly non-negative input, result of compression will never be greater\n+      \/\/ than input.\n+      \/\/ Proof: Since input is a non-negative value, hence, its most significant bit will\n+      \/\/ always be 0, thus even if corresponding MSB of mask is one results will be a +ve\n+      \/\/ value. Bit compression discards the input bits corresponding zero mask bits, hence\n+      \/\/ in order to consider all the set input bits, corresponding mask bits must also be\n+      \/\/ set. If a mask bit corresponding to set input bit is zero then that input bit will\n+      \/\/ not take part in bit compression, which means that maximum possible result value\n+      \/\/ can never be greater than non-negative input.\n+      \/\/\n+      \/\/ Rule 3:\n+      \/\/ We can further constrain the upper bound of bit compression if number of bits which\n+      \/\/ can be set to 1 is less than the maximum number of bits of integral type.\n+      \/\/ by using following equation.\n+      \/\/ res.hi = MIN(res.hi, (1UL << result_bit_width) - 1)\n+\n+      \/\/ Using Lemma 1, for non-negative input, upper bound of bit compression is equal to input.\n+      hi = src_type->hi_as_long() >= 0 ? src_type->hi_as_long() : hi;\n+      \/\/ Tightening upper bound of bit compression as per Rule 3.\n+      hi = result_bit_width < mask_bit_width ? MIN2((jlong)((1UL << result_bit_width) - 1L), hi) : hi;\n@@ -332,0 +417,5 @@\n+  \/\/ Result is zero if src is zero irrespective of mask value.\n+  if (src_type == TypeInteger::zero(bt)) {\n+     return TypeInteger::zero(bt);\n+  }\n+\n@@ -368,0 +458,5 @@\n+  \/\/ Result is zero if src is zero irrespective of mask value.\n+  if (src_type == TypeInteger::zero(bt)) {\n+     return TypeInteger::zero(bt);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":129,"deletions":34,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -0,0 +1,312 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350896\n+ * @library \/test\/lib \/\n+ * @summary C2: wrong result: Integer\/Long.compress gets wrong type from CompressBitsNode::Value.\n+ * @run driver compiler.c2.gvn.TestBitCompressValueTransform\n+ *\/\n+package compiler.c2.gvn;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+public class TestBitCompressValueTransform {\n+\n+    public static final int  field_I = 0x400_0000;\n+    public static final long field_L = 0x400_0000_0000_0000L;\n+    public static final int  gold_I = Integer.valueOf(Integer.compress(0x8000_0000, field_I));\n+    public static final long gold_L = Long.valueOf(Long.compress(0x8000_0000_0000_0000L, field_L));\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test1(long value) {\n+        return Long.compress(0x8000_0000_0000_0000L, value);\n+    }\n+\n+    @Run(test = \"test1\")\n+    public void run1(RunInfo info) {\n+        long res = 0;\n+        for (int i = 0; i < 100000; i++) {\n+            res |= test1(field_L);\n+        }\n+        Asserts.assertEQ(res, gold_L);\n+    }\n+\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test2(int value) {\n+        return Integer.compress(0x8000_0000, value);\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void run2(RunInfo info) {\n+        int res = 0;\n+        for (int i = 0; i < 100000; i++) {\n+            res |= test2(field_I);\n+        }\n+        Asserts.assertEQ(res, gold_I);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \"} , failOn = { IRNode.UNSTABLE_IF_TRAP }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test3(int value) {\n+        int filter_bits = value & 0xF;\n+        int compress_bits = Integer.compress(15, filter_bits);\n+        if (compress_bits > 15) {\n+            value = -1;\n+        }\n+        return value;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void run3(RunInfo info) {\n+        int res = 0;\n+        for (int i = 1; i < 100000; i++) {\n+            res |= test3(i);\n+        }\n+        Asserts.assertLTE(0, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \"} , failOn = { IRNode.UNSTABLE_IF_TRAP }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test4(long value) {\n+        long filter_bits = value & 0xFL;\n+        long compress_bits = Long.compress(15L, filter_bits);\n+        if (compress_bits > 15L) {\n+            value = -1;\n+        }\n+        return value;\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void run4(RunInfo info) {\n+        long res = 0;\n+        for (long i = 1; i < 100000; i++) {\n+            res |= test4(i);\n+        }\n+        Asserts.assertLTE(0L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test5(long value) {\n+        \/\/ Since value range includes -1 hence with mask\n+        \/\/ and value as -1 all the result bits will be set.\n+        long mask = Long.min(10000L, Long.max(-10000L, value));\n+        return Long.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void run5(RunInfo info) {\n+        long res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test5((long)i);\n+        }\n+        Asserts.assertEQ(-1L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test6(long value) {\n+        \/\/ For mask within a strictly -ve value range less than -1,\n+        \/\/ result of compression will always be a +ve value.\n+        long mask = Long.min(-2L, Long.max(-10000L, value));\n+        return Long.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test6\")\n+    public void run6(RunInfo info) {\n+        long res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test6((long)i);\n+        }\n+        Asserts.assertLTE(0L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test7(long value) {\n+        \/\/ For mask within a strictly +ve value range,\n+        \/\/ result of compression will always be a +ve value with\n+        \/\/ upper bound capped at max mask value.\n+        long mask = Long.min(10000L, Long.max(0L, value));\n+        return Long.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test7\")\n+    public void run7(RunInfo info) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = -10000; i < 100000; i++) {\n+            res = Long.max(test7((long)i), res);\n+        }\n+        Asserts.assertGTE(10000L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test8(int value) {\n+        \/\/ Since value range includes -1 hence with mask\n+        \/\/ and value as -1 all the result bits will be set.\n+        int mask = Integer.min(10000, Integer.max(-10000, value));\n+        return Integer.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void run8(RunInfo info) {\n+        int res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test8(i);\n+        }\n+        Asserts.assertEQ(-1, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test9(int value) {\n+        \/\/ For mask within a strictly -ve value range less than -1,\n+        \/\/ result of compression will always be a +ve value.\n+        int mask = Integer.min(-2, Integer.max(-10000, value));\n+        return Integer.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void run9(RunInfo info) {\n+        int res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test9(i);\n+        }\n+        Asserts.assertLTE(0, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test10(int value) {\n+        \/\/ For mask within a strictly +ve value range,\n+        \/\/ result of compression will always be a +ve value with\n+        \/\/ upper bound capped at max mask value.\n+        int mask = Integer.min(10000, Integer.max(0, value));\n+        return Integer.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test10\")\n+    public void run10(RunInfo info) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = -10000; i < 100000; i++) {\n+            res = Integer.max(test10(i), res);\n+        }\n+        Asserts.assertGTE(10000, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \" })\n+    public int test11(int value) {\n+        \/\/ For constant zero input, compress is folded to zero\n+        int mask = Integer.min(10000, Integer.max(0, value));\n+        return Integer.compress(0, mask);\n+    }\n+\n+    @Run(test = \"test11\")\n+    public void run11(RunInfo info) {\n+        int res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test11(i);\n+        }\n+        Asserts.assertEQ(0, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \" })\n+    public long test12(long value) {\n+        \/\/ For constant zero input, compress is folded to zero\n+        long mask = Long.min(10000L, Long.max(0L, value));\n+        return Long.compress(0L, mask);\n+    }\n+\n+    @Run(test = \"test12\")\n+    public void run12(RunInfo info) {\n+        long res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test12(i);\n+        }\n+        Asserts.assertEQ(0L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.EXPAND_BITS, \" 0 \" })\n+    public int test13(int value) {\n+        \/\/ For constant zero input, expand is folded to zero\n+        int mask = Integer.min(10000, Integer.max(0, value));\n+        return Integer.expand(0, mask);\n+    }\n+\n+    @Run(test = \"test13\")\n+    public void run13(RunInfo info) {\n+        int res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test13(i);\n+        }\n+        Asserts.assertEQ(0, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.EXPAND_BITS, \" 0 \" })\n+    public long test14(long value) {\n+        \/\/ For constant zero input, compress is folded to zero\n+        long mask = Long.min(10000L, Long.max(0L, value));\n+        return Long.expand(0L, mask);\n+    }\n+\n+    @Run(test = \"test14\")\n+    public void run14(RunInfo info) {\n+        long res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test14(i);\n+        }\n+        Asserts.assertEQ(0L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" 1 \" })\n+    public int test15(int src, int mask) {\n+        \/\/ src_type = [min_int + 1, -1]\n+        src = Math.max(Integer.MIN_VALUE + 1, Math.min(src, -1));\n+        return Integer.compress(src, mask);\n+    }\n+\n+    @Run (test = \"test15\")\n+    public void run15(RunInfo info) {\n+        int res = 0;\n+        for (int i = 0; i < 100000; i++) {\n+            res |= test15(0, 0);\n+        }\n+        Asserts.assertEQ(0, res);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run(TestBitCompressValueTransform.class);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestBitCompressValueTransform.java","additions":312,"deletions":0,"binary":false,"changes":312,"status":"added"},{"patch":"@@ -107,0 +107,1 @@\n+        \"bmi2\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}