{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import compiler.lib.generators.*;\n@@ -43,0 +44,27 @@\n+    public static RestrictableGenerator<Integer> GEN_I = Generators.G.ints();\n+    public static RestrictableGenerator<Long> GEN_L = Generators.G.longs();\n+\n+    public final int LIMIT_I1 = GEN_I.next();\n+    public final int LIMIT_I2 = GEN_I.next();\n+    public final int LIMIT_I3 = GEN_I.next();\n+    public final int LIMIT_I4 = GEN_I.next();\n+    public final int LIMIT_I5 = GEN_I.next();\n+    public final int LIMIT_I6 = GEN_I.next();\n+    public final int LIMIT_I7 = GEN_I.next();\n+    public final int LIMIT_I8 = GEN_I.next();\n+\n+    public final long LIMIT_L1 = GEN_L.next();\n+    public final long LIMIT_L2 = GEN_L.next();\n+    public final long LIMIT_L3 = GEN_L.next();\n+    public final long LIMIT_L4 = GEN_L.next();\n+    public final long LIMIT_L5 = GEN_L.next();\n+    public final long LIMIT_L6 = GEN_L.next();\n+    public final long LIMIT_L7 = GEN_L.next();\n+    public final long LIMIT_L8 = GEN_L.next();\n+\n+    public final int BOUND_LO_I = GEN_I.next();\n+    public final int BOUND_HI_I = GEN_I.next();\n+\n+    public final long BOUND_LO_L = GEN_L.next();\n+    public final long BOUND_HI_L = GEN_L.next();\n+\n@@ -309,0 +337,336 @@\n+    @DontCompile\n+    public int test16_interpreted(int src, int mask) {\n+        src = Math.max(BOUND_LO_I, Math.min(src, BOUND_HI_I));\n+        int res = Integer.compress(src, mask);\n+\n+        if (res > LIMIT_I1) {\n+            res += 100;\n+        }\n+        if (res > LIMIT_I2) {\n+            res += 200;\n+        }\n+        if (res > LIMIT_I3) {\n+            res += 300;\n+        }\n+        if (res > LIMIT_I4) {\n+            res += 400;\n+        }\n+        if (res > LIMIT_I5) {\n+            res += 500;\n+        }\n+        if (res > LIMIT_I6) {\n+            res += 600;\n+        }\n+        if (res > LIMIT_I7) {\n+            res += 700;\n+        }\n+        if (res > LIMIT_I8) {\n+            res += 800;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = {\"bmi2\" , \"true\"})\n+    public int test16(int src, int mask) {\n+        src = Math.max(BOUND_LO_I, Math.min(src, BOUND_HI_I));\n+        int res = Integer.compress(src, mask);\n+\n+        \/\/ Check the result with some random value ranges, if any of the\n+        \/\/ following conditions incorrectly constant folds the result will\n+        \/\/ not comply with the interpreter.\n+\n+        if (res > LIMIT_I1) {\n+            res += 100;\n+        }\n+        if (res > LIMIT_I2) {\n+            res += 200;\n+        }\n+        if (res > LIMIT_I3) {\n+            res += 300;\n+        }\n+        if (res > LIMIT_I4) {\n+            res += 400;\n+        }\n+        if (res > LIMIT_I5) {\n+            res += 500;\n+        }\n+        if (res > LIMIT_I6) {\n+            res += 600;\n+        }\n+        if (res > LIMIT_I7) {\n+            res += 700;\n+        }\n+        if (res > LIMIT_I8) {\n+            res += 800;\n+        }\n+        return res;\n+    }\n+\n+    @Run (test = \"test16\")\n+    public void run16(RunInfo info) {\n+        int actual = 0;\n+        int expected = 0;\n+\n+        for (int i = 0; i < 10000; i++) {\n+            int arg1 = GEN_I.next();\n+            int arg2 = GEN_I.next();\n+\n+            actual += test16(arg1, arg2);\n+            expected += test16_interpreted(arg1, arg2);\n+        }\n+        Asserts.assertEQ(actual, expected);\n+    }\n+\n+    @DontCompile\n+    public int test17_interpreted(int src, int mask) {\n+        src = Math.max(BOUND_LO_I, Math.min(src, BOUND_HI_I));\n+        int res = Integer.expand(src, mask);\n+\n+        if (res > LIMIT_I1) {\n+            res += 100;\n+        }\n+        if (res > LIMIT_I2) {\n+            res += 200;\n+        }\n+        if (res > LIMIT_I3) {\n+            res += 300;\n+        }\n+        if (res > LIMIT_I4) {\n+            res += 400;\n+        }\n+        if (res > LIMIT_I5) {\n+            res += 500;\n+        }\n+        if (res > LIMIT_I6) {\n+            res += 600;\n+        }\n+        if (res > LIMIT_I7) {\n+            res += 700;\n+        }\n+        if (res > LIMIT_I8) {\n+            res += 800;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.EXPAND_BITS, \" >0 \" }, applyIfCPUFeature = {\"bmi2\" , \"true\"})\n+    public int test17(int src, int mask) {\n+        src = Math.max(BOUND_LO_I, Math.min(src, BOUND_HI_I));\n+        int res = Integer.expand(src, mask);\n+\n+        \/\/ Check the result with some random value ranges, if any of the\n+        \/\/ following conditions incorrectly constant folds the result will\n+        \/\/ not comply with the interpreter.\n+\n+        if (res > LIMIT_I1) {\n+            res += 100;\n+        }\n+        if (res > LIMIT_I2) {\n+            res += 200;\n+        }\n+        if (res > LIMIT_I3) {\n+            res += 300;\n+        }\n+        if (res > LIMIT_I4) {\n+            res += 400;\n+        }\n+        if (res > LIMIT_I5) {\n+            res += 500;\n+        }\n+        if (res > LIMIT_I6) {\n+            res += 600;\n+        }\n+        if (res > LIMIT_I7) {\n+            res += 700;\n+        }\n+        if (res > LIMIT_I8) {\n+            res += 800;\n+        }\n+        return res;\n+    }\n+\n+    @Run (test = \"test17\")\n+    public void run17(RunInfo info) {\n+        int actual = 0;\n+        int expected = 0;\n+\n+        for (int i = 0; i < 10000; i++) {\n+            int arg1 = GEN_I.next();\n+            int arg2 = GEN_I.next();\n+\n+            actual += test16(arg1, arg2);\n+            expected += test16_interpreted(arg1, arg2);\n+        }\n+        Asserts.assertEQ(actual, expected);\n+    }\n+\n+    @DontCompile\n+    public long test18_interpreted(long src, long mask) {\n+        src = Math.max(BOUND_LO_L, Math.min(src, BOUND_HI_L));\n+        long res = Long.compress(src, mask);\n+\n+        if (res > LIMIT_L1) {\n+            res += 100;\n+        }\n+        if (res > LIMIT_L2) {\n+            res += 200;\n+        }\n+        if (res > LIMIT_L3) {\n+            res += 300;\n+        }\n+        if (res > LIMIT_L4) {\n+            res += 400;\n+        }\n+        if (res > LIMIT_L5) {\n+            res += 500;\n+        }\n+        if (res > LIMIT_L6) {\n+            res += 600;\n+        }\n+        if (res > LIMIT_L7) {\n+            res += 700;\n+        }\n+        if (res > LIMIT_L8) {\n+            res += 800;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = {\"bmi2\" , \"true\"})\n+    public long test18(long src, long mask) {\n+        src = Math.max(BOUND_LO_L, Math.min(src, BOUND_HI_L));\n+        long res = Long.compress(src, mask);\n+\n+        \/\/ Check the result with some random value ranges, if any of the\n+        \/\/ following conditions incorrectly constant folds the result will\n+        \/\/ not comply with the interpreter.\n+\n+        if (res > LIMIT_L1) {\n+            res += 100;\n+        }\n+        if (res > LIMIT_L2) {\n+            res += 200;\n+        }\n+        if (res > LIMIT_L3) {\n+            res += 300;\n+        }\n+        if (res > LIMIT_L4) {\n+            res += 400;\n+        }\n+        if (res > LIMIT_L5) {\n+            res += 500;\n+        }\n+        if (res > LIMIT_L6) {\n+            res += 600;\n+        }\n+        if (res > LIMIT_L7) {\n+            res += 700;\n+        }\n+        if (res > LIMIT_L8) {\n+            res += 800;\n+        }\n+        return res;\n+    }\n+\n+    @Run (test = \"test18\")\n+    public void run18(RunInfo info) {\n+        long actual = 0;\n+        long expected = 0;\n+\n+        for (int i = 0; i < 10000; i++) {\n+            long arg1 = GEN_L.next();\n+            long arg2 = GEN_L.next();\n+\n+            actual += test18(arg1, arg2);\n+            expected += test18_interpreted(arg1, arg2);\n+        }\n+        Asserts.assertEQ(actual, expected);\n+    }\n+\n+    @DontCompile\n+    public long test19_interpreted(long src, long mask) {\n+        src = Math.max(BOUND_LO_L, Math.min(src, BOUND_HI_L));\n+        long res = Long.expand(src, mask);\n+\n+        if (res > LIMIT_L1) {\n+            res += 100;\n+        }\n+        if (res > LIMIT_L2) {\n+            res += 200;\n+        }\n+        if (res > LIMIT_L3) {\n+            res += 300;\n+        }\n+        if (res > LIMIT_L4) {\n+            res += 400;\n+        }\n+        if (res > LIMIT_L5) {\n+            res += 500;\n+        }\n+        if (res > LIMIT_L6) {\n+            res += 600;\n+        }\n+        if (res > LIMIT_L7) {\n+            res += 700;\n+        }\n+        if (res > LIMIT_L8) {\n+            res += 800;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.EXPAND_BITS, \" >0 \" }, applyIfCPUFeature = {\"bmi2\" , \"true\"})\n+    public long test19(long src, long mask) {\n+        src = Math.max(BOUND_LO_L, Math.min(src, BOUND_HI_L));\n+        long res = Long.expand(src, mask);\n+\n+        \/\/ Check the result with some random value ranges, if any of the\n+        \/\/ following conditions incorrectly constant folds the result will\n+        \/\/ not comply with the interpreter.\n+\n+        if (res > LIMIT_L1) {\n+            res += 100;\n+        }\n+        if (res > LIMIT_L2) {\n+            res += 200;\n+        }\n+        if (res > LIMIT_L3) {\n+            res += 300;\n+        }\n+        if (res > LIMIT_L4) {\n+            res += 400;\n+        }\n+        if (res > LIMIT_L5) {\n+            res += 500;\n+        }\n+        if (res > LIMIT_L6) {\n+            res += 600;\n+        }\n+        if (res > LIMIT_L7) {\n+            res += 700;\n+        }\n+        if (res > LIMIT_L8) {\n+            res += 800;\n+        }\n+        return res;\n+    }\n+\n+    @Run (test = \"test19\")\n+    public void run19(RunInfo info) {\n+        long actual = 0;\n+        long expected = 0;\n+\n+        for (int i = 0; i < 10000; i++) {\n+            long arg1 = GEN_L.next();\n+            long arg2 = GEN_L.next();\n+\n+            actual += test19(arg1, arg2);\n+            expected += test19_interpreted(arg1, arg2);\n+        }\n+        Asserts.assertEQ(actual, expected);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestBitCompressValueTransform.java","additions":364,"deletions":0,"binary":false,"changes":364,"status":"modified"}]}