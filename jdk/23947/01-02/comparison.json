{"files":[{"patch":"@@ -274,1 +274,1 @@\n-        \/\/ one zero bit in the mask value, there by constraining the result of compression\n+        \/\/ one zero bit in the mask value, thereby constraining the result of compression\n@@ -278,2 +278,3 @@\n-        \/\/ Case 3) Mask value range only includes +ve values, this can again be\n-        \/\/ used to ascertain known Zero bits of resultant value.\n+        \/\/ Case 3) Mask value range only includes +ve values, thus we can\n+        \/\/ identify leading known zero bits of mask value and use this to\n+        \/\/ constrain upper bound of result value range.\n@@ -294,1 +295,1 @@\n-      \/\/ For upper bound estimation of result value range for a constant input we\n+      \/\/ For upper bound estimation of result value range with a constant input we\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm -Xbatch -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 compiler.c2.TestBitCompressValueTransform\n+ * @run main\/othervm compiler.c2.TestBitCompressValueTransform\n@@ -225,1 +225,1 @@\n-    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \" })\n@@ -242,1 +242,1 @@\n-    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \" })\n@@ -258,0 +258,34 @@\n+    @Test\n+    @IR (counts = { IRNode.EXPAND_BITS, \" 0 \" })\n+    public int test13(int value) {\n+        \/\/ For constant zero input, expand is folded to zero\n+        int mask = Integer.min(10000, Integer.max(0, value));\n+        return Integer.expand(0, mask);\n+    }\n+\n+    @Run(test = \"test13\")\n+    public void run13(RunInfo info) {\n+        int res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test13(i);\n+        }\n+        Asserts.assertEQ(0, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.EXPAND_BITS, \" 0 \" })\n+    public long test14(long value) {\n+        \/\/ For constant zero input, compress is folded to zero\n+        long mask = Long.min(10000L, Long.max(0L, value));\n+        return Long.expand(0L, mask);\n+    }\n+\n+    @Run(test = \"test14\")\n+    public void run14(RunInfo info) {\n+        long res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test14(i);\n+        }\n+        Asserts.assertEQ(0L, res);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestBitCompressValueTransform.java","additions":37,"deletions":3,"binary":false,"changes":40,"status":"modified"}]}