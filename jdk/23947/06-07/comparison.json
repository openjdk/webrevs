{"files":[{"patch":"@@ -241,1 +241,27 @@\n-  if (mask_type->is_con() && mask_type->get_con_as_long(bt) != -1L) {\n+\n+  \/\/ Rule 1: Bit compression selects the source bits corresponding to true mask bits,\n+  \/\/ packs them and places them contiguously at destination bit positions\n+  \/\/ starting from least significant bit, remaining higher order bits are set\n+  \/\/ to zero.\n+\n+  \/\/ Rule 2: Bit expansion is a reverse process, which sequentially reads source bits\n+  \/\/ starting from LSB and places them at bit positions in result value where\n+  \/\/ corresponding mask bits are 1. Thus, bit expansion for non-negative mask\n+  \/\/ value will always generate a +ve value, this is because sign bit of result\n+  \/\/ will never be set to 1 as corresponding mask bit is always 0.\n+\n+  \/\/ Case A) Constant mask\n+  if (mask_type->is_con()) {\n+    \/\/ Case A.1 bit compression:-\n+    \/\/ Result.Hi = popcount(1 << mask_bits - 1)\n+    \/\/ Result.Lo = min iff mask == -1 assuming all source bits apart from most\n+    \/\/                                significant bit were set to 0\n+    \/\/       else\n+    \/\/ Result.Lo = 0 iff atleast one mask bit is zero, corresponding source\n+    \/\/ bit will be masked, hence result of bit compression will be a +ve\n+    \/\/ value.\n+    \/\/ e.g.\n+    \/\/  src = 0xXXXXXXXX (non-constant source)\n+    \/\/  mask = 0xEFFFFFFF (constant mask)\n+    \/\/  result.hi = 0x7FFFFFFF\n+    \/\/  result.lo = 0\n@@ -243,1 +269,0 @@\n-    int bitcount = population_count(static_cast<julong>(bt == T_INT ? maskcon & 0xFFFFFFFFL : maskcon));\n@@ -245,7 +270,3 @@\n-      \/\/ Bit compression selects the source bits corresponding to true mask bits\n-      \/\/ and lays them out contiguously at destination bit positions starting from\n-      \/\/ LSB, remaining higher order bits are set to zero.\n-      \/\/ Thus, it will always generate a +ve value i.e. sign bit set to 0 if\n-      \/\/ any bit of constant mask value is zero.\n-      lo = 0L;\n-      hi = (1UL << bitcount) - 1;\n+      int bitcount = population_count(static_cast<julong>(bt == T_INT ? maskcon & 0xFFFFFFFFL : maskcon));\n+      hi = maskcon == -1L ? hi : (1UL << bitcount) - 1;\n+      lo = maskcon == -1L ? lo : 0L;\n@@ -253,0 +274,25 @@\n+    \/\/ Case A.2 bit expansion:-\n+    \/\/   Case A.2.1 constant mask >= 0\n+    \/\/     Result.Hi = mask, optimistically assuming all source bits\n+    \/\/     read starting from least significant bit positions are 1.\n+    \/\/     Result.Lo = 0\n+    \/\/   e.g.\n+    \/\/    src = 0xXXXXXXXX (non-constant source)\n+    \/\/    mask = 0x7FFFFFFF (constant mask >= 0)\n+    \/\/    result.hi = 0x7FFFFFFF\n+    \/\/    result.lo = 0\n+\n+    \/\/   Case A.2.2) mask < 0\n+    \/\/     For constant mask strictly less than zero, maximum result value will be\n+    \/\/     same as mask value with its sign bit flipped, assuming all but last read\n+    \/\/     source bits are set to 1.\n+    \/\/\n+    \/\/     To compute minimum result value we assume all but last read source bit as zero,\n+    \/\/     this is because sign bit of result will always be set to 1 while other bit\n+    \/\/     corresponding to set mask bit should be zero.\n+    \/\/   e.g.\n+    \/\/    src = 0xXXXXXXXX (non-constant source)\n+    \/\/    mask = 0xEFFFFFFF (constant mask)\n+    \/\/    result.hi = 0xEFFFFFFF ^ 0x80000000 = 0x6FFFFFFF\n+    \/\/    result.lo = 0x80000000\n+    \/\/\n@@ -254,4 +300,0 @@\n-      \/\/ Expansion sequentially reads source bits starting from LSB\n-      \/\/ and places them over destination at bit positions corresponding\n-      \/\/ set mask bit. Thus bit expansion for non-negative mask value\n-      \/\/ will always generate a +ve value.\n@@ -263,0 +305,1 @@\n+  \/\/ Case B) Non-constant mask.\n@@ -265,1 +308,0 @@\n-      \/\/ Pattern: Integer\/Long.compress(src_type, mask_type)\n@@ -269,2 +311,4 @@\n-        \/\/ Case 1) Mask value range includes -1, this negates the possibility of\n-        \/\/ strictly non-negative result value range.\n+        \/\/ Case B.1 Since mask value range includes -1 value, hence there is atleast one\n+        \/\/ mask value for which iff all corresponding input bits are set then bit compression\n+        \/\/ will result in a -ve value, therefore this case negates the possibility of\n+        \/\/ strictly non-negative bit compression result.\n@@ -273,3 +317,4 @@\n-        \/\/ Case 2) Mask value range is less than -1, this indicates presence of at least\n-        \/\/ one zero bit in the mask value, thereby constraining the result of compression\n-        \/\/ to a +ve value range.\n+        \/\/ Case B.2 Mask value range is strictly less than -1, this indicates presence of at least\n+        \/\/ one unset(zero) bit in mask value, thus as per Rule 1, bit compression will always\n+        \/\/ result in a non-negative value. This guarantees that MSB bit of result value will\n+        \/\/ always be set to zero.\n@@ -278,3 +323,5 @@\n-        \/\/ Case 3) Mask value range only includes +ve values, thus we can\n-        \/\/ identify leading known zero bits of mask value and use this to\n-        \/\/ constrain upper bound of result value range.\n+        \/\/ Case B.3 Mask value range only includes non-negative values. Since all integral\n+        \/\/ types honours an invariant that TypeInteger._lo <= TypeInteger._hi, thus computing\n+        \/\/ leading zero bits of upper bound of mask value will allow us to ascertain\n+        \/\/ optimistic upper bound of result i.e. all the bits other than leading zero bits\n+        \/\/ can be assumed holding 1 value.\n@@ -291,1 +338,1 @@\n-      \/\/ lower bound of the result value range to zero.\n+      \/\/ lower bound of bit compression to zero.\n@@ -297,4 +344,23 @@\n-      \/\/ Following rules applies to upper bound estimation of results value range\n-      \/\/ res.hi = src.hi iff src.hi > 0 else max_value\n-      \/\/ if result_bit_width < mask_bit_width, then we can further constrain res.hi as follows.\n-      \/\/ res.hi = MIN(res.hi, (1L << result_bit_width) - 1)\n+      \/\/ As per Rule 1, bit compression packs the source bits corresponding to\n+      \/\/ set mask bits, hence for a non-negative input, result of compression will\n+      \/\/ always be less that equal to input.\n+      \/\/ e.g.\n+      \/\/    input = 0x0000F0F0\n+      \/\/    mask  = 0xFFFFFF00\n+      \/\/ Lemma 1: For strictly non-negative input, result of compression will never be greater\n+      \/\/ than input.\n+      \/\/ Proof: Since input is a non-negative value, hence, its most significant bit will\n+      \/\/ always be 0, thus even if corresponding MSB of mask is one results will be a +ve\n+      \/\/ value. Bit compression discards the input bits corresponding zero mask bits, hence\n+      \/\/ in order to consider all the set input bits, corresponding mask bits must also be\n+      \/\/ set. If a mask bit corresponding to set input bit is zero then that input bit will\n+      \/\/ not take part in bit compression, which means that maximum possible result value\n+      \/\/ can never be greater than non-negative input.\n+      \/\/\n+      \/\/ Rule 3:\n+      \/\/ We can further constrain the upper bound of bit compression if number of bits which\n+      \/\/ can be set to 1 is less than the maximum number of bits of integral type.\n+      \/\/ by using following equation.\n+      \/\/ res.hi = MIN(res.hi, (1UL << result_bit_width) - 1)\n+\n+      \/\/ Using Lemma 1, for non-negative input, upper bound of bit compression is equal to input.\n@@ -302,1 +368,2 @@\n-      hi = result_bit_width < mask_bit_width ? MIN2((jlong)((1L << result_bit_width) - 1L), hi) : hi;\n+      \/\/ Tightening upper bound of bit compression as per Rule 3.\n+      hi = result_bit_width < mask_bit_width ? MIN2((jlong)((1UL << result_bit_width) - 1L), hi) : hi;\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":95,"deletions":28,"binary":false,"changes":123,"status":"modified"}]}