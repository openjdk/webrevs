{"files":[{"patch":"@@ -240,1 +240,1 @@\n-\n+  assert(bt == T_INT || bt == T_LONG, \"\");\n@@ -265,4 +265,3 @@\n-      int mask_max_bw;\n-      int max_bw = bt == T_INT ? 32 : 64;\n-      \/\/ Case 1) Mask value range includes -1, this negates the possibility of\n-      \/\/ strictly non-negative result value range.\n+      \/\/ Pattern: Integer\/Long.compress(src_type, mask_type)\n+      int max_mask_bit_width;\n+      int mask_bit_width = bt == T_INT ? 32 : 64;\n@@ -270,4 +269,3 @@\n-        mask_max_bw = max_bw;\n-      \/\/ Case 2) Mask value range is less than -1, this indicates presence of at least\n-      \/\/ one zero bit in the mask value, there by constraining the result of compression to\n-      \/\/ a +ve value range.\n+        \/\/ Case 1) Mask value range includes -1, this negates the possibility of\n+        \/\/ strictly non-negative result value range.\n+        max_mask_bit_width = mask_bit_width;\n@@ -275,1 +273,4 @@\n-        mask_max_bw = max_bw - 1;\n+        \/\/ Case 2) Mask value range is less than -1, this indicates presence of at least\n+        \/\/ one zero bit in the mask value, there by constraining the result of compression\n+        \/\/ to a +ve value range.\n+        max_mask_bit_width = mask_bit_width - 1;\n@@ -277,2 +278,2 @@\n-      \/\/ Case 3) Mask value range only includes +ve values, this can again be\n-      \/\/ used to ascertain known Zero bits of resultant value.\n+        \/\/ Case 3) Mask value range only includes +ve values, this can again be\n+        \/\/ used to ascertain known Zero bits of resultant value.\n@@ -280,0 +281,2 @@\n+        \/\/ Here, result of clz is w.r.t to long argument, hence for integer argument\n+        \/\/ we explicitly subtract 32 from the result.\n@@ -282,1 +285,1 @@\n-        mask_max_bw = max_bw - clz;\n+        max_mask_bit_width = mask_bit_width - clz;\n@@ -285,8 +288,9 @@\n-      lo = mask_max_bw == max_bw ? lo : 0L;\n-      \/\/ Compress operation is inherently an unsigned operation and\n-      \/\/ result value range is primarily dependent on true count\n-      \/\/ of participating mask value. Thus bit compression can never\n-      \/\/ result into a value greater than original value.\n-      \/\/ For constant input we pessimistically set the upper bound\n-      \/\/ of result to max_int to prevent incorrect constant value in case\n-      \/\/ input equals lower bound of mask value range.\n+      \/\/ If number of bits required to accommodated mask value range is less than the\n+      \/\/ full bit width of integral type, then MSB bit is guaranteed to be zero, thus\n+      \/\/ compression result will never be a -ve value and we can safely set the\n+      \/\/ lower bound of the result value range to zero.\n+      lo = max_mask_bit_width == mask_bit_width ? lo : 0L;\n+\n+      \/\/ For upper bound estimation of result value range for a constant input we\n+      \/\/ pessimistically pick max_int value to prevent incorrect constant folding\n+      \/\/ in case input equals above estimated lower bound.\n@@ -294,1 +298,1 @@\n-      hi = mask_max_bw < max_bw ? (1L << mask_max_bw) - 1 : hi;\n+      hi = max_mask_bit_width < mask_bit_width ? (1L << max_mask_bit_width) - 1 : hi;\n@@ -342,0 +346,5 @@\n+  \/\/ Result is zero if src is zero irrespective of mask value.\n+  if (src_type == TypeInteger::zero(bt)) {\n+     return TypeInteger::zero(bt);\n+  }\n+\n@@ -378,0 +387,5 @@\n+  \/\/ Result is zero if src is zero irrespective of mask value.\n+  if (src_type == TypeInteger::zero(bt)) {\n+     return TypeInteger::zero(bt);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":36,"deletions":22,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @key stress randomness\n- * @requires vm.compiler2.enabled & os.simpleArch == \"x64\"\n@@ -93,1 +91,1 @@\n-        Asserts.assertGT(res, 0);\n+        Asserts.assertLTE(0, res);\n@@ -99,3 +97,3 @@\n-        long filter_bits = value & 0xF;\n-        long compress_bits = Long.compress(15, filter_bits);\n-        if (compress_bits > 15) {\n+        long filter_bits = value & 0xFL;\n+        long compress_bits = Long.compress(15L, filter_bits);\n+        if (compress_bits > 15L) {\n@@ -113,1 +111,145 @@\n-        Asserts.assertGT(res, 0L);\n+        Asserts.assertLTE(0L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test5(long value) {\n+        \/\/ Since value range includes -1 hence with mask\n+        \/\/ and value as -1 all the result bits will be set.\n+        long mask = Long.min(10000L, Long.max(-10000L, value));\n+        return Long.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void run5(RunInfo info) {\n+        long res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test5((long)i);\n+        }\n+        Asserts.assertEQ(-1L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test6(long value) {\n+        \/\/ For mask within a strictly -ve value range less than -1,\n+        \/\/ result of compression will always be a +ve value.\n+        long mask = Long.min(-2L, Long.max(-10000L, value));\n+        return Long.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test6\")\n+    public void run6(RunInfo info) {\n+        long res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test6((long)i);\n+        }\n+        Asserts.assertLTE(0L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test7(long value) {\n+        \/\/ For mask within a strictly +ve value range,\n+        \/\/ result of compression will always be a +ve value with\n+        \/\/ upper bound capped at max mask value.\n+        long mask = Long.min(10000L, Long.max(0L, value));\n+        return Long.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test7\")\n+    public void run7(RunInfo info) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = -10000; i < 100000; i++) {\n+            res = Long.max(test7((long)i), res);\n+        }\n+        Asserts.assertGTE(10000L, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test8(int value) {\n+        \/\/ Since value range includes -1 hence with mask\n+        \/\/ and value as -1 all the result bits will be set.\n+        int mask = Integer.min(10000, Integer.max(-10000, value));\n+        return Integer.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void run8(RunInfo info) {\n+        int res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test8(i);\n+        }\n+        Asserts.assertEQ(-1, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test9(int value) {\n+        \/\/ For mask within a strictly -ve value range less than -1,\n+        \/\/ result of compression will always be a +ve value.\n+        int mask = Integer.min(-2, Integer.max(-10000, value));\n+        return Integer.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void run9(RunInfo info) {\n+        int res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test9(i);\n+        }\n+        Asserts.assertLTE(0, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test10(int value) {\n+        \/\/ For mask within a strictly +ve value range,\n+        \/\/ result of compression will always be a +ve value with\n+        \/\/ upper bound capped at max mask value.\n+        int mask = Integer.min(10000, Integer.max(0, value));\n+        return Integer.compress(value, mask);\n+    }\n+\n+    @Run(test = \"test10\")\n+    public void run10(RunInfo info) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = -10000; i < 100000; i++) {\n+            res = Integer.max(test10(i), res);\n+        }\n+        Asserts.assertGTE(10000, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public int test11(int value) {\n+        \/\/ For constant zero input, compress is folded to zero\n+        int mask = Integer.min(10000, Integer.max(0, value));\n+        return Integer.compress(0, mask);\n+    }\n+\n+    @Run(test = \"test11\")\n+    public void run11(RunInfo info) {\n+        int res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test11(i);\n+        }\n+        Asserts.assertEQ(0, res);\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" 0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public long test12(long value) {\n+        \/\/ For constant zero input, compress is folded to zero\n+        long mask = Long.min(10000L, Long.max(0L, value));\n+        return Long.compress(0L, mask);\n+    }\n+\n+    @Run(test = \"test12\")\n+    public void run12(RunInfo info) {\n+        long res = 0;\n+        for (int i = -10000; i < 100000; i++) {\n+            res |= test12(i);\n+        }\n+        Asserts.assertEQ(0L, res);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestBitCompressValueTransform.java","additions":149,"deletions":7,"binary":false,"changes":156,"status":"modified"}]}