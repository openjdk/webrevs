{"files":[{"patch":"@@ -255,13 +255,0 @@\n-    \/\/ Case A.1 bit compression:-\n-    \/\/ Result.Hi = popcount(1 << mask_bits - 1)\n-    \/\/ Result.Lo = min iff mask == -1 assuming all source bits apart from most\n-    \/\/                                significant bit were set to 0\n-    \/\/       else\n-    \/\/ Result.Lo = 0 iff atleast one mask bit is zero, corresponding source\n-    \/\/ bit will be masked, hence result of bit compression will be a +ve\n-    \/\/ value.\n-    \/\/ e.g.\n-    \/\/  src = 0xXXXXXXXX (non-constant source)\n-    \/\/  mask = 0xEFFFFFFF (constant mask)\n-    \/\/  result.hi = 0x7FFFFFFF\n-    \/\/  result.lo = 0\n@@ -270,0 +257,17 @@\n+      \/\/ Case A.1 bit compression:-\n+      \/\/ For an outlier mask value of -1 upper bound of the result equals\n+      \/\/ maximum integral value, for any other mask value its computed using\n+      \/\/ following formula\n+      \/\/       Result.Hi = 1 << popcount(mask_bits) - 1\n+      \/\/\n+      \/\/ For mask values other than -1, lower bound of the result is estimated\n+      \/\/ as zero, by assuming at least one mask bit is zero and corresponding source\n+      \/\/ bit will be masked, hence result of bit compression will always be\n+      \/\/ non-negative value. For outlier mask value of -1, assume all source bits\n+      \/\/ apart from most significant bit were set to 0, thereby resulting in\n+      \/\/ a minimum integral value.\n+      \/\/ e.g.\n+      \/\/  src = 0xXXXXXXXX (non-constant source)\n+      \/\/  mask = 0xEFFFFFFF (constant mask)\n+      \/\/  result.hi = 0x7FFFFFFF\n+      \/\/  result.lo = 0\n@@ -271,2 +275,8 @@\n-      hi = maskcon == -1L ? hi : (1UL << bitcount) - 1;\n-      lo = maskcon == -1L ? lo : 0L;\n+      if (maskcon != -1L) {\n+        hi = (1UL << bitcount) - 1;\n+        lo = 0L;\n+      } else {\n+        \/\/ preserve originally assigned hi (MAX_INT\/LONG) and lo (MIN_INT\/LONG) values.\n+        assert(hi == (T_INT ? max_jint : max_jlong), \"\");\n+        assert(lo == (T_INT ? min_jint : min_jlong), \"\");\n+      }\n@@ -274,25 +284,1 @@\n-    \/\/ Case A.2 bit expansion:-\n-    \/\/   Case A.2.1 constant mask >= 0\n-    \/\/     Result.Hi = mask, optimistically assuming all source bits\n-    \/\/     read starting from least significant bit positions are 1.\n-    \/\/     Result.Lo = 0, because at least one bit in mask is zero.\n-    \/\/   e.g.\n-    \/\/    src = 0xXXXXXXXX (non-constant source)\n-    \/\/    mask = 0x7FFFFFFF (constant mask >= 0)\n-    \/\/    result.hi = 0x7FFFFFFF\n-    \/\/    result.lo = 0\n-\n-    \/\/   Case A.2.2) mask < 0\n-    \/\/     For constant mask strictly less than zero, the maximum result value will be\n-    \/\/     the same as the mask value with its sign bit flipped, assuming all source bits but the last\n-    \/\/     are set to 1.\n-    \/\/\n-    \/\/     To compute minimum result value we assume all but last read source bit as zero,\n-    \/\/     this is because sign bit of result will always be set to 1 while other bit\n-    \/\/     corresponding to set mask bit should be zero.\n-    \/\/   e.g.\n-    \/\/    src = 0xXXXXXXXX (non-constant source)\n-    \/\/    mask = 0xEFFFFFFF (constant mask)\n-    \/\/    result.hi = 0xEFFFFFFF ^ 0x80000000 = 0x6FFFFFFF\n-    \/\/    result.lo = 0x80000000\n-    \/\/\n+      \/\/ Case A.2 bit expansion:-\n@@ -300,2 +286,31 @@\n-      hi = maskcon >= 0L ? maskcon : maskcon ^ lo;\n-      lo = maskcon >= 0L ? 0L : lo;\n+      if (maskcon >= 0L) {\n+        \/\/   Case A.2.1 constant mask >= 0\n+        \/\/     Result.Hi = mask, optimistically assuming all source bits\n+        \/\/     read starting from least significant bit positions are 1.\n+        \/\/     Result.Lo = 0, because at least one bit in mask is zero.\n+        \/\/   e.g.\n+        \/\/    src = 0xXXXXXXXX (non-constant source)\n+        \/\/    mask = 0x7FFFFFFF (constant mask >= 0)\n+        \/\/    result.hi = 0x7FFFFFFF\n+        \/\/    result.lo = 0\n+        hi = maskcon;\n+        lo = 0L;\n+      } else {\n+        \/\/   Case A.2.2) mask < 0\n+        \/\/     For constant mask strictly less than zero, the maximum result value will be\n+        \/\/     the same as the mask value with its sign bit flipped, assuming all source bits\n+        \/\/     except the MSB bit are set(one).\n+        \/\/\n+        \/\/     To compute minimum result value we assume all but last read source bit as zero,\n+        \/\/     this is because sign bit of result will always be set to 1 while other bit\n+        \/\/     corresponding to set mask bit should be zero.\n+        \/\/   e.g.\n+        \/\/    src = 0xXXXXXXXX (non-constant source)\n+        \/\/    mask = 0xEFFFFFFF (constant mask)\n+        \/\/    result.hi = 0xEFFFFFFF ^ 0x80000000 = 0x6FFFFFFF\n+        \/\/    result.lo = 0x80000000\n+        \/\/\n+        hi = maskcon ^ lo;\n+        \/\/ lo still retains MIN_INT\/LONG.\n+        assert(lo == (T_INT ? min_jint : min_jlong), \"\");\n+      }\n@@ -347,1 +362,8 @@\n-        \/\/ value. <the actual proof>\n+        \/\/ value. There are three possible cases\n+        \/\/   a. All the mask bits corresponding to set source bits are unset(zero).\n+        \/\/   b. All the mask bits corresponding to set source bits are set(one)\n+        \/\/   c. Some mask bits corresponding to set source bits are set(one) while others are unset(zero)\n+        \/\/\n+        \/\/ Case a. results into an allzero result, while Case b. gives us the upper bound which is equals source\n+        \/\/ value, while for Case c. the result will lie within [0, src]\n+        \/\/\n@@ -354,1 +376,1 @@\n-        \/\/ which can be set to 1 is less than the maximum number of bits of integral type.\n+        \/\/ which can be set(one) is less than the maximum number of bits of integral type.\n@@ -360,0 +382,1 @@\n+      jlong min_mask = mask_type->lo_as_long();\n@@ -362,2 +385,12 @@\n-      lo = mask_type->lo_as_long() >= 0L ? 0L : lo;\n-      hi = mask_type->lo_as_long() >= 0L ? max_mask : hi;\n+      if (min_mask >= 0L) {\n+        \/\/ Lemma 2: Based on the integral type invariant ie. TypeInteger.lo <= TypeInteger.hi,\n+        \/\/ if the lower bound of non-constant mask is a non-negative value then result can never\n+        \/\/ be greater than the mask.\n+        \/\/ Proof: Since lower bound of the mask is a non-negative value, hence most significant\n+        \/\/ bit of its entire value must be unset(zero). Similar to the proof of Lemma1, upper and\n+        \/\/ lower bounds of result will always match the bounds of the mask value range.\n+        hi = max_mask;\n+        lo = min_mask;\n+      } else {\n+        \/\/ preserve the lo and hi bounds estimated till now.\n+      }\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":79,"deletions":46,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        for (int i = 0; i < 100000; i++) {\n+        for (int i = 0; i < 10000; i++) {\n@@ -96,1 +96,1 @@\n-        for (int i = 0; i < 100000; i++) {\n+        for (int i = 0; i < 10000; i++) {\n@@ -116,1 +116,1 @@\n-        for (int i = 1; i < 100000; i++) {\n+        for (int i = 1; i < 10000; i++) {\n@@ -136,1 +136,1 @@\n-        for (long i = 1; i < 100000; i++) {\n+        for (long i = 1; i < 10000; i++) {\n@@ -154,1 +154,1 @@\n-        for (int i = -10000; i < 100000; i++) {\n+        for (int i = -10000; i < 10000; i++) {\n@@ -172,1 +172,1 @@\n-        for (int i = -10000; i < 100000; i++) {\n+        for (int i = -10000; i < 10000; i++) {\n@@ -191,1 +191,1 @@\n-        for (int i = -10000; i < 100000; i++) {\n+        for (int i = -10000; i < 10000; i++) {\n@@ -209,1 +209,1 @@\n-        for (int i = -10000; i < 100000; i++) {\n+        for (int i = -10000; i < 10000; i++) {\n@@ -227,1 +227,1 @@\n-        for (int i = -10000; i < 100000; i++) {\n+        for (int i = -10000; i < 10000; i++) {\n@@ -246,1 +246,1 @@\n-        for (int i = -10000; i < 100000; i++) {\n+        for (int i = -10000; i < 10000; i++) {\n@@ -263,1 +263,1 @@\n-        for (int i = -10000; i < 100000; i++) {\n+        for (int i = -10000; i < 10000; i++) {\n@@ -280,1 +280,1 @@\n-        for (int i = -10000; i < 100000; i++) {\n+        for (int i = -10000; i < 10000; i++) {\n@@ -297,1 +297,1 @@\n-        for (int i = -10000; i < 100000; i++) {\n+        for (int i = -10000; i < 10000; i++) {\n@@ -314,1 +314,1 @@\n-        for (int i = -10000; i < 100000; i++) {\n+        for (int i = -10000; i < 10000; i++) {\n@@ -331,1 +331,1 @@\n-        for (int i = 0; i < 100000; i++) {\n+        for (int i = 0; i < 10000; i++) {\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestBitCompressValueTransform.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"}]}