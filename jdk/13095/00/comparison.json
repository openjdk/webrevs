{"files":[{"patch":"@@ -55,0 +55,4 @@\n+\n+    static int PREMUL_SH(int x) {\n+        return x << 23;\n+    }\n@@ -57,8 +61,10 @@\n-    private static final int PT_GRAY_8  = CHANNELS_SH(1) | BYTES_SH(1);\n-    private static final int PT_GRAY_16 = CHANNELS_SH(1) | BYTES_SH(2);\n-    private static final int PT_RGB_8   = CHANNELS_SH(3) | BYTES_SH(1);\n-    private static final int PT_RGBA_8  = PT_RGB_8  | EXTRA_SH(1);\n-    private static final int PT_ARGB_8  = PT_RGBA_8 | SWAPFIRST;\n-    private static final int PT_BGR_8   = PT_RGB_8  | DOSWAP;\n-    private static final int PT_ABGR_8  = PT_BGR_8  | EXTRA_SH(1);\n-\/\/  private static final int PT_BGRA_8  = PT_ABGR_8 | SWAPFIRST;\n+    private static final int PT_GRAY_8        = CHANNELS_SH(1) | BYTES_SH(1);\n+    private static final int PT_GRAY_16       = CHANNELS_SH(1) | BYTES_SH(2);\n+    private static final int PT_RGB_8         = CHANNELS_SH(3) | BYTES_SH(1);\n+    private static final int PT_RGBA_8        = PT_RGB_8  | EXTRA_SH(1);\n+    private static final int PT_ARGB_8        = PT_RGBA_8 | SWAPFIRST;\n+    private static final int PT_ARGB_8_PREMUL = PT_ARGB_8 | PREMUL_SH(1);\n+    private static final int PT_BGR_8         = PT_RGB_8  | DOSWAP;\n+    private static final int PT_ABGR_8        = PT_BGR_8  | EXTRA_SH(1);\n+    private static final int PT_ABGR_8_PREMUL = PT_ABGR_8 | PREMUL_SH(1);\n+\/\/  private static final int PT_BGRA_8        = PT_ABGR_8 | SWAPFIRST;\n@@ -151,0 +157,3 @@\n+            case BufferedImage.TYPE_INT_ARGB_PRE:\n+                l.pixelType = PT_ARGB_8_PREMUL ^ SWAP_ENDIAN;\n+                break;\n@@ -163,0 +172,3 @@\n+            case BufferedImage.TYPE_4BYTE_ABGR_PRE:\n+                l.pixelType = PT_ABGR_8_PREMUL;\n+                break;\n@@ -175,4 +187,1 @@\n-                \/\/ lcms as of now does not support pre-alpha\n-                if (!cm.isAlphaPremultiplied()\n-                        && cm instanceof ComponentColorModel ccm)\n-                {\n+                if (cm instanceof ComponentColorModel ccm) {\n@@ -186,1 +195,1 @@\n-                    return createImageLayout(image.getRaster(), cm.hasAlpha());\n+                    return createImageLayout(image.getRaster(), cm);\n@@ -197,0 +206,1 @@\n+            case BufferedImage.TYPE_INT_ARGB_PRE:\n@@ -212,0 +222,1 @@\n+            case BufferedImage.TYPE_4BYTE_ABGR_PRE:\n@@ -323,1 +334,1 @@\n-    static LCMSImageLayout createImageLayout(Raster r, boolean hasAlpha) {\n+    static LCMSImageLayout createImageLayout(Raster r, ColorModel cm) {\n@@ -332,0 +343,1 @@\n+            boolean hasAlpha = cm != null && cm.hasAlpha();\n@@ -334,0 +346,3 @@\n+            if (hasAlpha && cm.isAlphaPremultiplied()) {\n+                l.pixelType |= PREMUL_SH(1);\n+            }\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMSImageLayout.java","additions":29,"deletions":14,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-     * Returns {@code true} if lcms may supports this format directly.\n+     * Returns {@code true} if lcms may support this format directly.\n@@ -133,7 +133,4 @@\n-        if (!dst.getColorModel().hasAlpha()) {\n-            return true;\n-        }\n-        \/\/ lcms as of now does not support pre-alpha\n-        if (src.isAlphaPremultiplied() || dst.isAlphaPremultiplied()) {\n-            return false;\n-        }\n+        boolean dstAlpha = dst.getColorModel().hasAlpha();\n+        boolean srcAlpha = src.getColorModel().hasAlpha();\n+        boolean srcPre = srcAlpha && src.getColorModel().isAlphaPremultiplied();\n+        \/\/ lcms does not convert pre-alpha for transparent src if dst is opaque\n@@ -141,2 +138,1 @@\n-        \/\/ is it feature or bug?\n-        return dst.getColorModel().hasAlpha() == src.getColorModel().hasAlpha();\n+        return !dstAlpha && !srcPre || dstAlpha == srcAlpha;\n@@ -427,1 +423,1 @@\n-        dstIL = LCMSImageLayout.createImageLayout(dst, false);\n+        dstIL = LCMSImageLayout.createImageLayout(dst, null);\n@@ -429,1 +425,1 @@\n-            srcIL = LCMSImageLayout.createImageLayout(src, false);\n+            srcIL = LCMSImageLayout.createImageLayout(src, null);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMSTransform.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.awt.Transparency;\n@@ -31,0 +32,6 @@\n+import java.awt.image.ColorModel;\n+import java.awt.image.ComponentColorModel;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.DirectColorModel;\n+import java.awt.image.Raster;\n+import java.awt.image.WritableRaster;\n@@ -48,1 +55,1 @@\n- * @bug 8012229 8300725\n+ * @bug 8012229 8300725 8279216\n@@ -56,0 +63,7 @@\n+    private static final int TYPE_CUSTOM_4BYTE_ABGR_PRE = -1;\n+    private static final int TYPE_CUSTOM_4BYTE_ARGB_PRE = -2;\n+    private static final int TYPE_CUSTOM_4BYTE_RGBA_PRE = -3;\n+    private static final int TYPE_CUSTOM_4BYTE_GABR_PRE = -4;\n+    private static final int TYPE_CUSTOM_INT_ARGB_PRE = -5;\n+    private static final int TYPE_CUSTOM_INT_GABR_PRE = -6;\n+\n@@ -61,0 +75,1 @@\n+        differentToTransparentDst(TYPE_4BYTE_ABGR_PRE);\n@@ -100,1 +115,10 @@\n-        \/\/ It is unclear how to hangle pre colors in the opaque DST\n+        \/\/ compare the \"fast\" and \"slow\" paths\n+        opaqueDst(TYPE_4BYTE_ABGR_PRE, TYPE_CUSTOM_4BYTE_ABGR_PRE);\n+        opaqueDst(TYPE_4BYTE_ABGR_PRE, TYPE_CUSTOM_4BYTE_ARGB_PRE);\n+        opaqueDst(TYPE_4BYTE_ABGR_PRE, TYPE_CUSTOM_4BYTE_RGBA_PRE);\n+        opaqueDst(TYPE_4BYTE_ABGR_PRE, TYPE_CUSTOM_4BYTE_GABR_PRE);\n+\n+        opaqueDst(TYPE_INT_ARGB_PRE, TYPE_CUSTOM_INT_ARGB_PRE);\n+        opaqueDst(TYPE_INT_ARGB_PRE, TYPE_CUSTOM_INT_GABR_PRE);\n+\n+        \/\/ It is unclear how to handle pre colors in the opaque DST\n@@ -199,1 +223,9 @@\n-        BufferedImage img = new BufferedImage(WIDTH, HEIGHT, type);\n+        BufferedImage img = switch (type) {\n+            case TYPE_CUSTOM_4BYTE_ABGR_PRE -> TYPE_4BYTE_ABGR_PRE();\n+            case TYPE_CUSTOM_4BYTE_ARGB_PRE -> TYPE_4BYTE_ARGB_PRE();\n+            case TYPE_CUSTOM_4BYTE_RGBA_PRE -> TYPE_4BYTE_RGBA_PRE();\n+            case TYPE_CUSTOM_4BYTE_GABR_PRE -> TYPE_4BYTE_GABR_PRE();\n+            case TYPE_CUSTOM_INT_ARGB_PRE -> TYPE_INT_ARGB_PRE();\n+            case TYPE_CUSTOM_INT_GABR_PRE -> TYPE_INT_GABR_PRE();\n+            default -> new BufferedImage(WIDTH, HEIGHT, type);\n+        };\n@@ -223,0 +255,88 @@\n+\n+    private static BufferedImage TYPE_4BYTE_RGBA_PRE() {\n+        ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+        int[] nBits = {8, 8, 8, 8};\n+        int[] bOffs = {0, 1, 2, 3};\n+        ColorModel colorModel = new ComponentColorModel(cs, nBits, true, true,\n+                                                        Transparency.TRANSLUCENT,\n+                                                        DataBuffer.TYPE_BYTE);\n+        WritableRaster raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,\n+                                                               WIDTH, HEIGHT,\n+                                                               WIDTH * 4, 4,\n+                                                               bOffs, null);\n+        return new BufferedImage(colorModel, raster, true, null);\n+    }\n+\n+    private static BufferedImage TYPE_4BYTE_ABGR_PRE() {\n+        ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+        int[] nBits = {8, 8, 8, 8};\n+        int[] bOffs = {3, 2, 1, 0};\n+        ColorModel colorModel = new ComponentColorModel(cs, nBits, true, true,\n+                                                        Transparency.TRANSLUCENT,\n+                                                        DataBuffer.TYPE_BYTE);\n+        WritableRaster raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,\n+                                                               WIDTH, HEIGHT,\n+                                                               WIDTH * 4, 4,\n+                                                               bOffs, null);\n+        return new BufferedImage(colorModel, raster, true, null);\n+    }\n+\n+    private static BufferedImage TYPE_4BYTE_ARGB_PRE() {\n+        ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+        int[] nBits = {8, 8, 8, 8};\n+        int[] bOffs = {1, 2, 3, 0};\n+        ColorModel colorModel = new ComponentColorModel(cs, nBits, true, true,\n+                                                        Transparency.TRANSLUCENT,\n+                                                        DataBuffer.TYPE_BYTE);\n+        WritableRaster raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,\n+                                                               WIDTH, HEIGHT,\n+                                                               WIDTH * 4, 4,\n+                                                               bOffs, null);\n+        return new BufferedImage(colorModel, raster, true, null);\n+    }\n+\n+    private static BufferedImage TYPE_4BYTE_GABR_PRE() {\n+        ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+        int[] nBits = {8, 8, 8, 8};\n+        int[] bOffs = {3, 0, 2, 1};\n+        ColorModel colorModel = new ComponentColorModel(cs, nBits, true, false,\n+                                                        Transparency.TRANSLUCENT,\n+                                                        DataBuffer.TYPE_BYTE);\n+        WritableRaster raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,\n+                                                               WIDTH, HEIGHT,\n+                                                               WIDTH * 4, 4,\n+                                                               bOffs, null);\n+        return new BufferedImage(colorModel, raster, true, null);\n+    }\n+\n+    private static BufferedImage TYPE_INT_ARGB_PRE() {\n+        ColorModel colorModel = new DirectColorModel(\n+                ColorSpace.getInstance(ColorSpace.CS_sRGB),\n+                32,\n+                0x00ff0000, \/\/ Red\n+                0x0000ff00, \/\/ Green\n+                0x000000ff, \/\/ Blue\n+                0xff000000, \/\/ Alpha\n+                true,       \/\/ Alpha Premultiplied\n+                DataBuffer.TYPE_INT\n+        );\n+        WritableRaster raster = colorModel.createCompatibleWritableRaster(WIDTH,\n+                                                                          HEIGHT);\n+        return new BufferedImage(colorModel, raster, true, null);\n+    }\n+\n+    private static BufferedImage TYPE_INT_GABR_PRE() {\n+        ColorModel colorModel = new DirectColorModel(\n+                ColorSpace.getInstance(ColorSpace.CS_sRGB),\n+                32,\n+                0x000000ff, \/\/ Red\n+                0xff000000, \/\/ Green\n+                0x0000ff00, \/\/ Blue\n+                0x00ff0000, \/\/ Alpha\n+                true,       \/\/ Alpha Premultiplied\n+                DataBuffer.TYPE_INT\n+        );\n+        WritableRaster raster = colorModel.createCompatibleWritableRaster(WIDTH,\n+                                                                          HEIGHT);\n+        return new BufferedImage(colorModel, raster, true, null);\n+    }\n","filename":"test\/jdk\/sun\/java2d\/cmm\/ColorConvertOp\/ColCvtAlphaDifferentSrcDst.java","additions":123,"deletions":3,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -0,0 +1,264 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.Transparency;\n+import java.awt.color.ColorSpace;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorConvertOp;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ComponentColorModel;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.DirectColorModel;\n+import java.awt.image.Raster;\n+import java.awt.image.WritableRaster;\n+import java.util.Arrays;\n+\n+import static java.awt.image.BufferedImage.TYPE_4BYTE_ABGR_PRE;\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB_PRE;\n+\n+\/**\n+ * @test\n+ * @bug 8279216\n+ * @summary Verifies implementation of premultiplied alpha\n+ *\/\n+public final class PremultipliedAlpha {\n+\n+    private static final int SIZE = 256;\n+\n+    private static final int COLOR_TOLERANCE = 2;\n+\n+    private enum Type {\n+        TYPE_ARGB_PRE,\n+        TYPE_4BYTE_ABGR_PRE,\n+        TYPE_CUSTOM_ARGB_PRE,\n+        TYPE_CUSTOM_GABR_PRE,\n+        TYPE_CUSTOM_4BYTE_ABGR_PRE,\n+        TYPE_CUSTOM_4BYTE_ARGB_PRE,\n+        TYPE_CUSTOM_4BYTE_RGBA_PRE,\n+        TYPE_CUSTOM_4BYTE_GABR_PRE,\n+        TYPE_CUSTOM_4USHORT_8bit_ARGB_PRE,\n+        TYPE_CUSTOM_4INT_8bit_ARGB_PRE,\n+    }\n+\n+    private static final ColorSpace[] CSs = {\n+            ColorSpace.getInstance(ColorSpace.CS_CIEXYZ),\n+            ColorSpace.getInstance(ColorSpace.CS_GRAY),\n+            ColorSpace.getInstance(ColorSpace.CS_LINEAR_RGB),\n+            ColorSpace.getInstance(ColorSpace.CS_PYCC),\n+            ColorSpace.getInstance(ColorSpace.CS_sRGB)\n+    };\n+\n+    public static void main(String[] args) {\n+        for (ColorSpace cs : CSs) {\n+            for (Type dst : Type.values()) {\n+                BufferedImage gold = null;\n+                for (Type src : Type.values()) {\n+                    BufferedImage from = createSrc(src);\n+                    BufferedImage to = createDst(dst);\n+                    ColorConvertOp op = new ColorConvertOp(cs, null);\n+                    op.filter(from, to);\n+                    if (gold == null) {\n+                        gold = to;\n+                    } else {\n+                        validate(gold, to);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void validate(BufferedImage img1, BufferedImage img2) {\n+        for (int a = 0; a < SIZE; a++) {\n+            for (int c = 0; c < SIZE; c++) {\n+                int[] pixel1 = img1.getRaster().getPixel(c, a, (int[]) null);\n+                int[] pixel2 = img2.getRaster().getPixel(c, a, (int[]) null);\n+                if (pixel1.length != pixel2.length) {\n+                    throw new RuntimeException();\n+                }\n+                for (int i = 0 ; i < pixel1.length; ++i) {\n+                    if (Math.abs(pixel1[i] - pixel2[i]) >= COLOR_TOLERANCE) {\n+                        System.out.println(\"c = \" + c);\n+                        System.out.println(\"a = \" + a);\n+                        System.err.println(\"rgb1 = \" + Arrays.toString(pixel1));\n+                        System.err.println(\"rgb2 = \" + Arrays.toString(pixel2));\n+                        throw new RuntimeException();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static BufferedImage createDst(Type type) {\n+        BufferedImage img = createSrc(type);\n+        Graphics2D g = img.createGraphics();\n+        g.setComposite(AlphaComposite.Clear);\n+        g.fillRect(0, 0, SIZE, SIZE);\n+        g.dispose();\n+        return img;\n+    }\n+\n+    private static BufferedImage createSrc(Type type) {\n+        BufferedImage bi = switch (type) {\n+            case TYPE_ARGB_PRE -> new BufferedImage(SIZE, SIZE, TYPE_INT_ARGB_PRE);\n+            case TYPE_CUSTOM_ARGB_PRE -> TYPE_ARGB_PRE();\n+            case TYPE_CUSTOM_GABR_PRE -> TYPE_GABR_PRE();\n+            case TYPE_4BYTE_ABGR_PRE -> new BufferedImage(SIZE, SIZE, TYPE_4BYTE_ABGR_PRE);\n+            case TYPE_CUSTOM_4BYTE_ARGB_PRE -> TYPE_4BYTE_ARGB_PRE();\n+            case TYPE_CUSTOM_4BYTE_ABGR_PRE -> TYPE_4BYTE_ABGR_PRE();\n+            case TYPE_CUSTOM_4BYTE_RGBA_PRE -> TYPE_4BYTE_RGBA_PRE();\n+            case TYPE_CUSTOM_4BYTE_GABR_PRE -> TYPE_4BYTE_GABR_PRE();\n+            case TYPE_CUSTOM_4USHORT_8bit_ARGB_PRE -> TYPE_4USHORT_ARGB_8bit_PRE();\n+            case TYPE_CUSTOM_4INT_8bit_ARGB_PRE -> TYPE_4INT_ARGB_8bit_PRE();\n+        };\n+        fill(bi);\n+        return bi;\n+    }\n+\n+    private static BufferedImage TYPE_ARGB_PRE() {\n+        ColorModel colorModel = new DirectColorModel(\n+                ColorSpace.getInstance(ColorSpace.CS_sRGB),\n+                32,\n+                0x00ff0000, \/\/ Red\n+                0x0000ff00, \/\/ Green\n+                0x000000ff, \/\/ Blue\n+                0xff000000, \/\/ Alpha\n+                true,       \/\/ Alpha Premultiplied\n+                DataBuffer.TYPE_INT\n+        );\n+        WritableRaster raster = colorModel.createCompatibleWritableRaster(SIZE,\n+                                                                          SIZE);\n+        return new BufferedImage(colorModel, raster, true, null);\n+    }\n+\n+    private static BufferedImage TYPE_GABR_PRE() {\n+        ColorModel colorModel = new DirectColorModel(\n+                ColorSpace.getInstance(ColorSpace.CS_sRGB),\n+                32,\n+                0x000000ff, \/\/ Red\n+                0xff000000, \/\/ Green\n+                0x0000ff00, \/\/ Blue\n+                0x00ff0000, \/\/ Alpha\n+                true,       \/\/ Alpha Premultiplied\n+                DataBuffer.TYPE_INT\n+        );\n+        WritableRaster raster = colorModel.createCompatibleWritableRaster(SIZE,\n+                                                                          SIZE);\n+        return new BufferedImage(colorModel, raster, true, null);\n+    }\n+\n+    private static BufferedImage TYPE_4BYTE_RGBA_PRE() {\n+        ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+        int[] nBits = {8, 8, 8, 8};\n+        int[] bOffs = {0, 1, 2, 3};\n+        ColorModel colorModel = new ComponentColorModel(cs, nBits, true, true,\n+                                                        Transparency.TRANSLUCENT,\n+                                                        DataBuffer.TYPE_BYTE);\n+        WritableRaster raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,\n+                                                               SIZE, SIZE,\n+                                                               SIZE * 4, 4,\n+                                                               bOffs, null);\n+        return new BufferedImage(colorModel, raster, true, null);\n+    }\n+\n+    private static BufferedImage TYPE_4BYTE_ABGR_PRE() {\n+        ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+        int[] nBits = {8, 8, 8, 8};\n+        int[] bOffs = {3, 2, 1, 0};\n+        ColorModel colorModel = new ComponentColorModel(cs, nBits, true, true,\n+                                                        Transparency.TRANSLUCENT,\n+                                                        DataBuffer.TYPE_BYTE);\n+        WritableRaster raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,\n+                                                               SIZE, SIZE,\n+                                                               SIZE * 4, 4,\n+                                                               bOffs, null);\n+        return new BufferedImage(colorModel, raster, true, null);\n+    }\n+\n+    private static BufferedImage TYPE_4BYTE_ARGB_PRE() {\n+        ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+        int[] nBits = {8, 8, 8, 8};\n+        int[] bOffs = {1, 2, 3, 0};\n+        ColorModel colorModel = new ComponentColorModel(cs, nBits, true, true,\n+                                                        Transparency.TRANSLUCENT,\n+                                                        DataBuffer.TYPE_BYTE);\n+        WritableRaster raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,\n+                                                               SIZE, SIZE,\n+                                                               SIZE * 4, 4,\n+                                                               bOffs, null);\n+        return new BufferedImage(colorModel, raster, true, null);\n+    }\n+\n+    private static BufferedImage TYPE_4BYTE_GABR_PRE() {\n+        ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+        int[] nBits = {8, 8, 8, 8};\n+        int[] bOffs = {3, 0, 2, 1};\n+        ColorModel colorModel = new ComponentColorModel(cs, nBits, true, false,\n+                                                        Transparency.TRANSLUCENT,\n+                                                        DataBuffer.TYPE_BYTE);\n+        WritableRaster raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,\n+                                                               SIZE, SIZE,\n+                                                               SIZE * 4, 4,\n+                                                               bOffs, null);\n+        return new BufferedImage(colorModel, raster, true, null);\n+    }\n+\n+    private static BufferedImage TYPE_4INT_ARGB_8bit_PRE() {\n+        ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+        int[] nBits = {8, 8, 8, 8};\n+        ColorModel colorModel = new ComponentColorModel(cs, nBits, true, true,\n+                                                        Transparency.TRANSLUCENT,\n+                                                        DataBuffer.TYPE_INT);\n+        WritableRaster raster = colorModel.createCompatibleWritableRaster(SIZE,\n+                                                                          SIZE);\n+        return new BufferedImage(colorModel, raster, true, null);\n+    }\n+\n+    private static BufferedImage TYPE_4USHORT_ARGB_8bit_PRE() {\n+        ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+        int[] nBits = {8, 8, 8, 8};\n+        ColorModel colorModel = new ComponentColorModel(cs, nBits, true, true,\n+                                                        Transparency.TRANSLUCENT,\n+                                                        DataBuffer.TYPE_USHORT);\n+        WritableRaster raster = colorModel.createCompatibleWritableRaster(SIZE,\n+                                                                          SIZE);\n+        return new BufferedImage(colorModel, raster, true, null);\n+    }\n+\n+    private static void fill(BufferedImage image) {\n+\/\/        Graphics2D g = image.createGraphics();\n+\/\/        g.setComposite(AlphaComposite.Src);\n+        for (int a = 0; a < SIZE; ++a) {\n+            for (int c = 0; c < SIZE; ++c) {\n+                Color c1 = new Color(a, c, c, a);\n+\/\/                g.setColor(c1);\n+\/\/TODO CANNOT USE fillrect, does not work for custom types!\n+\/\/                g.fillRect(c, a, 1, 1);\n+                image.setRGB(c,a , c1.getRGB());\n+            }\n+        }\n+\/\/        g.dispose();\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/cmm\/ColorConvertOp\/PremultipliedAlpha.java","additions":264,"deletions":0,"binary":false,"changes":264,"status":"added"}]}