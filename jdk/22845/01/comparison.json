{"files":[{"patch":"@@ -833,0 +833,16 @@\n+  if test \"x$FLAGS_CPU\" = xriscv64; then\n+    AC_MSG_CHECKING([if RVV\/vector sigcontext supported])\n+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([#include <linux\/ptrace.h>],\n+        [\n+          return (int)sizeof(struct __riscv_v_ext_state);\n+        ])],\n+        [\n+          AC_MSG_RESULT([yes])\n+        ],\n+        [\n+          $1_DEFINES_CPU_JVM=\"${$1_DEFINES_CPU_JVM} -DNO_RVV_SIGCONTEXT\"\n+          AC_MSG_RESULT([no])\n+        ]\n+    )\n+  fi\n+\n","filename":"make\/autoconf\/flags-cflags.m4","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-# include <fpu_control.h>\n@@ -61,0 +60,2 @@\n+# include <fpu_control.h>\n+# include <linux\/ptrace.h>\n@@ -353,0 +354,68 @@\n+  const struct __riscv_mc_d_ext_state * const f_ext_state = &(uc->uc_mcontext.__fpregs.__d);\n+  st->print_cr(\"Floating point state:\");\n+  st->print_cr(\"fcsr=\" UINT32_FORMAT, f_ext_state->__fcsr);\n+  st->print_cr(\"Floating point registers:\");\n+  for (int r = 0; r < 32; r++) {\n+    st->print_cr(\"f%d=\" INTPTR_FORMAT \" | %g\", r, (intptr_t)f_ext_state->__f[r], (double)f_ext_state->__f[r]);\n+  }\n+  st->cr();\n+\n+#ifdef NO_RVV_SIGCONTEXT\n+  st->print_cr(\"Vector state: JVM compiled without vector sigcontext support\");\n+#else \/\/ ifndef NO_RVV_SIGCONTEXT\n+\/\/ This magic number is not in any user-space header.\n+\/\/ No other choice but to define it.\n+#ifndef RISCV_V_MAGIC\n+#define RISCV_V_MAGIC 0x53465457\n+#endif\n+\n+  \/\/ vector state\n+  struct __riscv_extra_ext_header *ext;\n+  struct __riscv_v_ext_state *v_ext_state;\n+\n+  \/\/ Find the vector context\n+  ext = (struct __riscv_extra_ext_header *)(&uc->uc_mcontext.__fpregs);\n+  if (ext->hdr.magic != RISCV_V_MAGIC) {\n+    st->print_cr(\"Vector state: not found\");\n+    return;\n+  }\n+\n+  \/\/ The size passed to user-space is calculated accordingly:\n+  \/\/ size = sizeof(struct __riscv_ctx_hdr) + sizeof(struct __sc_riscv_v_state) + riscv_v_vsize;\n+  uint32_t ext_size = ext->hdr.size;\n+\n+  if (ext_size < (sizeof(struct __riscv_ctx_hdr) + sizeof(*v_ext_state))) {\n+    st->print_cr(\"Vector state: not found, invalid size\");\n+    return;\n+  }\n+\n+  ext_size -= (sizeof(struct __riscv_ctx_hdr) + sizeof(*v_ext_state));\n+\n+  v_ext_state = (struct __riscv_v_ext_state *)((char *)(ext) + sizeof(*ext));\n+\n+  st->print_cr(\"Vector state:\");\n+  st->print_cr(\"vstart=\" INTPTR_FORMAT, v_ext_state->vstart);\n+  st->print_cr(\"vl=\" INTPTR_FORMAT, v_ext_state->vl);\n+  st->print_cr(\"vtype=\" INTPTR_FORMAT, v_ext_state->vtype);\n+  st->print_cr(\"vcsr=\" INTPTR_FORMAT, v_ext_state->vcsr);\n+  st->print_cr(\"vlenb=\" INTPTR_FORMAT, v_ext_state->vlenb);\n+  st->print_cr(\"Vector registers:\");\n+\n+  uint64_t vr_size = v_ext_state->vlenb;\n+\n+  if (ext_size < (32 * vr_size)) {\n+    st->print_cr(\"Vector registers: not found, invalid size\");\n+    return;\n+  }\n+  \/\/ datap format is undocumented, but is generated by kernel function riscv_v_vstate_save().\n+  uint8_t *regp = (uint8_t *)v_ext_state->datap;\n+  for (int r = 0; r < 32; r++) {\n+    st->print(\"v%d=0x\", r);\n+    for (int i = vr_size; i > 0; i--) {\n+      st->print(\"%02\" PRIx8, regp[i-1]);\n+    }\n+    st->print_cr(\"\");\n+    regp += vr_size;\n+  }\n+  st->cr();\n+#endif \/\/ #ifndef NO_RVV_SIGCONTEXT\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/os_linux_riscv.cpp","additions":70,"deletions":1,"binary":false,"changes":71,"status":"modified"}]}