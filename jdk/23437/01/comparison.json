{"files":[{"patch":"@@ -1,149 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.loom.obsolete;\n-\n-import jdk.internal.vm.Continuation;\n-import jdk.internal.vm.ContinuationScope;\n-\n-import java.util.concurrent.TimeUnit;\n-import org.openjdk.jmh.annotations.*;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Thread)\n-@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n-@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n-@Fork(1)\n-public class FreezeAndThaw {\n-    static final ContinuationScope SCOPE = new ContinuationScope() { };\n-\n-    static class Arg {\n-        volatile int field;\n-    }\n-\n-    \/**\n-     * A recursive task that optionally yields when the stack gets to a specific\n-     * depth. If continued after yielding, it runs to completion.\n-     *\/\n-    static class Yielder implements Runnable {\n-        private final int paramCount;\n-        private final int maxDepth;\n-        private final boolean yieldAtLimit;\n-\n-        private Yielder(int paramCount, int maxDepth, boolean yieldAtLimit) {\n-            if (paramCount < 1 || paramCount > 3)\n-                throw new IllegalArgumentException();\n-            this.paramCount = paramCount;\n-            this.maxDepth = maxDepth;\n-            this.yieldAtLimit = yieldAtLimit;\n-        }\n-\n-        @Override\n-        public void run() {\n-            switch (paramCount) {\n-                case 1: run1(maxDepth); break;\n-                case 2: run2(maxDepth, new Arg()); break;\n-                case 3: run3(maxDepth, new Arg(), new Arg()); break;\n-                default: throw new Error(\"should not happen\");\n-            }\n-        }\n-\n-        private void run1(int depth) {\n-            if (depth > 0) {\n-                run1(depth - 1);\n-            } if (depth == 0) {\n-                if (yieldAtLimit) Continuation.yield(SCOPE);\n-            }\n-        }\n-\n-        private void run2(int depth, Arg arg2) {\n-            if (depth > 0) {\n-                run2(depth - 1, arg2);\n-            } if (depth == 0) {\n-                if (yieldAtLimit) Continuation.yield(SCOPE);\n-            } else {\n-                \/\/ never executed\n-                arg2.field = 0;\n-            }\n-        }\n-\n-        private void run3(int depth, Arg arg2, Arg arg3) {\n-            if (depth > 0) {\n-                run3(depth - 1, arg2, arg3);\n-            } if (depth == 0) {\n-                if (yieldAtLimit) {\n-                    Continuation.yield(SCOPE);\n-                }\n-            } else {\n-                \/\/ never executed\n-                arg2.field = 0;\n-                arg3.field = 0;\n-            }\n-        }\n-\n-        static Continuation continuation(int paramCount, int maxDepth,\n-                                         boolean yieldAtLimit) {\n-            Runnable task = new Yielder(paramCount, maxDepth, yieldAtLimit);\n-            return new Continuation(SCOPE, task);\n-        }\n-    }\n-\n-    @Param({\"1\", \"2\", \"3\"})\n-    public int paramCount;\n-\n-    @Param({\"5\", \"10\", \"20\", \"100\"})\n-    public int stackDepth;\n-\n-    Continuation cont;\n-    Continuation cont0;\n-\n-    @Setup(Level.Invocation)\n-    public void setup() {\n-        \/\/ System.out.println(\"pc = \" + paramCount + \" sd = \" + stackDepth);\n-        cont = Yielder.continuation(paramCount, stackDepth, true);\n-        cont0 = Yielder.continuation(paramCount, stackDepth, false);\n-    }\n-\n-    \/**\n-     * Creates and runs a continuation that yields at a given stack depth.\n-     *\/\n-    @Benchmark\n-    public void baseline() {\n-        \/\/ Continuation cont0 = Yielder.continuation(paramCount, stackDepth, false);\n-        cont0.run();\n-        assert cont0.isDone();\n-    }\n-\n-    \/**\n-     * Creates and runs a continuation that yields at a given stack depth.\n-     *\/\n-    @Benchmark\n-    public void yieldAndContinue() {\n-        \/\/ Continuation cont = Yielder.continuation(paramCount, stackDepth, true);\n-        cont.run();\n-        assert !cont.isDone();\n-        cont.run();\n-        assert cont.isDone();\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/loom\/obsolete\/FreezeAndThaw.java","additions":0,"deletions":149,"binary":false,"changes":149,"status":"deleted"},{"patch":"@@ -1,252 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.loom.obsolete;\n-\n-import jdk.internal.vm.Continuation;\n-import jdk.internal.vm.ContinuationScope;\n-\n-import java.util.concurrent.TimeUnit;\n-import org.openjdk.jmh.annotations.*;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Thread)\n-@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n-@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n-@Fork(1)\n-public class OneShot {\n-    static final ContinuationScope SCOPE = new ContinuationScope() { };\n-\n-    static class Arg {\n-        volatile int field;\n-    }\n-\n-    \/**\n-     * A recursive task that optionally yields when the stack gets to a specific\n-     * depth. If continued after yielding, it runs to completion.\n-     *\/\n-    static class Yielder implements Runnable {\n-        private final int paramCount;\n-        private final int maxDepth;\n-        private final boolean yieldAtLimit;\n-\n-        private Yielder(int paramCount, int maxDepth, boolean yieldAtLimit) {\n-            if (paramCount < 1 || paramCount > 3)\n-                throw new IllegalArgumentException();\n-            this.paramCount = paramCount;\n-            this.maxDepth = maxDepth;\n-            this.yieldAtLimit = yieldAtLimit;\n-        }\n-\n-        @Override\n-        public void run() {\n-            switch (paramCount) {\n-                case 1: run1(maxDepth); break;\n-                case 2: run2(maxDepth, new Arg()); break;\n-                case 3: run3(maxDepth, new Arg(), new Arg()); break;\n-                default: throw new Error(\"should not happen\");\n-            }\n-        }\n-\n-        private void run1(int depth) {\n-            if (depth > 0) {\n-                run1(depth - 1);\n-            } if (depth == 0) {\n-                if (yieldAtLimit) Continuation.yield(SCOPE);\n-            }\n-        }\n-\n-        private void run2(int depth, Arg arg2) {\n-            if (depth > 0) {\n-                run2(depth - 1, arg2);\n-            } if (depth == 0) {\n-                if (yieldAtLimit) Continuation.yield(SCOPE);\n-            } else {\n-                \/\/ never executed\n-                arg2.field = 0;\n-            }\n-        }\n-\n-        private void run3(int depth, Arg arg2, Arg arg3) {\n-            if (depth > 0) {\n-                run3(depth - 1, arg2, arg3);\n-            } if (depth == 0) {\n-                if (yieldAtLimit) Continuation.yield(SCOPE);\n-            } else {\n-                \/\/ never executed\n-                arg2.field = 0;\n-                arg3.field = 0;\n-            }\n-        }\n-\n-        static Continuation continuation(int paramCount, int maxDepth,\n-                                         boolean yieldAtLimit) {\n-            Runnable task = new Yielder(paramCount, maxDepth, yieldAtLimit);\n-            return new Continuation(SCOPE, task);\n-        }\n-    }\n-\n-    \/**\n-     * A recursive task that optionally yields before and\/or after each call.\n-     *\/\n-    static class Stepper implements Runnable {\n-        private final int paramCount;\n-        private final int maxDepth;\n-        private final boolean yieldBefore;\n-        private final boolean yieldAfter;\n-\n-        private Stepper(int paramCount,\n-                        int maxDepth,\n-                        boolean yieldBefore,\n-                        boolean yieldAfter) {\n-            this.paramCount = paramCount;\n-            this.maxDepth = maxDepth;\n-            this.yieldBefore = yieldBefore;\n-            this.yieldAfter = yieldAfter;\n-        }\n-\n-        public void run() {\n-            switch (paramCount) {\n-                case 1: run1(maxDepth); break;\n-                case 2: run2(maxDepth, new Arg()); break;\n-                case 3: run3(maxDepth, new Arg(), new Arg()); break;\n-                default: throw new Error(\"should not happen\");\n-            }\n-        }\n-\n-        private void run1(int depth) {\n-            if (depth > 0) {\n-                if (yieldBefore) Continuation.yield(SCOPE);\n-                run1(depth - 1);\n-                if (yieldAfter) Continuation.yield(SCOPE);\n-            }\n-        }\n-\n-        private void run2(int depth, Arg arg2) {\n-            if (depth > 0) {\n-                if (yieldBefore) Continuation.yield(SCOPE);\n-                run2(depth - 1, arg2);\n-                if (yieldAfter) Continuation.yield(SCOPE);\n-            } else if (depth < 0) {\n-                \/\/ never executed\n-                arg2.field = 0;\n-            }\n-        }\n-\n-        private void run3(int depth, Arg arg2, Arg arg3) {\n-            if (depth > 0) {\n-                if (yieldBefore) Continuation.yield(SCOPE);\n-                run3(depth - 1, arg2, arg3);\n-                if (yieldAfter) Continuation.yield(SCOPE);\n-            } else if (depth < 0) {\n-                \/\/ never executed\n-                arg2.field = 0;\n-                arg3.field = 0;\n-            }\n-        }\n-\n-        static Continuation continuation(int paramCount, int maxDepth,\n-                                         boolean yieldBefore, boolean yieldAfter) {\n-            Runnable task = new Stepper(paramCount, maxDepth, yieldBefore, yieldAfter);\n-            return new Continuation(SCOPE, task);\n-        }\n-    }\n-\n-    @Param({\"1\", \"2\", \"3\"})\n-    public int paramCount;\n-\n-    @Param({\"5\", \"10\", \"20\", \"100\"})\n-    public int stackDepth;\n-\n-    \/**\n-     * Creates and run continuation that does not yield.\n-     *\/\n-    @Benchmark\n-    public void noYield() {\n-        Continuation cont = Yielder.continuation(paramCount, stackDepth, false);\n-        cont.run();\n-        if (!cont.isDone())\n-            throw new RuntimeException(\"continuation not done???\");\n-    }\n-\n-    \/**\n-     * Creates and runs a continuation that yields at a given stack depth.\n-     *\/\n-    @Benchmark\n-    public void yield() {\n-        Continuation cont = Yielder.continuation(paramCount, stackDepth, true);\n-        cont.run();\n-        if (cont.isDone())\n-            throw new RuntimeException(\"continuation done???\");\n-    }\n-\n-    \/**\n-     * Creates and runs a continuation that yields at a given stack depth, it is\n-     * then continued to run to completion.\n-     *\/\n-    @Benchmark\n-    public void yieldThenContinue() {\n-        Continuation cont = Yielder.continuation(paramCount, stackDepth, true);\n-        cont.run();\n-        cont.run();  \/\/ continue\n-        if (!cont.isDone())\n-            throw new RuntimeException(\"continuation not done???\");\n-    }\n-\n-    \/**\n-     * Creates and runs a continuation to the given stack depth, yielding before\n-     * each call.\n-     *\/\n-    @Benchmark\n-    public void yieldBeforeEachCall() {\n-        Continuation cont = Stepper.continuation(paramCount, stackDepth, true, false);\n-        while (!cont.isDone()) {\n-            cont.run();\n-        }\n-    }\n-\n-    \/**\n-     * Creates and runs a continuation to the given stack depth, yielding after\n-     * each call.\n-     *\/\n-    @Benchmark\n-    public void yieldAfterEachCall() {\n-        Continuation cont = Stepper.continuation(paramCount, stackDepth, false, true);\n-        while (!cont.isDone()) {\n-            cont.run();\n-        }\n-    }\n-\n-    \/**\n-     * Creates and runs a continuation to the given stack depth, yielding before\n-     * and after each call.\n-     *\/\n-    @Benchmark\n-    public void yieldBeforeAndAfterEachCall() {\n-        Continuation cont = Stepper.continuation(paramCount, stackDepth, true, true);\n-        while (!cont.isDone()) {\n-            cont.run();\n-        }\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/loom\/obsolete\/OneShot.java","additions":0,"deletions":252,"binary":false,"changes":252,"status":"deleted"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.loom.obsolete;\n-\n-import jdk.internal.vm.Continuation;\n-import jdk.internal.vm.ContinuationScope;\n-\n-import java.util.concurrent.TimeUnit;\n-import org.openjdk.jmh.annotations.*;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Benchmark)\n-@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n-@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n-@Fork(1)\n-public class Oscillation {\n-    static final ContinuationScope SCOPE = new ContinuationScope() { };\n-\n-    \/**\n-     * A task that oscillates between a minimum and maximum stack depth, yielding\n-     * at the maximum stack until continued.\n-     *\/\n-    static class Wave implements Runnable {\n-        private final int min;\n-        private final int max;\n-\n-        private enum Mode { GROW, SHRINK }\n-        private Mode mode;\n-\n-        Wave(int min, int max) {\n-            if (min < 0)\n-                throw new IllegalArgumentException(\"negative min\");\n-            if (max <= min)\n-                throw new IllegalArgumentException(\"max must be greater than min\");\n-            this.min = min;\n-            this.max = max;\n-            this.mode = Mode.GROW;\n-        }\n-\n-        private void run(int depth) {\n-            if (depth == max) {\n-                Continuation.yield(SCOPE);\n-                mode = Mode.SHRINK;\n-            } else if (depth == min) {\n-                while (true) {\n-                    mode = Mode.GROW;\n-                    run(depth + 1);\n-                }\n-            } else if (mode == Mode.GROW) {\n-                run(depth + 1);\n-            }\n-        }\n-\n-        @Override\n-        public void run() {\n-            run(0);\n-        }\n-    }\n-\n-    @Param({\"2\", \"3\", \"4\"})\n-    public int minDepth;\n-\n-    @Param({\"5\", \"6\", \"7\", \"8\"})\n-    public int maxDepth;\n-\n-    @Param({\"10\", \"100\", \"1000\"})\n-    public int repeat;\n-\n-    \/**\n-     * Creates and runs a continuation that oscillates between a minimum and\n-     * maximum stack depth, yielding at the maximum stack until continued.\n-     *\n-     * Useful to measure freeze and thaw, also to compare full stack vs. lazy copy.\n-     *\/\n-    @Benchmark\n-    public void oscillate() {\n-        Continuation cont = new Continuation(SCOPE, new Wave(minDepth, maxDepth));\n-        for (int i=0; i<repeat; i++) {\n-            cont.run();\n-        }\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/loom\/obsolete\/Oscillation.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"}]}