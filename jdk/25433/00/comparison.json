{"files":[{"patch":"@@ -177,0 +177,1 @@\n+        jdk.internal.vm.ci,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.util.List;\n@@ -34,0 +35,2 @@\n+import static jdk.vm.ci.code.CodeUtil.listFromTrustedArray;\n+\n@@ -78,1 +81,1 @@\n-     * An array describing the Java kinds in {@link #values}. It records a kind for the locals and\n+     * A list describing the Java kinds in {@link #values}. It records a kind for the locals and\n@@ -81,1 +84,1 @@\n-    private final JavaKind[] slotKinds;\n+    private final List<JavaKind> slotKinds;\n@@ -224,1 +227,1 @@\n-        this.slotKinds = slotKinds;\n+        this.slotKinds = listFromTrustedArray(slotKinds);\n@@ -242,1 +245,1 @@\n-        if (slotKinds.length != numLocals + numStack) {\n+        if (slotKinds.size() != numLocals + numStack) {\n@@ -245,1 +248,1 @@\n-        for (int i = 0; i < slotKinds.length; i++) {\n+        for (int i = 0; i < slotKinds.size(); i++) {\n@@ -247,1 +250,1 @@\n-            JavaKind kind = slotKinds[i];\n+            JavaKind kind = slotKinds.get(i);\n@@ -254,1 +257,1 @@\n-        for (int i = slotKinds.length; i < values.length; i++) {\n+        for (int i = slotKinds.size(); i < values.length; i++) {\n@@ -274,1 +277,1 @@\n-                JavaKind kind = slotKinds[i];\n+                JavaKind kind = slotKinds.get(i);\n@@ -276,2 +279,2 @@\n-                    assert slotKinds.length > i + 1 : String.format(\"missing second word %s\", this);\n-                    assert slotKinds[i + 1] == JavaKind.Illegal : this;\n+                    assert slotKinds.size() > i + 1 : String.format(\"missing second word %s\", this);\n+                    assert slotKinds.get(i + 1) == JavaKind.Illegal : this;\n@@ -293,1 +296,1 @@\n-        return slotKinds[i];\n+        return slotKinds.get(i);\n@@ -305,1 +308,1 @@\n-        return slotKinds[i + numLocals];\n+        return slotKinds.get(i + numLocals);\n@@ -361,1 +364,1 @@\n-                        Arrays.hashCode(slotKinds),\n+                        slotKinds,\n@@ -382,1 +385,1 @@\n-                        Arrays.equals(slotKinds, that.slotKinds) &&\n+                        slotKinds.equals(that.slotKinds) &&\n@@ -390,0 +393,7 @@\n+\n+    \/**\n+     * Returns the list describing the Java kinds in {@link #values}.\n+     *\/\n+    public List<JavaKind> getSlotKinds() {\n+        return slotKinds;\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/BytecodeFrame.java","additions":24,"deletions":14,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.List;\n@@ -30,0 +31,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -440,0 +442,10 @@\n+\n+    \/**\n+     * Creates an immutable list from a trusted array that has no references retained by the caller.\n+     *\/\n+    static <T> List<T> listFromTrustedArray(Object[] array) {\n+        if (array == null) {\n+            return List.of();\n+        }\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(array);\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/CodeUtil.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.List;\n@@ -35,0 +36,2 @@\n+import static jdk.vm.ci.code.CodeUtil.listFromTrustedArray;\n+\n@@ -44,1 +47,1 @@\n-    private JavaKind[] slotKinds;\n+    private List<JavaKind> slotKinds;\n@@ -121,1 +124,1 @@\n-                                if (vo.slotKinds[i].getSlotCount() == 2 && field.getType().getJavaKind().getSlotCount() == 1) {\n+                                if (vo.slotKinds.get(i).getSlotCount() == 2 && field.getType().getJavaKind().getSlotCount() == 1) {\n@@ -160,1 +163,1 @@\n-                JavaKind slotKind = slotKinds[i];\n+                JavaKind slotKind = slotKinds.get(i);\n@@ -195,1 +198,1 @@\n-                JavaKind slotkind = slotKinds[i];\n+                JavaKind slotkind = slotKinds.get(i);\n@@ -201,1 +204,1 @@\n-                    while (++i < values.length && slotKinds[i] == JavaKind.Illegal) {\n+                    while (++i < values.length && slotKinds.get(i) == JavaKind.Illegal) {\n@@ -247,1 +250,1 @@\n-        return slotKinds[index];\n+        return slotKinds.get(index);\n@@ -279,1 +282,1 @@\n-        this.slotKinds = slotKinds;\n+        this.slotKinds = listFromTrustedArray(slotKinds);\n@@ -292,3 +295,4 @@\n-        if (o instanceof VirtualObject) {\n-            VirtualObject l = (VirtualObject) o;\n-            if (!l.type.equals(type) || l.values.length != values.length) {\n+        if (o instanceof VirtualObject that) {\n+            int thatValuesLength = (that.values == null) ? 0 : that.values.length;\n+            int valuesLength = (values == null) ? 0 : values.length;\n+            if (!that.type.equals(type) || thatValuesLength != valuesLength) {\n@@ -297,1 +301,1 @@\n-            for (int i = 0; i < values.length; i++) {\n+            for (int i = 0; i < valuesLength; i++) {\n@@ -302,1 +306,1 @@\n-                if (!same(values[i], l.values[i])) {\n+                if (!same(values[i], that.values[i])) {\n@@ -314,0 +318,7 @@\n+\n+    \/**\n+     * Returns the list containing the Java kinds of the values stored in this virtual object.\n+     *\/\n+    public List<JavaKind> getSlotKinds() {\n+        return slotKinds;\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/VirtualObject.java","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-    public final int hashCode() {\n-        throw new UnsupportedOperationException(\"hashCode\");\n+    public int hashCode() {\n+        return 41 * pcOffset;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/site\/Site.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.List;\n@@ -29,0 +30,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -1079,0 +1081,7 @@\n+    static <T> List<T> listFromTrustedArray(Object[] array) {\n+        if (array == null) {\n+            return List.of();\n+        }\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(array);\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import static jdk.vm.ci.hotspot.CompilerToVM.listFromTrustedArray;\n+\n@@ -36,0 +38,2 @@\n+import java.util.List;\n+\n@@ -60,1 +64,1 @@\n-    protected final Site[] sites;\n+    protected final List<Site> sites;\n@@ -65,1 +69,1 @@\n-    protected final Assumption[] assumptions;\n+    protected final List<Assumption> assumptions;\n@@ -69,1 +73,1 @@\n-     * {@code null}, then the compilation did not record method dependencies. Otherwise, the first\n+     * empty, then the compilation did not record method dependencies. Otherwise, the first\n@@ -72,1 +76,1 @@\n-    protected final ResolvedJavaMethod[] methods;\n+    protected final List<ResolvedJavaMethod> methods;\n@@ -77,1 +81,1 @@\n-    protected final Comment[] comments;\n+    protected final List<Comment> comments;\n@@ -92,1 +96,1 @@\n-    protected final DataPatch[] dataSectionPatches;\n+    protected final List<DataPatch> dataSectionPatches;\n@@ -120,0 +124,23 @@\n+    \/**\n+     * @param name                 the name of this compilation unit.\n+     * @param targetCode           the buffer containing the emitted machine code. This array is now owned by this\n+     *                             object and should not be mutated by the caller.\n+     * @param targetCodeSize       the leading number of bytes in {@link #targetCode} containing the emitted machine\n+     *                             code.\n+     * @param sites                an array of code annotations describing special sites in {@link #targetCode}. This\n+     *                             array is now owned by this object and should not be mutated by the caller.\n+     * @param assumptions          an array of {@link Assumption} this code relies on. This array is now owned by this\n+     *                             object and should not be mutated by the caller.\n+     * @param methods              an array of the methods whose bytecodes were used as input to the compilation. This\n+     *                             array is now owned by this object and should not be mutated by the caller.\n+     * @param comments             an array of comments that will be included in code dumps. This array is now owned by\n+     *                             this object and should not be mutated by the caller.\n+     * @param dataSection          the data section containing serialized constants for the emitted machine code. This\n+     *                             array is now owned by this object and should not be mutated by the caller.\n+     * @param dataSectionAlignment the minimum alignment of the data section.\n+     * @param dataSectionPatches   an array of relocations in the {@link #dataSection}. This array is now owned by this\n+     *                             object and should not be mutated by the caller.\n+     * @param isImmutablePIC       the flag determining whether this code is immutable and position independent.\n+     * @param totalFrameSize       the total size of the stack frame of this compiled method.\n+     * @param deoptRescueSlot      the deopt rescue slot. Must be non-null if there is a safepoint in the method.\n+     *\/\n@@ -122,12 +149,12 @@\n-                    byte[] targetCode,\n-                    int targetCodeSize,\n-                    Site[] sites,\n-                    Assumption[] assumptions,\n-                    ResolvedJavaMethod[] methods,\n-                    Comment[] comments,\n-                    byte[] dataSection,\n-                    int dataSectionAlignment,\n-                    DataPatch[] dataSectionPatches,\n-                    boolean isImmutablePIC,\n-                    int totalFrameSize,\n-                    StackSlot deoptRescueSlot) {\n+                               byte[] targetCode,\n+                               int targetCodeSize,\n+                               Site[] sites,\n+                               Assumption[] assumptions,\n+                               ResolvedJavaMethod[] methods,\n+                               Comment[] comments,\n+                               byte[] dataSection,\n+                               int dataSectionAlignment,\n+                               DataPatch[] dataSectionPatches,\n+                               boolean isImmutablePIC,\n+                               int totalFrameSize,\n+                               StackSlot deoptRescueSlot) {\n@@ -137,3 +164,3 @@\n-        this.sites = sites;\n-        this.assumptions = assumptions;\n-        this.methods = methods;\n+        this.sites = listFromTrustedArray(sites);\n+        this.assumptions = listFromTrustedArray(assumptions);\n+        this.methods = listFromTrustedArray(methods);\n@@ -141,1 +168,1 @@\n-        this.comments = comments;\n+        this.comments = listFromTrustedArray(comments);\n@@ -144,1 +171,1 @@\n-        this.dataSectionPatches = dataSectionPatches;\n+        this.dataSectionPatches = listFromTrustedArray(dataSectionPatches);\n@@ -149,0 +176,1 @@\n+        assert targetCode != null && dataSection != null;\n@@ -191,0 +219,84 @@\n+\n+    \/**\n+     * Returns a copy of the compiled machine code.\n+     *\/\n+    public byte[] getTargetCode() {\n+        return targetCode.clone();\n+    }\n+\n+    \/**\n+     * Gets the size of the compiled machine code in bytes.\n+     *\/\n+    public int getTargetCodeSize() {\n+        return targetCodeSize;\n+    }\n+\n+    \/**\n+     * Returns the list of code annotations describing special sites in {@link #targetCode}.\n+     *\/\n+    public List<Site> getSites() {\n+        return sites;\n+    }\n+\n+    \/**\n+     * Returns list of {@link Assumption} this code relies on.\n+     *\/\n+    public List<Assumption> getAssumptions() {\n+        return assumptions;\n+    }\n+\n+    \/**\n+     * Returns the list of the methods whose bytecodes were used as input to the compilation\n+     *\/\n+    public List<ResolvedJavaMethod> getMethods() {\n+        return methods;\n+    }\n+\n+    \/**\n+     * Returns the list of comments that will be included in code dumps.\n+     *\/\n+    public List<Comment> getComments() {\n+        return comments;\n+    }\n+\n+    \/**\n+     * Returns a copy of the data section containing serialized constants for the emitted machine code.\n+     *\/\n+    public byte[] getDataSection() {\n+        return dataSection.clone();\n+    }\n+\n+    \/**\n+     * Gets the minimum alignment of the data section.\n+     *\/\n+    public int getDataSectionAlignment() {\n+        return dataSectionAlignment;\n+    }\n+\n+    \/**\n+     * Gets the list of relocations in the {@link #dataSection}.\n+     *\/\n+    public List<DataPatch> getDataSectionPatches() {\n+        return dataSectionPatches;\n+    }\n+\n+    \/**\n+     * Checks if this compiled code is immutable and position independent.\n+     *\/\n+    public boolean isImmutablePIC() {\n+        return isImmutablePIC;\n+    }\n+\n+    \/**\n+     * Gets the total size of the stack frame of this compiled method.\n+     *\/\n+    public int getTotalFrameSize() {\n+        return totalFrameSize;\n+    }\n+\n+    \/**\n+     * Gets the deoptimization rescue slot associated with this compiled code.\n+     *\/\n+    public StackSlot getDeoptRescueSlot() {\n+        return deoptRescueSlot;\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotCompiledCode.java","additions":135,"deletions":23,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+import java.util.List;\n@@ -546,2 +547,2 @@\n-        ResolvedJavaMethod[] methods = withMethods ? code.methods : null;\n-        Assumption[] assumptions = code.assumptions;\n+        List<ResolvedJavaMethod> methods = withMethods ? code.methods : null;\n+        List<Assumption> assumptions = code.assumptions;\n@@ -549,1 +550,1 @@\n-        Comment[] comments = withComments ? code.comments : null;\n+        List<Comment> comments = withComments ? code.comments : null;\n@@ -565,1 +566,1 @@\n-                    setIf(HAS_METHODS, nmethod != null && methods != null && methods.length != 0 ) |\n+                    setIf(HAS_METHODS, nmethod != null && methods != null && !methods.isEmpty() ) |\n@@ -586,1 +587,1 @@\n-            writeU2(\"methods:length\", methods.length);\n+            writeU2(\"methods:length\", methods.size());\n@@ -592,1 +593,1 @@\n-        writeInt(\"sites:length\", code.sites.length);\n+        writeInt(\"sites:length\", code.sites.size());\n@@ -608,1 +609,1 @@\n-            writeU2(\"comments:length\", comments.length);\n+            writeU2(\"comments:length\", comments.size());\n@@ -738,2 +739,1 @@\n-        Site[] sites = code.sites;\n-        for (Site site : sites) {\n+        for (Site site : code.sites) {\n@@ -807,2 +807,2 @@\n-    private void writeDataSectionPatches(DataPatch[] dataSectionPatches) {\n-        writeU2(\"dataSectionPatches:length\", dataSectionPatches.length);\n+    private void writeDataSectionPatches(List<DataPatch> dataSectionPatches) {\n+        writeU2(\"dataSectionPatches:length\", dataSectionPatches.size());\n@@ -930,2 +930,2 @@\n-    private void writeAssumptions(Assumption[] assumptions) {\n-        writeU2(\"assumptions:length\", assumptions.length);\n+    private void writeAssumptions(List<Assumption> assumptions) {\n+        writeU2(\"assumptions:length\", assumptions.size());\n@@ -1180,2 +1180,2 @@\n-    private static int setIf(int flag, Object[] array) {\n-        return array != null && array.length > 0 ? flag : 0;\n+    private static int setIf(int flag, List<?> array) {\n+        return array != null && !array.isEmpty() ? flag : 0;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotCompiledCodeStream.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -55,1 +55,2 @@\n-    @SuppressFBWarnings(value = \"UWF_UNWRITTEN_FIELD\", justification = \"set by the VM\") private String installationFailureMessage;\n+    @SuppressFBWarnings(value = \"UWF_UNWRITTEN_FIELD\", justification = \"set by the VM\")\n+    private String installationFailureMessage;\n@@ -57,0 +58,30 @@\n+    \/**\n+     * @param name                 the name of this compilation unit.\n+     * @param targetCode           the buffer containing the emitted machine code. This array is now owned by this\n+     *                             object and should not be mutated by the caller.\n+     * @param targetCodeSize       the leading number of bytes in {@link #targetCode} containing the emitted machine\n+     *                             code.\n+     * @param sites                an array of code annotations describing special sites in {@link #targetCode}. This\n+     *                             array is now owned by this object and should not be mutated by the caller.\n+     * @param assumptions          an array of {@link Assumption} this code relies on. This array is now owned by this\n+     *                             object and should not be mutated by the caller.\n+     * @param methods              an array of the methods whose bytecodes were used as input to the compilation. This\n+     *                             array is now owned by this object and should not be mutated by the caller.\n+     * @param comments             an array of comments that will be included in code dumps. This array is now owned by\n+     *                             this object and should not be mutated by the caller.\n+     * @param dataSection          the data section containing serialized constants for the emitted machine code. This\n+     *                             array is now owned by this object and should not be mutated by the caller.\n+     * @param dataSectionAlignment the minimum alignment of the data section.\n+     * @param dataSectionPatches   an array of relocations in the {@link #dataSection}. This array is now owned by this\n+     *                             object and should not be mutated by the caller.\n+     * @param isImmutablePIC       the flag determining whether this code is immutable and position independent.\n+     * @param totalFrameSize       the total size of the stack frame of this compiled method.\n+     * @param deoptRescueSlot      the deopt rescue slot. Must be non-null if there is a safepoint in the method.\n+     * @param method               the method to which this compiled nmethod belongs.\n+     * @param entryBCI             the bytecode index (BCI) in the {@link #method}\n+     * @param id                   the identifier of the compilation request.\n+     * @param compileState         the address of a native {@code JVMCICompileState} object associated with this\n+     *                             compiled nmethod.\n+     * @param hasUnsafeAccess      a flag indicating if this compiled nmethod has a memory access via the\n+     *                             {@code Unsafe} class.\n+     *\/\n@@ -58,17 +89,17 @@\n-                    byte[] targetCode,\n-                    int targetCodeSize,\n-                    Site[] sites,\n-                    Assumption[] assumptions,\n-                    ResolvedJavaMethod[] methods,\n-                    Comment[] comments,\n-                    byte[] dataSection,\n-                    int dataSectionAlignment,\n-                    DataPatch[] dataSectionPatches,\n-                    boolean isImmutablePIC,\n-                    int totalFrameSize,\n-                    StackSlot deoptRescueSlot,\n-                    HotSpotResolvedJavaMethod method,\n-                    int entryBCI,\n-                    int id,\n-                    long compileState,\n-                    boolean hasUnsafeAccess) {\n+                                  byte[] targetCode,\n+                                  int targetCodeSize,\n+                                  Site[] sites,\n+                                  Assumption[] assumptions,\n+                                  ResolvedJavaMethod[] methods,\n+                                  Comment[] comments,\n+                                  byte[] dataSection,\n+                                  int dataSectionAlignment,\n+                                  DataPatch[] dataSectionPatches,\n+                                  boolean isImmutablePIC,\n+                                  int totalFrameSize,\n+                                  StackSlot deoptRescueSlot,\n+                                  HotSpotResolvedJavaMethod method,\n+                                  int entryBCI,\n+                                  int id,\n+                                  long compileState,\n+                                  boolean hasUnsafeAccess) {\n@@ -76,12 +107,12 @@\n-                        targetCode,\n-                        targetCodeSize,\n-                        sites,\n-                        assumptions,\n-                        methods,\n-                        comments,\n-                        dataSection,\n-                        dataSectionAlignment,\n-                        dataSectionPatches,\n-                        isImmutablePIC,\n-                        totalFrameSize,\n-                        deoptRescueSlot);\n+                targetCode,\n+                targetCodeSize,\n+                sites,\n+                assumptions,\n+                methods,\n+                comments,\n+                dataSection,\n+                dataSectionAlignment,\n+                dataSectionPatches,\n+                isImmutablePIC,\n+                totalFrameSize,\n+                deoptRescueSlot);\n@@ -121,0 +152,38 @@\n+    \/**\n+     * Returns the method to which this compiled nmethod belongs.\n+     *\/\n+    public HotSpotResolvedJavaMethod getMethod() {\n+        return method;\n+    }\n+\n+    \/**\n+     * Returns the bytecode index (BCI) in the {@link #getMethod() method} that is the beginning of this compiled\n+     * nmethod. -1 denotes the beginning of the method.\n+     *\/\n+    public int getEntryBCI() {\n+        return entryBCI;\n+    }\n+\n+    \/**\n+     * Returns the identifier of the compilation request.\n+     *\/\n+    public int getId() {\n+        return id;\n+    }\n+\n+    \/**\n+     * Returns the address of a native {@code JVMCICompileState} object associated with this compiled nmethod.\n+     * If no such object exists, it returns 0L.\n+     *\n+     * @return the address of the native {@code JVMCICompileState} object or 0L if it does not exist\n+     *\/\n+    public long getCompileState() {\n+        return compileState;\n+    }\n+\n+    \/**\n+     * Checks if this compiled nmethod has a memory access via the {@code Unsafe} class.\n+     *\/\n+    public boolean hasUnsafeAccess() {\n+        return hasUnsafeAccess;\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotCompiledNmethod.java","additions":99,"deletions":30,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    public final String getName() {\n+    public String getName() {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJavaType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-abstract class HotSpotMethod implements JavaMethod, Formattable {\n+public abstract class HotSpotMethod implements JavaMethod, Formattable {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-import java.lang.invoke.CallSite;\n-import java.util.Objects;\n-\n@@ -33,0 +30,4 @@\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.ConstantCallSite;\n+import java.util.Objects;\n+\n@@ -64,1 +65,20 @@\n-    JavaConstant getCallSiteTarget(Assumptions assumptions);\n+    default JavaConstant getCallSiteTarget(Assumptions assumptions) {\n+        Assumptions.AssumptionResult<JavaConstant> result = getCallSiteTarget();\n+        if (!result.canRecordTo(assumptions)) {\n+            return null;\n+        }\n+        result.recordTo(assumptions);\n+        return result.getResult();\n+    }\n+\n+    \/**\n+     * Gets the result of {@link CallSite#getTarget()} for the {@link CallSite} object represented\n+     * by this constant. The target is bound to an assumption if this is not a fully initialized\n+     * {@link ConstantCallSite}.\n+     *\n+     * @return a call-site target (possibly bound to an assumption) or {@code null} if this constant\n+     * does not represent a {@link CallSite} object\n+     *\/\n+    default Assumptions.AssumptionResult<JavaConstant> getCallSiteTarget() {\n+        throw new UnsupportedOperationException(\"getCallSiteTarget\");\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotObjectConstant.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-    public JavaConstant getCallSiteTarget(Assumptions assumptions) {\n+    public Assumptions.AssumptionResult<JavaConstant> getCallSiteTarget() {\n@@ -97,4 +97,1 @@\n-                return readTarget();\n-            }\n-            if (assumptions == null) {\n-                return null;\n+                return new Assumptions.AssumptionResult<>(readTarget());\n@@ -103,2 +100,1 @@\n-            assumptions.record(new Assumptions.CallSiteTargetValue(this, result));\n-            return result;\n+            return new Assumptions.AssumptionResult<>(result, new Assumptions.CallSiteTargetValue(this, result));\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotObjectConstantImpl.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-    HotSpotResolvedObjectTypeImpl arrayOfType;\n+    HotSpotResolvedObjectType arrayOfType;\n@@ -35,1 +35,1 @@\n-    HotSpotResolvedJavaType(String name) {\n+    protected HotSpotResolvedJavaType(String name) {\n@@ -43,1 +43,1 @@\n-    public final int hashCode() {\n+    public int hashCode() {\n@@ -47,1 +47,4 @@\n-    abstract JavaConstant getJavaMirror();\n+    \/**\n+     * Gets the runtime representation of the {@link Class} object of this type.\n+     *\/\n+    public abstract JavaConstant getJavaMirror();\n@@ -49,1 +52,4 @@\n-    abstract HotSpotResolvedObjectTypeImpl getArrayType();\n+    \/**\n+     * Gets the array type of this type without caching the result.\n+     *\/\n+    protected abstract HotSpotResolvedObjectType getArrayType();\n@@ -52,1 +58,1 @@\n-    public final HotSpotResolvedObjectType getArrayClass() {\n+    public HotSpotResolvedObjectType getArrayClass() {\n@@ -66,1 +72,1 @@\n-    abstract boolean isBeingInitialized();\n+    protected abstract boolean isBeingInitialized();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaType.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -83,0 +83,7 @@\n+    \/**\n+     * Gets the runtime representation of the {@link Class} object of this type.\n+     *\/\n+    default JavaConstant getJavaMirror() {\n+        throw new UnsupportedOperationException(\"getJavaMirror\");\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectType.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -675,1 +675,1 @@\n-    JavaConstant getJavaMirror() {\n+    public JavaConstant getJavaMirror() {\n@@ -680,1 +680,1 @@\n-    HotSpotResolvedObjectTypeImpl getArrayType() {\n+    protected HotSpotResolvedObjectTypeImpl getArrayType() {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,1 +64,7 @@\n-    static HotSpotResolvedPrimitiveType forKind(JavaKind kind) {\n+    \/**\n+     * Returns a primitive type instance corresponding to the given {@link JavaKind}.\n+     *\n+     * @param kind the Java kind of the primitive type\n+     * @return the primitive type instance for the given Java kind\n+     *\/\n+    public static HotSpotResolvedPrimitiveType forKind(JavaKind kind) {\n@@ -87,1 +93,1 @@\n-    HotSpotResolvedObjectTypeImpl getArrayType() {\n+    protected HotSpotResolvedObjectType getArrayType() {\n@@ -324,1 +330,1 @@\n-    JavaConstant getJavaMirror() {\n+    public JavaConstant getJavaMirror() {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedPrimitiveType.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -133,1 +134,1 @@\n-        HotSpotSpeculation(SpeculationReason reason, JavaConstant id, byte[] encoding) {\n+        public HotSpotSpeculation(SpeculationReason reason, JavaConstant id, byte[] encoding) {\n@@ -143,0 +144,7 @@\n+        \/**\n+         * Returns a copy of the speculation reason encoding.\n+         *\/\n+        public byte[] getReasonEncoding() {\n+            return (encoding == null) ? null : Arrays.copyOf(encoding, encoding.length);\n+        }\n+\n@@ -150,0 +158,14 @@\n+\n+        @Override\n+        public boolean equals(Object object) {\n+            if (object instanceof HotSpotSpeculation that) {\n+                return getReason().equals(that.getReason()) && id.equals(that.id) && Arrays.equals(encoding, that.encoding);\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(getReason(), id, Arrays.hashCode(encoding));\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotSpeculationLog.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-    private VMField getField(String name, String cppType, boolean required) {\n+    public VMField getField(String name, String cppType, boolean required) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfigAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    VMField(String name, String type, long offset, long address, Object value) {\n+    public VMField(String name, String type, long offset, long address, Object value) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/VMField.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,0 +116,21 @@\n+\n+    \/**\n+     * Returns the group ID of this speculation reason.\n+     *\/\n+    public int getGroupId() {\n+        return groupId;\n+    }\n+\n+    \/**\n+     * Returns the group name of this speculation reason.\n+     *\/\n+    public String getGroupName() {\n+        return groupName;\n+    }\n+\n+    \/**\n+     * Returns a copy of the array of context objects.\n+     *\/\n+    public Object[] getContext() {\n+        return (context == null) ? null : Arrays.copyOf(context, context.length);\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/EncodedSpeculationReason.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}