{"files":[{"patch":"@@ -390,0 +390,7 @@\n+\n+    \/**\n+     * Returns a copy of the array describing the Java kinds in {@link #values}.\n+     *\/\n+    public JavaKind[] getSlotKinds() {\n+        return (slotKinds == null) ? null : slotKinds.clone();\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/BytecodeFrame.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -292,3 +292,4 @@\n-        if (o instanceof VirtualObject) {\n-            VirtualObject l = (VirtualObject) o;\n-            if (!l.type.equals(type) || l.values.length != values.length) {\n+        if (o instanceof VirtualObject that) {\n+            int thatValuesLength = (that.values == null) ? 0 : that.values.length;\n+            int valuesLength = (values == null) ? 0 : values.length;\n+            if (!that.type.equals(type) || thatValuesLength != valuesLength) {\n@@ -297,1 +298,1 @@\n-            for (int i = 0; i < values.length; i++) {\n+            for (int i = 0; i < valuesLength; i++) {\n@@ -302,1 +303,1 @@\n-                if (!same(values[i], l.values[i])) {\n+                if (!same(values[i], that.values[i])) {\n@@ -314,0 +315,7 @@\n+\n+    \/**\n+     * Returns a copy of the array containing the Java kinds of the values stored in this virtual object.\n+     *\/\n+    public JavaKind[] getSlotKinds() {\n+        return (slotKinds == null) ? null : slotKinds.clone();\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/VirtualObject.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-    public final int hashCode() {\n-        throw new UnsupportedOperationException(\"hashCode\");\n+    public int hashCode() {\n+        return 41 * pcOffset;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/code\/site\/Site.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -191,0 +191,84 @@\n+\n+    \/**\n+     * Returns a copy of the compiled machine code.\n+     *\/\n+    public byte[] getTargetCode() {\n+        return (targetCode == null) ? null : targetCode.clone();\n+    }\n+\n+    \/**\n+     * Gets the size of the compiled machine code in bytes.\n+     *\/\n+    public int getTargetCodeSize() {\n+        return targetCodeSize;\n+    }\n+\n+    \/**\n+     * Returns a copy of the code annotations describing special sites in {@link #targetCode}.\n+     *\/\n+    public Site[] getSites() {\n+        return (sites == null) ? null : sites.clone();\n+    }\n+\n+    \/**\n+     * Returns an array copy of the assumptions this code relies on.\n+     *\/\n+    public Assumption[] getAssumptions() {\n+        return (assumptions == null) ? null : assumptions.clone();\n+    }\n+\n+    \/**\n+     * Returns an array copy of the methods whose bytecodes were used as input to the compilation.\n+     *\/\n+    public ResolvedJavaMethod[] getMethods() {\n+        return (methods == null) ? null : methods.clone();\n+    }\n+\n+    \/**\n+     * Returns an array copy of the comments that are included in code dumps.\n+     *\/\n+    public Comment[] getComments() {\n+        return (comments == null) ? null : comments.clone();\n+    }\n+\n+    \/**\n+     * Returns a copy of the data section containing serialized constants for the emitted machine code.\n+     *\/\n+    public byte[] getDataSection() {\n+        return (dataSection == null) ? null : dataSection.clone();\n+    }\n+\n+    \/**\n+     * Gets the minimum alignment of the data section.\n+     *\/\n+    public int getDataSectionAlignment() {\n+        return dataSectionAlignment;\n+    }\n+\n+    \/**\n+     * Returns a copy of the {@link #dataSection} relocations.\n+     *\/\n+    public DataPatch[] getDataSectionPatches() {\n+        return (dataSectionPatches == null) ? null : dataSectionPatches.clone();\n+    }\n+\n+    \/**\n+     * Checks if this compiled code is immutable and position independent.\n+     *\/\n+    public boolean isImmutablePIC() {\n+        return isImmutablePIC;\n+    }\n+\n+    \/**\n+     * Gets the total size of the stack frame of this compiled method.\n+     *\/\n+    public int getTotalFrameSize() {\n+        return totalFrameSize;\n+    }\n+\n+    \/**\n+     * Gets the deoptimization rescue slot associated with this compiled code.\n+     *\/\n+    public StackSlot getDeoptRescueSlot() {\n+        return deoptRescueSlot;\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotCompiledCode.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -121,0 +121,40 @@\n+    \/**\n+     * Returns the method to which this compiled nmethod belongs.\n+     *\/\n+    public HotSpotResolvedJavaMethod getMethod() {\n+        return method;\n+    }\n+\n+    \/**\n+     * Returns the bytecode index (BCI) in the {@link #getMethod() method} that is the beginning of this compiled\n+     * nmethod. -1 denotes the beginning of the method.\n+     *\n+     * @return the entry BCI of this nmethod or -1 if the entry is the method's beginning\n+     *\/\n+    public int getEntryBCI() {\n+        return entryBCI;\n+    }\n+\n+    \/**\n+     * Returns the identifier of the compilation request.\n+     *\/\n+    public int getId() {\n+        return id;\n+    }\n+\n+    \/**\n+     * Returns the address of a native {@code JVMCICompileState} object associated with this compiled nmethod.\n+     * If no such object exists, it returns 0L.\n+     *\n+     * @return the address of the native {@code JVMCICompileState} object or 0L if it does not exist\n+     *\/\n+    public long getCompileState() {\n+        return compileState;\n+    }\n+\n+    \/**\n+     * Checks if this compiled nmethod has a memory access via the {@code Unsafe} class.\n+     *\/\n+    public boolean hasUnsafeAccess() {\n+        return hasUnsafeAccess;\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotCompiledNmethod.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    public final String getName() {\n+    public String getName() {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJavaType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-abstract class HotSpotMethod implements JavaMethod, Formattable {\n+public abstract class HotSpotMethod implements JavaMethod, Formattable {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-import java.lang.invoke.CallSite;\n-import java.util.Objects;\n-\n@@ -33,0 +30,4 @@\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.ConstantCallSite;\n+import java.util.Objects;\n+\n@@ -64,1 +65,20 @@\n-    JavaConstant getCallSiteTarget(Assumptions assumptions);\n+    default JavaConstant getCallSiteTarget(Assumptions assumptions) {\n+        Assumptions.AssumptionResult<JavaConstant> result = getCallSiteTarget();\n+        if (!result.canRecordTo(assumptions)) {\n+            return null;\n+        }\n+        result.recordTo(assumptions);\n+        return result.getResult();\n+    }\n+\n+    \/**\n+     * Gets the result of {@link CallSite#getTarget()} for the {@link CallSite} object represented\n+     * by this constant. The target is bound to an assumption if this is not a fully initialized\n+     * {@link ConstantCallSite}.\n+     *\n+     * @return a call-site target (possibly bound to an assumption) or {@code null} if this constant\n+     * does not represent a {@link CallSite} object\n+     *\/\n+    default Assumptions.AssumptionResult<JavaConstant> getCallSiteTarget() {\n+        throw new UnsupportedOperationException(\"getCallSiteTarget\");\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotObjectConstant.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-    public JavaConstant getCallSiteTarget(Assumptions assumptions) {\n+    public Assumptions.AssumptionResult<JavaConstant> getCallSiteTarget() {\n@@ -97,4 +97,1 @@\n-                return readTarget();\n-            }\n-            if (assumptions == null) {\n-                return null;\n+                return new Assumptions.AssumptionResult<>(readTarget());\n@@ -103,2 +100,1 @@\n-            assumptions.record(new Assumptions.CallSiteTargetValue(this, result));\n-            return result;\n+            return new Assumptions.AssumptionResult<>(result, new Assumptions.CallSiteTargetValue(this, result));\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotObjectConstantImpl.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-    HotSpotResolvedObjectTypeImpl arrayOfType;\n+    HotSpotResolvedObjectType arrayOfType;\n@@ -35,1 +35,1 @@\n-    HotSpotResolvedJavaType(String name) {\n+    protected HotSpotResolvedJavaType(String name) {\n@@ -43,1 +43,1 @@\n-    public final int hashCode() {\n+    public int hashCode() {\n@@ -47,1 +47,4 @@\n-    abstract JavaConstant getJavaMirror();\n+    \/**\n+     * Gets the runtime representation of the {@link Class} object of this type.\n+     *\/\n+    public abstract JavaConstant getJavaMirror();\n@@ -49,1 +52,4 @@\n-    abstract HotSpotResolvedObjectTypeImpl getArrayType();\n+    \/**\n+     * Gets the array type of this type without caching the result.\n+     *\/\n+    protected abstract HotSpotResolvedObjectType getArrayType();\n@@ -52,1 +58,1 @@\n-    public final HotSpotResolvedObjectType getArrayClass() {\n+    public HotSpotResolvedObjectType getArrayClass() {\n@@ -66,1 +72,1 @@\n-    abstract boolean isBeingInitialized();\n+    protected abstract boolean isBeingInitialized();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaType.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -83,0 +83,7 @@\n+    \/**\n+     * Gets the runtime representation of the {@link Class} object of this type.\n+     *\/\n+    default JavaConstant getJavaMirror() {\n+        throw new UnsupportedOperationException(\"getJavaMirror\");\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectType.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -675,1 +675,1 @@\n-    JavaConstant getJavaMirror() {\n+    public JavaConstant getJavaMirror() {\n@@ -680,1 +680,1 @@\n-    HotSpotResolvedObjectTypeImpl getArrayType() {\n+    protected HotSpotResolvedObjectTypeImpl getArrayType() {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,1 +64,7 @@\n-    static HotSpotResolvedPrimitiveType forKind(JavaKind kind) {\n+    \/**\n+     * Returns a primitive type instance corresponding to the given {@link JavaKind}.\n+     *\n+     * @param kind the Java kind of the primitive type\n+     * @return the primitive type instance for the given Java kind\n+     *\/\n+    public static HotSpotResolvedPrimitiveType forKind(JavaKind kind) {\n@@ -87,1 +93,1 @@\n-    HotSpotResolvedObjectTypeImpl getArrayType() {\n+    protected HotSpotResolvedObjectType getArrayType() {\n@@ -324,1 +330,1 @@\n-    JavaConstant getJavaMirror() {\n+    public JavaConstant getJavaMirror() {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedPrimitiveType.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -133,1 +134,1 @@\n-        HotSpotSpeculation(SpeculationReason reason, JavaConstant id, byte[] encoding) {\n+        public HotSpotSpeculation(SpeculationReason reason, JavaConstant id, byte[] encoding) {\n@@ -143,0 +144,7 @@\n+        \/**\n+         * Returns a copy of the speculation reason encoding.\n+         *\/\n+        public byte[] getReasonEncoding() {\n+            return (encoding == null) ? null : encoding.clone();\n+        }\n+\n@@ -150,0 +158,14 @@\n+\n+        @Override\n+        public boolean equals(Object object) {\n+            if (object instanceof HotSpotSpeculation that) {\n+                return getReason().equals(that.getReason()) && id.equals(that.id) && Arrays.equals(encoding, that.encoding);\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(getReason(), id, Arrays.hashCode(encoding));\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotSpeculationLog.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-    private VMField getField(String name, String cppType, boolean required) {\n+    public VMField getField(String name, String cppType, boolean required) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfigAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    VMField(String name, String type, long offset, long address, Object value) {\n+    public VMField(String name, String type, long offset, long address, Object value) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/VMField.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,0 +116,21 @@\n+\n+    \/**\n+     * Returns the group ID of this speculation reason.\n+     *\/\n+    public int getGroupId() {\n+        return groupId;\n+    }\n+\n+    \/**\n+     * Returns the group name of this speculation reason.\n+     *\/\n+    public String getGroupName() {\n+        return groupName;\n+    }\n+\n+    \/**\n+     * Returns a copy of the array of context objects.\n+     *\/\n+    public Object[] getContext() {\n+        return (context == null) ? null : context.clone();\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/EncodedSpeculationReason.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}