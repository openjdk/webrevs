[{"commit":{"message":"8212084\n\nHi all,\n\n  please review these changes to implement the `UseGCOverheadLimit` functionality for G1 (and make the implementation for Parallel GC have similar output).\n\nThe `UseGCOverheadLimit` feature prematurely returns `null` from a GC if GC cpu usage limits and heap usage limits are met for some time. This is to avoid a VM limping along if garbage collection gets into an endless cycle of garbage collections or until a \"real\" OOME is thrown.\n\nWhat is important here is how this works (derived from the Parallel GC implementation):\n\n* check overheads at the end of the (initial) garbage collection (before upgrading) to see whether we are over the limits for a successive amount of GCs.\n* keep doing GCs without actually allocating memory for the allocation request to keep on measuring gc CPU usage. This is important for measuring the correct cpu usage in case of the application being able to free memory on the OOME.\n\nTesting: tier1-5 without any OOMEs due to this feature, test case\n\nThanks,\n  Thomas"},"files":[{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp"},{"filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.cpp"},{"filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp"},{"filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp"},{"filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp"},{"filename":"test\/hotspot\/jtreg\/gc\/TestUseGCOverheadLimit.java"}],"sha":"389e5a269d48fe82fde900a74fbdb1ca56153c27"}]