{"files":[{"patch":"@@ -121,0 +121,1 @@\n+uintx G1CollectedHeap::_gc_overhead_counter = 0;\n@@ -470,0 +471,12 @@\n+    if (is_shutting_down()) {\n+      stall_for_vm_shutdown();\n+      return nullptr;\n+    }\n+\n+    \/\/ Has the gc overhead limit been reached in the meantime? If so, this mutator\n+    \/\/ should receive null even when unsuccessfully scheduling a collection as well\n+    \/\/ for global consistency.\n+    if (gc_overhead_limit_exceeded()) {\n+      return nullptr;\n+    }\n+\n@@ -471,1 +484,1 @@\n-    \/\/ another thread beat us to it). In this case immeditealy retry the allocation\n+    \/\/ another thread beat us to it). In this case immediately retry the allocation\n@@ -488,5 +501,0 @@\n-\n-    if (is_shutting_down()) {\n-      stall_for_vm_shutdown();\n-      return nullptr;\n-    }\n@@ -717,0 +725,12 @@\n+    if (is_shutting_down()) {\n+      stall_for_vm_shutdown();\n+      return nullptr;\n+    }\n+\n+    \/\/ Has the gc overhead limit been reached in the meantime? If so, this mutator\n+    \/\/ should receive null even when unsuccessfully scheduling a collection as well\n+    \/\/ for global consistency.\n+    if (gc_overhead_limit_exceeded()) {\n+      return nullptr;\n+    }\n+\n@@ -728,5 +748,0 @@\n-\n-    if (is_shutting_down()) {\n-      stall_for_vm_shutdown();\n-      return nullptr;\n-    }\n@@ -958,0 +973,26 @@\n+void G1CollectedHeap::update_gc_overhead_limit_exceeded() {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n+\n+  if (UseGCOverheadLimit) {\n+    bool gc_time_over_limit = (_policy->analytics()->long_term_gc_time_ratio() * 100) >= GCTimeLimit;\n+    double free_space_percent = percent_of(num_available_regions() * G1HeapRegion::GrainBytes, max_capacity());\n+    bool free_space_below_limit = free_space_percent < GCHeapFreeLimit;\n+\n+    log_debug(gc)(\"GC Overhead Limit: GC Time %f Free Space %f Counter %zu\",\n+                  (_policy->analytics()->long_term_gc_time_ratio() * 100),\n+                  free_space_percent,\n+                  _gc_overhead_counter);\n+\n+    if (gc_time_over_limit && free_space_below_limit) {\n+      _gc_overhead_counter++;\n+      return;\n+    } else {\n+      _gc_overhead_counter = 0;\n+    }\n+  }\n+}\n+\n+bool G1CollectedHeap::gc_overhead_limit_exceeded() {\n+  return _gc_overhead_counter >= GCOverheadLimitThreshold;\n+}\n+\n@@ -962,7 +1003,16 @@\n-  \/\/ Let's attempt the allocation first.\n-  HeapWord* result =\n-    attempt_allocation_at_safepoint(word_size,\n-                                    expect_null_mutator_alloc_region);\n-  if (result != nullptr) {\n-    return result;\n-  }\n+  \/\/ Skip allocation if GC overhead limit has been exceeded to let the mutator run\n+  \/\/ into an OOME. It can either exit \"gracefully\" or try to free up memory asap.\n+  \/\/ For the latter situation, keep running GCs. If the mutator frees up enough\n+  \/\/ memory quickly enough, the overhead(s) will go below the threshold(s) again\n+  \/\/ and the VM may continue running.\n+  \/\/ If we did not continue garbage collections, the (gc overhead) limit may decrease\n+  \/\/ enough by itself to not count as exceeding the limit any more, in the worst\n+  \/\/ case bouncing back-and-forth all the time.\n+  if (!gc_overhead_limit_exceeded()) {\n+    \/\/ Let's attempt the allocation first.\n+    HeapWord* result =\n+      attempt_allocation_at_safepoint(word_size,\n+                                      expect_null_mutator_alloc_region);\n+    if (result != nullptr) {\n+      return result;\n+    }\n@@ -970,7 +1020,8 @@\n-  \/\/ In a G1 heap, we're supposed to keep allocation from failing by\n-  \/\/ incremental pauses.  Therefore, at least for now, we'll favor\n-  \/\/ expansion over collection.  (This might change in the future if we can\n-  \/\/ do something smarter than full collection to satisfy a failed alloc.)\n-  result = expand_and_allocate(word_size);\n-  if (result != nullptr) {\n-    return result;\n+    \/\/ In a G1 heap, we're supposed to keep allocation from failing by\n+    \/\/ incremental pauses.  Therefore, at least for now, we'll favor\n+    \/\/ expansion over collection.  (This might change in the future if we can\n+    \/\/ do something smarter than full collection to satisfy a failed alloc.)\n+    result = expand_and_allocate(word_size);\n+    if (result != nullptr) {\n+      return result;\n+    }\n@@ -1000,0 +1051,4 @@\n+  \/\/ Update GC overhead limits after the initial garbage collection leading to this\n+  \/\/ allocation attempt.\n+  update_gc_overhead_limit_exceeded();\n+\n@@ -1031,0 +1086,4 @@\n+  if (gc_overhead_limit_exceeded()) {\n+    log_info(gc)(\"GC Overhead Limit exceeded too often (%zu).\", GCOverheadLimitThreshold);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":84,"deletions":25,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -172,0 +172,11 @@\n+  \/\/ GC Overhead Limit functionality related members.\n+  \/\/\n+  \/\/ The goal is to return null for allocations prematurely (before really going\n+  \/\/ OOME) in case both GC CPU usage (>= GCTimeLimit) and not much available free\n+  \/\/ memory (<= GCHeapFreeLimit) so that applications can exit gracefully or try\n+  \/\/ to keep running by easing off memory.\n+  static uintx _gc_overhead_counter;        \/\/ The amount of successive times we were over the limits.\n+\n+  void update_gc_overhead_limit_exceeded();\n+  static bool gc_overhead_limit_exceeded();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -69,5 +69,0 @@\n-  \/\/ True in product build, since tests using debug build often stress GC\n-  if (FLAG_IS_DEFAULT(UseGCOverheadLimit)) {\n-    FLAG_SET_DEFAULT(UseGCOverheadLimit, trueInProduct);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -377,0 +377,7 @@\n+\n+    log_debug(gc)(\"GC Overhead Limit: GC Time %f Free Space Young %f Old %f Counter %zu\",\n+                  (100 - _size_policy->mutator_time_percent()),\n+                  percent_of(_young_gen->free_in_bytes(), _young_gen->capacity_in_bytes()),\n+                  percent_of(_old_gen->free_in_bytes(), _young_gen->capacity_in_bytes()),\n+                  _gc_overhead_counter);\n+\n@@ -429,1 +436,1 @@\n-    log_info(gc)(\"GCOverheadLimitThreshold %zu reached.\", GCOverheadLimitThreshold);\n+    log_info(gc)(\"GC Overhead Limit exceeded too often (%zu).\", GCOverheadLimitThreshold);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  uint _gc_overhead_counter;\n+  uintx _gc_overhead_counter;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-  product(bool, UseGCOverheadLimit, true,                                   \\\n+  product(bool, UseGCOverheadLimit, falseInDebug,                           \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc;\n+\n+\/*\n+ * @test id=Parallel\n+ * @requires vm.gc.Parallel\n+ * @requires !vm.debug\n+ * @summary Verifies that the UseGCOverheadLimit functionality works in Parallel GC.\n+ * @library \/test\/lib\n+ * @run driver gc.TestUseGCOverheadLimit Parallel\n+ *\/\n+\n+\/*\n+ * @test id=G1\n+ * @requires vm.gc.G1\n+ * @requires !vm.debug\n+ * @summary Verifies that the UseGCOverheadLimit functionality works in G1 GC.\n+ * @library \/test\/lib\n+ * @run driver gc.TestUseGCOverheadLimit G1\n+ *\/\n+\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestUseGCOverheadLimit {\n+  public static void main(String args[]) throws Exception {\n+    String[] parallelArgs = {\n+      \"-XX:+UseParallelGC\",\n+      \"-XX:NewSize=122m\",\n+      \"-XX:SurvivorRatio=99\",\n+      \"-XX:GCHeapFreeLimit=10\"\n+    };\n+    String[] g1Args = {\n+      \"-XX:+UseG1GC\",\n+      \"-XX:GCHeapFreeLimit=5\"\n+    };\n+\n+    String[] selectedArgs = args[0].equals(\"G1\") ? g1Args : parallelArgs;\n+\n+    final String[] commonArgs = {\n+      \"-XX:-UseCompactObjectHeaders\", \/\/ Object sizes are calculated such that the heap is tight.\n+      \"-XX:ParallelGCThreads=1\",      \/\/ Make GCs take longer.\n+      \"-XX:+UseGCOverheadLimit\",\n+      \"-Xlog:gc=debug\",\n+      \"-XX:GCTimeLimit=90\",           \/\/ Ease the CPU requirement a little.\n+      \"-Xmx128m\",\n+      Allocating.class.getName()\n+    };\n+\n+    String[] vmArgs = Stream.concat(Arrays.stream(selectedArgs), Arrays.stream(commonArgs)).toArray(String[]::new);\n+    OutputAnalyzer output = ProcessTools.executeLimitedTestJava(vmArgs);\n+    output.shouldNotHaveExitValue(0);\n+\n+    System.out.println(output.getStdout());\n+\n+    output.stdoutShouldContain(\"GC Overhead Limit exceeded too often (5).\");\n+  }\n+\n+  static class Allocating {\n+    public static void main(String[] args) {\n+      Object[] cache = new Object[1024 * 1024 * 2];\n+\n+      \/\/ Allocate random objects, keeping around data, causing garbage\n+      \/\/ collections.\n+      for (int i = 0; i < 1024* 1024 * 30; i++) {\n+        Object[] obj = new Object[10];\n+        cache[i % cache.length] = obj;\n+      }\n+\n+      System.out.println(cache);\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/TestUseGCOverheadLimit.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"}]}