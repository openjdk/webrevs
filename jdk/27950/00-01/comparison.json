{"files":[{"patch":"@@ -476,2 +476,2 @@\n-    \/\/ Was the gc-overhead reached inside the safepoint? If so, this mutator\n-    \/\/ should return null even when unsuccessfully scheduling a collection as well\n+    \/\/ Has the gc overhead limit been reached in the meantime? If so, this mutator\n+    \/\/ should receive null even when unsuccessfully scheduling a collection as well\n@@ -730,2 +730,3 @@\n-    \/\/ Was the gc-overhead reached inside the safepoint? If so, this mutator\n-    \/\/ should return null as well for global consistency.\n+    \/\/ Has the gc overhead limit been reached in the meantime? If so, this mutator\n+    \/\/ should receive null even when unsuccessfully scheduling a collection as well\n+    \/\/ for global consistency.\n@@ -976,1 +977,1 @@\n-    bool little_mutator_time = (_policy->analytics()->long_term_gc_time_ratio() * 100) >= GCTimeLimit;\n+    bool gc_time_over_limit = (_policy->analytics()->long_term_gc_time_ratio() * 100) >= GCTimeLimit;\n@@ -978,1 +979,1 @@\n-    bool little_free_space = free_space_percent < GCHeapFreeLimit;\n+    bool free_space_below_limit = free_space_percent < GCHeapFreeLimit;\n@@ -985,1 +986,1 @@\n-    if (little_mutator_time && little_free_space) {\n+    if (gc_time_over_limit && free_space_below_limit) {\n@@ -1002,2 +1003,2 @@\n-  \/\/ Skip allocation if GC overhead has been exceeded to let the mutator run into\n-  \/\/ an OOME. It can either exit \"gracefully\" or try to free up memory asap.\n+  \/\/ Skip allocation limit if GC overhead has been exceeded to let the mutator run\n+  \/\/ into an OOME. It can either exit \"gracefully\" or try to free up memory asap.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import jdk.test.lib.Asserts;\n@@ -82,2 +81,1 @@\n-    Asserts.assertTrue(output.getStdout().indexOf(\"GC Overhead Limit exceeded too often (5).\") != -1,\n-                       \"Could not find indication that we failed because of GC overhead limit.\");\n+    output.stdoutShouldContain(\"GC Overhead Limit exceeded too often (5).\");\n@@ -90,1 +88,2 @@\n-      \/\/ Allocate random objects, keeping around most of the data.\n+      \/\/ Allocate random objects, keeping around data, causing garbage\n+      \/\/ collections.\n","filename":"test\/hotspot\/jtreg\/gc\/TestUseGCOverheadLimit.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}