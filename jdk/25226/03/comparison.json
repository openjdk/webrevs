{"files":[{"patch":"@@ -64,1 +64,1 @@\n-  bool match_mode_flag(MallocLimitMode* out) {\n+  bool match_mode(MallocLimitMode* out) {\n@@ -80,1 +80,1 @@\n-  \/\/ Check if string at position matches a category name.\n+  \/\/ Check if string at position matches a MemTag name.\n@@ -82,1 +82,1 @@\n-  bool match_category(MemTag* out) {\n+  bool match_mem_tag(MemTag* out) {\n@@ -133,1 +133,1 @@\n-void MallocLimitSet::set_category_limit(MemTag mem_tag, size_t s, MallocLimitMode flag) {\n+void MallocLimitSet::set_mem_tag_limit(MemTag mem_tag, size_t s, MallocLimitMode mode) {\n@@ -135,1 +135,1 @@\n-  _cat[i].sz = s; _cat[i].mode = flag;\n+  _mtag[i].sz = s; _mtag[i].mode = mode;\n@@ -142,1 +142,1 @@\n-    set_category_limit(NMTUtil::index_to_tag(i), 0, MallocLimitMode::trigger_fatal);\n+    set_mem_tag_limit(NMTUtil::index_to_tag(i), 0, MallocLimitMode::trigger_fatal);\n@@ -147,1 +147,0 @@\n-  static const char* flagnames[] = { MODE_FATAL, MODE_OOM };\n@@ -153,1 +152,1 @@\n-      if (_cat[i].sz > 0) {\n+      if (_mtag[i].sz > 0) {\n@@ -156,1 +155,1 @@\n-                     PROPERFMTARGS(_cat[i].sz), mode_to_name(_cat[i].mode));\n+                     PROPERFMTARGS(_mtag[i].sz), mode_to_name(_mtag[i].mode));\n@@ -167,1 +166,1 @@\n-  \/\/ MallocLimit=<size>[:flag]\n+  \/\/ MallocLimit=<size>[:mode]\n@@ -169,2 +168,2 @@\n-  \/\/ Category-specific form:\n-  \/\/ MallocLimit=<category>:<size>[:flag][,<category>:<size>[:flag]...]\n+  \/\/ MemTag-specific form:\n+  \/\/ MallocLimit=<mem-tag>:<size>[:mode][,<mem-tag>:<size>[:mode]...]\n@@ -180,1 +179,1 @@\n-    \/\/ Match optional mode flag (e.g. 1g:oom)\n+    \/\/ Match optional mode  (e.g. 1g:oom)\n@@ -183,1 +182,1 @@\n-      BAIL_UNLESS(sst.match_mode_flag(&_glob.mode), \"Expected flag\");\n+      BAIL_UNLESS(sst.match_mode(&_glob.mode), \"Expected mode\");\n@@ -186,1 +185,1 @@\n-  \/\/ Category-specific form?\n+  \/\/ MemTag-specific form?\n@@ -191,2 +190,2 @@\n-      \/\/ Match category, followed by :\n-      BAIL_UNLESS(sst.match_category(&mem_tag), \"Expected category name\");\n+      \/\/ Match MemTag, followed by :\n+      BAIL_UNLESS(sst.match_mem_tag(&mem_tag), \"Expected category name\");\n@@ -195,1 +194,1 @@\n-      malloclimit* const modified_limit = &_cat[NMTUtil::tag_to_index(mem_tag)];\n+      malloclimit* const modified_limit = &_mtag[NMTUtil::tag_to_index(mem_tag)];\n@@ -200,1 +199,1 @@\n-      \/\/ Match optional flag\n+      \/\/ Match optional mode\n@@ -202,1 +201,1 @@\n-        BAIL_UNLESS(sst.match_mode_flag(&modified_limit->mode), \"Expected flag\");\n+        BAIL_UNLESS(sst.match_mode(&modified_limit->mode), \"Expected mode\");\n","filename":"src\/hotspot\/share\/nmt\/mallocLimit.cpp","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-  malloclimit _cat[mt_number_of_tags]; \/\/ per-category limit\n+  malloclimit _mtag[mt_number_of_tags]; \/\/ per-memtag limit\n@@ -57,1 +57,1 @@\n-  void set_category_limit(MemTag mem_tag, size_t s, MallocLimitMode mode);\n+  void set_mem_tag_limit(MemTag mem_tag, size_t s, MallocLimitMode mode);\n@@ -60,1 +60,1 @@\n-  const malloclimit* category_limit(MemTag mem_tag) const { return &_cat[(int)mem_tag]; }\n+  const malloclimit* mem_tag_limit(MemTag mem_tag) const { return &_mtag[(int)mem_tag]; }\n@@ -72,1 +72,1 @@\n-  static const malloclimit* category_limit(MemTag mem_tag) { return _limits.category_limit(mem_tag); }\n+  static const malloclimit* mem_tag_limit(MemTag mem_tag) { return _limits.mem_tag_limit(mem_tag); }\n","filename":"src\/hotspot\/share\/nmt\/mallocLimit.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-bool MallocMemorySummary::category_limit_reached(MemTag mem_tag, size_t s, size_t so_far, const malloclimit* limit) {\n+bool MallocMemorySummary::mem_tag_limit_reached(MemTag mem_tag, size_t s, size_t so_far, const malloclimit* limit) {\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-  static bool category_limit_reached(MemTag mem_tag, size_t s, size_t so_far, const malloclimit* limit);\n+  static bool mem_tag_limit_reached(MemTag mem_tag, size_t s, size_t so_far, const malloclimit* limit);\n@@ -258,1 +258,1 @@\n-  \/\/ either global or the category limit\n+  \/\/ either global or the MemTag limit\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-\/\/ Returns true if allocating s bytes on f would trigger either global or the category limit\n+\/\/ Returns true if allocating s bytes on f would trigger either global or the MemTag limit\n@@ -52,2 +52,2 @@\n-      \/\/ Category Limit?\n-      l = MallocLimitHandler::category_limit(mem_tag);\n+      \/\/ MemTag Limit?\n+      l = MallocLimitHandler::mem_tag_limit(mem_tag);\n@@ -58,1 +58,1 @@\n-          return category_limit_reached(mem_tag, s, so_far, l);\n+          return mem_tag_limit_reached(mem_tag, s, so_far, l);\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-      if (!compare_limits(a->category_limit(NMTUtil::index_to_tag(i)),\n-                          b->category_limit(NMTUtil::index_to_tag(i)))) {\n+      if (!compare_limits(a->mem_tag_limit(NMTUtil::index_to_tag(i)),\n+                          b->mem_tag_limit(NMTUtil::index_to_tag(i)))) {\n@@ -79,1 +79,1 @@\n-TEST(NMT, MallocLimitPerCategory) {\n+TEST(NMT, MallocLimitPerMemTag) {\n@@ -82,1 +82,1 @@\n-  expected.set_category_limit(mtMetaspace, 1 * M, MallocLimitMode::trigger_fatal);\n+  expected.set_mem_tag_limit(mtMetaspace, 1 * M, MallocLimitMode::trigger_fatal);\n@@ -87,5 +87,5 @@\n-  expected.set_category_limit(mtCompiler, 2 * M, MallocLimitMode::trigger_oom);\n-  expected.set_category_limit(mtThread, 3 * M, MallocLimitMode::trigger_oom);\n-  expected.set_category_limit(mtThreadStack, 4 * M, MallocLimitMode::trigger_oom);\n-  expected.set_category_limit(mtClass, 5 * M, MallocLimitMode::trigger_fatal);\n-  expected.set_category_limit(mtClassShared, 6 * M, MallocLimitMode::trigger_fatal);\n+  expected.set_mem_tag_limit(mtCompiler, 2 * M, MallocLimitMode::trigger_oom);\n+  expected.set_mem_tag_limit(mtThread, 3 * M, MallocLimitMode::trigger_oom);\n+  expected.set_mem_tag_limit(mtThreadStack, 4 * M, MallocLimitMode::trigger_oom);\n+  expected.set_mem_tag_limit(mtClass, 5 * M, MallocLimitMode::trigger_fatal);\n+  expected.set_mem_tag_limit(mtClassShared, 6 * M, MallocLimitMode::trigger_fatal);\n@@ -95,1 +95,1 @@\n-TEST(NMT, MallocLimitCategoryEnumNames) {\n+TEST(NMT, MallocLimitMemTagEnumNames) {\n@@ -101,1 +101,1 @@\n-      expected.set_category_limit(mem_tag, (i + 1) * M, MallocLimitMode::trigger_fatal);\n+      expected.set_mem_tag_limit(mem_tag, (i + 1) * M, MallocLimitMode::trigger_fatal);\n@@ -114,1 +114,1 @@\n-      expected.set_category_limit(mem_tag, (i + 1) * M, MallocLimitMode::trigger_fatal);\n+      expected.set_mem_tag_limit(mem_tag, (i + 1) * M, MallocLimitMode::trigger_fatal);\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_malloclimit.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -90,3 +90,3 @@\n-    \/\/ spread over categories\n-    int category = i % (mt_number_of_tags - 1);\n-    p[i] = NEW_C_HEAP_ARRAY(char, ALLOC_SIZE, (MemTag)category);\n+    \/\/ spread over mem-tags\n+    int mtag = i % (mt_number_of_tags - 1);\n+    p[i] = NEW_C_HEAP_ARRAY(char, ALLOC_SIZE, (MemTag)mtag);\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_totals.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}