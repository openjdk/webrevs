{"files":[{"patch":"@@ -64,1 +64,1 @@\n-  bool match_mode_flag(MallocLimitMode* out) {\n+  bool match_mode(MallocLimitMode* out) {\n@@ -80,1 +80,1 @@\n-  \/\/ Check if string at position matches a category name.\n+  \/\/ Check if string at position matches a MemTag name.\n@@ -82,1 +82,1 @@\n-  bool match_category(MemTag* out) {\n+  bool match_mem_tag(MemTag* out) {\n@@ -133,1 +133,1 @@\n-void MallocLimitSet::set_category_limit(MemTag mem_tag, size_t s, MallocLimitMode flag) {\n+void MallocLimitSet::set_category_limit(MemTag mem_tag, size_t s, MallocLimitMode mode) {\n@@ -135,1 +135,1 @@\n-  _cat[i].sz = s; _cat[i].mode = flag;\n+  _mtag[i].sz = s; _mtag[i].mode = mode;\n@@ -147,1 +147,0 @@\n-  static const char* flagnames[] = { MODE_FATAL, MODE_OOM };\n@@ -153,1 +152,1 @@\n-      if (_cat[i].sz > 0) {\n+      if (_mtag[i].sz > 0) {\n@@ -156,1 +155,1 @@\n-                     PROPERFMTARGS(_cat[i].sz), mode_to_name(_cat[i].mode));\n+                     PROPERFMTARGS(_mtag[i].sz), mode_to_name(_mtag[i].mode));\n@@ -167,1 +166,1 @@\n-  \/\/ MallocLimit=<size>[:flag]\n+  \/\/ MallocLimit=<size>[:mode]\n@@ -169,2 +168,2 @@\n-  \/\/ Category-specific form:\n-  \/\/ MallocLimit=<category>:<size>[:flag][,<category>:<size>[:flag]...]\n+  \/\/ MemTag-specific form:\n+  \/\/ MallocLimit=<mem-tag>:<size>[:mode][,<mem-tag>:<size>[:mode]...]\n@@ -180,1 +179,1 @@\n-    \/\/ Match optional mode flag (e.g. 1g:oom)\n+    \/\/ Match optional mode  (e.g. 1g:oom)\n@@ -183,1 +182,1 @@\n-      BAIL_UNLESS(sst.match_mode_flag(&_glob.mode), \"Expected flag\");\n+      BAIL_UNLESS(sst.match_mode(&_glob.mode), \"Expected mode\");\n@@ -186,1 +185,1 @@\n-  \/\/ Category-specific form?\n+  \/\/ MemTag-specific form?\n@@ -191,2 +190,2 @@\n-      \/\/ Match category, followed by :\n-      BAIL_UNLESS(sst.match_category(&mem_tag), \"Expected category name\");\n+      \/\/ Match MemTag, followed by :\n+      BAIL_UNLESS(sst.match_mem_tag(&mem_tag), \"Expected category name\");\n@@ -195,1 +194,1 @@\n-      malloclimit* const modified_limit = &_cat[NMTUtil::tag_to_index(mem_tag)];\n+      malloclimit* const modified_limit = &_mtag[NMTUtil::tag_to_index(mem_tag)];\n@@ -200,1 +199,1 @@\n-      \/\/ Match optional flag\n+      \/\/ Match optional mode\n@@ -202,1 +201,1 @@\n-        BAIL_UNLESS(sst.match_mode_flag(&modified_limit->mode), \"Expected flag\");\n+        BAIL_UNLESS(sst.match_mode(&modified_limit->mode), \"Expected mode\");\n","filename":"src\/hotspot\/share\/nmt\/mallocLimit.cpp","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-  malloclimit _cat[mt_number_of_tags]; \/\/ per-category limit\n+  malloclimit _mtag[mt_number_of_tags]; \/\/ per-memtag limit\n@@ -60,1 +60,1 @@\n-  const malloclimit* category_limit(MemTag mem_tag) const { return &_cat[(int)mem_tag]; }\n+  const malloclimit* mem_tag_limit(MemTag mem_tag) const { return &_mtag[(int)mem_tag]; }\n@@ -72,1 +72,1 @@\n-  static const malloclimit* category_limit(MemTag mem_tag) { return _limits.category_limit(mem_tag); }\n+  static const malloclimit* mem_tag_limit(MemTag mem_tag) { return _limits.mem_tag_limit(mem_tag); }\n","filename":"src\/hotspot\/share\/nmt\/mallocLimit.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-      \/\/ Category Limit?\n-      l = MallocLimitHandler::category_limit(mem_tag);\n+      \/\/ MemTag Limit?\n+      l = MallocLimitHandler::mem_tag_limit(mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-      if (!compare_limits(a->category_limit(NMTUtil::index_to_tag(i)),\n-                          b->category_limit(NMTUtil::index_to_tag(i)))) {\n+      if (!compare_limits(a->mem_tag_limit(NMTUtil::index_to_tag(i)),\n+                          b->mem_tag_limit(NMTUtil::index_to_tag(i)))) {\n@@ -95,1 +95,1 @@\n-TEST(NMT, MallocLimitCategoryEnumNames) {\n+TEST(NMT, MallocLimitMemTagEnumNames) {\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_malloclimit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -91,2 +91,2 @@\n-    int category = i % (mt_number_of_tags - 1);\n-    p[i] = NEW_C_HEAP_ARRAY(char, ALLOC_SIZE, (MemTag)category);\n+    int mtag = i % (mt_number_of_tags - 1);\n+    p[i] = NEW_C_HEAP_ARRAY(char, ALLOC_SIZE, (MemTag)mtag);\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_totals.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}