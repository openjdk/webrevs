{"files":[{"patch":"@@ -3023,1 +3023,1 @@\n-  CodeBuffer buffer(name, 2348, 1024);\n+  CodeBuffer buffer(name, 2548, 1024);\n@@ -3089,1 +3089,1 @@\n-    Label no_prefix, not_special;\n+    Label no_prefix, not_special, check_rex_prefix;\n@@ -3093,1 +3093,1 @@\n-    __ jccb(Assembler::notEqual, no_adjust);\n+    __ jcc(Assembler::notEqual, no_adjust);\n@@ -3116,1 +3116,21 @@\n-\n+    \/\/\n+    \/\/ Notes:\n+    \/\/  Format of legacy MAP0 test instruction:-\n+    \/\/  [REX\/REX2] [OPCODE] [ModRM] [SIB] [DISP] [IMM32]\n+    \/\/  o  For safepoint polling instruction \"test %eax,(%rax)\", encoding of first register\n+    \/\/     operand and base register of memory operand is b\/w [0-8), hence we do not require\n+    \/\/     additional REX prefix where REX.B bit stores MSB bit of register encoding, which\n+    \/\/     is why two bytes encoding is sufficient here.\n+    \/\/  o  For safepoint polling instruction like \"test %eax,(%r8)\", register encoding of BASE\n+    \/\/     register of memory operand is 1000, thus we need additional REX prefix in this case,\n+    \/\/     there by adding additional byte to instruction encoding.\n+    \/\/  o  In case BASE register is one of the 32 extended GPR registers available only on targets\n+    \/\/     supporting Intel APX extension, then we need to emit two bytes REX2 prefix to hold\n+    \/\/     most significant two bits of 5 bit register encoding.\n+\n+    if (VM_Version::supports_apx_f()) {\n+      __ cmpb(Address(rbx, 0), Assembler::REX2);\n+      __ jccb(Assembler::notEqual, check_rex_prefix);\n+      __ addptr(rbx, 2);\n+      __ bind(check_rex_prefix);\n+    }\n@@ -3118,1 +3138,1 @@\n-    __ jcc(Assembler::notEqual, no_prefix);\n+    __ jccb(Assembler::notEqual, no_prefix);\n@@ -3131,1 +3151,1 @@\n-    __ jcc(Assembler::above, not_special);\n+    __ jccb(Assembler::above, not_special);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"}]}