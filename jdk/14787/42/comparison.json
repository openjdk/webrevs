{"files":[{"patch":"@@ -99,0 +99,4 @@\n+ifeq ($(JLINK_PRODUCE_LINKABLE_RUNTIME), true)\n+  JLINK_JDK_EXTRA_OPTS += --generate-linkable-runtime\n+endif\n+\n","filename":"make\/Images.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -589,1 +589,0 @@\n-# We always keep packaged modules in JDK image.\n@@ -593,1 +592,30 @@\n-  UTIL_ARG_ENABLE(NAME: keep-packaged-modules, DEFAULT: true,\n+\n+  ################################################################################\n+  #\n+  # Configure option for building a JDK that is suitable for linking from the\n+  # run-time image without JMODs.\n+  #\n+  # Determines whether or not a suitable run-time image is being produced from\n+  # packaged modules. If set to 'true, changes the *default* of packaged\n+  # modules to 'false'.\n+  #\n+  UTIL_ARG_ENABLE(NAME: linkable-runtime, DEFAULT: false,\n+      RESULT: JLINK_PRODUCE_LINKABLE_RUNTIME,\n+      DESC: [enable a JDK build suitable for linking from the run-time image],\n+      CHECKING_MSG: [whether or not a JDK suitable for linking from the run-time image should be produced])\n+  AC_SUBST(JLINK_PRODUCE_LINKABLE_RUNTIME)\n+\n+  if test \"x$JLINK_PRODUCE_LINKABLE_RUNTIME\" = xtrue; then\n+    DEFAULT_PACKAGED_MODULES=false\n+  else\n+    DEFAULT_PACKAGED_MODULES=true\n+  fi\n+\n+  ################################################################################\n+  #\n+  # Configure option for packaged modules\n+  #\n+  # We keep packaged modules in the JDK image unless --enable-linkable-runtime is\n+  # requested.\n+  #\n+  UTIL_ARG_ENABLE(NAME: keep-packaged-modules, DEFAULT: $DEFAULT_PACKAGED_MODULES,\n@@ -596,0 +624,1 @@\n+      DEFAULT_DESC: [enabled by default unless --enable-linkable-runtime is set],\n","filename":"make\/autoconf\/jdk-options.m4","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -710,0 +710,1 @@\n+JLINK_PRODUCE_LINKABLE_RUNTIME := @JLINK_PRODUCE_LINKABLE_RUNTIME@\n","filename":"make\/autoconf\/spec.gmk.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import static jdk.tools.jlink.internal.LinkableRuntimeImage.DIFF_PATTERN;\n+import static jdk.tools.jlink.internal.LinkableRuntimeImage.RESPATH_PATTERN;\n+\n@@ -28,0 +31,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -32,0 +36,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -35,0 +40,1 @@\n+import java.util.Collections;\n@@ -40,0 +46,1 @@\n+import java.util.Optional;\n@@ -46,0 +53,1 @@\n+import jdk.tools.jlink.internal.JRTArchive.ResourceFileEntry;\n@@ -47,0 +55,5 @@\n+import jdk.tools.jlink.internal.runtimelink.JimageDiffGenerator;\n+import jdk.tools.jlink.internal.runtimelink.JimageDiffGenerator.ImageResource;\n+import jdk.tools.jlink.internal.runtimelink.ResourceDiff;\n+import jdk.tools.jlink.internal.runtimelink.ResourcePoolReader;\n+import jdk.tools.jlink.internal.runtimelink.RuntimeImageLinkException;\n@@ -49,0 +62,1 @@\n+import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n@@ -50,0 +64,1 @@\n+import jdk.tools.jlink.plugin.ResourcePoolModule;\n@@ -71,0 +86,5 @@\n+    private static final byte[] EMPTY_RESOURCE_BYTES = new byte[] {};\n+\n+    private static final String JLINK_MOD_NAME = \"jdk.jlink\";\n+    private static final String RESPATH = \"\/\" + JLINK_MOD_NAME + \"\/\" + RESPATH_PATTERN;\n+    private static final String DIFF_PATH = \"\/\" + JLINK_MOD_NAME + \"\/\" + DIFF_PATTERN;\n@@ -73,10 +93,2 @@\n-    private ImageFileCreator(ImagePluginStack plugins) {\n-        this.plugins = Objects.requireNonNull(plugins);\n-    }\n-\n-    public static ExecutableImage create(Set<Archive> archives,\n-            ImagePluginStack plugins)\n-            throws IOException {\n-        return ImageFileCreator.create(archives, ByteOrder.nativeOrder(),\n-                plugins);\n-    }\n+    private final boolean generateRuntimeImage;\n+    private final TaskHelper helper;\n@@ -84,5 +96,6 @@\n-    public static ExecutableImage create(Set<Archive> archives,\n-            ByteOrder byteOrder)\n-            throws IOException {\n-        return ImageFileCreator.create(archives, byteOrder,\n-                new ImagePluginStack());\n+    private ImageFileCreator(ImagePluginStack plugins,\n+                             boolean generateRuntimeImage,\n+                             TaskHelper taskHelper) {\n+        this.plugins = Objects.requireNonNull(plugins);\n+        this.generateRuntimeImage = generateRuntimeImage;\n+        this.helper = taskHelper;\n@@ -91,0 +104,14 @@\n+    \/**\n+     * Create an executable image based on a set of input archives and a given\n+     * plugin stack for a given byte order. It optionally generates a runtime\n+     * that can be used for linking from the run-time image if\n+     * {@code generateRuntimeImage} is set to {@code true}.\n+     *\n+     * @param archives The set of input archives\n+     * @param byteOrder The desired byte order of the result\n+     * @param plugins The plugin stack to apply to the input\n+     * @param generateRuntimeImage if a runtime suitable for linking from the\n+     *        run-time image should get created.\n+     * @return The executable image.\n+     * @throws IOException\n+     *\/\n@@ -93,1 +120,3 @@\n-            ImagePluginStack plugins)\n+            ImagePluginStack plugins,\n+            boolean generateRuntimeImage,\n+            TaskHelper taskHelper)\n@@ -96,1 +125,3 @@\n-        ImageFileCreator image = new ImageFileCreator(plugins);\n+        ImageFileCreator image = new ImageFileCreator(plugins,\n+                                                      generateRuntimeImage,\n+                                                      taskHelper);\n@@ -101,0 +132,7 @@\n+        } catch (RuntimeImageLinkException e) {\n+            \/\/ readAllEntries() might throw this exception.\n+            \/\/ Propagate as IOException with appropriate message for\n+            \/\/ jlink runs from the run-time image. This handles better\n+            \/\/ error messages for the case of modified files in the run-time\n+            \/\/ image.\n+            throw image.newIOException(e);\n@@ -102,1 +140,1 @@\n-            \/\/Close all archives\n+            \/\/ Close all archives\n@@ -128,1 +166,2 @@\n-            ImagePluginStack pluginSupport)\n+            ImagePluginStack pluginSupport,\n+            boolean generateRuntimeImage)\n@@ -145,1 +184,1 @@\n-                generateJImage(pool, writer, pluginSupport, out);\n+                generateJImage(pool, writer, pluginSupport, out, generateRuntimeImage);\n@@ -161,1 +200,1 @@\n-        ResourcePool result;\n+        ResourcePool result = null;\n@@ -163,1 +202,6 @@\n-            result = generateJImage(allContent, writer, plugins, out);\n+            result = generateJImage(allContent, writer, plugins, out, generateRuntimeImage);\n+        } catch (RuntimeImageLinkException e) {\n+            \/\/ Propagate as IOException with appropriate message for\n+            \/\/ jlink runs from the run-time image. This handles better\n+            \/\/ error messages for the case of --patch-module.\n+            throw newIOException(e);\n@@ -177,0 +221,27 @@\n+    private IOException newIOException(RuntimeImageLinkException e) throws IOException {\n+        if (JlinkTask.DEBUG) {\n+            e.printStackTrace();\n+        }\n+        String message = switch (e.getReason()) {\n+            case PATCH_MODULE -> helper.getMessage(\"err.runtime.link.patched.module\", e.getFile());\n+            case MODIFIED_FILE -> helper.getMessage(\"err.runtime.link.modified.file\", e.getFile());\n+            default -> throw new AssertionError(\"Unexpected value: \" + e.getReason());\n+        };\n+        throw new IOException(message);\n+    }\n+\n+    \/**\n+     * Create a jimage based on content of the given ResourcePoolManager,\n+     * optionally creating a runtime that can be used for linking from the\n+     * run-time image\n+     *\n+     * @param allContent The content that needs to get added to the resulting\n+     *                   lib\/modules (jimage) file.\n+     * @param writer The writer for the jimage file.\n+     * @param pluginSupport The stack of all plugins to apply.\n+     * @param out The output stream to write the jimage to.\n+     * @param generateRuntimeImage if a runtime suitable for linking from the\n+     *        run-time image should get created.\n+     * @return A pool of the actual result resources.\n+     * @throws IOException\n+     *\/\n@@ -180,1 +251,2 @@\n-            DataOutputStream out\n+            DataOutputStream out,\n+            boolean generateRuntimeImage\n@@ -185,0 +257,11 @@\n+            if (generateRuntimeImage) {\n+                \/\/ Keep track of non-modules resources for linking from a run-time image\n+                resultResources = addNonClassResourcesTrackFiles(resultResources,\n+                                                                 writer);\n+                \/\/ Generate the diff between the input resources from packaged\n+                \/\/ modules in 'allContent' to the plugin- or otherwise\n+                \/\/ generated-content in 'resultResources'\n+                resultResources = addResourceDiffFiles(allContent.resourcePool(),\n+                                                       resultResources,\n+                                                       writer);\n+            }\n@@ -201,1 +284,1 @@\n-                 \/\/ the order of traversing the resources and the order of\n+        \/\/ the order of traversing the resources and the order of\n@@ -251,0 +334,200 @@\n+    \/**\n+     * Support for creating a runtime suitable for linking from the run-time\n+     * image.\n+     *\n+     * Generates differences between the packaged modules \"view\" in\n+     * {@code jmodContent} to the optimized image in {@code resultContent} and\n+     * adds the result to the returned resource pool.\n+     *\n+     * @param jmodContent The resource pool view of packaged modules\n+     * @param resultContent The optimized result generated from the jmodContent\n+     *                      input by applying the plugin stack.\n+     * @param writer The image writer.\n+     * @return The resource pool with the difference file resources added to\n+     *         the {@code resultContent}\n+     *\/\n+    @SuppressWarnings(\"try\")\n+    private static ResourcePool addResourceDiffFiles(ResourcePool jmodContent,\n+                                                     ResourcePool resultContent,\n+                                                     BasicImageWriter writer) {\n+        JimageDiffGenerator generator = new JimageDiffGenerator();\n+        List<ResourceDiff> diff;\n+        try (ImageResource jmods = new ResourcePoolReader(jmodContent);\n+             ImageResource jimage = new ResourcePoolReader(resultContent)) {\n+            diff = generator.generateDiff(jmods, jimage);\n+        } catch (Exception e) {\n+            throw new AssertionError(\"Failed to generate the runtime image diff\", e);\n+        }\n+        Set<String> modules = resultContent.moduleView().modules()\n+                                                        .map(a -> a.name())\n+                                                        .collect(Collectors.toSet());\n+        \/\/ Add resource diffs for the resource files we are about to add\n+        modules.stream().forEach(m -> {\n+            String resourceName = String.format(DIFF_PATH, m);\n+            ResourceDiff.Builder builder = new ResourceDiff.Builder();\n+            ResourceDiff d = builder.setKind(ResourceDiff.Kind.ADDED)\n+                                    .setName(resourceName)\n+                                    .build();\n+            diff.add(d);\n+        });\n+        Map<String, List<ResourceDiff>> perModDiffs = preparePerModuleDiffs(diff,\n+                                                                            modules);\n+        return addDiffResourcesFiles(modules, perModDiffs, resultContent, writer);\n+    }\n+\n+    private static Map<String, List<ResourceDiff>> preparePerModuleDiffs(List<ResourceDiff> resDiffs,\n+                                                                         Set<String> modules) {\n+        Map<String, List<ResourceDiff>> modToDiff = new HashMap<>();\n+        resDiffs.forEach(d -> {\n+            int secondSlash = d.getName().indexOf(\"\/\", 1);\n+            if (secondSlash == -1) {\n+                throw new AssertionError(\"Module name not present\");\n+            }\n+            String module = d.getName().substring(1, secondSlash);\n+            List<ResourceDiff> perModDiff = modToDiff.computeIfAbsent(module,\n+                                                                      a -> new ArrayList<>());\n+            perModDiff.add(d);\n+        });\n+        Map<String, List<ResourceDiff>> allModsToDiff = new HashMap<>();\n+        modules.stream().forEach(m -> {\n+            List<ResourceDiff> d = modToDiff.get(m);\n+            if (d == null) {\n+                \/\/ Not all modules will have a diff\n+                allModsToDiff.put(m, Collections.emptyList());\n+            } else {\n+                allModsToDiff.put(m, d);\n+            }\n+        });\n+        return allModsToDiff;\n+    }\n+\n+    private static ResourcePool addDiffResourcesFiles(Set<String> modules,\n+                                                      Map<String, List<ResourceDiff>> perModDiffs,\n+                                                      ResourcePool resultResources,\n+                                                      BasicImageWriter writer) {\n+        ResourcePoolManager mgr = createPoolManager(resultResources, writer);\n+        ResourcePoolBuilder out = mgr.resourcePoolBuilder();\n+        modules.stream().sorted().forEach(module -> {\n+            String mResource = String.format(DIFF_PATH, module);\n+            List<ResourceDiff> diff = perModDiffs.get(module);\n+            \/\/ Note that for modules without diff to the packaged modules view\n+            \/\/ we create resource diff files with just the header and no content.\n+            ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+            try {\n+                ResourceDiff.write(diff, bout);\n+            } catch (IOException e) {\n+                throw new AssertionError(\"Failed to write resource diff file\" +\n+                                         \" for module \" + module, e);\n+            }\n+            out.add(ResourcePoolEntry.create(mResource, bout.toByteArray()));\n+        });\n+        return out.build();\n+    }\n+\n+    \/**\n+     * Support for creating runtimes that can be used for linking from the\n+     * run-time image. Adds meta-data files for resources not in the lib\/modules\n+     * file of the JDK. That is, mapping files for which on-disk files belong to\n+     * which module.\n+     *\n+     * @param resultResources\n+     *            The original resources which serve as the basis for generating\n+     *            the meta-data files.\n+     * @param writer\n+     *            The image writer.\n+     *\n+     * @return An amended resource pool which includes meta-data files.\n+     *\/\n+    private static ResourcePool addNonClassResourcesTrackFiles(ResourcePool resultResources,\n+                                                               BasicImageWriter writer) {\n+        \/\/ Only add resources if jdk.jlink module is present in the target image\n+        Optional<ResourcePoolModule> jdkJlink = resultResources.moduleView()\n+                                                               .findModule(JLINK_MOD_NAME);\n+        if (jdkJlink.isPresent()) {\n+            Map<String, List<String>> nonClassResources = recordAndFilterEntries(resultResources);\n+            return addModuleResourceEntries(resultResources, nonClassResources, writer);\n+        } else {\n+            return resultResources; \/\/ No-op\n+        }\n+    }\n+\n+    \/**\n+     * Support for creating runtimes that can be used for linking from the\n+     * run-time image. Adds the given mapping of files as a meta-data file to\n+     * the given resource pool.\n+     *\n+     * @param resultResources\n+     *            The resource pool to add files to.\n+     * @param nonClassResEntries\n+     *            The per module mapping for which to create the meta-data files\n+     *            for.\n+     * @param writer\n+     *            The image writer.\n+     *\n+     * @return A resource pool with meta-data files added.\n+     *\/\n+    private static ResourcePool addModuleResourceEntries(ResourcePool resultResources,\n+                                                         Map<String, List<String>> nonClassResEntries,\n+                                                         BasicImageWriter writer) {\n+        Set<String> inputModules = resultResources.moduleView().modules()\n+                                                  .map(rm -> rm.name())\n+                                                  .collect(Collectors.toSet());\n+        ResourcePoolManager mgr = createPoolManager(resultResources, writer);\n+        ResourcePoolBuilder out = mgr.resourcePoolBuilder();\n+        inputModules.stream().sorted().forEach(module -> {\n+            String mResource = String.format(RESPATH, module);\n+            List<String> mResources = nonClassResEntries.get(module);\n+            if (mResources == null) {\n+                \/\/ We create empty resource files for modules in the resource\n+                \/\/ pool view that don't themselves contain native resources\n+                \/\/ or config files.\n+                out.add(ResourcePoolEntry.create(mResource, EMPTY_RESOURCE_BYTES));\n+            } else {\n+                String mResContent = mResources.stream().sorted()\n+                                               .collect(Collectors.joining(\"\\n\"));\n+                out.add(ResourcePoolEntry.create(mResource,\n+                                                 mResContent.getBytes(StandardCharsets.UTF_8)));\n+            }\n+        });\n+        return out.build();\n+    }\n+\n+    \/**\n+     * Support for creating runtimes that can be used for linking from the\n+     * run-time image. Generates a per module mapping of files not part of the\n+     * modules image (jimage). This mapping is needed so as to know which files\n+     * of the installed JDK belong to which module.\n+     *\n+     * @param resultResources\n+     *            The resources from which the mapping gets generated\n+     * @return A mapping with the module names as keys and the list of files not\n+     *         part of the modules image (jimage) as values.\n+     *\/\n+    private static Map<String, List<String>> recordAndFilterEntries(ResourcePool resultResources) {\n+        Map<String, List<String>> nonClassResEntries = new HashMap<>();\n+        Platform platform = getTargetPlatform(resultResources);\n+        resultResources.entries().forEach(entry -> {\n+            \/\/ Note that the fs_$module_files file is a resource file itself, so\n+            \/\/ we cannot add fs_$module_files themselves due to the\n+            \/\/ not(class_or_resources) condition. However, we also don't want\n+            \/\/ to track 'release' file entries (not(top) condition) as those are\n+            \/\/ handled by the release info plugin.\n+            if (entry.type() != ResourcePoolEntry.Type.CLASS_OR_RESOURCE &&\n+                    entry.type() != ResourcePoolEntry.Type.TOP) {\n+                List<String> mRes = nonClassResEntries.computeIfAbsent(entry.moduleName(),\n+                                                                       a -> new ArrayList<>());\n+                ResourceFileEntry rfEntry = ResourceFileEntry.toResourceFileEntry(entry,\n+                                                                                  platform);\n+                mRes.add(rfEntry.encodeToString());\n+            }\n+        });\n+        return nonClassResEntries;\n+    }\n+\n+    private static Platform getTargetPlatform(ResourcePool in) {\n+        String platform = in.moduleView().findModule(\"java.base\")\n+                .map(ResourcePoolModule::targetPlatform)\n+                .orElseThrow(() -> new AssertionError(\"java.base not found\"));\n+        return Platform.parsePlatform(platform);\n+    }\n+\n@@ -255,1 +538,15 @@\n-        ResourcePoolManager resources = new ResourcePoolManager(byteOrder, new StringTable() {\n+        ResourcePoolManager resources = createBasicResourcePoolManager(byteOrder, writer);\n+        archives.stream()\n+                .map(Archive::moduleName)\n+                .sorted()\n+                .flatMap(mn ->\n+                    entriesForModule.get(mn).stream()\n+                            .map(e -> new ArchiveEntryResourcePoolEntry(mn,\n+                                    e.getResourcePoolEntryName(), e)))\n+                .forEach(resources::add);\n+        return resources;\n+    }\n+\n+    private static ResourcePoolManager createBasicResourcePoolManager(ByteOrder byteOrder,\n+                                                                      BasicImageWriter writer) {\n+        return new ResourcePoolManager(byteOrder, new StringTable() {\n@@ -267,8 +564,19 @@\n-        archives.stream()\n-                .map(Archive::moduleName)\n-                .sorted()\n-                .flatMap(mn ->\n-                    entriesForModule.get(mn).stream()\n-                            .map(e -> new ArchiveEntryResourcePoolEntry(mn,\n-                                    e.getResourcePoolEntryName(), e)))\n-                .forEach(resources::add);\n+    }\n+\n+    \/**\n+     * Creates a ResourcePoolManager from existing resources so that more\n+     * resources can be appended.\n+     *\n+     * @param resultResources The existing resources to initially add.\n+     * @param writer The basic image writer.\n+     * @return An appendable ResourcePoolManager.\n+     *\/\n+    private static ResourcePoolManager createPoolManager(ResourcePool resultResources,\n+                                                         BasicImageWriter writer) {\n+        ResourcePoolManager resources = createBasicResourcePoolManager(resultResources.byteOrder(),\n+                                                                       writer);\n+        \/\/ Note that resources are already sorted in the correct order.\n+        \/\/ The underlying ResourcePoolManager keeps track of entries via\n+        \/\/ LinkedHashMap, which keeps values in insertion order. Therefore\n+        \/\/ adding resources here, preserving that same order is OK.\n+        resultResources.entries().forEach(resources::add);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageFileCreator.java","additions":341,"deletions":33,"binary":false,"changes":374,"status":"modified"},{"patch":"@@ -0,0 +1,528 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal;\n+\n+import static jdk.tools.jlink.internal.LinkableRuntimeImage.RESPATH_PATTERN;\n+import static jdk.tools.jlink.internal.runtimelink.RuntimeImageLinkException.Reason.MODIFIED_FILE;\n+import static jdk.tools.jlink.internal.runtimelink.RuntimeImageLinkException.Reason.PATCH_MODULE;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReference;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.util.OperatingSystem;\n+import jdk.tools.jlink.internal.Archive.Entry.EntryType;\n+import jdk.tools.jlink.internal.runtimelink.ResourceDiff;\n+import jdk.tools.jlink.internal.runtimelink.RuntimeImageLinkException;\n+import jdk.tools.jlink.plugin.ResourcePoolEntry;\n+import jdk.tools.jlink.plugin.ResourcePoolEntry.Type;\n+\n+\/**\n+ * An archive implementation based on the JDK's run-time image. That is, classes\n+ * and resources from the modules image (lib\/modules, or jimage) and other\n+ * associated files from the filesystem of the JDK installation.\n+ *\/\n+public class JRTArchive implements Archive {\n+\n+    private final String module;\n+    private final Path path;\n+    private final ModuleReference ref;\n+    \/\/ The collection of files of this module\n+    private final List<JRTFile> files = new ArrayList<>();\n+    \/\/ Files not part of the lib\/modules image of the JDK install.\n+    \/\/ Thus, native libraries, binaries, legal files, etc.\n+    private final List<String> otherRes;\n+    \/\/ Maps a module resource path to the corresponding diff to packaged\n+    \/\/ modules for that resource (if any)\n+    private final Map<String, ResourceDiff> resDiff;\n+    private final boolean errorOnModifiedFile;\n+    private final TaskHelper taskHelper;\n+\n+    \/**\n+     * JRTArchive constructor\n+     *\n+     * @param module The module name this archive refers to\n+     * @param path The JRT filesystem path.\n+     * @param errorOnModifiedFile Whether or not modified files of the JDK\n+     *        install aborts the link.\n+     * @param perModDiff The lib\/modules (a.k.a jimage) diff for this module,\n+     *                   possibly an empty list if there are no differences.\n+     *\/\n+    JRTArchive(String module,\n+               Path path,\n+               boolean errorOnModifiedFile,\n+               List<ResourceDiff> perModDiff,\n+               TaskHelper taskHelper) {\n+        this.module = module;\n+        this.path = path;\n+        this.ref = ModuleFinder.ofSystem()\n+                               .find(module)\n+                               .orElseThrow(() ->\n+                                    new IllegalArgumentException(\n+                                            \"Module \" + module +\n+                                            \" not part of the JDK install\"));\n+        this.errorOnModifiedFile = errorOnModifiedFile;\n+        this.otherRes = readModuleResourceFile(module);\n+        this.resDiff = Objects.requireNonNull(perModDiff).stream()\n+                            .collect(Collectors.toMap(ResourceDiff::getName, Function.identity()));\n+        this.taskHelper = taskHelper;\n+    }\n+\n+    @Override\n+    public String moduleName() {\n+        return module;\n+    }\n+\n+    @Override\n+    public Path getPath() {\n+        return path;\n+    }\n+\n+    @Override\n+    public Stream<Entry> entries() {\n+        try {\n+            collectFiles();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        } catch (RuntimeImageLinkException e) {\n+            \/\/ populate modified files exception\n+            throw e;\n+        }\n+        return files.stream().map(JRTFile::toEntry);\n+    }\n+\n+    @Override\n+    public void open() throws IOException {\n+        if (files.isEmpty()) {\n+            collectFiles();\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (!files.isEmpty()) {\n+            files.clear();\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(module, path);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return (obj instanceof JRTArchive other &&\n+                   Objects.equals(module, other.module) &&\n+                   Objects.equals(path, other.path));\n+    }\n+\n+    private void collectFiles() throws IOException {\n+        if (files.isEmpty()) {\n+            addNonClassResources();\n+            \/\/ Add classes\/resources from the run-time image,\n+            \/\/ patched with the run-time image diff\n+            files.addAll(ref.open().list()\n+                                   .filter(i -> {\n+                                           String lookupKey = String.format(\"\/%s\/%s\", module, i);\n+                                           ResourceDiff rd = resDiff.get(lookupKey);\n+                                           \/\/ Filter all resources with a resource diff\n+                                           \/\/ that are of kind MODIFIED.\n+                                           \/\/ Note that REMOVED won't happen since in\n+                                           \/\/ that case the module listing won't have\n+                                           \/\/ the resource anyway.\n+                                           \/\/ Note as well that filter removes files\n+                                           \/\/ of kind ADDED. Those files are not in\n+                                           \/\/ the packaged modules, so ought not to\n+                                           \/\/ get returned from the pipeline.\n+                                           return (rd == null ||\n+                                                   rd.getKind() == ResourceDiff.Kind.MODIFIED);\n+                                   })\n+                                   .map(s -> {\n+                                           String lookupKey = String.format(\"\/%s\/%s\", module, s);\n+                                           return new JRTArchiveFile(JRTArchive.this, s,\n+                                                           EntryType.CLASS_OR_RESOURCE,\n+                                                           null \/* hashOrTarget *\/,\n+                                                           false \/* symlink *\/,\n+                                                           resDiff.get(lookupKey));\n+                                   })\n+                                   .toList());\n+            \/\/ Finally add all files only present in the resource diff\n+            \/\/ That is, removed items in the run-time image.\n+            files.addAll(resDiff.values().stream()\n+                                         .filter(rd -> rd.getKind() == ResourceDiff.Kind.REMOVED)\n+                                         .map(s -> {\n+                                                 int secondSlash = s.getName().indexOf(\"\/\", 1);\n+                                                 assert secondSlash != -1;\n+                                                 String pathWithoutModule = s.getName().substring(secondSlash + 1);\n+                                                 return new JRTArchiveFile(JRTArchive.this,\n+                                                         pathWithoutModule,\n+                                                         EntryType.CLASS_OR_RESOURCE,\n+                                                         null  \/* hashOrTarget *\/,\n+                                                         false \/* symlink *\/,\n+                                                         s);\n+                                         })\n+                                         .toList());\n+        }\n+    }\n+\n+    \/*\n+     * no need to keep track of the warning produced since this is eagerly\n+     * checked once.\n+     *\/\n+    private void addNonClassResources() {\n+        \/\/ Not all modules will have other resources like bin, lib, legal etc.\n+        \/\/ files. In that case the list will be empty.\n+        if (!otherRes.isEmpty()) {\n+            files.addAll(otherRes.stream()\n+                 .filter(Predicate.not(String::isEmpty))\n+                 .map(s -> {\n+                        ResourceFileEntry m = ResourceFileEntry.decodeFromString(s);\n+\n+                        \/\/ Read from the base JDK image.\n+                        Path path = BASE.resolve(m.resPath);\n+                        if (shaSumMismatch(path, m.hashOrTarget, m.symlink)) {\n+                            if (errorOnModifiedFile) {\n+                                throw new RuntimeImageLinkException(path.toString(), MODIFIED_FILE);\n+                            } else {\n+                                taskHelper.warning(\"err.runtime.link.modified.file\", path.toString());\n+                            }\n+                        }\n+\n+                        return new JRTArchiveFile(JRTArchive.this,\n+                                                  m.resPath,\n+                                                  toEntryType(m.resType),\n+                                                  m.hashOrTarget,\n+                                                  m.symlink,\n+                                                  \/* diff only for resources *\/\n+                                                  null);\n+                 })\n+                 .toList());\n+        }\n+    }\n+\n+    static boolean shaSumMismatch(Path res, String expectedSha, boolean isSymlink) {\n+        if (isSymlink) {\n+            return false;\n+        }\n+        \/\/ handle non-symlink resources\n+        try {\n+            HexFormat format = HexFormat.of();\n+            byte[] expected = format.parseHex(expectedSha);\n+            MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n+            try (InputStream is = Files.newInputStream(res)) {\n+                byte[] buf = new byte[1024];\n+                int readBytes = -1;\n+                while ((readBytes = is.read(buf)) != -1) {\n+                    digest.update(buf, 0, readBytes);\n+                }\n+            }\n+            byte[] actual = digest.digest();\n+            return !MessageDigest.isEqual(expected, actual);\n+        } catch (Exception e) {\n+            throw new AssertionError(\"SHA-512 sum check failed!\", e);\n+        }\n+    }\n+\n+    private static EntryType toEntryType(Type input) {\n+        return switch(input) {\n+            case CLASS_OR_RESOURCE -> EntryType.CLASS_OR_RESOURCE;\n+            case CONFIG -> EntryType.CONFIG;\n+            case HEADER_FILE -> EntryType.HEADER_FILE;\n+            case LEGAL_NOTICE -> EntryType.LEGAL_NOTICE;\n+            case MAN_PAGE -> EntryType.MAN_PAGE;\n+            case NATIVE_CMD -> EntryType.NATIVE_CMD;\n+            case NATIVE_LIB -> EntryType.NATIVE_LIB;\n+            case TOP -> throw new IllegalArgumentException(\n+                           \"TOP files should be handled by ReleaseInfoPlugin!\");\n+            default -> throw new IllegalArgumentException(\"Unknown type: \" + input);\n+        };\n+    }\n+\n+    public record ResourceFileEntry(Type resType,\n+                                    boolean symlink,\n+                                    String hashOrTarget,\n+                                    String resPath) {\n+        \/\/ Type file format:\n+        \/\/ '<type>|{0,1}|<sha-sum>|<file-path>'\n+        \/\/   (1)    (2)      (3)      (4)\n+        \/\/\n+        \/\/ Where fields are:\n+        \/\/\n+        \/\/ (1) The resource type as specified by ResourcePoolEntry.type()\n+        \/\/ (2) Symlink designator. 0 => regular resource, 1 => symlinked resource\n+        \/\/ (3) The SHA-512 sum of the resources' content. The link to the target\n+        \/\/     for symlinked resources.\n+        \/\/ (4) The relative file path of the resource\n+        private static final String TYPE_FILE_FORMAT = \"%d|%d|%s|%s\";\n+\n+        private static final Map<Integer, Type> typeMap = Arrays.stream(Type.values())\n+                .collect(Collectors.toMap(Type::ordinal, Function.identity()));\n+\n+        public String encodeToString() {\n+            return String.format(TYPE_FILE_FORMAT,\n+                                 resType.ordinal(),\n+                                 symlink ? 1 : 0,\n+                                 hashOrTarget,\n+                                 resPath);\n+        }\n+\n+        \/**\n+         *  line: <int>|<int>|<hashOrTarget>|<path>\n+         *\n+         *  Take the integer before '|' convert it to a Type. The second\n+         *  token is an integer representing symlinks (or not). The third token is\n+         *  a hash sum (sha512) of the file denoted by the fourth token (path).\n+         *\/\n+        static ResourceFileEntry decodeFromString(String line) {\n+            assert !line.isEmpty();\n+\n+            String[] tokens = line.split(\"\\\\|\", 4);\n+            Type type = null;\n+            int symlinkNum = -1;\n+            try {\n+                Integer typeInt = Integer.valueOf(tokens[0]);\n+                type = typeMap.get(typeInt);\n+                if (type == null) {\n+                    throw new AssertionError(\"Illegal type ordinal: \" + typeInt);\n+                }\n+                symlinkNum = Integer.valueOf(tokens[1]);\n+            } catch (NumberFormatException e) {\n+                throw new AssertionError(e); \/\/ must not happen\n+            }\n+            if (symlinkNum < 0 || symlinkNum > 1) {\n+                throw new AssertionError(\n+                        \"Symlink designator out of range [0,1] got: \" +\n+                        symlinkNum);\n+            }\n+            return new ResourceFileEntry(type,\n+                                         symlinkNum == 1,\n+                                         tokens[2] \/* hash or target *\/,\n+                                         tokens[3] \/* resource path *\/);\n+        }\n+\n+        public static ResourceFileEntry toResourceFileEntry(ResourcePoolEntry entry,\n+                                                            Platform platform) {\n+            String resPathWithoutMod = dropModuleFromPath(entry, platform);\n+            \/\/ Symlinks don't have a hash sum, but a link to the target instead\n+            String hashOrTarget = entry.linkedTarget() == null\n+                                        ? computeSha512(entry)\n+                                        : dropModuleFromPath(entry.linkedTarget(),\n+                                                             platform);\n+            return new ResourceFileEntry(entry.type(),\n+                                         entry.linkedTarget() != null,\n+                                         hashOrTarget,\n+                                         resPathWithoutMod);\n+        }\n+\n+        private static String computeSha512(ResourcePoolEntry entry) {\n+            try {\n+                assert entry.linkedTarget() == null;\n+                MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n+                try (InputStream is = entry.content()) {\n+                    byte[] buf = new byte[1024];\n+                    int bytesRead = -1;\n+                    while ((bytesRead = is.read(buf)) != -1) {\n+                        digest.update(buf, 0, bytesRead);\n+                    }\n+                }\n+                byte[] db = digest.digest();\n+                HexFormat format = HexFormat.of();\n+                return format.formatHex(db);\n+            } catch (Exception e) {\n+                throw new AssertionError(\"Failed to generate hash sum for \" +\n+                                         entry.path());\n+            }\n+        }\n+\n+        private static String dropModuleFromPath(ResourcePoolEntry entry,\n+                                                 Platform platform) {\n+            String resPath = entry.path()\n+                                  .substring(\n+                                      \/\/ + 2 => prefixed and suffixed '\/'\n+                                      \/\/ For example: '\/java.base\/'\n+                                      entry.moduleName().length() + 2);\n+            if (!isWindows(platform)) {\n+                return resPath;\n+            }\n+            \/\/ For Windows the libraries live in the 'bin' folder rather than\n+            \/\/ the 'lib' folder in the final image. Note that going by the\n+            \/\/ NATIVE_LIB type only is insufficient since only files with suffix\n+            \/\/ .dll\/diz\/map\/pdb are transplanted to 'bin'.\n+            \/\/ See: DefaultImageBuilder.nativeDir()\n+            return nativeDir(entry, resPath);\n+        }\n+\n+        private static boolean isWindows(Platform platform) {\n+            return platform.os() == OperatingSystem.WINDOWS;\n+        }\n+\n+        private static String nativeDir(ResourcePoolEntry entry, String resPath) {\n+            if (entry.type() != ResourcePoolEntry.Type.NATIVE_LIB) {\n+                return resPath;\n+            }\n+            \/\/ precondition: Native lib, windows platform\n+            if (resPath.endsWith(\".dll\") || resPath.endsWith(\".diz\")\n+                    || resPath.endsWith(\".pdb\") || resPath.endsWith(\".map\")) {\n+                if (resPath.startsWith(LIB_DIRNAME + \"\/\")) {\n+                    return BIN_DIRNAME + \"\/\" +\n+                               resPath.substring((LIB_DIRNAME + \"\/\").length());\n+                }\n+            }\n+            return resPath;\n+        }\n+        private static final String BIN_DIRNAME = \"bin\";\n+        private static final String LIB_DIRNAME = \"lib\";\n+    }\n+\n+    private static final Path BASE = Paths.get(System.getProperty(\"java.home\"));\n+\n+    interface JRTFile {\n+        Entry toEntry();\n+    }\n+\n+    record JRTArchiveFile(Archive archive,\n+                          String resPath,\n+                          EntryType resType,\n+                          String sha,\n+                          boolean symlink,\n+                          ResourceDiff diff) implements JRTFile {\n+        public Entry toEntry() {\n+            return new Entry(archive,\n+                             String.format(\"\/%s\/%s\",\n+                                           archive.moduleName(),\n+                                           resPath),\n+                             resPath,\n+                             resType) {\n+                @Override\n+                public long size() {\n+                    try {\n+                        if (resType != EntryType.CLASS_OR_RESOURCE) {\n+                            \/\/ Read from the base JDK image, special casing\n+                            \/\/ symlinks, which have the link target in the\n+                            \/\/ hashOrTarget field\n+                            if (symlink) {\n+                                return Files.size(BASE.resolve(sha));\n+                            }\n+                            return Files.size(BASE.resolve(resPath));\n+                        } else {\n+                            if (diff != null) {\n+                                \/\/ If the resource has a diff to the\n+                                \/\/ packaged modules, use the diff. Diffs of kind\n+                                \/\/ ADDED have been filtered out in collectFiles();\n+                                assert diff.getKind() != ResourceDiff.Kind.ADDED;\n+                                assert diff.getName().equals(String.format(\"\/%s\/%s\",\n+                                                                           archive.moduleName(),\n+                                                                           resPath));\n+                                return diff.getResourceBytes().length;\n+                            }\n+                            \/\/ Read from the module image. This works, because\n+                            \/\/ the underlying base path is a JrtPath with the\n+                            \/\/ JrtFileSystem underneath which is able to handle\n+                            \/\/ this size query.\n+                            try {\n+                                return Files.size(archive.getPath().resolve(resPath));\n+                            } catch (NoSuchFileException file) {\n+                                \/\/ This indicates that we don't find the class in the\n+                                \/\/ modules image using the JRT FS provider. Yet, we find\n+                                \/\/ the class using the system module finder. Therefore,\n+                                \/\/ we have a patched module. Mention that module patching\n+                                \/\/ is not supported.\n+                                throw new RuntimeImageLinkException(file.getFile(), PATCH_MODULE);\n+                            }\n+                        }\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                }\n+\n+                @Override\n+                public InputStream stream() throws IOException {\n+                    if (resType != EntryType.CLASS_OR_RESOURCE) {\n+                        \/\/ Read from the base JDK image.\n+                        Path path = symlink ? BASE.resolve(sha) : BASE.resolve(resPath);\n+                        return Files.newInputStream(path);\n+                    } else {\n+                        \/\/ Read from the module image. Use the diff to the\n+                        \/\/ packaged modules if we have one. Diffs of kind\n+                        \/\/ ADDED have been filtered out in collectFiles();\n+                        if (diff != null) {\n+                            assert diff.getKind() != ResourceDiff.Kind.ADDED;\n+                            assert diff.getName().equals(String.format(\"\/%s\/%s\",\n+                                                                       archive.moduleName(),\n+                                                                       resPath));\n+                            return new ByteArrayInputStream(diff.getResourceBytes());\n+                        }\n+                        String module = archive.moduleName();\n+                        ModuleReference mRef = ModuleFinder.ofSystem()\n+                                                    .find(module).orElseThrow();\n+                        return mRef.open().open(resPath).orElseThrow();\n+                    }\n+                }\n+\n+            };\n+        }\n+    }\n+\n+    private static List<String> readModuleResourceFile(String modName) {\n+        String resName = String.format(RESPATH_PATTERN, modName);\n+        try {\n+            try (InputStream inStream = JRTArchive.class.getModule()\n+                                                  .getResourceAsStream(resName)) {\n+                String input = new String(inStream.readAllBytes(), StandardCharsets.UTF_8);\n+                if (input.isEmpty()) {\n+                    \/\/ Not all modules have non-class resources\n+                    return Collections.emptyList();\n+                } else {\n+                    return Arrays.asList(input.split(\"\\n\"));\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(\"Failed to process resources from the \" +\n+                                           \"run-time image for module \" + modName, e);\n+        }\n+    }\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JRTArchive.java","additions":528,"deletions":0,"binary":false,"changes":528,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import java.nio.ByteOrder;\n@@ -151,0 +150,3 @@\n+        private final boolean linkFromRuntimeImage;\n+        private final boolean ignoreModifiedRuntime;\n+        private final boolean generateRuntimeImage;\n@@ -161,1 +163,4 @@\n-                                  ModuleFinder finder) {\n+                                  ModuleFinder finder,\n+                                  boolean linkFromRuntimeImage,\n+                                  boolean ignoreModifiedRuntime,\n+                                  boolean generateRuntimeImage) {\n@@ -165,0 +170,3 @@\n+            this.linkFromRuntimeImage = linkFromRuntimeImage;\n+            this.ignoreModifiedRuntime = ignoreModifiedRuntime;\n+            this.generateRuntimeImage = generateRuntimeImage;\n@@ -189,0 +197,12 @@\n+        public boolean linkFromRuntimeImage() {\n+            return linkFromRuntimeImage;\n+        }\n+\n+        public boolean ignoreModifiedRuntime() {\n+            return ignoreModifiedRuntime;\n+        }\n+\n+        public boolean isGenerateRuntimeImage() {\n+            return generateRuntimeImage;\n+        }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Jlink.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import static jdk.tools.jlink.internal.TaskHelper.JLINK_BUNDLE;\n+\n@@ -42,1 +44,0 @@\n-import java.nio.file.Files;\n@@ -44,0 +45,1 @@\n+import java.nio.file.Files;\n@@ -50,0 +52,1 @@\n+import java.util.Collections;\n@@ -63,0 +66,1 @@\n+import jdk.internal.module.ModulePath;\n@@ -64,2 +68,3 @@\n-import jdk.tools.jlink.internal.TaskHelper.BadArgs;\n-import static jdk.tools.jlink.internal.TaskHelper.JLINK_BUNDLE;\n+import jdk.internal.module.ModuleResolution;\n+import jdk.internal.opt.CommandLine;\n+import jdk.tools.jlink.internal.ImagePluginStack.ImageProvider;\n@@ -68,0 +73,1 @@\n+import jdk.tools.jlink.internal.TaskHelper.BadArgs;\n@@ -70,1 +76,1 @@\n-import jdk.tools.jlink.internal.ImagePluginStack.ImageProvider;\n+import jdk.tools.jlink.internal.runtimelink.RuntimeImageLinkException;\n@@ -72,3 +78,0 @@\n-import jdk.internal.opt.CommandLine;\n-import jdk.internal.module.ModulePath;\n-import jdk.internal.module.ModuleResolution;\n@@ -89,1 +92,0 @@\n-\n@@ -185,1 +187,11 @@\n-        }, \"--ignore-signing-information\"),};\n+        }, \"--ignore-signing-information\"),\n+        new Option<JlinkTask>(false, (task, opt, arg) -> {\n+            task.options.ignoreModifiedRuntime = true;\n+        }, true, \"--ignore-modified-runtime\"),\n+        \/\/ option for generating a runtime that can then\n+        \/\/ be used for linking from the run-time image.\n+        new Option<JlinkTask>(false, (task, opt, arg) -> {\n+            task.options.generateLinkableRuntime = true;\n+        }, true, \"--generate-linkable-runtime\")\n+    };\n+\n@@ -225,0 +237,2 @@\n+        boolean ignoreModifiedRuntime = false;\n+        boolean generateLinkableRuntime = false;\n@@ -255,1 +269,1 @@\n-                optionsHelper.showHelp(PROGNAME);\n+                optionsHelper.showHelp(PROGNAME, LinkableRuntimeImage.isLinkableRuntime());\n@@ -273,5 +287,0 @@\n-\n-                if (options.modulePath.isEmpty()) {\n-                    throw taskHelper.newBadArgs(\"err.modulepath.must.be.specified\")\n-                            .showUsage(true);\n-                }\n@@ -303,1 +312,1 @@\n-        } catch (IllegalArgumentException | ResolutionException e) {\n+        } catch (IllegalArgumentException | ResolutionException | RuntimeImageLinkException e) {\n@@ -359,0 +368,1 @@\n+                                    new OptionsValues(),\n@@ -373,1 +383,1 @@\n-            if (mod.equals(ALL_MODULE_PATH)) {\n+            if (mod.equals(ALL_MODULE_PATH) && options.modulePath.size() > 0) {\n@@ -395,0 +405,19 @@\n+        boolean isLinkFromRuntime = options.modulePath.isEmpty();\n+        \/\/ In case of custom modules outside the JDK we may\n+        \/\/ have a non-empty module path, which must not include\n+        \/\/ java.base. If it did, we link using packaged modules from that\n+        \/\/ module path. If the module path does not include java.base, we have\n+        \/\/ the case where we link from the run-time image. In that case, we take\n+        \/\/ the JDK modules from the run-time image (ModuleFinder.ofSystem()).\n+        if (finder.find(\"java.base\").isEmpty()) {\n+            isLinkFromRuntime = true;\n+            ModuleFinder runtimeImageFinder = ModuleFinder.ofSystem();\n+            finder = combinedFinders(runtimeImageFinder, finder, options.limitMods, roots);\n+        }\n+\n+        \/\/ --keep-packaged-modules doesn't make sense as we are not linking\n+        \/\/ from packaged modules to begin with.\n+        if (isLinkFromRuntime && options.packagedModulesPath != null) {\n+            throw taskHelper.newBadArgs(\"err.runtime.link.packaged.mods\");\n+        }\n+\n@@ -397,1 +426,48 @@\n-                                      finder);\n+                                      finder,\n+                                      isLinkFromRuntime,\n+                                      options.ignoreModifiedRuntime,\n+                                      options.generateLinkableRuntime);\n+    }\n+\n+    \/**\n+     * Creates a combined module finder of {@code finder} and\n+     * {@code runtimeImageFinder} that first looks-up modules in the\n+     * {@code runtimeImageFinder} and if not present in {@code finder}.\n+     *\n+     * @param runtimeImageFinder A system modules finder.\n+     * @param finder A module finder based on packaged modules.\n+     * @param limitMods The set of limited modules for the resulting\n+     *                  finder (if any).\n+     * @param roots All module roots.\n+     *\n+     * @return A combined finder, or the input finder, potentially applying\n+     *         module limits.\n+     *\/\n+    private ModuleFinder combinedFinders(ModuleFinder runtimeImageFinder,\n+                                         ModuleFinder finder,\n+                                         Set<String> limitMods,\n+                                         Set<String> roots) {\n+        ModuleFinder combined = new ModuleFinder() {\n+\n+            @Override\n+            public Optional<ModuleReference> find(String name) {\n+                Optional<ModuleReference> mref = runtimeImageFinder.find(name);\n+                if (mref.isEmpty()) {\n+                    return finder.find(name);\n+                }\n+                return mref;\n+            }\n+\n+            @Override\n+            public Set<ModuleReference> findAll() {\n+                Set<ModuleReference> all = new HashSet<>();\n+                all.addAll(runtimeImageFinder.findAll());\n+                all.addAll(finder.findAll());\n+                return Collections.unmodifiableSet(all);\n+            }\n+        };\n+        \/\/ if limitmods is specified then limit the universe\n+        if (limitMods != null && !limitMods.isEmpty()) {\n+            return limitFinder(combined, limitMods, Objects.requireNonNull(roots));\n+        }\n+        return combined;\n@@ -416,0 +492,1 @@\n+                                                        options,\n@@ -436,4 +513,4 @@\n-     * Returns a module finder of the given module path that limits\n-     * the observable modules to those in the transitive closure of\n-     * the modules specified in {@code limitMods} plus other modules\n-     * specified in the {@code roots} set.\n+     * Returns a module finder of the given module path or the system modules\n+     * if the module path is empty that limits the observable modules to those\n+     * in the transitive closure of the modules specified in {@code limitMods}\n+     * plus other modules specified in the {@code roots} set.\n@@ -448,5 +525,0 @@\n-        if (Objects.requireNonNull(paths).isEmpty()) {\n-             throw new IllegalArgumentException(taskHelper.getMessage(\"err.empty.module.path\"));\n-        }\n-\n-        Path[] entries = paths.toArray(new Path[0]);\n@@ -454,2 +526,3 @@\n-        ModuleFinder finder = ModulePath.of(version, true, entries);\n-\n+        Path[] entries = paths.toArray(new Path[0]);\n+        ModuleFinder finder = paths.isEmpty() ? ModuleFinder.ofSystem()\n+                                              : ModulePath.of(version, true, entries);\n@@ -508,1 +581,1 @@\n-        if (ouri.isEmpty())\n+        if (ouri.isEmpty()) {\n@@ -510,0 +583,1 @@\n+        }\n@@ -521,0 +595,1 @@\n+                                                   OptionsValues opts,\n@@ -537,0 +612,18 @@\n+        \/\/ Perform some sanity checks for linking from the run-time image\n+        if (config.linkFromRuntimeImage()) {\n+            if (!LinkableRuntimeImage.isLinkableRuntime()) {\n+                String msg = taskHelper.getMessage(\"err.runtime.link.not.linkable.runtime\");\n+                throw new IllegalArgumentException(msg);\n+            }\n+            \/\/ Do not permit linking from run-time image and also including jdk.jlink module\n+            if (cf.findModule(JlinkTask.class.getModule().getName()).isPresent()) {\n+                String msg = taskHelper.getMessage(\"err.runtime.link.jdk.jlink.prohibited\");\n+                throw new IllegalArgumentException(msg);\n+            }\n+\n+            \/\/ Print info message indicating linking from the run-time image\n+            if (verbose && log != null) {\n+                log.println(taskHelper.getMessage(\"runtime.link.info\"));\n+            }\n+        }\n+\n@@ -541,2 +634,7 @@\n-              .forEach(rm -> log.format(\"%s %s%n\",\n-                                        rm.name(), rm.reference().location().get()));\n+              .forEach(rm -> log.format(\"%s %s%s%n\",\n+                                        rm.name(),\n+                                        rm.reference().location().get(),\n+                                        \/\/ We have a link from run-time image when scheme is 'jrt'\n+                                        \"jrt\".equals(rm.reference().location().get().getScheme())\n+                                                ? \" \" + taskHelper.getMessage(\"runtime.link.jprt.path.extra\")\n+                                                : \"\"));\n@@ -562,1 +660,1 @@\n-            if (!\"\".equals(im))\n+            if (!\"\".equals(im)) {\n@@ -564,0 +662,1 @@\n+            }\n@@ -569,1 +668,1 @@\n-        Platform targetPlatform = targetPlatform(cf, mods);\n+        Platform targetPlatform = targetPlatform(cf, mods, config.linkFromRuntimeImage());\n@@ -583,1 +682,86 @@\n-        return new ImageHelper(cf, mods, targetPlatform, retainModulesPath, ignoreSigning);\n+\n+        \/\/ use the version of java.base module, if present, as\n+        \/\/ the release version for multi-release JAR files\n+        var version = cf.findModule(\"java.base\")\n+                        .map(ResolvedModule::reference)\n+                        .map(ModuleReference::descriptor)\n+                        .flatMap(ModuleDescriptor::version)\n+                        .map(ModuleDescriptor.Version::toString)\n+                        .map(Runtime.Version::parse)\n+                        .orElse(Runtime.version());\n+\n+        Set<Archive> archives = mods.entrySet().stream()\n+                .map(e -> newArchive(e.getKey(),\n+                                     e.getValue(),\n+                                     version,\n+                                     ignoreSigning,\n+                                     config,\n+                                     log))\n+                .collect(Collectors.toSet());\n+\n+        return new ImageHelper(archives,\n+                               targetPlatform,\n+                               retainModulesPath,\n+                               config.isGenerateRuntimeImage());\n+    }\n+\n+    private static Archive newArchive(String module,\n+                                      Path path,\n+                                      Runtime.Version version,\n+                                      boolean ignoreSigning,\n+                                      JlinkConfiguration config,\n+                                      PrintWriter log) {\n+        if (path.toString().endsWith(\".jmod\")) {\n+            return new JmodArchive(module, path);\n+        } else if (path.toString().endsWith(\".jar\")) {\n+            ModularJarArchive modularJarArchive = new ModularJarArchive(module, path, version);\n+            try (Stream<Archive.Entry> entries = modularJarArchive.entries()) {\n+                boolean hasSignatures = entries.anyMatch((entry) -> {\n+                    String name = entry.name().toUpperCase(Locale.ROOT);\n+\n+                    return name.startsWith(\"META-INF\/\") && name.indexOf('\/', 9) == -1 && (\n+                            name.endsWith(\".SF\") ||\n+                                    name.endsWith(\".DSA\") ||\n+                                    name.endsWith(\".RSA\") ||\n+                                    name.endsWith(\".EC\") ||\n+                                    name.startsWith(\"META-INF\/SIG-\")\n+                    );\n+                });\n+\n+                if (hasSignatures) {\n+                    if (ignoreSigning) {\n+                        System.err.println(taskHelper.getMessage(\"warn.signing\", path));\n+                    } else {\n+                        throw new IllegalArgumentException(taskHelper.getMessage(\"err.signing\", path));\n+                    }\n+                }\n+            }\n+            return modularJarArchive;\n+        } else if (Files.isDirectory(path) && !\"jrt\".equals(path.toUri().getScheme())) {\n+            \/\/ The jrt URI path scheme conditional is there since we'd otherwise\n+            \/\/ enter this branch for linking from the run-time image where the\n+            \/\/ path is a jrt path. Note that the specific module would be a\n+            \/\/ directory. I.e. Files.isDirectory() would be true.\n+            Path modInfoPath = path.resolve(\"module-info.class\");\n+            if (Files.isRegularFile(modInfoPath)) {\n+                return new DirArchive(path, findModuleName(modInfoPath));\n+            } else {\n+                throw new IllegalArgumentException(\n+                        taskHelper.getMessage(\"err.not.a.module.directory\", path));\n+            }\n+        } else if (config.linkFromRuntimeImage()) {\n+            return LinkableRuntimeImage.newArchive(module, path, config.ignoreModifiedRuntime(), taskHelper);\n+        } else {\n+            throw new IllegalArgumentException(\n+                    taskHelper.getMessage(\"err.not.modular.format\", module, path));\n+        }\n+    }\n+\n+    private static String findModuleName(Path modInfoPath) {\n+        try (BufferedInputStream bis = new BufferedInputStream(\n+                Files.newInputStream(modInfoPath))) {\n+            return ModuleDescriptor.read(bis).name();\n+        } catch (IOException exp) {\n+            throw new IllegalArgumentException(taskHelper.getMessage(\n+                    \"err.cannot.read.module.info\", modInfoPath), exp);\n+        }\n@@ -629,1 +813,3 @@\n-    private static Platform targetPlatform(Configuration cf, Map<String, Path> modsPaths) throws IOException {\n+    private static Platform targetPlatform(Configuration cf,\n+                                           Map<String, Path> modsPaths,\n+                                           boolean runtimeImageLink) throws IOException {\n@@ -632,1 +818,1 @@\n-        if (isJavaBaseFromDefaultModulePath(javaBasePath)) {\n+        if (runtimeImageLink || isJavaBaseFromDefaultModulePath(javaBasePath)) {\n@@ -723,1 +909,1 @@\n-        if (modules.isEmpty())\n+        if (modules.isEmpty()) {\n@@ -725,0 +911,1 @@\n+        }\n@@ -848,85 +1035,4 @@\n-    private static class ImageHelper implements ImageProvider {\n-        final Platform targetPlatform;\n-        final Path packagedModulesPath;\n-        final boolean ignoreSigning;\n-        final Runtime.Version version;\n-        final Set<Archive> archives;\n-\n-        ImageHelper(Configuration cf,\n-                    Map<String, Path> modsPaths,\n-                    Platform targetPlatform,\n-                    Path packagedModulesPath,\n-                    boolean ignoreSigning) throws IOException {\n-            Objects.requireNonNull(targetPlatform);\n-            this.targetPlatform = targetPlatform;\n-            this.packagedModulesPath = packagedModulesPath;\n-            this.ignoreSigning = ignoreSigning;\n-\n-            \/\/ use the version of java.base module, if present, as\n-            \/\/ the release version for multi-release JAR files\n-            this.version = cf.findModule(\"java.base\")\n-                .map(ResolvedModule::reference)\n-                .map(ModuleReference::descriptor)\n-                .flatMap(ModuleDescriptor::version)\n-                .map(ModuleDescriptor.Version::toString)\n-                .map(Runtime.Version::parse)\n-                .orElse(Runtime.version());\n-\n-            this.archives = modsPaths.entrySet().stream()\n-                                .map(e -> newArchive(e.getKey(), e.getValue()))\n-                                .collect(Collectors.toSet());\n-        }\n-\n-        private Archive newArchive(String module, Path path) {\n-            if (path.toString().endsWith(\".jmod\")) {\n-                return new JmodArchive(module, path);\n-            } else if (path.toString().endsWith(\".jar\")) {\n-                ModularJarArchive modularJarArchive = new ModularJarArchive(module, path, version);\n-\n-                try (Stream<Archive.Entry> entries = modularJarArchive.entries()) {\n-                    boolean hasSignatures = entries.anyMatch((entry) -> {\n-                        String name = entry.name().toUpperCase(Locale.ROOT);\n-\n-                        return name.startsWith(\"META-INF\/\") && name.indexOf('\/', 9) == -1 && (\n-                                name.endsWith(\".SF\") ||\n-                                name.endsWith(\".DSA\") ||\n-                                name.endsWith(\".RSA\") ||\n-                                name.endsWith(\".EC\") ||\n-                                name.startsWith(\"META-INF\/SIG-\")\n-                        );\n-                    });\n-\n-                    if (hasSignatures) {\n-                        if (ignoreSigning) {\n-                            System.err.println(taskHelper.getMessage(\"warn.signing\", path));\n-                        } else {\n-                            throw new IllegalArgumentException(taskHelper.getMessage(\"err.signing\", path));\n-                        }\n-                    }\n-                }\n-\n-                return modularJarArchive;\n-            } else if (Files.isDirectory(path)) {\n-                Path modInfoPath = path.resolve(\"module-info.class\");\n-                if (Files.isRegularFile(modInfoPath)) {\n-                    return new DirArchive(path, findModuleName(modInfoPath));\n-                } else {\n-                    throw new IllegalArgumentException(\n-                        taskHelper.getMessage(\"err.not.a.module.directory\", path));\n-                }\n-            } else {\n-                throw new IllegalArgumentException(\n-                    taskHelper.getMessage(\"err.not.modular.format\", module, path));\n-            }\n-        }\n-\n-        private static String findModuleName(Path modInfoPath) {\n-            try (BufferedInputStream bis = new BufferedInputStream(\n-                    Files.newInputStream(modInfoPath))) {\n-                return ModuleDescriptor.read(bis).name();\n-            } catch (IOException exp) {\n-                throw new IllegalArgumentException(taskHelper.getMessage(\n-                    \"err.cannot.read.module.info\", modInfoPath), exp);\n-            }\n-        }\n-\n+    private static record ImageHelper(Set<Archive> archives,\n+                                      Platform targetPlatform,\n+                                      Path packagedModulesPath,\n+                                      boolean generateRuntimeImage) implements ImageProvider {\n@@ -936,1 +1042,1 @@\n-                    targetPlatform.arch().byteOrder(), stack);\n+                    targetPlatform.arch().byteOrder(), stack, generateRuntimeImage, taskHelper);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":230,"deletions":124,"binary":false,"changes":354,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import jdk.tools.jlink.internal.runtimelink.ResourceDiff;\n+\n+\/**\n+ * Class that supports the feature of running jlink based on the current\n+ * run-time image.\n+ *\/\n+public class LinkableRuntimeImage {\n+\n+    \/\/ meta-data files per module for supporting linking from the run-time image\n+    public static final String RESPATH_PATTERN = \"jdk\/tools\/jlink\/internal\/runtimelink\/fs_%s_files\";\n+    \/\/ The diff files per module for supporting linking from the run-time image\n+    public static final String DIFF_PATTERN = \"jdk\/tools\/jlink\/internal\/runtimelink\/diff_%s\";\n+\n+    \/**\n+     * In order to be able to show whether or not a runtime is capable of\n+     * linking from it in {@code jlink --help} we need to look for the delta\n+     * files in the {@code jdk.jlink} module. If present we have the capability.\n+     *\n+     * @return {@code true} iff this jlink is capable of linking from the\n+     *         run-time image.\n+     *\/\n+    public static boolean isLinkableRuntime() {\n+        try (InputStream in = getDiffInputStream(\"java.base\")) {\n+            return in != null;\n+        } catch (IOException e) {\n+            \/\/ fall-through\n+        }\n+        return false;\n+    }\n+\n+    private static InputStream getDiffInputStream(String module) throws IOException {\n+        String resourceName = String.format(DIFF_PATTERN, module);\n+        return LinkableRuntimeImage.class.getModule().getResourceAsStream(resourceName);\n+    }\n+\n+    public static Archive newArchive(String module,\n+                                     Path path,\n+                                     boolean ignoreModifiedRuntime,\n+                                     TaskHelper taskHelper) {\n+        assert isLinkableRuntime();\n+        \/\/ Here we retrieve the per module difference file, which is\n+        \/\/ potentially empty, from the modules image and pass that on to\n+        \/\/ JRTArchive for further processing. When streaming resources from\n+        \/\/ the archive, the diff is being applied.\n+        List<ResourceDiff> perModuleDiff = null;\n+        try (InputStream in = getDiffInputStream(module)){\n+            perModuleDiff = ResourceDiff.read(in);\n+        } catch (IOException e) {\n+            throw new AssertionError(\"Failure to retrieve resource diff for \" +\n+                                     \"module \" + module, e);\n+        }\n+        return new JRTArchive(module, path, !ignoreModifiedRuntime, perModuleDiff, taskHelper);\n+    }\n+\n+\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/LinkableRuntimeImage.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -31,1 +31,0 @@\n-import java.nio.file.Paths;\n@@ -33,6 +32,0 @@\n-import java.util.Map;\n-import java.util.HashMap;\n-import java.util.Map.Entry;\n-import java.util.Set;\n-import java.util.HashSet;\n-import java.util.List;\n@@ -41,1 +34,0 @@\n-import java.util.stream.Stream;\n@@ -43,0 +35,4 @@\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n@@ -44,1 +40,2 @@\n-import java.util.ResourceBundle;\n+import java.util.Map;\n+import java.util.Map.Entry;\n@@ -46,2 +43,3 @@\n-import java.util.Comparator;\n-\n+import java.util.ResourceBundle;\n+import java.util.Set;\n+import java.util.stream.Stream;\n@@ -58,1 +56,0 @@\n-import jdk.tools.jlink.plugin.PluginException;\n@@ -587,1 +584,1 @@\n-        public void showHelp(String progName) {\n+        public void showHelp(String progName, boolean linkableRuntimeEnabled) {\n@@ -597,0 +594,4 @@\n+            \/\/ If the JDK build has the run-time image capability show it\n+            \/\/ in the help output\n+            log.println(bundleHelper.getMessage(\"main.runtime.image.linking.capability\",\n+                                                linkableRuntimeEnabled ? \"+\" : \"-\"));\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/TaskHelper.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.tools.jlink.internal.runtimelink;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+\/**\n+ * Generates a delta between packaged modules (as an ImageResource) and an\n+ * optimized jimage (lib\/modules) as an ImageResource. The result can be\n+ * serialized to a file using {@link ResourceDiff}.\n+ *\/\n+public class JimageDiffGenerator {\n+\n+    \/**\n+     * A resource used for linking. Either packaged modules or\n+     * packaged modules transformed to an optimized run-time image by applying\n+     * the jlink plug-in pipeline. The canonical source, the packaged modules,\n+     * are being used to devise the delta to the transformed run-time image. The\n+     * delta can can then be used for jlink input together *with* a prepared\n+     * run-time image.\n+     *\/\n+    @SuppressWarnings(\"try\")\n+    public interface ImageResource extends AutoCloseable {\n+        public List<String> getEntries();\n+        public byte[] getResourceBytes(String name);\n+    }\n+\n+    \/**\n+     * Produce a difference between packaged modules' resources (base) and the\n+     * result of all plug-ins being applied on those resources (image).\n+     *\n+     * @param base\n+     *            The ImageResource view of unmodified resources coming from\n+     *            packaged modules.\n+     * @param image\n+     *            The ImageResource view of the jlink plug-in pipeline having\n+     *            been applied to the resources in base.\n+     * @return The list of resource differences across all modules.\n+     *\/\n+    public List<ResourceDiff> generateDiff(ImageResource base, ImageResource image) throws Exception {\n+        List<String> baseResources;\n+        Set<String> resources = new HashSet<>();\n+        List<ResourceDiff> diffs = new ArrayList<>();\n+        try (base; image) {\n+            resources.addAll(image.getEntries());\n+            baseResources = base.getEntries();\n+            for (String item: baseResources) {\n+                byte[] baseBytes = base.getResourceBytes(item);\n+                \/\/ First check that every item in the base image exist in\n+                \/\/ the optimized image as well. If it does not, it's a removed\n+                \/\/ item in the optimized image.\n+                if (!resources.remove(item)) {\n+                    \/\/ keep track of original bytes for removed item in the\n+                    \/\/ optimized image, since we need to restore them for the\n+                    \/\/ runtime image link\n+                    ResourceDiff.Builder builder = new ResourceDiff.Builder();\n+                    ResourceDiff diff = builder.setKind(ResourceDiff.Kind.REMOVED)\n+                           .setName(item)\n+                           .setResourceBytes(baseBytes)\n+                           .build();\n+                    diffs.add(diff);\n+                    continue;\n+                }\n+                \/\/ Verify resource bytes are equal if present in both images\n+                boolean contentEquals = Arrays.equals(baseBytes, image.getResourceBytes(item));\n+                if (!contentEquals) {\n+                    \/\/ keep track of original bytes (non-optimized)\n+                    ResourceDiff.Builder builder = new ResourceDiff.Builder();\n+                    ResourceDiff diff = builder.setKind(ResourceDiff.Kind.MODIFIED)\n+                        .setName(item)\n+                        .setResourceBytes(baseBytes)\n+                        .build();\n+                    diffs.add(diff);\n+                }\n+            }\n+        }\n+        \/\/ What's now left in the set are the resources only present in the\n+        \/\/ optimized image (generated by some plugins; not present in jmods)\n+        for (String e: resources) {\n+            ResourceDiff.Builder builder = new ResourceDiff.Builder();\n+            ResourceDiff diff = builder.setKind(ResourceDiff.Kind.ADDED)\n+                                    .setName(e)\n+                                    .build();\n+            diffs.add(diff);\n+        }\n+        return diffs;\n+    }\n+\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/JimageDiffGenerator.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,286 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.tools.jlink.internal.runtimelink;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * Class representing a difference of a jimage resource. For all intents\n+ * and purposes this represents a difference between a resource in an optimized\n+ * jimage (e.g. images\/jdk\/lib\/modules) and the underlying basic resources from\n+ * which the optimized image got derived from (e.g. packaged modules). The\n+ * differences are being used in JRTArchive so as to back-track from an optimized\n+ * jimage to the original (i.e. it restores original resources using the diff).\n+ *\/\n+public class ResourceDiff implements Comparable<ResourceDiff> {\n+\n+    private static final int MAGIC = 0xabba;\n+\n+    public static enum Kind {\n+        ADDED((short)1),    \/\/ Resource added\n+        REMOVED((short)2),  \/\/ Resource removed\n+        MODIFIED((short)3); \/\/ Resource modified\n+\n+        private short value;\n+\n+        private Kind(short value) {\n+            this.value = value;\n+        }\n+\n+        public short value() {\n+            return value;\n+        }\n+\n+        static Kind fromShort(short v) {\n+            if (v > 3 || v < 1) {\n+                throw new IllegalArgumentException(\"Must be within range [1-3]\");\n+            }\n+            switch (v) {\n+            case 1: return ADDED;\n+            case 2: return REMOVED;\n+            case 3: return MODIFIED;\n+            }\n+            throw new AssertionError(\"Must not reach here!\");\n+        }\n+    }\n+\n+    private final Kind kind;\n+    private final byte[] resourceBytes;\n+    private final String name;\n+\n+    private ResourceDiff(Kind kind, String name, byte[] resourceBytes) {\n+        this.kind = kind;\n+        this.name = name;\n+        if ((kind == Kind.REMOVED || kind == Kind.MODIFIED) &&\n+                resourceBytes == null) {\n+            throw new AssertionError(\"Resource bytes must be set for REMOVED or MODIFIED\");\n+        }\n+        this.resourceBytes = resourceBytes;\n+    }\n+\n+    public Kind getKind() {\n+        return kind;\n+    }\n+\n+    public byte[] getResourceBytes() {\n+        return resourceBytes;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public int compareTo(ResourceDiff o) {\n+        int kindComp = kind.value() - o.kind.value();\n+        if (kindComp == 0) {\n+            return getName().compareTo(o.getName());\n+        } else {\n+            return kindComp;\n+        }\n+    }\n+\n+    public static class Builder {\n+        private Kind kind;\n+        private String name;\n+        private byte[] resourceBytes;\n+\n+        public Builder setKind(Kind kind) {\n+            this.kind = kind;\n+            return this;\n+        }\n+        public Builder setName(String name) {\n+            this.name = Objects.requireNonNull(name);\n+            return this;\n+        }\n+        public Builder setResourceBytes(byte[] resourceBytes) {\n+            this.resourceBytes = Objects.requireNonNull(resourceBytes);\n+            return this;\n+        }\n+        public ResourceDiff build() {\n+            if (kind == null || name == null) {\n+                throw new AssertionError(\"kind and name must be set\");\n+            }\n+            switch (kind) {\n+            case ADDED:\n+                {\n+                    break; \/\/ null bytes for added is OK.\n+                }\n+            case MODIFIED: \/\/ fall-through\n+            case REMOVED:\n+                {\n+                    if (resourceBytes == null) {\n+                        throw new AssertionError(\"Original bytes needed for MODIFIED, REMOVED!\");\n+                    }\n+                    break;\n+                }\n+            default:\n+                break;\n+            }\n+            return new ResourceDiff(kind, name, resourceBytes);\n+        }\n+    }\n+\n+    \/**\n+     * Writes a list of resource diffs to an output stream\n+     *\n+     * @param diffs The list of resource diffs to write.\n+     * @param out The stream to write the serialized bytes to.\n+     *\/\n+    public static void write(List<ResourceDiff> diffs, OutputStream out) throws IOException {\n+        \/*\n+         * Simple binary format:\n+         *\n+         * <header>|<items>\n+         *\n+         * ****************************************\n+         * HEADER info\n+         * ****************************************\n+         *\n+         * where <header> is ('|' separation for clarity):\n+         *\n+         *  <int>|<int>\n+         *\n+         * The first integer is the MAGIC, 0xabba. The second integer is the\n+         * total number of items.\n+         *\n+         * *****************************************\n+         * ITEMS info\n+         * *****************************************\n+         *\n+         * Each <item> consists of ('|' separation for clarity):\n+         *\n+         * <short>|<int>|<name-bytes-utf>|<int>|<resource-bytes>\n+         *\n+         * Where the individual items are:\n+         *\n+         * <short>:\n+         *     The value of the respective ResourceDiff.Kind.\n+         * <int>:\n+         *     The length of the name bytes (in UTF-8).\n+         * <name-bytes-utf>:\n+         *     The resource name bytes in UTF-8.\n+         * <int>:\n+         *     The length of the resource bytes. 0 (zero) if no resource bytes.\n+         *     A.k.a 'null'.\n+         * <resource-bytes>:\n+         *     The bytes of the resource as stored in the jmod files.\n+         *\/\n+        try (DataOutputStream dataOut = new DataOutputStream(out)) {\n+            dataOut.writeInt(MAGIC);\n+            dataOut.writeInt(diffs.size());\n+            for (ResourceDiff d: diffs) {\n+                dataOut.writeShort(d.kind.value());\n+                byte[] buf = d.name.getBytes(StandardCharsets.UTF_8);\n+                dataOut.writeInt(buf.length);\n+                dataOut.write(buf);\n+                buf = d.resourceBytes;\n+                dataOut.writeInt(buf == null ? 0 : buf.length);\n+                if (buf != null) {\n+                    dataOut.write(buf);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Read a list of resource diffs from an input stream.\n+     *\n+     * @param in The input stream to read from\n+     * @return The list of resource diffs.\n+     *\/\n+    public static List<ResourceDiff> read(InputStream in) throws IOException {\n+        \/*\n+         * See write() for the details how this is being written\n+         *\/\n+        List<ResourceDiff> diffs = new ArrayList<>();\n+        try (DataInputStream din = new DataInputStream(in)) {\n+            int magic = din.readInt();\n+            if (magic != MAGIC) {\n+                throw new IllegalArgumentException(\"Not a ResourceDiff data stream!\");\n+            }\n+            int numItems = din.readInt();\n+            for (int i = 0; i < numItems; i++) {\n+                Kind k = Kind.fromShort(din.readShort());\n+                int numBytes = din.readInt();\n+                byte[] buf = readBytesFromStream(din, numBytes);\n+                String name = new String(buf, StandardCharsets.UTF_8);\n+                numBytes = din.readInt();\n+                byte[] resBytes = null;\n+                if (numBytes != 0) {\n+                    resBytes = readBytesFromStream(din, numBytes);\n+                }\n+                Builder builder = new Builder();\n+                builder.setKind(k)\n+                       .setName(name);\n+                if (resBytes != null) {\n+                    builder.setResourceBytes(resBytes);\n+                }\n+                diffs.add(builder.build());\n+            }\n+        }\n+        return Collections.unmodifiableList(diffs);\n+    }\n+\n+    private static byte[] readBytesFromStream(DataInputStream din, int numBytes) throws IOException {\n+        byte[] b = new byte[numBytes];\n+        for (int i = 0; i < numBytes; i++) {\n+            int data = din.read();\n+            if (data == -1) {\n+                throw new IOException(\"Short read!\");\n+            }\n+            b[i] = (byte)data;\n+        }\n+        return b;\n+    }\n+\n+    public static void printDiffs(List<ResourceDiff> diffs) {\n+        for (ResourceDiff diff: diffs.stream().sorted().toList()) {\n+            switch (diff.getKind()) {\n+            case ADDED:\n+                System.out.println(\"Only added in opt: \" + diff.getName());\n+                break;\n+            case MODIFIED:\n+                System.out.println(\"Modified in opt: \" + diff.getName());\n+                break;\n+            case REMOVED:\n+                System.out.println(\"Removed in opt: \" + diff.getName());\n+                break;\n+            default:\n+                break;\n+            }\n+        }\n+    }\n+\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/ResourceDiff.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal.runtimelink;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+import jdk.tools.jlink.internal.runtimelink.JimageDiffGenerator.ImageResource;\n+import jdk.tools.jlink.plugin.ResourcePool;\n+import jdk.tools.jlink.plugin.ResourcePoolEntry;\n+\n+@SuppressWarnings(\"try\")\n+public class ResourcePoolReader implements ImageResource {\n+\n+    private final ResourcePool pool;\n+\n+    public ResourcePoolReader(ResourcePool pool) {\n+        this.pool = Objects.requireNonNull(pool);\n+    }\n+\n+    @Override\n+    public void close() throws Exception {\n+        \/\/ nothing\n+    }\n+\n+    @Override\n+    public List<String> getEntries() {\n+        return pool.entries().map(ResourcePoolEntry::path).toList();\n+    }\n+\n+    @Override\n+    public byte[] getResourceBytes(String name) {\n+        return pool.findEntry(name).orElseThrow().contentBytes();\n+    }\n+\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/ResourcePoolReader.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal.runtimelink;\n+\n+\/**\n+ * Exception thrown when linking from the run-time image\n+ *\/\n+public class RuntimeImageLinkException extends RuntimeException {\n+\n+    private static final long serialVersionUID = -1848914673073119403L;\n+\n+    public static enum Reason {\n+        PATCH_MODULE,  \/* link exception due to patched module *\/\n+        MODIFIED_FILE, \/* link exception due to modified file  *\/\n+    }\n+\n+    private final String file;\n+    private final Reason reason;\n+\n+    public RuntimeImageLinkException(String file, Reason reason) {\n+        this.file = file;\n+        this.reason = reason;\n+    }\n+\n+    public String getFile() {\n+        return file;\n+    }\n+\n+    public Reason getReason() {\n+        return reason;\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        return reason + \", file: \" + file;\n+    }\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/RuntimeImageLinkException.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -114,0 +114,1 @@\n+main.runtime.image.linking.capability=Capabilities: {0}run-time-image\n@@ -118,0 +119,8 @@\n+err.runtime.link.not.linkable.runtime=This JDK does not support linking from the current run-time image\n+err.runtime.link.jdk.jlink.prohibited=This JDK does not contain packaged modules\\\n+\\ and cannot be used to create another image with the jdk.jlink module\n+err.runtime.link.packaged.mods=This JDK has no packaged modules.\\\n+\\ --keep-packaged-modules is not supported.\n+err.runtime.link.modified.file={0} has been modified\n+err.runtime.link.patched.module=File {0} not found in the modules image.\\\n+\\ --patch-module is not supported when linking from the run-time image\n@@ -126,1 +135,1 @@\n-err.modulepath.must.be.specified:--module-path is not specified and this runtime image does not contain jmods directory.\n+err.modulepath.must.be.specified:--module-path is not specified and this run-time image does not contain a jmods directory\n@@ -160,0 +169,3 @@\n+\n+runtime.link.info=Linking based on the current run-time image\n+runtime.link.jprt.path.extra=(run-time image)\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -89,1 +89,3 @@\n-    jdk.containerized\n+    jdk.containerized \\\n+    jlink.runtime.linkable \\\n+    jlink.packagedModules\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,1 +105,3 @@\n-    jdk.foreign.linker\n+    jdk.foreign.linker \\\n+    jlink.runtime.linkable \\\n+    jlink.packagedModules\n","filename":"test\/jdk\/TEST.ROOT","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires jlink.packagedModules\n","filename":"test\/jdk\/jdk\/modules\/etc\/JmodExcludedFiles.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+\n+import jdk.tools.jlink.builder.ImageBuilder;\n@@ -38,0 +40,1 @@\n+import jdk.tools.jlink.internal.ExecutableImage;\n@@ -40,2 +43,0 @@\n-import jdk.tools.jlink.internal.ExecutableImage;\n-import jdk.tools.jlink.builder.ImageBuilder;\n@@ -226,1 +227,1 @@\n-        ImageFileCreator.create(archives, ByteOrder.nativeOrder(), stack);\n+        ImageFileCreator.create(archives, ByteOrder.nativeOrder(), stack, false, null);\n","filename":"test\/jdk\/tools\/jlink\/ImageFileCreatorTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.nio.ByteOrder;\n@@ -41,2 +40,1 @@\n-import jdk.tools.jlink.internal.Jlink;\n-import jdk.tools.jlink.internal.JlinkTask;\n+\n@@ -44,4 +42,0 @@\n-import jdk.tools.jlink.internal.Platform;\n-import jdk.tools.jlink.plugin.ResourcePool;\n-import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n-import jdk.tools.jlink.plugin.Plugin;\n@@ -49,0 +43,1 @@\n+import jdk.tools.jlink.internal.Jlink;\n@@ -51,0 +46,2 @@\n+import jdk.tools.jlink.internal.JlinkTask;\n+import jdk.tools.jlink.internal.Platform;\n@@ -52,3 +49,3 @@\n-import jdk.tools.jlink.internal.plugins.DefaultCompressPlugin;\n-import jdk.tools.jlink.internal.plugins.DefaultStripDebugPlugin;\n-\n+import jdk.tools.jlink.plugin.Plugin;\n+import jdk.tools.jlink.plugin.ResourcePool;\n+import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n@@ -77,2 +74,0 @@\n-    private static final List<Integer> ordered = new ArrayList<>();\n-\n@@ -165,1 +160,1 @@\n-                JlinkTask.newModuleFinder(modulePaths, limits, mods));\n+                JlinkTask.newModuleFinder(modulePaths, limits, mods), false, false, false);\n","filename":"test\/jdk\/tools\/jlink\/IntegrationTest.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -24,3 +24,0 @@\n-import jdk.test.lib.compiler.CompilerUtils;\n-import tests.JImageGenerator;\n-\n@@ -32,0 +29,22 @@\n+import jdk.test.lib.compiler.CompilerUtils;\n+import tests.JImageGenerator;\n+\n+\/*\n+ * @test id=packaged_modules\n+ * @summary Make sure that modules can be linked using jlink\n+ * and deduplication works correctly when creating sub methods\n+ * @bug 8311591\n+ * @library \/test\/lib\n+ *          ..\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jmod\n+ *          jdk.jlink\/jdk.tools.jimage\n+ *          jdk.compiler\n+ * @build tests.* JLinkDedupTestBatchSizeOne jdk.test.lib.compiler.CompilerUtils\n+ * @requires jlink.packagedModules\n+ * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLinkDedupTestBatchSizeOne false\n+ *\/\n+\n@@ -33,1 +52,1 @@\n- * @test\n+ * @test id=linkable_jdk_runtimes\n@@ -46,0 +65,1 @@\n+ * @requires (jlink.runtime.linkable & !jlink.packagedModules)\n@@ -47,1 +67,1 @@\n- * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLinkDedupTestBatchSizeOne\n+ * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLinkDedupTestBatchSizeOne true\n@@ -57,4 +77,0 @@\n-    private static final String MODULE_PATH =\n-            Paths.get(JAVA_HOME, \"jmods\").toString() +\n-                    File.pathSeparator + MODS_DIR.toString();\n-\n@@ -72,2 +88,7 @@\n-    public static void compileAll() throws Throwable {\n-        if (!hasJmods()) return;\n+    private static String modulePath(boolean linkableRuntime) {\n+        return (linkableRuntime ? \"\" : (Paths.get(JAVA_HOME, \"jmods\").toString() +\n+                                        File.pathSeparator)) + MODS_DIR.toString();\n+    }\n+\n+    public static void compileAll(boolean linkableRuntime) throws Throwable {\n+        if (!linkableRuntime && !hasJmods()) return;\n@@ -83,1 +104,8 @@\n-        compileAll();\n+        if (args.length != 1) {\n+            throw new AssertionError(\"Wrong number of arguments for the test!\");\n+        }\n+        boolean linkableRuntime = Boolean.parseBoolean(args[0]);\n+        System.out.println(\"Running test on \" +\n+                               (linkableRuntime ? \"a linkable JDK runtime\" :\n+                                   \"packaged modules\") + \".\");\n+        compileAll(linkableRuntime);\n@@ -87,1 +115,1 @@\n-                .modulePath(MODULE_PATH)\n+                .modulePath(modulePath(linkableRuntime))\n","filename":"test\/jdk\/tools\/jlink\/JLinkDedupTestBatchSizeOne.java","additions":41,"deletions":13,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.spi.ToolProvider;\n+\n+\/*\n+ * @test id=run-time-image-cap-yes\n+ * @summary Test jlink --help for capability output (true)\n+ * @requires (vm.compMode != \"Xcomp\" & jlink.runtime.linkable)\n+ * @run main\/othervm JLinkHelpCapabilityTest true\n+ *\/\n+\n+\/*\n+ * @test id=run-time-image-cap-no\n+ * @summary Test jlink --help for capability output (false)\n+ * @requires (vm.compMode != \"Xcomp\" & !jlink.runtime.linkable)\n+ * @run main\/othervm JLinkHelpCapabilityTest false\n+ *\/\n+public class JLinkHelpCapabilityTest {\n+    static final ToolProvider JLINK_TOOL = ToolProvider.findFirst(\"jlink\")\n+        .orElseThrow(() ->\n+            new RuntimeException(\"jlink tool not found\")\n+        );\n+\n+    public static void main(String[] args) throws Exception {\n+        boolean runtimeLinkCap = Boolean.parseBoolean(args[0]);\n+        String capabilities = String.format(\"Capabilities: %srun-time-image\",\n+                                            runtimeLinkCap ? \"+\" : \"-\");\n+        {\n+            \/\/ Verify capability in --help output\n+            StringWriter writer = new StringWriter();\n+            PrintWriter pw = new PrintWriter(writer);\n+            JLINK_TOOL.run(pw, pw, \"--help\");\n+            String output = writer.toString().trim();\n+            String lines[] = output.split(\"\\n\");\n+            if (!capabilities.equals(lines[lines.length - 1])) {\n+                System.err.println(output);\n+                throw new AssertionError(\"'--help': Capabilities mismatch. Expected: '\" + capabilities +\"'\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JLinkHelpCapabilityTest.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires jlink.packagedModules\n","filename":"test\/jdk\/tools\/jlink\/multireleasejar\/JLinkMRJavaBaseVersionTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -24,0 +24,3 @@\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+\n@@ -35,0 +38,3 @@\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n@@ -40,5 +46,15 @@\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.Test;\n-\n-import static java.lang.constant.ConstantDescs.CD_Object;\n-import static java.lang.constant.ConstantDescs.CD_int;\n+\/*\n+ * @test id=packaged_modules\n+ * @bug 8252919 8327499\n+ * @library ..\/..\/lib\n+ * @summary Test --generate-jli-classes plugin\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.internal.plugins\n+ *          jdk.jlink\/jdk.tools.jmod\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @requires jlink.packagedModules\n+ * @build tests.*\n+ * @run testng\/othervm -DlinkableRuntime=false GenerateJLIClassesPluginTest\n+ *\/\n@@ -47,1 +63,1 @@\n- * @test\n+ * @test id=linkable_jdk_runtimes\n@@ -57,0 +73,1 @@\n+ * @requires (jlink.runtime.linkable & !jlink.packagedModules)\n@@ -58,1 +75,1 @@\n- * @run testng\/othervm GenerateJLIClassesPluginTest\n+ * @run testng\/othervm -DlinkableRuntime=true GenerateJLIClassesPluginTest\n@@ -62,0 +79,1 @@\n+    private static final String LINKABLE_RUNTIME_PROP = \"linkableRuntime\";\n@@ -66,1 +84,4 @@\n-        helper = Helper.newHelper();\n+        boolean isLinkableRuntime = Boolean.getBoolean(LINKABLE_RUNTIME_PROP);\n+        System.out.println(\"Tests run on \" +\n+                           (isLinkableRuntime ? \"linkable JDK runtime.\" : \"packaged modules.\"));\n+        helper = Helper.newHelper(isLinkableRuntime);\n","filename":"test\/jdk\/tools\/jlink\/plugins\/GenerateJLIClassesPluginTest.java","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.util.Arrays;\n@@ -27,0 +26,1 @@\n+import java.util.Arrays;\n@@ -31,1 +31,0 @@\n-import jdk.tools.jlink.plugin.PluginException;\n@@ -34,0 +33,1 @@\n+import jdk.tools.jlink.plugin.PluginException;\n@@ -40,1 +40,1 @@\n- * @test\n+ * @test id=packaged_modules\n@@ -46,1 +46,1 @@\n- * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @requires (jlink.packagedModules & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n@@ -58,1 +58,23 @@\n- * @run main\/othervm\/timeout=180 -Xmx1g IncludeLocalesPluginTest\n+ * @run main\/othervm\/timeout=180 -Xmx1g IncludeLocalesPluginTest false\n+ *\/\n+\n+\/*\n+ * @test id=linkable_jdk_runtimes\n+ * @bug 8152143 8152704 8155649 8165804 8185841 8176841 8190918\n+ *      8179071 8202537 8221432 8222098 8251317 8258794 8265315\n+ *      8296248 8306116 8174269\n+ * @summary IncludeLocalesPlugin tests\n+ * @author Naoto Sato\n+ * @requires (jlink.runtime.linkable & !jlink.packagedModules & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.internal.plugins\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jmod\n+ *          jdk.jlink\/jdk.tools.jimage\n+ *          jdk.compiler\n+ * @build tests.*\n+ * @build tools.jlink.plugins.GetAvailableLocales\n+ * @run main\/othervm\/timeout=180 -Xmx1g IncludeLocalesPluginTest true\n@@ -62,1 +84,1 @@\n-    private final static String moduleName = \"IncludeLocalesTest\";\n+    private static final String moduleName = \"IncludeLocalesTest\";\n@@ -64,6 +86,6 @@\n-    private final static int INCLUDE_LOCALES_OPTION = 0;\n-    private final static int ADDMODS_OPTION         = 1;\n-    private final static int EXPECTED_LOCATIONS     = 2;\n-    private final static int UNEXPECTED_PATHS       = 3;\n-    private final static int AVAILABLE_LOCALES      = 4;\n-    private final static int ERROR_MESSAGE          = 5;\n+    private static final int INCLUDE_LOCALES_OPTION = 0;\n+    private static final int ADDMODS_OPTION         = 1;\n+    private static final int EXPECTED_LOCATIONS     = 2;\n+    private static final int UNEXPECTED_PATHS       = 3;\n+    private static final int AVAILABLE_LOCALES      = 4;\n+    private static final int ERROR_MESSAGE          = 5;\n@@ -415,1 +437,10 @@\n-        helper = Helper.newHelper();\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Usage: \" +\n+                                       IncludeLocalesPluginTest.class.getSimpleName() +\n+                                       \" {true,false}\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        System.out.println(\"Running test on \" +\n+                           (isLinkableRuntime ? \"linkable JDK runtime.\" : \"packaged modules.\"));\n+\n+        helper = Helper.newHelper(isLinkableRuntime);\n","filename":"test\/jdk\/tools\/jlink\/plugins\/IncludeLocalesPluginTest.java","additions":44,"deletions":13,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -0,0 +1,703 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.FileVisitor;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import tests.Helper;\n+import tests.JImageGenerator;\n+import tests.JImageGenerator.JLinkTask;\n+import tests.JImageValidator;\n+\n+public abstract class AbstractLinkableRuntimeTest {\n+\n+    protected static final boolean DEBUG = true;\n+\n+    public void run(boolean isLinkableRuntime) throws Exception {\n+        Helper helper = Helper.newHelper(isLinkableRuntime);\n+        if (helper == null) {\n+            System.err.println(AbstractLinkableRuntimeTest.class.getSimpleName() +\n+                               \": Test not run\");\n+            return;\n+        }\n+        runTest(helper, isLinkableRuntime);\n+        System.out.println(getClass().getSimpleName() + \" PASSED!\");\n+    }\n+\n+    \/**\n+     * Main test entry point that actual tests ought to override.\n+     *\n+     * @param helper The jlink helper\n+     * @param isLinkableRuntime {@code true} iff the JDK build under test already\n+     *                          includes the linkable runtime capability in jlink.\n+     * @throws Exception\n+     *\/\n+    abstract void runTest(Helper helper, boolean isLinkableRuntime) throws Exception;\n+\n+    \/**\n+     * Ensure 'java --list-modules' lists the correct set of modules in the given\n+     * image.\n+     *\n+     * @param jlinkImage\n+     * @param expectedModules\n+     *\/\n+    protected void verifyListModules(Path image,\n+            List<String> expectedModules) throws Exception {\n+        OutputAnalyzer out = runJavaCmd(image, List.of(\"--list-modules\"));\n+        List<String> actual = parseListMods(out.getStdout());\n+        Collections.sort(actual);\n+        if (!expectedModules.equals(actual)) {\n+            throw new AssertionError(\"Different modules! Expected \" + expectedModules + \" got: \" + actual);\n+        }\n+    }\n+\n+    protected OutputAnalyzer runJavaCmd(Path image, List<String> options) throws Exception {\n+        Path targetJava = image.resolve(\"bin\").resolve(getJava());\n+        List<String> cmd = new ArrayList<>();\n+        cmd.add(targetJava.toString());\n+        for (String opt: options) {\n+            cmd.add(opt);\n+        }\n+        List<String> javaCmd = Collections.unmodifiableList(cmd);\n+        OutputAnalyzer out;\n+        try {\n+            out = ProcessTools.executeCommand(javaCmd.toArray(new String[0]));\n+        } catch (Throwable e) {\n+            throw new Exception(\"Process failed to execute\", e);\n+        }\n+        if (out.getExitValue() != 0) {\n+            if (DEBUG) {\n+                System.err.println(\"Process stdout was: \");\n+                System.err.println(out.getStdout());\n+                System.err.println(\"Process stderr was: \");\n+                System.err.println(out.getStderr());\n+            }\n+            throw new AssertionError(\"'\" + javaCmd.stream().collect(Collectors.joining(\" \")) + \"'\"\n+                    + \" expected to succeed!\");\n+        }\n+        return out;\n+    }\n+\n+    protected Path createJavaImageRuntimeLink(BaseJlinkSpec baseSpec) throws Exception {\n+        return createJavaImageRuntimeLink(baseSpec, Collections.emptySet() \/* exclude all jmods *\/);\n+    }\n+\n+    protected Path createJavaImageRuntimeLink(BaseJlinkSpec baseSpec, Set<String> excludedJmods) throws Exception {\n+        \/\/ Be sure we have a JDK without JMODs\n+        Path runtimeJlinkImage = createRuntimeLinkImage(baseSpec, excludedJmods);\n+\n+        \/\/ On Windows jvm.dll is in 'bin' after the jlink\n+        Path libjvm = Path.of((isWindows() ? \"bin\" : \"lib\"), \"server\", System.mapLibraryName(\"jvm\"));\n+        JlinkSpecBuilder builder = new JlinkSpecBuilder();\n+        \/\/ And expect libjvm (not part of the jimage) to be present in the resulting image\n+        builder.expectedFile(libjvm.toString())\n+               .helper(baseSpec.getHelper())\n+               .name(baseSpec.getName())\n+               .validatingModule(baseSpec.getValidatingModule())\n+               .imagePath(runtimeJlinkImage)\n+               .expectedLocation(\"\/java.base\/java\/lang\/String.class\");\n+        for (String m: baseSpec.getModules()) {\n+            builder.addModule(m);\n+        }\n+        for (String extra: baseSpec.getExtraOptions()) {\n+            builder.extraJlinkOpt(extra);\n+        }\n+        return jlinkUsingImage(builder.build());\n+    }\n+\n+    protected Path jlinkUsingImage(JlinkSpec spec) throws Exception {\n+        return jlinkUsingImage(spec, new RuntimeLinkOutputAnalyzerHandler());\n+    }\n+\n+    protected Path jlinkUsingImage(JlinkSpec spec, OutputAnalyzerHandler handler) throws Exception {\n+        return jlinkUsingImage(spec, handler, new DefaultSuccessExitPredicate());\n+    }\n+\n+    protected Path jlinkUsingImage(JlinkSpec spec, OutputAnalyzerHandler handler, Predicate<OutputAnalyzer> exitChecker) throws Exception {\n+        String generatedImage = \"target-run-time-\" + spec.getName();\n+        Path targetImageDir = spec.getHelper().createNewImageDir(generatedImage);\n+        Path targetJlink = spec.getImageToUse().resolve(\"bin\").resolve(getJlink());\n+        String[] jlinkCmdArray = new String[] {\n+                targetJlink.toString(),\n+                \"--output\", targetImageDir.toString(),\n+                \"--verbose\",\n+                \"--add-modules\", spec.getModules().stream().collect(Collectors.joining(\",\"))\n+        };\n+        List<String> jlinkCmd = new ArrayList<>();\n+        jlinkCmd.addAll(Arrays.asList(jlinkCmdArray));\n+        if (spec.getExtraJlinkOpts() != null && !spec.getExtraJlinkOpts().isEmpty()) {\n+            jlinkCmd.addAll(spec.getExtraJlinkOpts());\n+        }\n+        if (spec.getModulePath() != null) {\n+            for (String mp: spec.getModulePath()) {\n+                jlinkCmd.add(\"--module-path\");\n+                jlinkCmd.add(mp);\n+            }\n+        }\n+        jlinkCmd = Collections.unmodifiableList(jlinkCmd); \/\/ freeze\n+        System.out.println(\"DEBUG: run-time image based jlink command: \" +\n+                           jlinkCmd.stream().collect(Collectors.joining(\" \")));\n+        OutputAnalyzer analyzer = null;\n+        try {\n+            analyzer = ProcessTools.executeProcess(jlinkCmd.toArray(new String[0]));\n+        } catch (Throwable t) {\n+            throw new AssertionError(\"Executing process failed!\", t);\n+        }\n+        if (!exitChecker.test(analyzer)) {\n+            if (DEBUG) {\n+                System.err.println(\"Process stdout was: \");\n+                System.err.println(analyzer.getStdout());\n+                System.err.println(\"Process stderr was: \");\n+                System.err.println(analyzer.getStderr());\n+            }\n+            \/\/ if the exit checker failed, we expected the other outcome\n+            \/\/ i.e. fail for success and success for fail.\n+            boolean successExit = analyzer.getExitValue() == 0;\n+            String msg = String.format(\"Expected jlink to %s given a jmodless image. Exit code was: %d\",\n+                                       (successExit ? \"fail\" : \"pass\"), analyzer.getExitValue());\n+            throw new AssertionError(msg);\n+        }\n+        handler.handleAnalyzer(analyzer); \/\/ Give tests a chance to process in\/output\n+\n+        \/\/ validate the resulting image; Includes running 'java -version', only do this\n+        \/\/ if the jlink succeeded.\n+        if (analyzer.getExitValue() == 0) {\n+            JImageValidator validator = new JImageValidator(spec.getValidatingModule(), spec.getExpectedLocations(),\n+                    targetImageDir.toFile(), spec.getUnexpectedLocations(), Collections.emptyList(), spec.getExpectedFiles());\n+            validator.validate(); \/\/ This doesn't validate locations\n+            if (!spec.getExpectedLocations().isEmpty() || !spec.getUnexpectedLocations().isEmpty()) {\n+                JImageValidator.validate(targetImageDir.resolve(\"lib\").resolve(\"modules\"), spec.getExpectedLocations(), spec.getUnexpectedLocations());\n+            }\n+        }\n+        return targetImageDir;\n+    }\n+\n+    \/**\n+     * Prepares the test for execution. This assumes the current runtime\n+     * supports linking from it. However, since the 'jmods' dir might be present\n+     * (default jmods module path), the 'jmods' directory needs to get removed\n+     * to provoke actual linking from the run-time image.\n+     *\n+     * @param baseSpec\n+     * @return A path to a JDK that is capable for linking from the run-time\n+     *         image.\n+     * @throws Exception\n+     *\/\n+    protected Path createRuntimeLinkImage(BaseJlinkSpec baseSpec) throws Exception {\n+        return createRuntimeLinkImage(baseSpec, Collections.emptySet() \/* exclude all jmods *\/);\n+    }\n+\n+    \/**\n+     * Prepares the test for execution. Creates a JDK with a jlink that has the\n+     * capability to link from the run-time image (if needed). It further\n+     * ensures that if packaged modules ('jmods' dir) are present, to remove\n+     * them entirely or as specified in the {@link excludedJmodFiles} set. If\n+     * that set is empty, all packaged modules will be removed. Note that with\n+     * packaged modules present no run-time image based linking would be done.\n+     *\n+     * @param baseSpec\n+     *            The specification for the custom - run-time image link capable\n+     *            - JDK to create via jlink (if any)\n+     * @param excludedJmods\n+     *            The set of jmod files to exclude in the base JDK. Empty set if\n+     *            all JMODs should be removed.\n+     * @return A path to a JDK, including jdk.jlink, that has the run-time image\n+     * link capability.\n+     *\n+     * @throws Exception\n+     *\/\n+    protected Path createRuntimeLinkImage(BaseJlinkSpec baseSpec,\n+                                          Set<String> excludedJmodFiles) throws Exception {\n+        \/\/ Depending on the shape of the JDK under test, we either only filter\n+        \/\/ jmod files or create a run-time image link capable JDK on-the-fly.\n+        Path from = null;\n+        Path runtimeJlinkImage = null;\n+        String finalName = baseSpec.getName() + \"-jlink\";\n+        if (baseSpec.isLinkableRuntime()) {\n+            \/\/ The build is already run-time image link capable\n+            String javaHome = System.getProperty(\"java.home\");\n+            from = Path.of(javaHome);\n+        } else {\n+            \/\/ Create a run-time image capable JDK using --generate-linkable-runtime\n+            Path tempRuntimeImage = Path.of(finalName + \"-tmp\");\n+            JLinkTask task = JImageGenerator.getJLinkTask();\n+            task.output(tempRuntimeImage)\n+                .addMods(\"jdk.jlink\") \/\/ that modules is always needed for the test\n+                .option(\"--generate-linkable-runtime\");\n+            if (baseJDKhasPackagedModules()) {\n+                Path jmodsPath = tempRuntimeImage.resolve(\"jmods\");\n+                task.option(\"--keep-packaged-modules=\" + jmodsPath);\n+            }\n+            for (String module: baseSpec.getModules()) {\n+                task.addMods(module);\n+            }\n+            task.call().assertSuccess();\n+            from = tempRuntimeImage;\n+        }\n+\n+        \/\/ Create the target directory\n+        runtimeJlinkImage = baseSpec.getHelper().createNewImageDir(finalName);\n+\n+        \/\/ Remove JMODs as needed for the test\n+        copyJDKTreeWithoutSpecificJmods(from, runtimeJlinkImage, excludedJmodFiles);\n+        \/\/ Verify the base image is actually without desired packaged modules\n+        if (excludedJmodFiles.isEmpty()) {\n+            if (Files.exists(runtimeJlinkImage.resolve(\"jmods\"))) {\n+                throw new AssertionError(\"Must not contain 'jmods' directory\");\n+            }\n+        } else {\n+            Path basePath = runtimeJlinkImage.resolve(\"jmods\");\n+            for (String jmodFile: excludedJmodFiles) {\n+                Path unexpectedFile = basePath.resolve(Path.of(jmodFile));\n+                if (Files.exists(unexpectedFile)) {\n+                    throw new AssertionError(\"Must not contain jmod: \" + unexpectedFile);\n+                }\n+            }\n+        }\n+        return runtimeJlinkImage;\n+    }\n+\n+    private boolean baseJDKhasPackagedModules() {\n+        Path jmodsPath = Path.of(System.getProperty(\"java.home\"), \"jmods\");\n+        return jmodsPath.toFile().exists();\n+    }\n+\n+    private void copyJDKTreeWithoutSpecificJmods(Path from,\n+                                                 Path to,\n+                                                 Set<String> excludedJmods) throws Exception {\n+        if (Files.exists(to)) {\n+            throw new AssertionError(\"Expected target dir '\" + to + \"' to exist\");\n+        }\n+        FileVisitor<Path> fileVisitor = null;\n+        if (excludedJmods.isEmpty()) {\n+            fileVisitor = new ExcludeAllJmodsFileVisitor(from, to);\n+        } else {\n+            fileVisitor = new FileExcludingFileVisitor(excludedJmods,\n+                                                       from,\n+                                                       to);\n+        }\n+        Files.walkFileTree(from, fileVisitor);\n+    }\n+\n+    private List<String> parseListMods(String output) throws Exception {\n+        List<String> outputLines = new ArrayList<>();\n+        try (Scanner lineScan = new Scanner(output)) {\n+            while (lineScan.hasNextLine()) {\n+                outputLines.add(lineScan.nextLine());\n+            }\n+        }\n+        return outputLines.stream()\n+                .map(a -> { return a.split(\"@\", 2)[0];})\n+                .filter(a -> !a.isBlank())\n+                .collect(Collectors.toList());\n+    }\n+\n+    private String getJlink() {\n+        return getBinary(\"jlink\");\n+    }\n+\n+    private String getJava() {\n+        return getBinary(\"java\");\n+    }\n+\n+    private String getBinary(String binary) {\n+        return isWindows() ? binary + \".exe\" : binary;\n+    }\n+\n+    protected static boolean isWindows() {\n+        return System.getProperty(\"os.name\").startsWith(\"Windows\");\n+    }\n+\n+    static class ExcludeAllJmodsFileVisitor extends SimpleFileVisitor<Path> {\n+        private final Path root;\n+        private final Path destination;\n+\n+        private ExcludeAllJmodsFileVisitor(Path root,\n+                                           Path destination) {\n+            this.destination = destination;\n+            this.root = root;\n+        }\n+\n+        @Override\n+        public FileVisitResult preVisitDirectory(Path dir,\n+                BasicFileAttributes attrs) throws IOException {\n+            Objects.requireNonNull(dir);\n+            Path relative = root.relativize(dir);\n+            if (relative.getFileName().equals(Path.of(\"jmods\"))) {\n+                return FileVisitResult.SKIP_SUBTREE;\n+            }\n+            \/\/ Create dir in destination location\n+            Path targetDir = destination.resolve(relative);\n+            if (!Files.exists(targetDir)) {\n+                Files.createDirectory(targetDir);\n+            }\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                throws IOException {\n+            Path relative = root.relativize(file);\n+            Files.copy(file, destination.resolve(relative), StandardCopyOption.REPLACE_EXISTING);\n+            return FileVisitResult.CONTINUE;\n+        }\n+    }\n+\n+    static class FileExcludingFileVisitor extends SimpleFileVisitor<Path> {\n+\n+        private final Set<String> filesToExclude;\n+        private final Path root;\n+        private final Path destination;\n+\n+        private FileExcludingFileVisitor(Set<String> filesToExclude,\n+                                         Path root,\n+                                         Path destination) {\n+            this.filesToExclude = filesToExclude;\n+            this.destination = destination;\n+            this.root = root;\n+        }\n+\n+        @Override\n+        public FileVisitResult preVisitDirectory(Path dir,\n+                BasicFileAttributes attrs) throws IOException {\n+            Objects.requireNonNull(dir);\n+            Path relative = root.relativize(dir);\n+            \/\/ Create dir in destination location\n+            Path targetDir = destination.resolve(relative);\n+            if (!Files.exists(targetDir)) {\n+                Files.createDirectory(targetDir);\n+            }\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                throws IOException {\n+            Path relative = root.relativize(file);\n+            \/\/ Skip files as determined by the exclude set\n+            String fileName = file.getFileName().toString();\n+            if (!filesToExclude.contains(fileName)) {\n+                Files.copy(file, destination.resolve(relative), StandardCopyOption.REPLACE_EXISTING);\n+            }\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+    }\n+\n+    static class BaseJlinkSpec {\n+        final Helper helper;\n+        final String name;\n+        final String validatingModule;\n+        final List<String> modules;\n+        final List<String> extraOptions;\n+        final boolean isLinkableRuntime;\n+\n+        BaseJlinkSpec(Helper helper, String name, String validatingModule,\n+                List<String> modules, List<String> extraOptions, boolean isLinkableRuntime) {\n+            this.helper = helper;\n+            this.name = name;\n+            this.modules = modules;\n+            this.extraOptions = extraOptions;\n+            this.validatingModule = validatingModule;\n+            this.isLinkableRuntime = isLinkableRuntime;\n+        }\n+\n+        public String getValidatingModule() {\n+            return validatingModule;\n+        }\n+\n+        public Helper getHelper() {\n+            return helper;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public List<String> getModules() {\n+            return modules;\n+        }\n+\n+        public List<String> getExtraOptions() {\n+            return extraOptions;\n+        }\n+\n+        public boolean isLinkableRuntime() {\n+            return isLinkableRuntime;\n+        }\n+    }\n+\n+    static class BaseJlinkSpecBuilder {\n+        Helper helper;\n+        String name;\n+        String validatingModule;\n+        List<String> modules = new ArrayList<>();\n+        List<String> extraOptions = new ArrayList<>();\n+        boolean isLinkableRuntime;\n+\n+        BaseJlinkSpecBuilder addModule(String module) {\n+            modules.add(module);\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder addExtraOption(String option) {\n+            extraOptions.add(option);\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder setLinkableRuntime() {\n+            isLinkableRuntime = true;\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder helper(Helper helper) {\n+            this.helper = helper;\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder name(String name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder validatingModule(String module) {\n+            this.validatingModule = module;\n+            return this;\n+        }\n+\n+        BaseJlinkSpec build() {\n+            if (name == null) {\n+                throw new IllegalStateException(\"Name must be set\");\n+            }\n+            if (helper == null) {\n+                throw new IllegalStateException(\"helper must be set\");\n+            }\n+            if (modules.isEmpty()) {\n+                throw new IllegalStateException(\"modules must be set\");\n+            }\n+            if (validatingModule == null) {\n+                throw new IllegalStateException(\"the module which should get validated must be set\");\n+            }\n+            return new BaseJlinkSpec(helper, name, validatingModule, modules, extraOptions, isLinkableRuntime);\n+        }\n+    }\n+\n+    static class JlinkSpec {\n+        final Path imageToUse;\n+        final Helper helper;\n+        final String name;\n+        final List<String> modules;\n+        final String validatingModule;\n+        final List<String> expectedLocations;\n+        final List<String> unexpectedLocations;\n+        final String[] expectedFiles;\n+        final List<String> extraJlinkOpts;\n+        final List<String> modulePath;\n+\n+        JlinkSpec(Path imageToUse, Helper helper, String name, List<String> modules,\n+                String validatingModule, List<String> expectedLocations,\n+                List<String> unexpectedLocations, String[] expectedFiles,\n+                List<String> extraJlinkOpts,\n+                List<String> modulePath) {\n+            this.imageToUse = imageToUse;\n+            this.helper = helper;\n+            this.name = name;\n+            this.modules = modules;\n+            this.validatingModule = validatingModule;\n+            this.expectedLocations = expectedLocations;\n+            this.unexpectedLocations = unexpectedLocations;\n+            this.expectedFiles = expectedFiles;\n+            this.extraJlinkOpts = extraJlinkOpts;\n+            this.modulePath = modulePath;\n+        }\n+\n+        public Path getImageToUse() {\n+            return imageToUse;\n+        }\n+\n+        public Helper getHelper() {\n+            return helper;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public List<String> getModules() {\n+            return modules;\n+        }\n+\n+        public String getValidatingModule() {\n+            return validatingModule;\n+        }\n+\n+        public List<String> getExpectedLocations() {\n+            return expectedLocations;\n+        }\n+\n+        public List<String> getUnexpectedLocations() {\n+            return unexpectedLocations;\n+        }\n+\n+        public String[] getExpectedFiles() {\n+            return expectedFiles;\n+        }\n+\n+        public List<String> getExtraJlinkOpts() {\n+            return extraJlinkOpts;\n+        }\n+\n+        public List<String> getModulePath() {\n+            return modulePath;\n+        }\n+    }\n+\n+    static class JlinkSpecBuilder {\n+        Path imageToUse;\n+        Helper helper;\n+        String name;\n+        List<String> modules = new ArrayList<>();\n+        String validatingModule;\n+        List<String> expectedLocations = new ArrayList<>();\n+        List<String> unexpectedLocations = new ArrayList<>();\n+        List<String> expectedFiles = new ArrayList<>();\n+        List<String> extraJlinkOpts = new ArrayList<>();\n+        List<String> modulePath = new ArrayList<>();\n+\n+        JlinkSpec build() {\n+            if (imageToUse == null) {\n+                throw new IllegalStateException(\"No image to use for jlink specified!\");\n+            }\n+            if (helper == null) {\n+                throw new IllegalStateException(\"No helper specified!\");\n+            }\n+            if (name == null) {\n+                throw new IllegalStateException(\"No name for the image location specified!\");\n+            }\n+            if (validatingModule == null) {\n+                throw new IllegalStateException(\"No module specified for after generation validation!\");\n+            }\n+            return new JlinkSpec(imageToUse,\n+                                 helper,\n+                                 name,\n+                                 modules,\n+                                 validatingModule,\n+                                 expectedLocations,\n+                                 unexpectedLocations,\n+                                 expectedFiles.toArray(new String[0]),\n+                                 extraJlinkOpts,\n+                                 modulePath);\n+        }\n+\n+        JlinkSpecBuilder imagePath(Path image) {\n+            this.imageToUse = image;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder helper(Helper helper) {\n+            this.helper = helper;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder name(String name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder addModule(String module) {\n+            modules.add(module);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder validatingModule(String module) {\n+            this.validatingModule = module;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder addModulePath(String modulePath) {\n+            this.modulePath.add(modulePath);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder expectedLocation(String location) {\n+            expectedLocations.add(location);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder unexpectedLocation(String location) {\n+            unexpectedLocations.add(location);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder expectedFile(String file) {\n+            expectedFiles.add(file);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder extraJlinkOpt(String opt) {\n+            extraJlinkOpts.add(opt);\n+            return this;\n+        }\n+    }\n+\n+    static abstract class OutputAnalyzerHandler {\n+\n+        public abstract void handleAnalyzer(OutputAnalyzer out);\n+\n+    }\n+\n+    static class RuntimeLinkOutputAnalyzerHandler extends OutputAnalyzerHandler {\n+\n+        @Override\n+        public void handleAnalyzer(OutputAnalyzer out) {\n+            out.shouldContain(\"Linking based on the current run-time image\");\n+        }\n+\n+    }\n+\n+    static class DefaultSuccessExitPredicate implements Predicate<OutputAnalyzer> {\n+\n+        @Override\n+        public boolean test(OutputAnalyzer t) {\n+            return t.getExitValue() == 0;\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/AbstractLinkableRuntimeTest.java","additions":703,"deletions":0,"binary":false,"changes":703,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Scanner;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Test --add-options jlink plugin when linking from the run-time image\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g AddOptionsTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Test --add-options jlink plugin when linking from the run-time image\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g AddOptionsTest false\n+ *\/\n+public class AddOptionsTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        AddOptionsTest test = new AddOptionsTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+                .addExtraOption(\"--add-options\")\n+                .addExtraOption(\"-Xlog:gc=info:stderr -XX:+UseParallelGC\")\n+                .name(\"java-base-with-opts\")\n+                .addModule(\"java.base\")\n+                .validatingModule(\"java.base\")\n+                .helper(helper);\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        Path finalImage = createJavaImageRuntimeLink(builder.build());\n+        verifyListModules(finalImage, List.of(\"java.base\"));\n+        verifyParallelGCInUse(finalImage);\n+    }\n+\n+    private void verifyParallelGCInUse(Path finalImage) throws Exception {\n+        OutputAnalyzer analyzer = runJavaCmd(finalImage, List.of(\"--version\"));\n+        boolean foundMatch = false;\n+        try (Scanner lineScan = new Scanner(analyzer.getStderr())) {\n+            while (lineScan.hasNextLine()) {\n+                String line = lineScan.nextLine();\n+                if (line.endsWith(\"Using Parallel\")) {\n+                    foundMatch = true;\n+                    break;\n+                }\n+            }\n+        }\n+        if (!foundMatch) {\n+            throw new AssertionError(\"Expected Parallel GC in place for jlinked image\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/AddOptionsTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Set;\n+\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Test basic linking from the run-time image with java.base.jmod missing\n+ *          but java.xml.jmod present. It should link from the run-time image without errors.\n+ * @requires (jlink.packagedModules & jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g BasicJlinkMissingJavaBase true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Test basic linking from the run-time image with java.base.jmod missing\n+ *          but java.xml.jmod present. It should link from the run-time image without errors.\n+ * @requires (jlink.packagedModules & !jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g BasicJlinkMissingJavaBase false\n+ *\/\n+public class BasicJlinkMissingJavaBase extends AbstractLinkableRuntimeTest {\n+\n+    @Override\n+    public void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        Path finalImage = createJavaXMLRuntimeLink(helper, \"java-xml\", isLinkableRuntime);\n+        verifyListModules(finalImage, List.of(\"java.base\", \"java.xml\"));\n+    }\n+\n+    private Path createJavaXMLRuntimeLink(Helper helper, String name, boolean isLinkableRuntime) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder();\n+        builder.helper(helper)\n+               .name(name)\n+               .addModule(\"java.xml\")\n+               .validatingModule(\"java.xml\");\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        Set<String> excludedJmods = Set.of(\"java.base.jmod\");\n+        return createJavaImageRuntimeLink(builder.build(), excludedJmods);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        BasicJlinkMissingJavaBase test = new BasicJlinkMissingJavaBase();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/BasicJlinkMissingJavaBase.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Test basic linking from the run-time image\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g BasicJlinkTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Test basic linking from the run-time image\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g BasicJlinkTest false\n+ *\/\n+public class BasicJlinkTest extends AbstractLinkableRuntimeTest {\n+\n+    @Override\n+    public void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        Path finalImage = createJavaBaseRuntimeLink(helper, \"java-base\", isLinkableRuntime);\n+        verifyListModules(finalImage, List.of(\"java.base\"));\n+    }\n+\n+    private Path createJavaBaseRuntimeLink(Helper helper, String name, boolean isLinkableRuntime) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder();\n+        builder.helper(helper)\n+               .name(name)\n+               .addModule(\"java.base\")\n+               .validatingModule(\"java.base\");\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        return createJavaImageRuntimeLink(builder.build());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        BasicJlinkTest test = new BasicJlinkTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/BasicJlinkTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+class CapturingHandler extends AbstractLinkableRuntimeTest.OutputAnalyzerHandler {\n+\n+    private OutputAnalyzer output;\n+\n+    public String stdErr() {\n+        return output.getStderr();\n+    }\n+\n+    public OutputAnalyzer analyzer() {\n+        return output;\n+    }\n+\n+    @Override\n+    public void handleAnalyzer(OutputAnalyzer out) {\n+        this.output = out;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/CapturingHandler.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Test jmod-less jlink with a custom module\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g CustomModuleJlinkTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Test jmod-less jlink with a custom module\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g CustomModuleJlinkTest false\n+ *\/\n+public class CustomModuleJlinkTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        CustomModuleJlinkTest test = new CustomModuleJlinkTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        String customModule = \"leaf1\";\n+        helper.generateDefaultJModule(customModule);\n+\n+        \/\/ create a base image for linking from the run-time image\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+            .helper(helper)\n+            .name(\"cmod-jlink\")\n+            .addModule(\"java.base\")\n+            .validatingModule(\"java.base\");\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        Path jlinkImage = createRuntimeLinkImage(builder.build());\n+\n+        \/\/ Next jlink using the run-time image for java.base, but take\n+        \/\/ the custom module from the module path.\n+        Path finalImage = jlinkUsingImage(new JlinkSpecBuilder()\n+                                                .imagePath(jlinkImage)\n+                                                .helper(helper)\n+                                                .name(customModule)\n+                                                .addModulePath(helper.defaultModulePath(false))\n+                                                .expectedLocation(String.format(\"\/%s\/%s\/com\/foo\/bar\/X.class\", customModule, customModule))\n+                                                .addModule(customModule)\n+                                                .validatingModule(customModule)\n+                                                .build());\n+        \/\/ Expected only the transitive closure of \"leaf1\" module in the --list-modules\n+        \/\/ output of the java launcher.\n+        List<String> expectedModules = List.of(\"java.base\", customModule);\n+        verifyListModules(finalImage, expectedModules);\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/CustomModuleJlinkTest.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import tests.Helper;\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Verify JLI class generation in run-time image link mode\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g GenerateJLIClassesTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Verify JLI class generation in run-time image link mode\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g GenerateJLIClassesTest false\n+ *\/\n+public class GenerateJLIClassesTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        GenerateJLIClassesTest test = new GenerateJLIClassesTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    \/*\n+     * java.lang.invoke.BoundMethodHandle$Species_* classes get generated\n+     * by the GenerateJLiClassesPlugin. This test ensures that potentially\n+     * generated JLI classes from the run-time image don't populate to the\n+     * target image in the run-time image based link mode.\n+     *\/\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        Path baseFile = Files.createTempFile(\"base\", \"trace\");\n+        String species = \"LLLLLLLLLLLLLLLLLLL\";\n+        String fileString = \"[SPECIES_RESOLVE] java.lang.invoke.BoundMethodHandle$Species_\" + species + \" (salvaged)\\n\";\n+        Files.write(baseFile, fileString.getBytes(StandardCharsets.UTF_8));\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+                .helper(helper)\n+                .addModule(\"java.base\")\n+                .name(\"jlink.jli-jmodless\")\n+                .validatingModule(\"java.base\");\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+\n+        Path runtimeLinkableImage = createRuntimeLinkImage(builder.build());\n+        \/\/ Finally attempt another jmodless link reducing modules to java.base only,\n+        \/\/ and asking for specific jli classes.\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(runtimeLinkableImage)\n+                                .name(\"java.base-jli-derived\")\n+                                .addModule(\"java.base\")\n+                                .extraJlinkOpt(\"--generate-jli-classes=@\" + baseFile.toString())\n+                                .expectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_\" + species + \".class\")\n+                                .expectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_L.class\")\n+                                .unexpectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_\" + species.substring(1) + \".class\")\n+                                .unexpectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LL.class\")\n+                                .validatingModule(\"java.base\")\n+                                .build());\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/GenerateJLIClassesTest.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import jdk.internal.jimage.BasicImageReader;\n+import jdk.internal.jimage.ImageLocation;\n+\n+\/**\n+ *\n+ * JDK Modular image iterator\n+ *\/\n+public class JImageHelper {\n+\n+    private JImageHelper() {\n+        \/\/ Don't instantiate\n+    }\n+\n+    public static List<String> listContents(Path jimage) throws IOException {\n+        try(BasicImageReader reader = BasicImageReader.open(jimage)) {\n+            List<String> entries = new ArrayList<>();\n+            for (String s : reader.getEntryNames()) {\n+                entries.add(s);\n+            }\n+            Collections.sort(entries);\n+            return entries;\n+        }\n+    }\n+\n+    public static byte[] getLocationBytes(String location, Path jimage) throws IOException {\n+        try(BasicImageReader reader = BasicImageReader.open(jimage)) {\n+            ImageLocation il = reader.findLocation(location);\n+            byte[] r = reader.getResource(il);\n+            if (r == null) {\n+                throw new IllegalStateException(String.format(\"bytes for %s not found!\", location));\n+            }\n+            return r;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/JImageHelper.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import tests.Helper;\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Test reproducibility of linking an java.se image using the run-time\n+ *          image.\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g JavaSEReproducibleTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Test reproducibility of linking an java.se image using the run-time\n+ *          image.\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g JavaSEReproducibleTest false\n+ *\/\n+public class JavaSEReproducibleTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        JavaSEReproducibleTest test = new JavaSEReproducibleTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        String javaSeModule = \"java.se\";\n+        \/\/ create a java.se using jmod-less approach\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+                .helper(helper)\n+                .addModule(javaSeModule)\n+                .validatingModule(javaSeModule);\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        builder.name(\"java-se-repro1\");\n+        Path javaSEJmodLess1 = createJavaImageRuntimeLink(builder.build());\n+\n+        \/\/ create another java.se version using jmod-less approach\n+        builder.name(\"java-se-repro2\");\n+        Path javaSEJmodLess2 = createJavaImageRuntimeLink(builder.build());\n+        if (Files.mismatch(javaSEJmodLess1.resolve(\"lib\").resolve(\"modules\"),\n+                           javaSEJmodLess2.resolve(\"lib\").resolve(\"modules\")) != -1L) {\n+            throw new RuntimeException(\"jlink producing inconsistent result for \" + javaSeModule + \" (jmod-less)\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/JavaSEReproducibleTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Verify that jlink with an empty module path, but trying to use\n+ *          --keep-packaged-modules fails as expected.\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g KeepPackagedModulesFailTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Verify that jlink with an empty module path, but trying to use\n+ *          --keep-packaged-modules fails as expected.\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g KeepPackagedModulesFailTest false\n+ *\/\n+public class KeepPackagedModulesFailTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        KeepPackagedModulesFailTest test = new KeepPackagedModulesFailTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        \/\/ create a base image for linking from the run-time image\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+                .helper(helper)\n+                .name(\"jlink-fail\")\n+                .addModule(\"java.base\")\n+                .validatingModule(\"java.base\");\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        Path baseImage = createRuntimeLinkImage(builder.build());\n+\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer t) {\n+                return t.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        \/\/ Attempt a jlink using the run-time image and also using option\n+        \/\/ --keep-packaged-modules, which should fail.\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(baseImage)\n+                                .name(\"java-base-jlink-keep-packaged-target\")\n+                                .addModule(\"java.base\")\n+                                .extraJlinkOpt(\"--keep-packaged-modules=foo\")\n+                                .validatingModule(\"java.base\")\n+                                .build(), handler, exitFailPred);\n+        OutputAnalyzer analyzer = handler.analyzer();\n+        if (analyzer.getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to have failed!\");\n+        }\n+        analyzer.stdoutShouldContain(\"Error\");\n+        analyzer.stdoutShouldContain(\"--keep-packaged-modules\");\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/KeepPackagedModulesFailTest.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Verify jlink fails by default when linking from the run-time image\n+ *          and files have been modified\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g ModifiedFilesExitTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Verify jlink fails by default when linking from the run-time image\n+ *          and files have been modified\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g ModifiedFilesExitTest false\n+ *\/\n+public class ModifiedFilesExitTest extends ModifiedFilesTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        ModifiedFilesExitTest test = new ModifiedFilesExitTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    @Override\n+    String initialImageName() {\n+        return \"java-base-jlink-with-mod-exit\";\n+    }\n+\n+    @Override\n+    void testAndAssert(Path modifiedFile, Helper helper, Path initialImage)\n+            throws Exception {\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer t) {\n+                return t.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(initialImage)\n+                                .name(\"java-base-jlink-with-mod-exit-target\")\n+                                .addModule(\"java.base\")\n+                                .validatingModule(\"java.base\")\n+                                .build(), handler, exitFailPred);\n+        OutputAnalyzer analyzer = handler.analyzer();\n+        if (analyzer.getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to fail due to modified file!\");\n+        }\n+        analyzer.stdoutShouldContain(modifiedFile.toString() + \" has been modified\");\n+        \/\/ Verify the error message is reasonable\n+        analyzer.stdoutShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n+        analyzer.stdoutShouldNotContain(\"java.lang.IllegalArgumentException\");\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/ModifiedFilesExitTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Properties;\n+\n+import tests.Helper;\n+\n+public abstract class ModifiedFilesTest extends AbstractLinkableRuntimeTest {\n+\n+    abstract String initialImageName();\n+    abstract void testAndAssert(Path modifiedFile, Helper helper, Path initialImage) throws Exception;\n+\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+                .name(initialImageName())\n+                .addModule(\"java.base\")\n+                .validatingModule(\"java.base\")\n+                .helper(helper);\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        Path initialImage = createRuntimeLinkImage(builder.build());\n+\n+        Path netPropertiesFile = modifyFileInImage(initialImage);\n+\n+        testAndAssert(netPropertiesFile, helper, initialImage);\n+    }\n+\n+    protected Path modifyFileInImage(Path jmodLessImg)\n+            throws IOException, AssertionError {\n+        \/\/ modify net.properties config file\n+        Path netPropertiesFile = jmodLessImg.resolve(\"conf\").resolve(\"net.properties\");\n+        Properties props = new Properties();\n+        try (InputStream is = Files.newInputStream(netPropertiesFile)) {\n+            props.load(is);\n+        }\n+        String prevVal = (String)props.put(\"java.net.useSystemProxies\", Boolean.TRUE.toString());\n+        if (prevVal == null || Boolean.getBoolean(prevVal) != false) {\n+            throw new AssertionError(\"Expected previous value to be false!\");\n+        }\n+        try (OutputStream out = Files.newOutputStream(netPropertiesFile)) {\n+            props.store(out, \"Modified net.properties file!\");\n+        }\n+        return netPropertiesFile;\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/ModifiedFilesTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Verify warnings are being produced when linking from the run-time\n+ *          image and files have been modified\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g ModifiedFilesWarningTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Verify warnings are being produced when linking from the run-time\n+ *          image and files have been modified\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g ModifiedFilesWarningTest false\n+ *\/\n+public class ModifiedFilesWarningTest extends ModifiedFilesTest {\n+\n+    protected static final String IGNORE_MODIFIED_RUNTIME_OPT = \"--ignore-modified-runtime\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        ModifiedFilesWarningTest test = new ModifiedFilesWarningTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    @Override\n+    String initialImageName() {\n+        return \"java-base-jlink-with-mod-warn\";\n+    }\n+\n+    @Override\n+    void testAndAssert(Path modifiedFile, Helper helper, Path initialImage) throws Exception {\n+        CapturingHandler handler = new CapturingHandler();\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(initialImage)\n+                                .name(\"java-base-jlink-with-mod-warn-target\")\n+                                .addModule(\"java.base\")\n+                                .validatingModule(\"java.base\")\n+                                .extraJlinkOpt(IGNORE_MODIFIED_RUNTIME_OPT) \/\/ only generate a warning\n+                                .build(), handler);\n+        OutputAnalyzer out = handler.analyzer();\n+        \/\/ verify we get the warning message\n+        out.stdoutShouldMatch(\"Warning: .* has been modified\");\n+        out.stdoutShouldNotContain(\"java.lang.IllegalArgumentException\");\n+        out.stdoutShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/ModifiedFilesWarningTest.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Verify that a jlink using the run-time image cannot include jdk.jlink\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g MultiHopTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Verify that a jlink using the run-time image cannot include jdk.jlink\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g MultiHopTest false\n+ *\/\n+public class MultiHopTest extends AbstractLinkableRuntimeTest {\n+\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        Path jdkJlinkJmodless = createJDKJlinkJmodLess(helper, \"jdk.jlink-multi-hop1\", isLinkableRuntime);\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer a) {\n+                return a.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(jdkJlinkJmodless)\n+                                .name(\"jdk-jlink-multi-hop1-target\")\n+                                .addModule(\"jdk.jlink\")\n+                                .validatingModule(\"java.base\")\n+                                .build(), handler, exitFailPred);\n+        OutputAnalyzer analyzer = handler.analyzer();\n+        if (analyzer.getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to fail due to including jdk.jlink\");\n+        }\n+        String expectedMsg = \"This JDK does not contain packaged modules \" +\n+                             \"and cannot be used to create another image with \" +\n+                             \"the jdk.jlink module\";\n+        analyzer.stdoutShouldContain(expectedMsg);\n+        analyzer.stdoutShouldNotContain(\"Exception\"); \/\/ ensure error message is sane\n+    }\n+\n+    private Path createJDKJlinkJmodLess(Helper helper, String name, boolean isLinkableRuntime) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder();\n+        builder.helper(helper)\n+               .name(name)\n+               .addModule(\"jdk.jlink\")\n+               .validatingModule(\"java.base\");\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        return createRuntimeLinkImage(builder.build());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        MultiHopTest test = new MultiHopTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/MultiHopTest.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import tests.Helper;\n+import tests.JImageGenerator;\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Compare packaged-modules jlink with a run-time image based jlink to\n+ *          produce the same result\n+ * @requires (jlink.packagedModules & jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g PackagedModulesVsRuntimeImageLinkTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Compare packaged-modules jlink with a run-time image based jlink to\n+ *          produce the same result\n+ * @requires (jlink.packagedModules & !jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g PackagedModulesVsRuntimeImageLinkTest false\n+ *\/\n+public class PackagedModulesVsRuntimeImageLinkTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        PackagedModulesVsRuntimeImageLinkTest test = new PackagedModulesVsRuntimeImageLinkTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        \/\/ create a java.se using jmod-less approach\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+                .helper(helper)\n+                .name(\"java-se-jmodless\")\n+                .addModule(\"java.se\")\n+                .validatingModule(\"java.se\");\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        Path javaSEruntimeLink = createJavaImageRuntimeLink(builder.build());\n+\n+        \/\/ create a java.se using packaged modules (jmod-full)\n+        Path javaSEJmodFull = JImageGenerator.getJLinkTask()\n+                .output(helper.createNewImageDir(\"java-se-jmodfull\"))\n+                .addMods(\"java.se\").call().assertSuccess();\n+\n+        compareRecursively(javaSEruntimeLink, javaSEJmodFull);\n+    }\n+\n+    \/\/ Visit all files in the given directories checking that they're byte-by-byte identical\n+    private static void compareRecursively(Path javaSEJmodLess,\n+            Path javaSEJmodFull) throws IOException, AssertionError {\n+        FilesCapturingVisitor jmodFullVisitor = new FilesCapturingVisitor(javaSEJmodFull);\n+        FilesCapturingVisitor jmodLessVisitor = new FilesCapturingVisitor(javaSEJmodLess);\n+        Files.walkFileTree(javaSEJmodFull, jmodFullVisitor);\n+        Files.walkFileTree(javaSEJmodLess, jmodLessVisitor);\n+        List<String> jmodFullFiles = jmodFullVisitor.filesVisited();\n+        List<String> jmodLessFiles = jmodLessVisitor.filesVisited();\n+        Collections.sort(jmodFullFiles);\n+        Collections.sort(jmodLessFiles);\n+\n+        if (jmodFullFiles.size() != jmodLessFiles.size()) {\n+            throw new AssertionError(String.format(\"Size of files different for jmod-less (%d) vs jmod-full (%d) java.se jlink\", jmodLessFiles.size(), jmodFullFiles.size()));\n+        }\n+        String jimageFile = Path.of(\"lib\").resolve(\"modules\").toString();\n+        \/\/ Compare all files except the modules image\n+        for (int i = 0; i < jmodFullFiles.size(); i++) {\n+            String jmodFullPath = jmodFullFiles.get(i);\n+            String jmodLessPath = jmodLessFiles.get(i);\n+            if (!jmodFullPath.equals(jmodLessPath)) {\n+                throw new AssertionError(String.format(\"jmod-full path (%s) != jmod-less path (%s)\", jmodFullPath, jmodLessPath));\n+            }\n+            if (jmodFullPath.equals(jimageFile)) {\n+                continue;\n+            }\n+            Path a = javaSEJmodFull.resolve(Path.of(jmodFullPath));\n+            Path b = javaSEJmodLess.resolve(Path.of(jmodLessPath));\n+            if (Files.mismatch(a, b) != -1L) {\n+                handleFileMismatch(a, b);\n+            }\n+        }\n+        \/\/ Compare jimage contents by iterating its entries and comparing their\n+        \/\/ paths and content bytes\n+        \/\/\n+        \/\/ Note: The files aren't byte-by-byte comparable (probably due to string hashing\n+        \/\/ and offset differences in container bytes)\n+        Path jimageJmodLess = javaSEJmodLess.resolve(Path.of(\"lib\")).resolve(Path.of(\"modules\"));\n+        Path jimageJmodFull = javaSEJmodFull.resolve(Path.of(\"lib\")).resolve(Path.of(\"modules\"));\n+        List<String> jimageContentJmodLess = JImageHelper.listContents(jimageJmodLess);\n+        List<String> jimageContentJmodFull = JImageHelper.listContents(jimageJmodFull);\n+        if (jimageContentJmodLess.size() != jimageContentJmodFull.size()) {\n+            throw new AssertionError(String.format(\"Size of jimage content differs for jmod-less (%d) v. jmod-full (%d)\", jimageContentJmodLess.size(), jimageContentJmodFull.size()));\n+        }\n+        for (int i = 0; i < jimageContentJmodFull.size(); i++) {\n+            if (!jimageContentJmodFull.get(i).equals(jimageContentJmodLess.get(i))) {\n+                throw new AssertionError(String.format(\"Jimage content differs at index %d: jmod-full was: '%s' jmod-less was: '%s'\",\n+                                                       i,\n+                                                       jimageContentJmodFull.get(i),\n+                                                       jimageContentJmodLess.get(i)\n+                                                       ));\n+            }\n+            String loc = jimageContentJmodFull.get(i);\n+            if (isTreeInfoResource(loc)) {\n+                \/\/ Skip container bytes as those are offsets to the content\n+                \/\/ of the container which might be different between jlink runs.\n+                continue;\n+            }\n+            byte[] resBytesFull = JImageHelper.getLocationBytes(loc, jimageJmodFull);\n+            byte[] resBytesLess = JImageHelper.getLocationBytes(loc, jimageJmodLess);\n+            if (resBytesFull.length != resBytesLess.length || Arrays.mismatch(resBytesFull, resBytesLess) != -1) {\n+                throw new AssertionError(\"Content bytes mismatch for \" + loc);\n+            }\n+        }\n+    }\n+\n+    private static boolean isTreeInfoResource(String path) {\n+        return path.startsWith(\"\/packages\") || path.startsWith(\"\/modules\");\n+    }\n+\n+    private static void handleFileMismatch(Path a, Path b) {\n+        throw new AssertionError(\"Files mismatch: \" + a + \" vs. \" + b);\n+    }\n+\n+    static class FilesCapturingVisitor extends SimpleFileVisitor<Path> {\n+        private final Path basePath;\n+        private final List<String> filePaths = new ArrayList<>();\n+        public FilesCapturingVisitor(Path basePath) {\n+            this.basePath = basePath;\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) {\n+            Path relative = basePath.relativize(path);\n+            filePaths.add(relative.toString());\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        List<String> filesVisited() {\n+            return filePaths;\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/PackagedModulesVsRuntimeImageLinkTest.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+import java.util.spi.ToolProvider;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Test run-time link with --patch-module. Expect failure.\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g PatchedJDKModuleJlinkTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Test run-time link with --patch-module. Expect failure.\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g PatchedJDKModuleJlinkTest false\n+ *\/\n+public class PatchedJDKModuleJlinkTest extends AbstractLinkableRuntimeTest {\n+\n+    @Override\n+    public void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        String imageName = \"java-base-patched\";\n+        Path runtimeLinkImage = createRuntimeLinkImage(helper, imageName + \"-base\", isLinkableRuntime);\n+\n+        \/\/ Prepare patched module content\n+        Path patchSource = Path.of(\"java-base-patch-src\");\n+        Path pkg = patchSource.resolve(\"java\", \"lang\");\n+        Path extraClass = pkg.resolve(\"MyJlinkPatchInteger.java\");\n+        String source = \"\"\"\n+                package java.lang;\n+                public class MyJlinkPatchInteger {\n+                    public int add(int a, int b) {\n+                        return a + b;\n+                    }\n+                }\n+                \"\"\";\n+        Files.createDirectories(pkg);\n+        Files.writeString(extraClass, source);\n+        Path patchClasses = Path.of(\"java-base-patch-classes\");\n+        Files.createDirectories(patchClasses);\n+        ToolProvider javac = ToolProvider.findFirst(\"javac\")\n+                                         .orElseThrow(() -> new AssertionError(\"javac not found\"));\n+        javac.run(System.out, System.err, new String[] {\n+                \"-d\", patchClasses.toString(),\n+                \"--patch-module=java.base=\" + patchSource.toAbsolutePath().toString(),\n+                extraClass.toAbsolutePath().toString()\n+        });\n+\n+        \/\/ Perform a run-time image link expecting a failure\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer t) {\n+                return t.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(runtimeLinkImage)\n+                                .name(imageName + \"-derived\")\n+                                .addModule(\"java.base\")\n+                                .validatingModule(\"java.base\")\n+                                .extraJlinkOpt(\"-J--patch-module=java.base=\" +\n+                                               patchClasses.toAbsolutePath().toString())\n+                                .build(), handler, exitFailPred);\n+        OutputAnalyzer analyzer = handler.analyzer();\n+        if (analyzer.getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to fail due to patched module!\");\n+        }\n+        analyzer.stdoutShouldContain(\"MyJlinkPatchInteger.class not found in the modules image.\");\n+        analyzer.stdoutShouldContain(\"--patch-module is not supported\");\n+        \/\/ Verify the error message is reasonable\n+        analyzer.stdoutShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n+        analyzer.stdoutShouldNotContain(\"java.lang.IllegalArgumentException\");\n+    }\n+\n+    private Path createRuntimeLinkImage(Helper helper, String name, boolean isLinkableRuntime) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+                .name(name)\n+                .addModule(\"java.base\")\n+                .validatingModule(\"java.base\")\n+                .helper(helper);\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        return createRuntimeLinkImage(builder.build());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        PatchedJDKModuleJlinkTest test = new PatchedJDKModuleJlinkTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/PatchedJDKModuleJlinkTest.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import tests.Helper;\n+import tests.JImageValidator;\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Test appropriate handling of generated SystemModules* classes in run-time image link mode\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g SystemModulesTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Test appropriate handling of generated SystemModules* classes in run-time image link mode\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g SystemModulesTest false\n+ *\/\n+public class SystemModulesTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        SystemModulesTest test = new SystemModulesTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    \/*\n+     * SystemModule classes are module specific. If the jlink is based on the\n+     * modules image, then earlier generated SystemModule classes shall not get\n+     * propagated.\n+     *\/\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        \/\/ create an image with a module containing a main entrypoint (jdk.httpserver),\n+        \/\/ thus producing the SystemModules$0.class. Add jdk.jdwp.agent as a module which\n+        \/\/ isn't resolved by default, so as to generate SystemModules$default.class\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+                .helper(helper)\n+                .name(\"httpserver-jlink-jmodless-derived\")\n+                .addModule(\"jdk.httpserver\")\n+                .addModule(\"jdk.jdwp.agent\")\n+                .validatingModule(\"java.base\");\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        Path javaseJmodless = createJavaImageRuntimeLink(builder.build());\n+        \/\/ Verify that SystemModules$0.class etc. are there, due to httpserver and jdwp.agent\n+        JImageValidator.validate(javaseJmodless.resolve(\"lib\").resolve(\"modules\"),\n+                                    List.of(\"\/java.base\/jdk\/internal\/module\/SystemModules$default.class\",\n+                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$0.class\",\n+                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$all.class\"),\n+                                    Collections.emptyList());\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/SystemModulesTest.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import tests.Helper;\n+import tests.JImageValidator;\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Test disabled SystemModulesPlugin in run-time image link mode. Expect\n+ *          generated classes to not be there.\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g SystemModulesTest2 true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Test disabled SystemModulesPlugin in run-time image link mode. Expect\n+ *          generated classes to not be there.\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g SystemModulesTest2 false\n+ *\/\n+public class SystemModulesTest2 extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        SystemModulesTest2 test = new SystemModulesTest2();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        \/\/ See SystemModulesTest which enables the system-modules plugin. With\n+        \/\/ it disabled, we expect for the generated classes to not be there.\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+                .helper(helper)\n+                .name(\"jlink-jmodless-sysmod2\")\n+                .addModule(\"jdk.httpserver\")\n+                .validatingModule(\"java.base\")\n+                .addExtraOption(\"--disable-plugin\")\n+                .addExtraOption(\"system-modules\");\n+        Path runtimeImageLinkTarget = createJavaImageRuntimeLink(builder.build());\n+        JImageValidator.validate(runtimeImageLinkTarget.resolve(\"lib\").resolve(\"modules\"),\n+                                    Collections.emptyList(),\n+                                    List.of(\"\/java.base\/jdk\/internal\/module\/SystemModules$all.class\",\n+                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$default.class\",\n+                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$0.class\"));\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/SystemModulesTest2.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -67,0 +67,2 @@\n+    private final boolean linkableRuntime;\n+    private static final Path JDK_HOME = Paths.get(System.getProperty(\"test.jdk\"));\n@@ -69,2 +71,5 @@\n-        Path jdkHome = Paths.get(System.getProperty(\"test.jdk\"));\n-        if (!Files.exists(jdkHome.resolve(\"jmods\"))) {\n+        return newHelper(false);\n+    }\n+\n+    public static Helper newHelper(boolean linkableRuntime) throws IOException {\n+        if (!linkableRuntime && !Files.exists(JDK_HOME.resolve(\"jmods\"))) {\n@@ -75,1 +80,1 @@\n-        return new Helper(jdkHome);\n+        return new Helper(JDK_HOME, linkableRuntime);\n@@ -78,1 +83,2 @@\n-    private Helper(Path jdkHome) throws IOException {\n+    private Helper(Path jdkHome, boolean linkableRuntime) throws IOException {\n+        this.linkableRuntime = linkableRuntime;\n@@ -80,1 +86,1 @@\n-        if (!Files.exists(stdjmods)) {\n+        if (!linkableRuntime && !Files.exists(stdjmods)) {\n@@ -143,1 +149,2 @@\n-        return (includeStdMods? stdjmods.toAbsolutePath().toString() : \"\") + File.pathSeparator\n+        String standardMods = linkableRuntime ? \"\" : stdjmods.toAbsolutePath().toString() + File.pathSeparator;\n+        return (includeStdMods? standardMods : \"\")\n@@ -187,1 +194,1 @@\n-        JModTask task = JImageGenerator.getJModTask()\n+        JModTask task = JImageGenerator.getJModTask(linkableRuntime)\n","filename":"test\/jdk\/tools\/lib\/tests\/Helper.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -162,1 +162,5 @@\n-        return new JModTask();\n+        return getJModTask(false);\n+    }\n+\n+    public static JModTask getJModTask(boolean linkableRuntime) {\n+        return new JModTask(linkableRuntime);\n@@ -353,0 +357,1 @@\n+        private final boolean linkableRuntime;\n@@ -358,0 +363,4 @@\n+        private JModTask(boolean linkableRuntime) {\n+            this.linkableRuntime = linkableRuntime;\n+        }\n+\n@@ -417,1 +426,1 @@\n-            return jmods + File.pathSeparator + jars;\n+            return linkableRuntime ? jars : jmods + File.pathSeparator + jars;\n","filename":"test\/jdk\/tools\/lib\/tests\/JImageGenerator.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReader;\n+import java.lang.module.ModuleReference;\n@@ -27,0 +30,1 @@\n+import java.io.DataInputStream;\n@@ -42,0 +46,1 @@\n+import java.util.Optional;\n@@ -141,0 +146,2 @@\n+        map.put(\"jlink.runtime.linkable\", this::runtimeLinkable);\n+        map.put(\"jlink.packagedModules\", this::packagedModules);\n@@ -718,0 +725,40 @@\n+    private String packagedModules() {\n+        \/\/ Some jlink tests require packaged modules being present (jmods).\n+        \/\/ For a runtime linkable image build packaged modules aren't present\n+        try {\n+            Path jmodsDir = Path.of(System.getProperty(\"java.home\"), \"jmods\");\n+            if (jmodsDir.toFile().exists()) {\n+                return Boolean.TRUE.toString();\n+            } else {\n+                return Boolean.FALSE.toString();\n+            }\n+        } catch (Throwable t) {\n+            return Boolean.FALSE.toString();\n+        }\n+    }\n+\n+    private String runtimeLinkable() {\n+        \/\/ jdk.jlink module has the following resource indicating a runtime-linkable\n+        \/\/ image. It's the diff file for runtime linking of the java.base module.\n+        String linkableRuntimeResource = \"jdk\/tools\/jlink\/internal\/runtimelink\/diff_java.base\";\n+        try {\n+            ModuleFinder finder = ModuleFinder.ofSystem();\n+            Optional<ModuleReference> ref = finder.find(\"jdk.jlink\");\n+            if (ref.isEmpty()) {\n+                \/\/ No jdk.jlink in the current image\n+                return Boolean.FALSE.toString();\n+            }\n+            try (ModuleReader reader = ref.get().open()) {\n+                Optional<InputStream> inOpt = reader.open(linkableRuntimeResource);\n+                if (inOpt.isPresent()) {\n+                    inOpt.get().close();\n+                    return Boolean.TRUE.toString();\n+                } else {\n+                    return Boolean.FALSE.toString();\n+                }\n+            }\n+        } catch (Throwable t) {\n+            return Boolean.FALSE.toString();\n+        }\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- *  @run main AutostartPlugins\n+ *  @run main\/othervm AutostartPlugins\n","filename":"test\/langtools\/tools\/javac\/plugin\/AutostartPlugins.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- *  @run main InternalAPI\n+ *  @run main\/othervm InternalAPI\n","filename":"test\/langtools\/tools\/javac\/plugin\/InternalAPI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}