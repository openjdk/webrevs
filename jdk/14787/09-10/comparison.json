{"files":[{"patch":"@@ -169,1 +169,1 @@\n-        } catch (RunImageLinkException e) {\n+        } catch (RuntimeImageLinkException e) {\n@@ -193,1 +193,1 @@\n-        } catch (RunImageLinkException re) {\n+        } catch (RuntimeImageLinkException re) {\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageFileCreator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,0 +66,5 @@\n+    public static ImagePluginStack parseConfiguration(Jlink.PluginsConfiguration pluginsConfiguration)\n+            throws Exception {\n+        return parseConfiguration(pluginsConfiguration, null);\n+    }\n+\n@@ -69,1 +74,1 @@\n-    public static ImagePluginStack parseConfiguration(Jlink.PluginsConfiguration pluginsConfiguration)\n+    public static ImagePluginStack parseConfiguration(Jlink.PluginsConfiguration pluginsConfiguration, List<String> cli)\n@@ -133,1 +138,1 @@\n-        return new ImagePluginStack(builder, orderedPlugins, lastSorter);\n+        return new ImagePluginStack(builder, orderedPlugins, lastSorter, cli);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImagePluginConfiguration.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,1 +31,10 @@\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n@@ -165,0 +174,1 @@\n+    private final List<JlinkCLIArgsListener> cliArgsListeners = new ArrayList<>();\n@@ -166,0 +176,1 @@\n+    private final List<String> cliArgs;\n@@ -168,1 +179,1 @@\n-        this(null, Collections.emptyList(), null);\n+        this(null, Collections.emptyList(), null, null);\n@@ -173,2 +184,2 @@\n-            Plugin lastSorter) {\n-        this(imageBuilder, plugins, lastSorter, true);\n+            Plugin lastSorter, List<String> cliArgs) {\n+        this(imageBuilder, plugins, lastSorter, true, cliArgs);\n@@ -180,1 +191,2 @@\n-            boolean validate) {\n+            boolean validate,\n+            List<String> cliArgs) {\n@@ -189,0 +201,3 @@\n+            if (p instanceof JlinkCLIArgsListener) {\n+                cliArgsListeners.add((JlinkCLIArgsListener) p);\n+            }\n@@ -190,0 +205,1 @@\n+        this.cliArgs = cliArgs;\n@@ -229,0 +245,3 @@\n+        cliArgsListeners.forEach((p) -> {\n+            p.process(cliArgs);\n+        });\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImagePluginStack.java","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,349 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReference;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.tools.jlink.plugin.ResourcePoolEntry.Type;\n+\n+\/**\n+ * An archive implementation based on the run-time image (lib\/modules, or jimage)\n+ * and associated files from the filesystem if any (e.g. native libraries).\n+ *\/\n+public class JRTArchive implements Archive {\n+\n+    \/\/ File marker in lib\/modules file for jdk.jlink indicating it got created\n+    \/\/ with a run-time image type link.\n+    public static final String RUNIMAGE_SINGLE_HOP_STAMP = \"jdk\/tools\/jlink\/internal\/runtimeimage.link.stamp\";\n+    private static final String JDK_JLINK_MODULE = \"jdk.jlink\";\n+    private final String module;\n+    private final Path path;\n+    private final ModuleReference ref;\n+    private final List<JRTArchiveFile> files = new ArrayList<>();\n+    private final List<String> otherRes;\n+    private final boolean singleHop;\n+\n+    JRTArchive(String module, Path path, boolean singleHop, List<String> otherRes) {\n+        this.module = module;\n+        this.path = path;\n+        this.ref = ModuleFinder.ofSystem()\n+                    .find(module)\n+                    .orElseThrow(() ->\n+                        new IllegalArgumentException(\"Module \" + module + \" not part of the JDK install\"));\n+        this.singleHop = singleHop;\n+        this.otherRes = otherRes;\n+    }\n+\n+    @Override\n+    public String moduleName() {\n+        return module;\n+    }\n+\n+    @Override\n+    public Path getPath() {\n+        return path;\n+    }\n+\n+    @Override\n+    public Stream<Entry> entries() {\n+        try {\n+            collectFiles();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        } catch (RuntimeImageLinkException e) {\n+            \/\/ populate single-hop issue\n+            throw e.getReason();\n+        }\n+        return files.stream()\n+                    .sorted((a, b) -> {return a.resPath.compareTo(b.resPath);})\n+                    .map(f -> { return f.toEntry();});\n+    }\n+\n+    @Override\n+    public void open() throws IOException {\n+        if (files.isEmpty()) {\n+            collectFiles();\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (!files.isEmpty()) {\n+            files.clear();\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(module, path);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof JRTArchive) {\n+            JRTArchive other = (JRTArchive)obj;\n+            return Objects.equals(module, other.module) &&\n+                   Objects.equals(path, other.path);\n+        }\n+\n+        return false;\n+    }\n+\n+    private void collectFiles() throws IOException {\n+        if (files.isEmpty()) {\n+            addNonClassResources();\n+            \/\/ Add classes\/resources from image module\n+            files.addAll(ref.open().list()\n+                                   .map(s -> {\n+                return new JRTArchiveFile(JRTArchive.this, s,\n+                        Type.CLASS_OR_RESOURCE, null \/* sha *\/, false \/* symlink *\/, singleHop);\n+            }).collect(Collectors.toList()));\n+            \/\/ add\/persist a special, empty file for jdk.jlink so as to support\n+            \/\/ the single-hop-only run-time image jlink\n+            if (singleHop && JDK_JLINK_MODULE.equals(module)) {\n+                files.add(createRuntimeImageSingleHopStamp());\n+            }\n+        }\n+    }\n+\n+    private JRTArchiveFile createRuntimeImageSingleHopStamp() {\n+        return new JRTArchiveStampFile(this, RUNIMAGE_SINGLE_HOP_STAMP, Type.CLASS_OR_RESOURCE, null, false, singleHop);\n+    }\n+\n+    private void addNonClassResources() throws IOException {\n+        \/\/ Not all modules will have other resources like bin, lib, legal etc.\n+        \/\/ files. In that case the list will be empty.\n+        if (!otherRes.isEmpty()) {\n+            files.addAll(otherRes.stream()\n+                    .map(s -> {\n+                        TypePathMapping m = mappingResource(s);\n+                        return new JRTArchiveFile(JRTArchive.this, m.resPath, m.resType, m.sha, m.symlink, singleHop);\n+                    })\n+                    .filter(m -> m != null)\n+                    .collect(Collectors.toList()));\n+        }\n+    }\n+\n+    \/**\n+     *  line: <int>|<int>|<sha>|<path>\n+     *\n+     *  Take the integer before '|' convert it to a Type. The second\n+     *  token is an integer representing symlinks (or not). The third token is\n+     *  a hash sum (sha512) of the file denoted by the fourth token (path).\n+     *\/\n+    private static TypePathMapping mappingResource(String line) {\n+        if (line.isEmpty()) {\n+            return null;\n+        }\n+        String[] tokens = line.split(\"\\\\|\", 4);\n+        Type type = null;\n+        int symlinkNum = -1;\n+        try {\n+            Integer typeInt = Integer.valueOf(tokens[0]);\n+            type = Type.fromOrdinal(typeInt);\n+            symlinkNum = Integer.valueOf(tokens[1]);\n+        } catch (NumberFormatException e) {\n+            throw new AssertionError(e); \/\/ must not happen\n+        }\n+        if (symlinkNum < 0 || symlinkNum > 1) {\n+            throw new IllegalStateException(\"Symlink designator out of range [0,1] got: \" + symlinkNum);\n+        }\n+        boolean isSymlink = symlinkNum > 0;\n+        return new TypePathMapping(tokens[2], tokens[3], type, isSymlink);\n+    }\n+\n+    static class TypePathMapping {\n+        final String resPath;\n+        final String sha;\n+        final Type resType;\n+        final boolean symlink;\n+        TypePathMapping(String sha, String resPath, Type resType, boolean symlink) {\n+            this.resPath = resPath;\n+            this.resType = resType;\n+            this.sha = Objects.requireNonNull(sha);\n+            this.symlink = symlink;\n+        }\n+    }\n+\n+    static class JRTArchiveFile {\n+        private static final String JAVA_HOME = System.getProperty(\"java.home\");\n+        private static final Path BASE = Paths.get(JAVA_HOME);\n+        private static final String MISMATCH_FORMAT = \"%s has been modified.%n\";\n+        final String resPath;\n+        final Archive.Entry.EntryType resType;\n+        final Archive archive;\n+        final String sha; \/\/ Checksum for non-resource files\n+        final boolean symlink;\n+        final boolean failOnMod; \/\/ Only allow non-failure in multi-hop mode\n+\n+        JRTArchiveFile(Archive archive, String resPath, Type resType, String sha, boolean symlink, boolean failOnMod) {\n+            this.resPath = resPath;\n+            this.resType = toEntryType(resType);\n+            this.archive = archive;\n+            this.sha = sha;\n+            this.symlink = symlink;\n+            this.failOnMod = failOnMod;\n+        }\n+\n+        Entry toEntry() {\n+            return new Entry(archive, resPath, resPath, resType) {\n+\n+                private boolean warningProduced = false;\n+\n+                @Override\n+                public long size() {\n+                    try {\n+                        if (resType != Archive.Entry.EntryType.CLASS_OR_RESOURCE) {\n+                            \/\/ Read from the base JDK image, special casing\n+                            \/\/ symlinks, which have the link target in the sha field\n+                            if (symlink) {\n+                                return Files.size(BASE.resolve(sha));\n+                            }\n+                            return Files.size(BASE.resolve(resPath));\n+                        } else {\n+                            \/\/ Read from the module image. This works, because\n+                            \/\/ the underlying base path is a JrtPath with the\n+                            \/\/ JrtFileSystem underneath which is able to handle\n+                            \/\/ this size query\n+                            return Files.size(archive.getPath().resolve(resPath));\n+                        }\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                }\n+\n+                @Override\n+                public InputStream stream() throws IOException {\n+                    if (resType != Archive.Entry.EntryType.CLASS_OR_RESOURCE) {\n+                        \/\/ Read from the base JDK image.\n+                        Path path = BASE.resolve(resPath);\n+                        if (shaSumMismatch(path, sha, symlink)) {\n+                            if (failOnMod) {\n+                                String msg = String.format(MISMATCH_FORMAT, path.toString());\n+                                IllegalArgumentException ise = new IllegalArgumentException(msg);\n+                                throw new RuntimeImageLinkException(ise);\n+                            } else if (!warningProduced) {\n+                                String msg = String.format(MISMATCH_FORMAT, path.toString());\n+                                System.err.printf(\"WARNING: %s\", msg);\n+                                warningProduced = true;\n+                            }\n+                        }\n+                        if (symlink) {\n+                            path = BASE.resolve(sha);\n+                            return Files.newInputStream(path);\n+                        }\n+                        return Files.newInputStream(path);\n+                    } else {\n+                        \/\/ Read from the module image.\n+                        String module = archive.moduleName();\n+                        ModuleReference mRef = ModuleFinder.ofSystem().find(module).orElseThrow();\n+                        return mRef.open().open(resPath).orElseThrow();\n+                    }\n+                }\n+\n+                static boolean shaSumMismatch(Path res, String expectedSha, boolean isSymlink) {\n+                    if (isSymlink) {\n+                        return false;\n+                    }\n+                    \/\/ handle non-symlink resources\n+                    try {\n+                        HexFormat format = HexFormat.of();\n+                        byte[] expected = format.parseHex(expectedSha);\n+                        MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n+                        try (InputStream is = Files.newInputStream(res)) {\n+                            byte[] buf = new byte[1024];\n+                            int readBytes = -1;\n+                            while ((readBytes = is.read(buf)) != -1) {\n+                                digest.update(buf, 0, readBytes);\n+                            }\n+                        }\n+                        byte[] actual = digest.digest();\n+                        return !MessageDigest.isEqual(expected, actual);\n+                    } catch (Exception e) {\n+                        throw new AssertionError(\"SHA-512 sum check failed!\", e);\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        private static Archive.Entry.EntryType toEntryType(Type input) {\n+            return switch(input) {\n+                case CLASS_OR_RESOURCE -> Archive.Entry.EntryType.CLASS_OR_RESOURCE;\n+                case CONFIG -> Archive.Entry.EntryType.CONFIG;\n+                case HEADER_FILE -> Archive.Entry.EntryType.HEADER_FILE;\n+                case LEGAL_NOTICE -> Archive.Entry.EntryType.LEGAL_NOTICE;\n+                case MAN_PAGE -> Archive.Entry.EntryType.MAN_PAGE;\n+                case NATIVE_CMD -> Archive.Entry.EntryType.NATIVE_CMD;\n+                case NATIVE_LIB -> Archive.Entry.EntryType.NATIVE_LIB;\n+                case TOP -> throw new IllegalArgumentException(\"TOP files should be handled by ReleaseInfoPlugin!\");\n+                default -> throw new IllegalArgumentException(\"Unknown type: \" + input);\n+            };\n+        }\n+    }\n+\n+    \/\/ Stamp file marker for single-hop implementation\n+    static class JRTArchiveStampFile extends JRTArchiveFile {\n+        JRTArchiveStampFile(Archive archive, String resPath, Type resType, String sha, boolean symlink, boolean failOnMod) {\n+            super(archive, resPath, resType, sha, symlink, failOnMod);\n+        }\n+\n+        @Override\n+        Entry toEntry() {\n+            return new Entry(archive, resPath, resPath, resType) {\n+\n+                @Override\n+                public long size() {\n+                    \/\/ empty file\n+                    return 0;\n+                }\n+\n+                @Override\n+                public InputStream stream() throws IOException {\n+                    \/\/ empty content\n+                    return new ByteArrayInputStream(new byte[0]);\n+                }\n+\n+            };\n+        }\n+    }\n+\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JRTArchive.java","additions":349,"deletions":0,"binary":false,"changes":349,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal;\n+\n+import java.util.List;\n+\n+\/**\n+ *\n+ * Plugins wishing to observe the command list that was used to\n+ * trigger the link must implement this interface.\n+ *\n+ *\/\n+public interface JlinkCLIArgsListener {\n+\n+    public void process(List<String> cliArgs);\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkCLIArgsListener.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -77,0 +77,3 @@\n+import jdk.tools.jlink.internal.plugins.JlinkResourcesListPlugin;\n+import jdk.tools.jlink.internal.plugins.LegalNoticeFilePlugin;\n+import jdk.tools.jlink.plugin.Plugin;\n@@ -88,1 +91,3 @@\n-    private static final String OTHER_RESOURCES_FILE = \"jdk\/tools\/jlink\/internal\/runlink_%s_resources\";\n+    private static final String OTHER_RESOURCES_FILE = JlinkResourcesListPlugin.RESPATH_PREFIX +\n+                                                       \"%s\" + JlinkResourcesListPlugin.RESPATH_SUFFIX;\n+    private static final String OLD_CLI_FILE = JlinkResourcesListPlugin.CLI_RESOURCE_FILE;\n@@ -286,0 +291,5 @@\n+            \/\/ Currently run-time image based jlinks are only used when\n+            \/\/ the module path is empty. I.e. not specified on the command line\n+            \/\/ and the 'jmods' folder in JAVA_HOME is not present. This restriction\n+            \/\/ is so because cases with an external jimage as run-time image base\n+            \/\/ have not been considered at this point.\n@@ -366,0 +376,1 @@\n+                                    new OptionsValues(),\n@@ -425,0 +436,1 @@\n+                                                        options,\n@@ -430,1 +442,1 @@\n-                    imageProvider.targetPlatform, config));\n+                    imageProvider.targetPlatform, config), getMergedCliArgs(!config.useModulePath()));\n@@ -534,0 +546,1 @@\n+                                                   OptionsValues opts,\n@@ -561,1 +574,18 @@\n-                log.println(\"'jmods' folder not present, performing a run-time image based link.\");\n+                String verboseHint = \" \" + taskHelper.getMessage(\"runtime.link.verbose.hint\");\n+                if (verbose) {\n+                    \/\/ Don't mention the hint if we already use --verbose.\n+                    verboseHint = \"\";\n+                }\n+                log.println(taskHelper.getMessage(\"runtime.link.info\", verboseHint));\n+                if (verbose) {\n+                    logPackagedModuleEquivalent(log, getMergedCliArgs(!config.useModulePath()), opts);\n+                }\n+            }\n+            \/\/ if we use single-hop and we find a stamp file we fail the link\n+            if (config.singleHop()) {\n+                try (InputStream in = jdkJlink.getResourceAsStream(JRTArchive.RUNIMAGE_SINGLE_HOP_STAMP)) {\n+                    if (in != null) {\n+                        String msg = taskHelper.getMessage(\"err.runtime.link.recursive\");\n+                        throw new IllegalArgumentException(msg);\n+                    }\n+                }\n@@ -570,1 +600,3 @@\n-                                        rm.name(), rm.reference().location().get(), config.useModulePath() ? \"\" : \" (run-time image)\"));\n+                                        rm.name(),\n+                                        rm.reference().location().get(),\n+                                        config.useModulePath() ? \"\" : \" \" + taskHelper.getMessage(\"runtime.link.jprt.path.extra\")));\n@@ -616,0 +648,106 @@\n+    \/**\n+     * Log a message when a run-time image link is being performed and mention\n+     * the equivalent packaged-module based link.\n+     *\n+     * @param logWriter\n+     *            The log to print to.\n+     * @param mergedCLI\n+     *            The merged command line parameters of the persisted link of\n+     *            the run-time image being used and the current command line\n+     *            arguments.\n+     * @param inputCommand\n+     *            The jlink CLI args used for the current link run.\n+     * @param opts\n+     *            The parsed options of the current command line arguments.\n+     *\/\n+    private static void logPackagedModuleEquivalent(PrintWriter logWriter,\n+            List<String> mergedCLI, OptionsValues opts) {\n+        \/\/ parse options, produce plugins maps.\n+        TaskHelper scratchTaskHelper = new TaskHelper(JLINK_BUNDLE);\n+        OptionsHelper<JlinkTask> scratchOptionsHelper = scratchTaskHelper.newOptionsHelper(JlinkTask.class, recognizedOptions);\n+        JlinkTask scratch = new JlinkTask();\n+\n+        Map<Plugin, List<Map<String, String>>> pluginMaps = null;\n+        try {\n+            scratchOptionsHelper.handleOptions(scratch, mergedCLI.toArray(new String[] {}));\n+            pluginMaps = scratchTaskHelper.getPluginMaps();\n+        } catch (BadArgs e) {\n+            throw new AssertionError(\"handling of scratch options failed\", e);\n+        }\n+        List<Plugin> forwardingPlugins = pluginMaps.keySet()\n+                                                        .stream()\n+                                                        .filter(p -> p.runTimeImageLinkPersistent())\n+                                                        .toList();\n+        List<String> jlinkCmd = new ArrayList<>();\n+        jlinkCmd.add(\"jlink\");\n+        \/\/ Iterate over recognized opts to figure out options used\n+        if (opts.bindServices) {\n+            jlinkCmd.add(\"--bind-services\");\n+        }\n+        if (opts.suggestProviders) {\n+            jlinkCmd.add(\"--suggest-providers\");\n+        }\n+        if (opts.ignoreSigning) {\n+            jlinkCmd.add(\"--ignore-signing\");\n+        }\n+        \/\/ --add-modules is a required option, but the JLink API calls this with\n+        \/\/ dummy options\n+        if (!opts.addMods.isEmpty()) {\n+            jlinkCmd.add(\"--add-modules\");\n+            jlinkCmd.add(opts.addMods.stream().collect(Collectors.joining(\",\")));\n+        }\n+        if (!opts.limitMods.isEmpty()) {\n+            jlinkCmd.add(\"--limit-modules\");\n+            jlinkCmd.add(opts.limitMods.stream().collect(Collectors.joining(\",\")));\n+        }\n+        \/\/ Launchers carry forward, so we need to use the scratch JlinkTask\n+        if (!scratch.options.launchers.isEmpty()) {\n+            for (Map.Entry<String, String> entry: scratch.options.launchers.entrySet()) {\n+                jlinkCmd.add(\"--launcher\");\n+                jlinkCmd.add(entry.getKey() + \"=\" + entry.getValue());\n+            }\n+        }\n+        String outputPath = \"\";\n+        if (opts.output != null) {\n+            outputPath = opts.output.toString();\n+            jlinkCmd.add(\"--output\");\n+            jlinkCmd.add(outputPath);\n+        }\n+        logWriter.println(taskHelper.getMessage(\"runtime.link.equivalent.packaged.modules\", outputPath));\n+        logWriter.print(\"    \");\n+        logWriter.print(jlinkCmd.stream().collect(Collectors.joining(\" \")));\n+        for (Plugin p: forwardingPlugins) {\n+            List<Map<String, String>> configs = pluginMaps.get(p);\n+            for (Map<String, String> config: configs) {\n+                String value = config.get(p.getName());\n+                \/\/ Work-around for --dedup-legal-notices which auto-enables,\n+                \/\/ carries forward and doesn't allow to be run without argument\n+                \/\/ value from the CLI.\n+                if (p instanceof LegalNoticeFilePlugin && value == null) {\n+                    continue;\n+                }\n+                logWriter.print(\" --\" + p.getName());\n+                if (value != null) {\n+                    logWriter.print(\" \" + value);\n+                }\n+            }\n+        }\n+        logWriter.println();\n+    }\n+\n+    private static List<String> getMergedCliArgs(boolean isRunTimeImageLink) throws IOException {\n+        \/\/ First read in the stored CLI args that were used for the input\n+        \/\/ run-time image\n+        List<String> merged = new ArrayList<>();\n+        if (isRunTimeImageLink) {\n+            try (InputStream in = JlinkTask.class.getModule().getResourceAsStream(OLD_CLI_FILE)) {\n+                CommandLine.loadCmdFile(Objects.requireNonNull(in, \"Old CLI args not being tracked in jimage\"),\n+                                merged);\n+            }\n+        }\n+        for (String arg: optionsHelper.getInputCommand()) {\n+            merged.add(arg);\n+        }\n+        return Collections.unmodifiableList(merged);\n+    }\n+\n@@ -622,3 +760,6 @@\n-            if (inStream != null) {\n-                try (inStream) {\n-                    String input = new String(inStream.readAllBytes(), StandardCharsets.UTF_8);\n+            try (inStream) {\n+                String input = new String(inStream.readAllBytes(), StandardCharsets.UTF_8);\n+                if (input.isEmpty()) {\n+                    \/\/ Not all modules have non-class resources\n+                    nonResEntries.put(modName, Collections.emptyList());\n+                } else {\n@@ -627,3 +768,0 @@\n-            } else {\n-                \/\/ Not all modules have non-class resources\n-                nonResEntries.put(modName, Collections.emptyList());\n@@ -975,2 +1113,2 @@\n-                \/\/ the path is a JRTPath, when using a jmod-less image\n-                return new RunImageArchive(module, path, singleHop, Objects.requireNonNull(nonClassRes));\n+                \/\/ the path is a JRTPath, when using the run-time image for linking\n+                return new JRTArchive(module, path, singleHop, Objects.requireNonNull(nonClassRes));\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":150,"deletions":12,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -1,361 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.tools.jlink.internal;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.UncheckedIOException;\n-import java.lang.module.ModuleFinder;\n-import java.lang.module.ModuleReference;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.security.MessageDigest;\n-import java.util.ArrayList;\n-import java.util.HexFormat;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import jdk.tools.jlink.plugin.ResourcePoolEntry.Type;\n-\n-public class RunImageArchive implements Archive {\n-\n-    private static final String JAVA_BASE_MODULE = \"java.base\";\n-    \/\/ File marker in lib\/modules file for java.base indicating it got created\n-    \/\/ with a run-image-type link.\n-    private static final String RUNIMAGE_SINGLE_HOP_STAMP = \".runtimeimage.stamp\";\n-    private final String module;\n-    private final Path path;\n-    private final ModuleReference ref;\n-    private final List<RunImageFile> files = new ArrayList<>();\n-    private final List<String> otherRes;\n-    private final boolean singleHop;\n-\n-    RunImageArchive(String module, Path path, boolean singleHop, List<String> otherRes) {\n-        this.module = module;\n-        this.path = path;\n-        this.ref = ModuleFinder.ofSystem()\n-                    .find(module)\n-                    .orElseThrow(() ->\n-                        new IllegalArgumentException(\"Module \" + module + \" not part of the JDK install\"));\n-        this.singleHop = singleHop;\n-        this.otherRes = otherRes;\n-    }\n-\n-    @Override\n-    public String moduleName() {\n-        return module;\n-    }\n-\n-    @Override\n-    public Path getPath() {\n-        return path;\n-    }\n-\n-    @Override\n-    public Stream<Entry> entries() {\n-        try {\n-            collectFiles();\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        } catch (RunImageLinkException e) {\n-            \/\/ populate single-hop issue\n-            throw e.getReason();\n-        }\n-        return files.stream()\n-                    .sorted((a, b) -> {return a.resPath.compareTo(b.resPath);})\n-                    .map(f -> { return f.toEntry();});\n-    }\n-\n-    @Override\n-    public void open() throws IOException {\n-        if (files.isEmpty()) {\n-            collectFiles();\n-        }\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-        if (!files.isEmpty()) {\n-            files.clear();\n-        }\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(module, path);\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj instanceof RunImageArchive) {\n-            RunImageArchive other = (RunImageArchive)obj;\n-            return Objects.equals(module, other.module) &&\n-                   Objects.equals(path, other.path);\n-        }\n-\n-        return false;\n-    }\n-\n-    private void collectFiles() throws IOException {\n-        if (files.isEmpty()) {\n-            addNonClassResources();\n-            \/\/ Add classes\/resources from image module\n-            files.addAll(ref.open().list()\n-                                   .map(s -> {\n-                return new RunImageFile(RunImageArchive.this, s,\n-                        Type.CLASS_OR_RESOURCE, null \/* sha *\/, false \/* symlink *\/, singleHop);\n-            }).collect(Collectors.toList()));\n-            \/\/ if we use single-hop and we find a stamp file we fail the link\n-            if (files.stream().anyMatch(f -> { return RUNIMAGE_SINGLE_HOP_STAMP.equals(f.resPath);})) {\n-                String msg = \"Recursive links based on the current run-time image are not allowed.\";\n-                IllegalArgumentException ise = new IllegalArgumentException(msg);\n-                throw new RunImageLinkException(ise);\n-            };\n-            \/\/ add\/persist a special, empty file for java.base so as to support\n-            \/\/ the single-hop-only runimage-jlink\n-            if (singleHop && JAVA_BASE_MODULE.equals(module)) {\n-                files.add(createRunImageSingleHopStamp());\n-            }\n-        }\n-    }\n-\n-    private RunImageFile createRunImageSingleHopStamp() {\n-        return new RunImageStampFile(this, RUNIMAGE_SINGLE_HOP_STAMP, Type.CLASS_OR_RESOURCE, null, false, singleHop);\n-    }\n-\n-    private void addNonClassResources() throws IOException {\n-        \/\/ Not all modules will have other resources like bin, lib, legal etc.\n-        \/\/ files. In that case the list will be empty.\n-        if (!otherRes.isEmpty()) {\n-            files.addAll(otherRes.stream()\n-                    .map(s -> {\n-                        TypePathMapping m = mappingResource(s);\n-                        return new RunImageFile(RunImageArchive.this, m.resPath, m.resType, m.sha, m.symlink, singleHop);\n-                    })\n-                    .filter(m -> m != null)\n-                    .collect(Collectors.toList()));\n-        }\n-    }\n-\n-    \/**\n-     *  line: <int>|<int>|<sha>|<path>\n-     *\n-     *  Take the integer before '|' convert it to a Type. The second\n-     *  token is an integer representing symlinks (or not). The third token is\n-     *  a hash sum (sha512) of the file denoted by the fourth token (path).\n-     *\/\n-    private static TypePathMapping mappingResource(String line) {\n-        if (line.isEmpty()) {\n-            return null;\n-        }\n-        String[] tokens = line.split(\"\\\\|\", 4);\n-        Type type = null;\n-        int symlinkNum = -1;\n-        try {\n-            Integer typeInt = Integer.valueOf(tokens[0]);\n-            type = Type.fromOrdinal(typeInt);\n-            symlinkNum = Integer.valueOf(tokens[1]);\n-        } catch (NumberFormatException e) {\n-            throw new AssertionError(e); \/\/ must not happen\n-        }\n-        if (symlinkNum < 0 || symlinkNum > 1) {\n-            throw new IllegalStateException(\"Symlink designator out of range [0,1] got: \" + symlinkNum);\n-        }\n-        boolean isSymlink = symlinkNum > 0;\n-        return new TypePathMapping(tokens[2], tokens[3], type, isSymlink);\n-    }\n-\n-    static class TypePathMapping {\n-        final String resPath;\n-        final String sha;\n-        final Type resType;\n-        final boolean symlink;\n-        TypePathMapping(String sha, String resPath, Type resType, boolean symlink) {\n-            this.resPath = resPath;\n-            this.resType = resType;\n-            this.sha = Objects.requireNonNull(sha);\n-            this.symlink = symlink;\n-        }\n-    }\n-\n-    static class RunImageFile {\n-        private static final String JAVA_HOME = System.getProperty(\"java.home\");\n-        private static final Path BASE = Paths.get(JAVA_HOME);\n-        private static final String MISMATCH_FORMAT = \"%s has been modified.%s%n\";\n-        final String resPath;\n-        final Archive.Entry.EntryType resType;\n-        final Archive archive;\n-        final String sha; \/\/ Checksum for non-resource files\n-        final boolean symlink;\n-        final boolean failOnMod; \/\/ Only allow non-failure in multi-hop mode\n-\n-        RunImageFile(Archive archive, String resPath, Type resType, String sha, boolean symlink, boolean failOnMod) {\n-            this.resPath = resPath;\n-            this.resType = toEntryType(resType);\n-            this.archive = archive;\n-            this.sha = sha;\n-            this.symlink = symlink;\n-            this.failOnMod = failOnMod;\n-        }\n-\n-        Entry toEntry() {\n-            return new Entry(archive, resPath, resPath, resType) {\n-\n-                private boolean warningProduced = false;\n-\n-                @Override\n-                public long size() {\n-                    try {\n-                        if (resType != Archive.Entry.EntryType.CLASS_OR_RESOURCE) {\n-                            \/\/ Read from the base JDK image, special casing\n-                            \/\/ symlinks, which have the link target in the sha field\n-                            if (symlink) {\n-                                return Files.size(BASE.resolve(sha));\n-                            }\n-                            return Files.size(BASE.resolve(resPath));\n-                        } else {\n-                            \/\/ Read from the module image. This works, because\n-                            \/\/ the underlying base path is a JrtPath with the\n-                            \/\/ JrtFileSystem underneath which is able to handle\n-                            \/\/ this size query\n-                            return Files.size(archive.getPath().resolve(resPath));\n-                        }\n-                    } catch (IOException e) {\n-                        throw new UncheckedIOException(e);\n-                    }\n-                }\n-\n-                @Override\n-                public InputStream stream() throws IOException {\n-                    if (resType != Archive.Entry.EntryType.CLASS_OR_RESOURCE) {\n-                        \/\/ Read from the base JDK image.\n-                        Path path = BASE.resolve(resPath);\n-                        if (shaSumMismatch(path, sha, symlink)) {\n-                            if (failOnMod) {\n-                                String hint = \" You may force the link with '--unlock-run-image'.\";\n-                                String msg = String.format(MISMATCH_FORMAT, path.toString(), hint);\n-                                IllegalArgumentException ise = new IllegalArgumentException(msg);\n-                                throw new RunImageLinkException(ise);\n-                            } else if (!warningProduced) {\n-                                String msg = String.format(MISMATCH_FORMAT, path.toString(), \"\");\n-                                System.err.printf(\"WARNING: %s\", msg);\n-                                warningProduced = true;\n-                            }\n-                        }\n-                        if (symlink) {\n-                            path = BASE.resolve(sha);\n-                            return Files.newInputStream(path);\n-                        }\n-                        return Files.newInputStream(path);\n-                    } else {\n-                        \/\/ Read from the module image.\n-                        String module = archive.moduleName();\n-                        ModuleReference mRef = ModuleFinder.ofSystem().find(module).orElseThrow();\n-                        return mRef.open().open(resPath).orElseThrow();\n-                    }\n-                }\n-\n-                static boolean shaSumMismatch(Path res, String expectedSha, boolean isSymlink) {\n-                    if (isSymlink) {\n-                        return false;\n-                    }\n-                    \/\/ handle non-symlink resources\n-                    try {\n-                        HexFormat format = HexFormat.of();\n-                        byte[] expected = format.parseHex(expectedSha);\n-                        MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n-                        try (InputStream is = Files.newInputStream(res)) {\n-                            byte[] buf = new byte[1024];\n-                            int readBytes = -1;\n-                            while ((readBytes = is.read(buf)) != -1) {\n-                                digest.update(buf, 0, readBytes);\n-                            }\n-                        }\n-                        byte[] actual = digest.digest();\n-                        return !MessageDigest.isEqual(expected, actual);\n-                    } catch (Exception e) {\n-                        throw new AssertionError(\"SHA-512 sum check failed!\", e);\n-                    }\n-                }\n-\n-            };\n-        }\n-\n-        private static Archive.Entry.EntryType toEntryType(Type input) {\n-            switch(input) {\n-            case CLASS_OR_RESOURCE:\n-                return Archive.Entry.EntryType.CLASS_OR_RESOURCE;\n-            case CONFIG:\n-                return Archive.Entry.EntryType.CONFIG;\n-            case HEADER_FILE:\n-                return Archive.Entry.EntryType.HEADER_FILE;\n-            case LEGAL_NOTICE:\n-                return Archive.Entry.EntryType.LEGAL_NOTICE;\n-            case MAN_PAGE:\n-                return Archive.Entry.EntryType.MAN_PAGE;\n-            case NATIVE_CMD:\n-                return Archive.Entry.EntryType.NATIVE_CMD;\n-            case NATIVE_LIB:\n-                return Archive.Entry.EntryType.NATIVE_LIB;\n-            case TOP:\n-                throw new IllegalArgumentException(\"TOP files should be handled by ReleaseInfoPlugin!\");\n-            default:\n-                throw new IllegalArgumentException(\"Unknown type: \" + input);\n-            }\n-        }\n-    }\n-\n-    \/\/ Stamp file marker for single-hop implementation\n-    static class RunImageStampFile extends RunImageFile {\n-        RunImageStampFile(Archive archive, String resPath, Type resType, String sha, boolean symlink, boolean failOnMod) {\n-            super(archive, resPath, resType, sha, symlink, failOnMod);\n-        }\n-\n-        @Override\n-        Entry toEntry() {\n-            return new Entry(archive, resPath, resPath, resType) {\n-\n-                @Override\n-                public long size() {\n-                    \/\/ empty file\n-                    return 0;\n-                }\n-\n-                @Override\n-                public InputStream stream() throws IOException {\n-                    \/\/ empty content\n-                    return new ByteArrayInputStream(new byte[0]);\n-                }\n-\n-            };\n-        }\n-    }\n-\n-}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/RunImageArchive.java","additions":0,"deletions":361,"binary":false,"changes":361,"status":"deleted"},{"patch":"@@ -32,1 +32,1 @@\n-public class RunImageLinkException extends IllegalStateException {\n+public class RuntimeImageLinkException extends IllegalStateException {\n@@ -38,1 +38,1 @@\n-    public RunImageLinkException(IllegalArgumentException cause) {\n+    public RuntimeImageLinkException(IllegalArgumentException cause) {\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/RuntimeImageLinkException.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/RunImageLinkException.java","status":"renamed"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.stream.Collectors;\n@@ -51,1 +52,0 @@\n-import jdk.tools.jlink.internal.plugins.AddOptionsPlugin;\n@@ -428,1 +428,1 @@\n-                Plugin addOptionsPlugin = null;\n+                List<String> excludePatterns = new ArrayList<>();\n@@ -436,2 +436,2 @@\n-                    if (p instanceof AddOptionsPlugin) {\n-                        addOptionsPlugin = p;\n+                    if (p.getExcludePatterns() != null) {\n+                        excludePatterns.addAll(p.getExcludePatterns());\n@@ -440,16 +440,1 @@\n-                \/\/ Certain system module classes get generated and SystemModulesMap replaced by the\n-                \/\/ SystemModulesPlugin. Filter previously generated classes so the\n-                \/\/ set of classes match the set of the packaged modules link.\n-                String systemModulesPattern = \"regex:\/java\\\\.base\/jdk\/internal\/module\/SystemModules\\\\$.*\\\\.class\";\n-                \/\/ The default OpenJDK build generates JLI Species classes so they\n-                \/\/ would be in the run-time image we derive from if we don't filter\n-                \/\/ them. This filter corresponds to the set of classes part of the\n-                \/\/ jmods.\n-                String speciesPattern = \"regex:\/java\\\\.base\/java\/lang\/invoke\/BoundMethodHandle\\\\$Species_(?:D|DL|I|IL|LJ|LL).*\\\\.class\";\n-                \/\/ The AddResourcePlugin (used by AddOptionsPlugin)\n-                String addOptionsGlob = \"glob:\" + AddOptionsPlugin.OPTS_FILE;\n-                String saveJlinkOptsGlob = \"glob:\/jdk.jlink\/\" + JlinkTask.OPTIONS_RESOURCE;\n-                String additionalPatterns = systemModulesPattern + \",\" +\n-                                            speciesPattern + \",\" +\n-                                            addOptionsGlob + \",\" +\n-                                            saveJlinkOptsGlob;\n+                String additionalPatterns = excludePatterns.stream().collect(Collectors.joining(\",\"));\n@@ -471,4 +456,3 @@\n-                \/\/ If the system modules plug-in is disabled, we add the\n-                \/\/ -Djdk.system.module.finder.disableFastPath property as the\n-                \/\/ SystemModulesMap class isn't guaranteed to be correct for the\n-                \/\/ current module set.\n+                \/\/ If the system modules plug-in is disabled, we fail the link\n+                \/\/ as the SystemModulesMap class isn't guaranteed to be suitable\n+                \/\/ for the to-be produced jimage.\n@@ -476,15 +460,1 @@\n-                    String disableFastPath = \"-Djdk.system.module.finder.disableFastPath=true\";\n-                    if (addOptionsPlugin != null) {\n-                        \/\/ Retrieve existing options and add the needed\n-                        \/\/ property\n-                        List<Map<String, String>> addOptsConfig = pluginToMaps.get(addOptionsPlugin);\n-                        Map<String, String> lastOpt = addOptsConfig.get(addOptsConfig.size() - 1);\n-                        String existingOpt = lastOpt.get(\"add-options\");\n-                        lastOpt.put(\"add-options\", disableFastPath + \" \" + existingOpt);\n-                        addOptsConfig.set(addOptsConfig.size() - 1, lastOpt);\n-                    } else {\n-                        addOptionsPlugin = PluginRepository.getPlugin(\"add-options\", ModuleLayer.boot());\n-                        List<Map<String, String>> addOptsConfig = new ArrayList<>();\n-                        addOptsConfig.add(Map.of(\"add-options\", disableFastPath));\n-                        pluginToMaps.put(addOptionsPlugin, addOptsConfig);\n-                    }\n+                    throw new IllegalArgumentException(\"Disabling system-modules plugin for a run-time image based link is not allowed.\");\n@@ -791,0 +761,4 @@\n+    Map<Plugin, List<Map<String, String>>> getPluginMaps() {\n+        return pluginOptions.pluginToMaps;\n+    }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/TaskHelper.java","additions":13,"deletions":39,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.List;\n+\n@@ -34,1 +36,1 @@\n-    public static final String OPTS_FILE = \"\/java.base\/jdk\/internal\/vm\/options\";\n+    private static final String OPTS_FILE = \"\/java.base\/jdk\/internal\/vm\/options\";\n@@ -40,0 +42,6 @@\n+    \/\/ Filter the file we create for run-time image based links\n+    @Override\n+    public List<String> getExcludePatterns() {\n+        return List.of(\"glob:\" + AddOptionsPlugin.OPTS_FILE);\n+    }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/AddOptionsPlugin.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,240 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.tools.jlink.internal.plugins;\n-\n-import java.io.InputStream;\n-import java.nio.charset.StandardCharsets;\n-import java.security.MessageDigest;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.EnumSet;\n-import java.util.HexFormat;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-\n-import jdk.internal.util.OperatingSystem;\n-import jdk.tools.jlink.internal.Platform;\n-import jdk.tools.jlink.internal.RunImageLinkException;\n-import jdk.tools.jlink.plugin.ResourcePool;\n-import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n-import jdk.tools.jlink.plugin.ResourcePoolEntry;\n-import jdk.tools.jlink.plugin.ResourcePoolModule;\n-\n-\n-\/**\n- * Plugin to collect resources from jmod which aren't classes or\n- * resources. Needed for the the run-time image based jlink.\n- *\/\n-public final class AddRunImageResourcesPlugin extends AbstractPlugin {\n-\n-    private static final int SYMLINKED_RES = 1;\n-    private static final int REGULAR_RES = 0;\n-    private static final String BIN_DIRNAME = \"bin\";\n-    private static final String LIB_DIRNAME = \"lib\";\n-    private static final String NAME = \"add-run-image-resources\";\n-    private static final String RESPATH_PREFIX = \"\/jdk.jlink\/jdk\/tools\/jlink\/internal\/runlink_\";\n-    \/\/ This resource is being used in JLinkTask which passes its contents to\n-    \/\/ RunImageArchive for further processing.\n-    private static final String RESPATH = RESPATH_PREFIX + \"%s_resources\";\n-    private static final String JLINK_MOD_NAME = \"jdk.jlink\";\n-\n-    \/\/ Type file format:\n-    \/\/ '<type>|{0,1}|<sha-sum>|<file-path>'\n-    \/\/   (1)    (2)      (3)      (4)\n-    \/\/\n-    \/\/ Where fields are:\n-    \/\/\n-    \/\/ (1) The resource type as specified by ResourcePoolEntry.type()\n-    \/\/ (2) Symlink designator. 0 => regular resource, 1 => symlinked resource\n-    \/\/ (3) The SHA-512 sum of the resources' content. The link to the target\n-    \/\/     for symlinked resources.\n-    \/\/ (4) The relative file path of the resource\n-    private static final String TYPE_FILE_FORMAT = \"%d|%d|%s|%s\";\n-\n-    private final Map<String, List<String>> nonClassResEntries;\n-\n-    public AddRunImageResourcesPlugin() {\n-        super(NAME);\n-        this.nonClassResEntries = new ConcurrentHashMap<>();\n-    }\n-\n-    @Override\n-    public boolean isHidden() {\n-        return true; \/\/ Don't show in --list-plugins output\n-    }\n-\n-    @Override\n-    public ResourcePool transform(ResourcePool in, ResourcePoolBuilder out) {\n-        \/\/ Only add resources if we have the jdk.jlink module part of the\n-        \/\/ link.\n-        Optional<ResourcePoolModule> jdkJlink = in.moduleView().findModule(\"jdk.jlink\");\n-        if (jdkJlink.isPresent()) {\n-            Platform targetPlatform = getTargetPlatform(in);\n-            in.transformAndCopy(e -> { ResourcePoolEntry retval = recordAndFilterEntry(e, targetPlatform);\n-                                   return retval;}, out);\n-            addModuleResourceEntries(out);\n-        } else {\n-            in.transformAndCopy(Function.identity(), out);\n-        }\n-        return out.build();\n-    }\n-\n-    private Platform getTargetPlatform(ResourcePool in) {\n-        String platform = in.moduleView().findModule(\"java.base\")\n-                .map(ResourcePoolModule::targetPlatform)\n-                .orElse(null);\n-        if (platform == null) {\n-            throw new IllegalStateException(\"java.base not part of the image?\");\n-        }\n-        return Platform.parsePlatform(platform);\n-    }\n-\n-    private void addModuleResourceEntries(ResourcePoolBuilder out) {\n-        for (String module: keysInSortedOrder()) {\n-            String mResource = String.format(RESPATH, module);\n-            List<String> mResources = nonClassResEntries.get(module);\n-            if (mResources == null) {\n-                throw new AssertionError(\"Module listed, but no resources?\");\n-            }\n-            String mResContent = mResources.stream().sorted().collect(Collectors.joining(\"\\n\"));\n-            out.add(ResourcePoolEntry.create(mResource,\n-                    mResContent.getBytes(StandardCharsets.UTF_8)));\n-        }\n-    }\n-\n-    private List<String> keysInSortedOrder() {\n-        List<String> keys = new ArrayList<>();\n-        keys.addAll(nonClassResEntries.keySet());\n-        Collections.sort(keys);\n-        return keys;\n-    }\n-\n-    private ResourcePoolEntry recordAndFilterEntry(ResourcePoolEntry entry, Platform platform) {\n-        \/\/ Note that the jmod_resources file is a resource file, so we cannot\n-        \/\/ add ourselves due to this condition. However, we want to not add\n-        \/\/ an old version of the resource file again.\n-        if (entry.type() != ResourcePoolEntry.Type.CLASS_OR_RESOURCE) {\n-            if (entry.type() == ResourcePoolEntry.Type.TOP) {\n-                return entry; \/\/ Handled by ReleaseInfoPlugin, nothing to do\n-            }\n-            List<String> moduleResources = nonClassResEntries.computeIfAbsent(entry.moduleName(), a -> new ArrayList<>());\n-            int type = entry.type().ordinal();\n-            int isSymlink = entry.linkedTarget() != null ? SYMLINKED_RES : REGULAR_RES;\n-            String resPathWithoutMod = resPathWithoutModule(entry, platform);\n-            String sha512 = computeSha512(entry, platform);\n-            moduleResources.add(String.format(TYPE_FILE_FORMAT, type, isSymlink, sha512, resPathWithoutMod));\n-        } else if (entry.moduleName().equals(JLINK_MOD_NAME) &&\n-                   entry.type() == ResourcePoolEntry.Type.CLASS_OR_RESOURCE &&\n-                   entry.path().startsWith(RESPATH_PREFIX)) {\n-            \/\/ Filter internal runtime image based link resource file which we\n-            \/\/ create later on-the-fly\n-            return null;\n-        }\n-        return entry;\n-    }\n-\n-    private String computeSha512(ResourcePoolEntry entry, Platform platform) {\n-        try {\n-            if (entry.linkedTarget() != null) {\n-                \/\/ Symlinks don't have a hash sum, but a link to the target instead\n-                return resPathWithoutModule(entry.linkedTarget(), platform);\n-            } else {\n-                MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n-                try (InputStream is = entry.content()) {\n-                    byte[] buf = new byte[1024];\n-                    int bytesRead = -1;\n-                    while ((bytesRead = is.read(buf)) != -1) {\n-                        digest.update(buf, 0, bytesRead);\n-                    }\n-                }\n-                byte[] db = digest.digest();\n-                HexFormat format = HexFormat.of();\n-                return format.formatHex(db);\n-            }\n-        } catch (RunImageLinkException e) {\n-            \/\/ RunImageArchive::RunImageFile.content() may throw this when\n-            \/\/ getting the content(). Propagate this specific exeption.\n-            throw e;\n-        } catch (Exception e) {\n-            throw new AssertionError(\"Failed to generate hash sum for \" + entry.path());\n-        }\n-    }\n-\n-    private String resPathWithoutModule(ResourcePoolEntry entry, Platform platform) {\n-        String resPath = entry.path().substring(entry.moduleName().length() + 2 \/* prefixed and suffixed '\/' *\/);\n-        if (!isWindows(platform)) {\n-            return resPath;\n-        }\n-        \/\/ For Windows the libraries live in the 'bin' folder rather than the 'lib' folder\n-        \/\/ in the final image. Note that going by the NATIVE_LIB type only is insufficient since\n-        \/\/ only files with suffix .dll\/diz\/map\/pdb are transplanted to 'bin'.\n-        \/\/ See: DefaultImageBuilder.nativeDir()\n-        return nativeDir(entry, resPath);\n-    }\n-\n-    private boolean isWindows(Platform platform) {\n-        return platform.os() == OperatingSystem.WINDOWS;\n-    }\n-\n-    private String nativeDir(ResourcePoolEntry entry, String resPath) {\n-        if (entry.type() != ResourcePoolEntry.Type.NATIVE_LIB) {\n-            return resPath;\n-        }\n-        \/\/ precondition: Native lib, windows platform\n-        if (resPath.endsWith(\".dll\") || resPath.endsWith(\".diz\")\n-                || resPath.endsWith(\".pdb\") || resPath.endsWith(\".map\")) {\n-            if (resPath.startsWith(LIB_DIRNAME + \"\/\")) {\n-                return BIN_DIRNAME + \"\/\" + resPath.substring((LIB_DIRNAME + \"\/\").length());\n-            }\n-        }\n-        return resPath;\n-    }\n-\n-    @Override\n-    public Set<State> getState() {\n-        return EnumSet.of(State.AUTO_ENABLED, State.FUNCTIONAL);\n-    }\n-\n-    @Override\n-    public boolean hasArguments() {\n-        return false;\n-    }\n-\n-    @Override\n-    public Category getType() {\n-        \/\/ Ensure we run in a later stage as we need to generate\n-        \/\/ SHA-512 sums for non-(class\/resource) files. The jmod_resources\n-        \/\/ files can be considered meta-info describing the universe we\n-        \/\/ draft from.\n-        return Category.METAINFO_ADDER;\n-    }\n-\n-}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/AddRunImageResourcesPlugin.java","additions":0,"deletions":240,"binary":false,"changes":240,"status":"deleted"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.List;\n@@ -157,0 +158,16 @@\n+    \/\/ We generate these JLI Species classes so they would be in the run-time\n+    \/\/ image we derive from if we don't filter them for run-time image based\n+    \/\/ links. This filter corresponds to the set of classes part of the\n+    \/\/ jmods.\n+    @Override\n+    public List<String> getExcludePatterns() {\n+        return List.of(\"regex:\/java\\\\.base\/java\/lang\/invoke\/BoundMethodHandle\\\\$Species_(?:D|DL|I|IL|LJ|LL).*\\\\.class\");\n+    }\n+\n+    \/\/ This plugin doesn't persist, since generated classes are filtered for\n+    \/\/ run-time image based links.\n+    @Override\n+    public boolean runTimeImageLinkPersistent() {\n+        return false;\n+    }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/GenerateJLIClassesPlugin.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,274 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal.plugins;\n+\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.util.OperatingSystem;\n+import jdk.tools.jlink.internal.JlinkCLIArgsListener;\n+import jdk.tools.jlink.internal.Platform;\n+import jdk.tools.jlink.internal.RuntimeImageLinkException;\n+import jdk.tools.jlink.plugin.ResourcePool;\n+import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n+import jdk.tools.jlink.plugin.ResourcePoolEntry;\n+import jdk.tools.jlink.plugin.ResourcePoolModule;\n+\n+\n+\/**\n+ * Plugin to collect resources from jmod which aren't classes or\n+ * resources. Needed for the the run-time image based jlink.\n+ *\/\n+public final class JlinkResourcesListPlugin extends AbstractPlugin implements JlinkCLIArgsListener {\n+\n+    public static final String RESPATH_PREFIX = \"jdk\/tools\/jlink\/internal\/fs_\";\n+    public static final String RESPATH_SUFFIX = \"_files\";\n+    public static final String CLI_RESOURCE_FILE = \"jdk\/tools\/jlink\/internal\/cli_cmd.txt\";\n+    private static final int SYMLINKED_RES = 1;\n+    private static final int REGULAR_RES = 0;\n+    private static final String BIN_DIRNAME = \"bin\";\n+    private static final String LIB_DIRNAME = \"lib\";\n+    private static final String NAME = \"add-run-image-resources\";\n+    private static final String JLINK_MOD_NAME = \"jdk.jlink\";\n+    \/\/ This resource is being used in JLinkTask which passes its contents to\n+    \/\/ RunImageArchive for further processing.\n+    private static final String RESPATH = \"\/\" + JLINK_MOD_NAME + \"\/\" + RESPATH_PREFIX + \"%s\" + RESPATH_SUFFIX;\n+    private static final String CLI_RESOURCE = \"\/\" + JLINK_MOD_NAME + \"\/\" + CLI_RESOURCE_FILE;\n+    private static final Pattern WHITESPACE_PATTERN = Pattern.compile(\".*\\\\s.*\");\n+    private static final byte[] EMPTY_RESOURCE_BYTES = new byte[] {};\n+\n+    \/\/ Type file format:\n+    \/\/ '<type>|{0,1}|<sha-sum>|<file-path>'\n+    \/\/   (1)    (2)      (3)      (4)\n+    \/\/\n+    \/\/ Where fields are:\n+    \/\/\n+    \/\/ (1) The resource type as specified by ResourcePoolEntry.type()\n+    \/\/ (2) Symlink designator. 0 => regular resource, 1 => symlinked resource\n+    \/\/ (3) The SHA-512 sum of the resources' content. The link to the target\n+    \/\/     for symlinked resources.\n+    \/\/ (4) The relative file path of the resource\n+    private static final String TYPE_FILE_FORMAT = \"%d|%d|%s|%s\";\n+\n+    private final Map<String, List<String>> nonClassResEntries;\n+\n+    private List<String> commands;\n+\n+    public JlinkResourcesListPlugin() {\n+        super(NAME);\n+        this.nonClassResEntries = new ConcurrentHashMap<>();\n+    }\n+\n+    @Override\n+    public boolean isHidden() {\n+        return true; \/\/ Don't show in --list-plugins output\n+    }\n+\n+    @Override\n+    public ResourcePool transform(ResourcePool in, ResourcePoolBuilder out) {\n+        \/\/ Only add resources if we have the jdk.jlink module part of the\n+        \/\/ link.\n+        Optional<ResourcePoolModule> jdkJlink = in.moduleView().findModule(JLINK_MOD_NAME);\n+        if (jdkJlink.isPresent()) {\n+            Platform targetPlatform = getTargetPlatform(in);\n+            in.transformAndCopy(e -> recordAndFilterEntry(e, targetPlatform), out);\n+            addModuleResourceEntries(in, out);\n+            addCLIResource(out);\n+        } else {\n+            in.transformAndCopy(Function.identity(), out);\n+        }\n+        return out.build();\n+    }\n+\n+    private void addCLIResource(ResourcePoolBuilder out) {\n+        out.add(ResourcePoolEntry.create(CLI_RESOURCE, getCliBytes()));\n+    }\n+\n+    private byte[] getCliBytes() {\n+        StringBuilder builder = new StringBuilder();\n+        for (String s: commands) {\n+            Matcher m = WHITESPACE_PATTERN.matcher(s);\n+            if (m.matches()) {\n+                \/\/ Quote arguments containing whitespace\n+                builder.append(\"\\\"\");\n+                builder.append(s);\n+                builder.append(\"\\\"\");\n+            } else {\n+                builder.append(s);\n+            }\n+            builder.append(\" \");\n+        }\n+        builder.append(\"\\n\");\n+        return builder.toString().getBytes(StandardCharsets.UTF_8);\n+    }\n+\n+    \/\/ Filter the resource we add.\n+    @Override\n+    public List<String> getExcludePatterns() {\n+        return List.of(\"glob:\" + CLI_RESOURCE,\n+                       \"regex:\/jdk\\\\.jlink\/\" + RESPATH_PREFIX + \".*\" + RESPATH_SUFFIX);\n+    }\n+\n+    private Platform getTargetPlatform(ResourcePool in) {\n+        String platform = in.moduleView().findModule(\"java.base\")\n+                .map(ResourcePoolModule::targetPlatform)\n+                .orElseThrow(() -> new AssertionError(\"java.base not found\"));\n+        return Platform.parsePlatform(platform);\n+    }\n+\n+    private void addModuleResourceEntries(ResourcePool in, ResourcePoolBuilder out) {\n+        Set<String> inputModules = in.moduleView().modules()\n+                                                  .map(rm -> rm.name())\n+                                                  .collect(Collectors.toSet());\n+        inputModules.stream().sorted().forEach(module -> {\n+            String mResource = String.format(RESPATH, module);\n+            List<String> mResources = nonClassResEntries.get(module);\n+            if (mResources == null) {\n+                \/\/ We create empty resource files for modules in the resource\n+                \/\/ pool view, but which don't themselves contain native resources\n+                \/\/ or config files.\n+                out.add(ResourcePoolEntry.create(mResource, EMPTY_RESOURCE_BYTES));\n+            } else {\n+                String mResContent = mResources.stream().sorted()\n+                                               .collect(Collectors.joining(\"\\n\"));\n+                out.add(ResourcePoolEntry.create(mResource,\n+                    mResContent.getBytes(StandardCharsets.UTF_8)));\n+            }\n+        });\n+    }\n+\n+    private ResourcePoolEntry recordAndFilterEntry(ResourcePoolEntry entry, Platform platform) {\n+        \/\/ Note that the jmod_resources file is a resource file, so we cannot\n+        \/\/ add ourselves due to this condition. However, we want to not add\n+        \/\/ an old version of the resource file again.\n+        if (entry.type() != ResourcePoolEntry.Type.CLASS_OR_RESOURCE) {\n+            if (entry.type() == ResourcePoolEntry.Type.TOP) {\n+                return entry; \/\/ Handled by ReleaseInfoPlugin, nothing to do\n+            }\n+            List<String> moduleResources = nonClassResEntries.computeIfAbsent(entry.moduleName(), a -> new ArrayList<>());\n+            int type = entry.type().ordinal();\n+            int isSymlink = entry.linkedTarget() != null ? SYMLINKED_RES : REGULAR_RES;\n+            String resPathWithoutMod = resPathWithoutModule(entry, platform);\n+            String sha512 = computeSha512(entry, platform);\n+            moduleResources.add(String.format(TYPE_FILE_FORMAT, type, isSymlink, sha512, resPathWithoutMod));\n+        }\n+        return entry;\n+    }\n+\n+    private String computeSha512(ResourcePoolEntry entry, Platform platform) {\n+        try {\n+            if (entry.linkedTarget() != null) {\n+                \/\/ Symlinks don't have a hash sum, but a link to the target instead\n+                return resPathWithoutModule(entry.linkedTarget(), platform);\n+            } else {\n+                MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n+                try (InputStream is = entry.content()) {\n+                    byte[] buf = new byte[1024];\n+                    int bytesRead = -1;\n+                    while ((bytesRead = is.read(buf)) != -1) {\n+                        digest.update(buf, 0, bytesRead);\n+                    }\n+                }\n+                byte[] db = digest.digest();\n+                HexFormat format = HexFormat.of();\n+                return format.formatHex(db);\n+            }\n+        } catch (RuntimeImageLinkException e) {\n+            \/\/ RunImageArchive::RunImageFile.content() may throw this when\n+            \/\/ getting the content(). Propagate this specific exception.\n+            throw e;\n+        } catch (Exception e) {\n+            throw new AssertionError(\"Failed to generate hash sum for \" + entry.path());\n+        }\n+    }\n+\n+    private String resPathWithoutModule(ResourcePoolEntry entry, Platform platform) {\n+        String resPath = entry.path().substring(entry.moduleName().length() + 2 \/* prefixed and suffixed '\/' *\/);\n+        if (!isWindows(platform)) {\n+            return resPath;\n+        }\n+        \/\/ For Windows the libraries live in the 'bin' folder rather than the 'lib' folder\n+        \/\/ in the final image. Note that going by the NATIVE_LIB type only is insufficient since\n+        \/\/ only files with suffix .dll\/diz\/map\/pdb are transplanted to 'bin'.\n+        \/\/ See: DefaultImageBuilder.nativeDir()\n+        return nativeDir(entry, resPath);\n+    }\n+\n+    private boolean isWindows(Platform platform) {\n+        return platform.os() == OperatingSystem.WINDOWS;\n+    }\n+\n+    private String nativeDir(ResourcePoolEntry entry, String resPath) {\n+        if (entry.type() != ResourcePoolEntry.Type.NATIVE_LIB) {\n+            return resPath;\n+        }\n+        \/\/ precondition: Native lib, windows platform\n+        if (resPath.endsWith(\".dll\") || resPath.endsWith(\".diz\")\n+                || resPath.endsWith(\".pdb\") || resPath.endsWith(\".map\")) {\n+            if (resPath.startsWith(LIB_DIRNAME + \"\/\")) {\n+                return BIN_DIRNAME + \"\/\" + resPath.substring((LIB_DIRNAME + \"\/\").length());\n+            }\n+        }\n+        return resPath;\n+    }\n+\n+    @Override\n+    public Set<State> getState() {\n+        return EnumSet.of(State.AUTO_ENABLED, State.FUNCTIONAL);\n+    }\n+\n+    @Override\n+    public boolean hasArguments() {\n+        return false;\n+    }\n+\n+    @Override\n+    public Category getType() {\n+        \/\/ Ensure we run in a later stage as we need to generate\n+        \/\/ SHA-512 sums for non-(class\/resource) files. The jmod_resources\n+        \/\/ files can be considered meta-info describing the universe we\n+        \/\/ draft from.\n+        return Category.METAINFO_ADDER;\n+    }\n+\n+    @Override\n+    public void process(List<String> commands) {\n+        this.commands = commands;\n+    }\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/JlinkResourcesListPlugin.java","additions":274,"deletions":0,"binary":false,"changes":274,"status":"added"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.tools.jlink.internal.JlinkTask;\n@@ -107,0 +108,6 @@\n+\n+    \/\/ Filter the file we create for run-time image based links\n+    @Override\n+    public List<String> getExcludePatterns() {\n+        return List.of(\"glob:\/jdk.jlink\/\" + JlinkTask.OPTIONS_RESOURCE);\n+    }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SaveJlinkArgfilesPlugin.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,16 @@\n+import static java.lang.constant.ConstantDescs.CD_List;\n+import static java.lang.constant.ConstantDescs.CD_Map;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_Set;\n+import static java.lang.constant.ConstantDescs.CD_String;\n+import static java.lang.constant.ConstantDescs.CD_boolean;\n+import static java.lang.constant.ConstantDescs.CD_byte;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static java.lang.constant.ConstantDescs.MTD_void;\n+import static jdk.internal.classfile.Classfile.ACC_FINAL;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n+import static jdk.internal.classfile.Classfile.ACC_SUPER;\n+\n@@ -33,1 +49,0 @@\n-import static java.lang.constant.ConstantDescs.*;\n@@ -67,0 +82,5 @@\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n@@ -69,1 +89,0 @@\n-import jdk.internal.module.Modules;\n@@ -76,8 +95,1 @@\n-\n-import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n-import jdk.internal.classfile.ClassBuilder;\n-import jdk.internal.classfile.Classfile;\n-import jdk.internal.classfile.TypeKind;\n-import static jdk.internal.classfile.Classfile.*;\n-import jdk.internal.classfile.CodeBuilder;\n-\n+import jdk.internal.module.Modules;\n@@ -179,0 +191,16 @@\n+    \/\/ Certain system module classes get generated and SystemModulesMap replaced.\n+    \/\/ Filter previously generated classes so the set of classes match the set\n+    \/\/ of the packaged modules link.\n+    @Override\n+    public List<String> getExcludePatterns() {\n+        return List.of(\"regex:\/java\\\\.base\/jdk\/internal\/module\/SystemModules\\\\$.*\\\\.class\");\n+    }\n+\n+    \/\/ This plugin doesn't persist, since generated classes are filtered for\n+    \/\/ run-time image based links and running without --system-modules on a\n+    \/\/ run-time image based link is not allowed.\n+    @Override\n+    public boolean runTimeImageLinkPersistent() {\n+        return false;\n+    }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":38,"deletions":10,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.List;\n@@ -31,0 +32,1 @@\n+import jdk.tools.jlink.internal.plugins.ExcludePlugin;\n@@ -179,0 +181,28 @@\n+    \/**\n+     * A list of exclude patterns suitable to be fed to the\n+     * {@link ExcludePlugin}. The list of patterns should be such that\n+     * the classes and resource list will be the same as before the\n+     * plugin ran.\n+     *\n+     * @return A list of glob or regex patterns suitable for the\n+     *         exclude-resource plugin.\n+     *\/\n+    public default List<String> getExcludePatterns() {\n+        return null;\n+    }\n+\n+    \/**\n+     * Determined whether or not application of the plugin changes binary files\n+     * in the resulting image on the filesystem or the plugin changes classes or\n+     * resources in the resulting jimage and there is no way to undo this\n+     * operation. This is being used for the run-time image based link so as to\n+     * craft an equivalent CLI command of a link using packaged modules.\n+     *\n+     * @return {@code true} if the transformation cannot be undone and carries\n+     *         forward in a subsequent jlink using the run-time image.\n+     *         {@code false} otherwise.\n+     *\/\n+    public default boolean runTimeImageLinkPersistent() {\n+        return getType() == Category.FILTER || getType() == Category.TRANSFORMER;\n+    }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/plugin\/Plugin.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -126,0 +126,2 @@\n+err.runtime.link.recursive=Module path to the JDK packaged modules must be specified. \\\n+Run-time image based linking is not supported as $java.home was already created from a run-time image.\n@@ -168,0 +170,5 @@\n+\n+runtime.link.info=The default module path, ''$java.home\/jmods'' not present.{0}\n+runtime.link.verbose.hint=Use --verbose to show the full list of plugin options applied.\n+runtime.link.jprt.path.extra=(run-time image)\n+runtime.link.equivalent.packaged.modules=''{0}'' is linked equivalent to using jlink with packaged modules as:\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        jdk.tools.jlink.internal.plugins.AddRunImageResourcesPlugin,\n+        jdk.tools.jlink.internal.plugins.JlinkResourcesListPlugin,\n","filename":"src\/jdk.jlink\/share\/classes\/module-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+\n+import jdk.tools.jlink.builder.ImageBuilder;\n@@ -38,0 +40,1 @@\n+import jdk.tools.jlink.internal.ExecutableImage;\n@@ -40,2 +43,0 @@\n-import jdk.tools.jlink.internal.ExecutableImage;\n-import jdk.tools.jlink.builder.ImageBuilder;\n@@ -224,1 +225,1 @@\n-                null, false);\n+                null, false, null);\n","filename":"test\/jdk\/tools\/jlink\/ImageFileCreatorTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -64,1 +64,2 @@\n-        if (handler.analyzer().getExitValue() == 0) {\n+        OutputAnalyzer analyzer = handler.analyzer();\n+        if (analyzer.getExitValue() == 0) {\n@@ -67,1 +68,4 @@\n-        handler.analyzer().stdoutShouldContain(\"Recursive links based on the current run-time image are not allowed.\");\n+        String expectedMsg = \"Module path to the JDK packaged modules must be specified. \" +\n+                \"Run-time image based linking is not supported as $java.home was already created from a run-time image.\";\n+        analyzer.stdoutShouldContain(expectedMsg);\n+        analyzer.stdoutShouldNotContain(\"Exception\"); \/\/ ensure error message is sane\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/MultiHopTest.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.function.Predicate;\n@@ -28,0 +29,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -78,3 +80,12 @@\n-        \/\/ Attempt another run-time image link reducing modules to java.base only,\n-        \/\/ but we don't rewrite SystemModulesMap.\n-        Path finalResult = jlinkUsingImage(new JlinkSpecBuilder()\n+        \/\/ The following jlink using --disable-plugin system-modules ought to\n+        \/\/ fail, since the SystemModulesMap class would be incorrect if not\n+        \/\/ re-generated (due to disabled system-modules plugin).\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer t) {\n+                return t.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        jlinkUsingImage(new JlinkSpecBuilder()\n@@ -86,4 +97,1 @@\n-                                .extraJlinkOpt(\"system-modules\") \/\/ disable sysmods\n-                                .expectedLocation(\"\/java.base\/jdk\/internal\/module\/SystemModulesMap.class\")\n-                                .expectedLocation(\"\/java.base\/jdk\/internal\/module\/SystemModules.class\")\n-                                .unexpectedLocation(\"\/java.base\/jdk\/internal\/module\/SystemModules$0.class\")\n+                                .extraJlinkOpt(\"system-modules\")\n@@ -91,4 +99,10 @@\n-                                .build());\n-        \/\/ Finally run --list-modules so as to verify it does not thow CNFE\n-        List<String> expectedModules = List.of(\"java.base\");\n-        verifyListModules(finalResult, expectedModules);\n+                                .build(), handler, exitFailPred);\n+        OutputAnalyzer analyzer = handler.analyzer();\n+        if (analyzer.getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to fail due to disable system-modules plugin!\");\n+        }\n+        analyzer.stdoutShouldContain(\"Disabling system-modules plugin for a run-time image based link is not allowed.\");\n+        \/\/ Verify the error message is reasonable\n+        analyzer.stdoutShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n+        analyzer.stdoutShouldNotContain(\"java.lang.IllegalArgumentException\");\n+        analyzer.stdoutShouldNotContain(\"java.lang.IllegalStateException\");\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/SystemModulesTest2.java","additions":25,"deletions":11,"binary":false,"changes":36,"status":"modified"}]}