{"files":[{"patch":"@@ -44,0 +44,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -52,0 +53,1 @@\n+import java.util.Collections;\n@@ -85,0 +87,2 @@\n+    \/\/ Run time based link internal resources files\n+    private static final String OTHER_RESOURCES_FILE = \"jdk\/tools\/jlink\/internal\/runlink_%s_resources\";\n@@ -189,1 +193,1 @@\n-        }, \"--unlock-run-image\"),\n+        }, true, \"--unlock-run-image\"),\n@@ -426,1 +430,1 @@\n-                    imageProvider.targetPlatform));\n+                    imageProvider.targetPlatform, config));\n@@ -546,3 +550,13 @@\n-        \/\/ Print info message when a run-image link is being performed\n-        if (log != null && !config.useModulePath()) {\n-            log.println(\"'jmods' folder not present, performing a run-time image based link.\");\n+        \/\/ Perform some setup for run-time image based links\n+        Map<String, List<String>> nonClassRes = Collections.emptyMap();\n+        if (!config.useModulePath()) {\n+            final Map<String, List<String>> nonClassResMap = new HashMap<>();\n+            final Module jdkJlink = JlinkTask.class.getModule();\n+            cf.modules().stream().forEach((a) -> {\n+                collectNonClassResources(a.name(), nonClassResMap, jdkJlink);\n+            });\n+            nonClassRes = nonClassResMap;\n+            \/\/ Print info message when a run-image link is being performed\n+            if (log != null) {\n+                log.println(\"'jmods' folder not present, performing a run-time image based link.\");\n+            }\n@@ -599,1 +613,21 @@\n-                               config.singleHop());\n+                               config.singleHop(), nonClassRes);\n+    }\n+\n+    private static void collectNonClassResources(String modName,\n+                                                 Map<String, List<String>> nonResEntries,\n+                                                 Module jdkJlink) {\n+        String resName = String.format(OTHER_RESOURCES_FILE, modName);\n+        try {\n+            InputStream inStream = jdkJlink.getResourceAsStream(resName);\n+            if (inStream != null) {\n+                try (inStream) {\n+                    String input = new String(inStream.readAllBytes(), StandardCharsets.UTF_8);\n+                    nonResEntries.put(modName, Arrays.asList(input.split(\"\\n\")));\n+                }\n+            } else {\n+                \/\/ Not all modules have non-class resources\n+                nonResEntries.put(modName, Collections.emptyList());\n+            }\n+        } catch (IOException e) {\n+            throw new InternalError(\"Failed to process run-time image resources for \" + modName);\n+        }\n@@ -871,0 +905,1 @@\n+        final Map<String, List<String>> nonClassRes;\n@@ -878,1 +913,2 @@\n-                    boolean singleHop) throws IOException {\n+                    boolean singleHop,\n+                    Map<String, List<String>> nonClassRes) throws IOException {\n@@ -884,0 +920,1 @@\n+            this.nonClassRes = nonClassRes;\n@@ -896,1 +933,1 @@\n-                                .map(e -> newArchive(e.getKey(), e.getValue(), useModulePath))\n+                                .map(e -> newArchive(e.getKey(), e.getValue(), useModulePath, this.nonClassRes.get(e.getKey())))\n@@ -900,1 +937,1 @@\n-        private Archive newArchive(String module, Path path, boolean useModulePath) {\n+        private Archive newArchive(String module, Path path, boolean useModulePath, List<String> nonClassRes) {\n@@ -939,1 +976,1 @@\n-                return new RunImageArchive(module, path, singleHop);\n+                return new RunImageArchive(module, path, singleHop, Objects.requireNonNull(nonClassRes));\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":47,"deletions":10,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -40,1 +39,0 @@\n-import java.util.Arrays;\n@@ -44,1 +42,0 @@\n-import java.util.Optional;\n@@ -55,2 +52,1 @@\n-    private static final String RUNIMAGE_SINGLE_HOP_STAMP = \".runimage.stamp\";\n-    private static final String OTHER_RESOURCES_FILE = \"jdk_internal_runimage\";\n+    private static final String RUNIMAGE_SINGLE_HOP_STAMP = \".runtimeimage.stamp\";\n@@ -61,0 +57,1 @@\n+    private final List<String> otherRes;\n@@ -63,1 +60,1 @@\n-    RunImageArchive(String module, Path path, boolean singleHop) {\n+    RunImageArchive(String module, Path path, boolean singleHop, List<String> otherRes) {\n@@ -71,0 +68,1 @@\n+        this.otherRes = otherRes;\n@@ -156,2 +154,0 @@\n-        String otherResourceFile = String.format(OTHER_RESOURCES_FILE, module);\n-        Optional<InputStream> runImageResources = ref.open().open(otherResourceFile);\n@@ -159,12 +155,9 @@\n-        \/\/ files. In that case the file won't exist in the modules image.\n-        if (runImageResources.isPresent()) {\n-            try (InputStream inStream = runImageResources.get()) {\n-                String input = new String(inStream.readAllBytes(), StandardCharsets.UTF_8);\n-                files.addAll(Arrays.asList(input.split(\"\\n\")).stream()\n-                        .map(s -> {\n-                            TypePathMapping m = mappingResource(s);\n-                            return new RunImageFile(RunImageArchive.this, m.resPath, m.resType, m.sha, m.symlink, singleHop);\n-                        })\n-                        .filter(m -> m != null)\n-                        .collect(Collectors.toList()));\n-            }\n+        \/\/ files. In that case the list will be empty.\n+        if (!otherRes.isEmpty()) {\n+            files.addAll(otherRes.stream()\n+                    .map(s -> {\n+                        TypePathMapping m = mappingResource(s);\n+                        return new RunImageFile(RunImageArchive.this, m.resPath, m.resType, m.sha, m.symlink, singleHop);\n+                    })\n+                    .filter(m -> m != null)\n+                    .collect(Collectors.toList()));\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/RunImageArchive.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import jdk.tools.jlink.internal.Jlink.JlinkConfiguration;\n@@ -50,0 +51,1 @@\n+import jdk.tools.jlink.internal.plugins.AddOptionsPlugin;\n@@ -53,0 +55,1 @@\n+import jdk.tools.jlink.internal.plugins.ExcludePlugin;\n@@ -54,0 +57,1 @@\n+import jdk.tools.jlink.internal.plugins.SystemModulesPlugin;\n@@ -410,1 +414,1 @@\n-                                                      Platform targetPlatform)\n+                                                      Platform targetPlatform, JlinkConfiguration config)\n@@ -419,0 +423,71 @@\n+            \/\/ if we perform a run-time based link, add relevant exclude\n+            \/\/ patterns, so as to match the packaged-modules-based link\n+            if (!config.useModulePath()) {\n+                Plugin systemModulesPlugin = null;\n+                Plugin excludeResourcePlugin = null;\n+                Plugin addOptionsPlugin = null;\n+                for (Plugin p: pluginToMaps.keySet()) {\n+                    if (p instanceof ExcludePlugin) {\n+                        excludeResourcePlugin = p;\n+                    }\n+                    if (p instanceof SystemModulesPlugin) {\n+                        systemModulesPlugin = p;\n+                    }\n+                    if (p instanceof AddOptionsPlugin) {\n+                        addOptionsPlugin = p;\n+                    }\n+                }\n+                \/\/ Certain system module classes get generated and SystemModulesMap replaced by the\n+                \/\/ SystemModulesPlugin. Filter previously generated classes so the\n+                \/\/ set of classes match the set of the packaged modules link.\n+                String systemModulesPattern = \"regex:\/java\\\\.base\/jdk\/internal\/module\/SystemModules\\\\$.*\\\\.class\";\n+                \/\/ The default OpenJDK build generates JLI Species classes so they\n+                \/\/ would be in the run-time image we derive from if we don't filter\n+                \/\/ them. This filter corresponds to the set of classes part of the\n+                \/\/ jmods.\n+                String speciesPattern = \"regex:\/java\\\\.base\/java\/lang\/invoke\/BoundMethodHandle\\\\$Species_(?:D|DL|I|IL|LJ|LL).*\\\\.class\";\n+                \/\/ The AddResourcePlugin (used by AddOptionsPlugin)\n+                String addOptionsGlob = \"glob:\" + AddOptionsPlugin.OPTS_FILE;\n+                String saveJlinkOptsGlob = \"glob:\/jdk.jlink\/\" + JlinkTask.OPTIONS_RESOURCE;\n+                String additionalPatterns = systemModulesPattern + \",\" +\n+                                            speciesPattern + \",\" +\n+                                            addOptionsGlob + \",\" +\n+                                            saveJlinkOptsGlob;\n+                List<Map<String, String>> excludeResConfig = null;\n+                if (excludeResourcePlugin == null) {\n+                    \/\/ no existing 'exclude-resources' setting\n+                    excludeResourcePlugin = PluginRepository.getPlugin(\"exclude-resources\", ModuleLayer.boot());\n+                    excludeResConfig = new ArrayList<>();\n+                    excludeResConfig.add(Map.of(\"exclude-resources\", additionalPatterns));\n+                    pluginToMaps.put(excludeResourcePlugin, excludeResConfig);\n+                } else {\n+                    excludeResConfig = pluginToMaps.get(excludeResourcePlugin);\n+                    \/\/ currently last exclude-resources wins\n+                    Map<String, String> lastConfig = excludeResConfig.get(excludeResConfig.size() - 1);\n+                    String existingPattern = lastConfig.get(\"exclude-resources\");\n+                    lastConfig.put(\"exclude-resources\", existingPattern + \",\" + additionalPatterns);\n+                    excludeResConfig.set(excludeResConfig.size() - 1, lastConfig);\n+                }\n+                \/\/ If the system modules plug-in is disabled, we add the\n+                \/\/ -Djdk.system.module.finder.disableFastPath property as the\n+                \/\/ SystemModulesMap class isn't guaranteed to be correct for the\n+                \/\/ current module set.\n+                if (systemModulesPlugin == null) {\n+                    String disableFastPath = \"-Djdk.system.module.finder.disableFastPath=true\";\n+                    if (addOptionsPlugin != null) {\n+                        \/\/ Retrieve existing options and add the needed\n+                        \/\/ property\n+                        List<Map<String, String>> addOptsConfig = pluginToMaps.get(addOptionsPlugin);\n+                        Map<String, String> lastOpt = addOptsConfig.get(addOptsConfig.size() - 1);\n+                        String existingOpt = lastOpt.get(\"add-options\");\n+                        lastOpt.put(\"add-options\", disableFastPath + \" \" + existingOpt);\n+                        addOptsConfig.set(addOptsConfig.size() - 1, lastOpt);\n+                    } else {\n+                        addOptionsPlugin = PluginRepository.getPlugin(\"add-options\", ModuleLayer.boot());\n+                        List<Map<String, String>> addOptsConfig = new ArrayList<>();\n+                        addOptsConfig.add(Map.of(\"add-options\", disableFastPath));\n+                        pluginToMaps.put(addOptionsPlugin, addOptsConfig);\n+                    }\n+                }\n+            }\n+\n@@ -711,1 +786,1 @@\n-                                                 Platform targetPlatform)\n+                                                 Platform targetPlatform, JlinkConfiguration config)\n@@ -713,1 +788,1 @@\n-        return pluginOptions.getPluginsConfig(output, launchers, targetPlatform);\n+        return pluginOptions.getPluginsConfig(output, launchers, targetPlatform, config);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/TaskHelper.java","additions":78,"deletions":3,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+    public static final String OPTS_FILE = \"\/java.base\/jdk\/internal\/vm\/options\";\n+\n@@ -35,1 +37,1 @@\n-        super(\"add-options\", \"\/java.base\/jdk\/internal\/vm\/options\");\n+        super(\"add-options\", OPTS_FILE);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/AddOptionsPlugin.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.function.Function;\n@@ -74,7 +75,1 @@\n-        in.transformAndCopy(e -> {\n-            if (path.equals(e.path())) {\n-                \/\/ Overwrite potentially existing entry\n-                return null;\n-            }\n-            return e;\n-        }, out);\n+        in.transformAndCopy(Function.identity(), out);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/AddResourcePlugin.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.Optional;\n@@ -39,0 +40,1 @@\n+import java.util.function.Function;\n@@ -52,1 +54,1 @@\n- * resources. Needed for the the run-image-based jlink.\n+ * resources. Needed for the the run-time image based jlink.\n@@ -61,5 +63,5 @@\n-    \/\/ This ought to be a package-less resource so as to not conflict with\n-    \/\/ packages listed in the module descriptors. Making it package-less ensures\n-    \/\/ it works for any module, regardless of packages present. This resource\n-    \/\/ is being used in RunImageArchive class\n-    private static final String RESPATH = \"\/%s\/jdk_internal_runimage\";\n+    private static final String RESPATH_PREFIX = \"\/jdk.jlink\/jdk\/tools\/jlink\/internal\/runlink_\";\n+    \/\/ This resource is being used in JLinkTask which passes its contents to\n+    \/\/ RunImageArchive for further processing.\n+    private static final String RESPATH = RESPATH_PREFIX + \"%s_resources\";\n+    private static final String JLINK_MOD_NAME = \"jdk.jlink\";\n@@ -94,2 +96,6 @@\n-        Platform targetPlatform = getTargetPlatform(in);\n-        in.transformAndCopy(e -> { ResourcePoolEntry retval = recordAndFilterEntry(e, targetPlatform);\n+        \/\/ Only add resources if we have the jdk.jlink module part of the\n+        \/\/ link.\n+        Optional<ResourcePoolModule> jdkJlink = in.moduleView().findModule(\"jdk.jlink\");\n+        if (jdkJlink.isPresent()) {\n+            Platform targetPlatform = getTargetPlatform(in);\n+            in.transformAndCopy(e -> { ResourcePoolEntry retval = recordAndFilterEntry(e, targetPlatform);\n@@ -97,1 +103,4 @@\n-        addModuleResourceEntries(out);\n+            addModuleResourceEntries(out);\n+        } else {\n+            in.transformAndCopy(Function.identity(), out);\n+        }\n@@ -145,2 +154,3 @@\n-        } else if (entry.type() == ResourcePoolEntry.Type.CLASS_OR_RESOURCE &&\n-                String.format(RESPATH, entry.moduleName()).equals(entry.path())) {\n+        } else if (entry.moduleName().equals(JLINK_MOD_NAME) &&\n+                   entry.type() == ResourcePoolEntry.Type.CLASS_OR_RESOURCE &&\n+                   entry.path().startsWith(RESPATH_PREFIX)) {\n@@ -148,1 +158,1 @@\n-            \/\/ create later\n+            \/\/ create later on-the-fly\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/AddRunImageResourcesPlugin.java","additions":22,"deletions":12,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.util.HashSet;\n@@ -66,18 +65,1 @@\n-    \/\/ Work-around for jmod-less jlinking. jmod archives don't contain these\n-    \/\/ classes so it isn't an issue for a jmod-full jlink.\n-    private static final Set<String> GENERATED_JAVA_BASE_CLASSES = Set.of(\n-            \"java\/lang\/invoke\/BoundMethodHandle$Species_D\",\n-            \"java\/lang\/invoke\/BoundMethodHandle$Species_DL\",\n-            \"java\/lang\/invoke\/BoundMethodHandle$Species_I\",\n-            \"java\/lang\/invoke\/BoundMethodHandle$Species_IL\",\n-            \"java\/lang\/invoke\/BoundMethodHandle$Species_LJ\",\n-            \"java\/lang\/invoke\/BoundMethodHandle$Species_LL\",\n-            \"java\/lang\/invoke\/BoundMethodHandle$Species_LLJ\",\n-            \"java\/lang\/invoke\/BoundMethodHandle$Species_LLL\",\n-            \"java\/lang\/invoke\/BoundMethodHandle$Species_LLLJ\",\n-            \"java\/lang\/invoke\/BoundMethodHandle$Species_LLLL\",\n-            \"java\/lang\/invoke\/BoundMethodHandle$Species_LLLLL\",\n-            \"java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLL\",\n-            \"java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLLL\",\n-            \"java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLLLL\",\n-            \"java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLLLLL\");\n+\n@@ -142,1 +124,0 @@\n-        final Set<String> containedClasses = new HashSet<>();\n@@ -156,5 +137,0 @@\n-                    \/\/ Keep track of generated JLI classes\n-                    String className = possiblyStripFromPath(path);\n-                    if (GENERATED_JAVA_BASE_CLASSES.contains(className)) {\n-                        containedClasses.add(className);\n-                    }\n@@ -170,9 +146,3 @@\n-                        \/\/ containedClasses will not contain any generated JLI\n-                        \/\/ classes for the initial link, but will contain all\n-                        \/\/ JLI classes in GENERATED_JAVA_BASE_CLASSES in the\n-                        \/\/ recursive jmodless jlink case.\n-                        if (!containedClasses.contains(cn)) {\n-                            String entryName = \"\/java.base\/\" + cn + \".class\";\n-                            ResourcePoolEntry ndata = ResourcePoolEntry.create(entryName, bytes);\n-                            out.add(ndata);\n-                        }\n+                        String entryName = \"\/java.base\/\" + cn + \".class\";\n+                        ResourcePoolEntry ndata = ResourcePoolEntry.create(entryName, bytes);\n+                        out.add(ndata);\n@@ -187,7 +157,0 @@\n-    private static String possiblyStripFromPath(String path) {\n-        if (path.startsWith(\"\/java.base\/\") && path.endsWith(\".class\")) {\n-            return path.substring(\"\/java.base\/\".length(), path.length() - \".class\".length());\n-        }\n-        return path;\n-    }\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/GenerateJLIClassesPlugin.java","additions":4,"deletions":41,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.function.Function;\n@@ -95,0 +96,1 @@\n+        in.transformAndCopy(Function.identity(), out);\n@@ -98,1 +100,0 @@\n-        final String jdkJlinkResource = \"\/jdk.jlink\/\" + OPTIONS_RESOURCE;\n@@ -100,19 +101,4 @@\n-                .collect(Collectors.joining(\"\\n\"))\n-                .getBytes(StandardCharsets.UTF_8);\n-        final ResourcePoolEntry jdkJlinkSavedEntry = ResourcePoolEntry.create(\"\/jdk.jlink\/\" + OPTIONS_RESOURCE,\n-                savedOptions);\n-        final boolean[] haveEntry = new boolean[] { false };\n-        in.transformAndCopy(e -> {\n-            if (jdkJlinkResource.equals(e.path())) {\n-                \/\/ override new options if present. The jmod-less plugin might\n-                \/\/ have the resource already in the base image\n-                haveEntry[0] = true;\n-                return jdkJlinkSavedEntry;\n-            } else {\n-                return e;\n-            }\n-        }, out);\n-        if (!haveEntry[0]) {\n-            \/\/ Add the resource if and only if there isn't one already\n-            out.add(jdkJlinkSavedEntry);\n-        }\n+                                      .collect(Collectors.joining(\"\\n\"))\n+                                      .getBytes(StandardCharsets.UTF_8);\n+        out.add(ResourcePoolEntry.create(\"\/jdk.jlink\/\" + OPTIONS_RESOURCE,\n+                                         savedOptions));\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SaveJlinkArgfilesPlugin.java","additions":6,"deletions":20,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,16 +27,0 @@\n-import static java.lang.constant.ConstantDescs.CD_List;\n-import static java.lang.constant.ConstantDescs.CD_Map;\n-import static java.lang.constant.ConstantDescs.CD_Object;\n-import static java.lang.constant.ConstantDescs.CD_Set;\n-import static java.lang.constant.ConstantDescs.CD_String;\n-import static java.lang.constant.ConstantDescs.CD_boolean;\n-import static java.lang.constant.ConstantDescs.CD_byte;\n-import static java.lang.constant.ConstantDescs.CD_int;\n-import static java.lang.constant.ConstantDescs.CD_void;\n-import static java.lang.constant.ConstantDescs.INIT_NAME;\n-import static java.lang.constant.ConstantDescs.MTD_void;\n-import static jdk.internal.classfile.Classfile.ACC_FINAL;\n-import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n-import static jdk.internal.classfile.Classfile.ACC_STATIC;\n-import static jdk.internal.classfile.Classfile.ACC_SUPER;\n-\n@@ -49,0 +33,1 @@\n+import static java.lang.constant.ConstantDescs.*;\n@@ -82,5 +67,0 @@\n-import jdk.internal.classfile.ClassBuilder;\n-import jdk.internal.classfile.Classfile;\n-import jdk.internal.classfile.CodeBuilder;\n-import jdk.internal.classfile.TypeKind;\n-import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n@@ -89,0 +69,1 @@\n+import jdk.internal.module.Modules;\n@@ -95,1 +76,8 @@\n-import jdk.internal.module.Modules;\n+\n+import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.TypeKind;\n+import static jdk.internal.classfile.Classfile.*;\n+import jdk.internal.classfile.CodeBuilder;\n+\n@@ -182,2 +170,1 @@\n-        \/\/ pass through all other resources other than SystemModules* and\n-        \/\/ SystemModulesMap classes as we've generated them.\n+        \/\/ pass through all other resources\n@@ -185,13 +172,2 @@\n-            .filter(data -> {\n-                String path = data.path();\n-                if (path.endsWith(\"\/module-info.class\") || generated.contains(path)) {\n-                    return false;\n-                }\n-                String className = extractClassName(path);\n-                if (className != null &&\n-                        className.startsWith(\n-                                 SYSTEM_MODULES_CLASS_PREFIX)) {\n-                    return false;\n-                }\n-                return true;\n-            })\n+            .filter(data -> !data.path().endsWith(\"\/module-info.class\")\n+                    && !generated.contains(data.path()))\n@@ -203,7 +179,0 @@\n-    static String extractClassName(String path) {\n-        if (!path.endsWith(\".class\") || !path.startsWith(\"\/java.base\/\")) {\n-            return null; \/\/ not a class or not java.base\n-        }\n-        return path.substring(\"\/java.base\/\".length(), path.length() - 6 \/* .class *\/);\n-    }\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":13,"deletions":44,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.nio.file.Paths;\n@@ -32,1 +31,0 @@\n-import java.util.Collections;\n@@ -39,1 +37,0 @@\n-import jdk.tools.jlink.plugin.Plugin;\n@@ -41,0 +38,1 @@\n+import jdk.tools.jlink.plugin.Plugin;\n@@ -102,1 +100,2 @@\n-            totalPlugins = builtInPlugins.size();\n+            \/\/ AddRunImageResourcesPlugin is hidden from --list-plugins\n+            totalPlugins = builtInPlugins.stream().filter(p -> !p.isHidden()).collect(Collectors.toList()).size();\n","filename":"test\/jdk\/tools\/jlink\/JLinkTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Verify JLI class generation in run-time image link mode\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g GenerateJLIClassesTest\n+ *\/\n+public class GenerateJLIClassesTest extends AbstractJmodLessTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        GenerateJLIClassesTest test = new GenerateJLIClassesTest();\n+        test.run();\n+    }\n+\n+    \/*\n+     * java.lang.invoke.BoundMethodHandle$Species_* classes get generated\n+     * by the GenerateJLiClassesPlugin. This test ensures that potentially\n+     * generated JLI classes from the run-time image don't populate to the\n+     * target image in the run-time image based link mode.\n+     *\/\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        \/\/ create an image with a module containing a main entrypoint (jdk.httpserver),\n+        \/\/ thus producing the SystemModules$0.class. Add jdk.jdwp.agent as a module which\n+        \/\/ isn't resolved by default, so as to generate SystemModules$default.class\n+\n+        Path baseFile = Files.createTempFile(\"base\", \"trace\");\n+        String species = \"LLLLLLLLLLLLLLLLLLL\";\n+        String fileString = \"[SPECIES_RESOLVE] java.lang.invoke.BoundMethodHandle$Species_\" + species + \" (salvaged)\\n\";\n+        Files.write(baseFile, fileString.getBytes(StandardCharsets.UTF_8));\n+        Path jmodLessImage = createJavaImageJmodLess(new BaseJlinkSpecBuilder()\n+                                                            .helper(helper)\n+                                                            .name(\"jlink.jli-jmodless\")\n+                                                            .addModule(\"jdk.jlink\")\n+                                                            .validatingModule(\"java.base\")\n+                                                            .addExtraOption(\"--unlock-run-image\")\n+                                                            .build());\n+        \/\/ Finally attempt another jmodless link reducing modules to java.base only,\n+        \/\/ and asking for specific jli classes.\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(jmodLessImage)\n+                                .name(\"java.base-jli-derived\")\n+                                .addModule(\"java.base\")\n+                                .extraJlinkOpt(\"--generate-jli-classes=@\" + baseFile.toString())\n+                                .expectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_\" + species + \".class\")\n+                                .expectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_L.class\")\n+                                .unexpectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_\" + species.substring(1) + \".class\")\n+                                .unexpectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LL.class\")\n+                                .validatingModule(\"java.base\")\n+                                .build());\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/GenerateJLIClassesTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -33,1 +33,1 @@\n- * @summary Test appropriate handling of generated SystemModules* classes in jmod-less mode\n+ * @summary Test appropriate handling of generated SystemModules* classes in run-time image link mode\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/SystemModulesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import tests.Helper;\n+import tests.JImageValidator;\n+\n+\/*\n+ * @test\n+ * @summary Test SystemModules handling of java --list-modules with system modules\n+ *          not consistently enabled\/disabled.\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g SystemModulesTest2\n+ *\/\n+public class SystemModulesTest2 extends AbstractJmodLessTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        SystemModulesTest2 test = new SystemModulesTest2();\n+        test.run();\n+    }\n+\n+    \/*\n+     * SystemModule classes are module specific and SystemModulesMap gets generated\n+     * for each link. This turns out to be a problem if we perform an initial\n+     * jmod-full link with system-modules plugin enabled, which in turn would\n+     * change the SystemModulesMap in the run time image that the final run-time\n+     * based link will then use to generate a link only using java.base. In that\n+     * case, we cannot use the fast path and we ought to use the slow path in\n+     * order to avoid CNFEs.\n+     *\/\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        \/\/ Create an image with two modules, so that SystemModulesMap gets generated\n+        \/\/ for it as system-modules plugin is auto-enabled. Later, reduce the set\n+        \/\/ of modules to only java.base with system-modules plugin disabled.\n+        Path javaJmodless = createJavaImageJmodLess(new BaseJlinkSpecBuilder()\n+                                                            .helper(helper)\n+                                                            .name(\"jlink-jmodless-sysmod2\")\n+                                                            .addModule(\"jdk.httpserver\")\n+                                                            .addModule(\"jdk.jlink\")\n+                                                            .validatingModule(\"java.base\")\n+                                                            .addExtraOption(\"--unlock-run-image\")\n+                                                            .build());\n+        \/\/ Verify that SystemModules$all.class is there\n+        JImageValidator.validate(javaJmodless.resolve(\"lib\").resolve(\"modules\"),\n+                                    List.of(\"\/java.base\/jdk\/internal\/module\/SystemModules$all.class\"), Collections.emptyList());\n+        \/\/ Attempt another run-time image link reducing modules to java.base only,\n+        \/\/ but we don't rewrite SystemModulesMap.\n+        Path finalResult = jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(javaJmodless)\n+                                .name(\"java.base-from-sysmod2-derived\")\n+                                .addModule(\"java.base\")\n+                                .extraJlinkOpt(\"--disable-plugin\")\n+                                .extraJlinkOpt(\"system-modules\") \/\/ disable sysmods\n+                                .expectedLocation(\"\/java.base\/jdk\/internal\/module\/SystemModulesMap.class\")\n+                                .expectedLocation(\"\/java.base\/jdk\/internal\/module\/SystemModules.class\")\n+                                .unexpectedLocation(\"\/java.base\/jdk\/internal\/module\/SystemModules$0.class\")\n+                                .validatingModule(\"java.base\")\n+                                .build());\n+        \/\/ Finally run --list-modules so as to verify it does not thow CNFE\n+        List<String> expectedModules = List.of(\"java.base\");\n+        verifyListModules(finalResult, expectedModules);\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/SystemModulesTest2.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"}]}