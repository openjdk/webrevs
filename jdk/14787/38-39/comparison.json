{"files":[{"patch":"@@ -219,1 +219,1 @@\n-        ResourcePool result;\n+        ResourcePool result = null;\n@@ -222,0 +222,2 @@\n+        } catch (RuntimeImageLinkException e) {\n+            throwRuntimeLinkFailure(e);\n@@ -228,2 +230,1 @@\n-            \/\/ Propagate reason for jlink runs based on linkable JDK runtimes\n-            throw e.getReason();\n+            throwRuntimeLinkFailure(e);\n@@ -238,0 +239,9 @@\n+    private static void throwRuntimeLinkFailure(RuntimeImageLinkException e) throws IOException {\n+        if (JlinkTask.DEBUG) {\n+            e.getReason().printStackTrace();\n+        }\n+        \/\/ Propagate as IOException with appropriate message for\n+        \/\/ jlink runs from the run-time image\n+        throw new IOException(e.getReason().getMessage());\n+    }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageFileCreator.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.nio.file.NoSuchFileException;\n@@ -462,1 +463,14 @@\n-                            return Files.size(archive.getPath().resolve(resPath));\n+                            try {\n+                                return Files.size(archive.getPath().resolve(resPath));\n+                            } catch (NoSuchFileException file) {\n+                                \/\/ This indicates that we don't find the class in the\n+                                \/\/ modules image using the JRT FS provider. Yet, we find\n+                                \/\/ the class using the system module finder. Therefore,\n+                                \/\/ we have a patched module. Mention that module patching\n+                                \/\/ is not supported.\n+                                String msgFormat = \"File %s not found in the modules image.\\n\" +\n+                                                   \"--patch-module is not supported for run-time image linking.\";\n+                                String msg = String.format(msgFormat, file.getFile());\n+                                IllegalArgumentException noModulePatch = new IllegalArgumentException(msg);\n+                                throw new RuntimeImageLinkException(noModulePatch);\n+                            }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JRTArchive.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -274,1 +274,5 @@\n-                optionsHelper.showHelp(PROGNAME);\n+                \/\/ In order to be able to show the run-time image based link\n+                \/\/ capability in --help, we need to look for the delta files\n+                \/\/ in jdk.jlink\n+                boolean runtimeCapability = hasRuntimeImageLinkCap();\n+                optionsHelper.showHelp(PROGNAME, runtimeCapability);\n@@ -609,1 +613,1 @@\n-        if (ouri.isEmpty())\n+        if (ouri.isEmpty()) {\n@@ -611,0 +615,1 @@\n+        }\n@@ -674,1 +679,1 @@\n-            if (!\"\".equals(im))\n+            if (!\"\".equals(im)) {\n@@ -676,0 +681,1 @@\n+            }\n@@ -681,1 +687,1 @@\n-        Platform targetPlatform = targetPlatform(cf, mods);\n+        Platform targetPlatform = targetPlatform(cf, mods, config.linkFromRuntimeImage());\n@@ -734,6 +740,6 @@\n-        String resourceName = String.format(DIFF_PATTERN, \"java.base\");\n-        InputStream inStream = JlinkTask.class.getModule().getResourceAsStream(resourceName);\n-        if (inStream == null) {\n-            \/\/ Only linkable JDK runtimes have those resources. Abort otherwise.\n-            String msg = taskHelper.getMessage(\"err.runtime.link.not.linkable.runtime\");\n-            throw new IllegalArgumentException(msg);\n+        try (InputStream inStream = getDiffInputStream()) {\n+            if (inStream == null) {\n+                \/\/ Only linkable JDK runtimes have those resources. Abort otherwise.\n+                String msg = taskHelper.getMessage(\"err.runtime.link.not.linkable.runtime\");\n+                throw new IllegalArgumentException(msg);\n+            }\n@@ -754,0 +760,22 @@\n+    private static boolean hasRuntimeImageLinkCap() {\n+        try (InputStream in = getDiffInputStream()) {\n+            return in != null;\n+        } catch (IOException e) {\n+            \/\/ fall-through\n+        }\n+        return false;\n+    }\n+\n+    private static InputStream getDiffInputStream() {\n+        try {\n+            String resourceName = String.format(DIFF_PATTERN, \"java.base\");\n+            return JlinkTask.class.getModule().getResourceAsStream(resourceName);\n+        } catch (IOException e) {\n+            if (DEBUG) {\n+                System.err.println(\"Failed to get diff pattern resource\");\n+                e.printStackTrace();\n+            }\n+            return null;\n+        }\n+    }\n+\n@@ -878,1 +906,3 @@\n-    private static Platform targetPlatform(Configuration cf, Map<String, Path> modsPaths) throws IOException {\n+    private static Platform targetPlatform(Configuration cf,\n+                                           Map<String, Path> modsPaths,\n+                                           boolean runtimeImageLink) throws IOException {\n@@ -881,1 +911,1 @@\n-        if (isJavaBaseFromDefaultModulePath(javaBasePath)) {\n+        if (runtimeImageLink || isJavaBaseFromDefaultModulePath(javaBasePath)) {\n@@ -972,1 +1002,1 @@\n-        if (modules.isEmpty())\n+        if (modules.isEmpty()) {\n@@ -974,0 +1004,1 @@\n+        }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":44,"deletions":13,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.nio.file.Paths;\n@@ -33,6 +32,0 @@\n-import java.util.Map;\n-import java.util.HashMap;\n-import java.util.Map.Entry;\n-import java.util.Set;\n-import java.util.HashSet;\n-import java.util.List;\n@@ -41,1 +34,0 @@\n-import java.util.stream.Stream;\n@@ -43,0 +35,4 @@\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n@@ -44,1 +40,2 @@\n-import java.util.ResourceBundle;\n+import java.util.Map;\n+import java.util.Map.Entry;\n@@ -46,2 +43,3 @@\n-import java.util.Comparator;\n-\n+import java.util.ResourceBundle;\n+import java.util.Set;\n+import java.util.stream.Stream;\n@@ -58,1 +56,0 @@\n-import jdk.tools.jlink.plugin.PluginException;\n@@ -587,1 +584,1 @@\n-        public void showHelp(String progName) {\n+        public void showHelp(String progName, boolean runtimeCap) {\n@@ -597,0 +594,4 @@\n+            \/\/ If the JDK build has the run-time image capability show it\n+            \/\/ in the help output\n+            log.println(bundleHelper.getMessage(\"main.capability.runtime\",\n+                                                runtimeCap ? \"+\" : \"-\"));\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/TaskHelper.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -114,0 +114,1 @@\n+main.capability.runtime=Capabilities: {0}run-time-image\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires jlink.packagedModules\n","filename":"test\/jdk\/jdk\/modules\/etc\/JmodExcludedFiles.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.spi.ToolProvider;\n+\n+\/*\n+ * @test id=run-time-image-cap-yes\n+ * @summary Test jlink --help for capability output (true)\n+ * @requires (vm.compMode != \"Xcomp\" & jlink.runtime.linkable)\n+ * @run main\/othervm JLinkHelpCapabilityTest true\n+ *\/\n+\n+\/*\n+ * @test id=run-time-image-cap-no\n+ * @summary Test jlink --help for capability output (false)\n+ * @requires (vm.compMode != \"Xcomp\" & !jlink.runtime.linkable)\n+ * @run main\/othervm JLinkHelpCapabilityTest false\n+ *\/\n+public class JLinkHelpCapabilityTest {\n+    static final ToolProvider JLINK_TOOL = ToolProvider.findFirst(\"jlink\")\n+        .orElseThrow(() ->\n+            new RuntimeException(\"jlink tool not found\")\n+        );\n+\n+    public static void main(String[] args) throws Exception {\n+        boolean runtimeLinkCap = Boolean.parseBoolean(args[0]);\n+        String capabilities = String.format(\"Capabilities: %srun-time-image\",\n+                                            runtimeLinkCap ? \"+\" : \"-\");\n+        {\n+            \/\/ Verify capability in --help output\n+            StringWriter writer = new StringWriter();\n+            PrintWriter pw = new PrintWriter(writer);\n+            JLINK_TOOL.run(pw, pw, \"--help\");\n+            String output = writer.toString().trim();\n+            String lines[] = output.split(\"\\n\");\n+            if (!capabilities.equals(lines[lines.length - 1])) {\n+                System.err.println(output);\n+                throw new AssertionError(\"'--help': Capabilities mismatch. Expected: '\" + capabilities +\"'\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JLinkHelpCapabilityTest.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import java.nio.file.FileVisitor;\n@@ -37,0 +38,1 @@\n+import java.util.Set;\n@@ -108,0 +110,4 @@\n+        return createJavaImageRuntimeLink(baseSpec, Collections.emptySet() \/* exclude all jmods *\/);\n+    }\n+\n+    protected Path createJavaImageRuntimeLink(BaseJlinkSpec baseSpec, Set<String> excludedJmods) throws Exception {\n@@ -109,1 +115,1 @@\n-        Path runtimeJlinkImage = createRuntimeLinkImage(baseSpec);\n+        Path runtimeJlinkImage = createRuntimeLinkImage(baseSpec, excludedJmods);\n@@ -199,2 +205,3 @@\n-     * runtime-linkable. However, since the 'jmods' dir is present (default jmods\n-     * module path), it needs to get removed to provoke a runtime link.\n+     * runtime-linkable. However, since the 'jmods' dir might be present\n+     * (default jmods module path), it needs to get removed to provoke a runtime\n+     * link.\n@@ -207,0 +214,17 @@\n+        return createRuntimeLinkImage(baseSpec, Collections.emptySet() \/* exclude all jmods *\/);\n+    }\n+\n+    \/**\n+     * Prepares the test for execution. This assumes the current jimage is\n+     * runtime-linkable. However, since the 'jmods' dir might be present\n+     * (default jmods module path), it needs to get removed to provoke a runtime\n+     * link.\n+     *\n+     * @param baseSpec The modules to jlink\n+     * @param excludedJmods The set of jmod files to exclude in the base JDK. Empty set if\n+     *                      all JMODs should be removed.\n+     * @return A path to a JDK image which is prepared for runtime linking.\n+     * @throws Exception\n+     *\/\n+    protected Path createRuntimeLinkImage(BaseJlinkSpec baseSpec,\n+                                          Set<String> excludedJmodFiles) throws Exception {\n@@ -208,4 +232,14 @@\n-        copyJDKTreeWithoutJmods(runtimeJlinkImage);\n-        \/\/ Verify the base image is actually without packaged modules\n-        if (Files.exists(runtimeJlinkImage.resolve(\"jmods\"))) {\n-            throw new AssertionError(\"Must not contain 'jmods' directory\");\n+        copyJDKTreeWithoutSpecificJmods(runtimeJlinkImage, excludedJmodFiles);\n+        \/\/ Verify the base image is actually without desired packaged modules\n+        if (excludedJmodFiles.isEmpty()) {\n+            if (Files.exists(runtimeJlinkImage.resolve(\"jmods\"))) {\n+                throw new AssertionError(\"Must not contain 'jmods' directory\");\n+            }\n+        } else {\n+            Path basePath = runtimeJlinkImage.resolve(\"jmods\");\n+            for (String jmodFile: excludedJmodFiles) {\n+                Path unexpectedFile = basePath.resolve(Path.of(jmodFile));\n+                if (Files.exists(unexpectedFile)) {\n+                    throw new AssertionError(\"Must not contain jmod: \" + unexpectedFile);\n+                }\n+            }\n@@ -216,1 +250,2 @@\n-    private void copyJDKTreeWithoutJmods(Path runtimeJlinkImage) throws Exception {\n+    private void copyJDKTreeWithoutSpecificJmods(Path runtimeJlinkImage,\n+                                                 Set<String> excludedJmods) throws Exception {\n@@ -220,26 +255,9 @@\n-        Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n-            @Override\n-            public FileVisitResult preVisitDirectory(Path dir,\n-                    BasicFileAttributes attrs) throws IOException {\n-                Objects.requireNonNull(dir);\n-                Path relative = root.relativize(dir);\n-                if (relative.getFileName().equals(Path.of(\"jmods\"))) {\n-                    return FileVisitResult.SKIP_SUBTREE;\n-                }\n-                \/\/ Create dir in destination location\n-                Path targetDir = runtimeJlinkImage.resolve(relative);\n-                if (!Files.exists(targetDir)) {\n-                    Files.createDirectory(targetDir);\n-                }\n-                return FileVisitResult.CONTINUE;\n-            }\n-\n-            @Override\n-            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n-                    throws IOException {\n-                Path relative = root.relativize(file);\n-                Files.copy(file, runtimeJlinkImage.resolve(relative), StandardCopyOption.REPLACE_EXISTING);\n-                return FileVisitResult.CONTINUE;\n-            }\n-        });\n-\n+        FileVisitor<Path> fileVisitor = null;\n+        if (excludedJmods.isEmpty()) {\n+            fileVisitor = new ExcludeAllJmodsFileVisitor(root, runtimeJlinkImage);\n+        } else {\n+            fileVisitor = new FileExcludingFileVisitor(excludedJmods,\n+                                                       root,\n+                                                       runtimeJlinkImage);\n+        }\n+        Files.walkFileTree(root, fileVisitor);\n@@ -277,0 +295,76 @@\n+    static class ExcludeAllJmodsFileVisitor extends SimpleFileVisitor<Path> {\n+        private final Path root;\n+        private final Path destination;\n+\n+        private ExcludeAllJmodsFileVisitor(Path root,\n+                                           Path destination) {\n+            this.destination = destination;\n+            this.root = root;\n+        }\n+\n+        @Override\n+        public FileVisitResult preVisitDirectory(Path dir,\n+                BasicFileAttributes attrs) throws IOException {\n+            Objects.requireNonNull(dir);\n+            Path relative = root.relativize(dir);\n+            if (relative.getFileName().equals(Path.of(\"jmods\"))) {\n+                return FileVisitResult.SKIP_SUBTREE;\n+            }\n+            \/\/ Create dir in destination location\n+            Path targetDir = destination.resolve(relative);\n+            if (!Files.exists(targetDir)) {\n+                Files.createDirectory(targetDir);\n+            }\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                throws IOException {\n+            Path relative = root.relativize(file);\n+            Files.copy(file, destination.resolve(relative), StandardCopyOption.REPLACE_EXISTING);\n+            return FileVisitResult.CONTINUE;\n+        }\n+    }\n+\n+    static class FileExcludingFileVisitor extends SimpleFileVisitor<Path> {\n+\n+        private final Set<String> filesToExclude;\n+        private final Path root;\n+        private final Path destination;\n+\n+        private FileExcludingFileVisitor(Set<String> filesToExclude,\n+                                         Path root,\n+                                         Path destination) {\n+            this.filesToExclude = filesToExclude;\n+            this.destination = destination;\n+            this.root = root;\n+        }\n+\n+        @Override\n+        public FileVisitResult preVisitDirectory(Path dir,\n+                BasicFileAttributes attrs) throws IOException {\n+            Objects.requireNonNull(dir);\n+            Path relative = root.relativize(dir);\n+            \/\/ Create dir in destination location\n+            Path targetDir = destination.resolve(relative);\n+            if (!Files.exists(targetDir)) {\n+                Files.createDirectory(targetDir);\n+            }\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                throws IOException {\n+            Path relative = root.relativize(file);\n+            \/\/ Skip files as determined by the exclude set\n+            String fileName = file.getFileName().toString();\n+            if (!filesToExclude.contains(fileName)) {\n+                Files.copy(file, destination.resolve(relative), StandardCopyOption.REPLACE_EXISTING);\n+            }\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+    }\n+\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/AbstractLinkableRuntimeTest.java","additions":128,"deletions":34,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Set;\n+\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test\n+ * @summary Test basic runtime-image-based jlinking with java.base.jmod missing\n+ *          but java.xml.jmod present. It should use a run-time image based link.\n+ * @requires (jlink.packagedModules & jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g BasicJlinkMissingJavaBase\n+ *\/\n+public class BasicJlinkMissingJavaBase extends AbstractLinkableRuntimeTest {\n+\n+    @Override\n+    public void runTest(Helper helper) throws Exception {\n+        Path finalImage = createJavaXMLRuntimeLink(helper, \"java-xml\");\n+        verifyListModules(finalImage, List.of(\"java.base\", \"java.xml\"));\n+    }\n+\n+    private Path createJavaXMLRuntimeLink(Helper helper, String name) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder();\n+        builder.helper(helper)\n+               .name(name)\n+               .addModule(\"java.xml\")\n+               .validatingModule(\"java.xml\");\n+        Set<String> excludedJmods = Set.of(\"java.base.jmod\");\n+        return createJavaImageRuntimeLink(builder.build(), excludedJmods);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        BasicJlinkMissingJavaBase test = new BasicJlinkMissingJavaBase();\n+        test.run();\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/BasicJlinkMissingJavaBase.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -41,1 +41,0 @@\n-                \/\/.name(\"java-base-jlink-with-mod\")\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+import java.util.spi.ToolProvider;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test\n+ * @summary Test run-time link with --patch-module. Expect failure.\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g PatchedJDKModuleJlinkTest\n+ *\/\n+public class PatchedJDKModuleJlinkTest extends AbstractLinkableRuntimeTest {\n+\n+    @Override\n+    public void runTest(Helper helper) throws Exception {\n+        String imageName = \"java-base-patched\";\n+        Path runtimeLinkImage = createRuntimeLinkImage(helper, imageName + \"-base\");\n+\n+        \/\/ Prepare patched module content\n+        Path patchSource = Path.of(\"java-base-patch-src\");\n+        Path pkg = patchSource.resolve(\"java\", \"lang\");\n+        Path extraClass = pkg.resolve(\"MyJlinkPatchInteger.java\");\n+        String source = \"\"\"\n+                package java.lang;\n+                public class MyJlinkPatchInteger {\n+                    public int add(int a, int b) {\n+                        return a + b;\n+                    }\n+                }\n+                \"\"\";\n+        Files.createDirectories(pkg);\n+        Files.writeString(extraClass, source);\n+        Path patchClasses = Path.of(\"java-base-patch-classes\");\n+        Files.createDirectories(patchClasses);\n+        ToolProvider javac = ToolProvider.findFirst(\"javac\")\n+                                         .orElseThrow(() -> new AssertionError(\"javac not found\"));\n+        javac.run(System.out, System.err, new String[] {\n+                \"-d\", patchClasses.toString(),\n+                \"--patch-module=java.base=\" + patchSource.toAbsolutePath().toString(),\n+                extraClass.toAbsolutePath().toString()\n+        });\n+\n+        \/\/ Perform a run-time image link expecting a failure\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer t) {\n+                return t.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(runtimeLinkImage)\n+                                .name(imageName + \"-derived\")\n+                                .addModule(\"java.base\")\n+                                .validatingModule(\"java.base\")\n+                                .extraJlinkOpt(\"-J--patch-module=java.base=\" +\n+                                               patchClasses.toAbsolutePath().toString())\n+                                .build(), handler, exitFailPred);\n+        OutputAnalyzer analyzer = handler.analyzer();\n+        if (analyzer.getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to fail due to patched module!\");\n+        }\n+        analyzer.stdoutShouldContain(\"MyJlinkPatchInteger.class not found in the modules image.\");\n+        analyzer.stdoutShouldContain(\"--patch-module is not supported\");\n+        \/\/ Verify the error message is reasonable\n+        analyzer.stdoutShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n+        analyzer.stdoutShouldNotContain(\"java.lang.IllegalArgumentException\");\n+    }\n+\n+    private Path createRuntimeLinkImage(Helper helper, String name) throws Exception {\n+        Path initialImage = createRuntimeLinkImage(new BaseJlinkSpecBuilder()\n+                .name(name)\n+                .addModule(\"java.base\")\n+                .validatingModule(\"java.base\")\n+                .helper(helper)\n+                .build());\n+        return initialImage;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        PatchedJDKModuleJlinkTest test = new PatchedJDKModuleJlinkTest();\n+        test.run();\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/PatchedJDKModuleJlinkTest.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -33,1 +33,1 @@\n- *  @run main AutostartPlugins\n+ *  @run main\/othervm AutostartPlugins\n","filename":"test\/langtools\/tools\/javac\/plugin\/AutostartPlugins.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- *  @run main InternalAPI\n+ *  @run main\/othervm InternalAPI\n","filename":"test\/langtools\/tools\/javac\/plugin\/InternalAPI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}