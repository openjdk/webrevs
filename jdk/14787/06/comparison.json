{"files":[{"patch":"@@ -190,0 +190,7 @@\n+        } catch (RunImageLinkException re) {\n+            \/\/ might be thrown in the run-image link case. Populate the\n+            \/\/ actual reason.\n+            if (JlinkTask.DEBUG) {\n+                re.printStackTrace();\n+            }\n+            throw re.getReason();\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageFileCreator.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.nio.ByteOrder;\n@@ -151,0 +150,2 @@\n+        private final boolean useModulePath;\n+        private final boolean singleHop;\n@@ -161,1 +162,3 @@\n-                                  ModuleFinder finder) {\n+                                  ModuleFinder finder,\n+                                  boolean useModulePath,\n+                                  boolean singleHop) {\n@@ -165,0 +168,2 @@\n+            this.useModulePath = useModulePath;\n+            this.singleHop = singleHop;\n@@ -189,0 +194,8 @@\n+        public boolean useModulePath() {\n+            return useModulePath;\n+        }\n+\n+        public boolean singleHop() {\n+            return singleHop;\n+        }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Jlink.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import static jdk.tools.jlink.internal.TaskHelper.JLINK_BUNDLE;\n+\n@@ -42,1 +44,0 @@\n-import java.nio.file.Files;\n@@ -44,0 +45,1 @@\n+import java.nio.file.Files;\n@@ -63,0 +65,1 @@\n+import jdk.internal.module.ModulePath;\n@@ -64,2 +67,3 @@\n-import jdk.tools.jlink.internal.TaskHelper.BadArgs;\n-import static jdk.tools.jlink.internal.TaskHelper.JLINK_BUNDLE;\n+import jdk.internal.module.ModuleResolution;\n+import jdk.internal.opt.CommandLine;\n+import jdk.tools.jlink.internal.ImagePluginStack.ImageProvider;\n@@ -68,0 +72,1 @@\n+import jdk.tools.jlink.internal.TaskHelper.BadArgs;\n@@ -70,1 +75,0 @@\n-import jdk.tools.jlink.internal.ImagePluginStack.ImageProvider;\n@@ -72,3 +76,0 @@\n-import jdk.internal.opt.CommandLine;\n-import jdk.internal.module.ModulePath;\n-import jdk.internal.module.ModuleResolution;\n@@ -185,1 +186,6 @@\n-        }, \"--ignore-signing-information\"),};\n+        }, \"--ignore-signing-information\"),\n+        new Option<JlinkTask>(false, (task, opt, arg) -> {\n+            task.options.runImageSingleHop = false;\n+        }, \"--unlock-run-image\"),\n+    };\n+\n@@ -225,0 +231,1 @@\n+        boolean runImageSingleHop = true;\n@@ -273,5 +280,0 @@\n-\n-                if (options.modulePath.isEmpty()) {\n-                    throw taskHelper.newBadArgs(\"err.modulepath.must.be.specified\")\n-                            .showUsage(true);\n-                }\n@@ -280,1 +282,2 @@\n-            JlinkConfiguration config = initJlinkConfig();\n+            boolean useModulePath = !options.modulePath.isEmpty();\n+            JlinkConfiguration config = initJlinkConfig(useModulePath);\n@@ -370,1 +373,1 @@\n-    private JlinkConfiguration initJlinkConfig() throws BadArgs {\n+    private JlinkConfiguration initJlinkConfig(boolean useModulePath) throws BadArgs {\n@@ -374,1 +377,1 @@\n-                ModuleFinder finder = newModuleFinder(options.modulePath, options.limitMods, Set.of());\n+                ModuleFinder finder = newModuleFinder(options.modulePath, options.limitMods, Set.of(), useModulePath);\n@@ -386,1 +389,1 @@\n-        ModuleFinder finder = newModuleFinder(options.modulePath, options.limitMods, roots);\n+        ModuleFinder finder = newModuleFinder(options.modulePath, options.limitMods, roots, useModulePath);\n@@ -392,1 +395,1 @@\n-            finder = newModuleFinder(options.modulePath, options.limitMods, roots);\n+            finder = newModuleFinder(options.modulePath, options.limitMods, roots, useModulePath);\n@@ -397,1 +400,3 @@\n-                                      finder);\n+                                      finder,\n+                                      useModulePath,\n+                                      options.runImageSingleHop);\n@@ -446,1 +451,2 @@\n-                                               Set<String> roots)\n+                                               Set<String> roots,\n+                                               boolean useModulePath)\n@@ -448,5 +454,0 @@\n-        if (Objects.requireNonNull(paths).isEmpty()) {\n-             throw new IllegalArgumentException(taskHelper.getMessage(\"err.empty.module.path\"));\n-        }\n-\n-        Path[] entries = paths.toArray(new Path[0]);\n@@ -454,2 +455,1 @@\n-        ModuleFinder finder = ModulePath.of(version, true, entries);\n-\n+        ModuleFinder finder = useModulePath ? moduleFinderFromPath(paths, version) : ModuleFinder.ofSystem();\n@@ -484,0 +484,9 @@\n+    private static ModuleFinder moduleFinderFromPath(List<Path> paths, Runtime.Version version) {\n+        if (Objects.requireNonNull(paths).isEmpty()) {\n+            throw new IllegalArgumentException(taskHelper.getMessage(\"err.empty.module.path\"));\n+       }\n+\n+       Path[] entries = paths.toArray(new Path[0]);\n+       return ModulePath.of(version, true, entries);\n+    }\n+\n@@ -537,0 +546,5 @@\n+        \/\/ Print info message when a run-image link is being performed\n+        if (log != null && !config.useModulePath()) {\n+            log.println(\"'jmods' folder not present, performing a run-image based link.\");\n+        }\n+\n@@ -541,2 +555,2 @@\n-              .forEach(rm -> log.format(\"%s %s%n\",\n-                                        rm.name(), rm.reference().location().get()));\n+              .forEach(rm -> log.format(\"%s %s%s%n\",\n+                                        rm.name(), rm.reference().location().get(), config.useModulePath() ? \"\" : \" (run-image)\"));\n@@ -583,1 +597,3 @@\n-        return new ImageHelper(cf, mods, targetPlatform, retainModulesPath, ignoreSigning);\n+        return new ImageHelper(cf, mods, targetPlatform, retainModulesPath,\n+                               ignoreSigning, config.useModulePath(),\n+                               config.singleHop());\n@@ -854,0 +870,1 @@\n+        final boolean singleHop;\n@@ -859,1 +876,3 @@\n-                    boolean ignoreSigning) throws IOException {\n+                    boolean ignoreSigning,\n+                    boolean useModulePath,\n+                    boolean singleHop) throws IOException {\n@@ -864,0 +883,1 @@\n+            this.singleHop = singleHop;\n@@ -876,1 +896,1 @@\n-                                .map(e -> newArchive(e.getKey(), e.getValue()))\n+                                .map(e -> newArchive(e.getKey(), e.getValue(), useModulePath))\n@@ -880,1 +900,1 @@\n-        private Archive newArchive(String module, Path path) {\n+        private Archive newArchive(String module, Path path, boolean useModulePath) {\n@@ -909,1 +929,1 @@\n-            } else if (Files.isDirectory(path)) {\n+            } else if (useModulePath && Files.isDirectory(path)) {\n@@ -917,0 +937,3 @@\n+            } else if (ModuleFinder.ofSystem().find(module).isPresent()){\n+                \/\/ the path is a JRTPath, when using a jmod-less image\n+                return new RunImageArchive(module, path, singleHop);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":57,"deletions":34,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -0,0 +1,367 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReference;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.tools.jlink.plugin.ResourcePoolEntry.Type;\n+\n+public class RunImageArchive implements Archive {\n+\n+    private static final String JAVA_BASE_MODULE = \"java.base\";\n+    \/\/ File marker in lib\/modules file for java.base indicating it got created\n+    \/\/ with a run-image-type link.\n+    private static final String RUNIMAGE_SINGLE_HOP_STAMP = \".runimage.stamp\";\n+    private static final String OTHER_RESOURCES_FILE = \"runimage_resources\";\n+    private final String module;\n+    private final Path path;\n+    private final ModuleReference ref;\n+    private final List<RunImageFile> files = new ArrayList<>();\n+    private final boolean singleHop;\n+\n+    RunImageArchive(String module, Path path, boolean singleHop) {\n+        this.module = module;\n+        this.path = path;\n+        this.ref = ModuleFinder.ofSystem()\n+                    .find(module)\n+                    .orElseThrow(() ->\n+                        new IllegalArgumentException(\"Module \" + module + \" not part of the JDK install\"));\n+        this.singleHop = singleHop;\n+    }\n+\n+    @Override\n+    public String moduleName() {\n+        return module;\n+    }\n+\n+    @Override\n+    public Path getPath() {\n+        return path;\n+    }\n+\n+    @Override\n+    public Stream<Entry> entries() {\n+        try {\n+            collectFiles();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        } catch (RunImageLinkException e) {\n+            \/\/ populate single-hop issue\n+            throw e.getReason();\n+        }\n+        return files.stream()\n+                    .sorted((a, b) -> {return a.resPath.compareTo(b.resPath);})\n+                    .map(f -> { return f.toEntry();});\n+    }\n+\n+    @Override\n+    public void open() throws IOException {\n+        if (files.isEmpty()) {\n+            collectFiles();\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (!files.isEmpty()) {\n+            files.clear();\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(module, path);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof RunImageArchive) {\n+            RunImageArchive other = (RunImageArchive)obj;\n+            return Objects.equals(module, other.module) &&\n+                   Objects.equals(path, other.path);\n+        }\n+\n+        return false;\n+    }\n+\n+    private void collectFiles() throws IOException {\n+        if (files.isEmpty()) {\n+            addNonClassResources();\n+            \/\/ Add classes\/resources from image module\n+            files.addAll(ref.open().list()\n+                                   .map(s -> {\n+                return new RunImageFile(RunImageArchive.this, s,\n+                        Type.CLASS_OR_RESOURCE, null \/* sha *\/, false \/* symlink *\/, singleHop);\n+            }).collect(Collectors.toList()));\n+            \/\/ if we use single-hop and we find a stamp file we fail the link\n+            if (files.stream().anyMatch(f -> { return RUNIMAGE_SINGLE_HOP_STAMP.equals(f.resPath);})) {\n+                String msg = \"Recursive links based on the current run-image are not allowed.\";\n+                IllegalArgumentException ise = new IllegalArgumentException(msg);\n+                throw new RunImageLinkException(ise);\n+            };\n+            \/\/ add\/persist a special, empty file for java.base so as to support\n+            \/\/ the single-hop-only runimage-jlink\n+            if (singleHop && JAVA_BASE_MODULE.equals(module)) {\n+                files.add(createRunImageSingleHopStamp());\n+            }\n+        }\n+    }\n+\n+    private RunImageFile createRunImageSingleHopStamp() {\n+        return new RunImageStampFile(this, RUNIMAGE_SINGLE_HOP_STAMP, Type.CLASS_OR_RESOURCE, null, false, singleHop);\n+    }\n+\n+    private void addNonClassResources() throws IOException {\n+        Optional<InputStream> runImageResources = ref.open().open(OTHER_RESOURCES_FILE);\n+        \/\/ Not all modules will have other resources like bin, lib, legal etc.\n+        \/\/ files. In that case the file won't exist in the modules image.\n+        if (runImageResources.isPresent()) {\n+            try (InputStream inStream = runImageResources.get()) {\n+                String input = new String(inStream.readAllBytes(), StandardCharsets.UTF_8);\n+                files.addAll(Arrays.asList(input.split(\"\\n\")).stream()\n+                        .map(s -> {\n+                            TypePathMapping m = mappingResource(s);\n+                            return new RunImageFile(RunImageArchive.this, m.resPath, m.resType, m.sha, m.symlink, singleHop);\n+                        })\n+                        .filter(m -> m != null)\n+                        .collect(Collectors.toList()));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     *  line: <int>|<int>|<sha>|<path>\n+     *\n+     *  Take the integer before '|' convert it to a Type. The second\n+     *  token is an integer representing symlinks (or not). The third token is\n+     *  a hash sum (sha512) of the file denoted by the fourth token (path).\n+     *\/\n+    private static TypePathMapping mappingResource(String line) {\n+        if (line.isEmpty()) {\n+            return null;\n+        }\n+        String[] tokens = line.split(\"\\\\|\", 4);\n+        Type type = null;\n+        int symlinkNum = -1;\n+        try {\n+            Integer typeInt = Integer.valueOf(tokens[0]);\n+            type = Type.fromOrdinal(typeInt);\n+            symlinkNum = Integer.valueOf(tokens[1]);\n+        } catch (NumberFormatException e) {\n+            throw new AssertionError(e); \/\/ must not happen\n+        }\n+        if (symlinkNum < 0 || symlinkNum > 1) {\n+            throw new IllegalStateException(\"Symlink designator out of range [0,1] got: \" + symlinkNum);\n+        }\n+        boolean isSymlink = symlinkNum > 0;\n+        return new TypePathMapping(tokens[2], tokens[3], type, isSymlink);\n+    }\n+\n+    static class TypePathMapping {\n+        final String resPath;\n+        final String sha;\n+        final Type resType;\n+        final boolean symlink;\n+        TypePathMapping(String sha, String resPath, Type resType, boolean symlink) {\n+            this.resPath = resPath;\n+            this.resType = resType;\n+            this.sha = Objects.requireNonNull(sha);\n+            this.symlink = symlink;\n+        }\n+    }\n+\n+    static class RunImageFile {\n+        private static final String JAVA_HOME = System.getProperty(\"java.home\");\n+        private static final Path BASE = Paths.get(JAVA_HOME);\n+        private static final String MISMATCH_FORMAT = \"%s has been modified. Please double check!%s%n\";\n+        final String resPath;\n+        final Archive.Entry.EntryType resType;\n+        final Archive archive;\n+        final String sha; \/\/ Checksum for non-resource files\n+        final boolean symlink;\n+        final boolean failOnMod; \/\/ Only allow non-failure in multi-hop mode\n+\n+        RunImageFile(Archive archive, String resPath, Type resType, String sha, boolean symlink, boolean failOnMod) {\n+            this.resPath = resPath;\n+            this.resType = toEntryType(resType);\n+            this.archive = archive;\n+            this.sha = sha;\n+            this.symlink = symlink;\n+            this.failOnMod = failOnMod;\n+        }\n+\n+        Entry toEntry() {\n+            return new Entry(archive, resPath, resPath, resType) {\n+\n+                private boolean warningProduced = false;\n+\n+                @Override\n+                public long size() {\n+                    try {\n+                        if (resType != Archive.Entry.EntryType.CLASS_OR_RESOURCE) {\n+                            \/\/ Read from the base JDK image, special casing\n+                            \/\/ symlinks, which have the link target in the sha field\n+                            if (symlink) {\n+                                return Files.size(BASE.resolve(sha));\n+                            }\n+                            return Files.size(BASE.resolve(resPath));\n+                        } else {\n+                            \/\/ Read from the module image. This works, because\n+                            \/\/ the underlying base path is a JrtPath with the\n+                            \/\/ JrtFileSystem underneath which is able to handle\n+                            \/\/ this size query\n+                            return Files.size(archive.getPath().resolve(resPath));\n+                        }\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                }\n+\n+                @Override\n+                public InputStream stream() throws IOException {\n+                    if (resType != Archive.Entry.EntryType.CLASS_OR_RESOURCE) {\n+                        \/\/ Read from the base JDK image.\n+                        Path path = BASE.resolve(resPath);\n+                        if (shaSumMismatch(path, sha, symlink)) {\n+                            if (failOnMod) {\n+                                String hint = \" You may force the link with '--unlock-run-image'.\";\n+                                String msg = String.format(MISMATCH_FORMAT, path.toString(), hint);\n+                                IllegalArgumentException ise = new IllegalArgumentException(msg);\n+                                throw new RunImageLinkException(ise);\n+                            } else if (!warningProduced) {\n+                                String msg = String.format(MISMATCH_FORMAT, path.toString(), \"\");\n+                                System.err.printf(\"WARNING: %s\", msg);\n+                                warningProduced = true;\n+                            }\n+                        }\n+                        if (symlink) {\n+                            path = BASE.resolve(sha);\n+                            return Files.newInputStream(path);\n+                        }\n+                        return Files.newInputStream(path);\n+                    } else {\n+                        \/\/ Read from the module image.\n+                        String module = archive.moduleName();\n+                        ModuleReference mRef = ModuleFinder.ofSystem().find(module).orElseThrow();\n+                        return mRef.open().open(resPath).orElseThrow();\n+                    }\n+                }\n+\n+                static boolean shaSumMismatch(Path res, String expectedSha, boolean isSymlink) {\n+                    if (isSymlink) {\n+                        return false;\n+                    }\n+                    \/\/ handle non-symlink resources\n+                    try {\n+                        HexFormat format = HexFormat.of();\n+                        byte[] expected = format.parseHex(expectedSha);\n+                        MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n+                        try (InputStream is = Files.newInputStream(res)) {\n+                            byte[] buf = new byte[1024];\n+                            int readBytes = -1;\n+                            while ((readBytes = is.read(buf)) != -1) {\n+                                digest.update(buf, 0, readBytes);\n+                            }\n+                        }\n+                        byte[] actual = digest.digest();\n+                        return !MessageDigest.isEqual(expected, actual);\n+                    } catch (Exception e) {\n+                        throw new AssertionError(\"SHA-512 sum check failed!\", e);\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        private static Archive.Entry.EntryType toEntryType(Type input) {\n+            switch(input) {\n+            case CLASS_OR_RESOURCE:\n+                return Archive.Entry.EntryType.CLASS_OR_RESOURCE;\n+            case CONFIG:\n+                return Archive.Entry.EntryType.CONFIG;\n+            case HEADER_FILE:\n+                return Archive.Entry.EntryType.HEADER_FILE;\n+            case LEGAL_NOTICE:\n+                return Archive.Entry.EntryType.LEGAL_NOTICE;\n+            case MAN_PAGE:\n+                return Archive.Entry.EntryType.MAN_PAGE;\n+            case NATIVE_CMD:\n+                return Archive.Entry.EntryType.NATIVE_CMD;\n+            case NATIVE_LIB:\n+                return Archive.Entry.EntryType.NATIVE_LIB;\n+            case TOP:\n+                throw new IllegalArgumentException(\"TOP files should be handled by ReleaseInfoPlugin!\");\n+            default:\n+                throw new IllegalArgumentException(\"Unknown type: \" + input);\n+            }\n+        }\n+    }\n+\n+    \/\/ Stamp file marker for single-hop implementation\n+    static class RunImageStampFile extends RunImageFile {\n+        RunImageStampFile(Archive archive, String resPath, Type resType, String sha, boolean symlink, boolean failOnMod) {\n+            super(archive, resPath, resType, sha, symlink, failOnMod);\n+        }\n+\n+        @Override\n+        Entry toEntry() {\n+            return new Entry(archive, resPath, resPath, resType) {\n+\n+                @Override\n+                public long size() {\n+                    \/\/ empty file\n+                    return 0;\n+                }\n+\n+                @Override\n+                public InputStream stream() throws IOException {\n+                    \/\/ empty content\n+                    return new ByteArrayInputStream(new byte[0]);\n+                }\n+\n+            };\n+        }\n+    }\n+\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/RunImageArchive.java","additions":367,"deletions":0,"binary":false,"changes":367,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal;\n+\n+\/**\n+ * Exception thrown for links without packaged modules. I.e. run-image link.\n+ *\n+ *\/\n+public class RunImageLinkException extends IllegalStateException {\n+\n+    private static final long serialVersionUID = -1848914673073119403L;\n+\n+    private final IllegalArgumentException iae;\n+\n+    public RunImageLinkException(IllegalArgumentException cause) {\n+        super(cause);\n+        this.iae = cause;\n+    }\n+\n+    public IllegalArgumentException getReason() {\n+        return iae;\n+    }\n+\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/RunImageLinkException.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.function.Function;\n@@ -75,1 +74,7 @@\n-        in.transformAndCopy(Function.identity(), out);\n+        in.transformAndCopy(e -> {\n+            if (path.equals(e.path())) {\n+                \/\/ Overwrite potentially existing entry\n+                return null;\n+            }\n+            return e;\n+        }, out);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/AddResourcePlugin.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal.plugins;\n+\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.util.OperatingSystem;\n+import jdk.tools.jlink.internal.Platform;\n+import jdk.tools.jlink.internal.RunImageLinkException;\n+import jdk.tools.jlink.plugin.ResourcePool;\n+import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n+import jdk.tools.jlink.plugin.ResourcePoolEntry;\n+import jdk.tools.jlink.plugin.ResourcePoolModule;\n+\n+\n+\/**\n+ * Plugin to collect resources from jmod which aren't classes or\n+ * resources. Needed for the the run-image-based jlink.\n+ *\/\n+public final class AddRunImageResourcesPlugin extends AbstractPlugin {\n+\n+    private static final int SYMLINKED_RES = 1;\n+    private static final int REGULAR_RES = 0;\n+    private static final String BIN_DIRNAME = \"bin\";\n+    private static final String LIB_DIRNAME = \"lib\";\n+    private static final String NAME = \"add-run-image-resources\";\n+    \/\/ This ought to be a package-less resource so as to not conflict with\n+    \/\/ packages listed in the module descriptors. Making it package-less ensures\n+    \/\/ it works for any module, regardless of packages present. This resource\n+    \/\/ is being used in RunImageArchive class\n+    private static final String RESPATH = \"\/%s\/runimage_resources\";\n+\n+    \/\/ Type file format:\n+    \/\/ '<type>|{0,1}|<sha-sum>|<file-path>'\n+    \/\/   (1)    (2)      (3)      (4)\n+    \/\/\n+    \/\/ Where fields are:\n+    \/\/\n+    \/\/ (1) The resource type as specified by ResourcePoolEntry.type()\n+    \/\/ (2) Symlink designator. 0 => regular resource, 1 => symlinked resource\n+    \/\/ (3) The SHA-512 sum of the resources' content. The link to the target\n+    \/\/     for symlinked resources.\n+    \/\/ (4) The relative file path of the resource\n+    private static final String TYPE_FILE_FORMAT = \"%d|%d|%s|%s\";\n+\n+    private final Map<String, List<String>> nonClassResEntries;\n+\n+    public AddRunImageResourcesPlugin() {\n+        super(NAME);\n+        this.nonClassResEntries = new ConcurrentHashMap<>();\n+    }\n+\n+    @Override\n+    public ResourcePool transform(ResourcePool in, ResourcePoolBuilder out) {\n+        Platform targetPlatform = getTargetPlatform(in);\n+        in.transformAndCopy(e -> { ResourcePoolEntry retval = recordAndFilterEntry(e, targetPlatform);\n+                                   return retval;}, out);\n+        addModuleResourceEntries(out);\n+        return out.build();\n+    }\n+\n+    private Platform getTargetPlatform(ResourcePool in) {\n+        String platform = in.moduleView().findModule(\"java.base\")\n+                .map(ResourcePoolModule::targetPlatform)\n+                .orElse(null);\n+        if (platform == null) {\n+            throw new IllegalStateException(\"java.base not part of the image?\");\n+        }\n+        return Platform.parsePlatform(platform);\n+    }\n+\n+    private void addModuleResourceEntries(ResourcePoolBuilder out) {\n+        for (String module: keysInSortedOrder()) {\n+            String mResource = String.format(RESPATH, module);\n+            List<String> mResources = nonClassResEntries.get(module);\n+            if (mResources == null) {\n+                throw new AssertionError(\"Module listed, but no resources?\");\n+            }\n+            String mResContent = mResources.stream().sorted().collect(Collectors.joining(\"\\n\"));\n+            out.add(ResourcePoolEntry.create(mResource,\n+                    mResContent.getBytes(StandardCharsets.UTF_8)));\n+        }\n+    }\n+\n+    private List<String> keysInSortedOrder() {\n+        List<String> keys = new ArrayList<>();\n+        keys.addAll(nonClassResEntries.keySet());\n+        Collections.sort(keys);\n+        return keys;\n+    }\n+\n+    private ResourcePoolEntry recordAndFilterEntry(ResourcePoolEntry entry, Platform platform) {\n+        \/\/ Note that the jmod_resources file is a resource file, so we cannot\n+        \/\/ add ourselves due to this condition. However, we want to not add\n+        \/\/ an old version of the resource file again.\n+        if (entry.type() != ResourcePoolEntry.Type.CLASS_OR_RESOURCE) {\n+            if (entry.type() == ResourcePoolEntry.Type.TOP) {\n+                return entry; \/\/ Handled by ReleaseInfoPlugin, nothing to do\n+            }\n+            List<String> moduleResources = nonClassResEntries.computeIfAbsent(entry.moduleName(), a -> new ArrayList<>());\n+            int type = entry.type().ordinal();\n+            int isSymlink = entry.linkedTarget() != null ? SYMLINKED_RES : REGULAR_RES;\n+            String resPathWithoutMod = resPathWithoutModule(entry, platform);\n+            String sha512 = computeSha512(entry, platform);\n+            moduleResources.add(String.format(TYPE_FILE_FORMAT, type, isSymlink, sha512, resPathWithoutMod));\n+        } else if (entry.type() == ResourcePoolEntry.Type.CLASS_OR_RESOURCE &&\n+                String.format(RESPATH, entry.moduleName()).equals(entry.path())) {\n+            \/\/ Filter \/<module>\/jmod_resources file which we create later\n+            return null;\n+        }\n+        return entry;\n+    }\n+\n+    private String computeSha512(ResourcePoolEntry entry, Platform platform) {\n+        try {\n+            if (entry.linkedTarget() != null) {\n+                \/\/ Symlinks don't have a hash sum, but a link to the target instead\n+                return resPathWithoutModule(entry.linkedTarget(), platform);\n+            } else {\n+                MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n+                try (InputStream is = entry.content()) {\n+                    byte[] buf = new byte[1024];\n+                    int bytesRead = -1;\n+                    while ((bytesRead = is.read(buf)) != -1) {\n+                        digest.update(buf, 0, bytesRead);\n+                    }\n+                }\n+                byte[] db = digest.digest();\n+                HexFormat format = HexFormat.of();\n+                return format.formatHex(db);\n+            }\n+        } catch (RunImageLinkException e) {\n+            \/\/ RunImageArchive::RunImageFile.content() may throw this when\n+            \/\/ getting the content(). Propagate this specific exeption.\n+            throw e;\n+        } catch (Exception e) {\n+            throw new AssertionError(\"Failed to generate hash sum for \" + entry.path());\n+        }\n+    }\n+\n+    private String resPathWithoutModule(ResourcePoolEntry entry, Platform platform) {\n+        String resPath = entry.path().substring(entry.moduleName().length() + 2 \/* prefixed and suffixed '\/' *\/);\n+        if (!isWindows(platform)) {\n+            return resPath;\n+        }\n+        \/\/ For Windows the libraries live in the 'bin' folder rather than the 'lib' folder\n+        \/\/ in the final image. Note that going by the NATIVE_LIB type only is insufficient since\n+        \/\/ only files with suffix .dll\/diz\/map\/pdb are transplanted to 'bin'.\n+        \/\/ See: DefaultImageBuilder.nativeDir()\n+        return nativeDir(entry, resPath);\n+    }\n+\n+    private boolean isWindows(Platform platform) {\n+        return platform.os() == OperatingSystem.WINDOWS;\n+    }\n+\n+    private String nativeDir(ResourcePoolEntry entry, String resPath) {\n+        if (entry.type() != ResourcePoolEntry.Type.NATIVE_LIB) {\n+            return resPath;\n+        }\n+        \/\/ precondition: Native lib, windows platform\n+        if (resPath.endsWith(\".dll\") || resPath.endsWith(\".diz\")\n+                || resPath.endsWith(\".pdb\") || resPath.endsWith(\".map\")) {\n+            if (resPath.startsWith(LIB_DIRNAME + \"\/\")) {\n+                return BIN_DIRNAME + \"\/\" + resPath.substring((LIB_DIRNAME + \"\/\").length());\n+            }\n+        }\n+        return resPath;\n+    }\n+\n+    @Override\n+    public Set<State> getState() {\n+        return EnumSet.of(State.AUTO_ENABLED, State.FUNCTIONAL);\n+    }\n+\n+    @Override\n+    public boolean hasArguments() {\n+        return false;\n+    }\n+\n+    @Override\n+    public Category getType() {\n+        \/\/ Ensure we run in a later stage as we need to generate\n+        \/\/ SHA-512 sums for non-(class\/resource) files. The jmod_resources\n+        \/\/ files can be considered meta-info describing the universe we\n+        \/\/ draft from.\n+        return Category.METAINFO_ADDER;\n+    }\n+\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/AddRunImageResourcesPlugin.java","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.HashSet;\n@@ -65,1 +66,18 @@\n-\n+    \/\/ Work-around for jmod-less jlinking. jmod archives don't contain these\n+    \/\/ classes so it isn't an issue for a jmod-full jlink.\n+    private static final Set<String> GENERATED_JAVA_BASE_CLASSES = Set.of(\n+            \"java\/lang\/invoke\/BoundMethodHandle$Species_D\",\n+            \"java\/lang\/invoke\/BoundMethodHandle$Species_DL\",\n+            \"java\/lang\/invoke\/BoundMethodHandle$Species_I\",\n+            \"java\/lang\/invoke\/BoundMethodHandle$Species_IL\",\n+            \"java\/lang\/invoke\/BoundMethodHandle$Species_LJ\",\n+            \"java\/lang\/invoke\/BoundMethodHandle$Species_LL\",\n+            \"java\/lang\/invoke\/BoundMethodHandle$Species_LLJ\",\n+            \"java\/lang\/invoke\/BoundMethodHandle$Species_LLL\",\n+            \"java\/lang\/invoke\/BoundMethodHandle$Species_LLLJ\",\n+            \"java\/lang\/invoke\/BoundMethodHandle$Species_LLLL\",\n+            \"java\/lang\/invoke\/BoundMethodHandle$Species_LLLLL\",\n+            \"java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLL\",\n+            \"java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLLL\",\n+            \"java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLLLL\",\n+            \"java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLLLLL\");\n@@ -124,0 +142,1 @@\n+        final Set<String> containedClasses = new HashSet<>();\n@@ -137,0 +156,5 @@\n+                    \/\/ Keep track of generated JLI classes\n+                    String className = possiblyStripFromPath(path);\n+                    if (GENERATED_JAVA_BASE_CLASSES.contains(className)) {\n+                        containedClasses.add(className);\n+                    }\n@@ -146,3 +170,9 @@\n-                        String entryName = \"\/java.base\/\" + cn + \".class\";\n-                        ResourcePoolEntry ndata = ResourcePoolEntry.create(entryName, bytes);\n-                        out.add(ndata);\n+                        \/\/ containedClasses will not contain any generated JLI\n+                        \/\/ classes for the initial link, but will contain all\n+                        \/\/ JLI classes in GENERATED_JAVA_BASE_CLASSES in the\n+                        \/\/ recursive jmodless jlink case.\n+                        if (!containedClasses.contains(cn)) {\n+                            String entryName = \"\/java.base\/\" + cn + \".class\";\n+                            ResourcePoolEntry ndata = ResourcePoolEntry.create(entryName, bytes);\n+                            out.add(ndata);\n+                        }\n@@ -157,0 +187,7 @@\n+    private static String possiblyStripFromPath(String path) {\n+        if (path.startsWith(\"\/java.base\/\") && path.endsWith(\".class\")) {\n+            return path.substring(\"\/java.base\/\".length(), path.length() - \".class\".length());\n+        }\n+        return path;\n+    }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/GenerateJLIClassesPlugin.java","additions":41,"deletions":4,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.util.function.Function;\n@@ -96,1 +95,0 @@\n-        in.transformAndCopy(Function.identity(), out);\n@@ -100,0 +98,1 @@\n+        final String jdkJlinkResource = \"\/jdk.jlink\/\" + OPTIONS_RESOURCE;\n@@ -101,4 +100,19 @@\n-                                      .collect(Collectors.joining(\"\\n\"))\n-                                      .getBytes(StandardCharsets.UTF_8);\n-        out.add(ResourcePoolEntry.create(\"\/jdk.jlink\/\" + OPTIONS_RESOURCE,\n-                                         savedOptions));\n+                .collect(Collectors.joining(\"\\n\"))\n+                .getBytes(StandardCharsets.UTF_8);\n+        final ResourcePoolEntry jdkJlinkSavedEntry = ResourcePoolEntry.create(\"\/jdk.jlink\/\" + OPTIONS_RESOURCE,\n+                savedOptions);\n+        final boolean[] haveEntry = new boolean[] { false };\n+        in.transformAndCopy(e -> {\n+            if (jdkJlinkResource.equals(e.path())) {\n+                \/\/ override new options if present. The jmod-less plugin might\n+                \/\/ have the resource already in the base image\n+                haveEntry[0] = true;\n+                return jdkJlinkSavedEntry;\n+            } else {\n+                return e;\n+            }\n+        }, out);\n+        if (!haveEntry[0]) {\n+            \/\/ Add the resource if and only if there isn't one already\n+            out.add(jdkJlinkSavedEntry);\n+        }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SaveJlinkArgfilesPlugin.java","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,0 +27,16 @@\n+import static java.lang.constant.ConstantDescs.CD_List;\n+import static java.lang.constant.ConstantDescs.CD_Map;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_Set;\n+import static java.lang.constant.ConstantDescs.CD_String;\n+import static java.lang.constant.ConstantDescs.CD_boolean;\n+import static java.lang.constant.ConstantDescs.CD_byte;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static java.lang.constant.ConstantDescs.MTD_void;\n+import static jdk.internal.classfile.Classfile.ACC_FINAL;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n+import static jdk.internal.classfile.Classfile.ACC_SUPER;\n+\n@@ -33,1 +49,0 @@\n-import static java.lang.constant.ConstantDescs.*;\n@@ -67,0 +82,5 @@\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n@@ -69,1 +89,0 @@\n-import jdk.internal.module.Modules;\n@@ -76,8 +95,1 @@\n-\n-import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n-import jdk.internal.classfile.ClassBuilder;\n-import jdk.internal.classfile.Classfile;\n-import jdk.internal.classfile.TypeKind;\n-import static jdk.internal.classfile.Classfile.*;\n-import jdk.internal.classfile.CodeBuilder;\n-\n+import jdk.internal.module.Modules;\n@@ -170,1 +182,2 @@\n-        \/\/ pass through all other resources\n+        \/\/ pass through all other resources other than SystemModules* and\n+        \/\/ SystemModulesMap classes as we've generated them.\n@@ -172,2 +185,13 @@\n-            .filter(data -> !data.path().endsWith(\"\/module-info.class\")\n-                    && !generated.contains(data.path()))\n+            .filter(data -> {\n+                String path = data.path();\n+                if (path.endsWith(\"\/module-info.class\") || generated.contains(path)) {\n+                    return false;\n+                }\n+                String className = extractClassName(path);\n+                if (className != null &&\n+                        className.startsWith(\n+                                 SYSTEM_MODULES_CLASS_PREFIX)) {\n+                    return false;\n+                }\n+                return true;\n+            })\n@@ -179,0 +203,7 @@\n+    static String extractClassName(String path) {\n+        if (!path.endsWith(\".class\") || !path.startsWith(\"\/java.base\/\")) {\n+            return null; \/\/ not a class or not java.base\n+        }\n+        return path.substring(\"\/java.base\/\".length(), path.length() - 6 \/* .class *\/);\n+    }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":44,"deletions":13,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.io.InputStream;\n@@ -29,0 +28,1 @@\n+import java.io.InputStream;\n@@ -71,1 +71,15 @@\n-        TOP\n+        TOP;\n+\n+        public static Type fromOrdinal(int value) {\n+            Type retval = null;\n+            for (Type v: Type.values()) {\n+                if (v.ordinal() == value) {\n+                    retval = v;\n+                    break;\n+                }\n+            }\n+            if (retval == null) {\n+                throw new IllegalArgumentException(\"Illegal ordinal: \" + value);\n+            }\n+            return retval;\n+        }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/plugin\/ResourcePoolEntry.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -92,0 +92,8 @@\n+main.opt.unlock-run-image=\\\n+\\      --unlock-run-image                Allow for multiple run-image-based links.\\n\\\n+\\                                        Default is to only allow a single link using\\n\\\n+\\                                        the run-image. With this option a run-image\\n\\\n+\\                                        link and a link using packaged modules become\\n\\\n+\\                                        equivalent as it does not add a stamp file to\\n\\\n+\\                                        the module image.\\n\\\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -210,0 +210,8 @@\n+add-run-image-resources.description=\\\n+Add a resource file that is later used for run image-based links\n+\n+add-run-image-resources.usage=\\\n+\\  --add-run-image-resources   Add a resource file, ''\/<module-name>\/runimage_resources'', listing\\n\\\n+\\                              all resource files other than classes\/resources within it. This\\n\\\n+\\                              plugin is required for run-image-based links.\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/plugins.properties","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+        jdk.tools.jlink.internal.plugins.AddRunImageResourcesPlugin,\n","filename":"src\/jdk.jlink\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.nio.ByteOrder;\n@@ -41,2 +40,1 @@\n-import jdk.tools.jlink.internal.Jlink;\n-import jdk.tools.jlink.internal.JlinkTask;\n+\n@@ -44,4 +42,0 @@\n-import jdk.tools.jlink.internal.Platform;\n-import jdk.tools.jlink.plugin.ResourcePool;\n-import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n-import jdk.tools.jlink.plugin.Plugin;\n@@ -49,0 +43,1 @@\n+import jdk.tools.jlink.internal.Jlink;\n@@ -51,0 +46,2 @@\n+import jdk.tools.jlink.internal.JlinkTask;\n+import jdk.tools.jlink.internal.Platform;\n@@ -52,3 +49,3 @@\n-import jdk.tools.jlink.internal.plugins.DefaultCompressPlugin;\n-import jdk.tools.jlink.internal.plugins.DefaultStripDebugPlugin;\n-\n+import jdk.tools.jlink.plugin.Plugin;\n+import jdk.tools.jlink.plugin.ResourcePool;\n+import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n@@ -169,1 +166,1 @@\n-                JlinkTask.newModuleFinder(modulePaths, limits, mods));\n+                JlinkTask.newModuleFinder(modulePaths, limits, mods, true), true, true);\n","filename":"test\/jdk\/tools\/jlink\/IntegrationTest.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,484 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Scanner;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import tests.Helper;\n+import tests.JImageGenerator;\n+import tests.JImageGenerator.JLinkTask;\n+import tests.JImageValidator;\n+\n+public abstract class AbstractJmodLessTest {\n+\n+    protected static final boolean DEBUG = true;\n+\n+    public void run() throws Exception {\n+        Helper helper = Helper.newHelper();\n+        if (helper == null) {\n+            System.err.println(\"Test not run\");\n+            return;\n+        }\n+        runTest(helper);\n+        System.out.println(getClass().getSimpleName() + \" PASSED!\");\n+    }\n+\n+    \/** main test entrypoint **\/\n+    abstract void runTest(Helper helper) throws Exception;\n+\n+    \/**\n+     * Ensure 'java --list-modules' lists the correct set of modules in the given\n+     * image.\n+     *\n+     * @param jlinkImage\n+     * @param expectedModules\n+     *\/\n+    protected void verifyListModules(Path image,\n+            List<String> expectedModules) throws Exception {\n+        OutputAnalyzer out = runJavaCmd(image, List.of(\"--list-modules\"));\n+        List<String> actual = parseListMods(out.getStdout());\n+        Collections.sort(actual);\n+        if (!expectedModules.equals(actual)) {\n+            throw new AssertionError(\"Different modules! Expected \" + expectedModules + \" got: \" + actual);\n+        }\n+    }\n+\n+    protected OutputAnalyzer runJavaCmd(Path image, List<String> options) throws Exception {\n+        Path targetJava = image.resolve(\"bin\").resolve(getJava());\n+        List<String> cmd = new ArrayList<>();\n+        cmd.add(targetJava.toString());\n+        for (String opt: options) {\n+            cmd.add(opt);\n+        }\n+        List<String> javaCmd = Collections.unmodifiableList(cmd);\n+        OutputAnalyzer out;\n+        try {\n+            out = ProcessTools.executeCommand(javaCmd.toArray(new String[0]));\n+        } catch (Throwable e) {\n+            throw new Exception(\"Process failed to execute\", e);\n+        }\n+        if (out.getExitValue() != 0) {\n+            if (DEBUG) {\n+                System.err.println(\"Process stdout was: \");\n+                System.err.println(out.getStdout());\n+                System.err.println(\"Process stderr was: \");\n+                System.err.println(out.getStderr());\n+            }\n+            throw new AssertionError(\"'\" + javaCmd.stream().collect(Collectors.joining(\" \")) + \"'\"\n+                    + \" expected to succeed!\");\n+        }\n+        return out;\n+    }\n+\n+    protected Path createJavaImageJmodLess(BaseJlinkSpec baseSpec) throws Exception {\n+        \/\/ create a base image only containing the jdk.jlink module and its transitive closure\n+        Path jlinkJmodlessImage = createBaseJlinkImage(baseSpec);\n+\n+        \/\/ On Windows jvm.dll is in 'bin' after the jlink\n+        Path libjvm = Path.of((isWindows() ? \"bin\" : \"lib\"), \"server\", System.mapLibraryName(\"jvm\"));\n+        JlinkSpecBuilder builder = new JlinkSpecBuilder();\n+        \/\/ And expect libjvm (not part of the jimage) to be present in the resulting image\n+        builder.expectedFile(libjvm.toString())\n+               .helper(baseSpec.getHelper())\n+               .name(baseSpec.getName())\n+               .validatingModule(baseSpec.getValidatingModule())\n+               .imagePath(jlinkJmodlessImage)\n+               .expectedLocation(\"\/java.base\/java\/lang\/String.class\");\n+        for (String m: baseSpec.getModules()) {\n+            builder.addModule(m);\n+        }\n+        for (String extra: baseSpec.getExtraOptions()) {\n+            builder.extraJlinkOpt(extra);\n+        }\n+        return jlinkUsingImage(builder.build());\n+    }\n+\n+    protected Path jlinkUsingImage(JlinkSpec spec) throws Exception {\n+        return jlinkUsingImage(spec, new NoopOutputAnalyzerHandler());\n+    }\n+\n+    protected Path jlinkUsingImage(JlinkSpec spec, OutputAnalyzerHandler handler) throws Exception {\n+        return jlinkUsingImage(spec, handler, new DefaultSuccessExitPredicate());\n+    }\n+\n+    protected Path jlinkUsingImage(JlinkSpec spec, OutputAnalyzerHandler handler, Predicate<OutputAnalyzer> exitChecker) throws Exception {\n+        String jmodLessGeneratedImage = \"target-jmodless-\" + spec.getName();\n+        Path targetImageDir = spec.getHelper().createNewImageDir(jmodLessGeneratedImage);\n+        Path targetJlink = spec.getImageToUse().resolve(\"bin\").resolve(getJlink());\n+        String[] jlinkCmdArray = new String[] {\n+                targetJlink.toString(),\n+                \"--output\", targetImageDir.toString(),\n+                \"--verbose\",\n+                \"--add-modules\", spec.getModules().stream().collect(Collectors.joining(\",\"))\n+        };\n+        List<String> jlinkCmd = new ArrayList<>();\n+        jlinkCmd.addAll(Arrays.asList(jlinkCmdArray));\n+        if (spec.getExtraJlinkOpts() != null && !spec.getExtraJlinkOpts().isEmpty()) {\n+            jlinkCmd.addAll(spec.getExtraJlinkOpts());\n+        }\n+        jlinkCmd = Collections.unmodifiableList(jlinkCmd); \/\/ freeze\n+        System.out.println(\"DEBUG: jmod-less jlink command: \" + jlinkCmd.stream().collect(\n+                                                    Collectors.joining(\" \")));\n+        OutputAnalyzer analyzer = null;\n+        try {\n+            analyzer = ProcessTools.executeProcess(jlinkCmd.toArray(new String[0]));\n+        } catch (Throwable t) {\n+            throw new AssertionError(\"Executing process failed!\", t);\n+        }\n+        if (!exitChecker.test(analyzer)) {\n+            if (DEBUG) {\n+                System.err.println(\"Process stdout was: \");\n+                System.err.println(analyzer.getStdout());\n+                System.err.println(\"Process stderr was: \");\n+                System.err.println(analyzer.getStderr());\n+            }\n+            \/\/ if the exit checker failed, we expected the other outcome\n+            \/\/ i.e. fail for success and success for fail.\n+            boolean successExit = analyzer.getExitValue() == 0;\n+            String msg = String.format(\"Expected jlink to %s given a jmodless image. Exit code was: %d\",\n+                                       (successExit ? \"fail\" : \"pass\"), analyzer.getExitValue());\n+            throw new AssertionError(msg);\n+        }\n+        handler.handleAnalyzer(analyzer); \/\/ Give tests a chance to process in\/output\n+\n+        \/\/ validate the resulting image; Includes running 'java -version', only do this\n+        \/\/ if the jlink succeeded.\n+        if (analyzer.getExitValue() == 0) {\n+            JImageValidator validator = new JImageValidator(spec.getValidatingModule(), spec.getExpectedLocations(),\n+                    targetImageDir.toFile(), spec.getUnexpectedLocations(), Collections.emptyList(), spec.getExpectedFiles());\n+            validator.validate(); \/\/ This doesn't validate locations\n+            if (!spec.getExpectedLocations().isEmpty() || !spec.getUnexpectedLocations().isEmpty()) {\n+                JImageValidator.validate(targetImageDir.resolve(\"lib\").resolve(\"modules\"), spec.getExpectedLocations(), spec.getUnexpectedLocations());\n+            }\n+        }\n+        return targetImageDir;\n+    }\n+\n+    protected Path createBaseJlinkImage(BaseJlinkSpec baseSpec) throws Exception {\n+        \/\/ Jlink an image including jdk.jlink (i.e. the jlink tool). The\n+        \/\/ result must not contain a jmods directory.\n+        Path jlinkJmodlessImage = baseSpec.getHelper().createNewImageDir(baseSpec.getName() + \"-jlink\");\n+        JLinkTask task = JImageGenerator.getJLinkTask();\n+        if (baseSpec.getModules().contains(\"leaf1\")) {\n+            task.modulePath(baseSpec.getHelper().getJmodDir().toString());\n+        }\n+        task.output(jlinkJmodlessImage);\n+        for (String module: baseSpec.getModules()) {\n+            task.addMods(module);\n+        }\n+        if (!baseSpec.getModules().contains(\"ALL-MODULE-PATH\")) {\n+            task.addMods(\"jdk.jlink\"); \/\/ needed for the recursive jlink\n+        }\n+        for (String opt: baseSpec.getExtraOptions()) {\n+            task.option(opt);\n+        }\n+        task.option(\"--verbose\")\n+            .call().assertSuccess();\n+        \/\/ Verify the base image is actually jmod-less\n+        if (Files.exists(jlinkJmodlessImage.resolve(\"jmods\"))) {\n+            throw new AssertionError(\"Must not contain 'jmods' directory\");\n+        }\n+        return jlinkJmodlessImage;\n+    }\n+\n+    private List<String> parseListMods(String output) throws Exception {\n+        List<String> outputLines = new ArrayList<>();\n+        try (Scanner lineScan = new Scanner(output)) {\n+            while (lineScan.hasNextLine()) {\n+                outputLines.add(lineScan.nextLine());\n+            }\n+        }\n+        return outputLines.stream()\n+                .map(a -> { return a.split(\"@\", 2)[0];})\n+                .filter(a -> !a.isBlank())\n+                .collect(Collectors.toList());\n+    }\n+\n+    private String getJlink() {\n+        return getBinary(\"jlink\");\n+    }\n+\n+    private String getJava() {\n+        return getBinary(\"java\");\n+    }\n+\n+    private String getBinary(String binary) {\n+        return isWindows() ? binary + \".exe\" : binary;\n+    }\n+\n+    protected static boolean isWindows() {\n+        return System.getProperty(\"os.name\").startsWith(\"Windows\");\n+    }\n+\n+    static class BaseJlinkSpec {\n+        final Helper helper;\n+        final String name;\n+        final String validatingModule;\n+        final List<String> modules;\n+        final List<String> extraOptions;\n+\n+        BaseJlinkSpec(Helper helper, String name, String validatingModule,\n+                List<String> modules, List<String> extraOptions) {\n+            this.helper = helper;\n+            this.name = name;\n+            this.modules = modules;\n+            this.extraOptions = extraOptions;\n+            this.validatingModule = validatingModule;\n+        }\n+\n+        public String getValidatingModule() {\n+            return validatingModule;\n+        }\n+\n+        public Helper getHelper() {\n+            return helper;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public List<String> getModules() {\n+            return modules;\n+        }\n+\n+        public List<String> getExtraOptions() {\n+            return extraOptions;\n+        }\n+    }\n+\n+    static class BaseJlinkSpecBuilder {\n+        Helper helper;\n+        String name;\n+        String validatingModule;\n+        List<String> modules = new ArrayList<>();\n+        List<String> extraOptions = new ArrayList<>();\n+\n+        BaseJlinkSpecBuilder addModule(String module) {\n+            modules.add(module);\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder addExtraOption(String option) {\n+            extraOptions.add(option);\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder helper(Helper helper) {\n+            this.helper = helper;\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder name(String name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder validatingModule(String module) {\n+            this.validatingModule = module;\n+            return this;\n+        }\n+\n+        BaseJlinkSpec build() {\n+            if (name == null) {\n+                throw new IllegalStateException(\"Name must be set\");\n+            }\n+            if (helper == null) {\n+                throw new IllegalStateException(\"helper must be set\");\n+            }\n+            if (validatingModule == null) {\n+                throw new IllegalStateException(\"the module which should get validated must be set\");\n+            }\n+            return new BaseJlinkSpec(helper, name, validatingModule, modules, extraOptions);\n+        }\n+    }\n+\n+    static class JlinkSpec {\n+        final Path imageToUse;\n+        final Helper helper;\n+        final String name;\n+        final List<String> modules;\n+        final String validatingModule;\n+        final List<String> expectedLocations;\n+        final List<String> unexpectedLocations;\n+        final String[] expectedFiles;\n+        final List<String> extraJlinkOpts;\n+\n+        JlinkSpec(Path imageToUse, Helper helper, String name, List<String> modules,\n+                String validatingModule, List<String> expectedLocations,\n+                List<String> unexpectedLocations, String[] expectedFiles,\n+                List<String> extraJlinkOpts) {\n+            this.imageToUse = imageToUse;\n+            this.helper = helper;\n+            this.name = name;\n+            this.modules = modules;\n+            this.validatingModule = validatingModule;\n+            this.expectedLocations = expectedLocations;\n+            this.unexpectedLocations = unexpectedLocations;\n+            this.expectedFiles = expectedFiles;\n+            this.extraJlinkOpts = extraJlinkOpts;\n+        }\n+\n+        public Path getImageToUse() {\n+            return imageToUse;\n+        }\n+\n+        public Helper getHelper() {\n+            return helper;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public List<String> getModules() {\n+            return modules;\n+        }\n+\n+        public String getValidatingModule() {\n+            return validatingModule;\n+        }\n+\n+        public List<String> getExpectedLocations() {\n+            return expectedLocations;\n+        }\n+\n+        public List<String> getUnexpectedLocations() {\n+            return unexpectedLocations;\n+        }\n+\n+        public String[] getExpectedFiles() {\n+            return expectedFiles;\n+        }\n+\n+        public List<String> getExtraJlinkOpts() {\n+            return extraJlinkOpts;\n+        }\n+    }\n+\n+    static class JlinkSpecBuilder {\n+        Path imageToUse;\n+        Helper helper;\n+        String name;\n+        List<String> modules = new ArrayList<>();\n+        String validatingModule;\n+        List<String> expectedLocations = new ArrayList<>();\n+        List<String> unexpectedLocations = new ArrayList<>();\n+        List<String> expectedFiles = new ArrayList<>();\n+        List<String> extraJlinkOpts = new ArrayList<>();\n+\n+        JlinkSpec build() {\n+            if (imageToUse == null) {\n+                throw new IllegalStateException(\"No image to use for jlink specified!\");\n+            }\n+            if (helper == null) {\n+                throw new IllegalStateException(\"No helper specified!\");\n+            }\n+            if (name == null) {\n+                throw new IllegalStateException(\"No name for the image location specified!\");\n+            }\n+            if (validatingModule == null) {\n+                throw new IllegalStateException(\"No module specified for after generation validation!\");\n+            }\n+            return new JlinkSpec(imageToUse, helper, name, modules, validatingModule, expectedLocations, unexpectedLocations, expectedFiles.toArray(new String[0]), extraJlinkOpts);\n+        }\n+\n+        JlinkSpecBuilder imagePath(Path image) {\n+            this.imageToUse = image;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder helper(Helper helper) {\n+            this.helper = helper;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder name(String name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder addModule(String module) {\n+            modules.add(module);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder validatingModule(String module) {\n+            this.validatingModule = module;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder expectedLocation(String location) {\n+            expectedLocations.add(location);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder unexpectedLocation(String location) {\n+            unexpectedLocations.add(location);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder expectedFile(String file) {\n+            expectedFiles.add(file);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder extraJlinkOpt(String opt) {\n+            extraJlinkOpts.add(opt);\n+            return this;\n+        }\n+    }\n+\n+    static abstract class OutputAnalyzerHandler {\n+\n+        public abstract void handleAnalyzer(OutputAnalyzer out);\n+\n+    }\n+\n+    static class NoopOutputAnalyzerHandler extends OutputAnalyzerHandler {\n+\n+        @Override\n+        public void handleAnalyzer(OutputAnalyzer out) {\n+            \/\/ nothing\n+        }\n+\n+    }\n+\n+    static class DefaultSuccessExitPredicate implements Predicate<OutputAnalyzer> {\n+\n+        @Override\n+        public boolean test(OutputAnalyzer t) {\n+            return t.getExitValue() == 0;\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/AbstractJmodLessTest.java","additions":484,"deletions":0,"binary":false,"changes":484,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Scanner;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Test --add-options jlink plugin in jmod-less mode\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g AddOptionsTest\n+ *\/\n+public class AddOptionsTest extends AbstractJmodLessTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        AddOptionsTest test = new AddOptionsTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        Path finalImage = createJavaImageJmodLess(new BaseJlinkSpecBuilder()\n+                .addExtraOption(\"--add-options\")\n+                .addExtraOption(\"-Xlog:gc=info:stderr -XX:+UseParallelGC\")\n+                .name(\"java-base-with-opts\")\n+                .addModule(\"java.base\")\n+                .validatingModule(\"java.base\")\n+                .helper(helper)\n+                .build());\n+        verifyListModules(finalImage, List.of(\"java.base\"));\n+        verifyParallelGCInUse(finalImage);\n+    }\n+\n+    private void verifyParallelGCInUse(Path finalImage) throws Exception {\n+        OutputAnalyzer analyzer = runJavaCmd(finalImage, List.of(\"--version\"));\n+        boolean foundMatch = false;\n+        try (Scanner lineScan = new Scanner(analyzer.getStderr())) {\n+            while (lineScan.hasNextLine()) {\n+                String line = lineScan.nextLine();\n+                if (line.endsWith(\"Using Parallel\")) {\n+                    foundMatch = true;\n+                    break;\n+                }\n+            }\n+        }\n+        if (!foundMatch) {\n+            throw new AssertionError(\"Expected Parallel GC in place for jlinked image\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/AddOptionsTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test\n+ * @summary Test basic jmod-less jlinking\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g BasicJlinkTest\n+ *\/\n+public class BasicJlinkTest extends AbstractJmodLessTest {\n+\n+    @Override\n+    public void runTest(Helper helper) throws Exception {\n+        Path finalImage = createJavaBaseJmodLess(helper, \"java-base\");\n+        verifyListModules(finalImage, List.of(\"java.base\"));\n+    }\n+\n+    private Path createJavaBaseJmodLess(Helper helper, String name) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder();\n+        builder.helper(helper)\n+               .name(name)\n+               .addModule(\"java.base\")\n+               .validatingModule(\"java.base\");\n+        return createJavaImageJmodLess(builder.build());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        BasicJlinkTest test = new BasicJlinkTest();\n+        test.run();\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/BasicJlinkTest.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+class CapturingHandler extends AbstractJmodLessTest.OutputAnalyzerHandler {\n+\n+    private OutputAnalyzer output;\n+\n+    public String stdErr() {\n+        return output.getStderr();\n+    }\n+\n+    public OutputAnalyzer analyzer() {\n+        return output;\n+    }\n+\n+    @Override\n+    public void handleAnalyzer(OutputAnalyzer out) {\n+        this.output = out;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/CapturingHandler.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test\n+ * @summary Test jmod-less jlink with a custom module\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g CustomModuleJlinkTest\n+ *\/\n+public class CustomModuleJlinkTest extends AbstractJmodLessTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        CustomModuleJlinkTest test = new CustomModuleJlinkTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        String customModule = \"leaf1\";\n+        helper.generateDefaultJModule(customModule);\n+\n+        \/\/ create a base image including jdk.jlink and the leaf1 module. This will\n+        \/\/ add the leaf1 module's module path.\n+        Path jlinkImage = createBaseJlinkImage(new BaseJlinkSpecBuilder()\n+                                                    .helper(helper)\n+                                                    .name(\"cmod-jlink\")\n+                                                    .addModule(customModule)\n+                                                    .validatingModule(\"java.base\") \/\/ not used\n+                                                    .build());\n+\n+        \/\/ Now that the base image already includes the 'leaf1' module, it should\n+        \/\/ be possible to jlink it again, asking for *only* the 'leaf1' plugin even\n+        \/\/ though we won't have any jmods directories present.\n+        Path finalImage = jlinkUsingImage(new JlinkSpecBuilder()\n+                                                .imagePath(jlinkImage)\n+                                                .helper(helper)\n+                                                .name(customModule)\n+                                                .expectedLocation(String.format(\"\/%s\/%s\/com\/foo\/bar\/X.class\", customModule, customModule))\n+                                                .addModule(customModule)\n+                                                .validatingModule(customModule)\n+                                                .build());\n+        \/\/ Expected only the transitive closure of \"leaf1\" module in the --list-modules\n+        \/\/ output of the java launcher.\n+        List<String> expectedModules = List.of(\"java.base\", customModule);\n+        verifyListModules(finalImage, expectedModules);\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/CustomModuleJlinkTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Test reproducibility of jmod-less jlink of java.se\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g JavaSEReproducibleTest\n+ *\/\n+public class JavaSEReproducibleTest extends AbstractJmodLessTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        JavaSEReproducibleTest test = new JavaSEReproducibleTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        String javaSeModule = \"java.se\";\n+        \/\/ create a java.se using jmod-less approach\n+        Path javaSEJmodLess1 = createJavaImageJmodLess(new BaseJlinkSpecBuilder()\n+                                                                   .helper(helper)\n+                                                                   .name(\"java-se-repro1\")\n+                                                                   .addModule(javaSeModule)\n+                                                                   .validatingModule(javaSeModule)\n+                                                                   .build());\n+\n+        \/\/ create another java.se version using jmod-less approach\n+        Path javaSEJmodLess2 = createJavaImageJmodLess(new BaseJlinkSpecBuilder()\n+                                                                   .helper(helper)\n+                                                                   .name(\"java-se-repro2\")\n+                                                                   .addModule(javaSeModule)\n+                                                                   .validatingModule(javaSeModule)\n+                                                                   .build());\n+        if (Files.mismatch(javaSEJmodLess1.resolve(\"lib\").resolve(\"modules\"),\n+                           javaSEJmodLess2.resolve(\"lib\").resolve(\"modules\")) != -1L) {\n+            throw new RuntimeException(\"jlink producing inconsistent result for \" + javaSeModule + \" (jmod-less)\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/JavaSEReproducibleTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Verify jlink fails by default when jlinking in jmod-less mode and files have been changed\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g ModifiedFilesExitTest\n+ *\/\n+public class ModifiedFilesExitTest extends ModifiedFilesTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        ModifiedFilesExitTest test = new ModifiedFilesExitTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    String initialImageName() {\n+        return \"java-base-jlink-with-mod-exit\";\n+    }\n+\n+    @Override\n+    void testAndAssert(Path modifiedFile, Helper helper, Path initialImage)\n+            throws Exception {\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer t) {\n+                return t.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(initialImage)\n+                                .name(\"java-base-jlink-with-mod-exit-target\")\n+                                .addModule(\"java.base\")\n+                                .validatingModule(\"java.base\")\n+                                .build(), handler, exitFailPred);\n+        if (handler.analyzer().getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to fail due to modified file!\");\n+        }\n+        handler.analyzer().stdoutShouldContain(modifiedFile.toString() + \" has been modified\");\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesExitTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Properties;\n+\n+import tests.Helper;\n+\n+public abstract class ModifiedFilesTest extends AbstractJmodLessTest {\n+\n+    abstract String initialImageName();\n+    abstract void testAndAssert(Path modifiedFile, Helper helper, Path initialImage) throws Exception;\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        Path initialImage = createJavaImageJmodLess(new BaseJlinkSpecBuilder()\n+                \/\/.name(\"java-base-jlink-with-mod\")\n+                .name(initialImageName())\n+                .addModule(\"java.base\")\n+                .addModule(\"jdk.jlink\")\n+                .validatingModule(\"java.base\")\n+                .addExtraOption(\"--unlock-run-image\")\n+                .helper(helper)\n+                .build());\n+\n+        Path netPropertiesFile = modifyFileInImage(initialImage);\n+\n+        testAndAssert(netPropertiesFile, helper, initialImage);\n+    }\n+\n+    protected Path modifyFileInImage(Path jmodLessImg)\n+            throws IOException, AssertionError {\n+        \/\/ modify net.properties config file\n+        Path netPropertiesFile = jmodLessImg.resolve(\"conf\").resolve(\"net.properties\");\n+        Properties props = new Properties();\n+        try (InputStream is = Files.newInputStream(netPropertiesFile)) {\n+            props.load(is);\n+        }\n+        String prevVal = (String)props.put(\"java.net.useSystemProxies\", Boolean.TRUE.toString());\n+        if (prevVal == null || Boolean.getBoolean(prevVal) != false) {\n+            throw new AssertionError(\"Expected previous value to be false!\");\n+        }\n+        try (OutputStream out = Files.newOutputStream(netPropertiesFile)) {\n+            props.store(out, \"Modified net.properties file!\");\n+        }\n+        return netPropertiesFile;\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Scanner;\n+\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Verify warnings are being produced when jlinking in jmod-less mode and files have been changed\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g ModifiedFilesWarningTest\n+ *\/\n+public class ModifiedFilesWarningTest extends ModifiedFilesTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        ModifiedFilesWarningTest test = new ModifiedFilesWarningTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    String initialImageName() {\n+        return \"java-base-jlink-with-mod-warn\";\n+    }\n+\n+    @Override\n+    void testAndAssert(Path modifiedFile, Helper helper, Path initialImage) throws Exception {\n+        CapturingHandler handler = new CapturingHandler();\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(initialImage)\n+                                .name(\"java-base-jlink-with-mod-warn-target\")\n+                                .addModule(\"java.base\")\n+                                .validatingModule(\"java.base\")\n+                                .extraJlinkOpt(\"--unlock-run-image\") \/\/ only generate a warning\n+                                .build(), handler);\n+        \/\/ verify we get the warning message\n+        expectMatch(modifiedFile.toString(), handler.stdErr());\n+        expectMatch(\"WARNING: \", handler.stdErr());\n+        expectMatch(\"has been modified\", handler.stdErr());\n+    }\n+\n+    private static void expectMatch(String string, String lines) {\n+        boolean foundMatch = false;\n+        try (Scanner lineScan = new Scanner(lines)) {\n+            String line;\n+            while (lineScan.hasNextLine()) {\n+                line = lineScan.nextLine();\n+                if (line.contains(string)) {\n+                    foundMatch = true;\n+                    break;\n+                }\n+            }\n+        }\n+        if (!foundMatch) {\n+            throw new AssertionError(String.format(\"Expected to find '%s' in '%s'\", string, lines));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesWarningTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Verify that a jlink unsing the run-image only is single-hop only\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g MultiHopTest\n+ *\/\n+public class MultiHopTest extends AbstractJmodLessTest {\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        Path jdkJlinkJmodless = createJDKJlinkJmodLess(helper, \"jdk.jlink-multi-hop1\");\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer a) {\n+                return a.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(jdkJlinkJmodless)\n+                                .name(\"jdk-jlink-multi-hop1-target\")\n+                                .addModule(\"java.base\")\n+                                .validatingModule(\"java.base\")\n+                                .build(), handler, exitFailPred);\n+        if (handler.analyzer().getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to fail due to multi-hop (hop 2)\");\n+        }\n+        handler.analyzer().stdoutShouldContain(\"Recursive links based on the current run-image are not allowed.\");\n+    }\n+\n+    private Path createJDKJlinkJmodLess(Helper helper, String name) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder();\n+        builder.helper(helper)\n+               .name(name)\n+               .addModule(\"jdk.jlink\")\n+               .validatingModule(\"java.base\");\n+        return createJavaImageJmodLess(builder.build());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        MultiHopTest test = new MultiHopTest();\n+        test.run();\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/MultiHopTest.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import tests.Helper;\n+import tests.JImageGenerator;\n+import tests.JImageHelper;\n+\n+\/*\n+ * @test\n+ * @summary Compare packaged-modules jlink with a jmod-less jlink to produce the same result\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g PackagedModulesVsJmodLessTest\n+ *\/\n+public class PackagedModulesVsJmodLessTest extends AbstractJmodLessTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        PackagedModulesVsJmodLessTest test = new PackagedModulesVsJmodLessTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        \/\/ create a java.se using jmod-less approach\n+        Path javaSEJmodLess = createJavaImageJmodLess(new BaseJlinkSpecBuilder()\n+                                                            .helper(helper)\n+                                                            .name(\"java-se-jmodless\")\n+                                                            .addModule(\"java.se\")\n+                                                            .validatingModule(\"java.se\")\n+                                                            .addExtraOption(\"--unlock-run-image\")\n+                                                            .build());\n+\n+        \/\/ create a java.se using packaged modules (jmod-full)\n+        Path javaSEJmodFull = JImageGenerator.getJLinkTask()\n+                .output(helper.createNewImageDir(\"java-se-jmodfull\"))\n+                .addMods(\"java.se\").call().assertSuccess();\n+\n+        compareRecursively(javaSEJmodLess, javaSEJmodFull);\n+    }\n+\n+    \/\/ Visit all files in the given directories checking that they're byte-by-byte identical\n+    private static void compareRecursively(Path javaSEJmodLess,\n+            Path javaSEJmodFull) throws IOException, AssertionError {\n+        FilesCapturingVisitor jmodFullVisitor = new FilesCapturingVisitor(javaSEJmodFull);\n+        FilesCapturingVisitor jmodLessVisitor = new FilesCapturingVisitor(javaSEJmodLess);\n+        Files.walkFileTree(javaSEJmodFull, jmodFullVisitor);\n+        Files.walkFileTree(javaSEJmodLess, jmodLessVisitor);\n+        List<String> jmodFullFiles = jmodFullVisitor.filesVisited();\n+        List<String> jmodLessFiles = jmodLessVisitor.filesVisited();\n+        Collections.sort(jmodFullFiles);\n+        Collections.sort(jmodLessFiles);\n+\n+        if (jmodFullFiles.size() != jmodLessFiles.size()) {\n+            throw new AssertionError(String.format(\"Size of files different for jmod-less (%d) vs jmod-full (%d) java.se jlink\", jmodLessFiles.size(), jmodFullFiles.size()));\n+        }\n+        String jimageFile = Path.of(\"lib\").resolve(\"modules\").toString();\n+        \/\/ Compare all files except the modules image\n+        for (int i = 0; i < jmodFullFiles.size(); i++) {\n+            String jmodFullPath = jmodFullFiles.get(i);\n+            String jmodLessPath = jmodLessFiles.get(i);\n+            if (!jmodFullPath.equals(jmodLessPath)) {\n+                throw new AssertionError(String.format(\"jmod-full path (%s) != jmod-less path (%s)\", jmodFullPath, jmodLessPath));\n+            }\n+            if (jmodFullPath.equals(jimageFile)) {\n+                continue;\n+            }\n+            Path a = javaSEJmodFull.resolve(Path.of(jmodFullPath));\n+            Path b = javaSEJmodLess.resolve(Path.of(jmodLessPath));\n+            if (Files.mismatch(a, b) != -1L) {\n+                handleFileMismatch(a, b);\n+            }\n+        }\n+        \/\/ Compare jimage contents by iterating its entries and comparing their\n+        \/\/ paths and content bytes\n+        \/\/\n+        \/\/ Note: The files aren't byte-by-byte comparable (probably due to string hashing\n+        \/\/ and offset differences in container bytes)\n+        Path jimageJmodLess = javaSEJmodLess.resolve(Path.of(\"lib\")).resolve(Path.of(\"modules\"));\n+        Path jimageJmodFull = javaSEJmodFull.resolve(Path.of(\"lib\")).resolve(Path.of(\"modules\"));\n+        List<String> jimageContentJmodLess = JImageHelper.listContents(jimageJmodLess);\n+        List<String> jimageContentJmodFull = JImageHelper.listContents(jimageJmodFull);\n+        if (jimageContentJmodLess.size() != jimageContentJmodFull.size()) {\n+            throw new AssertionError(String.format(\"Size of jimage content differs for jmod-less (%d) v. jmod-full (%d)\", jimageContentJmodLess.size(), jimageContentJmodFull.size()));\n+        }\n+        for (int i = 0; i < jimageContentJmodFull.size(); i++) {\n+            if (!jimageContentJmodFull.get(i).equals(jimageContentJmodLess.get(i))) {\n+                throw new AssertionError(String.format(\"Jimage content differs at index %d: jmod-full was: '%s' jmod-less was: '%s'\",\n+                                                       i,\n+                                                       jimageContentJmodFull.get(i),\n+                                                       jimageContentJmodLess.get(i)\n+                                                       ));\n+            }\n+            String loc = jimageContentJmodFull.get(i);\n+            if (isTreeInfoResource(loc)) {\n+                \/\/ Skip container bytes as those are offsets to the content\n+                \/\/ of the container which might be different between jlink runs.\n+                continue;\n+            }\n+            byte[] resBytesFull = JImageHelper.getLocationBytes(loc, jimageJmodFull);\n+            byte[] resBytesLess = JImageHelper.getLocationBytes(loc, jimageJmodLess);\n+            if (resBytesFull.length != resBytesLess.length || Arrays.mismatch(resBytesFull, resBytesLess) != -1) {\n+                throw new AssertionError(\"Content bytes mismatch for \" + loc);\n+            }\n+        }\n+    }\n+\n+    private static boolean isTreeInfoResource(String path) {\n+        return path.startsWith(\"\/packages\") || path.startsWith(\"\/modules\");\n+    }\n+\n+    private static void handleFileMismatch(Path a, Path b) {\n+        throw new AssertionError(\"Files mismatch: \" + a + \" vs. \" + b);\n+    }\n+\n+    static class FilesCapturingVisitor extends SimpleFileVisitor<Path> {\n+        private final Path basePath;\n+        private final List<String> filePaths = new ArrayList<>();\n+        public FilesCapturingVisitor(Path basePath) {\n+            this.basePath = basePath;\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) {\n+            Path relative = basePath.relativize(path);\n+            filePaths.add(relative.toString());\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        List<String> filesVisited() {\n+            return filePaths;\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/PackagedModulesVsJmodLessTest.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Test --save-jlink-argfiles plugin in jmod-less mode\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g SaveJlinkOptsTest\n+ *\/\n+public class SaveJlinkOptsTest extends AbstractJmodLessTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        SaveJlinkOptsTest test = new SaveJlinkOptsTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        String vendorVersion = \"jmodless\";\n+        Path jlinkOptsFile = createJlinkOptsFile(List.of(\"--compress\", \"zip-6\", \"--vendor-version\", vendorVersion));\n+        Path finalImage = createJavaImageJmodLess(new BaseJlinkSpecBuilder()\n+                                                        .addExtraOption(\"--save-jlink-argfiles\")\n+                                                        .addExtraOption(jlinkOptsFile.toAbsolutePath().toString())\n+                                                        .addModule(\"jdk.jlink\")\n+                                                        .name(\"java-base-with-jlink-opts\")\n+                                                        .helper(helper)\n+                                                        .validatingModule(\"java.base\")\n+                                                        .build());\n+        verifyVendorVersion(finalImage, vendorVersion);\n+    }\n+\n+    \/**\n+     * Create a temporary file for use via --save-jlink-argfiles-file\n+     * @param options The options to save in the file.\n+     * @return The path to the temporary file\n+     *\/\n+    private static Path createJlinkOptsFile(List<String> options) throws Exception {\n+        Path tmpFile = Files.createTempFile(\"JLinkTestJmodsLess\", \"jlink-options-file\");\n+        tmpFile.toFile().deleteOnExit();\n+        String content = options.stream().collect(Collectors.joining(\"\\n\"));\n+        Files.writeString(tmpFile, content, StandardOpenOption.TRUNCATE_EXISTING);\n+        return tmpFile;\n+    }\n+\n+    private void verifyVendorVersion(Path finalImage, String vendorVersion) throws Exception {\n+        OutputAnalyzer out = runJavaCmd(finalImage, List.of(\"--version\"));\n+        String stdOut = out.getStdout();\n+        if (!stdOut.contains(vendorVersion)) {\n+            if (DEBUG) {\n+                System.err.println(stdOut);\n+            }\n+            throw new AssertionError(\"Expected vendor version '\" + vendorVersion + \"' in jlinked image.\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/SaveJlinkOptsTest.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import tests.Helper;\n+import tests.JImageValidator;\n+\n+\/*\n+ * @test\n+ * @summary Test appropriate handling of generated SystemModules* classes in jmod-less mode\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g SystemModulesTest\n+ *\/\n+public class SystemModulesTest extends AbstractJmodLessTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        SystemModulesTest test = new SystemModulesTest();\n+        test.run();\n+    }\n+\n+    \/*\n+     * SystemModule classes are module specific. If the jlink is based on the\n+     * modules image, then earlier generated SystemModule classes shall not get\n+     * propagated.\n+     *\/\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        \/\/ create an image with a module containing a main entrypoint (jdk.httpserver),\n+        \/\/ thus producing the SystemModules$0.class. Add jdk.jdwp.agent as a module which\n+        \/\/ isn't resolved by default, so as to generate SystemModules$default.class\n+        Path javaseJmodless = createJavaImageJmodLess(new BaseJlinkSpecBuilder()\n+                                                            .helper(helper)\n+                                                            .name(\"httpserver-jlink-jmodless-derived\")\n+                                                            .addModule(\"jdk.httpserver\")\n+                                                            .addModule(\"jdk.jdwp.agent\")\n+                                                            .addModule(\"jdk.jlink\")\n+                                                            .validatingModule(\"java.base\")\n+                                                            .addExtraOption(\"--unlock-run-image\")\n+                                                            .build());\n+        \/\/ Verify that SystemModules$0.class etc. are there\n+        JImageValidator.validate(javaseJmodless.resolve(\"lib\").resolve(\"modules\"),\n+                                    List.of(\"\/java.base\/jdk\/internal\/module\/SystemModules$default.class\",\n+                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$0.class\"), Collections.emptyList());\n+        \/\/ Finally attempt another jmodless link reducing modules to java.base only,\n+        \/\/ no longer expecting SystemModules$0.class\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(javaseJmodless)\n+                                .name(\"java.base-from-jdk-httpserver-derived\")\n+                                .addModule(\"java.base\")\n+                                .expectedLocation(\"\/java.base\/jdk\/internal\/module\/SystemModulesMap.class\")\n+                                .expectedLocation(\"\/java.base\/jdk\/internal\/module\/SystemModules.class\")\n+                                .expectedLocation(\"\/java.base\/jdk\/internal\/module\/SystemModules$all.class\")\n+                                .unexpectedLocation(\"\/java.base\/jdk\/internal\/module\/SystemModules$0.class\")\n+                                .unexpectedLocation(\"\/java.base\/jdk\/internal\/module\/SystemModules$default.class\")\n+                                .validatingModule(\"java.base\")\n+                                .build());\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/SystemModulesTest.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -32,0 +32,3 @@\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n@@ -37,3 +40,0 @@\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.Test;\n-\n@@ -116,0 +116,12 @@\n+    @Test\n+    public static void basicJlinkJavaBase() throws IOException {\n+        Result result = JImageGenerator.getJLinkTask()\n+                .modulePath(helper.defaultModulePath())\n+                .output(helper.createNewImageDir(\"java-base-basic\"))\n+                .addMods(\"java.base\")\n+                .call();\n+\n+        Path image = result.assertSuccess();\n+        validateJLISpeciesClasses(image);\n+    }\n+\n@@ -138,0 +150,20 @@\n+    private static void validateJLISpeciesClasses(Path image) throws IOException {\n+        JImageValidator.validate(image.resolve(\"lib\").resolve(\"modules\"),\n+                List.of(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_D.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_DL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_I.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_IL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LJ.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLJ.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLJ.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLLL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLLL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLLLL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLLLLL.class\"),\n+                List.of());\n+    }\n+\n","filename":"test\/jdk\/tools\/jlink\/plugins\/GenerateJLIClassesPluginTest.java","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package tests;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import jdk.internal.jimage.BasicImageReader;\n+import jdk.internal.jimage.ImageLocation;\n+\n+\/**\n+ *\n+ * JDK Modular image iterator\n+ *\/\n+public class JImageHelper {\n+\n+    private JImageHelper() {\n+        \/\/ Don't instantiate\n+    }\n+\n+    public static List<String> listContents(Path jimage) throws IOException {\n+        try(BasicImageReader reader = BasicImageReader.open(jimage)) {\n+            List<String> entries = new ArrayList<>();\n+            for (String s : reader.getEntryNames()) {\n+                entries.add(s);\n+            }\n+            Collections.sort(entries);\n+            return entries;\n+        }\n+    }\n+\n+    public static byte[] getLocationBytes(String location, Path jimage) throws IOException {\n+        try(BasicImageReader reader = BasicImageReader.open(jimage)) {\n+            ImageLocation il = reader.findLocation(location);\n+            byte[] r = reader.getResource(il);\n+            if (r == null) {\n+                throw new IllegalStateException(String.format(\"bytes for %s not found!\", location));\n+            }\n+            return r;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/lib\/tests\/JImageHelper.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"}]}