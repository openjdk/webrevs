{"files":[{"patch":"@@ -169,0 +169,3 @@\n+        } catch (RuntimeImageLinkException e) {\n+            \/\/ Propagate reason for run-time image based links\n+            throw e.getReason();\n@@ -190,0 +193,7 @@\n+        } catch (RuntimeImageLinkException re) {\n+            \/\/ might be thrown in the run-image link case. Populate the\n+            \/\/ actual reason.\n+            if (JlinkTask.DEBUG) {\n+                re.printStackTrace();\n+            }\n+            throw re.getReason();\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageFileCreator.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -66,0 +66,5 @@\n+    public static ImagePluginStack parseConfiguration(Jlink.PluginsConfiguration pluginsConfiguration)\n+            throws Exception {\n+        return parseConfiguration(pluginsConfiguration, null);\n+    }\n+\n@@ -69,1 +74,1 @@\n-    public static ImagePluginStack parseConfiguration(Jlink.PluginsConfiguration pluginsConfiguration)\n+    public static ImagePluginStack parseConfiguration(Jlink.PluginsConfiguration pluginsConfiguration, List<String> cli)\n@@ -133,1 +138,1 @@\n-        return new ImagePluginStack(builder, orderedPlugins, lastSorter);\n+        return new ImagePluginStack(builder, orderedPlugins, lastSorter, cli);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImagePluginConfiguration.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,1 +31,10 @@\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n@@ -165,0 +174,1 @@\n+    private final List<JlinkCLIArgsListener> cliArgsListeners = new ArrayList<>();\n@@ -166,0 +176,1 @@\n+    private final List<String> cliArgs;\n@@ -168,1 +179,1 @@\n-        this(null, Collections.emptyList(), null);\n+        this(null, Collections.emptyList(), null, null);\n@@ -173,2 +184,2 @@\n-            Plugin lastSorter) {\n-        this(imageBuilder, plugins, lastSorter, true);\n+            Plugin lastSorter, List<String> cliArgs) {\n+        this(imageBuilder, plugins, lastSorter, true, cliArgs);\n@@ -180,1 +191,2 @@\n-            boolean validate) {\n+            boolean validate,\n+            List<String> cliArgs) {\n@@ -189,0 +201,3 @@\n+            if (p instanceof JlinkCLIArgsListener) {\n+                cliArgsListeners.add((JlinkCLIArgsListener) p);\n+            }\n@@ -190,0 +205,1 @@\n+        this.cliArgs = cliArgs;\n@@ -229,0 +245,3 @@\n+        cliArgsListeners.forEach((p) -> {\n+            p.process(cliArgs);\n+        });\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImagePluginStack.java","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,349 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReference;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.tools.jlink.plugin.ResourcePoolEntry.Type;\n+\n+\/**\n+ * An archive implementation based on the run-time image (lib\/modules, or jimage)\n+ * and associated files from the filesystem if any (e.g. native libraries).\n+ *\/\n+public class JRTArchive implements Archive {\n+\n+    \/\/ File marker in lib\/modules file for jdk.jlink indicating it got created\n+    \/\/ with a run-time image type link.\n+    public static final String RUNIMAGE_SINGLE_HOP_STAMP = \"jdk\/tools\/jlink\/internal\/runtimeimage.link.stamp\";\n+    private static final String JDK_JLINK_MODULE = \"jdk.jlink\";\n+    private final String module;\n+    private final Path path;\n+    private final ModuleReference ref;\n+    private final List<JRTArchiveFile> files = new ArrayList<>();\n+    private final List<String> otherRes;\n+    private final boolean singleHop;\n+\n+    JRTArchive(String module, Path path, boolean singleHop, List<String> otherRes) {\n+        this.module = module;\n+        this.path = path;\n+        this.ref = ModuleFinder.ofSystem()\n+                    .find(module)\n+                    .orElseThrow(() ->\n+                        new IllegalArgumentException(\"Module \" + module + \" not part of the JDK install\"));\n+        this.singleHop = singleHop;\n+        this.otherRes = otherRes;\n+    }\n+\n+    @Override\n+    public String moduleName() {\n+        return module;\n+    }\n+\n+    @Override\n+    public Path getPath() {\n+        return path;\n+    }\n+\n+    @Override\n+    public Stream<Entry> entries() {\n+        try {\n+            collectFiles();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        } catch (RuntimeImageLinkException e) {\n+            \/\/ populate single-hop issue\n+            throw e.getReason();\n+        }\n+        return files.stream()\n+                    .sorted((a, b) -> {return a.resPath.compareTo(b.resPath);})\n+                    .map(f -> { return f.toEntry();});\n+    }\n+\n+    @Override\n+    public void open() throws IOException {\n+        if (files.isEmpty()) {\n+            collectFiles();\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (!files.isEmpty()) {\n+            files.clear();\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(module, path);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof JRTArchive) {\n+            JRTArchive other = (JRTArchive)obj;\n+            return Objects.equals(module, other.module) &&\n+                   Objects.equals(path, other.path);\n+        }\n+\n+        return false;\n+    }\n+\n+    private void collectFiles() throws IOException {\n+        if (files.isEmpty()) {\n+            addNonClassResources();\n+            \/\/ Add classes\/resources from image module\n+            files.addAll(ref.open().list()\n+                                   .map(s -> {\n+                return new JRTArchiveFile(JRTArchive.this, s,\n+                        Type.CLASS_OR_RESOURCE, null \/* sha *\/, false \/* symlink *\/, singleHop);\n+            }).collect(Collectors.toList()));\n+            \/\/ add\/persist a special, empty file for jdk.jlink so as to support\n+            \/\/ the single-hop-only run-time image jlink\n+            if (singleHop && JDK_JLINK_MODULE.equals(module)) {\n+                files.add(createRuntimeImageSingleHopStamp());\n+            }\n+        }\n+    }\n+\n+    private JRTArchiveFile createRuntimeImageSingleHopStamp() {\n+        return new JRTArchiveStampFile(this, RUNIMAGE_SINGLE_HOP_STAMP, Type.CLASS_OR_RESOURCE, null, false, singleHop);\n+    }\n+\n+    private void addNonClassResources() throws IOException {\n+        \/\/ Not all modules will have other resources like bin, lib, legal etc.\n+        \/\/ files. In that case the list will be empty.\n+        if (!otherRes.isEmpty()) {\n+            files.addAll(otherRes.stream()\n+                    .map(s -> {\n+                        TypePathMapping m = mappingResource(s);\n+                        return new JRTArchiveFile(JRTArchive.this, m.resPath, m.resType, m.sha, m.symlink, singleHop);\n+                    })\n+                    .filter(m -> m != null)\n+                    .collect(Collectors.toList()));\n+        }\n+    }\n+\n+    \/**\n+     *  line: <int>|<int>|<sha>|<path>\n+     *\n+     *  Take the integer before '|' convert it to a Type. The second\n+     *  token is an integer representing symlinks (or not). The third token is\n+     *  a hash sum (sha512) of the file denoted by the fourth token (path).\n+     *\/\n+    private static TypePathMapping mappingResource(String line) {\n+        if (line.isEmpty()) {\n+            return null;\n+        }\n+        String[] tokens = line.split(\"\\\\|\", 4);\n+        Type type = null;\n+        int symlinkNum = -1;\n+        try {\n+            Integer typeInt = Integer.valueOf(tokens[0]);\n+            type = Type.fromOrdinal(typeInt);\n+            symlinkNum = Integer.valueOf(tokens[1]);\n+        } catch (NumberFormatException e) {\n+            throw new AssertionError(e); \/\/ must not happen\n+        }\n+        if (symlinkNum < 0 || symlinkNum > 1) {\n+            throw new IllegalStateException(\"Symlink designator out of range [0,1] got: \" + symlinkNum);\n+        }\n+        boolean isSymlink = symlinkNum > 0;\n+        return new TypePathMapping(tokens[2], tokens[3], type, isSymlink);\n+    }\n+\n+    static class TypePathMapping {\n+        final String resPath;\n+        final String sha;\n+        final Type resType;\n+        final boolean symlink;\n+        TypePathMapping(String sha, String resPath, Type resType, boolean symlink) {\n+            this.resPath = resPath;\n+            this.resType = resType;\n+            this.sha = Objects.requireNonNull(sha);\n+            this.symlink = symlink;\n+        }\n+    }\n+\n+    static class JRTArchiveFile {\n+        private static final String JAVA_HOME = System.getProperty(\"java.home\");\n+        private static final Path BASE = Paths.get(JAVA_HOME);\n+        private static final String MISMATCH_FORMAT = \"%s has been modified.%n\";\n+        final String resPath;\n+        final Archive.Entry.EntryType resType;\n+        final Archive archive;\n+        final String sha; \/\/ Checksum for non-resource files\n+        final boolean symlink;\n+        final boolean failOnMod; \/\/ Only allow non-failure in multi-hop mode\n+\n+        JRTArchiveFile(Archive archive, String resPath, Type resType, String sha, boolean symlink, boolean failOnMod) {\n+            this.resPath = resPath;\n+            this.resType = toEntryType(resType);\n+            this.archive = archive;\n+            this.sha = sha;\n+            this.symlink = symlink;\n+            this.failOnMod = failOnMod;\n+        }\n+\n+        Entry toEntry() {\n+            return new Entry(archive, resPath, resPath, resType) {\n+\n+                private boolean warningProduced = false;\n+\n+                @Override\n+                public long size() {\n+                    try {\n+                        if (resType != Archive.Entry.EntryType.CLASS_OR_RESOURCE) {\n+                            \/\/ Read from the base JDK image, special casing\n+                            \/\/ symlinks, which have the link target in the sha field\n+                            if (symlink) {\n+                                return Files.size(BASE.resolve(sha));\n+                            }\n+                            return Files.size(BASE.resolve(resPath));\n+                        } else {\n+                            \/\/ Read from the module image. This works, because\n+                            \/\/ the underlying base path is a JrtPath with the\n+                            \/\/ JrtFileSystem underneath which is able to handle\n+                            \/\/ this size query\n+                            return Files.size(archive.getPath().resolve(resPath));\n+                        }\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                }\n+\n+                @Override\n+                public InputStream stream() throws IOException {\n+                    if (resType != Archive.Entry.EntryType.CLASS_OR_RESOURCE) {\n+                        \/\/ Read from the base JDK image.\n+                        Path path = BASE.resolve(resPath);\n+                        if (shaSumMismatch(path, sha, symlink)) {\n+                            if (failOnMod) {\n+                                String msg = String.format(MISMATCH_FORMAT, path.toString());\n+                                IllegalArgumentException ise = new IllegalArgumentException(msg);\n+                                throw new RuntimeImageLinkException(ise);\n+                            } else if (!warningProduced) {\n+                                String msg = String.format(MISMATCH_FORMAT, path.toString());\n+                                System.err.printf(\"WARNING: %s\", msg);\n+                                warningProduced = true;\n+                            }\n+                        }\n+                        if (symlink) {\n+                            path = BASE.resolve(sha);\n+                            return Files.newInputStream(path);\n+                        }\n+                        return Files.newInputStream(path);\n+                    } else {\n+                        \/\/ Read from the module image.\n+                        String module = archive.moduleName();\n+                        ModuleReference mRef = ModuleFinder.ofSystem().find(module).orElseThrow();\n+                        return mRef.open().open(resPath).orElseThrow();\n+                    }\n+                }\n+\n+                static boolean shaSumMismatch(Path res, String expectedSha, boolean isSymlink) {\n+                    if (isSymlink) {\n+                        return false;\n+                    }\n+                    \/\/ handle non-symlink resources\n+                    try {\n+                        HexFormat format = HexFormat.of();\n+                        byte[] expected = format.parseHex(expectedSha);\n+                        MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n+                        try (InputStream is = Files.newInputStream(res)) {\n+                            byte[] buf = new byte[1024];\n+                            int readBytes = -1;\n+                            while ((readBytes = is.read(buf)) != -1) {\n+                                digest.update(buf, 0, readBytes);\n+                            }\n+                        }\n+                        byte[] actual = digest.digest();\n+                        return !MessageDigest.isEqual(expected, actual);\n+                    } catch (Exception e) {\n+                        throw new AssertionError(\"SHA-512 sum check failed!\", e);\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        private static Archive.Entry.EntryType toEntryType(Type input) {\n+            return switch(input) {\n+                case CLASS_OR_RESOURCE -> Archive.Entry.EntryType.CLASS_OR_RESOURCE;\n+                case CONFIG -> Archive.Entry.EntryType.CONFIG;\n+                case HEADER_FILE -> Archive.Entry.EntryType.HEADER_FILE;\n+                case LEGAL_NOTICE -> Archive.Entry.EntryType.LEGAL_NOTICE;\n+                case MAN_PAGE -> Archive.Entry.EntryType.MAN_PAGE;\n+                case NATIVE_CMD -> Archive.Entry.EntryType.NATIVE_CMD;\n+                case NATIVE_LIB -> Archive.Entry.EntryType.NATIVE_LIB;\n+                case TOP -> throw new IllegalArgumentException(\"TOP files should be handled by ReleaseInfoPlugin!\");\n+                default -> throw new IllegalArgumentException(\"Unknown type: \" + input);\n+            };\n+        }\n+    }\n+\n+    \/\/ Stamp file marker for single-hop implementation\n+    static class JRTArchiveStampFile extends JRTArchiveFile {\n+        JRTArchiveStampFile(Archive archive, String resPath, Type resType, String sha, boolean symlink, boolean failOnMod) {\n+            super(archive, resPath, resType, sha, symlink, failOnMod);\n+        }\n+\n+        @Override\n+        Entry toEntry() {\n+            return new Entry(archive, resPath, resPath, resType) {\n+\n+                @Override\n+                public long size() {\n+                    \/\/ empty file\n+                    return 0;\n+                }\n+\n+                @Override\n+                public InputStream stream() throws IOException {\n+                    \/\/ empty content\n+                    return new ByteArrayInputStream(new byte[0]);\n+                }\n+\n+            };\n+        }\n+    }\n+\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JRTArchive.java","additions":349,"deletions":0,"binary":false,"changes":349,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import java.nio.ByteOrder;\n@@ -151,0 +150,2 @@\n+        private final boolean useModulePath;\n+        private final boolean singleHop;\n@@ -161,1 +162,3 @@\n-                                  ModuleFinder finder) {\n+                                  ModuleFinder finder,\n+                                  boolean useModulePath,\n+                                  boolean singleHop) {\n@@ -165,0 +168,2 @@\n+            this.useModulePath = useModulePath;\n+            this.singleHop = singleHop;\n@@ -189,0 +194,8 @@\n+        public boolean useModulePath() {\n+            return useModulePath;\n+        }\n+\n+        public boolean singleHop() {\n+            return singleHop;\n+        }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Jlink.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal;\n+\n+import java.util.List;\n+\n+\/**\n+ *\n+ * Plugins wishing to observe the command list that was used to\n+ * trigger the link must implement this interface.\n+ *\n+ *\/\n+public interface JlinkCLIArgsListener {\n+\n+    public void process(List<String> cliArgs);\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkCLIArgsListener.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -27,0 +27,2 @@\n+import static jdk.tools.jlink.internal.TaskHelper.JLINK_BUNDLE;\n+\n@@ -42,1 +44,1 @@\n-import java.nio.file.Files;\n+import java.nio.charset.StandardCharsets;\n@@ -44,0 +46,1 @@\n+import java.nio.file.Files;\n@@ -50,0 +53,1 @@\n+import java.util.Collections;\n@@ -63,0 +67,1 @@\n+import jdk.internal.module.ModulePath;\n@@ -64,2 +69,3 @@\n-import jdk.tools.jlink.internal.TaskHelper.BadArgs;\n-import static jdk.tools.jlink.internal.TaskHelper.JLINK_BUNDLE;\n+import jdk.internal.module.ModuleResolution;\n+import jdk.internal.opt.CommandLine;\n+import jdk.tools.jlink.internal.ImagePluginStack.ImageProvider;\n@@ -68,0 +74,1 @@\n+import jdk.tools.jlink.internal.TaskHelper.BadArgs;\n@@ -70,1 +77,3 @@\n-import jdk.tools.jlink.internal.ImagePluginStack.ImageProvider;\n+import jdk.tools.jlink.internal.plugins.JlinkResourcesListPlugin;\n+import jdk.tools.jlink.internal.plugins.LegalNoticeFilePlugin;\n+import jdk.tools.jlink.plugin.Plugin;\n@@ -72,3 +81,0 @@\n-import jdk.internal.opt.CommandLine;\n-import jdk.internal.module.ModulePath;\n-import jdk.internal.module.ModuleResolution;\n@@ -84,0 +90,4 @@\n+    \/\/ Run time based link internal resources files\n+    private static final String OTHER_RESOURCES_FILE = JlinkResourcesListPlugin.RESPATH_PREFIX +\n+                                                       \"%s\" + JlinkResourcesListPlugin.RESPATH_SUFFIX;\n+    private static final String OLD_CLI_FILE = JlinkResourcesListPlugin.CLI_RESOURCE_FILE;\n@@ -90,0 +100,11 @@\n+    \/\/ Flag for scratch task validation in run-time image mode\n+    private final boolean isScratch;\n+\n+    public JlinkTask() {\n+        this(false);\n+    }\n+\n+    private JlinkTask(boolean isScratch) {\n+        this.isScratch = isScratch;\n+    }\n+\n@@ -172,1 +193,1 @@\n-            if (Files.exists(path)) {\n+            if (!task.isScratch && Files.exists(path)) {\n@@ -185,1 +206,6 @@\n-        }, \"--ignore-signing-information\"),};\n+        }, \"--ignore-signing-information\"),\n+        new Option<JlinkTask>(false, (task, opt, arg) -> {\n+            task.options.runImageSingleHop = false;\n+        }, true, \"--unlock-run-image\"),\n+    };\n+\n@@ -225,0 +251,1 @@\n+        boolean runImageSingleHop = true;\n@@ -273,5 +300,0 @@\n-\n-                if (options.modulePath.isEmpty()) {\n-                    throw taskHelper.newBadArgs(\"err.modulepath.must.be.specified\")\n-                            .showUsage(true);\n-                }\n@@ -280,1 +302,10 @@\n-            JlinkConfiguration config = initJlinkConfig();\n+            \/\/ Currently run-time image based jlinks are only used when\n+            \/\/ the module path is empty. I.e. not specified on the command line\n+            \/\/ and the 'jmods' folder in JAVA_HOME is not present. This restriction\n+            \/\/ is so because cases with an external jimage as run-time image base\n+            \/\/ have not been considered at this point.\n+            boolean useModulePath = !options.modulePath.isEmpty();\n+            if (!useModulePath && options.packagedModulesPath != null) {\n+                throw taskHelper.newBadArgs(\"err.runtime.link.packaged.mods\");\n+            }\n+            JlinkConfiguration config = initJlinkConfig(useModulePath);\n@@ -359,0 +390,1 @@\n+                                    new OptionsValues(),\n@@ -370,1 +402,1 @@\n-    private JlinkConfiguration initJlinkConfig() throws BadArgs {\n+    private JlinkConfiguration initJlinkConfig(boolean useModulePath) throws BadArgs {\n@@ -374,1 +406,1 @@\n-                ModuleFinder finder = newModuleFinder(options.modulePath, options.limitMods, Set.of());\n+                ModuleFinder finder = newModuleFinder(options.modulePath, options.limitMods, Set.of(), useModulePath);\n@@ -386,1 +418,1 @@\n-        ModuleFinder finder = newModuleFinder(options.modulePath, options.limitMods, roots);\n+        ModuleFinder finder = newModuleFinder(options.modulePath, options.limitMods, roots, useModulePath);\n@@ -392,1 +424,1 @@\n-            finder = newModuleFinder(options.modulePath, options.limitMods, roots);\n+            finder = newModuleFinder(options.modulePath, options.limitMods, roots, useModulePath);\n@@ -397,1 +429,3 @@\n-                                      finder);\n+                                      finder,\n+                                      useModulePath,\n+                                      options.runImageSingleHop);\n@@ -416,0 +450,1 @@\n+                                                        options,\n@@ -421,1 +456,1 @@\n-                    imageProvider.targetPlatform));\n+                    imageProvider.targetPlatform, config), getMergedCliArgs(!config.useModulePath()));\n@@ -446,1 +481,2 @@\n-                                               Set<String> roots)\n+                                               Set<String> roots,\n+                                               boolean useModulePath)\n@@ -448,5 +484,0 @@\n-        if (Objects.requireNonNull(paths).isEmpty()) {\n-             throw new IllegalArgumentException(taskHelper.getMessage(\"err.empty.module.path\"));\n-        }\n-\n-        Path[] entries = paths.toArray(new Path[0]);\n@@ -454,2 +485,1 @@\n-        ModuleFinder finder = ModulePath.of(version, true, entries);\n-\n+        ModuleFinder finder = useModulePath ? moduleFinderFromPath(paths, version) : ModuleFinder.ofSystem();\n@@ -484,0 +514,9 @@\n+    private static ModuleFinder moduleFinderFromPath(List<Path> paths, Runtime.Version version) {\n+        if (Objects.requireNonNull(paths).isEmpty()) {\n+            throw new IllegalArgumentException(taskHelper.getMessage(\"err.empty.module.path\"));\n+       }\n+\n+       Path[] entries = paths.toArray(new Path[0]);\n+       return ModulePath.of(version, true, entries);\n+    }\n+\n@@ -521,0 +560,1 @@\n+                                                   OptionsValues opts,\n@@ -537,0 +577,32 @@\n+        \/\/ Perform some setup for run-time image based links\n+        Map<String, List<String>> nonClassRes = Collections.emptyMap();\n+        if (!config.useModulePath()) {\n+            final Map<String, List<String>> nonClassResMap = new HashMap<>();\n+            final Module jdkJlink = JlinkTask.class.getModule();\n+            cf.modules().stream().forEach((a) -> {\n+                collectNonClassResources(a.name(), nonClassResMap, jdkJlink);\n+            });\n+            nonClassRes = nonClassResMap;\n+            \/\/ Print info message when a run-image link is being performed\n+            if (log != null) {\n+                String verboseHint = \" \" + taskHelper.getMessage(\"runtime.link.verbose.hint\");\n+                if (verbose) {\n+                    \/\/ Don't mention the hint if we already use --verbose.\n+                    verboseHint = \"\";\n+                }\n+                log.println(taskHelper.getMessage(\"runtime.link.info\", verboseHint));\n+                if (verbose) {\n+                    logPackagedModuleEquivalent(log, getMergedCliArgs(!config.useModulePath()), opts);\n+                }\n+            }\n+            \/\/ if we use single-hop and we find a stamp file we fail the link\n+            if (config.singleHop()) {\n+                try (InputStream in = jdkJlink.getResourceAsStream(JRTArchive.RUNIMAGE_SINGLE_HOP_STAMP)) {\n+                    if (in != null) {\n+                        String msg = taskHelper.getMessage(\"err.runtime.link.recursive\");\n+                        throw new IllegalArgumentException(msg);\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -541,2 +613,4 @@\n-              .forEach(rm -> log.format(\"%s %s%n\",\n-                                        rm.name(), rm.reference().location().get()));\n+              .forEach(rm -> log.format(\"%s %s%s%n\",\n+                                        rm.name(),\n+                                        rm.reference().location().get(),\n+                                        config.useModulePath() ? \"\" : \" \" + taskHelper.getMessage(\"runtime.link.jprt.path.extra\")));\n@@ -583,1 +657,129 @@\n-        return new ImageHelper(cf, mods, targetPlatform, retainModulesPath, ignoreSigning);\n+        return new ImageHelper(cf, mods, targetPlatform, retainModulesPath,\n+                               ignoreSigning, config.useModulePath(),\n+                               config.singleHop(), nonClassRes);\n+    }\n+\n+    \/**\n+     * Log a message when a run-time image link is being performed and mention\n+     * the equivalent packaged-module based link.\n+     *\n+     * @param logWriter\n+     *            The log to print to.\n+     * @param mergedCLI\n+     *            The merged command line parameters of the persisted link of\n+     *            the run-time image being used and the current command line\n+     *            arguments.\n+     * @param inputCommand\n+     *            The jlink CLI args used for the current link run.\n+     * @param opts\n+     *            The parsed options of the current command line arguments.\n+     *\/\n+    private static void logPackagedModuleEquivalent(PrintWriter logWriter,\n+            List<String> mergedCLI, OptionsValues opts) {\n+        \/\/ parse options, produce plugins maps.\n+        TaskHelper scratchTaskHelper = new TaskHelper(JLINK_BUNDLE);\n+        OptionsHelper<JlinkTask> scratchOptionsHelper = scratchTaskHelper.newOptionsHelper(JlinkTask.class, recognizedOptions);\n+        JlinkTask scratch = new JlinkTask(true);\n+\n+        Map<Plugin, List<Map<String, String>>> pluginMaps = null;\n+        try {\n+            scratchOptionsHelper.handleOptions(scratch, mergedCLI.toArray(new String[] {}));\n+            pluginMaps = scratchTaskHelper.getPluginMaps();\n+        } catch (BadArgs e) {\n+            throw new AssertionError(\"handling of scratch options failed\", e);\n+        }\n+        List<Plugin> forwardingPlugins = pluginMaps.keySet()\n+                                                        .stream()\n+                                                        .filter(p -> p.runTimeImageLinkPersistent())\n+                                                        .toList();\n+        List<String> jlinkCmd = new ArrayList<>();\n+        jlinkCmd.add(\"jlink\");\n+        \/\/ Iterate over recognized opts to figure out options used\n+        if (opts.bindServices) {\n+            jlinkCmd.add(\"--bind-services\");\n+        }\n+        if (opts.suggestProviders) {\n+            jlinkCmd.add(\"--suggest-providers\");\n+        }\n+        if (opts.ignoreSigning) {\n+            jlinkCmd.add(\"--ignore-signing\");\n+        }\n+        \/\/ --add-modules is a required option, but the JLink API calls this with\n+        \/\/ dummy options\n+        if (!opts.addMods.isEmpty()) {\n+            jlinkCmd.add(\"--add-modules\");\n+            jlinkCmd.add(opts.addMods.stream().collect(Collectors.joining(\",\")));\n+        }\n+        if (!opts.limitMods.isEmpty()) {\n+            jlinkCmd.add(\"--limit-modules\");\n+            jlinkCmd.add(opts.limitMods.stream().collect(Collectors.joining(\",\")));\n+        }\n+        \/\/ Launchers carry forward, so we need to use the scratch JlinkTask\n+        if (!scratch.options.launchers.isEmpty()) {\n+            for (Map.Entry<String, String> entry: scratch.options.launchers.entrySet()) {\n+                jlinkCmd.add(\"--launcher\");\n+                jlinkCmd.add(entry.getKey() + \"=\" + entry.getValue());\n+            }\n+        }\n+        String outputPath = \"\";\n+        if (opts.output != null) {\n+            outputPath = opts.output.toString();\n+            jlinkCmd.add(\"--output\");\n+            jlinkCmd.add(outputPath);\n+        }\n+        logWriter.println(taskHelper.getMessage(\"runtime.link.equivalent.packaged.modules\", outputPath));\n+        logWriter.print(\"    \");\n+        logWriter.print(jlinkCmd.stream().collect(Collectors.joining(\" \")));\n+        for (Plugin p: forwardingPlugins) {\n+            List<Map<String, String>> configs = pluginMaps.get(p);\n+            for (Map<String, String> config: configs) {\n+                String value = config.get(p.getName());\n+                \/\/ Work-around for --dedup-legal-notices which auto-enables,\n+                \/\/ carries forward and doesn't allow to be run without argument\n+                \/\/ value from the CLI.\n+                if (p instanceof LegalNoticeFilePlugin && value == null) {\n+                    continue;\n+                }\n+                logWriter.print(\" --\" + p.getName());\n+                if (value != null) {\n+                    logWriter.print(\" \" + value);\n+                }\n+            }\n+        }\n+        logWriter.println();\n+    }\n+\n+    private static List<String> getMergedCliArgs(boolean isRunTimeImageLink) throws IOException {\n+        \/\/ First read in the stored CLI args that were used for the input\n+        \/\/ run-time image\n+        List<String> merged = new ArrayList<>();\n+        if (isRunTimeImageLink) {\n+            try (InputStream in = JlinkTask.class.getModule().getResourceAsStream(OLD_CLI_FILE)) {\n+                CommandLine.loadCmdFile(Objects.requireNonNull(in, \"Old CLI args not being tracked in jimage\"),\n+                                merged);\n+            }\n+        }\n+        for (String arg: optionsHelper.getInputCommand()) {\n+            merged.add(arg);\n+        }\n+        return Collections.unmodifiableList(merged);\n+    }\n+\n+    private static void collectNonClassResources(String modName,\n+                                                 Map<String, List<String>> nonResEntries,\n+                                                 Module jdkJlink) {\n+        String resName = String.format(OTHER_RESOURCES_FILE, modName);\n+        try {\n+            InputStream inStream = jdkJlink.getResourceAsStream(resName);\n+            try (inStream) {\n+                String input = new String(inStream.readAllBytes(), StandardCharsets.UTF_8);\n+                if (input.isEmpty()) {\n+                    \/\/ Not all modules have non-class resources\n+                    nonResEntries.put(modName, Collections.emptyList());\n+                } else {\n+                    nonResEntries.put(modName, Arrays.asList(input.split(\"\\n\")));\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new InternalError(\"Failed to process run-time image resources for \" + modName);\n+        }\n@@ -854,0 +1056,2 @@\n+        final boolean singleHop;\n+        final Map<String, List<String>> nonClassRes;\n@@ -859,1 +1063,4 @@\n-                    boolean ignoreSigning) throws IOException {\n+                    boolean ignoreSigning,\n+                    boolean useModulePath,\n+                    boolean singleHop,\n+                    Map<String, List<String>> nonClassRes) throws IOException {\n@@ -864,0 +1071,2 @@\n+            this.singleHop = singleHop;\n+            this.nonClassRes = nonClassRes;\n@@ -876,1 +1085,1 @@\n-                                .map(e -> newArchive(e.getKey(), e.getValue()))\n+                                .map(e -> newArchive(e.getKey(), e.getValue(), useModulePath, this.nonClassRes.get(e.getKey())))\n@@ -880,1 +1089,1 @@\n-        private Archive newArchive(String module, Path path) {\n+        private Archive newArchive(String module, Path path, boolean useModulePath, List<String> nonClassRes) {\n@@ -909,1 +1118,1 @@\n-            } else if (Files.isDirectory(path)) {\n+            } else if (useModulePath && Files.isDirectory(path)) {\n@@ -917,0 +1126,3 @@\n+            } else if (ModuleFinder.ofSystem().find(module).isPresent()){\n+                \/\/ the path is a JRTPath, when using the run-time image for linking\n+                return new JRTArchive(module, path, singleHop, Objects.requireNonNull(nonClassRes));\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":248,"deletions":36,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal;\n+\n+\/**\n+ * Exception thrown for links without packaged modules. I.e. run-image link.\n+ *\n+ *\/\n+public class RuntimeImageLinkException extends IllegalStateException {\n+\n+    private static final long serialVersionUID = -1848914673073119403L;\n+\n+    private final IllegalArgumentException iae;\n+\n+    public RuntimeImageLinkException(IllegalArgumentException cause) {\n+        super(cause);\n+        this.iae = cause;\n+    }\n+\n+    public IllegalArgumentException getReason() {\n+        return iae;\n+    }\n+\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/RuntimeImageLinkException.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -31,1 +31,0 @@\n-import java.nio.file.Paths;\n@@ -33,6 +32,0 @@\n-import java.util.Map;\n-import java.util.HashMap;\n-import java.util.Map.Entry;\n-import java.util.Set;\n-import java.util.HashSet;\n-import java.util.List;\n@@ -41,1 +34,0 @@\n-import java.util.stream.Stream;\n@@ -43,0 +35,4 @@\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n@@ -44,1 +40,2 @@\n-import java.util.ResourceBundle;\n+import java.util.Map;\n+import java.util.Map.Entry;\n@@ -46,2 +43,4 @@\n-import java.util.Comparator;\n-\n+import java.util.ResourceBundle;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -51,0 +50,1 @@\n+import jdk.tools.jlink.internal.Jlink.JlinkConfiguration;\n@@ -55,0 +55,1 @@\n+import jdk.tools.jlink.internal.plugins.ExcludePlugin;\n@@ -56,0 +57,1 @@\n+import jdk.tools.jlink.internal.plugins.SystemModulesPlugin;\n@@ -58,1 +60,0 @@\n-import jdk.tools.jlink.plugin.PluginException;\n@@ -413,1 +414,1 @@\n-                                                      Platform targetPlatform)\n+                                                      Platform targetPlatform, JlinkConfiguration config)\n@@ -422,0 +423,41 @@\n+            \/\/ if we perform a run-time based link, add relevant exclude\n+            \/\/ patterns, so as to match the packaged-modules-based link\n+            if (!config.useModulePath()) {\n+                Plugin systemModulesPlugin = null;\n+                Plugin excludeResourcePlugin = null;\n+                List<String> excludePatterns = new ArrayList<>();\n+                for (Plugin p: pluginToMaps.keySet()) {\n+                    if (p instanceof ExcludePlugin) {\n+                        excludeResourcePlugin = p;\n+                    }\n+                    if (p instanceof SystemModulesPlugin) {\n+                        systemModulesPlugin = p;\n+                    }\n+                    if (p.getExcludePatterns() != null) {\n+                        excludePatterns.addAll(p.getExcludePatterns());\n+                    }\n+                }\n+                String additionalPatterns = excludePatterns.stream().collect(Collectors.joining(\",\"));\n+                List<Map<String, String>> excludeResConfig = null;\n+                if (excludeResourcePlugin == null) {\n+                    \/\/ no existing 'exclude-resources' setting\n+                    excludeResourcePlugin = PluginRepository.getPlugin(\"exclude-resources\", ModuleLayer.boot());\n+                    excludeResConfig = new ArrayList<>();\n+                    excludeResConfig.add(Map.of(\"exclude-resources\", additionalPatterns));\n+                    pluginToMaps.put(excludeResourcePlugin, excludeResConfig);\n+                } else {\n+                    excludeResConfig = pluginToMaps.get(excludeResourcePlugin);\n+                    \/\/ currently last exclude-resources wins\n+                    Map<String, String> lastConfig = excludeResConfig.get(excludeResConfig.size() - 1);\n+                    String existingPattern = lastConfig.get(\"exclude-resources\");\n+                    lastConfig.put(\"exclude-resources\", existingPattern + \",\" + additionalPatterns);\n+                    excludeResConfig.set(excludeResConfig.size() - 1, lastConfig);\n+                }\n+                \/\/ If the system modules plug-in is disabled, we fail the link\n+                \/\/ as the SystemModulesMap class isn't guaranteed to be suitable\n+                \/\/ for the to-be produced jimage.\n+                if (systemModulesPlugin == null) {\n+                    throw new IllegalArgumentException(\"Disabling system-modules plugin for a run-time image based link is not allowed.\");\n+                }\n+            }\n+\n@@ -605,0 +647,1 @@\n+                    .filter((Plugin plugin) -> !plugin.isHidden())\n@@ -713,1 +756,1 @@\n-                                                 Platform targetPlatform)\n+                                                 Platform targetPlatform, JlinkConfiguration config)\n@@ -715,1 +758,5 @@\n-        return pluginOptions.getPluginsConfig(output, launchers, targetPlatform);\n+        return pluginOptions.getPluginsConfig(output, launchers, targetPlatform, config);\n+    }\n+\n+    Map<Plugin, List<Map<String, String>>> getPluginMaps() {\n+        return pluginOptions.pluginToMaps;\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/TaskHelper.java","additions":62,"deletions":15,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.List;\n+\n@@ -34,0 +36,2 @@\n+    private static final String OPTS_FILE = \"\/java.base\/jdk\/internal\/vm\/options\";\n+\n@@ -35,1 +39,7 @@\n-        super(\"add-options\", \"\/java.base\/jdk\/internal\/vm\/options\");\n+        super(\"add-options\", OPTS_FILE);\n+    }\n+\n+    \/\/ Filter the file we create for run-time image based links\n+    @Override\n+    public List<String> getExcludePatterns() {\n+        return List.of(\"glob:\" + AddOptionsPlugin.OPTS_FILE);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/AddOptionsPlugin.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.List;\n@@ -157,0 +158,16 @@\n+    \/\/ We generate these JLI Species classes so they would be in the run-time\n+    \/\/ image we derive from if we don't filter them for run-time image based\n+    \/\/ links. This filter corresponds to the set of classes part of the\n+    \/\/ jmods.\n+    @Override\n+    public List<String> getExcludePatterns() {\n+        return List.of(\"regex:\/java\\\\.base\/java\/lang\/invoke\/BoundMethodHandle\\\\$Species_(?:D|DL|I|IL|LJ|LL).*\\\\.class\");\n+    }\n+\n+    \/\/ This plugin doesn't persist, since generated classes are filtered for\n+    \/\/ run-time image based links.\n+    @Override\n+    public boolean runTimeImageLinkPersistent() {\n+        return false;\n+    }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/GenerateJLIClassesPlugin.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,274 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal.plugins;\n+\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.util.OperatingSystem;\n+import jdk.tools.jlink.internal.JlinkCLIArgsListener;\n+import jdk.tools.jlink.internal.Platform;\n+import jdk.tools.jlink.internal.RuntimeImageLinkException;\n+import jdk.tools.jlink.plugin.ResourcePool;\n+import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n+import jdk.tools.jlink.plugin.ResourcePoolEntry;\n+import jdk.tools.jlink.plugin.ResourcePoolModule;\n+\n+\n+\/**\n+ * Plugin to collect resources from jmod which aren't classes or\n+ * resources. Needed for the the run-time image based jlink.\n+ *\/\n+public final class JlinkResourcesListPlugin extends AbstractPlugin implements JlinkCLIArgsListener {\n+\n+    public static final String RESPATH_PREFIX = \"jdk\/tools\/jlink\/internal\/fs_\";\n+    public static final String RESPATH_SUFFIX = \"_files\";\n+    public static final String CLI_RESOURCE_FILE = \"jdk\/tools\/jlink\/internal\/cli_cmd.txt\";\n+    private static final int SYMLINKED_RES = 1;\n+    private static final int REGULAR_RES = 0;\n+    private static final String BIN_DIRNAME = \"bin\";\n+    private static final String LIB_DIRNAME = \"lib\";\n+    private static final String NAME = \"add-run-image-resources\";\n+    private static final String JLINK_MOD_NAME = \"jdk.jlink\";\n+    \/\/ This resource is being used in JLinkTask which passes its contents to\n+    \/\/ RunImageArchive for further processing.\n+    private static final String RESPATH = \"\/\" + JLINK_MOD_NAME + \"\/\" + RESPATH_PREFIX + \"%s\" + RESPATH_SUFFIX;\n+    private static final String CLI_RESOURCE = \"\/\" + JLINK_MOD_NAME + \"\/\" + CLI_RESOURCE_FILE;\n+    private static final Pattern WHITESPACE_PATTERN = Pattern.compile(\".*\\\\s.*\");\n+    private static final byte[] EMPTY_RESOURCE_BYTES = new byte[] {};\n+\n+    \/\/ Type file format:\n+    \/\/ '<type>|{0,1}|<sha-sum>|<file-path>'\n+    \/\/   (1)    (2)      (3)      (4)\n+    \/\/\n+    \/\/ Where fields are:\n+    \/\/\n+    \/\/ (1) The resource type as specified by ResourcePoolEntry.type()\n+    \/\/ (2) Symlink designator. 0 => regular resource, 1 => symlinked resource\n+    \/\/ (3) The SHA-512 sum of the resources' content. The link to the target\n+    \/\/     for symlinked resources.\n+    \/\/ (4) The relative file path of the resource\n+    private static final String TYPE_FILE_FORMAT = \"%d|%d|%s|%s\";\n+\n+    private final Map<String, List<String>> nonClassResEntries;\n+\n+    private List<String> commands;\n+\n+    public JlinkResourcesListPlugin() {\n+        super(NAME);\n+        this.nonClassResEntries = new ConcurrentHashMap<>();\n+    }\n+\n+    @Override\n+    public boolean isHidden() {\n+        return true; \/\/ Don't show in --list-plugins output\n+    }\n+\n+    @Override\n+    public ResourcePool transform(ResourcePool in, ResourcePoolBuilder out) {\n+        \/\/ Only add resources if we have the jdk.jlink module part of the\n+        \/\/ link.\n+        Optional<ResourcePoolModule> jdkJlink = in.moduleView().findModule(JLINK_MOD_NAME);\n+        if (jdkJlink.isPresent()) {\n+            Platform targetPlatform = getTargetPlatform(in);\n+            in.transformAndCopy(e -> recordAndFilterEntry(e, targetPlatform), out);\n+            addModuleResourceEntries(in, out);\n+            addCLIResource(out);\n+        } else {\n+            in.transformAndCopy(Function.identity(), out);\n+        }\n+        return out.build();\n+    }\n+\n+    private void addCLIResource(ResourcePoolBuilder out) {\n+        out.add(ResourcePoolEntry.create(CLI_RESOURCE, getCliBytes()));\n+    }\n+\n+    private byte[] getCliBytes() {\n+        StringBuilder builder = new StringBuilder();\n+        for (String s: commands) {\n+            Matcher m = WHITESPACE_PATTERN.matcher(s);\n+            if (m.matches()) {\n+                \/\/ Quote arguments containing whitespace\n+                builder.append(\"\\\"\");\n+                builder.append(s);\n+                builder.append(\"\\\"\");\n+            } else {\n+                builder.append(s);\n+            }\n+            builder.append(\" \");\n+        }\n+        builder.append(\"\\n\");\n+        return builder.toString().getBytes(StandardCharsets.UTF_8);\n+    }\n+\n+    \/\/ Filter the resource we add.\n+    @Override\n+    public List<String> getExcludePatterns() {\n+        return List.of(\"glob:\" + CLI_RESOURCE,\n+                       \"regex:\/jdk\\\\.jlink\/\" + RESPATH_PREFIX + \".*\" + RESPATH_SUFFIX);\n+    }\n+\n+    private Platform getTargetPlatform(ResourcePool in) {\n+        String platform = in.moduleView().findModule(\"java.base\")\n+                .map(ResourcePoolModule::targetPlatform)\n+                .orElseThrow(() -> new AssertionError(\"java.base not found\"));\n+        return Platform.parsePlatform(platform);\n+    }\n+\n+    private void addModuleResourceEntries(ResourcePool in, ResourcePoolBuilder out) {\n+        Set<String> inputModules = in.moduleView().modules()\n+                                                  .map(rm -> rm.name())\n+                                                  .collect(Collectors.toSet());\n+        inputModules.stream().sorted().forEach(module -> {\n+            String mResource = String.format(RESPATH, module);\n+            List<String> mResources = nonClassResEntries.get(module);\n+            if (mResources == null) {\n+                \/\/ We create empty resource files for modules in the resource\n+                \/\/ pool view, but which don't themselves contain native resources\n+                \/\/ or config files.\n+                out.add(ResourcePoolEntry.create(mResource, EMPTY_RESOURCE_BYTES));\n+            } else {\n+                String mResContent = mResources.stream().sorted()\n+                                               .collect(Collectors.joining(\"\\n\"));\n+                out.add(ResourcePoolEntry.create(mResource,\n+                    mResContent.getBytes(StandardCharsets.UTF_8)));\n+            }\n+        });\n+    }\n+\n+    private ResourcePoolEntry recordAndFilterEntry(ResourcePoolEntry entry, Platform platform) {\n+        \/\/ Note that the jmod_resources file is a resource file, so we cannot\n+        \/\/ add ourselves due to this condition. However, we want to not add\n+        \/\/ an old version of the resource file again.\n+        if (entry.type() != ResourcePoolEntry.Type.CLASS_OR_RESOURCE) {\n+            if (entry.type() == ResourcePoolEntry.Type.TOP) {\n+                return entry; \/\/ Handled by ReleaseInfoPlugin, nothing to do\n+            }\n+            List<String> moduleResources = nonClassResEntries.computeIfAbsent(entry.moduleName(), a -> new ArrayList<>());\n+            int type = entry.type().ordinal();\n+            int isSymlink = entry.linkedTarget() != null ? SYMLINKED_RES : REGULAR_RES;\n+            String resPathWithoutMod = resPathWithoutModule(entry, platform);\n+            String sha512 = computeSha512(entry, platform);\n+            moduleResources.add(String.format(TYPE_FILE_FORMAT, type, isSymlink, sha512, resPathWithoutMod));\n+        }\n+        return entry;\n+    }\n+\n+    private String computeSha512(ResourcePoolEntry entry, Platform platform) {\n+        try {\n+            if (entry.linkedTarget() != null) {\n+                \/\/ Symlinks don't have a hash sum, but a link to the target instead\n+                return resPathWithoutModule(entry.linkedTarget(), platform);\n+            } else {\n+                MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n+                try (InputStream is = entry.content()) {\n+                    byte[] buf = new byte[1024];\n+                    int bytesRead = -1;\n+                    while ((bytesRead = is.read(buf)) != -1) {\n+                        digest.update(buf, 0, bytesRead);\n+                    }\n+                }\n+                byte[] db = digest.digest();\n+                HexFormat format = HexFormat.of();\n+                return format.formatHex(db);\n+            }\n+        } catch (RuntimeImageLinkException e) {\n+            \/\/ RunImageArchive::RunImageFile.content() may throw this when\n+            \/\/ getting the content(). Propagate this specific exception.\n+            throw e;\n+        } catch (Exception e) {\n+            throw new AssertionError(\"Failed to generate hash sum for \" + entry.path());\n+        }\n+    }\n+\n+    private String resPathWithoutModule(ResourcePoolEntry entry, Platform platform) {\n+        String resPath = entry.path().substring(entry.moduleName().length() + 2 \/* prefixed and suffixed '\/' *\/);\n+        if (!isWindows(platform)) {\n+            return resPath;\n+        }\n+        \/\/ For Windows the libraries live in the 'bin' folder rather than the 'lib' folder\n+        \/\/ in the final image. Note that going by the NATIVE_LIB type only is insufficient since\n+        \/\/ only files with suffix .dll\/diz\/map\/pdb are transplanted to 'bin'.\n+        \/\/ See: DefaultImageBuilder.nativeDir()\n+        return nativeDir(entry, resPath);\n+    }\n+\n+    private boolean isWindows(Platform platform) {\n+        return platform.os() == OperatingSystem.WINDOWS;\n+    }\n+\n+    private String nativeDir(ResourcePoolEntry entry, String resPath) {\n+        if (entry.type() != ResourcePoolEntry.Type.NATIVE_LIB) {\n+            return resPath;\n+        }\n+        \/\/ precondition: Native lib, windows platform\n+        if (resPath.endsWith(\".dll\") || resPath.endsWith(\".diz\")\n+                || resPath.endsWith(\".pdb\") || resPath.endsWith(\".map\")) {\n+            if (resPath.startsWith(LIB_DIRNAME + \"\/\")) {\n+                return BIN_DIRNAME + \"\/\" + resPath.substring((LIB_DIRNAME + \"\/\").length());\n+            }\n+        }\n+        return resPath;\n+    }\n+\n+    @Override\n+    public Set<State> getState() {\n+        return EnumSet.of(State.AUTO_ENABLED, State.FUNCTIONAL);\n+    }\n+\n+    @Override\n+    public boolean hasArguments() {\n+        return false;\n+    }\n+\n+    @Override\n+    public Category getType() {\n+        \/\/ Ensure we run in a later stage as we need to generate\n+        \/\/ SHA-512 sums for non-(class\/resource) files. The jmod_resources\n+        \/\/ files can be considered meta-info describing the universe we\n+        \/\/ draft from.\n+        return Category.METAINFO_ADDER;\n+    }\n+\n+    @Override\n+    public void process(List<String> commands) {\n+        this.commands = commands;\n+    }\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/JlinkResourcesListPlugin.java","additions":274,"deletions":0,"binary":false,"changes":274,"status":"added"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.tools.jlink.internal.JlinkTask;\n@@ -107,0 +108,6 @@\n+\n+    \/\/ Filter the file we create for run-time image based links\n+    @Override\n+    public List<String> getExcludePatterns() {\n+        return List.of(\"glob:\/jdk.jlink\/\" + JlinkTask.OPTIONS_RESOURCE);\n+    }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SaveJlinkArgfilesPlugin.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,16 @@\n+import static java.lang.classfile.ClassFile.ACC_FINAL;\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.classfile.ClassFile.ACC_SUPER;\n+import static java.lang.constant.ConstantDescs.CD_List;\n+import static java.lang.constant.ConstantDescs.CD_Map;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_Set;\n+import static java.lang.constant.ConstantDescs.CD_String;\n+import static java.lang.constant.ConstantDescs.CD_boolean;\n+import static java.lang.constant.ConstantDescs.CD_byte;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static java.lang.constant.ConstantDescs.MTD_void;\n+\n@@ -31,0 +47,5 @@\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.attribute.ModulePackagesAttribute;\n@@ -33,1 +54,0 @@\n-import static java.lang.constant.ConstantDescs.*;\n@@ -69,1 +89,0 @@\n-import jdk.internal.module.Modules;\n@@ -76,8 +95,1 @@\n-\n-import java.lang.classfile.attribute.ModulePackagesAttribute;\n-import java.lang.classfile.ClassBuilder;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.TypeKind;\n-import static java.lang.classfile.ClassFile.*;\n-import java.lang.classfile.CodeBuilder;\n-\n+import jdk.internal.module.Modules;\n@@ -179,0 +191,16 @@\n+    \/\/ Certain system module classes get generated and SystemModulesMap replaced.\n+    \/\/ Filter previously generated classes so the set of classes match the set\n+    \/\/ of the packaged modules link.\n+    @Override\n+    public List<String> getExcludePatterns() {\n+        return List.of(\"regex:\/java\\\\.base\/jdk\/internal\/module\/SystemModules\\\\$.*\\\\.class\");\n+    }\n+\n+    \/\/ This plugin doesn't persist, since generated classes are filtered for\n+    \/\/ run-time image based links and running without --system-modules on a\n+    \/\/ run-time image based link is not allowed.\n+    @Override\n+    public boolean runTimeImageLinkPersistent() {\n+        return false;\n+    }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":38,"deletions":10,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.List;\n@@ -31,0 +32,1 @@\n+import jdk.tools.jlink.internal.plugins.ExcludePlugin;\n@@ -169,0 +171,38 @@\n+    \/**\n+     * Determine whether or not the plugin is hidden from\n+     * {@code jlink --list-plugins} output.\n+     *\n+     * @return true if the plugin needs to be hidden from --list-plugins\n+     *\/\n+    public default boolean isHidden() {\n+        return false;\n+    }\n+\n+    \/**\n+     * A list of exclude patterns suitable to be fed to the\n+     * {@link ExcludePlugin}. The list of patterns should be such that\n+     * the classes and resource list will be the same as before the\n+     * plugin ran.\n+     *\n+     * @return A list of glob or regex patterns suitable for the\n+     *         exclude-resource plugin.\n+     *\/\n+    public default List<String> getExcludePatterns() {\n+        return null;\n+    }\n+\n+    \/**\n+     * Determined whether or not application of the plugin changes binary files\n+     * in the resulting image on the filesystem or the plugin changes classes or\n+     * resources in the resulting jimage and there is no way to undo this\n+     * operation. This is being used for the run-time image based link so as to\n+     * craft an equivalent CLI command of a link using packaged modules.\n+     *\n+     * @return {@code true} if the transformation cannot be undone and carries\n+     *         forward in a subsequent jlink using the run-time image.\n+     *         {@code false} otherwise.\n+     *\/\n+    public default boolean runTimeImageLinkPersistent() {\n+        return getType() == Category.FILTER || getType() == Category.TRANSFORMER;\n+    }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/plugin\/Plugin.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.io.InputStream;\n@@ -29,0 +28,1 @@\n+import java.io.InputStream;\n@@ -71,1 +71,15 @@\n-        TOP\n+        TOP;\n+\n+        public static Type fromOrdinal(int value) {\n+            Type retval = null;\n+            for (Type v: Type.values()) {\n+                if (v.ordinal() == value) {\n+                    retval = v;\n+                    break;\n+                }\n+            }\n+            if (retval == null) {\n+                throw new IllegalArgumentException(\"Illegal ordinal: \" + value);\n+            }\n+            return retval;\n+        }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/plugin\/ResourcePoolEntry.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -92,0 +92,8 @@\n+main.opt.unlock-run-image=\\\n+\\      --unlock-run-image                Allow for multiple run-image-based links.\\n\\\n+\\                                        Default is to only allow a single link using\\n\\\n+\\                                        the run-image. With this option a run-image\\n\\\n+\\                                        link and a link using packaged modules become\\n\\\n+\\                                        equivalent as it does not add a stamp file to\\n\\\n+\\                                        the module image.\\n\\\n+\n@@ -118,0 +126,3 @@\n+err.runtime.link.recursive=Module path to the JDK packaged modules must be specified. \\\n+Run-time image based linking is not supported as $java.home was already created from a run-time image.\n+err.runtime.link.packaged.mods=--keep-packaged-modules is not allowed for run-time image based links.\n@@ -160,0 +171,5 @@\n+\n+runtime.link.info=The default module path, ''$java.home\/jmods'' not present.{0}\n+runtime.link.verbose.hint=Use --verbose to show the full list of plugin options applied.\n+runtime.link.jprt.path.extra=(run-time image)\n+runtime.link.equivalent.packaged.modules=''{0}'' is linked equivalent to using jlink with packaged modules as:\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -210,0 +210,8 @@\n+add-run-image-resources.description=\\\n+Add a resource file that is later used for run image-based links\n+\n+add-run-image-resources.usage=\\\n+\\  --add-run-image-resources   Add a resource file, ''\/<module-name>\/runimage_resources'', listing\\n\\\n+\\                              all resource files other than classes\/resources within it. This\\n\\\n+\\                              plugin is required for run-image-based links.\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/plugins.properties","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+        jdk.tools.jlink.internal.plugins.JlinkResourcesListPlugin,\n","filename":"src\/jdk.jlink\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+\n+import jdk.tools.jlink.builder.ImageBuilder;\n@@ -38,0 +40,1 @@\n+import jdk.tools.jlink.internal.ExecutableImage;\n@@ -40,2 +43,0 @@\n-import jdk.tools.jlink.internal.ExecutableImage;\n-import jdk.tools.jlink.builder.ImageBuilder;\n@@ -224,1 +225,1 @@\n-                null, false);\n+                null, false, null);\n","filename":"test\/jdk\/tools\/jlink\/ImageFileCreatorTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.nio.ByteOrder;\n@@ -41,2 +40,1 @@\n-import jdk.tools.jlink.internal.Jlink;\n-import jdk.tools.jlink.internal.JlinkTask;\n+\n@@ -44,4 +42,0 @@\n-import jdk.tools.jlink.internal.Platform;\n-import jdk.tools.jlink.plugin.ResourcePool;\n-import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n-import jdk.tools.jlink.plugin.Plugin;\n@@ -49,0 +43,1 @@\n+import jdk.tools.jlink.internal.Jlink;\n@@ -51,0 +46,2 @@\n+import jdk.tools.jlink.internal.JlinkTask;\n+import jdk.tools.jlink.internal.Platform;\n@@ -52,3 +49,3 @@\n-import jdk.tools.jlink.internal.plugins.DefaultCompressPlugin;\n-import jdk.tools.jlink.internal.plugins.DefaultStripDebugPlugin;\n-\n+import jdk.tools.jlink.plugin.Plugin;\n+import jdk.tools.jlink.plugin.ResourcePool;\n+import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n@@ -165,1 +162,1 @@\n-                JlinkTask.newModuleFinder(modulePaths, limits, mods));\n+                JlinkTask.newModuleFinder(modulePaths, limits, mods, true), true, true);\n","filename":"test\/jdk\/tools\/jlink\/IntegrationTest.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.nio.file.Paths;\n@@ -32,1 +31,0 @@\n-import java.util.Collections;\n@@ -39,1 +37,0 @@\n-import jdk.tools.jlink.plugin.Plugin;\n@@ -41,0 +38,1 @@\n+import jdk.tools.jlink.plugin.Plugin;\n@@ -98,1 +96,2 @@\n-            totalPlugins = builtInPlugins.size();\n+            \/\/ AddRunImageResourcesPlugin is hidden from --list-plugins\n+            totalPlugins = builtInPlugins.stream().filter(p -> !p.isHidden()).collect(Collectors.toList()).size();\n","filename":"test\/jdk\/tools\/jlink\/JLinkTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,484 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Scanner;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import tests.Helper;\n+import tests.JImageGenerator;\n+import tests.JImageGenerator.JLinkTask;\n+import tests.JImageValidator;\n+\n+public abstract class AbstractJmodLessTest {\n+\n+    protected static final boolean DEBUG = true;\n+\n+    public void run() throws Exception {\n+        Helper helper = Helper.newHelper();\n+        if (helper == null) {\n+            System.err.println(\"Test not run\");\n+            return;\n+        }\n+        runTest(helper);\n+        System.out.println(getClass().getSimpleName() + \" PASSED!\");\n+    }\n+\n+    \/** main test entrypoint **\/\n+    abstract void runTest(Helper helper) throws Exception;\n+\n+    \/**\n+     * Ensure 'java --list-modules' lists the correct set of modules in the given\n+     * image.\n+     *\n+     * @param jlinkImage\n+     * @param expectedModules\n+     *\/\n+    protected void verifyListModules(Path image,\n+            List<String> expectedModules) throws Exception {\n+        OutputAnalyzer out = runJavaCmd(image, List.of(\"--list-modules\"));\n+        List<String> actual = parseListMods(out.getStdout());\n+        Collections.sort(actual);\n+        if (!expectedModules.equals(actual)) {\n+            throw new AssertionError(\"Different modules! Expected \" + expectedModules + \" got: \" + actual);\n+        }\n+    }\n+\n+    protected OutputAnalyzer runJavaCmd(Path image, List<String> options) throws Exception {\n+        Path targetJava = image.resolve(\"bin\").resolve(getJava());\n+        List<String> cmd = new ArrayList<>();\n+        cmd.add(targetJava.toString());\n+        for (String opt: options) {\n+            cmd.add(opt);\n+        }\n+        List<String> javaCmd = Collections.unmodifiableList(cmd);\n+        OutputAnalyzer out;\n+        try {\n+            out = ProcessTools.executeCommand(javaCmd.toArray(new String[0]));\n+        } catch (Throwable e) {\n+            throw new Exception(\"Process failed to execute\", e);\n+        }\n+        if (out.getExitValue() != 0) {\n+            if (DEBUG) {\n+                System.err.println(\"Process stdout was: \");\n+                System.err.println(out.getStdout());\n+                System.err.println(\"Process stderr was: \");\n+                System.err.println(out.getStderr());\n+            }\n+            throw new AssertionError(\"'\" + javaCmd.stream().collect(Collectors.joining(\" \")) + \"'\"\n+                    + \" expected to succeed!\");\n+        }\n+        return out;\n+    }\n+\n+    protected Path createJavaImageJmodLess(BaseJlinkSpec baseSpec) throws Exception {\n+        \/\/ create a base image only containing the jdk.jlink module and its transitive closure\n+        Path jlinkJmodlessImage = createBaseJlinkImage(baseSpec);\n+\n+        \/\/ On Windows jvm.dll is in 'bin' after the jlink\n+        Path libjvm = Path.of((isWindows() ? \"bin\" : \"lib\"), \"server\", System.mapLibraryName(\"jvm\"));\n+        JlinkSpecBuilder builder = new JlinkSpecBuilder();\n+        \/\/ And expect libjvm (not part of the jimage) to be present in the resulting image\n+        builder.expectedFile(libjvm.toString())\n+               .helper(baseSpec.getHelper())\n+               .name(baseSpec.getName())\n+               .validatingModule(baseSpec.getValidatingModule())\n+               .imagePath(jlinkJmodlessImage)\n+               .expectedLocation(\"\/java.base\/java\/lang\/String.class\");\n+        for (String m: baseSpec.getModules()) {\n+            builder.addModule(m);\n+        }\n+        for (String extra: baseSpec.getExtraOptions()) {\n+            builder.extraJlinkOpt(extra);\n+        }\n+        return jlinkUsingImage(builder.build());\n+    }\n+\n+    protected Path jlinkUsingImage(JlinkSpec spec) throws Exception {\n+        return jlinkUsingImage(spec, new NoopOutputAnalyzerHandler());\n+    }\n+\n+    protected Path jlinkUsingImage(JlinkSpec spec, OutputAnalyzerHandler handler) throws Exception {\n+        return jlinkUsingImage(spec, handler, new DefaultSuccessExitPredicate());\n+    }\n+\n+    protected Path jlinkUsingImage(JlinkSpec spec, OutputAnalyzerHandler handler, Predicate<OutputAnalyzer> exitChecker) throws Exception {\n+        String jmodLessGeneratedImage = \"target-jmodless-\" + spec.getName();\n+        Path targetImageDir = spec.getHelper().createNewImageDir(jmodLessGeneratedImage);\n+        Path targetJlink = spec.getImageToUse().resolve(\"bin\").resolve(getJlink());\n+        String[] jlinkCmdArray = new String[] {\n+                targetJlink.toString(),\n+                \"--output\", targetImageDir.toString(),\n+                \"--verbose\",\n+                \"--add-modules\", spec.getModules().stream().collect(Collectors.joining(\",\"))\n+        };\n+        List<String> jlinkCmd = new ArrayList<>();\n+        jlinkCmd.addAll(Arrays.asList(jlinkCmdArray));\n+        if (spec.getExtraJlinkOpts() != null && !spec.getExtraJlinkOpts().isEmpty()) {\n+            jlinkCmd.addAll(spec.getExtraJlinkOpts());\n+        }\n+        jlinkCmd = Collections.unmodifiableList(jlinkCmd); \/\/ freeze\n+        System.out.println(\"DEBUG: jmod-less jlink command: \" + jlinkCmd.stream().collect(\n+                                                    Collectors.joining(\" \")));\n+        OutputAnalyzer analyzer = null;\n+        try {\n+            analyzer = ProcessTools.executeProcess(jlinkCmd.toArray(new String[0]));\n+        } catch (Throwable t) {\n+            throw new AssertionError(\"Executing process failed!\", t);\n+        }\n+        if (!exitChecker.test(analyzer)) {\n+            if (DEBUG) {\n+                System.err.println(\"Process stdout was: \");\n+                System.err.println(analyzer.getStdout());\n+                System.err.println(\"Process stderr was: \");\n+                System.err.println(analyzer.getStderr());\n+            }\n+            \/\/ if the exit checker failed, we expected the other outcome\n+            \/\/ i.e. fail for success and success for fail.\n+            boolean successExit = analyzer.getExitValue() == 0;\n+            String msg = String.format(\"Expected jlink to %s given a jmodless image. Exit code was: %d\",\n+                                       (successExit ? \"fail\" : \"pass\"), analyzer.getExitValue());\n+            throw new AssertionError(msg);\n+        }\n+        handler.handleAnalyzer(analyzer); \/\/ Give tests a chance to process in\/output\n+\n+        \/\/ validate the resulting image; Includes running 'java -version', only do this\n+        \/\/ if the jlink succeeded.\n+        if (analyzer.getExitValue() == 0) {\n+            JImageValidator validator = new JImageValidator(spec.getValidatingModule(), spec.getExpectedLocations(),\n+                    targetImageDir.toFile(), spec.getUnexpectedLocations(), Collections.emptyList(), spec.getExpectedFiles());\n+            validator.validate(); \/\/ This doesn't validate locations\n+            if (!spec.getExpectedLocations().isEmpty() || !spec.getUnexpectedLocations().isEmpty()) {\n+                JImageValidator.validate(targetImageDir.resolve(\"lib\").resolve(\"modules\"), spec.getExpectedLocations(), spec.getUnexpectedLocations());\n+            }\n+        }\n+        return targetImageDir;\n+    }\n+\n+    protected Path createBaseJlinkImage(BaseJlinkSpec baseSpec) throws Exception {\n+        \/\/ Jlink an image including jdk.jlink (i.e. the jlink tool). The\n+        \/\/ result must not contain a jmods directory.\n+        Path jlinkJmodlessImage = baseSpec.getHelper().createNewImageDir(baseSpec.getName() + \"-jlink\");\n+        JLinkTask task = JImageGenerator.getJLinkTask();\n+        if (baseSpec.getModules().contains(\"leaf1\")) {\n+            task.modulePath(baseSpec.getHelper().getJmodDir().toString());\n+        }\n+        task.output(jlinkJmodlessImage);\n+        for (String module: baseSpec.getModules()) {\n+            task.addMods(module);\n+        }\n+        if (!baseSpec.getModules().contains(\"ALL-MODULE-PATH\")) {\n+            task.addMods(\"jdk.jlink\"); \/\/ needed for the recursive jlink\n+        }\n+        for (String opt: baseSpec.getExtraOptions()) {\n+            task.option(opt);\n+        }\n+        task.option(\"--verbose\")\n+            .call().assertSuccess();\n+        \/\/ Verify the base image is actually jmod-less\n+        if (Files.exists(jlinkJmodlessImage.resolve(\"jmods\"))) {\n+            throw new AssertionError(\"Must not contain 'jmods' directory\");\n+        }\n+        return jlinkJmodlessImage;\n+    }\n+\n+    private List<String> parseListMods(String output) throws Exception {\n+        List<String> outputLines = new ArrayList<>();\n+        try (Scanner lineScan = new Scanner(output)) {\n+            while (lineScan.hasNextLine()) {\n+                outputLines.add(lineScan.nextLine());\n+            }\n+        }\n+        return outputLines.stream()\n+                .map(a -> { return a.split(\"@\", 2)[0];})\n+                .filter(a -> !a.isBlank())\n+                .collect(Collectors.toList());\n+    }\n+\n+    private String getJlink() {\n+        return getBinary(\"jlink\");\n+    }\n+\n+    private String getJava() {\n+        return getBinary(\"java\");\n+    }\n+\n+    private String getBinary(String binary) {\n+        return isWindows() ? binary + \".exe\" : binary;\n+    }\n+\n+    protected static boolean isWindows() {\n+        return System.getProperty(\"os.name\").startsWith(\"Windows\");\n+    }\n+\n+    static class BaseJlinkSpec {\n+        final Helper helper;\n+        final String name;\n+        final String validatingModule;\n+        final List<String> modules;\n+        final List<String> extraOptions;\n+\n+        BaseJlinkSpec(Helper helper, String name, String validatingModule,\n+                List<String> modules, List<String> extraOptions) {\n+            this.helper = helper;\n+            this.name = name;\n+            this.modules = modules;\n+            this.extraOptions = extraOptions;\n+            this.validatingModule = validatingModule;\n+        }\n+\n+        public String getValidatingModule() {\n+            return validatingModule;\n+        }\n+\n+        public Helper getHelper() {\n+            return helper;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public List<String> getModules() {\n+            return modules;\n+        }\n+\n+        public List<String> getExtraOptions() {\n+            return extraOptions;\n+        }\n+    }\n+\n+    static class BaseJlinkSpecBuilder {\n+        Helper helper;\n+        String name;\n+        String validatingModule;\n+        List<String> modules = new ArrayList<>();\n+        List<String> extraOptions = new ArrayList<>();\n+\n+        BaseJlinkSpecBuilder addModule(String module) {\n+            modules.add(module);\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder addExtraOption(String option) {\n+            extraOptions.add(option);\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder helper(Helper helper) {\n+            this.helper = helper;\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder name(String name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder validatingModule(String module) {\n+            this.validatingModule = module;\n+            return this;\n+        }\n+\n+        BaseJlinkSpec build() {\n+            if (name == null) {\n+                throw new IllegalStateException(\"Name must be set\");\n+            }\n+            if (helper == null) {\n+                throw new IllegalStateException(\"helper must be set\");\n+            }\n+            if (validatingModule == null) {\n+                throw new IllegalStateException(\"the module which should get validated must be set\");\n+            }\n+            return new BaseJlinkSpec(helper, name, validatingModule, modules, extraOptions);\n+        }\n+    }\n+\n+    static class JlinkSpec {\n+        final Path imageToUse;\n+        final Helper helper;\n+        final String name;\n+        final List<String> modules;\n+        final String validatingModule;\n+        final List<String> expectedLocations;\n+        final List<String> unexpectedLocations;\n+        final String[] expectedFiles;\n+        final List<String> extraJlinkOpts;\n+\n+        JlinkSpec(Path imageToUse, Helper helper, String name, List<String> modules,\n+                String validatingModule, List<String> expectedLocations,\n+                List<String> unexpectedLocations, String[] expectedFiles,\n+                List<String> extraJlinkOpts) {\n+            this.imageToUse = imageToUse;\n+            this.helper = helper;\n+            this.name = name;\n+            this.modules = modules;\n+            this.validatingModule = validatingModule;\n+            this.expectedLocations = expectedLocations;\n+            this.unexpectedLocations = unexpectedLocations;\n+            this.expectedFiles = expectedFiles;\n+            this.extraJlinkOpts = extraJlinkOpts;\n+        }\n+\n+        public Path getImageToUse() {\n+            return imageToUse;\n+        }\n+\n+        public Helper getHelper() {\n+            return helper;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public List<String> getModules() {\n+            return modules;\n+        }\n+\n+        public String getValidatingModule() {\n+            return validatingModule;\n+        }\n+\n+        public List<String> getExpectedLocations() {\n+            return expectedLocations;\n+        }\n+\n+        public List<String> getUnexpectedLocations() {\n+            return unexpectedLocations;\n+        }\n+\n+        public String[] getExpectedFiles() {\n+            return expectedFiles;\n+        }\n+\n+        public List<String> getExtraJlinkOpts() {\n+            return extraJlinkOpts;\n+        }\n+    }\n+\n+    static class JlinkSpecBuilder {\n+        Path imageToUse;\n+        Helper helper;\n+        String name;\n+        List<String> modules = new ArrayList<>();\n+        String validatingModule;\n+        List<String> expectedLocations = new ArrayList<>();\n+        List<String> unexpectedLocations = new ArrayList<>();\n+        List<String> expectedFiles = new ArrayList<>();\n+        List<String> extraJlinkOpts = new ArrayList<>();\n+\n+        JlinkSpec build() {\n+            if (imageToUse == null) {\n+                throw new IllegalStateException(\"No image to use for jlink specified!\");\n+            }\n+            if (helper == null) {\n+                throw new IllegalStateException(\"No helper specified!\");\n+            }\n+            if (name == null) {\n+                throw new IllegalStateException(\"No name for the image location specified!\");\n+            }\n+            if (validatingModule == null) {\n+                throw new IllegalStateException(\"No module specified for after generation validation!\");\n+            }\n+            return new JlinkSpec(imageToUse, helper, name, modules, validatingModule, expectedLocations, unexpectedLocations, expectedFiles.toArray(new String[0]), extraJlinkOpts);\n+        }\n+\n+        JlinkSpecBuilder imagePath(Path image) {\n+            this.imageToUse = image;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder helper(Helper helper) {\n+            this.helper = helper;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder name(String name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder addModule(String module) {\n+            modules.add(module);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder validatingModule(String module) {\n+            this.validatingModule = module;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder expectedLocation(String location) {\n+            expectedLocations.add(location);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder unexpectedLocation(String location) {\n+            unexpectedLocations.add(location);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder expectedFile(String file) {\n+            expectedFiles.add(file);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder extraJlinkOpt(String opt) {\n+            extraJlinkOpts.add(opt);\n+            return this;\n+        }\n+    }\n+\n+    static abstract class OutputAnalyzerHandler {\n+\n+        public abstract void handleAnalyzer(OutputAnalyzer out);\n+\n+    }\n+\n+    static class NoopOutputAnalyzerHandler extends OutputAnalyzerHandler {\n+\n+        @Override\n+        public void handleAnalyzer(OutputAnalyzer out) {\n+            \/\/ nothing\n+        }\n+\n+    }\n+\n+    static class DefaultSuccessExitPredicate implements Predicate<OutputAnalyzer> {\n+\n+        @Override\n+        public boolean test(OutputAnalyzer t) {\n+            return t.getExitValue() == 0;\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/AbstractJmodLessTest.java","additions":484,"deletions":0,"binary":false,"changes":484,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Scanner;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Test --add-options jlink plugin in jmod-less mode\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g AddOptionsTest\n+ *\/\n+public class AddOptionsTest extends AbstractJmodLessTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        AddOptionsTest test = new AddOptionsTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        Path finalImage = createJavaImageJmodLess(new BaseJlinkSpecBuilder()\n+                .addExtraOption(\"--add-options\")\n+                .addExtraOption(\"-Xlog:gc=info:stderr -XX:+UseParallelGC\")\n+                .name(\"java-base-with-opts\")\n+                .addModule(\"java.base\")\n+                .validatingModule(\"java.base\")\n+                .helper(helper)\n+                .build());\n+        verifyListModules(finalImage, List.of(\"java.base\"));\n+        verifyParallelGCInUse(finalImage);\n+    }\n+\n+    private void verifyParallelGCInUse(Path finalImage) throws Exception {\n+        OutputAnalyzer analyzer = runJavaCmd(finalImage, List.of(\"--version\"));\n+        boolean foundMatch = false;\n+        try (Scanner lineScan = new Scanner(analyzer.getStderr())) {\n+            while (lineScan.hasNextLine()) {\n+                String line = lineScan.nextLine();\n+                if (line.endsWith(\"Using Parallel\")) {\n+                    foundMatch = true;\n+                    break;\n+                }\n+            }\n+        }\n+        if (!foundMatch) {\n+            throw new AssertionError(\"Expected Parallel GC in place for jlinked image\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/AddOptionsTest.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test\n+ * @summary Test basic jmod-less jlinking\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g BasicJlinkTest\n+ *\/\n+public class BasicJlinkTest extends AbstractJmodLessTest {\n+\n+    @Override\n+    public void runTest(Helper helper) throws Exception {\n+        Path finalImage = createJavaBaseJmodLess(helper, \"java-base\");\n+        verifyListModules(finalImage, List.of(\"java.base\"));\n+    }\n+\n+    private Path createJavaBaseJmodLess(Helper helper, String name) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder();\n+        builder.helper(helper)\n+               .name(name)\n+               .addModule(\"java.base\")\n+               .validatingModule(\"java.base\");\n+        return createJavaImageJmodLess(builder.build());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        BasicJlinkTest test = new BasicJlinkTest();\n+        test.run();\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/BasicJlinkTest.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+class CapturingHandler extends AbstractJmodLessTest.OutputAnalyzerHandler {\n+\n+    private OutputAnalyzer output;\n+\n+    public String stdErr() {\n+        return output.getStderr();\n+    }\n+\n+    public OutputAnalyzer analyzer() {\n+        return output;\n+    }\n+\n+    @Override\n+    public void handleAnalyzer(OutputAnalyzer out) {\n+        this.output = out;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/CapturingHandler.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test\n+ * @summary Test jmod-less jlink with a custom module\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g CustomModuleJlinkTest\n+ *\/\n+public class CustomModuleJlinkTest extends AbstractJmodLessTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        CustomModuleJlinkTest test = new CustomModuleJlinkTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        String customModule = \"leaf1\";\n+        helper.generateDefaultJModule(customModule);\n+\n+        \/\/ create a base image including jdk.jlink and the leaf1 module. This will\n+        \/\/ add the leaf1 module's module path.\n+        Path jlinkImage = createBaseJlinkImage(new BaseJlinkSpecBuilder()\n+                                                    .helper(helper)\n+                                                    .name(\"cmod-jlink\")\n+                                                    .addModule(customModule)\n+                                                    .validatingModule(\"java.base\") \/\/ not used\n+                                                    .build());\n+\n+        \/\/ Now that the base image already includes the 'leaf1' module, it should\n+        \/\/ be possible to jlink it again, asking for *only* the 'leaf1' plugin even\n+        \/\/ though we won't have any jmods directories present.\n+        Path finalImage = jlinkUsingImage(new JlinkSpecBuilder()\n+                                                .imagePath(jlinkImage)\n+                                                .helper(helper)\n+                                                .name(customModule)\n+                                                .expectedLocation(String.format(\"\/%s\/%s\/com\/foo\/bar\/X.class\", customModule, customModule))\n+                                                .addModule(customModule)\n+                                                .validatingModule(customModule)\n+                                                .build());\n+        \/\/ Expected only the transitive closure of \"leaf1\" module in the --list-modules\n+        \/\/ output of the java launcher.\n+        List<String> expectedModules = List.of(\"java.base\", customModule);\n+        verifyListModules(finalImage, expectedModules);\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/CustomModuleJlinkTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Verify JLI class generation in run-time image link mode\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g GenerateJLIClassesTest\n+ *\/\n+public class GenerateJLIClassesTest extends AbstractJmodLessTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        GenerateJLIClassesTest test = new GenerateJLIClassesTest();\n+        test.run();\n+    }\n+\n+    \/*\n+     * java.lang.invoke.BoundMethodHandle$Species_* classes get generated\n+     * by the GenerateJLiClassesPlugin. This test ensures that potentially\n+     * generated JLI classes from the run-time image don't populate to the\n+     * target image in the run-time image based link mode.\n+     *\/\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        \/\/ create an image with a module containing a main entrypoint (jdk.httpserver),\n+        \/\/ thus producing the SystemModules$0.class. Add jdk.jdwp.agent as a module which\n+        \/\/ isn't resolved by default, so as to generate SystemModules$default.class\n+\n+        Path baseFile = Files.createTempFile(\"base\", \"trace\");\n+        String species = \"LLLLLLLLLLLLLLLLLLL\";\n+        String fileString = \"[SPECIES_RESOLVE] java.lang.invoke.BoundMethodHandle$Species_\" + species + \" (salvaged)\\n\";\n+        Files.write(baseFile, fileString.getBytes(StandardCharsets.UTF_8));\n+        Path jmodLessImage = createJavaImageJmodLess(new BaseJlinkSpecBuilder()\n+                                                            .helper(helper)\n+                                                            .name(\"jlink.jli-jmodless\")\n+                                                            .addModule(\"jdk.jlink\")\n+                                                            .validatingModule(\"java.base\")\n+                                                            .addExtraOption(\"--unlock-run-image\")\n+                                                            .build());\n+        \/\/ Finally attempt another jmodless link reducing modules to java.base only,\n+        \/\/ and asking for specific jli classes.\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(jmodLessImage)\n+                                .name(\"java.base-jli-derived\")\n+                                .addModule(\"java.base\")\n+                                .extraJlinkOpt(\"--generate-jli-classes=@\" + baseFile.toString())\n+                                .expectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_\" + species + \".class\")\n+                                .expectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_L.class\")\n+                                .unexpectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_\" + species.substring(1) + \".class\")\n+                                .unexpectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LL.class\")\n+                                .validatingModule(\"java.base\")\n+                                .build());\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/GenerateJLIClassesTest.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Test reproducibility of jmod-less jlink of java.se\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g JavaSEReproducibleTest\n+ *\/\n+public class JavaSEReproducibleTest extends AbstractJmodLessTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        JavaSEReproducibleTest test = new JavaSEReproducibleTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        String javaSeModule = \"java.se\";\n+        \/\/ create a java.se using jmod-less approach\n+        Path javaSEJmodLess1 = createJavaImageJmodLess(new BaseJlinkSpecBuilder()\n+                                                                   .helper(helper)\n+                                                                   .name(\"java-se-repro1\")\n+                                                                   .addModule(javaSeModule)\n+                                                                   .validatingModule(javaSeModule)\n+                                                                   .build());\n+\n+        \/\/ create another java.se version using jmod-less approach\n+        Path javaSEJmodLess2 = createJavaImageJmodLess(new BaseJlinkSpecBuilder()\n+                                                                   .helper(helper)\n+                                                                   .name(\"java-se-repro2\")\n+                                                                   .addModule(javaSeModule)\n+                                                                   .validatingModule(javaSeModule)\n+                                                                   .build());\n+        if (Files.mismatch(javaSEJmodLess1.resolve(\"lib\").resolve(\"modules\"),\n+                           javaSEJmodLess2.resolve(\"lib\").resolve(\"modules\")) != -1L) {\n+            throw new RuntimeException(\"jlink producing inconsistent result for \" + javaSeModule + \" (jmod-less)\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/JavaSEReproducibleTest.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Verify jlink fails by default when jlinking in jmod-less mode and files have been changed\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g ModifiedFilesExitTest\n+ *\/\n+public class ModifiedFilesExitTest extends ModifiedFilesTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        ModifiedFilesExitTest test = new ModifiedFilesExitTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    String initialImageName() {\n+        return \"java-base-jlink-with-mod-exit\";\n+    }\n+\n+    @Override\n+    void testAndAssert(Path modifiedFile, Helper helper, Path initialImage)\n+            throws Exception {\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer t) {\n+                return t.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(initialImage)\n+                                .name(\"java-base-jlink-with-mod-exit-target\")\n+                                .addModule(\"java.base\")\n+                                .validatingModule(\"java.base\")\n+                                .build(), handler, exitFailPred);\n+        OutputAnalyzer analyzer = handler.analyzer();\n+        if (analyzer.getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to fail due to modified file!\");\n+        }\n+        analyzer.stdoutShouldContain(modifiedFile.toString() + \" has been modified\");\n+        \/\/ Verify the error message is reasonable\n+        analyzer.stdoutShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n+        analyzer.stdoutShouldNotContain(\"java.lang.IllegalArgumentException\");\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesExitTest.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Properties;\n+\n+import tests.Helper;\n+\n+public abstract class ModifiedFilesTest extends AbstractJmodLessTest {\n+\n+    abstract String initialImageName();\n+    abstract void testAndAssert(Path modifiedFile, Helper helper, Path initialImage) throws Exception;\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        Path initialImage = createJavaImageJmodLess(new BaseJlinkSpecBuilder()\n+                \/\/.name(\"java-base-jlink-with-mod\")\n+                .name(initialImageName())\n+                .addModule(\"java.base\")\n+                .addModule(\"jdk.jlink\")\n+                .validatingModule(\"java.base\")\n+                .addExtraOption(\"--unlock-run-image\")\n+                .helper(helper)\n+                .build());\n+\n+        Path netPropertiesFile = modifyFileInImage(initialImage);\n+\n+        testAndAssert(netPropertiesFile, helper, initialImage);\n+    }\n+\n+    protected Path modifyFileInImage(Path jmodLessImg)\n+            throws IOException, AssertionError {\n+        \/\/ modify net.properties config file\n+        Path netPropertiesFile = jmodLessImg.resolve(\"conf\").resolve(\"net.properties\");\n+        Properties props = new Properties();\n+        try (InputStream is = Files.newInputStream(netPropertiesFile)) {\n+            props.load(is);\n+        }\n+        String prevVal = (String)props.put(\"java.net.useSystemProxies\", Boolean.TRUE.toString());\n+        if (prevVal == null || Boolean.getBoolean(prevVal) != false) {\n+            throw new AssertionError(\"Expected previous value to be false!\");\n+        }\n+        try (OutputStream out = Files.newOutputStream(netPropertiesFile)) {\n+            props.store(out, \"Modified net.properties file!\");\n+        }\n+        return netPropertiesFile;\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Verify warnings are being produced when jlinking in jmod-less mode and files have been changed\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g ModifiedFilesWarningTest\n+ *\/\n+public class ModifiedFilesWarningTest extends ModifiedFilesTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        ModifiedFilesWarningTest test = new ModifiedFilesWarningTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    String initialImageName() {\n+        return \"java-base-jlink-with-mod-warn\";\n+    }\n+\n+    @Override\n+    void testAndAssert(Path modifiedFile, Helper helper, Path initialImage) throws Exception {\n+        CapturingHandler handler = new CapturingHandler();\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(initialImage)\n+                                .name(\"java-base-jlink-with-mod-warn-target\")\n+                                .addModule(\"java.base\")\n+                                .validatingModule(\"java.base\")\n+                                .extraJlinkOpt(\"--unlock-run-image\") \/\/ only generate a warning\n+                                .build(), handler);\n+        OutputAnalyzer out = handler.analyzer();\n+        \/\/ verify we get the warning message\n+        out.stderrShouldMatch(\"WARNING: .* has been modified\");\n+        out.stderrShouldNotContain(\"java.lang.IllegalArgumentException\");\n+        out.stderrShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesWarningTest.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Verify that a jlink unsing the run-image only is single-hop only\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g MultiHopTest\n+ *\/\n+public class MultiHopTest extends AbstractJmodLessTest {\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        Path jdkJlinkJmodless = createJDKJlinkJmodLess(helper, \"jdk.jlink-multi-hop1\");\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer a) {\n+                return a.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(jdkJlinkJmodless)\n+                                .name(\"jdk-jlink-multi-hop1-target\")\n+                                .addModule(\"java.base\")\n+                                .validatingModule(\"java.base\")\n+                                .build(), handler, exitFailPred);\n+        OutputAnalyzer analyzer = handler.analyzer();\n+        if (analyzer.getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to fail due to multi-hop (hop 2)\");\n+        }\n+        String expectedMsg = \"Module path to the JDK packaged modules must be specified. \" +\n+                \"Run-time image based linking is not supported as $java.home was already created from a run-time image.\";\n+        analyzer.stdoutShouldContain(expectedMsg);\n+        analyzer.stdoutShouldNotContain(\"Exception\"); \/\/ ensure error message is sane\n+    }\n+\n+    private Path createJDKJlinkJmodLess(Helper helper, String name) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder();\n+        builder.helper(helper)\n+               .name(name)\n+               .addModule(\"jdk.jlink\")\n+               .validatingModule(\"java.base\");\n+        return createJavaImageJmodLess(builder.build());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        MultiHopTest test = new MultiHopTest();\n+        test.run();\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/MultiHopTest.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import tests.Helper;\n+import tests.JImageGenerator;\n+import tests.JImageHelper;\n+\n+\/*\n+ * @test\n+ * @summary Compare packaged-modules jlink with a jmod-less jlink to produce the same result\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g PackagedModulesVsJmodLessTest\n+ *\/\n+public class PackagedModulesVsJmodLessTest extends AbstractJmodLessTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        PackagedModulesVsJmodLessTest test = new PackagedModulesVsJmodLessTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        \/\/ create a java.se using jmod-less approach\n+        Path javaSEJmodLess = createJavaImageJmodLess(new BaseJlinkSpecBuilder()\n+                                                            .helper(helper)\n+                                                            .name(\"java-se-jmodless\")\n+                                                            .addModule(\"java.se\")\n+                                                            .validatingModule(\"java.se\")\n+                                                            .addExtraOption(\"--unlock-run-image\")\n+                                                            .build());\n+\n+        \/\/ create a java.se using packaged modules (jmod-full)\n+        Path javaSEJmodFull = JImageGenerator.getJLinkTask()\n+                .output(helper.createNewImageDir(\"java-se-jmodfull\"))\n+                .addMods(\"java.se\").call().assertSuccess();\n+\n+        compareRecursively(javaSEJmodLess, javaSEJmodFull);\n+    }\n+\n+    \/\/ Visit all files in the given directories checking that they're byte-by-byte identical\n+    private static void compareRecursively(Path javaSEJmodLess,\n+            Path javaSEJmodFull) throws IOException, AssertionError {\n+        FilesCapturingVisitor jmodFullVisitor = new FilesCapturingVisitor(javaSEJmodFull);\n+        FilesCapturingVisitor jmodLessVisitor = new FilesCapturingVisitor(javaSEJmodLess);\n+        Files.walkFileTree(javaSEJmodFull, jmodFullVisitor);\n+        Files.walkFileTree(javaSEJmodLess, jmodLessVisitor);\n+        List<String> jmodFullFiles = jmodFullVisitor.filesVisited();\n+        List<String> jmodLessFiles = jmodLessVisitor.filesVisited();\n+        Collections.sort(jmodFullFiles);\n+        Collections.sort(jmodLessFiles);\n+\n+        if (jmodFullFiles.size() != jmodLessFiles.size()) {\n+            throw new AssertionError(String.format(\"Size of files different for jmod-less (%d) vs jmod-full (%d) java.se jlink\", jmodLessFiles.size(), jmodFullFiles.size()));\n+        }\n+        String jimageFile = Path.of(\"lib\").resolve(\"modules\").toString();\n+        \/\/ Compare all files except the modules image\n+        for (int i = 0; i < jmodFullFiles.size(); i++) {\n+            String jmodFullPath = jmodFullFiles.get(i);\n+            String jmodLessPath = jmodLessFiles.get(i);\n+            if (!jmodFullPath.equals(jmodLessPath)) {\n+                throw new AssertionError(String.format(\"jmod-full path (%s) != jmod-less path (%s)\", jmodFullPath, jmodLessPath));\n+            }\n+            if (jmodFullPath.equals(jimageFile)) {\n+                continue;\n+            }\n+            Path a = javaSEJmodFull.resolve(Path.of(jmodFullPath));\n+            Path b = javaSEJmodLess.resolve(Path.of(jmodLessPath));\n+            if (Files.mismatch(a, b) != -1L) {\n+                handleFileMismatch(a, b);\n+            }\n+        }\n+        \/\/ Compare jimage contents by iterating its entries and comparing their\n+        \/\/ paths and content bytes\n+        \/\/\n+        \/\/ Note: The files aren't byte-by-byte comparable (probably due to string hashing\n+        \/\/ and offset differences in container bytes)\n+        Path jimageJmodLess = javaSEJmodLess.resolve(Path.of(\"lib\")).resolve(Path.of(\"modules\"));\n+        Path jimageJmodFull = javaSEJmodFull.resolve(Path.of(\"lib\")).resolve(Path.of(\"modules\"));\n+        List<String> jimageContentJmodLess = JImageHelper.listContents(jimageJmodLess);\n+        List<String> jimageContentJmodFull = JImageHelper.listContents(jimageJmodFull);\n+        if (jimageContentJmodLess.size() != jimageContentJmodFull.size()) {\n+            throw new AssertionError(String.format(\"Size of jimage content differs for jmod-less (%d) v. jmod-full (%d)\", jimageContentJmodLess.size(), jimageContentJmodFull.size()));\n+        }\n+        for (int i = 0; i < jimageContentJmodFull.size(); i++) {\n+            if (!jimageContentJmodFull.get(i).equals(jimageContentJmodLess.get(i))) {\n+                throw new AssertionError(String.format(\"Jimage content differs at index %d: jmod-full was: '%s' jmod-less was: '%s'\",\n+                                                       i,\n+                                                       jimageContentJmodFull.get(i),\n+                                                       jimageContentJmodLess.get(i)\n+                                                       ));\n+            }\n+            String loc = jimageContentJmodFull.get(i);\n+            if (isTreeInfoResource(loc)) {\n+                \/\/ Skip container bytes as those are offsets to the content\n+                \/\/ of the container which might be different between jlink runs.\n+                continue;\n+            }\n+            byte[] resBytesFull = JImageHelper.getLocationBytes(loc, jimageJmodFull);\n+            byte[] resBytesLess = JImageHelper.getLocationBytes(loc, jimageJmodLess);\n+            if (resBytesFull.length != resBytesLess.length || Arrays.mismatch(resBytesFull, resBytesLess) != -1) {\n+                throw new AssertionError(\"Content bytes mismatch for \" + loc);\n+            }\n+        }\n+    }\n+\n+    private static boolean isTreeInfoResource(String path) {\n+        return path.startsWith(\"\/packages\") || path.startsWith(\"\/modules\");\n+    }\n+\n+    private static void handleFileMismatch(Path a, Path b) {\n+        throw new AssertionError(\"Files mismatch: \" + a + \" vs. \" + b);\n+    }\n+\n+    static class FilesCapturingVisitor extends SimpleFileVisitor<Path> {\n+        private final Path basePath;\n+        private final List<String> filePaths = new ArrayList<>();\n+        public FilesCapturingVisitor(Path basePath) {\n+            this.basePath = basePath;\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) {\n+            Path relative = basePath.relativize(path);\n+            filePaths.add(relative.toString());\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        List<String> filesVisited() {\n+            return filePaths;\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/PackagedModulesVsJmodLessTest.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Test --save-jlink-argfiles plugin in jmod-less mode\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g SaveJlinkOptsTest\n+ *\/\n+public class SaveJlinkOptsTest extends AbstractJmodLessTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        SaveJlinkOptsTest test = new SaveJlinkOptsTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        String vendorVersion = \"jmodless\";\n+        Path jlinkOptsFile = createJlinkOptsFile(List.of(\"--compress\", \"zip-6\", \"--vendor-version\", vendorVersion));\n+        Path finalImage = createJavaImageJmodLess(new BaseJlinkSpecBuilder()\n+                                                        .addExtraOption(\"--save-jlink-argfiles\")\n+                                                        .addExtraOption(jlinkOptsFile.toAbsolutePath().toString())\n+                                                        .addModule(\"jdk.jlink\")\n+                                                        .name(\"java-base-with-jlink-opts\")\n+                                                        .helper(helper)\n+                                                        .validatingModule(\"java.base\")\n+                                                        .build());\n+        verifyVendorVersion(finalImage, vendorVersion);\n+    }\n+\n+    \/**\n+     * Create a temporary file for use via --save-jlink-argfiles-file\n+     * @param options The options to save in the file.\n+     * @return The path to the temporary file\n+     *\/\n+    private static Path createJlinkOptsFile(List<String> options) throws Exception {\n+        Path tmpFile = Files.createTempFile(\"JLinkTestJmodsLess\", \"jlink-options-file\");\n+        tmpFile.toFile().deleteOnExit();\n+        String content = options.stream().collect(Collectors.joining(\"\\n\"));\n+        Files.writeString(tmpFile, content, StandardOpenOption.TRUNCATE_EXISTING);\n+        return tmpFile;\n+    }\n+\n+    private void verifyVendorVersion(Path finalImage, String vendorVersion) throws Exception {\n+        OutputAnalyzer out = runJavaCmd(finalImage, List.of(\"--version\"));\n+        String stdOut = out.getStdout();\n+        if (!stdOut.contains(vendorVersion)) {\n+            if (DEBUG) {\n+                System.err.println(stdOut);\n+            }\n+            throw new AssertionError(\"Expected vendor version '\" + vendorVersion + \"' in jlinked image.\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/SaveJlinkOptsTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import tests.Helper;\n+import tests.JImageValidator;\n+\n+\/*\n+ * @test\n+ * @summary Test appropriate handling of generated SystemModules* classes in run-time image link mode\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g SystemModulesTest\n+ *\/\n+public class SystemModulesTest extends AbstractJmodLessTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        SystemModulesTest test = new SystemModulesTest();\n+        test.run();\n+    }\n+\n+    \/*\n+     * SystemModule classes are module specific. If the jlink is based on the\n+     * modules image, then earlier generated SystemModule classes shall not get\n+     * propagated.\n+     *\/\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        \/\/ create an image with a module containing a main entrypoint (jdk.httpserver),\n+        \/\/ thus producing the SystemModules$0.class. Add jdk.jdwp.agent as a module which\n+        \/\/ isn't resolved by default, so as to generate SystemModules$default.class\n+        Path javaseJmodless = createJavaImageJmodLess(new BaseJlinkSpecBuilder()\n+                                                            .helper(helper)\n+                                                            .name(\"httpserver-jlink-jmodless-derived\")\n+                                                            .addModule(\"jdk.httpserver\")\n+                                                            .addModule(\"jdk.jdwp.agent\")\n+                                                            .addModule(\"jdk.jlink\")\n+                                                            .validatingModule(\"java.base\")\n+                                                            .addExtraOption(\"--unlock-run-image\")\n+                                                            .build());\n+        \/\/ Verify that SystemModules$0.class etc. are there\n+        JImageValidator.validate(javaseJmodless.resolve(\"lib\").resolve(\"modules\"),\n+                                    List.of(\"\/java.base\/jdk\/internal\/module\/SystemModules$default.class\",\n+                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$0.class\"), Collections.emptyList());\n+        \/\/ Finally attempt another jmodless link reducing modules to java.base only,\n+        \/\/ no longer expecting SystemModules$0.class\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(javaseJmodless)\n+                                .name(\"java.base-from-jdk-httpserver-derived\")\n+                                .addModule(\"java.base\")\n+                                .expectedLocation(\"\/java.base\/jdk\/internal\/module\/SystemModulesMap.class\")\n+                                .expectedLocation(\"\/java.base\/jdk\/internal\/module\/SystemModules.class\")\n+                                .expectedLocation(\"\/java.base\/jdk\/internal\/module\/SystemModules$all.class\")\n+                                .unexpectedLocation(\"\/java.base\/jdk\/internal\/module\/SystemModules$0.class\")\n+                                .unexpectedLocation(\"\/java.base\/jdk\/internal\/module\/SystemModules$default.class\")\n+                                .validatingModule(\"java.base\")\n+                                .build());\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/SystemModulesTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+import tests.JImageValidator;\n+\n+\/*\n+ * @test\n+ * @summary Test SystemModules handling of java --list-modules with system modules\n+ *          not consistently enabled\/disabled.\n+ * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g SystemModulesTest2\n+ *\/\n+public class SystemModulesTest2 extends AbstractJmodLessTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        SystemModulesTest2 test = new SystemModulesTest2();\n+        test.run();\n+    }\n+\n+    \/*\n+     * SystemModule classes are module specific and SystemModulesMap gets generated\n+     * for each link. This turns out to be a problem if we perform an initial\n+     * jmod-full link with system-modules plugin enabled, which in turn would\n+     * change the SystemModulesMap in the run time image that the final run-time\n+     * based link will then use to generate a link only using java.base. In that\n+     * case, we cannot use the fast path and we ought to use the slow path in\n+     * order to avoid CNFEs.\n+     *\/\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        \/\/ Create an image with two modules, so that SystemModulesMap gets generated\n+        \/\/ for it as system-modules plugin is auto-enabled. Later, reduce the set\n+        \/\/ of modules to only java.base with system-modules plugin disabled.\n+        Path javaJmodless = createJavaImageJmodLess(new BaseJlinkSpecBuilder()\n+                                                            .helper(helper)\n+                                                            .name(\"jlink-jmodless-sysmod2\")\n+                                                            .addModule(\"jdk.httpserver\")\n+                                                            .addModule(\"jdk.jlink\")\n+                                                            .validatingModule(\"java.base\")\n+                                                            .addExtraOption(\"--unlock-run-image\")\n+                                                            .build());\n+        \/\/ Verify that SystemModules$all.class is there\n+        JImageValidator.validate(javaJmodless.resolve(\"lib\").resolve(\"modules\"),\n+                                    List.of(\"\/java.base\/jdk\/internal\/module\/SystemModules$all.class\"), Collections.emptyList());\n+        \/\/ The following jlink using --disable-plugin system-modules ought to\n+        \/\/ fail, since the SystemModulesMap class would be incorrect if not\n+        \/\/ re-generated (due to disabled system-modules plugin).\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer t) {\n+                return t.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(javaJmodless)\n+                                .name(\"java.base-from-sysmod2-derived\")\n+                                .addModule(\"java.base\")\n+                                .extraJlinkOpt(\"--disable-plugin\")\n+                                .extraJlinkOpt(\"system-modules\")\n+                                .validatingModule(\"java.base\")\n+                                .build(), handler, exitFailPred);\n+        OutputAnalyzer analyzer = handler.analyzer();\n+        if (analyzer.getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to fail due to disable system-modules plugin!\");\n+        }\n+        analyzer.stdoutShouldContain(\"Disabling system-modules plugin for a run-time image based link is not allowed.\");\n+        \/\/ Verify the error message is reasonable\n+        analyzer.stdoutShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n+        analyzer.stdoutShouldNotContain(\"java.lang.IllegalArgumentException\");\n+        analyzer.stdoutShouldNotContain(\"java.lang.IllegalStateException\");\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/SystemModulesTest2.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -32,0 +32,3 @@\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n@@ -37,3 +40,0 @@\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.Test;\n-\n@@ -112,0 +112,12 @@\n+    @Test\n+    public static void basicJlinkJavaBase() throws IOException {\n+        Result result = JImageGenerator.getJLinkTask()\n+                .modulePath(helper.defaultModulePath())\n+                .output(helper.createNewImageDir(\"java-base-basic\"))\n+                .addMods(\"java.base\")\n+                .call();\n+\n+        Path image = result.assertSuccess();\n+        validateJLISpeciesClasses(image);\n+    }\n+\n@@ -134,0 +146,20 @@\n+    private static void validateJLISpeciesClasses(Path image) throws IOException {\n+        JImageValidator.validate(image.resolve(\"lib\").resolve(\"modules\"),\n+                List.of(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_D.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_DL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_I.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_IL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LJ.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLJ.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLJ.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLLL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLLL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLLLL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLLLLL.class\"),\n+                List.of());\n+    }\n+\n","filename":"test\/jdk\/tools\/jlink\/plugins\/GenerateJLIClassesPluginTest.java","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package tests;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import jdk.internal.jimage.BasicImageReader;\n+import jdk.internal.jimage.ImageLocation;\n+\n+\/**\n+ *\n+ * JDK Modular image iterator\n+ *\/\n+public class JImageHelper {\n+\n+    private JImageHelper() {\n+        \/\/ Don't instantiate\n+    }\n+\n+    public static List<String> listContents(Path jimage) throws IOException {\n+        try(BasicImageReader reader = BasicImageReader.open(jimage)) {\n+            List<String> entries = new ArrayList<>();\n+            for (String s : reader.getEntryNames()) {\n+                entries.add(s);\n+            }\n+            Collections.sort(entries);\n+            return entries;\n+        }\n+    }\n+\n+    public static byte[] getLocationBytes(String location, Path jimage) throws IOException {\n+        try(BasicImageReader reader = BasicImageReader.open(jimage)) {\n+            ImageLocation il = reader.findLocation(location);\n+            byte[] r = reader.getResource(il);\n+            if (r == null) {\n+                throw new IllegalStateException(String.format(\"bytes for %s not found!\", location));\n+            }\n+            return r;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/lib\/tests\/JImageHelper.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"}]}