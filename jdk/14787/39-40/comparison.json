{"files":[{"patch":"@@ -595,1 +595,2 @@\n-  # Configure option for runtime image based linkable jimage.\n+  # Configure option for building a JDK that is suitable for linking from the\n+  # run-time image without JMODs.\n@@ -597,3 +598,3 @@\n-  # Determines whether or not a run-time linkable JDK image is being\n-  # produced from the product image. If set to 'true, changes the *default*\n-  # of packaged modules to 'false'.\n+  # Determines whether or not a suitable run-time image is being produced from\n+  # packaged modules. If set to 'true, changes the *default* of packaged\n+  # modules to 'false'.\n@@ -603,2 +604,2 @@\n-      DESC: [enable JDK linkable runtime],\n-      CHECKING_MSG: [whether or not JDK linkable runtime should be produced])\n+      DESC: [enable a JDK build suitable for linking from the run-time image],\n+      CHECKING_MSG: [whether or not a JDK suitable for linking from the run-time image should be produced])\n@@ -617,2 +618,2 @@\n-  # We keep packaged modules in JDK image unless a runtime linkable image\n-  # is requested.\n+  # We keep packaged modules in the JDK image unless --enable-linkable-runtime is\n+  # requested.\n@@ -623,1 +624,1 @@\n-      DEFAULT_DESC: [enabled by default unless --enable-runtime-link-image is set],\n+      DEFAULT_DESC: [enabled by default unless --enable-linkable-runtime is set],\n","filename":"make\/autoconf\/jdk-options.m4","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-import static jdk.tools.jlink.internal.JlinkTask.DIFF_PATTERN;\n-import static jdk.tools.jlink.internal.JlinkTask.RESPATH_PATTERN;\n+import static jdk.tools.jlink.internal.LinkableRuntimeImage.DIFF_PATTERN;\n+import static jdk.tools.jlink.internal.LinkableRuntimeImage.RESPATH_PATTERN;\n@@ -86,0 +86,2 @@\n+    private static final byte[] EMPTY_RESOURCE_BYTES = new byte[] {};\n+\n@@ -87,2 +89,0 @@\n-    \/\/ This resource is being used in JLinkTask which passes its contents to\n-    \/\/ JRTArchive for further processing.\n@@ -91,2 +91,0 @@\n-    private static final byte[] EMPTY_RESOURCE_BYTES = new byte[] {};\n-\n@@ -101,34 +99,0 @@\n-    \/**\n-     * Create an executable image based on a set of archives and a given\n-     * plug-in stack and the native byte order. Note: this is will not create\n-     * a linkable JDK runtime.\n-     *\n-     * @param archives The set of input archives\n-     * @param plugins The plug-in stack to apply to the input\n-     * @return The executable image\n-     * @throws IOException\n-     *\/\n-    public static ExecutableImage create(Set<Archive> archives,\n-            ImagePluginStack plugins)\n-            throws IOException {\n-        return ImageFileCreator.create(archives, ByteOrder.nativeOrder(),\n-                plugins, false);\n-    }\n-\n-    \/**\n-     * Create an executable image based on a set of archives and an empty\n-     * plug-in stack and a given byte order. Note: this is will not create\n-     * a linkable JDK runtime.\n-     *\n-     * @param archives The set of input archives\n-     * @param byteOrder The required byte order of the output image.\n-     * @return The executable image for the given byte order.\n-     * @throws IOException\n-     *\/\n-    public static ExecutableImage create(Set<Archive> archives,\n-            ByteOrder byteOrder)\n-            throws IOException {\n-        return ImageFileCreator.create(archives, byteOrder,\n-                new ImagePluginStack(), false);\n-    }\n-\n@@ -137,2 +101,3 @@\n-     * plugin stack for a given byte order. It optionally generates a linkable\n-     * JDK runtime if {@code generateRuntimeImage} is set to {@code true}.\n+     * plugin stack for a given byte order. It optionally generates a runtime\n+     * that can be used for linking from the run-time image if\n+     * {@code generateRuntimeImage} is set to {@code true}.\n@@ -143,2 +108,2 @@\n-     * @param generateRuntimeImage Whether or not a linkable JDK runtime should\n-     *        get created.\n+     * @param generateRuntimeImage if a runtime suitable for linking from the\n+     *        run-time image should get created.\n@@ -160,1 +125,1 @@\n-            \/\/Close all archives\n+            \/\/ Close all archives\n@@ -241,1 +206,1 @@\n-            e.getReason().printStackTrace();\n+            e.printStackTrace();\n@@ -245,1 +210,1 @@\n-        throw new IOException(e.getReason().getMessage());\n+        throw new IOException(e.getMessage());\n@@ -250,1 +215,2 @@\n-     * optionally creating a linkable JDK runtime.\n+     * optionally creating a runtime that can be used for linking from the\n+     * run-time image\n@@ -257,2 +223,2 @@\n-     * @param generateRuntimeImage Whether or not a linkable JDK runtime should\n-     *                             be generated.\n+     * @param generateRuntimeImage if a runtime suitable for linking from the\n+     *        run-time image should get created.\n@@ -272,2 +238,1 @@\n-                \/\/ Keep track of non-modules image resources for\n-                \/\/ linkable JDK runtimes\n+                \/\/ Keep track of non-modules resources for linking from a run-time image\n@@ -279,3 +244,3 @@\n-                resultResources = addRessourceDiffFiles(allContent.resourcePool(),\n-                                                        resultResources,\n-                                                        writer);\n+                resultResources = addResourceDiffFiles(allContent.resourcePool(),\n+                                                       resultResources,\n+                                                       writer);\n@@ -289,2 +254,2 @@\n-            \/\/ might be thrown in the run-image link case. Populate the\n-            \/\/ actual reason.\n+            \/\/ Might be thrown when linking from the current run-time image.\n+            \/\/ Populate the actual reason.\n@@ -294,1 +259,1 @@\n-            throw re.getReason();\n+            throw re;\n@@ -357,1 +322,2 @@\n-     * Support for linkable JDK runtimes.\n+     * Support for creating a runtime suitable for linking from the run-time\n+     * image.\n@@ -371,2 +337,2 @@\n-    private static ResourcePool addRessourceDiffFiles(ResourcePool jmodContent,\n-            ResourcePool resultContent, BasicImageWriter writer) {\n+    private static ResourcePool addResourceDiffFiles(ResourcePool jmodContent,\n+                                                     ResourcePool resultContent, BasicImageWriter writer) {\n@@ -435,1 +401,1 @@\n-                \/\/ pool view, but which don't themselves have a diff to packaged\n+                \/\/ pool view that don't themselves have a diff to packaged\n@@ -453,3 +419,4 @@\n-     * Support for linkable JDK runtimes. Adds meta-data files for resources not\n-     * in the lib\/modules file of the JDK. That is, mapping files for which\n-     * on-disk files belong to which module.\n+     * Support for creating runtimes that can be used for linking from the\n+     * run-time image. Adds meta-data files for resources not in the lib\/modules\n+     * file of the JDK. That is, mapping files for which on-disk files belong to\n+     * which module.\n@@ -457,3 +424,5 @@\n-     * @param resultResources The original resources which serve as the basis\n-     *                        for generating the meta-data files.\n-     * @param writer The image writer.\n+     * @param resultResources\n+     *            The original resources which serve as the basis for generating\n+     *            the meta-data files.\n+     * @param writer\n+     *            The image writer.\n@@ -478,2 +447,3 @@\n-     * Support for linkable JDK runtimes. Adds the given mapping of files\n-     * as a meta-data file to the given resource pool.\n+     * Support for creating runtimes that can be used for linking from the\n+     * run-time image. Adds the given mapping of files as a meta-data file to\n+     * the given resource pool.\n@@ -481,4 +451,7 @@\n-     * @param resultResources The resource pool to add files to.\n-     * @param nonClassResEntries The per module mapping for which to create\n-     *                           the meta-data files for.\n-     * @param writer The image writer.\n+     * @param resultResources\n+     *            The resource pool to add files to.\n+     * @param nonClassResEntries\n+     *            The per module mapping for which to create the meta-data files\n+     *            for.\n+     * @param writer\n+     *            The image writer.\n@@ -501,1 +474,1 @@\n-                \/\/ pool view, but which don't themselves contain native resources\n+                \/\/ pool view that don't themselves contain native resources\n@@ -515,3 +488,4 @@\n-     * Support for linkable JDK runtimes. Generates a per module mapping of\n-     * files not part of the modules image (jimage). This mapping is needed so\n-     * as to know which files of the installed JDK belong to which module.\n+     * Support for creating runtimes that can be used for linking from the\n+     * run-time image. Generates a per module mapping of files not part of the\n+     * modules image (jimage). This mapping is needed so as to know which files\n+     * of the installed JDK belong to which module.\n@@ -519,4 +493,4 @@\n-     * @param resultResources The resources from which the mapping gets\n-     *        generated\n-     * @return A mapping with the module names as keys and the list of files\n-     *         not part of the modules image (jimage) as values.\n+     * @param resultResources\n+     *            The resources from which the mapping gets generated\n+     * @return A mapping with the module names as keys and the list of files not\n+     *         part of the modules image (jimage) as values.\n@@ -524,2 +498,1 @@\n-    private static Map<String, List<String>> recordAndFilterEntries(\n-            ResourcePool resultResources) {\n+    private static Map<String, List<String>> recordAndFilterEntries(ResourcePool resultResources) {\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageFileCreator.java","additions":57,"deletions":84,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import static jdk.tools.jlink.internal.JlinkTask.RESPATH_PATTERN;\n+import static jdk.tools.jlink.internal.LinkableRuntimeImage.RESPATH_PATTERN;\n@@ -45,1 +45,0 @@\n-import java.util.HashMap;\n@@ -50,0 +49,1 @@\n+import java.util.function.Function;\n@@ -62,3 +62,3 @@\n- * An archive implementation based on the JDK's modules image (lib\/modules,\n- * or jimage) as well as associated files from the filesystem of the JDK\n- * installation.\n+ * An archive implementation based on the JDK's run-time image. That is, classes\n+ * and resources from the modules image (lib\/modules, or jimage) and other\n+ * associated files from the filesystem of the JDK installation.\n@@ -104,1 +104,2 @@\n-        this.resDiff = prepareDiffMap(Objects.requireNonNull(perModDiff));\n+        this.resDiff = Objects.requireNonNull(perModDiff).stream()\n+                            .collect(Collectors.toMap(ResourceDiff::getName, Function.identity()));\n@@ -125,1 +126,1 @@\n-            throw e.getReason();\n+            throw e;\n@@ -159,2 +160,2 @@\n-            \/\/ Add classes\/resources from image module,\n-            \/\/ patched with the runtime image link diff\n+            \/\/ Add classes\/resources from the run-time image,\n+            \/\/ patched with the run-time image diff\n@@ -163,13 +164,13 @@\n-                                       String lookupKey = String.format(\"\/%s\/%s\", module, i);\n-                                       ResourceDiff rd = resDiff.get(lookupKey);\n-                                       \/\/ Filter all resources with a resource diff\n-                                       \/\/ that are of kind MODIFIED.\n-                                       \/\/ Note that REMOVED won't happen since in\n-                                       \/\/ that case the module listing won't have\n-                                       \/\/ the resource anyway.\n-                                       \/\/ Note as well that filter removes files\n-                                       \/\/ of kind ADDED. Those files are not in\n-                                       \/\/ the packaged modules, so ought not to\n-                                       \/\/ get returned from the pipeline.\n-                                       return (rd == null ||\n-                                               rd.getKind() == ResourceDiff.Kind.MODIFIED);\n+                                           String lookupKey = String.format(\"\/%s\/%s\", module, i);\n+                                           ResourceDiff rd = resDiff.get(lookupKey);\n+                                           \/\/ Filter all resources with a resource diff\n+                                           \/\/ that are of kind MODIFIED.\n+                                           \/\/ Note that REMOVED won't happen since in\n+                                           \/\/ that case the module listing won't have\n+                                           \/\/ the resource anyway.\n+                                           \/\/ Note as well that filter removes files\n+                                           \/\/ of kind ADDED. Those files are not in\n+                                           \/\/ the packaged modules, so ought not to\n+                                           \/\/ get returned from the pipeline.\n+                                           return (rd == null ||\n+                                                   rd.getKind() == ResourceDiff.Kind.MODIFIED);\n@@ -178,6 +179,6 @@\n-                                               String lookupKey = String.format(\"\/%s\/%s\", module, s);\n-                                               return new JRTArchiveFile(JRTArchive.this, s,\n-                                                       EntryType.CLASS_OR_RESOURCE,\n-                                                       null \/* hashOrTarget *\/,\n-                                                       false \/* symlink *\/,\n-                                                       resDiff.get(lookupKey));\n+                                           String lookupKey = String.format(\"\/%s\/%s\", module, s);\n+                                           return new JRTArchiveFile(JRTArchive.this, s,\n+                                                           EntryType.CLASS_OR_RESOURCE,\n+                                                           null \/* hashOrTarget *\/,\n+                                                           false \/* symlink *\/,\n+                                                           resDiff.get(lookupKey));\n@@ -185,1 +186,1 @@\n-                                   .collect(Collectors.toList()));\n+                                   .toList());\n@@ -187,1 +188,1 @@\n-            \/\/ That is, removed items in the runtime image.\n+            \/\/ That is, removed items in the run-time image.\n@@ -195,3 +196,1 @@\n-                                                 String pathWithoutModule = s.getName()\n-                                                            .substring(secondSlash + 1,\n-                                                                       s.getName().length());\n+                                                 String pathWithoutModule = s.getName().substring(secondSlash + 1);\n@@ -205,1 +204,1 @@\n-                                         .collect(Collectors.toList()));\n+                                         .toList());\n@@ -228,2 +227,1 @@\n-                                IllegalArgumentException ise = new IllegalArgumentException(msg);\n-                                throw new RuntimeImageLinkException(ise);\n+                                throw new RuntimeImageLinkException(msg);\n@@ -231,0 +229,1 @@\n+                                \/\/ System.err vs taskHelper.warning?\n@@ -243,1 +242,1 @@\n-                 .collect(Collectors.toList()));\n+                 .toList());\n@@ -281,2 +280,1 @@\n-            default -> throw new IllegalArgumentException(\n-                           \"Unknown type: \" + input);\n+            default -> throw new IllegalArgumentException(\"Unknown type: \" + input);\n@@ -303,0 +301,3 @@\n+        private static final Map<Integer, Type> typeMap = Arrays.stream(Type.values())\n+                .collect(Collectors.toMap(Type::ordinal, Function.identity()));\n+\n@@ -326,1 +327,4 @@\n-                type = Type.fromOrdinal(typeInt);\n+                type = typeMap.get(typeInt);\n+                if (type == null) {\n+                    throw new AssertionError(\"Illegal type ordinal: \" + typeInt);\n+                }\n@@ -417,1 +421,1 @@\n-    private static final String MISMATCH_FORMAT = \"%s has been modified.%n\";\n+    private static final String MISMATCH_FORMAT = \"%s has been modified%n\";\n@@ -453,4 +457,3 @@\n-                                assert diff.getName().equals(\n-                                                          String.format(\"\/%s\/%s\",\n-                                                                        archive.moduleName(),\n-                                                                        resPath));\n+                                assert diff.getName().equals(String.format(\"\/%s\/%s\",\n+                                                                           archive.moduleName(),\n+                                                                           resPath));\n@@ -472,1 +475,1 @@\n-                                                   \"--patch-module is not supported for run-time image linking.\";\n+                                                   \"--patch-module is not supported when linking from the run-time image\";\n@@ -474,2 +477,1 @@\n-                                IllegalArgumentException noModulePatch = new IllegalArgumentException(msg);\n-                                throw new RuntimeImageLinkException(noModulePatch);\n+                                throw new RuntimeImageLinkException(msg);\n@@ -496,2 +498,2 @@\n-                                                                    archive.moduleName(),\n-                                                                    resPath));\n+                                                                       archive.moduleName(),\n+                                                                       resPath));\n@@ -516,2 +518,1 @@\n-                String input = new String(inStream.readAllBytes(),\n-                                          StandardCharsets.UTF_8);\n+                String input = new String(inStream.readAllBytes(), StandardCharsets.UTF_8);\n@@ -526,2 +527,2 @@\n-            throw new InternalError(\"Failed to process run-time image resources \" +\n-                                    \" for \" + modName);\n+            throw new AssertionError(\"Failed to process resources from the run-time image\" +\n+                                    \" for module \" + modName);\n@@ -530,6 +531,0 @@\n-\n-    private static Map<String, ResourceDiff> prepareDiffMap(List<ResourceDiff> diffs) {\n-        Map<String, ResourceDiff> resDiffsAsMap = new HashMap<>();\n-        diffs.forEach(r -> resDiffsAsMap.put(r.getName(), r));\n-        return resDiffsAsMap;\n-    }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JRTArchive.java","additions":55,"deletions":60,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-import jdk.tools.jlink.internal.runtimelink.ResourceDiff;\n+import jdk.tools.jlink.internal.runtimelink.RuntimeImageLinkException;\n@@ -92,2 +92,0 @@\n-    public static final String JLINK_MOD_NAME = \"jdk.jlink\";\n-\n@@ -193,1 +191,2 @@\n-        \/\/ option for generating linkable JDK runtimes (at JDK build time)\n+        \/\/ option for generating a runtime that can then\n+        \/\/ be used for linking from the run-time image.\n@@ -243,4 +242,0 @@\n-    \/\/ meta-data files per module for linkable JDK runtimes\n-    public static final String RESPATH_PATTERN = \"jdk\/tools\/jlink\/internal\/runtimelink\/fs_%s_files\";\n-    \/\/ The diff files per module for linkable JDK runtimes\n-    public static final String DIFF_PATTERN = \"jdk\/tools\/jlink\/internal\/runtimelink\/diff_%s\";\n@@ -274,5 +269,1 @@\n-                \/\/ In order to be able to show the run-time image based link\n-                \/\/ capability in --help, we need to look for the delta files\n-                \/\/ in jdk.jlink\n-                boolean runtimeCapability = hasRuntimeImageLinkCap();\n-                optionsHelper.showHelp(PROGNAME, runtimeCapability);\n+                optionsHelper.showHelp(PROGNAME, LinkableRuntimeImage.isLinkableRuntime());\n@@ -321,1 +312,1 @@\n-        } catch (IllegalArgumentException | ResolutionException e) {\n+        } catch (IllegalArgumentException | ResolutionException | RuntimeImageLinkException e) {\n@@ -413,10 +404,0 @@\n-        \/\/ Setup and init actions for JDK linkable runtimes\n-        LinkableRuntimesResult result = linkableJDKRuntimesInit(finder, roots);\n-\n-        return new JlinkConfiguration(options.output,\n-                                      roots,\n-                                      result.finder,\n-                                      result.isLinkFromRuntime,\n-                                      options.ignoreModifiedRuntime,\n-                                      options.generateLinkableRuntime);\n-    }\n@@ -424,26 +405,0 @@\n-    private static record LinkableRuntimesResult(boolean isLinkFromRuntime,\n-                                                 ModuleFinder finder) {}\n-\n-    \/**\n-     * Perform sanity checks and setup actions for JDK linkable runtime links\n-     *\n-     * @param finder The module finder from packaged modules\n-     * @param roots The roots (if any) of the modules.\n-     * @return A module finder possibly adding the system modules for JDK\n-     *         linkable runtimes if and only if java.base wasn't in the provided\n-     *         module finder already. Otherwise returns the provided finder.\n-     *         In both cases finders get the set of limited modules applied if\n-     *         so requested with --limit-modules.\n-     *\n-     * @throws BadArgs if the jlink input options contain an invalid\n-     *                 combination.\n-     *\/\n-    private LinkableRuntimesResult linkableJDKRuntimesInit(ModuleFinder finder,\n-                                                           Set<String> roots)\n-        throws BadArgs {\n-        \/\/ Linkable JDK runtimes and an empty module path in conjunction\n-        \/\/ with --keep-packaged-modules doesn't make sense as we are not linking\n-        \/\/ from packaged modules to begin with.\n-        if (options.modulePath.isEmpty() && options.packagedModulesPath != null) {\n-            throw taskHelper.newBadArgs(\"err.runtime.link.packaged.mods\");\n-        }\n@@ -454,3 +409,3 @@\n-        \/\/ module path. If the module path does not include java.base, we must\n-        \/\/ have a linkable JDK runtime. In that case we take the JDK modules\n-        \/\/ from the run-time image.\n+        \/\/ module path. If the module path does not include java.base, we have\n+        \/\/ the case where we link from the run-time image. In that case, we take\n+        \/\/ the JDK modules from the run-time image (ModuleFinder.ofSystem()).\n@@ -460,1 +415,1 @@\n-            finder = combinedFinders(finder, runtimeImageFinder, options.limitMods, roots);\n+            finder = combinedFinders(runtimeImageFinder, finder, options.limitMods, roots);\n@@ -462,1 +417,13 @@\n-        return new LinkableRuntimesResult(isLinkFromRuntime, finder);\n+\n+        \/\/ --keep-packaged-modules doesn't make sense as we are not linking\n+        \/\/ from packaged modules to begin with.\n+        if (isLinkFromRuntime && options.packagedModulesPath != null) {\n+            throw taskHelper.newBadArgs(\"err.runtime.link.packaged.mods\");\n+        }\n+\n+        return new JlinkConfiguration(options.output,\n+                                      roots,\n+                                      finder,\n+                                      isLinkFromRuntime,\n+                                      options.ignoreModifiedRuntime,\n+                                      options.generateLinkableRuntime);\n@@ -479,3 +446,4 @@\n-    private ModuleFinder combinedFinders(ModuleFinder finder,\n-            ModuleFinder runtimeImageFinder, Set<String> limitMods,\n-            Set<String> roots) {\n+    private ModuleFinder combinedFinders(ModuleFinder runtimeImageFinder,\n+                                         ModuleFinder finder,\n+                                         Set<String> limitMods,\n+                                         Set<String> roots) {\n@@ -486,2 +454,2 @@\n-                Optional<ModuleReference> basic = runtimeImageFinder.find(name);\n-                if (basic.isEmpty()) {\n+                Optional<ModuleReference> mref = runtimeImageFinder.find(name);\n+                if (mref.isEmpty()) {\n@@ -490,1 +458,1 @@\n-                return basic;\n+                return mref;\n@@ -545,4 +513,4 @@\n-     * Returns a module finder of the given module path that limits\n-     * the observable modules to those in the transitive closure of\n-     * the modules specified in {@code limitMods} plus other modules\n-     * specified in the {@code roots} set.\n+     * Returns a module finder of the given module path or the system modules\n+     * if the module path is empty that limits the observable modules to those\n+     * in the transitive closure of the modules specified in {@code limitMods}\n+     * plus other modules specified in the {@code roots} set.\n@@ -644,1 +612,1 @@\n-        \/\/ Perform some sanity checks for linkable JDK runtimes\n+        \/\/ Perform some sanity checks for linking from the run-time image\n@@ -646,1 +614,14 @@\n-            sanityChecksLinkableJDKRuntime(log, cf, verbose);\n+            if (!LinkableRuntimeImage.isLinkableRuntime()) {\n+                String msg = taskHelper.getMessage(\"err.runtime.link.not.linkable.runtime\");\n+                throw new IllegalArgumentException(msg);\n+            }\n+            \/\/ Do not permit linking from run-time image and also including jdk.jlink module\n+            if (cf.findModule(JlinkTask.class.getModule().getName()).isPresent()) {\n+                String msg = taskHelper.getMessage(\"err.runtime.link.jdk.jlink.prohibited\");\n+                throw new IllegalArgumentException(msg);\n+            }\n+\n+            \/\/ Print info message indicating linking from the run-time image\n+            if (verbose && log != null) {\n+                log.println(taskHelper.getMessage(\"runtime.link.info\"));\n+            }\n@@ -656,0 +637,1 @@\n+                                        \/\/ We have a link from run-time image when scheme is 'jrt'\n@@ -657,2 +639,1 @@\n-                                            && config.linkFromRuntimeImage() ?\n-                                                \" \" + taskHelper.getMessage(\"runtime.link.jprt.path.extra\")\n+                                                ? \" \" + taskHelper.getMessage(\"runtime.link.jprt.path.extra\")\n@@ -726,56 +707,0 @@\n-    \/**\n-     * Linkable JDK runtimes support. Perform some sanity checks if we run\n-     * jlink from the current run-time JDK image.\n-     *\n-     * @param log The log to write messages to.\n-     * @param cf The current configuration\n-     *\n-     * @throws IOException\n-     *\/\n-    private static void sanityChecksLinkableJDKRuntime(PrintWriter log,\n-                                                       Configuration cf,\n-                                                       boolean verbose) throws IOException {\n-        \/\/ Catch the case where we don't have a linkable JDK runtime. If so,\n-        \/\/ we don't have the per module resource diffs in the modules image\n-        try (InputStream inStream = getDiffInputStream()) {\n-            if (inStream == null) {\n-                \/\/ Only linkable JDK runtimes have those resources. Abort otherwise.\n-                String msg = taskHelper.getMessage(\"err.runtime.link.not.linkable.runtime\");\n-                throw new IllegalArgumentException(msg);\n-            }\n-        }\n-        \/\/ Disallow jlink runs for linkable JDK runtimes with jdk.jlink included\n-        if (cf.findModule(JLINK_MOD_NAME).isPresent()) {\n-            String msg = taskHelper.getMessage(\"err.runtime.link.jdk.jlink.prohibited\");\n-            throw new IllegalArgumentException(msg);\n-        }\n-\n-        \/\/ Print info message indicating jlink is performed on a linkable JDK\n-        \/\/ runtime\n-        if (log != null && verbose) {\n-            log.println(taskHelper.getMessage(\"runtime.link.info\"));\n-        }\n-    }\n-\n-    private static boolean hasRuntimeImageLinkCap() {\n-        try (InputStream in = getDiffInputStream()) {\n-            return in != null;\n-        } catch (IOException e) {\n-            \/\/ fall-through\n-        }\n-        return false;\n-    }\n-\n-    private static InputStream getDiffInputStream() {\n-        try {\n-            String resourceName = String.format(DIFF_PATTERN, \"java.base\");\n-            return JlinkTask.class.getModule().getResourceAsStream(resourceName);\n-        } catch (IOException e) {\n-            if (DEBUG) {\n-                System.err.println(\"Failed to get diff pattern resource\");\n-                e.printStackTrace();\n-            }\n-            return null;\n-        }\n-    }\n-\n@@ -813,1 +738,1 @@\n-        } else if (!\"jrt\".equals(path.toUri().getScheme()) && Files.isDirectory(path)) {\n+        } else if (Files.isDirectory(path) && !\"jrt\".equals(path.toUri().getScheme())) {\n@@ -815,2 +740,3 @@\n-            \/\/ enter this branch for linkable JDK runtimes where the path is\n-            \/\/ a jrt path and for the specific JDK module is a directory.\n+            \/\/ enter this branch for linking from the run-time image where the\n+            \/\/ path is a jrt path. Note that the specific module would be a\n+            \/\/ directory. I.e. Files.isDirectory() would be true.\n@@ -825,22 +751,1 @@\n-            \/\/ This is after all other archive types, since user-provided\n-            \/\/ modules might be in any of the above forms and we'd like to\n-            \/\/ support them.\n-            \/\/\n-            \/\/ For linkable JDK runtimes the modules image includes resource\n-            \/\/ diffs on a per-module bases as part of the jdk.jlink module.\n-            \/\/ See ImageFileCreator.generateJImage() where those are added at\n-            \/\/ JDK build time for linkable JDK runtimes.\n-            \/\/\n-            \/\/ Here we retrieve the per module difference file, which is\n-            \/\/ potentially empty, from the modules image and pass that on to\n-            \/\/ JRTArchive for further processing. When streaming resources from\n-            \/\/ the archive, the diff is being applied.\n-            String diffResourceName = String.format(DIFF_PATTERN, module);\n-            List<ResourceDiff> perModuleDiff = null;\n-            try (InputStream in = JlinkTask.class.getModule().getResourceAsStream(diffResourceName)){\n-                perModuleDiff = ResourceDiff.read(in);\n-            } catch (IOException e) {\n-                throw new AssertionError(\"Failure to retrieve resource diff for \" +\n-                                         \"module \" + module, e);\n-            }\n-            return new JRTArchive(module, path, !config.ignoreModifiedRuntime(), perModuleDiff);\n+            return LinkableRuntimeImage.newArchive(module, path, config.ignoreModifiedRuntime());\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":55,"deletions":150,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import jdk.tools.jlink.internal.runtimelink.ResourceDiff;\n+\n+\/**\n+ * Class that supports the feature of running jlink based on the current\n+ * run-time image.\n+ *\/\n+public class LinkableRuntimeImage {\n+\n+    \/\/ meta-data files per module for supporting linking from the run-time image\n+    public static final String RESPATH_PATTERN = \"jdk\/tools\/jlink\/internal\/runtimelink\/fs_%s_files\";\n+    \/\/ The diff files per module for supporting linking from the run-time image\n+    public static final String DIFF_PATTERN = \"jdk\/tools\/jlink\/internal\/runtimelink\/diff_%s\";\n+\n+    \/**\n+     * In order to be able to show whether or not a runtime is capable of\n+     * linking from it in {@code jlink --help} we need to look for the delta\n+     * files in the {@code jdk.jlink} module. If present we have the capability.\n+     *\n+     * @return {@code true} iff this jlink is capable of linking from the\n+     *         run-time image.\n+     *\/\n+    public static boolean isLinkableRuntime() {\n+        try (InputStream in = getDiffInputStream()) {\n+            return in != null;\n+        } catch (IOException e) {\n+            \/\/ fall-through\n+        }\n+        return false;\n+    }\n+\n+    private static InputStream getDiffInputStream() {\n+        return getDiffInputStream(\"java.base\");\n+    }\n+\n+    private static InputStream getDiffInputStream(String module) {\n+        try {\n+            String resourceName = String.format(DIFF_PATTERN, module);\n+            return LinkableRuntimeImage.class.getModule().getResourceAsStream(resourceName);\n+        } catch (IOException e) {\n+            if (JlinkTask.DEBUG) {\n+                System.err.println(\"Failed to get diff pattern resource\");\n+                e.printStackTrace();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static Archive newArchive(String module, Path path, boolean ignoreModifiedRuntime) {\n+        \/\/ Here we retrieve the per module difference file, which is\n+        \/\/ potentially empty, from the modules image and pass that on to\n+        \/\/ JRTArchive for further processing. When streaming resources from\n+        \/\/ the archive, the diff is being applied.\n+        List<ResourceDiff> perModuleDiff = null;\n+        try (InputStream in = getDiffInputStream(module)){\n+            perModuleDiff = ResourceDiff.read(in);\n+        } catch (IOException e) {\n+            throw new AssertionError(\"Failure to retrieve resource diff for \" +\n+                                     \"module \" + module, e);\n+        }\n+        return new JRTArchive(module, path, !ignoreModifiedRuntime, perModuleDiff);\n+    }\n+\n+\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/LinkableRuntimeImage.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.tools.jlink.internal.runtimelink;\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-import jdk.internal.jimage.BasicImageReader;\n-\n-public class ImageReader extends BasicImageReader implements JimageDiffGenerator.ImageResource {\n-\n-    public ImageReader(Path path) throws IOException {\n-        super(path);\n-    }\n-\n-    public static boolean isNotTreeInfoResource(String path) {\n-        return !(path.startsWith(\"\/packages\") || path.startsWith(\"\/modules\"));\n-    }\n-\n-    @Override\n-    public List<String> getEntries() {\n-        return Arrays.asList(getEntryNames()).stream()\n-                .filter(ImageReader::isNotTreeInfoResource)\n-                .sorted()\n-                .collect(Collectors.toList());\n-    }\n-\n-    @Override\n-    public byte[] getResourceBytes(String name) {\n-        return getResource(name);\n-    }\n-\n-}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/ImageReader.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -39,4 +39,6 @@\n-     * A resource used for linking jimages. Either packaged modules or\n-     * an existing JDK jimage. The canonical source, the packaged modules,\n-     * are being used to devise a delta to a JDK jimage which can then be\n-     * also used for jlink input together *with* that delta.\n+     * A resource used for linking. Either packaged modules or\n+     * packaged modules transformed to an optimized run-time image by applying\n+     * the jlink plug-in pipeline. The canonical source, the packaged modules,\n+     * are being used to devise the delta to the transformed run-time image. The\n+     * delta can can then be used for jlink input together *with* a prepared\n+     * run-time image.\n@@ -50,1 +52,13 @@\n-    public List<ResourceDiff> generateDiff(ImageResource baseImg, ImageResource optImage) throws Exception {\n+    \/**\n+     * Produce a difference between packaged modules' resources (base) and the\n+     * result of all plug-ins being applied on those resources (image).\n+     *\n+     * @param base\n+     *            The ImageResource view of unmodified resources coming from\n+     *            packaged modules.\n+     * @param image\n+     *            The ImageResource view of the jlink plug-in pipeline having\n+     *            been applied to the resources in base.\n+     * @return The list of resource differences across all modules.\n+     *\/\n+    public List<ResourceDiff> generateDiff(ImageResource base, ImageResource image) throws Exception {\n@@ -52,1 +66,1 @@\n-        Set<String> optResSet = new HashSet<>();\n+        Set<String> resources = new HashSet<>();\n@@ -54,4 +68,3 @@\n-        try (baseImg;\n-             optImage) {\n-            optResSet.addAll(optImage.getEntries());\n-            baseResources = baseImg.getEntries();\n+        try (base; image) {\n+            resources.addAll(image.getEntries());\n+            baseResources = base.getEntries();\n@@ -59,1 +72,1 @@\n-                byte[] baseBytes = baseImg.getResourceBytes(item);\n+                byte[] baseBytes = base.getResourceBytes(item);\n@@ -63,1 +76,1 @@\n-                if (!optResSet.remove(item)) {\n+                if (!resources.remove(item)) {\n@@ -76,1 +89,1 @@\n-                boolean contentEquals = Arrays.equals(baseBytes, optImage.getResourceBytes(item));\n+                boolean contentEquals = Arrays.equals(baseBytes, image.getResourceBytes(item));\n@@ -90,1 +103,1 @@\n-        for (String e: optResSet) {\n+        for (String e: resources) {\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/JimageDiffGenerator.java","additions":27,"deletions":14,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.tools.jlink.internal.runtimelink;\n-\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.lang.module.ModuleFinder;\n-import java.lang.module.ModuleReader;\n-import java.lang.module.ModuleReference;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import jdk.internal.module.ModulePath;\n-\n-@SuppressWarnings(\"try\")\n-public class JmodsReader implements JimageDiffGenerator.ImageResource {\n-\n-    private final ModuleFinder finder;\n-\n-    public JmodsReader(Path packagedModulesDir) {\n-        List<Path> pa;\n-        try {\n-            pa = Files.list(packagedModulesDir).filter(p -> !p.endsWith(\".jmod\")).collect(Collectors.toList());\n-        } catch (IOException e) {\n-            throw new IllegalStateException(\"Listing of jmods directory failed!\", e);\n-        }\n-        Path[] paths = pa.toArray(new Path[0]);\n-        this.finder = ModulePath.of(Runtime.version(), true, paths);\n-    }\n-\n-    @Override\n-    public void close() throws Exception {\n-        \/\/ nothing\n-    }\n-\n-    @Override\n-    public List<String> getEntries() {\n-        List<String> all = new ArrayList<>();\n-        try {\n-            Set<ModuleReference> allMods = finder.findAll();\n-            for (ModuleReference mRef: allMods) {\n-                String moduleName = mRef.descriptor().name();\n-                ModuleReader reader = mRef.open();\n-                List<String> perModule = reader.list().map(a -> {return \"\/\" + moduleName + \"\/\" + a;}).collect(Collectors.toList());\n-                all.addAll(perModule);\n-            }\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-        Collections.sort(all);\n-        return all;\n-    }\n-\n-    @Override\n-    public byte[] getResourceBytes(String name) {\n-        String moduleName = moduleName(name);\n-        if (moduleName == null) {\n-            throw new IllegalArgumentException(\"Module name not found in \" + name);\n-        }\n-        ModuleReference ref = finder.find(moduleName).orElseThrow();\n-        String refName = stripModuleName(name);\n-        try (ModuleReader reader = ref.open()) {\n-            return reader.open(refName).orElseThrow().readAllBytes();\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n-\n-    private String moduleName(String name) {\n-        int secondSlash = name.indexOf(\"\/\", 1);\n-        if (secondSlash != -1) {\n-            return name.substring(1, secondSlash);\n-        }\n-        return null;\n-    }\n-\n-    private String stripModuleName(String name) {\n-        int secondSlash = name.indexOf(\"\/\", 1);\n-        return name.substring(secondSlash + 1); \/\/ omit the leading slash\n-    }\n-\n-}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/JmodsReader.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -36,1 +36,0 @@\n-import java.util.stream.Collectors;\n@@ -133,0 +132,1 @@\n+                \/\/ should this be RuntimeImageLinkException?   output needs cleanup?\n@@ -144,0 +144,1 @@\n+                        \/\/ should this be RuntimeImageLinkException?  output needs cleanup?\n@@ -214,2 +215,0 @@\n-        } catch (IOException e) {\n-            throw e;\n@@ -236,1 +235,1 @@\n-            diffs = new ArrayList<>(numItems);\n+            diffs = new ArrayList<>(numItems);  \/\/ why not initialized above?  optimized size?\n@@ -240,1 +239,1 @@\n-                byte[] buf = readNumBytesFromStream(din, numBytes);\n+                byte[] buf = readBytesFromStream(din, numBytes);\n@@ -245,1 +244,1 @@\n-                    resBytes = readNumBytesFromStream(din, numBytes);\n+                    resBytes = readBytesFromStream(din, numBytes);\n@@ -259,1 +258,1 @@\n-    private static byte[] readNumBytesFromStream(DataInputStream din, int numBytes) throws IOException {\n+    private static byte[] readBytesFromStream(DataInputStream din, int numBytes) throws IOException {\n@@ -272,1 +271,1 @@\n-        for (ResourceDiff diff: diffs.stream().sorted().collect(Collectors.toList())) {\n+        for (ResourceDiff diff: diffs.stream().sorted().toList()) {\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/ResourceDiff.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.tools.jlink.plugin.ResourcePoolEntry;\n@@ -48,1 +49,1 @@\n-        return pool.entries().map(a -> a.path()).toList();\n+        return pool.entries().map(ResourcePoolEntry::path).toList();\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/ResourcePoolReader.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,2 +29,1 @@\n- * Exception thrown for links without packaged modules. I.e. run-image link.\n- *\n+ * Exception thrown when linking from the run-time image\n@@ -32,1 +31,1 @@\n-public class RuntimeImageLinkException extends IllegalStateException {\n+public class RuntimeImageLinkException extends RuntimeException {\n@@ -36,5 +35,2 @@\n-    private final IllegalArgumentException iae;\n-\n-    public RuntimeImageLinkException(IllegalArgumentException cause) {\n-        super(cause);\n-        this.iae = cause;\n+    public RuntimeImageLinkException(String msg) {\n+        super(msg);\n@@ -42,5 +38,0 @@\n-\n-    public IllegalArgumentException getReason() {\n-        return iae;\n-    }\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/RuntimeImageLinkException.java","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.io.IOException;\n@@ -29,0 +28,1 @@\n+import java.io.IOException;\n@@ -71,15 +71,1 @@\n-        TOP;\n-\n-        public static Type fromOrdinal(int value) {\n-            Type retval = null;\n-            for (Type v: Type.values()) {\n-                if (v.ordinal() == value) {\n-                    retval = v;\n-                    break;\n-                }\n-            }\n-            if (retval == null) {\n-                throw new IllegalArgumentException(\"Illegal ordinal: \" + value);\n-            }\n-            return retval;\n-        }\n+        TOP\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/plugin\/ResourcePoolEntry.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-err.runtime.link.not.linkable.runtime=The current run-time image does not support run-time linking.\n+err.runtime.link.not.linkable.runtime=This JDK does not support linking from the current run-time image\n@@ -121,3 +121,3 @@\n-\\ and cannot be used to create another run-time image that includes the jdk.jlink module.\n-err.runtime.link.packaged.mods=--keep-packaged-modules is not allowed. This linkable run-time image\\\n-\\ does not include packaged modules.\n+\\ and cannot be used to create another image with the jdk.jlink module\n+err.runtime.link.packaged.mods=--keep-packaged-modules is not allowed. This run-time image capable JDK\\\n+\\ does not include packaged modules\n@@ -132,1 +132,1 @@\n-err.modulepath.must.be.specified:--module-path is not specified and this runtime image does not contain jmods directory.\n+err.modulepath.must.be.specified:--module-path is not specified and this run-time image does not contain a jmods directory\n@@ -167,1 +167,1 @@\n-runtime.link.info=Linking based on the current run-time image.\n+runtime.link.info=Linking based on the current run-time image\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        Helper helper = Helper.newHelper(true \/* JDK linkable runtime tests *\/);\n+        Helper helper = Helper.newHelper(true \/* linking from run-time image *\/);\n@@ -114,1 +114,1 @@\n-        \/\/ create a base image only containing the jdk.jlink module and its transitive closure\n+        \/\/ Be sure we have a JDK without JMODs\n@@ -204,4 +204,4 @@\n-     * Prepares the test for execution. This assumes the current jimage is\n-     * runtime-linkable. However, since the 'jmods' dir might be present\n-     * (default jmods module path), it needs to get removed to provoke a runtime\n-     * link.\n+     * Prepares the test for execution. This assumes the current runtime\n+     * supports linking from it. However, since the 'jmods' dir might be present\n+     * (default jmods module path), the 'jmods' directory needs to get removed\n+     * to provoke actual linking from the run-time image.\n@@ -210,1 +210,2 @@\n-     * @return A path to a JDK image which is prepared for runtime linking.\n+     * @return A path to a JDK that is capable for linking from the run-time\n+     *         image.\n@@ -218,4 +219,4 @@\n-     * Prepares the test for execution. This assumes the current jimage is\n-     * runtime-linkable. However, since the 'jmods' dir might be present\n-     * (default jmods module path), it needs to get removed to provoke a runtime\n-     * link.\n+     * Prepares the test for execution. This assumes the current runtime\n+     * supports linking from it. However, since the 'jmods' dir might be present\n+     * (default jmods module path), the 'jmods' directory needs to get removed\n+     * to provoke actual linking from the run-time image.\n@@ -223,4 +224,6 @@\n-     * @param baseSpec The modules to jlink\n-     * @param excludedJmods The set of jmod files to exclude in the base JDK. Empty set if\n-     *                      all JMODs should be removed.\n-     * @return A path to a JDK image which is prepared for runtime linking.\n+     * @param baseSpec\n+     *            The modules to jlink\n+     * @param excludedJmods\n+     *            The set of jmod files to exclude in the base JDK. Empty set if\n+     *            all JMODs should be removed.\n+     * @return A path to a JDK image ready for running jlink\n@@ -622,1 +625,1 @@\n-            out.shouldContain(\"Linking based on the current run-time image.\");\n+            out.shouldContain(\"Linking based on the current run-time image\");\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/AbstractLinkableRuntimeTest.java","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @summary Test --add-options jlink plugin in runtime image link mode\n+ * @summary Test --add-options jlink plugin when linking from the run-time image\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/AddOptionsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n- * @summary Test basic runtime-image-based jlinking with java.base.jmod missing\n- *          but java.xml.jmod present. It should use a run-time image based link.\n+ * @summary Test basic linking from the run-time image with java.base.jmod missing\n+ *          but java.xml.jmod present. It should link from the run-time image without errors.\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/BasicJlinkMissingJavaBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @summary Test basic runtime-image-based jlinking\n+ * @summary Test basic linking from the run-time image\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/BasicJlinkTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        \/\/ create a base image for runtime linking\n+        \/\/ create a base image for linking from the run-time image\n@@ -64,1 +64,1 @@\n-        \/\/ Next jlink using the current runtime image for java.base, but take\n+        \/\/ Next jlink using the run-time image for java.base, but take\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/CustomModuleJlinkTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * @summary Test reproducibility of runtime image based jlink of java.se\n+ * @summary Test reproducibility of linking an java.se image using the run-time\n+ *          image.\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/JavaSEReproducibleTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        \/\/ create a base image for runtime linking\n+        \/\/ create a base image for linking from the run-time image\n@@ -71,2 +71,2 @@\n-        \/\/ Attempt a jlink using system modules and --keep-packaged-modules,\n-        \/\/ which should fail.\n+        \/\/ Attempt a jlink using the run-time image and also using option\n+        \/\/ --keep-packaged-modules, which should fail.\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/KeepPackagedModulesFailTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n- * @summary Verify jlink fails by default when jlinking in runtime-image-based mode\n- *          and files have been changed\n+ * @summary Verify jlink fails by default when linking from the run-time image\n+ *          and files have been modified\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesExitTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * @summary Verify warnings are being produced when jlinking in runtime-based image\n- *          mode and files have been modified\n+ * @summary Verify warnings are being produced when linking from the run-time\n+ *          image and files have been modified\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesWarningTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,2 +69,2 @@\n-                             \"and cannot be used to create another run-time image that includes \" +\n-                             \"the jdk.jlink module.\";\n+                             \"and cannot be used to create another image with \" +\n+                             \"the jdk.jlink module\";\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/MultiHopTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n- * @summary Test SystemModules handling of java --list-modules with system modules\n- *          not consistently enabled\/disabled.\n+ * @summary Test disabled SystemModulesPlugin in run-time image link mode. Expect\n+ *          generated classes to not be there.\n@@ -65,1 +65,0 @@\n-        \/\/ Verify that SystemModules$all.class is there\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/SystemModulesTest2.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}