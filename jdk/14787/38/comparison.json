{"files":[{"patch":"@@ -99,0 +99,4 @@\n+ifeq ($(JLINK_PRODUCE_LINKABLE_RUNTIME), true)\n+  JLINK_JDK_EXTRA_OPTS += --generate-linkable-runtime\n+endif\n+\n","filename":"make\/Images.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -589,1 +589,0 @@\n-# We always keep packaged modules in JDK image.\n@@ -593,1 +592,29 @@\n-  UTIL_ARG_ENABLE(NAME: keep-packaged-modules, DEFAULT: true,\n+\n+  ################################################################################\n+  #\n+  # Configure option for runtime image based linkable jimage.\n+  #\n+  # Determines whether or not a run-time linkable JDK image is being\n+  # produced from the product image. If set to 'true, changes the *default*\n+  # of packaged modules to 'false'.\n+  #\n+  UTIL_ARG_ENABLE(NAME: linkable-runtime, DEFAULT: false,\n+      RESULT: JLINK_PRODUCE_LINKABLE_RUNTIME,\n+      DESC: [enable JDK linkable runtime],\n+      CHECKING_MSG: [whether or not JDK linkable runtime should be produced])\n+  AC_SUBST(JLINK_PRODUCE_LINKABLE_RUNTIME)\n+\n+  if test \"x$JLINK_PRODUCE_LINKABLE_RUNTIME\" = xtrue; then\n+    DEFAULT_PACKAGED_MODULES=false\n+  else\n+    DEFAULT_PACKAGED_MODULES=true\n+  fi\n+\n+  ################################################################################\n+  #\n+  # Configure option for packaged modules\n+  #\n+  # We keep packaged modules in JDK image unless a runtime linkable image\n+  # is requested.\n+  #\n+  UTIL_ARG_ENABLE(NAME: keep-packaged-modules, DEFAULT: $DEFAULT_PACKAGED_MODULES,\n@@ -596,0 +623,1 @@\n+      DEFAULT_DESC: [enabled by default unless --enable-runtime-link-image is set],\n","filename":"make\/autoconf\/jdk-options.m4","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -710,0 +710,1 @@\n+JLINK_PRODUCE_LINKABLE_RUNTIME := @JLINK_PRODUCE_LINKABLE_RUNTIME@\n","filename":"make\/autoconf\/spec.gmk.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import static jdk.tools.jlink.internal.JlinkTask.DIFF_PATTERN;\n+import static jdk.tools.jlink.internal.JlinkTask.RESPATH_PATTERN;\n+\n@@ -28,0 +31,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -32,0 +36,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -35,0 +40,1 @@\n+import java.util.Collections;\n@@ -40,0 +46,1 @@\n+import java.util.Optional;\n@@ -46,0 +53,1 @@\n+import jdk.tools.jlink.internal.JRTArchive.ResourceFileEntry;\n@@ -47,0 +55,5 @@\n+import jdk.tools.jlink.internal.runtimelink.JimageDiffGenerator;\n+import jdk.tools.jlink.internal.runtimelink.JimageDiffGenerator.ImageResource;\n+import jdk.tools.jlink.internal.runtimelink.ResourceDiff;\n+import jdk.tools.jlink.internal.runtimelink.ResourcePoolReader;\n+import jdk.tools.jlink.internal.runtimelink.RuntimeImageLinkException;\n@@ -49,0 +62,1 @@\n+import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n@@ -50,0 +64,1 @@\n+import jdk.tools.jlink.plugin.ResourcePoolModule;\n@@ -71,0 +86,7 @@\n+    private static final String JLINK_MOD_NAME = \"jdk.jlink\";\n+    \/\/ This resource is being used in JLinkTask which passes its contents to\n+    \/\/ JRTArchive for further processing.\n+    private static final String RESPATH = \"\/\" + JLINK_MOD_NAME + \"\/\" + RESPATH_PATTERN;\n+    private static final String DIFF_PATH = \"\/\" + JLINK_MOD_NAME + \"\/\" + DIFF_PATTERN;\n+    private static final byte[] EMPTY_RESOURCE_BYTES = new byte[] {};\n+\n@@ -73,1 +95,2 @@\n-    private ImageFileCreator(ImagePluginStack plugins) {\n+    private final boolean generateRuntimeImage;\n+    private ImageFileCreator(ImagePluginStack plugins, boolean generateRuntimeImage) {\n@@ -75,0 +98,1 @@\n+        this.generateRuntimeImage = generateRuntimeImage;\n@@ -77,0 +101,10 @@\n+    \/**\n+     * Create an executable image based on a set of archives and a given\n+     * plug-in stack and the native byte order. Note: this is will not create\n+     * a linkable JDK runtime.\n+     *\n+     * @param archives The set of input archives\n+     * @param plugins The plug-in stack to apply to the input\n+     * @return The executable image\n+     * @throws IOException\n+     *\/\n@@ -81,1 +115,1 @@\n-                plugins);\n+                plugins, false);\n@@ -84,0 +118,10 @@\n+    \/**\n+     * Create an executable image based on a set of archives and an empty\n+     * plug-in stack and a given byte order. Note: this is will not create\n+     * a linkable JDK runtime.\n+     *\n+     * @param archives The set of input archives\n+     * @param byteOrder The required byte order of the output image.\n+     * @return The executable image for the given byte order.\n+     * @throws IOException\n+     *\/\n@@ -88,1 +132,1 @@\n-                new ImagePluginStack());\n+                new ImagePluginStack(), false);\n@@ -91,0 +135,13 @@\n+    \/**\n+     * Create an executable image based on a set of input archives and a given\n+     * plugin stack for a given byte order. It optionally generates a linkable\n+     * JDK runtime if {@code generateRuntimeImage} is set to {@code true}.\n+     *\n+     * @param archives The set of input archives\n+     * @param byteOrder The desired byte order of the result\n+     * @param plugins The plugin stack to apply to the input\n+     * @param generateRuntimeImage Whether or not a linkable JDK runtime should\n+     *        get created.\n+     * @return The executable image.\n+     * @throws IOException\n+     *\/\n@@ -93,1 +150,2 @@\n-            ImagePluginStack plugins)\n+            ImagePluginStack plugins,\n+            boolean generateRuntimeImage)\n@@ -96,1 +154,1 @@\n-        ImageFileCreator image = new ImageFileCreator(plugins);\n+        ImageFileCreator image = new ImageFileCreator(plugins, generateRuntimeImage);\n@@ -128,1 +186,1 @@\n-            ImagePluginStack pluginSupport)\n+            ImagePluginStack pluginSupport, boolean generateRuntimeImage)\n@@ -145,1 +203,1 @@\n-                generateJImage(pool, writer, pluginSupport, out);\n+                generateJImage(pool, writer, pluginSupport, out, generateRuntimeImage);\n@@ -163,1 +221,1 @@\n-            result = generateJImage(allContent, writer, plugins, out);\n+            result = generateJImage(allContent, writer, plugins, out, generateRuntimeImage);\n@@ -169,0 +227,3 @@\n+        } catch (RuntimeImageLinkException e) {\n+            \/\/ Propagate reason for jlink runs based on linkable JDK runtimes\n+            throw e.getReason();\n@@ -177,0 +238,14 @@\n+    \/**\n+     * Create a jimage based on content of the given ResourcePoolManager,\n+     * optionally creating a linkable JDK runtime.\n+     *\n+     * @param allContent The content that needs to get added to the resulting\n+     *                   lib\/modules (jimage) file.\n+     * @param writer The writer for the jimage file.\n+     * @param pluginSupport The stack of all plugins to apply.\n+     * @param out The output stream to write the jimage to.\n+     * @param generateRuntimeImage Whether or not a linkable JDK runtime should\n+     *                             be generated.\n+     * @return A pool of the actual result resources.\n+     * @throws IOException\n+     *\/\n@@ -180,1 +255,2 @@\n-            DataOutputStream out\n+            DataOutputStream out,\n+            boolean generateRuntimeImage\n@@ -185,0 +261,12 @@\n+            if (generateRuntimeImage) {\n+                \/\/ Keep track of non-modules image resources for\n+                \/\/ linkable JDK runtimes\n+                resultResources = addNonClassResourcesTrackFiles(resultResources,\n+                                                                 writer);\n+                \/\/ Generate the diff between the input resources from packaged\n+                \/\/ modules in 'allContent' to the plugin- or otherwise\n+                \/\/ generated-content in 'resultResources'\n+                resultResources = addRessourceDiffFiles(allContent.resourcePool(),\n+                                                        resultResources,\n+                                                        writer);\n+            }\n@@ -190,0 +278,7 @@\n+        } catch (RuntimeImageLinkException re) {\n+            \/\/ might be thrown in the run-image link case. Populate the\n+            \/\/ actual reason.\n+            if (JlinkTask.DEBUG) {\n+                re.printStackTrace();\n+            }\n+            throw re.getReason();\n@@ -201,1 +296,1 @@\n-                 \/\/ the order of traversing the resources and the order of\n+        \/\/ the order of traversing the resources and the order of\n@@ -251,0 +346,197 @@\n+    \/**\n+     * Support for linkable JDK runtimes.\n+     *\n+     * Generates differences between the packaged modules \"view\" in\n+     * {@code jmodContent} to the optimized image in {@code resultContent} and\n+     * adds the result to the returned resource pool.\n+     *\n+     * @param jmodContent The resource pool view of packaged modules\n+     * @param resultContent The optimized result generated from the jmodContent\n+     *                      input by applying the plugin stack.\n+     * @param writer The image writer.\n+     * @return The resource pool with the difference file resources added to\n+     *         the {@code resultContent}\n+     *\/\n+    @SuppressWarnings(\"try\")\n+    private static ResourcePool addRessourceDiffFiles(ResourcePool jmodContent,\n+            ResourcePool resultContent, BasicImageWriter writer) {\n+        JimageDiffGenerator generator = new JimageDiffGenerator();\n+        List<ResourceDiff> diff;\n+        try (ImageResource jmods = new ResourcePoolReader(jmodContent);\n+             ImageResource jimage = new ResourcePoolReader(resultContent)) {\n+            diff = generator.generateDiff(jmods, jimage);\n+        } catch (Exception e) {\n+            throw new AssertionError(\"Failed to generate the runtime image diff\", e);\n+        }\n+        Set<String> modules = resultContent.moduleView().modules()\n+                                                        .map(a -> a.name())\n+                                                        .collect(Collectors.toSet());\n+        \/\/ Add resource diffs for the resource files we are about to add\n+        modules.stream().forEach(m -> {\n+            String resourceName = String.format(DIFF_PATH, m);\n+            ResourceDiff.Builder builder = new ResourceDiff.Builder();\n+            ResourceDiff d = builder.setKind(ResourceDiff.Kind.ADDED)\n+                                    .setName(resourceName)\n+                                    .build();\n+            diff.add(d);\n+        });\n+        Map<String, List<ResourceDiff>> perModDiffs = preparePerModuleDiffs(diff,\n+                                                                            modules);\n+        return addDiffResourcesFiles(modules, perModDiffs, resultContent, writer);\n+    }\n+\n+    private static Map<String, List<ResourceDiff>> preparePerModuleDiffs(List<ResourceDiff> resDiffs,\n+                                                                         Set<String> modules) {\n+        Map<String, List<ResourceDiff>> modToDiff = new HashMap<>();\n+        resDiffs.forEach(d -> {\n+            int secondSlash = d.getName().indexOf(\"\/\", 1);\n+            if (secondSlash == -1) {\n+                throw new AssertionError(\"Module name not present\");\n+            }\n+            String module = d.getName().substring(1, secondSlash);\n+            List<ResourceDiff> perModDiff = modToDiff.computeIfAbsent(module,\n+                                                                      a -> new ArrayList<>());\n+            perModDiff.add(d);\n+        });\n+        Map<String, List<ResourceDiff>> allModsToDiff = new HashMap<>();\n+        modules.stream().forEach(m -> {\n+            List<ResourceDiff> d = modToDiff.get(m);\n+            if (d == null) {\n+                \/\/ Not all modules will have a diff\n+                allModsToDiff.put(m, Collections.emptyList());\n+            } else {\n+                allModsToDiff.put(m, d);\n+            }\n+        });\n+        return allModsToDiff;\n+    }\n+\n+    private static ResourcePool addDiffResourcesFiles(Set<String> modules,\n+                                                      Map<String, List<ResourceDiff>> perModDiffs,\n+                                                      ResourcePool resultResources,\n+                                                      BasicImageWriter writer) {\n+        ResourcePoolManager mgr = createPoolManager(resultResources, writer);\n+        ResourcePoolBuilder out = mgr.resourcePoolBuilder();\n+        modules.stream().sorted().forEach(module -> {\n+            String mResource = String.format(DIFF_PATH, module);\n+            List<ResourceDiff> diff = perModDiffs.get(module);\n+            if (diff == null) {\n+                \/\/ We create empty resource files for modules in the resource\n+                \/\/ pool view, but which don't themselves have a diff to packaged\n+                \/\/ modules\n+                out.add(ResourcePoolEntry.create(mResource, EMPTY_RESOURCE_BYTES));\n+            } else {\n+                ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+                try {\n+                    ResourceDiff.write(diff, bout);\n+                } catch (IOException e) {\n+                    throw new AssertionError(\"Failed to write resource diff file\" +\n+                                             \" for module \" + module, e);\n+                }\n+                out.add(ResourcePoolEntry.create(mResource, bout.toByteArray()));\n+            }\n+        });\n+        return out.build();\n+    }\n+\n+    \/**\n+     * Support for linkable JDK runtimes. Adds meta-data files for resources not\n+     * in the lib\/modules file of the JDK. That is, mapping files for which\n+     * on-disk files belong to which module.\n+     *\n+     * @param resultResources The original resources which serve as the basis\n+     *                        for generating the meta-data files.\n+     * @param writer The image writer.\n+     *\n+     * @return An amended resource pool which includes meta-data files.\n+     *\/\n+    private static ResourcePool addNonClassResourcesTrackFiles(ResourcePool resultResources,\n+                                                               BasicImageWriter writer) {\n+        \/\/ Only add resources if we have the jdk.jlink module part of the\n+        \/\/ target modules view\n+        Optional<ResourcePoolModule> jdkJlink = resultResources.moduleView()\n+                                                               .findModule(JLINK_MOD_NAME);\n+        if (jdkJlink.isPresent()) {\n+            Map<String, List<String>> nonClassResources = recordAndFilterEntries(resultResources);\n+            return addModuleResourceEntries(resultResources, nonClassResources, writer);\n+        } else {\n+            return resultResources; \/\/ No-op\n+        }\n+    }\n+\n+    \/**\n+     * Support for linkable JDK runtimes. Adds the given mapping of files\n+     * as a meta-data file to the given resource pool.\n+     *\n+     * @param resultResources The resource pool to add files to.\n+     * @param nonClassResEntries The per module mapping for which to create\n+     *                           the meta-data files for.\n+     * @param writer The image writer.\n+     *\n+     * @return A resource pool with meta-data files added.\n+     *\/\n+    private static ResourcePool addModuleResourceEntries(ResourcePool resultResources,\n+                                                         Map<String, List<String>> nonClassResEntries,\n+                                                         BasicImageWriter writer) {\n+        Set<String> inputModules = resultResources.moduleView().modules()\n+                                                  .map(rm -> rm.name())\n+                                                  .collect(Collectors.toSet());\n+        ResourcePoolManager mgr = createPoolManager(resultResources, writer);\n+        ResourcePoolBuilder out = mgr.resourcePoolBuilder();\n+        inputModules.stream().sorted().forEach(module -> {\n+            String mResource = String.format(RESPATH, module);\n+            List<String> mResources = nonClassResEntries.get(module);\n+            if (mResources == null) {\n+                \/\/ We create empty resource files for modules in the resource\n+                \/\/ pool view, but which don't themselves contain native resources\n+                \/\/ or config files.\n+                out.add(ResourcePoolEntry.create(mResource, EMPTY_RESOURCE_BYTES));\n+            } else {\n+                String mResContent = mResources.stream().sorted()\n+                                               .collect(Collectors.joining(\"\\n\"));\n+                out.add(ResourcePoolEntry.create(mResource,\n+                                                 mResContent.getBytes(StandardCharsets.UTF_8)));\n+            }\n+        });\n+        return out.build();\n+    }\n+\n+    \/**\n+     * Support for linkable JDK runtimes. Generates a per module mapping of\n+     * files not part of the modules image (jimage). This mapping is needed so\n+     * as to know which files of the installed JDK belong to which module.\n+     *\n+     * @param resultResources The resources from which the mapping gets\n+     *        generated\n+     * @return A mapping with the module names as keys and the list of files\n+     *         not part of the modules image (jimage) as values.\n+     *\/\n+    private static Map<String, List<String>> recordAndFilterEntries(\n+            ResourcePool resultResources) {\n+        final Map<String, List<String>> nonClassResEntries = new HashMap<>();\n+        final Platform platform = getTargetPlatform(resultResources);\n+        resultResources.entries().forEach(entry -> {\n+            \/\/ Note that the fs_$module_files file is a resource file itself, so\n+            \/\/ we cannot add fs_$module_files themselves due to the\n+            \/\/ not(class_or_resources) condition. However, we also don't want\n+            \/\/ to track 'release' file entries (not(top) condition) as those are\n+            \/\/ handled by the release info plugin.\n+            if (entry.type() != ResourcePoolEntry.Type.CLASS_OR_RESOURCE &&\n+                    entry.type() != ResourcePoolEntry.Type.TOP) {\n+                List<String> mRes = nonClassResEntries.computeIfAbsent(entry.moduleName(),\n+                                                                       a -> new ArrayList<>());\n+                ResourceFileEntry rfEntry = ResourceFileEntry.toResourceFileEntry(entry,\n+                                                                                  platform);\n+                mRes.add(rfEntry.encodeToString());\n+            }\n+        });\n+        return nonClassResEntries;\n+    }\n+\n+    private static Platform getTargetPlatform(ResourcePool in) {\n+        String platform = in.moduleView().findModule(\"java.base\")\n+                .map(ResourcePoolModule::targetPlatform)\n+                .orElseThrow(() -> new AssertionError(\"java.base not found\"));\n+        return Platform.parsePlatform(platform);\n+    }\n+\n@@ -255,1 +547,15 @@\n-        ResourcePoolManager resources = new ResourcePoolManager(byteOrder, new StringTable() {\n+        ResourcePoolManager resources = createBasicResourcePoolManager(byteOrder, writer);\n+        archives.stream()\n+                .map(Archive::moduleName)\n+                .sorted()\n+                .flatMap(mn ->\n+                    entriesForModule.get(mn).stream()\n+                            .map(e -> new ArchiveEntryResourcePoolEntry(mn,\n+                                    e.getResourcePoolEntryName(), e)))\n+                .forEach(resources::add);\n+        return resources;\n+    }\n+\n+    private static ResourcePoolManager createBasicResourcePoolManager(\n+            ByteOrder byteOrder, BasicImageWriter writer) {\n+        return new ResourcePoolManager(byteOrder, new StringTable() {\n@@ -267,8 +573,19 @@\n-        archives.stream()\n-                .map(Archive::moduleName)\n-                .sorted()\n-                .flatMap(mn ->\n-                    entriesForModule.get(mn).stream()\n-                            .map(e -> new ArchiveEntryResourcePoolEntry(mn,\n-                                    e.getResourcePoolEntryName(), e)))\n-                .forEach(resources::add);\n+    }\n+\n+    \/**\n+     * Creates a ResourcePoolManager from existing resources so that more\n+     * resources can be appended.\n+     *\n+     * @param resultResources The existing resources to initially add.\n+     * @param writer The basic image writer.\n+     * @return An appendable ResourcePoolManager.\n+     *\/\n+    private static ResourcePoolManager createPoolManager(\n+            ResourcePool resultResources, BasicImageWriter writer) {\n+        ResourcePoolManager resources = createBasicResourcePoolManager(resultResources.byteOrder(),\n+                                                                       writer);\n+        \/\/ Note that resources are already sorted in the correct order.\n+        \/\/ The underlying ResourcePoolManager keeps track of entries via\n+        \/\/ LinkedHashMap, which keeps values in insertion order. Therefore\n+        \/\/ adding resources here, preserving that same order is OK.\n+        resultResources.entries().forEach(resources::add);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageFileCreator.java","additions":336,"deletions":19,"binary":false,"changes":355,"status":"modified"},{"patch":"@@ -0,0 +1,522 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal;\n+\n+import static jdk.tools.jlink.internal.JlinkTask.RESPATH_PATTERN;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReference;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.util.OperatingSystem;\n+import jdk.tools.jlink.internal.Archive.Entry.EntryType;\n+import jdk.tools.jlink.internal.runtimelink.ResourceDiff;\n+import jdk.tools.jlink.internal.runtimelink.RuntimeImageLinkException;\n+import jdk.tools.jlink.plugin.ResourcePoolEntry;\n+import jdk.tools.jlink.plugin.ResourcePoolEntry.Type;\n+\n+\/**\n+ * An archive implementation based on the JDK's modules image (lib\/modules,\n+ * or jimage) as well as associated files from the filesystem of the JDK\n+ * installation.\n+ *\/\n+public class JRTArchive implements Archive {\n+\n+    private final String module;\n+    private final Path path;\n+    private final ModuleReference ref;\n+    \/\/ The collection of files of this module\n+    private final List<JRTFile> files = new ArrayList<>();\n+    \/\/ Files not part of the lib\/modules image of the JDK install.\n+    \/\/ Thus, native libraries, binaries, legal files, etc.\n+    private final List<String> otherRes;\n+    \/\/ Maps a module resource path to the corresponding diff to packaged\n+    \/\/ modules for that resource (if any)\n+    private final Map<String, ResourceDiff> resDiff;\n+    private final boolean errorOnModifiedFile;\n+\n+    \/**\n+     * JRTArchive constructor\n+     *\n+     * @param module The module name this archive refers to\n+     * @param path The JRT filesystem path.\n+     * @param errorOnModifiedFile Whether or not modified files of the JDK\n+     *        install aborts the link.\n+     * @param perModDiff The lib\/modules (a.k.a jimage) diff for this module\n+     *\/\n+    JRTArchive(String module,\n+               Path path,\n+               boolean errorOnModifiedFile,\n+               List<ResourceDiff> perModDiff) {\n+        this.module = module;\n+        this.path = path;\n+        this.ref = ModuleFinder.ofSystem()\n+                               .find(module)\n+                               .orElseThrow(() ->\n+                                    new IllegalArgumentException(\n+                                            \"Module \" + module +\n+                                            \" not part of the JDK install\"));\n+        this.errorOnModifiedFile = errorOnModifiedFile;\n+        this.otherRes = readModuleResourceFile(module);\n+        this.resDiff = prepareDiffMap(Objects.requireNonNull(perModDiff));\n+    }\n+\n+    @Override\n+    public String moduleName() {\n+        return module;\n+    }\n+\n+    @Override\n+    public Path getPath() {\n+        return path;\n+    }\n+\n+    @Override\n+    public Stream<Entry> entries() {\n+        try {\n+            collectFiles();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        } catch (RuntimeImageLinkException e) {\n+            \/\/ populate modified files exception\n+            throw e.getReason();\n+        }\n+        return files.stream().map(JRTFile::toEntry);\n+    }\n+\n+    @Override\n+    public void open() throws IOException {\n+        if (files.isEmpty()) {\n+            collectFiles();\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (!files.isEmpty()) {\n+            files.clear();\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(module, path);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return (obj instanceof JRTArchive other &&\n+                   Objects.equals(module, other.module) &&\n+                   Objects.equals(path, other.path));\n+    }\n+\n+    private void collectFiles() throws IOException {\n+        if (files.isEmpty()) {\n+            addNonClassResources();\n+            \/\/ Add classes\/resources from image module,\n+            \/\/ patched with the runtime image link diff\n+            files.addAll(ref.open().list()\n+                                   .filter(i -> {\n+                                       String lookupKey = String.format(\"\/%s\/%s\", module, i);\n+                                       ResourceDiff rd = resDiff.get(lookupKey);\n+                                       \/\/ Filter all resources with a resource diff\n+                                       \/\/ that are of kind MODIFIED.\n+                                       \/\/ Note that REMOVED won't happen since in\n+                                       \/\/ that case the module listing won't have\n+                                       \/\/ the resource anyway.\n+                                       \/\/ Note as well that filter removes files\n+                                       \/\/ of kind ADDED. Those files are not in\n+                                       \/\/ the packaged modules, so ought not to\n+                                       \/\/ get returned from the pipeline.\n+                                       return (rd == null ||\n+                                               rd.getKind() == ResourceDiff.Kind.MODIFIED);\n+                                   })\n+                                   .map(s -> {\n+                                               String lookupKey = String.format(\"\/%s\/%s\", module, s);\n+                                               return new JRTArchiveFile(JRTArchive.this, s,\n+                                                       EntryType.CLASS_OR_RESOURCE,\n+                                                       null \/* hashOrTarget *\/,\n+                                                       false \/* symlink *\/,\n+                                                       resDiff.get(lookupKey));\n+                                   })\n+                                   .collect(Collectors.toList()));\n+            \/\/ Finally add all files only present in the resource diff\n+            \/\/ That is, removed items in the runtime image.\n+            files.addAll(resDiff.values().stream()\n+                                         .filter(rd -> rd.getKind() == ResourceDiff.Kind.REMOVED)\n+                                         .map(s -> {\n+                                                 int secondSlash = s.getName().indexOf(\"\/\", 1);\n+                                                 if (secondSlash == -1) {\n+                                                     throw new AssertionError();\n+                                                 }\n+                                                 String pathWithoutModule = s.getName()\n+                                                            .substring(secondSlash + 1,\n+                                                                       s.getName().length());\n+                                                 return new JRTArchiveFile(JRTArchive.this,\n+                                                         pathWithoutModule,\n+                                                         EntryType.CLASS_OR_RESOURCE,\n+                                                         null  \/* hashOrTarget *\/,\n+                                                         false \/* symlink *\/,\n+                                                         s);\n+                                         })\n+                                         .collect(Collectors.toList()));\n+        }\n+    }\n+\n+    \/*\n+     * no need to keep track of the warning produced since this is eagerly\n+     * checked once.\n+     *\/\n+    private void addNonClassResources() {\n+        \/\/ Not all modules will have other resources like bin, lib, legal etc.\n+        \/\/ files. In that case the list will be empty.\n+        if (!otherRes.isEmpty()) {\n+            files.addAll(otherRes.stream()\n+                 .filter(Predicate.not(String::isEmpty))\n+                 .map(s -> {\n+                        ResourceFileEntry m = ResourceFileEntry.decodeFromString(s);\n+\n+                        \/\/ Read from the base JDK image.\n+                        Path path = BASE.resolve(m.resPath);\n+                        if (shaSumMismatch(path, m.hashOrTarget, m.symlink)) {\n+                            String msg = String.format(MISMATCH_FORMAT,\n+                                                       path.toString());\n+                            if (errorOnModifiedFile) {\n+                                IllegalArgumentException ise = new IllegalArgumentException(msg);\n+                                throw new RuntimeImageLinkException(ise);\n+                            } else {\n+                                System.err.printf(\"WARNING: %s\", msg);\n+                            }\n+                        }\n+\n+                        return new JRTArchiveFile(JRTArchive.this,\n+                                                  m.resPath,\n+                                                  toEntryType(m.resType),\n+                                                  m.hashOrTarget,\n+                                                  m.symlink,\n+                                                  \/* diff only for resources *\/\n+                                                  null);\n+                 })\n+                 .collect(Collectors.toList()));\n+        }\n+    }\n+\n+    static boolean shaSumMismatch(Path res, String expectedSha, boolean isSymlink) {\n+        if (isSymlink) {\n+            return false;\n+        }\n+        \/\/ handle non-symlink resources\n+        try {\n+            HexFormat format = HexFormat.of();\n+            byte[] expected = format.parseHex(expectedSha);\n+            MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n+            try (InputStream is = Files.newInputStream(res)) {\n+                byte[] buf = new byte[1024];\n+                int readBytes = -1;\n+                while ((readBytes = is.read(buf)) != -1) {\n+                    digest.update(buf, 0, readBytes);\n+                }\n+            }\n+            byte[] actual = digest.digest();\n+            return !MessageDigest.isEqual(expected, actual);\n+        } catch (Exception e) {\n+            throw new AssertionError(\"SHA-512 sum check failed!\", e);\n+        }\n+    }\n+\n+    private static EntryType toEntryType(Type input) {\n+        return switch(input) {\n+            case CLASS_OR_RESOURCE -> EntryType.CLASS_OR_RESOURCE;\n+            case CONFIG -> EntryType.CONFIG;\n+            case HEADER_FILE -> EntryType.HEADER_FILE;\n+            case LEGAL_NOTICE -> EntryType.LEGAL_NOTICE;\n+            case MAN_PAGE -> EntryType.MAN_PAGE;\n+            case NATIVE_CMD -> EntryType.NATIVE_CMD;\n+            case NATIVE_LIB -> EntryType.NATIVE_LIB;\n+            case TOP -> throw new IllegalArgumentException(\n+                           \"TOP files should be handled by ReleaseInfoPlugin!\");\n+            default -> throw new IllegalArgumentException(\n+                           \"Unknown type: \" + input);\n+        };\n+    }\n+\n+    public record ResourceFileEntry(Type resType,\n+                                    boolean symlink,\n+                                    String hashOrTarget,\n+                                    String resPath) {\n+        \/\/ Type file format:\n+        \/\/ '<type>|{0,1}|<sha-sum>|<file-path>'\n+        \/\/   (1)    (2)      (3)      (4)\n+        \/\/\n+        \/\/ Where fields are:\n+        \/\/\n+        \/\/ (1) The resource type as specified by ResourcePoolEntry.type()\n+        \/\/ (2) Symlink designator. 0 => regular resource, 1 => symlinked resource\n+        \/\/ (3) The SHA-512 sum of the resources' content. The link to the target\n+        \/\/     for symlinked resources.\n+        \/\/ (4) The relative file path of the resource\n+        private static final String TYPE_FILE_FORMAT = \"%d|%d|%s|%s\";\n+\n+        public String encodeToString() {\n+            return String.format(TYPE_FILE_FORMAT,\n+                                 resType.ordinal(),\n+                                 symlink ? 1 : 0,\n+                                 hashOrTarget,\n+                                 resPath);\n+        }\n+\n+        \/**\n+         *  line: <int>|<int>|<hashOrTarget>|<path>\n+         *\n+         *  Take the integer before '|' convert it to a Type. The second\n+         *  token is an integer representing symlinks (or not). The third token is\n+         *  a hash sum (sha512) of the file denoted by the fourth token (path).\n+         *\/\n+        static ResourceFileEntry decodeFromString(String line) {\n+            assert !line.isEmpty();\n+\n+            String[] tokens = line.split(\"\\\\|\", 4);\n+            Type type = null;\n+            int symlinkNum = -1;\n+            try {\n+                Integer typeInt = Integer.valueOf(tokens[0]);\n+                type = Type.fromOrdinal(typeInt);\n+                symlinkNum = Integer.valueOf(tokens[1]);\n+            } catch (NumberFormatException e) {\n+                throw new AssertionError(e); \/\/ must not happen\n+            }\n+            if (symlinkNum < 0 || symlinkNum > 1) {\n+                throw new IllegalStateException(\n+                        \"Symlink designator out of range [0,1] got: \" +\n+                        symlinkNum);\n+            }\n+            return new ResourceFileEntry(type,\n+                                         symlinkNum == 1,\n+                                         tokens[2] \/* hash or target *\/,\n+                                         tokens[3] \/* resource path *\/);\n+        }\n+\n+        public static ResourceFileEntry toResourceFileEntry(ResourcePoolEntry entry,\n+                                                            Platform platform) {\n+            String resPathWithoutMod = dropModuleFromPath(entry, platform);\n+            \/\/ Symlinks don't have a hash sum, but a link to the target instead\n+            String hashOrTarget = entry.linkedTarget() == null\n+                                        ? computeSha512(entry)\n+                                        : dropModuleFromPath(entry.linkedTarget(),\n+                                                             platform);\n+            return new ResourceFileEntry(entry.type(),\n+                                         entry.linkedTarget() != null,\n+                                         hashOrTarget,\n+                                         resPathWithoutMod);\n+        }\n+\n+        private static String computeSha512(ResourcePoolEntry entry) {\n+            try {\n+                assert entry.linkedTarget() == null;\n+                MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n+                try (InputStream is = entry.content()) {\n+                    byte[] buf = new byte[1024];\n+                    int bytesRead = -1;\n+                    while ((bytesRead = is.read(buf)) != -1) {\n+                        digest.update(buf, 0, bytesRead);\n+                    }\n+                }\n+                byte[] db = digest.digest();\n+                HexFormat format = HexFormat.of();\n+                return format.formatHex(db);\n+            } catch (Exception e) {\n+                throw new AssertionError(\"Failed to generate hash sum for \" +\n+                                         entry.path());\n+            }\n+        }\n+\n+        private static String dropModuleFromPath(ResourcePoolEntry entry,\n+                                                 Platform platform) {\n+            String resPath = entry.path()\n+                                  .substring(\n+                                      \/\/ + 2 => prefixed and suffixed '\/'\n+                                      \/\/ For example: '\/java.base\/'\n+                                      entry.moduleName().length() + 2);\n+            if (!isWindows(platform)) {\n+                return resPath;\n+            }\n+            \/\/ For Windows the libraries live in the 'bin' folder rather than\n+            \/\/ the 'lib' folder in the final image. Note that going by the\n+            \/\/ NATIVE_LIB type only is insufficient since only files with suffix\n+            \/\/ .dll\/diz\/map\/pdb are transplanted to 'bin'.\n+            \/\/ See: DefaultImageBuilder.nativeDir()\n+            return nativeDir(entry, resPath);\n+        }\n+\n+        private static boolean isWindows(Platform platform) {\n+            return platform.os() == OperatingSystem.WINDOWS;\n+        }\n+\n+        private static String nativeDir(ResourcePoolEntry entry, String resPath) {\n+            if (entry.type() != ResourcePoolEntry.Type.NATIVE_LIB) {\n+                return resPath;\n+            }\n+            \/\/ precondition: Native lib, windows platform\n+            if (resPath.endsWith(\".dll\") || resPath.endsWith(\".diz\")\n+                    || resPath.endsWith(\".pdb\") || resPath.endsWith(\".map\")) {\n+                if (resPath.startsWith(LIB_DIRNAME + \"\/\")) {\n+                    return BIN_DIRNAME + \"\/\" +\n+                               resPath.substring((LIB_DIRNAME + \"\/\").length());\n+                }\n+            }\n+            return resPath;\n+        }\n+        private static final String BIN_DIRNAME = \"bin\";\n+        private static final String LIB_DIRNAME = \"lib\";\n+    }\n+\n+    private static final Path BASE = Paths.get(System.getProperty(\"java.home\"));\n+    private static final String MISMATCH_FORMAT = \"%s has been modified.%n\";\n+\n+    interface JRTFile {\n+        Entry toEntry();\n+    }\n+\n+    record JRTArchiveFile(Archive archive,\n+                          String resPath,\n+                          EntryType resType,\n+                          String sha,\n+                          boolean symlink,\n+                          ResourceDiff diff) implements JRTFile {\n+        public Entry toEntry() {\n+            return new Entry(archive,\n+                             String.format(\"\/%s\/%s\",\n+                                           archive.moduleName(),\n+                                           resPath),\n+                             resPath,\n+                             resType) {\n+                @Override\n+                public long size() {\n+                    try {\n+                        if (resType != EntryType.CLASS_OR_RESOURCE) {\n+                            \/\/ Read from the base JDK image, special casing\n+                            \/\/ symlinks, which have the link target in the\n+                            \/\/ hashOrTarget field\n+                            if (symlink) {\n+                                return Files.size(BASE.resolve(sha));\n+                            }\n+                            return Files.size(BASE.resolve(resPath));\n+                        } else {\n+                            if (diff != null) {\n+                                \/\/ If the resource has a diff to the\n+                                \/\/ packaged modules, use the diff. Diffs of kind\n+                                \/\/ ADDED have been filtered out in collectFiles();\n+                                assert diff.getKind() != ResourceDiff.Kind.ADDED;\n+                                assert diff.getName().equals(\n+                                                          String.format(\"\/%s\/%s\",\n+                                                                        archive.moduleName(),\n+                                                                        resPath));\n+                                return diff.getResourceBytes().length;\n+                            }\n+                            \/\/ Read from the module image. This works, because\n+                            \/\/ the underlying base path is a JrtPath with the\n+                            \/\/ JrtFileSystem underneath which is able to handle\n+                            \/\/ this size query.\n+                            return Files.size(archive.getPath().resolve(resPath));\n+                        }\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                }\n+\n+                @Override\n+                public InputStream stream() throws IOException {\n+                    if (resType != EntryType.CLASS_OR_RESOURCE) {\n+                        \/\/ Read from the base JDK image.\n+                        Path path = symlink ? BASE.resolve(sha) : BASE.resolve(resPath);\n+                        return Files.newInputStream(path);\n+                    } else {\n+                        \/\/ Read from the module image. Use the diff to the\n+                        \/\/ packaged modules if we have one. Diffs of kind\n+                        \/\/ ADDED have been filtered out in collectFiles();\n+                        if (diff != null) {\n+                            assert diff.getKind() != ResourceDiff.Kind.ADDED;\n+                            assert diff.getName().equals(String.format(\"\/%s\/%s\",\n+                                                                    archive.moduleName(),\n+                                                                    resPath));\n+                            return new ByteArrayInputStream(diff.getResourceBytes());\n+                        }\n+                        String module = archive.moduleName();\n+                        ModuleReference mRef = ModuleFinder.ofSystem()\n+                                                    .find(module).orElseThrow();\n+                        return mRef.open().open(resPath).orElseThrow();\n+                    }\n+                }\n+\n+            };\n+        }\n+    }\n+\n+    private static List<String> readModuleResourceFile(String modName) {\n+        String resName = String.format(RESPATH_PATTERN, modName);\n+        try {\n+            try (InputStream inStream = JRTArchive.class.getModule()\n+                                                  .getResourceAsStream(resName)) {\n+                String input = new String(inStream.readAllBytes(),\n+                                          StandardCharsets.UTF_8);\n+                if (input.isEmpty()) {\n+                    \/\/ Not all modules have non-class resources\n+                    return Collections.emptyList();\n+                } else {\n+                    return Arrays.asList(input.split(\"\\n\"));\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new InternalError(\"Failed to process run-time image resources \" +\n+                                    \" for \" + modName);\n+        }\n+    }\n+\n+    private static Map<String, ResourceDiff> prepareDiffMap(List<ResourceDiff> diffs) {\n+        Map<String, ResourceDiff> resDiffsAsMap = new HashMap<>();\n+        diffs.forEach(r -> resDiffsAsMap.put(r.getName(), r));\n+        return resDiffsAsMap;\n+    }\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JRTArchive.java","additions":522,"deletions":0,"binary":false,"changes":522,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import java.nio.ByteOrder;\n@@ -151,0 +150,3 @@\n+        private final boolean linkFromRuntimeImage;\n+        private final boolean ignoreModifiedRuntime;\n+        private final boolean generateRuntimeImage;\n@@ -161,1 +163,4 @@\n-                                  ModuleFinder finder) {\n+                                  ModuleFinder finder,\n+                                  boolean linkFromRuntimeImage,\n+                                  boolean ignoreModifiedRuntime,\n+                                  boolean generateRuntimeImage) {\n@@ -165,0 +170,3 @@\n+            this.linkFromRuntimeImage = linkFromRuntimeImage;\n+            this.ignoreModifiedRuntime = ignoreModifiedRuntime;\n+            this.generateRuntimeImage = generateRuntimeImage;\n@@ -189,0 +197,12 @@\n+        public boolean linkFromRuntimeImage() {\n+            return linkFromRuntimeImage;\n+        }\n+\n+        public boolean ignoreModifiedRuntime() {\n+            return ignoreModifiedRuntime;\n+        }\n+\n+        public boolean isGenerateRuntimeImage() {\n+            return generateRuntimeImage;\n+        }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Jlink.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import static jdk.tools.jlink.internal.TaskHelper.JLINK_BUNDLE;\n+\n@@ -42,1 +44,0 @@\n-import java.nio.file.Files;\n@@ -44,0 +45,1 @@\n+import java.nio.file.Files;\n@@ -50,0 +52,1 @@\n+import java.util.Collections;\n@@ -63,0 +66,1 @@\n+import jdk.internal.module.ModulePath;\n@@ -64,2 +68,3 @@\n-import jdk.tools.jlink.internal.TaskHelper.BadArgs;\n-import static jdk.tools.jlink.internal.TaskHelper.JLINK_BUNDLE;\n+import jdk.internal.module.ModuleResolution;\n+import jdk.internal.opt.CommandLine;\n+import jdk.tools.jlink.internal.ImagePluginStack.ImageProvider;\n@@ -68,0 +73,1 @@\n+import jdk.tools.jlink.internal.TaskHelper.BadArgs;\n@@ -70,1 +76,1 @@\n-import jdk.tools.jlink.internal.ImagePluginStack.ImageProvider;\n+import jdk.tools.jlink.internal.runtimelink.ResourceDiff;\n@@ -72,3 +78,0 @@\n-import jdk.internal.opt.CommandLine;\n-import jdk.internal.module.ModulePath;\n-import jdk.internal.module.ModuleResolution;\n@@ -89,0 +92,1 @@\n+    public static final String JLINK_MOD_NAME = \"jdk.jlink\";\n@@ -185,1 +189,10 @@\n-        }, \"--ignore-signing-information\"),};\n+        }, \"--ignore-signing-information\"),\n+        new Option<JlinkTask>(false, (task, opt, arg) -> {\n+            task.options.ignoreModifiedRuntime = true;\n+        }, true, \"--ignore-modified-runtime\"),\n+        \/\/ option for generating linkable JDK runtimes (at JDK build time)\n+        new Option<JlinkTask>(false, (task, opt, arg) -> {\n+            task.options.generateLinkableRuntime = true;\n+        }, true, \"--generate-linkable-runtime\")\n+    };\n+\n@@ -225,0 +238,2 @@\n+        boolean ignoreModifiedRuntime = false;\n+        boolean generateLinkableRuntime = false;\n@@ -228,0 +243,4 @@\n+    \/\/ meta-data files per module for linkable JDK runtimes\n+    public static final String RESPATH_PATTERN = \"jdk\/tools\/jlink\/internal\/runtimelink\/fs_%s_files\";\n+    \/\/ The diff files per module for linkable JDK runtimes\n+    public static final String DIFF_PATTERN = \"jdk\/tools\/jlink\/internal\/runtimelink\/diff_%s\";\n@@ -273,5 +292,0 @@\n-\n-                if (options.modulePath.isEmpty()) {\n-                    throw taskHelper.newBadArgs(\"err.modulepath.must.be.specified\")\n-                            .showUsage(true);\n-                }\n@@ -359,0 +373,1 @@\n+                                    new OptionsValues(),\n@@ -373,1 +388,1 @@\n-            if (mod.equals(ALL_MODULE_PATH)) {\n+            if (mod.equals(ALL_MODULE_PATH) && options.modulePath.size() > 0) {\n@@ -394,0 +409,2 @@\n+        \/\/ Setup and init actions for JDK linkable runtimes\n+        LinkableRuntimesResult result = linkableJDKRuntimesInit(finder, roots);\n@@ -397,1 +414,88 @@\n-                                      finder);\n+                                      result.finder,\n+                                      result.isLinkFromRuntime,\n+                                      options.ignoreModifiedRuntime,\n+                                      options.generateLinkableRuntime);\n+    }\n+\n+    private static record LinkableRuntimesResult(boolean isLinkFromRuntime,\n+                                                 ModuleFinder finder) {}\n+\n+    \/**\n+     * Perform sanity checks and setup actions for JDK linkable runtime links\n+     *\n+     * @param finder The module finder from packaged modules\n+     * @param roots The roots (if any) of the modules.\n+     * @return A module finder possibly adding the system modules for JDK\n+     *         linkable runtimes if and only if java.base wasn't in the provided\n+     *         module finder already. Otherwise returns the provided finder.\n+     *         In both cases finders get the set of limited modules applied if\n+     *         so requested with --limit-modules.\n+     *\n+     * @throws BadArgs if the jlink input options contain an invalid\n+     *                 combination.\n+     *\/\n+    private LinkableRuntimesResult linkableJDKRuntimesInit(ModuleFinder finder,\n+                                                           Set<String> roots)\n+        throws BadArgs {\n+        \/\/ Linkable JDK runtimes and an empty module path in conjunction\n+        \/\/ with --keep-packaged-modules doesn't make sense as we are not linking\n+        \/\/ from packaged modules to begin with.\n+        if (options.modulePath.isEmpty() && options.packagedModulesPath != null) {\n+            throw taskHelper.newBadArgs(\"err.runtime.link.packaged.mods\");\n+        }\n+        boolean isLinkFromRuntime = options.modulePath.isEmpty();\n+        \/\/ In case of custom modules outside the JDK we may\n+        \/\/ have a non-empty module path, which must not include\n+        \/\/ java.base. If it did, we link using packaged modules from that\n+        \/\/ module path. If the module path does not include java.base, we must\n+        \/\/ have a linkable JDK runtime. In that case we take the JDK modules\n+        \/\/ from the run-time image.\n+        if (finder.find(\"java.base\").isEmpty()) {\n+            isLinkFromRuntime = true;\n+            ModuleFinder runtimeImageFinder = ModuleFinder.ofSystem();\n+            finder = combinedFinders(finder, runtimeImageFinder, options.limitMods, roots);\n+        }\n+        return new LinkableRuntimesResult(isLinkFromRuntime, finder);\n+    }\n+\n+    \/**\n+     * Creates a combined module finder of {@code finder} and\n+     * {@code runtimeImageFinder} that first looks-up modules in the\n+     * {@code runtimeImageFinder} and if not present in {@code finder}.\n+     *\n+     * @param finder A module finder based on packaged modules.\n+     * @param runtimeImageFinder A system modules finder.\n+     * @param limitMods The set of limited modules for the resulting\n+     *                  finder (if any).\n+     * @param roots All module roots.\n+     *\n+     * @return A combined finder, or the input finder, potentially applying\n+     *         module limits.\n+     *\/\n+    private ModuleFinder combinedFinders(ModuleFinder finder,\n+            ModuleFinder runtimeImageFinder, Set<String> limitMods,\n+            Set<String> roots) {\n+        ModuleFinder combined = new ModuleFinder() {\n+\n+            @Override\n+            public Optional<ModuleReference> find(String name) {\n+                Optional<ModuleReference> basic = runtimeImageFinder.find(name);\n+                if (basic.isEmpty()) {\n+                    return finder.find(name);\n+                }\n+                return basic;\n+            }\n+\n+            @Override\n+            public Set<ModuleReference> findAll() {\n+                Set<ModuleReference> all = new HashSet<>();\n+                all.addAll(runtimeImageFinder.findAll());\n+                all.addAll(finder.findAll());\n+                return Collections.unmodifiableSet(all);\n+            }\n+        };\n+        \/\/ if limitmods is specified then limit the universe\n+        if (limitMods != null && !limitMods.isEmpty()) {\n+            return limitFinder(combined, limitMods, Objects.requireNonNull(roots));\n+        }\n+        return combined;\n@@ -416,0 +520,1 @@\n+                                                        options,\n@@ -448,5 +553,0 @@\n-        if (Objects.requireNonNull(paths).isEmpty()) {\n-             throw new IllegalArgumentException(taskHelper.getMessage(\"err.empty.module.path\"));\n-        }\n-\n-        Path[] entries = paths.toArray(new Path[0]);\n@@ -454,2 +554,3 @@\n-        ModuleFinder finder = ModulePath.of(version, true, entries);\n-\n+        Path[] entries = paths.toArray(new Path[0]);\n+        ModuleFinder finder = paths.isEmpty() ? ModuleFinder.ofSystem()\n+                                              : ModulePath.of(version, true, entries);\n@@ -521,0 +622,1 @@\n+                                                   OptionsValues opts,\n@@ -537,0 +639,5 @@\n+        \/\/ Perform some sanity checks for linkable JDK runtimes\n+        if (config.linkFromRuntimeImage()) {\n+            sanityChecksLinkableJDKRuntime(log, cf, verbose);\n+        }\n+\n@@ -541,2 +648,7 @@\n-              .forEach(rm -> log.format(\"%s %s%n\",\n-                                        rm.name(), rm.reference().location().get()));\n+              .forEach(rm -> log.format(\"%s %s%s%n\",\n+                                        rm.name(),\n+                                        rm.reference().location().get(),\n+                                        \"jrt\".equals(rm.reference().location().get().getScheme())\n+                                            && config.linkFromRuntimeImage() ?\n+                                                \" \" + taskHelper.getMessage(\"runtime.link.jprt.path.extra\")\n+                                                : \"\"));\n@@ -583,1 +695,138 @@\n-        return new ImageHelper(cf, mods, targetPlatform, retainModulesPath, ignoreSigning);\n+\n+        \/\/ use the version of java.base module, if present, as\n+        \/\/ the release version for multi-release JAR files\n+        var version = cf.findModule(\"java.base\")\n+                        .map(ResolvedModule::reference)\n+                        .map(ModuleReference::descriptor)\n+                        .flatMap(ModuleDescriptor::version)\n+                        .map(ModuleDescriptor.Version::toString)\n+                        .map(Runtime.Version::parse)\n+                        .orElse(Runtime.version());\n+\n+        Set<Archive> archives = mods.entrySet().stream()\n+                .map(e -> newArchive(e.getKey(),\n+                                     e.getValue(),\n+                                     version,\n+                                     ignoreSigning,\n+                                     config))\n+                .collect(Collectors.toSet());\n+\n+        return new ImageHelper(archives,\n+                               targetPlatform,\n+                               retainModulesPath,\n+                               config.isGenerateRuntimeImage());\n+    }\n+\n+    \/**\n+     * Linkable JDK runtimes support. Perform some sanity checks if we run\n+     * jlink from the current run-time JDK image.\n+     *\n+     * @param log The log to write messages to.\n+     * @param cf The current configuration\n+     *\n+     * @throws IOException\n+     *\/\n+    private static void sanityChecksLinkableJDKRuntime(PrintWriter log,\n+                                                       Configuration cf,\n+                                                       boolean verbose) throws IOException {\n+        \/\/ Catch the case where we don't have a linkable JDK runtime. If so,\n+        \/\/ we don't have the per module resource diffs in the modules image\n+        String resourceName = String.format(DIFF_PATTERN, \"java.base\");\n+        InputStream inStream = JlinkTask.class.getModule().getResourceAsStream(resourceName);\n+        if (inStream == null) {\n+            \/\/ Only linkable JDK runtimes have those resources. Abort otherwise.\n+            String msg = taskHelper.getMessage(\"err.runtime.link.not.linkable.runtime\");\n+            throw new IllegalArgumentException(msg);\n+        }\n+        \/\/ Disallow jlink runs for linkable JDK runtimes with jdk.jlink included\n+        if (cf.findModule(JLINK_MOD_NAME).isPresent()) {\n+            String msg = taskHelper.getMessage(\"err.runtime.link.jdk.jlink.prohibited\");\n+            throw new IllegalArgumentException(msg);\n+        }\n+\n+        \/\/ Print info message indicating jlink is performed on a linkable JDK\n+        \/\/ runtime\n+        if (log != null && verbose) {\n+            log.println(taskHelper.getMessage(\"runtime.link.info\"));\n+        }\n+    }\n+\n+    private static Archive newArchive(String module,\n+                                      Path path,\n+                                      Runtime.Version version,\n+                                      boolean ignoreSigning,\n+                                      JlinkConfiguration config) {\n+        if (path.toString().endsWith(\".jmod\")) {\n+            return new JmodArchive(module, path);\n+        } else if (path.toString().endsWith(\".jar\")) {\n+            ModularJarArchive modularJarArchive = new ModularJarArchive(module, path, version);\n+            try (Stream<Archive.Entry> entries = modularJarArchive.entries()) {\n+                boolean hasSignatures = entries.anyMatch((entry) -> {\n+                    String name = entry.name().toUpperCase(Locale.ROOT);\n+\n+                    return name.startsWith(\"META-INF\/\") && name.indexOf('\/', 9) == -1 && (\n+                            name.endsWith(\".SF\") ||\n+                                    name.endsWith(\".DSA\") ||\n+                                    name.endsWith(\".RSA\") ||\n+                                    name.endsWith(\".EC\") ||\n+                                    name.startsWith(\"META-INF\/SIG-\")\n+                    );\n+                });\n+\n+                if (hasSignatures) {\n+                    if (ignoreSigning) {\n+                        System.err.println(taskHelper.getMessage(\"warn.signing\", path));\n+                    } else {\n+                        throw new IllegalArgumentException(taskHelper.getMessage(\"err.signing\", path));\n+                    }\n+                }\n+            }\n+            return modularJarArchive;\n+        } else if (!\"jrt\".equals(path.toUri().getScheme()) && Files.isDirectory(path)) {\n+            \/\/ The jrt URI path scheme conditional is there since we'd otherwise\n+            \/\/ enter this branch for linkable JDK runtimes where the path is\n+            \/\/ a jrt path and for the specific JDK module is a directory.\n+            Path modInfoPath = path.resolve(\"module-info.class\");\n+            if (Files.isRegularFile(modInfoPath)) {\n+                return new DirArchive(path, findModuleName(modInfoPath));\n+            } else {\n+                throw new IllegalArgumentException(\n+                        taskHelper.getMessage(\"err.not.a.module.directory\", path));\n+            }\n+        } else if (config.linkFromRuntimeImage()) {\n+            \/\/ This is after all other archive types, since user-provided\n+            \/\/ modules might be in any of the above forms and we'd like to\n+            \/\/ support them.\n+            \/\/\n+            \/\/ For linkable JDK runtimes the modules image includes resource\n+            \/\/ diffs on a per-module bases as part of the jdk.jlink module.\n+            \/\/ See ImageFileCreator.generateJImage() where those are added at\n+            \/\/ JDK build time for linkable JDK runtimes.\n+            \/\/\n+            \/\/ Here we retrieve the per module difference file, which is\n+            \/\/ potentially empty, from the modules image and pass that on to\n+            \/\/ JRTArchive for further processing. When streaming resources from\n+            \/\/ the archive, the diff is being applied.\n+            String diffResourceName = String.format(DIFF_PATTERN, module);\n+            List<ResourceDiff> perModuleDiff = null;\n+            try (InputStream in = JlinkTask.class.getModule().getResourceAsStream(diffResourceName)){\n+                perModuleDiff = ResourceDiff.read(in);\n+            } catch (IOException e) {\n+                throw new AssertionError(\"Failure to retrieve resource diff for \" +\n+                                         \"module \" + module, e);\n+            }\n+            return new JRTArchive(module, path, !config.ignoreModifiedRuntime(), perModuleDiff);\n+        } else {\n+            throw new IllegalArgumentException(\n+                    taskHelper.getMessage(\"err.not.modular.format\", module, path));\n+        }\n+    }\n+\n+    private static String findModuleName(Path modInfoPath) {\n+        try (BufferedInputStream bis = new BufferedInputStream(\n+                Files.newInputStream(modInfoPath))) {\n+            return ModuleDescriptor.read(bis).name();\n+        } catch (IOException exp) {\n+            throw new IllegalArgumentException(taskHelper.getMessage(\n+                    \"err.cannot.read.module.info\", modInfoPath), exp);\n+        }\n@@ -848,85 +1097,4 @@\n-    private static class ImageHelper implements ImageProvider {\n-        final Platform targetPlatform;\n-        final Path packagedModulesPath;\n-        final boolean ignoreSigning;\n-        final Runtime.Version version;\n-        final Set<Archive> archives;\n-\n-        ImageHelper(Configuration cf,\n-                    Map<String, Path> modsPaths,\n-                    Platform targetPlatform,\n-                    Path packagedModulesPath,\n-                    boolean ignoreSigning) throws IOException {\n-            Objects.requireNonNull(targetPlatform);\n-            this.targetPlatform = targetPlatform;\n-            this.packagedModulesPath = packagedModulesPath;\n-            this.ignoreSigning = ignoreSigning;\n-\n-            \/\/ use the version of java.base module, if present, as\n-            \/\/ the release version for multi-release JAR files\n-            this.version = cf.findModule(\"java.base\")\n-                .map(ResolvedModule::reference)\n-                .map(ModuleReference::descriptor)\n-                .flatMap(ModuleDescriptor::version)\n-                .map(ModuleDescriptor.Version::toString)\n-                .map(Runtime.Version::parse)\n-                .orElse(Runtime.version());\n-\n-            this.archives = modsPaths.entrySet().stream()\n-                                .map(e -> newArchive(e.getKey(), e.getValue()))\n-                                .collect(Collectors.toSet());\n-        }\n-\n-        private Archive newArchive(String module, Path path) {\n-            if (path.toString().endsWith(\".jmod\")) {\n-                return new JmodArchive(module, path);\n-            } else if (path.toString().endsWith(\".jar\")) {\n-                ModularJarArchive modularJarArchive = new ModularJarArchive(module, path, version);\n-\n-                try (Stream<Archive.Entry> entries = modularJarArchive.entries()) {\n-                    boolean hasSignatures = entries.anyMatch((entry) -> {\n-                        String name = entry.name().toUpperCase(Locale.ROOT);\n-\n-                        return name.startsWith(\"META-INF\/\") && name.indexOf('\/', 9) == -1 && (\n-                                name.endsWith(\".SF\") ||\n-                                name.endsWith(\".DSA\") ||\n-                                name.endsWith(\".RSA\") ||\n-                                name.endsWith(\".EC\") ||\n-                                name.startsWith(\"META-INF\/SIG-\")\n-                        );\n-                    });\n-\n-                    if (hasSignatures) {\n-                        if (ignoreSigning) {\n-                            System.err.println(taskHelper.getMessage(\"warn.signing\", path));\n-                        } else {\n-                            throw new IllegalArgumentException(taskHelper.getMessage(\"err.signing\", path));\n-                        }\n-                    }\n-                }\n-\n-                return modularJarArchive;\n-            } else if (Files.isDirectory(path)) {\n-                Path modInfoPath = path.resolve(\"module-info.class\");\n-                if (Files.isRegularFile(modInfoPath)) {\n-                    return new DirArchive(path, findModuleName(modInfoPath));\n-                } else {\n-                    throw new IllegalArgumentException(\n-                        taskHelper.getMessage(\"err.not.a.module.directory\", path));\n-                }\n-            } else {\n-                throw new IllegalArgumentException(\n-                    taskHelper.getMessage(\"err.not.modular.format\", module, path));\n-            }\n-        }\n-\n-        private static String findModuleName(Path modInfoPath) {\n-            try (BufferedInputStream bis = new BufferedInputStream(\n-                    Files.newInputStream(modInfoPath))) {\n-                return ModuleDescriptor.read(bis).name();\n-            } catch (IOException exp) {\n-                throw new IllegalArgumentException(taskHelper.getMessage(\n-                    \"err.cannot.read.module.info\", modInfoPath), exp);\n-            }\n-        }\n-\n+    private static record ImageHelper(Set<Archive> archives,\n+                                      Platform targetPlatform,\n+                                      Path packagedModulesPath,\n+                                      boolean generateRuntimeImage) implements ImageProvider {\n@@ -936,1 +1104,1 @@\n-                    targetPlatform.arch().byteOrder(), stack);\n+                    targetPlatform.arch().byteOrder(), stack, generateRuntimeImage);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":279,"deletions":111,"binary":false,"changes":390,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.tools.jlink.internal.runtimelink;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.jimage.BasicImageReader;\n+\n+public class ImageReader extends BasicImageReader implements JimageDiffGenerator.ImageResource {\n+\n+    public ImageReader(Path path) throws IOException {\n+        super(path);\n+    }\n+\n+    public static boolean isNotTreeInfoResource(String path) {\n+        return !(path.startsWith(\"\/packages\") || path.startsWith(\"\/modules\"));\n+    }\n+\n+    @Override\n+    public List<String> getEntries() {\n+        return Arrays.asList(getEntryNames()).stream()\n+                .filter(ImageReader::isNotTreeInfoResource)\n+                .sorted()\n+                .collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public byte[] getResourceBytes(String name) {\n+        return getResource(name);\n+    }\n+\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/ImageReader.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.tools.jlink.internal.runtimelink;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+\/**\n+ * Generates a delta between packaged modules (as an ImageResource) and an\n+ * optimized jimage (lib\/modules) as an ImageResource. The result can be\n+ * serialized to a file using {@link ResourceDiff}.\n+ *\/\n+public class JimageDiffGenerator {\n+\n+    \/**\n+     * A resource used for linking jimages. Either packaged modules or\n+     * an existing JDK jimage. The canonical source, the packaged modules,\n+     * are being used to devise a delta to a JDK jimage which can then be\n+     * also used for jlink input together *with* that delta.\n+     *\/\n+    @SuppressWarnings(\"try\")\n+    public interface ImageResource extends AutoCloseable {\n+        public List<String> getEntries();\n+        public byte[] getResourceBytes(String name);\n+    }\n+\n+    public List<ResourceDiff> generateDiff(ImageResource baseImg, ImageResource optImage) throws Exception {\n+        List<String> baseResources;\n+        Set<String> optResSet = new HashSet<>();\n+        List<ResourceDiff> diffs = new ArrayList<>();\n+        try (baseImg;\n+             optImage) {\n+            optResSet.addAll(optImage.getEntries());\n+            baseResources = baseImg.getEntries();\n+            for (String item: baseResources) {\n+                byte[] baseBytes = baseImg.getResourceBytes(item);\n+                \/\/ First check that every item in the base image exist in\n+                \/\/ the optimized image as well. If it does not, it's a removed\n+                \/\/ item in the optimized image.\n+                if (!optResSet.remove(item)) {\n+                    \/\/ keep track of original bytes for removed item in the\n+                    \/\/ optimized image, since we need to restore them for the\n+                    \/\/ runtime image link\n+                    ResourceDiff.Builder builder = new ResourceDiff.Builder();\n+                    ResourceDiff diff = builder.setKind(ResourceDiff.Kind.REMOVED)\n+                           .setName(item)\n+                           .setResourceBytes(baseBytes)\n+                           .build();\n+                    diffs.add(diff);\n+                    continue;\n+                }\n+                \/\/ Verify resource bytes are equal if present in both images\n+                boolean contentEquals = Arrays.equals(baseBytes, optImage.getResourceBytes(item));\n+                if (!contentEquals) {\n+                    \/\/ keep track of original bytes (non-optimized)\n+                    ResourceDiff.Builder builder = new ResourceDiff.Builder();\n+                    ResourceDiff diff = builder.setKind(ResourceDiff.Kind.MODIFIED)\n+                        .setName(item)\n+                        .setResourceBytes(baseBytes)\n+                        .build();\n+                    diffs.add(diff);\n+                }\n+            }\n+        }\n+        \/\/ What's now left in optResSet are the resources only present in the\n+        \/\/ optimized image (generated by some plugins; not present in jmods)\n+        for (String e: optResSet) {\n+            ResourceDiff.Builder builder = new ResourceDiff.Builder();\n+            ResourceDiff diff = builder.setKind(ResourceDiff.Kind.ADDED)\n+                                    .setName(e)\n+                                    .build();\n+            diffs.add(diff);\n+        }\n+        return diffs;\n+    }\n+\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/JimageDiffGenerator.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.tools.jlink.internal.runtimelink;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReader;\n+import java.lang.module.ModuleReference;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.module.ModulePath;\n+\n+@SuppressWarnings(\"try\")\n+public class JmodsReader implements JimageDiffGenerator.ImageResource {\n+\n+    private final ModuleFinder finder;\n+\n+    public JmodsReader(Path packagedModulesDir) {\n+        List<Path> pa;\n+        try {\n+            pa = Files.list(packagedModulesDir).filter(p -> !p.endsWith(\".jmod\")).collect(Collectors.toList());\n+        } catch (IOException e) {\n+            throw new IllegalStateException(\"Listing of jmods directory failed!\", e);\n+        }\n+        Path[] paths = pa.toArray(new Path[0]);\n+        this.finder = ModulePath.of(Runtime.version(), true, paths);\n+    }\n+\n+    @Override\n+    public void close() throws Exception {\n+        \/\/ nothing\n+    }\n+\n+    @Override\n+    public List<String> getEntries() {\n+        List<String> all = new ArrayList<>();\n+        try {\n+            Set<ModuleReference> allMods = finder.findAll();\n+            for (ModuleReference mRef: allMods) {\n+                String moduleName = mRef.descriptor().name();\n+                ModuleReader reader = mRef.open();\n+                List<String> perModule = reader.list().map(a -> {return \"\/\" + moduleName + \"\/\" + a;}).collect(Collectors.toList());\n+                all.addAll(perModule);\n+            }\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        Collections.sort(all);\n+        return all;\n+    }\n+\n+    @Override\n+    public byte[] getResourceBytes(String name) {\n+        String moduleName = moduleName(name);\n+        if (moduleName == null) {\n+            throw new IllegalArgumentException(\"Module name not found in \" + name);\n+        }\n+        ModuleReference ref = finder.find(moduleName).orElseThrow();\n+        String refName = stripModuleName(name);\n+        try (ModuleReader reader = ref.open()) {\n+            return reader.open(refName).orElseThrow().readAllBytes();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    private String moduleName(String name) {\n+        int secondSlash = name.indexOf(\"\/\", 1);\n+        if (secondSlash != -1) {\n+            return name.substring(1, secondSlash);\n+        }\n+        return null;\n+    }\n+\n+    private String stripModuleName(String name) {\n+        int secondSlash = name.indexOf(\"\/\", 1);\n+        return name.substring(secondSlash + 1); \/\/ omit the leading slash\n+    }\n+\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/JmodsReader.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,289 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.tools.jlink.internal.runtimelink;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Class representing a difference of a jimage resource. For all intents\n+ * and purposes this represents a difference between a resource in an optimized\n+ * jimage (e.g. images\/jdk\/lib\/modules) and the underlying basic resources from\n+ * which the optimized image got derived from (e.g. packaged modules). The\n+ * differences are being used in JRTArchive so as to back-track from an optimized\n+ * jimage to the original (i.e. it restores original resources using the diff).\n+ *\/\n+public class ResourceDiff implements Comparable<ResourceDiff> {\n+\n+    private static final int MAGIC = 0xabba;\n+\n+    public static enum Kind {\n+        ADDED((short)1),    \/\/ Resource added\n+        REMOVED((short)2),  \/\/ Resource removed\n+        MODIFIED((short)3); \/\/ Resource modified\n+\n+        private short value;\n+\n+        private Kind(short value) {\n+            this.value = value;\n+        }\n+\n+        public short value() {\n+            return value;\n+        }\n+\n+        static Kind fromShort(short v) {\n+            if (v > 3 || v < 1) {\n+                throw new IllegalArgumentException(\"Must be within range [1-3]\");\n+            }\n+            switch (v) {\n+            case 1: return ADDED;\n+            case 2: return REMOVED;\n+            case 3: return MODIFIED;\n+            }\n+            throw new IllegalStateException(\"Must not reach here!\");\n+        }\n+    }\n+\n+    private final Kind kind;\n+    private final byte[] resourceBytes;\n+    private final String name;\n+\n+    private ResourceDiff(Kind kind, String name, byte[] resourceBytes) {\n+        this.kind = kind;\n+        this.name = name;\n+        if ((kind == Kind.REMOVED || kind == Kind.MODIFIED) &&\n+                resourceBytes == null) {\n+            throw new AssertionError(\"Resource bytes must be set for REMOVED or MODIFIED\");\n+        }\n+        this.resourceBytes = resourceBytes;\n+    }\n+\n+    public Kind getKind() {\n+        return kind;\n+    }\n+\n+    public byte[] getResourceBytes() {\n+        return resourceBytes;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public int compareTo(ResourceDiff o) {\n+        int kindComp = kind.value() - o.kind.value();\n+        if (kindComp == 0) {\n+            return getName().compareTo(o.getName());\n+        } else {\n+            return kindComp;\n+        }\n+    }\n+\n+    public static class Builder {\n+        private Kind kind;\n+        private String name;\n+        private byte[] resourceBytes;\n+\n+        public Builder setKind(Kind kind) {\n+            this.kind = kind;\n+            return this;\n+        }\n+        public Builder setName(String name) {\n+            this.name = Objects.requireNonNull(name);\n+            return this;\n+        }\n+        public Builder setResourceBytes(byte[] resourceBytes) {\n+            this.resourceBytes = Objects.requireNonNull(resourceBytes);\n+            return this;\n+        }\n+        public ResourceDiff build() {\n+            if (kind == null || name == null) {\n+                throw new IllegalStateException(\"kind and name must be set\");\n+            }\n+            switch (kind) {\n+            case ADDED:\n+                {\n+                    break; \/\/ null bytes for added is OK.\n+                }\n+            case MODIFIED: \/\/ fall-through\n+            case REMOVED:\n+                {\n+                    if (resourceBytes == null) {\n+                        throw new IllegalStateException(\"Original bytes needed for MODIFIED, REMOVED!\");\n+                    }\n+                    break;\n+                }\n+            default:\n+                break;\n+            }\n+            return new ResourceDiff(kind, name, resourceBytes);\n+        }\n+    }\n+\n+    \/**\n+     * Writes a list of resource diffs to an output stream\n+     *\n+     * @param diffs The list of resource diffs to write.\n+     * @param out The stream to write the serialized bytes to.\n+     *\/\n+    public static void write(List<ResourceDiff> diffs, OutputStream out) throws IOException {\n+        \/*\n+         * Simple binary format:\n+         *\n+         * <header>|<items>\n+         *\n+         * ****************************************\n+         * HEADER info\n+         * ****************************************\n+         *\n+         * where <header> is ('|' separation for clarity):\n+         *\n+         *  <int>|<int>\n+         *\n+         * The first integer is the MAGIC, 0xabba. The second integer is the\n+         * total number of items.\n+         *\n+         * *****************************************\n+         * ITEMS info\n+         * *****************************************\n+         *\n+         * Each <item> consists of ('|' separation for clarity):\n+         *\n+         * <short>|<int>|<name-bytes-utf>|<int>|<resource-bytes>\n+         *\n+         * Where the individual items are:\n+         *\n+         * <short>:\n+         *     The value of the respective ResourceDiff.Kind.\n+         * <int>:\n+         *     The length of the name bytes (in UTF-8).\n+         * <name-bytes-utf>:\n+         *     The resource name bytes in UTF-8.\n+         * <int>:\n+         *     The length of the resource bytes. 0 (zero) if no resource bytes.\n+         *     A.k.a 'null'.\n+         * <resource-bytes>:\n+         *     The bytes of the resource as stored in the jmod files.\n+         *\/\n+        try (DataOutputStream dataOut = new DataOutputStream(out)) {\n+            dataOut.writeInt(MAGIC);\n+            dataOut.writeInt(diffs.size());\n+            for (ResourceDiff d: diffs) {\n+                dataOut.writeShort(d.kind.value());\n+                byte[] buf = d.name.getBytes(StandardCharsets.UTF_8);\n+                dataOut.writeInt(buf.length);\n+                dataOut.write(buf);\n+                buf = d.resourceBytes;\n+                dataOut.writeInt(buf == null ? 0 : buf.length);\n+                if (buf != null) {\n+                    dataOut.write(buf);\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw e;\n+        }\n+    }\n+\n+    \/**\n+     * Read a list of resource diffs from an input stream.\n+     *\n+     * @param in The input stream to read from\n+     * @return The list of resource diffs.\n+     *\/\n+    public static List<ResourceDiff> read(InputStream in) throws IOException {\n+        \/*\n+         * See write() for the details how this is being written\n+         *\/\n+        List<ResourceDiff> diffs;\n+        try (DataInputStream din = new DataInputStream(in)) {\n+            int magic = din.readInt();\n+            if (magic != MAGIC) {\n+                throw new IllegalArgumentException(\"Not a ResourceDiff data stream!\");\n+            }\n+            int numItems = din.readInt();\n+            diffs = new ArrayList<>(numItems);\n+            for (int i = 0; i < numItems; i++) {\n+                Kind k = Kind.fromShort(din.readShort());\n+                int numBytes = din.readInt();\n+                byte[] buf = readNumBytesFromStream(din, numBytes);\n+                String name = new String(buf, StandardCharsets.UTF_8);\n+                numBytes = din.readInt();\n+                byte[] resBytes = null;\n+                if (numBytes != 0) {\n+                    resBytes = readNumBytesFromStream(din, numBytes);\n+                }\n+                Builder builder = new Builder();\n+                builder.setKind(k)\n+                       .setName(name);\n+                if (resBytes != null) {\n+                    builder.setResourceBytes(resBytes);\n+                }\n+                diffs.add(builder.build());\n+            }\n+        }\n+        return diffs;\n+    }\n+\n+    private static byte[] readNumBytesFromStream(DataInputStream din, int numBytes) throws IOException {\n+        byte[] b = new byte[numBytes];\n+        for (int i = 0; i < numBytes; i++) {\n+            int data = din.read();\n+            if (data == -1) {\n+                throw new IOException(\"Short read!\");\n+            }\n+            b[i] = (byte)data;\n+        }\n+        return b;\n+    }\n+\n+    public static void printDiffs(List<ResourceDiff> diffs) {\n+        for (ResourceDiff diff: diffs.stream().sorted().collect(Collectors.toList())) {\n+            switch (diff.getKind()) {\n+            case ADDED:\n+                System.out.println(\"Only added in opt: \" + diff.getName());\n+                break;\n+            case MODIFIED:\n+                System.out.println(\"Modified in opt: \" + diff.getName());\n+                break;\n+            case REMOVED:\n+                System.out.println(\"Removed in opt: \" + diff.getName());\n+                break;\n+            default:\n+                break;\n+            }\n+        }\n+    }\n+\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/ResourceDiff.java","additions":289,"deletions":0,"binary":false,"changes":289,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal.runtimelink;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+import jdk.tools.jlink.internal.runtimelink.JimageDiffGenerator.ImageResource;\n+import jdk.tools.jlink.plugin.ResourcePool;\n+\n+@SuppressWarnings(\"try\")\n+public class ResourcePoolReader implements ImageResource {\n+\n+    private final ResourcePool pool;\n+\n+    public ResourcePoolReader(ResourcePool pool) {\n+        this.pool = Objects.requireNonNull(pool);\n+    }\n+\n+    @Override\n+    public void close() throws Exception {\n+        \/\/ nothing\n+    }\n+\n+    @Override\n+    public List<String> getEntries() {\n+        return pool.entries().map(a -> a.path()).toList();\n+    }\n+\n+    @Override\n+    public byte[] getResourceBytes(String name) {\n+        return pool.findEntry(name).orElseThrow().contentBytes();\n+    }\n+\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/ResourcePoolReader.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal.runtimelink;\n+\n+\/**\n+ * Exception thrown for links without packaged modules. I.e. run-image link.\n+ *\n+ *\/\n+public class RuntimeImageLinkException extends IllegalStateException {\n+\n+    private static final long serialVersionUID = -1848914673073119403L;\n+\n+    private final IllegalArgumentException iae;\n+\n+    public RuntimeImageLinkException(IllegalArgumentException cause) {\n+        super(cause);\n+        this.iae = cause;\n+    }\n+\n+    public IllegalArgumentException getReason() {\n+        return iae;\n+    }\n+\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/RuntimeImageLinkException.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n-import java.io.InputStream;\n@@ -29,0 +28,1 @@\n+import java.io.InputStream;\n@@ -71,1 +71,15 @@\n-        TOP\n+        TOP;\n+\n+        public static Type fromOrdinal(int value) {\n+            Type retval = null;\n+            for (Type v: Type.values()) {\n+                if (v.ordinal() == value) {\n+                    retval = v;\n+                    break;\n+                }\n+            }\n+            if (retval == null) {\n+                throw new IllegalArgumentException(\"Illegal ordinal: \" + value);\n+            }\n+            return retval;\n+        }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/plugin\/ResourcePoolEntry.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -118,0 +118,5 @@\n+err.runtime.link.not.linkable.runtime=The current run-time image does not support run-time linking.\n+err.runtime.link.jdk.jlink.prohibited=This JDK does not contain packaged modules\\\n+\\ and cannot be used to create another run-time image that includes the jdk.jlink module.\n+err.runtime.link.packaged.mods=--keep-packaged-modules is not allowed. This linkable run-time image\\\n+\\ does not include packaged modules.\n@@ -160,0 +165,3 @@\n+\n+runtime.link.info=Linking based on the current run-time image.\n+runtime.link.jprt.path.extra=(run-time image)\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -91,1 +91,3 @@\n-    jdk.containerized\n+    jdk.containerized \\\n+    jlink.runtime.linkable \\\n+    jlink.packagedModules\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -107,1 +107,3 @@\n-    jdk.foreign.linker\n+    jdk.foreign.linker \\\n+    jlink.runtime.linkable \\\n+    jlink.packagedModules\n","filename":"test\/jdk\/TEST.ROOT","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+\n+import jdk.tools.jlink.builder.ImageBuilder;\n@@ -38,0 +40,1 @@\n+import jdk.tools.jlink.internal.ExecutableImage;\n@@ -40,2 +43,0 @@\n-import jdk.tools.jlink.internal.ExecutableImage;\n-import jdk.tools.jlink.builder.ImageBuilder;\n@@ -226,1 +227,1 @@\n-        ImageFileCreator.create(archives, ByteOrder.nativeOrder(), stack);\n+        ImageFileCreator.create(archives, ByteOrder.nativeOrder(), stack, false);\n","filename":"test\/jdk\/tools\/jlink\/ImageFileCreatorTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.nio.ByteOrder;\n@@ -41,2 +40,1 @@\n-import jdk.tools.jlink.internal.Jlink;\n-import jdk.tools.jlink.internal.JlinkTask;\n+\n@@ -44,4 +42,0 @@\n-import jdk.tools.jlink.internal.Platform;\n-import jdk.tools.jlink.plugin.ResourcePool;\n-import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n-import jdk.tools.jlink.plugin.Plugin;\n@@ -49,0 +43,1 @@\n+import jdk.tools.jlink.internal.Jlink;\n@@ -51,0 +46,2 @@\n+import jdk.tools.jlink.internal.JlinkTask;\n+import jdk.tools.jlink.internal.Platform;\n@@ -52,3 +49,3 @@\n-import jdk.tools.jlink.internal.plugins.DefaultCompressPlugin;\n-import jdk.tools.jlink.internal.plugins.DefaultStripDebugPlugin;\n-\n+import jdk.tools.jlink.plugin.Plugin;\n+import jdk.tools.jlink.plugin.ResourcePool;\n+import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n@@ -77,2 +74,0 @@\n-    private static final List<Integer> ordered = new ArrayList<>();\n-\n@@ -165,1 +160,1 @@\n-                JlinkTask.newModuleFinder(modulePaths, limits, mods));\n+                JlinkTask.newModuleFinder(modulePaths, limits, mods), false, false, false);\n","filename":"test\/jdk\/tools\/jlink\/IntegrationTest.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -24,3 +24,0 @@\n-import jdk.test.lib.compiler.CompilerUtils;\n-import tests.JImageGenerator;\n-\n@@ -32,0 +29,22 @@\n+import jdk.test.lib.compiler.CompilerUtils;\n+import tests.JImageGenerator;\n+\n+\/*\n+ * @test id=packaged_modules\n+ * @summary Make sure that modules can be linked using jlink\n+ * and deduplication works correctly when creating sub methods\n+ * @bug 8311591\n+ * @library \/test\/lib\n+ *          ..\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jmod\n+ *          jdk.jlink\/jdk.tools.jimage\n+ *          jdk.compiler\n+ * @build tests.* JLinkDedupTestBatchSizeOne jdk.test.lib.compiler.CompilerUtils\n+ * @requires jlink.packagedModules\n+ * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLinkDedupTestBatchSizeOne false\n+ *\/\n+\n@@ -33,1 +52,1 @@\n- * @test\n+ * @test id=linkable_jdk_runtimes\n@@ -46,0 +65,1 @@\n+ * @requires (jlink.runtime.linkable & !jlink.packagedModules)\n@@ -47,1 +67,1 @@\n- * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLinkDedupTestBatchSizeOne\n+ * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLinkDedupTestBatchSizeOne true\n@@ -57,4 +77,0 @@\n-    private static final String MODULE_PATH =\n-            Paths.get(JAVA_HOME, \"jmods\").toString() +\n-                    File.pathSeparator + MODS_DIR.toString();\n-\n@@ -72,2 +88,7 @@\n-    public static void compileAll() throws Throwable {\n-        if (!hasJmods()) return;\n+    private static String modulePath(boolean linkableRuntime) {\n+        return (linkableRuntime ? \"\" : (Paths.get(JAVA_HOME, \"jmods\").toString() +\n+                                        File.pathSeparator)) + MODS_DIR.toString();\n+    }\n+\n+    public static void compileAll(boolean linkableRuntime) throws Throwable {\n+        if (!linkableRuntime && !hasJmods()) return;\n@@ -83,1 +104,8 @@\n-        compileAll();\n+        if (args.length != 1) {\n+            throw new AssertionError(\"Wrong number of arguments for the test!\");\n+        }\n+        boolean linkableRuntime = Boolean.parseBoolean(args[0]);\n+        System.out.println(\"Running test on \" +\n+                               (linkableRuntime ? \"a linkable JDK runtime\" :\n+                                   \"packaged modules\") + \".\");\n+        compileAll(linkableRuntime);\n@@ -87,1 +115,1 @@\n-                .modulePath(MODULE_PATH)\n+                .modulePath(modulePath(linkableRuntime))\n","filename":"test\/jdk\/tools\/jlink\/JLinkDedupTestBatchSizeOne.java","additions":41,"deletions":13,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,541 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Scanner;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import tests.Helper;\n+import tests.JImageValidator;\n+\n+public abstract class AbstractLinkableRuntimeTest {\n+\n+    protected static final boolean DEBUG = true;\n+\n+    public void run() throws Exception {\n+        Helper helper = Helper.newHelper(true \/* JDK linkable runtime tests *\/);\n+        if (helper == null) {\n+            System.err.println(AbstractLinkableRuntimeTest.class.getSimpleName() +\n+                               \": Test not run\");\n+            return;\n+        }\n+        runTest(helper);\n+        System.out.println(getClass().getSimpleName() + \" PASSED!\");\n+    }\n+\n+    \/** main test entrypoint **\/\n+    abstract void runTest(Helper helper) throws Exception;\n+\n+    \/**\n+     * Ensure 'java --list-modules' lists the correct set of modules in the given\n+     * image.\n+     *\n+     * @param jlinkImage\n+     * @param expectedModules\n+     *\/\n+    protected void verifyListModules(Path image,\n+            List<String> expectedModules) throws Exception {\n+        OutputAnalyzer out = runJavaCmd(image, List.of(\"--list-modules\"));\n+        List<String> actual = parseListMods(out.getStdout());\n+        Collections.sort(actual);\n+        if (!expectedModules.equals(actual)) {\n+            throw new AssertionError(\"Different modules! Expected \" + expectedModules + \" got: \" + actual);\n+        }\n+    }\n+\n+    protected OutputAnalyzer runJavaCmd(Path image, List<String> options) throws Exception {\n+        Path targetJava = image.resolve(\"bin\").resolve(getJava());\n+        List<String> cmd = new ArrayList<>();\n+        cmd.add(targetJava.toString());\n+        for (String opt: options) {\n+            cmd.add(opt);\n+        }\n+        List<String> javaCmd = Collections.unmodifiableList(cmd);\n+        OutputAnalyzer out;\n+        try {\n+            out = ProcessTools.executeCommand(javaCmd.toArray(new String[0]));\n+        } catch (Throwable e) {\n+            throw new Exception(\"Process failed to execute\", e);\n+        }\n+        if (out.getExitValue() != 0) {\n+            if (DEBUG) {\n+                System.err.println(\"Process stdout was: \");\n+                System.err.println(out.getStdout());\n+                System.err.println(\"Process stderr was: \");\n+                System.err.println(out.getStderr());\n+            }\n+            throw new AssertionError(\"'\" + javaCmd.stream().collect(Collectors.joining(\" \")) + \"'\"\n+                    + \" expected to succeed!\");\n+        }\n+        return out;\n+    }\n+\n+    protected Path createJavaImageRuntimeLink(BaseJlinkSpec baseSpec) throws Exception {\n+        \/\/ create a base image only containing the jdk.jlink module and its transitive closure\n+        Path runtimeJlinkImage = createRuntimeLinkImage(baseSpec);\n+\n+        \/\/ On Windows jvm.dll is in 'bin' after the jlink\n+        Path libjvm = Path.of((isWindows() ? \"bin\" : \"lib\"), \"server\", System.mapLibraryName(\"jvm\"));\n+        JlinkSpecBuilder builder = new JlinkSpecBuilder();\n+        \/\/ And expect libjvm (not part of the jimage) to be present in the resulting image\n+        builder.expectedFile(libjvm.toString())\n+               .helper(baseSpec.getHelper())\n+               .name(baseSpec.getName())\n+               .validatingModule(baseSpec.getValidatingModule())\n+               .imagePath(runtimeJlinkImage)\n+               .expectedLocation(\"\/java.base\/java\/lang\/String.class\");\n+        for (String m: baseSpec.getModules()) {\n+            builder.addModule(m);\n+        }\n+        for (String extra: baseSpec.getExtraOptions()) {\n+            builder.extraJlinkOpt(extra);\n+        }\n+        return jlinkUsingImage(builder.build());\n+    }\n+\n+    protected Path jlinkUsingImage(JlinkSpec spec) throws Exception {\n+        return jlinkUsingImage(spec, new RuntimeLinkOutputAnalyzerHandler());\n+    }\n+\n+    protected Path jlinkUsingImage(JlinkSpec spec, OutputAnalyzerHandler handler) throws Exception {\n+        return jlinkUsingImage(spec, handler, new DefaultSuccessExitPredicate());\n+    }\n+\n+    protected Path jlinkUsingImage(JlinkSpec spec, OutputAnalyzerHandler handler, Predicate<OutputAnalyzer> exitChecker) throws Exception {\n+        String jmodLessGeneratedImage = \"target-jmodless-\" + spec.getName();\n+        Path targetImageDir = spec.getHelper().createNewImageDir(jmodLessGeneratedImage);\n+        Path targetJlink = spec.getImageToUse().resolve(\"bin\").resolve(getJlink());\n+        String[] jlinkCmdArray = new String[] {\n+                targetJlink.toString(),\n+                \"--output\", targetImageDir.toString(),\n+                \"--verbose\",\n+                \"--add-modules\", spec.getModules().stream().collect(Collectors.joining(\",\"))\n+        };\n+        List<String> jlinkCmd = new ArrayList<>();\n+        jlinkCmd.addAll(Arrays.asList(jlinkCmdArray));\n+        if (spec.getExtraJlinkOpts() != null && !spec.getExtraJlinkOpts().isEmpty()) {\n+            jlinkCmd.addAll(spec.getExtraJlinkOpts());\n+        }\n+        if (spec.getModulePath() != null) {\n+            for (String mp: spec.getModulePath()) {\n+                jlinkCmd.add(\"--module-path\");\n+                jlinkCmd.add(mp);\n+            }\n+        }\n+        jlinkCmd = Collections.unmodifiableList(jlinkCmd); \/\/ freeze\n+        System.out.println(\"DEBUG: jmod-less jlink command: \" + jlinkCmd.stream().collect(\n+                                                    Collectors.joining(\" \")));\n+        OutputAnalyzer analyzer = null;\n+        try {\n+            analyzer = ProcessTools.executeProcess(jlinkCmd.toArray(new String[0]));\n+        } catch (Throwable t) {\n+            throw new AssertionError(\"Executing process failed!\", t);\n+        }\n+        if (!exitChecker.test(analyzer)) {\n+            if (DEBUG) {\n+                System.err.println(\"Process stdout was: \");\n+                System.err.println(analyzer.getStdout());\n+                System.err.println(\"Process stderr was: \");\n+                System.err.println(analyzer.getStderr());\n+            }\n+            \/\/ if the exit checker failed, we expected the other outcome\n+            \/\/ i.e. fail for success and success for fail.\n+            boolean successExit = analyzer.getExitValue() == 0;\n+            String msg = String.format(\"Expected jlink to %s given a jmodless image. Exit code was: %d\",\n+                                       (successExit ? \"fail\" : \"pass\"), analyzer.getExitValue());\n+            throw new AssertionError(msg);\n+        }\n+        handler.handleAnalyzer(analyzer); \/\/ Give tests a chance to process in\/output\n+\n+        \/\/ validate the resulting image; Includes running 'java -version', only do this\n+        \/\/ if the jlink succeeded.\n+        if (analyzer.getExitValue() == 0) {\n+            JImageValidator validator = new JImageValidator(spec.getValidatingModule(), spec.getExpectedLocations(),\n+                    targetImageDir.toFile(), spec.getUnexpectedLocations(), Collections.emptyList(), spec.getExpectedFiles());\n+            validator.validate(); \/\/ This doesn't validate locations\n+            if (!spec.getExpectedLocations().isEmpty() || !spec.getUnexpectedLocations().isEmpty()) {\n+                JImageValidator.validate(targetImageDir.resolve(\"lib\").resolve(\"modules\"), spec.getExpectedLocations(), spec.getUnexpectedLocations());\n+            }\n+        }\n+        return targetImageDir;\n+    }\n+\n+    \/**\n+     * Prepares the test for execution. This assumes the current jimage is\n+     * runtime-linkable. However, since the 'jmods' dir is present (default jmods\n+     * module path), it needs to get removed to provoke a runtime link.\n+     *\n+     * @param baseSpec\n+     * @return A path to a JDK image which is prepared for runtime linking.\n+     * @throws Exception\n+     *\/\n+    protected Path createRuntimeLinkImage(BaseJlinkSpec baseSpec) throws Exception {\n+        Path runtimeJlinkImage = baseSpec.getHelper().createNewImageDir(baseSpec.getName() + \"-jlink\");\n+        copyJDKTreeWithoutJmods(runtimeJlinkImage);\n+        \/\/ Verify the base image is actually without packaged modules\n+        if (Files.exists(runtimeJlinkImage.resolve(\"jmods\"))) {\n+            throw new AssertionError(\"Must not contain 'jmods' directory\");\n+        }\n+        return runtimeJlinkImage;\n+    }\n+\n+    private void copyJDKTreeWithoutJmods(Path runtimeJlinkImage) throws Exception {\n+        Files.createDirectory(runtimeJlinkImage);\n+        String javaHome = System.getProperty(\"java.home\");\n+        Path root = Path.of(javaHome);\n+        Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+            @Override\n+            public FileVisitResult preVisitDirectory(Path dir,\n+                    BasicFileAttributes attrs) throws IOException {\n+                Objects.requireNonNull(dir);\n+                Path relative = root.relativize(dir);\n+                if (relative.getFileName().equals(Path.of(\"jmods\"))) {\n+                    return FileVisitResult.SKIP_SUBTREE;\n+                }\n+                \/\/ Create dir in destination location\n+                Path targetDir = runtimeJlinkImage.resolve(relative);\n+                if (!Files.exists(targetDir)) {\n+                    Files.createDirectory(targetDir);\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                    throws IOException {\n+                Path relative = root.relativize(file);\n+                Files.copy(file, runtimeJlinkImage.resolve(relative), StandardCopyOption.REPLACE_EXISTING);\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+\n+    }\n+\n+    private List<String> parseListMods(String output) throws Exception {\n+        List<String> outputLines = new ArrayList<>();\n+        try (Scanner lineScan = new Scanner(output)) {\n+            while (lineScan.hasNextLine()) {\n+                outputLines.add(lineScan.nextLine());\n+            }\n+        }\n+        return outputLines.stream()\n+                .map(a -> { return a.split(\"@\", 2)[0];})\n+                .filter(a -> !a.isBlank())\n+                .collect(Collectors.toList());\n+    }\n+\n+    private String getJlink() {\n+        return getBinary(\"jlink\");\n+    }\n+\n+    private String getJava() {\n+        return getBinary(\"java\");\n+    }\n+\n+    private String getBinary(String binary) {\n+        return isWindows() ? binary + \".exe\" : binary;\n+    }\n+\n+    protected static boolean isWindows() {\n+        return System.getProperty(\"os.name\").startsWith(\"Windows\");\n+    }\n+\n+    static class BaseJlinkSpec {\n+        final Helper helper;\n+        final String name;\n+        final String validatingModule;\n+        final List<String> modules;\n+        final List<String> extraOptions;\n+\n+        BaseJlinkSpec(Helper helper, String name, String validatingModule,\n+                List<String> modules, List<String> extraOptions) {\n+            this.helper = helper;\n+            this.name = name;\n+            this.modules = modules;\n+            this.extraOptions = extraOptions;\n+            this.validatingModule = validatingModule;\n+        }\n+\n+        public String getValidatingModule() {\n+            return validatingModule;\n+        }\n+\n+        public Helper getHelper() {\n+            return helper;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public List<String> getModules() {\n+            return modules;\n+        }\n+\n+        public List<String> getExtraOptions() {\n+            return extraOptions;\n+        }\n+    }\n+\n+    static class BaseJlinkSpecBuilder {\n+        Helper helper;\n+        String name;\n+        String validatingModule;\n+        List<String> modules = new ArrayList<>();\n+        List<String> extraOptions = new ArrayList<>();\n+\n+        BaseJlinkSpecBuilder addModule(String module) {\n+            modules.add(module);\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder addExtraOption(String option) {\n+            extraOptions.add(option);\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder helper(Helper helper) {\n+            this.helper = helper;\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder name(String name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder validatingModule(String module) {\n+            this.validatingModule = module;\n+            return this;\n+        }\n+\n+        BaseJlinkSpec build() {\n+            if (name == null) {\n+                throw new IllegalStateException(\"Name must be set\");\n+            }\n+            if (helper == null) {\n+                throw new IllegalStateException(\"helper must be set\");\n+            }\n+            if (validatingModule == null) {\n+                throw new IllegalStateException(\"the module which should get validated must be set\");\n+            }\n+            return new BaseJlinkSpec(helper, name, validatingModule, modules, extraOptions);\n+        }\n+    }\n+\n+    static class JlinkSpec {\n+        final Path imageToUse;\n+        final Helper helper;\n+        final String name;\n+        final List<String> modules;\n+        final String validatingModule;\n+        final List<String> expectedLocations;\n+        final List<String> unexpectedLocations;\n+        final String[] expectedFiles;\n+        final List<String> extraJlinkOpts;\n+        final List<String> modulePath;\n+\n+        JlinkSpec(Path imageToUse, Helper helper, String name, List<String> modules,\n+                String validatingModule, List<String> expectedLocations,\n+                List<String> unexpectedLocations, String[] expectedFiles,\n+                List<String> extraJlinkOpts,\n+                List<String> modulePath) {\n+            this.imageToUse = imageToUse;\n+            this.helper = helper;\n+            this.name = name;\n+            this.modules = modules;\n+            this.validatingModule = validatingModule;\n+            this.expectedLocations = expectedLocations;\n+            this.unexpectedLocations = unexpectedLocations;\n+            this.expectedFiles = expectedFiles;\n+            this.extraJlinkOpts = extraJlinkOpts;\n+            this.modulePath = modulePath;\n+        }\n+\n+        public Path getImageToUse() {\n+            return imageToUse;\n+        }\n+\n+        public Helper getHelper() {\n+            return helper;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public List<String> getModules() {\n+            return modules;\n+        }\n+\n+        public String getValidatingModule() {\n+            return validatingModule;\n+        }\n+\n+        public List<String> getExpectedLocations() {\n+            return expectedLocations;\n+        }\n+\n+        public List<String> getUnexpectedLocations() {\n+            return unexpectedLocations;\n+        }\n+\n+        public String[] getExpectedFiles() {\n+            return expectedFiles;\n+        }\n+\n+        public List<String> getExtraJlinkOpts() {\n+            return extraJlinkOpts;\n+        }\n+\n+        public List<String> getModulePath() {\n+            return modulePath;\n+        }\n+    }\n+\n+    static class JlinkSpecBuilder {\n+        Path imageToUse;\n+        Helper helper;\n+        String name;\n+        List<String> modules = new ArrayList<>();\n+        String validatingModule;\n+        List<String> expectedLocations = new ArrayList<>();\n+        List<String> unexpectedLocations = new ArrayList<>();\n+        List<String> expectedFiles = new ArrayList<>();\n+        List<String> extraJlinkOpts = new ArrayList<>();\n+        List<String> modulePath = new ArrayList<>();\n+\n+        JlinkSpec build() {\n+            if (imageToUse == null) {\n+                throw new IllegalStateException(\"No image to use for jlink specified!\");\n+            }\n+            if (helper == null) {\n+                throw new IllegalStateException(\"No helper specified!\");\n+            }\n+            if (name == null) {\n+                throw new IllegalStateException(\"No name for the image location specified!\");\n+            }\n+            if (validatingModule == null) {\n+                throw new IllegalStateException(\"No module specified for after generation validation!\");\n+            }\n+            return new JlinkSpec(imageToUse,\n+                                 helper,\n+                                 name,\n+                                 modules,\n+                                 validatingModule,\n+                                 expectedLocations,\n+                                 unexpectedLocations,\n+                                 expectedFiles.toArray(new String[0]),\n+                                 extraJlinkOpts,\n+                                 modulePath);\n+        }\n+\n+        JlinkSpecBuilder imagePath(Path image) {\n+            this.imageToUse = image;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder helper(Helper helper) {\n+            this.helper = helper;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder name(String name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder addModule(String module) {\n+            modules.add(module);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder validatingModule(String module) {\n+            this.validatingModule = module;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder addModulePath(String modulePath) {\n+            this.modulePath.add(modulePath);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder expectedLocation(String location) {\n+            expectedLocations.add(location);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder unexpectedLocation(String location) {\n+            unexpectedLocations.add(location);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder expectedFile(String file) {\n+            expectedFiles.add(file);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder extraJlinkOpt(String opt) {\n+            extraJlinkOpts.add(opt);\n+            return this;\n+        }\n+    }\n+\n+    static abstract class OutputAnalyzerHandler {\n+\n+        public abstract void handleAnalyzer(OutputAnalyzer out);\n+\n+    }\n+\n+    static class RuntimeLinkOutputAnalyzerHandler extends OutputAnalyzerHandler {\n+\n+        @Override\n+        public void handleAnalyzer(OutputAnalyzer out) {\n+            out.shouldContain(\"Linking based on the current run-time image.\");\n+        }\n+\n+    }\n+\n+    static class DefaultSuccessExitPredicate implements Predicate<OutputAnalyzer> {\n+\n+        @Override\n+        public boolean test(OutputAnalyzer t) {\n+            return t.getExitValue() == 0;\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/AbstractLinkableRuntimeTest.java","additions":541,"deletions":0,"binary":false,"changes":541,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Scanner;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Test --add-options jlink plugin in runtime image link mode\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g AddOptionsTest\n+ *\/\n+public class AddOptionsTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        AddOptionsTest test = new AddOptionsTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        Path finalImage = createJavaImageRuntimeLink(new BaseJlinkSpecBuilder()\n+                .addExtraOption(\"--add-options\")\n+                .addExtraOption(\"-Xlog:gc=info:stderr -XX:+UseParallelGC\")\n+                .name(\"java-base-with-opts\")\n+                .addModule(\"java.base\")\n+                .validatingModule(\"java.base\")\n+                .helper(helper)\n+                .build());\n+        verifyListModules(finalImage, List.of(\"java.base\"));\n+        verifyParallelGCInUse(finalImage);\n+    }\n+\n+    private void verifyParallelGCInUse(Path finalImage) throws Exception {\n+        OutputAnalyzer analyzer = runJavaCmd(finalImage, List.of(\"--version\"));\n+        boolean foundMatch = false;\n+        try (Scanner lineScan = new Scanner(analyzer.getStderr())) {\n+            while (lineScan.hasNextLine()) {\n+                String line = lineScan.nextLine();\n+                if (line.endsWith(\"Using Parallel\")) {\n+                    foundMatch = true;\n+                    break;\n+                }\n+            }\n+        }\n+        if (!foundMatch) {\n+            throw new AssertionError(\"Expected Parallel GC in place for jlinked image\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/AddOptionsTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test\n+ * @summary Test basic runtime-image-based jlinking\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g BasicJlinkTest\n+ *\/\n+public class BasicJlinkTest extends AbstractLinkableRuntimeTest {\n+\n+    @Override\n+    public void runTest(Helper helper) throws Exception {\n+        Path finalImage = createJavaBaseRuntimeLink(helper, \"java-base\");\n+        verifyListModules(finalImage, List.of(\"java.base\"));\n+    }\n+\n+    private Path createJavaBaseRuntimeLink(Helper helper, String name) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder();\n+        builder.helper(helper)\n+               .name(name)\n+               .addModule(\"java.base\")\n+               .validatingModule(\"java.base\");\n+        return createJavaImageRuntimeLink(builder.build());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        BasicJlinkTest test = new BasicJlinkTest();\n+        test.run();\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/BasicJlinkTest.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+class CapturingHandler extends AbstractLinkableRuntimeTest.OutputAnalyzerHandler {\n+\n+    private OutputAnalyzer output;\n+\n+    public String stdErr() {\n+        return output.getStderr();\n+    }\n+\n+    public OutputAnalyzer analyzer() {\n+        return output;\n+    }\n+\n+    @Override\n+    public void handleAnalyzer(OutputAnalyzer out) {\n+        this.output = out;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/CapturingHandler.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test\n+ * @summary Test jmod-less jlink with a custom module\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g CustomModuleJlinkTest\n+ *\/\n+public class CustomModuleJlinkTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        CustomModuleJlinkTest test = new CustomModuleJlinkTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        String customModule = \"leaf1\";\n+        helper.generateDefaultJModule(customModule);\n+\n+        \/\/ create a base image for runtime linking\n+        Path jlinkImage = createRuntimeLinkImage(new BaseJlinkSpecBuilder()\n+                                                    .helper(helper)\n+                                                    .name(\"cmod-jlink\")\n+                                                    .addModule(\"java.base\")\n+                                                    .validatingModule(\"java.base\")\n+                                                    .build());\n+\n+        \/\/ Next jlink using the current runtime image for java.base, but take\n+        \/\/ the custom module from the module path.\n+        Path finalImage = jlinkUsingImage(new JlinkSpecBuilder()\n+                                                .imagePath(jlinkImage)\n+                                                .helper(helper)\n+                                                .name(customModule)\n+                                                .addModulePath(helper.defaultModulePath(false))\n+                                                .expectedLocation(String.format(\"\/%s\/%s\/com\/foo\/bar\/X.class\", customModule, customModule))\n+                                                .addModule(customModule)\n+                                                .validatingModule(customModule)\n+                                                .build());\n+        \/\/ Expected only the transitive closure of \"leaf1\" module in the --list-modules\n+        \/\/ output of the java launcher.\n+        List<String> expectedModules = List.of(\"java.base\", customModule);\n+        verifyListModules(finalImage, expectedModules);\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/CustomModuleJlinkTest.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Verify JLI class generation in run-time image link mode\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g GenerateJLIClassesTest\n+ *\/\n+public class GenerateJLIClassesTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        GenerateJLIClassesTest test = new GenerateJLIClassesTest();\n+        test.run();\n+    }\n+\n+    \/*\n+     * java.lang.invoke.BoundMethodHandle$Species_* classes get generated\n+     * by the GenerateJLiClassesPlugin. This test ensures that potentially\n+     * generated JLI classes from the run-time image don't populate to the\n+     * target image in the run-time image based link mode.\n+     *\/\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        Path baseFile = Files.createTempFile(\"base\", \"trace\");\n+        String species = \"LLLLLLLLLLLLLLLLLLL\";\n+        String fileString = \"[SPECIES_RESOLVE] java.lang.invoke.BoundMethodHandle$Species_\" + species + \" (salvaged)\\n\";\n+        Files.write(baseFile, fileString.getBytes(StandardCharsets.UTF_8));\n+        Path runtimeLinkableImage = createRuntimeLinkImage(new BaseJlinkSpecBuilder()\n+                                                            .helper(helper)\n+                                                            .name(\"jlink.jli-jmodless\")\n+                                                            .validatingModule(\"java.base\")\n+                                                            .build());\n+        \/\/ Finally attempt another jmodless link reducing modules to java.base only,\n+        \/\/ and asking for specific jli classes.\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(runtimeLinkableImage)\n+                                .name(\"java.base-jli-derived\")\n+                                .addModule(\"java.base\")\n+                                .extraJlinkOpt(\"--generate-jli-classes=@\" + baseFile.toString())\n+                                .expectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_\" + species + \".class\")\n+                                .expectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_L.class\")\n+                                .unexpectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_\" + species.substring(1) + \".class\")\n+                                .unexpectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LL.class\")\n+                                .validatingModule(\"java.base\")\n+                                .build());\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/GenerateJLIClassesTest.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import jdk.internal.jimage.BasicImageReader;\n+import jdk.internal.jimage.ImageLocation;\n+\n+\/**\n+ *\n+ * JDK Modular image iterator\n+ *\/\n+public class JImageHelper {\n+\n+    private JImageHelper() {\n+        \/\/ Don't instantiate\n+    }\n+\n+    public static List<String> listContents(Path jimage) throws IOException {\n+        try(BasicImageReader reader = BasicImageReader.open(jimage)) {\n+            List<String> entries = new ArrayList<>();\n+            for (String s : reader.getEntryNames()) {\n+                entries.add(s);\n+            }\n+            Collections.sort(entries);\n+            return entries;\n+        }\n+    }\n+\n+    public static byte[] getLocationBytes(String location, Path jimage) throws IOException {\n+        try(BasicImageReader reader = BasicImageReader.open(jimage)) {\n+            ImageLocation il = reader.findLocation(location);\n+            byte[] r = reader.getResource(il);\n+            if (r == null) {\n+                throw new IllegalStateException(String.format(\"bytes for %s not found!\", location));\n+            }\n+            return r;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/JImageHelper.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Test reproducibility of runtime image based jlink of java.se\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g JavaSEReproducibleTest\n+ *\/\n+public class JavaSEReproducibleTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        JavaSEReproducibleTest test = new JavaSEReproducibleTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        String javaSeModule = \"java.se\";\n+        \/\/ create a java.se using jmod-less approach\n+        Path javaSEJmodLess1 = createJavaImageRuntimeLink(new BaseJlinkSpecBuilder()\n+                                                                   .helper(helper)\n+                                                                   .name(\"java-se-repro1\")\n+                                                                   .addModule(javaSeModule)\n+                                                                   .validatingModule(javaSeModule)\n+                                                                   .build());\n+\n+        \/\/ create another java.se version using jmod-less approach\n+        Path javaSEJmodLess2 = createJavaImageRuntimeLink(new BaseJlinkSpecBuilder()\n+                                                                   .helper(helper)\n+                                                                   .name(\"java-se-repro2\")\n+                                                                   .addModule(javaSeModule)\n+                                                                   .validatingModule(javaSeModule)\n+                                                                   .build());\n+        if (Files.mismatch(javaSEJmodLess1.resolve(\"lib\").resolve(\"modules\"),\n+                           javaSEJmodLess2.resolve(\"lib\").resolve(\"modules\")) != -1L) {\n+            throw new RuntimeException(\"jlink producing inconsistent result for \" + javaSeModule + \" (jmod-less)\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/JavaSEReproducibleTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test\n+ * @summary Verify that jlink with an empty module path, but trying to use\n+ *          --keep-packaged-modules fails as expected.\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g KeepPackagedModulesFailTest\n+ *\/\n+public class KeepPackagedModulesFailTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        KeepPackagedModulesFailTest test = new KeepPackagedModulesFailTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        \/\/ create a base image for runtime linking\n+        Path baseImage = createRuntimeLinkImage(new BaseJlinkSpecBuilder()\n+                                                    .helper(helper)\n+                                                    .name(\"jlink-fail\")\n+                                                    .addModule(\"java.base\")\n+                                                    .validatingModule(\"java.base\")\n+                                                    .build());\n+\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer t) {\n+                return t.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        \/\/ Attempt a jlink using system modules and --keep-packaged-modules,\n+        \/\/ which should fail.\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(baseImage)\n+                                .name(\"java-base-jlink-keep-packaged-target\")\n+                                .addModule(\"java.base\")\n+                                .extraJlinkOpt(\"--keep-packaged-modules=foo\")\n+                                .validatingModule(\"java.base\")\n+                                .build(), handler, exitFailPred);\n+        OutputAnalyzer analyzer = handler.analyzer();\n+        if (analyzer.getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to have failed!\");\n+        }\n+        analyzer.stdoutShouldContain(\"Error\");\n+        analyzer.stdoutShouldContain(\"--keep-packaged-modules\");\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/KeepPackagedModulesFailTest.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Verify jlink fails by default when jlinking in runtime-image-based mode\n+ *          and files have been changed\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g ModifiedFilesExitTest\n+ *\/\n+public class ModifiedFilesExitTest extends ModifiedFilesTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        ModifiedFilesExitTest test = new ModifiedFilesExitTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    String initialImageName() {\n+        return \"java-base-jlink-with-mod-exit\";\n+    }\n+\n+    @Override\n+    void testAndAssert(Path modifiedFile, Helper helper, Path initialImage)\n+            throws Exception {\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer t) {\n+                return t.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(initialImage)\n+                                .name(\"java-base-jlink-with-mod-exit-target\")\n+                                .addModule(\"java.base\")\n+                                .validatingModule(\"java.base\")\n+                                .build(), handler, exitFailPred);\n+        OutputAnalyzer analyzer = handler.analyzer();\n+        if (analyzer.getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to fail due to modified file!\");\n+        }\n+        analyzer.stdoutShouldContain(modifiedFile.toString() + \" has been modified\");\n+        \/\/ Verify the error message is reasonable\n+        analyzer.stdoutShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n+        analyzer.stdoutShouldNotContain(\"java.lang.IllegalArgumentException\");\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesExitTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Properties;\n+\n+import tests.Helper;\n+\n+public abstract class ModifiedFilesTest extends AbstractLinkableRuntimeTest {\n+\n+    abstract String initialImageName();\n+    abstract void testAndAssert(Path modifiedFile, Helper helper, Path initialImage) throws Exception;\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        Path initialImage = createRuntimeLinkImage(new BaseJlinkSpecBuilder()\n+                \/\/.name(\"java-base-jlink-with-mod\")\n+                .name(initialImageName())\n+                .addModule(\"java.base\")\n+                .validatingModule(\"java.base\")\n+                .helper(helper)\n+                .build());\n+\n+        Path netPropertiesFile = modifyFileInImage(initialImage);\n+\n+        testAndAssert(netPropertiesFile, helper, initialImage);\n+    }\n+\n+    protected Path modifyFileInImage(Path jmodLessImg)\n+            throws IOException, AssertionError {\n+        \/\/ modify net.properties config file\n+        Path netPropertiesFile = jmodLessImg.resolve(\"conf\").resolve(\"net.properties\");\n+        Properties props = new Properties();\n+        try (InputStream is = Files.newInputStream(netPropertiesFile)) {\n+            props.load(is);\n+        }\n+        String prevVal = (String)props.put(\"java.net.useSystemProxies\", Boolean.TRUE.toString());\n+        if (prevVal == null || Boolean.getBoolean(prevVal) != false) {\n+            throw new AssertionError(\"Expected previous value to be false!\");\n+        }\n+        try (OutputStream out = Files.newOutputStream(netPropertiesFile)) {\n+            props.store(out, \"Modified net.properties file!\");\n+        }\n+        return netPropertiesFile;\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Verify warnings are being produced when jlinking in runtime-based image\n+ *          mode and files have been modified\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g ModifiedFilesWarningTest\n+ *\/\n+public class ModifiedFilesWarningTest extends ModifiedFilesTest {\n+\n+    protected static final String IGNORE_MODIFIED_RUNTIME_OPT = \"--ignore-modified-runtime\";\n+\n+    public static void main(String[] args) throws Exception {\n+        ModifiedFilesWarningTest test = new ModifiedFilesWarningTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    String initialImageName() {\n+        return \"java-base-jlink-with-mod-warn\";\n+    }\n+\n+    @Override\n+    void testAndAssert(Path modifiedFile, Helper helper, Path initialImage) throws Exception {\n+        CapturingHandler handler = new CapturingHandler();\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(initialImage)\n+                                .name(\"java-base-jlink-with-mod-warn-target\")\n+                                .addModule(\"java.base\")\n+                                .validatingModule(\"java.base\")\n+                                .extraJlinkOpt(IGNORE_MODIFIED_RUNTIME_OPT) \/\/ only generate a warning\n+                                .build(), handler);\n+        OutputAnalyzer out = handler.analyzer();\n+        \/\/ verify we get the warning message\n+        out.stderrShouldMatch(\"WARNING: .* has been modified\");\n+        out.stderrShouldNotContain(\"java.lang.IllegalArgumentException\");\n+        out.stderrShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesWarningTest.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Verify that a jlink using the run-time image cannot include jdk.jlink\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g MultiHopTest\n+ *\/\n+public class MultiHopTest extends AbstractLinkableRuntimeTest {\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        Path jdkJlinkJmodless = createJDKJlinkJmodLess(helper, \"jdk.jlink-multi-hop1\");\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer a) {\n+                return a.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(jdkJlinkJmodless)\n+                                .name(\"jdk-jlink-multi-hop1-target\")\n+                                .addModule(\"jdk.jlink\")\n+                                .validatingModule(\"java.base\")\n+                                .build(), handler, exitFailPred);\n+        OutputAnalyzer analyzer = handler.analyzer();\n+        if (analyzer.getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to fail due to including jdk.jlink\");\n+        }\n+        String expectedMsg = \"This JDK does not contain packaged modules \" +\n+                             \"and cannot be used to create another run-time image that includes \" +\n+                             \"the jdk.jlink module.\";\n+        analyzer.stdoutShouldContain(expectedMsg);\n+        analyzer.stdoutShouldNotContain(\"Exception\"); \/\/ ensure error message is sane\n+    }\n+\n+    private Path createJDKJlinkJmodLess(Helper helper, String name) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder();\n+        builder.helper(helper)\n+               .name(name)\n+               .addModule(\"jdk.jlink\")\n+               .validatingModule(\"java.base\");\n+        return createRuntimeLinkImage(builder.build());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        MultiHopTest test = new MultiHopTest();\n+        test.run();\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/MultiHopTest.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import tests.Helper;\n+import tests.JImageGenerator;\n+\n+\/*\n+ * @test\n+ * @summary Compare packaged-modules jlink with a run-time image based jlink to\n+ *          produce the same result\n+ * @requires (jlink.packagedModules & jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g PackagedModulesVsJmodLessTest\n+ *\/\n+public class PackagedModulesVsJmodLessTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        PackagedModulesVsJmodLessTest test = new PackagedModulesVsJmodLessTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        \/\/ create a java.se using jmod-less approach\n+        Path javaSEruntimeLink = createJavaImageRuntimeLink(new BaseJlinkSpecBuilder()\n+                                                            .helper(helper)\n+                                                            .name(\"java-se-jmodless\")\n+                                                            .addModule(\"java.se\")\n+                                                            .validatingModule(\"java.se\")\n+                                                            .build());\n+\n+        \/\/ create a java.se using packaged modules (jmod-full)\n+        Path javaSEJmodFull = JImageGenerator.getJLinkTask()\n+                .output(helper.createNewImageDir(\"java-se-jmodfull\"))\n+                .addMods(\"java.se\").call().assertSuccess();\n+\n+        compareRecursively(javaSEruntimeLink, javaSEJmodFull);\n+    }\n+\n+    \/\/ Visit all files in the given directories checking that they're byte-by-byte identical\n+    private static void compareRecursively(Path javaSEJmodLess,\n+            Path javaSEJmodFull) throws IOException, AssertionError {\n+        FilesCapturingVisitor jmodFullVisitor = new FilesCapturingVisitor(javaSEJmodFull);\n+        FilesCapturingVisitor jmodLessVisitor = new FilesCapturingVisitor(javaSEJmodLess);\n+        Files.walkFileTree(javaSEJmodFull, jmodFullVisitor);\n+        Files.walkFileTree(javaSEJmodLess, jmodLessVisitor);\n+        List<String> jmodFullFiles = jmodFullVisitor.filesVisited();\n+        List<String> jmodLessFiles = jmodLessVisitor.filesVisited();\n+        Collections.sort(jmodFullFiles);\n+        Collections.sort(jmodLessFiles);\n+\n+        if (jmodFullFiles.size() != jmodLessFiles.size()) {\n+            throw new AssertionError(String.format(\"Size of files different for jmod-less (%d) vs jmod-full (%d) java.se jlink\", jmodLessFiles.size(), jmodFullFiles.size()));\n+        }\n+        String jimageFile = Path.of(\"lib\").resolve(\"modules\").toString();\n+        \/\/ Compare all files except the modules image\n+        for (int i = 0; i < jmodFullFiles.size(); i++) {\n+            String jmodFullPath = jmodFullFiles.get(i);\n+            String jmodLessPath = jmodLessFiles.get(i);\n+            if (!jmodFullPath.equals(jmodLessPath)) {\n+                throw new AssertionError(String.format(\"jmod-full path (%s) != jmod-less path (%s)\", jmodFullPath, jmodLessPath));\n+            }\n+            if (jmodFullPath.equals(jimageFile)) {\n+                continue;\n+            }\n+            Path a = javaSEJmodFull.resolve(Path.of(jmodFullPath));\n+            Path b = javaSEJmodLess.resolve(Path.of(jmodLessPath));\n+            if (Files.mismatch(a, b) != -1L) {\n+                handleFileMismatch(a, b);\n+            }\n+        }\n+        \/\/ Compare jimage contents by iterating its entries and comparing their\n+        \/\/ paths and content bytes\n+        \/\/\n+        \/\/ Note: The files aren't byte-by-byte comparable (probably due to string hashing\n+        \/\/ and offset differences in container bytes)\n+        Path jimageJmodLess = javaSEJmodLess.resolve(Path.of(\"lib\")).resolve(Path.of(\"modules\"));\n+        Path jimageJmodFull = javaSEJmodFull.resolve(Path.of(\"lib\")).resolve(Path.of(\"modules\"));\n+        List<String> jimageContentJmodLess = JImageHelper.listContents(jimageJmodLess);\n+        List<String> jimageContentJmodFull = JImageHelper.listContents(jimageJmodFull);\n+        if (jimageContentJmodLess.size() != jimageContentJmodFull.size()) {\n+            throw new AssertionError(String.format(\"Size of jimage content differs for jmod-less (%d) v. jmod-full (%d)\", jimageContentJmodLess.size(), jimageContentJmodFull.size()));\n+        }\n+        for (int i = 0; i < jimageContentJmodFull.size(); i++) {\n+            if (!jimageContentJmodFull.get(i).equals(jimageContentJmodLess.get(i))) {\n+                throw new AssertionError(String.format(\"Jimage content differs at index %d: jmod-full was: '%s' jmod-less was: '%s'\",\n+                                                       i,\n+                                                       jimageContentJmodFull.get(i),\n+                                                       jimageContentJmodLess.get(i)\n+                                                       ));\n+            }\n+            String loc = jimageContentJmodFull.get(i);\n+            if (isTreeInfoResource(loc)) {\n+                \/\/ Skip container bytes as those are offsets to the content\n+                \/\/ of the container which might be different between jlink runs.\n+                continue;\n+            }\n+            byte[] resBytesFull = JImageHelper.getLocationBytes(loc, jimageJmodFull);\n+            byte[] resBytesLess = JImageHelper.getLocationBytes(loc, jimageJmodLess);\n+            if (resBytesFull.length != resBytesLess.length || Arrays.mismatch(resBytesFull, resBytesLess) != -1) {\n+                throw new AssertionError(\"Content bytes mismatch for \" + loc);\n+            }\n+        }\n+    }\n+\n+    private static boolean isTreeInfoResource(String path) {\n+        return path.startsWith(\"\/packages\") || path.startsWith(\"\/modules\");\n+    }\n+\n+    private static void handleFileMismatch(Path a, Path b) {\n+        throw new AssertionError(\"Files mismatch: \" + a + \" vs. \" + b);\n+    }\n+\n+    static class FilesCapturingVisitor extends SimpleFileVisitor<Path> {\n+        private final Path basePath;\n+        private final List<String> filePaths = new ArrayList<>();\n+        public FilesCapturingVisitor(Path basePath) {\n+            this.basePath = basePath;\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) {\n+            Path relative = basePath.relativize(path);\n+            filePaths.add(relative.toString());\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        List<String> filesVisited() {\n+            return filePaths;\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/PackagedModulesVsJmodLessTest.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import tests.Helper;\n+import tests.JImageValidator;\n+\n+\/*\n+ * @test\n+ * @summary Test appropriate handling of generated SystemModules* classes in run-time image link mode\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g SystemModulesTest\n+ *\/\n+public class SystemModulesTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        SystemModulesTest test = new SystemModulesTest();\n+        test.run();\n+    }\n+\n+    \/*\n+     * SystemModule classes are module specific. If the jlink is based on the\n+     * modules image, then earlier generated SystemModule classes shall not get\n+     * propagated.\n+     *\/\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        \/\/ create an image with a module containing a main entrypoint (jdk.httpserver),\n+        \/\/ thus producing the SystemModules$0.class. Add jdk.jdwp.agent as a module which\n+        \/\/ isn't resolved by default, so as to generate SystemModules$default.class\n+        Path javaseJmodless = createJavaImageRuntimeLink(new BaseJlinkSpecBuilder()\n+                                                            .helper(helper)\n+                                                            .name(\"httpserver-jlink-jmodless-derived\")\n+                                                            .addModule(\"jdk.httpserver\")\n+                                                            .addModule(\"jdk.jdwp.agent\")\n+                                                            .validatingModule(\"java.base\")\n+                                                            .build());\n+        \/\/ Verify that SystemModules$0.class etc. are there, due to httpserver and jdwp.agent\n+        JImageValidator.validate(javaseJmodless.resolve(\"lib\").resolve(\"modules\"),\n+                                    List.of(\"\/java.base\/jdk\/internal\/module\/SystemModules$default.class\",\n+                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$0.class\",\n+                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$all.class\"),\n+                                    Collections.emptyList());\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/SystemModulesTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import tests.Helper;\n+import tests.JImageValidator;\n+\n+\/*\n+ * @test\n+ * @summary Test SystemModules handling of java --list-modules with system modules\n+ *          not consistently enabled\/disabled.\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g SystemModulesTest2\n+ *\/\n+public class SystemModulesTest2 extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        SystemModulesTest2 test = new SystemModulesTest2();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        \/\/ See SystemModulesTest which enables the system-modules plugin. With\n+        \/\/ it disabled, we expect for the generated classes to not be there.\n+        Path javaJmodless = createJavaImageRuntimeLink(new BaseJlinkSpecBuilder()\n+                                                            .helper(helper)\n+                                                            .name(\"jlink-jmodless-sysmod2\")\n+                                                            .addModule(\"jdk.httpserver\")\n+                                                            .validatingModule(\"java.base\")\n+                                                            .addExtraOption(\"--disable-plugin\")\n+                                                            .addExtraOption(\"system-modules\")\n+                                                            .build());\n+        \/\/ Verify that SystemModules$all.class is there\n+        JImageValidator.validate(javaJmodless.resolve(\"lib\").resolve(\"modules\"),\n+                                    Collections.emptyList(),\n+                                    List.of(\"\/java.base\/jdk\/internal\/module\/SystemModules$all.class\",\n+                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$default.class\",\n+                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$0.class\"));\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/SystemModulesTest2.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires jlink.packagedModules\n","filename":"test\/jdk\/tools\/jlink\/multireleasejar\/JLinkMRJavaBaseVersionTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -24,0 +24,3 @@\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+\n@@ -35,0 +38,3 @@\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n@@ -40,5 +46,15 @@\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.Test;\n-\n-import static java.lang.constant.ConstantDescs.CD_Object;\n-import static java.lang.constant.ConstantDescs.CD_int;\n+\/*\n+ * @test id=packaged_modules\n+ * @bug 8252919 8327499\n+ * @library ..\/..\/lib\n+ * @summary Test --generate-jli-classes plugin\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.internal.plugins\n+ *          jdk.jlink\/jdk.tools.jmod\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @requires jlink.packagedModules\n+ * @build tests.*\n+ * @run testng\/othervm -DlinkableRuntime=false GenerateJLIClassesPluginTest\n+ *\/\n@@ -47,1 +63,1 @@\n- * @test\n+ * @test id=linkable_jdk_runtimes\n@@ -57,0 +73,1 @@\n+ * @requires (jlink.runtime.linkable & !jlink.packagedModules)\n@@ -58,1 +75,1 @@\n- * @run testng\/othervm GenerateJLIClassesPluginTest\n+ * @run testng\/othervm -DlinkableRuntime=true GenerateJLIClassesPluginTest\n@@ -62,0 +79,1 @@\n+    private static final String LINKABLE_RUNTIME_PROP = \"linkableRuntime\";\n@@ -66,1 +84,4 @@\n-        helper = Helper.newHelper();\n+        boolean isLinkableRuntime = Boolean.getBoolean(LINKABLE_RUNTIME_PROP);\n+        System.out.println(\"Tests run on \" +\n+                           (isLinkableRuntime ? \"linkable JDK runtime.\" : \"packaged modules.\"));\n+        helper = Helper.newHelper(isLinkableRuntime);\n","filename":"test\/jdk\/tools\/jlink\/plugins\/GenerateJLIClassesPluginTest.java","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.util.Arrays;\n@@ -27,0 +26,1 @@\n+import java.util.Arrays;\n@@ -31,1 +31,0 @@\n-import jdk.tools.jlink.plugin.PluginException;\n@@ -34,0 +33,1 @@\n+import jdk.tools.jlink.plugin.PluginException;\n@@ -40,1 +40,1 @@\n- * @test\n+ * @test id=packaged_modules\n@@ -46,1 +46,1 @@\n- * @requires (vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @requires (jlink.packagedModules & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n@@ -58,1 +58,23 @@\n- * @run main\/othervm\/timeout=180 -Xmx1g IncludeLocalesPluginTest\n+ * @run main\/othervm\/timeout=180 -Xmx1g IncludeLocalesPluginTest false\n+ *\/\n+\n+\/*\n+ * @test id=linkable_jdk_runtimes\n+ * @bug 8152143 8152704 8155649 8165804 8185841 8176841 8190918\n+ *      8179071 8202537 8221432 8222098 8251317 8258794 8265315\n+ *      8296248 8306116 8174269\n+ * @summary IncludeLocalesPlugin tests\n+ * @author Naoto Sato\n+ * @requires (jlink.runtime.linkable & !jlink.packagedModules & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.internal.plugins\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jmod\n+ *          jdk.jlink\/jdk.tools.jimage\n+ *          jdk.compiler\n+ * @build tests.*\n+ * @build tools.jlink.plugins.GetAvailableLocales\n+ * @run main\/othervm\/timeout=180 -Xmx1g IncludeLocalesPluginTest true\n@@ -62,1 +84,1 @@\n-    private final static String moduleName = \"IncludeLocalesTest\";\n+    private static final String moduleName = \"IncludeLocalesTest\";\n@@ -64,6 +86,6 @@\n-    private final static int INCLUDE_LOCALES_OPTION = 0;\n-    private final static int ADDMODS_OPTION         = 1;\n-    private final static int EXPECTED_LOCATIONS     = 2;\n-    private final static int UNEXPECTED_PATHS       = 3;\n-    private final static int AVAILABLE_LOCALES      = 4;\n-    private final static int ERROR_MESSAGE          = 5;\n+    private static final int INCLUDE_LOCALES_OPTION = 0;\n+    private static final int ADDMODS_OPTION         = 1;\n+    private static final int EXPECTED_LOCATIONS     = 2;\n+    private static final int UNEXPECTED_PATHS       = 3;\n+    private static final int AVAILABLE_LOCALES      = 4;\n+    private static final int ERROR_MESSAGE          = 5;\n@@ -415,1 +437,10 @@\n-        helper = Helper.newHelper();\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Usage: \" +\n+                                       IncludeLocalesPluginTest.class.getSimpleName() +\n+                                       \" {true,false}\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        System.out.println(\"Running test on \" +\n+                           (isLinkableRuntime ? \"linkable JDK runtime.\" : \"packaged modules.\"));\n+\n+        helper = Helper.newHelper(isLinkableRuntime);\n","filename":"test\/jdk\/tools\/jlink\/plugins\/IncludeLocalesPluginTest.java","additions":44,"deletions":13,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+    private final boolean linkableRuntime;\n+    private static final Path JDK_HOME = Paths.get(System.getProperty(\"test.jdk\"));\n@@ -69,2 +71,5 @@\n-        Path jdkHome = Paths.get(System.getProperty(\"test.jdk\"));\n-        if (!Files.exists(jdkHome.resolve(\"jmods\"))) {\n+        return newHelper(false);\n+    }\n+\n+    public static Helper newHelper(boolean linkableRuntime) throws IOException {\n+        if (!linkableRuntime && !Files.exists(JDK_HOME.resolve(\"jmods\"))) {\n@@ -75,1 +80,1 @@\n-        return new Helper(jdkHome);\n+        return new Helper(JDK_HOME, linkableRuntime);\n@@ -78,1 +83,2 @@\n-    private Helper(Path jdkHome) throws IOException {\n+    private Helper(Path jdkHome, boolean linkableRuntime) throws IOException {\n+        this.linkableRuntime = linkableRuntime;\n@@ -80,1 +86,1 @@\n-        if (!Files.exists(stdjmods)) {\n+        if (!linkableRuntime && !Files.exists(stdjmods)) {\n@@ -143,1 +149,2 @@\n-        return (includeStdMods? stdjmods.toAbsolutePath().toString() : \"\") + File.pathSeparator\n+        String standardMods = linkableRuntime ? \"\" : stdjmods.toAbsolutePath().toString() + File.pathSeparator;\n+        return (includeStdMods? standardMods : \"\")\n@@ -187,1 +194,1 @@\n-        JModTask task = JImageGenerator.getJModTask()\n+        JModTask task = JImageGenerator.getJModTask(linkableRuntime)\n","filename":"test\/jdk\/tools\/lib\/tests\/Helper.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -162,1 +162,5 @@\n-        return new JModTask();\n+        return getJModTask(false);\n+    }\n+\n+    public static JModTask getJModTask(boolean linkableRuntime) {\n+        return new JModTask(linkableRuntime);\n@@ -353,0 +357,1 @@\n+        private final boolean linkableRuntime;\n@@ -358,0 +363,4 @@\n+        private JModTask(boolean linkableRuntime) {\n+            this.linkableRuntime = linkableRuntime;\n+        }\n+\n@@ -417,1 +426,1 @@\n-            return jmods + File.pathSeparator + jars;\n+            return linkableRuntime ? jars : jmods + File.pathSeparator + jars;\n","filename":"test\/jdk\/tools\/lib\/tests\/JImageGenerator.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReader;\n+import java.lang.module.ModuleReference;\n@@ -27,0 +30,1 @@\n+import java.io.DataInputStream;\n@@ -42,0 +46,1 @@\n+import java.util.Optional;\n@@ -141,0 +146,2 @@\n+        map.put(\"jlink.runtime.linkable\", this::runtimeLinkable);\n+        map.put(\"jlink.packagedModules\", this::packagedModules);\n@@ -730,0 +737,40 @@\n+    private String packagedModules() {\n+        \/\/ Some jlink tests require packaged modules being present (jmods).\n+        \/\/ For a runtime linkable image build packaged modules aren't present\n+        try {\n+            Path jmodsDir = Path.of(System.getProperty(\"java.home\"), \"jmods\");\n+            if (jmodsDir.toFile().exists()) {\n+                return Boolean.TRUE.toString();\n+            } else {\n+                return Boolean.FALSE.toString();\n+            }\n+        } catch (Throwable t) {\n+            return Boolean.FALSE.toString();\n+        }\n+    }\n+\n+    private String runtimeLinkable() {\n+        \/\/ jdk.jlink module has the following resource indicating a runtime-linkable\n+        \/\/ image. It's the diff file for runtime linking of the java.base module.\n+        String linkableRuntimeResource = \"jdk\/tools\/jlink\/internal\/runtimelink\/diff_java.base\";\n+        try {\n+            ModuleFinder finder = ModuleFinder.ofSystem();\n+            Optional<ModuleReference> ref = finder.find(\"jdk.jlink\");\n+            if (ref.isEmpty()) {\n+                \/\/ No jdk.jlink in the current image\n+                return Boolean.FALSE.toString();\n+            }\n+            try (ModuleReader reader = ref.get().open()) {\n+                Optional<InputStream> inOpt = reader.open(linkableRuntimeResource);\n+                if (inOpt.isPresent()) {\n+                    inOpt.get().close();\n+                    return Boolean.TRUE.toString();\n+                } else {\n+                    return Boolean.FALSE.toString();\n+                }\n+            }\n+        } catch (Throwable t) {\n+            return Boolean.FALSE.toString();\n+        }\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"}]}