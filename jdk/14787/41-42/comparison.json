{"files":[{"patch":"@@ -94,1 +94,5 @@\n-    private ImageFileCreator(ImagePluginStack plugins, boolean generateRuntimeImage) {\n+    private final TaskHelper helper;\n+\n+    private ImageFileCreator(ImagePluginStack plugins,\n+                             boolean generateRuntimeImage,\n+                             TaskHelper taskHelper) {\n@@ -97,0 +101,1 @@\n+        this.helper = taskHelper;\n@@ -116,1 +121,2 @@\n-            boolean generateRuntimeImage)\n+            boolean generateRuntimeImage,\n+            TaskHelper taskHelper)\n@@ -119,1 +125,3 @@\n-        ImageFileCreator image = new ImageFileCreator(plugins, generateRuntimeImage);\n+        ImageFileCreator image = new ImageFileCreator(plugins,\n+                                                      generateRuntimeImage,\n+                                                      taskHelper);\n@@ -124,0 +132,7 @@\n+        } catch (RuntimeImageLinkException e) {\n+            \/\/ readAllEntries() might throw this exception.\n+            \/\/ Propagate as IOException with appropriate message for\n+            \/\/ jlink runs from the run-time image. This handles better\n+            \/\/ error messages for the case of modified files in the run-time\n+            \/\/ image.\n+            throw image.newIOException(e);\n@@ -151,1 +166,2 @@\n-            ImagePluginStack pluginSupport, boolean generateRuntimeImage)\n+            ImagePluginStack pluginSupport,\n+            boolean generateRuntimeImage)\n@@ -188,1 +204,4 @@\n-            throwRuntimeLinkFailure(e);\n+            \/\/ Propagate as IOException with appropriate message for\n+            \/\/ jlink runs from the run-time image. This handles better\n+            \/\/ error messages for the case of --patch-module.\n+            throw newIOException(e);\n@@ -194,2 +213,0 @@\n-        } catch (RuntimeImageLinkException e) {\n-            throwRuntimeLinkFailure(e);\n@@ -204,1 +221,1 @@\n-    private static void throwRuntimeLinkFailure(RuntimeImageLinkException e) throws IOException {\n+    private IOException newIOException(RuntimeImageLinkException e) throws IOException {\n@@ -208,3 +225,6 @@\n-        \/\/ Propagate as IOException with appropriate message for\n-        \/\/ jlink runs from the run-time image\n-        throw new IOException(e.getMessage());\n+        String message = switch (e.getReason()) {\n+            case PATCH_MODULE -> helper.getMessage(\"err.runtime.link.patched.module\", e.getFile());\n+            case MODIFIED_FILE -> helper.getMessage(\"err.runtime.link.modified.file\", e.getFile());\n+            default -> throw new AssertionError(\"Unexpected value: \" + e.getReason());\n+        };\n+        throw new IOException(message);\n@@ -253,7 +273,0 @@\n-        } catch (RuntimeImageLinkException re) {\n-            \/\/ Might be thrown when linking from the current run-time image.\n-            \/\/ Populate the actual reason.\n-            if (JlinkTask.DEBUG) {\n-                re.printStackTrace();\n-            }\n-            throw re;\n@@ -338,1 +351,2 @@\n-                                                     ResourcePool resultContent, BasicImageWriter writer) {\n+                                                     ResourcePool resultContent,\n+                                                     BasicImageWriter writer) {\n@@ -399,14 +413,8 @@\n-            if (diff == null) {\n-                \/\/ We create empty resource files for modules in the resource\n-                \/\/ pool view that don't themselves have a diff to packaged\n-                \/\/ modules\n-                out.add(ResourcePoolEntry.create(mResource, EMPTY_RESOURCE_BYTES));\n-            } else {\n-                ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-                try {\n-                    ResourceDiff.write(diff, bout);\n-                } catch (IOException e) {\n-                    throw new AssertionError(\"Failed to write resource diff file\" +\n-                                             \" for module \" + module, e);\n-                }\n-                out.add(ResourcePoolEntry.create(mResource, bout.toByteArray()));\n+            \/\/ Note that for modules without diff to the packaged modules view\n+            \/\/ we create resource diff files with just the header and no content.\n+            ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+            try {\n+                ResourceDiff.write(diff, bout);\n+            } catch (IOException e) {\n+                throw new AssertionError(\"Failed to write resource diff file\" +\n+                                         \" for module \" + module, e);\n@@ -414,0 +422,1 @@\n+            out.add(ResourcePoolEntry.create(mResource, bout.toByteArray()));\n@@ -434,2 +443,1 @@\n-        \/\/ Only add resources if we have the jdk.jlink module part of the\n-        \/\/ target modules view\n+        \/\/ Only add resources if jdk.jlink module is present in the target image\n@@ -499,2 +507,2 @@\n-        final Map<String, List<String>> nonClassResEntries = new HashMap<>();\n-        final Platform platform = getTargetPlatform(resultResources);\n+        Map<String, List<String>> nonClassResEntries = new HashMap<>();\n+        Platform platform = getTargetPlatform(resultResources);\n@@ -542,2 +550,2 @@\n-    private static ResourcePoolManager createBasicResourcePoolManager(\n-            ByteOrder byteOrder, BasicImageWriter writer) {\n+    private static ResourcePoolManager createBasicResourcePoolManager(ByteOrder byteOrder,\n+                                                                      BasicImageWriter writer) {\n@@ -566,2 +574,2 @@\n-    private static ResourcePoolManager createPoolManager(\n-            ResourcePool resultResources, BasicImageWriter writer) {\n+    private static ResourcePoolManager createPoolManager(ResourcePool resultResources,\n+                                                         BasicImageWriter writer) {\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageFileCreator.java","additions":49,"deletions":41,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import static jdk.tools.jlink.internal.runtimelink.RuntimeImageLinkException.Reason.MODIFIED_FILE;\n+import static jdk.tools.jlink.internal.runtimelink.RuntimeImageLinkException.Reason.PATCH_MODULE;\n@@ -80,0 +82,1 @@\n+    private final TaskHelper taskHelper;\n@@ -88,1 +91,2 @@\n-     * @param perModDiff The lib\/modules (a.k.a jimage) diff for this module\n+     * @param perModDiff The lib\/modules (a.k.a jimage) diff for this module,\n+     *                   possibly an empty list if there are no differences.\n@@ -93,1 +97,2 @@\n-               List<ResourceDiff> perModDiff) {\n+               List<ResourceDiff> perModDiff,\n+               TaskHelper taskHelper) {\n@@ -106,0 +111,1 @@\n+        this.taskHelper = taskHelper;\n@@ -193,3 +199,1 @@\n-                                                 if (secondSlash == -1) {\n-                                                     throw new AssertionError();\n-                                                 }\n+                                                 assert secondSlash != -1;\n@@ -224,2 +228,0 @@\n-                            String msg = String.format(MISMATCH_FORMAT,\n-                                                       path.toString());\n@@ -227,1 +229,1 @@\n-                                throw new RuntimeImageLinkException(msg);\n+                                throw new RuntimeImageLinkException(path.toString(), MODIFIED_FILE);\n@@ -229,2 +231,1 @@\n-                                \/\/ System.err vs taskHelper.warning?\n-                                System.err.printf(\"WARNING: %s\", msg);\n+                                taskHelper.warning(\"err.runtime.link.modified.file\", path.toString());\n@@ -336,1 +337,1 @@\n-                throw new IllegalStateException(\n+                throw new AssertionError(\n@@ -421,1 +422,0 @@\n-    private static final String MISMATCH_FORMAT = \"%s has been modified%n\";\n@@ -474,4 +474,1 @@\n-                                String msgFormat = \"File %s not found in the modules image.\\n\" +\n-                                                   \"--patch-module is not supported when linking from the run-time image\";\n-                                String msg = String.format(msgFormat, file.getFile());\n-                                throw new RuntimeImageLinkException(msg);\n+                                throw new RuntimeImageLinkException(file.getFile(), PATCH_MODULE);\n@@ -527,2 +524,2 @@\n-            throw new AssertionError(\"Failed to process resources from the run-time image\" +\n-                                    \" for module \" + modName);\n+            throw new UncheckedIOException(\"Failed to process resources from the \" +\n+                                           \"run-time image for module \" + modName, e);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JRTArchive.java","additions":15,"deletions":18,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -437,1 +437,0 @@\n-     * @param finder A module finder based on packaged modules.\n@@ -439,0 +438,1 @@\n+     * @param finder A module finder based on packaged modules.\n@@ -698,1 +698,2 @@\n-                                     config))\n+                                     config,\n+                                     log))\n@@ -711,1 +712,2 @@\n-                                      JlinkConfiguration config) {\n+                                      JlinkConfiguration config,\n+                                      PrintWriter log) {\n@@ -751,1 +753,1 @@\n-            return LinkableRuntimeImage.newArchive(module, path, config.ignoreModifiedRuntime());\n+            return LinkableRuntimeImage.newArchive(module, path, config.ignoreModifiedRuntime(), taskHelper);\n@@ -1040,1 +1042,1 @@\n-                    targetPlatform.arch().byteOrder(), stack, generateRuntimeImage);\n+                    targetPlatform.arch().byteOrder(), stack, generateRuntimeImage, taskHelper);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        try (InputStream in = getDiffInputStream()) {\n+        try (InputStream in = getDiffInputStream(\"java.base\")) {\n@@ -63,2 +63,3 @@\n-    private static InputStream getDiffInputStream() {\n-        return getDiffInputStream(\"java.base\");\n+    private static InputStream getDiffInputStream(String module) throws IOException {\n+        String resourceName = String.format(DIFF_PATTERN, module);\n+        return LinkableRuntimeImage.class.getModule().getResourceAsStream(resourceName);\n@@ -67,14 +68,5 @@\n-    private static InputStream getDiffInputStream(String module) {\n-        try {\n-            String resourceName = String.format(DIFF_PATTERN, module);\n-            return LinkableRuntimeImage.class.getModule().getResourceAsStream(resourceName);\n-        } catch (IOException e) {\n-            if (JlinkTask.DEBUG) {\n-                System.err.println(\"Failed to get diff pattern resource\");\n-                e.printStackTrace();\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static Archive newArchive(String module, Path path, boolean ignoreModifiedRuntime) {\n+    public static Archive newArchive(String module,\n+                                     Path path,\n+                                     boolean ignoreModifiedRuntime,\n+                                     TaskHelper taskHelper) {\n+        assert isLinkableRuntime();\n@@ -92,1 +84,1 @@\n-        return new JRTArchive(module, path, !ignoreModifiedRuntime, perModuleDiff);\n+        return new JRTArchive(module, path, !ignoreModifiedRuntime, perModuleDiff, taskHelper);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/LinkableRuntimeImage.java","additions":10,"deletions":18,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -584,1 +584,1 @@\n-        public void showHelp(String progName, boolean runtimeCap) {\n+        public void showHelp(String progName, boolean linkableRuntimeEnabled) {\n@@ -596,2 +596,2 @@\n-            log.println(bundleHelper.getMessage(\"main.capability.runtime\",\n-                                                runtimeCap ? \"+\" : \"-\"));\n+            log.println(bundleHelper.getMessage(\"main.runtime.image.linking.capability\",\n+                                                linkableRuntimeEnabled ? \"+\" : \"-\"));\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/TaskHelper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-        \/\/ What's now left in optResSet are the resources only present in the\n+        \/\/ What's now left in the set are the resources only present in the\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/JimageDiffGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.Collections;\n@@ -73,1 +74,1 @@\n-            throw new IllegalStateException(\"Must not reach here!\");\n+            throw new AssertionError(\"Must not reach here!\");\n@@ -132,2 +133,1 @@\n-                \/\/ should this be RuntimeImageLinkException?   output needs cleanup?\n-                throw new IllegalStateException(\"kind and name must be set\");\n+                throw new AssertionError(\"kind and name must be set\");\n@@ -144,2 +144,1 @@\n-                        \/\/ should this be RuntimeImageLinkException?  output needs cleanup?\n-                        throw new IllegalStateException(\"Original bytes needed for MODIFIED, REMOVED!\");\n+                        throw new AssertionError(\"Original bytes needed for MODIFIED, REMOVED!\");\n@@ -228,1 +227,1 @@\n-        List<ResourceDiff> diffs;\n+        List<ResourceDiff> diffs = new ArrayList<>();\n@@ -235,1 +234,0 @@\n-            diffs = new ArrayList<>(numItems);  \/\/ why not initialized above?  optimized size?\n@@ -255,1 +253,1 @@\n-        return diffs;\n+        return Collections.unmodifiableList(diffs);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/ResourceDiff.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,2 +35,24 @@\n-    public RuntimeImageLinkException(String msg) {\n-        super(msg);\n+    public static enum Reason {\n+        PATCH_MODULE,  \/* link exception due to patched module *\/\n+        MODIFIED_FILE, \/* link exception due to modified file  *\/\n+    }\n+\n+    private final String file;\n+    private final Reason reason;\n+\n+    public RuntimeImageLinkException(String file, Reason reason) {\n+        this.file = file;\n+        this.reason = reason;\n+    }\n+\n+    public String getFile() {\n+        return file;\n+    }\n+\n+    public Reason getReason() {\n+        return reason;\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        return reason + \", file: \" + file;\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/RuntimeImageLinkException.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-main.capability.runtime=Capabilities: {0}run-time-image\n+main.runtime.image.linking.capability=Capabilities: {0}run-time-image\n@@ -122,2 +122,5 @@\n-err.runtime.link.packaged.mods=--keep-packaged-modules is not allowed. This run-time image capable JDK\\\n-\\ does not include packaged modules\n+err.runtime.link.packaged.mods=This JDK has no packaged modules.\\\n+\\ --keep-packaged-modules is not supported.\n+err.runtime.link.modified.file={0} has been modified\n+err.runtime.link.patched.module=File {0} not found in the modules image.\\\n+\\ --patch-module is not supported when linking from the run-time image\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-        ImageFileCreator.create(archives, ByteOrder.nativeOrder(), stack, false);\n+        ImageFileCreator.create(archives, ByteOrder.nativeOrder(), stack, false, null);\n","filename":"test\/jdk\/tools\/jlink\/ImageFileCreatorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,638 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.IOException;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.FileVisitor;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.SimpleFileVisitor;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Scanner;\n-import java.util.Set;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-import tests.Helper;\n-import tests.JImageValidator;\n-\n-public abstract class AbstractLinkableRuntimeTest {\n-\n-    protected static final boolean DEBUG = true;\n-\n-    public void run() throws Exception {\n-        Helper helper = Helper.newHelper(true \/* linking from run-time image *\/);\n-        if (helper == null) {\n-            System.err.println(AbstractLinkableRuntimeTest.class.getSimpleName() +\n-                               \": Test not run\");\n-            return;\n-        }\n-        runTest(helper);\n-        System.out.println(getClass().getSimpleName() + \" PASSED!\");\n-    }\n-\n-    \/** main test entrypoint **\/\n-    abstract void runTest(Helper helper) throws Exception;\n-\n-    \/**\n-     * Ensure 'java --list-modules' lists the correct set of modules in the given\n-     * image.\n-     *\n-     * @param jlinkImage\n-     * @param expectedModules\n-     *\/\n-    protected void verifyListModules(Path image,\n-            List<String> expectedModules) throws Exception {\n-        OutputAnalyzer out = runJavaCmd(image, List.of(\"--list-modules\"));\n-        List<String> actual = parseListMods(out.getStdout());\n-        Collections.sort(actual);\n-        if (!expectedModules.equals(actual)) {\n-            throw new AssertionError(\"Different modules! Expected \" + expectedModules + \" got: \" + actual);\n-        }\n-    }\n-\n-    protected OutputAnalyzer runJavaCmd(Path image, List<String> options) throws Exception {\n-        Path targetJava = image.resolve(\"bin\").resolve(getJava());\n-        List<String> cmd = new ArrayList<>();\n-        cmd.add(targetJava.toString());\n-        for (String opt: options) {\n-            cmd.add(opt);\n-        }\n-        List<String> javaCmd = Collections.unmodifiableList(cmd);\n-        OutputAnalyzer out;\n-        try {\n-            out = ProcessTools.executeCommand(javaCmd.toArray(new String[0]));\n-        } catch (Throwable e) {\n-            throw new Exception(\"Process failed to execute\", e);\n-        }\n-        if (out.getExitValue() != 0) {\n-            if (DEBUG) {\n-                System.err.println(\"Process stdout was: \");\n-                System.err.println(out.getStdout());\n-                System.err.println(\"Process stderr was: \");\n-                System.err.println(out.getStderr());\n-            }\n-            throw new AssertionError(\"'\" + javaCmd.stream().collect(Collectors.joining(\" \")) + \"'\"\n-                    + \" expected to succeed!\");\n-        }\n-        return out;\n-    }\n-\n-    protected Path createJavaImageRuntimeLink(BaseJlinkSpec baseSpec) throws Exception {\n-        return createJavaImageRuntimeLink(baseSpec, Collections.emptySet() \/* exclude all jmods *\/);\n-    }\n-\n-    protected Path createJavaImageRuntimeLink(BaseJlinkSpec baseSpec, Set<String> excludedJmods) throws Exception {\n-        \/\/ Be sure we have a JDK without JMODs\n-        Path runtimeJlinkImage = createRuntimeLinkImage(baseSpec, excludedJmods);\n-\n-        \/\/ On Windows jvm.dll is in 'bin' after the jlink\n-        Path libjvm = Path.of((isWindows() ? \"bin\" : \"lib\"), \"server\", System.mapLibraryName(\"jvm\"));\n-        JlinkSpecBuilder builder = new JlinkSpecBuilder();\n-        \/\/ And expect libjvm (not part of the jimage) to be present in the resulting image\n-        builder.expectedFile(libjvm.toString())\n-               .helper(baseSpec.getHelper())\n-               .name(baseSpec.getName())\n-               .validatingModule(baseSpec.getValidatingModule())\n-               .imagePath(runtimeJlinkImage)\n-               .expectedLocation(\"\/java.base\/java\/lang\/String.class\");\n-        for (String m: baseSpec.getModules()) {\n-            builder.addModule(m);\n-        }\n-        for (String extra: baseSpec.getExtraOptions()) {\n-            builder.extraJlinkOpt(extra);\n-        }\n-        return jlinkUsingImage(builder.build());\n-    }\n-\n-    protected Path jlinkUsingImage(JlinkSpec spec) throws Exception {\n-        return jlinkUsingImage(spec, new RuntimeLinkOutputAnalyzerHandler());\n-    }\n-\n-    protected Path jlinkUsingImage(JlinkSpec spec, OutputAnalyzerHandler handler) throws Exception {\n-        return jlinkUsingImage(spec, handler, new DefaultSuccessExitPredicate());\n-    }\n-\n-    protected Path jlinkUsingImage(JlinkSpec spec, OutputAnalyzerHandler handler, Predicate<OutputAnalyzer> exitChecker) throws Exception {\n-        String jmodLessGeneratedImage = \"target-jmodless-\" + spec.getName();\n-        Path targetImageDir = spec.getHelper().createNewImageDir(jmodLessGeneratedImage);\n-        Path targetJlink = spec.getImageToUse().resolve(\"bin\").resolve(getJlink());\n-        String[] jlinkCmdArray = new String[] {\n-                targetJlink.toString(),\n-                \"--output\", targetImageDir.toString(),\n-                \"--verbose\",\n-                \"--add-modules\", spec.getModules().stream().collect(Collectors.joining(\",\"))\n-        };\n-        List<String> jlinkCmd = new ArrayList<>();\n-        jlinkCmd.addAll(Arrays.asList(jlinkCmdArray));\n-        if (spec.getExtraJlinkOpts() != null && !spec.getExtraJlinkOpts().isEmpty()) {\n-            jlinkCmd.addAll(spec.getExtraJlinkOpts());\n-        }\n-        if (spec.getModulePath() != null) {\n-            for (String mp: spec.getModulePath()) {\n-                jlinkCmd.add(\"--module-path\");\n-                jlinkCmd.add(mp);\n-            }\n-        }\n-        jlinkCmd = Collections.unmodifiableList(jlinkCmd); \/\/ freeze\n-        System.out.println(\"DEBUG: jmod-less jlink command: \" + jlinkCmd.stream().collect(\n-                                                    Collectors.joining(\" \")));\n-        OutputAnalyzer analyzer = null;\n-        try {\n-            analyzer = ProcessTools.executeProcess(jlinkCmd.toArray(new String[0]));\n-        } catch (Throwable t) {\n-            throw new AssertionError(\"Executing process failed!\", t);\n-        }\n-        if (!exitChecker.test(analyzer)) {\n-            if (DEBUG) {\n-                System.err.println(\"Process stdout was: \");\n-                System.err.println(analyzer.getStdout());\n-                System.err.println(\"Process stderr was: \");\n-                System.err.println(analyzer.getStderr());\n-            }\n-            \/\/ if the exit checker failed, we expected the other outcome\n-            \/\/ i.e. fail for success and success for fail.\n-            boolean successExit = analyzer.getExitValue() == 0;\n-            String msg = String.format(\"Expected jlink to %s given a jmodless image. Exit code was: %d\",\n-                                       (successExit ? \"fail\" : \"pass\"), analyzer.getExitValue());\n-            throw new AssertionError(msg);\n-        }\n-        handler.handleAnalyzer(analyzer); \/\/ Give tests a chance to process in\/output\n-\n-        \/\/ validate the resulting image; Includes running 'java -version', only do this\n-        \/\/ if the jlink succeeded.\n-        if (analyzer.getExitValue() == 0) {\n-            JImageValidator validator = new JImageValidator(spec.getValidatingModule(), spec.getExpectedLocations(),\n-                    targetImageDir.toFile(), spec.getUnexpectedLocations(), Collections.emptyList(), spec.getExpectedFiles());\n-            validator.validate(); \/\/ This doesn't validate locations\n-            if (!spec.getExpectedLocations().isEmpty() || !spec.getUnexpectedLocations().isEmpty()) {\n-                JImageValidator.validate(targetImageDir.resolve(\"lib\").resolve(\"modules\"), spec.getExpectedLocations(), spec.getUnexpectedLocations());\n-            }\n-        }\n-        return targetImageDir;\n-    }\n-\n-    \/**\n-     * Prepares the test for execution. This assumes the current runtime\n-     * supports linking from it. However, since the 'jmods' dir might be present\n-     * (default jmods module path), the 'jmods' directory needs to get removed\n-     * to provoke actual linking from the run-time image.\n-     *\n-     * @param baseSpec\n-     * @return A path to a JDK that is capable for linking from the run-time\n-     *         image.\n-     * @throws Exception\n-     *\/\n-    protected Path createRuntimeLinkImage(BaseJlinkSpec baseSpec) throws Exception {\n-        return createRuntimeLinkImage(baseSpec, Collections.emptySet() \/* exclude all jmods *\/);\n-    }\n-\n-    \/**\n-     * Prepares the test for execution. This assumes the current runtime\n-     * supports linking from it. However, since the 'jmods' dir might be present\n-     * (default jmods module path), the 'jmods' directory needs to get removed\n-     * to provoke actual linking from the run-time image.\n-     *\n-     * @param baseSpec\n-     *            The modules to jlink\n-     * @param excludedJmods\n-     *            The set of jmod files to exclude in the base JDK. Empty set if\n-     *            all JMODs should be removed.\n-     * @return A path to a JDK image ready for running jlink\n-     * @throws Exception\n-     *\/\n-    protected Path createRuntimeLinkImage(BaseJlinkSpec baseSpec,\n-                                          Set<String> excludedJmodFiles) throws Exception {\n-        Path runtimeJlinkImage = baseSpec.getHelper().createNewImageDir(baseSpec.getName() + \"-jlink\");\n-        copyJDKTreeWithoutSpecificJmods(runtimeJlinkImage, excludedJmodFiles);\n-        \/\/ Verify the base image is actually without desired packaged modules\n-        if (excludedJmodFiles.isEmpty()) {\n-            if (Files.exists(runtimeJlinkImage.resolve(\"jmods\"))) {\n-                throw new AssertionError(\"Must not contain 'jmods' directory\");\n-            }\n-        } else {\n-            Path basePath = runtimeJlinkImage.resolve(\"jmods\");\n-            for (String jmodFile: excludedJmodFiles) {\n-                Path unexpectedFile = basePath.resolve(Path.of(jmodFile));\n-                if (Files.exists(unexpectedFile)) {\n-                    throw new AssertionError(\"Must not contain jmod: \" + unexpectedFile);\n-                }\n-            }\n-        }\n-        return runtimeJlinkImage;\n-    }\n-\n-    private void copyJDKTreeWithoutSpecificJmods(Path runtimeJlinkImage,\n-                                                 Set<String> excludedJmods) throws Exception {\n-        Files.createDirectory(runtimeJlinkImage);\n-        String javaHome = System.getProperty(\"java.home\");\n-        Path root = Path.of(javaHome);\n-        FileVisitor<Path> fileVisitor = null;\n-        if (excludedJmods.isEmpty()) {\n-            fileVisitor = new ExcludeAllJmodsFileVisitor(root, runtimeJlinkImage);\n-        } else {\n-            fileVisitor = new FileExcludingFileVisitor(excludedJmods,\n-                                                       root,\n-                                                       runtimeJlinkImage);\n-        }\n-        Files.walkFileTree(root, fileVisitor);\n-    }\n-\n-    private List<String> parseListMods(String output) throws Exception {\n-        List<String> outputLines = new ArrayList<>();\n-        try (Scanner lineScan = new Scanner(output)) {\n-            while (lineScan.hasNextLine()) {\n-                outputLines.add(lineScan.nextLine());\n-            }\n-        }\n-        return outputLines.stream()\n-                .map(a -> { return a.split(\"@\", 2)[0];})\n-                .filter(a -> !a.isBlank())\n-                .collect(Collectors.toList());\n-    }\n-\n-    private String getJlink() {\n-        return getBinary(\"jlink\");\n-    }\n-\n-    private String getJava() {\n-        return getBinary(\"java\");\n-    }\n-\n-    private String getBinary(String binary) {\n-        return isWindows() ? binary + \".exe\" : binary;\n-    }\n-\n-    protected static boolean isWindows() {\n-        return System.getProperty(\"os.name\").startsWith(\"Windows\");\n-    }\n-\n-    static class ExcludeAllJmodsFileVisitor extends SimpleFileVisitor<Path> {\n-        private final Path root;\n-        private final Path destination;\n-\n-        private ExcludeAllJmodsFileVisitor(Path root,\n-                                           Path destination) {\n-            this.destination = destination;\n-            this.root = root;\n-        }\n-\n-        @Override\n-        public FileVisitResult preVisitDirectory(Path dir,\n-                BasicFileAttributes attrs) throws IOException {\n-            Objects.requireNonNull(dir);\n-            Path relative = root.relativize(dir);\n-            if (relative.getFileName().equals(Path.of(\"jmods\"))) {\n-                return FileVisitResult.SKIP_SUBTREE;\n-            }\n-            \/\/ Create dir in destination location\n-            Path targetDir = destination.resolve(relative);\n-            if (!Files.exists(targetDir)) {\n-                Files.createDirectory(targetDir);\n-            }\n-            return FileVisitResult.CONTINUE;\n-        }\n-\n-        @Override\n-        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n-                throws IOException {\n-            Path relative = root.relativize(file);\n-            Files.copy(file, destination.resolve(relative), StandardCopyOption.REPLACE_EXISTING);\n-            return FileVisitResult.CONTINUE;\n-        }\n-    }\n-\n-    static class FileExcludingFileVisitor extends SimpleFileVisitor<Path> {\n-\n-        private final Set<String> filesToExclude;\n-        private final Path root;\n-        private final Path destination;\n-\n-        private FileExcludingFileVisitor(Set<String> filesToExclude,\n-                                         Path root,\n-                                         Path destination) {\n-            this.filesToExclude = filesToExclude;\n-            this.destination = destination;\n-            this.root = root;\n-        }\n-\n-        @Override\n-        public FileVisitResult preVisitDirectory(Path dir,\n-                BasicFileAttributes attrs) throws IOException {\n-            Objects.requireNonNull(dir);\n-            Path relative = root.relativize(dir);\n-            \/\/ Create dir in destination location\n-            Path targetDir = destination.resolve(relative);\n-            if (!Files.exists(targetDir)) {\n-                Files.createDirectory(targetDir);\n-            }\n-            return FileVisitResult.CONTINUE;\n-        }\n-\n-        @Override\n-        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n-                throws IOException {\n-            Path relative = root.relativize(file);\n-            \/\/ Skip files as determined by the exclude set\n-            String fileName = file.getFileName().toString();\n-            if (!filesToExclude.contains(fileName)) {\n-                Files.copy(file, destination.resolve(relative), StandardCopyOption.REPLACE_EXISTING);\n-            }\n-            return FileVisitResult.CONTINUE;\n-        }\n-\n-    }\n-\n-    static class BaseJlinkSpec {\n-        final Helper helper;\n-        final String name;\n-        final String validatingModule;\n-        final List<String> modules;\n-        final List<String> extraOptions;\n-\n-        BaseJlinkSpec(Helper helper, String name, String validatingModule,\n-                List<String> modules, List<String> extraOptions) {\n-            this.helper = helper;\n-            this.name = name;\n-            this.modules = modules;\n-            this.extraOptions = extraOptions;\n-            this.validatingModule = validatingModule;\n-        }\n-\n-        public String getValidatingModule() {\n-            return validatingModule;\n-        }\n-\n-        public Helper getHelper() {\n-            return helper;\n-        }\n-\n-        public String getName() {\n-            return name;\n-        }\n-\n-        public List<String> getModules() {\n-            return modules;\n-        }\n-\n-        public List<String> getExtraOptions() {\n-            return extraOptions;\n-        }\n-    }\n-\n-    static class BaseJlinkSpecBuilder {\n-        Helper helper;\n-        String name;\n-        String validatingModule;\n-        List<String> modules = new ArrayList<>();\n-        List<String> extraOptions = new ArrayList<>();\n-\n-        BaseJlinkSpecBuilder addModule(String module) {\n-            modules.add(module);\n-            return this;\n-        }\n-\n-        BaseJlinkSpecBuilder addExtraOption(String option) {\n-            extraOptions.add(option);\n-            return this;\n-        }\n-\n-        BaseJlinkSpecBuilder helper(Helper helper) {\n-            this.helper = helper;\n-            return this;\n-        }\n-\n-        BaseJlinkSpecBuilder name(String name) {\n-            this.name = name;\n-            return this;\n-        }\n-\n-        BaseJlinkSpecBuilder validatingModule(String module) {\n-            this.validatingModule = module;\n-            return this;\n-        }\n-\n-        BaseJlinkSpec build() {\n-            if (name == null) {\n-                throw new IllegalStateException(\"Name must be set\");\n-            }\n-            if (helper == null) {\n-                throw new IllegalStateException(\"helper must be set\");\n-            }\n-            if (validatingModule == null) {\n-                throw new IllegalStateException(\"the module which should get validated must be set\");\n-            }\n-            return new BaseJlinkSpec(helper, name, validatingModule, modules, extraOptions);\n-        }\n-    }\n-\n-    static class JlinkSpec {\n-        final Path imageToUse;\n-        final Helper helper;\n-        final String name;\n-        final List<String> modules;\n-        final String validatingModule;\n-        final List<String> expectedLocations;\n-        final List<String> unexpectedLocations;\n-        final String[] expectedFiles;\n-        final List<String> extraJlinkOpts;\n-        final List<String> modulePath;\n-\n-        JlinkSpec(Path imageToUse, Helper helper, String name, List<String> modules,\n-                String validatingModule, List<String> expectedLocations,\n-                List<String> unexpectedLocations, String[] expectedFiles,\n-                List<String> extraJlinkOpts,\n-                List<String> modulePath) {\n-            this.imageToUse = imageToUse;\n-            this.helper = helper;\n-            this.name = name;\n-            this.modules = modules;\n-            this.validatingModule = validatingModule;\n-            this.expectedLocations = expectedLocations;\n-            this.unexpectedLocations = unexpectedLocations;\n-            this.expectedFiles = expectedFiles;\n-            this.extraJlinkOpts = extraJlinkOpts;\n-            this.modulePath = modulePath;\n-        }\n-\n-        public Path getImageToUse() {\n-            return imageToUse;\n-        }\n-\n-        public Helper getHelper() {\n-            return helper;\n-        }\n-\n-        public String getName() {\n-            return name;\n-        }\n-\n-        public List<String> getModules() {\n-            return modules;\n-        }\n-\n-        public String getValidatingModule() {\n-            return validatingModule;\n-        }\n-\n-        public List<String> getExpectedLocations() {\n-            return expectedLocations;\n-        }\n-\n-        public List<String> getUnexpectedLocations() {\n-            return unexpectedLocations;\n-        }\n-\n-        public String[] getExpectedFiles() {\n-            return expectedFiles;\n-        }\n-\n-        public List<String> getExtraJlinkOpts() {\n-            return extraJlinkOpts;\n-        }\n-\n-        public List<String> getModulePath() {\n-            return modulePath;\n-        }\n-    }\n-\n-    static class JlinkSpecBuilder {\n-        Path imageToUse;\n-        Helper helper;\n-        String name;\n-        List<String> modules = new ArrayList<>();\n-        String validatingModule;\n-        List<String> expectedLocations = new ArrayList<>();\n-        List<String> unexpectedLocations = new ArrayList<>();\n-        List<String> expectedFiles = new ArrayList<>();\n-        List<String> extraJlinkOpts = new ArrayList<>();\n-        List<String> modulePath = new ArrayList<>();\n-\n-        JlinkSpec build() {\n-            if (imageToUse == null) {\n-                throw new IllegalStateException(\"No image to use for jlink specified!\");\n-            }\n-            if (helper == null) {\n-                throw new IllegalStateException(\"No helper specified!\");\n-            }\n-            if (name == null) {\n-                throw new IllegalStateException(\"No name for the image location specified!\");\n-            }\n-            if (validatingModule == null) {\n-                throw new IllegalStateException(\"No module specified for after generation validation!\");\n-            }\n-            return new JlinkSpec(imageToUse,\n-                                 helper,\n-                                 name,\n-                                 modules,\n-                                 validatingModule,\n-                                 expectedLocations,\n-                                 unexpectedLocations,\n-                                 expectedFiles.toArray(new String[0]),\n-                                 extraJlinkOpts,\n-                                 modulePath);\n-        }\n-\n-        JlinkSpecBuilder imagePath(Path image) {\n-            this.imageToUse = image;\n-            return this;\n-        }\n-\n-        JlinkSpecBuilder helper(Helper helper) {\n-            this.helper = helper;\n-            return this;\n-        }\n-\n-        JlinkSpecBuilder name(String name) {\n-            this.name = name;\n-            return this;\n-        }\n-\n-        JlinkSpecBuilder addModule(String module) {\n-            modules.add(module);\n-            return this;\n-        }\n-\n-        JlinkSpecBuilder validatingModule(String module) {\n-            this.validatingModule = module;\n-            return this;\n-        }\n-\n-        JlinkSpecBuilder addModulePath(String modulePath) {\n-            this.modulePath.add(modulePath);\n-            return this;\n-        }\n-\n-        JlinkSpecBuilder expectedLocation(String location) {\n-            expectedLocations.add(location);\n-            return this;\n-        }\n-\n-        JlinkSpecBuilder unexpectedLocation(String location) {\n-            unexpectedLocations.add(location);\n-            return this;\n-        }\n-\n-        JlinkSpecBuilder expectedFile(String file) {\n-            expectedFiles.add(file);\n-            return this;\n-        }\n-\n-        JlinkSpecBuilder extraJlinkOpt(String opt) {\n-            extraJlinkOpts.add(opt);\n-            return this;\n-        }\n-    }\n-\n-    static abstract class OutputAnalyzerHandler {\n-\n-        public abstract void handleAnalyzer(OutputAnalyzer out);\n-\n-    }\n-\n-    static class RuntimeLinkOutputAnalyzerHandler extends OutputAnalyzerHandler {\n-\n-        @Override\n-        public void handleAnalyzer(OutputAnalyzer out) {\n-            out.shouldContain(\"Linking based on the current run-time image\");\n-        }\n-\n-    }\n-\n-    static class DefaultSuccessExitPredicate implements Predicate<OutputAnalyzer> {\n-\n-        @Override\n-        public boolean test(OutputAnalyzer t) {\n-            return t.getExitValue() == 0;\n-        }\n-\n-    }\n-}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/AbstractLinkableRuntimeTest.java","additions":0,"deletions":638,"binary":false,"changes":638,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.file.Path;\n-import java.util.List;\n-import java.util.Scanner;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import tests.Helper;\n-\n-\/*\n- * @test\n- * @summary Test --add-options jlink plugin when linking from the run-time image\n- * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n- * @library ..\/..\/lib \/test\/lib\n- * @enablePreview\n- * @modules java.base\/jdk.internal.jimage\n- *          jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- *          jdk.jlink\/jdk.tools.jimage\n- * @build tests.* jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.process.ProcessTools\n- * @run main\/othervm -Xmx1g AddOptionsTest\n- *\/\n-public class AddOptionsTest extends AbstractLinkableRuntimeTest {\n-\n-    public static void main(String[] args) throws Exception {\n-        AddOptionsTest test = new AddOptionsTest();\n-        test.run();\n-    }\n-\n-    @Override\n-    void runTest(Helper helper) throws Exception {\n-        Path finalImage = createJavaImageRuntimeLink(new BaseJlinkSpecBuilder()\n-                .addExtraOption(\"--add-options\")\n-                .addExtraOption(\"-Xlog:gc=info:stderr -XX:+UseParallelGC\")\n-                .name(\"java-base-with-opts\")\n-                .addModule(\"java.base\")\n-                .validatingModule(\"java.base\")\n-                .helper(helper)\n-                .build());\n-        verifyListModules(finalImage, List.of(\"java.base\"));\n-        verifyParallelGCInUse(finalImage);\n-    }\n-\n-    private void verifyParallelGCInUse(Path finalImage) throws Exception {\n-        OutputAnalyzer analyzer = runJavaCmd(finalImage, List.of(\"--version\"));\n-        boolean foundMatch = false;\n-        try (Scanner lineScan = new Scanner(analyzer.getStderr())) {\n-            while (lineScan.hasNextLine()) {\n-                String line = lineScan.nextLine();\n-                if (line.endsWith(\"Using Parallel\")) {\n-                    foundMatch = true;\n-                    break;\n-                }\n-            }\n-        }\n-        if (!foundMatch) {\n-            throw new AssertionError(\"Expected Parallel GC in place for jlinked image\");\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/AddOptionsTest.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.file.Path;\n-import java.util.List;\n-import java.util.Set;\n-\n-import tests.Helper;\n-\n-\n-\/*\n- * @test\n- * @summary Test basic linking from the run-time image with java.base.jmod missing\n- *          but java.xml.jmod present. It should link from the run-time image without errors.\n- * @requires (jlink.packagedModules & jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n- * @library ..\/..\/lib \/test\/lib\n- * @enablePreview\n- * @modules java.base\/jdk.internal.jimage\n- *          jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- *          jdk.jlink\/jdk.tools.jimage\n- * @build tests.* jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.process.ProcessTools\n- * @run main\/othervm -Xmx1g BasicJlinkMissingJavaBase\n- *\/\n-public class BasicJlinkMissingJavaBase extends AbstractLinkableRuntimeTest {\n-\n-    @Override\n-    public void runTest(Helper helper) throws Exception {\n-        Path finalImage = createJavaXMLRuntimeLink(helper, \"java-xml\");\n-        verifyListModules(finalImage, List.of(\"java.base\", \"java.xml\"));\n-    }\n-\n-    private Path createJavaXMLRuntimeLink(Helper helper, String name) throws Exception {\n-        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder();\n-        builder.helper(helper)\n-               .name(name)\n-               .addModule(\"java.xml\")\n-               .validatingModule(\"java.xml\");\n-        Set<String> excludedJmods = Set.of(\"java.base.jmod\");\n-        return createJavaImageRuntimeLink(builder.build(), excludedJmods);\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        BasicJlinkMissingJavaBase test = new BasicJlinkMissingJavaBase();\n-        test.run();\n-    }\n-\n-}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/BasicJlinkMissingJavaBase.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.file.Path;\n-import java.util.List;\n-\n-import tests.Helper;\n-\n-\n-\/*\n- * @test\n- * @summary Test basic linking from the run-time image\n- * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n- * @library ..\/..\/lib \/test\/lib\n- * @enablePreview\n- * @modules java.base\/jdk.internal.jimage\n- *          jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- *          jdk.jlink\/jdk.tools.jimage\n- * @build tests.* jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.process.ProcessTools\n- * @run main\/othervm -Xmx1g BasicJlinkTest\n- *\/\n-public class BasicJlinkTest extends AbstractLinkableRuntimeTest {\n-\n-    @Override\n-    public void runTest(Helper helper) throws Exception {\n-        Path finalImage = createJavaBaseRuntimeLink(helper, \"java-base\");\n-        verifyListModules(finalImage, List.of(\"java.base\"));\n-    }\n-\n-    private Path createJavaBaseRuntimeLink(Helper helper, String name) throws Exception {\n-        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder();\n-        builder.helper(helper)\n-               .name(name)\n-               .addModule(\"java.base\")\n-               .validatingModule(\"java.base\");\n-        return createJavaImageRuntimeLink(builder.build());\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        BasicJlinkTest test = new BasicJlinkTest();\n-        test.run();\n-    }\n-\n-}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/BasicJlinkTest.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.file.Path;\n-import java.util.List;\n-\n-import tests.Helper;\n-\n-\n-\/*\n- * @test\n- * @summary Test jmod-less jlink with a custom module\n- * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n- * @library ..\/..\/lib \/test\/lib\n- * @enablePreview\n- * @modules java.base\/jdk.internal.jimage\n- *          jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- *          jdk.jlink\/jdk.tools.jimage\n- * @build tests.* jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.process.ProcessTools\n- * @run main\/othervm -Xmx1g CustomModuleJlinkTest\n- *\/\n-public class CustomModuleJlinkTest extends AbstractLinkableRuntimeTest {\n-\n-    public static void main(String[] args) throws Exception {\n-        CustomModuleJlinkTest test = new CustomModuleJlinkTest();\n-        test.run();\n-    }\n-\n-    @Override\n-    void runTest(Helper helper) throws Exception {\n-        String customModule = \"leaf1\";\n-        helper.generateDefaultJModule(customModule);\n-\n-        \/\/ create a base image for linking from the run-time image\n-        Path jlinkImage = createRuntimeLinkImage(new BaseJlinkSpecBuilder()\n-                                                    .helper(helper)\n-                                                    .name(\"cmod-jlink\")\n-                                                    .addModule(\"java.base\")\n-                                                    .validatingModule(\"java.base\")\n-                                                    .build());\n-\n-        \/\/ Next jlink using the run-time image for java.base, but take\n-        \/\/ the custom module from the module path.\n-        Path finalImage = jlinkUsingImage(new JlinkSpecBuilder()\n-                                                .imagePath(jlinkImage)\n-                                                .helper(helper)\n-                                                .name(customModule)\n-                                                .addModulePath(helper.defaultModulePath(false))\n-                                                .expectedLocation(String.format(\"\/%s\/%s\/com\/foo\/bar\/X.class\", customModule, customModule))\n-                                                .addModule(customModule)\n-                                                .validatingModule(customModule)\n-                                                .build());\n-        \/\/ Expected only the transitive closure of \"leaf1\" module in the --list-modules\n-        \/\/ output of the java launcher.\n-        List<String> expectedModules = List.of(\"java.base\", customModule);\n-        verifyListModules(finalImage, expectedModules);\n-    }\n-\n-}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/CustomModuleJlinkTest.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.charset.StandardCharsets;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-\n-import tests.Helper;\n-\n-\/*\n- * @test\n- * @summary Verify JLI class generation in run-time image link mode\n- * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n- * @library ..\/..\/lib \/test\/lib\n- * @enablePreview\n- * @modules java.base\/jdk.internal.jimage\n- *          jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- *          jdk.jlink\/jdk.tools.jimage\n- * @build tests.* jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.process.ProcessTools\n- * @run main\/othervm -Xmx1g GenerateJLIClassesTest\n- *\/\n-public class GenerateJLIClassesTest extends AbstractLinkableRuntimeTest {\n-\n-    public static void main(String[] args) throws Exception {\n-        GenerateJLIClassesTest test = new GenerateJLIClassesTest();\n-        test.run();\n-    }\n-\n-    \/*\n-     * java.lang.invoke.BoundMethodHandle$Species_* classes get generated\n-     * by the GenerateJLiClassesPlugin. This test ensures that potentially\n-     * generated JLI classes from the run-time image don't populate to the\n-     * target image in the run-time image based link mode.\n-     *\/\n-    @Override\n-    void runTest(Helper helper) throws Exception {\n-        Path baseFile = Files.createTempFile(\"base\", \"trace\");\n-        String species = \"LLLLLLLLLLLLLLLLLLL\";\n-        String fileString = \"[SPECIES_RESOLVE] java.lang.invoke.BoundMethodHandle$Species_\" + species + \" (salvaged)\\n\";\n-        Files.write(baseFile, fileString.getBytes(StandardCharsets.UTF_8));\n-        Path runtimeLinkableImage = createRuntimeLinkImage(new BaseJlinkSpecBuilder()\n-                                                            .helper(helper)\n-                                                            .name(\"jlink.jli-jmodless\")\n-                                                            .validatingModule(\"java.base\")\n-                                                            .build());\n-        \/\/ Finally attempt another jmodless link reducing modules to java.base only,\n-        \/\/ and asking for specific jli classes.\n-        jlinkUsingImage(new JlinkSpecBuilder()\n-                                .helper(helper)\n-                                .imagePath(runtimeLinkableImage)\n-                                .name(\"java.base-jli-derived\")\n-                                .addModule(\"java.base\")\n-                                .extraJlinkOpt(\"--generate-jli-classes=@\" + baseFile.toString())\n-                                .expectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_\" + species + \".class\")\n-                                .expectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_L.class\")\n-                                .unexpectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_\" + species.substring(1) + \".class\")\n-                                .unexpectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LL.class\")\n-                                .validatingModule(\"java.base\")\n-                                .build());\n-    }\n-\n-}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/GenerateJLIClassesTest.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-\n-import tests.Helper;\n-\n-\/*\n- * @test\n- * @summary Test reproducibility of linking an java.se image using the run-time\n- *          image.\n- * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n- * @library ..\/..\/lib \/test\/lib\n- * @enablePreview\n- * @modules java.base\/jdk.internal.jimage\n- *          jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- *          jdk.jlink\/jdk.tools.jimage\n- * @build tests.* jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.process.ProcessTools\n- * @run main\/othervm -Xmx1g JavaSEReproducibleTest\n- *\/\n-public class JavaSEReproducibleTest extends AbstractLinkableRuntimeTest {\n-\n-    public static void main(String[] args) throws Exception {\n-        JavaSEReproducibleTest test = new JavaSEReproducibleTest();\n-        test.run();\n-    }\n-\n-    @Override\n-    void runTest(Helper helper) throws Exception {\n-        String javaSeModule = \"java.se\";\n-        \/\/ create a java.se using jmod-less approach\n-        Path javaSEJmodLess1 = createJavaImageRuntimeLink(new BaseJlinkSpecBuilder()\n-                                                                   .helper(helper)\n-                                                                   .name(\"java-se-repro1\")\n-                                                                   .addModule(javaSeModule)\n-                                                                   .validatingModule(javaSeModule)\n-                                                                   .build());\n-\n-        \/\/ create another java.se version using jmod-less approach\n-        Path javaSEJmodLess2 = createJavaImageRuntimeLink(new BaseJlinkSpecBuilder()\n-                                                                   .helper(helper)\n-                                                                   .name(\"java-se-repro2\")\n-                                                                   .addModule(javaSeModule)\n-                                                                   .validatingModule(javaSeModule)\n-                                                                   .build());\n-        if (Files.mismatch(javaSEJmodLess1.resolve(\"lib\").resolve(\"modules\"),\n-                           javaSEJmodLess2.resolve(\"lib\").resolve(\"modules\")) != -1L) {\n-            throw new RuntimeException(\"jlink producing inconsistent result for \" + javaSeModule + \" (jmod-less)\");\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/JavaSEReproducibleTest.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.file.Path;\n-import java.util.function.Predicate;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import tests.Helper;\n-\n-\n-\/*\n- * @test\n- * @summary Verify that jlink with an empty module path, but trying to use\n- *          --keep-packaged-modules fails as expected.\n- * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n- * @library ..\/..\/lib \/test\/lib\n- * @enablePreview\n- * @modules java.base\/jdk.internal.jimage\n- *          jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- *          jdk.jlink\/jdk.tools.jimage\n- * @build tests.* jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.process.ProcessTools\n- * @run main\/othervm -Xmx1g KeepPackagedModulesFailTest\n- *\/\n-public class KeepPackagedModulesFailTest extends AbstractLinkableRuntimeTest {\n-\n-    public static void main(String[] args) throws Exception {\n-        KeepPackagedModulesFailTest test = new KeepPackagedModulesFailTest();\n-        test.run();\n-    }\n-\n-    @Override\n-    void runTest(Helper helper) throws Exception {\n-        \/\/ create a base image for linking from the run-time image\n-        Path baseImage = createRuntimeLinkImage(new BaseJlinkSpecBuilder()\n-                                                    .helper(helper)\n-                                                    .name(\"jlink-fail\")\n-                                                    .addModule(\"java.base\")\n-                                                    .validatingModule(\"java.base\")\n-                                                    .build());\n-\n-        CapturingHandler handler = new CapturingHandler();\n-        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n-\n-            @Override\n-            public boolean test(OutputAnalyzer t) {\n-                return t.getExitValue() != 0; \/\/ expect failure\n-            }\n-        };\n-        \/\/ Attempt a jlink using the run-time image and also using option\n-        \/\/ --keep-packaged-modules, which should fail.\n-        jlinkUsingImage(new JlinkSpecBuilder()\n-                                .helper(helper)\n-                                .imagePath(baseImage)\n-                                .name(\"java-base-jlink-keep-packaged-target\")\n-                                .addModule(\"java.base\")\n-                                .extraJlinkOpt(\"--keep-packaged-modules=foo\")\n-                                .validatingModule(\"java.base\")\n-                                .build(), handler, exitFailPred);\n-        OutputAnalyzer analyzer = handler.analyzer();\n-        if (analyzer.getExitValue() == 0) {\n-            throw new AssertionError(\"Expected jlink to have failed!\");\n-        }\n-        analyzer.stdoutShouldContain(\"Error\");\n-        analyzer.stdoutShouldContain(\"--keep-packaged-modules\");\n-    }\n-\n-}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/KeepPackagedModulesFailTest.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.file.Path;\n-import java.util.function.Predicate;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import tests.Helper;\n-\n-\/*\n- * @test\n- * @summary Verify jlink fails by default when linking from the run-time image\n- *          and files have been modified\n- * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n- * @library ..\/..\/lib \/test\/lib\n- * @enablePreview\n- * @modules java.base\/jdk.internal.jimage\n- *          jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- *          jdk.jlink\/jdk.tools.jimage\n- * @build tests.* jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.process.ProcessTools\n- * @run main\/othervm -Xmx1g ModifiedFilesExitTest\n- *\/\n-public class ModifiedFilesExitTest extends ModifiedFilesTest {\n-\n-    public static void main(String[] args) throws Exception {\n-        ModifiedFilesExitTest test = new ModifiedFilesExitTest();\n-        test.run();\n-    }\n-\n-    @Override\n-    String initialImageName() {\n-        return \"java-base-jlink-with-mod-exit\";\n-    }\n-\n-    @Override\n-    void testAndAssert(Path modifiedFile, Helper helper, Path initialImage)\n-            throws Exception {\n-        CapturingHandler handler = new CapturingHandler();\n-        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n-\n-            @Override\n-            public boolean test(OutputAnalyzer t) {\n-                return t.getExitValue() != 0; \/\/ expect failure\n-            }\n-        };\n-        jlinkUsingImage(new JlinkSpecBuilder()\n-                                .helper(helper)\n-                                .imagePath(initialImage)\n-                                .name(\"java-base-jlink-with-mod-exit-target\")\n-                                .addModule(\"java.base\")\n-                                .validatingModule(\"java.base\")\n-                                .build(), handler, exitFailPred);\n-        OutputAnalyzer analyzer = handler.analyzer();\n-        if (analyzer.getExitValue() == 0) {\n-            throw new AssertionError(\"Expected jlink to fail due to modified file!\");\n-        }\n-        analyzer.stdoutShouldContain(modifiedFile.toString() + \" has been modified\");\n-        \/\/ Verify the error message is reasonable\n-        analyzer.stdoutShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n-        analyzer.stdoutShouldNotContain(\"java.lang.IllegalArgumentException\");\n-    }\n-\n-}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesExitTest.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Properties;\n-\n-import tests.Helper;\n-\n-public abstract class ModifiedFilesTest extends AbstractLinkableRuntimeTest {\n-\n-    abstract String initialImageName();\n-    abstract void testAndAssert(Path modifiedFile, Helper helper, Path initialImage) throws Exception;\n-\n-    @Override\n-    void runTest(Helper helper) throws Exception {\n-        Path initialImage = createRuntimeLinkImage(new BaseJlinkSpecBuilder()\n-                .name(initialImageName())\n-                .addModule(\"java.base\")\n-                .validatingModule(\"java.base\")\n-                .helper(helper)\n-                .build());\n-\n-        Path netPropertiesFile = modifyFileInImage(initialImage);\n-\n-        testAndAssert(netPropertiesFile, helper, initialImage);\n-    }\n-\n-    protected Path modifyFileInImage(Path jmodLessImg)\n-            throws IOException, AssertionError {\n-        \/\/ modify net.properties config file\n-        Path netPropertiesFile = jmodLessImg.resolve(\"conf\").resolve(\"net.properties\");\n-        Properties props = new Properties();\n-        try (InputStream is = Files.newInputStream(netPropertiesFile)) {\n-            props.load(is);\n-        }\n-        String prevVal = (String)props.put(\"java.net.useSystemProxies\", Boolean.TRUE.toString());\n-        if (prevVal == null || Boolean.getBoolean(prevVal) != false) {\n-            throw new AssertionError(\"Expected previous value to be false!\");\n-        }\n-        try (OutputStream out = Files.newOutputStream(netPropertiesFile)) {\n-            props.store(out, \"Modified net.properties file!\");\n-        }\n-        return netPropertiesFile;\n-    }\n-}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesTest.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.file.Path;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import tests.Helper;\n-\n-\/*\n- * @test\n- * @summary Verify warnings are being produced when linking from the run-time\n- *          image and files have been modified\n- * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n- * @library ..\/..\/lib \/test\/lib\n- * @enablePreview\n- * @modules java.base\/jdk.internal.jimage\n- *          jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- *          jdk.jlink\/jdk.tools.jimage\n- * @build tests.* jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.process.ProcessTools\n- * @run main\/othervm -Xmx1g ModifiedFilesWarningTest\n- *\/\n-public class ModifiedFilesWarningTest extends ModifiedFilesTest {\n-\n-    protected static final String IGNORE_MODIFIED_RUNTIME_OPT = \"--ignore-modified-runtime\";\n-\n-    public static void main(String[] args) throws Exception {\n-        ModifiedFilesWarningTest test = new ModifiedFilesWarningTest();\n-        test.run();\n-    }\n-\n-    @Override\n-    String initialImageName() {\n-        return \"java-base-jlink-with-mod-warn\";\n-    }\n-\n-    @Override\n-    void testAndAssert(Path modifiedFile, Helper helper, Path initialImage) throws Exception {\n-        CapturingHandler handler = new CapturingHandler();\n-        jlinkUsingImage(new JlinkSpecBuilder()\n-                                .helper(helper)\n-                                .imagePath(initialImage)\n-                                .name(\"java-base-jlink-with-mod-warn-target\")\n-                                .addModule(\"java.base\")\n-                                .validatingModule(\"java.base\")\n-                                .extraJlinkOpt(IGNORE_MODIFIED_RUNTIME_OPT) \/\/ only generate a warning\n-                                .build(), handler);\n-        OutputAnalyzer out = handler.analyzer();\n-        \/\/ verify we get the warning message\n-        out.stderrShouldMatch(\"WARNING: .* has been modified\");\n-        out.stderrShouldNotContain(\"java.lang.IllegalArgumentException\");\n-        out.stderrShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n-    }\n-}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesWarningTest.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.file.Path;\n-import java.util.function.Predicate;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import tests.Helper;\n-\n-\/*\n- * @test\n- * @summary Verify that a jlink using the run-time image cannot include jdk.jlink\n- * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n- * @library ..\/..\/lib \/test\/lib\n- * @enablePreview\n- * @modules java.base\/jdk.internal.jimage\n- *          jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- *          jdk.jlink\/jdk.tools.jimage\n- * @build tests.* jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.process.ProcessTools\n- * @run main\/othervm -Xmx1g MultiHopTest\n- *\/\n-public class MultiHopTest extends AbstractLinkableRuntimeTest {\n-\n-    @Override\n-    void runTest(Helper helper) throws Exception {\n-        Path jdkJlinkJmodless = createJDKJlinkJmodLess(helper, \"jdk.jlink-multi-hop1\");\n-        CapturingHandler handler = new CapturingHandler();\n-        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n-\n-            @Override\n-            public boolean test(OutputAnalyzer a) {\n-                return a.getExitValue() != 0; \/\/ expect failure\n-            }\n-        };\n-        jlinkUsingImage(new JlinkSpecBuilder()\n-                                .helper(helper)\n-                                .imagePath(jdkJlinkJmodless)\n-                                .name(\"jdk-jlink-multi-hop1-target\")\n-                                .addModule(\"jdk.jlink\")\n-                                .validatingModule(\"java.base\")\n-                                .build(), handler, exitFailPred);\n-        OutputAnalyzer analyzer = handler.analyzer();\n-        if (analyzer.getExitValue() == 0) {\n-            throw new AssertionError(\"Expected jlink to fail due to including jdk.jlink\");\n-        }\n-        String expectedMsg = \"This JDK does not contain packaged modules \" +\n-                             \"and cannot be used to create another image with \" +\n-                             \"the jdk.jlink module\";\n-        analyzer.stdoutShouldContain(expectedMsg);\n-        analyzer.stdoutShouldNotContain(\"Exception\"); \/\/ ensure error message is sane\n-    }\n-\n-    private Path createJDKJlinkJmodLess(Helper helper, String name) throws Exception {\n-        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder();\n-        builder.helper(helper)\n-               .name(name)\n-               .addModule(\"jdk.jlink\")\n-               .validatingModule(\"java.base\");\n-        return createRuntimeLinkImage(builder.build());\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        MultiHopTest test = new MultiHopTest();\n-        test.run();\n-    }\n-\n-}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/MultiHopTest.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -1,171 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.IOException;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.SimpleFileVisitor;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import tests.Helper;\n-import tests.JImageGenerator;\n-\n-\/*\n- * @test\n- * @summary Compare packaged-modules jlink with a run-time image based jlink to\n- *          produce the same result\n- * @requires (jlink.packagedModules & jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n- * @library ..\/..\/lib \/test\/lib\n- * @enablePreview\n- * @modules java.base\/jdk.internal.jimage\n- *          jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- *          jdk.jlink\/jdk.tools.jimage\n- * @build tests.* jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.process.ProcessTools\n- * @run main\/othervm -Xmx1g PackagedModulesVsJmodLessTest\n- *\/\n-public class PackagedModulesVsJmodLessTest extends AbstractLinkableRuntimeTest {\n-\n-    public static void main(String[] args) throws Exception {\n-        PackagedModulesVsJmodLessTest test = new PackagedModulesVsJmodLessTest();\n-        test.run();\n-    }\n-\n-    @Override\n-    void runTest(Helper helper) throws Exception {\n-        \/\/ create a java.se using jmod-less approach\n-        Path javaSEruntimeLink = createJavaImageRuntimeLink(new BaseJlinkSpecBuilder()\n-                                                            .helper(helper)\n-                                                            .name(\"java-se-jmodless\")\n-                                                            .addModule(\"java.se\")\n-                                                            .validatingModule(\"java.se\")\n-                                                            .build());\n-\n-        \/\/ create a java.se using packaged modules (jmod-full)\n-        Path javaSEJmodFull = JImageGenerator.getJLinkTask()\n-                .output(helper.createNewImageDir(\"java-se-jmodfull\"))\n-                .addMods(\"java.se\").call().assertSuccess();\n-\n-        compareRecursively(javaSEruntimeLink, javaSEJmodFull);\n-    }\n-\n-    \/\/ Visit all files in the given directories checking that they're byte-by-byte identical\n-    private static void compareRecursively(Path javaSEJmodLess,\n-            Path javaSEJmodFull) throws IOException, AssertionError {\n-        FilesCapturingVisitor jmodFullVisitor = new FilesCapturingVisitor(javaSEJmodFull);\n-        FilesCapturingVisitor jmodLessVisitor = new FilesCapturingVisitor(javaSEJmodLess);\n-        Files.walkFileTree(javaSEJmodFull, jmodFullVisitor);\n-        Files.walkFileTree(javaSEJmodLess, jmodLessVisitor);\n-        List<String> jmodFullFiles = jmodFullVisitor.filesVisited();\n-        List<String> jmodLessFiles = jmodLessVisitor.filesVisited();\n-        Collections.sort(jmodFullFiles);\n-        Collections.sort(jmodLessFiles);\n-\n-        if (jmodFullFiles.size() != jmodLessFiles.size()) {\n-            throw new AssertionError(String.format(\"Size of files different for jmod-less (%d) vs jmod-full (%d) java.se jlink\", jmodLessFiles.size(), jmodFullFiles.size()));\n-        }\n-        String jimageFile = Path.of(\"lib\").resolve(\"modules\").toString();\n-        \/\/ Compare all files except the modules image\n-        for (int i = 0; i < jmodFullFiles.size(); i++) {\n-            String jmodFullPath = jmodFullFiles.get(i);\n-            String jmodLessPath = jmodLessFiles.get(i);\n-            if (!jmodFullPath.equals(jmodLessPath)) {\n-                throw new AssertionError(String.format(\"jmod-full path (%s) != jmod-less path (%s)\", jmodFullPath, jmodLessPath));\n-            }\n-            if (jmodFullPath.equals(jimageFile)) {\n-                continue;\n-            }\n-            Path a = javaSEJmodFull.resolve(Path.of(jmodFullPath));\n-            Path b = javaSEJmodLess.resolve(Path.of(jmodLessPath));\n-            if (Files.mismatch(a, b) != -1L) {\n-                handleFileMismatch(a, b);\n-            }\n-        }\n-        \/\/ Compare jimage contents by iterating its entries and comparing their\n-        \/\/ paths and content bytes\n-        \/\/\n-        \/\/ Note: The files aren't byte-by-byte comparable (probably due to string hashing\n-        \/\/ and offset differences in container bytes)\n-        Path jimageJmodLess = javaSEJmodLess.resolve(Path.of(\"lib\")).resolve(Path.of(\"modules\"));\n-        Path jimageJmodFull = javaSEJmodFull.resolve(Path.of(\"lib\")).resolve(Path.of(\"modules\"));\n-        List<String> jimageContentJmodLess = JImageHelper.listContents(jimageJmodLess);\n-        List<String> jimageContentJmodFull = JImageHelper.listContents(jimageJmodFull);\n-        if (jimageContentJmodLess.size() != jimageContentJmodFull.size()) {\n-            throw new AssertionError(String.format(\"Size of jimage content differs for jmod-less (%d) v. jmod-full (%d)\", jimageContentJmodLess.size(), jimageContentJmodFull.size()));\n-        }\n-        for (int i = 0; i < jimageContentJmodFull.size(); i++) {\n-            if (!jimageContentJmodFull.get(i).equals(jimageContentJmodLess.get(i))) {\n-                throw new AssertionError(String.format(\"Jimage content differs at index %d: jmod-full was: '%s' jmod-less was: '%s'\",\n-                                                       i,\n-                                                       jimageContentJmodFull.get(i),\n-                                                       jimageContentJmodLess.get(i)\n-                                                       ));\n-            }\n-            String loc = jimageContentJmodFull.get(i);\n-            if (isTreeInfoResource(loc)) {\n-                \/\/ Skip container bytes as those are offsets to the content\n-                \/\/ of the container which might be different between jlink runs.\n-                continue;\n-            }\n-            byte[] resBytesFull = JImageHelper.getLocationBytes(loc, jimageJmodFull);\n-            byte[] resBytesLess = JImageHelper.getLocationBytes(loc, jimageJmodLess);\n-            if (resBytesFull.length != resBytesLess.length || Arrays.mismatch(resBytesFull, resBytesLess) != -1) {\n-                throw new AssertionError(\"Content bytes mismatch for \" + loc);\n-            }\n-        }\n-    }\n-\n-    private static boolean isTreeInfoResource(String path) {\n-        return path.startsWith(\"\/packages\") || path.startsWith(\"\/modules\");\n-    }\n-\n-    private static void handleFileMismatch(Path a, Path b) {\n-        throw new AssertionError(\"Files mismatch: \" + a + \" vs. \" + b);\n-    }\n-\n-    static class FilesCapturingVisitor extends SimpleFileVisitor<Path> {\n-        private final Path basePath;\n-        private final List<String> filePaths = new ArrayList<>();\n-        public FilesCapturingVisitor(Path basePath) {\n-            this.basePath = basePath;\n-        }\n-\n-        @Override\n-        public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) {\n-            Path relative = basePath.relativize(path);\n-            filePaths.add(relative.toString());\n-            return FileVisitResult.CONTINUE;\n-        }\n-\n-        List<String> filesVisited() {\n-            return filePaths;\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/PackagedModulesVsJmodLessTest.java","additions":0,"deletions":171,"binary":false,"changes":171,"status":"deleted"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.function.Predicate;\n-import java.util.spi.ToolProvider;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import tests.Helper;\n-\n-\n-\/*\n- * @test\n- * @summary Test run-time link with --patch-module. Expect failure.\n- * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n- * @library ..\/..\/lib \/test\/lib\n- * @enablePreview\n- * @modules java.base\/jdk.internal.jimage\n- *          jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- *          jdk.jlink\/jdk.tools.jimage\n- * @build tests.* jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.process.ProcessTools\n- * @run main\/othervm -Xmx1g PatchedJDKModuleJlinkTest\n- *\/\n-public class PatchedJDKModuleJlinkTest extends AbstractLinkableRuntimeTest {\n-\n-    @Override\n-    public void runTest(Helper helper) throws Exception {\n-        String imageName = \"java-base-patched\";\n-        Path runtimeLinkImage = createRuntimeLinkImage(helper, imageName + \"-base\");\n-\n-        \/\/ Prepare patched module content\n-        Path patchSource = Path.of(\"java-base-patch-src\");\n-        Path pkg = patchSource.resolve(\"java\", \"lang\");\n-        Path extraClass = pkg.resolve(\"MyJlinkPatchInteger.java\");\n-        String source = \"\"\"\n-                package java.lang;\n-                public class MyJlinkPatchInteger {\n-                    public int add(int a, int b) {\n-                        return a + b;\n-                    }\n-                }\n-                \"\"\";\n-        Files.createDirectories(pkg);\n-        Files.writeString(extraClass, source);\n-        Path patchClasses = Path.of(\"java-base-patch-classes\");\n-        Files.createDirectories(patchClasses);\n-        ToolProvider javac = ToolProvider.findFirst(\"javac\")\n-                                         .orElseThrow(() -> new AssertionError(\"javac not found\"));\n-        javac.run(System.out, System.err, new String[] {\n-                \"-d\", patchClasses.toString(),\n-                \"--patch-module=java.base=\" + patchSource.toAbsolutePath().toString(),\n-                extraClass.toAbsolutePath().toString()\n-        });\n-\n-        \/\/ Perform a run-time image link expecting a failure\n-        CapturingHandler handler = new CapturingHandler();\n-        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n-\n-            @Override\n-            public boolean test(OutputAnalyzer t) {\n-                return t.getExitValue() != 0; \/\/ expect failure\n-            }\n-        };\n-        jlinkUsingImage(new JlinkSpecBuilder()\n-                                .helper(helper)\n-                                .imagePath(runtimeLinkImage)\n-                                .name(imageName + \"-derived\")\n-                                .addModule(\"java.base\")\n-                                .validatingModule(\"java.base\")\n-                                .extraJlinkOpt(\"-J--patch-module=java.base=\" +\n-                                               patchClasses.toAbsolutePath().toString())\n-                                .build(), handler, exitFailPred);\n-        OutputAnalyzer analyzer = handler.analyzer();\n-        if (analyzer.getExitValue() == 0) {\n-            throw new AssertionError(\"Expected jlink to fail due to patched module!\");\n-        }\n-        analyzer.stdoutShouldContain(\"MyJlinkPatchInteger.class not found in the modules image.\");\n-        analyzer.stdoutShouldContain(\"--patch-module is not supported\");\n-        \/\/ Verify the error message is reasonable\n-        analyzer.stdoutShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n-        analyzer.stdoutShouldNotContain(\"java.lang.IllegalArgumentException\");\n-    }\n-\n-    private Path createRuntimeLinkImage(Helper helper, String name) throws Exception {\n-        Path initialImage = createRuntimeLinkImage(new BaseJlinkSpecBuilder()\n-                .name(name)\n-                .addModule(\"java.base\")\n-                .validatingModule(\"java.base\")\n-                .helper(helper)\n-                .build());\n-        return initialImage;\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        PatchedJDKModuleJlinkTest test = new PatchedJDKModuleJlinkTest();\n-        test.run();\n-    }\n-\n-}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/PatchedJDKModuleJlinkTest.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.file.Path;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import tests.Helper;\n-import tests.JImageValidator;\n-\n-\/*\n- * @test\n- * @summary Test appropriate handling of generated SystemModules* classes in run-time image link mode\n- * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n- * @library ..\/..\/lib \/test\/lib\n- * @enablePreview\n- * @modules java.base\/jdk.internal.jimage\n- *          jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- *          jdk.jlink\/jdk.tools.jimage\n- * @build tests.* jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.process.ProcessTools\n- * @run main\/othervm -Xmx1g SystemModulesTest\n- *\/\n-public class SystemModulesTest extends AbstractLinkableRuntimeTest {\n-\n-    public static void main(String[] args) throws Exception {\n-        SystemModulesTest test = new SystemModulesTest();\n-        test.run();\n-    }\n-\n-    \/*\n-     * SystemModule classes are module specific. If the jlink is based on the\n-     * modules image, then earlier generated SystemModule classes shall not get\n-     * propagated.\n-     *\/\n-    @Override\n-    void runTest(Helper helper) throws Exception {\n-        \/\/ create an image with a module containing a main entrypoint (jdk.httpserver),\n-        \/\/ thus producing the SystemModules$0.class. Add jdk.jdwp.agent as a module which\n-        \/\/ isn't resolved by default, so as to generate SystemModules$default.class\n-        Path javaseJmodless = createJavaImageRuntimeLink(new BaseJlinkSpecBuilder()\n-                                                            .helper(helper)\n-                                                            .name(\"httpserver-jlink-jmodless-derived\")\n-                                                            .addModule(\"jdk.httpserver\")\n-                                                            .addModule(\"jdk.jdwp.agent\")\n-                                                            .validatingModule(\"java.base\")\n-                                                            .build());\n-        \/\/ Verify that SystemModules$0.class etc. are there, due to httpserver and jdwp.agent\n-        JImageValidator.validate(javaseJmodless.resolve(\"lib\").resolve(\"modules\"),\n-                                    List.of(\"\/java.base\/jdk\/internal\/module\/SystemModules$default.class\",\n-                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$0.class\",\n-                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$all.class\"),\n-                                    Collections.emptyList());\n-    }\n-\n-}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/SystemModulesTest.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.file.Path;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import tests.Helper;\n-import tests.JImageValidator;\n-\n-\/*\n- * @test\n- * @summary Test disabled SystemModulesPlugin in run-time image link mode. Expect\n- *          generated classes to not be there.\n- * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n- * @library ..\/..\/lib \/test\/lib\n- * @enablePreview\n- * @modules java.base\/jdk.internal.jimage\n- *          jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- *          jdk.jlink\/jdk.tools.jimage\n- * @build tests.* jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.process.ProcessTools\n- * @run main\/othervm -Xmx1g SystemModulesTest2\n- *\/\n-public class SystemModulesTest2 extends AbstractLinkableRuntimeTest {\n-\n-    public static void main(String[] args) throws Exception {\n-        SystemModulesTest2 test = new SystemModulesTest2();\n-        test.run();\n-    }\n-\n-    @Override\n-    void runTest(Helper helper) throws Exception {\n-        \/\/ See SystemModulesTest which enables the system-modules plugin. With\n-        \/\/ it disabled, we expect for the generated classes to not be there.\n-        Path javaJmodless = createJavaImageRuntimeLink(new BaseJlinkSpecBuilder()\n-                                                            .helper(helper)\n-                                                            .name(\"jlink-jmodless-sysmod2\")\n-                                                            .addModule(\"jdk.httpserver\")\n-                                                            .validatingModule(\"java.base\")\n-                                                            .addExtraOption(\"--disable-plugin\")\n-                                                            .addExtraOption(\"system-modules\")\n-                                                            .build());\n-        JImageValidator.validate(javaJmodless.resolve(\"lib\").resolve(\"modules\"),\n-                                    Collections.emptyList(),\n-                                    List.of(\"\/java.base\/jdk\/internal\/module\/SystemModules$all.class\",\n-                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$default.class\",\n-                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$0.class\"));\n-    }\n-\n-}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/SystemModulesTest2.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -0,0 +1,703 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.FileVisitor;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import tests.Helper;\n+import tests.JImageGenerator;\n+import tests.JImageGenerator.JLinkTask;\n+import tests.JImageValidator;\n+\n+public abstract class AbstractLinkableRuntimeTest {\n+\n+    protected static final boolean DEBUG = true;\n+\n+    public void run(boolean isLinkableRuntime) throws Exception {\n+        Helper helper = Helper.newHelper(isLinkableRuntime);\n+        if (helper == null) {\n+            System.err.println(AbstractLinkableRuntimeTest.class.getSimpleName() +\n+                               \": Test not run\");\n+            return;\n+        }\n+        runTest(helper, isLinkableRuntime);\n+        System.out.println(getClass().getSimpleName() + \" PASSED!\");\n+    }\n+\n+    \/**\n+     * Main test entry point that actual tests ought to override.\n+     *\n+     * @param helper The jlink helper\n+     * @param isLinkableRuntime {@code true} iff the JDK build under test already\n+     *                          includes the linkable runtime capability in jlink.\n+     * @throws Exception\n+     *\/\n+    abstract void runTest(Helper helper, boolean isLinkableRuntime) throws Exception;\n+\n+    \/**\n+     * Ensure 'java --list-modules' lists the correct set of modules in the given\n+     * image.\n+     *\n+     * @param jlinkImage\n+     * @param expectedModules\n+     *\/\n+    protected void verifyListModules(Path image,\n+            List<String> expectedModules) throws Exception {\n+        OutputAnalyzer out = runJavaCmd(image, List.of(\"--list-modules\"));\n+        List<String> actual = parseListMods(out.getStdout());\n+        Collections.sort(actual);\n+        if (!expectedModules.equals(actual)) {\n+            throw new AssertionError(\"Different modules! Expected \" + expectedModules + \" got: \" + actual);\n+        }\n+    }\n+\n+    protected OutputAnalyzer runJavaCmd(Path image, List<String> options) throws Exception {\n+        Path targetJava = image.resolve(\"bin\").resolve(getJava());\n+        List<String> cmd = new ArrayList<>();\n+        cmd.add(targetJava.toString());\n+        for (String opt: options) {\n+            cmd.add(opt);\n+        }\n+        List<String> javaCmd = Collections.unmodifiableList(cmd);\n+        OutputAnalyzer out;\n+        try {\n+            out = ProcessTools.executeCommand(javaCmd.toArray(new String[0]));\n+        } catch (Throwable e) {\n+            throw new Exception(\"Process failed to execute\", e);\n+        }\n+        if (out.getExitValue() != 0) {\n+            if (DEBUG) {\n+                System.err.println(\"Process stdout was: \");\n+                System.err.println(out.getStdout());\n+                System.err.println(\"Process stderr was: \");\n+                System.err.println(out.getStderr());\n+            }\n+            throw new AssertionError(\"'\" + javaCmd.stream().collect(Collectors.joining(\" \")) + \"'\"\n+                    + \" expected to succeed!\");\n+        }\n+        return out;\n+    }\n+\n+    protected Path createJavaImageRuntimeLink(BaseJlinkSpec baseSpec) throws Exception {\n+        return createJavaImageRuntimeLink(baseSpec, Collections.emptySet() \/* exclude all jmods *\/);\n+    }\n+\n+    protected Path createJavaImageRuntimeLink(BaseJlinkSpec baseSpec, Set<String> excludedJmods) throws Exception {\n+        \/\/ Be sure we have a JDK without JMODs\n+        Path runtimeJlinkImage = createRuntimeLinkImage(baseSpec, excludedJmods);\n+\n+        \/\/ On Windows jvm.dll is in 'bin' after the jlink\n+        Path libjvm = Path.of((isWindows() ? \"bin\" : \"lib\"), \"server\", System.mapLibraryName(\"jvm\"));\n+        JlinkSpecBuilder builder = new JlinkSpecBuilder();\n+        \/\/ And expect libjvm (not part of the jimage) to be present in the resulting image\n+        builder.expectedFile(libjvm.toString())\n+               .helper(baseSpec.getHelper())\n+               .name(baseSpec.getName())\n+               .validatingModule(baseSpec.getValidatingModule())\n+               .imagePath(runtimeJlinkImage)\n+               .expectedLocation(\"\/java.base\/java\/lang\/String.class\");\n+        for (String m: baseSpec.getModules()) {\n+            builder.addModule(m);\n+        }\n+        for (String extra: baseSpec.getExtraOptions()) {\n+            builder.extraJlinkOpt(extra);\n+        }\n+        return jlinkUsingImage(builder.build());\n+    }\n+\n+    protected Path jlinkUsingImage(JlinkSpec spec) throws Exception {\n+        return jlinkUsingImage(spec, new RuntimeLinkOutputAnalyzerHandler());\n+    }\n+\n+    protected Path jlinkUsingImage(JlinkSpec spec, OutputAnalyzerHandler handler) throws Exception {\n+        return jlinkUsingImage(spec, handler, new DefaultSuccessExitPredicate());\n+    }\n+\n+    protected Path jlinkUsingImage(JlinkSpec spec, OutputAnalyzerHandler handler, Predicate<OutputAnalyzer> exitChecker) throws Exception {\n+        String generatedImage = \"target-run-time-\" + spec.getName();\n+        Path targetImageDir = spec.getHelper().createNewImageDir(generatedImage);\n+        Path targetJlink = spec.getImageToUse().resolve(\"bin\").resolve(getJlink());\n+        String[] jlinkCmdArray = new String[] {\n+                targetJlink.toString(),\n+                \"--output\", targetImageDir.toString(),\n+                \"--verbose\",\n+                \"--add-modules\", spec.getModules().stream().collect(Collectors.joining(\",\"))\n+        };\n+        List<String> jlinkCmd = new ArrayList<>();\n+        jlinkCmd.addAll(Arrays.asList(jlinkCmdArray));\n+        if (spec.getExtraJlinkOpts() != null && !spec.getExtraJlinkOpts().isEmpty()) {\n+            jlinkCmd.addAll(spec.getExtraJlinkOpts());\n+        }\n+        if (spec.getModulePath() != null) {\n+            for (String mp: spec.getModulePath()) {\n+                jlinkCmd.add(\"--module-path\");\n+                jlinkCmd.add(mp);\n+            }\n+        }\n+        jlinkCmd = Collections.unmodifiableList(jlinkCmd); \/\/ freeze\n+        System.out.println(\"DEBUG: run-time image based jlink command: \" +\n+                           jlinkCmd.stream().collect(Collectors.joining(\" \")));\n+        OutputAnalyzer analyzer = null;\n+        try {\n+            analyzer = ProcessTools.executeProcess(jlinkCmd.toArray(new String[0]));\n+        } catch (Throwable t) {\n+            throw new AssertionError(\"Executing process failed!\", t);\n+        }\n+        if (!exitChecker.test(analyzer)) {\n+            if (DEBUG) {\n+                System.err.println(\"Process stdout was: \");\n+                System.err.println(analyzer.getStdout());\n+                System.err.println(\"Process stderr was: \");\n+                System.err.println(analyzer.getStderr());\n+            }\n+            \/\/ if the exit checker failed, we expected the other outcome\n+            \/\/ i.e. fail for success and success for fail.\n+            boolean successExit = analyzer.getExitValue() == 0;\n+            String msg = String.format(\"Expected jlink to %s given a jmodless image. Exit code was: %d\",\n+                                       (successExit ? \"fail\" : \"pass\"), analyzer.getExitValue());\n+            throw new AssertionError(msg);\n+        }\n+        handler.handleAnalyzer(analyzer); \/\/ Give tests a chance to process in\/output\n+\n+        \/\/ validate the resulting image; Includes running 'java -version', only do this\n+        \/\/ if the jlink succeeded.\n+        if (analyzer.getExitValue() == 0) {\n+            JImageValidator validator = new JImageValidator(spec.getValidatingModule(), spec.getExpectedLocations(),\n+                    targetImageDir.toFile(), spec.getUnexpectedLocations(), Collections.emptyList(), spec.getExpectedFiles());\n+            validator.validate(); \/\/ This doesn't validate locations\n+            if (!spec.getExpectedLocations().isEmpty() || !spec.getUnexpectedLocations().isEmpty()) {\n+                JImageValidator.validate(targetImageDir.resolve(\"lib\").resolve(\"modules\"), spec.getExpectedLocations(), spec.getUnexpectedLocations());\n+            }\n+        }\n+        return targetImageDir;\n+    }\n+\n+    \/**\n+     * Prepares the test for execution. This assumes the current runtime\n+     * supports linking from it. However, since the 'jmods' dir might be present\n+     * (default jmods module path), the 'jmods' directory needs to get removed\n+     * to provoke actual linking from the run-time image.\n+     *\n+     * @param baseSpec\n+     * @return A path to a JDK that is capable for linking from the run-time\n+     *         image.\n+     * @throws Exception\n+     *\/\n+    protected Path createRuntimeLinkImage(BaseJlinkSpec baseSpec) throws Exception {\n+        return createRuntimeLinkImage(baseSpec, Collections.emptySet() \/* exclude all jmods *\/);\n+    }\n+\n+    \/**\n+     * Prepares the test for execution. Creates a JDK with a jlink that has the\n+     * capability to link from the run-time image (if needed). It further\n+     * ensures that if packaged modules ('jmods' dir) are present, to remove\n+     * them entirely or as specified in the {@link excludedJmodFiles} set. If\n+     * that set is empty, all packaged modules will be removed. Note that with\n+     * packaged modules present no run-time image based linking would be done.\n+     *\n+     * @param baseSpec\n+     *            The specification for the custom - run-time image link capable\n+     *            - JDK to create via jlink (if any)\n+     * @param excludedJmods\n+     *            The set of jmod files to exclude in the base JDK. Empty set if\n+     *            all JMODs should be removed.\n+     * @return A path to a JDK, including jdk.jlink, that has the run-time image\n+     * link capability.\n+     *\n+     * @throws Exception\n+     *\/\n+    protected Path createRuntimeLinkImage(BaseJlinkSpec baseSpec,\n+                                          Set<String> excludedJmodFiles) throws Exception {\n+        \/\/ Depending on the shape of the JDK under test, we either only filter\n+        \/\/ jmod files or create a run-time image link capable JDK on-the-fly.\n+        Path from = null;\n+        Path runtimeJlinkImage = null;\n+        String finalName = baseSpec.getName() + \"-jlink\";\n+        if (baseSpec.isLinkableRuntime()) {\n+            \/\/ The build is already run-time image link capable\n+            String javaHome = System.getProperty(\"java.home\");\n+            from = Path.of(javaHome);\n+        } else {\n+            \/\/ Create a run-time image capable JDK using --generate-linkable-runtime\n+            Path tempRuntimeImage = Path.of(finalName + \"-tmp\");\n+            JLinkTask task = JImageGenerator.getJLinkTask();\n+            task.output(tempRuntimeImage)\n+                .addMods(\"jdk.jlink\") \/\/ that modules is always needed for the test\n+                .option(\"--generate-linkable-runtime\");\n+            if (baseJDKhasPackagedModules()) {\n+                Path jmodsPath = tempRuntimeImage.resolve(\"jmods\");\n+                task.option(\"--keep-packaged-modules=\" + jmodsPath);\n+            }\n+            for (String module: baseSpec.getModules()) {\n+                task.addMods(module);\n+            }\n+            task.call().assertSuccess();\n+            from = tempRuntimeImage;\n+        }\n+\n+        \/\/ Create the target directory\n+        runtimeJlinkImage = baseSpec.getHelper().createNewImageDir(finalName);\n+\n+        \/\/ Remove JMODs as needed for the test\n+        copyJDKTreeWithoutSpecificJmods(from, runtimeJlinkImage, excludedJmodFiles);\n+        \/\/ Verify the base image is actually without desired packaged modules\n+        if (excludedJmodFiles.isEmpty()) {\n+            if (Files.exists(runtimeJlinkImage.resolve(\"jmods\"))) {\n+                throw new AssertionError(\"Must not contain 'jmods' directory\");\n+            }\n+        } else {\n+            Path basePath = runtimeJlinkImage.resolve(\"jmods\");\n+            for (String jmodFile: excludedJmodFiles) {\n+                Path unexpectedFile = basePath.resolve(Path.of(jmodFile));\n+                if (Files.exists(unexpectedFile)) {\n+                    throw new AssertionError(\"Must not contain jmod: \" + unexpectedFile);\n+                }\n+            }\n+        }\n+        return runtimeJlinkImage;\n+    }\n+\n+    private boolean baseJDKhasPackagedModules() {\n+        Path jmodsPath = Path.of(System.getProperty(\"java.home\"), \"jmods\");\n+        return jmodsPath.toFile().exists();\n+    }\n+\n+    private void copyJDKTreeWithoutSpecificJmods(Path from,\n+                                                 Path to,\n+                                                 Set<String> excludedJmods) throws Exception {\n+        if (Files.exists(to)) {\n+            throw new AssertionError(\"Expected target dir '\" + to + \"' to exist\");\n+        }\n+        FileVisitor<Path> fileVisitor = null;\n+        if (excludedJmods.isEmpty()) {\n+            fileVisitor = new ExcludeAllJmodsFileVisitor(from, to);\n+        } else {\n+            fileVisitor = new FileExcludingFileVisitor(excludedJmods,\n+                                                       from,\n+                                                       to);\n+        }\n+        Files.walkFileTree(from, fileVisitor);\n+    }\n+\n+    private List<String> parseListMods(String output) throws Exception {\n+        List<String> outputLines = new ArrayList<>();\n+        try (Scanner lineScan = new Scanner(output)) {\n+            while (lineScan.hasNextLine()) {\n+                outputLines.add(lineScan.nextLine());\n+            }\n+        }\n+        return outputLines.stream()\n+                .map(a -> { return a.split(\"@\", 2)[0];})\n+                .filter(a -> !a.isBlank())\n+                .collect(Collectors.toList());\n+    }\n+\n+    private String getJlink() {\n+        return getBinary(\"jlink\");\n+    }\n+\n+    private String getJava() {\n+        return getBinary(\"java\");\n+    }\n+\n+    private String getBinary(String binary) {\n+        return isWindows() ? binary + \".exe\" : binary;\n+    }\n+\n+    protected static boolean isWindows() {\n+        return System.getProperty(\"os.name\").startsWith(\"Windows\");\n+    }\n+\n+    static class ExcludeAllJmodsFileVisitor extends SimpleFileVisitor<Path> {\n+        private final Path root;\n+        private final Path destination;\n+\n+        private ExcludeAllJmodsFileVisitor(Path root,\n+                                           Path destination) {\n+            this.destination = destination;\n+            this.root = root;\n+        }\n+\n+        @Override\n+        public FileVisitResult preVisitDirectory(Path dir,\n+                BasicFileAttributes attrs) throws IOException {\n+            Objects.requireNonNull(dir);\n+            Path relative = root.relativize(dir);\n+            if (relative.getFileName().equals(Path.of(\"jmods\"))) {\n+                return FileVisitResult.SKIP_SUBTREE;\n+            }\n+            \/\/ Create dir in destination location\n+            Path targetDir = destination.resolve(relative);\n+            if (!Files.exists(targetDir)) {\n+                Files.createDirectory(targetDir);\n+            }\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                throws IOException {\n+            Path relative = root.relativize(file);\n+            Files.copy(file, destination.resolve(relative), StandardCopyOption.REPLACE_EXISTING);\n+            return FileVisitResult.CONTINUE;\n+        }\n+    }\n+\n+    static class FileExcludingFileVisitor extends SimpleFileVisitor<Path> {\n+\n+        private final Set<String> filesToExclude;\n+        private final Path root;\n+        private final Path destination;\n+\n+        private FileExcludingFileVisitor(Set<String> filesToExclude,\n+                                         Path root,\n+                                         Path destination) {\n+            this.filesToExclude = filesToExclude;\n+            this.destination = destination;\n+            this.root = root;\n+        }\n+\n+        @Override\n+        public FileVisitResult preVisitDirectory(Path dir,\n+                BasicFileAttributes attrs) throws IOException {\n+            Objects.requireNonNull(dir);\n+            Path relative = root.relativize(dir);\n+            \/\/ Create dir in destination location\n+            Path targetDir = destination.resolve(relative);\n+            if (!Files.exists(targetDir)) {\n+                Files.createDirectory(targetDir);\n+            }\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                throws IOException {\n+            Path relative = root.relativize(file);\n+            \/\/ Skip files as determined by the exclude set\n+            String fileName = file.getFileName().toString();\n+            if (!filesToExclude.contains(fileName)) {\n+                Files.copy(file, destination.resolve(relative), StandardCopyOption.REPLACE_EXISTING);\n+            }\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+    }\n+\n+    static class BaseJlinkSpec {\n+        final Helper helper;\n+        final String name;\n+        final String validatingModule;\n+        final List<String> modules;\n+        final List<String> extraOptions;\n+        final boolean isLinkableRuntime;\n+\n+        BaseJlinkSpec(Helper helper, String name, String validatingModule,\n+                List<String> modules, List<String> extraOptions, boolean isLinkableRuntime) {\n+            this.helper = helper;\n+            this.name = name;\n+            this.modules = modules;\n+            this.extraOptions = extraOptions;\n+            this.validatingModule = validatingModule;\n+            this.isLinkableRuntime = isLinkableRuntime;\n+        }\n+\n+        public String getValidatingModule() {\n+            return validatingModule;\n+        }\n+\n+        public Helper getHelper() {\n+            return helper;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public List<String> getModules() {\n+            return modules;\n+        }\n+\n+        public List<String> getExtraOptions() {\n+            return extraOptions;\n+        }\n+\n+        public boolean isLinkableRuntime() {\n+            return isLinkableRuntime;\n+        }\n+    }\n+\n+    static class BaseJlinkSpecBuilder {\n+        Helper helper;\n+        String name;\n+        String validatingModule;\n+        List<String> modules = new ArrayList<>();\n+        List<String> extraOptions = new ArrayList<>();\n+        boolean isLinkableRuntime;\n+\n+        BaseJlinkSpecBuilder addModule(String module) {\n+            modules.add(module);\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder addExtraOption(String option) {\n+            extraOptions.add(option);\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder setLinkableRuntime() {\n+            isLinkableRuntime = true;\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder helper(Helper helper) {\n+            this.helper = helper;\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder name(String name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder validatingModule(String module) {\n+            this.validatingModule = module;\n+            return this;\n+        }\n+\n+        BaseJlinkSpec build() {\n+            if (name == null) {\n+                throw new IllegalStateException(\"Name must be set\");\n+            }\n+            if (helper == null) {\n+                throw new IllegalStateException(\"helper must be set\");\n+            }\n+            if (modules.isEmpty()) {\n+                throw new IllegalStateException(\"modules must be set\");\n+            }\n+            if (validatingModule == null) {\n+                throw new IllegalStateException(\"the module which should get validated must be set\");\n+            }\n+            return new BaseJlinkSpec(helper, name, validatingModule, modules, extraOptions, isLinkableRuntime);\n+        }\n+    }\n+\n+    static class JlinkSpec {\n+        final Path imageToUse;\n+        final Helper helper;\n+        final String name;\n+        final List<String> modules;\n+        final String validatingModule;\n+        final List<String> expectedLocations;\n+        final List<String> unexpectedLocations;\n+        final String[] expectedFiles;\n+        final List<String> extraJlinkOpts;\n+        final List<String> modulePath;\n+\n+        JlinkSpec(Path imageToUse, Helper helper, String name, List<String> modules,\n+                String validatingModule, List<String> expectedLocations,\n+                List<String> unexpectedLocations, String[] expectedFiles,\n+                List<String> extraJlinkOpts,\n+                List<String> modulePath) {\n+            this.imageToUse = imageToUse;\n+            this.helper = helper;\n+            this.name = name;\n+            this.modules = modules;\n+            this.validatingModule = validatingModule;\n+            this.expectedLocations = expectedLocations;\n+            this.unexpectedLocations = unexpectedLocations;\n+            this.expectedFiles = expectedFiles;\n+            this.extraJlinkOpts = extraJlinkOpts;\n+            this.modulePath = modulePath;\n+        }\n+\n+        public Path getImageToUse() {\n+            return imageToUse;\n+        }\n+\n+        public Helper getHelper() {\n+            return helper;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public List<String> getModules() {\n+            return modules;\n+        }\n+\n+        public String getValidatingModule() {\n+            return validatingModule;\n+        }\n+\n+        public List<String> getExpectedLocations() {\n+            return expectedLocations;\n+        }\n+\n+        public List<String> getUnexpectedLocations() {\n+            return unexpectedLocations;\n+        }\n+\n+        public String[] getExpectedFiles() {\n+            return expectedFiles;\n+        }\n+\n+        public List<String> getExtraJlinkOpts() {\n+            return extraJlinkOpts;\n+        }\n+\n+        public List<String> getModulePath() {\n+            return modulePath;\n+        }\n+    }\n+\n+    static class JlinkSpecBuilder {\n+        Path imageToUse;\n+        Helper helper;\n+        String name;\n+        List<String> modules = new ArrayList<>();\n+        String validatingModule;\n+        List<String> expectedLocations = new ArrayList<>();\n+        List<String> unexpectedLocations = new ArrayList<>();\n+        List<String> expectedFiles = new ArrayList<>();\n+        List<String> extraJlinkOpts = new ArrayList<>();\n+        List<String> modulePath = new ArrayList<>();\n+\n+        JlinkSpec build() {\n+            if (imageToUse == null) {\n+                throw new IllegalStateException(\"No image to use for jlink specified!\");\n+            }\n+            if (helper == null) {\n+                throw new IllegalStateException(\"No helper specified!\");\n+            }\n+            if (name == null) {\n+                throw new IllegalStateException(\"No name for the image location specified!\");\n+            }\n+            if (validatingModule == null) {\n+                throw new IllegalStateException(\"No module specified for after generation validation!\");\n+            }\n+            return new JlinkSpec(imageToUse,\n+                                 helper,\n+                                 name,\n+                                 modules,\n+                                 validatingModule,\n+                                 expectedLocations,\n+                                 unexpectedLocations,\n+                                 expectedFiles.toArray(new String[0]),\n+                                 extraJlinkOpts,\n+                                 modulePath);\n+        }\n+\n+        JlinkSpecBuilder imagePath(Path image) {\n+            this.imageToUse = image;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder helper(Helper helper) {\n+            this.helper = helper;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder name(String name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder addModule(String module) {\n+            modules.add(module);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder validatingModule(String module) {\n+            this.validatingModule = module;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder addModulePath(String modulePath) {\n+            this.modulePath.add(modulePath);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder expectedLocation(String location) {\n+            expectedLocations.add(location);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder unexpectedLocation(String location) {\n+            unexpectedLocations.add(location);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder expectedFile(String file) {\n+            expectedFiles.add(file);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder extraJlinkOpt(String opt) {\n+            extraJlinkOpts.add(opt);\n+            return this;\n+        }\n+    }\n+\n+    static abstract class OutputAnalyzerHandler {\n+\n+        public abstract void handleAnalyzer(OutputAnalyzer out);\n+\n+    }\n+\n+    static class RuntimeLinkOutputAnalyzerHandler extends OutputAnalyzerHandler {\n+\n+        @Override\n+        public void handleAnalyzer(OutputAnalyzer out) {\n+            out.shouldContain(\"Linking based on the current run-time image\");\n+        }\n+\n+    }\n+\n+    static class DefaultSuccessExitPredicate implements Predicate<OutputAnalyzer> {\n+\n+        @Override\n+        public boolean test(OutputAnalyzer t) {\n+            return t.getExitValue() == 0;\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/AbstractLinkableRuntimeTest.java","additions":703,"deletions":0,"binary":false,"changes":703,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Scanner;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Test --add-options jlink plugin when linking from the run-time image\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g AddOptionsTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Test --add-options jlink plugin when linking from the run-time image\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g AddOptionsTest false\n+ *\/\n+public class AddOptionsTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        AddOptionsTest test = new AddOptionsTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+                .addExtraOption(\"--add-options\")\n+                .addExtraOption(\"-Xlog:gc=info:stderr -XX:+UseParallelGC\")\n+                .name(\"java-base-with-opts\")\n+                .addModule(\"java.base\")\n+                .validatingModule(\"java.base\")\n+                .helper(helper);\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        Path finalImage = createJavaImageRuntimeLink(builder.build());\n+        verifyListModules(finalImage, List.of(\"java.base\"));\n+        verifyParallelGCInUse(finalImage);\n+    }\n+\n+    private void verifyParallelGCInUse(Path finalImage) throws Exception {\n+        OutputAnalyzer analyzer = runJavaCmd(finalImage, List.of(\"--version\"));\n+        boolean foundMatch = false;\n+        try (Scanner lineScan = new Scanner(analyzer.getStderr())) {\n+            while (lineScan.hasNextLine()) {\n+                String line = lineScan.nextLine();\n+                if (line.endsWith(\"Using Parallel\")) {\n+                    foundMatch = true;\n+                    break;\n+                }\n+            }\n+        }\n+        if (!foundMatch) {\n+            throw new AssertionError(\"Expected Parallel GC in place for jlinked image\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/AddOptionsTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Set;\n+\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Test basic linking from the run-time image with java.base.jmod missing\n+ *          but java.xml.jmod present. It should link from the run-time image without errors.\n+ * @requires (jlink.packagedModules & jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g BasicJlinkMissingJavaBase true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Test basic linking from the run-time image with java.base.jmod missing\n+ *          but java.xml.jmod present. It should link from the run-time image without errors.\n+ * @requires (jlink.packagedModules & !jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g BasicJlinkMissingJavaBase false\n+ *\/\n+public class BasicJlinkMissingJavaBase extends AbstractLinkableRuntimeTest {\n+\n+    @Override\n+    public void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        Path finalImage = createJavaXMLRuntimeLink(helper, \"java-xml\", isLinkableRuntime);\n+        verifyListModules(finalImage, List.of(\"java.base\", \"java.xml\"));\n+    }\n+\n+    private Path createJavaXMLRuntimeLink(Helper helper, String name, boolean isLinkableRuntime) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder();\n+        builder.helper(helper)\n+               .name(name)\n+               .addModule(\"java.xml\")\n+               .validatingModule(\"java.xml\");\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        Set<String> excludedJmods = Set.of(\"java.base.jmod\");\n+        return createJavaImageRuntimeLink(builder.build(), excludedJmods);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        BasicJlinkMissingJavaBase test = new BasicJlinkMissingJavaBase();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/BasicJlinkMissingJavaBase.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Test basic linking from the run-time image\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g BasicJlinkTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Test basic linking from the run-time image\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g BasicJlinkTest false\n+ *\/\n+public class BasicJlinkTest extends AbstractLinkableRuntimeTest {\n+\n+    @Override\n+    public void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        Path finalImage = createJavaBaseRuntimeLink(helper, \"java-base\", isLinkableRuntime);\n+        verifyListModules(finalImage, List.of(\"java.base\"));\n+    }\n+\n+    private Path createJavaBaseRuntimeLink(Helper helper, String name, boolean isLinkableRuntime) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder();\n+        builder.helper(helper)\n+               .name(name)\n+               .addModule(\"java.base\")\n+               .validatingModule(\"java.base\");\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        return createJavaImageRuntimeLink(builder.build());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        BasicJlinkTest test = new BasicJlinkTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/BasicJlinkTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/CapturingHandler.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/tools\/jlink\/JmodLess\/CapturingHandler.java","status":"renamed"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Test jmod-less jlink with a custom module\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g CustomModuleJlinkTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Test jmod-less jlink with a custom module\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g CustomModuleJlinkTest false\n+ *\/\n+public class CustomModuleJlinkTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        CustomModuleJlinkTest test = new CustomModuleJlinkTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        String customModule = \"leaf1\";\n+        helper.generateDefaultJModule(customModule);\n+\n+        \/\/ create a base image for linking from the run-time image\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+            .helper(helper)\n+            .name(\"cmod-jlink\")\n+            .addModule(\"java.base\")\n+            .validatingModule(\"java.base\");\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        Path jlinkImage = createRuntimeLinkImage(builder.build());\n+\n+        \/\/ Next jlink using the run-time image for java.base, but take\n+        \/\/ the custom module from the module path.\n+        Path finalImage = jlinkUsingImage(new JlinkSpecBuilder()\n+                                                .imagePath(jlinkImage)\n+                                                .helper(helper)\n+                                                .name(customModule)\n+                                                .addModulePath(helper.defaultModulePath(false))\n+                                                .expectedLocation(String.format(\"\/%s\/%s\/com\/foo\/bar\/X.class\", customModule, customModule))\n+                                                .addModule(customModule)\n+                                                .validatingModule(customModule)\n+                                                .build());\n+        \/\/ Expected only the transitive closure of \"leaf1\" module in the --list-modules\n+        \/\/ output of the java launcher.\n+        List<String> expectedModules = List.of(\"java.base\", customModule);\n+        verifyListModules(finalImage, expectedModules);\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/CustomModuleJlinkTest.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import tests.Helper;\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Verify JLI class generation in run-time image link mode\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g GenerateJLIClassesTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Verify JLI class generation in run-time image link mode\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g GenerateJLIClassesTest false\n+ *\/\n+public class GenerateJLIClassesTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        GenerateJLIClassesTest test = new GenerateJLIClassesTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    \/*\n+     * java.lang.invoke.BoundMethodHandle$Species_* classes get generated\n+     * by the GenerateJLiClassesPlugin. This test ensures that potentially\n+     * generated JLI classes from the run-time image don't populate to the\n+     * target image in the run-time image based link mode.\n+     *\/\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        Path baseFile = Files.createTempFile(\"base\", \"trace\");\n+        String species = \"LLLLLLLLLLLLLLLLLLL\";\n+        String fileString = \"[SPECIES_RESOLVE] java.lang.invoke.BoundMethodHandle$Species_\" + species + \" (salvaged)\\n\";\n+        Files.write(baseFile, fileString.getBytes(StandardCharsets.UTF_8));\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+                .helper(helper)\n+                .addModule(\"java.base\")\n+                .name(\"jlink.jli-jmodless\")\n+                .validatingModule(\"java.base\");\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+\n+        Path runtimeLinkableImage = createRuntimeLinkImage(builder.build());\n+        \/\/ Finally attempt another jmodless link reducing modules to java.base only,\n+        \/\/ and asking for specific jli classes.\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(runtimeLinkableImage)\n+                                .name(\"java.base-jli-derived\")\n+                                .addModule(\"java.base\")\n+                                .extraJlinkOpt(\"--generate-jli-classes=@\" + baseFile.toString())\n+                                .expectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_\" + species + \".class\")\n+                                .expectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_L.class\")\n+                                .unexpectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_\" + species.substring(1) + \".class\")\n+                                .unexpectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LL.class\")\n+                                .validatingModule(\"java.base\")\n+                                .build());\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/GenerateJLIClassesTest.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/JImageHelper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/tools\/jlink\/JmodLess\/JImageHelper.java","status":"renamed"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import tests.Helper;\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Test reproducibility of linking an java.se image using the run-time\n+ *          image.\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g JavaSEReproducibleTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Test reproducibility of linking an java.se image using the run-time\n+ *          image.\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g JavaSEReproducibleTest false\n+ *\/\n+public class JavaSEReproducibleTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        JavaSEReproducibleTest test = new JavaSEReproducibleTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        String javaSeModule = \"java.se\";\n+        \/\/ create a java.se using jmod-less approach\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+                .helper(helper)\n+                .addModule(javaSeModule)\n+                .validatingModule(javaSeModule);\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        builder.name(\"java-se-repro1\");\n+        Path javaSEJmodLess1 = createJavaImageRuntimeLink(builder.build());\n+\n+        \/\/ create another java.se version using jmod-less approach\n+        builder.name(\"java-se-repro2\");\n+        Path javaSEJmodLess2 = createJavaImageRuntimeLink(builder.build());\n+        if (Files.mismatch(javaSEJmodLess1.resolve(\"lib\").resolve(\"modules\"),\n+                           javaSEJmodLess2.resolve(\"lib\").resolve(\"modules\")) != -1L) {\n+            throw new RuntimeException(\"jlink producing inconsistent result for \" + javaSeModule + \" (jmod-less)\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/JavaSEReproducibleTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Verify that jlink with an empty module path, but trying to use\n+ *          --keep-packaged-modules fails as expected.\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g KeepPackagedModulesFailTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Verify that jlink with an empty module path, but trying to use\n+ *          --keep-packaged-modules fails as expected.\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g KeepPackagedModulesFailTest false\n+ *\/\n+public class KeepPackagedModulesFailTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        KeepPackagedModulesFailTest test = new KeepPackagedModulesFailTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        \/\/ create a base image for linking from the run-time image\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+                .helper(helper)\n+                .name(\"jlink-fail\")\n+                .addModule(\"java.base\")\n+                .validatingModule(\"java.base\");\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        Path baseImage = createRuntimeLinkImage(builder.build());\n+\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer t) {\n+                return t.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        \/\/ Attempt a jlink using the run-time image and also using option\n+        \/\/ --keep-packaged-modules, which should fail.\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(baseImage)\n+                                .name(\"java-base-jlink-keep-packaged-target\")\n+                                .addModule(\"java.base\")\n+                                .extraJlinkOpt(\"--keep-packaged-modules=foo\")\n+                                .validatingModule(\"java.base\")\n+                                .build(), handler, exitFailPred);\n+        OutputAnalyzer analyzer = handler.analyzer();\n+        if (analyzer.getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to have failed!\");\n+        }\n+        analyzer.stdoutShouldContain(\"Error\");\n+        analyzer.stdoutShouldContain(\"--keep-packaged-modules\");\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/KeepPackagedModulesFailTest.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Verify jlink fails by default when linking from the run-time image\n+ *          and files have been modified\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g ModifiedFilesExitTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Verify jlink fails by default when linking from the run-time image\n+ *          and files have been modified\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g ModifiedFilesExitTest false\n+ *\/\n+public class ModifiedFilesExitTest extends ModifiedFilesTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        ModifiedFilesExitTest test = new ModifiedFilesExitTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    @Override\n+    String initialImageName() {\n+        return \"java-base-jlink-with-mod-exit\";\n+    }\n+\n+    @Override\n+    void testAndAssert(Path modifiedFile, Helper helper, Path initialImage)\n+            throws Exception {\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer t) {\n+                return t.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(initialImage)\n+                                .name(\"java-base-jlink-with-mod-exit-target\")\n+                                .addModule(\"java.base\")\n+                                .validatingModule(\"java.base\")\n+                                .build(), handler, exitFailPred);\n+        OutputAnalyzer analyzer = handler.analyzer();\n+        if (analyzer.getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to fail due to modified file!\");\n+        }\n+        analyzer.stdoutShouldContain(modifiedFile.toString() + \" has been modified\");\n+        \/\/ Verify the error message is reasonable\n+        analyzer.stdoutShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n+        analyzer.stdoutShouldNotContain(\"java.lang.IllegalArgumentException\");\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/ModifiedFilesExitTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Properties;\n+\n+import tests.Helper;\n+\n+public abstract class ModifiedFilesTest extends AbstractLinkableRuntimeTest {\n+\n+    abstract String initialImageName();\n+    abstract void testAndAssert(Path modifiedFile, Helper helper, Path initialImage) throws Exception;\n+\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+                .name(initialImageName())\n+                .addModule(\"java.base\")\n+                .validatingModule(\"java.base\")\n+                .helper(helper);\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        Path initialImage = createRuntimeLinkImage(builder.build());\n+\n+        Path netPropertiesFile = modifyFileInImage(initialImage);\n+\n+        testAndAssert(netPropertiesFile, helper, initialImage);\n+    }\n+\n+    protected Path modifyFileInImage(Path jmodLessImg)\n+            throws IOException, AssertionError {\n+        \/\/ modify net.properties config file\n+        Path netPropertiesFile = jmodLessImg.resolve(\"conf\").resolve(\"net.properties\");\n+        Properties props = new Properties();\n+        try (InputStream is = Files.newInputStream(netPropertiesFile)) {\n+            props.load(is);\n+        }\n+        String prevVal = (String)props.put(\"java.net.useSystemProxies\", Boolean.TRUE.toString());\n+        if (prevVal == null || Boolean.getBoolean(prevVal) != false) {\n+            throw new AssertionError(\"Expected previous value to be false!\");\n+        }\n+        try (OutputStream out = Files.newOutputStream(netPropertiesFile)) {\n+            props.store(out, \"Modified net.properties file!\");\n+        }\n+        return netPropertiesFile;\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/ModifiedFilesTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Verify warnings are being produced when linking from the run-time\n+ *          image and files have been modified\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g ModifiedFilesWarningTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Verify warnings are being produced when linking from the run-time\n+ *          image and files have been modified\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g ModifiedFilesWarningTest false\n+ *\/\n+public class ModifiedFilesWarningTest extends ModifiedFilesTest {\n+\n+    protected static final String IGNORE_MODIFIED_RUNTIME_OPT = \"--ignore-modified-runtime\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        ModifiedFilesWarningTest test = new ModifiedFilesWarningTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    @Override\n+    String initialImageName() {\n+        return \"java-base-jlink-with-mod-warn\";\n+    }\n+\n+    @Override\n+    void testAndAssert(Path modifiedFile, Helper helper, Path initialImage) throws Exception {\n+        CapturingHandler handler = new CapturingHandler();\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(initialImage)\n+                                .name(\"java-base-jlink-with-mod-warn-target\")\n+                                .addModule(\"java.base\")\n+                                .validatingModule(\"java.base\")\n+                                .extraJlinkOpt(IGNORE_MODIFIED_RUNTIME_OPT) \/\/ only generate a warning\n+                                .build(), handler);\n+        OutputAnalyzer out = handler.analyzer();\n+        \/\/ verify we get the warning message\n+        out.stdoutShouldMatch(\"Warning: .* has been modified\");\n+        out.stdoutShouldNotContain(\"java.lang.IllegalArgumentException\");\n+        out.stdoutShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/ModifiedFilesWarningTest.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Verify that a jlink using the run-time image cannot include jdk.jlink\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g MultiHopTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Verify that a jlink using the run-time image cannot include jdk.jlink\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g MultiHopTest false\n+ *\/\n+public class MultiHopTest extends AbstractLinkableRuntimeTest {\n+\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        Path jdkJlinkJmodless = createJDKJlinkJmodLess(helper, \"jdk.jlink-multi-hop1\", isLinkableRuntime);\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer a) {\n+                return a.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(jdkJlinkJmodless)\n+                                .name(\"jdk-jlink-multi-hop1-target\")\n+                                .addModule(\"jdk.jlink\")\n+                                .validatingModule(\"java.base\")\n+                                .build(), handler, exitFailPred);\n+        OutputAnalyzer analyzer = handler.analyzer();\n+        if (analyzer.getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to fail due to including jdk.jlink\");\n+        }\n+        String expectedMsg = \"This JDK does not contain packaged modules \" +\n+                             \"and cannot be used to create another image with \" +\n+                             \"the jdk.jlink module\";\n+        analyzer.stdoutShouldContain(expectedMsg);\n+        analyzer.stdoutShouldNotContain(\"Exception\"); \/\/ ensure error message is sane\n+    }\n+\n+    private Path createJDKJlinkJmodLess(Helper helper, String name, boolean isLinkableRuntime) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder();\n+        builder.helper(helper)\n+               .name(name)\n+               .addModule(\"jdk.jlink\")\n+               .validatingModule(\"java.base\");\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        return createRuntimeLinkImage(builder.build());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        MultiHopTest test = new MultiHopTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/MultiHopTest.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import tests.Helper;\n+import tests.JImageGenerator;\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Compare packaged-modules jlink with a run-time image based jlink to\n+ *          produce the same result\n+ * @requires (jlink.packagedModules & jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g PackagedModulesVsRuntimeImageLinkTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Compare packaged-modules jlink with a run-time image based jlink to\n+ *          produce the same result\n+ * @requires (jlink.packagedModules & !jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g PackagedModulesVsRuntimeImageLinkTest false\n+ *\/\n+public class PackagedModulesVsRuntimeImageLinkTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        PackagedModulesVsRuntimeImageLinkTest test = new PackagedModulesVsRuntimeImageLinkTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        \/\/ create a java.se using jmod-less approach\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+                .helper(helper)\n+                .name(\"java-se-jmodless\")\n+                .addModule(\"java.se\")\n+                .validatingModule(\"java.se\");\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        Path javaSEruntimeLink = createJavaImageRuntimeLink(builder.build());\n+\n+        \/\/ create a java.se using packaged modules (jmod-full)\n+        Path javaSEJmodFull = JImageGenerator.getJLinkTask()\n+                .output(helper.createNewImageDir(\"java-se-jmodfull\"))\n+                .addMods(\"java.se\").call().assertSuccess();\n+\n+        compareRecursively(javaSEruntimeLink, javaSEJmodFull);\n+    }\n+\n+    \/\/ Visit all files in the given directories checking that they're byte-by-byte identical\n+    private static void compareRecursively(Path javaSEJmodLess,\n+            Path javaSEJmodFull) throws IOException, AssertionError {\n+        FilesCapturingVisitor jmodFullVisitor = new FilesCapturingVisitor(javaSEJmodFull);\n+        FilesCapturingVisitor jmodLessVisitor = new FilesCapturingVisitor(javaSEJmodLess);\n+        Files.walkFileTree(javaSEJmodFull, jmodFullVisitor);\n+        Files.walkFileTree(javaSEJmodLess, jmodLessVisitor);\n+        List<String> jmodFullFiles = jmodFullVisitor.filesVisited();\n+        List<String> jmodLessFiles = jmodLessVisitor.filesVisited();\n+        Collections.sort(jmodFullFiles);\n+        Collections.sort(jmodLessFiles);\n+\n+        if (jmodFullFiles.size() != jmodLessFiles.size()) {\n+            throw new AssertionError(String.format(\"Size of files different for jmod-less (%d) vs jmod-full (%d) java.se jlink\", jmodLessFiles.size(), jmodFullFiles.size()));\n+        }\n+        String jimageFile = Path.of(\"lib\").resolve(\"modules\").toString();\n+        \/\/ Compare all files except the modules image\n+        for (int i = 0; i < jmodFullFiles.size(); i++) {\n+            String jmodFullPath = jmodFullFiles.get(i);\n+            String jmodLessPath = jmodLessFiles.get(i);\n+            if (!jmodFullPath.equals(jmodLessPath)) {\n+                throw new AssertionError(String.format(\"jmod-full path (%s) != jmod-less path (%s)\", jmodFullPath, jmodLessPath));\n+            }\n+            if (jmodFullPath.equals(jimageFile)) {\n+                continue;\n+            }\n+            Path a = javaSEJmodFull.resolve(Path.of(jmodFullPath));\n+            Path b = javaSEJmodLess.resolve(Path.of(jmodLessPath));\n+            if (Files.mismatch(a, b) != -1L) {\n+                handleFileMismatch(a, b);\n+            }\n+        }\n+        \/\/ Compare jimage contents by iterating its entries and comparing their\n+        \/\/ paths and content bytes\n+        \/\/\n+        \/\/ Note: The files aren't byte-by-byte comparable (probably due to string hashing\n+        \/\/ and offset differences in container bytes)\n+        Path jimageJmodLess = javaSEJmodLess.resolve(Path.of(\"lib\")).resolve(Path.of(\"modules\"));\n+        Path jimageJmodFull = javaSEJmodFull.resolve(Path.of(\"lib\")).resolve(Path.of(\"modules\"));\n+        List<String> jimageContentJmodLess = JImageHelper.listContents(jimageJmodLess);\n+        List<String> jimageContentJmodFull = JImageHelper.listContents(jimageJmodFull);\n+        if (jimageContentJmodLess.size() != jimageContentJmodFull.size()) {\n+            throw new AssertionError(String.format(\"Size of jimage content differs for jmod-less (%d) v. jmod-full (%d)\", jimageContentJmodLess.size(), jimageContentJmodFull.size()));\n+        }\n+        for (int i = 0; i < jimageContentJmodFull.size(); i++) {\n+            if (!jimageContentJmodFull.get(i).equals(jimageContentJmodLess.get(i))) {\n+                throw new AssertionError(String.format(\"Jimage content differs at index %d: jmod-full was: '%s' jmod-less was: '%s'\",\n+                                                       i,\n+                                                       jimageContentJmodFull.get(i),\n+                                                       jimageContentJmodLess.get(i)\n+                                                       ));\n+            }\n+            String loc = jimageContentJmodFull.get(i);\n+            if (isTreeInfoResource(loc)) {\n+                \/\/ Skip container bytes as those are offsets to the content\n+                \/\/ of the container which might be different between jlink runs.\n+                continue;\n+            }\n+            byte[] resBytesFull = JImageHelper.getLocationBytes(loc, jimageJmodFull);\n+            byte[] resBytesLess = JImageHelper.getLocationBytes(loc, jimageJmodLess);\n+            if (resBytesFull.length != resBytesLess.length || Arrays.mismatch(resBytesFull, resBytesLess) != -1) {\n+                throw new AssertionError(\"Content bytes mismatch for \" + loc);\n+            }\n+        }\n+    }\n+\n+    private static boolean isTreeInfoResource(String path) {\n+        return path.startsWith(\"\/packages\") || path.startsWith(\"\/modules\");\n+    }\n+\n+    private static void handleFileMismatch(Path a, Path b) {\n+        throw new AssertionError(\"Files mismatch: \" + a + \" vs. \" + b);\n+    }\n+\n+    static class FilesCapturingVisitor extends SimpleFileVisitor<Path> {\n+        private final Path basePath;\n+        private final List<String> filePaths = new ArrayList<>();\n+        public FilesCapturingVisitor(Path basePath) {\n+            this.basePath = basePath;\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) {\n+            Path relative = basePath.relativize(path);\n+            filePaths.add(relative.toString());\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        List<String> filesVisited() {\n+            return filePaths;\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/PackagedModulesVsRuntimeImageLinkTest.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+import java.util.spi.ToolProvider;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Test run-time link with --patch-module. Expect failure.\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g PatchedJDKModuleJlinkTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Test run-time link with --patch-module. Expect failure.\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g PatchedJDKModuleJlinkTest false\n+ *\/\n+public class PatchedJDKModuleJlinkTest extends AbstractLinkableRuntimeTest {\n+\n+    @Override\n+    public void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        String imageName = \"java-base-patched\";\n+        Path runtimeLinkImage = createRuntimeLinkImage(helper, imageName + \"-base\", isLinkableRuntime);\n+\n+        \/\/ Prepare patched module content\n+        Path patchSource = Path.of(\"java-base-patch-src\");\n+        Path pkg = patchSource.resolve(\"java\", \"lang\");\n+        Path extraClass = pkg.resolve(\"MyJlinkPatchInteger.java\");\n+        String source = \"\"\"\n+                package java.lang;\n+                public class MyJlinkPatchInteger {\n+                    public int add(int a, int b) {\n+                        return a + b;\n+                    }\n+                }\n+                \"\"\";\n+        Files.createDirectories(pkg);\n+        Files.writeString(extraClass, source);\n+        Path patchClasses = Path.of(\"java-base-patch-classes\");\n+        Files.createDirectories(patchClasses);\n+        ToolProvider javac = ToolProvider.findFirst(\"javac\")\n+                                         .orElseThrow(() -> new AssertionError(\"javac not found\"));\n+        javac.run(System.out, System.err, new String[] {\n+                \"-d\", patchClasses.toString(),\n+                \"--patch-module=java.base=\" + patchSource.toAbsolutePath().toString(),\n+                extraClass.toAbsolutePath().toString()\n+        });\n+\n+        \/\/ Perform a run-time image link expecting a failure\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer t) {\n+                return t.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(runtimeLinkImage)\n+                                .name(imageName + \"-derived\")\n+                                .addModule(\"java.base\")\n+                                .validatingModule(\"java.base\")\n+                                .extraJlinkOpt(\"-J--patch-module=java.base=\" +\n+                                               patchClasses.toAbsolutePath().toString())\n+                                .build(), handler, exitFailPred);\n+        OutputAnalyzer analyzer = handler.analyzer();\n+        if (analyzer.getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to fail due to patched module!\");\n+        }\n+        analyzer.stdoutShouldContain(\"MyJlinkPatchInteger.class not found in the modules image.\");\n+        analyzer.stdoutShouldContain(\"--patch-module is not supported\");\n+        \/\/ Verify the error message is reasonable\n+        analyzer.stdoutShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n+        analyzer.stdoutShouldNotContain(\"java.lang.IllegalArgumentException\");\n+    }\n+\n+    private Path createRuntimeLinkImage(Helper helper, String name, boolean isLinkableRuntime) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+                .name(name)\n+                .addModule(\"java.base\")\n+                .validatingModule(\"java.base\")\n+                .helper(helper);\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        return createRuntimeLinkImage(builder.build());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        PatchedJDKModuleJlinkTest test = new PatchedJDKModuleJlinkTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/PatchedJDKModuleJlinkTest.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import tests.Helper;\n+import tests.JImageValidator;\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Test appropriate handling of generated SystemModules* classes in run-time image link mode\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g SystemModulesTest true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Test appropriate handling of generated SystemModules* classes in run-time image link mode\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g SystemModulesTest false\n+ *\/\n+public class SystemModulesTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        SystemModulesTest test = new SystemModulesTest();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    \/*\n+     * SystemModule classes are module specific. If the jlink is based on the\n+     * modules image, then earlier generated SystemModule classes shall not get\n+     * propagated.\n+     *\/\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        \/\/ create an image with a module containing a main entrypoint (jdk.httpserver),\n+        \/\/ thus producing the SystemModules$0.class. Add jdk.jdwp.agent as a module which\n+        \/\/ isn't resolved by default, so as to generate SystemModules$default.class\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+                .helper(helper)\n+                .name(\"httpserver-jlink-jmodless-derived\")\n+                .addModule(\"jdk.httpserver\")\n+                .addModule(\"jdk.jdwp.agent\")\n+                .validatingModule(\"java.base\");\n+        if (isLinkableRuntime) {\n+            builder.setLinkableRuntime();\n+        }\n+        Path javaseJmodless = createJavaImageRuntimeLink(builder.build());\n+        \/\/ Verify that SystemModules$0.class etc. are there, due to httpserver and jdwp.agent\n+        JImageValidator.validate(javaseJmodless.resolve(\"lib\").resolve(\"modules\"),\n+                                    List.of(\"\/java.base\/jdk\/internal\/module\/SystemModules$default.class\",\n+                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$0.class\",\n+                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$all.class\"),\n+                                    Collections.emptyList());\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/SystemModulesTest.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import tests.Helper;\n+import tests.JImageValidator;\n+\n+\/*\n+ * @test id=linkable_runtime\n+ * @summary Test disabled SystemModulesPlugin in run-time image link mode. Expect\n+ *          generated classes to not be there.\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g SystemModulesTest2 true\n+ *\/\n+\n+\/*\n+ * @test id=default_build\n+ * @summary Test disabled SystemModulesPlugin in run-time image link mode. Expect\n+ *          generated classes to not be there.\n+ * @requires (!jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g SystemModulesTest2 false\n+ *\/\n+public class SystemModulesTest2 extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Wrong number of passed arguments\");\n+        }\n+        boolean isLinkableRuntime = Boolean.parseBoolean(args[0]);\n+        SystemModulesTest2 test = new SystemModulesTest2();\n+        test.run(isLinkableRuntime);\n+    }\n+\n+    @Override\n+    void runTest(Helper helper, boolean isLinkableRuntime) throws Exception {\n+        \/\/ See SystemModulesTest which enables the system-modules plugin. With\n+        \/\/ it disabled, we expect for the generated classes to not be there.\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder()\n+                .helper(helper)\n+                .name(\"jlink-jmodless-sysmod2\")\n+                .addModule(\"jdk.httpserver\")\n+                .validatingModule(\"java.base\")\n+                .addExtraOption(\"--disable-plugin\")\n+                .addExtraOption(\"system-modules\");\n+        Path runtimeImageLinkTarget = createJavaImageRuntimeLink(builder.build());\n+        JImageValidator.validate(runtimeImageLinkTarget.resolve(\"lib\").resolve(\"modules\"),\n+                                    Collections.emptyList(),\n+                                    List.of(\"\/java.base\/jdk\/internal\/module\/SystemModules$all.class\",\n+                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$default.class\",\n+                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$0.class\"));\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/SystemModulesTest2.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}