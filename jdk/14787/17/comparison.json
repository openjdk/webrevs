{"files":[{"patch":"@@ -62,1 +62,4 @@\n-        --add-exports jdk.internal.opt\/jdk.internal.opt=jdk.javadoc.interim, \\\n+        --add-exports jdk.internal.opt\/jdk.internal.opt=jdk.javadoc.interim \\\n+        --add-exports java.base\/jdk.internal.module=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.jimage=ALL-UNNAMED \\\n+        , \\\n","filename":"make\/CompileToolsJdk.gmk","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+include ToolsJdk.gmk\n@@ -88,0 +89,6 @@\n+ifeq ($(JLINK_PRODUCE_RUNTIME_LINK_JDK), true)\n+  JDK_LINK_OUTPUT_DIR := $(RL_INTERMEDIATE_IMAGE_DIR)\n+else\n+  JDK_LINK_OUTPUT_DIR := $(JDK_IMAGE_DIR)\n+endif\n+\n@@ -89,1 +96,6 @@\n-  JLINK_JDK_EXTRA_OPTS := --keep-packaged-modules $(JDK_IMAGE_DIR)\/jmods\n+  ifeq ($(JLINK_PRODUCE_RUNTIME_LINK_JDK), true)\n+    JLINK_JDK_EXTRA_OPTS := --keep-packaged-modules $(RL_INTERMEDIATE_IMAGE_DIR)\/jmods\n+    JLINK_RUNTIME_CREATE_EXTRA := --keep-packaged-modules $(JDK_IMAGE_DIR)\/jmods\n+  else\n+    JLINK_JDK_EXTRA_OPTS := --keep-packaged-modules $(JDK_IMAGE_DIR)\/jmods\n+  endif\n@@ -92,0 +104,1 @@\n+\n@@ -101,1 +114,1 @@\n-    OUTPUT_DIR := $(JDK_IMAGE_DIR), \\\n+    OUTPUT_DIR := $(JDK_LINK_OUTPUT_DIR), \\\n@@ -103,1 +116,1 @@\n-    PRE_COMMAND := $(RM) -r $(JDK_IMAGE_DIR), \\\n+    PRE_COMMAND := $(RM) -r $(JDK_LINK_OUTPUT_DIR), \\\n@@ -105,1 +118,1 @@\n-        $(JLINK_JDK_EXTRA_OPTS) --output $(JDK_IMAGE_DIR) \\\n+        $(JLINK_JDK_EXTRA_OPTS) --output $(JDK_LINK_OUTPUT_DIR) \\\n@@ -111,0 +124,32 @@\n+ifeq ($(JLINK_PRODUCE_RUNTIME_LINK_JDK), true)\n+\n+  JDK_RUN_TIME_IMAGE_SUPPORT_DIR := $(SUPPORT_OUTPUTDIR)\/images\/jlink-run-time\n+  JDK_JMODS_DIFF := $(JDK_RUN_TIME_IMAGE_SUPPORT_DIR)\/jimage_packaged_modules_diff.data\n+  JLINK_RUNTIME_CREATE_EXTRA += --create-linkable-runtime=$(JDK_JMODS_DIFF)\n+\n+  $(eval $(call SetupExecute, generate_jimage_diff, \\\n+      WARN := Generating the jimage to packaged modules diff, \\\n+      DEPS := $(jlink_jdk), \\\n+      OUTPUT_FILE := $(JDK_JMODS_DIFF), \\\n+      SUPPORT_DIR := $(JDK_RUN_TIME_IMAGE_SUPPORT_DIR), \\\n+      COMMAND := $(TOOL_JIMAGE_DIFF_TO_JMODS) $(IMAGES_OUTPUTDIR)\/jmods \\\n+          $(JDK_LINK_OUTPUT_DIR)\/lib\/modules $(JDK_JMODS_DIFF), \\\n+  ))\n+\n+  $(eval $(call SetupExecute, jlink_runtime_jdk, \\\n+      WARN := Creating jdk image for runtime linking, \\\n+      DEPS := $(generate_jimage_diff), \\\n+      OUTPUT_DIR := $(JDK_IMAGE_DIR), \\\n+      SUPPORT_DIR := $(JDK_RUN_TIME_IMAGE_SUPPORT_DIR), \\\n+      PRE_COMMAND := $(RM) -r $(JDK_IMAGE_DIR), \\\n+      COMMAND := $(JLINK_TOOL) --add-modules $(JDK_MODULES_LIST) \\\n+          $(JLINK_RUNTIME_CREATE_EXTRA) \\\n+          --output $(JDK_IMAGE_DIR) \\\n+          $(JLINK_DISABLE_WARNINGS), \\\n+  ))\n+\n+  JLINK_JDK_TARGETS += $(generate_jimage_diff)\n+  JLINK_JDK_TARGETS += $(jlink_runtime_jdk)\n+\n+endif\n+\n","filename":"make\/Images.gmk","additions":49,"deletions":4,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -85,0 +85,5 @@\n+TOOL_JIMAGE_DIFF_TO_JMODS = $(BUILD_JAVA_SMALL) -cp $(BUILDTOOLS_OUTPUTDIR)\/jdk_tools_classes \\\n+    --add-modules=jdk.jlink --add-exports=java.base\/jdk.internal.module=ALL-UNNAMED \\\n+    --add-exports=java.base\/jdk.internal.jimage=ALL-UNNAMED \\\n+    build.tools.runtimelink.JimageDiffGenerator\n+\n","filename":"make\/ToolsJdk.gmk","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -140,0 +140,1 @@\n+JDKOPT_SETUP_JLINK_RUN_TIME_LINK_IMAGE\n","filename":"make\/autoconf\/configure.ac","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -594,0 +594,16 @@\n+################################################################################\n+#\n+# jlink related.\n+#\n+# Determines whether or not a run-time linkable JDK image is being\n+# produced from the product image.\n+#\n+AC_DEFUN_ONCE([JDKOPT_SETUP_JLINK_RUN_TIME_LINK_IMAGE],\n+[\n+  UTIL_ARG_ENABLE(NAME: runtime-link-image, DEFAULT: false,\n+      RESULT: JLINK_PRODUCE_RUNTIME_LINK_JDK,\n+      DESC: [enable producing an image suitable for runtime linking],\n+      CHECKING_MSG: [whether or not an image suitable for runtime linking should be produced])\n+  AC_SUBST(JLINK_PRODUCE_RUNTIME_LINK_JDK)\n+])\n+\n","filename":"make\/autoconf\/jdk-options.m4","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -732,0 +732,1 @@\n+JLINK_PRODUCE_RUNTIME_LINK_JDK := @JLINK_PRODUCE_RUNTIME_LINK_JDK@\n@@ -900,0 +901,4 @@\n+# Runtime jdk link image\n+RL_INTERMEDIATE_IMAGE_SUBDIR := runtime-link-initial-jdk\n+RL_INTERMEDIATE_IMAGE_DIR := $(IMAGES_OUTPUTDIR)\/$(RL_INTERMEDIATE_IMAGE_SUBDIR)\n+\n","filename":"make\/autoconf\/spec.gmk.template","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package build.tools.runtimelink;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.jimage.BasicImageReader;\n+\n+public class ImageReader extends BasicImageReader implements JimageDiffGenerator.ImageResource {\n+\n+    public ImageReader(Path path) throws IOException {\n+        super(path);\n+    }\n+\n+    public static boolean isNotTreeInfoResource(String path) {\n+        return !(path.startsWith(\"\/packages\") || path.startsWith(\"\/modules\"));\n+    }\n+\n+    @Override\n+    public List<String> getEntries() {\n+        return Arrays.asList(getEntryNames()).stream()\n+                .filter(ImageReader::isNotTreeInfoResource)\n+                .sorted()\n+                .collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public byte[] getResourceBytes(String name) {\n+        return getResource(name);\n+    }\n+\n+}\n","filename":"make\/jdk\/src\/classes\/build\/tools\/runtimelink\/ImageReader.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package build.tools.runtimelink;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class JimageDiffGenerator {\n+\n+    private static final boolean DEBUG = false;\n+\n+    @SuppressWarnings(\"try\")\n+    public interface ImageResource extends AutoCloseable {\n+        public List<String> getEntries();\n+        public byte[] getResourceBytes(String name);\n+    }\n+\n+    public List<ResourceDiff> generateDiff(ImageResource baseImg, ImageResource optImage) throws Exception {\n+        List<String> baseResources;\n+        Set<String> optResSet = new HashSet<>();\n+        List<ResourceDiff> diffs = new ArrayList<>();\n+        try (baseImg;\n+             optImage) {\n+            optResSet.addAll(optImage.getEntries());\n+            baseResources = baseImg.getEntries();\n+            for (String item: baseResources) {\n+                byte[] baseBytes = baseImg.getResourceBytes(item);\n+                \/\/ First check that every item in the base image exist in\n+                \/\/ the optimized image as well. If it does not, it's a removed\n+                \/\/ item in the optimized image.\n+                if (!optResSet.remove(item)) {\n+                    \/\/ keep track of original bytes for removed item in the\n+                    \/\/ optimized image, since we need to restore them for the\n+                    \/\/ runtime image link\n+                    ResourceDiff.Builder builder = new ResourceDiff.Builder();\n+                    ResourceDiff diff = builder.setKind(ResourceDiff.Kind.REMOVED)\n+                           .setName(item)\n+                           .setResourceBytes(baseBytes)\n+                           .build();\n+                    diffs.add(diff);\n+                    continue;\n+                }\n+                \/\/ Verify resource bytes are equal if present in both images\n+                boolean contentEquals = Arrays.equals(baseBytes, optImage.getResourceBytes(item));\n+                if (!contentEquals) {\n+                    \/\/ keep track of original bytes (non-optimized)\n+                    ResourceDiff.Builder builder = new ResourceDiff.Builder();\n+                    ResourceDiff diff = builder.setKind(ResourceDiff.Kind.MODIFIED)\n+                        .setName(item)\n+                        .setResourceBytes(baseBytes)\n+                        .build();\n+                    diffs.add(diff);\n+                }\n+            }\n+        }\n+        \/\/ What's now left in optResSet are the resources only present in the\n+        \/\/ optimized image (generated by some plugins; not present in jmods)\n+        for (String e: optResSet) {\n+            ResourceDiff.Builder builder = new ResourceDiff.Builder();\n+            ResourceDiff diff = builder.setKind(ResourceDiff.Kind.ADDED)\n+                                    .setName(e)\n+                                    .build();\n+            diffs.add(diff);\n+        }\n+        return diffs;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 3) {\n+            System.out.println(\"Usage: java -cp jrt-fs.jar:. JimageDiffGenerator <packaged-modules> <image-to-compare> <output-file>\");\n+            System.exit(1);\n+        }\n+        ImageResource base = new JmodsReader(Path.of(args[0]));\n+        ImageResource opt = new ImageReader(Path.of(args[1]));\n+        JimageDiffGenerator diffGen = new JimageDiffGenerator();\n+        List<ResourceDiff> diffs = diffGen.generateDiff(base, opt);\n+\n+        if (DEBUG) {\n+            printDiffs(diffs);\n+        }\n+        FileOutputStream fout = new FileOutputStream(new File(args[2]));\n+        ResourceDiff.write(diffs, fout);\n+    }\n+\n+    private static void printDiffs(List<ResourceDiff> diffs) {\n+        for (ResourceDiff diff: diffs.stream().sorted().collect(Collectors.toList())) {\n+            switch (diff.getKind()) {\n+            case ADDED:\n+                System.out.println(\"Only added in opt: \" + diff.getName());\n+                break;\n+            case MODIFIED:\n+                System.out.println(\"Modified in opt: \" + diff.getName());\n+                break;\n+            case REMOVED:\n+                System.out.println(\"Removed in opt: \" + diff.getName());\n+                break;\n+            default:\n+                break;\n+            }\n+        }\n+    }\n+\n+}\n","filename":"make\/jdk\/src\/classes\/build\/tools\/runtimelink\/JimageDiffGenerator.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package build.tools.runtimelink;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReader;\n+import java.lang.module.ModuleReference;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.module.ModulePath;\n+\n+@SuppressWarnings(\"try\")\n+public class JmodsReader implements JimageDiffGenerator.ImageResource {\n+\n+    private final ModuleFinder finder;\n+\n+    public JmodsReader(Path packagedModulesDir) {\n+        List<Path> pa;\n+        try {\n+            pa = Files.list(packagedModulesDir).filter(p -> !p.endsWith(\".jmod\")).collect(Collectors.toList());\n+        } catch (IOException e) {\n+            throw new IllegalStateException(\"Listing of jmods directory failed!\", e);\n+        }\n+        Path[] paths = pa.toArray(new Path[0]);\n+        this.finder = ModulePath.of(Runtime.version(), true, paths);\n+    }\n+\n+    @Override\n+    public void close() throws Exception {\n+        \/\/ nothing\n+    }\n+\n+    @Override\n+    public List<String> getEntries() {\n+        List<String> all = new ArrayList<>();\n+        try {\n+            Set<ModuleReference> allMods = finder.findAll();\n+            for (ModuleReference mRef: allMods) {\n+                String moduleName = mRef.descriptor().name();\n+                ModuleReader reader = mRef.open();\n+                List<String> perModule = reader.list().map(a -> {return \"\/\" + moduleName + \"\/\" + a;}).collect(Collectors.toList());\n+                all.addAll(perModule);\n+            }\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        Collections.sort(all);\n+        return all;\n+    }\n+\n+    @Override\n+    public byte[] getResourceBytes(String name) {\n+        int secondSlash = name.indexOf(\"\/\", 1);\n+        String moduleName = null;\n+        if (secondSlash != -1) {\n+            moduleName = name.substring(1, secondSlash);\n+        }\n+        if (moduleName == null) {\n+            throw new IllegalArgumentException(\"Module name not found in \" + name);\n+        }\n+        ModuleReference ref = finder.find(moduleName).orElseThrow();\n+        String refName = name.substring(secondSlash + 1); \/\/ omit the leading slash\n+        try (ModuleReader reader = ref.open()) {\n+            return reader.open(refName).orElseThrow().readAllBytes();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+}\n","filename":"make\/jdk\/src\/classes\/build\/tools\/runtimelink\/JmodsReader.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package build.tools.runtimelink;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * Class representing a difference between a jimage resource. For all intents\n+ * and purposes this represents a difference between a resource in an optimized\n+ * jimage (e.g. images\/jdk\/lib\/modules) and the underlying basic resources from\n+ * which the optimized image got derived from. The differences are being used\n+ * in JRTArchive so as to back-track from an optimized jimage to the original\n+ * (i.e. it restores original resources using the diff).\n+ *\n+ * Duplicated in jdk.jlink\/jdk.tools.jlink.internal.ResourceDiff\n+ *\/\n+public class ResourceDiff implements Comparable<ResourceDiff> {\n+\n+    private static final int MAGIC = 0xabba;\n+\n+    public static enum Kind {\n+        ADDED((short)1),    \/\/ Resource added\n+        REMOVED((short)2),  \/\/ Resource removed\n+        MODIFIED((short)3); \/\/ Resource modified\n+\n+        private short value;\n+\n+        private Kind(short value) {\n+            this.value = value;\n+        }\n+\n+        public short value() {\n+            return value;\n+        }\n+\n+        static Kind fromShort(short v) {\n+            if (v > 3 || v < 1) {\n+                throw new IllegalArgumentException(\"Must be within range [1-3]\");\n+            }\n+            switch (v) {\n+            case 1: return ADDED;\n+            case 2: return REMOVED;\n+            case 3: return MODIFIED;\n+            }\n+            throw new IllegalStateException(\"Must not reach here!\");\n+        }\n+    }\n+\n+    private final Kind kind;\n+    private final byte[] resourceBytes;\n+    private final String name;\n+\n+    private ResourceDiff(Kind kind, String name, byte[] resourceBytes) {\n+        this.kind = kind;\n+        this.name = name;\n+        if ((kind == Kind.REMOVED || kind == Kind.MODIFIED) &&\n+                resourceBytes == null) {\n+            throw new AssertionError(\"Resource bytes must be set for REMOVED or MODIFIED\");\n+        }\n+        this.resourceBytes = resourceBytes;\n+    }\n+\n+    public Kind getKind() {\n+        return kind;\n+    }\n+\n+    public byte[] getResourceBytes() {\n+        return resourceBytes;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public int compareTo(ResourceDiff o) {\n+        int kindComp = kind.value() - o.kind.value();\n+        if (kindComp == 0) {\n+            return getName().compareTo(o.getName());\n+        } else {\n+            return kindComp;\n+        }\n+    }\n+\n+    public static class Builder {\n+        private Kind kind;\n+        private String name;\n+        private byte[] resourceBytes;\n+\n+        public Builder setKind(Kind kind) {\n+            this.kind = kind;\n+            return this;\n+        }\n+        public Builder setName(String name) {\n+            this.name = Objects.requireNonNull(name);\n+            return this;\n+        }\n+        public Builder setResourceBytes(byte[] resourceBytes) {\n+            this.resourceBytes = Objects.requireNonNull(resourceBytes);\n+            return this;\n+        }\n+        public ResourceDiff build() {\n+            if (kind == null || name == null) {\n+                throw new IllegalStateException(\"kind and name must be set\");\n+            }\n+            switch (kind) {\n+            case ADDED:\n+                {\n+                    break; \/\/ null bytes for added is OK.\n+                }\n+            case MODIFIED: \/\/ fall-through\n+            case REMOVED:\n+                {\n+                    if (resourceBytes == null) {\n+                        throw new IllegalStateException(\"Original bytes needed for MODIFIED, REMOVED!\");\n+                    }\n+                    break;\n+                }\n+            default:\n+                break;\n+            }\n+            return new ResourceDiff(kind, name, resourceBytes);\n+        }\n+    }\n+\n+    \/**\n+     * Writes a list of resource diffs to an output stream\n+     *\n+     * @param diffs The list of resource diffs to write.\n+     * @param out The stream to write the serialized bytes to.\n+     *\/\n+    public static void write(List<ResourceDiff> diffs, OutputStream out) throws IOException {\n+        \/*\n+         * Simple binary format:\n+         *\n+         * <header>|<items>\n+         *\n+         * ****************************************\n+         * HEADER info\n+         * ****************************************\n+         *\n+         * where <header> is ('|' separation for clarity):\n+         *\n+         *  <int>|<int>\n+         *\n+         * The first integer is the MAGIC, 0xabba. The second integer is the\n+         * total number of items.\n+         *\n+         * *****************************************\n+         * ITEMS info\n+         * *****************************************\n+         *\n+         * Each <item> consists of ('|' separation for clarity):\n+         *\n+         * <short>|<int>|<name-bytes-utf>|<int>|<resource-bytes>\n+         *\n+         * Where the individual items are:\n+         *\n+         * <short>:\n+         *     The value of the respective ResourceDiff.Kind.\n+         * <int>:\n+         *     The length of the name bytes (in UTF-8).\n+         * <name-bytes-utf>:\n+         *     The resource name bytes in UTF-8.\n+         * <int>:\n+         *     The length of the resource bytes. 0 (zero) if no resource bytes.\n+         *     A.k.a 'null'.\n+         * <resource-bytes>:\n+         *     The bytes of the resource as stored in the jmod files.\n+         *\/\n+        try (DataOutputStream dataOut = new DataOutputStream(out)) {\n+            dataOut.writeInt(MAGIC);\n+            dataOut.writeInt(diffs.size());\n+            for (ResourceDiff d: diffs) {\n+                dataOut.writeShort(d.kind.value());\n+                byte[] buf = d.name.getBytes(StandardCharsets.UTF_8);\n+                dataOut.writeInt(buf.length);\n+                dataOut.write(buf);\n+                buf = d.resourceBytes;\n+                dataOut.writeInt(buf == null ? 0 : buf.length);\n+                if (buf != null) {\n+                    dataOut.write(buf);\n+                }\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+            throw e;\n+        }\n+    }\n+\n+    \/**\n+     * Read a list of resource diffs from an input stream.\n+     *\n+     * @param in The input stream to read from\n+     * @return The list of resource diffs.\n+     *\/\n+    public static List<ResourceDiff> read(InputStream in) throws IOException {\n+        \/*\n+         * See write() for the details how this is being written\n+         *\/\n+        List<ResourceDiff> diffs;\n+        try (DataInputStream din = new DataInputStream(in)) {\n+            int magic = din.readInt();\n+            if (magic != MAGIC) {\n+                throw new IllegalArgumentException(\"Not a ResourceDiff data stream!\");\n+            }\n+            int numItems = din.readInt();\n+            diffs = new ArrayList<>(numItems);\n+            for (int i = 0; i < numItems; i++) {\n+                Kind k = Kind.fromShort(din.readShort());\n+                int numBytes = din.readInt();\n+                byte[] buf = readNumBytesFromStream(din, numBytes);\n+                String name = new String(buf, StandardCharsets.UTF_8);\n+                numBytes = din.readInt();\n+                byte[] resBytes = null;\n+                if (numBytes != 0) {\n+                    resBytes = readNumBytesFromStream(din, numBytes);\n+                }\n+                Builder builder = new Builder();\n+                builder.setKind(k)\n+                       .setName(name);\n+                if (resBytes != null) {\n+                    builder.setResourceBytes(resBytes);\n+                }\n+                diffs.add(builder.build());\n+            }\n+        }\n+        return diffs;\n+    }\n+\n+    private static byte[] readNumBytesFromStream(DataInputStream din, int numBytes) throws IOException {\n+        byte[] b = new byte[numBytes];\n+        for (int i = 0; i < numBytes; i++) {\n+            int data = din.read();\n+            if (data == -1) {\n+                throw new IOException(\"Short read!\");\n+            }\n+            b[i] = (byte)data;\n+        }\n+        return b;\n+    }\n+}\n","filename":"make\/jdk\/src\/classes\/build\/tools\/runtimelink\/ResourceDiff.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -169,0 +169,3 @@\n+        } catch (RuntimeImageLinkException e) {\n+            \/\/ Propagate reason for run-time image based links\n+            throw e.getReason();\n@@ -190,0 +193,7 @@\n+        } catch (RuntimeImageLinkException re) {\n+            \/\/ might be thrown in the run-image link case. Populate the\n+            \/\/ actual reason.\n+            if (JlinkTask.DEBUG) {\n+                re.printStackTrace();\n+            }\n+            throw re.getReason();\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageFileCreator.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,456 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal;\n+\n+import static jdk.tools.jlink.internal.JlinkTask.DIFF_PATTERN;\n+import static jdk.tools.jlink.internal.JlinkTask.RESPATH_PATTERN;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReference;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.util.OperatingSystem;\n+import jdk.tools.jlink.internal.Archive.Entry.EntryType;\n+import jdk.tools.jlink.plugin.ResourcePoolEntry;\n+import jdk.tools.jlink.plugin.ResourcePoolEntry.Type;\n+\n+\/**\n+ * An archive implementation based on the run-time image (lib\/modules, or jimage)\n+ * and associated files from the filesystem if any (e.g. native libraries).\n+ *\/\n+public class JRTArchive implements Archive {\n+\n+    private final String module;\n+    private final Path path;\n+    private final ModuleReference ref;\n+    private final List<JRTFile> files = new ArrayList<>();\n+    private final List<String> otherRes;\n+    private final Map<String, ResourceDiff> resDiff;\n+    private final boolean errorOnModifiedFile;\n+\n+    JRTArchive(String module, Path path, boolean errorOnModifiedFile) {\n+        this.module = module;\n+        this.path = path;\n+        this.ref = ModuleFinder.ofSystem()\n+                               .find(module)\n+                               .orElseThrow(() ->\n+                                    new IllegalArgumentException(\"Module \" + module + \" not part of the JDK install\"));\n+        this.errorOnModifiedFile = errorOnModifiedFile;\n+        this.otherRes = readModuleResourceFile(module);\n+        this.resDiff = readModuleResourceDiff(module);\n+    }\n+\n+    @Override\n+    public String moduleName() {\n+        return module;\n+    }\n+\n+    @Override\n+    public Path getPath() {\n+        return path;\n+    }\n+\n+    @Override\n+    public Stream<Entry> entries() {\n+        try {\n+            collectFiles();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        } catch (RuntimeImageLinkException e) {\n+            \/\/ populate single-hop issue\n+            throw e.getReason();\n+        }\n+        return files.stream().map(JRTFile::toEntry);\n+    }\n+\n+    @Override\n+    public void open() throws IOException {\n+        if (files.isEmpty()) {\n+            collectFiles();\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (!files.isEmpty()) {\n+            files.clear();\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(module, path);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof JRTArchive) {\n+            JRTArchive other = (JRTArchive)obj;\n+            return Objects.equals(module, other.module) &&\n+                   Objects.equals(path, other.path);\n+        }\n+\n+        return false;\n+    }\n+\n+    private void collectFiles() throws IOException {\n+        if (files.isEmpty()) {\n+            addNonClassResources();\n+            \/\/ Add classes\/resources from image module,\n+            \/\/ patched with the runtime image link diff\n+            files.addAll(ref.open().list()\n+                                   .filter(i -> {\n+                                       String lookupKey = String.format(\"\/%s\/%s\", module, i);\n+                                       ResourceDiff rd = resDiff.get(lookupKey);\n+                                       \/\/ Filter all resources with a resource diff\n+                                       \/\/ that are of kind MODIFIED.\n+                                       \/\/ Note that REMOVED won't happen since in\n+                                       \/\/ that case the module listing won't have\n+                                       \/\/ the resource anyway.\n+                                       return (rd == null || rd.getKind() == ResourceDiff.Kind.MODIFIED);\n+                                   })\n+                                   .map(s -> {\n+                                               String lookupKey = String.format(\"\/%s\/%s\", module, s);\n+                                               return new JRTArchiveFile(JRTArchive.this, s,\n+                                                       EntryType.CLASS_OR_RESOURCE,\n+                                                       null \/* hashOrTarget *\/,\n+                                                       false \/* symlink *\/,\n+                                                       resDiff.get(lookupKey));\n+                                   })\n+                                   .collect(Collectors.toList()));\n+            \/\/ Finally add all files only present in the resource diff\n+            \/\/ That is, removed items in the runtime image.\n+            files.addAll(resDiff.values().stream()\n+                                         .filter(rd -> rd.getKind() == ResourceDiff.Kind.REMOVED)\n+                                         .map(s -> {\n+                                                 int secondSlash = s.getName().indexOf(\"\/\", 1);\n+                                                 if (secondSlash == -1) {\n+                                                     throw new AssertionError();\n+                                                 }\n+                                                 String pathWithoutModule = s.getName().substring(secondSlash + 1, s.getName().length());\n+                                                 return new JRTArchiveFile(JRTArchive.this, pathWithoutModule,\n+                                                         EntryType.CLASS_OR_RESOURCE,\n+                                                         null  \/* hashOrTarget *\/,\n+                                                         false \/* symlink *\/,\n+                                                         s);\n+                                         })\n+                                         .collect(Collectors.toList()));\n+        }\n+    }\n+\n+    \/*\n+     * no need to keep track of the warning produced since this is eagerly checked once.\n+     *\/\n+    private void addNonClassResources() {\n+        \/\/ Not all modules will have other resources like bin, lib, legal etc.\n+        \/\/ files. In that case the list will be empty.\n+        if (!otherRes.isEmpty()) {\n+            files.addAll(otherRes.stream()\n+                 .filter(Predicate.not(String::isEmpty))\n+                 .map(s -> {\n+                        ResourceFileEntry m = ResourceFileEntry.decodeFromString(s);\n+\n+                        \/\/ Read from the base JDK image.\n+                        Path path = BASE.resolve(m.resPath);\n+                        if (shaSumMismatch(path, m.hashOrTarget, m.symlink)) {\n+                            if (errorOnModifiedFile) {\n+                                String msg = String.format(MISMATCH_FORMAT, path.toString());\n+                                IllegalArgumentException ise = new IllegalArgumentException(msg);\n+                                throw new RuntimeImageLinkException(ise);\n+                            } else {\n+                                String msg = String.format(MISMATCH_FORMAT, path.toString());\n+                                System.err.printf(\"WARNING: %s\", msg);\n+                            }\n+                        }\n+\n+                        return new JRTArchiveFile(JRTArchive.this, m.resPath, toEntryType(m.resType), m.hashOrTarget, m.symlink, null);\n+                 })\n+                 .collect(Collectors.toList()));\n+        }\n+    }\n+\n+    static boolean shaSumMismatch(Path res, String expectedSha, boolean isSymlink) {\n+        if (isSymlink) {\n+            return false;\n+        }\n+        \/\/ handle non-symlink resources\n+        try {\n+            HexFormat format = HexFormat.of();\n+            byte[] expected = format.parseHex(expectedSha);\n+            MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n+            try (InputStream is = Files.newInputStream(res)) {\n+                byte[] buf = new byte[1024];\n+                int readBytes = -1;\n+                while ((readBytes = is.read(buf)) != -1) {\n+                    digest.update(buf, 0, readBytes);\n+                }\n+            }\n+            byte[] actual = digest.digest();\n+            return !MessageDigest.isEqual(expected, actual);\n+        } catch (Exception e) {\n+            throw new AssertionError(\"SHA-512 sum check failed!\", e);\n+        }\n+    }\n+\n+    private static EntryType toEntryType(Type input) {\n+        return switch(input) {\n+            case CLASS_OR_RESOURCE -> EntryType.CLASS_OR_RESOURCE;\n+            case CONFIG -> EntryType.CONFIG;\n+            case HEADER_FILE -> EntryType.HEADER_FILE;\n+            case LEGAL_NOTICE -> EntryType.LEGAL_NOTICE;\n+            case MAN_PAGE -> EntryType.MAN_PAGE;\n+            case NATIVE_CMD -> EntryType.NATIVE_CMD;\n+            case NATIVE_LIB -> EntryType.NATIVE_LIB;\n+            case TOP -> throw new IllegalArgumentException(\"TOP files should be handled by ReleaseInfoPlugin!\");\n+            default -> throw new IllegalArgumentException(\"Unknown type: \" + input);\n+        };\n+    }\n+\n+    public record ResourceFileEntry(Type resType, boolean symlink, String hashOrTarget, String resPath) {\n+        \/\/ Type file format:\n+        \/\/ '<type>|{0,1}|<sha-sum>|<file-path>'\n+        \/\/   (1)    (2)      (3)      (4)\n+        \/\/\n+        \/\/ Where fields are:\n+        \/\/\n+        \/\/ (1) The resource type as specified by ResourcePoolEntry.type()\n+        \/\/ (2) Symlink designator. 0 => regular resource, 1 => symlinked resource\n+        \/\/ (3) The SHA-512 sum of the resources' content. The link to the target\n+        \/\/     for symlinked resources.\n+        \/\/ (4) The relative file path of the resource\n+        private static final String TYPE_FILE_FORMAT = \"%d|%d|%s|%s\";\n+\n+        public String encodeToString() {\n+            return String.format(TYPE_FILE_FORMAT, resType.ordinal(), symlink ? 1 : 0, hashOrTarget, resPath);\n+        }\n+\n+        \/**\n+         *  line: <int>|<int>|<hashOrTarget>|<path>\n+         *\n+         *  Take the integer before '|' convert it to a Type. The second\n+         *  token is an integer representing symlinks (or not). The third token is\n+         *  a hash sum (sha512) of the file denoted by the fourth token (path).\n+         *\/\n+        static ResourceFileEntry decodeFromString(String line) {\n+            assert !line.isEmpty();\n+\n+            String[] tokens = line.split(\"\\\\|\", 4);\n+            Type type = null;\n+            int symlinkNum = -1;\n+            try {\n+                Integer typeInt = Integer.valueOf(tokens[0]);\n+                type = Type.fromOrdinal(typeInt);\n+                symlinkNum = Integer.valueOf(tokens[1]);\n+            } catch (NumberFormatException e) {\n+                throw new AssertionError(e); \/\/ must not happen\n+            }\n+            if (symlinkNum < 0 || symlinkNum > 1) {\n+                throw new IllegalStateException(\"Symlink designator out of range [0,1] got: \" + symlinkNum);\n+            }\n+            return new ResourceFileEntry(type, symlinkNum == 1, tokens[2], tokens[3]);\n+        }\n+\n+        public static ResourceFileEntry toResourceFileEntry(ResourcePoolEntry entry, Platform platform) {\n+            String resPathWithoutMod = dropModuleFromPath(entry, platform);\n+            \/\/ Symlinks don't have a hash sum, but a link to the target instead\n+            String hashOrTarget = entry.linkedTarget() == null\n+                                        ? computeSha512(entry)\n+                                        : dropModuleFromPath(entry.linkedTarget(), platform);\n+            return new ResourceFileEntry(entry.type(), entry.linkedTarget() != null, hashOrTarget, resPathWithoutMod);\n+        }\n+\n+        private static String computeSha512(ResourcePoolEntry entry) {\n+            try {\n+                assert entry.linkedTarget() == null;\n+                MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n+                try (InputStream is = entry.content()) {\n+                    byte[] buf = new byte[1024];\n+                    int bytesRead = -1;\n+                    while ((bytesRead = is.read(buf)) != -1) {\n+                        digest.update(buf, 0, bytesRead);\n+                    }\n+                }\n+                byte[] db = digest.digest();\n+                HexFormat format = HexFormat.of();\n+                return format.formatHex(db);\n+            } catch (RuntimeImageLinkException e) {\n+                \/\/ RunImageArchive::RunImageFile.content() may throw this when\n+                \/\/ getting the content(). Propagate this specific exception.\n+                throw e;\n+            } catch (Exception e) {\n+                throw new AssertionError(\"Failed to generate hash sum for \" + entry.path());\n+            }\n+        }\n+\n+        private static String dropModuleFromPath(ResourcePoolEntry entry, Platform platform) {\n+            String resPath = entry.path().substring(entry.moduleName().length() + 2 \/* prefixed and suffixed '\/' *\/);\n+            if (!isWindows(platform)) {\n+                return resPath;\n+            }\n+            \/\/ For Windows the libraries live in the 'bin' folder rather than the 'lib' folder\n+            \/\/ in the final image. Note that going by the NATIVE_LIB type only is insufficient since\n+            \/\/ only files with suffix .dll\/diz\/map\/pdb are transplanted to 'bin'.\n+            \/\/ See: DefaultImageBuilder.nativeDir()\n+            return nativeDir(entry, resPath);\n+        }\n+\n+        private static boolean isWindows(Platform platform) {\n+            return platform.os() == OperatingSystem.WINDOWS;\n+        }\n+\n+        private static String nativeDir(ResourcePoolEntry entry, String resPath) {\n+            if (entry.type() != ResourcePoolEntry.Type.NATIVE_LIB) {\n+                return resPath;\n+            }\n+            \/\/ precondition: Native lib, windows platform\n+            if (resPath.endsWith(\".dll\") || resPath.endsWith(\".diz\")\n+                    || resPath.endsWith(\".pdb\") || resPath.endsWith(\".map\")) {\n+                if (resPath.startsWith(LIB_DIRNAME + \"\/\")) {\n+                    return BIN_DIRNAME + \"\/\" + resPath.substring((LIB_DIRNAME + \"\/\").length());\n+                }\n+            }\n+            return resPath;\n+        }\n+        private static final String BIN_DIRNAME = \"bin\";\n+        private static final String LIB_DIRNAME = \"lib\";\n+    }\n+\n+    private static final Path BASE = Paths.get(System.getProperty(\"java.home\"));\n+    private static final String MISMATCH_FORMAT = \"%s has been modified.%n\";\n+\n+    interface JRTFile {\n+        Entry toEntry();\n+    }\n+\n+    record JRTArchiveFile (Archive archive, String resPath, EntryType resType, String sha, boolean symlink, ResourceDiff diff)\n+            implements JRTFile\n+    {\n+        public Entry toEntry() {\n+            return new Entry(archive, String.format(\"\/%s\/%s\", archive.moduleName(), resPath), resPath, resType) {\n+                @Override\n+                public long size() {\n+                    try {\n+                        if (resType != EntryType.CLASS_OR_RESOURCE) {\n+                            \/\/ Read from the base JDK image, special casing\n+                            \/\/ symlinks, which have the link target in the hashOrTarget field\n+                            if (symlink) {\n+                                return Files.size(BASE.resolve(sha));\n+                            }\n+                            return Files.size(BASE.resolve(resPath));\n+                        } else {\n+                            \/\/ Read from the module image. This works, because\n+                            \/\/ the underlying base path is a JrtPath with the\n+                            \/\/ JrtFileSystem underneath which is able to handle\n+                            \/\/ this size query.\n+                            if (diff != null) {\n+                                \/\/ If the resource has a diff to the\n+                                \/\/ packaged modules, use the diff. Diffs of kind\n+                                \/\/ ADDED have been filtered in collectFiles();\n+                                assert diff.getKind() != ResourceDiff.Kind.ADDED;\n+                                assert diff.getName().equals(String.format(\"\/%s\/%s\", archive.moduleName(), resPath));\n+                                return diff.getResourceBytes().length;\n+                            }\n+                            return Files.size(archive.getPath().resolve(resPath));\n+                        }\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                }\n+\n+                @Override\n+                public InputStream stream() throws IOException {\n+                    if (resType != EntryType.CLASS_OR_RESOURCE) {\n+                        \/\/ Read from the base JDK image.\n+                        Path path = symlink ? BASE.resolve(sha) : BASE.resolve(resPath);\n+                        return Files.newInputStream(path);\n+                    } else {\n+                        \/\/ Read from the module image. Use the diff to the\n+                        \/\/ packaged modules if we have one.\n+                        if (diff != null) {\n+                            assert diff.getKind() != ResourceDiff.Kind.ADDED;\n+                            assert diff.getName().equals(String.format(\"\/%s\/%s\", archive.moduleName(), resPath));\n+                            return new ByteArrayInputStream(diff.getResourceBytes());\n+                        }\n+                        String module = archive.moduleName();\n+                        ModuleReference mRef = ModuleFinder.ofSystem().find(module).orElseThrow();\n+                        return mRef.open().open(resPath).orElseThrow();\n+                    }\n+                }\n+\n+            };\n+        }\n+    }\n+\n+    static List<String> readModuleResourceFile(String modName) {\n+        String resName = String.format(RESPATH_PATTERN, modName);\n+        try {\n+            try (InputStream inStream = JRTArchive.class.getModule().getResourceAsStream(resName)) {\n+                String input = new String(inStream.readAllBytes(), StandardCharsets.UTF_8);\n+                if (input.isEmpty()) {\n+                    \/\/ Not all modules have non-class resources\n+                    return Collections.emptyList();\n+                } else {\n+                    return Arrays.asList(input.split(\"\\n\"));\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new InternalError(\"Failed to process run-time image resources for \" + modName);\n+        }\n+    }\n+\n+    static Map<String, ResourceDiff> readModuleResourceDiff(String modName) {\n+        String resName = String.format(DIFF_PATTERN, modName);\n+        try {\n+            try (InputStream inStream = JRTArchive.class.getModule().getResourceAsStream(resName)) {\n+                List<ResourceDiff> diffs = ResourceDiff.read(inStream);\n+                Map<String, ResourceDiff> resDiffsAsMap = new HashMap<>();\n+                diffs.forEach(r -> resDiffsAsMap.put(r.getName(), r));\n+                return resDiffsAsMap;\n+            }\n+        } catch (IOException e) {\n+            throw new InternalError(\"Failed to process run-time image diff file for \" + modName);\n+        }\n+    }\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JRTArchive.java","additions":456,"deletions":0,"binary":false,"changes":456,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import java.nio.ByteOrder;\n@@ -151,0 +150,2 @@\n+        private final boolean linkFromRuntimeImage;\n+        private final boolean ignoreModifiedRuntime;\n@@ -161,1 +162,3 @@\n-                                  ModuleFinder finder) {\n+                                  ModuleFinder finder,\n+                                  boolean linkFromRuntimeImage,\n+                                  boolean ignoreModifiedRuntime) {\n@@ -165,0 +168,2 @@\n+            this.linkFromRuntimeImage = linkFromRuntimeImage;\n+            this.ignoreModifiedRuntime = ignoreModifiedRuntime;\n@@ -189,0 +194,8 @@\n+        public boolean linkFromRuntimeImage() {\n+            return linkFromRuntimeImage;\n+        }\n+\n+        public boolean ignoreModifiedRuntime() {\n+            return ignoreModifiedRuntime;\n+        }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Jlink.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import static jdk.tools.jlink.internal.TaskHelper.JLINK_BUNDLE;\n+\n@@ -42,1 +44,0 @@\n-import java.nio.file.Files;\n@@ -44,0 +45,1 @@\n+import java.nio.file.Files;\n@@ -50,0 +52,1 @@\n+import java.util.Collections;\n@@ -63,0 +66,1 @@\n+import jdk.internal.module.ModulePath;\n@@ -64,2 +68,3 @@\n-import jdk.tools.jlink.internal.TaskHelper.BadArgs;\n-import static jdk.tools.jlink.internal.TaskHelper.JLINK_BUNDLE;\n+import jdk.internal.module.ModuleResolution;\n+import jdk.internal.opt.CommandLine;\n+import jdk.tools.jlink.internal.ImagePluginStack.ImageProvider;\n@@ -68,0 +73,1 @@\n+import jdk.tools.jlink.internal.TaskHelper.BadArgs;\n@@ -70,1 +76,0 @@\n-import jdk.tools.jlink.internal.ImagePluginStack.ImageProvider;\n@@ -72,3 +77,0 @@\n-import jdk.internal.opt.CommandLine;\n-import jdk.internal.module.ModulePath;\n-import jdk.internal.module.ModuleResolution;\n@@ -89,0 +91,1 @@\n+    private static final String JLINK_MOD_NAME = \"jdk.jlink\";\n@@ -185,1 +188,6 @@\n-        }, \"--ignore-signing-information\"),};\n+        }, \"--ignore-signing-information\"),\n+        new Option<JlinkTask>(false, (task, opt, arg) -> {\n+            task.options.ignoreModifiedRuntime = true;\n+        }, true, \"--ignore-modified-runtime\")\n+    };\n+\n@@ -225,0 +233,1 @@\n+        boolean ignoreModifiedRuntime = false;\n@@ -228,0 +237,3 @@\n+    public static final String RESPATH_PATTERN = \"jdk\/tools\/jlink\/internal\/fs_%s_files\";\n+    \/\/ The diff file per module\n+    public static final String DIFF_PATTERN = \"jdk\/tools\/jlink\/internal\/diff_%s\";\n@@ -273,5 +285,0 @@\n-\n-                if (options.modulePath.isEmpty()) {\n-                    throw taskHelper.newBadArgs(\"err.modulepath.must.be.specified\")\n-                            .showUsage(true);\n-                }\n@@ -359,0 +366,1 @@\n+                                    new OptionsValues(),\n@@ -371,0 +379,8 @@\n+        \/\/ Currently run-time image based jlinks are only used when\n+        \/\/ the module path is empty. I.e. not specified on the command line\n+        \/\/ and the 'jmods' folder in JAVA_HOME is not present. This restriction\n+        \/\/ is so because cases with an external jimage as run-time image based\n+        \/\/ have not been considered at this point.\n+        if (options.modulePath.isEmpty() && options.packagedModulesPath != null) {\n+            throw taskHelper.newBadArgs(\"err.runtime.link.packaged.mods\");\n+        }\n@@ -373,1 +389,1 @@\n-            if (mod.equals(ALL_MODULE_PATH)) {\n+            if (mod.equals(ALL_MODULE_PATH) && options.modulePath.size() > 0) {\n@@ -394,0 +410,11 @@\n+        boolean isLinkFromRuntime = options.modulePath.isEmpty();\n+        \/\/ In case of custom modules outside the JDK we may\n+        \/\/ have a non-empty module path, which doesn't include\n+        \/\/ java.base. In that case take the JDK modules from the\n+        \/\/ current run-time image.\n+        if (finder.find(\"java.base\").isEmpty()) {\n+            isLinkFromRuntime = true;\n+            ModuleFinder runtimeImageFinder = ModuleFinder.ofSystem();\n+            finder = combinedFinders(finder, runtimeImageFinder, options.limitMods, roots);\n+        }\n+\n@@ -397,1 +424,32 @@\n-                                      finder);\n+                                      finder,\n+                                      isLinkFromRuntime,\n+                                      options.ignoreModifiedRuntime);\n+    }\n+\n+    private ModuleFinder combinedFinders(ModuleFinder finder,\n+            ModuleFinder runtimeImageFinder, Set<String> limitMods,\n+            Set<String> roots) {\n+        ModuleFinder combined = new ModuleFinder() {\n+\n+            @Override\n+            public Optional<ModuleReference> find(String name) {\n+                Optional<ModuleReference> basic = runtimeImageFinder.find(name);\n+                if (basic.isEmpty()) {\n+                    return finder.find(name);\n+                }\n+                return basic;\n+            }\n+\n+            @Override\n+            public Set<ModuleReference> findAll() {\n+                Set<ModuleReference> all = new HashSet<>();\n+                all.addAll(runtimeImageFinder.findAll());\n+                all.addAll(finder.findAll());\n+                return Collections.unmodifiableSet(all);\n+            }\n+        };\n+        \/\/ if limitmods is specified then limit the universe\n+        if (limitMods != null && !limitMods.isEmpty()) {\n+            return limitFinder(combined, limitMods, Objects.requireNonNull(roots));\n+        }\n+        return combined;\n@@ -416,0 +474,1 @@\n+                                                        options,\n@@ -448,5 +507,0 @@\n-        if (Objects.requireNonNull(paths).isEmpty()) {\n-             throw new IllegalArgumentException(taskHelper.getMessage(\"err.empty.module.path\"));\n-        }\n-\n-        Path[] entries = paths.toArray(new Path[0]);\n@@ -454,2 +508,3 @@\n-        ModuleFinder finder = ModulePath.of(version, true, entries);\n-\n+        Path[] entries = paths.toArray(new Path[0]);\n+        ModuleFinder finder = paths.isEmpty() ? ModuleFinder.ofSystem()\n+                                              : ModulePath.of(version, true, entries);\n@@ -521,0 +576,1 @@\n+                                                   OptionsValues opts,\n@@ -537,0 +593,24 @@\n+        \/\/ Perform some setup for run-time image based links\n+        if (config.linkFromRuntimeImage()) {\n+            \/\/ Catch the case where we don't have a linkable runtime. In that\n+            \/\/ case, fs_java.base_files doesn't exist in the jdk.jlink\n+            \/\/ module.\n+            String resourceName = String.format(RESPATH_PATTERN, \"java.base\");\n+            InputStream inStream = JlinkTask.class.getModule().getResourceAsStream(resourceName);\n+            if (inStream == null) {\n+                \/\/ Only linkable runtimes have those resources. Abort otherwise.\n+                String msg = taskHelper.getMessage(\"err.runtime.link.not.linkable.runtime\");\n+                throw new IllegalArgumentException(msg);\n+            }\n+            \/\/ Disallow a runtime-image-based-link with jdk.jlink included\n+            if (cf.findModule(JLINK_MOD_NAME).isPresent()) {\n+                String msg = taskHelper.getMessage(\"err.runtime.link.jdk.jlink.prohibited\");\n+                throw new IllegalArgumentException(msg);\n+            }\n+\n+            \/\/ Print info message when a run-image link is being performed\n+            if (log != null) {\n+                log.println(taskHelper.getMessage(\"runtime.link.info\"));\n+            }\n+        }\n+\n@@ -541,2 +621,5 @@\n-              .forEach(rm -> log.format(\"%s %s%n\",\n-                                        rm.name(), rm.reference().location().get()));\n+              .forEach(rm -> log.format(\"%s %s%s%n\",\n+                                        rm.name(),\n+                                        rm.reference().location().get(),\n+                                        \"jrt\".equals(rm.reference().location().get().getScheme()) && config.linkFromRuntimeImage() ?\n+                                                \" \" + taskHelper.getMessage(\"runtime.link.jprt.path.extra\") : \"\"));\n@@ -583,1 +666,73 @@\n-        return new ImageHelper(cf, mods, targetPlatform, retainModulesPath, ignoreSigning);\n+\n+        \/\/ use the version of java.base module, if present, as\n+        \/\/ the release version for multi-release JAR files\n+        var version = cf.findModule(\"java.base\")\n+                        .map(ResolvedModule::reference)\n+                        .map(ModuleReference::descriptor)\n+                        .flatMap(ModuleDescriptor::version)\n+                        .map(ModuleDescriptor.Version::toString)\n+                        .map(Runtime.Version::parse)\n+                        .orElse(Runtime.version());\n+\n+        Set<Archive> archives = mods.entrySet().stream()\n+                .map(e -> newArchive(e.getKey(), e.getValue(), version, ignoreSigning, config))\n+                .collect(Collectors.toSet());\n+\n+        return new ImageHelper(archives, targetPlatform, retainModulesPath);\n+    }\n+\n+    private static Archive newArchive(String module, Path path, Runtime.Version version, boolean ignoreSigning, JlinkConfiguration config) {\n+        if (path.toString().endsWith(\".jmod\")) {\n+            return new JmodArchive(module, path);\n+        } else if (path.toString().endsWith(\".jar\")) {\n+            ModularJarArchive modularJarArchive = new ModularJarArchive(module, path, version);\n+            try (Stream<Archive.Entry> entries = modularJarArchive.entries()) {\n+                boolean hasSignatures = entries.anyMatch((entry) -> {\n+                    String name = entry.name().toUpperCase(Locale.ROOT);\n+\n+                    return name.startsWith(\"META-INF\/\") && name.indexOf('\/', 9) == -1 && (\n+                            name.endsWith(\".SF\") ||\n+                                    name.endsWith(\".DSA\") ||\n+                                    name.endsWith(\".RSA\") ||\n+                                    name.endsWith(\".EC\") ||\n+                                    name.startsWith(\"META-INF\/SIG-\")\n+                    );\n+                });\n+\n+                if (hasSignatures) {\n+                    if (ignoreSigning) {\n+                        System.err.println(taskHelper.getMessage(\"warn.signing\", path));\n+                    } else {\n+                        throw new IllegalArgumentException(taskHelper.getMessage(\"err.signing\", path));\n+                    }\n+                }\n+            }\n+            return modularJarArchive;\n+        } else if (config.linkFromRuntimeImage()) {\n+            \/\/ This is after jmod and modular jar branches, since, in runtime link\n+            \/\/ mode custom - JDK external modules - are only supported via the\n+            \/\/ module path. Directory module paths are not supported since those\n+            \/\/ clash with JRT-FS based archives of JRTArchive.\n+            return new JRTArchive(module, path, !config.ignoreModifiedRuntime());\n+        } else if (Files.isDirectory(path)) {\n+            Path modInfoPath = path.resolve(\"module-info.class\");\n+            if (Files.isRegularFile(modInfoPath)) {\n+                return new DirArchive(path, findModuleName(modInfoPath));\n+            } else {\n+                throw new IllegalArgumentException(\n+                        taskHelper.getMessage(\"err.not.a.module.directory\", path));\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\n+                    taskHelper.getMessage(\"err.not.modular.format\", module, path));\n+        }\n+    }\n+\n+    private static String findModuleName(Path modInfoPath) {\n+        try (BufferedInputStream bis = new BufferedInputStream(\n+                Files.newInputStream(modInfoPath))) {\n+            return ModuleDescriptor.read(bis).name();\n+        } catch (IOException exp) {\n+            throw new IllegalArgumentException(taskHelper.getMessage(\n+                    \"err.cannot.read.module.info\", modInfoPath), exp);\n+        }\n@@ -848,85 +1003,1 @@\n-    private static class ImageHelper implements ImageProvider {\n-        final Platform targetPlatform;\n-        final Path packagedModulesPath;\n-        final boolean ignoreSigning;\n-        final Runtime.Version version;\n-        final Set<Archive> archives;\n-\n-        ImageHelper(Configuration cf,\n-                    Map<String, Path> modsPaths,\n-                    Platform targetPlatform,\n-                    Path packagedModulesPath,\n-                    boolean ignoreSigning) throws IOException {\n-            Objects.requireNonNull(targetPlatform);\n-            this.targetPlatform = targetPlatform;\n-            this.packagedModulesPath = packagedModulesPath;\n-            this.ignoreSigning = ignoreSigning;\n-\n-            \/\/ use the version of java.base module, if present, as\n-            \/\/ the release version for multi-release JAR files\n-            this.version = cf.findModule(\"java.base\")\n-                .map(ResolvedModule::reference)\n-                .map(ModuleReference::descriptor)\n-                .flatMap(ModuleDescriptor::version)\n-                .map(ModuleDescriptor.Version::toString)\n-                .map(Runtime.Version::parse)\n-                .orElse(Runtime.version());\n-\n-            this.archives = modsPaths.entrySet().stream()\n-                                .map(e -> newArchive(e.getKey(), e.getValue()))\n-                                .collect(Collectors.toSet());\n-        }\n-\n-        private Archive newArchive(String module, Path path) {\n-            if (path.toString().endsWith(\".jmod\")) {\n-                return new JmodArchive(module, path);\n-            } else if (path.toString().endsWith(\".jar\")) {\n-                ModularJarArchive modularJarArchive = new ModularJarArchive(module, path, version);\n-\n-                try (Stream<Archive.Entry> entries = modularJarArchive.entries()) {\n-                    boolean hasSignatures = entries.anyMatch((entry) -> {\n-                        String name = entry.name().toUpperCase(Locale.ROOT);\n-\n-                        return name.startsWith(\"META-INF\/\") && name.indexOf('\/', 9) == -1 && (\n-                                name.endsWith(\".SF\") ||\n-                                name.endsWith(\".DSA\") ||\n-                                name.endsWith(\".RSA\") ||\n-                                name.endsWith(\".EC\") ||\n-                                name.startsWith(\"META-INF\/SIG-\")\n-                        );\n-                    });\n-\n-                    if (hasSignatures) {\n-                        if (ignoreSigning) {\n-                            System.err.println(taskHelper.getMessage(\"warn.signing\", path));\n-                        } else {\n-                            throw new IllegalArgumentException(taskHelper.getMessage(\"err.signing\", path));\n-                        }\n-                    }\n-                }\n-\n-                return modularJarArchive;\n-            } else if (Files.isDirectory(path)) {\n-                Path modInfoPath = path.resolve(\"module-info.class\");\n-                if (Files.isRegularFile(modInfoPath)) {\n-                    return new DirArchive(path, findModuleName(modInfoPath));\n-                } else {\n-                    throw new IllegalArgumentException(\n-                        taskHelper.getMessage(\"err.not.a.module.directory\", path));\n-                }\n-            } else {\n-                throw new IllegalArgumentException(\n-                    taskHelper.getMessage(\"err.not.modular.format\", module, path));\n-            }\n-        }\n-\n-        private static String findModuleName(Path modInfoPath) {\n-            try (BufferedInputStream bis = new BufferedInputStream(\n-                    Files.newInputStream(modInfoPath))) {\n-                return ModuleDescriptor.read(bis).name();\n-            } catch (IOException exp) {\n-                throw new IllegalArgumentException(taskHelper.getMessage(\n-                    \"err.cannot.read.module.info\", modInfoPath), exp);\n-            }\n-        }\n-\n+    private static record ImageHelper(Set<Archive> archives, Platform targetPlatform, Path packagedModulesPath) implements ImageProvider {\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":181,"deletions":110,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -0,0 +1,270 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.tools.jlink.internal;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * Class representing a difference between a jimage resource. For all intents\n+ * and purposes this represents a difference between a resource in an optimized\n+ * jimage (e.g. images\/jdk\/lib\/modules) and the underlying basic resources from\n+ * which the optimized image got derived from. The differences are being used\n+ * in JRTArchive so as to back-track from an optimized jimage to the original\n+ * (i.e. it restores original resources using the diff).\n+ *\/\n+public class ResourceDiff implements Comparable<ResourceDiff> {\n+\n+    private static final int MAGIC = 0xabba;\n+\n+    public static enum Kind {\n+        ADDED((short)1),    \/\/ Resource added\n+        REMOVED((short)2),  \/\/ Resource removed\n+        MODIFIED((short)3); \/\/ Resource modified\n+\n+        private short value;\n+\n+        private Kind(short value) {\n+            this.value = value;\n+        }\n+\n+        public short value() {\n+            return value;\n+        }\n+\n+        static Kind fromShort(short v) {\n+            if (v > 3 || v < 1) {\n+                throw new IllegalArgumentException(\"Must be within range [1-3]\");\n+            }\n+            switch (v) {\n+            case 1: return ADDED;\n+            case 2: return REMOVED;\n+            case 3: return MODIFIED;\n+            }\n+            throw new IllegalStateException(\"Must not reach here!\");\n+        }\n+    }\n+\n+    private final Kind kind;\n+    private final byte[] resourceBytes;\n+    private final String name;\n+\n+    private ResourceDiff(Kind kind, String name, byte[] resourceBytes) {\n+        this.kind = kind;\n+        this.name = name;\n+        if ((kind == Kind.REMOVED || kind == Kind.MODIFIED) &&\n+                resourceBytes == null) {\n+            throw new AssertionError(\"Resource bytes must be set for REMOVED or MODIFIED\");\n+        }\n+        this.resourceBytes = resourceBytes;\n+    }\n+\n+    public Kind getKind() {\n+        return kind;\n+    }\n+\n+    public byte[] getResourceBytes() {\n+        return resourceBytes;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public int compareTo(ResourceDiff o) {\n+        int kindComp = kind.value() - o.kind.value();\n+        if (kindComp == 0) {\n+            return getName().compareTo(o.getName());\n+        } else {\n+            return kindComp;\n+        }\n+    }\n+\n+    public static class Builder {\n+        private Kind kind;\n+        private String name;\n+        private byte[] resourceBytes;\n+\n+        public Builder setKind(Kind kind) {\n+            this.kind = kind;\n+            return this;\n+        }\n+        public Builder setName(String name) {\n+            this.name = Objects.requireNonNull(name);\n+            return this;\n+        }\n+        public Builder setResourceBytes(byte[] resourceBytes) {\n+            this.resourceBytes = Objects.requireNonNull(resourceBytes);\n+            return this;\n+        }\n+        public ResourceDiff build() {\n+            if (kind == null || name == null) {\n+                throw new IllegalStateException(\"kind and name must be set\");\n+            }\n+            switch (kind) {\n+            case ADDED:\n+                {\n+                    break; \/\/ null bytes for added is OK.\n+                }\n+            case MODIFIED: \/\/ fall-through\n+            case REMOVED:\n+                {\n+                    if (resourceBytes == null) {\n+                        throw new IllegalStateException(\"Original bytes needed for MODIFIED, REMOVED!\");\n+                    }\n+                    break;\n+                }\n+            default:\n+                break;\n+            }\n+            return new ResourceDiff(kind, name, resourceBytes);\n+        }\n+    }\n+\n+    \/**\n+     * Writes a list of resource diffs to an output stream\n+     *\n+     * @param diffs The list of resource diffs to write.\n+     * @param out The stream to write the serialized bytes to.\n+     *\/\n+    public static void write(List<ResourceDiff> diffs, OutputStream out) throws IOException {\n+        \/*\n+         * Simple binary format:\n+         *\n+         * <header>|<items>\n+         *\n+         * ****************************************\n+         * HEADER info\n+         * ****************************************\n+         *\n+         * where <header> is ('|' separation for clarity):\n+         *\n+         *  <int>|<int>\n+         *\n+         * The first integer is the MAGIC, 0xabba. The second integer is the\n+         * total number of items.\n+         *\n+         * *****************************************\n+         * ITEMS info\n+         * *****************************************\n+         *\n+         * Each <item> consists of ('|' separation for clarity):\n+         *\n+         * <short>|<int>|<name-bytes-utf>|<int>|<resource-bytes>\n+         *\n+         * Where the individual items are:\n+         *\n+         * <short>:\n+         *     The value of the respective ResourceDiff.Kind.\n+         * <int>:\n+         *     The length of the name bytes (in UTF-8).\n+         * <name-bytes-utf>:\n+         *     The resource name bytes in UTF-8.\n+         * <int>:\n+         *     The length of the resource bytes. 0 (zero) if no resource bytes.\n+         *     A.k.a 'null'.\n+         * <resource-bytes>:\n+         *     The bytes of the resource as stored in the jmod files.\n+         *\/\n+        try (DataOutputStream dataOut = new DataOutputStream(out)) {\n+            dataOut.writeInt(MAGIC);\n+            dataOut.writeInt(diffs.size());\n+            for (ResourceDiff d: diffs) {\n+                dataOut.writeShort(d.kind.value());\n+                byte[] buf = d.name.getBytes(StandardCharsets.UTF_8);\n+                dataOut.writeInt(buf.length);\n+                dataOut.write(buf);\n+                buf = d.resourceBytes;\n+                dataOut.writeInt(buf == null ? 0 : buf.length);\n+                if (buf != null) {\n+                    dataOut.write(buf);\n+                }\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+            throw e;\n+        }\n+    }\n+\n+    \/**\n+     * Read a list of resource diffs from an input stream.\n+     *\n+     * @param in The input stream to read from\n+     * @return The list of resource diffs.\n+     *\/\n+    public static List<ResourceDiff> read(InputStream in) throws IOException {\n+        \/*\n+         * See write() for the details how this is being written\n+         *\/\n+        List<ResourceDiff> diffs;\n+        try (DataInputStream din = new DataInputStream(in)) {\n+            int magic = din.readInt();\n+            if (magic != MAGIC) {\n+                throw new IllegalArgumentException(\"Not a ResourceDiff data stream!\");\n+            }\n+            int numItems = din.readInt();\n+            diffs = new ArrayList<>(numItems);\n+            for (int i = 0; i < numItems; i++) {\n+                Kind k = Kind.fromShort(din.readShort());\n+                int numBytes = din.readInt();\n+                byte[] buf = readNumBytesFromStream(din, numBytes);\n+                String name = new String(buf, StandardCharsets.UTF_8);\n+                numBytes = din.readInt();\n+                byte[] resBytes = null;\n+                if (numBytes != 0) {\n+                    resBytes = readNumBytesFromStream(din, numBytes);\n+                }\n+                Builder builder = new Builder();\n+                builder.setKind(k)\n+                       .setName(name);\n+                if (resBytes != null) {\n+                    builder.setResourceBytes(resBytes);\n+                }\n+                diffs.add(builder.build());\n+            }\n+        }\n+        return diffs;\n+    }\n+\n+    private static byte[] readNumBytesFromStream(DataInputStream din, int numBytes) throws IOException {\n+        byte[] b = new byte[numBytes];\n+        for (int i = 0; i < numBytes; i++) {\n+            int data = din.read();\n+            if (data == -1) {\n+                throw new IOException(\"Short read!\");\n+            }\n+            b[i] = (byte)data;\n+        }\n+        return b;\n+    }\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ResourceDiff.java","additions":270,"deletions":0,"binary":false,"changes":270,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal;\n+\n+\/**\n+ * Exception thrown for links without packaged modules. I.e. run-image link.\n+ *\n+ *\/\n+public class RuntimeImageLinkException extends IllegalStateException {\n+\n+    private static final long serialVersionUID = -1848914673073119403L;\n+\n+    private final IllegalArgumentException iae;\n+\n+    public RuntimeImageLinkException(IllegalArgumentException cause) {\n+        super(cause);\n+        this.iae = cause;\n+    }\n+\n+    public IllegalArgumentException getReason() {\n+        return iae;\n+    }\n+\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/RuntimeImageLinkException.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal.plugins;\n+\n+import static jdk.tools.jlink.internal.JlinkTask.DIFF_PATTERN;\n+import static jdk.tools.jlink.internal.JlinkTask.RESPATH_PATTERN;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import jdk.tools.jlink.internal.JRTArchive;\n+import jdk.tools.jlink.internal.Platform;\n+import jdk.tools.jlink.internal.ResourceDiff;\n+import jdk.tools.jlink.plugin.ResourcePool;\n+import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n+import jdk.tools.jlink.plugin.ResourcePoolEntry;\n+import jdk.tools.jlink.plugin.ResourcePoolModule;\n+\n+\n+\/**\n+ * Plugin to produce a runtime-linkable JDK image. It does the following:\n+ *\n+ * <ul>\n+ * <li>\n+ * It tracks resources per module and saves the list in 'fs_$M_files' in the\n+ * jdk.jlink module.\n+ * <\/li>\n+ * <li>\n+ * It adds a serialized resource diff to the jdk.jlink module so as to be able\n+ * to reconstruct the packaged modules equivalent view when performing runtime\n+ * links.\n+ * <\/li>\n+ * <\/ul>\n+ *\/\n+public final class CreateLinkableRuntimePlugin extends AbstractPlugin {\n+    private static final String PLUGIN_NAME = \"create-linkable-runtime\";\n+    private static final String JLINK_MOD_NAME = \"jdk.jlink\";\n+    \/\/ This resource is being used in JLinkTask which passes its contents to\n+    \/\/ JRTArchive for further processing.\n+    private static final String RESPATH = \"\/\" + JLINK_MOD_NAME + \"\/\" + RESPATH_PATTERN;\n+    private static final String DIFF_PATH = \"\/\" + JLINK_MOD_NAME + \"\/\" + DIFF_PATTERN;\n+    private static final byte[] EMPTY_RESOURCE_BYTES = new byte[] {};\n+\n+    private final Map<String, List<String>> nonClassResEntries;\n+    private String diffFile;\n+\n+    public CreateLinkableRuntimePlugin() {\n+        super(PLUGIN_NAME);\n+        this.nonClassResEntries = new ConcurrentHashMap<>();\n+    }\n+\n+    @Override\n+    public void configure(Map<String, String> config) {\n+        String v = config.get(PLUGIN_NAME);\n+        if (v == null)\n+            throw new AssertionError();\n+        diffFile = v;\n+    }\n+\n+    @Override\n+    public ResourcePool transform(ResourcePool in, ResourcePoolBuilder out) {\n+        \/\/ Only add resources if we have the jdk.jlink module part of the\n+        \/\/ link.\n+        Optional<ResourcePoolModule> jdkJlink = in.moduleView().findModule(JLINK_MOD_NAME);\n+        if (jdkJlink.isPresent()) {\n+            Platform targetPlatform = getTargetPlatform(in);\n+            in.transformAndCopy(e -> recordAndFilterEntry(e, targetPlatform), out);\n+            addModuleResourceEntries(in, out);\n+            addResourceDiffFiles(in, out);\n+        } else {\n+            throw new IllegalStateException(\"jdk.jlink module not in list of modules for target image\");\n+        }\n+        return out.build();\n+    }\n+\n+    private void addResourceDiffFiles(ResourcePool in, ResourcePoolBuilder out) {\n+        Map<String, List<ResourceDiff>> diffs = readResourceDiffs();\n+        \/\/ Create a resource file with the delta to the packaged-modules view\n+        in.moduleView().modules().forEach(m -> {\n+            String modName = m.descriptor().name();\n+            String resFile = String.format(DIFF_PATH, modName);\n+            List<ResourceDiff> perModDiff = diffs.get(modName);\n+            \/\/ Not every module will have a diff\n+            if (perModDiff == null) {\n+                perModDiff = Collections.emptyList();\n+            }\n+            ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+            try {\n+                ResourceDiff.write(perModDiff, bout);\n+            } catch (IOException e) {\n+                throw new IllegalStateException(\"Failed to write per module diff\");\n+            }\n+            out.add(ResourcePoolEntry.create(resFile, bout.toByteArray()));\n+        });\n+    }\n+\n+    private Map<String, List<ResourceDiff>> readResourceDiffs() {\n+        List<ResourceDiff> resDiffs = null;\n+        try (FileInputStream fin = new FileInputStream(new File(diffFile))) {\n+            resDiffs = ResourceDiff.read(fin);\n+        } catch (IOException e) {\n+            throw new IllegalStateException(\"Failed to read resource diff file: \" + diffFile);\n+        }\n+        Map<String, List<ResourceDiff>> modToDiff = new HashMap<>();\n+        resDiffs.forEach(d -> {\n+            int secondSlash = d.getName().indexOf(\"\/\", 1);\n+            if (secondSlash == -1) {\n+                throw new AssertionError(\"Module name not present\");\n+            }\n+            String module = d.getName().substring(1, secondSlash);\n+            List<ResourceDiff> perModDiff = modToDiff.computeIfAbsent(module, a -> new ArrayList<>());\n+            perModDiff.add(d);\n+        });\n+        return modToDiff;\n+    }\n+\n+    private Platform getTargetPlatform(ResourcePool in) {\n+        String platform = in.moduleView().findModule(\"java.base\")\n+                .map(ResourcePoolModule::targetPlatform)\n+                .orElseThrow(() -> new AssertionError(\"java.base not found\"));\n+        return Platform.parsePlatform(platform);\n+    }\n+\n+    private void addModuleResourceEntries(ResourcePool in, ResourcePoolBuilder out) {\n+        Set<String> inputModules = in.moduleView().modules()\n+                                                  .map(rm -> rm.name())\n+                                                  .collect(Collectors.toSet());\n+        inputModules.stream().sorted().forEach(module -> {\n+            String mResource = String.format(RESPATH, module);\n+            List<String> mResources = nonClassResEntries.get(module);\n+            if (mResources == null) {\n+                \/\/ We create empty resource files for modules in the resource\n+                \/\/ pool view, but which don't themselves contain native resources\n+                \/\/ or config files.\n+                out.add(ResourcePoolEntry.create(mResource, EMPTY_RESOURCE_BYTES));\n+            } else {\n+                String mResContent = mResources.stream().sorted()\n+                                               .collect(Collectors.joining(\"\\n\"));\n+                out.add(ResourcePoolEntry.create(mResource, mResContent.getBytes(StandardCharsets.UTF_8)));\n+            }\n+        });\n+    }\n+\n+    private ResourcePoolEntry recordAndFilterEntry(ResourcePoolEntry entry, Platform platform) {\n+        \/\/ Note that the jmod_resources file is a resource file, so we cannot\n+        \/\/ add ourselves due to this condition. However, we want to not add\n+        \/\/ an old version of the resource file again.\n+        if (entry.type() != ResourcePoolEntry.Type.CLASS_OR_RESOURCE) {\n+            if (entry.type() == ResourcePoolEntry.Type.TOP) {\n+                return entry; \/\/ Handled by ReleaseInfoPlugin, nothing to do\n+            }\n+            List<String> moduleResources = nonClassResEntries.computeIfAbsent(entry.moduleName(), a -> new ArrayList<>());\n+\n+            JRTArchive.ResourceFileEntry rfEntry = JRTArchive.ResourceFileEntry.toResourceFileEntry(entry, platform);\n+            moduleResources.add(rfEntry.encodeToString());\n+        }\n+        return entry;\n+    }\n+\n+    @Override\n+    public Set<State> getState() {\n+        return EnumSet.of(State.FUNCTIONAL);\n+    }\n+\n+    @Override\n+    public boolean hasArguments() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Category getType() {\n+        \/\/ Ensure we run in a later stage as we need to generate\n+        \/\/ SHA-512 sums for non-(class\/resource) files. The fs_$module_files\n+        \/\/ files can be considered meta-info describing the universe we\n+        \/\/ draft from (together with the jimage and respective diff_$module files).\n+        return Category.METAINFO_ADDER;\n+    }\n+}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/CreateLinkableRuntimePlugin.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n-import java.io.InputStream;\n@@ -29,0 +28,1 @@\n+import java.io.InputStream;\n@@ -71,1 +71,15 @@\n-        TOP\n+        TOP;\n+\n+        public static Type fromOrdinal(int value) {\n+            Type retval = null;\n+            for (Type v: Type.values()) {\n+                if (v.ordinal() == value) {\n+                    retval = v;\n+                    break;\n+                }\n+            }\n+            if (retval == null) {\n+                throw new IllegalArgumentException(\"Illegal ordinal: \" + value);\n+            }\n+            return retval;\n+        }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/plugin\/ResourcePoolEntry.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -118,0 +118,3 @@\n+err.runtime.link.not.linkable.runtime=The current run-time image does not support run-time linking.\n+err.runtime.link.jdk.jlink.prohibited=Including jdk.jlink module for run-time image based links is not allowed.\n+err.runtime.link.packaged.mods=--keep-packaged-modules is not allowed for run-time image based links.\n@@ -160,0 +163,3 @@\n+\n+runtime.link.info=Linking based on the current run-time image.\n+runtime.link.jprt.path.extra=(run-time image)\n\\ No newline at end of file\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -210,0 +210,8 @@\n+add-run-image-resources.description=\\\n+Add a resource file that is later used for run image-based links\n+\n+add-run-image-resources.usage=\\\n+\\  --add-run-image-resources   Add a resource file, ''\/<module-name>\/runimage_resources'', listing\\n\\\n+\\                              all resource files other than classes\/resources within it. This\\n\\\n+\\                              plugin is required for run-image-based links.\n+\n@@ -246,0 +254,13 @@\n+create-linkable-runtime.argument=<path\/to\/jimage-vs-packaged-modules-diff>\n+\n+create-linkable-runtime.description=\\\n+Create a linkable run-time image given a serialized diff file (as compared to\\n\\\n+the contents - classes and resources - of the packaged modules).\n+\n+create-linkable-runtime.usage=\\\n+\\  --create-linkable-runtime <path\/to\/jimage-vs-packaged-modules-diff>\\n\\\n+\\                            Creates a linkable run-time image so that \\n\\\n+\\                            the current jimage (which includes jdk.jlink)\\n\\\n+\\                            together with natives from the filesystem\\n\\\n+\\                            can be used to create derivative images.\\n\\\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/plugins.properties","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+        jdk.tools.jlink.internal.plugins.CreateLinkableRuntimePlugin,\n","filename":"src\/jdk.jlink\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -90,1 +90,2 @@\n-    jdk.containerized\n+    jdk.containerized \\\n+    jlink.runtime.linkable\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -105,1 +105,2 @@\n-    jdk.foreign.linker\n+    jdk.foreign.linker \\\n+    jlink.runtime.linkable\n","filename":"test\/jdk\/TEST.ROOT","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.nio.ByteOrder;\n@@ -41,2 +40,1 @@\n-import jdk.tools.jlink.internal.Jlink;\n-import jdk.tools.jlink.internal.JlinkTask;\n+\n@@ -44,4 +42,0 @@\n-import jdk.tools.jlink.internal.Platform;\n-import jdk.tools.jlink.plugin.ResourcePool;\n-import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n-import jdk.tools.jlink.plugin.Plugin;\n@@ -49,0 +43,1 @@\n+import jdk.tools.jlink.internal.Jlink;\n@@ -51,0 +46,2 @@\n+import jdk.tools.jlink.internal.JlinkTask;\n+import jdk.tools.jlink.internal.Platform;\n@@ -52,3 +49,3 @@\n-import jdk.tools.jlink.internal.plugins.DefaultCompressPlugin;\n-import jdk.tools.jlink.internal.plugins.DefaultStripDebugPlugin;\n-\n+import jdk.tools.jlink.plugin.Plugin;\n+import jdk.tools.jlink.plugin.ResourcePool;\n+import jdk.tools.jlink.plugin.ResourcePoolBuilder;\n@@ -165,1 +162,1 @@\n-                JlinkTask.newModuleFinder(modulePaths, limits, mods));\n+                JlinkTask.newModuleFinder(modulePaths, limits, mods), false, true);\n","filename":"test\/jdk\/tools\/jlink\/IntegrationTest.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,540 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Scanner;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import tests.Helper;\n+import tests.JImageValidator;\n+\n+public abstract class AbstractLinkableRuntimeTest {\n+\n+    protected static final boolean DEBUG = true;\n+\n+    public void run() throws Exception {\n+        Helper helper = Helper.newHelper();\n+        if (helper == null) {\n+            System.err.println(\"Test not run\");\n+            return;\n+        }\n+        runTest(helper);\n+        System.out.println(getClass().getSimpleName() + \" PASSED!\");\n+    }\n+\n+    \/** main test entrypoint **\/\n+    abstract void runTest(Helper helper) throws Exception;\n+\n+    \/**\n+     * Ensure 'java --list-modules' lists the correct set of modules in the given\n+     * image.\n+     *\n+     * @param jlinkImage\n+     * @param expectedModules\n+     *\/\n+    protected void verifyListModules(Path image,\n+            List<String> expectedModules) throws Exception {\n+        OutputAnalyzer out = runJavaCmd(image, List.of(\"--list-modules\"));\n+        List<String> actual = parseListMods(out.getStdout());\n+        Collections.sort(actual);\n+        if (!expectedModules.equals(actual)) {\n+            throw new AssertionError(\"Different modules! Expected \" + expectedModules + \" got: \" + actual);\n+        }\n+    }\n+\n+    protected OutputAnalyzer runJavaCmd(Path image, List<String> options) throws Exception {\n+        Path targetJava = image.resolve(\"bin\").resolve(getJava());\n+        List<String> cmd = new ArrayList<>();\n+        cmd.add(targetJava.toString());\n+        for (String opt: options) {\n+            cmd.add(opt);\n+        }\n+        List<String> javaCmd = Collections.unmodifiableList(cmd);\n+        OutputAnalyzer out;\n+        try {\n+            out = ProcessTools.executeCommand(javaCmd.toArray(new String[0]));\n+        } catch (Throwable e) {\n+            throw new Exception(\"Process failed to execute\", e);\n+        }\n+        if (out.getExitValue() != 0) {\n+            if (DEBUG) {\n+                System.err.println(\"Process stdout was: \");\n+                System.err.println(out.getStdout());\n+                System.err.println(\"Process stderr was: \");\n+                System.err.println(out.getStderr());\n+            }\n+            throw new AssertionError(\"'\" + javaCmd.stream().collect(Collectors.joining(\" \")) + \"'\"\n+                    + \" expected to succeed!\");\n+        }\n+        return out;\n+    }\n+\n+    protected Path createJavaImageRuntimeLink(BaseJlinkSpec baseSpec) throws Exception {\n+        \/\/ create a base image only containing the jdk.jlink module and its transitive closure\n+        Path runtimeJlinkImage = createRuntimeLinkImage(baseSpec);\n+\n+        \/\/ On Windows jvm.dll is in 'bin' after the jlink\n+        Path libjvm = Path.of((isWindows() ? \"bin\" : \"lib\"), \"server\", System.mapLibraryName(\"jvm\"));\n+        JlinkSpecBuilder builder = new JlinkSpecBuilder();\n+        \/\/ And expect libjvm (not part of the jimage) to be present in the resulting image\n+        builder.expectedFile(libjvm.toString())\n+               .helper(baseSpec.getHelper())\n+               .name(baseSpec.getName())\n+               .validatingModule(baseSpec.getValidatingModule())\n+               .imagePath(runtimeJlinkImage)\n+               .expectedLocation(\"\/java.base\/java\/lang\/String.class\");\n+        for (String m: baseSpec.getModules()) {\n+            builder.addModule(m);\n+        }\n+        for (String extra: baseSpec.getExtraOptions()) {\n+            builder.extraJlinkOpt(extra);\n+        }\n+        return jlinkUsingImage(builder.build());\n+    }\n+\n+    protected Path jlinkUsingImage(JlinkSpec spec) throws Exception {\n+        return jlinkUsingImage(spec, new RuntimeLinkOutputAnalyzerHandler());\n+    }\n+\n+    protected Path jlinkUsingImage(JlinkSpec spec, OutputAnalyzerHandler handler) throws Exception {\n+        return jlinkUsingImage(spec, handler, new DefaultSuccessExitPredicate());\n+    }\n+\n+    protected Path jlinkUsingImage(JlinkSpec spec, OutputAnalyzerHandler handler, Predicate<OutputAnalyzer> exitChecker) throws Exception {\n+        String jmodLessGeneratedImage = \"target-jmodless-\" + spec.getName();\n+        Path targetImageDir = spec.getHelper().createNewImageDir(jmodLessGeneratedImage);\n+        Path targetJlink = spec.getImageToUse().resolve(\"bin\").resolve(getJlink());\n+        String[] jlinkCmdArray = new String[] {\n+                targetJlink.toString(),\n+                \"--output\", targetImageDir.toString(),\n+                \"--verbose\",\n+                \"--add-modules\", spec.getModules().stream().collect(Collectors.joining(\",\"))\n+        };\n+        List<String> jlinkCmd = new ArrayList<>();\n+        jlinkCmd.addAll(Arrays.asList(jlinkCmdArray));\n+        if (spec.getExtraJlinkOpts() != null && !spec.getExtraJlinkOpts().isEmpty()) {\n+            jlinkCmd.addAll(spec.getExtraJlinkOpts());\n+        }\n+        if (spec.getModulePath() != null) {\n+            for (String mp: spec.getModulePath()) {\n+                jlinkCmd.add(\"--module-path\");\n+                jlinkCmd.add(mp);\n+            }\n+        }\n+        jlinkCmd = Collections.unmodifiableList(jlinkCmd); \/\/ freeze\n+        System.out.println(\"DEBUG: jmod-less jlink command: \" + jlinkCmd.stream().collect(\n+                                                    Collectors.joining(\" \")));\n+        OutputAnalyzer analyzer = null;\n+        try {\n+            analyzer = ProcessTools.executeProcess(jlinkCmd.toArray(new String[0]));\n+        } catch (Throwable t) {\n+            throw new AssertionError(\"Executing process failed!\", t);\n+        }\n+        if (!exitChecker.test(analyzer)) {\n+            if (DEBUG) {\n+                System.err.println(\"Process stdout was: \");\n+                System.err.println(analyzer.getStdout());\n+                System.err.println(\"Process stderr was: \");\n+                System.err.println(analyzer.getStderr());\n+            }\n+            \/\/ if the exit checker failed, we expected the other outcome\n+            \/\/ i.e. fail for success and success for fail.\n+            boolean successExit = analyzer.getExitValue() == 0;\n+            String msg = String.format(\"Expected jlink to %s given a jmodless image. Exit code was: %d\",\n+                                       (successExit ? \"fail\" : \"pass\"), analyzer.getExitValue());\n+            throw new AssertionError(msg);\n+        }\n+        handler.handleAnalyzer(analyzer); \/\/ Give tests a chance to process in\/output\n+\n+        \/\/ validate the resulting image; Includes running 'java -version', only do this\n+        \/\/ if the jlink succeeded.\n+        if (analyzer.getExitValue() == 0) {\n+            JImageValidator validator = new JImageValidator(spec.getValidatingModule(), spec.getExpectedLocations(),\n+                    targetImageDir.toFile(), spec.getUnexpectedLocations(), Collections.emptyList(), spec.getExpectedFiles());\n+            validator.validate(); \/\/ This doesn't validate locations\n+            if (!spec.getExpectedLocations().isEmpty() || !spec.getUnexpectedLocations().isEmpty()) {\n+                JImageValidator.validate(targetImageDir.resolve(\"lib\").resolve(\"modules\"), spec.getExpectedLocations(), spec.getUnexpectedLocations());\n+            }\n+        }\n+        return targetImageDir;\n+    }\n+\n+    \/**\n+     * Prepares the test for execution. This assumes the current jimage is\n+     * runtime-linkable. However, since the 'jmods' dir is present (default jmods\n+     * module path), it needs to get removed to provoke a runtime link.\n+     *\n+     * @param baseSpec\n+     * @return A path to a JDK image which is prepared for runtime linking.\n+     * @throws Exception\n+     *\/\n+    protected Path createRuntimeLinkImage(BaseJlinkSpec baseSpec) throws Exception {\n+        Path runtimeJlinkImage = baseSpec.getHelper().createNewImageDir(baseSpec.getName() + \"-jlink\");\n+        copyJDKTreeWithoutJmods(runtimeJlinkImage);\n+        \/\/ Verify the base image is actually without packaged modules\n+        if (Files.exists(runtimeJlinkImage.resolve(\"jmods\"))) {\n+            throw new AssertionError(\"Must not contain 'jmods' directory\");\n+        }\n+        return runtimeJlinkImage;\n+    }\n+\n+    private void copyJDKTreeWithoutJmods(Path runtimeJlinkImage) throws Exception {\n+        Files.createDirectory(runtimeJlinkImage);\n+        String javaHome = System.getProperty(\"java.home\");\n+        Path root = Path.of(javaHome);\n+        Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+            @Override\n+            public FileVisitResult preVisitDirectory(Path dir,\n+                    BasicFileAttributes attrs) throws IOException {\n+                Objects.requireNonNull(dir);\n+                Path relative = root.relativize(dir);\n+                if (relative.getFileName().equals(Path.of(\"jmods\"))) {\n+                    return FileVisitResult.SKIP_SUBTREE;\n+                }\n+                \/\/ Create dir in destination location\n+                Path targetDir = runtimeJlinkImage.resolve(relative);\n+                if (!Files.exists(targetDir)) {\n+                    Files.createDirectory(targetDir);\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n+                    throws IOException {\n+                Path relative = root.relativize(file);\n+                Files.copy(file, runtimeJlinkImage.resolve(relative), StandardCopyOption.REPLACE_EXISTING);\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+\n+    }\n+\n+    private List<String> parseListMods(String output) throws Exception {\n+        List<String> outputLines = new ArrayList<>();\n+        try (Scanner lineScan = new Scanner(output)) {\n+            while (lineScan.hasNextLine()) {\n+                outputLines.add(lineScan.nextLine());\n+            }\n+        }\n+        return outputLines.stream()\n+                .map(a -> { return a.split(\"@\", 2)[0];})\n+                .filter(a -> !a.isBlank())\n+                .collect(Collectors.toList());\n+    }\n+\n+    private String getJlink() {\n+        return getBinary(\"jlink\");\n+    }\n+\n+    private String getJava() {\n+        return getBinary(\"java\");\n+    }\n+\n+    private String getBinary(String binary) {\n+        return isWindows() ? binary + \".exe\" : binary;\n+    }\n+\n+    protected static boolean isWindows() {\n+        return System.getProperty(\"os.name\").startsWith(\"Windows\");\n+    }\n+\n+    static class BaseJlinkSpec {\n+        final Helper helper;\n+        final String name;\n+        final String validatingModule;\n+        final List<String> modules;\n+        final List<String> extraOptions;\n+\n+        BaseJlinkSpec(Helper helper, String name, String validatingModule,\n+                List<String> modules, List<String> extraOptions) {\n+            this.helper = helper;\n+            this.name = name;\n+            this.modules = modules;\n+            this.extraOptions = extraOptions;\n+            this.validatingModule = validatingModule;\n+        }\n+\n+        public String getValidatingModule() {\n+            return validatingModule;\n+        }\n+\n+        public Helper getHelper() {\n+            return helper;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public List<String> getModules() {\n+            return modules;\n+        }\n+\n+        public List<String> getExtraOptions() {\n+            return extraOptions;\n+        }\n+    }\n+\n+    static class BaseJlinkSpecBuilder {\n+        Helper helper;\n+        String name;\n+        String validatingModule;\n+        List<String> modules = new ArrayList<>();\n+        List<String> extraOptions = new ArrayList<>();\n+\n+        BaseJlinkSpecBuilder addModule(String module) {\n+            modules.add(module);\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder addExtraOption(String option) {\n+            extraOptions.add(option);\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder helper(Helper helper) {\n+            this.helper = helper;\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder name(String name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        BaseJlinkSpecBuilder validatingModule(String module) {\n+            this.validatingModule = module;\n+            return this;\n+        }\n+\n+        BaseJlinkSpec build() {\n+            if (name == null) {\n+                throw new IllegalStateException(\"Name must be set\");\n+            }\n+            if (helper == null) {\n+                throw new IllegalStateException(\"helper must be set\");\n+            }\n+            if (validatingModule == null) {\n+                throw new IllegalStateException(\"the module which should get validated must be set\");\n+            }\n+            return new BaseJlinkSpec(helper, name, validatingModule, modules, extraOptions);\n+        }\n+    }\n+\n+    static class JlinkSpec {\n+        final Path imageToUse;\n+        final Helper helper;\n+        final String name;\n+        final List<String> modules;\n+        final String validatingModule;\n+        final List<String> expectedLocations;\n+        final List<String> unexpectedLocations;\n+        final String[] expectedFiles;\n+        final List<String> extraJlinkOpts;\n+        final List<String> modulePath;\n+\n+        JlinkSpec(Path imageToUse, Helper helper, String name, List<String> modules,\n+                String validatingModule, List<String> expectedLocations,\n+                List<String> unexpectedLocations, String[] expectedFiles,\n+                List<String> extraJlinkOpts,\n+                List<String> modulePath) {\n+            this.imageToUse = imageToUse;\n+            this.helper = helper;\n+            this.name = name;\n+            this.modules = modules;\n+            this.validatingModule = validatingModule;\n+            this.expectedLocations = expectedLocations;\n+            this.unexpectedLocations = unexpectedLocations;\n+            this.expectedFiles = expectedFiles;\n+            this.extraJlinkOpts = extraJlinkOpts;\n+            this.modulePath = modulePath;\n+        }\n+\n+        public Path getImageToUse() {\n+            return imageToUse;\n+        }\n+\n+        public Helper getHelper() {\n+            return helper;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public List<String> getModules() {\n+            return modules;\n+        }\n+\n+        public String getValidatingModule() {\n+            return validatingModule;\n+        }\n+\n+        public List<String> getExpectedLocations() {\n+            return expectedLocations;\n+        }\n+\n+        public List<String> getUnexpectedLocations() {\n+            return unexpectedLocations;\n+        }\n+\n+        public String[] getExpectedFiles() {\n+            return expectedFiles;\n+        }\n+\n+        public List<String> getExtraJlinkOpts() {\n+            return extraJlinkOpts;\n+        }\n+\n+        public List<String> getModulePath() {\n+            return modulePath;\n+        }\n+    }\n+\n+    static class JlinkSpecBuilder {\n+        Path imageToUse;\n+        Helper helper;\n+        String name;\n+        List<String> modules = new ArrayList<>();\n+        String validatingModule;\n+        List<String> expectedLocations = new ArrayList<>();\n+        List<String> unexpectedLocations = new ArrayList<>();\n+        List<String> expectedFiles = new ArrayList<>();\n+        List<String> extraJlinkOpts = new ArrayList<>();\n+        List<String> modulePath = new ArrayList<>();\n+\n+        JlinkSpec build() {\n+            if (imageToUse == null) {\n+                throw new IllegalStateException(\"No image to use for jlink specified!\");\n+            }\n+            if (helper == null) {\n+                throw new IllegalStateException(\"No helper specified!\");\n+            }\n+            if (name == null) {\n+                throw new IllegalStateException(\"No name for the image location specified!\");\n+            }\n+            if (validatingModule == null) {\n+                throw new IllegalStateException(\"No module specified for after generation validation!\");\n+            }\n+            return new JlinkSpec(imageToUse,\n+                                 helper,\n+                                 name,\n+                                 modules,\n+                                 validatingModule,\n+                                 expectedLocations,\n+                                 unexpectedLocations,\n+                                 expectedFiles.toArray(new String[0]),\n+                                 extraJlinkOpts,\n+                                 modulePath);\n+        }\n+\n+        JlinkSpecBuilder imagePath(Path image) {\n+            this.imageToUse = image;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder helper(Helper helper) {\n+            this.helper = helper;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder name(String name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder addModule(String module) {\n+            modules.add(module);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder validatingModule(String module) {\n+            this.validatingModule = module;\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder addModulePath(String modulePath) {\n+            this.modulePath.add(modulePath);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder expectedLocation(String location) {\n+            expectedLocations.add(location);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder unexpectedLocation(String location) {\n+            unexpectedLocations.add(location);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder expectedFile(String file) {\n+            expectedFiles.add(file);\n+            return this;\n+        }\n+\n+        JlinkSpecBuilder extraJlinkOpt(String opt) {\n+            extraJlinkOpts.add(opt);\n+            return this;\n+        }\n+    }\n+\n+    static abstract class OutputAnalyzerHandler {\n+\n+        public abstract void handleAnalyzer(OutputAnalyzer out);\n+\n+    }\n+\n+    static class RuntimeLinkOutputAnalyzerHandler extends OutputAnalyzerHandler {\n+\n+        @Override\n+        public void handleAnalyzer(OutputAnalyzer out) {\n+            out.shouldContain(\"Linking based on the current run-time image.\");\n+        }\n+\n+    }\n+\n+    static class DefaultSuccessExitPredicate implements Predicate<OutputAnalyzer> {\n+\n+        @Override\n+        public boolean test(OutputAnalyzer t) {\n+            return t.getExitValue() == 0;\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/AbstractLinkableRuntimeTest.java","additions":540,"deletions":0,"binary":false,"changes":540,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Scanner;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Test --add-options jlink plugin in runtime image link mode\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g AddOptionsTest\n+ *\/\n+public class AddOptionsTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        AddOptionsTest test = new AddOptionsTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        Path finalImage = createJavaImageRuntimeLink(new BaseJlinkSpecBuilder()\n+                .addExtraOption(\"--add-options\")\n+                .addExtraOption(\"-Xlog:gc=info:stderr -XX:+UseParallelGC\")\n+                .name(\"java-base-with-opts\")\n+                .addModule(\"java.base\")\n+                .validatingModule(\"java.base\")\n+                .helper(helper)\n+                .build());\n+        verifyListModules(finalImage, List.of(\"java.base\"));\n+        verifyParallelGCInUse(finalImage);\n+    }\n+\n+    private void verifyParallelGCInUse(Path finalImage) throws Exception {\n+        OutputAnalyzer analyzer = runJavaCmd(finalImage, List.of(\"--version\"));\n+        boolean foundMatch = false;\n+        try (Scanner lineScan = new Scanner(analyzer.getStderr())) {\n+            while (lineScan.hasNextLine()) {\n+                String line = lineScan.nextLine();\n+                if (line.endsWith(\"Using Parallel\")) {\n+                    foundMatch = true;\n+                    break;\n+                }\n+            }\n+        }\n+        if (!foundMatch) {\n+            throw new AssertionError(\"Expected Parallel GC in place for jlinked image\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/AddOptionsTest.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test\n+ * @summary Test basic runtime-image-based jlinking\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g BasicJlinkTest\n+ *\/\n+public class BasicJlinkTest extends AbstractLinkableRuntimeTest {\n+\n+    @Override\n+    public void runTest(Helper helper) throws Exception {\n+        Path finalImage = createJavaBaseRuntimeLink(helper, \"java-base\");\n+        verifyListModules(finalImage, List.of(\"java.base\"));\n+    }\n+\n+    private Path createJavaBaseRuntimeLink(Helper helper, String name) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder();\n+        builder.helper(helper)\n+               .name(name)\n+               .addModule(\"java.base\")\n+               .validatingModule(\"java.base\");\n+        return createJavaImageRuntimeLink(builder.build());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        BasicJlinkTest test = new BasicJlinkTest();\n+        test.run();\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/BasicJlinkTest.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+class CapturingHandler extends AbstractLinkableRuntimeTest.OutputAnalyzerHandler {\n+\n+    private OutputAnalyzer output;\n+\n+    public String stdErr() {\n+        return output.getStderr();\n+    }\n+\n+    public OutputAnalyzer analyzer() {\n+        return output;\n+    }\n+\n+    @Override\n+    public void handleAnalyzer(OutputAnalyzer out) {\n+        this.output = out;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/CapturingHandler.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import tests.Helper;\n+\n+\n+\/*\n+ * @test\n+ * @summary Test jmod-less jlink with a custom module\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g CustomModuleJlinkTest\n+ *\/\n+public class CustomModuleJlinkTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        CustomModuleJlinkTest test = new CustomModuleJlinkTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        String customModule = \"leaf1\";\n+        helper.generateDefaultJModule(customModule);\n+\n+        \/\/ create a base image for runtime linking\n+        Path jlinkImage = createRuntimeLinkImage(new BaseJlinkSpecBuilder()\n+                                                    .helper(helper)\n+                                                    .name(\"cmod-jlink\")\n+                                                    .addModule(\"java.base\")\n+                                                    .validatingModule(\"java.base\")\n+                                                    .build());\n+\n+        \/\/ Next jlink using the current runtime image for java.base, but take\n+        \/\/ the custom module from the module path.\n+        Path finalImage = jlinkUsingImage(new JlinkSpecBuilder()\n+                                                .imagePath(jlinkImage)\n+                                                .helper(helper)\n+                                                .name(customModule)\n+                                                .addModulePath(helper.defaultModulePath(false))\n+                                                .expectedLocation(String.format(\"\/%s\/%s\/com\/foo\/bar\/X.class\", customModule, customModule))\n+                                                .addModule(customModule)\n+                                                .validatingModule(customModule)\n+                                                .build());\n+        \/\/ Expected only the transitive closure of \"leaf1\" module in the --list-modules\n+        \/\/ output of the java launcher.\n+        List<String> expectedModules = List.of(\"java.base\", customModule);\n+        verifyListModules(finalImage, expectedModules);\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/CustomModuleJlinkTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Verify JLI class generation in run-time image link mode\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g GenerateJLIClassesTest\n+ *\/\n+public class GenerateJLIClassesTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        GenerateJLIClassesTest test = new GenerateJLIClassesTest();\n+        test.run();\n+    }\n+\n+    \/*\n+     * java.lang.invoke.BoundMethodHandle$Species_* classes get generated\n+     * by the GenerateJLiClassesPlugin. This test ensures that potentially\n+     * generated JLI classes from the run-time image don't populate to the\n+     * target image in the run-time image based link mode.\n+     *\/\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        Path baseFile = Files.createTempFile(\"base\", \"trace\");\n+        String species = \"LLLLLLLLLLLLLLLLLLL\";\n+        String fileString = \"[SPECIES_RESOLVE] java.lang.invoke.BoundMethodHandle$Species_\" + species + \" (salvaged)\\n\";\n+        Files.write(baseFile, fileString.getBytes(StandardCharsets.UTF_8));\n+        Path runtimeLinkableImage = createRuntimeLinkImage(new BaseJlinkSpecBuilder()\n+                                                            .helper(helper)\n+                                                            .name(\"jlink.jli-jmodless\")\n+                                                            .validatingModule(\"java.base\")\n+                                                            .build());\n+        \/\/ Finally attempt another jmodless link reducing modules to java.base only,\n+        \/\/ and asking for specific jli classes.\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(runtimeLinkableImage)\n+                                .name(\"java.base-jli-derived\")\n+                                .addModule(\"java.base\")\n+                                .extraJlinkOpt(\"--generate-jli-classes=@\" + baseFile.toString())\n+                                .expectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_\" + species + \".class\")\n+                                .expectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_L.class\")\n+                                .unexpectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_\" + species.substring(1) + \".class\")\n+                                .unexpectedLocation(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LL.class\")\n+                                .validatingModule(\"java.base\")\n+                                .build());\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/GenerateJLIClassesTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Test reproducibility of runtime image based jlink of java.se\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g JavaSEReproducibleTest\n+ *\/\n+public class JavaSEReproducibleTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        JavaSEReproducibleTest test = new JavaSEReproducibleTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        String javaSeModule = \"java.se\";\n+        \/\/ create a java.se using jmod-less approach\n+        Path javaSEJmodLess1 = createJavaImageRuntimeLink(new BaseJlinkSpecBuilder()\n+                                                                   .helper(helper)\n+                                                                   .name(\"java-se-repro1\")\n+                                                                   .addModule(javaSeModule)\n+                                                                   .validatingModule(javaSeModule)\n+                                                                   .build());\n+\n+        \/\/ create another java.se version using jmod-less approach\n+        Path javaSEJmodLess2 = createJavaImageRuntimeLink(new BaseJlinkSpecBuilder()\n+                                                                   .helper(helper)\n+                                                                   .name(\"java-se-repro2\")\n+                                                                   .addModule(javaSeModule)\n+                                                                   .validatingModule(javaSeModule)\n+                                                                   .build());\n+        if (Files.mismatch(javaSEJmodLess1.resolve(\"lib\").resolve(\"modules\"),\n+                           javaSEJmodLess2.resolve(\"lib\").resolve(\"modules\")) != -1L) {\n+            throw new RuntimeException(\"jlink producing inconsistent result for \" + javaSeModule + \" (jmod-less)\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/JavaSEReproducibleTest.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Verify jlink fails by default when jlinking in runtime-image-based mode\n+ *          and files have been changed\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g ModifiedFilesExitTest\n+ *\/\n+public class ModifiedFilesExitTest extends ModifiedFilesTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        ModifiedFilesExitTest test = new ModifiedFilesExitTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    String initialImageName() {\n+        return \"java-base-jlink-with-mod-exit\";\n+    }\n+\n+    @Override\n+    void testAndAssert(Path modifiedFile, Helper helper, Path initialImage)\n+            throws Exception {\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer t) {\n+                return t.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(initialImage)\n+                                .name(\"java-base-jlink-with-mod-exit-target\")\n+                                .addModule(\"java.base\")\n+                                .validatingModule(\"java.base\")\n+                                .build(), handler, exitFailPred);\n+        OutputAnalyzer analyzer = handler.analyzer();\n+        if (analyzer.getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to fail due to modified file!\");\n+        }\n+        analyzer.stdoutShouldContain(modifiedFile.toString() + \" has been modified\");\n+        \/\/ Verify the error message is reasonable\n+        analyzer.stdoutShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n+        analyzer.stdoutShouldNotContain(\"java.lang.IllegalArgumentException\");\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesExitTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Properties;\n+\n+import tests.Helper;\n+\n+public abstract class ModifiedFilesTest extends AbstractLinkableRuntimeTest {\n+\n+    abstract String initialImageName();\n+    abstract void testAndAssert(Path modifiedFile, Helper helper, Path initialImage) throws Exception;\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        Path initialImage = createRuntimeLinkImage(new BaseJlinkSpecBuilder()\n+                \/\/.name(\"java-base-jlink-with-mod\")\n+                .name(initialImageName())\n+                .addModule(\"java.base\")\n+                .validatingModule(\"java.base\")\n+                .helper(helper)\n+                .build());\n+\n+        Path netPropertiesFile = modifyFileInImage(initialImage);\n+\n+        testAndAssert(netPropertiesFile, helper, initialImage);\n+    }\n+\n+    protected Path modifyFileInImage(Path jmodLessImg)\n+            throws IOException, AssertionError {\n+        \/\/ modify net.properties config file\n+        Path netPropertiesFile = jmodLessImg.resolve(\"conf\").resolve(\"net.properties\");\n+        Properties props = new Properties();\n+        try (InputStream is = Files.newInputStream(netPropertiesFile)) {\n+            props.load(is);\n+        }\n+        String prevVal = (String)props.put(\"java.net.useSystemProxies\", Boolean.TRUE.toString());\n+        if (prevVal == null || Boolean.getBoolean(prevVal) != false) {\n+            throw new AssertionError(\"Expected previous value to be false!\");\n+        }\n+        try (OutputStream out = Files.newOutputStream(netPropertiesFile)) {\n+            props.store(out, \"Modified net.properties file!\");\n+        }\n+        return netPropertiesFile;\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Verify warnings are being produced when jlinking in runtime-based image\n+ *          mode and files have been modified\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g ModifiedFilesWarningTest\n+ *\/\n+public class ModifiedFilesWarningTest extends ModifiedFilesTest {\n+\n+    protected static final String IGNORE_MODIFIED_RUNTIME_OPT = \"--ignore-modified-runtime\";\n+\n+    public static void main(String[] args) throws Exception {\n+        ModifiedFilesWarningTest test = new ModifiedFilesWarningTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    String initialImageName() {\n+        return \"java-base-jlink-with-mod-warn\";\n+    }\n+\n+    @Override\n+    void testAndAssert(Path modifiedFile, Helper helper, Path initialImage) throws Exception {\n+        CapturingHandler handler = new CapturingHandler();\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(initialImage)\n+                                .name(\"java-base-jlink-with-mod-warn-target\")\n+                                .addModule(\"java.base\")\n+                                .validatingModule(\"java.base\")\n+                                .extraJlinkOpt(IGNORE_MODIFIED_RUNTIME_OPT) \/\/ only generate a warning\n+                                .build(), handler);\n+        OutputAnalyzer out = handler.analyzer();\n+        \/\/ verify we get the warning message\n+        out.stderrShouldMatch(\"WARNING: .* has been modified\");\n+        out.stderrShouldNotContain(\"java.lang.IllegalArgumentException\");\n+        out.stderrShouldNotContain(\"jdk.tools.jlink.internal.RunImageLinkException\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/ModifiedFilesWarningTest.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import tests.Helper;\n+\n+\/*\n+ * @test\n+ * @summary Verify that a jlink using the run-time image cannot include jdk.jlink\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g MultiHopTest\n+ *\/\n+public class MultiHopTest extends AbstractLinkableRuntimeTest {\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        Path jdkJlinkJmodless = createJDKJlinkJmodLess(helper, \"jdk.jlink-multi-hop1\");\n+        CapturingHandler handler = new CapturingHandler();\n+        Predicate<OutputAnalyzer> exitFailPred = new Predicate<>() {\n+\n+            @Override\n+            public boolean test(OutputAnalyzer a) {\n+                return a.getExitValue() != 0; \/\/ expect failure\n+            }\n+        };\n+        jlinkUsingImage(new JlinkSpecBuilder()\n+                                .helper(helper)\n+                                .imagePath(jdkJlinkJmodless)\n+                                .name(\"jdk-jlink-multi-hop1-target\")\n+                                .addModule(\"jdk.jlink\")\n+                                .validatingModule(\"java.base\")\n+                                .build(), handler, exitFailPred);\n+        OutputAnalyzer analyzer = handler.analyzer();\n+        if (analyzer.getExitValue() == 0) {\n+            throw new AssertionError(\"Expected jlink to fail due to including jdk.jlink\");\n+        }\n+        String expectedMsg = \"Including jdk.jlink module for run-time image based links is not allowed.\";\n+        analyzer.stdoutShouldContain(expectedMsg);\n+        analyzer.stdoutShouldNotContain(\"Exception\"); \/\/ ensure error message is sane\n+    }\n+\n+    private Path createJDKJlinkJmodLess(Helper helper, String name) throws Exception {\n+        BaseJlinkSpecBuilder builder = new BaseJlinkSpecBuilder();\n+        builder.helper(helper)\n+               .name(name)\n+               .addModule(\"jdk.jlink\")\n+               .validatingModule(\"java.base\");\n+        return createRuntimeLinkImage(builder.build());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        MultiHopTest test = new MultiHopTest();\n+        test.run();\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/MultiHopTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import tests.Helper;\n+import tests.JImageGenerator;\n+import tests.JImageHelper;\n+\n+\/*\n+ * @test\n+ * @summary Compare packaged-modules jlink with a run-time image based jlink to\n+ *          produce the same result\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g PackagedModulesVsJmodLessTest\n+ *\/\n+public class PackagedModulesVsJmodLessTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        PackagedModulesVsJmodLessTest test = new PackagedModulesVsJmodLessTest();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        \/\/ create a java.se using jmod-less approach\n+        Path javaSEruntimeLink = createJavaImageRuntimeLink(new BaseJlinkSpecBuilder()\n+                                                            .helper(helper)\n+                                                            .name(\"java-se-jmodless\")\n+                                                            .addModule(\"java.se\")\n+                                                            .validatingModule(\"java.se\")\n+                                                            .build());\n+\n+        \/\/ create a java.se using packaged modules (jmod-full)\n+        Path javaSEJmodFull = JImageGenerator.getJLinkTask()\n+                .output(helper.createNewImageDir(\"java-se-jmodfull\"))\n+                .addMods(\"java.se\").call().assertSuccess();\n+\n+        compareRecursively(javaSEruntimeLink, javaSEJmodFull);\n+    }\n+\n+    \/\/ Visit all files in the given directories checking that they're byte-by-byte identical\n+    private static void compareRecursively(Path javaSEJmodLess,\n+            Path javaSEJmodFull) throws IOException, AssertionError {\n+        FilesCapturingVisitor jmodFullVisitor = new FilesCapturingVisitor(javaSEJmodFull);\n+        FilesCapturingVisitor jmodLessVisitor = new FilesCapturingVisitor(javaSEJmodLess);\n+        Files.walkFileTree(javaSEJmodFull, jmodFullVisitor);\n+        Files.walkFileTree(javaSEJmodLess, jmodLessVisitor);\n+        List<String> jmodFullFiles = jmodFullVisitor.filesVisited();\n+        List<String> jmodLessFiles = jmodLessVisitor.filesVisited();\n+        Collections.sort(jmodFullFiles);\n+        Collections.sort(jmodLessFiles);\n+\n+        if (jmodFullFiles.size() != jmodLessFiles.size()) {\n+            throw new AssertionError(String.format(\"Size of files different for jmod-less (%d) vs jmod-full (%d) java.se jlink\", jmodLessFiles.size(), jmodFullFiles.size()));\n+        }\n+        String jimageFile = Path.of(\"lib\").resolve(\"modules\").toString();\n+        \/\/ Compare all files except the modules image\n+        for (int i = 0; i < jmodFullFiles.size(); i++) {\n+            String jmodFullPath = jmodFullFiles.get(i);\n+            String jmodLessPath = jmodLessFiles.get(i);\n+            if (!jmodFullPath.equals(jmodLessPath)) {\n+                throw new AssertionError(String.format(\"jmod-full path (%s) != jmod-less path (%s)\", jmodFullPath, jmodLessPath));\n+            }\n+            if (jmodFullPath.equals(jimageFile)) {\n+                continue;\n+            }\n+            Path a = javaSEJmodFull.resolve(Path.of(jmodFullPath));\n+            Path b = javaSEJmodLess.resolve(Path.of(jmodLessPath));\n+            if (Files.mismatch(a, b) != -1L) {\n+                handleFileMismatch(a, b);\n+            }\n+        }\n+        \/\/ Compare jimage contents by iterating its entries and comparing their\n+        \/\/ paths and content bytes\n+        \/\/\n+        \/\/ Note: The files aren't byte-by-byte comparable (probably due to string hashing\n+        \/\/ and offset differences in container bytes)\n+        Path jimageJmodLess = javaSEJmodLess.resolve(Path.of(\"lib\")).resolve(Path.of(\"modules\"));\n+        Path jimageJmodFull = javaSEJmodFull.resolve(Path.of(\"lib\")).resolve(Path.of(\"modules\"));\n+        List<String> jimageContentJmodLess = JImageHelper.listContents(jimageJmodLess);\n+        List<String> jimageContentJmodFull = JImageHelper.listContents(jimageJmodFull);\n+        if (jimageContentJmodLess.size() != jimageContentJmodFull.size()) {\n+            throw new AssertionError(String.format(\"Size of jimage content differs for jmod-less (%d) v. jmod-full (%d)\", jimageContentJmodLess.size(), jimageContentJmodFull.size()));\n+        }\n+        for (int i = 0; i < jimageContentJmodFull.size(); i++) {\n+            if (!jimageContentJmodFull.get(i).equals(jimageContentJmodLess.get(i))) {\n+                throw new AssertionError(String.format(\"Jimage content differs at index %d: jmod-full was: '%s' jmod-less was: '%s'\",\n+                                                       i,\n+                                                       jimageContentJmodFull.get(i),\n+                                                       jimageContentJmodLess.get(i)\n+                                                       ));\n+            }\n+            String loc = jimageContentJmodFull.get(i);\n+            if (isTreeInfoResource(loc)) {\n+                \/\/ Skip container bytes as those are offsets to the content\n+                \/\/ of the container which might be different between jlink runs.\n+                continue;\n+            }\n+            byte[] resBytesFull = JImageHelper.getLocationBytes(loc, jimageJmodFull);\n+            byte[] resBytesLess = JImageHelper.getLocationBytes(loc, jimageJmodLess);\n+            if (resBytesFull.length != resBytesLess.length || Arrays.mismatch(resBytesFull, resBytesLess) != -1) {\n+                throw new AssertionError(\"Content bytes mismatch for \" + loc);\n+            }\n+        }\n+    }\n+\n+    private static boolean isTreeInfoResource(String path) {\n+        return path.startsWith(\"\/packages\") || path.startsWith(\"\/modules\");\n+    }\n+\n+    private static void handleFileMismatch(Path a, Path b) {\n+        throw new AssertionError(\"Files mismatch: \" + a + \" vs. \" + b);\n+    }\n+\n+    static class FilesCapturingVisitor extends SimpleFileVisitor<Path> {\n+        private final Path basePath;\n+        private final List<String> filePaths = new ArrayList<>();\n+        public FilesCapturingVisitor(Path basePath) {\n+            this.basePath = basePath;\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) {\n+            Path relative = basePath.relativize(path);\n+            filePaths.add(relative.toString());\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        List<String> filesVisited() {\n+            return filePaths;\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/PackagedModulesVsJmodLessTest.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import tests.Helper;\n+import tests.JImageValidator;\n+\n+\/*\n+ * @test\n+ * @summary Test appropriate handling of generated SystemModules* classes in run-time image link mode\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g SystemModulesTest\n+ *\/\n+public class SystemModulesTest extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        SystemModulesTest test = new SystemModulesTest();\n+        test.run();\n+    }\n+\n+    \/*\n+     * SystemModule classes are module specific. If the jlink is based on the\n+     * modules image, then earlier generated SystemModule classes shall not get\n+     * propagated.\n+     *\/\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        \/\/ create an image with a module containing a main entrypoint (jdk.httpserver),\n+        \/\/ thus producing the SystemModules$0.class. Add jdk.jdwp.agent as a module which\n+        \/\/ isn't resolved by default, so as to generate SystemModules$default.class\n+        Path javaseJmodless = createJavaImageRuntimeLink(new BaseJlinkSpecBuilder()\n+                                                            .helper(helper)\n+                                                            .name(\"httpserver-jlink-jmodless-derived\")\n+                                                            .addModule(\"jdk.httpserver\")\n+                                                            .addModule(\"jdk.jdwp.agent\")\n+                                                            .validatingModule(\"java.base\")\n+                                                            .build());\n+        \/\/ Verify that SystemModules$0.class etc. are there, due to httpserver and jdwp.agent\n+        JImageValidator.validate(javaseJmodless.resolve(\"lib\").resolve(\"modules\"),\n+                                    List.of(\"\/java.base\/jdk\/internal\/module\/SystemModules$default.class\",\n+                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$0.class\",\n+                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$all.class\"),\n+                                    Collections.emptyList());\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/SystemModulesTest.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import tests.Helper;\n+import tests.JImageValidator;\n+\n+\/*\n+ * @test\n+ * @summary Test SystemModules handling of java --list-modules with system modules\n+ *          not consistently enabled\/disabled.\n+ * @requires (jlink.runtime.linkable & vm.compMode != \"Xcomp\" & os.maxMemory >= 2g)\n+ * @library ..\/..\/lib \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.* jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run main\/othervm -Xmx1g SystemModulesTest2\n+ *\/\n+public class SystemModulesTest2 extends AbstractLinkableRuntimeTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        SystemModulesTest2 test = new SystemModulesTest2();\n+        test.run();\n+    }\n+\n+    @Override\n+    void runTest(Helper helper) throws Exception {\n+        \/\/ See SystemModulesTest which enables the system-modules plugin. With\n+        \/\/ it disabled, we expect for the generated classes to not be there.\n+        Path javaJmodless = createJavaImageRuntimeLink(new BaseJlinkSpecBuilder()\n+                                                            .helper(helper)\n+                                                            .name(\"jlink-jmodless-sysmod2\")\n+                                                            .addModule(\"jdk.httpserver\")\n+                                                            .validatingModule(\"java.base\")\n+                                                            .addExtraOption(\"--disable-plugin\")\n+                                                            .addExtraOption(\"system-modules\")\n+                                                            .build());\n+        \/\/ Verify that SystemModules$all.class is there\n+        JImageValidator.validate(javaJmodless.resolve(\"lib\").resolve(\"modules\"),\n+                                    Collections.emptyList(),\n+                                    List.of(\"\/java.base\/jdk\/internal\/module\/SystemModules$all.class\",\n+                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$default.class\",\n+                                            \"\/java.base\/jdk\/internal\/module\/SystemModules$0.class\"));\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/JmodLess\/SystemModulesTest2.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -32,0 +32,3 @@\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n@@ -37,3 +40,0 @@\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.Test;\n-\n@@ -112,0 +112,12 @@\n+    @Test\n+    public static void basicJlinkJavaBase() throws IOException {\n+        Result result = JImageGenerator.getJLinkTask()\n+                .modulePath(helper.defaultModulePath())\n+                .output(helper.createNewImageDir(\"java-base-basic\"))\n+                .addMods(\"java.base\")\n+                .call();\n+\n+        Path image = result.assertSuccess();\n+        validateJLISpeciesClasses(image);\n+    }\n+\n@@ -134,0 +146,20 @@\n+    private static void validateJLISpeciesClasses(Path image) throws IOException {\n+        JImageValidator.validate(image.resolve(\"lib\").resolve(\"modules\"),\n+                List.of(\"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_D.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_DL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_I.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_IL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LJ.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLJ.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLJ.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLLL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLLL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLLLL.class\",\n+                        \"\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_LLLLLLLLL.class\"),\n+                List.of());\n+    }\n+\n","filename":"test\/jdk\/tools\/jlink\/plugins\/GenerateJLIClassesPluginTest.java","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package tests;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import jdk.internal.jimage.BasicImageReader;\n+import jdk.internal.jimage.ImageLocation;\n+\n+\/**\n+ *\n+ * JDK Modular image iterator\n+ *\/\n+public class JImageHelper {\n+\n+    private JImageHelper() {\n+        \/\/ Don't instantiate\n+    }\n+\n+    public static List<String> listContents(Path jimage) throws IOException {\n+        try(BasicImageReader reader = BasicImageReader.open(jimage)) {\n+            List<String> entries = new ArrayList<>();\n+            for (String s : reader.getEntryNames()) {\n+                entries.add(s);\n+            }\n+            Collections.sort(entries);\n+            return entries;\n+        }\n+    }\n+\n+    public static byte[] getLocationBytes(String location, Path jimage) throws IOException {\n+        try(BasicImageReader reader = BasicImageReader.open(jimage)) {\n+            ImageLocation il = reader.findLocation(location);\n+            byte[] r = reader.getResource(il);\n+            if (r == null) {\n+                throw new IllegalStateException(String.format(\"bytes for %s not found!\", location));\n+            }\n+            return r;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/lib\/tests\/JImageHelper.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -26,0 +26,3 @@\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReader;\n+import java.lang.module.ModuleReference;\n@@ -42,0 +45,1 @@\n+import java.util.Optional;\n@@ -138,0 +142,1 @@\n+        map.put(\"jlink.runtime.linkable\", this::runtimeLinkable);\n@@ -651,0 +656,25 @@\n+    private String runtimeLinkable() {\n+        \/\/ jdk.jlink module has the following resource listing native libs\n+        \/\/ belonging to the java.base module for runtime linkable jimages.\n+        String linkableRuntimeResource = \"jdk\/tools\/jlink\/internal\/fs_java.base_files\";\n+        try {\n+            ModuleFinder finder = ModuleFinder.ofSystem();\n+            Optional<ModuleReference> ref = finder.find(\"jdk.jlink\");\n+            if (ref.isEmpty()) {\n+                \/\/ No jdk.jlink in the current image\n+                return Boolean.FALSE.toString();\n+            }\n+            try (ModuleReader reader = ref.get().open()) {\n+                Optional<InputStream> inOpt = reader.open(linkableRuntimeResource);\n+                if (inOpt.isPresent()) {\n+                    inOpt.get().close();\n+                    return Boolean.TRUE.toString();\n+                } else {\n+                    return Boolean.FALSE.toString();\n+                }\n+            }\n+        } catch (Throwable t) {\n+            return Boolean.FALSE.toString();\n+        }\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"}]}