{"files":[{"patch":"@@ -569,1 +569,1 @@\n-  notify_threads();\n+  notify_threads(false);\n@@ -679,1 +679,15 @@\n-class JfrNotifyClosure : public ThreadClosure {\n+\/\/ Reset thread local state used for object allocation sampling.\n+static void clear_last_allocated_bytes(JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  assert(!JfrRecorder::is_recording(), \"invariant\");\n+  JfrThreadLocal* const tl = jt->jfr_thread_local();\n+  assert(tl != nullptr, \"invariant\");\n+  if (tl->last_allocated_bytes() != 0) {\n+    tl->clear_last_allocated_bytes();\n+  }\n+  assert(tl->last_allocated_bytes() == 0, \"invariant\");\n+}\n+\n+class JfrNotifyClosure : public StackObj {\n+ private:\n+  bool _clear;\n@@ -681,2 +695,3 @@\n-  void do_thread(Thread* thread) {\n-    assert(thread != nullptr, \"invariant\");\n+  JfrNotifyClosure(bool clear) : _clear(clear) {}\n+  void do_thread(JavaThread* jt) {\n+    assert(jt != nullptr, \"invariant\");\n@@ -684,1 +699,4 @@\n-    JfrJavaEventWriter::notify(JavaThread::cast(thread));\n+    JfrJavaEventWriter::notify(jt);\n+    if (_clear) {\n+      clear_last_allocated_bytes(jt);\n+    }\n@@ -688,1 +706,1 @@\n-void JfrCheckpointManager::notify_threads() {\n+void JfrCheckpointManager::notify_threads(bool clear \/* true *\/) {\n@@ -690,1 +708,1 @@\n-  JfrNotifyClosure tc;\n+  JfrNotifyClosure tc(clear);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  void notify_threads();\n+  void notify_threads(bool clear = true);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,24 +125,0 @@\n-\/\/ Reset thread local state used for object allocation sampling.\n-class ClearObjectAllocationSampling : public ThreadClosure {\n- public:\n-  void do_thread(Thread* t) {\n-    assert(t != nullptr, \"invariant\");\n-    t->jfr_thread_local()->clear_last_allocated_bytes();\n-  }\n-};\n-\n-template <typename Iterator>\n-static inline void iterate(Iterator& it, ClearObjectAllocationSampling& coas) {\n-  while (it.has_next()) {\n-    coas.do_thread(it.next());\n-  }\n-}\n-\n-static void clear_object_allocation_sampling() {\n-  ClearObjectAllocationSampling coas;\n-  JfrJavaThreadIterator jit;\n-  iterate(jit, coas);\n-  JfrNonJavaThreadIterator njit;\n-  iterate(njit, coas);\n-}\n-\n@@ -475,1 +451,0 @@\n-  clear_object_allocation_sampling();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"jfr\/jfrEvents.hpp\"\n@@ -34,1 +35,3 @@\n-  JfrObjectAllocationSample::send_event(klass, alloc_size, outside_tlab, thread);\n+  if (EventObjectAllocationSample::is_enabled()) {\n+    JfrObjectAllocationSample::send_event(klass, alloc_size, outside_tlab, thread);\n+  }\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAllocationTracer.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"jfr\/support\/jfrThreadLocal.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n@@ -46,3 +46,3 @@\n-inline int64_t estimate_tlab_size_bytes(Thread* thread) {\n-  const size_t desired_tlab_size_bytes = thread->tlab().desired_size() * HeapWordSize;\n-  const size_t alignment_reserve_bytes = thread->tlab().alignment_reserve_in_bytes();\n+inline int64_t estimate_tlab_size_bytes(JavaThread* jt) {\n+  const size_t desired_tlab_size_bytes = jt->tlab().desired_size() * HeapWordSize;\n+  const size_t alignment_reserve_bytes = jt->tlab().alignment_reserve_in_bytes();\n@@ -53,3 +53,10 @@\n-inline int64_t load_allocated_bytes(JfrThreadLocal* tl, Thread* thread) {\n-  const int64_t allocated_bytes = thread->allocated_bytes();\n-  return allocated_bytes == tl->last_allocated_bytes() ? 0 : allocated_bytes;\n+inline int64_t load_allocated_bytes(JfrThreadLocal* tl, JavaThread* jt) {\n+  const int64_t allocated_bytes = jt->allocated_bytes();\n+  const int64_t last_allocated_bytes = tl->last_allocated_bytes();\n+  assert(allocated_bytes >= last_allocated_bytes, \"invariant\");\n+  if (last_allocated_bytes == 0) {\n+    \/\/ Initialization.\n+    tl->set_last_allocated_bytes(allocated_bytes);\n+    return 0;\n+  }\n+  return allocated_bytes == last_allocated_bytes ? 0 : allocated_bytes;\n@@ -60,2 +67,5 @@\n-static void normalize_as_tlab_and_send_allocation_samples(const Klass* klass, int64_t obj_alloc_size_bytes, JfrThreadLocal* tl, Thread* thread) {\n-  const int64_t allocated_bytes = load_allocated_bytes(tl, thread);\n+static void normalize_as_tlab_and_send_allocation_samples(const Klass* klass,\n+                                                          int64_t obj_alloc_size_bytes,\n+                                                          int64_t allocated_bytes,\n+                                                          JfrThreadLocal* tl,\n+                                                          JavaThread* jt) {\n@@ -67,2 +77,2 @@\n-  const int64_t tlab_size_bytes = estimate_tlab_size_bytes(thread);\n-  if (tlab_size_bytes <= 0) {\n+  const int64_t tlab_size_bytes = estimate_tlab_size_bytes(jt);\n+  if (tlab_size_bytes <= 0 || allocated_bytes - tl->last_allocated_bytes() < tlab_size_bytes) {\n@@ -72,3 +82,0 @@\n-  if (allocated_bytes - tl->last_allocated_bytes() < tlab_size_bytes) {\n-    return;\n-  }\n@@ -84,3 +91,4 @@\n-void JfrObjectAllocationSample::send_event(const Klass* klass, size_t alloc_size, bool outside_tlab, Thread* thread) {\n-  assert(thread != nullptr, \"invariant\");\n-  JfrThreadLocal* const tl = thread->jfr_thread_local();\n+void JfrObjectAllocationSample::send_event(const Klass* klass, size_t alloc_size, bool outside_tlab, JavaThread* jt) {\n+  assert(klass != nullptr, \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+  JfrThreadLocal* const tl = jt->jfr_thread_local();\n@@ -88,7 +96,7 @@\n-  if (outside_tlab) {\n-    normalize_as_tlab_and_send_allocation_samples(klass, static_cast<int64_t>(alloc_size), tl, thread);\n-    return;\n-  }\n-  const int64_t allocated_bytes = load_allocated_bytes(tl, thread);\n-  if (allocated_bytes == 0) {\n-    return;\n+  const int64_t allocated_bytes = load_allocated_bytes(tl, jt);\n+  if (allocated_bytes > 0) {\n+    if (outside_tlab) {\n+      normalize_as_tlab_and_send_allocation_samples(klass, static_cast<int64_t>(alloc_size), allocated_bytes, tl, jt);\n+      return;\n+    }\n+    send_allocation_sample(klass, allocated_bytes, tl);\n@@ -96,1 +104,0 @@\n-  send_allocation_sample(klass, allocated_bytes, tl);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrObjectAllocationSample.cpp","additions":32,"deletions":25,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+class JavaThread;\n@@ -31,1 +32,0 @@\n-class Thread;\n@@ -35,1 +35,1 @@\n-  static void send_event(const Klass* klass, size_t alloc_size, bool outside_tlab, Thread* thread);\n+  static void send_event(const Klass* klass, size_t alloc_size, bool outside_tlab, JavaThread* jt);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrObjectAllocationSample.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.allocation;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.CountDownLatch;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @summary Tests that the VM maintains proper initialization state for ObjectAllocationSampleEvent.\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UseTLAB -XX:TLABSize=2k -XX:-ResizeTLAB jdk.jfr.event.allocation.TestObjectAllocationSampleEventInitialWeight\n+ *\/\n+public class TestObjectAllocationSampleEventInitialWeight {\n+    private static final String EVENT_NAME = EventNames.ObjectAllocationSample;\n+    private static final int OBJECT_SIZE = 4 * 1024;\n+    private static final int OBJECTS_TO_ALLOCATE = 16;\n+    private static final int OBJECTS_TO_ALLOCATE_BEFORE_RECORDING = 1024;\n+    private static final long BEFORE_RECORDING_SAMPLE_WEIGHT = OBJECT_SIZE * OBJECTS_TO_ALLOCATE_BEFORE_RECORDING;\n+    private static final String BYTE_ARRAY_CLASS_NAME = new byte[0].getClass().getName();\n+\n+    private static AtomicBoolean onError = null;\n+\n+    \/\/ Make sure allocation isn't dead code eliminated.\n+    public static byte[] tmp;\n+\n+    public static void main(String... args) throws Exception {\n+        test();\n+        \/\/ Test again to ensure reset logic works correctly for subsequent physical recordings.\n+        test();\n+    }\n+\n+    private static void test() throws Exception {\n+        CountDownLatch delivered = new CountDownLatch(1);\n+        onError = new AtomicBoolean();\n+        Thread current = Thread.currentThread();\n+        allocateBeforeRecording();\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.enable(EVENT_NAME);\n+            rs.onEvent(EVENT_NAME, e -> {\n+                if (verify(e, current)) {\n+                    delivered.countDown();\n+                }\n+            });\n+            rs.startAsync();\n+            allocate(OBJECTS_TO_ALLOCATE);\n+            delivered.await();\n+            if (onError.get()) {\n+                throw new RuntimeException(\"Sample weight is not below \" + BEFORE_RECORDING_SAMPLE_WEIGHT);\n+            }\n+        }\n+    }\n+\n+    private static void allocateBeforeRecording() throws Exception {\n+        allocate(OBJECTS_TO_ALLOCATE_BEFORE_RECORDING);\n+    }\n+\n+    private static void allocate(int number) throws Exception {\n+        for (int i = 0; i < number; ++i) {\n+            tmp = new byte[OBJECT_SIZE];\n+        }\n+    }\n+\n+    private static boolean verify(RecordedEvent event, Thread thread) {\n+        if (thread.getId() != event.getThread().getJavaThreadId()) {\n+            return false;\n+        }\n+        System.out.println(event);\n+        if (event.getLong(\"weight\") >= BEFORE_RECORDING_SAMPLE_WEIGHT) {\n+            onError.set(true);\n+        }\n+        return true;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/allocation\/TestObjectAllocationSampleEventInitialWeight.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"}]}