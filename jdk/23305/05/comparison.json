{"files":[{"patch":"@@ -243,0 +243,4 @@\n+  if (_start_gc_is_pending) {\n+    return true;\n+  }\n+\n@@ -252,0 +256,1 @@\n+    accept_trigger_with_type(OTHER);\n@@ -264,0 +269,1 @@\n+      accept_trigger_with_type(OTHER);\n@@ -295,1 +301,1 @@\n-    _last_trigger = RATE;\n+    accept_trigger_with_type(RATE);\n@@ -306,1 +312,1 @@\n-    _last_trigger = SPIKE;\n+    accept_trigger_with_type(SPIKE);\n@@ -310,1 +316,6 @@\n-  return ShenandoahHeuristics::should_start_gc();\n+  if (ShenandoahHeuristics::should_start_gc()) {\n+    _start_gc_is_pending = true;\n+    return true;\n+  } else {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -148,0 +148,5 @@\n+\n+  inline void accept_trigger_with_type(Trigger trigger_type) {\n+    _last_trigger = trigger_type;\n+    ShenandoahHeuristics::accept_trigger();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+  accept_trigger();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+    accept_trigger();\n@@ -72,0 +73,1 @@\n+    accept_trigger();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,3 @@\n+  _start_gc_is_pending(false),\n+  _declined_trigger_count(0),\n+  _most_recent_declined_trigger_count(0),\n@@ -187,0 +190,3 @@\n+  if (_start_gc_is_pending) {\n+    return true;\n+  }\n@@ -191,0 +197,1 @@\n+    accept_trigger();\n@@ -199,0 +206,1 @@\n+      accept_trigger();\n@@ -202,1 +210,1 @@\n-\n+  decline_trigger();\n@@ -214,0 +222,6 @@\n+  if ((_most_recent_declined_trigger_count <= Penalty_Free_Declinations) && (step > 0)) {\n+    \/\/ Don't penalize if heuristics are not responsible for a negative outcome.  Allow Penalty_Free_Declinations following\n+    \/\/ previous GC for self calibration without penalty.\n+    step = 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -72,0 +72,3 @@\n+  \/\/ How many times can I decline a trigger opportunity without being penalized for excessive idle span before trigger?\n+  static const size_t Penalty_Free_Declinations = 16;\n+\n@@ -81,0 +84,12 @@\n+  bool _start_gc_is_pending;              \/\/ True denotes that GC has been triggered, so no need to trigger again.\n+  size_t _declined_trigger_count;         \/\/ This counts how many times since previous GC finished that this\n+                                          \/\/  heuristic has answered false to should_start_gc().\n+  size_t _most_recent_declined_trigger_count;\n+                                       ;  \/\/ This represents the value of _declined_trigger_count as captured at the\n+                                          \/\/  moment the most recent GC effort was triggered.  In case the most recent\n+                                          \/\/  concurrent GC effort degenerates, the value of this variable allows us to\n+                                          \/\/  differentiate between degeneration because heuristic was overly optimistic\n+                                          \/\/  in delaying the trigger vs. degeneration for other reasons (such as the\n+                                          \/\/  most recent GC triggered \"immediately\" after previous GC finished, but the\n+                                          \/\/  free headroom has already been depleted).\n+\n@@ -170,0 +185,10 @@\n+  inline void accept_trigger() {\n+    _most_recent_declined_trigger_count = _declined_trigger_count;\n+    _declined_trigger_count = 0;\n+    _start_gc_is_pending = true;\n+  }\n+\n+  inline void decline_trigger() {\n+    _declined_trigger_count++;\n+  }\n+\n@@ -188,0 +213,4 @@\n+  inline void cancel_trigger_request() {\n+    _start_gc_is_pending = false;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+  decline_trigger();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveHeuristics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+    accept_trigger();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -122,0 +122,2 @@\n+        \/\/ Do not decline_trigger() when waiting for minimum quantum of Old-gen marking.  It is not at our discretion\n+        \/\/ to trigger at this time.\n@@ -143,0 +145,1 @@\n+    accept_trigger();\n@@ -153,0 +156,1 @@\n+    accept_trigger();\n@@ -156,0 +160,1 @@\n+  \/\/ Don't decline_trigger() here  That was done in ShenandoahAdaptiveHeuristics::should_start_gc()\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -950,5 +950,19 @@\n-  \/\/ Concurrent weak root processing\n-  ShenandoahTimingsTracker t(ShenandoahPhaseTimings::conc_weak_roots_work);\n-  ShenandoahGCWorkerPhase worker_phase(ShenandoahPhaseTimings::conc_weak_roots_work);\n-  ShenandoahConcurrentWeakRootsEvacUpdateTask task(ShenandoahPhaseTimings::conc_weak_roots_work);\n-  heap->workers()->run_task(&task);\n+  {\n+    \/\/ Concurrent weak root processing\n+    ShenandoahTimingsTracker t(ShenandoahPhaseTimings::conc_weak_roots_work);\n+    ShenandoahGCWorkerPhase worker_phase(ShenandoahPhaseTimings::conc_weak_roots_work);\n+    ShenandoahConcurrentWeakRootsEvacUpdateTask task(ShenandoahPhaseTimings::conc_weak_roots_work);\n+    heap->workers()->run_task(&task);\n+  }\n+\n+  {\n+    \/\/ It is possible for mutators executing the load reference barrier to have\n+    \/\/ loaded an oop through a weak handle that has since been nulled out by\n+    \/\/ weak root processing. Handshaking here forces them to complete the\n+    \/\/ barrier before the GC cycle continues and does something that would\n+    \/\/ change the evaluation of the barrier (for example, resetting the TAMS\n+    \/\/ on trashed regions could make an oop appear to be marked _after_ the\n+    \/\/ region has been recycled).\n+    ShenandoahTimingsTracker t(ShenandoahPhaseTimings::conc_weak_roots_rendezvous);\n+    heap->rendezvous_threads(\"Shenandoah Concurrent Weak Roots\");\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -134,0 +134,2 @@\n+      heuristics->cancel_trigger_request();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -440,0 +440,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+          _global_heuristics->cancel_trigger_request();\n@@ -75,0 +76,1 @@\n+            _young_heuristics->cancel_trigger_request();\n@@ -77,0 +79,1 @@\n+            _young_heuristics->cancel_trigger_request();\n@@ -83,0 +86,1 @@\n+        _young_heuristics->cancel_trigger_request();\n@@ -96,0 +100,1 @@\n+        _global_heuristics->cancel_trigger_request();\n@@ -98,0 +103,1 @@\n+        _young_heuristics->cancel_trigger_request();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}