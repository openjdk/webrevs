{"files":[{"patch":"@@ -244,0 +244,4 @@\n+  if (_start_gc_is_pending) {\n+    return true;\n+  }\n+\n@@ -253,0 +257,1 @@\n+    accept_trigger_with_type(OTHER);\n@@ -265,0 +270,1 @@\n+      accept_trigger_with_type(OTHER);\n@@ -296,1 +302,1 @@\n-    _last_trigger = RATE;\n+    accept_trigger_with_type(RATE);\n@@ -307,1 +313,1 @@\n-    _last_trigger = SPIKE;\n+    accept_trigger_with_type(SPIKE);\n@@ -311,1 +317,6 @@\n-  return ShenandoahHeuristics::should_start_gc();\n+  if (ShenandoahHeuristics::should_start_gc()) {\n+    _start_gc_is_pending = true;\n+    return true;\n+  } else {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -148,0 +148,5 @@\n+\n+  inline void accept_trigger_with_type(Trigger trigger_type) {\n+    _last_trigger = trigger_type;\n+    ShenandoahHeuristics::accept_trigger();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+  accept_trigger();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+    accept_trigger();\n@@ -73,0 +74,1 @@\n+    accept_trigger();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+  _start_gc_is_pending(false),\n+  _declined_trigger_count(0),\n+  _most_recent_declined_trigger_count(0),\n@@ -188,0 +191,3 @@\n+  if (_start_gc_is_pending) {\n+    return true;\n+  }\n@@ -192,0 +198,1 @@\n+    accept_trigger();\n@@ -200,0 +207,1 @@\n+      accept_trigger();\n@@ -203,1 +211,1 @@\n-\n+  decline_trigger();\n@@ -215,0 +223,6 @@\n+  if ((_most_recent_declined_trigger_count <= Penalty_Free_Declinations) && (step > 0)) {\n+    \/\/ Don't penalize if heuristics are not responsible for a negative outcome.  Allow Penalty_Free_Declinations following\n+    \/\/ previous GC for self calibration without penalty.\n+    step = 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -72,0 +72,3 @@\n+  \/\/ How many times can I decline a trigger opportunity without being penalized for excessive idle span before trigger?\n+  static const size_t Penalty_Free_Declinations = 16;\n+\n@@ -81,0 +84,12 @@\n+  bool _start_gc_is_pending;              \/\/ True denotes that GC has been triggered, so no need to trigger again.\n+  size_t _declined_trigger_count;         \/\/ This counts how many times since previous GC finished that this\n+                                          \/\/  heuristic has answered false to should_start_gc().\n+  size_t _most_recent_declined_trigger_count;\n+                                       ;  \/\/ This represents the value of _declined_trigger_count as captured at the\n+                                          \/\/  moment the most recent GC effort was triggered.  In case the most recent\n+                                          \/\/  concurrent GC effort degenerates, the value of this variable allows us to\n+                                          \/\/  differentiate between degeneration because heuristic was overly optimistic\n+                                          \/\/  in delaying the trigger vs. degeneration for other reasons (such as the\n+                                          \/\/  most recent GC triggered \"immediately\" after previous GC finished, but the\n+                                          \/\/  free headroom has already been depleted).\n+\n@@ -170,0 +185,10 @@\n+  inline void accept_trigger() {\n+    _most_recent_declined_trigger_count = _declined_trigger_count;\n+    _declined_trigger_count = 0;\n+    _start_gc_is_pending = true;\n+  }\n+\n+  inline void decline_trigger() {\n+    _declined_trigger_count++;\n+  }\n+\n@@ -188,0 +213,4 @@\n+  inline void cancel_trigger_request() {\n+    _start_gc_is_pending = false;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+  decline_trigger();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveHeuristics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+    accept_trigger();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -124,0 +124,2 @@\n+        \/\/ Do not decline_trigger() when waiting for minimum quantum of Old-gen marking.  It is not at our discretion\n+        \/\/ to trigger at this time.\n@@ -145,0 +147,1 @@\n+    accept_trigger();\n@@ -155,0 +158,1 @@\n+    accept_trigger();\n@@ -158,0 +162,1 @@\n+  \/\/ Don't decline_trigger() here  That was done in ShenandoahAdaptiveHeuristics::should_start_gc()\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -135,0 +135,2 @@\n+      heuristics->cancel_trigger_request();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -307,1 +307,1 @@\n-  if (!metrics.is_good_progress()) {\n+  if (!metrics.is_good_progress(_generation)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -440,0 +440,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-  if (metrics.is_good_progress()) {\n+  if (metrics.is_good_progress(heap->global_generation())) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-bool ShenandoahMetricsSnapshot::is_good_progress() {\n+bool ShenandoahMetricsSnapshot::is_good_progress(ShenandoahGeneration* generation) {\n@@ -50,1 +50,1 @@\n-  size_t free_expected = _heap->max_capacity() \/ 100 * ShenandoahCriticalFreeThreshold;\n+  size_t free_expected = (generation->max_capacity() \/ 100) * ShenandoahCriticalFreeThreshold;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMetrics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  bool is_good_progress();\n+  bool is_good_progress(ShenandoahGeneration* generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMetrics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+          _global_heuristics->cancel_trigger_request();\n@@ -76,0 +77,1 @@\n+            _young_heuristics->cancel_trigger_request();\n@@ -78,0 +80,1 @@\n+            _young_heuristics->cancel_trigger_request();\n@@ -84,0 +87,1 @@\n+        _young_heuristics->cancel_trigger_request();\n@@ -97,0 +101,1 @@\n+        _global_heuristics->cancel_trigger_request();\n@@ -99,0 +104,1 @@\n+        _young_heuristics->cancel_trigger_request();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}