{"files":[{"patch":"@@ -8528,1 +8528,1 @@\n-    \/\/ if length of the string is less than 16, handle it in an old fashioned way\n+    \/\/ if length of the string is less than 32, handle it the old fashioned way\n@@ -8617,1 +8617,1 @@\n-    jmpb(copy_chars_loop);\n+    jmp(copy_chars_loop);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8311906\n+ * @summary Validates String constructor intrinsics using varied input data.\n+ * @key randomness\n+ * @library \/compiler\/patches \/test\/lib\n+ * @build java.base\/java.lang.Helper\n+ * @run main\/othervm\/timeout=1200 -Xbatch -XX:CompileThreshold=100 compiler.intrinsics.string.TestStringConstructionIntrinsics\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8311906\n+ * @summary Validates String constructor intrinsic for AVX3 works with and without\n+ *          AVX3Threshold=0\n+ * @key randomness\n+ * @library \/compiler\/patches \/test\/lib\n+ * @build java.base\/java.lang.Helper\n+ * @requires vm.cpu.features ~= \".*avx512.*\"\n+ * @run main\/othervm\/timeout=1200 -Xbatch -XX:CompileThreshold=100 -XX:UseAVX=3 compiler.intrinsics.string.TestStringConstructionIntrinsics\n+ * @run main\/othervm\/timeout=1200 -Xbatch -XX:CompileThreshold=100 -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:AVX3Threshold=0 compiler.intrinsics.string.TestStringConstructionIntrinsics\n+ *\/\n+\n+package compiler.intrinsics.string;\n+\n+import java.lang.Helper;\n+import java.util.Random;\n+\n+import jdk.test.lib.Utils;\n+\n+public class TestStringConstructionIntrinsics {\n+\n+    private static byte[] bytes = new byte[2 * (4096 + 32)];\n+\n+    private static char[] chars = new char[4096 + 32];\n+\n+    \/\/ Used a scratch buffer, sized to accommodate inflated\n+    private static byte[] dst = new byte[bytes.length * 2];\n+\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    \/**\n+     * Completely initialize the bytes test array. The lowest index that will be\n+     * non-latin1 is marked by nlOffset\n+     *\/\n+    public static void initializeBytes(int off, int len, int nonLatin1, int nlOffset) {\n+        int maxLen = bytes.length >> 1;\n+        assert (len + off < maxLen);\n+        \/\/ insert \"canary\" (non-latin1) values before offset\n+        for (int i = 0; i < off; i++) {\n+            Helper.putCharSB(bytes, i, ((i + 15) & 0x7F) | 0x180);\n+        }\n+        \/\/ fill the array segment\n+        for (int i = off; i < len + off; i++) {\n+            Helper.putCharSB(bytes, i, ((i - off + 15) & 0xFF));\n+        }\n+        if (nonLatin1 != 0) {\n+            \/\/ modify a number disparate indexes to be non-latin1\n+            for (int i = 0; i < nonLatin1; i++) {\n+                int idx = off + RANDOM.nextInt(len - nlOffset) + nlOffset;\n+                Helper.putCharSB(bytes, i, ((i + 15) & 0x7F) | 0x180);\n+            }\n+        }\n+        \/\/ insert \"canary\" non-latin1 values after array segment\n+        for (int i = len + off; i < maxLen; i++) {\n+            Helper.putCharSB(bytes, i, ((i + 15) & 0x7F) | 0x180);\n+        }\n+    }\n+\n+    \/**\n+     * Completely initialize the char test array. The lowest index that will be\n+     * non-latin1 is marked by nlOffset\n+     *\/\n+    public static void initializeChars(int off, int len, int nonLatin1, int nlOffset) {\n+        assert (len + off <= chars.length);\n+        \/\/ insert \"canary\" non-latin1 values before offset\n+        for (int i = 0; i < off; ++i) {\n+            chars[i] = (char) (((i + 15) & 0x7F) | 0x180);\n+        }\n+        \/\/ fill the array segment\n+        for (int i = off; i < len + off; ++i) {\n+            chars[i] = (char) (((i - off + 15) & 0xFF));\n+        }\n+        if (nonLatin1 != 0) {\n+            \/\/ modify a number disparate chars inside\n+            \/\/ segment to be non-latin1.\n+            for (int i = 0; i < nonLatin1; i++) {\n+                int idx = off + RANDOM.nextInt(len - nlOffset) + nlOffset;\n+                chars[idx] = (char) (0x180 | chars[idx]);\n+            }\n+        }\n+        \/\/ insert \"canary\" non-latin1 values after array segment\n+        for (int i = len + off; i < chars.length; ++i) {\n+            chars[i] = (char) (((i + 15) & 0x7F) | 0x180);\n+        }\n+    }\n+\n+    \/**\n+     * Test different array segment sizes, offsets, and number of non-latin1\n+     * chars.\n+     *\/\n+    public static void testConstructBytes() throws Exception {\n+        for (int off = 0; off < 16; off++) { \/\/ starting offset of array segment\n+            \/\/ Test all array segment sizes 1-63\n+            for (int len = 1; len < 64; len++) {\n+                testConstructBytes(off, len, 0, 0);\n+                testConstructBytes(off, len, 1, 0);\n+                testConstructBytes(off, len, RANDOM.nextInt(30) + 2, 0);\n+            }\n+            \/\/ Test a random selection of sizes between 64 and 4099, inclusive\n+            for (int i = 0; i < 20; i++) {\n+                int len = 64 + RANDOM.nextInt(4100 - 64);\n+                testConstructBytes(off, len, 0, 0);\n+                testConstructBytes(off, len, 1, 0);\n+                testConstructBytes(off, len, RANDOM.nextInt(len) + 2, 0);\n+            }\n+            for (int len : new int[] { 128, 2048 }) {\n+                \/\/ test with negatives only in a 1-63 byte tail\n+                int tail = RANDOM.nextInt(63) + 1;\n+                int ng = RANDOM.nextInt(tail) + 1;\n+                testConstructBytes(off, len + tail, ng, len);\n+            }\n+        }\n+    }\n+\n+    private static void testConstructBytes(int off, int len, int ng, int ngOffset) throws Exception {\n+        assert (len + off < bytes.length);\n+        initializeBytes(off, len, ng, ngOffset);\n+        byte[] dst = new byte[bytes.length];\n+        \n+        int calculated = Helper.compress(bytes, off, dst, 0, len);\n+        int expected = compress(bytes, off, dst, 0, len);\n+        if (calculated != expected) {\n+            if (expected != len && ng >= 0 && calculated >= 0 && calculated < expected) {\n+                \/\/ allow intrinsics to return early with a lower value,\n+                \/\/ but only if we're not expecting the full length (no\n+                \/\/ negative bytes)\n+                return;\n+            }\n+            throw new Exception(\"Failed testConstructBytes: \" + \"offset: \" + off + \" \"\n+                    + \"length: \" + len + \" \" + \"return: \" + calculated + \" expected: \" + expected + \" negatives: \"\n+                    + ng + \" offset: \" + ngOffset);\n+        }\n+    }\n+\n+    private static int compress(byte[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+        for (int i = 0; i < len; i++) {\n+            char c = Helper.charAt(src, srcOff);\n+            if (c > 0xff) {\n+                return i;  \/\/ return index of non-latin1 char\n+            }\n+            dst[dstOff] = (byte)c;\n+            srcOff++;\n+            dstOff++;\n+        }\n+        return len;\n+    }\n+\n+    \/**\n+     * Test different array segment sizes, offsets, and number of non-latin1\n+     * chars.\n+     *\/\n+    public static void testConstructChars() throws Exception {\n+        for (int off = 0; off < 16; off++) { \/\/ starting offset of array segment\n+            \/\/ Test all array segment sizes 1-63\n+            for (int len = 1; len < 64; len++) {\n+                testConstructChars(off, len, 0, 0);\n+                testConstructChars(off, len, 1, 0);\n+                testConstructChars(off, len, RANDOM.nextInt(30) + 2, 0);\n+            }\n+            \/\/ Test a random selection of sizes between 64 and 4099, inclusive\n+            for (int i = 0; i < 20; i++) {\n+                int len = 64 + RANDOM.nextInt(4100 - 64);\n+                testConstructChars(off, len, 0, 0);\n+                testConstructChars(off, len, 1, 0);\n+                testConstructChars(off, len, RANDOM.nextInt(len) + 2, 0);\n+            }\n+            for (int len : new int[] { 128, 2048 }) {\n+                \/\/ test with negatives only in a 1-63 byte tail\n+                int tail = RANDOM.nextInt(63) + 1;\n+                int ng = RANDOM.nextInt(tail) + 1;\n+                testConstructChars(off, len + tail, ng, len);\n+            }\n+        }\n+    }\n+\n+    private static void testConstructChars(int off, int len, int nonLatin1, int nlOffset) throws Exception {\n+        assert (len + off < bytes.length);\n+        initializeChars(off, len, nonLatin1, nlOffset);\n+        \n+        int calculated = Helper.compress(chars, off, dst, 0, len);\n+        int expected = compress(chars, off, dst, 0, len);\n+        if (calculated != expected) {\n+            if (expected != len && nonLatin1 >= 0 && calculated >= 0 && calculated < expected) {\n+                \/\/ allow intrinsics to return early with a lower value,\n+                \/\/ but only if we're not expecting the full length (no\n+                \/\/ negative bytes)\n+                return;\n+            }\n+            throw new Exception(\"Failed testConstructChars: \" + \"offset: \" + off + \" \"\n+                    + \"length: \" + len + \" \" + \"return: \" + calculated + \" expected: \" + expected + \" non-latin1: \"\n+                    + nonLatin1 + \" offset: \" + nlOffset);\n+        }\n+    }\n+\n+    private static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+        for (int i = 0; i < len; i++) {\n+            char c = src[srcOff];\n+            if (c > 0xff) {\n+                return i;  \/\/ return index of non-latin1 char\n+            }\n+            dst[dstOff] = (byte)c;\n+            srcOff++;\n+            dstOff++;\n+        }\n+        return len;\n+    }\n+\n+    public void run() throws Exception {\n+        \/\/ iterate to eventually get intrinsic inlined\n+        for (int j = 0; j < 200; ++j) {\n+            testConstructBytes();\n+            testConstructChars();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        (new TestStringConstructionIntrinsics()).run();\n+        System.out.println(\"string construction intrinsics validated\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestStringConstructionIntrinsics.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -47,0 +47,5 @@\n+    @jdk.internal.vm.annotation.ForceInline\n+    public static int compress(byte[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+        return StringUTF16.compress(src, srcOff, dst, dstOff, len);\n+    }\n+\n@@ -54,0 +59,5 @@\n+    @jdk.internal.vm.annotation.ForceInline\n+    public static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+        return StringUTF16.compress(src, srcOff, dst, dstOff, len);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/patches\/java.base\/java\/lang\/Helper.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}