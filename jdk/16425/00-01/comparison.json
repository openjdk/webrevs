{"files":[{"patch":"@@ -602,1 +602,1 @@\n-                this.coder = (utf16.length == dp) ? LATIN1 : UTF16;\n+                this.coder = UTF16;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.internal.vm.annotation.ForceInline;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,0 +56,13 @@\n+    \/\/ Check the size of a UTF16-coded string\n+    \/\/ Throw an exception if out of range\n+    public static int newBytesLength(int len) {\n+        if (len < 0) {\n+            throw new NegativeArraySizeException();\n+        }\n+        if (len > MAX_LENGTH) {\n+            throw new OutOfMemoryError(\"UTF16 String size is \" + len +\n+                                       \", should be less than \" + MAX_LENGTH);\n+        }\n+        return len << 1;\n+    }\n+\n@@ -74,5 +87,0 @@\n-    \/\/ Like StringLatin1.isLatin1At, determine if a compact string UTF16-encoded bytes are latin1\n-    private static boolean isLatin1At(byte[] val, int index) {\n-        return val[index * 2 + HI_BYTE_OFFSET] == 0;\n-    }\n-\n@@ -157,2 +165,1 @@\n-     * **Only** use this if it is known that at least one character is UTF16.\n-     * Otherwise, an untrusted char array may have racy contents and really be latin1.\n+     * No checking is done on the characters, some may or may not be latin1.\n@@ -198,1 +205,1 @@\n-     * @param count length of chars to be compressed, length > 0\n+     * @param count count of chars to be compressed, {@code count} > 0\n@@ -209,1 +216,1 @@\n-            if (!isLatin1At(utf16, ndx)\n+            if (getChar(utf16, ndx) > 0xff\n@@ -226,1 +233,1 @@\n-     * @param count length of chars to be compressed, length > 0\n+     * @param count count of chars to be compressed, {@code count} > 0\n@@ -232,1 +239,1 @@\n-            byte[] utf16 = Arrays.copyOfRange(val, off << 1, (off + count) << 1);\n+            byte[] utf16 = Arrays.copyOfRange(val, off << 1, newBytesLength(off + count));\n@@ -235,1 +242,1 @@\n-            if (!isLatin1At(utf16, ndx)\n+            if (getChar(utf16, ndx) > 0xff\n@@ -291,1 +298,1 @@\n-                    extractCodepoints(val, off, end, utf16, ndx);\n+                    utf16 = extractCodepoints(val, off, end, utf16, ndx);\n@@ -295,1 +302,1 @@\n-                    if (isLatin1At(utf16, ndx) &&\n+                    if (getChar(utf16, ndx) <= 0xff &&\n@@ -312,1 +319,4 @@\n-    \/\/ The destination is resized as needed or truncated to the exact size.\n+    \/\/ If the utf16 destination is not large enough, it is resized to fit the\n+    \/\/ remaining codepoints assuming they occupy 2 characters.\n+    \/\/ The destination may be copied to return exactly the final length.\n+    \/\/ The additional allocations and compression only occur if the input array is modified.\n@@ -319,1 +329,1 @@\n-                    + (Character.isBmpCodePoint(codePoint) ? 1 : 2)\n+                    + Character.charCount(codePoint)\n@@ -322,2 +332,5 @@\n-                \/\/ Resize to hold at least the estimated number of chars\n-                dst = Arrays.copyOf(dst, dstLimit << 1);\n+                \/\/ Resize to hold the remaining codepoints assuming they are all surrogates.\n+                \/\/ By resizing to the maximum that might be needed, only a single resize will occur.\n+                \/\/ dstLimit includes only a single char per codepoint, pad with an additional for each.\n+                int maxRemaining = dstLimit + (end - off - 1);\n+                dst = Arrays.copyOf(dst, newBytesLength(maxRemaining));\n@@ -326,0 +339,1 @@\n+            \/\/ The dst at least enough space for the current codepoint.\n@@ -342,1 +356,1 @@\n-            return Arrays.copyOf(dst, dstOff << 1);\n+            return Arrays.copyOf(dst, newBytesLength(dstOff));\n@@ -404,10 +418,0 @@\n-    \/\/ Return the number of chars needed to store the code point.\n-    private static int charsPerCodePoint(int codePoint) {\n-        if (Character.isBmpCodePoint(codePoint)) {\n-            return 1;\n-        } else if (Character.isValidCodePoint(codePoint)) {\n-            return 2;\n-        } else\n-            throw new IllegalArgumentException(Integer.toString(codePoint));\n-    }\n-\n@@ -1681,1 +1685,0 @@\n-    private static final int HI_BYTE_OFFSET;\n@@ -1686,1 +1689,0 @@\n-            HI_BYTE_OFFSET = 0;\n@@ -1690,1 +1692,0 @@\n-            HI_BYTE_OFFSET = 1;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":33,"deletions":32,"binary":false,"changes":65,"status":"modified"}]}