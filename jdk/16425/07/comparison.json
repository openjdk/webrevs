{"files":[{"patch":"@@ -5654,1 +5654,1 @@\n-\/\/     return zero (0) if copy fails, otherwise 'len'.\n+\/\/     return index of non-latin1 character if copy fails, otherwise 'len'.\n@@ -5871,0 +5871,3 @@\n+\/\/ Intrinsic for java.lang.StringUTF16.compress(char[] src, int srcOff, byte[] dst, int dstOff, int len)\n+\/\/ Return the array length if every element in array can be encoded,\n+\/\/ otherwise, the index of first non-latin1 (> 0xff) character.\n@@ -5877,3 +5880,0 @@\n-  \/\/ Adjust result: res == len ? len : 0\n-  cmp(len, res);\n-  csel(res, res, zr, EQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -12730,10 +12730,2 @@\n-    Label Lskip, Ldone;\n-    __ li($result$$Register, 0);\n-    __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,\n-                          $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register, Ldone);\n-    __ rldicl_($tmp1$$Register, $len$$Register, 0, 64-3); \/\/ Remaining characters.\n-    __ beq(CCR0, Lskip);\n-    __ string_compress($src$$Register, $dst$$Register, $tmp1$$Register, $tmp2$$Register, Ldone);\n-    __ bind(Lskip);\n-    __ mr($result$$Register, $len$$Register);\n-    __ bind(Ldone);\n+    __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register, $tmp2$$Register,\n+                        $tmp3$$Register, $tmp4$$Register, $tmp5$$Register, $result$$Register, false);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1863,1 +1863,3 @@\n-\/\/ result: the array length if every element in array can be encoded; 0, otherwise.\n+\/\/ Intrinsic for java.lang.StringUTF16.compress(char[] src, int srcOff, byte[] dst, int dstOff, int len)\n+\/\/ result: the array length if every element in array can be encoded,\n+\/\/ otherwise, the index of first non-latin1 (> 0xff) character.\n@@ -1866,1 +1868,0 @@\n-  Label done;\n@@ -1868,3 +1869,0 @@\n-  beqz(len, done);\n-  mv(result, zr);\n-  bind(done);\n@@ -1878,1 +1876,1 @@\n-\/\/     return zero (0) if copy fails, otherwise 'len'.\n+\/\/     return index of non-latin1 character if copy fails, otherwise 'len'.\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -10193,1 +10193,1 @@\n-                       $tmp$$Register, false, false);\n+                       $tmp$$Register, true, false);\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8482,1 +8482,3 @@\n-\/\/   ..\\jdk\\src\\java.base\\share\\classes\\java\\lang\\StringUTF16.java\n+\/\/ Intrinsic for java.lang.StringUTF16.compress(char[] src, int srcOff, byte[] dst, int dstOff, int len)\n+\/\/ Return the array length if every element in array can be encoded,\n+\/\/ otherwise, the index of first non-latin1 (> 0xff) character.\n@@ -8484,1 +8486,1 @@\n-\/\/   private static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+\/\/   public static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n@@ -8486,3 +8488,3 @@\n-\/\/       int c = src[srcOff++];\n-\/\/       if (c >>> 8 != 0) {\n-\/\/         return 0;\n+\/\/       char c = src[srcOff];\n+\/\/       if (c > 0xff) {\n+\/\/           return i;  \/\/ return index of non-latin1 char\n@@ -8490,1 +8492,3 @@\n-\/\/       dst[dstOff++] = (byte)c;\n+\/\/       dst[dstOff] = (byte)c;\n+\/\/       srcOff++;\n+\/\/       dstOff++;\n@@ -8498,1 +8502,1 @@\n-  Label copy_chars_loop, return_length, return_zero, done;\n+  Label copy_chars_loop, return_length, done, reset_sp, copy_tail;\n@@ -8519,1 +8523,1 @@\n-    Label copy_32_loop, copy_loop_tail, below_threshold;\n+    Label copy_32_loop, copy_loop_tail, below_threshold, reset_for_copy_tail;\n@@ -8524,1 +8528,1 @@\n-    \/\/ if length of the string is less than 16, handle it in an old fashioned way\n+    \/\/ if length of the string is less than 32, handle it the old fashioned way\n@@ -8554,1 +8558,1 @@\n-    jcc(Assembler::carryClear, return_zero);\n+    jcc(Assembler::carryClear, copy_tail);\n@@ -8579,1 +8583,1 @@\n-    jcc(Assembler::carryClear, return_zero);\n+    jcc(Assembler::carryClear, reset_for_copy_tail);\n@@ -8604,1 +8608,1 @@\n-    jcc(Assembler::carryClear, return_zero);\n+    jcc(Assembler::carryClear, copy_tail);\n@@ -8609,0 +8613,6 @@\n+    bind(reset_for_copy_tail);\n+    lea(src, Address(src, tmp5, Address::times_2));\n+    lea(dst, Address(dst, tmp5, Address::times_1));\n+    subptr(len, tmp5);\n+    jmp(copy_chars_loop);\n+\n@@ -8613,1 +8623,1 @@\n-    Label copy_32_loop, copy_16, copy_tail;\n+    Label copy_32_loop, copy_16, copy_tail_sse, reset_for_copy_tail, reset_for_copy_tail_16;\n@@ -8640,1 +8650,1 @@\n-    jcc(Assembler::notZero, return_zero);\n+    jcc(Assembler::notZero, reset_for_copy_tail);\n@@ -8652,1 +8662,1 @@\n-    jccb(Assembler::zero, copy_tail);\n+    jccb(Assembler::zero, copy_tail_sse);\n@@ -8660,1 +8670,1 @@\n-    jccb(Assembler::notZero, return_zero);\n+    jccb(Assembler::notZero, reset_for_copy_tail_16);\n@@ -8665,0 +8675,7 @@\n+    jmp(copy_tail_sse);\n+\n+    bind(reset_for_copy_tail);\n+    lea(src, Address(src, result, Address::times_2));\n+    lea(dst, Address(dst, result, Address::times_1));\n+    subptr(len, result);\n+    jmpb(copy_chars_loop);\n@@ -8666,1 +8683,8 @@\n-    bind(copy_tail);\n+    bind(reset_for_copy_tail_16);\n+    addl(len, result);\n+    lea(src, Address(src, len, Address::times_2));\n+    lea(dst, Address(dst, len, Address::times_1));\n+    negptr(len);\n+    jmpb(copy_chars_loop);\n+\n+    bind(copy_tail_sse);\n@@ -8670,0 +8694,1 @@\n+  bind(copy_tail);\n@@ -8679,1 +8704,1 @@\n-  jccb(Assembler::notZero, return_zero);\n+  jccb(Assembler::notZero, reset_sp);\n@@ -8689,4 +8714,3 @@\n-  \/\/ if compression failed, return 0\n-  bind(return_zero);\n-  xorl(result, result);\n-  addptr(rsp, wordSize);\n+  bind(reset_sp);\n+  pop(result);\n+  addl(result, len);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":46,"deletions":22,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -133,0 +133,3 @@\n+     * <p>\n+     * The contents are indeterminate if the {@code CharSequence}\n+     * is modified before the constructor returns.\n@@ -669,0 +672,3 @@\n+     * <p>\n+     * The contents are indeterminate if the {@code CharSequence}\n+     * is modified before the method returns.\n@@ -1244,0 +1250,3 @@\n+     * <p>\n+     * The contents are indeterminate if the {@code CharSequence}\n+     * is modified before the method returns.\n@@ -1292,0 +1301,3 @@\n+     * <p>\n+     * The contents are indeterminate if the {@code CharSequence}\n+     * is modified before the method returns.\n@@ -1679,4 +1691,2 @@\n-            if (this.value != null) {\n-                this.coder = LATIN1;\n-                return;\n-            }\n+            this.coder = (this.value.length == len) ? LATIN1 : UTF16;\n+            return;\n@@ -1723,0 +1733,3 @@\n+                    \/\/ store c to make sure it has a UTF16 char\n+                    StringUTF16.putChar(this.value, j++, c);\n+                    i++;\n@@ -1815,0 +1828,4 @@\n+                    \/\/ Store c to make sure sb has a UTF16 char\n+                    StringUTF16.putChar(this.value, j++, c);\n+                    count = j;\n+                    i++;\n@@ -1926,0 +1943,3 @@\n+     * <p>\n+     * The contents are indeterminate if the {@code CharSequence}\n+     * is modified before the method returns.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -60,0 +60,4 @@\n+     * <p>\n+     * The contents of this {@code Appendable} are indeterminate if the argument\n+     * is modified before the {@code append} method returns or an exception is thrown\n+     * when accessing the {@code CharSequence}.\n@@ -84,0 +88,4 @@\n+     * <p>\n+     * The contents of this {@code Appendable} are indeterminate if the argument\n+     * is modified before the {@code append} method returns or an exception is thrown\n+     * when accessing the {@code CharSequence}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Appendable.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -276,0 +276,3 @@\n+     * <p> The contents of the string are indeterminate if the character array\n+     * is modified before the constructor returns.\n+     *\n@@ -291,0 +294,3 @@\n+     * <p> The contents of the string are indeterminate if the character array\n+     * is modified before the constructor returns.\n+     *\n@@ -322,0 +328,3 @@\n+     * <p> The contents of the string are indeterminate if the array of codepoints\n+     * is modified before the constructor returns.\n+     *\n@@ -349,6 +358,4 @@\n-            byte[] val = StringLatin1.toBytes(codePoints, offset, count);\n-            if (val != null) {\n-                this.coder = LATIN1;\n-                this.value = val;\n-                return;\n-            }\n+            byte[] val = StringUTF16.compress(codePoints, offset, count);\n+            this.coder = (val.length == count) ? LATIN1 : UTF16;\n+            this.value = val;\n+            return;\n@@ -371,0 +378,3 @@\n+     * <p> The contents of the string are indeterminate if the byte array\n+     * is modified before the constructor returns.\n+     *\n@@ -432,0 +442,3 @@\n+     * <p> The contents of the string are indeterminate if the byte array\n+     * is modified before the constructor returns.\n+     *\n@@ -466,0 +479,3 @@\n+     * <p> The contents of the string are indeterminate if the byte array\n+     * is modified before the constructor returns.\n+     *\n@@ -504,0 +520,3 @@\n+     * <p> The contents of the string are indeterminate if the byte array\n+     * is modified before the constructor returns.\n+     *\n@@ -546,8 +565,5 @@\n-                int sl = offset + length;\n-                byte[] dst = new byte[length];\n-                if (dp > 0) {\n-                    System.arraycopy(bytes, offset, dst, 0, dp);\n-                    offset += dp;\n-                }\n-                while (offset < sl) {\n-                    int b1 = bytes[offset++];\n+                \/\/ Decode with a stable copy, to be the result if the decoded length is the same\n+                byte[] latin1 = Arrays.copyOfRange(bytes, offset, offset + length);\n+                int sp = dp;            \/\/ first dp bytes are already in the copy\n+                while (sp < length) {\n+                    int b1 = latin1[sp++];\n@@ -555,1 +571,1 @@\n-                        dst[dp++] = (byte)b1;\n+                        latin1[dp++] = (byte)b1;\n@@ -558,2 +574,2 @@\n-                    if ((b1 & 0xfe) == 0xc2 && offset < sl) { \/\/ b1 either 0xc2 or 0xc3\n-                        int b2 = bytes[offset];\n+                    if ((b1 & 0xfe) == 0xc2 && sp < length) { \/\/ b1 either 0xc2 or 0xc3\n+                        int b2 = latin1[sp];\n@@ -561,2 +577,2 @@\n-                            dst[dp++] = (byte)decode2(b1, b2);\n-                            offset++;\n+                            latin1[dp++] = (byte)decode2(b1, b2);\n+                            sp++;\n@@ -568,1 +584,1 @@\n-                    offset--;\n+                    sp--;\n@@ -571,3 +587,3 @@\n-                if (offset == sl) {\n-                    if (dp != dst.length) {\n-                        dst = Arrays.copyOf(dst, dp);\n+                if (sp == length) {\n+                    if (dp != latin1.length) {\n+                        latin1 = Arrays.copyOf(latin1, dp);\n@@ -575,1 +591,1 @@\n-                    this.value = dst;\n+                    this.value = latin1;\n@@ -579,4 +595,3 @@\n-                byte[] buf = new byte[length << 1];\n-                StringLatin1.inflate(dst, 0, buf, 0, dp);\n-                dst = buf;\n-                dp = decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n+                byte[] utf16 = new byte[length << 1];\n+                StringLatin1.inflate(latin1, 0, utf16, 0, dp);\n+                dp = decodeUTF8_UTF16(latin1, sp, length, utf16, dp, true);\n@@ -584,1 +599,1 @@\n-                    dst = Arrays.copyOf(dst, dp << 1);\n+                    utf16 = Arrays.copyOf(utf16, dp << 1);\n@@ -586,1 +601,1 @@\n-                this.value = dst;\n+                this.value = utf16;\n@@ -658,6 +673,3 @@\n-                    byte[] bs = StringUTF16.compress(ca, 0, clen);\n-                    if (bs != null) {\n-                        value = bs;\n-                        coder = LATIN1;\n-                        return;\n-                    }\n+                    this.value = StringUTF16.compress(ca, 0, clen);\n+                    this.coder = (this.value.length == clen) ? LATIN1 : UTF16;\n+                    return;\n@@ -689,6 +701,3 @@\n-                byte[] bs = StringUTF16.compress(ca, 0, caLen);\n-                if (bs != null) {\n-                    value = bs;\n-                    coder = LATIN1;\n-                    return;\n-                }\n+                this.value = StringUTF16.compress(ca, 0, caLen);\n+                this.coder = (this.value.length == caLen) ? LATIN1 : UTF16;\n+                return;\n@@ -832,4 +841,3 @@\n-            byte[] bs = StringUTF16.compress(ca, 0, caLen);\n-            if (bs != null) {\n-                return new String(bs, LATIN1);\n-            }\n+            byte[] value = StringUTF16.compress(ca, 0, caLen);\n+            int coder = (value.length == len) ? LATIN1 : UTF16;\n+            return new String(value, coder);\n@@ -1389,0 +1397,3 @@\n+     * <p> The contents of the string are indeterminate if the byte array\n+     * is modified before the constructor returns.\n+     *\n@@ -1417,0 +1428,3 @@\n+     * <p> The contents of the string are indeterminate if the byte array\n+     * is modified before the constructor returns.\n+     *\n@@ -1441,0 +1455,3 @@\n+     * <p> The contents of the string are indeterminate if the byte array\n+     * is modified before the constructor returns.\n+     *\n@@ -1471,0 +1488,3 @@\n+     * <p> The contents of the string are indeterminate if the byte array\n+     * is modified before the constructor returns.\n+     *\n@@ -1499,0 +1519,3 @@\n+     * <p> The contents of the string are indeterminate if the {@code StringBuilder}\n+     * is modified before the constructor returns.\n+     *\n@@ -4491,0 +4514,3 @@\n+     * <p> The contents of the string are indeterminate if the character array\n+     * is modified before the constructor returns.\n+     *\n@@ -4509,0 +4535,3 @@\n+     * <p> The contents of the string are indeterminate if the character array\n+     * is modified before the constructor returns.\n+     *\n@@ -4770,1 +4799,1 @@\n-     * Package private constructor. Trailing Void argument is there for\n+     * Private constructor. Trailing Void argument is there for\n@@ -4777,0 +4806,3 @@\n+     *\n+     * <p> The contents of the string are indeterminate if the character array\n+     * is modified before the constructor returns.\n@@ -4778,1 +4810,1 @@\n-    String(char[] value, int off, int len, Void sig) {\n+    private String(char[] value, int off, int len, Void sig) {\n@@ -4786,5 +4818,3 @@\n-            if (val != null) {\n-                this.value = val;\n-                this.coder = LATIN1;\n-                return;\n-            }\n+            this.coder = (val.length == len) ? LATIN1 : UTF16;\n+            this.value = val;\n+            return;\n@@ -4799,0 +4829,3 @@\n+     *\n+     * <p> The contents of the string are indeterminate if the {@code StringBuilder}\n+     * is modified before the constructor returns.\n@@ -4809,6 +4842,3 @@\n-                byte[] buf = StringUTF16.compress(val, 0, length);\n-                if (buf != null) {\n-                    this.coder = LATIN1;\n-                    this.value = buf;\n-                    return;\n-                }\n+                this.value = StringUTF16.compress(val, 0, length);\n+                this.coder = (this.value.length == length) ? LATIN1 : UTF16;\n+                return;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":89,"deletions":59,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -50,0 +50,4 @@\n+    public static boolean canEncode(char cp) {\n+        return cp <= 0xff;\n+    }\n+\n@@ -51,1 +55,1 @@\n-        return cp >>> 8 == 0;\n+        return cp >=0 && cp <= 0xff;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.internal.vm.annotation.DontInline;\n@@ -57,0 +56,13 @@\n+    \/\/ Check the size of a UTF16-coded string\n+    \/\/ Throw an exception if out of range\n+    public static int newBytesLength(int len) {\n+        if (len < 0) {\n+            throw new NegativeArraySizeException();\n+        }\n+        if (len > MAX_LENGTH) {\n+            throw new OutOfMemoryError(\"UTF16 String size is \" + len +\n+                                       \", should be less than \" + MAX_LENGTH);\n+        }\n+        return len << 1;\n+    }\n+\n@@ -151,0 +163,7 @@\n+    \/**\n+     * {@return an encoded byte[] for the UTF16 characters in char[]}\n+     * No checking is done on the characters, some may or may not be latin1.\n+     * @param value a char array\n+     * @param off an offset\n+     * @param len a length\n+     *\/\n@@ -161,4 +180,40 @@\n-    public static byte[] compress(char[] val, int off, int len) {\n-        byte[] ret = new byte[len];\n-        if (compress(val, off, ret, 0, len) == len) {\n-            return ret;\n+    \/**\n+     * {@return Compress the char array (containing UTF16) into a compact strings byte array}\n+     * If all the chars are LATIN1, it returns an array with len == count,\n+     * otherwise, it contains UTF16 characters.\n+     * <p>\n+     * A UTF16 array is returned *only* if at least 1 non-latin1 character is present.\n+     * This must be true even if the input array is modified while this method is executing.\n+     * This is assured by copying the characters while checking for latin1.\n+     * If all characters are latin1, a byte array with length equals count is returned,\n+     * indicating all latin1 chars. The scan may be implemented as an intrinsic,\n+     * which returns the index of the first non-latin1 character.\n+     * When the first non-latin1 character is found, it switches to creating a new\n+     * buffer; the saved prefix of latin1 characters is copied to the new buffer;\n+     * and the remaining input characters are copied to the buffer.\n+     * The index of the known non-latin1 character is checked, if it is latin1,\n+     * the input has been changed. In this case, a second attempt is made to compress to\n+     * latin1 from the copy made in the first pass to the originally allocated latin1 buffer.\n+     * If it succeeds the return value is latin1, otherwise, the utf16 value is returned.\n+     * In this unusual case, the result is correct for the snapshot of the value.\n+     * The resulting string may be indeterminate if the input array is modified during this\n+     * operation, but it is ensured that at least 1 non-latin1 character is present in\n+     * the non-latin1 buffer.\n+     *\n+     * @param val   a char array\n+     * @param off   starting offset\n+     * @param count count of chars to be compressed, {@code count} > 0\n+     *\/\n+    @ForceInline\n+    public static byte[] compress(final char[] val, final int off, final int count) {\n+        byte[] latin1 = new byte[count];\n+        int ndx = compress(val, off, latin1, 0, count);\n+        if (ndx != count) {\n+            \/\/ Switch to UTF16\n+            byte[] utf16 = toBytes(val, off, count);\n+            \/\/ If the original character that was found to be non-latin1 is latin1 in the copy\n+            \/\/ try to make a latin1 string from the copy\n+            if (getChar(utf16, ndx) > 0xff\n+                    || compress(utf16, 0, latin1, 0, count) != count) {\n+                return utf16;\n+            }\n@@ -166,1 +221,1 @@\n-        return null;\n+        return latin1;     \/\/ latin1 success\n@@ -169,4 +224,22 @@\n-    public static byte[] compress(byte[] val, int off, int len) {\n-        byte[] ret = new byte[len];\n-        if (compress(val, off, ret, 0, len) == len) {\n-            return ret;\n+    \/**\n+     * {@return Compress the internal byte array (containing UTF16) into a compact strings byte array}\n+     * If all the chars are LATIN1, it returns an array with len == count,\n+     * otherwise, it contains UTF16 characters.\n+     * <p>\n+     * Refer to the description of the algorithm in {@link #compress(char[], int, int)}.\n+     *\n+     * @param val   a byte array with UTF16 coding\n+     * @param off   starting offset\n+     * @param count count of chars to be compressed, {@code count} > 0\n+     *\/\n+    public static byte[] compress(final byte[] val, final int off, final int count) {\n+        byte[] latin1 = new byte[count];\n+        int ndx = compress(val, off, latin1, 0, count);\n+        if (ndx != count) {\/\/ Switch to UTF16\n+            byte[] utf16 = Arrays.copyOfRange(val, off << 1, newBytesLength(off + count));\n+            \/\/ If the original character that was found to be non-latin1 is latin1 in the copy\n+            \/\/ try to make a latin1 string from the copy\n+            if (getChar(utf16, ndx) > 0xff\n+                    || compress(utf16, 0, latin1, 0, count) != count) {\n+                return utf16;\n+            }\n@@ -174,1 +247,128 @@\n-        return null;\n+        return latin1;     \/\/ latin1 success\n+    }\n+\n+    \/**\n+     * {@return compress the code points into a compact strings byte array}\n+     * If all the chars are LATIN1, returns an array with len == count.\n+     * If not, a new byte array is allocated and code points converted to UTF16.\n+     * The algorithm is similar to that of {@link #compress(char[], int, int)}.\n+     * <p>\n+     * The resulting encoding is attempted in several steps:\n+     * <UL>\n+     *     <LI>If no non-latin1 characters are found, the encoding is latin1<\/LI>\n+     *     <LI>If an estimate of the number of characters needed to represent the codepoints is\n+     *         equal to the string length, they are all BMP with at least 1 UTF16 character\n+     *         and are copied to the result. <\/LI>\n+     *     <LI>The extractCodePoints method is called to carefully expand surrogates. <\/LI>\n+     * <\/UL>\n+     *\n+     * @param val   an int array of code points\n+     * @param off   starting offset\n+     * @param count length of code points to be compressed, length > 0\n+     *\/\n+    public static byte[] compress(final int[] val, int off, final int count) {\n+        \/\/ Optimistically copy all latin1 code points to the destination\n+        byte[] latin1 = new byte[count];\n+        final int end = off + count;\n+        for (int ndx = 0; ndx < count; ndx++, off++) {\n+            int cp = val[off];\n+            if (cp >= 0 && cp <= 0xff) {\n+                latin1[ndx] = (byte)cp;\n+            } else {\n+                \/\/ Pass 1: Compute precise size of char[]; see extractCodePoints for caveat\n+                int estSize = ndx + computeCodePointSize(val, off, end);\n+\n+                \/\/ Pass 2: Switch to UTF16\n+                \/\/ cp = val[ndx] is at least one code point known to be UTF16\n+                byte[] utf16 = newBytesFor(estSize);\n+                if (ndx > 0) {\n+                    StringLatin1.inflate(latin1, 0, utf16, 0, ndx); \/\/ inflate latin1 bytes\n+                }\n+\n+                if (estSize == count) {\n+                    \/\/ Based on the computed size, all remaining code points are BMP and\n+                    \/\/ can be copied without checking again\n+                    putChar(utf16, ndx, cp);        \/\/ ensure utf16 has a UTF16 char\n+                    off++;\n+                    for (int i = ndx + 1; i < count; i++, off++) {\n+                        putChar(utf16, i, val[off]);\n+                    }\n+                } else {\n+                    \/\/ Some codepoint is a surrogate pair\n+                    utf16 = extractCodepoints(val, off, end, utf16, ndx);\n+\n+                    \/\/ The original character that was found to be UTF16 is not UTF16 in the copy\n+                    \/\/ Try to make a latin1 string from the copy\n+                    if (getChar(utf16, ndx) <= 0xff &&\n+                            compress(utf16, 0, latin1, 0, count) == count) {\n+                        return latin1;     \/\/ latin1 success\n+                    }\n+                }\n+                return utf16;\n+            }\n+        }\n+        return latin1;     \/\/ Latin1 success\n+    }\n+\n+    \/\/ Extract code points into chars in the byte array\n+    \/\/\n+    \/\/ Guard against possible races with the input array changing between the previous\n+    \/\/ computation of the required output size and storing the bmp or surrogates.\n+    \/\/ If a BMP code point is changed to a supplementary code point it would require 2 chars\n+    \/\/ in the output. Changing a supplementary char to BMP would reduce the size.\n+    \/\/ If the utf16 destination is not large enough, it is resized to fit the\n+    \/\/ remaining codepoints assuming they occupy 2 characters.\n+    \/\/ The destination may be copied to return exactly the final length.\n+    \/\/ The additional allocations and compression only occur if the input array is modified.\n+    private static byte[] extractCodepoints(int[] val, int off, int end, byte[] dst, int dstOff) {\n+        while (off < end) {\n+            \/\/ Compute a minimum estimate on the number of characters can be put into the dst\n+            \/\/ given the current codepoint and the number of remaining codepoints\n+            int codePoint = val[off];           \/\/ read each codepoint from val only once\n+            int dstLimit = dstOff\n+                    + Character.charCount(codePoint)\n+                    + (end - off - 1);\n+            if (dstLimit > (dst.length >> 1)) {\n+                \/\/ Resize to hold the remaining codepoints assuming they are all surrogates.\n+                \/\/ By resizing to the maximum that might be needed, only a single resize will occur.\n+                \/\/ dstLimit includes only a single char per codepoint, pad with an additional for each.\n+                int maxRemaining = dstLimit + (end - off - 1);\n+                dst = Arrays.copyOf(dst, newBytesLength(maxRemaining));\n+            }\n+            \/\/ Efficiently copy as many codepoints as fit within the current estimated limit\n+            \/\/ The dst at least enough space for the current codepoint.\n+            while (true) {\n+                if (Character.isBmpCodePoint(codePoint)) {\n+                    putChar(dst, dstOff++, codePoint);\n+                } else {\n+                    putChar(dst, dstOff++, Character.highSurrogate(codePoint));\n+                    putChar(dst, dstOff++, Character.lowSurrogate(codePoint));\n+                }\n+                off++;\n+                if (dstOff + 2 > dstLimit)\n+                    break;      \/\/ no space for another surrogate; recompute limit\n+                codePoint = val[off];\n+            }\n+        }\n+        if (dstOff != (dst.length >> 1)) {\n+            \/\/ Truncate to actual length; should only occur if a codepoint was racily\n+            \/\/ changed from a surrogate to a BMP character.\n+            return Arrays.copyOf(dst, newBytesLength(dstOff));\n+        }\n+        return dst;\n+    }\n+\n+    \/\/ Compute the number of chars needed to represent the code points from off to end-1\n+    private static int computeCodePointSize(int[] val, int off, int end) {\n+        int n = end - off;\n+        while (off < end) {\n+            int codePoint = val[off++];\n+            if (Character.isBmpCodePoint(codePoint)) {\n+                continue;\n+            } else if (Character.isValidCodePoint(codePoint)) {\n+                n++;\n+            } else {\n+                throw new IllegalArgumentException(Integer.toString(codePoint));\n+            }\n+        }\n+        return n;\n@@ -182,3 +382,2 @@\n-            if (c > 0xFF) {\n-                len = 0;\n-                break;\n+            if (c > 0xff) {\n+                return i;  \/\/ return index of non-latin1 char\n@@ -200,3 +399,2 @@\n-            if (c > 0xFF) {\n-                len = 0;\n-                break;\n+            if (c > 0xff) {\n+                return i;  \/\/ return index of non-latin1 char\n@@ -211,0 +409,1 @@\n+    \/\/ Create the UTF16 buffer for !COMPACT_STRINGS\n@@ -213,11 +412,2 @@\n-        \/\/ Pass 1: Compute precise size of char[]\n-        int n = len;\n-        for (int i = index; i < end; i++) {\n-            int cp = val[i];\n-            if (Character.isBmpCodePoint(cp))\n-                continue;\n-            else if (Character.isValidCodePoint(cp))\n-                n++;\n-            else throw new IllegalArgumentException(Integer.toString(cp));\n-        }\n-        \/\/ Pass 2: Allocate and fill in <high, low> pair\n+        int n = computeCodePointSize(val, index, end);\n+\n@@ -225,11 +415,2 @@\n-        for (int i = index, j = 0; i < end; i++, j++) {\n-            int cp = val[i];\n-            if (Character.isBmpCodePoint(cp)) {\n-                putChar(buf, j, cp);\n-            } else {\n-                putChar(buf, j++, Character.highSurrogate(cp));\n-                putChar(buf, j, Character.lowSurrogate(cp));\n-            }\n-        }\n-        return buf;\n-    }\n+        return extractCodepoints(val, index, len, buf, 0);\n+     }\n@@ -656,4 +837,3 @@\n-                byte[] val = compress(buf, 0, len);\n-                if (val != null) {\n-                    return new String(val, LATIN1);\n-                }\n+                byte[] res = StringUTF16.compress(buf, 0, len);\n+                byte coder = (res.length == len) ? LATIN1 : UTF16;\n+                return new String(res, coder);\n@@ -774,4 +954,3 @@\n-            byte[] lat1Result = compress(result, 0, resultLen);\n-            if (lat1Result != null) {\n-                return new String(lat1Result, LATIN1);\n-            }\n+            byte[] res = StringUTF16.compress(result, 0, resultLen);\n+            byte coder = (res.length == resultLen) ? LATIN1 : UTF16;\n+            return new String(res, coder);    \/\/ combination 6\n@@ -841,1 +1020,1 @@\n-        if (bits > 0xFF) {\n+        if (bits < 0 || bits > 0xff) {\n@@ -942,1 +1121,1 @@\n-        if (bits > 0xFF) {\n+        if (bits < 0 || bits > 0xff) {\n@@ -1171,4 +1350,3 @@\n-            byte[] buf = compress(val, index, len);\n-            if (buf != null) {\n-                return new String(buf, LATIN1);\n-            }\n+            byte[] res = StringUTF16.compress(val, index, len);\n+            byte coder = (res.length == len) ? LATIN1 : UTF16;\n+            return new String(res, coder);\n@@ -1505,2 +1683,2 @@\n-    static final int HI_BYTE_SHIFT;\n-    static final int LO_BYTE_SHIFT;\n+    private static final int HI_BYTE_SHIFT;\n+    private static final int LO_BYTE_SHIFT;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":233,"deletions":55,"binary":false,"changes":288,"status":"modified"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8311906\n+ * @summary Validates String constructor intrinsics using varied input data.\n+ * @key randomness\n+ * @library \/compiler\/patches \/test\/lib\n+ * @build java.base\/java.lang.Helper\n+ * @run main\/othervm\/timeout=1200 -Xbatch -XX:CompileThreshold=100 compiler.intrinsics.string.TestStringConstructionIntrinsics\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8311906\n+ * @summary Validates String constructor intrinsic for AVX3 works with and without\n+ *          AVX3Threshold=0\n+ * @key randomness\n+ * @library \/compiler\/patches \/test\/lib\n+ * @build java.base\/java.lang.Helper\n+ * @requires vm.cpu.features ~= \".*avx512.*\"\n+ * @run main\/othervm\/timeout=1200 -Xbatch -XX:CompileThreshold=100 -XX:UseAVX=3 compiler.intrinsics.string.TestStringConstructionIntrinsics\n+ * @run main\/othervm\/timeout=1200 -Xbatch -XX:CompileThreshold=100 -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:AVX3Threshold=0 compiler.intrinsics.string.TestStringConstructionIntrinsics\n+ *\/\n+\n+package compiler.intrinsics.string;\n+\n+import java.lang.Helper;\n+import java.util.Random;\n+\n+import jdk.test.lib.Utils;\n+\n+public class TestStringConstructionIntrinsics {\n+\n+    private static byte[] bytes = new byte[2 * (4096 + 32)];\n+\n+    private static char[] chars = new char[4096 + 32];\n+\n+    \/\/ Used a scratch buffer, sized to accommodate inflated\n+    private static byte[] dst = new byte[bytes.length * 2];\n+\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    \/**\n+     * Completely initialize the bytes test array. The lowest index that will be\n+     * non-latin1 is marked by nlOffset\n+     *\/\n+    public static void initializeBytes(int off, int len, int nonLatin1, int nlOffset) {\n+        int maxLen = bytes.length >> 1;\n+        assert (len + off < maxLen);\n+        \/\/ insert \"canary\" (non-latin1) values before offset\n+        for (int i = 0; i < off; i++) {\n+            Helper.putCharSB(bytes, i, ((i + 15) & 0x7F) | 0x180);\n+        }\n+        \/\/ fill the array segment\n+        for (int i = off; i < len + off; i++) {\n+            Helper.putCharSB(bytes, i, ((i - off + 15) & 0xFF));\n+        }\n+        if (nonLatin1 != 0) {\n+            \/\/ modify a number disparate indexes to be non-latin1\n+            for (int i = 0; i < nonLatin1; i++) {\n+                int idx = off + RANDOM.nextInt(len - nlOffset) + nlOffset;\n+                Helper.putCharSB(bytes, i, ((i + 15) & 0x7F) | 0x180);\n+            }\n+        }\n+        \/\/ insert \"canary\" non-latin1 values after array segment\n+        for (int i = len + off; i < maxLen; i++) {\n+            Helper.putCharSB(bytes, i, ((i + 15) & 0x7F) | 0x180);\n+        }\n+    }\n+\n+    \/**\n+     * Completely initialize the char test array. The lowest index that will be\n+     * non-latin1 is marked by nlOffset\n+     *\/\n+    public static void initializeChars(int off, int len, int nonLatin1, int nlOffset) {\n+        assert (len + off <= chars.length);\n+        \/\/ insert \"canary\" non-latin1 values before offset\n+        for (int i = 0; i < off; ++i) {\n+            chars[i] = (char) (((i + 15) & 0x7F) | 0x180);\n+        }\n+        \/\/ fill the array segment\n+        for (int i = off; i < len + off; ++i) {\n+            chars[i] = (char) (((i - off + 15) & 0xFF));\n+        }\n+        if (nonLatin1 != 0) {\n+            \/\/ modify a number disparate chars inside\n+            \/\/ segment to be non-latin1.\n+            for (int i = 0; i < nonLatin1; i++) {\n+                int idx = off + RANDOM.nextInt(len - nlOffset) + nlOffset;\n+                chars[idx] = (char) (0x180 | chars[idx]);\n+            }\n+        }\n+        \/\/ insert \"canary\" non-latin1 values after array segment\n+        for (int i = len + off; i < chars.length; ++i) {\n+            chars[i] = (char) (((i + 15) & 0x7F) | 0x180);\n+        }\n+    }\n+\n+    \/**\n+     * Test different array segment sizes, offsets, and number of non-latin1\n+     * chars.\n+     *\/\n+    public static void testConstructBytes() throws Exception {\n+        for (int off = 0; off < 16; off++) { \/\/ starting offset of array segment\n+            \/\/ Test all array segment sizes 1-63\n+            for (int len = 1; len < 64; len++) {\n+                testConstructBytes(off, len, 0, 0);\n+                testConstructBytes(off, len, 1, 0);\n+                testConstructBytes(off, len, RANDOM.nextInt(30) + 2, 0);\n+            }\n+            \/\/ Test a random selection of sizes between 64 and 4099, inclusive\n+            for (int i = 0; i < 20; i++) {\n+                int len = 64 + RANDOM.nextInt(4100 - 64);\n+                testConstructBytes(off, len, 0, 0);\n+                testConstructBytes(off, len, 1, 0);\n+                testConstructBytes(off, len, RANDOM.nextInt(len) + 2, 0);\n+            }\n+            for (int len : new int[] { 128, 2048 }) {\n+                \/\/ test with negatives only in a 1-63 byte tail\n+                int tail = RANDOM.nextInt(63) + 1;\n+                int ng = RANDOM.nextInt(tail) + 1;\n+                testConstructBytes(off, len + tail, ng, len);\n+            }\n+        }\n+    }\n+\n+    private static void testConstructBytes(int off, int len, int ng, int ngOffset) throws Exception {\n+        assert (len + off < bytes.length);\n+        initializeBytes(off, len, ng, ngOffset);\n+        byte[] dst = new byte[bytes.length];\n+\n+        int calculated = Helper.compress(bytes, off, dst, 0, len);\n+        int expected = compress(bytes, off, dst, 0, len);\n+        if (calculated != expected) {\n+            if (expected != len && ng >= 0 && calculated >= 0 && calculated < expected) {\n+                \/\/ allow intrinsics to return early with a lower value,\n+                \/\/ but only if we're not expecting the full length (no\n+                \/\/ negative bytes)\n+                return;\n+            }\n+            throw new Exception(\"Failed testConstructBytes: \" + \"offset: \" + off + \" \"\n+                    + \"length: \" + len + \" \" + \"return: \" + calculated + \" expected: \" + expected + \" negatives: \"\n+                    + ng + \" offset: \" + ngOffset);\n+        }\n+    }\n+\n+    private static int compress(byte[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+        for (int i = 0; i < len; i++) {\n+            char c = Helper.charAt(src, srcOff);\n+            if (c > 0xff) {\n+                return i;  \/\/ return index of non-latin1 char\n+            }\n+            dst[dstOff] = (byte)c;\n+            srcOff++;\n+            dstOff++;\n+        }\n+        return len;\n+    }\n+\n+    \/**\n+     * Test different array segment sizes, offsets, and number of non-latin1\n+     * chars.\n+     *\/\n+    public static void testConstructChars() throws Exception {\n+        for (int off = 0; off < 16; off++) { \/\/ starting offset of array segment\n+            \/\/ Test all array segment sizes 1-63\n+            for (int len = 1; len < 64; len++) {\n+                testConstructChars(off, len, 0, 0);\n+                testConstructChars(off, len, 1, 0);\n+                testConstructChars(off, len, RANDOM.nextInt(30) + 2, 0);\n+            }\n+            \/\/ Test a random selection of sizes between 64 and 4099, inclusive\n+            for (int i = 0; i < 20; i++) {\n+                int len = 64 + RANDOM.nextInt(4100 - 64);\n+                testConstructChars(off, len, 0, 0);\n+                testConstructChars(off, len, 1, 0);\n+                testConstructChars(off, len, RANDOM.nextInt(len) + 2, 0);\n+            }\n+            for (int len : new int[] { 128, 2048 }) {\n+                \/\/ test with negatives only in a 1-63 byte tail\n+                int tail = RANDOM.nextInt(63) + 1;\n+                int ng = RANDOM.nextInt(tail) + 1;\n+                testConstructChars(off, len + tail, ng, len);\n+            }\n+        }\n+    }\n+\n+    private static void testConstructChars(int off, int len, int nonLatin1, int nlOffset) throws Exception {\n+        assert (len + off < bytes.length);\n+        initializeChars(off, len, nonLatin1, nlOffset);\n+\n+        int calculated = Helper.compress(chars, off, dst, 0, len);\n+        int expected = compress(chars, off, dst, 0, len);\n+        if (calculated != expected) {\n+            if (expected != len && nonLatin1 >= 0 && calculated >= 0 && calculated < expected) {\n+                \/\/ allow intrinsics to return early with a lower value,\n+                \/\/ but only if we're not expecting the full length (no\n+                \/\/ negative bytes)\n+                return;\n+            }\n+            throw new Exception(\"Failed testConstructChars: \" + \"offset: \" + off + \" \"\n+                    + \"length: \" + len + \" \" + \"return: \" + calculated + \" expected: \" + expected + \" non-latin1: \"\n+                    + nonLatin1 + \" offset: \" + nlOffset);\n+        }\n+    }\n+\n+    private static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+        for (int i = 0; i < len; i++) {\n+            char c = src[srcOff];\n+            if (c > 0xff) {\n+                return i;  \/\/ return index of non-latin1 char\n+            }\n+            dst[dstOff] = (byte)c;\n+            srcOff++;\n+            dstOff++;\n+        }\n+        return len;\n+    }\n+\n+    public void run() throws Exception {\n+        \/\/ iterate to eventually get intrinsic inlined\n+        for (int j = 0; j < 200; ++j) {\n+            testConstructBytes();\n+            testConstructChars();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        (new TestStringConstructionIntrinsics()).run();\n+        System.out.println(\"string construction intrinsics validated\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestStringConstructionIntrinsics.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -47,0 +47,5 @@\n+    @jdk.internal.vm.annotation.ForceInline\n+    public static int compress(byte[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+        return StringUTF16.compress(src, srcOff, dst, dstOff, len);\n+    }\n+\n@@ -54,0 +59,5 @@\n+    @jdk.internal.vm.annotation.ForceInline\n+    public static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+        return StringUTF16.compress(src, srcOff, dst, dstOff, len);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/patches\/java.base\/java\/lang\/Helper.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,4 +25,4 @@\n-    @test\n-    @bug 8054307\n-    @summary test chars() and codePoints()\n-*\/\n+ * @test\n+ * @bug 8054307 8311906\n+ * @summary test String chars() and codePoints()\n+ *\/\n@@ -47,0 +47,1 @@\n+            testCharsSubrange(cc, ccExp);\n@@ -54,0 +55,1 @@\n+            testCharsSubrange(cc, ccExp);\n@@ -72,0 +74,1 @@\n+            testCharsSubrange(cc, ccExp);\n@@ -79,1 +82,22 @@\n-            throw new RuntimeException(\"chars\/codePoints() failed!\");\n+            throw new RuntimeException(\"testChars failed!\");\n+        }\n+    }\n+\n+    static void testCharsSubrange(char[] cc, int[] expected) {\n+        int[] offsets = { 7, 31 };   \/\/ offsets to test\n+        int LENGTH = 13;\n+        for (int i = 0; i < offsets.length; i++) {\n+            int offset = Math.max(0, offsets[i]);       \/\/ confine to the input array\n+            int count = Math.min(LENGTH, cc.length - offset);\n+            String str = new String(cc, offset, count);\n+            int[] actual = str.chars().toArray();\n+            int errOffset = Arrays.mismatch(actual, 0, actual.length,\n+                    expected, offset, offset + count);\n+            if (errOffset >= 0) {\n+                System.err.printf(\"expected[%d] (%d) != actual[%d] (%d)%n\",\n+                        offset + errOffset, expected[offset + errOffset],\n+                        errOffset, actual[errOffset]);\n+                System.err.println(\"expected: \" + Arrays.toString(expected));\n+                System.err.println(\"actual: \" + Arrays.toString(actual));\n+                throw new RuntimeException(\"testCharsSubrange failed!\");\n+            }\n@@ -86,1 +110,1 @@\n-            throw new RuntimeException(\"chars\/codePoints() failed!\");\n+            throw new RuntimeException(\"testCPs failed!\");\n","filename":"test\/jdk\/java\/lang\/String\/Chars.java","additions":31,"deletions":7,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,437 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.java.lang.String;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.ConcurrentModificationException;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledIf;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n+ * @test\n+ * @bug 8311906\n+ * @modules java.base\/java.lang:open\n+ * @summary check String's racy constructors\n+ * @run junit\/othervm -XX:+CompactStrings test.java.lang.String.StringRacyConstructor\n+ * @run junit\/othervm -XX:-CompactStrings test.java.lang.String.StringRacyConstructor\n+ *\/\n+\n+public class StringRacyConstructor {\n+    private static final byte LATIN1 = 0;\n+    private static final byte UTF16  = 1;\n+\n+    private static final Field STRING_CODER_FIELD;\n+    private static final Field SB_CODER_FIELD;\n+    private static final boolean COMPACT_STRINGS;\n+\n+    static {\n+        try {\n+            STRING_CODER_FIELD = String.class.getDeclaredField(\"coder\");\n+            STRING_CODER_FIELD.setAccessible(true);\n+            SB_CODER_FIELD = Class.forName(\"java.lang.AbstractStringBuilder\").getDeclaredField(\"coder\");\n+            SB_CODER_FIELD.setAccessible(true);\n+            COMPACT_STRINGS = isCompactStrings();\n+        } catch (NoSuchFieldException ex ) {\n+            throw new ExceptionInInitializerError(ex);\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/* {@return true iff CompactStrings are enabled}\n+     *\/\n+    public static boolean isCompactStrings() {\n+        try {\n+            Field compactStringField = String.class.getDeclaredField(\"COMPACT_STRINGS\");\n+            compactStringField.setAccessible(true);\n+            return compactStringField.getBoolean(null);\n+        } catch (NoSuchFieldException ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        } catch (IllegalAccessException iae) {\n+            throw new AssertionError(iae);\n+        }\n+    }\n+\n+    \/\/ Return the coder for the String\n+    private static int coder(String s) {\n+        try {\n+            return STRING_CODER_FIELD.getByte(s);\n+        } catch (IllegalAccessException iae) {\n+            throw new AssertionError(iae);\n+        }\n+    }\n+\n+    \/\/ Return the coder for the StringBuilder\n+    private static int sbCoder(StringBuilder sb) {\n+        try {\n+            return SB_CODER_FIELD.getByte(sb);\n+        } catch (IllegalAccessException iae) {\n+            throw new AssertionError(iae);\n+        }\n+    }\n+\n+    \/\/ Return a summary of the internals of the String\n+    \/\/ The coder and indicate if the coder matches the string contents\n+    private static String inspectString(String s) {\n+        try {\n+            char[] chars = s.toCharArray();\n+            String r = new String(chars);\n+\n+            boolean invalidCoder = coder(s) != coder(r);\n+            String coder = STRING_CODER_FIELD.getByte(s) == 0 ? \"isLatin1\" : \"utf16\";\n+            return (invalidCoder ? \"INVALID CODER\" : \"\" ) + \" \\\"\" + s + \"\\\", coder: \" + coder;\n+        } catch (IllegalAccessException ex ) {\n+            return \"EXCEPTION: \" + ex.getMessage();\n+        }\n+    }\n+\n+    \/**\n+     * {@return true if the coder matches the presence\/lack of UTF16 characters}\n+     * If it returns false, the coder and the contents have failed the precondition for string.\n+     * @param orig a string\n+     *\/\n+    private static boolean validCoder(String orig) {\n+        if (!COMPACT_STRINGS) {\n+            assertEquals(UTF16, coder(orig), \"Non-COMPACT STRINGS coder must be UTF16\");\n+        }\n+        int accum = 0;\n+        for (int i = 0; i < orig.length(); i++)\n+            accum |= orig.charAt(i);\n+        byte expectedCoder = (accum < 256) ? LATIN1 : UTF16;\n+        return expectedCoder == coder(orig);\n+    }\n+\n+    \/\/ Check a StringBuilder for consistency of coder and latin1 vs UTF16\n+    private static boolean validCoder(StringBuilder orig) {\n+        int accum = 0;\n+        for (int i = 0; i < orig.length(); i++)\n+            accum |= orig.charAt(i);\n+        byte expectedCoder = (accum < 256) ? LATIN1 : UTF16;\n+        return expectedCoder == sbCoder(orig);\n+    }\n+\n+    @Test\n+    @EnabledIf(\"test.java.lang.String.StringRacyConstructor#isCompactStrings\")\n+    public void checkStringRange() {\n+        char[] chars = {'a', 'b', 'c', 0xff21, 0xff22, 0xff23};\n+        String orig = new String(chars);\n+        char[] xx = orig.toCharArray();\n+        String stringFromChars = new String(xx);\n+        assertEquals(orig, stringFromChars, \"mixed chars\");\n+        assertTrue(validCoder(stringFromChars), \"invalid coder\"\n+                + \", invalid coder: \" + inspectString(stringFromChars));\n+    }\n+\n+    private static List<String> strings() {\n+        return List.of(\"01234\", \" \");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"strings\")\n+    @EnabledIf(\"test.java.lang.String.StringRacyConstructor#isCompactStrings\")\n+    public void racyString(String orig) {\n+        String racyString = racyStringConstruction(orig);\n+        \/\/ The contents are indeterminate due to the race\n+        assertTrue(validCoder(racyString), orig + \" string invalid\"\n+                + \", racyString: \" + inspectString(racyString));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"strings\")\n+    @EnabledIf(\"test.java.lang.String.StringRacyConstructor#isCompactStrings\")\n+    public void racyCodePoint(String orig) {\n+        String iffyString = racyStringConstructionCodepoints(orig);\n+        \/\/ The contents are indeterminate due to the race\n+        assertTrue(validCoder(iffyString), \"invalid coder in non-deterministic string\"\n+                + \", orig:\" + inspectString(orig)\n+                + \", iffyString: \" + inspectString(iffyString));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"strings\")\n+    @EnabledIf(\"test.java.lang.String.StringRacyConstructor#isCompactStrings\")\n+    public void racyCodePointSurrogates(String orig) {\n+        String iffyString = racyStringConstructionCodepointsSurrogates(orig);\n+        \/\/ The contents are indeterminate due to the race\n+        if (!orig.equals(iffyString))\n+            System.err.println(\"orig: \" + orig + \", iffy: \" + iffyString + Arrays.toString(iffyString.codePoints().toArray()));\n+        assertTrue(validCoder(iffyString), \"invalid coder in non-deterministic string\"\n+                + \", orig:\" + inspectString(orig)\n+                + \", iffyString: \" + inspectString(iffyString));\n+    }\n+\n+    \/\/ Test the private methods of StringUTF16 that compress and copy COMPRESSED_STRING\n+    \/\/ encoded byte arrays.\n+    @Test\n+    public void verifyUTF16CopyBytes()\n+            throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n+        Class<?> stringUTF16 = Class.forName(\"java.lang.StringUTF16\");\n+        Method mCompressChars = stringUTF16.getDeclaredMethod(\"compress\",\n+                char[].class, int.class, byte[].class, int.class, int.class);\n+        mCompressChars.setAccessible(true);\n+\n+        \/\/ First warmup the intrinsic and check 1 case\n+        char[] chars = {'a', 'b', 'c', 0xff21, 0xff22, 0xff23};\n+        byte[] bytes = new byte[chars.length];\n+        int printWarningCount = 0;\n+\n+        for (int i = 0; i < 1_000_000; i++) {   \/\/ repeat to get C2 to kick in\n+            \/\/ Copy only latin1 chars from UTF-16 converted prefix (3 chars -> 3 bytes)\n+            int intResult = (int) mCompressChars.invoke(null, chars, 0, bytes, 0, chars.length);\n+            if (intResult == 0) {\n+                if (printWarningCount == 0) {\n+                    printWarningCount = 1;\n+                    System.err.println(\"Intrinsic for StringUTF16.compress returned 0, may not have been updated.\");\n+                }\n+            } else {\n+                assertEquals(3, intResult, \"return length not-equal, iteration: \" + i);\n+            }\n+        }\n+\n+        \/\/ Exhaustively check compress returning the correct index of the non-latin1 char.\n+        final int SIZE = 48;\n+        final byte FILL_BYTE = 'R';\n+        chars = new char[SIZE];\n+        bytes = new byte[chars.length];\n+        for (int i = 0; i < SIZE; i++) { \/\/ Every starting index\n+            for (int j = i; j < SIZE; j++) {  \/\/ Every location of non-latin1\n+                Arrays.fill(chars, 'A');\n+                Arrays.fill(bytes, FILL_BYTE);\n+                chars[j] = 0xFF21;\n+                int intResult = (int) mCompressChars.invoke(null, chars, i, bytes, 0, chars.length - i);\n+                assertEquals(j - i, intResult, \"compress found wrong index\");\n+                assertEquals(FILL_BYTE, bytes[j], \"extra character stored\");\n+            }\n+        }\n+\n+    }\n+\n+    \/\/ Check that a concatenated \"hello\" has a valid coder\n+    @Test\n+    @EnabledIf(\"test.java.lang.String.StringRacyConstructor#isCompactStrings\")\n+    public void checkConcatAndIntern() {\n+        var helloWorld = \"hello world\";\n+        String helloToo = racyStringConstruction(\"hell\".concat(\"o\"));\n+        String o = helloToo.intern();\n+        var hello = \"hello\";\n+        assertTrue(validCoder(helloToo), \"startsWith: \"\n+                + \", hell: \" + inspectString(helloToo)\n+                + \", o: \" + inspectString(o)\n+                + \", hello: \" + inspectString(hello)\n+                + \", hello world: \" + inspectString(helloWorld));\n+    }\n+\n+    \/\/ Check that an empty string with racy construction has a valid coder\n+    @Test\n+    @EnabledIf(\"test.java.lang.String.StringRacyConstructor#isCompactStrings\")\n+    public void racyEmptyString() {\n+        var space = racyStringConstruction(\" \");\n+        var trimmed = space.trim();\n+        assertTrue(validCoder(trimmed), \"empty string invalid coder\"\n+                + \", trimmed: \" + inspectString(trimmed));\n+    }\n+\n+    \/\/ Check that an exception in a user implemented CharSequence doesn't result in\n+    \/\/ an invalid coder when appended to a StringBuilder\n+    @Test\n+    @EnabledIf(\"test.java.lang.String.StringRacyConstructor#isCompactStrings\")\n+    void charSequenceException() {\n+        ThrowingCharSequence bs = new ThrowingCharSequence(\"A\\u2030\\uFFFD\");\n+        var sb = new StringBuilder();\n+        try {\n+            sb.append(bs);\n+            fail(\"An IllegalArgumentException should have been thrown\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/ ignore expected\n+        }\n+        assertTrue(validCoder(sb), \"invalid coder in StringBuilder\");\n+    }\n+\n+    \/**\n+     * Given a latin-1 String, attempt to create a copy that is\n+     * incorrectly encoded as UTF-16.\n+     *\/\n+    public static String racyStringConstruction(String original) throws ConcurrentModificationException {\n+        if (original.chars().max().getAsInt() >= 256) {\n+            throw new IllegalArgumentException(\n+                    \"Only work with latin-1 Strings\");\n+        }\n+\n+        char[] chars = original.toCharArray();\n+\n+        \/\/ In another thread, flip the first character back\n+        \/\/ and forth between being latin-1 or not\n+        Thread thread = new Thread(() -> {\n+            while (!Thread.interrupted()) {\n+                chars[0] ^= 256;\n+            }\n+        });\n+        thread.start();\n+\n+        \/\/ at the same time call the String constructor,\n+        \/\/ until we hit the race condition\n+        int i = 0;\n+        while (true) {\n+            i++;\n+            String s = new String(chars);\n+            if ((s.charAt(0) < 256 && !original.equals(s)) || i > 1_000_000) {\n+                thread.interrupt();\n+                try {\n+                    thread.join();\n+                } catch (InterruptedException ie) {\n+                    \/\/ ignore interrupt\n+                }\n+                return s;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Given a latin-1 String, creates a copy that is\n+     * incorrectly encoded as UTF-16 using the APIs for Codepoints.\n+     *\/\n+    public static String racyStringConstructionCodepoints(String original) throws ConcurrentModificationException {\n+        if (original.chars().max().getAsInt() >= 256) {\n+            throw new IllegalArgumentException(\n+                    \"Can only work with latin-1 Strings\");\n+        }\n+\n+        int len = original.length();\n+        int[] codePoints = new int[len];\n+        for (int i = 0; i < len; i++) {\n+            codePoints[i] = original.charAt(i);\n+        }\n+\n+        \/\/ In another thread, flip the first character back\n+        \/\/ and forth between being latin-1 or not\n+        Thread thread = new Thread(() -> {\n+            while (!Thread.interrupted()) {\n+                codePoints[0] ^= 256;\n+            }\n+        });\n+        thread.start();\n+\n+        \/\/ at the same time call the String constructor,\n+        \/\/ until we hit the race condition\n+        int i = 0;\n+        while (true) {\n+            i++;\n+            String s = new String(codePoints, 0, len);\n+            if ((s.charAt(0) < 256 && !original.equals(s)) || i > 1_000_000) {\n+                thread.interrupt();\n+                try {\n+                    thread.join();\n+                } catch (InterruptedException ie) {\n+                    \/\/ ignore interrupt\n+                }\n+                return s;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns a string created from a codepoint array that has been racily\n+     * modified to contain high and low surrogates. The string is a different length\n+     * than the original due to the surrogate encoding.\n+     *\/\n+    public static String racyStringConstructionCodepointsSurrogates(String original) throws ConcurrentModificationException {\n+        if (original.chars().max().getAsInt() >= 256) {\n+            throw new IllegalArgumentException(\n+                    \"Can only work with latin-1 Strings\");\n+        }\n+\n+        int len = original.length();\n+        int[] codePoints = new int[len];\n+        for (int i = 0; i < len; i++) {\n+            codePoints[i] = original.charAt(i);\n+        }\n+\n+        \/\/ In another thread, flip the first character back\n+        \/\/ and forth between being latin-1 or as a surrogate pair.\n+        Thread thread = new Thread(() -> {\n+            while (!Thread.interrupted()) {\n+                codePoints[0] ^= 0x10000;\n+            }\n+        });\n+        thread.start();\n+\n+        \/\/ at the same time call the String constructor,\n+        \/\/ until we hit the race condition\n+        int i = 0;\n+        while (true) {\n+            i++;\n+            String s = new String(codePoints, 0, len);\n+            if ((s.length() != original.length()) || i > 1_000_000) {\n+                thread.interrupt();\n+                try {\n+                    thread.join();\n+                } catch (InterruptedException ie) {\n+                    \/\/ ignore interrupt\n+                }\n+                return s;\n+            }\n+        }\n+    }\n+\n+    \/\/ A CharSequence that returns characters from a string and throws IllegalArgumentException\n+    \/\/ when the character requested is 0xFFFD (the replacement character)\n+    \/\/ The string contents determine when the exception is thrown.\n+    static class ThrowingCharSequence implements CharSequence {\n+        private final String aString;\n+\n+        ThrowingCharSequence(String aString) {\n+            this.aString = aString;\n+        }\n+\n+        @Override\n+        public int length() {\n+            return aString.length();\n+        }\n+\n+        @Override\n+        public char charAt(int index) {\n+            char ch = aString.charAt(index);\n+            if (ch == 0xFFFD) {\n+                throw new IllegalArgumentException(\"Replacement character at index \" + index);\n+            }\n+            return ch;\n+        }\n+\n+        @Override\n+        \/\/ Not used; returns the entire string\n+        public CharSequence subSequence(int start, int end) {\n+            return this;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/StringRacyConstructor.java","additions":437,"deletions":0,"binary":false,"changes":437,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-package micro.org.openjdk.bench.java.lang;\n+package org.openjdk.bench.java.lang;\n@@ -27,0 +27,1 @@\n+import org.openjdk.jmh.infra.Blackhole;\n@@ -29,0 +30,1 @@\n+import java.util.Arrays;\n@@ -39,40 +41,1 @@\n-  @Param({\"7\", \"64\"})\n-  public int size;\n-\n-  \/\/ Offset to use for ranged newStrings\n-  @Param(\"1\")\n-  public int offset;\n-  private byte[] array;\n-\n-  @Setup\n-  public void setup() {\n-      if (offset > size) {\n-        offset = size;\n-      }\n-      array = \"a\".repeat(size).getBytes(StandardCharsets.UTF_8);\n-  }\n-\n-  @Benchmark\n-  public String newStringFromArray() {\n-      return new String(array);\n-  }\n-\n-  @Benchmark\n-  public String newStringFromArrayWithCharset() {\n-      return new String(array, StandardCharsets.UTF_8);\n-  }\n-\n-  @Benchmark\n-  public String newStringFromArrayWithCharsetName() throws Exception {\n-      return new String(array, StandardCharsets.UTF_8.name());\n-  }\n-\n-  @Benchmark\n-  public String newStringFromRangedArray() {\n-    return new String(array, offset, array.length - offset);\n-  }\n-\n-  @Benchmark\n-  public String newStringFromRangedArrayWithCharset() {\n-      return new String(array, offset, array.length - offset, StandardCharsets.UTF_8);\n-  }\n+    private static final char INTEROBANG = 0x2030;\n@@ -80,0 +43,109 @@\n+    \/\/ Fixed offset to use for ranged newStrings\n+    public final int offset = 1;\n+\n+    @Param({\"7\", \"64\"})\n+    public int size;\n+\n+    private byte[] array;\n+    private char[] chars;\n+    private char[] charsMixedBegin;\n+    private char[] charsMixedSmall;\n+    private char[] charsMixedEnd;\n+    private int[] codePointsLatin1;\n+    private int[] codePointsMixedBegin;\n+    private int[] codePointsMixedSmall;\n+\n+    private static int[] intCopyOfChars(char[] chars, int newLength) {\n+        int[] res = new int[newLength];\n+        for (int i = 0; i < Math.min(chars.length, newLength); i++)\n+            res[i] = chars[i];\n+        return res;\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        String s = \"a\".repeat(size);\n+        array = s.getBytes(StandardCharsets.UTF_8);\n+        chars = s.toCharArray();\n+        charsMixedBegin = Arrays.copyOf(chars, array.length);\n+        charsMixedBegin[0] = INTEROBANG;\n+        charsMixedSmall = Arrays.copyOf(chars, array.length);\n+        charsMixedSmall[Math.min(charsMixedSmall.length - 1, 7)] = INTEROBANG;\n+        charsMixedEnd = new char[size + 7];\n+        Arrays.fill(charsMixedEnd, 'a');\n+        charsMixedEnd[charsMixedEnd.length - 1] = INTEROBANG;\n+\n+        codePointsLatin1 = intCopyOfChars(chars, array.length);\n+        codePointsMixedBegin = intCopyOfChars(chars, array.length);\n+        codePointsMixedBegin[0] = INTEROBANG;\n+        codePointsMixedSmall = intCopyOfChars(chars, array.length);\n+        codePointsMixedSmall[Math.min(codePointsMixedSmall.length - 1, 7)] = INTEROBANG;\n+    }\n+\n+    @Benchmark\n+    public String newStringFromBytes() {\n+        return new String(array);\n+    }\n+\n+    @Benchmark\n+    public String newStringFromBytesRanged() {\n+        return new String(array, offset, array.length - offset);\n+    }\n+\n+    @Benchmark\n+    public String newStringFromBytesRangedWithCharsetUTF8() {\n+        return new String(array, offset, array.length - offset, StandardCharsets.UTF_8);\n+    }\n+\n+    @Benchmark\n+    public String newStringFromBytesWithCharsetUTF8() {\n+        return new String(array, StandardCharsets.UTF_8);\n+    }\n+\n+    @Benchmark\n+    public String newStringFromBytesWithCharsetNameUTF8() throws Exception {\n+        return new String(array, StandardCharsets.UTF_8.name());\n+    }\n+\n+    @Benchmark\n+    public String newStringFromCharsLatin1() {\n+        return new String(chars);\n+    }\n+\n+    @Benchmark\n+    public String newStringFromCharsMixedBegin() {\n+        return new String(charsMixedBegin);\n+    }\n+\n+    @Benchmark\n+    public String newStringFromCharsMixedSmall() {\n+        return new String(charsMixedSmall);\n+    }\n+\n+    @Benchmark\n+    public String newStringFromCharsMixedEnd() {\n+        return new String(charsMixedEnd);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void newStringFromCharsMixedAll(Blackhole bh) {\n+        bh.consume(new String(charsMixedBegin));\n+        bh.consume(new String(charsMixedSmall));\n+        bh.consume(new String(chars));\n+    }\n+\n+    @Benchmark\n+    public String newStringFromCodePointRangedLatin1() {\n+        return new String(codePointsLatin1, 0, codePointsLatin1.length);\n+    }\n+\n+    @Benchmark\n+    public String newStringFromCodePointRangedMixedBegin() {\n+        return new String(codePointsMixedBegin, 0, codePointsMixedBegin.length);\n+    }\n+\n+    @Benchmark\n+    public String newStringFromCodePointRangedMixedSmall() {\n+        return new String(codePointsMixedSmall, 0, codePointsMixedSmall.length);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringConstructor.java","additions":113,"deletions":41,"binary":false,"changes":154,"status":"modified"}]}