{"files":[{"patch":"@@ -3422,0 +3422,225 @@\n+\n+    \/**\n+     * Returns the product of the unsigned arguments,\n+     * throwing an exception if the result overflows an unsigned {@code int}.\n+     *\n+     * @param x the first unsigned value\n+     * @param y the second unsigned value\n+     * @return the result\n+     * @throws ArithmeticException if the result overflows an unsigned int\n+     * @since 25\n+     *\/\n+    public static int unsignedMultiplyExact(int x, int y) {\n+        long r = (x & 0xFFFF_FFFFL) * (y & 0xFFFF_FFFFL);\n+        if (r >>> 32 != 0) {\n+            throw new ArithmeticException(\"unsigned integer overflow\");\n+        }\n+        return (int)r;\n+    }\n+\n+    \/**\n+     * Returns the product of the unsigned arguments,\n+     * throwing an exception if the result overflows an unsigned {@code long}.\n+     *\n+     * @param x the first unsigned value\n+     * @param y the second unsigned value\n+     * @return the result\n+     * @throws ArithmeticException if the result overflows an unsigned long\n+     * @since 25\n+     *\/\n+    public static long unsignedMultiplyExact(long x, int y) {\n+        return unsignedMultiplyExact(x, y & 0xFFFF_FFFFL);\n+    }\n+\n+    \/**\n+     * Returns the product of the unsigned arguments,\n+     * throwing an exception if the result overflows an unsigned {@code long}.\n+     *\n+     * @param x the first unsigned value\n+     * @param y the second unsigned value\n+     * @return the result\n+     * @throws ArithmeticException if the result overflows an unsigned long\n+     * @since 25\n+     *\/\n+    public static long unsignedMultiplyExact(long x, long y) {\n+        long l = x * y;\n+        long h = unsignedMultiplyHigh(x, y);\n+        if (h == 0) {\n+            return l;\n+        }\n+        throw new ArithmeticException(\"unsigned long overflow\");\n+    }\n+\n+    \/**\n+     * Returns {@code x} raised to the power of {@code n},\n+     * throwing an exception if the result overflows an {@code int}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows an int.\n+     * @since 25\n+     *\/\n+    public static int powExact(int x, int n) {\n+        \/* See the comment in unsignedPowExact(long,int) for the details. *\/\n+        if (n < 0) {\n+            throw new ArithmeticException(\"negative exponent\");\n+        }\n+        if (n == 0) {\n+            return 1;\n+        }\n+        if (x == 0 || x == 1) {\n+            return x;\n+        }\n+        if (x == -1) {\n+            return (n & 0b1) == 0 ? 1 : -1;\n+        }\n+\n+        int p = 1;\n+        while (n > 1) {\n+            if ((n & 0b1) != 0) {\n+                p *= x;\n+            }\n+            x = multiplyExact(x, x);\n+            n >>>= 1;\n+        }\n+        return multiplyExact(p, x);\n+    }\n+\n+    \/**\n+     * Returns unsigned {@code x} raised to the power of {@code n},\n+     * throwing an exception if the result overflows an unsigned {@code int}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the unsigned base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows an unsigned int.\n+     * @since 25\n+     *\/\n+    public static int unsignedPowExact(int x, int n) {\n+        \/* See the comment in unsignedPowExact(long,int) for the details. *\/\n+        if (n < 0) {\n+            throw new ArithmeticException(\"negative exponent\");\n+        }\n+        if (n == 0) {\n+            return 1;\n+        }\n+        if (x == 0 || x == 1) {\n+            return x;\n+        }\n+\n+        int p = 1;\n+        while (n > 1) {\n+            if ((n & 0b1) != 0) {\n+                p *= x;\n+            }\n+            x = unsignedMultiplyExact(x, x);\n+            n >>>= 1;\n+        }\n+        return unsignedMultiplyExact(p, x);\n+    }\n+\n+    \/**\n+     * Returns {@code x} raised to the power of {@code n},\n+     * throwing an exception if the result overflows a {@code long}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows a long.\n+     * @since 25\n+     *\/\n+    public static long powExact(long x, int n) {\n+        \/* See the comment in unsignedPowExact(long,int) for the details. *\/\n+        if (n < 0) {\n+            throw new ArithmeticException(\"negative exponent\");\n+        }\n+        if (n == 0) {\n+            return 1;\n+        }\n+        if (x == 0 || x == 1) {\n+            return x;\n+        }\n+        if (x == -1) {\n+            return (n & 0b1) != 0 ? -1 : 1;\n+        }\n+\n+        long p = 1;\n+        while (n > 1) {\n+            if ((n & 0b1) != 0) {\n+                p *= x;\n+            }\n+            x = multiplyExact(x, x);\n+            n >>>= 1;\n+        }\n+        return multiplyExact(p, x);\n+    }\n+\n+    \/**\n+     * Returns unsigned {@code x} raised to the power of {@code n},\n+     * throwing an exception if the result overflows an unsigned {@code long}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the unsigned base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows an unsigned long.\n+     * @since 25\n+     *\/\n+    public static long unsignedPowExact(long x, int n) {\n+        if (n < 0) {\n+            throw new ArithmeticException(\"negative exponent\");\n+        }\n+        if (n == 0) {\n+            return 1;\n+        }\n+        \/*\n+         * To keep the code as simple as possible, there are intentionally\n+         * no fast paths, except for |x| <= 1.\n+         * The reason is that the number of loop iterations below can be kept\n+         * very small when |x| > 1, but not necessarily when |x| <= 1.\n+         *\/\n+        if (x == 0 || x == 1) {\n+            return x;\n+        }\n+\n+        \/*\n+         * Let x0 and n0 > 0 be the entry values of x and n, resp.\n+         * The useful loop invariants are:\n+         *      p * x^n = x0^n0\n+         *      |p| < |x|\n+         *\n+         * Since |x0| >= 2 here, and since |x0|^(2^6) >= 2^Long.SIZE, the squaring\n+         * of x in the loop overflows at latest during the 6th iteration,\n+         * so by then the method throws.\n+         * Thus, the loop executes at most 5 successful iterations, and fails\n+         * not later than at the 6th.\n+         *\n+         * But n is right-shifted at each iteration.\n+         * If the method returns, there are thus floor(log2(n0)) iterations.\n+         *\/\n+        long p = 1;\n+        while (n > 1) {\n+            if ((n & 0b1) != 0) {\n+                \/*\n+                 * The invariant |p| < |x| holds, so we have |p*x| < |x*x|.\n+                 * That is, if p*x overflows, so does x*x below, which is\n+                 * always executed.\n+                 * In other words, a plain * can be used here, since we are\n+                 * piggybacking on the squaring of x to throw.\n+                 *\/\n+                p *= x;\n+            }\n+            x = unsignedMultiplyExact(x, x);\n+            n >>>= 1;\n+        }\n+        return unsignedMultiplyExact(p, x);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -2597,0 +2597,107 @@\n+\n+    \/**\n+     * Returns the product of the unsigned arguments,\n+     * throwing an exception if the result overflows an unsigned {@code int}.\n+     *\n+     * @param x the first unsigned value\n+     * @param y the second unsigned value\n+     * @return the result\n+     * @throws ArithmeticException if the result overflows an unsigned int\n+     * @since 25\n+     *\/\n+    public static int unsignedMultiplyExact(int x, int y) {\n+        return Math.unsignedMultiplyExact(x, y);\n+    }\n+\n+    \/**\n+     * Returns the product of the unsigned arguments,\n+     * throwing an exception if the result overflows an unsigned {@code long}.\n+     *\n+     * @param x the first unsigned value\n+     * @param y the second unsigned value\n+     * @return the result\n+     * @throws ArithmeticException if the result overflows an unsigned long\n+     * @since 25\n+     *\/\n+    public static long unsignedMultiplyExact(long x, int y) {\n+        return Math.unsignedMultiplyExact(x, y);\n+    }\n+\n+    \/**\n+     * Returns the product of the unsigned arguments,\n+     * throwing an exception if the result overflows an unsigned {@code long}.\n+     *\n+     * @param x the first unsigned value\n+     * @param y the second unsigned value\n+     * @return the result\n+     * @throws ArithmeticException if the result overflows an unsigned long\n+     * @since 25\n+     *\/\n+    public static long unsignedMultiplyExact(long x, long y) {\n+        return Math.unsignedMultiplyExact(x, y);\n+    }\n+\n+    \/**\n+     * Returns {@code x} raised to the power of {@code n},\n+     * throwing an exception if the result overflows an {@code int}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows an int.\n+     * @since 25\n+     *\/\n+    public static int powExact(int x, int n) {\n+        return Math.powExact(x, n);\n+    }\n+\n+    \/**\n+     * Returns unsigned {@code x} raised to the power of {@code n},\n+     * throwing an exception if the result overflows an unsigned {@code int}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the unsigned base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows an unsigned int.\n+     * @since 25\n+     *\/\n+    public static int unsignedPowExact(int x, int n) {\n+        return Math.unsignedPowExact(x, n);\n+    }\n+\n+    \/**\n+     * Returns {@code x} raised to the power of {@code n},\n+     * throwing an exception if the result overflows a {@code long}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows a long.\n+     * @since 25\n+     *\/\n+    public static long powExact(long x, int n) {\n+        return Math.powExact(x, n);\n+    }\n+\n+    \/**\n+     * Returns unsigned {@code x} raised to the power of {@code n},\n+     * throwing an exception if the result overflows an unsigned {@code long}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the unsigned base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows an unsigned long.\n+     * @since 25\n+     *\/\n+    public static long unsignedPowExact(long x, int n) {\n+        return Math.unsignedPowExact(x, n);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -0,0 +1,392 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8355992\n+ * @summary Tests for StrictMath.*PowExact and .*unsignedMultiplyExact\n+ * @run junit IntegralPowTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.math.BigInteger;\n+\n+import static java.lang.StrictMath.*;\n+import static java.math.BigInteger.ONE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class IntegralPowTest {\n+\n+    private static final long MASK_32 = (1L << Integer.SIZE) - 1;  \/\/ 2^32 - 1\n+    private static final BigInteger MASK_64 = ONE.shiftLeft(Long.SIZE).subtract(ONE);  \/\/ 2^64 - 1\n+    private static final double INT_F = Integer.SIZE * Math.log(2);\n+    private static final double LONG_F = Long.SIZE * Math.log(2);\n+    private static final int INT_XMAX = 0x1_0000;\n+    private static final int LONG_XMAX = 0x10_0000;\n+\n+    private static BigInteger unsignedBigInteger(int x) {\n+        return BigInteger.valueOf(x & MASK_32);\n+    }\n+\n+    private static BigInteger unsignedBigInteger(long x) {\n+        return BigInteger.valueOf(x).and(MASK_64);\n+    }\n+\n+    private static int slowPowExact(int x, int n) {\n+        BigInteger pow = BigInteger.valueOf(x).pow(n);\n+        return pow.intValueExact();\n+    }\n+\n+    private static int slowUnsignedPowExact(int x, int n) {\n+        BigInteger pow = unsignedBigInteger(x).pow(n);\n+        if (pow.bitLength() > Integer.SIZE) {\n+            throw new ArithmeticException();\n+        }\n+        return pow.intValue();\n+    }\n+\n+    private static long slowPowExact(long x, int n) {\n+        BigInteger pow = BigInteger.valueOf(x).pow(n);\n+        return pow.longValueExact();\n+    }\n+\n+    private static long slowUnsignedPowExact(long x, int n) {\n+        BigInteger pow = unsignedBigInteger(x).pow(n);\n+        if (pow.bitLength() > Long.SIZE) {\n+            throw new ArithmeticException();\n+        }\n+        return pow.longValue();\n+    }\n+\n+    @Test\n+    void testIntUnsignedMultiplyExact() {\n+        assertEquals(0, unsignedMultiplyExact(0, 0));\n+        assertEquals(0, unsignedMultiplyExact(1, 0));\n+        assertEquals(0, unsignedMultiplyExact(-1, 0));\n+        assertEquals(1, unsignedMultiplyExact(1, 1));\n+        assertEquals(-1, unsignedMultiplyExact(1, -1));\n+        assertEquals(1 << 31, unsignedMultiplyExact(1 << 15, 1 << 16));\n+        assertEquals(1 << 31, unsignedMultiplyExact(1 << 10, 1 << 21));\n+        \/* 2^32 - 1 = (2^16 + 1) (2^16 - 1) *\/\n+        assertEquals(-1, unsignedMultiplyExact((1 << 16) + 1, (1 << 16) - 1));\n+\n+        assertThrows(ArithmeticException.class, () -> unsignedMultiplyExact(-1, -1));\n+    }\n+\n+    @Test\n+    void testLongIntUnsignedMultiplyExact() {\n+        assertEquals(0L, unsignedMultiplyExact(0L, 0));\n+        assertEquals(0L, unsignedMultiplyExact(1L, 0));\n+        assertEquals(0L, unsignedMultiplyExact(-1L, 0));\n+        assertEquals(1L, unsignedMultiplyExact(1L, 1));\n+        assertEquals(-3 & MASK_32, unsignedMultiplyExact(1L, -3));\n+        assertEquals(1L << 50, unsignedMultiplyExact(1L << 25, 1 << 25));\n+        \/* 2^64 - 1 = (2^32 + 1) (2^32 - 1) *\/\n+        assertEquals(-1L, unsignedMultiplyExact((1L << 32) + 1, -1));\n+\n+        assertThrows(ArithmeticException.class, () -> unsignedMultiplyExact(-1L, -1));\n+    }\n+\n+    @Test\n+    void testLongUnsignedMultiplyExact() {\n+        assertEquals(0L, unsignedMultiplyExact(0L, 0L));\n+        assertEquals(0L, unsignedMultiplyExact(1L, 0L));\n+        assertEquals(0L, unsignedMultiplyExact(-1L, 0L));\n+        assertEquals(1L, unsignedMultiplyExact(1L, 1L));\n+        assertEquals(-1L, unsignedMultiplyExact(1L, -1L));\n+        assertEquals(1L << 63, unsignedMultiplyExact(1L << 31, 1L << 32));\n+        assertEquals(1L << 63, unsignedMultiplyExact(1L << 25, 1L << 38));\n+        \/* 2^64 - 1 = (2^32 + 1) (2^32 - 1) *\/\n+        assertEquals(-1L, unsignedMultiplyExact((1L << 32) + 1, (1L << 32) - 1));\n+\n+        assertThrows(ArithmeticException.class, () -> unsignedMultiplyExact(-1L, -1L));\n+    }\n+\n+    @Test\n+    void testIntPowExact() {\n+        assertEquals(1, powExact(0, 0));\n+        assertEquals(0, powExact(0, 1_000_000));\n+        assertEquals(1, powExact(1, 0));\n+        assertEquals(1, powExact(1, 1_000_000));\n+        assertEquals(1, powExact(-1, 0));\n+        assertEquals(1, powExact(-1, 1_000_000));\n+        assertEquals(-1, powExact(-1, 1_000_001));\n+\n+        assertEquals(1 << -2, powExact(2, Integer.SIZE - 2));\n+        assertEquals(-1 << -1, powExact(-2, Integer.SIZE - 1));\n+        assertEquals(1_000_000_000, powExact(10, 9));\n+        assertEquals(-1_000_000_000, powExact(-10, 9));\n+\n+        assertThrows(ArithmeticException.class, () -> powExact(0, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> powExact(1, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> powExact(2, Integer.SIZE - 1));\n+        assertThrows(ArithmeticException.class, () -> powExact(10, 10));\n+        assertThrows(ArithmeticException.class, () -> powExact(-10, 10));\n+    }\n+\n+    @Test\n+    void testUnsignedIntPowExact() {\n+        assertEquals(1, unsignedPowExact(0, 0));\n+        assertEquals(0, unsignedPowExact(0, 1_000_000));\n+        assertEquals(1, unsignedPowExact(1, 0));\n+        assertEquals(1, unsignedPowExact(1, 1_000_000));\n+        assertEquals(1, unsignedPowExact(-1, 0));\n+        assertEquals(-1, unsignedPowExact(-1, 1));\n+\n+        assertEquals(1 << -1, unsignedPowExact(2, Integer.SIZE - 1));\n+        assertEquals(1_000_000_000, unsignedPowExact(10, 9));\n+\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(0, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(1, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(-1, 2));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(2, Integer.SIZE));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(10, 10));\n+    }\n+\n+    @Test\n+    void testLongPowExact() {\n+        assertEquals(1L, powExact(0L, 0));\n+        assertEquals(0L, powExact(0L, 1_000_000));\n+        assertEquals(1L, powExact(1L, 0));\n+        assertEquals(1L, powExact(1L, 1_000_000));\n+        assertEquals(1L, powExact(-1L, 0));\n+        assertEquals(1L, powExact(-1L, 1_000_000));\n+        assertEquals(-1L, powExact(-1L, 1_000_001));\n+\n+        assertEquals(1L << -2, powExact(2L, Long.SIZE - 2));\n+        assertEquals(-1L << -1, powExact(-2L, Long.SIZE - 1));\n+        assertEquals(1_000_000_000_000_000_000L, powExact(10L, 18));\n+        assertEquals(-100_000_000_000_000_000L, powExact(-10L, 17));\n+        assertEquals(1_000_000_000_000_000_000L, powExact(-10L, 18));\n+\n+        assertThrows(ArithmeticException.class, () -> powExact(0L, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> powExact(1L, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> powExact(2L, Long.SIZE - 1));\n+        assertThrows(ArithmeticException.class, () -> powExact(10L, 19));\n+        assertThrows(ArithmeticException.class, () -> powExact(-10L, 19));\n+    }\n+\n+    @Test\n+    void testUnsignedLongPowExact() {\n+        assertEquals(1L, unsignedPowExact(0L, 0));\n+        assertEquals(0L, unsignedPowExact(0L, 1_000_000));\n+        assertEquals(1L, unsignedPowExact(1L, 0));\n+        assertEquals(1L, unsignedPowExact(1L, 1_000_000));\n+        assertEquals(1L, unsignedPowExact(-1L, 0));\n+        assertEquals(-1L, unsignedPowExact(-1L, 1));\n+\n+        assertEquals(1L << -1, unsignedPowExact(2L, Long.SIZE - 1));\n+        assertEquals(10 * 1_000_000_000_000_000_000L, unsignedPowExact(10L, 19));\n+\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(0L, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(1L, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(-1L, 2));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(2L, Long.SIZE));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(10L, 20));\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static int expected(int x, int n) {\n+        try {\n+            return powExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static int actual(int x, int n) {\n+        try {\n+            return slowPowExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static int expectedUnsigned(int x, int n) {\n+        try {\n+            return unsignedPowExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static int actualUnsigned(int x, int n) {\n+        try {\n+            return slowUnsignedPowExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static long expected(long x, int n) {\n+        try {\n+            return powExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static long actual(long x, int n) {\n+        try {\n+            return slowPowExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static long expectedUnsigned(long x, int n) {\n+        try {\n+            return unsignedPowExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static long actualUnsigned(long x, int n) {\n+        try {\n+            return slowUnsignedPowExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/* signed int *\/\n+\n+    @Test\n+    void testPositiveIntPowExact() {\n+        for (int x = 2; x <= INT_XMAX; x += 1) {\n+            \/* An estimate for the max n such that x^n does not overflow. *\/\n+            int nmax = (int) ceil(INT_F \/ log(x));\n+            for (int n = 0; n <= nmax; ++n) {\n+                assertEquals(actual(x, n), expected(x, n));\n+            }\n+            int x0 = x;\n+            assertThrows(ArithmeticException.class, () -> powExact(x0, nmax + 1));\n+        }\n+    }\n+\n+    @Test\n+    void testNegativeIntPowExact() {\n+        for (int x = 2; x <= INT_XMAX; x += 1) {\n+            \/* An estimate for the max n such that (-x)^n does not overflow. *\/\n+            int nmax = (int) ceil(INT_F \/ log(x));\n+            for (int n = 0; n <= nmax; ++n) {\n+                assertEquals(actual(-x, n), expected(-x, n));\n+            }\n+            int x0 = x;\n+            assertThrows(ArithmeticException.class, () -> powExact(-x0, nmax + 1));\n+        }\n+    }\n+\n+    \/* unsigned int *\/\n+\n+    @Test\n+    void testSmallUnsignedIntPowExact() {\n+        for (int x = 2; x <= INT_XMAX; x += 1) {\n+            \/* An estimate for the max n such that x^n does not overflow. *\/\n+            int nmax = (int) ceil(INT_F \/ log(x));\n+            for (int n = 0; n <= nmax; ++n) {\n+                assertEquals(actualUnsigned(x, n), expectedUnsigned(x, n));\n+            }\n+            int x0 = x;\n+            assertThrows(ArithmeticException.class, () -> unsignedPowExact(x0, nmax + 1));\n+        }\n+    }\n+\n+    \/* signed long *\/\n+\n+    @Test\n+    void testPositiveLongPowExact() {\n+        for (long x = 2; x <= LONG_XMAX; x += 5) {\n+            \/* An estimate for the max n such that x^n does not overflow. *\/\n+            int nmax = (int) ceil(LONG_F \/ log(x));\n+            for (int n = 0; n <= nmax; ++n) {\n+                assertEquals(actual(x, n), expected(x, n));\n+            }\n+            long x0 = x;\n+            assertThrows(ArithmeticException.class, () -> powExact(x0, nmax + 1));\n+        }\n+    }\n+\n+    @Test\n+    void testNegativeLongPowExact() {\n+        for (long x = 2; x <= LONG_XMAX; x += 5) {\n+            \/* An estimate for the max n such that (-x)^n does not overflow. *\/\n+            int nmax = (int) ceil(LONG_F \/ log(x));\n+            for (int n = 0; n <= nmax; ++n) {\n+                assertEquals(actual(-x, n), expected(-x, n));\n+            }\n+            long x0 = x;\n+            assertThrows(ArithmeticException.class, () -> powExact(-x0, nmax + 1));\n+        }\n+    }\n+\n+    \/* unsigned long *\/\n+\n+    @Test\n+    void testSmallUnsignedLongPowExact() {\n+        for (long x = 2; x <= LONG_XMAX; x += 5) {\n+            \/* An estimate for the max n such that x^n does not overflow. *\/\n+            int nmax = (int) ceil(LONG_F \/ log(x));\n+            for (int n = 0; n <= nmax; ++n) {\n+                assertEquals(actualUnsigned(x, n), expectedUnsigned(x, n));\n+            }\n+            long x0 = x;\n+            assertThrows(ArithmeticException.class, () -> unsignedPowExact(x0, nmax + 1));\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/Math\/IntegralPowTest.java","additions":392,"deletions":0,"binary":false,"changes":392,"status":"added"}]}