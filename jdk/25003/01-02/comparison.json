{"files":[{"patch":"@@ -0,0 +1,392 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8355992\n+ * @summary Tests for StrictMath.*PowExact and .*unsignedMultiplyExact\n+ * @run junit IntegralPowTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.math.BigInteger;\n+\n+import static java.lang.StrictMath.*;\n+import static java.math.BigInteger.ONE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class IntegralPowTest {\n+\n+    private static final long MASK_32 = (1L << Integer.SIZE) - 1;  \/\/ 2^32 - 1\n+    private static final BigInteger MASK_64 = ONE.shiftLeft(Long.SIZE).subtract(ONE);  \/\/ 2^64 - 1\n+    private static final double INT_F = Integer.SIZE * Math.log(2);\n+    private static final double LONG_F = Long.SIZE * Math.log(2);\n+    private static final int INT_XMAX = 0x1_0000;\n+    private static final int LONG_XMAX = 0x10_0000;\n+\n+    private static BigInteger unsignedBigInteger(int x) {\n+        return BigInteger.valueOf(x & MASK_32);\n+    }\n+\n+    private static BigInteger unsignedBigInteger(long x) {\n+        return BigInteger.valueOf(x).and(MASK_64);\n+    }\n+\n+    private static int slowPowExact(int x, int n) {\n+        BigInteger pow = BigInteger.valueOf(x).pow(n);\n+        return pow.intValueExact();\n+    }\n+\n+    private static int slowUnsignedPowExact(int x, int n) {\n+        BigInteger pow = unsignedBigInteger(x).pow(n);\n+        if (pow.bitLength() > Integer.SIZE) {\n+            throw new ArithmeticException();\n+        }\n+        return pow.intValue();\n+    }\n+\n+    private static long slowPowExact(long x, int n) {\n+        BigInteger pow = BigInteger.valueOf(x).pow(n);\n+        return pow.longValueExact();\n+    }\n+\n+    private static long slowUnsignedPowExact(long x, int n) {\n+        BigInteger pow = unsignedBigInteger(x).pow(n);\n+        if (pow.bitLength() > Long.SIZE) {\n+            throw new ArithmeticException();\n+        }\n+        return pow.longValue();\n+    }\n+\n+    @Test\n+    void testIntUnsignedMultiplyExact() {\n+        assertEquals(0, unsignedMultiplyExact(0, 0));\n+        assertEquals(0, unsignedMultiplyExact(1, 0));\n+        assertEquals(0, unsignedMultiplyExact(-1, 0));\n+        assertEquals(1, unsignedMultiplyExact(1, 1));\n+        assertEquals(-1, unsignedMultiplyExact(1, -1));\n+        assertEquals(1 << 31, unsignedMultiplyExact(1 << 15, 1 << 16));\n+        assertEquals(1 << 31, unsignedMultiplyExact(1 << 10, 1 << 21));\n+        \/* 2^32 - 1 = (2^16 + 1) (2^16 - 1) *\/\n+        assertEquals(-1, unsignedMultiplyExact((1 << 16) + 1, (1 << 16) - 1));\n+\n+        assertThrows(ArithmeticException.class, () -> unsignedMultiplyExact(-1, -1));\n+    }\n+\n+    @Test\n+    void testLongIntUnsignedMultiplyExact() {\n+        assertEquals(0L, unsignedMultiplyExact(0L, 0));\n+        assertEquals(0L, unsignedMultiplyExact(1L, 0));\n+        assertEquals(0L, unsignedMultiplyExact(-1L, 0));\n+        assertEquals(1L, unsignedMultiplyExact(1L, 1));\n+        assertEquals(-3 & MASK_32, unsignedMultiplyExact(1L, -3));\n+        assertEquals(1L << 50, unsignedMultiplyExact(1L << 25, 1 << 25));\n+        \/* 2^64 - 1 = (2^32 + 1) (2^32 - 1) *\/\n+        assertEquals(-1L, unsignedMultiplyExact((1L << 32) + 1, -1));\n+\n+        assertThrows(ArithmeticException.class, () -> unsignedMultiplyExact(-1L, -1));\n+    }\n+\n+    @Test\n+    void testLongUnsignedMultiplyExact() {\n+        assertEquals(0L, unsignedMultiplyExact(0L, 0L));\n+        assertEquals(0L, unsignedMultiplyExact(1L, 0L));\n+        assertEquals(0L, unsignedMultiplyExact(-1L, 0L));\n+        assertEquals(1L, unsignedMultiplyExact(1L, 1L));\n+        assertEquals(-1L, unsignedMultiplyExact(1L, -1L));\n+        assertEquals(1L << 63, unsignedMultiplyExact(1L << 31, 1L << 32));\n+        assertEquals(1L << 63, unsignedMultiplyExact(1L << 25, 1L << 38));\n+        \/* 2^64 - 1 = (2^32 + 1) (2^32 - 1) *\/\n+        assertEquals(-1L, unsignedMultiplyExact((1L << 32) + 1, (1L << 32) - 1));\n+\n+        assertThrows(ArithmeticException.class, () -> unsignedMultiplyExact(-1L, -1L));\n+    }\n+\n+    @Test\n+    void testIntPowExact() {\n+        assertEquals(1, powExact(0, 0));\n+        assertEquals(0, powExact(0, 1_000_000));\n+        assertEquals(1, powExact(1, 0));\n+        assertEquals(1, powExact(1, 1_000_000));\n+        assertEquals(1, powExact(-1, 0));\n+        assertEquals(1, powExact(-1, 1_000_000));\n+        assertEquals(-1, powExact(-1, 1_000_001));\n+\n+        assertEquals(1 << -2, powExact(2, Integer.SIZE - 2));\n+        assertEquals(-1 << -1, powExact(-2, Integer.SIZE - 1));\n+        assertEquals(1_000_000_000, powExact(10, 9));\n+        assertEquals(-1_000_000_000, powExact(-10, 9));\n+\n+        assertThrows(ArithmeticException.class, () -> powExact(0, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> powExact(1, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> powExact(2, Integer.SIZE - 1));\n+        assertThrows(ArithmeticException.class, () -> powExact(10, 10));\n+        assertThrows(ArithmeticException.class, () -> powExact(-10, 10));\n+    }\n+\n+    @Test\n+    void testUnsignedIntPowExact() {\n+        assertEquals(1, unsignedPowExact(0, 0));\n+        assertEquals(0, unsignedPowExact(0, 1_000_000));\n+        assertEquals(1, unsignedPowExact(1, 0));\n+        assertEquals(1, unsignedPowExact(1, 1_000_000));\n+        assertEquals(1, unsignedPowExact(-1, 0));\n+        assertEquals(-1, unsignedPowExact(-1, 1));\n+\n+        assertEquals(1 << -1, unsignedPowExact(2, Integer.SIZE - 1));\n+        assertEquals(1_000_000_000, unsignedPowExact(10, 9));\n+\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(0, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(1, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(-1, 2));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(2, Integer.SIZE));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(10, 10));\n+    }\n+\n+    @Test\n+    void testLongPowExact() {\n+        assertEquals(1L, powExact(0L, 0));\n+        assertEquals(0L, powExact(0L, 1_000_000));\n+        assertEquals(1L, powExact(1L, 0));\n+        assertEquals(1L, powExact(1L, 1_000_000));\n+        assertEquals(1L, powExact(-1L, 0));\n+        assertEquals(1L, powExact(-1L, 1_000_000));\n+        assertEquals(-1L, powExact(-1L, 1_000_001));\n+\n+        assertEquals(1L << -2, powExact(2L, Long.SIZE - 2));\n+        assertEquals(-1L << -1, powExact(-2L, Long.SIZE - 1));\n+        assertEquals(1_000_000_000_000_000_000L, powExact(10L, 18));\n+        assertEquals(-100_000_000_000_000_000L, powExact(-10L, 17));\n+        assertEquals(1_000_000_000_000_000_000L, powExact(-10L, 18));\n+\n+        assertThrows(ArithmeticException.class, () -> powExact(0L, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> powExact(1L, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> powExact(2L, Long.SIZE - 1));\n+        assertThrows(ArithmeticException.class, () -> powExact(10L, 19));\n+        assertThrows(ArithmeticException.class, () -> powExact(-10L, 19));\n+    }\n+\n+    @Test\n+    void testUnsignedLongPowExact() {\n+        assertEquals(1L, unsignedPowExact(0L, 0));\n+        assertEquals(0L, unsignedPowExact(0L, 1_000_000));\n+        assertEquals(1L, unsignedPowExact(1L, 0));\n+        assertEquals(1L, unsignedPowExact(1L, 1_000_000));\n+        assertEquals(1L, unsignedPowExact(-1L, 0));\n+        assertEquals(-1L, unsignedPowExact(-1L, 1));\n+\n+        assertEquals(1L << -1, unsignedPowExact(2L, Long.SIZE - 1));\n+        assertEquals(10 * 1_000_000_000_000_000_000L, unsignedPowExact(10L, 19));\n+\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(0L, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(1L, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(-1L, 2));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(2L, Long.SIZE));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(10L, 20));\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static int expected(int x, int n) {\n+        try {\n+            return powExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static int actual(int x, int n) {\n+        try {\n+            return slowPowExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static int expectedUnsigned(int x, int n) {\n+        try {\n+            return unsignedPowExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static int actualUnsigned(int x, int n) {\n+        try {\n+            return slowUnsignedPowExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static long expected(long x, int n) {\n+        try {\n+            return powExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static long actual(long x, int n) {\n+        try {\n+            return slowPowExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static long expectedUnsigned(long x, int n) {\n+        try {\n+            return unsignedPowExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static long actualUnsigned(long x, int n) {\n+        try {\n+            return slowUnsignedPowExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/* signed int *\/\n+\n+    @Test\n+    void testPositiveIntPowExact() {\n+        for (int x = 2; x <= INT_XMAX; x += 1) {\n+            \/* An estimate for the max n such that x^n does not overflow. *\/\n+            int nmax = (int) ceil(INT_F \/ log(x));\n+            for (int n = 0; n <= nmax; ++n) {\n+                assertEquals(actual(x, n), expected(x, n));\n+            }\n+            int x0 = x;\n+            assertThrows(ArithmeticException.class, () -> powExact(x0, nmax + 1));\n+        }\n+    }\n+\n+    @Test\n+    void testNegativeIntPowExact() {\n+        for (int x = 2; x <= INT_XMAX; x += 1) {\n+            \/* An estimate for the max n such that (-x)^n does not overflow. *\/\n+            int nmax = (int) ceil(INT_F \/ log(x));\n+            for (int n = 0; n <= nmax; ++n) {\n+                assertEquals(actual(-x, n), expected(-x, n));\n+            }\n+            int x0 = x;\n+            assertThrows(ArithmeticException.class, () -> powExact(-x0, nmax + 1));\n+        }\n+    }\n+\n+    \/* unsigned int *\/\n+\n+    @Test\n+    void testSmallUnsignedIntPowExact() {\n+        for (int x = 2; x <= INT_XMAX; x += 1) {\n+            \/* An estimate for the max n such that x^n does not overflow. *\/\n+            int nmax = (int) ceil(INT_F \/ log(x));\n+            for (int n = 0; n <= nmax; ++n) {\n+                assertEquals(actualUnsigned(x, n), expectedUnsigned(x, n));\n+            }\n+            int x0 = x;\n+            assertThrows(ArithmeticException.class, () -> unsignedPowExact(x0, nmax + 1));\n+        }\n+    }\n+\n+    \/* signed long *\/\n+\n+    @Test\n+    void testPositiveLongPowExact() {\n+        for (long x = 2; x <= LONG_XMAX; x += 5) {\n+            \/* An estimate for the max n such that x^n does not overflow. *\/\n+            int nmax = (int) ceil(LONG_F \/ log(x));\n+            for (int n = 0; n <= nmax; ++n) {\n+                assertEquals(actual(x, n), expected(x, n));\n+            }\n+            long x0 = x;\n+            assertThrows(ArithmeticException.class, () -> powExact(x0, nmax + 1));\n+        }\n+    }\n+\n+    @Test\n+    void testNegativeLongPowExact() {\n+        for (long x = 2; x <= LONG_XMAX; x += 5) {\n+            \/* An estimate for the max n such that (-x)^n does not overflow. *\/\n+            int nmax = (int) ceil(LONG_F \/ log(x));\n+            for (int n = 0; n <= nmax; ++n) {\n+                assertEquals(actual(-x, n), expected(-x, n));\n+            }\n+            long x0 = x;\n+            assertThrows(ArithmeticException.class, () -> powExact(-x0, nmax + 1));\n+        }\n+    }\n+\n+    \/* unsigned long *\/\n+\n+    @Test\n+    void testSmallUnsignedLongPowExact() {\n+        for (long x = 2; x <= LONG_XMAX; x += 5) {\n+            \/* An estimate for the max n such that x^n does not overflow. *\/\n+            int nmax = (int) ceil(LONG_F \/ log(x));\n+            for (int n = 0; n <= nmax; ++n) {\n+                assertEquals(actualUnsigned(x, n), expectedUnsigned(x, n));\n+            }\n+            long x0 = x;\n+            assertThrows(ArithmeticException.class, () -> unsignedPowExact(x0, nmax + 1));\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/Math\/IntegralPowTest.java","additions":392,"deletions":0,"binary":false,"changes":392,"status":"added"}]}