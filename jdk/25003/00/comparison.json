{"files":[{"patch":"@@ -3422,0 +3422,221 @@\n+\n+    \/**\n+     * Returns the product of the unsigned arguments,\n+     * throwing an exception if the result overflows an unsigned {@code int}.\n+     *\n+     * @param x the first unsigned value\n+     * @param y the second unsigned value\n+     * @return the result\n+     * @throws ArithmeticException if the result overflows an unsigned int\n+     * @since 25\n+     *\/\n+    public static int unsignedMultiplyExact(int x, int y) {\n+        long r = (x & 0xFFFF_FFFFL) * (y & 0xFFFF_FFFFL);\n+        if (r >>> 32 != 0) {\n+            throw new ArithmeticException(\"unsigned integer overflow\");\n+        }\n+        return (int)r;\n+    }\n+\n+    \/**\n+     * Returns the product of the unsigned arguments,\n+     * throwing an exception if the result overflows an unsigned {@code long}.\n+     *\n+     * @param x the first unsigned value\n+     * @param y the second unsigned value\n+     * @return the result\n+     * @throws ArithmeticException if the result overflows an unsigned long\n+     * @since 25\n+     *\/\n+    public static long unsignedMultiplyExact(long x, int y) {\n+        return unsignedMultiplyExact(x, y & 0xFFFF_FFFFL);\n+    }\n+\n+    \/**\n+     * Returns the product of the unsigned arguments,\n+     * throwing an exception if the result overflows an unsigned {@code long}.\n+     *\n+     * @param x the first unsigned value\n+     * @param y the second unsigned value\n+     * @return the result\n+     * @throws ArithmeticException if the result overflows an unsigned long\n+     * @since 25\n+     *\/\n+    public static long unsignedMultiplyExact(long x, long y) {\n+        long l = x * y;\n+        long h = unsignedMultiplyHigh(x, y);\n+        if (h == 0) {\n+            return l;\n+        }\n+        throw new ArithmeticException(\"unsigned long overflow\");\n+    }\n+\n+    \/**\n+     * Returns {@code x} raised to the power of {@code n}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows an {@code int}.\n+     * @since 25\n+     *\/\n+    public static int powExact(int x, int n) {\n+        \/* See the comment in unsignedPowExact(long,int) for the details. *\/\n+        if (n < 0) {\n+            throw new ArithmeticException(\"negative exponent\");\n+        }\n+        if (n == 0) {\n+            return 1;\n+        }\n+        if (x == 0 || x == 1) {\n+            return x;\n+        }\n+        if (x == -1) {\n+            return (n & 0b1) == 0 ? 1 : -1;\n+        }\n+\n+        int p = 1;\n+        while (n > 1) {\n+            if ((n & 0b1) != 0) {\n+                p *= x;\n+            }\n+            x = multiplyExact(x, x);\n+            n >>>= 1;\n+        }\n+        return multiplyExact(p, x);\n+    }\n+\n+    \/**\n+     * Returns unsigned {@code x} raised to the power of {@code n}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the unsigned base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows an unsigned {@code int}.\n+     * @since 25\n+     *\/\n+    public static int unsignedPowExact(int x, int n) {\n+        \/* See the comment in unsignedPowExact(long,int) for the details. *\/\n+        if (n < 0) {\n+            throw new ArithmeticException(\"negative exponent\");\n+        }\n+        if (n == 0) {\n+            return 1;\n+        }\n+        if (x == 0 || x == 1) {\n+            return x;\n+        }\n+\n+        int p = 1;\n+        while (n > 1) {\n+            if ((n & 0b1) != 0) {\n+                p *= x;\n+            }\n+            x = unsignedMultiplyExact(x, x);\n+            n >>>= 1;\n+        }\n+        return unsignedMultiplyExact(p, x);\n+    }\n+\n+    \/**\n+     * Returns {@code x} raised to the power of {@code n}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows a {@code long}.\n+     * @since 25\n+     *\/\n+    public static long powExact(long x, int n) {\n+        \/* See the comment in unsignedPowExact(long,int) for the details. *\/\n+        if (n < 0) {\n+            throw new ArithmeticException(\"negative exponent\");\n+        }\n+        if (n == 0) {\n+            return 1;\n+        }\n+        if (x == 0 || x == 1) {\n+            return x;\n+        }\n+        if (x == -1) {\n+            return (n & 0b1) != 0 ? -1 : 1;\n+        }\n+\n+        long p = 1;\n+        while (n > 1) {\n+            if ((n & 0b1) != 0) {\n+                p *= x;\n+            }\n+            x = multiplyExact(x, x);\n+            n >>>= 1;\n+        }\n+        return multiplyExact(p, x);\n+    }\n+\n+    \/**\n+     * Returns unsigned {@code x} raised to the power of {@code n}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the unsigned base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows an unsigned {@code long}.\n+     * @since 25\n+     *\/\n+    public static long unsignedPowExact(long x, int n) {\n+        if (n < 0) {\n+            throw new ArithmeticException(\"negative exponent\");\n+        }\n+        if (n == 0) {\n+            return 1;\n+        }\n+        \/*\n+         * To keep the code as simple as possible, there are intentionally\n+         * no fast paths, except for |x| <= 1.\n+         * The reason is that the number of loop iterations below can be kept\n+         * very small when |x| > 1, but not necessarily when |x| <= 1.\n+         *\/\n+        if (x == 0 || x == 1) {\n+            return x;\n+        }\n+\n+        \/*\n+         * Let x0 and n0 > 0 be the entry values of x and n, resp.\n+         * The useful loop invariants are:\n+         *      p * x^n = x0^n0\n+         *      |p| < |x|\n+         *\n+         * Since |x0| >= 2 here, and since |x0|^(2^6) >= 2^Long.SIZE, the squaring\n+         * of x in the loop overflows at latest during the 6th iteration,\n+         * so by then the method throws.\n+         * Thus, the loop executes at most 5 successful iterations, and fails\n+         * not later than at the 6th.\n+         *\n+         * But n is right-shifted at each iteration.\n+         * If the method returns, there are thus floor(log2(n0)) iterations.\n+         *\/\n+        long p = 1;\n+        while (n > 1) {\n+            if ((n & 0b1) != 0) {\n+                \/*\n+                 * The invariant |p| < |x| holds, so we have |p*x| < |x*x|.\n+                 * That is, if p*x overflows, so does x*x below, which is\n+                 * always executed.\n+                 * In other words, a plain * can be used here, since we are\n+                 * piggybacking on the squaring of x to throw.\n+                 *\/\n+                p *= x;\n+            }\n+            x = unsignedMultiplyExact(x, x);\n+            n >>>= 1;\n+        }\n+        return unsignedMultiplyExact(p, x);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":221,"deletions":0,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -2597,0 +2597,103 @@\n+\n+    \/**\n+     * Returns the product of the unsigned arguments,\n+     * throwing an exception if the result overflows an unsigned {@code int}.\n+     *\n+     * @param x the first unsigned value\n+     * @param y the second unsigned value\n+     * @return the result\n+     * @throws ArithmeticException if the result overflows an unsigned int\n+     * @since 25\n+     *\/\n+    public static int unsignedMultiplyExact(int x, int y) {\n+        return Math.unsignedMultiplyExact(x, y);\n+    }\n+\n+    \/**\n+     * Returns the product of the unsigned arguments,\n+     * throwing an exception if the result overflows an unsigned {@code long}.\n+     *\n+     * @param x the first unsigned value\n+     * @param y the second unsigned value\n+     * @return the result\n+     * @throws ArithmeticException if the result overflows an unsigned long\n+     * @since 25\n+     *\/\n+    public static long unsignedMultiplyExact(long x, int y) {\n+        return Math.unsignedMultiplyExact(x, y);\n+    }\n+\n+    \/**\n+     * Returns the product of the unsigned arguments,\n+     * throwing an exception if the result overflows an unsigned {@code long}.\n+     *\n+     * @param x the first unsigned value\n+     * @param y the second unsigned value\n+     * @return the result\n+     * @throws ArithmeticException if the result overflows an unsigned long\n+     * @since 25\n+     *\/\n+    public static long unsignedMultiplyExact(long x, long y) {\n+        return Math.unsignedMultiplyExact(x, y);\n+    }\n+\n+    \/**\n+     * Returns {@code x} raised to the power of {@code n}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows an {@code int}.\n+     * @since 25\n+     *\/\n+    public static int powExact(int x, int n) {\n+        return Math.powExact(x, n);\n+    }\n+\n+    \/**\n+     * Returns unsigned {@code x} raised to the power of {@code n}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the unsigned base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows an unsigned {@code int}.\n+     * @since 25\n+     *\/\n+    public static int unsignedPowExact(int x, int n) {\n+        return Math.unsignedPowExact(x, n);\n+    }\n+\n+    \/**\n+     * Returns {@code x} raised to the power of {@code n}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows a {@code long}.\n+     * @since 25\n+     *\/\n+    public static long powExact(long x, int n) {\n+        return Math.powExact(x, n);\n+    }\n+\n+    \/**\n+     * Returns unsigned {@code x} raised to the power of {@code n}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the unsigned base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows an unsigned {@code long}.\n+     * @since 25\n+     *\/\n+    public static long unsignedPowExact(long x, int n) {\n+        return Math.unsignedPowExact(x, n);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"modified"}]}