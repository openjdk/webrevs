{"files":[{"patch":"@@ -818,4 +818,2 @@\n-        applyIfOr = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\",\n-                     \"ShortRunningLongLoop\", \"false\",\n-                     \"AlignVector\", \"true\"},\n-        applyIfAnd = { \"ShortRunningLongLoop\", \"false\", \"AlignVector\", \"false\" },\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\",\n+                      \"ShortRunningLongLoop\", \"false\"},\n@@ -824,0 +822,2 @@\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8331659\n@@ -830,1 +830,1 @@\n-                      \"ShortRunningLongLoop\", \"true\",\n+                      \"ShortRunningLongLoop\", \"false\",\n@@ -834,2 +834,0 @@\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n@@ -837,0 +835,12 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"ShortRunningLongLoop\", \"true\",\n+                      \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ If we don't create the loop nest for the long loop, then the issue with different Casts\n+    \/\/ seems to disappear. We also don't need multiversioning because the pointers are seen\n+    \/\/ as identical.\n@@ -848,1 +858,1 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+   @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n@@ -851,3 +861,2 @@\n-        applyIfOr = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\",\n-                     \"ShortRunningLongLoop\", \"false\",\n-                     \"AlignVector\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\",\n+                      \"ShortRunningLongLoop\", \"false\"},\n@@ -856,0 +865,2 @@\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8331659\n@@ -862,1 +873,1 @@\n-                      \"ShortRunningLongLoop\", \"true\",\n+                      \"ShortRunningLongLoop\", \"false\",\n@@ -866,2 +877,0 @@\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n@@ -869,0 +878,12 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"ShortRunningLongLoop\", \"true\",\n+                      \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ If we don't create the loop nest for the long loop, then the issue with different Casts\n+    \/\/ seems to disappear. We also don't need multiversioning because the pointers are seen\n+    \/\/ as identical.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment.java","additions":35,"deletions":14,"binary":false,"changes":49,"status":"modified"}]}