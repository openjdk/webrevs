{"files":[{"patch":"@@ -370,1 +370,4 @@\n-          \"Use Multiversioning or Predicate to add aliasing runtime checks\") \\\n+          \"Allow the use Multiversioning or Predicate to add aliasing\"      \\\n+          \"runtime checks. Runtime checks will only be inserted if either\"  \\\n+          \"LoopMultiversioning or UseAutoVectorizationPredicate are\"        \\\n+          \"enabled.\")                                                       \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -400,0 +400,6 @@\n+\/\/ With the \"Linearity Corrolary\" below, we can prove that some MemPointers can be treated as\n+\/\/ linear in some summand variable v over some range r. This is useful when MemPointers are\n+\/\/ used in loops, where v=iv scale_v=scale_iv and the range is the iv range from some initial\n+\/\/ iv value to the last iv value just before the limit.\n+\/\/ For an application, see: VPointer::make_speculative_aliasing_check_with\n+\/\/\n@@ -403,2 +409,2 @@\n-\/\/     (C1) a summand \"scale_v * v\" that occurs in mp.\n-\/\/     (C2) a strided range r = [lo, lo + stride_v, .. hi] for v.\n+\/\/     (C1) a specific summand \"scale_v * v\" that occurs in mp.\n+\/\/     (C2) a strided range r = [lo, lo + stride_v, .. hi] for v (lo and hi are inclusive in the range).\n@@ -406,1 +412,3 @@\n-\/\/     (C4) abs(scale_v * stride_v) < 2^31.\n+\/\/     (C4) abs(scale_v * stride_v) < 2^31\n+\/\/            Required for (S2) in application of MemPointer Lemma below, it is essencial in\n+\/\/            establishing linearity of mp.\n@@ -444,1 +452,0 @@\n-\/\/              = summand_rest + scale_v * v0              + scale_v * stride_v + con\n@@ -672,1 +679,16 @@\n-\/\/ to be as simple as possible. For example, the pointer:\n+\/\/ to be as simple as possible. For example, the C2 IR pointer:\n+\/\/\n+\/\/   pointer = AddP(\n+\/\/               AddP(\n+\/\/                 base,\n+\/\/                 LShiftL(\n+\/\/                   ConvI2L(\n+\/\/                     AddI(AddI(i, LShiftI(j, 2)), con1)\n+\/\/                   ),\n+\/\/                   1\n+\/\/                 )\n+\/\/               ),\n+\/\/               con2\n+\/\/             )\n+\/\/\n+\/\/ and more readable:\n@@ -676,1 +698,2 @@\n-\/\/ is simplified to this MemPointer form:\n+\/\/ is simplified to this MemPointer form, using only MemPointerSummands,\n+\/\/ which ignore the possible overflow in ConvI2L:\n","filename":"src\/hotspot\/share\/opto\/mempointer.hpp","additions":29,"deletions":6,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n- *                    There are initially four Parse Predicates for each loop:\n+ *                    There are initially five Parse Predicates for each loop:\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -490,0 +490,12 @@\n+\/\/ Remember that vp1 and vp2 both represent a region in memory, starting at a\n+\/\/ \"pointer\", and extending for \"size\" bytes:\n+\/\/\n+\/\/   vp1(iv) = [p1(iv), size1)\n+\/\/   vp2(iv) = [p2(iv), size2)\n+\/\/\n+\/\/       |---size1--->           |-------size2------->\n+\/\/       |                       |\n+\/\/     p1(iv)                  p2(iv)\n+\/\/\n+\/\/ In each iv value (intuitively: for each iteration), we check that there is no\n+\/\/ overlap:\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}