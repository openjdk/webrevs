{"files":[{"patch":"@@ -315,0 +315,1 @@\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -317,0 +318,11 @@\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, they never fail, so no multiversioning required.\n+    \/\/ With AlignVector we cannot prove that both accesses are alignable.\n+    \/\/\n@@ -319,1 +331,0 @@\n-    \/\/ Probably related to JDK-8348096, issue with RangeCheck elimination.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAliasing.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -210,0 +210,1 @@\n+            \"-XX:\" + randomPlusMinus(5, 1) + \"ShortRunningLongLoop\",\n@@ -233,1 +234,1 @@\n-        for (int i = 0; i < 20; i++) {\n+        for (int i = 0; i < 10; i++) {\n@@ -238,1 +239,1 @@\n-        for (int i = 0; i < 40; i++) {\n+        for (int i = 0; i < 20; i++) {\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAliasingFuzzer.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -82,0 +82,8 @@\n+\/*\n+ * @test id=byte-array-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n+ * @bug 8329273 8348263 8342692 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteArray NoSpeculativeAliasingCheck NoShortRunningLongLoop\n+ *\/\n+\n@@ -178,0 +186,40 @@\n+\/*\n+ * @test id=native-NoSpeculativeAliasingCheck\n+ * @bug 8329273 8348263 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=native-AlignVector-NoSpeculativeAliasingCheck\n+ * @bug 8329273 8348263 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native AlignVector NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=native-NoShortRunningLongLoop\n+ * @bug 8329273 8342692\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=native-AlignVector-NoShortRunningLongLoop\n+ * @bug 8329273 8348263 8342692\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native AlignVector NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=native-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n+ * @bug 8329273 8348263 8342692 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native NoSpeculativeAliasingCheck NoShortRunningLongLoop\n+ *\/\n+\n@@ -212,0 +260,3 @@\n+                \/\/ Disabling the ShortRunningLongLoop optimization changes the shape of the loop.\n+                \/\/ Testing both with and without it allows us to simulate long running loops with short running loops,\n+                \/\/ i.e. we don't need to allocate massive amounts of memory.\n@@ -819,33 +870,0 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n-                  IRNode.ADD_VI,        \"= 0\",\n-                  IRNode.STORE_VECTOR,  \"= 0\"},\n-        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\",\n-                      \"ShortRunningLongLoop\", \"false\"},\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n-                  IRNode.ADD_VI,        \"> 0\",\n-                  IRNode.STORE_VECTOR,  \"> 0\",\n-                  \".*multiversion.*\", \"> 0\"},\n-        phase = CompilePhase.PRINT_IDEAL,\n-        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n-                      \"ShortRunningLongLoop\", \"false\",\n-                      \"AlignVector\", \"false\"},\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    \/\/ After JDK-8324751, we now insert a aliasing runtime check, but it will always fail, which is a suboptimal.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n-                  IRNode.ADD_VI,        \"> 0\",\n-                  IRNode.STORE_VECTOR,  \"> 0\",\n-                  \".*multiversion.*\", \"= 0\"},\n-        phase = CompilePhase.PRINT_IDEAL,\n-        applyIfAnd = {\"ShortRunningLongLoop\", \"true\",\n-                      \"AlignVector\", \"false\"},\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    \/\/ If we don't create the loop nest for the long loop, then the issue with different Casts\n-    \/\/ seems to disappear. We also don't need multiversioning because the pointers are seen\n-    \/\/ as identical.\n-    \/\/ TODO: enough?\n@@ -868,34 +886,0 @@\n-   @Test\n-   @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n-                  IRNode.ADD_VI,        \"= 0\",\n-                  IRNode.STORE_VECTOR,  \"= 0\"},\n-        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\",\n-                      \"ShortRunningLongLoop\", \"false\"},\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n-                  IRNode.ADD_VI,        \"> 0\",\n-                  IRNode.STORE_VECTOR,  \"> 0\",\n-                  \".*multiversion.*\", \"> 0\"},\n-        phase = CompilePhase.PRINT_IDEAL,\n-        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n-                      \"ShortRunningLongLoop\", \"false\",\n-                      \"AlignVector\", \"false\"},\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    \/\/ After JDK-8324751, we now insert a aliasing runtime check, but it will always fail, which is a suboptimal.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n-                  IRNode.ADD_VI,        \"> 0\",\n-                  IRNode.STORE_VECTOR,  \"> 0\",\n-                  \".*multiversion.*\", \"= 0\"},\n-        phase = CompilePhase.PRINT_IDEAL,\n-        applyIfAnd = {\"ShortRunningLongLoop\", \"true\",\n-                      \"AlignVector\", \"false\"},\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n-    \/\/ If we don't create the loop nest for the long loop, then the issue with different Casts\n-    \/\/ seems to disappear. We also don't need multiversioning because the pointers are seen\n-    \/\/ as identical.\n-    \/\/ TODO: enough?\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment.java","additions":51,"deletions":67,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -75,0 +75,24 @@\n+\/*\n+ * @test id=byte-array-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-AlignVector-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray AlignVector NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray NoSpeculativeAliasingCheck NoShortRunningLongLoop\n+ *\/\n+\n@@ -131,0 +155,16 @@\n+\/*\n+ * @test id=int-array-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=int-array-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray NoSpeculativeAliasingCheck NoShortRunningLongLoop\n+ *\/\n+\n@@ -228,1 +268,17 @@\n- * @test id=native-NoAutoAlignment\n+ * @test id=native-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=native-AlignVector-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native AlignVector NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=native-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n@@ -232,1 +288,1 @@\n- * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native NoAutoAlignment\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native NoSpeculativeAliasingCheck NoShortRunningLongLoop\n@@ -247,0 +303,4 @@\n+                \/\/ Disabling the ShortRunningLongLoop optimization changes the shape of the loop.\n+                \/\/ Testing both with and without it allows us to simulate long running loops with short running loops,\n+                \/\/ i.e. we don't need to allocate massive amounts of memory.\n+                case \"NoShortRunningLongLoop\" ->     framework.addFlags(\"-XX:-ShortRunningLongLoop\");\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentAliasing.java","additions":62,"deletions":2,"binary":false,"changes":64,"status":"modified"}]}