{"files":[{"patch":"@@ -410,2 +410,2 @@\n-\/\/       p(v)  = p(lo)  - lo * scale_v + iv * scale_v              (Corrolary P)\n-\/\/       mp(v) = mp(lo) - lo * scale_v + iv * scale_v              (Corrolary MP)\n+\/\/       p(v)  = p(lo)  - lo * scale_v + v * scale_v              (Corrolary P)\n+\/\/       mp(v) = mp(lo) - lo * scale_v + v * scale_v              (Corrolary MP)\n@@ -419,1 +419,1 @@\n-\/\/     p(v) = p(lo) - lo * scale_v + iv * scale_v\n+\/\/     p(v) = p(lo) - lo * scale_v + v * scale_v\n@@ -421,1 +421,1 @@\n-\/\/          = p(hi) - hi * scale_v + iv * scale_v             (Alternative Corrolary P)\n+\/\/          = p(hi) - hi * scale_v + v * scale_v             (Alternative Corrolary P)\n@@ -441,4 +441,4 @@\n-\/\/       mp(v1) = summand_rest + scale_v * v1                                    + con\n-\/\/              = summand_rest + scale_v * (v0 + stride_v)                       + con\n-\/\/              = summand_rest + scale_v * v0              + scale_v * stride_v * con\n-\/\/              = summand_rest + scale_v * v0              + scale_v * stride_v * con\n+\/\/       mp(v1) = summand_rest + scale_v * v1                                   + con\n+\/\/              = summand_rest + scale_v * (v0 + stride_v)                      + con\n+\/\/              = summand_rest + scale_v * v0              + scale_v * stride_v + con\n+\/\/              = summand_rest + scale_v * v0              + scale_v * stride_v + con\n@@ -663,0 +663,7 @@\n+\/\/ We need two different ways of tracking the summands:\n+\/\/ - MemPointerRawSummand: designed to keep track of the original form of\n+\/\/                         the pointer, preserving its overflow behavior.\n+\/\/ - MemPointerSummand:    designed to allow simplification of the MemPointer\n+\/\/                         form, does not preserve the original form and\n+\/\/                         ignores overflow from ConvI2L.\n+\/\/\n@@ -706,1 +713,2 @@\n-\/\/       and we store the constant value in _scaleI.\n+\/\/       and we store the constant value in _scaleI (for int constant) and in\n+\/\/       _scaleL (for long constants).\n","filename":"src\/hotspot\/share\/opto\/mempointer.hpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-    \/\/ But in some cases, we ctrl of n is between the pre and\n+    \/\/ But in some cases, the ctrl of n is between the pre and\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-\/\/ The C2 IR Node memory edges essencially define a linear order of all memory operations\n+\/\/ The C2 IR Node memory edges essentially define a linear order of all memory operations\n@@ -281,1 +281,1 @@\n-\/\/ efficient, because it means ever Load and Store has exactly one input memory edge,\n+\/\/ efficient, because it means every Load and Store has exactly one input memory edge,\n@@ -285,1 +285,1 @@\n-\/\/ could be quadratic in the worst case. For vectorization, we must essencially reorder the\n+\/\/ could be quadratic in the worst case. For vectorization, we must essentially reorder the\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -270,1 +270,1 @@\n-    \/\/ The invar variables for invarRest must be in the range [-1, 1, 1], so that we can\n+    \/\/ The invar variables for invarRest must be in the range [-1, 0, 1], so that we can\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAliasingFuzzer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}