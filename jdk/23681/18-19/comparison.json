{"files":[{"patch":"@@ -39,1 +39,1 @@\n-    final String name;\n+    private final String name;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -747,1 +747,1 @@\n-#         ([HandshakeSignature] | [CertificateSignature])\n+#         HandshakeSignature | CertificateSignature\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+\n+import java.util.Objects;\n@@ -267,0 +269,71 @@\n+\n+    \/**\n+     * Given a TLS record containing one or more handshake messages, return\n+     * the specific handshake message as a ByteBuffer (a slice of the record)\n+     *\n+     * @param tlsRecord A ByteBuffer containing a TLS record.  It is\n+     *         assumed that the position of the ByteBuffer is on the\n+     *         first byte of the TLS record header.\n+     * @param hsMsgId The message identifier for the handshake message\n+     *         being sought.\n+     *         <a\n+     *         href=\"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8446#appendix-B.3\">\n+     *         Message Identifiers\n+     *         <\/a>\n+     * @param isDtls Indicates whether DTLS protocol being used.\n+     * @return a ByteBuffer containing the TLS handshake message.\n+     *         The position of the returned ByteBuffer will be on the\n+     *         first byte of the TLS handshake message data,\n+     *         immediately following the handshake header.\n+     *         If the message is not found, null will be returned.\n+     * @throws SSLException if the incoming ByteBuffer does not contain\n+     *         a well-formed TLS message.\n+     *\/\n+    protected static ByteBuffer extractHandshakeMsg(\n+            ByteBuffer tlsRecord, int hsMsgId, boolean isDtls)\n+            throws SSLException {\n+        Objects.requireNonNull(tlsRecord);\n+        tlsRecord.mark();\n+\n+        \/\/ Process the TLS record header\n+        int type = Byte.toUnsignedInt(tlsRecord.get());\n+        int ver_major = Byte.toUnsignedInt(tlsRecord.get());\n+        int ver_minor = Byte.toUnsignedInt(tlsRecord.get());\n+        \/\/ Skip DTLS-specific bytes\n+        if (isDtls) {\n+            tlsRecord.position(tlsRecord.position() + 8);\n+        }\n+        int recLen = Short.toUnsignedInt(tlsRecord.getShort());\n+\n+        if (recLen > tlsRecord.remaining()) {\n+            throw new SSLException(\"Incomplete record in buffer: \" +\n+                                   \"Record length = \" + recLen\n+                                   + \", Remaining = \" +\n+                                   tlsRecord.remaining());\n+        }\n+\n+        while (tlsRecord.hasRemaining()) {\n+            \/\/ Grab the handshake message header.\n+            int msgHdr = tlsRecord.getInt();\n+            int msgType = (msgHdr >> 24) & 0x000000FF;\n+            int msgLen = msgHdr & 0x00FFFFFF;\n+            \/\/ Skip DTLS-specific bytes\n+            if (isDtls) {\n+                tlsRecord.position(tlsRecord.position() + 8);\n+            }\n+\n+            if (msgType == hsMsgId) {\n+                \/\/ Slice the buffer such that it contains the entire\n+                \/\/ handshake message (less the handshake header).\n+                ByteBuffer buf = tlsRecord.slice(tlsRecord.position(), msgLen);\n+                tlsRecord.reset();\n+                return buf;\n+            } else {\n+                \/\/ Skip to the next handshake message, if there is one\n+                tlsRecord.position(tlsRecord.position() + msgLen);\n+            }\n+        }\n+\n+        tlsRecord.reset();\n+        return null;\n+    }\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLEngineTemplate.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -77,3 +77,2 @@\n-    protected String getProtocol() {\n-        return \"TLSv1.2\";\n-    }\n+    \/\/ Returns the protocol for test to use.\n+    abstract String getProtocol();\n@@ -110,62 +109,3 @@\n-    \/**\n-     * Given a TLS record containing one or more handshake messages, return\n-     * the specific handshake message as a ByteBuffer (a slice of the record)\n-     *\n-     * @param tlsRecord A ByteBuffer containing a TLS record.  It is\n-     *                  assumed that the position of the ByteBuffer is on the\n-     *                  first byte of the TLS record header.\n-     * @param hsMsgId   The message identifier for the handshake message\n-     *                  being sought.\n-     * @return          a ByteBuffer containing the TLS handshake message.\n-     *                  The position of the returned ByteBuffer will be on the\n-     *                  first byte of the TLS handshake message data,\n-     *                  immediately following the handshake header.\n-     *                  If the message is not found, null will be returned.\n-     * @throws SSLException if the incoming ByteBuffer does not contain\n-     *                      a well-formed TLS message.\n-     *\/\n-    protected ByteBuffer extractHandshakeMsg(ByteBuffer tlsRecord,\n-            int hsMsgId) throws SSLException {\n-        Objects.requireNonNull(tlsRecord);\n-        tlsRecord.mark();\n-\n-        \/\/ Process the TLS record header\n-        int type = Byte.toUnsignedInt(tlsRecord.get());\n-        int ver_major = Byte.toUnsignedInt(tlsRecord.get());\n-        int ver_minor = Byte.toUnsignedInt(tlsRecord.get());\n-        \/\/ Skip DTLS-specific bytes\n-        if (isDtls()) {\n-            tlsRecord.position(tlsRecord.position() + 8);\n-        }\n-        int recLen = Short.toUnsignedInt(tlsRecord.getShort());\n-\n-        if (recLen > tlsRecord.remaining()) {\n-            throw new SSLException(\"Incomplete record in buffer: \" +\n-                    \"Record length = \" + recLen + \", Remaining = \" +\n-                    tlsRecord.remaining());\n-        }\n-\n-        while (tlsRecord.hasRemaining()) {\n-            \/\/ Grab the handshake message header.\n-            int msgHdr = tlsRecord.getInt();\n-            int msgType = (msgHdr >> 24) & 0x000000FF;\n-            int msgLen = msgHdr & 0x00FFFFFF;\n-            \/\/ Skip DTLS-specific bytes\n-            if (isDtls()) {\n-                tlsRecord.position(tlsRecord.position() + 8);\n-            }\n-\n-            if (msgType == hsMsgId) {\n-                \/\/ Slice the buffer such that it contains the entire\n-                \/\/ handshake message (less the handshake header).\n-                ByteBuffer buf = tlsRecord.slice(tlsRecord.position(), msgLen);\n-                tlsRecord.reset();\n-                return buf;\n-            } else {\n-                \/\/ Skip to the next handshake message, if there is one\n-                tlsRecord.position(tlsRecord.position() + msgLen);\n-            }\n-        }\n-\n-        tlsRecord.reset();\n-        return null;\n+    protected ByteBuffer extractHandshakeMsg(ByteBuffer tlsRecord, int hsMsgId)\n+            throws SSLException {\n+        return extractHandshakeMsg(tlsRecord, hsMsgId, isDtls());\n@@ -174,1 +114,0 @@\n-\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/AbstractCheckSignatureSchemes.java","additions":5,"deletions":66,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+    \/\/ We differ from \"HandshakeSignature\" and \"CertificateSignature\" specified\n+    \/\/ in java.security to check case-insensitive matching.\n@@ -64,0 +66,4 @@\n+    protected String getProtocol() {\n+        return \"TLSv1.2\";\n+    }\n+\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableSignatureSchemePerScopeTLS12.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,0 +57,4 @@\n+    protected String getProtocol() {\n+        return \"TLSv1.2\";\n+    }\n+\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/SigSchemePropOrdering.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}