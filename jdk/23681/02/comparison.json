{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import static sun.security.ssl.SignatureScheme.CERTIFICATE_SCOPE;\n+\n@@ -100,5 +102,4 @@\n-            if (chc.localSupportedSignAlgs == null) {\n-                chc.localSupportedSignAlgs =\n-                    SignatureScheme.getSupportedAlgorithms(\n-                            chc.sslConfig,\n-                            chc.algorithmConstraints, chc.activeProtocols);\n+            if (chc.localSupportedCertSignAlgs == null) {\n+                chc.localSupportedCertSignAlgs =\n+                        SignatureScheme.getSupportedAlgorithms(\n+                                chc, CERTIFICATE_SCOPE);\n@@ -108,1 +109,1 @@\n-                    chc.localSupportedSignAlgs.size();\n+                    chc.localSupportedCertSignAlgs.size();\n@@ -112,1 +113,1 @@\n-            for (SignatureScheme ss : chc.localSupportedSignAlgs) {\n+            for (SignatureScheme ss : chc.localSupportedCertSignAlgs) {\n@@ -119,1 +120,1 @@\n-                    new SignatureSchemesSpec(chc.localSupportedSignAlgs));\n+                    new SignatureSchemesSpec(chc.localSupportedCertSignAlgs));\n@@ -192,3 +193,2 @@\n-                            shc.sslConfig,\n-                            shc.algorithmConstraints, shc.negotiatedProtocol,\n-                            spec.signatureSchemes);\n+                            shc, spec.signatureSchemes, CERTIFICATE_SCOPE);\n+\n@@ -243,5 +243,5 @@\n-            List<SignatureScheme> sigAlgs =\n-                    SignatureScheme.getSupportedAlgorithms(\n-                            shc.sslConfig,\n-                            shc.algorithmConstraints,\n-                            List.of(shc.negotiatedProtocol));\n+            if (shc.localSupportedCertSignAlgs == null) {\n+                shc.localSupportedCertSignAlgs =\n+                        SignatureScheme.getSupportedAlgorithms(\n+                                shc, CERTIFICATE_SCOPE);\n+            }\n@@ -249,1 +249,2 @@\n-            int vectorLen = SignatureScheme.sizeInRecord() * sigAlgs.size();\n+            int vectorLen = SignatureScheme.sizeInRecord()\n+                    * shc.localSupportedCertSignAlgs.size();\n@@ -253,1 +254,1 @@\n-            for (SignatureScheme ss : sigAlgs) {\n+            for (SignatureScheme ss : shc.localSupportedCertSignAlgs) {\n@@ -260,1 +261,1 @@\n-                    new SignatureSchemesSpec(shc.localSupportedSignAlgs));\n+                    new SignatureSchemesSpec(shc.localSupportedCertSignAlgs));\n@@ -332,3 +333,2 @@\n-                            chc.sslConfig,\n-                            chc.algorithmConstraints, chc.negotiatedProtocol,\n-                            spec.signatureSchemes);\n+                            chc, spec.signatureSchemes, CERTIFICATE_SCOPE);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertSignAlgsExtension.java","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+import static sun.security.ssl.SignatureScheme.CERTIFICATE_SCOPE;\n+import static sun.security.ssl.SignatureScheme.HANDSHAKE_SCOPE;\n+\n@@ -1054,1 +1057,2 @@\n-                            ka, hc.negotiatedProtocol) != null\n+                            ka, hc.negotiatedProtocol,\n+                            HANDSHAKE_SCOPE) != null\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateMessage.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import static sun.security.ssl.SignatureScheme.CERTIFICATE_SCOPE;\n+import static sun.security.ssl.SignatureScheme.HANDSHAKE_SCOPE;\n+\n@@ -399,1 +402,0 @@\n-\n@@ -635,1 +637,2 @@\n-            ServerHandshakeContext shc = (ServerHandshakeContext)context;\n+            ServerHandshakeContext shc = (ServerHandshakeContext) context;\n+\n@@ -638,3 +641,8 @@\n-                    SignatureScheme.getSupportedAlgorithms(\n-                            shc.sslConfig,\n-                            shc.algorithmConstraints, shc.activeProtocols);\n+                        SignatureScheme.getSupportedAlgorithms(\n+                                shc, HANDSHAKE_SCOPE);\n+            }\n+\n+            if (shc.localSupportedCertSignAlgs == null) {\n+                shc.localSupportedCertSignAlgs =\n+                        SignatureScheme.getSupportedAlgorithms(\n+                                shc, CERTIFICATE_SCOPE);\n@@ -643,1 +651,8 @@\n-            if (shc.localSupportedSignAlgs.isEmpty()) {\n+            \/\/ According to TLSv1.2 RFC, CertificateRequest message must\n+            \/\/ contain signature schemes supported for both:\n+            \/\/ handshake signatures and certificate signatures.\n+            List<SignatureScheme> certReqSignAlgs =\n+                    new ArrayList<>(shc.localSupportedSignAlgs);\n+            certReqSignAlgs.retainAll(shc.localSupportedCertSignAlgs);\n+\n+            if (certReqSignAlgs.isEmpty()) {\n@@ -652,1 +667,1 @@\n-                    shc.localSupportedSignAlgs);\n+                    certReqSignAlgs);\n@@ -733,1 +748,1 @@\n-            List<SignatureScheme> sss =\n+            List<SignatureScheme> signAlgs =\n@@ -735,4 +750,12 @@\n-                            chc.sslConfig,\n-                            chc.algorithmConstraints, chc.negotiatedProtocol,\n-                            crm.algorithmIds);\n-            if (sss.isEmpty()) {\n+                            chc, crm.algorithmIds, HANDSHAKE_SCOPE);\n+\n+            if (signAlgs.isEmpty()) {\n+                throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                        \"No supported signature algorithm\");\n+            }\n+\n+            List<SignatureScheme> signCertAlgs =\n+                    SignatureScheme.getSupportedAlgorithms(\n+                            chc, crm.algorithmIds, CERTIFICATE_SCOPE);\n+\n+            if (signCertAlgs.isEmpty()) {\n@@ -743,3 +766,4 @@\n-            chc.peerRequestedSignatureSchemes = sss;\n-            chc.peerRequestedCertSignSchemes = sss;     \/\/ use the same schemes\n-            chc.handshakeSession.setPeerSupportedSignatureAlgorithms(sss);\n+            chc.peerRequestedSignatureSchemes = signAlgs;\n+            chc.peerRequestedCertSignSchemes = signCertAlgs;\n+            chc.handshakeSession.setPeerSupportedSignatureAlgorithms(signCertAlgs);\n+\n@@ -795,1 +819,2 @@\n-                            ka, hc.negotiatedProtocol) != null\n+                            ka, hc.negotiatedProtocol,\n+                            HANDSHAKE_SCOPE) != null\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateRequest.java","additions":41,"deletions":16,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    final AlgorithmConstraints              algorithmConstraints;\n+    final SSLAlgorithmConstraints           algorithmConstraints;\n@@ -130,0 +130,1 @@\n+    List<SignatureScheme>                   localSupportedCertSignAlgs;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HandshakeContext.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import static sun.security.ssl.SignatureScheme.HANDSHAKE_SCOPE;\n@@ -450,2 +451,1 @@\n-                            shc.sslConfig,\n-                            shc.algorithmConstraints, shc.activeProtocols);\n+                            shc, HANDSHAKE_SCOPE);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PreSharedKeyExtension.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.stream.Collectors;\n@@ -45,1 +46,1 @@\n-    private static final AlgorithmConstraints tlsDisabledAlgConstraints =\n+    private static final DisabledAlgorithmConstraints tlsDisabledAlgConstraints =\n@@ -49,1 +50,1 @@\n-    private static final AlgorithmConstraints x509DisabledAlgConstraints =\n+    private static final DisabledAlgorithmConstraints x509DisabledAlgConstraints =\n@@ -59,1 +60,1 @@\n-    static final AlgorithmConstraints DEFAULT =\n+    static final SSLAlgorithmConstraints DEFAULT =\n@@ -63,1 +64,1 @@\n-    static final AlgorithmConstraints DEFAULT_SSL_ONLY =\n+    static final SSLAlgorithmConstraints DEFAULT_SSL_ONLY =\n@@ -87,1 +88,1 @@\n-    static AlgorithmConstraints wrap(AlgorithmConstraints userSpecifiedConstraints) {\n+    static SSLAlgorithmConstraints wrap(AlgorithmConstraints userSpecifiedConstraints) {\n@@ -91,1 +92,1 @@\n-    private static AlgorithmConstraints wrap(\n+    private static SSLAlgorithmConstraints wrap(\n@@ -202,1 +203,1 @@\n-                                    primitives, algorithm, parameters);\n+                    primitives, algorithm, parameters);\n@@ -207,1 +208,1 @@\n-                                    primitives, algorithm, parameters);\n+                    primitives, algorithm, parameters);\n@@ -212,1 +213,1 @@\n-                                    primitives, algorithm, parameters);\n+                    primitives, algorithm, parameters);\n@@ -217,1 +218,1 @@\n-                                    primitives, algorithm, parameters);\n+                    primitives, algorithm, parameters);\n@@ -255,1 +256,1 @@\n-                                    primitives, algorithm, key, parameters);\n+                    primitives, algorithm, key, parameters);\n@@ -260,1 +261,1 @@\n-                                    primitives, algorithm, key, parameters);\n+                    primitives, algorithm, key, parameters);\n@@ -265,1 +266,1 @@\n-                                    primitives, algorithm, key, parameters);\n+                    primitives, algorithm, key, parameters);\n@@ -270,1 +271,1 @@\n-                                    primitives, algorithm, key, parameters);\n+                    primitives, algorithm, key, parameters);\n@@ -276,0 +277,7 @@\n+    \/\/ Checks if algorithm is disabled for the given TLS scopes.\n+    boolean permits(String algorithm, Set<SSLCryptoScope> scopes) {\n+        return tlsDisabledAlgConstraints.permits(algorithm,\n+                scopes.stream()\n+                .map(SSLCryptoScope::name)\n+                .collect(Collectors.toSet()));\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLAlgorithmConstraints.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * Scopes defining different parts of TLS protocol.\n+ *\/\n+\n+package sun.security.ssl;\n+\n+enum SSLCryptoScope {\n+    \/\/ Handshake scope as in signature_algorithms extension.\n+    HANDSHAKE,\n+    \/\/ Certificate scope as in signature_algorithms_cert extension.\n+    CERTIFICATE;\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLCryptoScope.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -198,1 +198,1 @@\n-        this.localSupportedSignAlgs = hc.localSupportedSignAlgs == null ?\n+        this.localSupportedSignAlgs = hc.localSupportedCertSignAlgs == null ?\n@@ -201,1 +201,1 @@\n-                        new ArrayList<>(hc.localSupportedSignAlgs));\n+                        new ArrayList<>(hc.localSupportedCertSignAlgs));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import static sun.security.ssl.SignatureScheme.CERTIFICATE_SCOPE;\n+import static sun.security.ssl.SignatureScheme.HANDSHAKE_SCOPE;\n+\n@@ -275,2 +278,7 @@\n-                                shc.sslConfig,\n-                                shc.algorithmConstraints, shc.activeProtocols);\n+                                shc, HANDSHAKE_SCOPE);\n+                }\n+\n+                if (shc.localSupportedCertSignAlgs == null) {\n+                    shc.localSupportedCertSignAlgs =\n+                            SignatureScheme.getSupportedAlgorithms(\n+                                    shc, CERTIFICATE_SCOPE);\n@@ -516,2 +524,7 @@\n-                                shc.sslConfig,\n-                                shc.algorithmConstraints, shc.activeProtocols);\n+                                shc, HANDSHAKE_SCOPE);\n+                }\n+\n+                if (shc.localSupportedCertSignAlgs == null) {\n+                    shc.localSupportedCertSignAlgs =\n+                            SignatureScheme.getSupportedAlgorithms(\n+                                    shc, CERTIFICATE_SCOPE);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import static sun.security.ssl.SignatureScheme.CERTIFICATE_SCOPE;\n@@ -355,2 +356,2 @@\n-            if (chc.localSupportedSignAlgs == null) {\n-                chc.localSupportedSignAlgs =\n+            if (chc.localSupportedCertSignAlgs == null) {\n+                chc.localSupportedCertSignAlgs =\n@@ -358,2 +359,1 @@\n-                                chc.sslConfig,\n-                                chc.algorithmConstraints, chc.activeProtocols);\n+                                chc, CERTIFICATE_SCOPE);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SessionTicketExtension.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import static sun.security.ssl.SignatureScheme.HANDSHAKE_SCOPE;\n+\n@@ -191,2 +193,1 @@\n-                            chc.sslConfig,\n-                            chc.algorithmConstraints, chc.activeProtocols);\n+                            chc, HANDSHAKE_SCOPE);\n@@ -279,3 +280,2 @@\n-                            shc.sslConfig,\n-                            shc.algorithmConstraints, shc.negotiatedProtocol,\n-                            spec.signatureSchemes);\n+                            shc, spec.signatureSchemes, HANDSHAKE_SCOPE);\n+\n@@ -417,3 +417,1 @@\n-                            shc.sslConfig,\n-                            shc.algorithmConstraints,\n-                            List.of(shc.negotiatedProtocol));\n+                            shc, HANDSHAKE_SCOPE);\n@@ -507,3 +505,2 @@\n-                            chc.sslConfig,\n-                            chc.algorithmConstraints, chc.negotiatedProtocol,\n-                            spec.signatureSchemes);\n+                            chc, spec.signatureSchemes, HANDSHAKE_SCOPE);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureAlgorithmsExtension.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -221,3 +221,7 @@\n-    \/\/ performance optimization\n-    private static final Set<CryptoPrimitive> SIGNATURE_PRIMITIVE_SET =\n-        Collections.unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));\n+    \/\/ Handshake signature scope\n+    public static final Set<SSLCryptoScope> HANDSHAKE_SCOPE =\n+            Collections.unmodifiableSet(EnumSet.of(SSLCryptoScope.HANDSHAKE));\n+\n+    \/\/ Certificate signature scope\n+    public static final Set<SSLCryptoScope> CERTIFICATE_SCOPE =\n+            Collections.unmodifiableSet(EnumSet.of(SSLCryptoScope.CERTIFICATE));\n@@ -225,0 +229,2 @@\n+    private static final Set<CryptoPrimitive> SIGNATURE_PRIMITIVE_SET =\n+            Collections.unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));\n@@ -358,10 +364,22 @@\n-    private boolean isPermitted(AlgorithmConstraints constraints) {\n-        return constraints.permits(SIGNATURE_PRIMITIVE_SET,\n-                        this.name, null) &&\n-               constraints.permits(SIGNATURE_PRIMITIVE_SET,\n-                        this.keyAlgorithm, null) &&\n-               constraints.permits(SIGNATURE_PRIMITIVE_SET,\n-                        this.algorithm, (signAlgParams != null ?\n-                                signAlgParams.parameters : null)) &&\n-                        (namedGroup == null ||\n-                            namedGroup.isPermitted(constraints));\n+    private boolean isPermitted(\n+            SSLAlgorithmConstraints constraints, Set<SSLCryptoScope> scopes) {\n+        return constraints.permits(this.name, scopes)\n+                && constraints.permits(this.keyAlgorithm, scopes)\n+                && constraints.permits(this.algorithm, scopes)\n+                && constraints.permits(SIGNATURE_PRIMITIVE_SET, this.name, null)\n+                && constraints.permits(SIGNATURE_PRIMITIVE_SET, this.keyAlgorithm, null)\n+                && constraints.permits(SIGNATURE_PRIMITIVE_SET, this.algorithm,\n+                (signAlgParams != null ? signAlgParams.parameters : null))\n+                && (namedGroup == null || namedGroup.isPermitted(constraints));\n+    }\n+\n+    \/\/ Wrapper method taking a HandshakeContext.\n+    static List<SignatureScheme> getSupportedAlgorithms(\n+            HandshakeContext hc, Set<SSLCryptoScope> scopes) {\n+        return getSupportedAlgorithms(\n+                hc.sslConfig,\n+                hc.algorithmConstraints,\n+                hc.negotiatedProtocol != null\n+                        ? List.of(hc.negotiatedProtocol)\n+                        : hc.activeProtocols,\n+                scopes);\n@@ -374,2 +392,3 @@\n-            AlgorithmConstraints constraints,\n-            List<ProtocolVersion> activeProtocols) {\n+            SSLAlgorithmConstraints constraints,\n+            List<ProtocolVersion> activeProtocols,\n+            Set<SSLCryptoScope> scopes) {\n@@ -402,1 +421,1 @@\n-                if (ss.isPermitted(constraints)) {\n+                if (ss.isPermitted(constraints, scopes)) {\n@@ -419,0 +438,11 @@\n+    \/\/ Wrapper method taking a HandshakeContext.\n+    static List<SignatureScheme> getSupportedAlgorithms(\n+            HandshakeContext hc, int[] algorithmIds, Set<SSLCryptoScope> scopes) {\n+        return getSupportedAlgorithms(\n+                hc.sslConfig,\n+                hc.algorithmConstraints,\n+                hc.negotiatedProtocol,\n+                algorithmIds,\n+                scopes);\n+    }\n+\n@@ -421,2 +451,4 @@\n-            AlgorithmConstraints constraints,\n-            ProtocolVersion protocolVersion, int[] algorithmIds) {\n+            SSLAlgorithmConstraints constraints,\n+            ProtocolVersion protocolVersion,\n+            int[] algorithmIds,\n+            Set<SSLCryptoScope> scopes) {\n@@ -436,1 +468,1 @@\n-                    ss.isPermitted(constraints)) {\n+                    ss.isPermitted(constraints, scopes)) {\n@@ -450,1 +482,1 @@\n-            AlgorithmConstraints constraints,\n+            SSLAlgorithmConstraints constraints,\n@@ -453,1 +485,2 @@\n-            ProtocolVersion version) {\n+            ProtocolVersion version,\n+            Set<SSLCryptoScope> scopes) {\n@@ -459,1 +492,1 @@\n-                    ss.isPermitted(constraints)) {\n+                    ss.isPermitted(constraints, scopes)) {\n@@ -469,1 +502,1 @@\n-            AlgorithmConstraints constraints,\n+            SSLAlgorithmConstraints constraints,\n@@ -488,1 +521,1 @@\n-                    ss.isPermitted(constraints)) {\n+                    ss.isPermitted(constraints, HANDSHAKE_SCOPE)) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureScheme.java","additions":57,"deletions":24,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import java.util.TreeMap;\n@@ -90,0 +91,5 @@\n+    \/\/ These should match SSLCryptoScope enums which aren't public so\n+    \/\/ we can't access them here directly.\n+    private static final List<String> VALID_SCOPES = List.of(\n+            \"HANDSHAKE\", \"CERTIFICATE\");\n+\n@@ -105,0 +111,1 @@\n+    private final Map<String, Set<String>> disabledAlgorithmScopes;\n@@ -143,0 +150,1 @@\n+            disabledAlgorithmScopes = getDisabledAlgorithmScopes();\n@@ -145,0 +153,1 @@\n+            disabledAlgorithmScopes = null;\n@@ -175,1 +184,1 @@\n-        if (!cachedCheckAlgorithm(algorithm)) {\n+        if (!cachedCheckAlgorithm(algorithm, null)) {\n@@ -210,0 +219,5 @@\n+    \/\/ Checks if algorithm is disabled for the given TLS scopes.\n+    public boolean permits(String algorithm, Set<String> scopes) {\n+        return cachedCheckAlgorithm(algorithm, scopes);\n+    }\n+\n@@ -258,1 +272,1 @@\n-                    if (!cachedCheckAlgorithm(curve)) {\n+                    if (!cachedCheckAlgorithm(curve, null)) {\n@@ -964,1 +978,2 @@\n-    private boolean cachedCheckAlgorithm(String algorithm) {\n+    private boolean cachedCheckAlgorithm(\n+            String algorithm, Set<String> scopes) {\n@@ -966,0 +981,1 @@\n+\n@@ -974,1 +990,5 @@\n-        Boolean result = cache.get(algorithm);\n+\n+        final String cacheKey = algorithm + \":\" +\n+                (scopes == null ? \"null\" : String.valueOf(scopes.hashCode()));\n+        Boolean result = cache.get(cacheKey);\n+\n@@ -978,1 +998,1 @@\n-        \/\/ We won't check patterns if algorithm check fails.\n+\n@@ -980,2 +1000,4 @@\n-                && checkDisabledPatterns(algorithm);\n-        cache.put(algorithm, result);\n+                && checkDisabledPatterns(algorithm)\n+                && checkAlgorithmTlsScopes(algorithm, scopes);\n+\n+        cache.put(cacheKey, result);\n@@ -1020,0 +1042,65 @@\n+    private boolean checkAlgorithmTlsScopes(\n+            final String algorithm, Set<String> scopes) {\n+\n+        if (disabledAlgorithmScopes == null || scopes == null) {\n+            return true;\n+        }\n+\n+        Set<String> constraintScopes = disabledAlgorithmScopes.get(algorithm);\n+\n+        if (constraintScopes == null) {\n+            return true;\n+        }\n+\n+        for (String scope : scopes) {\n+            if (constraintScopes.contains(scope.toUpperCase(Locale.ENGLISH))) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    private Map<String, Set<String>> getDisabledAlgorithmScopes() {\n+        Map<String, Set<String>> ret = null;\n+        List<String> entriesToRemove = new ArrayList<>(1);\n+\n+        for (String p : disabledAlgorithms) {\n+            String[] arr = p.split(\" \");\n+\n+            if (arr.length > 2 && arr[1].equalsIgnoreCase(\"usage\")) {\n+                boolean tlsUsages = false;\n+                boolean nonTlsUsages = false;\n+                String key = arr[0];\n+\n+                for (int i = 2; i < arr.length; i++) {\n+                    String scope = arr[i].toUpperCase(Locale.ENGLISH);\n+\n+                    if (VALID_SCOPES.contains(scope)) {\n+                        tlsUsages = true;\n+\n+                        if (ret == null) {\n+                            ret = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n+                        }\n+                        ret.computeIfAbsent(key, _ -> new HashSet<>(1));\n+                        ret.get(key).add(scope);\n+                    } else {\n+                        nonTlsUsages = true;\n+                    }\n+                }\n+\n+                if (tlsUsages) {\n+                    if (nonTlsUsages) {\n+                        throw new IllegalArgumentException(\n+                                \"Can't mix TLS protocol specific constraints\"\n+                                        + \" with other usage constraints\");\n+                    }\n+                    entriesToRemove.add(p);\n+                }\n+            }\n+        }\n+\n+        entriesToRemove.forEach(disabledAlgorithms::remove);\n+        return ret;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DisabledAlgorithmConstraints.java","additions":94,"deletions":7,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -732,5 +732,21 @@\n-# syntax of the disabled algorithm string. Additionally, TLS cipher suites\n-# can be disabled with this property using one or more \"*\" wildcard characters.\n-# For example, \"TLS_RSA_*\" disables all cipher suites that start with\n-# \"TLS_RSA_\". Only cipher suites starting with \"TLS_\" are allowed to have\n-# wildcard characters.\n+# syntax of the disabled algorithm string.\n+#\n+# Additional TLS-specific syntax supported:\n+#\n+#   - TLS cipher suites can be disabled with this property using one or more\n+#     \"*\" wildcard characters. For example, \"TLS_RSA_*\" disables all cipher\n+#     suites that start with \"TLS_RSA_\". Only cipher suites starting with\n+#     \"TLS_\" are allowed to have wildcard characters.\n+#\n+#   - TLS protocol specific usage constraints are supported by this property:\n+#\n+#     UsageConstraint:\n+#       usage [HANDSHAKE] [CERTIFICATE]\n+#\n+#     HANDSHAKE restricts algorithm to be used for signing TLS handshake.\n+#     CERTIFICATE restricts algorithm to be used for signatures in certificates.\n+#     These constraints can't be mixed with any other usage constraints for the\n+#     same algorithm, they also can't be linked with other constraints by an\n+#     ampersand '&'.\n+#     See https:\/\/datatracker.ietf.org\/doc\/html\/rfc8446#section-4.2.3 for more\n+#     information on signatures used in TLS handshake and in certificates.\n@@ -746,1 +762,1 @@\n-#       rsa_pkcs1_sha1, secp224r1, TLS_RSA_*\n+#       secp224r1, TLS_RSA_*, rsa_pkcs1_sha1 usage handshake\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,307 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLException;\n+\n+\/**\n+ * This is not a test. Actual tests are implemented by concrete subclasses.\n+ * The abstract class AbstractCheckSignatureSchemes provides a base framework\n+ * for checking TLS signature schemes.\n+ *\/\n+\n+public abstract class AbstractCheckSignatureSchemes extends SSLEngineTemplate {\n+\n+    \/\/ Helper map to correlate integral SignatureScheme identifiers to\n+    \/\/ their IANA string name counterparts.\n+    protected static final Map<Integer, String> sigSchemeMap = Map.ofEntries(\n+            new SimpleImmutableEntry(0x0401, \"rsa_pkcs1_sha256\"),\n+            new SimpleImmutableEntry(0x0501, \"rsa_pkcs1_sha384\"),\n+            new SimpleImmutableEntry(0x0601, \"rsa_pkcs1_sha512\"),\n+            new SimpleImmutableEntry(0x0403, \"ecdsa_secp256r1_sha256\"),\n+            new SimpleImmutableEntry(0x0503, \"ecdsa_secp384r1_sha384\"),\n+            new SimpleImmutableEntry(0x0603, \"ecdsa_secp521r1_sha512\"),\n+            new SimpleImmutableEntry(0x0804, \"rsa_pss_rsae_sha256\"),\n+            new SimpleImmutableEntry(0x0805, \"rsa_pss_rsae_sha384\"),\n+            new SimpleImmutableEntry(0x0806, \"rsa_pss_rsae_sha512\"),\n+            new SimpleImmutableEntry(0x0807, \"ed25519\"),\n+            new SimpleImmutableEntry(0x0808, \"ed448\"),\n+            new SimpleImmutableEntry(0x0809, \"rsa_pss_pss_sha256\"),\n+            new SimpleImmutableEntry(0x080a, \"rsa_pss_pss_sha384\"),\n+            new SimpleImmutableEntry(0x080b, \"rsa_pss_pss_sha512\"),\n+            new SimpleImmutableEntry(0x0101, \"rsa_md5\"),\n+            new SimpleImmutableEntry(0x0201, \"rsa_pkcs1_sha1\"),\n+            new SimpleImmutableEntry(0x0202, \"dsa_sha1\"),\n+            new SimpleImmutableEntry(0x0203, \"ecdsa_sha1\"),\n+            new SimpleImmutableEntry(0x0301, \"rsa_sha224\"),\n+            new SimpleImmutableEntry(0x0302, \"dsa_sha224\"),\n+            new SimpleImmutableEntry(0x0303, \"ecdsa_sha224\"),\n+            new SimpleImmutableEntry(0x0402, \"rsa_pkcs1_sha256\"));\n+\n+    \/\/ Other useful TLS definitions for these tests\n+    protected static final int TLS_HS_CLI_HELLO = 1;\n+    protected static final int TLS_HS_CERT_REQ = 13;\n+    protected static final int SIG_ALGS_EXT = 13;\n+    protected static final int SIG_ALGS_CERT_EXT = 50;\n+\n+    protected AbstractCheckSignatureSchemes() throws Exception {\n+        super();\n+    }\n+\n+    protected String getProtocol() {\n+        return \"TLSv1.2\";\n+    }\n+\n+    protected boolean isDtls() {\n+        return getProtocol().startsWith(\"DTLS\");\n+    }\n+\n+    @Override\n+    protected SSLEngine configureClientEngine(SSLEngine clientEngine) {\n+        clientEngine.setUseClientMode(true);\n+        clientEngine.setEnabledProtocols(new String[]{getProtocol()});\n+        return clientEngine;\n+    }\n+\n+    @Override\n+    protected SSLEngine configureServerEngine(SSLEngine serverEngine) {\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.setWantClientAuth(true);\n+        serverEngine.setEnabledProtocols(new String[]{getProtocol()});\n+        return serverEngine;\n+    }\n+\n+    @Override\n+    protected ContextParameters getServerContextParameters() {\n+        return new ContextParameters(getProtocol(), \"PKIX\", \"NewSunX509\");\n+    }\n+\n+    @Override\n+    protected ContextParameters getClientContextParameters() {\n+        return new ContextParameters(getProtocol(), \"PKIX\", \"NewSunX509\");\n+    }\n+\n+    \/**\n+     * Given a TLS record containing one or more handshake messages, return\n+     * the specific handshake message as a ByteBuffer (a slice of the record)\n+     *\n+     * @param tlsRecord A ByteBuffer containing a TLS record.  It is\n+     *                  assumed that the position of the ByteBuffer is on the\n+     *                  first byte of the TLS record header.\n+     * @param hsMsgId   The message identifier for the handshake message\n+     *                  being sought.\n+     * @return          a ByteBuffer containing the TLS handshake message.\n+     *                  The position of the returned ByteBuffer will be on the\n+     *                  first byte of the TLS handshake message data,\n+     *                  immediately following the handshake header.\n+     *                  If the message is not found, null will be returned.\n+     * @throws SSLException if the incoming ByteBuffer does not contain\n+     *                      a well-formed TLS message.\n+     *\/\n+    protected ByteBuffer extractHandshakeMsg(ByteBuffer tlsRecord,\n+            int hsMsgId) throws SSLException {\n+        Objects.requireNonNull(tlsRecord);\n+        tlsRecord.mark();\n+\n+        \/\/ Process the TLS record header\n+        int type = Byte.toUnsignedInt(tlsRecord.get());\n+        int ver_major = Byte.toUnsignedInt(tlsRecord.get());\n+        int ver_minor = Byte.toUnsignedInt(tlsRecord.get());\n+        \/\/ Skip DTLS-specific bytes\n+        if (isDtls()) {\n+            tlsRecord.position(tlsRecord.position() + 8);\n+        }\n+        int recLen = Short.toUnsignedInt(tlsRecord.getShort());\n+\n+        if (recLen > tlsRecord.remaining()) {\n+            throw new SSLException(\"Incomplete record in buffer: \" +\n+                    \"Record length = \" + recLen + \", Remaining = \" +\n+                    tlsRecord.remaining());\n+        }\n+\n+        while (tlsRecord.hasRemaining()) {\n+            \/\/ Grab the handshake message header.\n+            int msgHdr = tlsRecord.getInt();\n+            int msgType = (msgHdr >> 24) & 0x000000FF;\n+            int msgLen = msgHdr & 0x00FFFFFF;\n+            \/\/ Skip DTLS-specific bytes\n+            if (isDtls()) {\n+                tlsRecord.position(tlsRecord.position() + 8);\n+            }\n+\n+            if (msgType == hsMsgId) {\n+                \/\/ Slice the buffer such that it contains the entire\n+                \/\/ handshake message (less the handshake header).\n+                ByteBuffer buf = tlsRecord.slice(tlsRecord.position(), msgLen);\n+                tlsRecord.reset();\n+                return buf;\n+            } else {\n+                \/\/ Skip to the next handshake message, if there is one\n+                tlsRecord.position(tlsRecord.position() + msgLen);\n+            }\n+        }\n+\n+        tlsRecord.reset();\n+        return null;\n+    }\n+\n+\n+    \/**\n+     * Parses the ClientHello message and extracts from it a list of\n+     * SignatureScheme values in string form.  It is assumed that the provided\n+     * ByteBuffer has its position set at the first byte of the ClientHello\n+     * message body (AFTER the handshake header) and contains the entire\n+     * hello message.  Upon successful completion of this method the ByteBuffer\n+     * will have its position reset to the initial offset in the buffer.\n+     * If an exception is thrown the position at the time of the exception\n+     * will be preserved.\n+     *\n+     * @param data    The ByteBuffer containing the ClientHello bytes.\n+     * @param extCode Code of the TLS extension from which to extract\n+     *                signature schemes.\n+     * @return        A List of the signature schemes in string form.\n+     *\/\n+    protected List<String> getSigSchemesCliHello(\n+            ByteBuffer data, int extCode) {\n+        Objects.requireNonNull(data);\n+        data.mark();\n+\n+        \/\/ Skip over the protocol version and client random\n+        data.position(data.position() + 34);\n+\n+        \/\/ Jump past the session ID (if there is one)\n+        int sessLen = Byte.toUnsignedInt(data.get());\n+        if (sessLen != 0) {\n+            data.position(data.position() + sessLen);\n+        }\n+\n+        \/\/ Skip DTLS-specific opaque cookie if any\n+        if (isDtls()) {\n+            int cookieLen = Byte.toUnsignedInt(data.get());\n+            if (cookieLen != 0) {\n+                data.position(data.position() + cookieLen);\n+            }\n+        }\n+\n+        \/\/ Jump past the cipher suites\n+        int csLen = Short.toUnsignedInt(data.getShort());\n+        if (csLen != 0) {\n+            data.position(data.position() + csLen);\n+        }\n+\n+        \/\/ ...and the compression\n+        int compLen = Byte.toUnsignedInt(data.get());\n+        if (compLen != 0) {\n+            data.position(data.position() + compLen);\n+        }\n+\n+        \/\/ Now for the fun part.  Go through the extensions and look\n+        \/\/ for the two status request exts.\n+        List<String> extSigAlgs = getSigSchemesFromExt(data, extCode);\n+\n+        \/\/ We should be at the end of the ClientHello\n+        data.reset();\n+        return extSigAlgs;\n+    }\n+\n+    \/**\n+     * Parses the CertificateRequest message and extracts from it a list of\n+     * SignatureScheme values in string form.  It is assumed that the provided\n+     * ByteBuffer has its position set at the first byte of the\n+     * CertificateRequest message body (AFTER the handshake header) and\n+     * contains the entire CR message.  Upon successful completion of this\n+     * method the ByteBuffer will have its position reset to the initial\n+     * offset in the buffer.\n+     * If an exception is thrown the position at the time of the exception\n+     * will be preserved.\n+     *\n+     * @param data The ByteBuffer containing the CertificateRequest bytes\n+     *\n+     * @return A List of the signature schemes in string form.  If no\n+     * signature_algorithms extension is present in the CertificateRequest\n+     * then an empty list will be returned.\n+     *\/\n+    protected List<String> getSigSchemesCertReq(ByteBuffer data) {\n+        Objects.requireNonNull(data);\n+        data.mark();\n+\n+        \/\/ Jump past the certificate types\n+        int certTypeLen = Byte.toUnsignedInt(data.get());\n+        if (certTypeLen != 0) {\n+            data.position(data.position() + certTypeLen);\n+        }\n+\n+        \/\/ Collect the SignatureAndHashAlgorithms\n+        List<String> extSigAlgs = new ArrayList();\n+        int sigSchemeLen = Short.toUnsignedInt(data.getShort());\n+        for (int ssOff = 0; ssOff < sigSchemeLen; ssOff += 2) {\n+            String schemeName = sigSchemeMap.get(\n+                    Short.toUnsignedInt(data.getShort()));\n+            if (schemeName != null) {\n+                extSigAlgs.add(schemeName);\n+            }\n+        }\n+\n+        data.reset();\n+        return extSigAlgs;\n+    }\n+\n+    \/**\n+     * Gets signatures schemes from the given TLS extension.\n+     * The buffer should be positioned at the start of the extension.\n+     *\/\n+    protected List<String> getSigSchemesFromExt(\n+            ByteBuffer data, int extCode) {\n+\n+        List<String> extSigAlgs = new ArrayList<>();\n+        data.getShort(); \/\/ read length\n+\n+        while (data.hasRemaining()) {\n+            int extType = Short.toUnsignedInt(data.getShort());\n+            int extLen = Short.toUnsignedInt(data.getShort());\n+            if (extType == extCode) {\n+                \/\/ Start processing signature algorithms\n+                int sigSchemeLen = Short.toUnsignedInt(data.getShort());\n+                for (int ssOff = 0; ssOff < sigSchemeLen; ssOff += 2) {\n+                    String schemeName = sigSchemeMap.get(\n+                            Short.toUnsignedInt(data.getShort()));\n+                    if (schemeName != null) {\n+                        extSigAlgs.add(schemeName);\n+                    }\n+                }\n+            } else {\n+                \/\/ Not the extension we're looking for.  Skip past the\n+                \/\/ extension data\n+                data.position(data.position() + extLen);\n+            }\n+        }\n+\n+        return extSigAlgs;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/AbstractCheckSignatureSchemes.java","additions":307,"deletions":0,"binary":false,"changes":307,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349583\n+ * @summary Add mechanism to disable signature schemes based on their TLS scope.\n+ *          This test only covers DTLS 1.2.\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm DisableSignatureSchemePerScopeDTLS12\n+ *\/\n+\n+import java.security.Security;\n+\n+public class DisableSignatureSchemePerScopeDTLS12\n+        extends DisableSignatureSchemePerScopeTLS12 {\n+\n+    protected DisableSignatureSchemePerScopeDTLS12() throws Exception {\n+        super();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\n+                \"jdk.tls.disabledAlgorithms\", DISABLED_CONSTRAINTS);\n+        new DisableSignatureSchemePerScopeDTLS12().run();\n+    }\n+\n+    @Override\n+    protected String getProtocol() {\n+        return \"DTLSv1.2\";\n+    }\n+\n+    \/\/ No CertificateRequest in DTLS server flight.\n+    @Override\n+    protected void checkCertificateRequest() {\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableSignatureSchemePerScopeDTLS12.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349583\n+ * @summary Add mechanism to disable signature schemes based on their TLS scope.\n+ *          This test only covers TLS 1.2.\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm DisableSignatureSchemePerScopeTLS12\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertFalse;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.security.Security;\n+import java.util.List;\n+\n+public class DisableSignatureSchemePerScopeTLS12 extends\n+        AbstractCheckSignatureSchemes {\n+\n+    \/\/ Disabled for Handshake scope.\n+    protected static final String HANDSHAKE_DISABLED_SIG = \"rsa_pkcs1_sha1\";\n+\n+    \/\/ Disabled for Certificate scope.\n+    protected static final String CERTIFICATE_DISABLED_SIG = \"rsa_pkcs1_sha384\";\n+\n+    \/\/ jdk.tls.disabledAlgorithms value\n+    protected static final String DISABLED_CONSTRAINTS =\n+            HANDSHAKE_DISABLED_SIG + \" usage handshake, \"\n+            + CERTIFICATE_DISABLED_SIG + \" usage certificate\";\n+\n+    protected DisableSignatureSchemePerScopeTLS12() throws Exception {\n+        super();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\n+                \"jdk.tls.disabledAlgorithms\", DISABLED_CONSTRAINTS);\n+        new DisableSignatureSchemePerScopeTLS12().run();\n+    }\n+\n+    \/\/ Run things in TLS handshake order.\n+    protected void run() throws Exception {\n+\n+        \/\/ Produce client_hello\n+        clientEngine.wrap(clientOut, cTOs);\n+        cTOs.flip();\n+\n+        checkClientHello();\n+\n+        \/\/ Consume client_hello.\n+        serverEngine.unwrap(cTOs, serverIn);\n+        runDelegatedTasks(serverEngine);\n+\n+        \/\/ Produce server_hello.\n+        serverEngine.wrap(serverOut, sTOc);\n+        sTOc.flip();\n+\n+        checkCertificateRequest();\n+    }\n+\n+    protected void checkClientHello() throws Exception {\n+        \/\/ --- Check signature_algorithms extension ---\n+\n+        \/\/ Get signature_algorithms extension signature schemes.\n+        List<String> sigAlgsSS = getSigSchemesCliHello(\n+                extractHandshakeMsg(cTOs, TLS_HS_CLI_HELLO),\n+                SIG_ALGS_EXT);\n+\n+        \/\/ signature_algorithms extension MUST NOT contain disabled\n+        \/\/ handshake signature scheme.\n+        assertFalse(sigAlgsSS.contains(HANDSHAKE_DISABLED_SIG),\n+                \"Signature Scheme \" + HANDSHAKE_DISABLED_SIG\n+                + \" present in ClientHello's signature_algorithms extension\");\n+\n+        \/\/ signature_algorithms extension MUST contain disabled\n+        \/\/ certificate signature scheme.\n+        assertTrue(sigAlgsSS.contains(CERTIFICATE_DISABLED_SIG),\n+                \"Signature Scheme \" + CERTIFICATE_DISABLED_SIG\n+                + \" isn't present in ClientHello's\"\n+                + \" signature_algorithms extension\");\n+\n+        \/\/ --- Check signature_algorithms_cert extension ---\n+\n+        \/\/ Get signature_algorithms_cert extension signature schemes.\n+        List<String> sigAlgsCertSS = getSigSchemesCliHello(\n+                extractHandshakeMsg(cTOs, TLS_HS_CLI_HELLO),\n+                SIG_ALGS_CERT_EXT);\n+\n+        \/\/ signature_algorithms_cert extension MUST contain disabled\n+        \/\/ handshake signature scheme.\n+        assertTrue(sigAlgsCertSS.contains(HANDSHAKE_DISABLED_SIG),\n+                \"Signature Scheme \" + HANDSHAKE_DISABLED_SIG\n+                + \" isn't present in ClientHello's\"\n+                + \" signature_algorithms extension\");\n+\n+        \/\/ signature_algorithms_cert extension MUST NOT contain disabled\n+        \/\/ certificate signature scheme.\n+        assertFalse(sigAlgsCertSS.contains(CERTIFICATE_DISABLED_SIG),\n+                \"Signature Scheme \" + CERTIFICATE_DISABLED_SIG\n+                + \" present in ClientHello's signature_algorithms extension\");\n+    }\n+\n+    protected void checkCertificateRequest() throws Exception {\n+        \/\/ Get CertificateRequest message signature schemes.\n+        List<String> sigAlgsCertSS = getSigSchemesCertReq(\n+                extractHandshakeMsg(sTOc, TLS_HS_CERT_REQ));\n+\n+        \/\/ TLSv1.2 CertificateRequest message MUST NOT contain both:\n+        \/\/ disabled handshake signature scheme and disabled\n+        \/\/ certificate signature scheme\n+\n+        assertFalse(sigAlgsCertSS.contains(HANDSHAKE_DISABLED_SIG),\n+                \"Signature Scheme \" + HANDSHAKE_DISABLED_SIG\n+                + \" present in CertificateRequest\");\n+\n+        assertFalse(sigAlgsCertSS.contains(CERTIFICATE_DISABLED_SIG),\n+                \"Signature Scheme \" + CERTIFICATE_DISABLED_SIG\n+                + \" present in CertificateRequest\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableSignatureSchemePerScopeTLS12.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349583\n+ * @summary Add mechanism to disable signature schemes based on their TLS scope.\n+ *          This test only covers TLS 1.3.\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm DisableSignatureSchemePerScopeTLS13\n+ *\/\n+\n+\n+import java.security.Security;\n+\n+public class DisableSignatureSchemePerScopeTLS13\n+        extends DisableSignatureSchemePerScopeTLS12 {\n+\n+    protected DisableSignatureSchemePerScopeTLS13() throws Exception {\n+        super();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\n+                \"jdk.tls.disabledAlgorithms\", DISABLED_CONSTRAINTS);\n+        new DisableSignatureSchemePerScopeTLS13().run();\n+    }\n+\n+    @Override\n+    protected String getProtocol() {\n+        return \"TLSv1.3\";\n+    }\n+\n+    \/\/ TLSv1.3 sends CertificateRequest signature schemes in\n+    \/\/ signature_algorithms and signature_algorithms_cert extensions. Same as\n+    \/\/ ClientHello, but they are encrypted. So we skip CertificateRequest\n+    \/\/ signature schemes verification for TLSv1.3.\n+    @Override\n+    protected void checkCertificateRequest() {\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableSignatureSchemePerScopeTLS13.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349583\n+ * @summary Add mechanism to disable signature schemes based on their TLS scope\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm MixingTLSUsageConstraintsWithNonTLS\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Utils.runAndCheckException;\n+\n+import java.security.Security;\n+\n+public class MixingTLSUsageConstraintsWithNonTLS extends SSLSocketTemplate {\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\",\n+                \"rsa_pkcs1_sha1 usage handshake certificate TLSServer\");\n+\n+        runAndCheckException(\n+                () -> new MixingTLSUsageConstraintsWithNonTLS().run(),\n+                e -> {\n+                    assertTrue(e instanceof ExceptionInInitializerError);\n+                    assertTrue(\n+                            e.getCause() instanceof IllegalArgumentException);\n+                    assertEquals(e.getCause().getMessage(),\n+                            \"Can't mix TLS protocol specific constraints\"\n+                                    + \" with other usage constraints\");\n+                });\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/MixingTLSUsageConstraintsWithNonTLS.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,5 +37,2 @@\n-import java.nio.ByteBuffer;\n-import java.util.*;\n-import java.util.AbstractMap.SimpleImmutableEntry;\n-import javax.net.ssl.SSLEngine;\n-import javax.net.ssl.SSLException;\n+import java.util.Arrays;\n+import java.util.List;\n@@ -43,32 +40,1 @@\n-public class SigSchemePropOrdering extends SSLEngineTemplate {\n-\n-    \/\/ Helper map to correlate integral SignatureScheme identifiers to\n-    \/\/ their IANA string name counterparts.\n-    static final Map<Integer, String> sigSchemeMap = Map.ofEntries(\n-            new SimpleImmutableEntry(0x0401, \"rsa_pkcs1_sha256\"),\n-            new SimpleImmutableEntry(0x0501, \"rsa_pkcs1_sha384\"),\n-            new SimpleImmutableEntry(0x0601, \"rsa_pkcs1_sha512\"),\n-            new SimpleImmutableEntry(0x0403, \"ecdsa_secp256r1_sha256\"),\n-            new SimpleImmutableEntry(0x0503, \"ecdsa_secp384r1_sha384\"),\n-            new SimpleImmutableEntry(0x0603, \"ecdsa_secp521r1_sha512\"),\n-            new SimpleImmutableEntry(0x0804, \"rsa_pss_rsae_sha256\"),\n-            new SimpleImmutableEntry(0x0805, \"rsa_pss_rsae_sha384\"),\n-            new SimpleImmutableEntry(0x0806, \"rsa_pss_rsae_sha512\"),\n-            new SimpleImmutableEntry(0x0807, \"ed25519\"),\n-            new SimpleImmutableEntry(0x0808, \"ed448\"),\n-            new SimpleImmutableEntry(0x0809, \"rsa_pss_pss_sha256\"),\n-            new SimpleImmutableEntry(0x080a, \"rsa_pss_pss_sha384\"),\n-            new SimpleImmutableEntry(0x080b, \"rsa_pss_pss_sha512\"),\n-            new SimpleImmutableEntry(0x0101, \"rsa_md5\"),\n-            new SimpleImmutableEntry(0x0201, \"rsa_pkcs1_sha1\"),\n-            new SimpleImmutableEntry(0x0202, \"dsa_sha1\"),\n-            new SimpleImmutableEntry(0x0203, \"ecdsa_sha1\"),\n-            new SimpleImmutableEntry(0x0301, \"rsa_sha224\"),\n-            new SimpleImmutableEntry(0x0302, \"dsa_sha224\"),\n-            new SimpleImmutableEntry(0x0303, \"ecdsa_sha224\"),\n-            new SimpleImmutableEntry(0x0402, \"rsa_pkcs1_sha256\"));\n-\n-    \/\/ Other useful TLS definitions for these tests\n-    private static final int TLS_HS_CLI_HELLO = 1;\n-    private static final int TLS_HS_CERT_REQ = 13;\n-    private static final int HELLO_EXT_SIG_ALGS = 13;\n+public class SigSchemePropOrdering extends AbstractCheckSignatureSchemes {\n@@ -78,1 +44,1 @@\n-            \"ed448,ed25519,ecdsa_secp256r1_sha256\";\n+                    \"ed448,ed25519,ecdsa_secp256r1_sha256\";\n@@ -91,14 +57,0 @@\n-    @Override\n-    protected SSLEngine configureClientEngine(SSLEngine clientEngine) {\n-        clientEngine.setUseClientMode(true);\n-        clientEngine.setEnabledProtocols(new String[] { \"TLSv1.2\" });\n-        return clientEngine;\n-    }\n-\n-    @Override\n-    protected SSLEngine configureServerEngine(SSLEngine serverEngine) {\n-        serverEngine.setUseClientMode(false);\n-        serverEngine.setWantClientAuth(true);\n-        return serverEngine;\n-    }\n-\n@@ -115,1 +67,2 @@\n-                extractHandshakeMsg(cTOs, TLS_HS_CLI_HELLO));\n+                extractHandshakeMsg(cTOs, TLS_HS_CLI_HELLO),\n+                SIG_ALGS_EXT);\n@@ -158,173 +111,0 @@\n-\n-    \/**\n-     * Given a TLS record containing one or more handshake messages, return\n-     * the specific handshake message as a ByteBuffer (a slice of the record)\n-     *\n-     * @param tlsRecord a ByteBuffer containing a TLS record.  It is assumed\n-     *      that the position of the ByteBuffer is on the first byte of the TLS\n-     *      record header.\n-     * @param hsMsgId the message identifier for the handshake message being\n-     *      sought.\n-     *\n-     * @return a ByteBuffer containing the TLS handshake message.  The position\n-     *      of the returned ByteBuffer will be on the first byte of the TLS\n-     *      handshake message data, immediately following the handshake header.\n-     *      If the message is not found, null will be returned.\n-     *\n-     * @throws SSLException if the incoming ByteBuffer does not contain a\n-     *      well-formed TLS message.\n-     *\/\n-    private static ByteBuffer extractHandshakeMsg(ByteBuffer tlsRecord,\n-            int hsMsgId) throws SSLException {\n-        Objects.requireNonNull(tlsRecord);\n-        tlsRecord.mark();\n-\n-        \/\/ Process the TLS record header\n-        int type = Byte.toUnsignedInt(tlsRecord.get());\n-        int ver_major = Byte.toUnsignedInt(tlsRecord.get());\n-        int ver_minor = Byte.toUnsignedInt(tlsRecord.get());\n-        int recLen = Short.toUnsignedInt(tlsRecord.getShort());\n-\n-        \/\/ Simple sanity checks\n-        if (type != 22) {\n-            throw new SSLException(\"Not a handshake: Type = \" + type);\n-        } else if (recLen > tlsRecord.remaining()) {\n-            throw new SSLException(\"Incomplete record in buffer: \" +\n-                    \"Record length = \" + recLen + \", Remaining = \" +\n-                    tlsRecord.remaining());\n-        }\n-\n-        while (tlsRecord.hasRemaining()) {\n-            \/\/ Grab the handshake message header.\n-            int msgHdr = tlsRecord.getInt();\n-            int msgType = (msgHdr >> 24) & 0x000000FF;\n-            int msgLen = msgHdr & 0x00FFFFFF;\n-\n-            if (msgType == hsMsgId) {\n-                \/\/ Slice the buffer such that it contains the entire\n-                \/\/ handshake message (less the handshake header).\n-                ByteBuffer buf = tlsRecord.slice(tlsRecord.position(), msgLen);\n-                tlsRecord.reset();\n-                return buf;\n-            } else {\n-                \/\/ Skip to the next handshake message, if there is one\n-                tlsRecord.position(tlsRecord.position() + msgLen);\n-            }\n-        }\n-\n-        tlsRecord.reset();\n-        return null;\n-    }\n-\n-\n-    \/**\n-     * Parses the ClientHello message and extracts from it a list of\n-     * SignatureScheme values in string form.  It is assumed that the provided\n-     * ByteBuffer has its position set at the first byte of the ClientHello\n-     * message body (AFTER the handshake header) and contains the entire\n-     * hello message.  Upon successful completion of this method the ByteBuffer\n-     * will have its position reset to the initial offset in the buffer.\n-     * If an exception is thrown the position at the time of the exception\n-     * will be preserved.\n-     *\n-     * @param data the ByteBuffer containing the ClientHello bytes\n-     *\n-     * @return A List of the signature schemes in string form.  If no\n-     * signature_algorithms extension is present in the client hello then\n-     * an empty list will be returned.\n-     *\/\n-    private static List<String> getSigSchemesCliHello(ByteBuffer data) {\n-        Objects.requireNonNull(data);\n-        data.mark();\n-\n-        \/\/ Skip over the protocol version and client random\n-        data.position(data.position() + 34);\n-\n-        \/\/ Jump past the session ID (if there is one)\n-        int sessLen = Byte.toUnsignedInt(data.get());\n-        if (sessLen != 0) {\n-            data.position(data.position() + sessLen);\n-        }\n-\n-        \/\/ Jump past the cipher suites\n-        int csLen = Short.toUnsignedInt(data.getShort());\n-        if (csLen != 0) {\n-            data.position(data.position() + csLen);\n-        }\n-\n-        \/\/ ...and the compression\n-        int compLen = Byte.toUnsignedInt(data.get());\n-        if (compLen != 0) {\n-            data.position(data.position() + compLen);\n-        }\n-\n-        \/\/ Now for the fun part.  Go through the extensions and look\n-        \/\/ for the two status request exts.\n-        List<String> extSigAlgs = new ArrayList();\n-        int extsLen = Short.toUnsignedInt(data.getShort());\n-        while (data.hasRemaining()) {\n-            int extType = Short.toUnsignedInt(data.getShort());\n-            int extLen = Short.toUnsignedInt(data.getShort());\n-            if (extType == HELLO_EXT_SIG_ALGS) {\n-                \/\/ Start processing signature algorithms\n-                int sigSchemeLen = Short.toUnsignedInt(data.getShort());\n-                for (int ssOff = 0; ssOff < sigSchemeLen; ssOff += 2) {\n-                    String schemeName = sigSchemeMap.get(\n-                            Short.toUnsignedInt(data.getShort()));\n-                    if (schemeName != null) {\n-                        extSigAlgs.add(schemeName);\n-                    }\n-                }\n-            } else {\n-                \/\/ Not the extension we're looking for.  Skip past the\n-                \/\/ extension data\n-                data.position(data.position() + extLen);\n-            }\n-        }\n-\n-        \/\/ We should be at the end of the ClientHello\n-        data.reset();\n-        return extSigAlgs;\n-    }\n-\n-    \/**\n-     * Parses the CertificateRequest message and extracts from it a list of\n-     * SignatureScheme values in string form.  It is assumed that the provided\n-     * ByteBuffer has its position set at the first byte of the\n-     * CertificateRequest message body (AFTER the handshake header) and\n-     * contains the entire CR message.  Upon successful completion of this\n-     * method the ByteBuffer will have its position reset to the initial\n-     * offset in the buffer.\n-     * If an exception is thrown the position at the time of the exception\n-     * will be preserved.\n-     *\n-     * @param data the ByteBuffer containing the CertificateRequest bytes\n-     *\n-     * @return A List of the signature schemes in string form.  If no\n-     * signature_algorithms extension is present in the CertificateRequest\n-     * then an empty list will be returned.\n-     *\/\n-    private static List<String> getSigSchemesCertReq(ByteBuffer data) {\n-        Objects.requireNonNull(data);\n-        data.mark();\n-\n-        \/\/ Jump past the certificate types\n-        int certTypeLen = Byte.toUnsignedInt(data.get());\n-        if (certTypeLen != 0) {\n-            data.position(data.position() + certTypeLen);\n-        }\n-\n-        \/\/ Collect the SignatureAndHashAlgorithms\n-        List<String> extSigAlgs = new ArrayList();\n-        int sigSchemeLen = Short.toUnsignedInt(data.getShort());\n-        for (int ssOff = 0; ssOff < sigSchemeLen; ssOff += 2) {\n-            String schemeName = sigSchemeMap.get(\n-                    Short.toUnsignedInt(data.getShort()));\n-            if (schemeName != null) {\n-                extSigAlgs.add(schemeName);\n-            }\n-        }\n-\n-        data.reset();\n-        return extSigAlgs;\n-    }\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/SigSchemePropOrdering.java","additions":7,"deletions":227,"binary":false,"changes":234,"status":"modified"}]}