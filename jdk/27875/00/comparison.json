{"files":[{"patch":"@@ -29,2 +29,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE_FILE;\n-import static jdk.jpackage.internal.StandardBundlerParam.SIGN_BUNDLE;\n@@ -32,3 +30,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.text.MessageFormat;\n@@ -36,1 +31,0 @@\n-import java.util.Optional;\n@@ -47,20 +41,1 @@\n-        if (PREDEFINED_APP_IMAGE.fetchFrom(params) != null) {\n-            Path applicationImage = PREDEFINED_APP_IMAGE.fetchFrom(params);\n-            if (new MacAppImageFileExtras(PREDEFINED_APP_IMAGE_FILE.fetchFrom(params)).signed()) {\n-                var appLayout = ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT.resolveAt(applicationImage);\n-                if (!Files.exists(\n-                        PackageFile.getPathInAppImage(appLayout))) {\n-                    Log.info(MessageFormat.format(I18N.getString(\n-                            \"warning.per.user.app.image.signed\"),\n-                            PackageFile.getPathInAppImage(appLayout)));\n-                }\n-            } else {\n-                if (Optional.ofNullable(\n-                        SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.FALSE)) {\n-                    \/\/ if signing bundle with app-image, warn user if app-image\n-                    \/\/ is not already signed.\n-                    Log.info(MessageFormat.format(I18N.getString(\n-                            \"warning.unsigned.app.image\"), getID()));\n-                }\n-            }\n-        } else {\n+        if (PREDEFINED_APP_IMAGE.fetchFrom(params) == null) {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBaseInstallerBundler.java","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import static jdk.jpackage.internal.MacPackagingPipeline.APPLICATION_LAYOUT;\n@@ -29,0 +30,1 @@\n+import java.nio.file.Files;\n@@ -60,1 +62,15 @@\n-        return MacPackage.create(pkg, new MacPackageMixin.Stub(pkg.predefinedAppImage().map(v -> predefinedAppImageSigned)));\n+\n+        var macPkg = MacPackage.create(pkg, new MacPackageMixin.Stub(pkg.predefinedAppImage().map(v -> predefinedAppImageSigned)));\n+        validatePredefinedAppImage(macPkg);\n+        return macPkg;\n+    }\n+\n+    private static void validatePredefinedAppImage(MacPackage pkg) {\n+        if (pkg.predefinedAppImageSigned().orElse(false)) {\n+            pkg.predefinedAppImage().ifPresent(predefinedAppImage -> {\n+                var thePackageFile = PackageFile.getPathInAppImage(APPLICATION_LAYOUT);\n+                if (!Files.exists(predefinedAppImage.resolve(thePackageFile))) {\n+                    Log.info(I18N.format(\"warning.per.user.app.image.signed\", thePackageFile));\n+                }\n+            });\n+        }\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackageBuilder.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -46,1 +46,3 @@\n-        return MacPkgPackage.create(pkgBuilder.create(), new MacPkgPackageMixin.Stub(createSigningConfig()));\n+        var pkg = MacPkgPackage.create(pkgBuilder.create(), new MacPkgPackageMixin.Stub(createSigningConfig()));\n+        validatePredefinedAppImage(pkg);\n+        return pkg;\n@@ -59,0 +61,8 @@\n+    private static void validatePredefinedAppImage(MacPkgPackage pkg) {\n+        if (!pkg.predefinedAppImageSigned().orElse(false) && pkg.sign()) {\n+            pkg.predefinedAppImage().ifPresent(predefinedAppImage -> {\n+                Log.info(I18N.format(\"warning.unsigned.app.image\", \"pkg\"));\n+            });\n+        }\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgPackageBuilder.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1133,0 +1133,5 @@\n+        MAC_BUNDLE_UNSIGNED_SIGNATURE(cmd -> {\n+            if (TKit.isOSX() && !MacHelper.appImageSigned(cmd)) {\n+                MacHelper.verifyUnsignedBundleSignature(cmd);\n+            }\n+        }),\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import java.util.function.BiConsumer;\n@@ -69,0 +70,1 @@\n+import jdk.jpackage.test.MacSign.CertificateRequest;\n@@ -232,0 +234,10 @@\n+    \/**\n+     * Returns {@code true} if the given jpackage command line is configured to sign\n+     * predefined app image in place.\n+     * <p>\n+     * jpackage will not create a new app image or a native bundle.\n+     *\n+     * @param cmd the jpackage command to examine\n+     * @return {@code true} if the given jpackage command line is configured to sign\n+     *         predefined app image in place and {@code false} otherwise.\n+     *\/\n@@ -237,1 +249,1 @@\n-        return cmd.hasArgument(\"--mac-sign\") && cmd.hasArgument(\"--app-image\");\n+        return cmd.hasArgument(\"--mac-sign\") && cmd.hasArgument(\"--app-image\") && cmd.isImagePackageType();\n@@ -240,0 +252,12 @@\n+    \/**\n+     * Returns {@code true} if the given jpackage command line is configured such\n+     * that the app image it will produce will be signed.\n+     * <p>\n+     * If the jpackage command line is bundling a native package, the function\n+     * returns {@code true} if the bundled app image will be signed.\n+     *\n+     * @param cmd the jpackage command to examine\n+     * @return {@code true} if the given jpackage command line is configured such\n+     *         that the app image it will produce will be signed and {@code false}\n+     *         otherwise.\n+     *\/\n@@ -246,1 +270,7 @@\n-        if (Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of).map(AppImageFile::load).map(AppImageFile::macSigned).orElse(false)) {\n+        var runtimeImage = Optional.ofNullable(cmd.getArgumentValue(\"--runtime-image\")).map(Path::of);\n+        var appImage = Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of);\n+\n+        if (cmd.isRuntime() && Files.isDirectory(runtimeImage.orElseThrow().resolve(\"Contents\/_CodeSignature\"))) {\n+            \/\/ If the predefined runtime is a signed bundle, bundled image should be signed too.\n+            return true;\n+        } else if (appImage.map(AppImageFile::load).map(AppImageFile::macSigned).orElse(false)) {\n@@ -251,0 +281,8 @@\n+        if (!cmd.isImagePackageType() && appImage.isPresent()) {\n+            \/\/ Building a \".pkg\" or a \".dmg\" bundle from the predefined app image.\n+            \/\/ The predefined app image is unsigned, so the app image bundled\n+            \/\/ in the output native package will be unsigned too\n+            \/\/ (even if the \".pkg\" file may be signed itself, and we never sign \".dmg\" files).\n+            return false;\n+        }\n+\n@@ -335,0 +373,94 @@\n+    public static JPackageCommand useKeychain(JPackageCommand cmd, MacSign.ResolvedKeychain keychain) {\n+        return useKeychain(cmd, keychain.spec().keychain());\n+    }\n+\n+    public static JPackageCommand useKeychain(JPackageCommand cmd, MacSign.Keychain keychain) {\n+        return sign(cmd).addArguments(\"--mac-signing-keychain\", keychain.name());\n+    }\n+\n+    public static JPackageCommand sign(JPackageCommand cmd) {\n+        if (!cmd.hasArgument(\"--mac-sign\")) {\n+            cmd.addArgument(\"--mac-sign\");\n+        }\n+        return cmd;\n+    }\n+\n+    public record SignKeyOption(Type type, CertificateRequest certRequest) {\n+\n+        public SignKeyOption {\n+            Objects.requireNonNull(type);\n+            Objects.requireNonNull(certRequest);\n+        }\n+\n+        public enum Type {\n+            SIGN_KEY_USER_NAME,\n+            SIGN_KEY_IDENTITY,\n+            ;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            var sb = new StringBuffer();\n+            applyTo((optionName, _) -> {\n+                sb.append(String.format(\"{%s: %s}\", optionName, certRequest));\n+            });\n+            return sb.toString();\n+        }\n+\n+        public JPackageCommand addTo(JPackageCommand cmd) {\n+            applyTo(cmd::addArguments);\n+            return sign(cmd);\n+        }\n+\n+        public JPackageCommand setTo(JPackageCommand cmd) {\n+            applyTo(cmd::setArgumentValue);\n+            return sign(cmd);\n+        }\n+\n+        private void applyTo(BiConsumer<String, String> sink) {\n+            switch (certRequest.type()) {\n+                case INSTALLER -> {\n+                    switch (type) {\n+                        case SIGN_KEY_IDENTITY -> {\n+                            sink.accept(\"--mac-installer-sign-identity\", certRequest.name());\n+                            return;\n+                        }\n+                        case SIGN_KEY_USER_NAME -> {\n+                            sink.accept(\"--mac-signing-key-user-name\", certRequest.shortName());\n+                            return;\n+                        }\n+                    }\n+                }\n+                case CODE_SIGN -> {\n+                    switch (type) {\n+                        case SIGN_KEY_IDENTITY -> {\n+                            sink.accept(\"--mac-app-image-sign-identity\", certRequest.name());\n+                            return;\n+                        }\n+                        case SIGN_KEY_USER_NAME -> {\n+                            sink.accept(\"--mac-signing-key-user-name\", certRequest.shortName());\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            throw new AssertionError();\n+        }\n+    }\n+\n+    static void verifyUnsignedBundleSignature(JPackageCommand cmd) {\n+        if (!cmd.isImagePackageType()) {\n+            MacSignVerify.assertUnsigned(cmd.outputBundle());\n+        }\n+\n+        final Path bundleRoot;\n+        if (cmd.isImagePackageType()) {\n+            bundleRoot = cmd.outputBundle();\n+        } else {\n+            bundleRoot = cmd.pathToUnpackedPackageFile(cmd.appInstallationDirectory());\n+        }\n+\n+        MacSignVerify.assertAdhocSigned(bundleRoot);\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":134,"deletions":2,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import java.util.function.Consumer;\n@@ -354,0 +355,46 @@\n+        public static final class UsageBuilder {\n+\n+            UsageBuilder(Collection<Keychain> keychains) {\n+                this.keychains = List.copyOf(keychains);\n+            }\n+\n+            public void run(Runnable runnable) {\n+                Objects.requireNonNull(runnable);\n+\n+                final Optional<List<Path>> oldKeychains;\n+                if (addToSearchList) {\n+                    oldKeychains = Optional.ofNullable(activeKeychainFiles());\n+                    Keychain.addToSearchList(keychains);\n+                } else {\n+                    oldKeychains = Optional.empty();\n+                }\n+\n+                try {\n+                    \/\/ Ensure keychains to be used for signing are unlocked.\n+                    \/\/ When the codesign command operates on a locked keychain in a ssh session\n+                    \/\/ it emits cryptic \"errSecInternalComponent\" error without other details.\n+                    keychains.forEach(Keychain::unlock);\n+                    runnable.run();\n+                } finally {\n+                    oldKeychains.ifPresent(restoreKeychains -> {\n+                        security(\"list-keychains\", \"-d\", \"user\", \"-s\")\n+                                .addArguments(restoreKeychains.stream().map(Path::toString).toList())\n+                                .execute();\n+                    });\n+                }\n+            }\n+\n+            public UsageBuilder addToSearchList(boolean v) {\n+                addToSearchList = v;\n+                return this;\n+            }\n+\n+            public UsageBuilder addToSearchList() {\n+                return addToSearchList(true);\n+            }\n+\n+            private final Collection<Keychain> keychains;\n+            private boolean addToSearchList;\n+        }\n+\n+\n@@ -418,1 +465,1 @@\n-        public static void addToSearchList(Collection<Keychain> keychains) {\n+        static void addToSearchList(Collection<Keychain> keychains) {\n@@ -424,12 +471,0 @@\n-        public static void withAddedKeychains(Collection<Keychain> keychains, Runnable runnable) {\n-            final var curKeychains = activeKeychainFiles();\n-            addToSearchList(keychains);\n-            try {\n-                runnable.run();\n-            } finally {\n-                security(\"list-keychains\", \"-d\", \"user\", \"-s\")\n-                        .addArguments(curKeychains.stream().map(Path::toString).toList())\n-                        .execute();\n-            }\n-        }\n-\n@@ -1040,0 +1075,41 @@\n+    public static Keychain.UsageBuilder withKeychains(KeychainWithCertsSpec... keychains) {\n+        return withKeychains(Stream.of(keychains).map(KeychainWithCertsSpec::keychain).toArray(Keychain[]::new));\n+    }\n+\n+    public static Keychain.UsageBuilder withKeychains(Keychain... keychains) {\n+        return new Keychain.UsageBuilder(List.of(keychains));\n+    }\n+\n+    public static void withKeychains(Runnable runnable, Consumer<Keychain.UsageBuilder> mutator, Keychain... keychains) {\n+        Objects.requireNonNull(runnable);\n+        var builder = withKeychains(keychains);\n+        mutator.accept(builder);\n+        builder.run(runnable);\n+    }\n+\n+    public static void withKeychains(Runnable runnable, Keychain... keychains) {\n+        withKeychains(runnable, _ -> {}, keychains);\n+    }\n+\n+    public static void withKeychain(Consumer<Keychain> consumer, Consumer<Keychain.UsageBuilder> mutator, Keychain keychain) {\n+        Objects.requireNonNull(consumer);\n+        withKeychains(() -> {\n+            consumer.accept(keychain);\n+        }, mutator, keychain);\n+    }\n+\n+    public static void withKeychain(Consumer<Keychain> consumer, Keychain keychain) {\n+        withKeychain(consumer, _ -> {}, keychain);\n+    }\n+\n+    public static void withKeychain(Consumer<ResolvedKeychain> consumer, Consumer<Keychain.UsageBuilder> mutator, ResolvedKeychain keychain) {\n+        Objects.requireNonNull(consumer);\n+        withKeychains(() -> {\n+            consumer.accept(keychain);\n+        }, mutator, keychain.spec().keychain());\n+    }\n+\n+    public static void withKeychain(Consumer<ResolvedKeychain> consumer, ResolvedKeychain keychain) {\n+        withKeychain(consumer, _ -> {}, keychain);\n+    }\n+\n@@ -1049,0 +1125,4 @@\n+        public String name() {\n+            return spec.keychain().name();\n+        }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSign.java","additions":93,"deletions":13,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -47,0 +47,37 @@\n+    public static void verifyAppImageSigned(\n+            JPackageCommand cmd, CertificateRequest certRequest, MacSign.ResolvedKeychain keychain) {\n+\n+        cmd.verifyIsOfType(PackageType.MAC);\n+        Objects.requireNonNull(certRequest);\n+        Objects.requireNonNull(keychain);\n+\n+        final Path bundleRoot;\n+        if (cmd.isImagePackageType()) {\n+            bundleRoot = cmd.outputBundle();\n+        } else {\n+            bundleRoot = cmd.pathToUnpackedPackageFile(\n+                    cmd.appInstallationDirectory());\n+        }\n+\n+        assertSigned(bundleRoot, certRequest);\n+\n+        if (!cmd.isRuntime()) {\n+            cmd.addLauncherNames().stream().map(cmd::appLauncherPath).forEach(launcherPath -> {\n+                assertSigned(launcherPath, certRequest);\n+            });\n+        }\n+\n+        \/\/ Set to \"null\" if the sign origin is not found, instead of bailing out with an exception.\n+        \/\/ Let is fail in the following TKit.assertEquals() call with a proper log message.\n+        var signOrigin = findSpctlSignOrigin(SpctlType.EXEC, bundleRoot).orElse(null);\n+\n+        TKit.assertEquals(certRequest.name(), signOrigin,\n+                String.format(\"Check [%s] has sign origin as expected\", bundleRoot));\n+    }\n+\n+    public static void verifyPkgSigned(JPackageCommand cmd, CertificateRequest certRequest, MacSign.ResolvedKeychain keychain) {\n+        cmd.verifyIsOfType(PackageType.MAC_PKG);\n+        assertPkgSigned(cmd.outputBundle(), certRequest,\n+                Objects.requireNonNull(keychain.mapCertificateRequests().get(certRequest)));\n+    }\n+\n@@ -117,2 +154,2 @@\n-        final var exec = Executor.of(\"\/usr\/bin\/codesign\", \"--display\", \"--verbose=4\", path.toString()).saveOutput();\n-        final var result = exec.executeWithoutExitCodeCheck();\n+        final var exec = Executor.of(\"\/usr\/bin\/codesign\", \"--display\", \"--verbose=4\", path.toString());\n+        final var result = exec.saveOutput().executeWithoutExitCodeCheck();\n@@ -147,6 +184,28 @@\n-        final var verifier = TKit.TextStreamVerifier.group()\n-                .add(TKit.assertTextStream(\": valid on disk\").predicate(String::endsWith))\n-                .add(TKit.assertTextStream(\": satisfies its Designated Requirement\").predicate(String::endsWith))\n-                .create();\n-        verifier.accept(Executor.of(\"\/usr\/bin\/codesign\", \"--verify\", \"--deep\",\n-                \"--strict\", \"--verbose=2\", path.toString()).executeAndGetOutput().iterator());\n+        assertSigned(path, false);\n+    }\n+\n+    private static void assertSigned(Path path, boolean sudo) {\n+        final Executor exec;\n+        if (sudo) {\n+            exec = Executor.of(\"sudo\", \"\/usr\/bin\/codesign\");\n+        } else {\n+            exec = Executor.of(\"\/usr\/bin\/codesign\");\n+        }\n+        exec.addArguments(\"--verify\", \"--deep\", \"--strict\", \"--verbose=2\", path.toString());\n+        final var result = exec.saveOutput().executeWithoutExitCodeCheck();\n+        if (result.getExitCode() == 0) {\n+            TKit.TextStreamVerifier.group()\n+                    .add(TKit.assertTextStream(\": valid on disk\").predicate(String::endsWith))\n+                    .add(TKit.assertTextStream(\": satisfies its Designated Requirement\").predicate(String::endsWith))\n+                    .create().accept(result.getOutput().iterator());\n+        } else if (!sudo && result.getOutput().stream().findFirst().filter(str -> {\n+            \/\/ By some reason \/usr\/bin\/codesign command fails for some installed bundles.\n+            \/\/ It is known to fail for some AppContentTest test cases and all FileAssociationsTest test cases.\n+            \/\/ Rerunning the command with \"sudo\" works, though.\n+            return str.equals(String.format(\"%s: Permission denied\", path));\n+        }).isPresent()) {\n+                TKit.trace(\"Try \/usr\/bin\/codesign again with `sudo`\");\n+                assertSigned(path, true);\n+        } else {\n+            reportUnexpectedCommandOutcome(exec.getPrintableCommandLine(), result);\n+        }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSignVerify.java","additions":67,"deletions":8,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -73,0 +73,2 @@\n+        expectedStrings.add(JPackageStringBundle.MAIN.cannedFormattedString(\"error.tool.failed.with.output\", \"codesign\"));\n+\n@@ -78,3 +80,1 @@\n-        final var keychain = SigningBase.StandardKeychain.EXPIRED.spec().keychain();\n-\n-        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n+        MacSign.withKeychain(keychain -> {\n@@ -89,2 +89,0 @@\n-                    .addArguments(\"--mac-sign\")\n-                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n@@ -98,2 +96,30 @@\n-            cmd.execute(1);\n-        });\n+            MacHelper.useKeychain(cmd, keychain).execute(1);\n+        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    @Test\n+    public static void testCodesignUnspecifiedFailure() throws IOException {\n+\n+        var appImageCmd = JPackageCommand.helloAppImage().setFakeRuntime();\n+\n+        appImageCmd.executeIgnoreExitCode().assertExitCodeIsZero();\n+\n+        \/\/ This test expects jpackage to respond in a specific way on a codesign failure.\n+        \/\/ The simplest option to trigger codesign failure is to request the signing of an invalid bundle.\n+        \/\/ Create app content directory with the name known to fail signing.\n+        final var appContent = appImageCmd.appLayout().contentDirectory().resolve(\"foo.1\");\n+        Files.createDirectory(appContent);\n+        Files.createFile(appContent.resolve(\"file\"));\n+\n+        final List<CannedFormattedString> expectedStrings = new ArrayList<>();\n+        expectedStrings.add(JPackageStringBundle.MAIN.cannedFormattedString(\"error.tool.failed.with.output\", \"codesign\"));\n+\n+        MacSign.withKeychain(keychain -> {\n+            final var cmd = new JPackageCommand().setPackageType(PackageType.IMAGE)\n+                    .ignoreDefaultVerbose(true)\n+                    .validateOutput(expectedStrings.toArray(CannedFormattedString[]::new))\n+                    .addArguments(\"--app-image\", appImageCmd.outputBundle())\n+                    .addArguments(\"--mac-app-image-sign-identity\", SigningBase.StandardCertificateRequest.CODESIGN.spec().name());\n+\n+            MacHelper.useKeychain(cmd, keychain).execute(1);\n+        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.MAIN.keychain());\n@@ -119,4 +145,2 @@\n-        final var keychain = SigningBase.StandardKeychain.EXPIRED.spec().keychain();\n-\n-        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n-            final var cmd = JPackageCommand.helloAppImage()\n+        MacSign.withKeychain(keychain -> {\n+            final var cmd = MacHelper.useKeychain(JPackageCommand.helloAppImage(), keychain)\n@@ -124,2 +148,0 @@\n-                    .addArguments(\"--mac-sign\")\n-                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n@@ -132,1 +154,1 @@\n-        });\n+        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.EXPIRED.keychain());\n@@ -151,4 +173,2 @@\n-        final var keychain = SigningBase.StandardKeychain.DUPLICATE.spec().keychain();\n-\n-        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n-            final var cmd = JPackageCommand.helloAppImage()\n+        MacSign.withKeychain(keychain -> {\n+            final var cmd = MacHelper.useKeychain(JPackageCommand.helloAppImage(), keychain)\n@@ -156,2 +176,0 @@\n-                    .addArguments(\"--mac-sign\")\n-                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n@@ -164,1 +182,1 @@\n-        });\n+        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.DUPLICATE.keychain());\n@@ -171,4 +189,2 @@\n-        final var keychain = SigningBase.StandardKeychain.MAIN.spec().keychain();\n-\n-        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n-            final var cmd = JPackageCommand.helloAppImage()\n+        MacSign.withKeychain(keychain -> {\n+            final var cmd = MacHelper.useKeychain(JPackageCommand.helloAppImage(), keychain)\n@@ -176,2 +192,0 @@\n-                    .addArguments(\"--mac-sign\")\n-                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n@@ -183,1 +197,1 @@\n-        });\n+        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.MAIN.keychain());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/MacSignTest.java","additions":42,"deletions":28,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.nio.file.Path;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n@@ -26,3 +26,1 @@\n-import jdk.jpackage.test.JPackageCommand;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n+import java.nio.file.Path;\n@@ -30,0 +28,4 @@\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.MacSign;\n@@ -71,0 +73,6 @@\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            test(keychain, doSign, signingKey, certEnum);\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    private void test(MacSign.ResolvedKeychain keychain, boolean doSign, boolean signingKey, SigningBase.CertIndex certEnum) throws Exception {\n@@ -77,1 +85,1 @@\n-                    SigningBase.getKeyChain());\n+                    keychain.name());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningAppImageTest.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-import java.nio.file.Path;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n@@ -26,0 +26,4 @@\n+import java.nio.file.Path;\n+import jdk.jpackage.test.AdditionalLauncher;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n@@ -27,1 +31,1 @@\n-import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.MacSign;\n@@ -29,3 +33,1 @@\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n-import jdk.jpackage.test.AdditionalLauncher;\n+import jdk.jpackage.test.TKit;\n@@ -70,0 +72,6 @@\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            test(keychain, signAppImage, signingKey);\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    private static void test(MacSign.ResolvedKeychain keychain, boolean signAppImage, boolean signingKey) throws Exception {\n@@ -81,1 +89,1 @@\n-                    SigningBase.getKeyChain());\n+                    keychain.name());\n@@ -106,1 +114,1 @@\n-            .addArguments(\"--mac-signing-keychain\", SigningBase.getKeyChain());\n+            .addArguments(\"--mac-signing-keychain\", keychain.name());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningAppImageTwoStepsTest.java","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,2 @@\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+\n@@ -25,0 +27,2 @@\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n@@ -27,1 +31,2 @@\n-import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.MacSign;\n@@ -30,3 +35,1 @@\n-import jdk.jpackage.test.MacHelper;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.TKit;\n@@ -105,0 +108,6 @@\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            test(keychain, signAppImage, signingKey);\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    private void test(MacSign.ResolvedKeychain keychain, boolean signAppImage, boolean signingKey) throws Exception {\n@@ -115,1 +124,1 @@\n-                    \"--mac-signing-keychain\", SigningBase.getKeyChain());\n+                    \"--mac-signing-keychain\", keychain.name());\n@@ -136,1 +145,1 @@\n-            .addArguments(\"--mac-signing-keychain\", SigningBase.getKeyChain());\n+            .addArguments(\"--mac-signing-keychain\", keychain.name());\n@@ -157,1 +166,1 @@\n-                                SigningBase.getKeyChain());\n+                                keychain.name());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageFromTwoStepAppImageTest.java","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+\n@@ -25,0 +27,2 @@\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n@@ -27,0 +31,2 @@\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.MacSign;\n@@ -29,3 +35,0 @@\n-import jdk.jpackage.test.MacHelper;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n@@ -147,0 +150,6 @@\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            test(keychain, signingKey, signAppImage, signPKG, certEnum);\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    private static void test(MacSign.ResolvedKeychain keychain, boolean signingKey, boolean signAppImage, boolean signPKG, SigningBase.CertIndex certEnum) throws Exception {\n@@ -154,1 +163,1 @@\n-                            \"--mac-signing-keychain\", SigningBase.getKeyChain());\n+                            \"--mac-signing-keychain\", keychain.name());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageTest.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,2 @@\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+\n@@ -25,1 +27,12 @@\n-import jdk.jpackage.test.ApplicationLayout;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import java.util.stream.Stream;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Test;\n@@ -27,1 +40,6 @@\n-import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.JPackageStringBundle;\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.MacHelper.SignKeyOption;\n+import jdk.jpackage.test.MacSign;\n+import jdk.jpackage.test.MacSignVerify;\n+import jdk.jpackage.test.PackageFile;\n@@ -30,3 +48,1 @@\n-import jdk.jpackage.test.MacHelper;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.TKit;\n@@ -35,14 +51,6 @@\n- * Note: Testing unsgined app image is done to verify support for per-user\n- * configuration by checking for PackageFile.\n- * Tests generation of dmg and pkg from signed or unsigned predefined app image.\n- * Test will generate pkg and verifies its signature. It verifies that dmg\n- * is not signed, but app image inside dmg is signed or unsigned. This test\n- * requires that the machine is configured with test certificate for\n- * \"Developer ID Installer: jpackage.openjdk.java.net\" in\n- * jpackagerTest keychain with\n- * always allowed access to this keychain for user which runs test.\n- * note:\n- * \"jpackage.openjdk.java.net\" can be over-ridden by system property\n- * \"jpackage.mac.signing.key.user.name\", and\n- * \"jpackagerTest\" can be over-ridden by system property\n- * \"jpackage.mac.signing.keychain\"\n+ * Tests packaging of a signed\/unsigned predefined app image into a\n+ * signed\/unsigned .pkg or .dmg package.\n+ *\n+ * <p>\n+ * Prerequisites: A keychain with self-signed certificates as specified in\n+ * {@link SigningBase.StandardKeychain#MAIN}.\n@@ -67,3 +75,23 @@\n-    private static void verifyPKG(JPackageCommand cmd) {\n-        if (!cmd.hasArgument(\"--mac-sign\")) {\n-            return; \/\/ Nothing to check if not signed\n+    @Test\n+    @ParameterSupplier\n+    public static void test(TestSpec spec) {\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            spec.test(keychain);\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    public record TestSpec(Optional<SignKeyOption> signAppImage, Map<PackageType, SignKeyOption> signPackage) {\n+\n+        public TestSpec {\n+            Objects.requireNonNull(signAppImage);\n+            Objects.requireNonNull(signPackage);\n+\n+            if ((signAppImage.isEmpty() && signPackage.isEmpty()) || !PackageType.MAC.containsAll(signPackage.keySet())) {\n+                \/\/ Unexpected package types.\n+                throw new IllegalArgumentException();\n+            }\n+\n+            \/\/ Ensure stable result of toString() call.\n+            if (!SortedMap.class.isInstance(signPackage)) {\n+                signPackage = new TreeMap<>(signPackage);\n+            }\n@@ -72,4 +100,3 @@\n-        Path outputBundle = cmd.outputBundle();\n-        SigningBase.verifyPkgutil(outputBundle, true, SigningBase.DEFAULT_INDEX);\n-        SigningBase.verifySpctl(outputBundle, \"install\", SigningBase.DEFAULT_INDEX);\n-    }\n+        @Override\n+        public String toString() {\n+            var sb = new StringBuilder();\n@@ -77,5 +104,3 @@\n-    private static void verifyDMG(JPackageCommand cmd) {\n-        \/\/ DMG always unsigned, so we will check it\n-        Path outputBundle = cmd.outputBundle();\n-        SigningBase.verifyDMG(outputBundle);\n-    }\n+            signAppImage.ifPresent(signOption -> {\n+                sb.append(String.format(\"app-image=%s\", signOption));\n+            });\n@@ -83,13 +108,2 @@\n-    private static void verifyAppImageInDMG(JPackageCommand cmd) {\n-        MacHelper.withExplodedDmg(cmd, dmgImage -> {\n-            \/\/ We will be called with all folders in DMG since JDK-8263155, but\n-            \/\/ we only need to verify app.\n-            if (dmgImage.endsWith(cmd.name() + \".app\")) {\n-                boolean isSigned = cmd.hasArgument(\"--mac-sign\");\n-                Path launcherPath = ApplicationLayout.platformAppImage()\n-                    .resolveAt(dmgImage).launchersDirectory().resolve(cmd.name());\n-                SigningBase.verifyCodesign(launcherPath, isSigned, SigningBase.DEFAULT_INDEX);\n-                SigningBase.verifyCodesign(dmgImage, isSigned, SigningBase.DEFAULT_INDEX);\n-                if (isSigned) {\n-                    SigningBase.verifySpctl(dmgImage, \"exec\", SigningBase.DEFAULT_INDEX);\n-                }\n+            if (!sb.isEmpty() && !signPackage.isEmpty()) {\n+                sb.append(\"; \");\n@@ -97,2 +111,0 @@\n-        });\n-    }\n@@ -100,23 +112,2 @@\n-    @Test\n-    \/\/ (Signed, \"signing-key or sign-identity\"})\n-    \/\/ Signed and signing-key\n-    @Parameter({\"true\", \"true\"})\n-    \/\/ Signed and signing-identity\n-    @Parameter({\"true\", \"false\"})\n-    \/\/ Unsigned\n-    @Parameter({\"false\", \"true\"})\n-    public static void test(boolean signAppImage, boolean signingKey) throws Exception {\n-        Path appimageOutput = TKit.createTempDirectory(\"appimage\");\n-\n-        JPackageCommand appImageCmd = JPackageCommand.helloAppImage()\n-                .setArgumentValue(\"--dest\", appimageOutput);\n-        if (signAppImage) {\n-            appImageCmd.addArguments(\"--mac-sign\")\n-                       .addArguments(\"--mac-signing-keychain\",\n-                                     SigningBase.getKeyChain());\n-            if (signingKey) {\n-                appImageCmd.addArguments(\"--mac-signing-key-user-name\",\n-                                SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n-            } else {\n-                appImageCmd.addArguments(\"--mac-app-image-sign-identity\",\n-                                SigningBase.getAppCert(SigningBase.DEFAULT_INDEX));\n+            if (!signPackage.isEmpty()) {\n+                sb.append(signPackage);\n@@ -124,0 +115,6 @@\n+\n+            return sb.toString();\n+        }\n+\n+        boolean signNativeBundle() {\n+            return signPackage.isEmpty();\n@@ -126,36 +123,127 @@\n-        new PackageTest()\n-                .addRunOnceInitializer(() -> appImageCmd.execute())\n-                .forTypes(PackageType.MAC)\n-                .addInitializer(cmd -> {\n-                    cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n-                    cmd.removeArgumentWithValue(\"--input\");\n-                    if (signAppImage) {\n-                        cmd.addArguments(\"--mac-sign\",\n-                                \"--mac-signing-keychain\",\n-                                SigningBase.getKeyChain());\n-                        if (signingKey) {\n-                            cmd.addArguments(\"--mac-signing-key-user-name\",\n-                                    SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n-                        } else {\n-                            cmd.addArguments(\"--mac-installer-sign-identity\",\n-                                    SigningBase.getInstallerCert(SigningBase.DEFAULT_INDEX));\n-                        }\n-                    }\n-                })\n-                .forTypes(PackageType.MAC_PKG)\n-                .addBundleVerifier(SigningPackageTwoStepTest::verifyPKG)\n-                .forTypes(PackageType.MAC_DMG)\n-                .addInitializer(cmd -> {\n-                    if (signAppImage && !signingKey) {\n-                        \/\/ jpackage throws expected error with\n-                        \/\/ --mac-installer-sign-identity and DMG type\n-                        cmd.removeArgumentWithValue(\"--mac-installer-sign-identity\");\n-                        \/\/ It will do nothing, but it signals test that app\n-                        \/\/ image itself is signed for verification.\n-                        cmd.addArguments(\"--mac-app-image-sign-identity\",\n-                                SigningBase.getAppCert(SigningBase.DEFAULT_INDEX));\n-                    }\n-                })\n-                .addBundleVerifier(SigningPackageTwoStepTest::verifyDMG)\n-                .addBundleVerifier(SigningPackageTwoStepTest::verifyAppImageInDMG)\n-                .run();\n+        static Builder build() {\n+            return new Builder();\n+        }\n+\n+        static class Builder {\n+\n+            TestSpec create() {\n+                return new TestSpec(Optional.ofNullable(signAppImage), signPackage);\n+            }\n+\n+            Builder certRequest(SigningBase.StandardCertificateRequest v) {\n+                return certRequest(v.spec());\n+            }\n+\n+            Builder certRequest(MacSign.CertificateRequest v) {\n+                certRequest = Objects.requireNonNull(v);\n+                return this;\n+            }\n+\n+            Builder signIdentityType(SignKeyOption.Type v) {\n+                signIdentityType = Objects.requireNonNull(v);\n+                return this;\n+            }\n+\n+            Builder signAppImage() {\n+                signAppImage = createSignKeyOption();\n+                return this;\n+            }\n+\n+            Builder signPackage(PackageType type) {\n+                Objects.requireNonNull(type);\n+                signPackage.put(type, createSignKeyOption());\n+                return this;\n+            }\n+\n+            Builder signPackage() {\n+                PackageType.MAC.forEach(this::signPackage);\n+                return this;\n+            }\n+\n+            private SignKeyOption createSignKeyOption() {\n+                return new SignKeyOption(signIdentityType, certRequest);\n+            }\n+\n+            private MacSign.CertificateRequest certRequest = SigningBase.StandardCertificateRequest.CODESIGN.spec();\n+            private SignKeyOption.Type signIdentityType = SignKeyOption.Type.SIGN_KEY_IDENTITY;\n+\n+            private SignKeyOption signAppImage;\n+            private Map<PackageType, SignKeyOption> signPackage = new HashMap<>();\n+        }\n+\n+        void test(MacSign.ResolvedKeychain keychain) {\n+\n+            var appImageCmd = JPackageCommand.helloAppImage().setFakeRuntime();\n+            MacHelper.useKeychain(appImageCmd, keychain);\n+            signAppImage.ifPresent(signOption -> {\n+                signOption.setTo(appImageCmd);\n+            });\n+\n+            var test = new PackageTest();\n+\n+            signAppImage.map(SignKeyOption::certRequest).ifPresent(certRequest -> {\n+                \/\/ The predefined app image is signed, verify bundled app image is signed too.\n+                test.addInstallVerifier(cmd -> {\n+                    MacSignVerify.verifyAppImageSigned(cmd, certRequest, keychain);\n+                });\n+            });\n+\n+            Optional.ofNullable(signPackage.get(PackageType.MAC_PKG)).map(SignKeyOption::certRequest).ifPresent(certRequest -> {\n+                test.forTypes(PackageType.MAC_PKG, () -> {\n+                    test.addBundleVerifier(cmd -> {\n+                        MacSignVerify.verifyPkgSigned(cmd, certRequest, keychain);\n+                    });\n+                });\n+            });\n+\n+            test.forTypes(signPackage.keySet()).addRunOnceInitializer(() -> {\n+                appImageCmd.setArgumentValue(\"--dest\", TKit.createTempDirectory(\"appimage\")).execute(0);\n+            }).addInitializer(cmd -> {\n+                MacHelper.useKeychain(cmd, keychain);\n+                cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n+                cmd.removeArgumentWithValue(\"--input\");\n+                Optional.ofNullable(signPackage.get(cmd.packageType())).ifPresent(signOption -> {\n+                    signOption.setTo(cmd);\n+                });\n+\n+                if (signAppImage.isPresent()) {\n+                    \/\/ Predefined app image is signed. Expect a warning.\n+                    cmd.validateOutput(JPackageStringBundle.MAIN.cannedFormattedString(\n+                            \"warning.per.user.app.image.signed\",\n+                            PackageFile.getPathInAppImage(Path.of(\"\"))));\n+                } else if (cmd.packageType() == PackageType.MAC_PKG && signPackage.containsKey(cmd.packageType())) {\n+                    \/\/ Create signed \".pkg\" bundle from the unsigned predefined app image. Expect a warning.\n+                    cmd.validateOutput(JPackageStringBundle.MAIN.cannedFormattedString(\"warning.unsigned.app.image\", \"pkg\"));\n+                }\n+            })\n+            .run();\n+        }\n+    }\n+\n+    public static Collection<Object[]> test() {\n+\n+        List<TestSpec.Builder> data = new ArrayList<>();\n+\n+        Stream.of(SignKeyOption.Type.values()).flatMap(signIdentityType -> {\n+            return Stream.of(\n+                    \/\/ Sign both predefined app image and native package.\n+                    TestSpec.build().signIdentityType(signIdentityType)\n+                            .signAppImage()\n+                            .signPackage()\n+                            .certRequest(SigningBase.StandardCertificateRequest.PKG)\n+                            .signPackage(PackageType.MAC_PKG),\n+\n+                    \/\/ Don't sign predefined app image, sign native package.\n+                    TestSpec.build().signIdentityType(signIdentityType)\n+                            .signPackage()\n+                            .certRequest(SigningBase.StandardCertificateRequest.PKG)\n+                            .signPackage(PackageType.MAC_PKG),\n+\n+                    \/\/ Sign predefined app image, don't sign native package.\n+                    TestSpec.build().signIdentityType(signIdentityType).signAppImage()\n+            );\n+        }).forEach(data::add);\n+\n+        return data.stream().map(TestSpec.Builder::create).map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageTwoStepTest.java","additions":194,"deletions":106,"binary":false,"changes":300,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+\n@@ -28,1 +30,0 @@\n-\n@@ -34,0 +35,1 @@\n+import jdk.jpackage.test.MacSign;\n@@ -39,3 +41,3 @@\n- * Tests generation of dmg and pkg with --mac-sign and related arguments.\n- * Test will generate pkg and verifies its signature. It verifies that dmg\n- * is not signed, but runtime image inside dmg is signed.\n+ * Tests generation of dmg and pkg with --mac-sign and related arguments. Test\n+ * will generate pkg and verifies its signature. It verifies that dmg is not\n+ * signed, but runtime image inside dmg is signed.\n@@ -43,2 +45,3 @@\n- * Note: Specific UNICODE signing is not tested, since it is shared code\n- * with app image signing and it will be covered by SigningPackageTest.\n+ * <p>\n+ * Note: Specific UNICODE signing is not tested, since it is shared code with\n+ * app image signing and it will be covered by SigningPackageTest.\n@@ -46,0 +49,1 @@\n+ * <p>\n@@ -47,1 +51,2 @@\n- * 1) \"--runtime-image\" points to unsigned JDK bundle and --mac-sign is not\n+ * <ol>\n+ * <li>\"--runtime-image\" points to unsigned JDK bundle and --mac-sign is not\n@@ -49,1 +54,1 @@\n- * 2) \"--runtime-image\" points to unsigned JDK bundle and --mac-sign is\n+ * <li>\"--runtime-image\" points to unsigned JDK bundle and --mac-sign is\n@@ -51,1 +56,1 @@\n- * 3) \"--runtime-image\" points to signed JDK bundle and --mac-sign is not\n+ * <li>\"--runtime-image\" points to signed JDK bundle and --mac-sign is not\n@@ -53,1 +58,1 @@\n- * 4) \"--runtime-image\" points to signed JDK bundle and --mac-sign is provided.\n+ * <li>\"--runtime-image\" points to signed JDK bundle and --mac-sign is provided.\n@@ -55,1 +60,1 @@\n- * 5) \"--runtime-image\" points to JDK image and --mac-sign is not provided.\n+ * <li>\"--runtime-image\" points to JDK image and --mac-sign is not provided.\n@@ -57,1 +62,1 @@\n- * 6) \"--runtime-image\" points to JDK image and --mac-sign is provided.\n+ * <li>\"--runtime-image\" points to JDK image and --mac-sign is provided.\n@@ -59,0 +64,1 @@\n+ * <\/ol>\n@@ -61,4 +67,2 @@\n- * \"Developer ID Installer: jpackage.openjdk.java.net\" in\n- * jpackagerTest keychain with\n- * always allowed access to this keychain for user which runs test.\n- * note:\n+ * \"Developer ID Installer: jpackage.openjdk.java.net\" in jpackagerTest keychain\n+ * with always allowed access to this keychain for user which runs test. note:\n@@ -66,3 +70,1 @@\n- * \"jpackage.mac.signing.key.user.name\", and\n- * \"jpackagerTest\" can be over-ridden by system property\n- * \"jpackage.mac.signing.keychain\"\n+ * \"jpackage.mac.signing.key.user.name\"\n@@ -87,1 +89,1 @@\n-    private static JPackageCommand addSignOptions(JPackageCommand cmd, int certIndex) {\n+    private static JPackageCommand addSignOptions(JPackageCommand cmd, MacSign.ResolvedKeychain keychain, int certIndex) {\n@@ -91,1 +93,1 @@\n-                    \"--mac-signing-keychain\", SigningBase.getKeyChain(),\n+                    \"--mac-signing-keychain\", keychain.name(),\n@@ -97,1 +99,1 @@\n-    private static Path createInputRuntimeBundle(int certIndex) throws IOException {\n+    private static Path createInputRuntimeBundle(MacSign.ResolvedKeychain keychain, int certIndex) throws IOException {\n@@ -114,1 +116,1 @@\n-        addSignOptions(cmd, certIndex);\n+        addSignOptions(cmd, keychain, certIndex);\n@@ -150,0 +152,8 @@\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            test(keychain, useJDKBundle, jdkBundleCert, signCert);\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    private static void test(MacSign.ResolvedKeychain keychain, boolean useJDKBundle,\n+            SigningBase.CertIndex jdkBundleCert,\n+            SigningBase.CertIndex signCert) throws Exception {\n@@ -156,1 +166,1 @@\n-                        inputRuntime[0] = createInputRuntimeBundle(jdkBundleCert.value());\n+                        inputRuntime[0] = createInputRuntimeBundle(keychain, jdkBundleCert.value());\n@@ -167,1 +177,1 @@\n-                    addSignOptions(cmd, signCert.value());\n+                    addSignOptions(cmd, keychain, signCert.value());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningRuntimeImagePackageTest.java","additions":35,"deletions":25,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -93,0 +93,3 @@\n+    \/**\n+     * Standard keychains used in signing tests.\n+     *\/\n@@ -94,1 +97,4 @@\n-        MAIN(DEFAULT_KEYCHAIN,\n+        \/**\n+         * The primary keychain with good certificates.\n+         *\/\n+        MAIN(\"jpackagerTest.keychain\",\n@@ -99,0 +105,3 @@\n+        \/**\n+         * A keychain with some good and some expired certificates.\n+         *\/\n@@ -104,0 +113,3 @@\n+        \/**\n+         * A keychain with duplicated certificates.\n+         *\/\n@@ -117,1 +129,1 @@\n-            this.spec = new ResolvedKeychain(builder.create());\n+            this.keychain = new ResolvedKeychain(builder.create());\n@@ -120,2 +132,2 @@\n-        public KeychainWithCertsSpec spec() {\n-            return spec.spec();\n+        public ResolvedKeychain keychain() {\n+            return keychain;\n@@ -125,1 +137,1 @@\n-            return Objects.requireNonNull(spec.mapCertificateRequests().get(certRequest));\n+            return Objects.requireNonNull(keychain.mapCertificateRequests().get(certRequest));\n@@ -132,4 +144,0 @@\n-        private static CertificateRequest.Builder cert() {\n-            return new CertificateRequest.Builder();\n-        }\n-\n@@ -137,1 +145,1 @@\n-            return Stream.of(values()).map(StandardKeychain::spec).toList();\n+            return Stream.of(values()).map(StandardKeychain::keychain).map(ResolvedKeychain::spec).toList();\n@@ -140,1 +148,1 @@\n-        private final ResolvedKeychain spec;\n+        private final ResolvedKeychain keychain;\n@@ -182,1 +190,0 @@\n-    private static String DEFAULT_KEYCHAIN = \"jpackagerTest.keychain\";\n@@ -198,10 +205,0 @@\n-    \/\/ Returns 'true' if dev name from DEV_NAMES\n-    public static boolean isDevNameDefault() {\n-        String value = System.getProperty(\"jpackage.mac.signing.key.user.name\");\n-        if (value != null) {\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-\n@@ -216,10 +213,0 @@\n-    public static String getKeyChain() {\n-        \/\/ Always use values from system properties if set\n-        String value = System.getProperty(\"jpackage.mac.signing.keychain\");\n-        if (value != null) {\n-            return value;\n-        }\n-\n-        return DEFAULT_KEYCHAIN;\n-    }\n-\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/base\/SigningBase.java","additions":19,"deletions":32,"binary":false,"changes":51,"status":"modified"}]}