{"files":[{"patch":"@@ -1518,1 +1518,1 @@\n-    private final transient DigitList digitList = new DigitList();\n+    private transient DigitList digitList = new DigitList();\n@@ -2509,0 +2509,3 @@\n+\n+        \/\/ Cloning reference fields. Other fields (e.g., \"positivePrefixPatterns\")\n+        \/\/ are not cloned since they are read-only constants after initialization.\n@@ -2511,0 +2514,3 @@\n+        other.decimalFormat = (DecimalFormat) decimalFormat.clone();\n+        other.defaultDecimalFormat = (DecimalFormat) defaultDecimalFormat.clone();\n+        other.digitList = (DigitList) digitList.clone();\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8368328\n+ * @summary Tests if CompactNumberFormat.clone() creates an independent object\n+ * @run junit\/othervm --add-opens java.base\/java.text=ALL-UNNAMED TestClone\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.text.CompactNumberFormat;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.NumberFormat;\n+import java.util.Locale;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+\n+public class TestClone {\n+    \/\/ Concurrently parse numbers using cloned instances as originally\n+    \/\/ reported in the bug. This test could produce false negative results,\n+    \/\/ depending on the testing environment\n+    @Test\n+    void randomAccessTest() {\n+        var original =\n+            NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);\n+        var threads = IntStream.range(0, 10)\n+            .mapToObj(num -> new Thread(() -> {\n+                var clone = (NumberFormat) original.clone();\n+                for (int i = 0; i < 1000; i++) {\n+                    assertDoesNotThrow(() ->\n+                        assertEquals(num, clone.parse(String.valueOf(num)).intValue()));\n+                }\n+            })).toList();\n+        threads.forEach(Thread::start);\n+        threads.forEach(t -> {\n+            try {\n+                t.join();\n+            } catch (InterruptedException ie) {\n+                throw new RuntimeException(ie);\n+            }\n+        });\n+    }\n+\n+    private static Stream<Arguments> referenceFields() throws ClassNotFoundException {\n+        return Stream.of(\n+            Arguments.of(\"compactPatterns\", String[].class),\n+            Arguments.of(\"symbols\", DecimalFormatSymbols.class),\n+            Arguments.of(\"decimalFormat\", DecimalFormat.class),\n+            Arguments.of(\"defaultDecimalFormat\", DecimalFormat.class),\n+            Arguments.of(\"digitList\", Class.forName(\"java.text.DigitList\"))\n+        );\n+    }\n+    \/\/ Explicitly checks if the cloned object has its own references for\n+    \/\/ decimalFormat\/defaultDecimalFormat\/digitList\n+    @ParameterizedTest\n+    @MethodSource(\"referenceFields\")\n+    void whiteBoxTest(String fieldName, Class<?> type) throws Throwable {\n+        var original = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);\n+        var clone = original.clone();\n+        var lookup = MethodHandles.privateLookupIn(CompactNumberFormat.class, MethodHandles.lookup());\n+\n+        assertNotSame(lookup.findGetter(CompactNumberFormat.class, fieldName, type).invoke(original),\n+            lookup.findGetter(CompactNumberFormat.class, fieldName, type).invoke(clone));\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestClone.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"}]}