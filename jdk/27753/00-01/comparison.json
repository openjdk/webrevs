{"files":[{"patch":"@@ -1,1035 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.nio.fs;\n-\n-import java.io.IOException;\n-import java.net.URI;\n-import java.nio.charset.CharacterCodingException;\n-import java.nio.file.DirectoryStream;\n-import java.nio.file.InvalidPathException;\n-import java.nio.file.LinkOption;\n-import java.nio.file.Path;\n-import java.nio.file.ProviderMismatchException;\n-import java.nio.file.WatchEvent;\n-import java.nio.file.WatchKey;\n-import java.nio.file.WatchService;\n-import java.util.Arrays;\n-import java.util.Objects;\n-\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.util.ArraysSupport;\n-import jdk.internal.vm.annotation.Stable;\n-\n-import static sun.nio.fs.UnixConstants.*;\n-import static sun.nio.fs.UnixNativeDispatcher.*;\n-\n-\/**\n- * Linux\/Mac implementation of java.nio.file.Path\n- *\/\n-class UnixPath implements Path {\n-\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n-    private final UnixFileSystem fs;\n-\n-    \/\/ internal representation\n-    private final byte[] path;\n-\n-    \/\/ String representation (created lazily, no need to be volatile)\n-    private @Stable String stringValue;\n-\n-    \/\/ cached hashcode (created lazily, no need to be volatile)\n-    private int hash;\n-\n-    \/\/ array of offsets of elements in path (created lazily)\n-    private volatile int[] offsets;\n-\n-    UnixPath(UnixFileSystem fs, byte[] path) {\n-        this.fs = fs;\n-        this.path = path;\n-    }\n-\n-    UnixPath(UnixFileSystem fs, String input) {\n-        \/\/ removes redundant slashes and checks for invalid characters\n-        this(fs, encode(fs, normalizeAndCheck(input)));\n-    }\n-\n-    \/\/ package-private\n-    \/\/ removes redundant slashes and check input for invalid characters\n-    static String normalizeAndCheck(String input) {\n-        int n = input.length();\n-        char prevChar = 0;\n-        for (int i=0; i < n; i++) {\n-            char c = input.charAt(i);\n-            if ((c == '\/') && (prevChar == '\/'))\n-                return normalize(input, n, i - 1);\n-            checkNotNul(input, c);\n-            prevChar = c;\n-        }\n-        if (prevChar == '\/' && n > 1) {\n-            return input.substring(0, n - 1);\n-        }\n-        return input;\n-    }\n-\n-    private static void checkNotNul(String input, char c) {\n-        if (c == '\\u0000')\n-            throw new InvalidPathException(input, \"Nul character not allowed\");\n-    }\n-\n-    private static String normalize(String input, int len, int off) {\n-        if (len == 0)\n-            return input;\n-        int n = len;\n-        while ((n > 0) && (input.charAt(n - 1) == '\/')) n--;\n-        if (n == 0)\n-            return \"\/\";\n-        StringBuilder sb = new StringBuilder(input.length());\n-        if (off > 0)\n-            sb.append(input, 0, off);\n-        char prevChar = 0;\n-        for (int i=off; i < n; i++) {\n-            char c = input.charAt(i);\n-            if ((c == '\/') && (prevChar == '\/'))\n-                continue;\n-            checkNotNul(input, c);\n-            sb.append(c);\n-            prevChar = c;\n-        }\n-        return sb.toString();\n-    }\n-\n-    \/\/ encodes the given path-string into a sequence of bytes\n-    private static byte[] encode(UnixFileSystem fs, String input) {\n-        try {\n-            return JLA.uncheckedGetBytesOrThrow(input, Util.jnuEncoding());\n-        } catch (CharacterCodingException cce) {\n-            throw new InvalidPathException(input,\n-                \"Malformed input or input contains unmappable characters\");\n-        }\n-    }\n-\n-    \/\/ package-private\n-    byte[] asByteArray() {\n-        return path;\n-    }\n-\n-    \/\/ use this path when making system\/library calls\n-    byte[] getByteArrayForSysCalls() {\n-        \/\/ resolve against default directory if required (chdir allowed or\n-        \/\/ file system default directory is not working directory)\n-        if (getFileSystem().needToResolveAgainstDefaultDirectory()) {\n-            return resolve(getFileSystem().defaultDirectory(), path);\n-        } else {\n-            if (!isEmpty()) {\n-                return path;\n-            } else {\n-                \/\/ empty path case will access current directory\n-                byte[] here = { '.' };\n-                return here;\n-            }\n-        }\n-    }\n-\n-    \/\/ use this message when throwing exceptions\n-    String getPathForExceptionMessage() {\n-        return toString();\n-    }\n-\n-    \/\/ use this path for permission checks\n-    String getPathForPermissionCheck() {\n-        if (getFileSystem().needToResolveAgainstDefaultDirectory()) {\n-            return Util.toString(getByteArrayForSysCalls());\n-        } else {\n-            return toString();\n-        }\n-    }\n-\n-    \/\/ Checks that the given file is a UnixPath\n-    static UnixPath toUnixPath(Path obj) {\n-        if (obj == null)\n-            throw new NullPointerException();\n-        if (!(obj instanceof UnixPath))\n-            throw new ProviderMismatchException();\n-        return (UnixPath)obj;\n-    }\n-\n-    \/\/ create offset list if not already created\n-    private void initOffsets() {\n-        if (offsets == null) {\n-            int count, index;\n-\n-            \/\/ count names\n-            count = 0;\n-            index = 0;\n-            if (isEmpty()) {\n-                \/\/ empty path has one name\n-                count = 1;\n-            } else {\n-                while (index < path.length) {\n-                    byte c = path[index++];\n-                    if (c != '\/') {\n-                        count++;\n-                        while (index < path.length && path[index] != '\/')\n-                            index++;\n-                    }\n-                }\n-            }\n-\n-            \/\/ populate offsets\n-            int[] result = new int[count];\n-            count = 0;\n-            index = 0;\n-            while (index < path.length) {\n-                byte c = path[index];\n-                if (c == '\/') {\n-                    index++;\n-                } else {\n-                    result[count++] = index++;\n-                    while (index < path.length && path[index] != '\/')\n-                        index++;\n-                }\n-            }\n-            synchronized (this) {\n-                if (offsets == null)\n-                    offsets = result;\n-            }\n-        }\n-    }\n-\n-    \/\/ returns {@code true} if this path is an empty path\n-    boolean isEmpty() {\n-        return path.length == 0;\n-    }\n-\n-    \/\/ returns an empty path\n-    private UnixPath emptyPath() {\n-        return new UnixPath(getFileSystem(), new byte[0]);\n-    }\n-\n-\n-    \/\/ return true if this path has \".\" or \"..\"\n-    private boolean hasDotOrDotDot() {\n-        int n = getNameCount();\n-        for (int i=0; i<n; i++) {\n-            byte[] bytes = getName(i).path;\n-            if ((bytes.length == 1 && bytes[0] == '.'))\n-                return true;\n-            if ((bytes.length == 2 && bytes[0] == '.') && bytes[1] == '.') {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    public UnixFileSystem getFileSystem() {\n-        return fs;\n-    }\n-\n-    @Override\n-    public UnixPath getRoot() {\n-        if (path.length > 0 && path[0] == '\/') {\n-            return getFileSystem().rootDirectory();\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    @Override\n-    public UnixPath getFileName() {\n-        initOffsets();\n-\n-        int count = offsets.length;\n-\n-        \/\/ no elements so no name\n-        if (count == 0)\n-            return null;\n-\n-        \/\/ one name element and no root component\n-        if (count == 1 && path.length > 0 && path[0] != '\/')\n-            return this;\n-\n-        int lastOffset = offsets[count-1];\n-        int len = path.length - lastOffset;\n-        byte[] result = new byte[len];\n-        System.arraycopy(path, lastOffset, result, 0, len);\n-        return new UnixPath(getFileSystem(), result);\n-    }\n-\n-    @Override\n-    public UnixPath getParent() {\n-        initOffsets();\n-\n-        int count = offsets.length;\n-        if (count == 0) {\n-            \/\/ no elements so no parent\n-            return null;\n-        }\n-        int len = offsets[count-1] - 1;\n-        if (len <= 0) {\n-            \/\/ parent is root only (may be null)\n-            return getRoot();\n-        }\n-        byte[] result = new byte[len];\n-        System.arraycopy(path, 0, result, 0, len);\n-        return new UnixPath(getFileSystem(), result);\n-    }\n-\n-    @Override\n-    public int getNameCount() {\n-        initOffsets();\n-        return offsets.length;\n-    }\n-\n-    @Override\n-    public UnixPath getName(int index) {\n-        initOffsets();\n-        if (index < 0)\n-            throw new IllegalArgumentException();\n-        if (index >= offsets.length)\n-            throw new IllegalArgumentException();\n-\n-        int begin = offsets[index];\n-        int len;\n-        if (index == (offsets.length-1)) {\n-            len = path.length - begin;\n-        } else {\n-            len = offsets[index+1] - begin - 1;\n-        }\n-\n-        \/\/ construct result\n-        byte[] result = new byte[len];\n-        System.arraycopy(path, begin, result, 0, len);\n-        return new UnixPath(getFileSystem(), result);\n-    }\n-\n-    @Override\n-    public UnixPath subpath(int beginIndex, int endIndex) {\n-        initOffsets();\n-\n-        if (beginIndex < 0)\n-            throw new IllegalArgumentException();\n-        if (beginIndex >= offsets.length)\n-            throw new IllegalArgumentException();\n-        if (endIndex > offsets.length)\n-            throw new IllegalArgumentException();\n-        if (beginIndex >= endIndex) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        \/\/ starting offset and length\n-        int begin = offsets[beginIndex];\n-        int len;\n-        if (endIndex == offsets.length) {\n-            len = path.length - begin;\n-        } else {\n-            len = offsets[endIndex] - begin - 1;\n-        }\n-\n-        \/\/ construct result\n-        byte[] result = new byte[len];\n-        System.arraycopy(path, begin, result, 0, len);\n-        return new UnixPath(getFileSystem(), result);\n-    }\n-\n-    @Override\n-    public boolean isAbsolute() {\n-        return (path.length > 0 && path[0] == '\/');\n-    }\n-\n-    \/\/ Resolve child against given base\n-    private static byte[] resolve(byte[] base, byte[] child) {\n-        int baseLength = base.length;\n-        int childLength = child.length;\n-        if (childLength == 0)\n-            return base;\n-        if (baseLength == 0 || child[0] == '\/')\n-            return child;\n-        byte[] result;\n-        if (baseLength == 1 && base[0] == '\/') {\n-            result = new byte[childLength + 1];\n-            result[0] = '\/';\n-            System.arraycopy(child, 0, result, 1, childLength);\n-        } else {\n-            result = new byte[baseLength + 1 + childLength];\n-            System.arraycopy(base, 0, result, 0, baseLength);\n-            result[base.length] = '\/';\n-            System.arraycopy(child, 0, result, baseLength+1, childLength);\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    public UnixPath resolve(Path obj) {\n-        byte[] other = toUnixPath(obj).path;\n-        if (other.length > 0 && other[0] == '\/')\n-            return ((UnixPath)obj);\n-        byte[] result = resolve(path, other);\n-        return new UnixPath(getFileSystem(), result);\n-    }\n-\n-    UnixPath resolve(byte[] other) {\n-        return resolve(new UnixPath(getFileSystem(), other));\n-    }\n-\n-   private static final byte[] resolve(byte[] base, byte[]... children) {\n-       \/\/ 'start' is either zero, indicating the base, or indicates which\n-       \/\/ child is that last one which is an absolute path\n-       int start = 0;\n-       int resultLength = base.length;\n-\n-       \/\/ Locate the last child which is an absolute path and calculate\n-       \/\/ the total number of bytes in the resolved path\n-       final int count = children.length;\n-       if (count > 0) {\n-           for (int i = 0; i < count; i++) {\n-               byte[] b = children[i];\n-               if (b.length > 0) {\n-                   if (b[0] == '\/') {\n-                       start = i + 1;\n-                       resultLength = b.length;\n-                   } else {\n-                       if (resultLength > 0)\n-                           resultLength++;\n-                       resultLength += b.length;\n-                   }\n-               }\n-           }\n-       }\n-\n-       \/\/ If the base is not being superseded by a child which is an\n-       \/\/ absolute path, then if at least one child is non-empty and\n-       \/\/ the base consists only of a '\/', then decrement resultLength to\n-       \/\/ account for an extra '\/' added in the resultLength computation.\n-       if (start == 0 && resultLength > base.length && base.length == 1 && base[0] == '\/')\n-           resultLength--;\n-\n-       \/\/ Allocate the result array and return if empty.\n-       byte[] result = new byte[resultLength];\n-       if (result.length == 0)\n-           return result;\n-\n-       \/\/ Prepend the base if it is non-empty and would not later be\n-       \/\/ overwritten by an absolute child\n-       int offset = 0;\n-       if (start == 0 && base.length > 0) {\n-           System.arraycopy(base, 0, result, 0, base.length);\n-           offset += base.length;\n-       }\n-\n-       \/\/ Append children starting with the last one which is an\n-       \/\/ absolute path\n-       if (count > 0) {\n-           int idx = Math.max(0, start - 1);\n-           for (int i = idx; i < count; i++) {\n-               byte[] b = children[i];\n-               if (b.length > 0) {\n-                   if (offset > 0 && result[offset - 1] != '\/')\n-                       result[offset++] = '\/';\n-                   System.arraycopy(b, 0, result, offset, b.length);\n-                   offset += b.length;\n-               }\n-           }\n-       }\n-\n-       return result;\n-   }\n-\n-    @Override\n-    public UnixPath resolve(Path first, Path... more) {\n-        if (more.length == 0)\n-            return resolve(first);\n-\n-        byte[][] children = new byte[1 + more.length][];\n-        children[0] = toUnixPath(first).path;\n-        for (int i = 0; i < more.length; i++)\n-            children[i + 1] = toUnixPath(more[i]).path;\n-\n-        byte[] result = resolve(path, children);\n-        return new UnixPath(getFileSystem(), result);\n-    }\n-\n-    @Override\n-    public UnixPath relativize(Path obj) {\n-        UnixPath child = toUnixPath(obj);\n-        if (child.equals(this))\n-            return emptyPath();\n-\n-        \/\/ can only relativize paths of the same type\n-        if (this.isAbsolute() != child.isAbsolute())\n-            throw new IllegalArgumentException(\"'other' is different type of Path\");\n-\n-        \/\/ this path is the empty path\n-        if (this.isEmpty())\n-            return child;\n-\n-        UnixPath base = this;\n-        if (base.hasDotOrDotDot() || child.hasDotOrDotDot()) {\n-            base = base.normalize();\n-            child = child.normalize();\n-        }\n-\n-        int baseCount = base.getNameCount();\n-        int childCount = child.getNameCount();\n-\n-        \/\/ skip matching names\n-        int n = Math.min(baseCount, childCount);\n-        int i = 0;\n-        while (i < n) {\n-            if (!base.getName(i).equals(child.getName(i)))\n-                break;\n-            i++;\n-        }\n-\n-        \/\/ remaining elements in child\n-        UnixPath childRemaining;\n-        boolean isChildEmpty;\n-        if (i == childCount) {\n-            childRemaining = emptyPath();\n-            isChildEmpty = true;\n-        } else {\n-            childRemaining = child.subpath(i, childCount);\n-            isChildEmpty = childRemaining.isEmpty();\n-        }\n-\n-        \/\/ matched all of base\n-        if (i == baseCount) {\n-            return childRemaining;\n-        }\n-\n-        \/\/ the remainder of base cannot contain \"..\"\n-        UnixPath baseRemaining = base.subpath(i, baseCount);\n-        if (baseRemaining.hasDotOrDotDot()) {\n-            throw new IllegalArgumentException(\"Unable to compute relative \"\n-                    + \" path from \" + this + \" to \" + obj);\n-        }\n-        if (baseRemaining.isEmpty())\n-            return childRemaining;\n-\n-        \/\/ number of \"..\" needed\n-        int dotdots = baseRemaining.getNameCount();\n-        if (dotdots == 0) {\n-            return childRemaining;\n-        }\n-\n-        \/\/ result is a  \"..\/\" for each remaining name in base followed by the\n-        \/\/ remaining names in child. If the remainder is the empty path\n-        \/\/ then we don't add the final trailing slash.\n-        int len = dotdots*3 + childRemaining.path.length;\n-        if (isChildEmpty) {\n-            assert childRemaining.isEmpty();\n-            len--;\n-        }\n-        byte[] result = new byte[len];\n-        int pos = 0;\n-        while (dotdots > 0) {\n-            result[pos++] = (byte)'.';\n-            result[pos++] = (byte)'.';\n-            if (isChildEmpty) {\n-                if (dotdots > 1) result[pos++] = (byte)'\/';\n-            } else {\n-                result[pos++] = (byte)'\/';\n-            }\n-            dotdots--;\n-        }\n-        System.arraycopy(childRemaining.path,0, result, pos,\n-                             childRemaining.path.length);\n-        return new UnixPath(getFileSystem(), result);\n-    }\n-\n-    @Override\n-    public UnixPath normalize() {\n-        final int count = getNameCount();\n-        if (count == 0 || isEmpty())\n-            return this;\n-\n-        boolean[] ignore = new boolean[count];      \/\/ true => ignore name\n-        int[] size = new int[count];                \/\/ length of name\n-        int remaining = count;                      \/\/ number of names remaining\n-        boolean hasDotDot = false;                  \/\/ has at least one ..\n-        boolean isAbsolute = isAbsolute();\n-\n-        \/\/ first pass:\n-        \/\/   1. compute length of names\n-        \/\/   2. mark all occurrences of \".\" to ignore\n-        \/\/   3. and look for any occurrences of \"..\"\n-        for (int i=0; i<count; i++) {\n-            int begin = offsets[i];\n-            int len;\n-            if (i == (offsets.length-1)) {\n-                len = path.length - begin;\n-            } else {\n-                len = offsets[i+1] - begin - 1;\n-            }\n-            size[i] = len;\n-\n-            if (path[begin] == '.') {\n-                if (len == 1) {\n-                    ignore[i] = true;  \/\/ ignore  \".\"\n-                    remaining--;\n-                }\n-                else {\n-                    if (path[begin+1] == '.')   \/\/ \"..\" found\n-                        hasDotDot = true;\n-                }\n-            }\n-        }\n-\n-        \/\/ multiple passes to eliminate all occurrences of name\/..\n-        if (hasDotDot) {\n-            int prevRemaining;\n-            do {\n-                prevRemaining = remaining;\n-                int prevName = -1;\n-                for (int i=0; i<count; i++) {\n-                    if (ignore[i])\n-                        continue;\n-\n-                    \/\/ not a \"..\"\n-                    if (size[i] != 2) {\n-                        prevName = i;\n-                        continue;\n-                    }\n-\n-                    int begin = offsets[i];\n-                    if (path[begin] != '.' || path[begin+1] != '.') {\n-                        prevName = i;\n-                        continue;\n-                    }\n-\n-                    \/\/ \"..\" found\n-                    if (prevName >= 0) {\n-                        \/\/ name\/<ignored>\/.. found so mark name and \"..\" to be\n-                        \/\/ ignored\n-                        ignore[prevName] = true;\n-                        ignore[i] = true;\n-                        remaining = remaining - 2;\n-                        prevName = -1;\n-                    } else {\n-                        \/\/ Case: \/<ignored>\/.. so mark \"..\" as ignored\n-                        if (isAbsolute) {\n-                            boolean hasPrevious = false;\n-                            for (int j=0; j<i; j++) {\n-                                if (!ignore[j]) {\n-                                    hasPrevious = true;\n-                                    break;\n-                                }\n-                            }\n-                            if (!hasPrevious) {\n-                                \/\/ all proceeding names are ignored\n-                                ignore[i] = true;\n-                                remaining--;\n-                            }\n-                        }\n-                    }\n-                }\n-            } while (prevRemaining > remaining);\n-        }\n-\n-        \/\/ no redundant names\n-        if (remaining == count)\n-            return this;\n-\n-        \/\/ corner case - all names removed\n-        if (remaining == 0) {\n-            return isAbsolute ? getFileSystem().rootDirectory() : emptyPath();\n-        }\n-\n-        \/\/ compute length of result\n-        int len = remaining - 1;\n-        if (isAbsolute)\n-            len++;\n-\n-        for (int i=0; i<count; i++) {\n-            if (!ignore[i])\n-                len += size[i];\n-        }\n-        byte[] result = new byte[len];\n-\n-        \/\/ copy names into result\n-        int pos = 0;\n-        if (isAbsolute)\n-            result[pos++] = '\/';\n-        for (int i=0; i<count; i++) {\n-            if (!ignore[i]) {\n-                System.arraycopy(path, offsets[i], result, pos, size[i]);\n-                pos += size[i];\n-                if (--remaining > 0) {\n-                    result[pos++] = '\/';\n-                }\n-            }\n-        }\n-        return new UnixPath(getFileSystem(), result);\n-    }\n-\n-    @Override\n-    public boolean startsWith(Path other) {\n-        if (!(Objects.requireNonNull(other) instanceof UnixPath))\n-            return false;\n-        UnixPath that = (UnixPath)other;\n-\n-        \/\/ other path is longer\n-        if (that.path.length > path.length)\n-            return false;\n-\n-        int thisOffsetCount = getNameCount();\n-        int thatOffsetCount = that.getNameCount();\n-\n-        \/\/ other path has no name elements\n-        if (thatOffsetCount == 0 && this.isAbsolute()) {\n-            return that.isEmpty() ? false : true;\n-        }\n-\n-        \/\/ given path has more elements that this path\n-        if (thatOffsetCount > thisOffsetCount)\n-            return false;\n-\n-        \/\/ same number of elements so must be exact match\n-        if ((thatOffsetCount == thisOffsetCount) &&\n-            (path.length != that.path.length)) {\n-            return false;\n-        }\n-\n-        \/\/ check offsets of elements match\n-        for (int i=0; i<thatOffsetCount; i++) {\n-            Integer o1 = offsets[i];\n-            Integer o2 = that.offsets[i];\n-            if (!o1.equals(o2))\n-                return false;\n-        }\n-\n-        \/\/ offsets match so need to compare bytes\n-        int i=0;\n-        while (i < that.path.length) {\n-            if (this.path[i] != that.path[i])\n-                return false;\n-            i++;\n-        }\n-\n-        \/\/ final check that match is on name boundary\n-        if (i < path.length && this.path[i] != '\/')\n-            return false;\n-\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean endsWith(Path other) {\n-        if (!(Objects.requireNonNull(other) instanceof UnixPath))\n-            return false;\n-        UnixPath that = (UnixPath)other;\n-\n-        int thisLen = path.length;\n-        int thatLen = that.path.length;\n-\n-        \/\/ other path is longer\n-        if (thatLen > thisLen)\n-            return false;\n-\n-        \/\/ other path is the empty path\n-        if (thisLen > 0 && thatLen == 0)\n-            return false;\n-\n-        \/\/ other path is absolute so this path must be absolute\n-        if (that.isAbsolute() && !this.isAbsolute())\n-            return false;\n-\n-        int thisOffsetCount = getNameCount();\n-        int thatOffsetCount = that.getNameCount();\n-\n-        \/\/ given path has more elements that this path\n-        if (thatOffsetCount > thisOffsetCount) {\n-            return false;\n-        } else {\n-            \/\/ same number of elements\n-            if (thatOffsetCount == thisOffsetCount) {\n-                if (thisOffsetCount == 0)\n-                    return true;\n-                int expectedLen = thisLen;\n-                if (this.isAbsolute() && !that.isAbsolute())\n-                    expectedLen--;\n-                if (thatLen != expectedLen)\n-                    return false;\n-            } else {\n-                \/\/ this path has more elements so given path must be relative\n-                if (that.isAbsolute())\n-                    return false;\n-            }\n-        }\n-\n-        \/\/ compare bytes\n-        int thisPos = offsets[thisOffsetCount - thatOffsetCount];\n-        int thatPos = that.offsets[0];\n-        return Arrays.equals(this.path, thisPos, thisLen, that.path, thatPos, thatLen);\n-    }\n-\n-    @Override\n-    public int compareTo(Path other) {\n-        return Arrays.compareUnsigned(path, ((UnixPath) other).path);\n-    }\n-\n-    @Override\n-    public boolean equals(Object ob) {\n-        return ob instanceof UnixPath p && compareTo(p) == 0;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        \/\/ OK if two or more threads compute hash\n-        int h = hash;\n-        if (h == 0) {\n-            h = ArraysSupport.hashCodeOfUnsigned(path, 0, path.length, 0);\n-            hash = h;\n-        }\n-        return h;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        \/\/ OK if two or more threads create a String\n-        String stringValue = this.stringValue;\n-        if (stringValue == null) {\n-            this.stringValue = stringValue = Util.toString(path);     \/\/ platform encoding\n-        }\n-        return stringValue;\n-    }\n-\n-    \/\/ -- file operations --\n-\n-    \/\/ package-private\n-    int openForAttributeAccess(boolean followLinks) throws UnixException {\n-        int flags = O_RDONLY;\n-        if (!followLinks) {\n-            if (O_NOFOLLOW == 0)\n-                throw new UnixException\n-                    (\"NOFOLLOW_LINKS is not supported on this platform\");\n-            flags |= O_NOFOLLOW;\n-        }\n-        return open(this, flags, 0);\n-    }\n-\n-    @Override\n-    public UnixPath toAbsolutePath() {\n-        if (isAbsolute()) {\n-            return this;\n-        }\n-        \/\/ The path is relative so need to resolve against default directory\n-        return new UnixPath(getFileSystem(),\n-            resolve(getFileSystem().defaultDirectory(), path));\n-    }\n-\n-    @Override\n-    public Path toRealPath(LinkOption... options) throws IOException {\n-        UnixPath absolute = toAbsolutePath();\n-\n-        \/\/ if resolving links then use realpath\n-        if (Util.followLinks(options)) {\n-            try {\n-                byte[] rp = realpath(absolute);\n-                return new UnixPath(getFileSystem(), rp);\n-            } catch (UnixException x) {\n-                x.rethrowAsIOException(this);\n-            }\n-        }\n-\n-        \/\/ if not resolving links then eliminate \".\" and also \"..\"\n-        \/\/ where the previous element is neither a link nor \"..\".\n-        \/\/ if there is a preceding \"..\", then it might have followed\n-        \/\/ a link or a link followed by a sequence of two or more \"..\".\n-        \/\/ if for example one has the path \"link\/..\/..\/file\",\n-        \/\/ then if a preceding \"..\" were eliminated, then the result\n-        \/\/ would be \"<root>\/link\/file\" instead of the correct\n-        \/\/ \"<root>\/link\/..\/..\/file\".\n-        UnixPath result = fs.rootDirectory();\n-        boolean parentIsDotDot = false;\n-        for (int i = 0; i < absolute.getNameCount(); i++) {\n-            UnixPath element = absolute.getName(i);\n-\n-            \/\/ eliminate \".\"\n-            if ((element.asByteArray().length == 1) &&\n-                (element.asByteArray()[0] == '.'))\n-                continue;\n-\n-            \/\/ cannot eliminate \"..\" if previous element is a link or \"..\"\n-            if ((element.asByteArray().length == 2) &&\n-                (element.asByteArray()[0] == '.') &&\n-                (element.asByteArray()[1] == '.'))\n-            {\n-                UnixFileAttributes attrs = null;\n-                try {\n-                    attrs = UnixFileAttributes.get(result, false);\n-                } catch (UnixException x) {\n-                    x.rethrowAsIOException(result);\n-                }\n-                if (!attrs.isSymbolicLink() && !parentIsDotDot) {\n-                    result = result.getParent();\n-                    if (result == null) {\n-                        result = fs.rootDirectory();\n-                    }\n-                    continue;\n-                }\n-                parentIsDotDot = true;\n-            } else {\n-                parentIsDotDot = false;\n-            }\n-            result = result.resolve(element);\n-        }\n-\n-        \/\/ check whether file exists (without following links)\n-        try {\n-            UnixFileAttributes.get(result, false);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(result);\n-        }\n-\n-        \/\/ Return if the file system is not both case insensitive and retentive\n-        if (!fs.isCaseInsensitiveAndPreserving())\n-            return result;\n-\n-        UnixPath path = fs.rootDirectory();\n-\n-        \/\/ Traverse the result obtained above from the root downward, leaving\n-        \/\/ any '..' elements intact, and replacing other elements with the\n-        \/\/ entry in the same directory which has an equal key\n-        for (int i = 0; i < result.getNameCount(); i++ ) {\n-            UnixPath element = result.getName(i);\n-\n-            \/\/ If the element is \"..\", append it directly and continue\n-            if (element.toString().equals(\"..\")) {\n-                path = path.resolve(element);\n-                continue;\n-            }\n-\n-            \/\/ Derive full path to element and check readability\n-            UnixPath elementPath = path.resolve(element);\n-\n-            \/\/ Obtain the file key of elementPath\n-            UnixFileAttributes attrs = null;\n-            try {\n-                attrs = UnixFileAttributes.get(elementPath, false);\n-            } catch (UnixException x) {\n-                x.rethrowAsIOException(result);\n-            }\n-            final UnixFileKey elementKey = attrs.fileKey();\n-\n-            \/\/ Obtain the directory stream pointer. It will be closed by\n-            \/\/ UnixDirectoryStream::close.\n-            long dp = -1;\n-            try {\n-                dp = opendir(path);\n-            } catch (UnixException x) {\n-                x.rethrowAsIOException(path);\n-            }\n-\n-            \/\/ Obtain the stream of entries in the directory corresponding\n-            \/\/ to the path constructed thus far, and extract the entry whose\n-            \/\/ internal path bytes equal the internal path bytes of the current\n-            \/\/ element, or whose string representation is equal to that of the\n-            \/\/ current element ignoring case and whose key is equal to the key\n-            \/\/ of the current element\n-            DirectoryStream.Filter<Path> filter = (p) -> { return true; };\n-            String elementName = element.toString();\n-            try (DirectoryStream<Path> entries = new UnixDirectoryStream(path, dp, filter)) {\n-                boolean found = false;\n-                for (Path entry : entries) {\n-                    Path name = entry.getFileName();\n-                    if (name.compareTo(element) == 0) {\n-                        found = true;\n-                        path = path.resolve(entry);\n-                        break;\n-                    } else if (name.toString().equalsIgnoreCase(elementName)) {\n-                        UnixPath p = path.resolve(name);\n-                        UnixFileAttributes attributes = null;\n-                        try {\n-                            attributes = UnixFileAttributes.get(p, false);\n-                            UnixFileKey key = attributes.fileKey();\n-                            if (key.equals(elementKey)) {\n-                                found = true;\n-                                path = path.resolve(entry);\n-                                break;\n-                            }\n-                        }catch (UnixException ignore) {\n-                            continue;\n-                        }\n-                    }\n-                }\n-\n-                if (!found) {\n-                    try (DirectoryStream<Path> entries = new UnixDirectoryStream(path, dp, filter)) {\n-                boolean found = false;\n-                for (Path entry : entries) {\n-                    Path name = entry.getFileName();\n-                    if (name.compareTo(element) == 0) {\n-                        found = true;\n-                        path = path.resolve(entry);\n-                        break;\n-                    } else if (name.toString().equalsIgnoreCase(elementName)) {\n-                        UnixPath p = path.resolve(name);\n-                        UnixFileAttributes attributes = null;\n-                        try {\n-                            attributes = UnixFileAttributes.get(p, false);\n-                            UnixFileKey key = attributes.fileKey();\n-                            if (key.equals(elementKey)) {\n-                                found = true;\n-                                path = path.resolve(entry);\n-                                break;\n-                            }\n-                        }catch (UnixException ignore) {\n-                            continue;\n-                        }\n-                    }\n-                }\n-\n-                if (!found) {\n-                    \/\/ Fallback which should in theory never happen\n-                    path = path.resolve(element);\n-                }\n-            }\n-        }\n-\n-        return path;\n-    }\n-\n-    @Override\n-    public URI toUri() {\n-        return UnixUriUtils.toUri(this);\n-    }\n-\n-    @Override\n-    public WatchKey register(WatchService watcher,\n-                             WatchEvent.Kind<?>[] events,\n-                             WatchEvent.Modifier... modifiers)\n-        throws IOException\n-    {\n-        if (watcher == null)\n-            throw new NullPointerException();\n-        if (!(watcher instanceof AbstractWatchService))\n-            throw new ProviderMismatchException();\n-        return ((AbstractWatchService)watcher).register(this, events, modifiers);\n-    }\n-}\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/#UnixPath.java#","additions":0,"deletions":1035,"binary":false,"changes":1035,"status":"deleted"},{"patch":"@@ -79,3 +79,1 @@\n-        IOException ex;\n-\n-        switch (lastError()) {\n+        return switch (lastError()) {\n@@ -83,1 +81,1 @@\n-            case 0 -> ex = new IOException(errorString());\n+            case 0 -> new IOException(errorString());\n@@ -87,1 +85,1 @@\n-                -> ex = new NoSuchFileException(file, other, null);\n+                -> new NoSuchFileException(file, other, null);\n@@ -89,1 +87,1 @@\n-                -> ex = new FileAlreadyExistsException(file, other, null);\n+                -> new FileAlreadyExistsException(file, other, null);\n@@ -91,1 +89,1 @@\n-                -> ex = new AccessDeniedException(file, other, null);\n+                -> new AccessDeniedException(file, other, null);\n@@ -94,4 +92,2 @@\n-            default -> ex = new FileSystemException(file, other, errorString());\n-        }\n-\n-        return ex;\n+            default -> new FileSystemException(file, other, errorString());\n+        };\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsException.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"}]}