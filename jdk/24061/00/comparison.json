{"files":[{"patch":"@@ -303,3 +303,3 @@\n-NO_TRANSITION(void, jfr_event_writer_flush(JNIEnv* env, jclass jvm, jobject writer, jint used_size, jint requested_size))\n-  JfrJavaEventWriter::flush(writer, used_size, requested_size, JavaThread::current());\n-NO_TRANSITION_END\n+JVM_ENTRY_NO_ENV(void, jfr_event_writer_flush(JNIEnv* env, jclass jvm, jobject writer, jint used_size, jint requested_size))\n+  JfrJavaEventWriter::flush(writer, used_size, requested_size, thread);\n+JVM_END\n@@ -307,3 +307,3 @@\n-NO_TRANSITION(jlong, jfr_commit(JNIEnv* env, jclass jvm, jlong next_position))\n-  return JfrJavaEventWriter::commit(next_position);\n-NO_TRANSITION_END\n+JVM_ENTRY_NO_ENV(jlong, jfr_commit(JNIEnv* env, jclass jvm, jlong next_position))\n+  return JfrJavaEventWriter::commit(next_position, thread);\n+JVM_END\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -571,1 +571,1 @@\n-void JfrCheckpointManager::on_rotation() {\n+void JfrCheckpointManager::on_rotation(bool notify_threads_only \/* false *\/) {\n@@ -573,1 +573,3 @@\n-  JfrTypeManager::on_rotation();\n+  if (!notify_threads_only) {\n+    JfrTypeManager::on_rotation();\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,1 @@\n-  void on_rotation();\n+  void on_rotation(bool notify_threads_only = false);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -489,0 +489,1 @@\n+  _checkpoint_manager.notify_threads();\n@@ -653,3 +654,1 @@\n-  if (_stack_trace_repository.is_modified()) {\n-    total_elements += flush_stacktrace(_stack_trace_repository, _chunkwriter);\n-  }\n+  total_elements += flush_stacktrace(_stack_trace_repository, _chunkwriter);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -95,4 +95,0 @@\n-bool JfrStackTraceRepository::is_modified() const {\n-  return _last_entries != _entries;\n-}\n-\n@@ -101,1 +97,1 @@\n-  if (_entries == 0) {\n+  if ((_entries == _last_entries) && !clear) {\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,0 @@\n-  bool is_modified() const;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,12 +40,1 @@\n-\n-static void assert_epoch_identity(JavaThread* jt, u2 current_epoch) {\n-  assert_precondition(jt);\n-  \/\/ Verify the epoch updates got written through also to the vthread object.\n-  const u2 epoch_raw = ThreadIdAccess::epoch(jt->vthread());\n-  const bool excluded = epoch_raw & excluded_bit;\n-  assert(!excluded, \"invariant\");\n-  assert(!JfrThreadLocal::is_excluded(jt), \"invariant\");\n-  const u2 vthread_epoch = epoch_raw & epoch_mask;\n-  assert(vthread_epoch == current_epoch, \"invariant\");\n-}\n-#endif \/\/ ASSERT\n+#endif\n@@ -56,11 +45,0 @@\n-  const u2 vthread_thread_local_epoch = JfrThreadLocal::vthread_epoch(jt);\n-  const u2 current_epoch = ThreadIdAccess::current_epoch();\n-  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, jt));\n-  if (vthread_thread_local_epoch == current_epoch) {\n-    \/\/ After the epoch test in the intrinsic, the thread sampler interleaved\n-    \/\/ and suspended the thread. As part of taking a sample, it updated\n-    \/\/ the vthread object and the thread local \"for us\". We are good.\n-    DEBUG_ONLY(assert_epoch_identity(jt, current_epoch);)\n-    ThreadInVMfromJava transition(jt);\n-    return JfrJavaEventWriter::event_writer(jt);\n-  }\n@@ -68,1 +46,2 @@\n-  \/\/ Transition before reading the epoch generation anew, now as _thread_in_vm. Can safepoint here.\n+  \/\/ Transition before reading the epoch generation, now as _thread_in_vm.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, jt));\n@@ -77,1 +56,1 @@\n-  ThreadStateTransition::transition_from_java(jt, _thread_in_native);\n+  ThreadInVMfromJava transition(jt);\n@@ -82,1 +61,0 @@\n-  ThreadStateTransition::transition_from_native(jt, _thread_in_Java);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrIntrinsics.cpp","additions":4,"deletions":26,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));\n@@ -133,3 +133,0 @@\n-  \/\/ can safepoint here\n-  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, jt));\n-  ThreadInVMfromNative transition(jt);\n@@ -150,1 +147,1 @@\n-jlong JfrJavaEventWriter::commit(jlong next_position) {\n+jlong JfrJavaEventWriter::commit(jlong next_position, JavaThread* jt) {\n@@ -152,1 +149,0 @@\n-  JavaThread* const jt = JavaThread::current();\n@@ -154,1 +150,1 @@\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));\n@@ -170,2 +166,3 @@\n-  if (!current->lease()) {\n-    return next_position;\n+  if (current->lease()) {\n+    flush(tl->java_event_writer(), 0, 0, jt);\n+    return 0; \/\/ signals that the buffer lease was returned.\n@@ -173,3 +170,1 @@\n-  assert(current->lease(), \"invariant\");\n-  flush(tl->java_event_writer(), 0, 0, jt);\n-  return 0; \/\/ signals that the buffer lease was returned.\n+  return next_position;\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrJavaEventWriter.cpp","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  static jlong commit(jlong next_position);\n+  static jlong commit(jlong next_position, JavaThread* jt);\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrJavaEventWriter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}