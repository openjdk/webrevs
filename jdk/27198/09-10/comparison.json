{"files":[{"patch":"@@ -50,0 +50,1 @@\n+#include \"oops\/bsmAttribute.inline.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_BSMATTRIBUTE_HPP\n+#define SHARE_OOPS_BSMATTRIBUTE_HPP\n+\n+#include \"classfile\/classLoaderData.hpp\"\n+#include \"oops\/array.hpp\"\n+#include \"utilities\/checkedCast.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class BSMAttributeEntry {\n+  friend class ConstantPool;\n+  friend class BSMAttributeEntries;\n+\n+  u2 _bootstrap_method_index;\n+  u2 _argument_count;\n+\n+  \/\/ The argument indexes are stored right after the object, in a contiguous array.\n+  \/\/ [ bsmi_0 argc_0 arg_00 arg_01 ... arg_0N bsmi_1 argc_1 arg_10 ... arg_1N ... ]\n+  \/\/ So in order to find the argument array, jump over ourselves.\n+  const u2* argument_indexes() const {\n+    return reinterpret_cast<const u2*>(this + 1);\n+  }\n+  u2* argument_indexes() {\n+    return reinterpret_cast<u2*>(this + 1);\n+  }\n+  \/\/ These are overlays on top of the BSMAttributeEntries data array, do not construct.\n+  BSMAttributeEntry() = delete;\n+  NONCOPYABLE(BSMAttributeEntry);\n+\n+  void copy_args_into(BSMAttributeEntry* entry) const;\n+\n+public:\n+  \/\/ Offsets for SA\n+  enum {\n+    _bsmi_offset = 0,\n+    _argc_offset = 1,\n+    _argv_offset = 2\n+  };\n+\n+  int bootstrap_method_index() const {\n+    return _bootstrap_method_index;\n+  }\n+  int argument_count() const {\n+    return _argument_count;\n+  }\n+  int argument(int n) const {\n+    assert(checked_cast<u2>(n) < _argument_count, \"oob\");\n+    return argument_indexes()[n];\n+  }\n+\n+  void set_argument(int index, u2 value) {\n+    assert(index >= 0 && index < argument_count(), \"invariant\");\n+    argument_indexes()[index] = value;\n+  }\n+\n+  \/\/ How many u2s are required to store a BSM entry with argc arguments?\n+  static int u2s_required (u2 argc) {\n+    return 1 \/* index *\/ + 1  \/* argc *\/ + argc \/* argv *\/;\n+  }\n+};\n+\n+\/\/ The BSMAttributeEntries stores the state of the BootstrapMethods attribute.\n+class BSMAttributeEntries {\n+  friend class VMStructs;\n+  friend class JVMCIVMStructs;\n+\n+public:\n+  class InsertionIterator {\n+    friend BSMAttributeEntries;\n+    BSMAttributeEntries* insert_into;\n+    \/\/ Current unused offset into BSMAEs offset array\n+    int _cur_offset;\n+    \/\/ Current unused offset into BSMAEs bsm-data array\n+    int _cur_array;\n+  public:\n+    InsertionIterator() : insert_into(nullptr), _cur_offset(-1), _cur_array(-1) {}\n+    InsertionIterator(BSMAttributeEntries* insert_into, int cur_offset, int cur_array)\n+    : insert_into(insert_into),\n+      _cur_offset(cur_offset),\n+      _cur_array(cur_array) {}\n+    InsertionIterator(const InsertionIterator&) = default;\n+    InsertionIterator& operator=(const InsertionIterator&) = default;\n+\n+    int current_offset() const { return _cur_offset; }\n+    \/\/ Add a new BSMAE, reserving the necessary memory for filling the argument vector.\n+    \/\/ Returns null if there isn't enough space.\n+    inline BSMAttributeEntry* reserve_new_entry(u2 bsmi, u2 argc);\n+  };\n+\n+private:\n+  \/\/ Each bootstrap method has a variable-sized array associated with it.\n+  \/\/ We want constant-time lookup of the Nth BSM. Therefore, we use an offset table,\n+  \/\/ such that the Nth BSM is located at _bootstrap_methods[_offsets[N]].\n+  Array<u4>* _offsets;\n+  Array<u2>* _bootstrap_methods;\n+\n+  \/\/ Copy the first num_entries into iter\n+  void copy_into(InsertionIterator& iter, int num_entries) const;\n+\n+public:\n+  BSMAttributeEntries() : _offsets(nullptr), _bootstrap_methods(nullptr) {}\n+  BSMAttributeEntries(Array<u4>* offsets, Array<u2>* bootstrap_methods)\n+    : _offsets(offsets),\n+      _bootstrap_methods(bootstrap_methods) {}\n+\n+  bool is_empty() const {\n+    return _offsets == nullptr && _bootstrap_methods == nullptr;\n+  }\n+\n+  Array<u4>*& offsets() { return _offsets; }\n+  const Array<u4>* const& offsets() const { return _offsets; }\n+  Array<u2>*& bootstrap_methods() { return _bootstrap_methods; }\n+  const Array<u2>* const& bootstrap_methods() const { return _bootstrap_methods; }\n+\n+  BSMAttributeEntry* entry(int bsms_attribute_index) {\n+    return reinterpret_cast<BSMAttributeEntry*>(_bootstrap_methods->adr_at(_offsets->at(bsms_attribute_index)));\n+  }\n+  const BSMAttributeEntry* entry(int bsms_attribute_index) const {\n+    return reinterpret_cast<BSMAttributeEntry*>(_bootstrap_methods->adr_at(_offsets->at(bsms_attribute_index)));\n+  }\n+\n+  int number_of_entries() const {\n+    return _offsets == nullptr ? 0 : _offsets->length();\n+  }\n+\n+  \/\/ The number of U2s the BSM data consists of.\n+  int array_length() const {\n+    return _bootstrap_methods == nullptr ? 0 :  _bootstrap_methods->length();\n+  }\n+\n+  void deallocate_contents(ClassLoaderData* loader_data);\n+\n+  \/\/ Extend to have the space for both this BSMAEntries and other's.\n+  \/\/ Does not copy in the other's BSMAEntrys, that must be done via the InsertionIterator.\n+  \/\/ This starts an insertion iterator. Any call to start_extension must have a matching end_extension call.\n+  InsertionIterator start_extension(const BSMAttributeEntries& other, ClassLoaderData* loader_data, TRAPS);\n+  \/\/ Extend the BSMAEntries with an additional number_of_entries with a total data_size.\n+  InsertionIterator start_extension(int number_of_entries, int data_size, ClassLoaderData* loader_data, TRAPS);\n+  \/\/ Reallocates the underlying memory to fit the limits of the InsertionIterator precisely.\n+  \/\/ This ends an insertion iteration. The memory is truncated to fit exactly the data used.\n+  void end_extension(InsertionIterator& iter, ClassLoaderData* loader_data, TRAPS);\n+  \/\/ Append all of the BSMAEs in other into this.\n+  void append(const BSMAttributeEntries& other, ClassLoaderData* loader_data, TRAPS);\n+};\n+\n+#endif \/\/ SHARE_OOPS_BSMATTRIBUTE_HPP\n","filename":"src\/hotspot\/share\/oops\/bsmAttribute.hpp","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_BSMATTRIBUTE_INLINE_HPP\n+#define SHARE_OOPS_BSMATTRIBUTE_INLINE_HPP\n+\n+#include \"oops\/bsmAttribute.hpp\"\n+\n+inline BSMAttributeEntry* BSMAttributeEntries::InsertionIterator::reserve_new_entry(u2 bsmi, u2 argc) {\n+  if (_cur_offset + 1 > insert_into->offsets()->length() ||\n+      _cur_array + BSMAttributeEntry::u2s_required(argc) > insert_into->bootstrap_methods()->length()) {\n+    return nullptr;\n+  }\n+  insert_into->_offsets->at_put(_cur_offset, _cur_array);\n+  BSMAttributeEntry* e = insert_into->entry(_cur_offset);\n+  e->_bootstrap_method_index = bsmi;\n+  e->_argument_count = argc;\n+\n+  _cur_array += 1 + 1 + argc;\n+  _cur_offset += 1;\n+  return e;\n+}\n+\n+inline void BSMAttributeEntry::copy_args_into(BSMAttributeEntry* entry) const {\n+  assert(entry->argument_count() == this->argument_count(), \"must be same\");\n+  for (int i = 0; i < argument_count(); i++) {\n+    entry->set_argument(i, this->argument(i));\n+  }\n+}\n+\n+#endif \/\/ SHARE_OOPS_BSMATTRIBUTE_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/bsmAttribute.inline.hpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/bsmAttribute.inline.hpp\"\n@@ -80,136 +81,0 @@\n-class BSMAttributeEntry {\n-  friend class ConstantPool;\n-  friend class BSMAttributeEntries;\n-\n-  u2 _bootstrap_method_index;\n-  u2 _argument_count;\n-\n-  \/\/ The argument indexes are stored right after the object, in a contiguous array.\n-  \/\/ [ bsmi_0 argc_0 arg_00 arg_01 ... arg_0N bsmi_1 argc_1 arg_10 ... arg_1N ... ]\n-  \/\/ So in order to find the argument array, jump over ourselves.\n-  const u2* argument_indexes() const {\n-    return reinterpret_cast<const u2*>(this + 1);\n-  }\n-  u2* argument_indexes() {\n-    return reinterpret_cast<u2*>(this + 1);\n-  }\n-  \/\/ These are overlays on top of the BSMAttributeEntries data array, do not construct.\n-  BSMAttributeEntry() = delete;\n-  NONCOPYABLE(BSMAttributeEntry);\n-\n-  void copy_args_into(BSMAttributeEntry* entry) const;\n-\n-public:\n-  \/\/ Offsets for SA\n-  enum {\n-    _bsmi_offset = 0,\n-    _argc_offset = 1,\n-    _argv_offset = 2\n-  };\n-\n-  int bootstrap_method_index() const {\n-    return _bootstrap_method_index;\n-  }\n-  int argument_count() const {\n-    return _argument_count;\n-  }\n-  int argument(int n) const {\n-    assert(checked_cast<u2>(n) < _argument_count, \"oob\");\n-    return argument_indexes()[n];\n-  }\n-\n-  void set_argument(int index, u2 value) {\n-    assert(index >= 0 && index < argument_count(), \"invariant\");\n-    argument_indexes()[index] = value;\n-  }\n-\n-  \/\/ How many u2s are required to store a BSM entry with argc arguments?\n-  static int u2s_required (u2 argc) {\n-    return 1 \/* index *\/ + 1  \/* argc *\/ + argc \/* argv *\/;\n-  }\n-};\n-\n-\/\/ The BSMAttributeEntries stores the state of the BootstrapMethods attribute.\n-class BSMAttributeEntries {\n-  friend class VMStructs;\n-  friend class JVMCIVMStructs;\n-\n-public:\n-  class InsertionIterator {\n-    friend BSMAttributeEntries;\n-    BSMAttributeEntries* insert_into;\n-    \/\/ Current unused offset into BSMAEs offset array\n-    int _cur_offset;\n-    \/\/ Current unused offset into BSMAEs bsm-data array\n-    int _cur_array;\n-  public:\n-    InsertionIterator() : insert_into(nullptr), _cur_offset(-1), _cur_array(-1) {}\n-    InsertionIterator(BSMAttributeEntries* insert_into, int cur_offset, int cur_array)\n-    : insert_into(insert_into),\n-      _cur_offset(cur_offset),\n-      _cur_array(cur_array) {}\n-    InsertionIterator(const InsertionIterator&) = default;\n-    InsertionIterator& operator=(const InsertionIterator&) = default;\n-\n-    int current_offset() const { return _cur_offset; }\n-    \/\/ Add a new BSMAE, reserving the necessary memory for filling the argument vector.\n-    \/\/ Returns null if there isn't enough space.\n-    inline BSMAttributeEntry* reserve_new_entry(u2 bsmi, u2 argc);\n-  };\n-\n-private:\n-  \/\/ Each bootstrap method has a variable-sized array associated with it.\n-  \/\/ We want constant-time lookup of the Nth BSM. Therefore, we use an offset table,\n-  \/\/ such that the Nth BSM is located at _bootstrap_methods[_offsets[N]].\n-  Array<u4>* _offsets;\n-  Array<u2>* _bootstrap_methods;\n-\n-  \/\/ Copy the first num_entries into iter\n-  void copy_into(InsertionIterator& iter, int num_entries) const;\n-\n-public:\n-  BSMAttributeEntries() : _offsets(nullptr), _bootstrap_methods(nullptr) {}\n-  BSMAttributeEntries(Array<u4>* offsets, Array<u2>* bootstrap_methods)\n-    : _offsets(offsets),\n-      _bootstrap_methods(bootstrap_methods) {}\n-\n-  bool is_empty() const {\n-    return _offsets == nullptr && _bootstrap_methods == nullptr;\n-  }\n-\n-  Array<u4>*& offsets() { return _offsets; }\n-  const Array<u4>* const& offsets() const { return _offsets; }\n-  Array<u2>*& bootstrap_methods() { return _bootstrap_methods; }\n-  const Array<u2>* const& bootstrap_methods() const { return _bootstrap_methods; }\n-\n-  BSMAttributeEntry* entry(int bsms_attribute_index) {\n-    return reinterpret_cast<BSMAttributeEntry*>(_bootstrap_methods->adr_at(_offsets->at(bsms_attribute_index)));\n-  }\n-  const BSMAttributeEntry* entry(int bsms_attribute_index) const {\n-    return reinterpret_cast<BSMAttributeEntry*>(_bootstrap_methods->adr_at(_offsets->at(bsms_attribute_index)));\n-  }\n-\n-  int number_of_entries() const {\n-    return _offsets == nullptr ? 0 : _offsets->length();\n-  }\n-\n-  \/\/ The number of U2s the BSM data consists of.\n-  int array_length() const {\n-    return _bootstrap_methods == nullptr ? 0 :  _bootstrap_methods->length();\n-  }\n-\n-  void deallocate_contents(ClassLoaderData* loader_data);\n-\n-  \/\/ Extend to have the space for both this BSMAEntries and other's.\n-  \/\/ Does not copy in the other's BSMAEntrys, that must be done via the InsertionIterator.\n-  \/\/ This starts an insertion iterator. Any call to start_extension must have a matching end_extension call.\n-  InsertionIterator start_extension(const BSMAttributeEntries& other, ClassLoaderData* loader_data, TRAPS);\n-  \/\/ Extend the BSMAEntries with an additional number_of_entries with a total data_size.\n-  InsertionIterator start_extension(int number_of_entries, int data_size, ClassLoaderData* loader_data, TRAPS);\n-  \/\/ Reallocates the underlying memory to fit the limits of the InsertionIterator precisely.\n-  \/\/ This ends an insertion iteration. The memory is truncated to fit exactly the data used.\n-  void end_extension(InsertionIterator& iter, ClassLoaderData* loader_data, TRAPS);\n-  \/\/ Append all of the BSMAEs in other into this.\n-  void append(const BSMAttributeEntries& other, ClassLoaderData* loader_data, TRAPS);\n-};\n-\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":136,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -91,23 +91,0 @@\n-inline BSMAttributeEntry* BSMAttributeEntries::InsertionIterator::reserve_new_entry(u2 bsmi, u2 argc) {\n-  if (_cur_offset + 1 > insert_into->offsets()->length() ||\n-      _cur_array + BSMAttributeEntry::u2s_required(argc) > insert_into->bootstrap_methods()->length()) {\n-    return nullptr;\n-  }\n-  insert_into->_offsets->at_put(_cur_offset, _cur_array);\n-  BSMAttributeEntry* e = insert_into->entry(_cur_offset);\n-  e->_bootstrap_method_index = bsmi;\n-  e->_argument_count = argc;\n-\n-  _cur_array += 1 + 1 + argc;\n-  _cur_offset += 1;\n-  return e;\n-}\n-\n-inline void BSMAttributeEntry::copy_args_into(BSMAttributeEntry* entry) const {\n-  assert(entry->argument_count() == this->argument_count(), \"must be same\");\n-  for (int i = 0; i < argument_count(); i++) {\n-    entry->set_argument(i, this->argument(i));\n-  }\n-}\n-\n-\n","filename":"src\/hotspot\/share\/oops\/constantPool.inline.hpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"oops\/bsmAttribute.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"oops\/bsmAttribute.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"oops\/bsmAttribute.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}